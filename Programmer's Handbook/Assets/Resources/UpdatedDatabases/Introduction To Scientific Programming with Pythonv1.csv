Larger Text,Smaller Text,Symbol
SIMULA SPRINGER BRIEFS ON ,NA,NA
COMPUTING   6,NA,NA
Joakim Sundnes,NA,NA
Introducti,NA,NA
on ,NA,NA
to ,NA,NA
Scientific ,NA,NA
Program,NA,NA
ming with ,NA,NA
Python ,NA,NA
Simula SpringerBriefs on Computing,NA,NA
Volume 6,"Editor-in-Chief 
  
 Aslak Tveito, Fornebu, Norway
  
 Series Editors 
  
 Are Magnus Bruaset, Fornebu, Norway 
 Kimberly Claffy, San Diego, USA 
  
 Magne Jørgensen, Fornebu, Norway 
 Olav Lysne, Fornebu, Norway 
  
 Andrew McCulloch, La Jolla, USA 
  
 Fabian Theis, Neuherberg, Germany 
 Karen Willcox, Cambridge, USA 
  
 Andreas Zeller, Saarbrücken, Germany",NA
Joakim  Sundnes,NA,NA
Introduction ,NA,NA
to Scientific ,NA,NA
Programming ,NA,NA
with Python,NA,NA
Foreword,"Dear reader, 
  
 Our aim with the series Simula SpringerBriefs on Computing is to provide 
 compact introductions to selected fields of computing. Entering a new field of 
 research can be quite demanding for graduate students, postdocs, and 
 experienced researchers alike: the process often involves reading hundreds of 
 papers, and the methods, results and notation styles used often vary 
 considerably, which makes for a time-consuming and potentially frustrating 
 experience. The briefs in this series are meant to ease the process by 
 introducing and explaining important concepts and theories in a relatively 
 narrow field, and by posing critical questions on the fun-damentals of that 
 field. A typical brief in this series should be around 100 pages and should be 
 well suited as material for a research seminar in a well-defined and limited 
 area of computing.
  
 We have decided to publish all items in this series under the SpringerOpen 
 framework, as this will allow authors to use the series to publish an initial 
 version of their manuscript that could subsequently evolve into a full-scale 
 book on a broader theme. Since the briefs are freely available online, the 
 authors will not receive any direct income from the sales; however, 
 remuneration is provided for every completed manuscript. Briefs are written 
 on the basis of an invitation from a member of the editorial board. 
 Suggestions for possible topics are most welcome and can be sent to 
 aslak@simula.no.
  
 January 2016
  
 Prof. Aslak Tveito 
  
 CEO
  
 Dr. Martin Peters 
  
 Executive Editor Mathematics 
 Springer Heidelberg, 
 Germany",NA
Preface,"This book was originally written as a set of lecture notes to the book
  A Primer 
 on Scientific Programming with Python
  by Hans Petter Langtangen
 1
 , and can 
 be used either as a supplement to that book or on its own, as a com-pact 
 introduction to scientific programming. Langtangen’s book and these lecture 
 notes, have formed the core of an introductory course on scientific 
 programming at the University of Oslo (INF1100/IN1900, 10 ETCS credits). 
 The course has been running since 2007 and is primarily taken by first-year 
 students of mathematics, engineering, physics, chemistry, and geosciences.
  
 The writing of these lecture notes, and their subsequent evolution into a 
 book, were primarily motivated by two factors. The first was that many stu-
 dents found the nearly 1000 pages of Langtangen’s book a bit overwhelming 
 as a first introduction to programming. This effect could be mostly psy-
 chological, since the book is well structured and suited for selective study of 
 chapters and sections, but the student feedback from students still indi-cated 
 the need for a more compact and (literally) lightweight introduction. The 
 second factor was that, sadly, Hans Petter Langtangen passed away in 2016, 
 and his book has therefore not been updated to the newest versions of 
 Python and the various tools introduced in the book. This issue could also be 
 mostly a mental obstacle, since the differences between the Python versions 
 are quite small, and only minor edits are needed to make most of the 
 examples from the original book run on the newest Python platform. 
 However, the book is intended as an introduction to programming, and when 
 learning an entirely new topic, any minor inconsistency is a potential source 
 of confusion. I therefore saw the need for an updated document where all the 
 code examples would run without any modifications on the most common 
 Python platforms. That said, in spite of these minor shortcomings as an in-
 troductory text, Langtangen’s book is still an excellent resource on scientific 
 programming in Python. Compared with the present book, it covers a much
  
  
 1
 Hans Petter Langtangen,
  A Primer on Scientific Programming with Python
 , 5th edition, 
 Springer-Verlag, 2016.
  
 ix",NA
Contents,"Preface
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 ix
  
 1
  
 Getting Started with Python
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.1 
  
 The 
 First Example: Hello, World!. . . . . . . . . . . . . . . . . . . . . . . . . 1.2 
  
 Different 
 Ways to Use Python . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
  
 1
  
  
 2
  
 2
  
 Computing with Formulas
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.1 
  
 Programming Simple Mathematics. . . . . . . . . . . . . . . . . . . . . . . .
  
 2.2 
  
 Variables and Variable Types . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3 
  
 Formatting Text Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.4 
  
 Importing Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.5 
  
 Pitfalls When Programming Mathematics . . . . . . . . . . . . . . . . .
  
 5 
  
 5 
  
 7 
  
 11 
 13 
 15
  
 3
  
 Loops and Lists
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.1 
  
 Loops for Automating Repetitive Tasks . . . . . . . . . . . . . . . . . . .
  
 3.2 
  
 Boolean Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.3 
  
 Using Lists to Store Sequences of Data . . . . . . . . . . . . . . . . . . . .
  
 3.4 
  
 Iterating Over a List with a for Loop . . . . . . . . . . . . . . . . . . . . .
  
 3.5 
  
 Nested Lists and List Slicing . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.6 
  
 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
 9 
 1
 9 
 2
 1 
 2
 3 
 2
 5 
 3
 1 
 3
 3
  
 4
  
 Functions and Branching
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.1 
  
 Programming with Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.2 
  
 Function Arguments and Local Variables . . . . . . . . . . . . . . . . . .
  
 4.3 
  
 Default Arguments and Doc Strings . . . . . . . . . . . . . . . . . . . . . .
  
 4.4 
  
 If-Tests for Branching the Program Flow . . . . . . . . . . . . . . . . . .
  
 4.5 
  
 Functions as Arguments to Functions . . . . . . . . . . . . . . . . . . . . .
  
 4.6 
  
 Solving Equations with Python Functions . . . . . . . . . . . . . . . . .
  
 4.7 
  
 Writing Test Functions to Verify our Programs . . . . . . . . . . . . .
  
 3
 5 
 3
 5 
 3
 8 
 4
 4 
 4
 6 
 4
 8 
 5
 0 
 5
 3
  
 xiii",NA
Chapter 1 ,NA,NA
Getting Started with Python,"This book teaches the Python programming language, which is one of the 
 most popular languages for introductory programming courses. An 
 advantage of Python is that it is a so-called high-level language, with simple 
 and intuitive syntax that makes it easy to get started. However, although it 
 works well as a beginner’s language, Python is also suitable for more 
 advanced tasks, and it is currently one of the most widely used programming 
 languages worldwide.",NA
"1.1 The First Example: Hello, World!","Most introductory books on programming start with a so-called Hello, World! 
 program, which is a program that simply writes
  Hello, World!
  to the screen.
  
 In Python, this program is just a single line;
  
 print
 (""Hello, World!"")
  
 To actually write and run such a program, Python offers a number of different 
 options. Throughout this book we will mostly apply the classical program-
 ming approach, where a program is written in a text editor and stored as a 
 file that is then run from the command line window or an integrated devel-
 opment environment (IDE). To write and run the ""Hello, World!""-program 
 above, open your favorite editor (Atom, gedit, Emacs etc.), type the given line 
 and save the file with a suitable filename, for instance, hello.py.
 1
 Then, open a 
 terminal or an iPython window, navigate to the directory where you saved 
 the file, and type python hello.py, if you are using a regular terminal, or run 
 hello.py if you are using iPython. The output
  Hello, World!
  should
  
 1
 We do not describe the technical details of acquiring and installing Python here, since 
 this information is platform dependent and becomes outdated very quickly. For up-dated 
 hints on installing Python, see the web page for the IN1900 course at the University of Oslo 
 (https://www.uio.no/studier/emner/matnat/ifi/IN1900/index-eng.html), 
 or 
 to 
 the 
 numerous other resources found online.
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 1
  
 https://doi.org/10.1007/978-3-030-50356-7_1",NA
1.2 Different Ways to Use Python,"As briefly mentioned above, Python offers some alternatives to the traditional 
 style of programming using a text editor and a terminal window, and some of 
 these alternatives can be very useful when learning to program. For instance, 
 we can use Python interactively by simply typing python or ipython in a 
 terminal window, without a subsequent file name. This will open an environ-
 ment for typing and running Python commands, which is not very suitable for 
 writing programs over several lines, but extremely useful for testing Python 
 commands and statements, or simply using Python as a calculator. In a reg-
 ular terminal window on macOS or Linux, an interactive version of the Hello, 
 World! example would look something like
  
 Terminal
  
 Terminal> ipython 
  
 Python 3.7.3 (default, Mar 27 2019, 16:54:48) 
  
 Type ’copyright’, ’credits’ or ’license’ for more information IPython 7.4.0 -- 
 An enhanced Interactive Python.
  
 In [1]: print(""Hello, World!"") 
  
 Hello, World!
  
 In [2]:
  
 The two versions python and ipython work largely the same way, but ipython 
 has a number of additional features and is recommended.
  
 2
 For details, see, for instance, https://www.spyder-ide.org/.",NA
Chapter 2 ,NA,NA
Computing with Formulas,"In this chapter, we will go one step beyond the Hello, World! example of the 
 first chapter, and introduce programming with mathematical formulas. Such 
 formulas are essential parts of most programs written for scientific applica-
 tions, and they are also useful for introducing the concept of
  variables
 , which 
 is a fundamental part of all programming languages.",NA
2.1 Programming Simple Mathematics,"To introduce the concepts of this chapter, we first consider a simple formula 
 for calculating the interest on a bank deposit:
  
 A
  =
  P
 (1+(
 r/
 100))
 n
 ,
  
 where
  P
  is the initial deposit (the
  principal
 ),
  r
  is the yearly interest rate given 
 in percent,
  n
  is the number of years, and
  A
  is the final amount.
  
 The task is now to write a program that computes
  A
  for given values of 
 P
 ,
  r
  
 and
  n
 . We could, of course, easily do so with a calculator, but a small program 
 can be much more flexible and powerful. To evaluate the formula above, we 
 first need to assign values to
  P
 ,
  r
  and
  n
 , and then make the calculation. 
 Choosing, for instance,
  P
  = 100
 ,r
  = 5
 .
 0, and
  n
  = 7, a complete Python program 
 that does the calculation and outputs the result reads
  
 print
 (100*(1 + 5.0/100)**7)
  
 140.71004226562505
  
 As described in the previous chapter this line can be typed into an inter-
 active Python session, or written in an editor and stored in a file, for in-stance 
 interest0.py. The program is then run with the command python
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 5
  
 https://doi.org/10.1007/978-3-030-50356-7_2",NA
2.2 Variables and Variable Types,"We are used to variables in mathematics, such as
  P
 ,
  r
  and
  n
  in the interest 
 formula above. We can use variables in a program too, and this makes the 
 program easier to read and understand:
  
 primary = 100 
  
 r = 5.0 
  
 n = 7 
  
 amount = primary * (1+r/100)**n 
  
 print
 (amount)
  
 This program spans several lines of text and uses variables, but otherwise 
 performs the same calculations and produces the exact same output as the 
 one-line program above. Still, the use of variables has a few advantages, even 
 in this very simple example. One is that the program becomes easier to read, 
 since the meaning of the numbers becomes more intuitive and the formula is 
 easier to recognize. Another advantage, which could be more important, is 
 that it becomes easier to change the value of one of the variables. This 
 advantage becomes even more obvious in more complex formulas where the 
 same variable occurs multiple times. Having to change the code in multiple 
 places each time a new value is needed is guaranteed to introduce errors. If 
 the same number occurs more than once in a program, it should always be 
 stored in a variable.
  
 The instructions in the program above are called
  statements
 , and are exe-
 cuted one by one when the program is run. It is common to have one state-
 ment per line, although it is possible to put multiple statements on one line, 
 separated by semicolons, as in primary = 100; r = 5.0; n=7. For people new to 
 programming, especially those used to reading mathematics, it is worth 
 noting the strict sequence in which the lines are executed. In the 
 mathematical equation above, we first introduced the formula itself, and then 
 defined and explained the variables used in the formula (
 P,r,n
 , and
  A
 ) on the 
 next line. This approach is completely standard in mathematics, but it makes 
 no sense in programming. Programs are executed line by line from the top, so 
 so all the variables must be defined
  above
  the line where they are used.
  
 The choice of variable names is up to the programmer and, generally, there 
 is great flexibility in choosing such names. In mathematics, it is common to 
 use a single letter for a variable, but a variable in a Python program can be 
 any word containing the letters a–z, A–Z, underscore _ and the digits 0-9, but 
 it cannot start with a digit. Variable names in Python are also case-sensitive,",NA
2.3 Formatting Text Output,"The calculations in the programs above would output a single number, and 
 simply print this number to the screen. In many cases this solution is fine, but 
 sometimes we want several numbers or other types of output from a 
 program. This is easy to do with the print function, by simply putting several 
 variables inside the parentheses, separated by comma. For instance, if we 
 want to output both primary and final_amount from the calculation above, 
 the following line would work:
  
 print
 (primary,final_amount)
  
 100 140.71004226562505
  
 However, although this line works, the output is not very readable or useful. 
 Sometimes a better output format or a combination of text and numbers is 
 more useful, for instance,
  
 After 7 years, 100 EUR has grown to xxx EUR.
  
 There are multiple ways to obtain this result in Python, but the most re-cent 
 and arguably most convenient is to use so called
  f-strings
 , which were 
 introduced in Python 3.6. If you are using an earlier version of Python, the 
 following examples will not work, but there are alternative and fairly similar 
 ways of formatting the text output.
  
  
 To achieve the output string above, using the
  f-string
  formatting, we would 
 replace the final line of our program by with
  
 print
 (f""After {n} years, 100 EUR has grown to {amount} EUR."")
  
 After 7 years, 100 EUR has grown to 140.71004226562505 EUR.
  
 There are a couple of things worth noticing here. First, we enclose the output 
 in quotation marks, just as in the Hello, World! example above, which tells 
 Python that this is a string. Second, the string is prefixed with the letter f, 
 which indicates that the string is an f-string that could contain something",NA
2.4 Importing Modules,"We have seen that standard arithmetic operations are directly available in 
 Python, with no extra effort. However, what if more advanced mathematical 
 operations, such as sin
 x
 , cos
 x
 , ln
 x
 , are required? These functions are not 
 available directly, but can be found in a so-called
  module
 , which must be 
 imported before they can be used in our program. Generally, a great deal of 
 functionality in Python is found in such modules, and we will import one or 
 more modules in nearly all the programs we write. Standard mathematical 
 functions are found in a module named math, and the following code 
 computes the square root of a number using the sqrt function in the math 
 module:
  
 import
  math 
  
 r = math.sqrt(2) 
  
 # or 
  
 from
  math
  import
  sqrt 
  
 r = sqrt(2) 
  
 # or 
  
 from
  math
  import
  * 
  
 # import everything in math 
 r = 
 sqrt(2)
  
 This example illustrate three different ways of importing modules. In the first 
 one, we import everything from the math module, but everything we want to 
 use must be prefixed with math. The second option imports only the sqrt 
 function, and this function is imported into the main
  namespace
  of the 
 program, which means it can be used without a prefix. Finally, the third 
 option imports everything from math into the main namespace, so that all the 
 functions from the module are available in our program without a prefix.",NA
2.5 Pitfalls When Programming Mathematics,"Usually, the mathematical operations described above work as expected. 
 When the results are not as expected, the cause is usually a trivial error 
 introduced during typing, typically assigning the wrong value to a variable or 
 mismatching the number of parentheses. However, some potential error 
 sources are less obvious and are worth knowing about, even if they are rela-
 tively rare.
  
 Round-off errors give inexact results.
  Computers have inexact arith-metic 
 because of rounding errors. This is usually not a problem in computa-tions, 
 but in some cases it can cause unexpected results. Let us, for instance, 
 compute 1
 /
 49
 ·
 49 and 1
 /
 51
 ·
 51:
  
 v1 
 = 
 1/49.0*49 
  
 v2 
 = 
 1/51.0*51 
  
 print
 (f""{v1:.16f} {v2:.16f}"")
  
 The output with 16 decimal places becomes
  
 0.9999999999999999 1.0000000000000000
  
 Most real numbers are represented inexactly on a computer, typically with an 
 accuracy of 17 digits. Neither 1/49 nor 1/51 are represented exactly, and the 
 error is approximately 10
 −
 16
 . Errors of this order usually do not matter, but 
 there are two particular cases in which they can be significant. In one case, 
 errors can accumulate through numerous computations, ending up as a 
 significant error in the final result. In the other case, which is more likely to 
 be encountered in the examples of this book, the comparison of two decimal 
 numbers can be unpredictable. The two numbers v1 and v2 above are both 
 supposed to be equal to one, but look at the result of this code:
  
 print
 (v1 == 1) 
  
  
 print
 (v2 == 1)",NA
Chapter 3 ,NA,NA
Loops and Lists,"In this chapter, programming starts to become useful. The concepts intro-
 duced in the previous chapter are essential building blocks in all computer 
 programs, but our example programs only performed a few calculations, 
 which we could easily do with a regular calculator. In this chapter, we will 
 introduce the concept of
  loops
 , which can be used to automate repetitive and 
 tedious operations. Loops are used in most computer programs, and they 
 look very similar across a wide range of programming languages. We will 
 primarily use loops for calculations, but as you gain more experience, you will 
 be able to automate other repetitive tasks. Two types of loops will be 
 introduced in this chapter: the while loop and the for loop. Both will be used 
 extensively in all subsequent chapters. In addition to the loop concept, we 
 will introduce Boolean expressions, which are expressions with a true/false 
 value, and a new variable type called a list, which is used to store sequences 
 of data.",NA
3.1 Loops for Automating Repetitive Tasks,"To start with a motivating example, consider again the simple interest cal-
 culation formula; 
  
  
 A
  =
  P ·
 (1+(
 r/
 100))
 n
 .
  
 In Chapter 2 we implemented this formula as a single-line Python program, 
 but what if we want to generate a table showing how the invested amount 
 grows with the years? For instance, we could write
  n
  and
  A
  in two columns 
 like this
  
 0 
  
 1 
  
 2 
  
 3 
  
 ...
  
 10
 0 
  
 10
 5 
  
 11
 0 
  
 ... 
  
 ...
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 19
  
 https://doi.org/10.1007/978-3-030-50356-7_3",NA
3.2 Boolean Expressions,"An expression with a value of true or false is called a Boolean expression. 
 Boolean expressions are essential in while loops and other important",NA
3.3 Using Lists to Store Sequences of Data,"So far, we have used one variable to refer to one number (or string). Some-
 times we naturally have a collection of numbers, such as the
  n
 -values (years) 
 0
 ,
 1
 ,
 2
 ,...,
 10 created in the example above. In some cases, such as the one above, 
 we are simply interested in writing all the values to the screen, in which case 
 using a single variable that is updated and printed for each pass of the loop 
 works fine. However, sometimes we want to store a sequence of such 
 variables, for instance, to process them further elsewhere in the program. We 
 could, of course, use a separate variable for each value of n, as follows:
  
 n0 = 0 
  
 n1 = 1 
  
 n2 = 2 
  
 ...
  
 n10 = 10
  
 However, this is another example of programming that becomes extremely 
 repetitive and boring, and there is obviously a better solution. In Python, the 
 most flexible way to store such a sequence of variables is to use a list:
  
 n = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
 Notice the square brackets and the commas separating the values, which is 
 how we tell Python that n is a list variable. Now we have a single variable that 
 can hold all the values we want. Python lists are not reserved just for 
 numbers and can hold any kind of object, and even different kinds of objects. 
 They also have a great deal of convenient built-in functionality, which makes 
 them very flexible and useful and extremely popular in Python programs. 
  
 We will not cover all the aspects of lists and list operations in this book, but 
 we will use some of the more basic ones. We have already seen how to 
 initialize a list using square brackets and comma-separated values, such as
  
 L1 = [-91, ’a string’, 7.2, 0]
  
 To retrieve individual elements from the list, we can use an index, for 
 instance L1[3] will pick out the element with index 3, that is, the fourth 
 element (having a value of zero) in the list, since the numbering starts at zero. 
 List indices start at zero and run to the
  n−
 1, where
  n
  is the number of 
 elements in the list:",NA
3.4 Iterating Over a List with a for Loop,"Having introduced lists, we are ready to look at the second type of loop we 
 will use in this book: the for loop. The for loop is less general than the while 
 loop, but it is also a bit simpler to use. The for loop simply iterates over 
 elements in a list, and performs operations on each one:
  
 for
  element
  in list
 : 
  
 <statement 1> 
  
 <statement 2> 
  
 ...
  
 <first statement after loop>
  
 The key line is the first one, which will simply run through the list, element by 
 element. For each pass of the loop, the single element is stored in the variable 
 element, and the block of code inside the for loop typically involves 
 calculations using this element variable. When the code lines in this block are 
 completed, the loop moves on to the next element in the list, and continues in 
 this manner until there are no more elements in the list. It is easy to see why 
 this loop is simpler than the while loop, since no condition is needed to stop 
 the loop and there is no need to update a variable inside the loop. The for 
 loop will simply iterate over all the elements in a predefined list, and stop 
 when there are no more elements. On the other hand, the for loop is slightly 
 less flexible, since the list needs to predefined. The for loop is the best choice 
 in most cases in which we know in advance how many times we want to 
 perform a set of operations. In cases in which this number is not known, the 
 while loop is usually the best choice.
  
 For a concrete for loop example, we return to the investment growth 
 exam-ple introduced above. To write a for loop for a given task, two key 
 questions must be answered: (i) What should the list contain, and (ii) what 
 operations should be performed on the elements in the list? In the present 
 case, the natural answers are (i) the list should be a range of
  n
 -values from 
 zero to 10, in steps of 1, and (ii) the operations to be repeated are the 
 computation of A and the printing of the two values, essentially the same as in 
 the while loop.
  
 The full program using a for loop thus becomes
  
 years = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] r = 5.0 
  
 P = 100.0 
  
 for
  n
  in
  years: 
  
 A = P * (1+r/100)**n 
  
 print
 (n, A)
  
 As with the while loop, the statements inside the loop must be indented. 
 Simply by counting the lines of code in the two programs shows that the for 
 loop is somewhat simpler and quicker to write than the while loop. Most 
 people will argue that the overall structure of the program is also simpler and 
 less error-prone, with no need to check a criterion to stop the loop or to",NA
3.5 Nested Lists and List Slicing,"As described above, lists in Python are quite general and can store
  any
  object, 
 including another list. The resulting list of lists is often referred to as a
  nested 
 list
 . Instead of storing the amounts resulting from the low and high interest 
 rates above as two separate lists, we could put them together in a new list:
  
 A_low = [P*(1+2.5/100)**n
  for
  n
  in range
 (11)] A_high = 
 [P*(1+5.0/100)**n
  for
  n
  in range
 (11)]
  
 amounts = [A_low, A_high]
  
 # list of two lists
  
 print
 (amounts[0]) 
  
 print
 (amounts[1]) 
  
 print
 (amounts[1][2])
  
 # the A_low list 
  
 # the A_high list 
  
 # the 3rd element in A_high
  
 The indexing of nested lists illustrated here is quite logical, but can take some 
 time getting used to. The important thing is that, if amounts is a list 
 containing lists, then, for instance, amounts[0] is also a list and can be 
 indexed in the way we are used to. Indexing into this list is done in the usual 
 way, such that, for instance, amounts[0][0] is the first element of the first list 
 contained in amounts. Playing a bit with indexing nested lists in the 
 interactive Python shell is a useful exercise to understand how they are used. 
 Iterating over nested lists also works as expected. Consider, for instance, the 
 following code
  
 for
  sublist1
  in
  somelist: 
  
 for
  sublist2
  in
  sublist1: 
  
  
  
 for
  value
  in
  sublist2: 
  
  
  
  
 # work with value
  
 Here, somelist is a three-dimensional nested list, that is, its elements are lists, 
 which, in turn, contain lists. The resulting nested for loop looks a bit 
 complicated, but it follows exactly the same logic as the simpler for loops 
 used above. When the outer loop starts, the first element from somelist is 
 copied into the variable sublist1, and then we then enter the code block 
 inside the loop, which is a new for loop that will start traversing sublist1, that 
 is, first copying the first element into the variable sublist2. Then the process 
 is repeated, with the innermost loop traversing all the elements of sublist2, 
 copying each element into the variable value, and doing some calculations 
 with this variable. When it reaches the end of sublist2, the innermost for loop 
 is over, we ""move outward"" one level in terms of the loops, to the loop for 
 sublist2 in sublist, which moves to the next element and starts a new run 
 through the innermost loop.
  
  
 Similar iterations over nested loops can be obtained by looping over the 
 list indices, as follows:
  
 for
  i1
  in range
 (
 len
 (somelist)): 
  
  
 for
  i2
  in range
 (
 len
 (somelist[i1])):",NA
3.6 Tuples,"Lists are a flexible and user-friendly way to store sequences of numbers, and 
 are used in nearly all Python programs. However, a few other data types are 
 also made to store sequences of data. One of the most important ones is 
 called a
  tuple
 , and it is essentially a constant list that cannot be changed. A 
 tuple is defined in almost the same way as a list, but with normal parentheses 
 instead of the square brackets. Alternatively, we can skip the parentheses and 
 just use a comma-separated sequence of values to define a tuple. The 
 following are two examples that are entirely equivalent and define the same 
 tuple:
  
 >>> t = (2, 4, 6, ’temp.pdf’) >>> t = 
  
 2, 4, 6, ’temp.pdf’
  
  
 # define a tuple 
  
 # can skip parentheses
  
  
 Tuples also provide much of the same functionality as lists, including indexing 
 and and slicing:
  
 >>> t = t + (-1.0, -2.0) 
  
 >>> t 
  
 (2, 4, 6, ’temp.pdf’, -1.0, -2.0) >>> t[1] 
  
 4 
  
 >>> t[2:] 
  
 (6, ’temp.pdf’, -1.0, -2.0) 
  
 >>> 6
  in
  t 
  
 True
  
 # add two tuples
  
 # indexing 
  
 # subtuple/slice 
  
 # membership
  
 However, tuples are
  immutable
 , which means that they cannot be changed. 
 Therefore, some operations we are used to from lists will not work. 
 Continuing the interactive session from above, the following are some 
 examples of illegal tuple operations:
  
 >>> t[1] = -1 
  
 ...
  
 TypeError: ’tuple’
  object
  does
  not
  support item assignment
  
  
 >>> t.append(0) 
  
 ...
  
 AttributeError: ’tuple’
  object
  has no attribute ’append’
  
  
    
 >>>
  del
  t[1]",NA
Chapter 4 ,NA,NA
Functions and Branching,"This chapter introduces two fundamental programming concepts:
  functions 
 and
  branching
 . We are used to
  functions
  from mathematics, where we typi-
 cally define a function
  f
 (
 x
 ) as some mathematical expression of
  x
 , and then we 
 can then evaluate the function for different values of
  x
 , plot the curve 
 y
  =
  f
 (
 x
 ), 
 solve equations of the kind
  f
 (
 x
 ) = 0, and so on. A similar function concept 
 exists in programming, where a function is a piece of code that takes one or 
 more variables as input, carries out some operations using these vari-ables, 
 and produces output in return. The function concept in programming is more 
 general than in mathematics, and is not restricted to numbers or 
 mathematical expressions, but the general idea is exactly the same.
  
 Branching
 , or if-tests, is another fundamental concept that exists in all 
 common programming languages. The idea is that decisions are made in the 
 code based on the value of some Boolean expression or variable. If the 
 expression evaluates to true, one set of operations is performed, and if the 
 expression is false, a different set of operations is. Such tests are essential for 
 controlling the flow of a computer program.",NA
4.1 Programming with Functions,"We have already used a number of Python functions in the previous chapters. 
 The mathematical functions from the math module are essentially the same 
 as we are used to from mathematics or from pushing buttons on a calculator:
  
 from
  math
  import
  * 
  
 y = sin(x)*log(x)
  
 Additionally, we used a few non-mathematical functions, such as len and 
 range
  
 n =
  len
 (somelist) 
  
 for
  i
  in range
 (5, n, 2):
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 35
  
 https://doi.org/10.1007/978-3-030-50356-7_4",NA
4.2 Function Arguments and Local Variables,"Just as in mathematics, we can define Python functions with more than one 
 argument. The formula above involves both
  P
  and
  r
  in addition to
  n
 , and 
 including them all as arguments could be useful. The function definition could 
 then look like
  
 def
  amount(P, r, n): 
  
 return
  P*(1+r/100.0)**n
  
  
 # sample calls: 
  
 a1 = amount(100, 5.0, 10) 
  
 a2 = amount(10, r= 3.0, n=6) a3 = 
 amount(r= 4, n = 2, P=100)
  
 Note that we are using the arguments P, r, and n inside the function exactly as 
 in the previous example, where we defined P and r inside the function. Inside 
 a function, there is no distinction between such
  local variables
  and the 
 arguments passed to the function. The arguments also become local variables, 
 and are used in exactly the same way as any variable we define inside the 
 function. However, there is an important distinction between
  local
  and
  global 
 variables. Variables defined in the main program become global variables, 
 whereas variables defined inside functions are local. The local variables are 
 only defined and available inside a function, whereas global variables can be 
 used everywhere in a program. If we tried to access P, r, or n (e.g., by 
 print(P)) from outside the function, we will simply obtain an error message 
 stating that the variable is not defined.
  
 Arguments can be
  positional arguments
  or
  keyword arguments
 .
  No-tice 
 also the alternative ways of calling a function. We can either specify the",NA
4.3 Default Arguments and Doc Strings,"When we used the range-function in the previous chapter, we saw that we 
 could vary the number of arguments in the function call from one to three, 
 and the non-specified arguments would be assigned default values. We can 
 achieve the same functionality in our own functions, by defining
  default 
 arguments 
 in the function definition:
  
 def
  somefunc(arg1, arg2, kwarg1=True, kwarg2=0): 
 print
 (arg1, arg2, kwarg1, kwarg2)
  
 A function defined in this way can be called with two, three, or four argu-
 ments. The first two have no default value and must therefore be included in 
 the call, while the last two are optional and will be set to the default value if 
 not specified in the call. In texts on Python programming,
  default arguments 
 are often referred to as keyword arguments, although these terms do not 
 mean exactly the same thing. They are, however, closely related, which is why 
 the terms are sometimes used interchangeably. Just as we cannot have 
 keyword arguments preceding positional arguments in a function call, we 
 cannot have default arguments preceding non-default arguments in the 
 function header. The following code demonstrates uses of the alternative 
 function calls for a useless but illustrative function. Testing a simple function 
 such as the follow-ing, which does nothing but print out the argument values, 
 is a good way to understand the implications of default arguments and the 
 resulting flexibility in argument lists:
  
 >>>
  def
  somefunc(arg1, arg2, kwarg1=True, kwarg2=0): >>> 
 print
 (arg1, arg2, kwarg1, kwarg2)
  
 >>> somefunc(’Hello’, [1,2])
  
 # drop kwarg1 and kwarg2",NA
4.4 If-Tests for Branching the Program Flow,"In computer programs we often want to perform different actions depending 
 on a condition. As usual, we can find a similar concept in mathematics that 
 should be familiar to most readers of this book. Consider a function defined in 
 a piecewise manner, for instance,
  
 f
 (
 x
 ) = 
  
 sin
 x,
  0
  ≤ x ≤ π
 0
 , 
  
 otherwise
  
 The Python implementation of such a function needs to test the value of the 
 input
  x
 , and return either zero or sin(
 x
 ) depending on the outcome. Such a 
 decision in the program code is called
  branching
  and is obtained using an if-
 test, or, more generally, an if-else block. The code looks like
  
 from
  math
  import
  sin, pi
  
 def
  f(x): 
  
 if
  0 <= x <= pi: 
  
  
 return
  sin(x) 
  
 else
 : 
  
  
 return
  0
  
  
 print
 (f(0.5)) 
  
 print
 (f(5*pi))
  
 The new item here is the if-else block. An if-test is simply constructed by the 
 keyword if followed by a Boolean variable or expression, and then a block of 
 code which is to be executed if the condition is true. When the if-test is 
 reached in the function above, the Boolean condition is tested, just as for the 
 while loops in the previous chapter. If the condition is true, the following 
 block of indented code is executed (in this case, just one line); if not, the 
 indented code block after else is executed. You might also notice",NA
4.5 Functions as Arguments to Functions,"Arguments to Python functions can be any Python object, including another 
 function. This functionality is quite useful for many scientific applications, 
 where we need to define mathematical functions that operate on or make use 
 of other mathematical functions. For instance, we can easily write Python
  
 functions for numerical approximations of integrals
  
  b 
  
 a
 f
 (
 x
 )
 dx
 , derivatives 
 f
 ′
 (
 x
 ), and roots
  f
 (
 x
 ) = 0. For such functions to be general and useful, they",NA
4.6 Solving Equations with Python Functions,"Solving equations of the form
  f
 (
 x
 ) = 0 is a frequently occuring task in all 
 branches of science and engineering. For special cases, such as a linear or 
 quadratic
  f
 , we have simple formulas that give us the solution directly. In the 
 general case, however, the equation cannot be solved analytically, and we 
 need to find an approximate solution using numerical methods. We shall see 
 that we can create powerful and flexible tools for equation solving based on 
 the building blocks introduced so far. Specifically, we will combine functions 
 and function arguments with the while loop introduced in Chapter 3.
  
 Finding roots on an interval with the bisection method.
  One of the 
 simplest algorithms for solving equations of the form
  f
 (
 x
 ) = 0 is called the 
 bisection method
 . This method is founded on the intermediate value theorem, 
 which states that, if a continuous function changes sign on an interval [
 a,b
 ] 
 then there must be a value
  x ∈
  [
 a,b
 ] such that
  f
 (
 x
 ) = 0. In the bisection method 
 we start by choosing an interval [
 a,b
 ] on which
  f
  changes sign (i.e., 
 f
 (
 a
 )
 f
 (
 b
 )
  <
  
 0), and then compute the midpoint
  m
  = (
 a
 +
 b
 )
 /
 2 and check the sign of
  f
 (
 m
 ). If
  f
  
 changes sign on [
 a,m
 ] then we repeat the process on the interval [
 a,m
 ]; 
 otherwise, we choose [
 m,b
 ] as our new interval and repeat the process there. 
 These steps are conveniently implemented as a while loop, and we can create 
 a generic tool by placing the while loop inside a function that takes a function 
 as argument:
  
 from
  math
  import
  exp
  
 def
  bisection(f,a,b,tol= 1e-3): 
  
 if
  f(a)*f(b) > 0: 
  
  
 print
 (f’No roots or more than one root in [{a},{b}]’) 
  
 return
  
  
 m = (a+b)/2
  
  
 while abs
 (f(m)) > tol: 
  
 if
  f(a)*f(m) < 0:",NA
4.7 Writing Test Functions to Verify our ,NA,NA
Programs,"In the first part of this chapter, we mentioned the idea of writing tests to 
 verify that functions work as intended. This approach to programming can be 
 very effective, and although we spend some time writing the tests, we often 
 save much more time by the fact that we discover errors early, and can build 
 our program from components that are known to work. The process is often 
 referred to as
  unit testing
 , since each test verifies that a small unit of the 
 program works as expected. Many programmers even take the approach one 
 step further and write the test before they write the actual function. This 
 approach is often referred to as test-driven development and is an 
 increasingly popular method for software development.
  
 The tests we write to test our functions are also functions, a special type of 
 function known as
  test functions
 . Writing good test functions, which test the 
 functionality of our code in a reliable manner, can be quite challenging; 
 however, the overall idea of test functions is very simple. For a given function, 
 which often takes one or more arguments, we choose arguments such that we 
 can calculate the result of the function by hand. Inside the test function, we 
 then simply call our function with the right arguments and compare the 
 result returned by the function with the expected (hand-calculated) result. 
 The following example illustrates how we can write a test function to test that 
 the (very) simple function double(x) works as it should:
  
 def
  double(x): 
 return
  2*x
  
 # some function
  
 def
  test_double(): 
  
 # associated test function
  
 x = 4 
  
 # some chosen x value
  
 expected = 8 
  
 # expected result from double(x)
  
 computed = double(x)
  
 success = computed == expected 
  
 # Boolean value: test passed?
  
 msg = f’computed {computed}, expected {expected}’
  
 assert success, msg
  
 In this code, the only Python keyword that we have not seen previously is 
 assert, which is used instead of return whenever we write a test function. 
 Test functions should not return anything, so a regular return statement 
 would not make sense. The only purpose of the test function is to compare 
 the value returned by a function with the value we expect it to return, and to 
 write an error message if the two are different. This task is precisely what 
 assert does. The keyword assert should always be followed by a condi-tion, 
 success in the code above, that is true if the test passes and false if it fails. The 
 code above follows the typical recipe; we compare the expected with the 
 returned result in computed == expected, which is a Boolean ex-pression 
 returning true or false. This value is then assigned to the variable success, 
 which is included in the assert statement. The last part of the",NA
Chapter 5 ,NA,NA
User Input and Error Handling,"So far, all the values we have assigned to variables have been written directly 
 into our programs. If we want a different value of a variable, we need to edit 
 the code and rerun the program. Of course, this is not how we are used to 
 interacting with computer programs. Usually, a program will receive some 
 input from users, most often through a graphical user interface (GUI). 
 However, although GUIs dominate in modern human–computer interaction, 
 other ways of interacting with computer programs can be just as efficient 
 and, in some cases, far more suitable for processing large amounts of data 
 and automating repetitive tasks. In this chapter we will show how we can 
 extend our programs with simple yet powerful systems for user input. In 
 particular, we will see how a program can receive command line arguments 
 when it is run, how to make a program stop and ask for user input, and how a 
 program can read data from files.
  
 A side effect of allowing users to interact with programs is that things will 
 often go wrong. Users will often provide the wrong input, and programs 
 should be able to handle such events without simply stopping and writing a 
 cryptic error message to the screen. We will introduce a concept known as
  
 exception handling
 , which is a widespread system for handling errors in 
 programs, used in Python and many other programming languages.
  
 Finally, in this chapter, we shall see how to create our own modules that 
 can be imported for use in other programs, just as we have done with the 
 math module in previous chapters.",NA
5.1 Reading User Input Data,"So far, we have implemented various mathematical formulas that involved 
 input variables and parameters, but all of these values have been hard-coded 
 into the programs. To introduce a new example, consider the following for-
 mula, which gives an estimate of the atmospheric pressure
  p
  as a function of
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 57
  
 https://doi.org/10.1007/978-3-030-50356-7_5",NA
5.2 Flexible User Input with eval and exec,"Generally, the safest way to handle input data in the form of text strings is to 
 convert it to the specific variable type needed in the program. We did this 
 above, using the type conversions int(...) and float(...), and we will see below 
 how such conversions can be made failproof and handle imporper user input. 
 However, Python also offers a couple of more flexible functions to handle 
 input data, namely, eval and exec, which are nice to know about. Extensive 
 use of these functions is not recommended, especially not in larger programs, 
 since the code can become messy and error-prone. However, they offer some 
 flexible and fun opportunities for handling input data. Starting with eval, this 
 function simply takes a string s as input and evaluates it as a regular Python 
 expression, just as if it were written directly into the program. Of course, s 
 must be a legal Python expression, otherwise the code stops with an error 
 message. The following interactive Python session illustrates how eval works:
  
 >>> r =
  eval
 (’[1, 6, 7.5] + [1, 2]’) 
  
 >>> r 
  
 [1, 6, 7.5, 1, 2] 
  
 >>>
  type
 (r) 
  
 <
 type
  ’list’>",NA
5.3 Reading Data from Files,"Scientific data are often available in files, and reading and processing data 
 from files have always been important tasks in programming. The data 
 science revolution that we have witnessed in recent years has only increased 
 their importance further, since all data analysis starts with being able to read 
 data from files and store them in suitable data structures. To start with a 
 simple example, consider a file named data.txt containing a single column of 
 numbers:
  
 21.8 
  
 18.1 
  
 19 
  
 23 
  
 26 
  
 17.8
  
 We assume that we know in advance that there is one number per line, but 
 we do not know the number of lines. How can we read these numbers into a 
 Python program?",NA
5.4 Writing Data to Files,"Writing data to files follows the same pattern as reading. We open a file for 
 writing and typically use a for loop to traverse the data, which we then write 
 to the file using write:
  
 outfile =
  open
 (filename, ’w’)
  
 # ’w’ for writing
  
  
 for
  data
  in
  somelist: 
  
 outfile.write(sometext + ’\n’)
  
  
 outfile.close()
  
 Notice the inclusion of \n in the call to write. Unlike print, a call to write will 
 not by default add a line break after each call by defauls, so if we do not add 
 this explicitly, the resulting file will consist of a single long line. It is often 
 more convenient to have a line-structured file, and for this we include the \n, 
 which adds a line break. The alternative way of opening files can also be used 
 for writing, and it ensures that the file is automatically closed:
  
  
 with
  open
 (filename, ’w’) as outfile: 
  
 # ’w’ for writing
  
 for
  data
  in
  somelist:
  
 outfile.write(sometext + ’\n’)
  
  
 One should use caution when writing to files from Python programs. If you 
 call open(filename,’w’) with a filename that does not exist, a new file will be 
 created; however, if a file with that name exists, it will simply be deleted and 
 replaced by an empty file. Therefore, even if we do not actually write",NA
5.5 Handling Errors in Programs,"As demonstrated above, allowing user input in our programs will often intro-
 duce errors, and, as our programs grow in complexity, there can be multiple",NA
5.6 Making Modules,"So far in this course we have frequently used modules such as math and sys, 
 by importing them into our code:
  
 from
  math
  import
  log 
  
 r = log(6) 
  
 # call log function in math module
  
 import
  sys 
  
 x =
  eval
 (sys.argv[1])
  
 # access list argv in sys module
  
 Modules are extremely useful in Python programs, since they contain a col-
 lection of useful data and functions (as well as classes later), that we can 
 reuse in our code. But what if you have written some general and useful 
 functions yourself that you would like to reuse in more than one program? In 
 such cases",NA
Chapter 6 ,NA,NA
Arrays and Plotting,"In this chapter, we will learn to visualize mathematical functions and the 
 results of mathematical calculations. You have probably used a variety of 
 different plotting tools in the past, and we will now do much of the same 
 thing in Python. The way standard plotting tools work in Python is that we 
 first compute a number of points lying on the curve we want to show and 
 then draw straight lines between them. If we have enough points, the result 
 looks like a smooth curve. For plotting mathematical functions, this approach 
 can seem a bit primitive, since there are other tools we can use to simply type 
 in a mathematical expression and have the curve plotted on the screen. 
 However, the approach we use here is also much more flexible, since we can 
 plot data when there is no underlying mathematical function, for instance, 
 experimental data read from a file or results from a numerical experiment. To 
 plot functions in Python, we need to learn about the package matplotlib, 
 which is an extensive toolbox for plotting and visualization. In addition, it is 
 useful to introduce the package named NumPy, which is useful for storing 
 storing
  arrays
  of data for efficient computations.",NA
6.1 NumPy and Array Computing,"The standard way to plot a curve
  y
  =
  f
 (
 x
 ) is to draw straight lines between 
 points along the curve, and for this purpose we need to store the coordinates 
 of the points. We could use lists for this, for instance, two lists x and y, and 
 most of the plotting tools we will use work fine with lists. However, a data 
 structure known as an
  array
  is much more efficient than a list, and it offers a 
 number of nice features and advantages. Computing with arrays is often 
 referred to as
  array computations
  or
  vectorized computations
 , and these 
 concepts are useful for much more than just plotting curves.
  
 Arrays are generalizations of vectors.
  In high school mathematics, vec-tors 
 were introduced as line segments with a direction, represented by coor-
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 81
  
 https://doi.org/10.1007/978-3-030-50356-7_6",NA
6.2 Plotting Curves with Matplotlib,"The motivation for introducing NumPy arrays was to plot mathematical 
 functions, and now that we have introduced all the necessary tools we are 
 finally ready to do so. Let us start with a simple example. Say we want to plot 
 the curve
  y
 (
 x
 ) =
  e
 −x
 sin(2
 πx
 ), for
  x
  ranging from zero to four. The code can look 
 like
  
 import
  matplotlib.pyplot as plt 
  
 import
  numpy as np
  
  
 n = 100 
  
 x = np.linspace(0, 4, n+1) 
  
   
 y = np.exp(-x)*np.sin(2*np.pi*x)",NA
6.3 Plotting Discontinuous and ,NA,NA
Piecewise-Defined Functions,"Discontinuous functions, and functions defined in a piecewise manner, are 
 common in science and engineering. We saw in Chapter 4 how these could be 
 implemented in Python using if-tests, but, as we briefly commented above, 
 this implementation gives rise to challenges when using arrays and NumPy.",NA
6.4 Making a Movie of a Plot,"It is often useful to make animations or movies of plots, for instance if the plot 
 represents some physical phenomenon that changes with time, or if we want 
 to visualize the effect of changing parameters. Matplotlib has multiple tools 
 for creating such plots, and we will explore some of them here. To start with a 
 specific case, consider again the well-known Gaussian bell function:
  
 f
 (
 x
 ;
 m,s
 ) =
  
 1
  
 √
 2
 π
  
 1 
  
 s
 exp
  
 −
 1
  
 x−m s
  
 2
  
 The parameter
  m
  is the location of the function’s peak, while
  s
  is a measure of 
 the width of the bell curve. Plots of this function for different values of 
 s
  are 
 shown in Figure 6.3. As an alternative illustration of how the parame-ters 
 change the function we can make a movie (animation) of how
  f
 (
 x
 ;
 m,s
 ) 
 changes shape as
  s
  goes from two to 0.2.
  
 Movies are made from a large set of individual plots.
  Movies of plots are 
 created through the classical approach of cartoon movies (or, really, all 
 movies): by creating a set of images and viewing them in rapid sequence. For 
 our specific example, the typical approach is to write a for loop to step 
 through the
  s
  values and either show the resulting plots directly or store them 
 in individual files for later processing. Regardless of the approach, it is 
 important to always fix the axes when making animations of plots; otherwise, 
 the
  y
  axis always adapts to the peak of the function and the visual impression 
 is completely wrong 
  
  
 We will look at three different ways to create a movie of the kind outlined 
 above:",NA
6.5 More Useful Array Operations,"At the start of this chapter we introduced the most essential operations 
 needed to use arrays in computations and for plotting, but NumPy arrays can 
 do much more. Here we introduce a few additional operations that are 
 convenient to know about when working with arrays. First, we often need to 
 make an array of the same size as another array. This can be done in several 
 ways, for instance, using the zeros function introduced above,
  
 import
  numpy as np 
  
 x = np.linspace(0,10,101)
  
  
 3
 Technically, what happens here is that we call the
  constructor
  of the class 
 FuncAnimation to create an object of this class. We will cover classes and construc-tors in 
 detail in Chapter 7, but, for now, it is sufficient to view this as a regular function call that 
 returns an object of type FuncAnimation.
  
  
 4
 This call relies on external software being installed and integrated with Matplotlib, so 
 it might not work on all platforms.",NA
Chapter 7 ,NA,NA
Dictionaries and Strings,"In this chapter we will mainly focus on two data types: dictionaries and 
 strings. Dictionaries can be considered a generalization of the list data type, 
 where the indices are not required to be integers. We have already used 
 strings multiple times in the previous chapters, but we will revisit them here 
 to introduce a number of new and useful functions. Both dictionaries and 
 strings are particularly useful for reading and processing text files, and many 
 of our examples will be related to such applications.",NA
7.1 Dictionaries,"In mathematics, a mapping is a relation between objects or structures that 
 often takes the form of a function. A mapping
  f
  is a rule that assigns a unique 
 value
  f
 (
 x
 ) to a given input
  x
 . Mappings are also widely used in com-puter 
 science and can be implemented in many different ways. For instance, a 
 Python list can be viewed as a mapping between integers (list indices) and 
 the objects contained in a list. More general mappings can be implemented 
 using functions and if-tests; for instance, the mapping
  
 ’Norway’ --> ’Oslo’
  
 ’Sweden’ --> ’Stockholm’
  
 ’France’ --> ’Paris’
  
 could be implemented in Python as a function:
  
 def
  f(x): 
  
 if
  x == ’Norway’: 
  
  
 return
  ’Oslo’
  
 elif
  x == ’Sweden’: 
  
  
 return
  ’Stockholm’
  
 elif
  x == ’France’: 
  
  
 return
  ’Paris’
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 101
  
 https://doi.org/10.1007/978-3-030-50356-7_7",NA
7.2 Example: A Dictionary for Polynomials,"The information in a polynomial such as
  
 p
 (
 x
 ) =
  −
 1+
 x
 2
 +3
 x
 7
  
 can be represented by a dictionary with the power as the key (int) and the 
 coefficient as the value (float or int):
  
 p = {0: -1, 2: 1, 7: 3}
  
 More generally, a polynomial written on the form
  
 p
 (
 x
 ) =
  
 N
  
 c
 i
 x
 i
 ,
  
 i∈I
  
 for some set of integers
  I
  can be represented by a dictionary with keys
  i 
 and 
 values
  c
 i
 . To evaluate a polynomial represented by such a dictionary, we need 
 to iterate over the keys of the dictionary, extract the corresponding values, 
 and sum up the terms. The following function takes two arguments –a 
 dictionary poly and a number or array x – and evaluates the polynomial in x:
  
 def
  eval_poly_dict(poly, x): 
  
 sum
  = 0.0 
  
 for
  power
  in
  poly: 
  
  
 sum
  += poly[power]*x**power",NA
7.3 Example: Reading File Data to a Dictionary,"Say we have a file deg2.txt, containing temperature data for a number of 
 cities:
  
 Oslo: 
  
 London: 
  
 Berlin: 
  
 Paris: 
  
 Rome: 
  
 Helsinki:
  
 21.8 
  
 18.1 
  
 19 
  
 23 
  
 26 
  
 17.8
  
 We now want to read this file and store the information in a dictionary, with 
 the city names as keys and the temperatures as values. The recipe is nearly 
 identical to the one we previously used to read file data into lists: first create 
 an empty dictionary and then fill it with values read from the file:
  
 with
  open
 (’deg2.txt’, ’r’) as infile: 
  
 temps = {} 
  
  
 # start with empty dict 
 for
  
 line
  in
  infile: 
  
  
 city, temp = line.split() 
  
  
 city = city[:-1] 
  
 # remove last char (:) 
  
 temps[city] 
  
 =
  float
 (temp)
  
 The only real difference between this code and previous examples based on 
 lists is the way new data are added to the dictionary. We used the append 
 method to populate an empty list, but dictionaries have no such method. 
 Instead, we add a new key–value pair with the line temps[city] = float(temp). 
 Apart from this technical difference, the recipe for populating a dictionary is 
 exactly the same as for lists.",NA
7.4 String Manipulation,"We have already worked with strings (having type str)in previous chapters, 
 for instance introducing the very useful split-method:
  
 >>> s = ’This is a string’
  
 >>> s.split() 
  
 [’This’, ’is’, ’a’, ’string’]
  
 String manipulation is essential for reading and interpreting the content of 
 files, and the way we process files often depends on the file structure. For",NA
Chapter 8 ,NA,NA
Classes,"In this chapter, we introduce classes, which is a fundamental concept in pro-
 gramming. Most modern programming languages support classes or similar 
 concepts, and we have already encountered classes earlier in this book. Re-
 call, for instance, from Chapter 2 how we can check the type of a variable with 
 the type function, and the output will be of the form <class ’int’>, <class 
 ’float’>, and so on. This simply states that the type of an object is defined in 
 the form of a class. Every time we create, for instance, an integer variable in 
 our program, we create an object or
  instance
  of the int class. The class defines 
 how the objects behave and what methods they contain. We have used a large 
 number of different methods bound to objects, such as the append method 
 for list objects and split for strings. All such methods are part of the definition 
 of the class to which the object belongs. So far, we have only used Python’s 
 built-in classes to create objects, but in this chapter we will write our own 
 classes and use them to create objects tailored to our particular needs.",NA
8.1 Basics of Classes,"A class packs together data and functions in a single unit. As seen in previous 
 chapters, functions that are bound to a class or an object are usually called 
 methods, and we will stick to this notation in the present chapter. Classes 
 have some similarity with modules, which are also collections of variables 
 and functions that naturally belong together. However, while there can be 
 only a single instance of a module, we can create multiple instances of a class. 
 Different instances of the same class can contain different data, but they all 
 behave in the same way and have the same methods. Think of a basic Python 
 class such as int; we can create many integer variables in a program, and they 
 obviously have different values (data), but we know that they all have the 
 same general behavior and the same set of operations defined for them.
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 115
  
 https://doi.org/10.1007/978-3-030-50356-7_8",NA
8.2 Protected Class Attributes,"For a more classical computer science example of a Python class, let us look at 
 a class representing a bank account. Natural attributes for such a class will be 
 the name of the owner, the account number, and the balance, and we can 
 include methods for deposits, withdrawals, and printing information about 
 the account. The code for defining such a class could look like this:
  
 class
  BankAccount: 
  
 def
  __init__(self, first_name, last_name, number, balance): 
  
 self.first_name = 
 first_name 
  
  
 self.last_name = last_name 
  
  
 self.number = number 
  
  
 self.balance = balance
  
  
 def
  deposit(self, amount): 
 self.balance += amount
  
  
 def
  withdraw(self, amount): 
 self.balance -= amount
  
  
 def
  print_info(self): 
  
 first = self.first_name; last = self.last_name number = 
 self.number; bal = self.balance 
  
 s = f’{first} {last}, {number}, balance: {balance}’
 print
 (s)
  
 Typical use of the class could be something like the following, where we 
 create two different account instances and call the various methods for de-
 posits, withdrawals, and printing information:
  
 >>> a1 = Account(’John’, ’Olsson’, ’19371554951’, 20000) >>> a2 = 
 Account(’Liz’, ’Olsson’,
  
 ’19371564761’, 20000) 
 >>> a1.deposit(1000) 
  
 >>> a1.withdraw(4000) 
  
 >>> a2.withdraw(10500) 
  
 >>> a1.withdraw(3500) 
  
 >>>
  print
  ""a1’s balance:"", a1.balance 
  
 a1’s balance: 13500 
  
 >>> a1.print_info() 
  
 John Olsson, 19371554951, balance: 13500 
  
  
 >>> a2.print_info()",NA
8.3 Special Methods,"In the examples above, we define a constructor for each class, identified by its 
 special name __init__(...). This name is recognized by Python, and the method 
 is automatically called every time we create a new instance of the class. The 
 constructor belongs to a family of methods known as
  special methods
 , which 
 are all recognized by double leading and trailing underscores in the name. 
 The term
  special methods
  could be a bit misleading, since the methods 
 themselves are not really special. The special thing about them is the name, 
 which ensures that they are automatically called in different situations, such 
 as the __init__ function being called when class instances are created. There 
 are many more such special methods that we can use to create object types 
 with very useful properties.
  
 Consider, for instance, the first example of this chapter, where the class 
 Barometric contained the method value(h) to evaluate a mathematical 
 function. After creating an instance named baro, we could call the method 
 with baro.value(t). However, it would be even more convenient if we could 
 just write baro(t) as if the instance were a regular Python function. This be-
 havior can be obtained by simply changing the name of the value method to 
 one of the special method names that Python automatically recognizes. The 
 special method name for making an instance
  callable
  like a regular Python 
 function is __call__:
  
 class
  Barometric: 
  
 def
  __init__(self, T): 
  
 self.T = T 
  
  
 self.g = 9.81 
  
  
 self.R = 8.314 
  
  
 self.M = 0.02896 
  
 self.p0 = 100.0
  
 #K 
  
 #m/(s*s) 
  
 #J/(K*mol) 
  
 #kg/mol 
  
 #kPa
  
  
 def
  __call__(self, h): 
  
 return
  self.p0 * exp(-self.M*self.g*h/(self.R*self.T))",NA
8.4 Example: Automatic Differentiation of ,NA,NA
Functions,"To provide a more relevant and useful example of a __call__ special method, 
 consider the task of computing the derivative of an arbitrary function. Given 
 some mathematical function in Python, say,
  
 def
  f(x): 
  
 return
  x**3
  
 we want to make a class Derivative and write
  
 dfdx = Derivative(f)
  
 so that dfdx behaves as a function that computes the derivative of f(x). When 
 the instance dfdx is created, we want to call it like a regular function to 
 evaluate the derivative of f in a point x:
  
 print
 (dfdx(2))
  
 # computes 3*x**2 for x=2
  
 It is tricky to create such a class using analytical differentiation rules, but we 
 can write a generic class by using numerical differentiation:",NA
8.5 Test Functions for Classes,"In Chapter 4 we introduced test functions as a method to verify that our 
 functions were implemented correctly, and the exact same approach can be 
 used to test the implementation of classes. Inside the test function, we define 
 parameters for which we know the expected output, and then call our class 
 methods and compare the results with those expected. The only additional 
 step involved when testing classes is that we will typically create one or more 
 instances of the class inside the test function and then call their. As an 
 example, consider a test function for the Derivative class of the previous 
 section. How can we define a test case with known output for this class? Two 
 possible methods are; (i) to compute (
 f
 (
 x
 +
 h
 )
 −f
 (
 x
 ))
 /h
  by hand for some
  f 
 and
  h
 , 
 or (ii) utilize the fact that linear functions are differentiated exactly by our 
 numerical formula, regardless of
  h
 . A test function based on (ii) could look 
 like the following:
  
 def
  test_Derivative(): 
  
 # The formula is exact for linear functions, regardless of h 
 f =
  lambda
  x: a*x + 
 b 
  
 a = 3.5; b = 8 
  
 dfdx = Derivative(f, h=0.5) 
  
 diff =
  abs
 (dfdx(4.5) - a) 
  
 assert diff < 1E-14, ’bug in class Derivative, diff=%s’ % diff
  
 This function follows the standard recipe for test functions: we construct a 
 problem with a known result, create an instance of the class, call the method, 
 and compare the result with the expected result. However, some of the details 
 inside the test function may be worth commenting on. First, we use a lambda 
 function to define f(x). As you may recall from Chapter 4, a lambda function is 
 simply a compact way of defining a function, with
  
 f =
  lambda
  x: a*x + b
  
 being equivalent to
  
 def
  f(x): 
  
 return
  a*x + b
  
 The use of the lambda function inside the test function appears straightfor-
 ward at first:
  
 f =
  lambda
  x: a*x + b 
  
 a = 3.5; b = 8 
  
 dfdx = Derivative(f, h=0.5) 
  
  
 dfdx(4.5)",NA
8.6 Example: A Polynomial Class,"As a summarizing example of classes and special methods, we can consider 
 the representation of polynomials introduced in Chapter 7. A polynomial can 
 be specified by a dictionary or list representing its coefficients and powers.
  
 For example, 1
 −x
 2
 +2
 x
 3
 is
  
 1+0
 ·x−
 1
 ·x
 2
 +2
 ·x
 3
  
 and the coefficients can be stored as a list [1, 0, -1, 2]. We now want to create 
 a class for such a polynomial and equip it with functionality to evaluate and 
 print polynomials and to add two polynomials. Intended use of the class 
 Polynomial could look like the following:
  
 >>> p1 = Polynomial([1, -1]) 
  
 >>>
  print
 (p1) 
  
 1 - x 
  
 >>> p2 = Polynomial([0, 1, 0, 0, -6, -1]) >>> p3 = p1 
 + p2 
  
 >>>
  print
 (p3.coeff) 
  
 [1, 0, 0, 0, -6, -1] 
  
 >>>
  print
 (p3) 
  
 1 - 6*x^4 - x^5 
  
 >>>
  print
 (p3(2.0))
  
 -127.0 
  
 >>> p4 = p1*p2 
  
 >>> p2.differentiate() 
  
 >>>
  print
 (p2) 
  
 1 - 24*x^3 - 5*x^4
  
 To make all these operations possible, the class needs the following special 
 methods:",NA
Chapter 9 ,NA,NA
Object-Oriented Programming,"Upon reading the chapter title, one could wonder why object-oriented pro-
 gramming (OOP) is introduced only now. We have used objects since Chap-
 ter 2, and we started making our own classes and object types in Chapter 8, 
 so what is new in Chapter 9? The answer is that the term OOP can have two 
 different meanings. The first simply involves programming with objects and 
 classes, which we introduced in Chapter 8, and is more commonly referred to 
 as object-
 based
  programming. The second meaning of OOP is programming 
 with
  class hierarchies
 , which are families of classes that inherit their methods 
 and attributes from each other. This is the topic of the present chapter. We 
 will learn how to collect classes in families (hierarchies) and let child classes 
 inherit attributes and methods from parent classes.",NA
9.1 Class Hierarchies and Inheritance,"A class hierarchy is a family of closely related classes organized in a hierar-
 chical manner. A key concept is
  inheritance
 , which means that child classes 
 can inherit attributes and methods from parent classes. A typical strategy is 
 to write a general class as a base class (or parent class) and then let special 
 cases be represented as subclasses (child classes). This approach can often 
 save much typing and code duplication. As usual, we introduce the topic by 
 looking at some examples.
  
 Classes for lines and parabolas.
  As a first example, let us create a class for 
 representing and evaluating straight lines,
  y
  =
  c
 0
  +
  c
 1
 x
 . Following the concepts 
 and ideas introduced in Chapter 8, the implementation of the class can look 
 like
  
 import
  numpy as np
  
 class
  Line:
  
 © The Author(s) 2020
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 135
  
 https://doi.org/10.1007/978-3-030-50356-7_9",NA
9.2 Example: Classes for Numerical ,NA,NA
Differentiation,"Common tasks in scientific computing, such as differentiation and integra-
 tion, can be carried out with a large variety of numerical methods. Many such 
 methods are closely related, and can be easily grouped into families of 
 methods that are very suitable for implementation in a class hierarchy. As a 
 first example, we consider methods for numerical differentiation. The 
 simplest formula is a one-sided finite difference:
  
 f
 ′
 (
 x
 )
  ≈f
 (
 x
 +
 h
 )
 −f
 (
 x
 ) 
 ,
  
 which can be implemented in the following class:
  
 class
  Derivative: 
  
 def
  __init__(self, f, h=1E-5): 
  
 self.f = f 
  
  
 self.h =
  float
 (h)
  
 def
  __call__(self, x): 
  
 f, h = self.f, self.h 
  
 return
  (f(x+h) - f(x))/h
  
 # make short forms
  
 To use the Derivative class, we simply define a function f(x), create an 
 instance of the class, and call it as if it were a regular function (effectively 
 calling the __call__ method behind the scenes):",NA
9.3 Example: Classes for Numerical Integration,"Just as numerical differentiation, numerical integration is a mainstay of com-
 putational mathematics. There are numerous methods to choose from, and 
 they can all be written on the form
  
  b
  
 f
 (
 x
 )
 dx ≈
  
 n−
 1
  
 w
 i
 f
 (
 x
 i
 )
 .
  
 a
  
 i
 =0
  
 and the Based on this general formula, different methods are realized by 
 choosing the integration points
  x
 i
  and associated weights
  w
 i
 . For instance, the 
 trapezoidal rule has
  
 x
 i
  =
  a
 +
 ih, w
 0
  =
  w
 n−
 1
  =
 h 
 2
 , w
 i
  =
  h
  (
 i ̸
 = 0
 ,n−
 1)
 ,",NA
Index,"__call__, 
 123 
  
 __init__, 
 117 
  
 __repr__, 
 125 
  
 __str__, 124
  
 animation, 93 
  
 append (list method), 24 
 argument, 38 
  
 array, 81 
  
 array, 83 
  
 array slicing, 99 
  
 array, two-dimensional, 99 
 assert, 53
  
 base class, 136 
  
 bisection method, 50 
  
 Boolean expressions, 
 21 branching, 46
  
 class, 115 
  
 class hierarchy, 135 
  
 class instance, 117 
  
 cmath, 14 
  
 command line argument, 59 
 comments, 8 
  
 constructor, 117 
  
 convergence, 51, 141
  
 default argument, 44 
 del function, 24 
  
 dictionary, 101 
  
 dir function, 126 
  
 doc string, 45
  
 editor, 1 
  
 elif, 47 
  
 else, 46 
  
 error handling, 70 
  
 eval, 61 
  
 exception handling, 70 
 exec, 61
  
 f-string, 11 
  
 file reading, 65 
  
 file writing, 69 
  
 find (string method), 108 
 float, 9 
  
 for loop, 25 
  
 FuncAnimation, 97 
  
 function, 35
  
 Gaussian function, 14, 93 
 global, 40 
  
 global variable, 38
  
 Heaviside function, 90
  
 def, 36
  
 IDE, 1
  
 147
  
 © The Author(s) 2020 
  
 J. Sundnes, 
 Introduction to Scientific Programming with 
 Python
 , Simula SpringerBriefs on Computing 6,
  
 https://doi.org/10.1007/978-3-030-50356-7",NA
