Larger Text,Smaller Text,Symbol
Beginning Swift,NA,NA
Master the fundamentals of programming in Swift 4,NA,NA
Rob Kerr ,NA,NA
Kåre Morstøl,BIRMINGHAM - MUMBAI,NA
Beginning Swift,"Copyright © 2018 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or 
 by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in 
 critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of the information presented. 
  
 However, the information contained in this book is sold without warranty, either express or implied. Neither the 
 authors, nor Packt Publishing or its dealers and distributors, will be held liable for any damages caused or alleged to 
 have been caused directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned 
 in this book by the appropriate use of capitals. However, Packt Publishing cannot guarantee the accuracy of this 
 information.
  
 Acquisition Editor:
  Aditya Date 
  
 Content Development Editor:
  Taabish Khan 
  
 Production Coordinator:
  Vishal Pawar
  
 First published: May 2018
  
 Production reference: 1310518
  
 Published by Packt Publishing Ltd. 
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK.
  
 ISBN 978-1-78953-431-3
  
 www.packtpub.com",NA
Why Subscribe?,"• 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Spend less time learning and more time coding with practical eBooks and Videos 
 from over 4,000 industry professionals 
  
 Learn better with Skill Plans built especially for you 
  
 Get a free eBook or video every month 
  
 Mapt is fully searchable 
  
 Copy and paste, print, and bookmark content",NA
PacktPub.com,"Did you know that Packt offers eBook versions of every book published, with PDF and ePub 
 files available? You can upgrade to the eBook version at 
 www.PacktPub.com
  and as a print 
 book customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for a 
 range of free newsletters, and receive exclusive discounts and offers on Packt books and 
 eBooks.",NA
Contributors,NA,NA
About the Authors,"Rob Kerr
  is a mobile software architect based in United States. He has been working 
 professionally with Swift since its introduction, delivering applications to the public App 
 Store and through enterprise distribution. His current focus is developing state-of-the-art 
 iOS applications using Swift in the IoT space.
  
 Kåre Morstøl
  is an independent software developer from Norway, with a bachelor's 
 degree in software development. He has programmed almost exclusively in Swift since it 
 was announced. He thinks it's a great language that is continually getting better.",NA
Packt is Searching for Authors Like You,"If you're interested in becoming an author for Packt, please visit 
 authors.packtpub.
  
 com
  and apply today. We have worked with thousands of developers and tech 
  
 professionals, just like you, to help them share their insight with the global tech 
  
 community. You can make a general application, apply for a specific hot topic that we are 
 recruiting an author for, or submit your own idea.",NA
Table of Contents,"Preface 
  
 vii
  
 Lesson 1: Swift Basics 
  
 1
  
 Swift Program Structure 
  
 Hello, World! 
  
 Swift Variables and Constants 
  
  
 Declaring Swift Variables 
  
  
 Variables Versus Constants 
  
  
 Type Inference 
  
  
 Variable Naming 
  
  
   
 Working with Variables 
  
  
  
 Tuples 
  
  
   
 Creating a Tuple 
  
  
  
 Optionals 
  
  
   
 Declaring an Optional 
  
  
   
 Working with Optionals 
  
  
   
 Optional nil Values 
  
  
   
 Accessing Optional Values 
  
  
   
 Force Unwrapping an Optional 
  
  
   
 Conditionally Unwrapping Optionals 
  
   
 The Swift guard Statement 
  
  
  
 Activity B: Variable Summary 
  
 Swift Data Types 
  
 Numeric Data Types 
  
  
 Int on 64-Bit Versus 32-Bit Platforms 
  
  
 Built-In Numeric Data Types 
  
  
 Choosing the Appropriate Numeric Data Type 
  
 Declaring and Assigning Integer Variables 
  
  
 Declaring and Assigning Floating Point Numbers 
  
 Numeric Literal Grouping 
  
  
 Numeric Type Conversions 
  
 Boolean 
  
 2
  
 3 
  
 6
  
 6 
  
 7 
  
 8 
  
 8 
  
 9 
  
 10 
  
 12 
  
 12 
  
 13 
  
 14 
  
 14 
  
 15 
  
 15 
  
 16 
  
 17 
  
 18 
  
 19
  
 20 
  
 20 
  
 20 
  
 20 
  
 21 
  
 21 
  
 22 
  
 22 
  
 25",NA
Preface,"Swift is a multi-paradigm language. It has expressive features familiar to those used to 
 working with modern functional languages, whilst also keeping the object-oriented features of 
 Objective-C. Swift vastly streamlines the developer experience, and Apple's Xcode playground 
 is a real game-changer.
  
 The book begins by teaching you the basic syntax and structure of Swift, and how to correctly 
 structure and architect software using Swift. It then builds expertise in the core Swift standard 
 library you will need to understand to complete real-world Swift programming projects. We will 
 work through concepts such as operators, branching and loop structures, functions, classes, 
 structs, collections, and strings. We end the book with a brief look at functional programming 
 and lazy operations.
  
 After reading and understanding this book, you will be well-prepared to begin developing 
 native end-user applications for iOS or macOS, or to develop server-side (backend) 
 application and web services using Swift on Linux.",NA
What This Book Covers,"Lesson 1
 , 
 Swift Basics
 , covers the fundamentals of using the Swift programming language. In this 
 lesson, you'll learn basic Swift syntax and program structure. You'll also learn how to use Swift 
 built-in data types and enums, and how to declare and use Swift variables and constants.
  
 Lesson 2
 , 
 Swift Operators and Control Flow
 , shows you how to use the fundamental flow control 
 structures and language elements that form the building blocks of Swift programs. 
  
 We will specifically cover operators, branching statements, and loops in this lesson.
  
 Lesson 3
 , 
 Functions, Classes, and Structs
 , teaches you how to develop fully featured Swift 
 functions, catch unexpected errors, and use asynchronous programming paradigms. You'll 
 learn how to create your own data types, and create object-oriented applications using classes 
 and structs.
  
 Lesson 4
 , 
 Collections
 , shows you how to work with Swift's collections, such as arrays, sets, and 
 dictionaries.
  
 Lesson 5
 , 
 Strings
 , covers Swift strings in detail. We will create and use strings and 
 substrings, and see the various common operations available for strings.
  
 Lesson 6
 , 
 Functional Programming and Lazy Operations
 , ventures at functional programming 
 and explains what lazy operations are. We will end this lesson with an important but often 
 overlooked topic—writing Swifty code.",NA
What You Need for This Book,"This book will require the following hardware:
  
 • 
  
 A Mac computer capable of running macOS Sierra 10.12.6+
  
 • 
  
 An internet connection
  
 Please ensure you have the following software installed on your machine:
  
 • 
  
 Operating system: macOS Sierra 10.12.6+ 
  
 • 
  
 Xcode 9.1
  
 • 
  
 Safari browser
  
 [
  viii 
 ]",NA
Who This Book is for,"This book is ideal for developers seeking fundamental Swift programming skills, in 
 preparation for learning to develop native applications for iOS or macOS. No prior Swift 
 knowledge is expected but object-oriented programming experience is desirable.
  
 You should have basic working knowledge of computer programming in a procedural/ 
 object-oriented language, such as Objective-C, BASIC, C++, Python, Java, or JavaScript.",NA
Conventions,"In this book, you will find a number of text styles that distinguish between different kinds of 
 information. Here are some examples of these styles and an explanation of their meaning.
  
 Code words 
 in text
  are shown as follows: ""Finally, use the console 
 print
  function to output the 
 content of each error variable.""
  
 Folder names, filenames, file extensions, pathnames, include file names in text are shown as 
 follows: ""Launch Xcode as before, and create a new playground named 
 Create a 
 Variable.playground
 .""
  
 A block of code is set as follows:
  
 let name = ""John Doe""
  
 var address = ""201 Main Street""
  
 print(""\(name) lives at \(address)"")
  
 New terms and important words are shown in bold. Words that you see on the screen, for 
 example, in menus or dialog boxes, appear in the text like this: ""Choose 
 Blank
  as the 
 playground template, and then press the 
 Next
  button.""
  
 Important new 
 programming terms
  are shown in bold. 
 Conceptual terms
  are shown in 
 italics.
  
  
 Important additional details about a topic appear like this, 
  
  
 as in a sidebar.
  
  
 Important notes, tips, and tricks appear like this.
  
  
 [
  ix 
 ]",NA
Reader Feedback,"Feedback from our readers is always welcome. Let us know what you think about this 
 book—what you liked or disliked. Reader feedback is important for us as it helps us 
 develop titles that you will really get the most out of.
  
 To send us general feedback, simply e-mail 
 feedback@packtpub.com
 , and mention the 
 book's title in the subject of your message.
  
 If there is a topic that you have expertise in and you are interested in either writing or 
 contributing to a book, see our author guide at 
 www.packtpub.com/authors
 .",NA
Customer Support,"Now that you are the proud owner of a Packt book, we have a number of things to help you to 
 get the most from your purchase.",NA
Downloading the Example Code,"You can download the example code files from your account at 
 http://www.packtpub.com 
 for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, 
 you can visit 
 http://www.packtpub.com/support
  and register to have the files e-mailed 
 directly to you.",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do happen. 
 If you find a mistake in one of our books—maybe a mistake in the text or the code—we would 
 be grateful if you could report this to us. By doing so, you can save other readers from 
 frustration and help us improve subsequent versions of this book. If you find any errata, 
 please report them by visiting 
 http://www.packtpub.com/submit-errata
 , selecting your 
 book, clicking on the 
 Errata Submission Form
  link, and entering the details of your errata. 
 Once your errata are verified, your submission will be accepted and the errata will be 
 uploaded to our website or added to any list of existing errata under the Errata section of that 
 title.
  
 To view the previously submitted errata, go to 
 https://www.packtpub.com/books/ 
 content/support
  and enter the name of the book in the search field. The required 
 information will appear under the 
 Errata
  section.
  
 [
  x 
 ]",NA
Piracy,"Piracy of copyrighted material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come across 
 any illegal copies of our works in any form on the Internet, please provide us with the location 
 address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected pirated 
 material.
  
 We appreciate your help in protecting our authors and our ability to bring you valuable 
 content.",NA
Questions,"If you have a problem with any aspect of this book, you can contact us at 
 questions@ 
 packtpub.com
 , and we will do our best to address the problem.
  
 [
  xi 
 ]",NA
Swift Basics,"Swift is a relatively new programming language designed by Apple Inc., and was initially made 
 available to Apple developers in 2014—primarily intended as a replacement for the aging 
 Objective-C language that was the foundation of OS X and iOS software development at the time.
  
 Unlike many object-oriented languages, which are based on older procedural languages—for 
 example, C++ and Objective-C are based on C—Swift was designed from the ground up as a new, 
 modern, object-oriented language that makes programming faster and easier, and helps 
 developers produce expressive code that's less prone to errors than many languages.
  
 While not based on an older language, Swift, in the words of its chief architect, Chris Lattner, 
 ""
 was inspired by drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too 
 many others to list.
 "" (Chris Lattner home page: 
 http://nondot.org/sabre/
 ).
  
 Swift was initially a proprietary language, but was made open source software in December 
 2015 as of its version 2.2. While Swift remains primarily used by developers targeting the Apple 
 macOS and iOS platforms, Swift is also fully supported on Linux, and there are unofficial ports 
 under development for Windows as well.
  
 The objective of this lesson is to learn the fundamentals of using the Swift programming 
 language. In this lesson, you'll learn basic Swift syntax and program structure. You'll also learn 
 how to use Swift built-in data types and enums, and how to declare and use Swift variables 
 and constants. Let's get started.",NA
Lesson objectives,"By the end of this lesson, you will be able to:
  
  
 • 
  
 Explain the program structure and syntax of Swift programs
  
 • 
  
 Declare and use Swift variables and constants
  
  
 • 
  
 Use the various built-in Swift data types
  
  
 • 
  
 Use the Swift enum language syntax",NA
Swift Program Structure ,"In this first section, we'll look at the basic language syntax for Swift, and you'll write your first 
 fully functional Swift program.
  
 Like many modern programming languages, Swift draws its most basic syntax from the 
 programming language C. If you have previous programming experience in other C-inspired 
 languages, such as C++, Java, C#, Objective-C, or PHP, many aspects of Swift will seem familiar, 
 and many Swift concepts you will probably find quite familiar.
  
 We can say the following about Swift's basic syntax:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Programs are made up of statements, executed sequentially 
  
 More than one statement are allowed per editor line when separated by a 
  
 semicolon (;) 
  
 Units of work in Swift are modularized using functions and organized into types 
 Functions accept one or more parameters, and return values 
  
 Single and multiline comments follow the same syntax as in C++ and Java 
  
 Swift data type names and usage are similar to that in Java, C#, and C++ 
  
 Swift has the concept of named variables, which are mutable, and named constants, 
 which are immutable 
  
 Swift has both struct and class semantics, as do C++ and C#
  
 [
  2 
 ]",NA
"Hello, World!","When learning a new language, it's traditional for a first program to make sure the 
 development environment is installed and properly configured by writing a program that 
 outputs something to the screen. That's what we'll do next.
  
 Now, let's use an Xcode playground to create a simple Swift program to display the string 
 Hello, World
  to the playground console, by following these steps:
  
 1. Begin by launching Xcode. You should be presented with a 
 Welcome to Xcode 
  
 screen with the following commands listed on the left:
  
 1. 
 Get started with a playground
  
 2. 
 Create a new Xcode project
  
 3. 
 Clone an existing project
  
 [
  3 
 ]",NA
Swift Variables and Constants,"Virtually all programming languages include the ability for programmers to store values in 
 memory using an associated name chosen by the programmer. Variables allow programs to 
 operate on data values that change during the run of the program.",NA
Declaring Swift Variables,"A Swift variable declaration uses the following basic syntax:
  
 var <variable name> : <type> = <value>
  
 Given this syntax, a legal declaration for a Pi variable would be the following:
  
  var pi : Double = 3.14159
  
 This declaration means: 
 create a variable named 
 pi
 , which stores a 
 Double
  data type, and assign it 
 an initial value of 3.14159
 .
  
 [
  6 
 ]",NA
Variables Versus Constants,"You may want to store a named value in your program that will not change during the life of the 
 program. In the previous example, the value of Pi should never change during the course of a 
 program. How can we ensure that, once defined, this named value can never be accidentally 
 changed by our code?
  
 Swift 
 variables
  are declared using the 
 var
  keyword, while Swift 
 constants
  are declared using the 
 let
  keyword, for example:
  
 var pi1 = 3.14159
  
 let pi2 = 3.15159
  
 In this code, the named value 
 pi1
  is a variable, and its value can be changed by the code after 
 it is declared. The following line of code later in the program would be legal, even though it 
 would result in an invalid value for 
 pi1
 :
  
 pi1 = pi1 * 2.0
  
 On the other hand, since 
 pi2
  was declared as a constant, using the 
 let
  keyword, the 
 following line of code later in the program would result in a compile-time error, since 
 changing a 
 let
  constant is illegal:
  
 pi2 = pi2 * 2.0
  
 Generally, any time you create a named value that will never be changed during the run of your 
 program, you should use the 
 let
  keyword to create a constant. The Swift compiler enforces this 
 recommendation by creating a compile-time warning whenever a 
 var
  is created that is not 
 subsequently changed.
  
  
 Other than the restriction on mutating the value of a constant once 
  
  
 declared (for safety), Swift variables and constants are used in virtually 
  
 identical ways, and you usually won't think about whether a symbol is a 
  
 variable or a constant after declaring it.
  
 [
  7 
 ]",NA
Type Inference,"In the previous example, we created the variable 
 pi1
  without specifying its data type. We took 
 advantage of a Swift compiler feature called 
 type inference
 .
  
 When you assign the value of a variable or constant as you create it, the Swift compiler will 
  
 analyze the right-hand side of the assignment, 
 infer
  the data type, and assign that data type 
  
 to the variable or constant you're creating. For example, in the following declaration, the 
 compiler will create the variable 
 name
  as a String data type:
  
 var name = ""George Smith""
  
 As a 
 type-safe
  language, once a data type is inferred by the compiler, it remains fixed for the life 
 of the variable or constant. Attempting to assign a non-string value to the 
 name
  variable 
 declared above would result in a compile-time error:
  
 name = 3.14159  // Error: ""Cannot assign value of type 'Double' to 'String'
  
 While Swift is a 
 type-safe
  language, where variable types are explicit and do not change, it is 
 possible to create Swift code that behaves like a dynamic type language using the Swift 
 Any 
 data 
 type. For example, the following code is legal in Swift:
  
 var anyType: Any
  
 anyType = ""Hello, world""
  
 anyType = 3.14159
  
 While this is legal, it's not a good Swift programming practice. The 
 Any
  type is mainly provided 
 to allow bridging between Objective-C and Swift code. To keep your code as safe 
  
 and error-free as possible, you should use explicit types wherever possible.",NA
Variable Naming,"Swift variables and constants have the same naming rules as most C-inspired programming 
  
 languages:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Must not start with a digit 
  
 After the first character, digits are allowed 
  
 Can begin with and include an underscore character 
  
 Symbol names are case sensitive 
  
 Reserved language keywords may be used as variable names if enclosed in 
 backticks (for example, 
 `Int`:Int = 5
 )
  
 [
  8 
 ]",NA
Working with Variables,"In this section, you'll use an Xcode playground to create a variable and constant, and 
 observe the difference between them. So, let's get started.
  
 To work with variables, follow these steps:
  
 1. Launch Xcode as before, and create a new playground named 
 Create a 
  
 Variable.playground
 .
  
 [
  9 
 ]",NA
Tuples,"One of Swift's unique language features is its inclusion of 
 tuples
 . By default, variables and 
 constants store a single value. Tuples allow a variable or constant name to refer to a set of 
 values. While tuples do not exist in many languages, you can think of them as 
 compound values
 , 
 and they function almost identically to a 
 structure
 , which is a single named object which can 
 store more than one variable embedded within it.
  
 By using a tuple, we could take the following variable declaration:
  
 var dialCode = 44 
  
 var isoCode = ""GB"" 
  
 var name = ""United Kingdom""
  
 We could combine it to the following:
  
 var country = (44, ""GB"", ""United Kingdom"")
  
 [
  10 
 ]",NA
Creating a Tuple,"Let's look at creating a tuple. We'll use an Xcode playground to create and use a tuple. Here are 
 the steps:
  
 1. Launch Xcode as before, and create a new playground named 
 Create a Tuple. 
  
 playground
 .
  
 2. Add the following code to the playground to create a tuple containing a person's 
  
 name, address and age:
  
 let person1 = (""John Doe"", ""201 Main Street"", 35)
  
 print(""\(person1.0) lives at \(person1.1) and is \(person1.2) years 
 old."")
  
 This code is very similar to the previous , except that we've used a tuple to group 
 together values describing John Doe—rather than using separate variables for each 
 element.
  
 While this syntax is legal, acceptable, and common, it can begin to result in difficult to 
 understand and maintain code—especially when a tuple contains more than two simple 
 values. To make a tuple more maintainable, you can give variable names to each of its 
 components.
  
 3. Add the following to the playground:
  
 let person2 = (name: ""Jane Doe"", address: ""301 Fifth Avenue"", age: 35)
  
 print(""\(person2.name) lives at \(person2.address) and is \(person2.age) 
 years old."")
  
 In this second approach, each member of the tuple has a descriptive name, making it 
 easier for the reader of the program to understand and maintain the code.",NA
Optionals,"Another unique language feature Swift provides is the 
 optional
 . In most programming 
 languages, all variables and constants 
 must
  hold some value. But, in the real world, sometimes a 
 value is 
 unknown
 . For example, an address may or may not contain a second address line, and 
 more than 60 countries in the world don't use postal codes. Optionals allow variables to indicate 
 whether their value is missing (that is, not assigned), or is truly a 
 blank value
 .
  
 [
  12 
 ]",NA
Declaring an Optional ,"Earlier in this lesson, we declared variables with initial values assigned. These variables are 
 not
  optional, have a value, and can never be assigned a 
 nil
  value, or an unwrapped optional 
 variable's value.
  
 In this section, we define a variable as an optional by adding a question mark to the type 
 name, which makes it subject to the Swift compiler's optional validation rules.
  
 A third possibility is to declare a 
 force unwrapped
  variable—a variable that can be 
 nil
 , but is 
 not optional. This type of variable is declared by placing an exclamation point (
 !
 ) after the type 
 (rather than the question mark (
 ?
 ) for the optional), for example: 
  
 var customerAge: Int!
  
 When a variable is declared in this fashion, the compiler 
 will
  allow the variable to be 
 assigned a 
 nil
  value at any time, but 
 will not
  warn the programmer at 
 compile time
  when the 
 variable's value is (or could be) assigned a 
 nil
  value.
  
 There are limited circumstances where this technique is required, and in general it should be 
 avoided.
  
 [
  13 
 ]",NA
Working with Optionals,"As mentioned, the simplest way to declare a variable as an optional is to append the data type 
 with a question mark, for example:
  
 var name: String?
  
 Because of Swift's type inference, the following line of code 
 will
  create a second variable of 
 optional type:
  
 var nameCopy = name
  
 The syntax to assign a value to this variable is the same as it would be if the variable was not 
 declared as optional:
  
 name = ""Adam Smith""
  
 The difference between optional and non-optional variables is primarily when you access the 
 value of an optional, which we'll cover next.",NA
Optional nil Values,"Optional variables in Swift can be directly compared to the absence of value (
 nil
 ) and assigned a 
 nil
  value. For example, in the following two statements, variable 
 a
  initially has a value of 
 4
 , then 
 is assigned a 
 nil
  value, and then is checked for having a 
 nil
  value:
  
 var a: Int? = 4
  
 a = nil
  
 if a == nil {
  
  print(""a is nil"")
  
 }
  
 While the presence or absence of a value within an optional can be directly tested, extracting 
 and using the value contained within an optional requires that the optional (the envelope) be 
 unwrapped, and the content (value) extracted. We'll learn how to do this next.
  
 [
  14 
 ]",NA
Accessing Optional Values ,"Think of an optional as a value 
 wrapped
  in an envelope. You cannot access the contents of an 
 envelope without opening it (
 unwrapping
  it), and then removing the contents.
  
 You can primarily unwrap an optional and use its value in two ways:
  
 • 
  
 Force unwrap
  
  
 • 
  
 Conditional unwrap 
  
 We'll learn each of these techniques next.",NA
Force Unwrapping an Optional ,"Look at the two optional 
 Int
  variables: 
  
  
 var a: Int?
  
  
 var b: Int = 4 
  
 You could attempt to assign 
 a
  to 
 b
 , for example: 
  
  
 b = a 
  
 But this would result in a compile-time error: 
  
  
 Value of optional type 'Int?' not unwrapped; did you mean to use '!' or 
  
 '?'?
  
 As the error indicates, accessing the value of an unwrapped optional variable is (always) 
 illegal. One approach to solving this problem is to force unwrap the variable as we use it. To 
 force unwrap a variable, simply place an exclamation mark (
 !
 ) after the variable name, for 
 example: 
  
  
 b = a!
  
 Force unwrapping is similar to using a 
 type cast
  in many languages. In Swift, a force 
 unwrap tells the compiler to assume that the optional contains a value.
  
 However, a force unwrap shifts all the responsibility to the programmer for ensuring optionals 
 actually have values. The above example, 
 b = a!
 , would allow the code to compile, but would 
 generate the following runtime error, and the application will crash: 
  
 Fatal error: 
 Unexpectedly found nil while unwrapping an Optional value 
 Because variable 
 a
  is an 
 optional with no value, there is no value to extract from it to assign to 
 b
 .
  
 [
  15 
 ]",NA
Conditionally Unwrapping Optionals ,"While there are times when force unwrapping variables is safe, you should typically take 
 advantage of Swift's type-safety features by using 
 conditional unwrapping
 .
  
 With conditional unwrapping, we ask the compiler to first check whether the optional has a 
 value, and return the value if present, or 
 nil
  if not.
  
 For example, to assign the value of optional 
 a
  to a new, non-optional variable 
 b
 , we can use the 
 following code:
  
 var a: Int? = 4 
  
 if let b = a {
  
  print(b) 
  
 }
  
 This code snippet would print the value 
 4
  to the console. If we had not assigned the initial 
 value 
 4
  to 
 a
 , then nothing would have been printed.",NA
Using Optionals,"Use an Xcode playground to create and use an optional, by performing the following steps:
  
 1. Launch Xcode as before, and create a new playground named 
 Using Optionals. 
  
 playground
 .
  
 2. Add the following code to the playground to create an optional containing a 
  
 person's name:
  
 var name: String? = nil
  
 3. Now add the following code to check whether the optional is 
 nil
 :
  
 if name == nil {
  
  
  print(""name is nil"") 
  
 } else {
  
 [
  16 
 ]",NA
The Swift guard Statement ,"It's very common that Swift functions should only execute when parameters passed to them are 
 in an expected state. In early versions of Swift, the conditional unwrapping technique was often 
 used to provide this type of safety checking. For example, a function that accepts an optional 
 Int
  value, but should only proceed when the parameter is not 
 nil
  might look as follows:
  
 func doubleValue(input: Int?) -> Int? {
  
  if let i = input {
  
   
  return i * 2
  
  }
  
  return nil 
  
 }
  
 While this function is only a few lines of code, imagine if the work done on the unwrapped 
 variable was more complex. To allow parameter and other data state checking to be concisely 
 done at the beginning of functions, Swift includes a 
 guard
  keyword.
  
 [
  17 
 ]",NA
Activity B: Variable Summary,"In Swift, variables are declared before being used. Variables can be declared in various 
 ways, and may not even need to have their type explicitly stated when the compiler can 
 infer data type from initial assignment.
  
 Use an Xcode playground to practice how to declare variables, constants, and tuples.
  
 1. Launch Xcode as before, and create a new playground named 
 Topic B Summary. 
  
 playground
 .
  
 2. Add the following code to the playground to create three variables storing values 
  
 related to the weather conditions in Berlin:
  
 let cityName = ""Berlin""
  
 var humidityPercentage: Double?
  
 var temperatureCentigrade: Double?
  
 Note that 
 cityName
  is a constant, non-optional variable, with an initial string value. 
 Since we know the name of the city in advance, and it doesn't change for this program, 
 it's most appropriate to use 
 let
  to declare this value as a constant.
  
 humidityPercentage
  and 
 temperatureCentigrade
  are declared as optional, since we do 
 not yet know the weather conditions in Berlin at the start of this program.
  
 3. Next, add the following line of code to create a tuple to collect the weather report 
  
 data 
 into a single variable named 
 weather
 :
  
 var weather = (city: cityName, humidityPercentage: humidityPercentage, 
 temperature: temperatureCentigrade)
  
 Recall that providing reference names for each tuple member is optional, but is 
 included here to make the remaining part of the program clearer to other 
 programmers who may need to read this program later.
  
 [
  18 
 ]",NA
Swift Data Types ,"Like most programming languages, Swift includes a full complement of built-in data types that 
 store numbers, characters, strings, and Boolean values.
  
  
 In the previous section, we covered the use of Swift optionals, and 
  
  
 worked through several examples declaring an 
 Int
  variable as optional 
  
 and non-optional. Keep in mind that any Swift variable, of any type, can 
  
 be declared as an optional.
  
 [
  19 
 ]",NA
Numeric Data Types,"Like most programming languages, Swift provides built-in numeric data types that 
 represent either integer or floating-point values.",NA
Int on 64-Bit Versus 32-Bit Platforms,"While it's likely you'll develop Swift applications exclusively on 64-bit platforms, it's important 
 to know that Swift is available on both 32-bit and 64-bit platforms. When using a generic 
 integer numeric type (
 Int
  or 
 UInt
 ), the generic type will be mapped to an underlying, specific 
 equivalent that matches the current platform's word size. For example, on a 64-bit platform, 
 Int
  is mapped to 
 Int64;
  on a 32-bit platform, the same 
 Int
  type is mapped to an Int32.",NA
Built-In Numeric Data Types,"The following table summarizes the available Swift numeric data types:
  
 Type
  
 Min value
  
 Max value
  
 Int8
  
 -128
  
 127
  
 Int16
  
 -32768
  
 32767
  
 Int32
  
 -2.1 x 109
  
 2.1 x 109
  
 Int64
  
 -9.2 x 1018
  
 9.2 x 1018
  
 UInt8
  
 0
  
 255
  
 UInt16
  
 0
  
 65535
  
 UInt32
  
 0
  
 4.3 x 10
 9
  
 UInt64
  
 0
  
 1.8 x 10
 19
  
 Double
  
 -1.8 x 
 103
 08
  
 1.8 x 10
 308
  
 Float
  
 -3.4 x 10
 38
  
 3.4 x 10
 38",NA
Choosing the Appropriate Numeric Data Type,"Conceptually, a 
 UInt64
  variable will consume four times more RAM than a 
 UInt8
  variable, so 
 you may ask, ""
 Should I tune my variables by selecting the smallest number of bits needed to meet 
 requirements?
 ""
  
 [
  20 
 ]",NA
Declaring and Assigning Integer Variables,"Integer values may be instantiated using base 10 (decimal), base 2 (binary), base 8 (octal), or 
 base 16 (hexadecimal) literal values, or by assigning another 
 Int
  variable of the same type to 
 the new variable.
  
 For example, assigning the number 100 to a new 
 Int
  variable holding a duration in minutes can 
 be done in any of the following ways:
  
 let minutes = 100         // decimal
  
 let minutes = 0b1100100   // binary
  
 let minutes = 0o144       // octal
  
 let minutes = 0x64        // hexadecimal",NA
Declaring and Assigning Floating Point Numbers,"Floating-point numbers are represented by either 
 Float
  or 
 Double
  data types. In general, you 
 should use 
 Double
 —and employ Float only when specific circumstances require using the 
 smaller, 32-bit numeric variable.
  
 Declaring and assigning value to floating-point variables follows the same syntax rules as with 
 integer variables. For example, the following statement creates a new 
 Double
  variable 
 interestRate
 , and assigns an initial value to it:
  
 var interestRate = 5.34
  
 [
  21 
 ]",NA
Numeric Literal Grouping,"When assigning constant values to numeric types, Swift provides a handy format to make 
 code more readable: the underscore character is ignored when parsing numeric literals.
  
 This feature is most commonly used to provide 
 groupings of thousands
  in a large integer or 
 floating-point assignments, but actually can be used to provide any grouping separation that 
 makes code more readable. For example, the following statements all assign the value 100,000 
 to the variable 
 minutes
 :
  
 var minutes = 100000
  
 var minutes = 100_000
  
 var minutes = 10_00_00
  
 var minutes = 0b110_000110_101000_00
  
 Using the underscore for readability can also be used for floating-point literal values. For 
 example, the following statements are equivalent:
  
 var balance = 10000.44556
  
 var balance = 10_000.44_556",NA
Numeric Type Conversions,"Like many fully compiled languages, Swift is a 
 strongly typed
  language, and requires explicit 
 type conversions (or casts) when assigning the value from one variable type to a variable of 
 a different type.
  
 Many new Swift programmers find that Swift is even 
 stricter
  than languages they've used 
 before. In many programming languages, the compiler will implicitly convert between data 
 types during an assignment so long as the value contained within the variable being assigned 
 (on the right of the equals sign) could not overflow the variable being assigned to (on the left of 
 the equals sign).
  
 In other words, in many languages, the following code would be legal, since an 
 Int8
  is 
 known to always 
 fit
  into an 
 Int16
  without a numeric overflow:
  
 Int8 smallNumber = 3;
  
 Int16 mediumNumber = smallNumber;
  
 However, this equivalent code in Swift would result in a compile-time error:
  
 var smallNumber: Int8 = 3
  
 var mediumNumber: Int16 = smallNumber
  
 [
  22 
 ]",NA
Using Numeric Types,"Now, let's see how to use various numeric variable types by following these steps:
  
 1. Launch Xcode as before, and create a new playground named 
 Topic B Using 
  
 Numeric Types.playground
 .
  
 2. Add the following code to the playground to create three 
 Int
  variables, using 
  
 binary, base10, and base16 literal notation, respectively:
  
 var base2 = 0b101010
  
 var base10 = 42
  
 var hex = 0x2A
  
 3. Now add the following three corresponding lines to print the data type and value 
  
 for 
 each of the variables you just created.
  
 print(""Printing \(type(of: base2)): \(base2)"")
  
 print(""Printing \(type(of: base10)): \(base10)"")
  
 print(""Printing \(type(of: hex)): \(hex)"")
  
 Examining the output, note that the three variables all have the same data type 
 (
 Int
 ) and same value (42 in base 10).
  
 [
  23 
 ]",NA
Boolean,"In Swift, the Boolean data type is Bool, and stores a value of 
 true
  or 
 false
 . As with other data 
 types, in the case that a Bool value is not yet known, a Bool can be declared as optional, for 
 example, 
 Bool?
 .
  
 For example, the following code declares a Boolean in Swift, and then changes its value:
  
 var isChecked = false 
  
 isChecked = true
  
 Testing for the value of a Bool value is similar to how we do it in other C-inspired 
 languages, for example:
  
 if isChecked {
  
  // statements to execute if isChecked is true } 
  
 if isChecked == true {
  
  // statements to execute if isChecked is true } 
  
 if !isChecked {
  
  // statements to execute if isChecked is false }",NA
Character,"The Character data type in Swift is an 
 extended grapheme cluster
 .
  
 What does that mean?
  
 An extended grapheme cluster is an ordered sequence of one or more Unicode scalars (that is, 
 values) that, when taken together, produce a human-readable character.
  
 Most important to understand is that, unlike ASCII or ANSI character representations many 
 programmers have worked with before, a Character in Swift may be made of more than one 
 Unicode value.
  
 In Swift 4, the underlying complexities of Unicode, scalar values, and extended grapheme 
 clusters are largely managed for you, but as you begin to work natively with Unicode characters 
 and strings, bear in mind that the Swift Character/String architecture was developed from the 
 ground up around Unicode character representation—not ANSI/ASCII as many other languages 
 were.
  
 [
  25 
 ]",NA
Assigning a Character,"The following are two examples creating new Character variables, and assigning literal 
 values:
  
 let ch1:Character = ""A"" 
  
 let ch2:Character = ""
 😎
 ""
  
 Note the following regarding this assignment:
  
 • 
  
 • 
  
 In Swift, a Character literal is delimited by a double quote, rather than the single 
 quote that's common in most C-inspired languages.
  
 Because the Swift compiler's type inference rules will assume double quotes around a 
 literal imply a string variable, the above 
 ch1
  assignment must explicitly declare the 
 variables as Character type—otherwise the Swift compiler will create 
 ch1
  as a string.",NA
Constructing a Character Literal,"To construct a Character type using Unicode values, you can assign an escape sequence, or use 
 the UnicodeScalar struct to create a Character using numeric Unicode values as input.
  
 The following line of code creates a UnicodeScalar from the value 65 (the ASCII value for the 
 English letter A), and then assigns it to the immutable variable 
 ch1
 :
  
 let ch1 = Character(UnicodeScalar(65))
  
 In this case, there is no ambiguity with regards to double quotation marks, so it's not 
 necessary to explicitly assign the Character type during this assignment.
  
 It's also common to construct a Character using a UnicodeScalar escape sequence within 
 double quotation marks. The following creates a character variable containing an emoji 
 character represented by the UnicodeScalar 
 1F601
 :
  
 let ch3 = ""�{1F601}""  // sets ch3 to ""
 😁
 ""
  
 While Unicode scalars are conceptually similar to ASCII/ANSI value encoding, Swift Characters 
 may be made of more than one numeric value, while ASCII and ANSI use only one numeric 
 value to represent each character.
  
 For example, an accented Western letter is expressed by providing a UnicodeScalar 
 containing two character values.
  
 [
  26 
 ]",NA
String,"Strings in Swift are very similar to strings in other programming languages. As string 
 handling is so central to any application development project, we'll dedicate an entire 
 subsequent lesson to Swift's powerful string handling capabilities. In this section, we'll 
 discuss the basics for declaring and using a string.
  
 Fundamentally, strings are arrays of the Character types, supporting the familiar 
 assignment operator (=), substrings, concatenation, and C-inspired escape characters.",NA
Instantiating a String,"Instantiating a string variable is highly intuitive. The following statements create string 
 variables:
  
 var alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"" 
 let macCharacters = ""
 ⌘⌃⌥⇧ ⏎
 ⌫
 ⇪⎋⇥
 "" 
  
 let emoji = ""
 😎😂🎃🐳🍎😜😆
 """,NA
String Concatenation,"As in many languages, Swift strings can be concatenated using the plus (
 +
 ) operator:
  
 let alphaMac = alphabet + macCharacters
  
 String also supports the unary addition operator:
  
 alphabet += macCharacters
  
 [
  27 
 ]",NA
Extracting Characters,"One difference between Swift strings and strings in many languages is how individual 
 elements of strings are accessed. Specifically, the following syntax with Swift strings is 
 illegal:
  
 let ch = alphabet[4]
  
 error: 'subscript' is unavailable: cannot subscript String with an Int, see 
 the documentation comment for discussion
  
 In Swift, the input to the subscript operator (that is, what's between the 
 []
  characters) is 
 expected to be of type 
 String.Index
 , not 
 Int
 .
  
 In practice, you will construct an Index, then pass the index to the substring operator, for 
 example:
  
 let idx = alphabet.index(alphabet.startIndex, offsetBy: 4) 
 let ch = alphabet[idx]  // ch is assigned the character ""E""",NA
String Length,"Obtaining the length of string is quite easy—simply call the 
 count
  property of a string:
  
 var alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
  
 let alphabetLength = alphabet.count  // 26
  
 We have now reached the end of this section. Here, we worked with the different data 
 types in Swift, specifically numeric, Boolean, character, and string data types.",NA
Activity C: Data Type Summary,"Now that you've learned about the various data types available with Swift, let's put this 
 knowledge into practice by using various types together, and also using the Apple 
 Foundation framework.
  
 Use an Xcode playground to practice various data types. You'll be using numeric data types, 
 formatting them as strings, and using string interpolation to print string values from various 
 data types.
  
 1. Launch Xcode as before, and create a new playground named 
 Data Type 
  
 Summary.playground
 .
  
 2. Add the following code to the playground to create an immutable 
 Double
  with an initial 
 value:
  
 let dVal = 4.9876
  
 [
  28 
 ]",NA
Enums,"Enums are frequently used in Swift to create custom data types that have a predefined set 
 of possible values to select from. Enums serve to make code more readable and 
 maintainable, and also provide compile-time checking for parameters and value 
 assignments which yield higher quality, more robust code.
  
 Many languages provide built-in enum features, and Swift's implementation of the enum is very 
 similar to other languages. Swift does have some unique enum features, which we'll cover in 
 this section.",NA
Basic Enum Syntax,"Consider the following code, which creates and uses a basic enum:
  
 enum DayOfWeek {
  
  
  case monday, tuesday, wednesday, thursday, friday 
 }
  
 var today = DayOfWeek.wednesday
  
 if today == .friday {
  
  
  print(""Today is Friday"") 
  
 } else {
  
  
  print(""Today is not Friday"") 
  
 }
  
 Defining the enum 
 DayOfWeek
  declares a new data type, which can be used just like any other 
 data type. Because the variable 
 today
  is of the type 
 DayOfWeek, 
 which can only be assigned one 
 of the seven listed values, we could not assign anything else. For example, the following code 
 would generate a compile-time error, because 
 Saturday
  is not included in the predefined values:
  
 Var today = DayOfWeek.saturday
  
 The preceding example illustrates the two most important advantages of enums:
  
 • 
  
 • 
  
 Possible values are restricted to a predefined list, making assignment of invalid 
 values something that is tested at compile time rather than at runtime.
  
 Code that uses enums become self-documenting and easier to understand.
  
 [
  30 
 ]",NA
Enum with Raw Values,"In the preceding enum example, the enum values (
 .monday
 , 
 .tuesday
 , and so on) have no 
 underlying data type. For example, we might want to calculate the 
 day of week
  by 
 subtracting the ordinal number for the 
 today
  variable from 
 .monday
 .
  
 However, with the enum as defined, there is no numeric value associated, so the following code 
 will fail to compile:
  
 var nthDay = today - DayOfWeek.Monday
  
 This code generates the following error:
  
 Binary operator – cannot be applied to two 'DayOfWeek' operands
  
 This is by design, because unlike some languages, a Swift enum need not be mapped to a 
 native data type (and should not be, if there's no reason to do so).
  
 However, Swift enums 
 can be
  mapped to any underlying data type. In the following revision, we 
 map the day of week to the 
 Int
  data type, which enables the 
 nth day of the week 
 calculation 
 mentioned above:
  
 enum DayOfWeek: Int {
  
  
  case monday, tuesday, wednesday, thursday, friday 
 }
  
 var today = DayOfWeek.Wednesday // DayOfWeek.wednesday 
  
 var nthDay = today.rawValue - DayOfWeek.monday.rawValue + 1 // 3 var 
 tomorrow = DayOfWeek(rawValue: today.rawValue + 1) // DayOfWeek.
  
 thursday
  
 In this case, all we needed to do was add a native data type (
 Int
 ) to the enum declaration. The 
 Swift compiler then holds a 
 .rawValue
  property. When an enum has an underlying value, it 
 also becomes possible to create an enum member by passing it to the 
 rawValue: 
 parameter of 
 the enum initializer.
  
  
 Use care with raw values. Passing a 
 rawValue:
  to an enum initializer that does 
 not match a defined case within the enum results in the creation of a 
 nil
  
 optional.
  
  
 [
  31 
 ]",NA
Activity D: Using Swift Enums,"Enumerations are a powerful construct available in many programming languages. 
 Enumerations make code more robust and easier for others to understand and maintain.
  
 Use Xcode to define error codes using conventional 
 error number
  techniques, and 
 alternatives that use Swift enums.
  
 1. Launch Xcode as before, and create a new playground named 
 Activity D - 
  
 Using 
 Numeric Types.playground
 .
  
 2. Add the following lines of code to create a set of error codes using simple integer 
  
 values:
  
 // Store an error condition as an integer 
 let success = 0 
  
 let ioFailure = 1 
  
 let timeoutFailure = 2
  
 [
  32 
 ]",NA
Summary,"In this lesson, we've learned the basic language structure and syntax for the Swift 
 programming language. We've now understood the following concepts:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The fundamental structure of Swift programs, and how to use an Xcode playground to 
 develop simple and complex programs 
  
 How to create and use mutable and immutable Swift variables 
  
 The built-in data types available to Swift programs, and how to select the 
  
 appropriate data type depending on circumstance 
  
 Swift's powerful optional construct for detecting and branching program flow when 
 data values are not available 
  
 Swift's type inference and strict type safety syntax and usage
  
 Now that you have the basics well in hand, we're ready to move on to the next lesson, 
 where we'll learn how to use these language elements in complex Swift programs. 
 Specifically, we'll look at the control flow structures and operators offered by Swift.
  
 [
  34 
 ]",NA
Swift Operators and Control ,NA,NA
Flow,"In the last lesson, you learned the fundamentals of Swift syntax, data types, and how to use 
 variables to store and operate on data in a Swift program.
  
 In this lesson, you'll learn how to use the fundamental flow control structures and language 
 elements that form the building blocks for Swift programs.
  
 Swift contains a full set of flow control constructions that help you build logic and organize 
 applications. Swift implements control structures you'll find familiar, and Swift adds modern 
 features and extensions not available in some other languages.
  
 This lesson also covers the broad range of Swift logical and bitwise operators. Swift supports a 
 comprehensive set of operators, based on the C operator construction—but with modern 
 extensions that we'll fully cover in this lesson.",NA
Lesson objectives,"By the end of this lesson, you will be able to do the following:
  
 • 
  
 Use the assignment, arithmetic, and bitwise operators
  
 • 
  
 Use Swift's comparison operators
  
 • 
  
 Explain the functionality of Swift's range operators
  
 • 
  
 Use the Swift branching features: 
 if
  and 
 switch
  
 • 
  
 Control program flow with loops, such as 
 for
 , 
 while
 , and 
 repeat
 /
 while",NA
Swift Operators,"Operators are special characters—usually drawn from mathematics—that are used to 
 process evaluations, modify variable values, and combine values. Swift operators break 
 down into categories by the function they perform:
  
 • 
  
 Assignment operators
  
 • 
  
 Arithmetic operators
  
 • 
  
 Comparison operators
  
 • 
  
 Logical operators
  
 • 
  
 Bitwise operators
  
 • 
  
 Nil-coalescing operators
  
 • 
  
 Range operators
  
 Refer to the following diagram:
  
  
 Swift implements its assignment, arithmetic, comparison, logical, and bitwise operators 
 nearly identically to other C-inspired languages, such as C++, Java, and C#—so your 
 previous experience with these operators will apply directly to Swift programming.
  
 [
  36 
 ]",NA
Assignment Operator,"Swift uses the equals sign (=) to assign the value of one object to another, for example:
  
 let x = 3.0
  
 Like most languages, the equals sign (=) is not overloaded for comparison. Thus, the 
 following is not a valid 
 if
  statement:
  
 if x = 3 {
  
  
  // do something 
  
 } 
  
 // error: use of '=' in a boolean context, did you mean '=='?",NA
Arithmetic Operators,"Let's look at the arithmetic operators, beginning with the standard ones.",NA
Standard Arithmetic Operators ,"Swift supports the four standard arithmetic operators for number types:
  
 Addition
  
 +
  
 Subtraction
  
 -
  
 Multiplication
  
 *
  
 Division
  
 /
  
 [
  37 
 ]",NA
Remainder Operator,"Swift's remainder operator (%) returns the remainder when a second operand is divided 
 into a first operand. For example, the result (
 r
 ) in the following expression is 
 2
 , since 
 14/4=3, with a remainder of 2:
  
 let r = 14 % 4   // r == 2
  
  
 The remainder operator (%) is designed to accept 
 Int
  operands. To 
  
  
 calculate the remainder for floating-point numbers, instead use the 
 function 
 remainder(dividingBy:)
 , for example:
  
 let r = 15.3.remainder(dividingBy: 5.0) // r == 0.3",NA
Unary minus Operator,"Use the unary minus operator (-) before a variable or constant to return the value 
 multiplied by -1, for example:
  
 let x = 3   // x == 3
  
 let y = -x  // y == -3",NA
Compound Assignment Operators,"Swift supports the compound assignment operators as a shortcut for assigning a variable the 
 value of itself changed with another numerical operator. For example, the following two 
 statements are equivalent:
  
 x = x + 1
  
 x += 1
  
 Unlike C (and some C-inspired languages), Swift does not support the use of the ++ unary 
 operator. The following is 
 not
  a Swift syntax:
  
 x++    // Unary operator '++' cannot be applied",NA
Comparison Operators,"Swift's comparison operators are nearly identical to other C-inspired languages. We'll 
 summarize them and any key differences in this section.
  
 [
  38 
 ]",NA
Equality ,"To compare whether the value of two value types are equal (for example, whether two 
 Int 
 variables contain the same value), use the double-equals sign, for example:
  
 if x == 3 {
  
  
  // do something 
  
 }
  
 To compare whether two class instances are the same instance, use the triple-equals sign, for 
 example:
  
 if obj1 === obj2 {
  
  
  // do something if the variables refer to the same object 
 }",NA
Inequality ,"To test for inequality (rather than equality), replace the first equals sign with an exclamation 
 point:
  
 Test for equality
  
 Test for inequality
  
 ==
  
 !=
  
 ===
  
 !==",NA
Comparison between Two Values ,"Swift inequality operators are straightforward, each returning a Bool type. The following 
 table explains each one:
  
 Greater than
  
 >
  
 Less than
  
 <
  
 Greater than or equal to
  
 >=
  
 Less than or equal to
  
 <=
  
 [
  39 
 ]",NA
Ternary Conditional Operator,"This operator provides a shorthand for assignments to variables that result from 
 if…then…else
  
 structured comparisons. For example, the following two statements are equivalent:
  
 // conventional if..then..else 
  
 if x > 4 {
  
  y = 1 
  
 } else {
  
  y = 2 
  
 } 
  
 // ternary conditional operator 
  
 y = x > 4 ? 1 : 2",NA
Logical Operators,"Swift's logical operators follow the same conventions as other C-inspired languages. The 
 following logical operators are available:
  
 NOT
  
 !
  
 AND
  
 &&
  
 OR
  
 ||
  
 Local operators can be chained in a single expression, for example:
  
 let canEnter = atDoor && doorUnlocked || haveKey
  
 Local operators are evaluated as a chain of pairs, and are left associative, meaning that this 
 expression is evaluated as follows:
  
 let canEnter = (atDoor && doorUnlocked) || haveKey
  
 This statement as written suggests a visitor should have a key whether the door is locked or 
 unlocked—which is probably not what was intended. Change the order of evaluation for logical 
 operators using parentheses to get what we want:
  
 let canEnter = atDoor && (doorUnlocked || haveKey)
  
 [
  40 
 ]",NA
Bitwise Operators,"Swift's bitwise operators also follow the same conventions as other C-inspired languages. The 
 following bitwise operators are available:
  
 NOT
  
 ~
  
 AND
  
 &
  
 OR
  
 |
  
 XOR
  
 ^
  
 Left shift
  
 <<
  
 Right shift
  
 >>",NA
Nil-Coalescing Operator,"The nil-coalescing operator is used when unwrapping an optional when a default value is 
 desired in the case that the optional is 
 nil
 .
  
 The following code unwraps an optional with and without 
 nil
 -coalescing: 
  
 let x:Int?
  
 let y = x       // y is an optional of type Int?, and is nil 
 let z = x ?? 4  // z is a non-optional Int, with value 4",NA
Range Operators,"Swift range operators are unique, and many developers new to Swift have not encountered this 
 type of operator in other languages. Range operators are used to express a range of values in a 
 concise syntax.
  
 We will use a range operator when we will introduce the 
 for
  loop: 
  
 for var i in 0..<10 {
  
  
  
  print(i) 
  
  
 }
  
 [
  41 
 ]",NA
Closed Range Operator ,"To create a range that includes the beginning and ending elements, use the closed range 
 operator, which is indicated by three periods (
 ...
 ): 
  
  
 let numbers = 0...10   // numbers = [0,1,2,3,4,5,6,7,8,9,10]",NA
Half-Open Range Operator ,"The half-open range operator (
 ..<
 ) creates a range that includes the first specified element and 
 all values before the ending element:
  
 let numbers = 0..<10   // numbers = [0,1,2,3,4,5,6,7,8,9]",NA
One-Sided Range Operator ,"One-sided range operators are variations on the closed and half-open operators. As the 
 name suggests, the one-sided variants exclude one of the bounding elements, creating a 
 range that includes all possible values on the unbounded side of the operator:
  
  
 let a = [-1,-2,-3,0,1,2,3] 
  
  
 let b = a[2...]      // b = [-3,0,1,2,3] 
  
 let c = a[...2]      // c = [-1,-2,-3] 
  
 let e = a[..<2]      // d = [-1,-2] 
  
 Here, 
 2
  refers to the position of a value in the array.
  
 This is the end of this section. We have covered the various operators available in Swift in 
 detail.
  
 [
  42 
 ]",NA
Activity A: Operators,"Swift provides a rich set of operators you can use to manipulate and transform data within your 
 program. Many of the Swift operators will be familiar, while some provide powerful modern 
 features you may not be familiar with.
  
 Use an Xcode playground to practice using Swift operators.
  
 1. Launch Xcode, create a new playground, and save it to your desktop with the name 
 Operators.playground
 .
  
 2. Add a custom class called 
 MyString
 , which contains a single string object. Don't worry that 
 we haven't formally covered objects—we'll be covering them fully in the next lesson! 
 For now, know that a class is a custom type you can create that contains variables and 
 methods:
  
 class MyString {
  
  
  var content = ""Foo"" 
  
 }
  
 3. Next, create two instances of your custom class: 
 string1
 , 
 string2
 , and a constant 
  
 string3
  
 assigned the value 
 string2
 :
  
 let 
 string1 
 = 
 MyString() 
  
 let 
 string2 
 = 
 MyString() 
  
 let string3 = string2
  
 4. Use variables to evaluate whether the content and instances are equal to each other:
  
 var isContentEqual = string1.content == string2.content 
 var isObjectEqual = string1 === string2 
  
 isObjectEqual = string2 === string3
  
 5. Change the content of one of the strings, and re-evaluate whether the content and 
  
 object equality has changed:
  
 string2.content = ""Bar"" 
  
 isContentEqual = string1.content == string2.content 
 isObjectEqual = string1 === string2
  
 [
  43 
 ]",NA
Branching,"Flow control structures enable developers to apply logical processes and make decisions about 
 what code is executed. Most modern programming languages provide a similar set of flow 
 control structures:
  
 • 
  
 The 
 if
  statements execute code blocks when a Boolean condition is 
 true
 .
  
 • 
  
 The 
 while
  loops execute blocks of code while a Boolean condition remains 
 true
 .
  
 • 
  
 The 
 for
  loops execute blocks of code a specific number of times.
  
 It's said that virtually any programming control flow requirement can be implemented with a 
 while
  statement alone. However, the other various control structures allow programmers to 
 create control flow that's more concise and clearly expresses the intent of the logical program 
 flow.
  
 Indeed, Swift provides a rich and powerful set of control structures, which you'll learn 
 about in this section.
  
 [
  44 
 ]",NA
The if Statement,"The most basic flow control statement in programming is the 
 if
  statement, which executes a 
 block of code 
 if
  some Boolean expression is 
 true
 . The preceding diagram is the flow chart of the 
 if
  statement. The syntax for the Swift 
 if
  statement is as follows:
  
 if {condition-list} {
  
  {statements} 
  
 } else {
  
  {statements} 
  
 }
  
 The following code example implements an 
 if
  statement:
  
 Let age = 18 
  
 if age >= 18 {
  
  print(""person can vote"") 
  
 }
  
 [
  45 
 ]",NA
Condition Lists,"The Swift 
 if
  statement can accept multiple, independent 
 {condition}
  clauses, in a comma-
 delimited fashion.
  
 In the following code sample, the code block is executed only when the 
 isCar
  and 
 isNew 
 values 
 are both true:
  
 let isCar = true
  
 let isNew = true
  
 if isCar, isNew {
  
  print(""new car"")
  
 }
  
 [
  46 
 ]",NA
Optional Unwrapping with if,"You'll use the 
 if
  statement to unwrap optional values frequently. In fact, the 
 if 
 construction will probably be the most frequent way you'll access values stored in 
  
 optionals!
  
 We covered optionals in the previous lesson.
  
 Unwrapping a variable with the 
 if
  statement is done by embedding an assignment into a new 
 variable within the 
 if
  statement condition list, for example:
  
 let price:Double? = 5.99
  
 if let p = price, p > 5.0 {
  
  print(p)
  
 }
  
 In this case, the original variable, 
 price
 , is an optional. In the first clause of the condition list, we 
 ask the compiler to check for a value within the optional 
 price
 , and if there is one, assign it to 
 the new constant 
 p
 . Then, the second clause of the condition list tests whether the unwrapped 
 value is greater than 5.0, and if so, the code block is executed.
  
 If the optional 
 price
  had been 
 nil
 , the comparison clause would not have been executed, and the 
 code block would not have executed. Program flow would have continued after the 
 if
  block.
  
 [
  47 
 ]",NA
The switch Statement,"Have a look at the following diagram. It illustrates how the switch statement works:
  
  
 [
  48 
 ]",NA
switch Statement Rules,"There are a few syntax rules to note when using the Swift 
 switch
  statement:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The cases within a 
 switch
  statement must be exhaustive. In the example above, the 
 special default case is included to mean ""
 When no other case is matched, do this…
 .""
  
 If a default case is included, it must be the last case before the 
 switch
  statement's 
 closing brace.
  
 If the 
 switch
  statement's control expression matches more than one case 
  
 expression, Swift will execute only the statements included with the first matching 
  
 case.
  
 A case must include at least one line of code. If you don't intend to execute any code 
 when a case is matched, add a single 
 break
  keyword to inform the compiler you intend 
 for no code to be executed when the case is true.
  
 By default, Swift's 
 switch
  statement does not support fallthrough to code in other 
 cases. Fallthrough is supported via the 
 fallthrough
  keyword.
  
 The 
 switch
  statement goes much further, and has many powerful extensions, which we'll 
 review next.",NA
The break Keyword,"As mentioned above, if a case is matched that should run no code, simply include a 
 break 
 statement.
  
 The following example will print 
 baby
  for ages < 1, 
 adult
  for ages > 17, and print nothing for 
 ages 1-17:
  
 switch personAge {
  
  case 0..<1: print(""baby"")
  
  case 1..<18: break
  
  default: print(""adult"")
  
 }",NA
The fallthrough Keyword,"If a matched case should execute statements declared for the case that directly follows it, use 
 the 
 fallthrough
  keyword.
  
 [
  50 
 ]",NA
Matching Non-Scalar Values ,"Unlike many other programming languages, Swift 
 does not
  limit 
 switch
  statements to scalar 
 data types. The expression provided to a 
 switch
  statement can be a variable holding a scalar 
 (discrete) set of values—as the previous examples have been—but can also be floating-point, 
 string, enumerations, or any type for which you can write a valid matching expression for each 
 case pattern.
  
 The following example is a valid 
 switch
  statement using a 
 Double
  data type as input:
  
 switch temperature {
  
  case -29.0..<(-7.0): print(""bitter cold"") 
 case -7.0..<12.0: print(""cold"")
  
  case 12.0..<20: print(""warm"")
  
  case 20..<40.0: print(""hot"")
  
  default: print(""deadly"") 
  
 }
  
 Switch can also be used to match non-numeric values, such as String values:
  
 let quarterName = ""Second Quarter"" 
  
 var quarterNum: Int?
  
 switch quarterName {
  
  case ""First Quarter"": quarterNum = 1 
 case ""Second Quarter"": quarterNum = 2 
 case ""Third Quarter"": quarterNum = 3 
 default: quarterNum = 4 
  
 }
  
 [
  51 
 ]",NA
Multiple Patterns in a Single Case ,"A single case within a 
 switch
  statement can match multiple patterns, as shown here:
  
 let monthName = ""February"" 
  
 var quarterNum: Int?
  
 switch monthName {
  
  case ""January"", ""February"", ""March"": quarterNum = 1 
 case ""April"", ""May"", ""June"": quarterNum = 2
  
  case ""July"", ""August"", ""September"": quarterNum = 3 
 default: quarterNum = 4 
  
 }",NA
Using the where Statement within case ,"Swift provides the flexibility to add evaluation logic within a 
 case
  statement. This 
 flexibility allows a case to be matched only when specific conditions are true.
  
 The following 
 switch
  statement branches on the relationship between two variables, 
 temperature
  and 
 humidity
 :
  
 let temperature = 21.5 
  
 let humidity = 22.0
  
 switch (temperature, humidity) {
  
  case let (t,h) where t > h: print(""humidity lower"") 
 case let (t,h) where t < h: print(""humidity higher"") 
 default: ""humidity and temperature are the same"" }
  
 [
  52 
 ]",NA
Evaluating Optionals with a switch Statement ,"The 
 switch
  statement can branch depending on whether a Swift optional is 
 nil
 , and then 
 evaluate the value contained in a non-
 nil
  optional:
  
 let responseCode:Int?
  
 let error:Error?
  
 // make a web service call, which will set responseCode or error to non-nil 
 switch (error, responseCode) {
  
  
  case (.none, .some(let code)) where code == 200: print(""success"")
  
  
  case (.some(let err), .none): print(err.localizedDescription)
  
  
  default: print(""something else happened"") 
  
 }
  
 As you can see already, the 
 switch
  statement in Swift is highly flexible and can meet a vast array 
 of use cases! In general, whenever you include multiple code branches based on the value of a 
 single variable (or related set of variables), consider using the 
 switch
  statement rather than 
 constructing a series of nested 
 if
 /
 else
  statements.
  
 [
  53 
 ]",NA
Activity B: Converting Code from if to switch,"The 
 switch
  statement is essentially a more structured and readable way to implement a 
 nested 
 if
  statement. It's common to refactor a nested 
 if
  to a 
 case
  statement to make the code 
 more readable and maintainable. Let's do this now.
  
 Use an Xcode playground to convert a code with 
 if
  statements to an equivalent code with 
 switch
  
 statements.
  
 1. Launch Xcode, create a new playground, and save it to your desktop with the name 
  
 CaseRefactor.playground
 .
  
 2. Add the following code, which uses a nested 
 if
  statement to determine the country 
  
 code given a country name:
  
 let countryName = ""United States"" 
  
 var countryCode = """"
  
 if countryName == ""United Kingdom"" {
  
  
  countryCode = ""GB"" 
  
 } else if countryName == ""Mexico"" {
  
  
  countryCode = ""MX"" 
  
 } else if countryName == ""Canada"" {
  
  
  countryCode = ""CA"" 
  
 } else if countryName == ""Spain"" {
  
  
  countryCode = ""ES"" 
  
 } else if countryName == ""United States"" {
  
  
  countryCode = ""US"" 
  
 } else {
  
  
  countryCode = ""??"" 
  
 } 
  
 print(""Country named '\(countryName)' has code \(countryCode)"")
  
 3. Next, let's employ an enumeration, which we learned in the last lesson, to encapsulate 
 the country names into a more maintainable data structure. Add the following code 
 underneath the 
 print
  statement:
  
 enum Countries:String {
  
  case uk = ""United Kingdom""
  
  case mx = ""Mexico""
  
  case ca = ""Canada""
  
  case es = ""Spain""
  
  case us = ""United States""
  
 [
  54 
 ]",NA
Loops,"After the branching structures 
 if
  and 
 switch
 , the most common structures you'll use in your 
 programming are looping structures, which cause your program flow to execute the same 
 code iteratively.
  
 The looping structures you'll learn in this section are the following:
  
 • 
  
 • 
  
 for…in
 , which executes the same code a predetermined number of times 
 while
  and 
 repeat…while
 , which executes code until a 
 true
  condition becomes 
 false
  
 As with the 
 switch
  control structure, there are many features and flexible options provided 
 by these structures that make Swift more expressive and powerful than many other 
 programming languages.
  
 [
  55 
 ]",NA
The for…in Statement,"The following diagram illustrates how the for...in statement works:
  
  
 Most programming languages have a 
 for
  statement used to execute a code statement a certain 
 number of times. The preceding diagram illustrates how the for...in statement works. A 
 canonical example of a 
 for
  loop in C, similar to many other C-inspired languages, is the 
 following:
  
 for(int i=0; i<10; i++)
  
  printf(""i=%d\n"", i);
  
 [
  56 
 ]",NA
Iterating over Objects ,"Although the previous code example actually does iterate over 
 Int
  values, it's effectively 
 running a code block a specific number of times. More often, you'll use 
 for…in
  to iterate over a 
 collection of objects stored in your application.
  
 The most common method to iterate over a set of objects is to use the 
 for
  syntax, as in the 
 following example:
  
 let strings = [""First String"", ""Second String"", ""Third String"", ""Fourth 
 String""] 
  
 for obj in strings {
  
  
  print(obj) 
  
 }
  
 Using this syntax, the 
 print
  statement within the block is executed once for each object in the 
 strings
  array. Swift implicitly creates the constant variable 
 obj
  for use within the block.
  
 [
  57 
 ]",NA
Iterating over Array Objects with index ,"The preceding example iterates over the 
 strings
  array, providing each string to the execution 
 block in a local variable named 
 obj
 . Sometimes, the code may need to know the ordinal position 
 of the object being processed. This can be accomplished by using the Array 
 enumerated
  
 member function of the collection being iterated:
  
 for (index, text) in strings.enumerated() {
  
  
  print(""The object at index \(index) is \(text)"") 
 }",NA
The for Loop where Clause ,"The next feature of the 
 for
  loop we'll learn is using the 
 where
  clause to control which 
 iterations are processed.
  
 In the previous examples, the code always outputs all of the strings in the variable 
 strings
 . 
 We might want to only output strings meeting a certain test, for example, only strings 
 beginning with the letter 
 F:
  
 One way to accomplish this requirement would be to rewrite the 
 for
  loop as follows:
  
 let strings = [""First String"", ""Second String"", ""Third String"", ""Fourth 
 String""]
  
 for string in strings {
  
  
  if string.starts(with: ""F"") {
  
  
  
  print(string)
  
  
  } 
  
 }
  
 [
  58 
 ]",NA
The break Control Transfer Statement ,"Like most C-inspired languages, Swift supports the use of the 
 break
  control transfer 
 statement in 
 for
  loops.
  
 The 
 break
  statement has the effect of immediately transferring program flow to the statement 
 following the 
 for
  loop, effectively skipping the remaining portion of the current iteration, and 
 cancelling all remaining iterations.
  
 In the following example, the code within the 
 for
  loop tests whether the current iteration's 
 string begins with the letter 
 T
 . If so, the 
 for
  loop is immediately exited:
  
 let strings = [""First String"", ""Second String"", ""Third String"", ""Fourth 
 String""]
  
 for string in strings {
  
  
  if string.starts(with: ""T"") {
  
  
  
  break
  
  
  }
  
  
  print(string) 
  
 }",NA
The continue Control Transfer Statement ,"Swift also supports the use of the 
 continue
  control transfer statement in 
 for
  loops.
  
 The 
 continue
  statement has the effect of skipping the remaining portion of the current 
 iteration. Control then passes to the 
 top
  of the 
 for
  loop, where the next iteration proceeds (if 
 there is a next iteration available).
  
 [
  59 
 ]",NA
The while Loop,"Where the 
 for
  loop executes a code block a predetermined number of times, the 
 while 
 loop 
 continues executing a code block until a Boolean expression evaluates as 
 false
 . The preceding 
 diagram illustrates how the while loop works.
  
 The general syntax of the 
 while
  loop is as follows: 
 while {condition-list} {
  
  
  
  statements 
  
 }
  
 [
  61 
 ]",NA
The repeat…while Loop ,"Because it evaluates its condition(s) prior to the first iteration, a 
 while
  loop occasionally 
 won't meet your needs. If you won't know whether a 
 while
  loop should continue until after 
 the first iteration, use the 
 repeat…while
  variant.
  
 If you were developing a console application that should play a game until the user pressed 
 Enter
  without entering text, a 
 repeat…while
  loop would be the ideal solution. For example, the 
 following Swift command-line program effectively uses 
 repeat…while 
 where a 
 while
  loop 
 would be awkward:
  
 #!/usr/bin/swift
  
 func playGame() {
  
  
  print(""simulate gameplay"") 
  
 }
  
 repeat {
  
 [
  62 
 ]",NA
Activity C: Implementing Loops,"Loops and iteration are a core part of any computer program. Data is often stored in array and 
 collection data structures, and loops allow you to develop concise, well-organized code to 
 operate on them.
  
 Use an Xcode playground to practice using the looping flow control structures we have 
 covered in this section.
  
 1. Launch Xcode and create a new playground, then save it to your desktop with the 
  
 name 
 Loops.playground
 .
  
 2. Add the following declaration of a new array, which contains a list of Canadian 
  
 provinces:
  
 let provinces = [""Ontario"", ""Quebec"", ""Nova Scotia"",  ""New 
 Brunswick"", ""Manitoba"",  
  
  ""British Columbia"", ""Prince Edward Island"",   
 ""Saskatchewan"", ""Alberta"",  
  
  ""Newfoundland and Labrador"" ]
  
 3. Add the following 
 repeat…while
  loop to print each of the provinces to the 
  
 console:
  
 var i = 0 
  
 repeat {
  
  
  print(provinces[i])
  
  
  i += 1 
  
 } while i < provinces.count-1 
  
 print(""=============="")
  
 [
  63 
 ]",NA
Summary,"In this lesson, you've learned how to use Swift's key language:
  
 • 
  
 Assignment, arithmetic, and bitwise operators
  
 • 
  
 Comparison and range operators
  
 • 
  
 The Swift branching features: 
 if
  and 
 switch
  
 • 
  
 Loops: 
 for
 , 
 while
 , 
 repeat…while
  
 You now have the skills needed to develop robust applications using Swift's powerful and 
 expressive language syntax. In the next lesson, you'll learn the skills to develop functions and 
 classes to organize your code. You will also explore and use error handling to efficiently handle 
 unexpected errors in your programs.
  
 [
  65 
 ]",NA
"Functions, Classes, and Structs","In the previous two lessons, you learned the fundamentals of Swift syntax, data types, and 
 how to use variables to store and operate on data in a Swift program. Specifically, you learned 
 how to use fundamental Swift elements such as operators, control structures, variables, and 
 built-in data types. With knowledge of these language elements, you're already prepared to 
 create fully functional Swift programs.
  
 In this lesson, you'll build on these skills, and learn how to develop fully featured Swift 
 applications, catch unexpected errors, and begin using asynchronous programming 
 paradigms. You'll learn how to create your own data types, and create object-oriented 
 applications using classes and structs.
  
 All object-oriented programming languages provide the ability to build your own custom 
 classes. Classes increase the level of modularity in your application, and promote code reuse. 
 This lesson will cover the key skills you'll need to build robust, object-oriented applications 
 with Swift.",NA
Lesson Objectives,"By the end of this lesson, you will be able to do the following:
  
 • 
  
 Define and call Swift functions
  
 • 
  
 Explain how to pass functions as parameters and argument labels
  
 • 
  
 Implement exception handling with 
 do…catch
  and 
 guard
  
 • 
  
 Use object-oriented features such as struct and class",NA
Functions,"In the program structure section in 
 Lesson 1
 , we mentioned that functions are a key part of 
 Swift's structure, and are units of code that can accept parameters and can return values. In this 
 section, we'll dive into Swift functions, learning how to implement and call them in the course 
 of a Swift application.
  
 Before diving into Swift function syntax, we should summarize some key points about how 
 functions are used in Swift, and in modern software development generally:
  
 • 
  
 • 
  
 • 
  
 • 
  
 Functions are units of code that carry out some specific task.
  
 In terms of lines of code, functions should be short. How many lines of code is a 
 maximum for a function has been a topic of debate for decades. However, long 
 functions often do not satisfy the specific task definition.
  
 All things being equal, it's better to have a complex process broken into smaller 
 functions, rather than combined into a large, complex function.
  
 All things being equal, a function that references its parameters—but not global 
 variables—is more maintainable, less error-prone and more testable.",NA
Defining a Function,"For many developers new to Swift, its function declaration syntax may seem unfamiliar. 
 Swift's function syntax is probably most similar to Pascal, but also has ideas from C++, 
 Objective-C, and others. With some practice, Swift code will begin to feel elegant and 
 familiar.
  
 The basic syntax for a Swift function that accepts parameters is as follows:
  
 func functionName(parm1: Type1, parm2: Type2) -> ReturnType {
  
 The basic syntax for a Swift function that accepts no parameters is as follows:
  
 func functionName() -> ReturnType {
  
 The basic syntax for a Swift function that accepts no parameters and returns nothing is as 
 follows:
  
 func functionName() {
  
 [
  68 
 ]",NA
Argument Labels,"In the previous section, we created a function with a parameter named 
 array
 , which is the 
 parameter label we used when calling the function:
  
 printArray(array: strings)
  
 Swift supports optional argument labels for parameters, which will be familiar to 
 Objective-C programmers, and likely unfamiliar to others.
  
 [
  69 
 ]",NA
Excluding Argument Labels,"In addition to changing the calling reference for a function's parameters, argument labels can be 
 used to remove names for input parameters. Doing so can make functions 
 feel
  more like calling 
 C or Objective-C functions.
  
 For example, consider the following function:
  
 func addTwoInts(_ a: Int, _ b: Int) -> Int { 
 return x + y 
  
 }
  
 [
  70 
 ]",NA
Parameter Default Values,"Like many other C-inspired languages, you can provide parameter default values for any 
 parameter. When a default value is specified in the function definition, the function caller can 
 omit the parameter—and the default value will be substituted instead.
  
 The following function prints the temperature. It assumes the provided value is in 
 Centigrade units, if units are not specified:
  
 enum TemperatureUnits : String {
  
  case celcius = ""�{00B0}C""
  
  case fahrenheit = ""�{00B0}F""
  
 }
  
 func printTemperature(value: Double, units: TempUnits = .celcius) {
  
  print(""The temperature is \(value)\(units.rawValue)"")
  
 }
  
 Because a default value is provided for units, we can omit the units when calling the 
 function:
  
 printTemperature(value: 17.5) // The temperature is 17.5°C
  
 [
  71 
 ]",NA
Activity A: Implementing a Function,"In any programming language, functions are a core language element used to make programs 
 modular, readable, and maintainable, and virtually every program you write will use functions 
 extensively. Let's practice what you've learned about Swift functions.
  
 Use an Xcode playground to implement a function that uses a variety of parameter 
 techniques covered until now.
  
 1. Launch Xcode and create a new playground, then save it to your desktop with the 
  
 name 
 Implement a Function.playground
 . 
  
 2. Add the following function to the playground:
  
 func buildAddress(_ name: String, address: String, city: String, zipCode 
 postalCode: String, country: String? = ""USA"") -> String {
  
  
  return """"""
  
  
  
  \(name)
  
  
  
  \(address)
  
  
  
  \(city)
  
  
  
  \(postalCode)         \(country ?? """")
  
  """""" 
  
 }
  
 3. Call the function within the 
 print
  function twice, passing parameters as in the 
  
 following code:
  
 print(buildAddress(""John Doe"", address: ""5 Covington Square"", city: 
 ""Birmingham"", zipCode: ""01234"")) 
  
 print(""====="") 
  
 print(buildAddress(""John Doe"", address: ""5 Covington Square"", city: 
 ""Birmingham"", zipCode: ""01234"", country: nil))
  
 An example output is given here:
  
  
  John Doe
  
  
  5 Covington Square
  
  
  Birmingham
  
  
  01234
  
  
  USA 
  
 =====
  
  
  John Doe
  
  
  5 Covington Square
  
  
  Birmingham
  
 [
  72 
 ]",NA
Returning Values from Functions,"Returning values from functions is largely consistent with C-inspired programming languages 
 you've probably used in the past. When processing is finished, a function simply uses the 
 return
  
 keyword to return a value to the caller. In the previous function example, we concatenated two 
 String variables, and returned the result using the 
 return
  keyword.
  
 The following are some Swift-specific notes regarding returning values from functions:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The value returned from the function must exactly match the return data type 
 specified in the function definition. To avoid compile-time errors, convert or cast 
 values that do not exactly match the return data type.
  
 It is allowed in Swift to use the 
 return
  keyword anywhere in the function. You can 
 return from more than one place in the function, when appropriate (such as in a 
 guard
  
 statement, which we'll cover shortly).
  
 To return from a function that does not specify a return value, simply use the 
 return
  keyword by itself.
  
 When a function returns no value, the 
 return
  statement before the function's 
 closing brace is optional.
  
 If a return value type is listed in the function definition, you must return a value of 
 that type from every code path within the function. Failure to do so will generate a 
 compiler error.
  
 While Swift functions can return only one value, that value can be a tuple, which can 
 embed multiple other values together. For example, to return the three integers 2, 4, 
 and 6 from a function, we can do the following:
  
 return (2, 4, 6)
  
 Swift can also return complex and custom types from functions. For example, your functions 
 can return instances of structures, instances of classes, and references to other functions. So, 
 while returning a single value may seem limiting, Swift actually provides tremendous 
 flexibility in its function return features.
  
 [
  73 
 ]",NA
Using @discardableResult ,"The Swift compiler will generate a warning if you call a function that returns a result but do not 
 use or assign that result in your code. For example, consider the following function: 
  
 func 
 addTwoInts(_ a: Int, _ b: Int) -> Int {
  
  
  return x + y 
  
  
 } 
  
 Suppose we had called it with this line of code: 
  
  
 addTwoInts(4, 5)   // return is ""discarded"" 
  
 The Swift compiler doesn't understand why we would call a function that returns a value but 
 not use that value. While not an error, it will generate a compile-time warning.
  
 There are times when you may implement a function that returns a value which may not be 
 important to the calling program. This is especially true when developing frameworks for use 
 by other applications—where you provide functionality that the consumer of the framework 
 may not feel is important to them.
  
 For example, a 
 log()
  function may return a Bool indicating how many characters of data were 
 written to the log—even if the callers don't consider this information interesting: 
  
 func 
 log(_ message: String) -> Int 
  
 Suppose the caller calls this function without using the Int return value: 
  
  
 log(""app started!"") 
  
 The compiler will generate the following warning: 
  
  
 Result of 'log(message:) is unused 
  
 To suppress the warning, simply add the 
 @discardableResult
  function attribute with the 
 declaration: 
  
  
 @disdcardableResult func log(_ message: String) -> Int 
  
 Now, knowing that you expect callers might disregard the return value, the Swift compiler will 
 no longer issue a warning at the point of the function call.
  
 [
  74 
 ]",NA
Function Attributes,"In the previous section, we used the function attribute 
 discardableResult
  to provide additional 
 information to the Swift compiler about the usage of a function we declared. In that case, the 
 discardableResult
  attribute informs the compiler that we expect callers of a function may ignore 
 the value returned from the function.
  
 You may encounter and use other function attributes in the course of your Swift 
  
 programming. The following are some of the more common function attributes:
  
 Name
  
 Description
  
 objc
  
 Used to generate Objective-C calling 
  
 wrappers. Used when a Swift function you 
 write should also be callable from an 
 Objective-C module.
  
 nonobjc
  
 Suppresses the generation of Objective-C 
 compatibility wrappers where it otherwise 
 would be created. Typically used to resolve 
 circular references that occasionally occur 
 between Swift and Objective-C modules.
  
 available
  
 Informs the compiler which OS versions, Swift 
 versions, or platforms are required for a 
 function to be called.
  
 discardableResult
  
 The return value may be ignored by function 
 callers without generating a compiler 
  
 warning message.
  
 IBAction
  
 Marks a function as a call point that can be 
 connected to an Interface Builder design file.
  
 [
  75 
 ]",NA
Variadic Parameters,"Swift supports functions with variadic parameters—these are named parameters that 
 accept 
 more than one value of the same type
 .
  
 For example, we could write a function to make a sentence containing a variable number of 
 words:
  
 import Foundation 
  
 func makeSentence1(_ words: String...) -> String {
  
  var sentence = """"
  
  
  for word in words {
  
  
  
  sentence += ""\(word) ""
  
  
  }
  
  return ""\(sentence.trimmingCharacters(in: ["" ""]))."" 
  
 } 
  
 let sentence1 = makeSentence1(""Hello"", ""World"", ""And"", ""Universe"")
  
 In this example, the 
 makeSentence1
  function will accept any number of words as input, and 
 then uses the 
 for…in
  loop to combine them into a sentence.
  
 Because Swift's array features are quite powerful, and declaring an ad hoc array of values of the 
 same type is quite easy, you might also approach variadic parameters in the following way:
  
 func makeSentence2(_ words: [String]) -> String {
  
  var sentence = """"
  
  
  for word in words {
  
  
  
  sentence += ""\(word) ""
  
  
  }
  
  return ""\(sentence.trimmingCharacters(in: ["" ""])).""
  
 [
  76 
 ]",NA
inout Parameters,"In each example so far, when we've written a function that provided values back to the point of 
 function call, we've used function return to do so. Using the 
 return
  statement to return a new 
 value to a function caller is the most common approach, and the approach you should use by 
 default.
  
 However, using 
 return
  to send data back to the function's caller returns a new value. In some 
 cases, it may be desirable to modify variables that are 
 owned
  by the caller—rather than 
 return new values. Swift provides 
 inout
  parameters as a way to accomplish this.
  
 Consider the following function, which swaps two Int values without 
 inout
  parameters:
  
 func swapValues1(_ a: Int, _ b: Int) -> (Int, Int) {
  
  return (b, a) 
  
 } 
  
 var a = 3 
  
 var b = 2
  
 let (a1,b1) = swapValues1(a, b)
  
 a = a1 
  
 b = b1
  
 print(""\(a), \(b)"") // 2, 3
  
 The parameters 
 a
  and 
 b
  are read-only within the function, and 
 swapValues
  cannot change 
 them. Instead, the function allocates a new tuple and returns it with the values in a swapped 
 order. The caller assigns these new values into the tuple (
 a1
 , 
 b1
 ). The caller must then 
 reassign the values of 
 a
  and 
 b
  to achieve the desired result.
  
 [
  77 
 ]",NA
Recursion,"Like many modern programming languages, Swift supports recursive function calls. 
  
 Recursion is simply the ability for a function to call itself from within its own body. Most 
 canonical use cases for recursion come from computer science, for example, sorting 
 algorithms. However, even if you're an end user app developer, there may be times when 
 recursion will make your code more concise and efficient.
  
 The following function uses recursion to calculate the mathematical factorial:
  
 func factorialWithRecursion(n: Int) -> Int {
  
  
  return n == 0 ? 1 : n * factorialWithRecursion(n: n-1) 
 }
  
 The following line calls the recursive function, assigning the result to a variable named 
 factorial2
 :
  
 let factorial2 = factorialWithRecursion(n: 6) // 720
  
 [
  78 
 ]",NA
Functions as Parameters,"Many languages, including Swift, have the ability to pass in functions by reference, which can 
 then be called from within the called function. In many languages, the function passed as a 
 parameter is referred to as a callback function, since it has the effect of allowing a function to 
 call back to the caller's code to perform some action after the function has done what was asked 
 of it.
  
 In the following example, let's rewrite the 
 makeSentence
  function with a version that 
 passes in a callback function as a parameter:
  
 import Foundation 
  
 func makeSentence3(_ words: [String], thenPrint: (String) -> Void) 
 {
  
  var sentence = """"
  
  
  for word in words {
  
  
  
  sentence += ""\(word) ""
  
  
  }
  
  
  thenPrint(""\(sentence.trimmingCharacters(in: ["" ""]))."") 
  
 }
  
 func printSentence(_ sentence: String) 
 {
  
  print(sentence) 
  
 }
  
 makeSentence3([""Hello"", ""World"", ""and"", ""Universe""], thenPrint: 
 printSentence(_:))
  
 The output of this code is identical to 
 makeSentence1
  and 
 makeSentence2
  that we saw earlier.
  
 In the 
 function as parameter
  version 3, the 
 makeSentence3
  function has no knowledge of 
 how the printing will be done. It simply calls the function it's provided through the 
 thenPrint
  parameter, and calls it when the sentence is finished.
  
 The function as parameter technique is commonly used in scenarios where there may be more 
 than one predefined alternative ending for a program flow. In the preceding example, we could 
 have one 
 printSentence
  routine that printed to the console, a second that posted the result to a 
 web service, and a third that displayed a message box.
  
 Functions as parameters are very powerful and flexible, and are commonly used in Swift 
 programming. Next, we'll learn about a similar—and even more commonly used variant of this 
 technique: 
 closures
 .
  
 [
  79 
 ]",NA
Closures,"In the previous section, you learned how to pass a named function into another function, 
 allowing the latter to call the former at the appropriate time.
  
 Closures are another way to pass code to a function, which it can then call later. In the case of 
 closures, however, we're passing a block of code that can be called from within the function.
  
 The two approaches are very similar—and to some extent, interchangeable. In both cases, the 
 called function will run a block of code using the name specified by its own parameter name. 
 A closure is primarily different in that a function as parameter 
 has a name
  in the caller's 
 scope, while a closure is an 
 unnamed
  block of code.
  
 Closures in Swift are the most common approach to providing code to execute after 
 asynchronous processing has completed. The following function uses a closure to download 
 data from the web. You'll fully implement this solution in the following activity:
  
 func doWebRequest(closure: @escaping (_ webSiteContent: String?) -> Void) {
  
  let url = URL(string: ""https://www.packtpub.com"")!
  
  let urlRequest = URLRequest(url: url)
  
  let session = URLSession(configuration: URLSessionConfiguration.
  
 default)
  
  let task = session.dataTask(with: urlRequest) {
  
  
  (data, response, error) in
  
  
  let content = String(data: data!, encoding: .utf8)
  
  closure(content)
  
  }
  
  task.resume()
  
  }
  
 This ends our look at functions. In this section, we took a deep dive into how Swift 
 implements functions and the importance of functions in developing virtually any 
 application in Swift.
  
 [
  80 
 ]",NA
Creating a Function to Receive Content from an ,NA,NA
Asynchronous Web Service Call ,"For application developers who use any type of web service, processing the results of 
 asynchronous web service requests will be a daily requirement. Let's apply what you've 
 learned about writing functions to implement real-world web service requests:
  
 1. Launch Xcode, and open the start project named 
 Functions - Starter. xcodeproj
 .
  
 2. Add the following function to the 
 ViewController.swift
  file before the closing 
  
 brace 
 of the 
 ViewController
  class:
  
 func doWebRequest() -> String {
  
  
  var webPageContent = ""No data yet!""
  
  let url = URL(string: ""https://www.packtpub.com"")!
  
  let urlRequest = URLRequest(url: url)
  
  let session = URLSession(
  
  
  configuration: URLSessionConfiguration.default)
  
  let task = session.dataTask(with: urlRequest) {
  
  (data, response, error) in
  
  webPageContent = String(data: data!, encoding: .utf8)!
  
  }
  
  task.resume()
  
  
  return webPageContent 
  
 }
  
 3. Change the start project's 
 startButtonTapped
  method to contain the following 
  
 body:
  
  @IBAction func startButtonTapped(_ sender: UIButton) { 
 self.updateTextView(doWebRequest())
  
  }
  
 4. Run the application with a simulator, press the 
 Start Web Request
  button, and 
  
 observe the output in the 
 TextView
  underneath the button.
  
 °
  
 °
  
 What happened? Why didn't that work?
  
 The 
 doWebRequest
  function, as written, doesn't wait for the web request to 
 complete before returning the 
 webPageContent
  String variable.
  
 [
  81 
 ]",NA
Error Handling,"We ended the last section by examining some sample code after it had been made 
  
 production-quality by adding correct error handling techniques. In this section, we'll dig 
  
 into the most common Swift error handling techniques, which will help ensure all the code 
  
 you develop in Swift will be robust and of high quality.
  
 Swift supports many of the same error handling techniques available in other object-
  
 oriented languages, such as C++, Java, and C#. Functions—either your own or standard 
  
 library functions—often return error codes as integers, error types, and Boolean variables. 
  
 In addition, Swift provides exception handling using the 
 do…catch
  construction, which is 
 functionally equivalent to the 
 try…catch
  construction used in many other languages.",NA
The do…catch Statement,"Most modern languages have exception handling features that allow code to throw 
  
 exceptions from an inner scope that can be caught in an outer scope. In Swift, this pattern is 
 implemented using the 
 do…catch
  structure.
  
 You'll very often use the Swift 
 do…catch
  structure when calling underlying Apple frameworks 
 to do data processing or file access work on your behalf. Catching exceptions 
  
 can help 
 bubble up
  highly detailed error information to your code.
  
 The following code declares a block that calls a function 
 decode
 , which may throw an 
 exception of type 
 Error
 :
  
 do {
  
  let userObject = try decode()
  
  print(userObject.name)
  
 } catch let error {
  
  print(error)
  
 }
  
 The important thing to note is that the code in between 
 do
  and 
 catch
  doesn't explicitly check for 
 an error. It simply instructs the 
 decode
  function to try to complete successfully. In the event 
 that 
 decode
  encounters an error, the remainder of the 
 do
  block will be skipped and the 
 catch
  
 block will receive the thrown 
 Error
  object, assigning it to the local variable 
 error
 .
  
 [
  83 
 ]",NA
Multiple catch Blocks,"In practice, a function that throws an exception may throw one of several more specific 
 exceptions, depending on what went wrong.
  
 The 
 do…catch
  construction allows you to catch more than one exception type. This works 
 almost identically to constructing a 
 switch
  statement with multiple case code blocks.
  
 Multiple 
 catch
  blocks provide the program with more specific information about the cause of 
 the decoding error, if available, for example:
  
 func decodeWithException() {
  
  if let data = jsonText.data(using: String.Encoding.utf8) {
   
  let decoder = JSONDecoder()
  
  do {
  
  
  let userObject = try decoder.decode(UserInfo.self,  
  
  
 from: data)
  
  
  print(""User decoded form JSON: \(userObject)"")
  
  } catch let DecodingError.typeMismatch(_, context) {
  
  
  print(""Type Mismatch Error: \(context.debugDescription)"") 
 } catch let DecodingError.dataCorrupted(context) {
  
  
  print(""Decoding Error: \(context.debugDescription)"") } 
 catch let error {
  
  
  print(error.localizedDescription)
  
  }
  
   
  print(""program always continues from this point."") 
 } 
  
 }
  
 [
  84 
 ]",NA
Using do without catch,"What if you didn't want to catch an exception, but wanted your program to continue even 
  
 when an exception is thrown?
  
 By using the 
 try?
  keyword (that is, 
 try
  with a question mark after it), we can ask Swift to try to 
 run code that may throw an exception, and return the result as an optional variable. 
  
 In this case, if an exception is thrown, the returned optional will be 
 nil
 ; if no exception is 
 thrown, the optional will contain the value the function would normally return, for 
  
 example:
  
 do {
  
  let userObject = try? decode()
  
  print(userObject?.name)
  
 }
  
 In this case, if the 
 decode
  function throws an exception, the 
 userObject
  optional will be 
 nil
 , and 
 the 
 print(userObject.name)
  line will not be executed. Because the action taken if an exception 
 is thrown is to assign 
 nil
  to the variable on the left-hand side of the equal sign, it's no longer 
 necessary to wrap the 
 decode
  call in the 
 do…catch
  block.",NA
The guard Statement,"The 
 guard
  statement is most commonly used at the top of a function body to validate that the 
 data the function will use to complete its task is in an expected state. In this sense, the 
 guard
  
 statement acts as a guard at the gate—checking the contents of inputs to the function before 
 they're allowed in.
  
 [
  85 
 ]",NA
Activity B: Exception Handling,"Exception handling, as the name implies, is an error handling technique that enables you to let 
 the Swift compiler know what errors you expect, and provide a way to 
 listen
  for them if they 
 occur while your program is running. We'll now apply exception handling in one of the most 
 common use cases for application developers—parsing data structures from JSON into 
 application data structures.
  
 Use an Xcode playground to practice catching an exception while parsing a JSON string into a 
 custom data structure—a very common task in any application development work that 
 involves integration with web services.
  
 1. Launch Xcode and create a new playground, then save it to your desktop with the 
  
 name 
 ExceptionHandling.playground
 .
  
 2. Add the following import to the top of the playground file:
  
 import Foundation
  
 3. Add the following code to define a data structure that holds basic user information 
  
 for an application:
  
  struct UserInfo : Codable {
  
  var name: String
  
  var email: String
  
  var userId: String
  
  }
  
 [
  87 
 ]",NA
Object-Oriented Features,"Throughout the past couple of lessons, we've been learning how to use Swift syntax, 
 variables, functions, and control flow structures to develop the building blocks of Swift 
 applications. In the final section of this lesson, we'll learn how to pull all those language 
 components together into Swift's object-oriented classes and structures—the high-level 
 building blocks of most professional Swift applications.
  
 [
  88 
 ]",NA
Object-Oriented Principles,"Swift is an object-oriented programming language, and enables the core principles of object-
 oriented programming. Generally speaking, in object-oriented programming, variables, 
 functions and data structures that implement a functional unit of your program are combined 
 into an 
 object
  that exists within its own namespace, and is accessed by other objects through 
 filtered, publicly exposed interfaces.
  
 Using Swift, instances are created using both 
 structs
  and 
 classes
 . Structs and classes support 
 encapsulation and abstraction, though only classes support inheritance. Both object types—
 structs and classes—are frequently used in Swift, and neither is 
 better
  than the other for all use 
 cases.",NA
Classes Versus Structs,"Virtually all object-oriented languages are based on the concept of organizing units of code into 
 classes that perform a very specific set of actions on a specific set of data.",NA
Illustration,"A 
 class
  can be thought of as a pattern, such as one a clothes factory might place over a bolt of 
 fabric to cut a new shirt. The pattern (class) has all the dimensions and notations that describe 
 to the tailor what shape the shirt will take. The tailor can use the pattern to create as many 
 shirts as they need—each one perfectly formed by placing the pattern on the raw fabric and 
 cutting around the pattern. Here, the tailor is the Swift runtime, the pattern is the class (or 
 struct) designed by the programmer, and the finished shirt is an object generated by the Swift 
 runtime environment.
  
 While this section isn't a comprehensive tutorial on object-oriented programming, some 
 general guidelines for selecting between classes and structs are the following:
  
 • 
  
 • 
  
 • 
  
 Structs are 
 value types
 , which are always copied when passed between objects or 
 assigned to variables. This makes them ideal to use when creating objects that are 
 primarily used to store data structures (though structs can and do include functions 
 that operate on their data).
  
 Classes support inheritance, which makes them the only alternative when defining 
 objects that will serve as base classes or be derived from base classes.
  
 Classes, as reference types, are also a better choice when it's advantageous to pass an 
 object by reference, allowing its members to be directly modified by functions it's 
 passed to (this is somewhat similar to the 
 inout
  parameter distinction we learned 
 earlier in this lesson).
  
 [
  89 
 ]",NA
Defining Classes and Structures,"In this lesson, we'll focus on the syntax to define, instantiate, and use your own structs and 
 classes. These techniques are nearly the same for each object type.
  
 A class or struct is defined with the following syntax:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 The 
 struct
  or 
 class
  keyword defines a namespace for the class. This namespace is 
 prepended to any symbol definition within the scope of the struct or class when your 
 application is assembled.
  
 The definition of struct or class members is enclosed in braces ({…}).
  
 If a class or struct contains member variables that are not assigned default values 
 where defined, an initializer must be provided so the uninitialized member variables 
 can be assigned a value. For structs (but not for classes), the Swift compiler will 
 create an initializer for you.
  
 Within the definition braces, variables and functions can be added, according to the 
 techniques learned in the last couple of lessons.
  
 Classes, structs, and their enclosed methods and variables can be given specific 
 access levels, which control how visible they will be from outside modules. The 
 default access level is 
 Internal
 , which makes all elements visible to any code in the 
 same module.
  
 The following are declarations for a 
 Customer
  object—the first declared as a struct and the 
 second as a class:
  
 struct Customer {
  
  var name: String
  
  var customerNumber: String 
  
 }
  
 class Customer {
  
  var name: String
  
  var customerNumber: String 
  
 }
  
 Throughout the last couple of lessons, you've been using structs and classes, for example:
  
 • 
  
 • 
  
 The String type is a struct that contains many properties and functions—for example, 
 the 
 .count
  property we often used to count the characters contained in a string.
  
 We used the 
 JSONDecoder
  class to decode the JSON text in 
 Activity B
 .
  
 [
  90 
 ]",NA
Activity C: Creating a Customer Struct and Class,"To compare the differences (and similarities) between Swift classes and structs, it's useful to 
 implement the same data structure in both. This is exactly what we'll do now.
  
 Use an Xcode playground to practice how to create Swift structs and classes.
  
 1. Launch Xcode and create a new playground, then save it to your desktop with the 
  
 name 
 CustomerStructClass.playground
 .
  
 2. Add the following lines of code to declare a new 
 Customer
  struct:
  
 struct CustomerStruct { 
  
 }
  
 3. Below the closing brace of the struct definition, create a new variable of type 
 Customer
 . Congratulations! You've created a struct definition, and instantiated 
 your first custom object!
  
 var customer1 = CustomerStruct()
  
 4. Modify the code to the following, adding the enum 
 CustomerType
  and variable 
 type
  to 
 the struct. Then modify your code to print the current 
 customer.type
  to the debug 
 console:
  
 struct CustomerStruct {
  
  
  enum CustomerType: String {
  
  
  
  case gold = ""Gold Customer!""
  
  
  
  case silver = ""Silver Customer!""
  
  
  
  case unknown = ""Unknown customer type""
  
  }
  
  
  var type: CustomerType? 
  
 }
  
 var customer1 = CustomerStruct()
  
 print(customer1.type ?? ""invalid customer type"")
  
 [
  91 
 ]",NA
Summary,"In the last couple of lessons, you've learned all the key building blocks needed to build 
 feature-rich, robust Swift programs:
  
 • 
  
 • 
  
 • 
  
 In 
 Lesson 1
 , 
 Swift Basics
 , you learned key language basics: using variables, 
 optionals, data types, and essential Swift code syntax
  
 In 
 Lesson 2
 , 
 Swift Operators and Control Flow
 , you learned the fundamental 
 structures you need to build logic and express the core flow of your application: 
  
 control flow, looping structures, and the range of operators Swift supports
  
 In this lesson, you began taking your Swift skills to the next level by creating 
  
 functions, handling exceptions, and defining your own data types using struct and 
  
 class language features
  
 In the next couple of lessons, you'll continue to build your Swift knowledge by learning more 
 advanced language concepts, including the following:
  
 • 
  
 Using and extending Swift collections
  
 • 
  
 Swift's sophisticated and powerful Unicode String structure and protocols
  
 • 
  
 Using Swift's functional programming and lazy operations features",NA
Challenge,"We'll tie together a variety of Swift language techniques, giving you additional practice to 
 create structs, functions, data types, and optionals, and use flow control structures.
  
 To solidify your understanding of basic struct and class usage by practicing the creation of each 
 type of object.
  
 1. Launch Xcode, and create a new playground, then save it to your desktop with the 
  
 name 
 Activity 5 - Final Activity.playground
 .
  
 2. Add the following enum, which will be used to classify customers by gold, silver, and 
 platinum levels. Note that this enum has a 
 rawValue
  of type String, which we will use 
 while printing customer information:
  
 enum CustomerType:String {
  
  case silver = ""SILVER""
  
  case gold = ""GOLD""
  
  case platinum = ""PLATINUM""
  
 }
  
 [
  93 
 ]",NA
Collections,"In the previous lesson, we looked into building Swift functions, error handling, and 
 developing fully-featured Swift programs. We also briefly looked at a few OOP features.
  
 In this lesson, we will work extensively with Swift's collections, such as arrays, sets, and 
 dictionaries.
  
 The Swift Standard Library (
 https://developer.apple.com/documentation/swift
 ) is 
 automatically imported into all Swift code, and contains basic types such as 
 Int
 , 
 Double
 , 
 Bool
 , Optional, and more. It is primarily organized around protocols, because Swift is a 
 Protocol-Oriented language (
 https://developer.apple.com/videos/play/ 
 wwdc2015/408/
 ).
  
 The root protocol for collections, which they all inherit from, is 
 Sequence
 . All a type needs to 
 conform to it is the ability to provide one value at a time, until it is empty, at which point it will 
 output 
 nil
 . This simple requirement provides a long list of methods (
 https:// 
 developer.apple.com/documentation/swift/sequence#topics
 ), and lets you iterate 
 over the type with a 
 for…in
  loop:
  
 for element in somesequence {
  
  // do something with 'element'
  
 }
  
 Collection (
 https://developer.apple.com/documentation/swift/collection
 ) inherits 
 from 
 Sequence
 , and adds the ability to refer to a specific position in the collection with an 
 index. You can only go forwards from an index, until you reach the end. Unlike 
 Sequence
 , it 
 guarantees that you can iterate over it multiple times. In other words, it preserves its contents, 
 whereas a 
 Sequence
  may forget each value as soon as it has provided it:",NA
Lesson Objectives,"By the end of this lesson, you will be able to do the following:
  
 • 
  
 • 
  
 • 
  
 Implement the main collections in the Swift Standard Library: arrays, sets, and 
 dictionaries 
  
 Explain sequences, collections, and other useful protocols 
  
 Create extensions of the standard library, as well as new types
  
 [
  98 
 ]",NA
Arrays ,"An array is an ordered collection of elements of the same type, and they are used for pretty 
 much anything that requires storing things in a certain order, such as the contents of lists in 
 apps. It works like similar types in other languages.",NA
Working with Arrays ,"Follow these steps to work with arrays: 
  
  
 1. We can create an array like this: 
  
  
   
 let a = [0,1,2,3,4] // array literal 
  
  
  
 2. We can join two arrays like this: 
  
  
   
 var b = a + [5,6]   // join two arrays 
  
  
  
 3. We can have a repeated value like this: 
  
  
   
 let c = Array(repeating: 4.1, count: 3) // repeat one value 
  
  
 4. To create an array from any sequence, we can do this: 
  
  
   
 // create from any Sequence (a String is a Sequence of Character) 
  
   
 var d = Array(""The 
 ☀
  and 
 🌙
  "") 
  
  
  
 5. To append a value to an array, use this: 
  
  
   
 b.append(10) // append one element 
  
  
  
 6. To append an entire array, use this: 
  
  
   
 b += a // append an array 
  
  
   
 Another way to append an array is by using this: 
  
  
   
 b.append(contentsOf: a) // append an array 
  
  
  
 7. To count the length of an array, we can do this: 
  
  
   
 b.count // the length of the array
  
 [
  99 
 ]",NA
Index,"The index type of an Array is 
 Int
  (integer), and its 
 startIndex
  is always 0. Its 
 endIndex
  is the 
 same as the length of the array. You can think of an index as something that's pointing to the 
 space between elements, right before the element it refers to. Here is an array of characters:
  
 var characters = Array(""The 
 ☀
  and 
 🌙
 "")
  
  
 endIndex
  points to the position 
 after
  the end, so if you ever try to access an element at 
 endIndex
  with 
 characters[characters.endIndex]
  (or with any other invalid index), 
 your program will crash. If an array is empty, 
 startIndex
  and 
 endIndex
  are both 0.
  
 [
  101 
 ]",NA
Utilizing Common Operations with Index ,"Common operations which are used with index are shown here: 
  
  
 1. To read an element at a particular index, use this: 
  
  
   
 characters[2] // read element at index 2 (""e"") 
  
  
  
 2. To change the element at a particular index, use this: 
  
  
   
 characters[2] = ""a"" // change element at index 2 
  
  
  
 3. To remove and return an element at a particular index, use this: 
  
  
   
 let removed = characters.remove(at: 8) // remove and return element 
  
  
 4. To insert an element at a particular index, use this: 
  
  
   
 characters.insert(""i"", at: 7) // insert element 
  
  
  
 5. To insert a collection of elements at a particular index, use this: 
  
  
   
 characters.insert(contentsOf: ""t the"", at: 9) // insert collection of 
  
   
 elements 
  
  
  
 6. To print all of the characters, use this: 
  
  
   
 print(characters) 
  
  
   
 // [""T"", ""h"", ""a"", "" "", ""
 ☀
 "", "" "", ""a"", ""i"", ""n"", ""t"", "" "", ""t"", ""h"", 
  
   
 ""e"", "" "", "" 
 🌙
  ""]
  
  
 Many collections use their own custom index type instead of 
 Int
 , 
  
  
 and even those that use 
 Int
  do not necessarily have a 
 startIndex
  
 that is always 0. It is therefore recommended to always use an array's 
  
 startIndex
  instead of 0. This also makes the code clearer.
  
 [
  102 
 ]",NA
ArraySlice,"All sequences have a 
 SubSequence
 , a type which represents a subrange of its elements. The 
 Array.SubSequence
  is an ArraySlice:
  
  
 [
  103 
 ]",NA
Creating Slices ,"Slices can be created in different ways, as shown here: 
  
  
 1. To create a slice with the first three elements, use this: 
  
  
   
 characters.prefix(3) // the first three elements 
  
  
  
 2. To create a slice with all the elements before the first space, use this: 
  
  
   
 characters.prefix(while: {$0 != "" ""}) // all elements before the first 
  
   
 space 
  
  
  
 3. To create a slice with the last two elements, use this: 
  
  
   
 characters.suffix(2) // the last two elements 
  
  
  
 4. To create a slice with elements from 4, use this: 
  
  
   
 characters.suffix(from: 4) // elements from number 4 and out",NA
Creating Slices Using Range Operators ,"We will now see how to use range operators to create slices: 
  
  
 1. To create a slice from elements 2 to 4 inclusive, use this: 
  
  
   
 characters[2...4] // elements 2 to 4 inclusive 
  
  
  
 2. To create a slice from element 3 up to, but not including 6, use this: 
  
  
   
 characters[3..<6] // elements 3 up to, but not including 6 
  
  
  
 3. To create a slice from element 3 to the end, use this: 
  
  
   
 characters[3...] // from element 3 to the end 
  
  
  
 4. To create a slice from the beginning up to and including element 5, use this: 
  
  
  
 characters[...5] // from the beginning up to and including 5 
  
  
  
 5. To create a slice from the beginning up to but not including element 5, use this: 
  
  
  
 characters[..<5] // from the beginning up to, but not including 5 
 That 
 ends our look at arrays. Next, we'll work through an activity that solidifies our 
 understanding of arrays and its related concepts.
  
 [
  105 
 ]",NA
Activity A: Working with Arrays,"Many operations on arrays can be done far more efficiently if the array is sorted. We will add 
 methods that take advantage of this for insertion, finding the index of the first or last 
 occurrence of an element, and checking if the array contains an element.
  
 We will just add methods to an array in an extension, but ideally this should be its own type 
 with an internal array so that we can guarantee that it is always sorted. Check out 
 ole/SortedArray
  (
 https://github.com/ole/SortedArray
 ) for an example of this.
  
 To perform basic array operations such as, inserting elements into an array and searching an 
 element in an array.
  
 1. Open the 
 CollectionsExtra
  Xcode project, and go to 
 SortedArray.swift
 .
  
 2. Create an extension to Range to find the middle of it. This will be used with the 
  
 indices of the array:
  
 public extension Range where Bound == Int {
  
  
  /// The value in the middle of this range. Returns nil if the range is 
 empty.
  
  
  var middle: Int? {
  
   
  guard !isEmpty else { return nil }
  
   
  return lowerBound + count / 2
  
  
  } 
  
 }
  
 3. We will assume that the array has been sorted using the 
 <
  operator (ascending), and we 
 will assure that elements can be used with this operator by constraining the extension 
 to arrays with elements that adopt the 
 Comparable
  protocol. This also means they can 
 be used with 
 >
 , 
 ==
 , 
 !=
 , 
 >=
 , and 
 <=
 :
  
 extension Array where Element: Comparable {
  
 4. Next, we need to find the insertion point if we were to insert an element into the 
 sorted array. We can use this for insertion and checking if the array contains a 
 specific element. This is a standard binary search, implemented with recursion:
  
  
  /// The index to use if you were to insert this element into a sorted 
 array.
  
  ///
  
  /// - Parameters:
  
  ///   - element: The element to potentially insert.
  
  ///   - range: The range to search in.
  
  
  /// - Note: If the element already occurs once or more, the index to 
 one of those will be returned.
  
 [
  106 
 ]",NA
Sets,"A set is an unordered collection of unique elements. It can very efficiently add, remove, or 
 check if it contains a specific element (on average 
 O(1)
 , meaning it takes the same time 
 regardless of the size of the set), in contrast to an unsorted array, where these operations take 
 O(n)
  (the array may need to access and/or move most of its element).
  
 Sets can be used for tracking which part of a custom view should be hidden, like which parts of 
 an outline view are collapsed. When displaying the view, you would only show the children of 
 those nodes which are not in the 
 collapsed
  set. So, you are in a sense adding a Bool property to 
 types you do not control. Sets can also be used for removing duplicates; you just add a sequence 
 to an empty set and all duplicates will be gone.
  
 [
  109 
 ]",NA
Working with Sets,"Let's look at working with sets by following these steps:
  
 1. To create a set, we can do this:
  
 var numbers: Set = [0,1,2,3,10,2.75,-3,-3.125,-14]
  
 2. We can then print it like this:
  
 // order is not preserved 
  
 print(numbers) // [-3.125, 10.0, 2.75, 2.0, -3.0, 3.0, -14.0, 0.0, 1.0]
  
 3. To insert a value if nothing equal is already there, we can do this:
  
 // insert if nothing equal is already there 
 numbers.insert(4)
  
 4. To insert a value and replace it if something equal is already there, we can do this:
  
 // insert, and replace it if something equal is already there 
 numbers.update(with: 4)
  
 5. Here are some more common operations with sets:
  
 numbers.remove(4) 
  
 numbers.contains(3) 
  
 numbers.isEmpty
  
 for n in numbers {
  
  
  // ...
  
 }",NA
Combining Sets,"Have a look at the following code:
  
 extension Double {
  
  
  var isInteger: Bool { return self.truncatingRemainder(dividingBy: 1) == 0 
 } 
  
 }
  
 let negativenumbers = numbers.filter { $0 < 0 } 
  
 let positivenumbers = numbers.subtracting(negativenumbers.union([0]))
  
 let integers = numbers.filter { $0.isInteger }
  
 [
  112 
 ]",NA
Comparing Sets,"Have a look at the following code:
  
 // all of the following return ""true"" 
  
 numbers.isSuperset(of: negativeintegers) 
  
 integers.isSubset(of: numbers) 
  
 positivenumbers.isStrictSubset(of: numbers) 
  
 numbers.isStrictSuperset(of: negativenumbers) 
 negativenumbers.isDisjoint(with: positivenumbers)
  
 Set A is a 
 superset
  of set B if every member of B is also a member of A. This also makes B a 
 subset
  of A. These are 
 strict
  supersets/subsets if A contains at least one element that is not a 
 member of B. In other words: a strict superset or subset means that the two sets are not 
 equal. 
 Disjoint
  means the two sets have no elements in common.
  
 In this section, we have looked at sets in detail. Sets are useful in various situations, for 
 example, removing duplicates. We'll see this in an activity next.",NA
Activity B: Removing Duplicates from a Sequence,"The most common method of removing duplicates from a sequence is to just add the entire 
 sequence to a set, and then create a new sequence from the set. However, this might re-order 
 the remaining elements. Here, we will use filter to keep the original order, and use a set to keep 
 track of which values are already in the sequence.
  
 [
  113 
 ]",NA
Dictionaries,"A 
 Dictionary
  is an 
 unordered
  collection of mappings/associations from keys to values. 
  
 It is very similar to a Set and has the same performance, but stores a key/value pair, and 
 only the key has to be 
 Hashable
 . It can be used for storing preferences, or when you have a 
 group of named values where there are either too many or change too often to be 
 hardcoded. Then, you can use the names as keys:
  
  
 The full name is 
 Dictionary<Key, Value>
 , but it is more commonly written as 
 [Key: 
 Value]
 .
  
 Dictionary ignores the order in which values are added or removed, and may change them 
 arbitrarily, just like Set.
  
 [
  115 
 ]",NA
Working with Dictionaries ,"Now it's time to lay our hands on dictionaries. Follow these steps to get started: 
  
  
 1. To create a dictionary, we can do this: 
  
  
   
 var numbers = [0: ""zero"", 1: ""one"", 10: ""ten"", 100: ""one hundred""] 
  
  
 2. We can then print it like this: 
  
  
   
 print(numbers) // [100: ""one hundred"", 10: ""ten"", 0: ""zero"", 1: ""one""] 
  
  
 3. To add or change a value, we can do this: 
  
  
   
 // Add or change value 
  
  
   
 numbers[20] = ""twenty"" 
  
  
  
 4. The following lookup returns an optional: 
  
  
   
 // Lookup returns an optional 
  
  
   
 if let one = numbers[1] {
  
  
   
  
  // ...
  
  
 } 
  
  
 Or, you can use a default value if the key is not found: 
  
  
 // Or you can use a default value if the key is not found 
  
  
 let two = numbers[2, default: ""no sensible default""] 
  
 5. You can remove a value by setting it to 
 nil
 : 
  
  
 // Remove a value by setting it to nil 
  
  
 numbers[2] = nil 
  
 6. You can iterate over the contents of the dictionary like this: 
  
  
 // You can iterate over the contents (again: the order is not defined) 
  
 for (key, value) in numbers {
  
  
  
  // ...
  
  
 } 
  
 7. This is how we can have a collection of all of the keys of the dictionary: 
  
 // 
 A collection of all keys 
  
  
 numbers.keys 
  
 8. This is how we can have a collection of all of the values of the dictionary: 
  
 // 
 A collection of all values 
  
  
 numbers.values
  
 [
  116 
 ]",NA
Activity C: Using Dictionaries,"A 
 CountedSet
  allows you to add equal elements more than once, and keeps count of how 
 many of each element it contains. Naturally, it is very useful for counting things, such as how 
 many times a word appears in a text, without having to store each word more than once.
  
 To use an Xcode playground to develop a new 
 CountedSet
  type using a dictionary 
 internally.
  
 1. Open the 
 CollectionsExtra
  Xcode project we used earlier, and go to 
 CountedSet. 
 swift
 .
  
 2. Leave the commented-out code as is, and add this to the top of the file:
  
 public struct CountedSet<Element: Hashable> {
  
  typealias ElementsDictionary = [Element: Int]
  
  private var elements: ElementsDictionary
  
  public init() {
  
  elements = ElementsDictionary()
  
  }
  
 }
  
 We use a type alias here because 
 ElementsDictionary
  will be referred to several 
 times in the code.
  
 3. Add the following code below the initialiser:
  
 public mutating func insert(_ newelement: Element, count: Int = 1) {
  
  elements[newelement, default: 0] += count
  
 }
  
 When inserting, we first get the current count of the element (or 0 if the element is not 
 in the dictionary), then we add how many times the element should be inserted (1 by 
 default) to this and insert the new value into the dictionary. 
 +=
  here means this:
  
  elements[newelement] = elements[newelement, default: 0] + count
  
 [
  117 
 ]",NA
Summary,"In this lesson, we covered the three main collections in the Swift Standard Library: Array, Set, 
 and Dictionary; what they are; and how they can be used. We also learned about indices, 
 slices/subsequences, and some common protocols. We also implemented methods for 
 searching in sorted arrays, for removing duplicates from a sequence, and created the new 
 collection, 
 CountedSet
 .
  
 In the next lesson, we will explore Strings in detail.
  
 [
  120 
 ]",NA
Strings,"In the previous lesson, we worked with arrays, sets, and dictionaries, all of which are part of 
 Swift's collections. In this lesson, we will look at strings in detail.
  
 The wide variety of characters and emojis a modern app may encounter requires correct 
 handling of Unicode text. Luckily, Swift does this by default. However, this means we have to 
 treat strings in Swift a bit differently than most programming languages.",NA
Lesson Objectives,"By the end of this lesson, you will be able to:
  
 • 
  
 Explain why strings work the way they do in Swift
  
 • 
  
 Create and use strings and substrings
  
 • 
  
 Implement the various common operations you can do with strings",NA
String Fundamentals,"Before we get into how to use strings, we will cover why they are the way they are. For 
 developers coming from other languages, this is a very reasonable question to ask.",NA
Character,"We won't go into the details of Unicode, but there are several ways of viewing a piece of 
 Unicode text in Swift. This is done by using different collections:
  
 let string = ""The 
 ☀
  and 
 🌙
 "" 
  
 string.utf8.count // 19 
  
 string.utf16.count // 13 
  
 string.unicodeScalars.count // 12
  
  
 An element of UTF-8 is 1 byte, UTF-16 is 2 bytes, and a Unicode scalar is 
  
  
 4 bytes.
  
 In addition to everyone reporting a different number of symbols in the string, you may 
 have also noticed that they are all wrong. 
 String
  itself, however, has the right answer:
  
 string.count // 11
  
 This is because 
 String
  is an ordered collection of 
 Character
 . 
 Character
  represents what we 
 humans would consider 
 one
  symbol, regardless of how many bytes it consists of.
  
 The reason for the discrepancies is, of course, the two emojis:
  
 let moon = Character(""
 🌙
 "") 
  
 String(moon).utf8.count // 4 
  
 String(moon).utf16.count // 2 
  
 moon.unicodeScalars.count // 1
  
 let sun: Character = ""
 ☀
 "" 
  
 String(sun).utf8.count // 6 
  
 String(sun).utf16.count // 2 
  
 sun.unicodeScalars.count // 2
  
 Even a simple letter such as 
 é
  may surprise you:
  
 let accented_e: Character = ""é"" 
  
 String(accented_e).utf8.count // 2 
  
 String(accented_e).utf16.count // 1 
  
 accented_e.unicodeScalars.count // 1
  
 [
  122 
 ]",NA
Collection,"Let's see what kind of a collection 
 String
  is:
  
  
 [
  123 
 ]",NA
Index,"Just like arrays, strings have indices, which refer to the position of every single character. But 
 before we get into what the type of strings index is, we should cover what it is 
 not
 : an integer.
  
 The index type of an 
 array
  is an integer. Because every element takes up the same amount of 
 space, you can ask for the 500th element and it will multiply 500 with the byte size of an 
 element, add the memory address of the first element, and find the element at the resulting 
 address.
  
 If we ask a 
 string
  for the 500
 th
  character, it has to start with the first character, see how much 
 space it takes, move past it, see how much space the next character takes, and so on, and repeat 
 this 500 times.
  
 On StackOverflow and other places, you will often find code examples which add a new 
 subscript to 
 String
  with an integer parameter, allowing us to do something such as this:
  
 for i in 0..<string.count {
  
  let character = string[i]
  
  // ...
  
 }
  
 This is extremely inefficient. Consider what is actually happening here: the string has to 
 process the first character, then the first and second characters, then the first, second, and third 
 characters, and so on. For a string of merely 500 characters, it will have processed the first 
 character 500 times, the second one 499, and so on until it has processed characters 
 n(n+1)/2
  
 or 125,250 times, plus 500 to find the count.
  
 The following, however, will visit each character exactly once, and is much simpler:
  
 for character in string {
  
  // ...
  
 }
  
 [
  125 
 ]",NA
Working with String Index ,"The actual index type of 
 String
  is 
 String.Index
 . It's a custom type whose inner workings 
 we are blissfully unaware of. All operations on it are performed using the standard 
 Collection
  and 
 BidirectionalCollection
  methods on 
 String
 .
  
 1. Let's define a few indices:
  
 let alphabet = ""abcdefghijklmnopqrstuvwxyz""
  
 let b_index = alphabet.index(after: alphabet.startIndex) 
 let a_index = alphabet.index(before: b_index) 
  
 let g_index = alphabet.index(a_index, offsetBy: 6) 
  
 let e_index = alphabet.index(g_index, offsetBy: -2)
  
 2. We can also add a limit to the offset. We get 
 nil
  if the result goes beyond this limit:
  
 let no_index = alphabet.index(e_index, offsetBy: 30, limitedBy: 
 alphabet.endIndex)
  
 3. To find the index of the first occurrence of a character, we do the following. We get 
  
 nil
  if it is not found:
  
 let i = alphabet.index(of: ""z"")
  
 4. The number of positions one index is from another is found like this:
  
 let a_e_distance = alphabet.distance(from: a_index, to: e_index)",NA
Debugging,"Perhaps the biggest drawback of using this custom type instead of an integer comes up during 
 debugging, when we would like to see what it contains. If we just print an index to the console, 
 we get something like this:
  
 Swift.String.Index(_compoundOffset: 100, _cache: Swift.String.Index._Cache. 
 character(1))
  
 This contains exactly nothing of interest. If we add this extension in a unit test module, we get 
 something more useful:
  
 // use in unit tests 
  
 extension String.Index: CustomDebugStringConvertible {
  
  
  // The offset into a string's UTF-16 encoding for this index.
  
  
 public var debugDescription: String { return ""\(encodedOffset)"" } }
  
 [
  126 
 ]",NA
Activity A: All Indices of a Character,"The 
 String.index(of:)
  method finds the index of the first occurrence of a character in a string. 
 Create a method which finds all the indices of a character.
  
 To use an Xcode playground to find the indices of a character.
  
 1. Open the 
 StringsExtra
  Xcode project, and go to the 
 StringsExtra.swift
  file. 2. Enter the 
 following code:
  
 extension String {
  
 °The method definition is similar to the one for 
 index(of:)
 :
  
 public func indices(of character: Character) -> [Index] { 
 var result = [Index]()
  
  var i = startIndex
  
 °
  
 Make sure to not access anything at 
 endIndex
 , as it will crash. This check also 
 takes care of empty strings:
  
  while i < endIndex {
  
  if self[i] == character {
  
  
  result.append(i)
  
  }
  
 °Move to the next index, like this:
  
   
  i = index(after: i)
  
   
  }
  
  
  return result
  
  
  } 
  
 }
  
 This is the traditional way of implementing it, to show how to work directly with 
 indices. Later, we will learn a much simpler and concise way to do this.
  
 [
  127 
 ]",NA
Using Strings,"So far in this course, we have only covered the Swift Standard Library, but when it comes 
  
 to strings we must also include the Foundation framework, as it contains a lot of both basic 
  
 and advanced text functionality that is missing from the Swift Standard Library.
  
 Foundation is available on all Apple platforms and has been around for a long time (there is also 
 a version for other platforms, re-implemented in Swift; see: 
 https://github.com/ apple/swift-
 corelibs-foundation
 ). It is written in and for Objective-C, but a lot of its API has been updated to 
 be easier to work with from Swift. Not all of it has been though, 
  
 and as we'll see, you might run into some problems when converting Foundation types to 
  
 Swift types.
  
 Foundation's string type is 
 NSString
 , and it works directly with UTF-16 encoded text. It does 
 not know what the Character type is, and does not necessarily handle Unicode text correctly 
 like Swift does. 
 NSString
  can be used as Swift String and vice versa as they can share the same 
 underlying storage.
  
 It also has 
 CharacterSet
 , which, despite the name, is a set of 
 UnicodeScalar
 . It has several 
 useful predefined sets, like 
 CharacterSet.alphanumerics
 , 
 .whitespaces
 , 
 .decimalDigits
 , and 
 more. You can only use them if you're lucky enough to have characters consisting of only 
 one 
 UnicodeScalar
 :
  
 CharacterSet.alphanumerics.contains(character.unicodeScalars.first!)
  
 Foundation's range type is 
 NSRange
 , and it uses integers to refer to positions in an 
  
 NSString
 . It can do this efficiently because each element of 
 NSString
  takes up the same amount of 
 space. We can always convert a Swift Range to 
 NSRange
  with 
 NSRange(range, in: string)
 , but we 
 can't necessarily go the other way, as we will see later on.
  
 [
  128 
 ]",NA
Creating Strings,"Let's look at creating strings by following these steps:
  
 1. There are many ways of creating strings. You've already seen the string literal:
  
 let literal = ""string from literal""
  
 2. There are also multi-line literals:
  
 let multilineLiteral = """"""
  
  
  line 1
  
  
  line 2
  
   
  line 3 indented
  
  """"""
  
 The result is 
 ""line 1\nline 2\n\tline 3 indented\n""
 . The closing three quotes must be at 
 the beginning of the line (excluding indentation) and any indentation that precedes it 
 will be removed from the beginning of every line in the string.
  
 3. Use backslash to insert special characters like 
 \\
  (backslash), 
 \t
  (horizontal tab), 
 \n
  
 (line feed), 
 \r
  (carriage return), 
 \""
  (double quotation mark), and 
 \'
  (single quotation 
 mark).
  
 4. We can create characters directly from their hexadecimal Unicode code points, like 
  
 this:
  
 let blackDiamond = ""�{2666}"" // ♦
  
 let brokenHeart = ""�{1F494}"" // 
 💔
  
 5. To include variables in the text, we use string interpolation, like this:
  
 let array = [1,2,3] 
  
 let stringInterpolation = ""The array \(array) has \(array.count) items."" 
 // ""The array [1, 2, 3] has 3 items.""
  
 [
  129 
 ]",NA
Common Operations,"Follow these steps to look at how to implement common operations on a string:
  
 1. Many of the common sequences and collection methods are useful on strings too, as 
  
 shown here:
  
 let string = """"""
  
  
  Line 1
  
  
  line 2
  
  
  """""" 
  
 let range1 = ..<string.index(of: ""1"")!
  
 [
  130 
 ]",NA
Implementing Extra Text Operations on a String ,"Follow this step to implement extra text operations on a string:
  
 1. Open 
 Strings.playground
  on the 
 Common string operations
  page and see if you can 
 find more text operations on string, using autocomplete and the documentation 
 in Xcode.
  
 This section is focused on how we can use strings and the various operations on strings that are 
 allowed in Swift. Next, we'll look at substrings in detail.",NA
Activity B-1: All Ranges of a Substring,"There is already a method on String for finding the first range of a substring. This method will 
 find all of the ranges of a substring.
  
 To use an Xcode playground to create a method on string which finds all ranges of a 
 substring.
  
 1. Open the 
 StringsExtra
  Xcode project, and go to the StringsExtra.swift file. 2. Enter 
 the following code:
  
 import Foundation
  
 extension String {
  
 °The method has the same parameters as 
 String.range
 :
  
  public func allRanges(of aString: String,
  
  options: String.CompareOptions = [],
  
  range searchRange: Range<String.Index>? = nil, 
 locale: Locale? = nil) -> [Range<String.Index>] {
  
 °If no search range is given, we search the entire string:
  
  var searchRange = searchRange ?? startIndex..<endIndex 
 var ranges = [Range<String.Index>]()
  
 °
  
 while let
  is a very useful combination of loop and optionals. It continues until 
 self.range
  returns 
 nil
 :
  
  
  while let foundRange = self.range(of: aString, options: options, 
 range: searchRange, locale: locale) {
  
  
  
  ranges.append(foundRange)
  
 [
  133 
 ]",NA
"Activity B-2: Counting Words, Sentences, and ",NA,NA
Paragraphs,"Perhaps the most straightforward way of counting the number of words in a string is to count 
 the number of spaces and add one. But, even if you only have text using the Latin alphabet, this 
 will often be wrong (there could be two spaces in a row, and 
 doesn't
  is technically two words). 
 Foundation has 
 NSLinguisticTagger
 , which handles these things and other alphabets. Not all of 
 its APIs have been updated for Swift yet, so it can be a bit cumbersome to use, but the method 
 that we will use here is fairly straightforward.
  
 To use an Xcode playground to create a method on string which can count words, 
 sentences, and paragraphs.
  
 1. Open the 
 StringsExtra
  Xcode project, and go to the 
 StringsExtra.swift
  file. 2.  Enter the 
 following code:
  
 extension String {
  
 [
  134 
 ]",NA
Substring,"SubString is for strings like what ArraySlice is for arrays: a view of a part of a string, where its 
 startIndex
  and 
 endIndex
  are indices into the original string. It conforms to the same protocols as 
 String:
  
  
 [
  136 
 ]",NA
Creating Substrings,"Now it's time to create substrings. Follow these steps to do so:
  
 1. We can create substrings by passing a range of indices to a string subscript:
  
 string[from..<upTo] 
  
 string[from...upToAndIncluding]
  
 2. And we get a substring of the entire string with this little shortcut:
  
 string[...]
  
 3. The following methods return a substring and leave the original string intact: 
  
 let string = ""This is  a pretty 
 👍
  sentence""
  
 // a substring from the 2nd character and out 
  
 string.dropFirst() 
  
 // a substring from the 6th character and out 
  
 string.dropFirst(5) 
  
 // a substring from the first up to and including the second last 
 string.dropLast() 
  
 // a substring from the first up to the 9th last character 
  
 string.dropLast(9) 
  
 // a substring from the first space and out 
  
 string.drop(while: {$0 != "" ""})
  
 // the index of the first space, or the first character if there are no 
 spaces 
  
 let space_index = string.index(of: "" "") ?? string.startIndex
  
 [
  137 
 ]",NA
Parsing Strings ,"Follow these steps to parse strings:
  
 1. Go to the 
 Exercise - Parse
  page of the 
 Strings
  playground. Enter the code to turn this:
  
 let info = """"""
  
  title: Beginning Swift
  
  type: course
  
  year: 2018
  
  publisher: Packt Publishing
  
  topic: programming
  
  """"""
  
 [
  138 
 ]",NA
Converting NSRange to Range,"Earlier, we made the 
 countLinguisticTokens
  method for counting the number of words, 
 sentences, and paragraphs in a string. It would be nice if we could get hold of the actual words, 
 sentences, and paragraphs, too:
  
 func linguisticTokens(ofType unit: NSLinguisticTaggerUnit, options: 
 NSLinguisticTagger.Options = [.omitPunctuation, .omitWhitespace]) -> 
 [String] {
  
  
  let tagger = NSLinguisticTagger(tagSchemes: [.tokenType], options: 0)
  
  tagger.string = self
  
  
  let range = NSRange(startIndex..<endIndex, in: self)
  
  
  var result = [String]()
  
  
  tagger.enumerateTags(in: range, unit: unit, scheme: .tokenType, options: 
 options, using: { _, tokenRange, _ in
  
   
  let token = (self as NSString).substring(with: tokenRange)
  
   
  result.append(token)
  
  
  })
  
  
  return result 
  
 }
  
 The only changes are the return type and these two lines:
  
  let token = (self as NSString).substring(with: tokenRange) 
 result.append(token)
  
 tokenRange
  is of type 
 NSRange
 , so we can't use it directly on String, but have to cast 
 ourselves into 
 NSString
  first.
  
 [
  139 
 ]",NA
Activity C: CamelCase,"Such a method can be used to automatically format code or create a text service on the Mac.
  
 To use an Xcode playground to create a method on String, which turns it into one 
 CamelCased word, optionally with the first letter lowercased.
  
 1. Open the 
 StringsExtra
  Xcode project, and go to the 
 StringsExtra.swift
  file.
  
 2. Add this code to the bottom of the file:
  
 extension String {
  
 °
  
 First, we create a method which returns an array of ranges of all the words in 
 the string:
  
  public func wordRanges() -> [Range<String.Index>] {
  
  let options: NSLinguisticTagger.Options = [.omitPunctuation, 
  
 .omitWhitespace]
  
  var words = [Range<String.Index>]()
  
 °
  
 This method on String gives us Swift ranges (as opposed to the NSRanges of 
 the 
 linguisticTokens
  method we used previously). Unfortunately, it doesn't 
 provide sentences or paragraphs, but in this case words are all we need:
  
 [
  140 
 ]",NA
Summary,"In this lesson, we learned about strings in Swift, how they are and why, and how to use them. 
 We've also learned about string indices, substrings, and some things to look out for when 
 using strings with the Foundation framework. We have also added some useful extensions to 
 String.
  
 In the next lesson, we will take a brief look at functional programming and explore lazy 
 operations.
  
 [
  142 
 ]",NA
Functional Programming and ,NA,NA
Lazy Operations,"In the previous lesson, we looked at strings and substrings. In this lesson, we will take a brief 
 look at functional programming and learn what lazy operations are. We will end this lesson 
 with an important but often overlooked topic: writing Swifty code.
  
 Functional programming is a style of programming which tries to keep things simple by 
 avoiding state, especially mutable state, and using a relatively small set of highly versatile 
 functions/methods which take other functions as input. The Swift Standard Library contains 
 several of these. They often make the code shorter, simpler, and easier to read if you know 
 what they do. They can also free you from the burden of having to come up with names for 
 temporary variables. Even if you don't use them in your own code, it is important to know 
 how they work as a lot of Swift code out there uses them.",NA
Lesson Objectives,"By the end of this lesson, you will be able to:
  
 • 
  
 Explain functional programming
  
 • 
  
 Implement the 
 filter
 , 
 map
 /
 forEach
 , 
 flatMap
 , and 
 reduce
  methods
  
 • 
  
 Use lazy sequences to delay operations until they are needed
  
 • 
  
 Write proper 
 Swifty
  code",NA
Function Type,"Open 
 Functional.playground
  at the 
 Introduction
  page.
  
  
 First, let's reiterate what a function type is:
  
 var sum: (Int, Int) -> Int
  
 The type of 
 sum
  is a function that takes two 
 Int
  values and returns one 
 Int
  value. We can 
 assign both functions and closures to it, as they are essentially the same thing:
  
 func sumFunction(a: Int, b: Int) -> Int {
  
  
  return a + b 
  
 } 
  
 let sumClosure = {(a: Int, b: Int) in return a + b}
  
 sum = sumFunction 
  
 sum = sumClosure
  
 We can also assign an operator to it:
  
 sum = (+)
  
 This is because an operator is a function (the parentheses around the + operator are just to 
 signal that we want to use it as a function, not add things together right away). The 
 definition of the 
 +
  operator for 
 Int
  is:
  
 static func +(lhs: Int, rhs: Int) -> Int
  
 So, whenever a function has a parameter of a function type, we can supply an operator, as 
 long as the input and output match:
  
 func perform(operation: (Int, Int) -> Int, on a: Int, _ b: Int) -> Int {
  
  return operation(a,b) 
  
 }
  
 perform(operation: +, on: 1, 2)
  
 Initialisers can also be used as functions:
  
 extension Int {
  
  
  init(add a: Int, _ b: Int) {
  
   
  self.init(a + b)
  
 [
  144 
 ]",NA
Functional Methods,"Open 
 Functional.playground
  at the 
 Methods
  page.
  
  
  
 The following sections show different ways of performing the same tasks. 
  
  
 They say nothing about which version, if any, is better.",NA
filter,"The 
 filter
  method looks like this:
  
 func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]
  
 This is a simple method on 
 Sequence,
  which we have already used. The input function takes 
 an element of the sequence and returns either 
 false
  or 
 true
 . 
 filter
  returns an array of only 
 those elements for which the input function returns 
 true
 :
  
 let numbers = [-4,4,2,-8,0] 
  
 let negative =   numbers.filter {$0<0} // [-4, -8]
  
 [
  145 
 ]",NA
Using the filter Method,"Let's look at using the 
 filter
  method by following this step:
  
 1. In 
 Activity A
  of 
 Lesson 5
 , we implemented a method on String for finding the indices of all 
 occurrences of a character. Go to the 
  - filter
  page in 
 Functional. playground
  
 and replace the body of the method with one that uses 
 filter
 . Make sure the unit test 
 passes afterwards.
  
 Here's a hint: when introducing arrays in 
 Lesson 4
 , we mentioned how to get all the 
 indices of a collection.
  
 Here's the solution:
  
 return indices.filter { self[$0] == character }",NA
map,"map
  is a method often used on container types. For 
 Sequence
 , it looks like this:
  
 func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]
  
 Each element of the sequence is passed to the input function, and the outputs are returned in 
 an array. This is a straight one-to-one transformation, where the resulting array has the same 
 number of elements as the sequence.
  
 map
  is remarkably versatile. Once you know about it, you'll be seeing uses for it everywhere. 
 Here's how we can use it to perform mathematical operations on arrays of numbers:
  
 let numbers = [-4,4,2,-8,0]
  
 let squared = numbers.map {$0*$0} // [16, 16, 4, 64, 0]
  
 There is also a similar function on the sequence that doesn't return anything:
  
 func forEach(_ body: (Element) throws -> Void) rethrows
  
 This does the exact same thing as 
 map
 , except it doesn't return an array, because the input 
 function doesn't return anything. It avoids having to create and return an array of Void (even 
 Void takes up space in an array):
  
 squared.forEach { print($0) }
  
 [
  146 
 ]",NA
Using the map Function,"Now that we had a brief about the 
 map
  function, let's see how we can make use of it. Here are 
 the steps to do so:
  
 1. Go to the 
  - map
  page in 
 Functional.playground
 .
  
 2. Create an array with the number of characters of each word in 
 text
 .
  
 3. Edit the body of the 
 range(where predicate: (Element) throws -> Bool) 
 function to use the optional 
 map
  instead of 
 guard let
 .
  
 Solution 1:
  
 let wordLengths = text.split(separator: "" "").map {$0.count}
  
 Solution 2:
  
 return try index(where: predicate).map { start in
  
  let end = try self[start..<endIndex]
  
  .index(where: { try !predicate($0) }) ?? endIndex
  
  return start..<end
  
 }
  
 [
  147 
 ]",NA
flatMap,"What if the function you provide to 
 map
  returns an array, and you don't want to end up with 
 an array of arrays? The 
 flatMap
  method on 
 Sequence
  takes care of that:
  
 func flatMap<S:Sequence>(_ transform: (Element) throws -> S) rethrows -> 
 [S.Element]
  
 The input function takes in an element and returns a sequence of elements, possibly of another 
 type. 
 flatMap
  runs the input function on each of the original sequence's elements, joins the 
 resulting sequences together, and returns them in an array. You can think of it as first running a 
 normal 
 map
 , then flattening the resulting sequence of sequences into a normal sequence.
  
 Here's how you can use it to split up an array of ranges into a single array of bounds:
  
 let ranges = [0...2, 5...7, 10...11]
  
 let bounds = ranges.flatMap {[$0.lowerBound, $0.upperBound]}
  
 // [0, 2, 5, 7, 10, 11]
  
 There is also a slightly different method of the same name on 
 Sequence
 :
  
 func flatMap<U>(_ transform: (Element) throws -> U?) rethrows -> [U]
  
 Here, the input function returns an optional, even if the sequence does not contain optionals. 
 Every time the input function returns 
 nil
 , it is ignored. This is more like a combination of 
 map
  
 and then filtering out all 
 nil
  values. The method is misnamed, and will be renamed to 
 compactMap
  (
 https://github.com/apple/swift-evolution/blob/ 
 master/proposals/0187-introduce-filtermap.md
 ) in Swift 4.1:
  
 [""a"",""1"",""b"",""3""].flatMap(Int.init) // [1, 3]
  
 Optional has its own version of 
 flatMap
 :
  
 func flatMap<U>(_ transform: (Element) throws -> U?) rethrows -> U?
  
 If the optional is 
 nil
 , 
 flatMap
  returns 
 nil
 . If not, the value the optional contains is passed to 
 the input function, and the result is returned. Using this function instead of 
 map
  avoids getting 
 an optional of an optional in return:
  
 var stringOptional: String?
  
 ...
  
 let intOptional = stringOptional.flatMap(Int.init)
  
 [
  148 
 ]",NA
Using the flatMap Function,"Follow these steps to learn how to use the 
 flatMap
  function:
  
 1. Go to the 
  - flatMap
  page in 
 Functional.playground
 .
  
 2. Create the inverted array using one 
 flatMap
  instead of a 
 filter
  and a 
 map
 .
  
 3. Change the body of the 
 range(between:and:)
  function to use 
 flatMap
  and 
 map 
  
 instead of 
 guard let
 .
  
 Solution 1:
  
 let inverted = numbers.flatMap { nr in
  
  
 return nr == 0 ? [] : [1.0/Double(nr)] }
  
 Or:
  
 let inverted = numbers.flatMap { nr in
  
  
  return nr == 0 ? nil : 1.0/Double(nr) 
  
 }
  
 Solution 2:
  
 public func range(between fromElement: Element, and toElement: Element) 
 -> Range<Index>? {
  
  
  return index(of: fromElement)
  
   
  .flatMap { fromIndex in
  
    
  let start = index(after: fromIndex)
  
    
  return suffix(from: start).index(of: toElement)
  
     
  .map { toIndex in start..<toIndex }
  
   
  } 
  
 }
  
 Or if you want to go all the way:
  
 public func range(between fromElement: Element, and toElement: Element) 
 -> Range<Index>? {
  
  
  return index(of: fromElement)
  
   
  .map(index(after: ))
  
   
  .map(suffix(from: ))
  
   
  .flatMap { suffix in
  
    
  suffix.index(of: toElement)
  
     
  .map { suffix.startIndex..<$0 }
  
   
  } 
  
 }
  
 [
  149 
 ]",NA
reduce,"reduce
  is used to produce a single value from a sequence:
  
 func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, 
 Element) throws -> Result) rethrows -> Result
  
 It can be used to, for example, multiply all the numbers together:
  
 let multiplied = negative.reduce(1) { result, element in result * element }
  
 First, it calls the input function with 
 initialResult
  and the first element of the sequence. 
  
 The result is passed to the input function again, together with the next element of the sequence. 
 After going through the entire sequence, the last result from the input function is returned.
  
 There is another version where the result parameter to the input function is 
 inout
 , in other 
 words, mutable. The input function itself doesn't return anything:
  
 func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: 
 (inout Result, Self.Element) throws -> ()) rethrows -> Result
  
 Here is the previous example using this version:
  
 let multiplied2 = negative.reduce(into: 1) { result, element in result = 
 result * element }
  
 The mutable version is best for producing more complex values, such as arrays. It lets us 
 directly add to one array in place instead of having to create a new array for every run of the 
 input function.",NA
Using the reduce Function,"Now, follow the given step to implement the 
 reduce
  function:
  
 1. Go to the 
  - reduce
  page in 
 Functional.playground
 . Compute the average using 
  
 reduce
 .
  
 Here's the solution:
  
 let average = Double(numbers.reduce(0, +)) / Double(numbers.count)
  
 This is the end of our journey with functional programming. In this section, we described 
 functional programming and worked with four important functions: 
 filter
 , 
 map
 , 
 flatMap
 , and 
 reduce
 .
  
 [
  150 
 ]",NA
Activity A: Implementing Functional ,NA,NA
Programming,"We want to make the code clearer, more concise, and hopefully easier to read.
  
 To use an Xcode playground to make a part of the code in 
 CountedSet
  from 
 Lesson 4
 , 
 Collections
 , more 
 functional
 .
  
 1. Duplicate the 
 CollectionsExtra
  project from 
 Lesson 4
 , and name the duplicate 
 CollectionsExtraFunc
 .
  
 2. Open the new project in Xcode, and go to 
 CountedSet.swift
 .
  
 3. Go to the following method:
  
  public var count: Int {
  
  var result = 0
  
  for count in elements.values {
  
  
  result += count
  
  }
  
  return result
  
  }
  
 4. This is the archetypical use case for 
 reduce
 . Replace the body of the function with 
  
 this:
  
  return elements.values.reduce(0, +)
  
 Beautiful, isn't it?
  
 5. Next, go to the following function:
  
  public mutating func insert<S>(contentsOf other: S) 
 where S:Sequence, S.Element == Element {
  
  for newelement in other {
  
  
  insert(newelement)
  
  }
  
  }
  
 6. One option is to use 
 forEach
 :
  
  other.forEach({self.insert($0)})
  
 7. Preferably, we would use 
 other.forEach(insert)
  here but it leads to an error 
  
 message about 
 self
  being immutable, even though we are in a mutating method.
  
 There is a 
 merge
  (
 https://developer.apple.com/documentation/swift/
  
 [
  151 
 ]",NA
Lazy Operations,"All the sequences and methods we have looked at so far this lesson have been 
 eager
 , which 
 means they perform their operations immediately, and 
 filter
 , 
 map
 , and 
 flatMap
  return their 
 results in arrays. But sometimes, we may want to delay operations until they are needed.
  
 Say you have a very large array, and you want to first use 
 map
  and then perform other 
 operations. If done eagerly, 
 map
  will create a new array with the same number of elements 
 as the original one to store its results. But if we do it lazily, 
 map
  will return a 
 LazyMapSequence
 , which will perform each map operation directly when asked for, 
 without using any intermediate storage.
  
 Infinite sequences 
 must
  be handled lazily, as they obviously cannot be stored.
  
 [
  152 
 ]",NA
Lazy Sequences,"Have a look at the preceding diagram that talks of lazy sequences. A lazy sequence is one that 
 conforms to 
 LazySequenceProtocol
 . The original sequence itself may or may not work 
 lazily internally, but some further operations on the sequence are lazy, for example, 
 filter
 , 
 map
 , 
 flatMap
 , 
 drop(while:)
 , and 
 prefix(while:)
 .
  
  
 Open 
 Functional.playground
  at the 
 Lazy sequences
  page.
  
  
 To make a sequence lazy, just use the 
 lazy
  property:
  
 let array = [1,2,3,4]
  
 let lazyArray = array.lazy
  
 The actual type we get back depends on the type of the original sequence. For array, it is 
 La 
 zyRandomAccessCollection<Array<Element>>
 .
  
 [
  153 
 ]",NA
Sequence Internals,"Open 
 Functional.playground
  at the 
 Sequence internals
  page.
  
  
 The 
 Sequence
  protocol looks like this (from the Swift source code, slightly simplified; see 
 https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.
  
 swift
 ):
  
 public protocol Sequence {
  
  
  /// A type representing the sequence's elements.
  
  associatedtype Element
  
  /// A type that provides the sequence's iteration interface and 
 /// encapsulates its iteration state.
  
  
  associatedtype Iterator : IteratorProtocol where Iterator.Element == 
 Element
  
  
  /// Returns an iterator over the elements of this sequence.
  
  func makeIterator() -> Iterator 
  
 }
  
 This, of course, begs the question: so what is 
 IteratorProtocol
 ?
  
 public protocol IteratorProtocol {
  
  
  /// The type of element traversed by the iterator.
  
  associatedtype Element
  
  /// The next element in the underlying sequence, 
 /// if a next element exists; otherwise, `nil`. 
 mutating func next() -> Element?
  
 }
  
 Every time a sequence is used in a 
 for…in
  loop, or when other methods go through its 
 elements, it first returns an iterator from 
 makeIterator
 , which in turn provides one 
 element at a time from 
 next
 , until it is empty and returns 
 nil
 .
  
 [
  155 
 ]",NA
Creating Lazy Operations,"Open 
 Functional.playground
  at the 
 Lazy operations
  page.
  
  
 How do we create operations that work lazily? For more complex operations, including 
 those that use recursion, it is often best to create a new type which implements the 
 Sequence
  and 
 IteratorProtocol
  protocols. But for simpler tasks, there are two very 
 convenient functions the Standard Library provides.",NA
sequence(first:next:) ,"Here is the function:
  
 func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, 
 (T?, Bool)>
  
 This function creates the sequence 
 first
 , 
 next(first)
 , 
 next(previous element)
 , 
 next(previous element)
 , and so on, until 
 next
  returns 
 nil
  (or, if it's infinite, the 
 sequence will continue forever).
  
 It is very useful for following references:
  
 for view in sequence(first: someView, next: { $0.superview }) {
  
  // 
 someView, someView.superview, someView.superview.superview, ...
  
 }
  
 It is also useful for some mathematical sequences:
  
 let powersOf2 = sequence(first: 1) {
  
  
  let result = $0.multipliedReportingOverflow(by: 2)
  
  return result.overflow ? nil : result.partialValue 
 }",NA
sequence(state:next:) ,"Here is the function:
  
 func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) 
 -> UnfoldSequence<T, State>
  
 This creates a sequence by repeatedly passing mutable 
 State
  to the 
 next
  function. It is 
 useful when there are changing values that are different than the output.
  
 [
  156 
 ]",NA
Activity B: Implementing a Lazy Version of a ,NA,NA
Method,"We want to make the method use less memory, or be more efficient if we only need some of the 
 ranges.
  
 To use an Xcode playground to make a lazy version of the 
 allRanges
  method from 
 Lesson 5
 , 
 Strings
 .
  
 1. Duplicate the 
 StringsExtra
  project from 
 Lesson 4
 , and name the duplicate 
 StringsExtraLazy
 .
  
  
 If you did not finish the 
 StringsExtra
  project, you can use the project 
  
  
 provided for this lesson, and check out the 
 Activity_B_start_here
  
 branch in the Xcode Source Control Navigator (⌘
 2
 ).
  
 2. Open a new project, and go to 
 StringsExtra.swift
 .
  
 3. First, it would be nice if both the current and the lazy version of the method could be used 
 on both strings and substrings. To achieve this, we must move the current version from 
 String
  to 
 StringProtocol
  (we can do this because the method we use inside, 
 range(of:)
 , is also available on 
 StringProtocol
 ). At the top of the file, change the 
 line 
 extension String {
  to 
 extension StringProtocol {
 .
  
 4. We get an error message a couple of lines below, saying this:
  
 Cannot convert value of type 'Range<Self.Index>' to expected argument 
 type 'Range<String.Index>'
  
 This is because even though only String and Substring conform to 
 StringProtocol
 , 
 and they both use 
 String.Index
  as index type, this associated type has not been set on 
 StringProtocol
 . We need to constrain our extension:
  
 extension StringProtocol where Index == String.Index {
  
 [
  158 
 ]",NA
Swifty Code,"When learning a new programming language, you're not just learning syntax, built-in libraries, 
 tooling, terminology, formatting style, and so on. There is also a somewhat vaguely defined idea 
 of what constitutes 
 good code
 , a way of performing some tasks that fits well with the language 
 and has evolved together with it over time. In Swift, such code is often referred to as 
 Swifty
  
 code. This is in no way a well-defined term, and experts in the language may disagree on some 
 points. Here, we will only cover things where there seems to be a consensus. The list is by no 
 means exhaustive, and there are exceptions to many of these.
  
 [
  164 
 ]",NA
Naming ,"Names of types and protocols are in UpperCamelCase. Everything else is in 
 lowerCamelCase. This makes it easy to tell values and types apart.
  
 Try to name functions and their parameters so that they form English phrases when called. 
  
 So, instead of this: 
  
 x.insert(y, position: z) 
  
 x.subViews(color: y) 
  
 x.nounCapitalize() 
  
 Do this: 
  
 x.insert(y, at: z) 
  
 x.subViews(havingColor: y) 
  
 x.capitalizingNouns() 
  
 Functions returning Booleans should read well in an 
 if
  statement: 
  
 if x.isEmpty {...} 
  
 if line1.intersects(line2) {...} 
  
 Methods that are mutating or have other side effects should read like commands: 
 print(x), x.sort(), x.append(y) 
  
 If this isn't possible because the operation is best described by a noun, prepend 
 form 
 instead: 
  
 y.formUnion(z), c.formSuccessor(&i) 
  
 Append 
 ed
  or 
 ing
  to methods that return a new value instead of mutating:
  
 Mutating
  
 Nonmutating
  
 x.sort()
  
 z = x.sorted()
  
 x.append(y)
  
 z = x.appending(y)
  
 [
  165 
 ]",NA
Organizing Code,"Avoid free functions, and place them where they belong. A function that processes text should 
 be placed in an extension on 
 StringProtocol
  (so it can be used by both strings and 
 substrings). If the function doesn't take a value as input, make it static.
  
 Group methods and properties that belong together in one extension. For example, if you are 
 adding protocol conformance to a type, group everything that is required by that protocol 
 together in one extension.
  
 If you have a function that is only going to be used from one other function, place it inside that 
 function. This makes it clear as to why it exists.",NA
Miscellaneous,"Don't put semicolons at the end of lines. That is pointless in Swift. You can, however, use a 
 semicolon to write two statements on one line, but that is not something you should do very 
 often.
  
 Languages without optionals have various ways of signaling the absence of a value: 
 """"
  for 
 strings, 
 -1
  for positive integers, 
 null
  for objects, and so on. Swift, thankfully, only has one – 
 nil
 . Always use optionals if a value can be empty.
  
 Use 
 Int
  for most integers, even if you only need positive values or smaller values that can fit in 
 Int8, Int16, or Int32. Otherwise, you will have to do a lot of conversions since Swift does not do 
 this automatically, not even when it is guaranteed to be safe.
  
 Unless the order is significant, place a parameter taking a closure last in the function definition 
 so that it can be used with trailing closure syntax. Place parameters with default values second 
 to last.
  
 Put underscores in long numeric literals, so they are easier to read:
  
 1_000_000, 0.352_463
  
 [
  166 
 ]",NA
Writing Swifty Code ,"Finally, we're ready to write Swifty code. Here is the step to do so:
  
 1. Rewrite the following code to be more Swifty, using the guidelines mentioned 
  
 previously:
  
 /// An immutable entry in an error log.
  
 struct LogError {
  
  var header: String
  
  let errorMessage: String
  
  
  init(header: String = """", errorMessage: String) {
   
  self.header = header
  
   
  self.errorMessage = errorMessage;
  
   
  if header.isEmpty {
  
    
  self.header = "" ::Error::errorCode::""
  
   
  }
  
  
  } 
  
 }
  
 LogError(errorMessage: ""something bad"") 
  
 LogError(header: ""head"", errorMessage: ""something bad"")
  
 Here is the solution:
  
 /// An immutable entry in an error log.
  
 struct ErrorLogItem {
  
  let header: String
  
  let errorMessage: String
  
  init(errorMessage: String, header: String? = nil) { 
 // Only if empty strings are invalid as headers.
  
  precondition(header != """", ""A header cannot be empty."")
  
 [
  167 
 ]",NA
Summary,"In this lesson, we learned about the functional operations 
 filter
 , 
 map
 , 
 flatMap
 , and 
 reduce
 . 
 Then, we learned about lazy operations and a few ways of creating them. Finally, we learned 
 characteristics of good Swifty code.
  
 The last three lessons of this course have been focused on the Swift Standard Library. We began 
 with learning about the three main generic collections: Arrays, Sets, and Dictionaries, and 
 added some useful methods to them. We also created our own collection: 
 CountedSet
 . 
  
 Then, we learned about text handling in Swift and working with Foundation, and added 
 some useful String methods. We also looked at functional programming and lazy operations.
  
 This entire course is designed to be a thorough introduction to Swift for programmers who are 
 new to the language. We hope you have found it useful and welcome you as a fellow Swift 
 programmer.
  
 [
  168 
 ]",NA
Further Study,"Apple's own books on Swift programming (
 https://itunes.apple.com/no/book-
 series/swift-programming-series/id888896989?mt=11
 ) are very well-written and 
 highly recommended. So are the books from the no-longer-appropriately-named objc.io 
 (
 https://www.objc.io/books/
 ).",NA
Challenge,"For a final challenge, here is what you can do after the book. The Standard Library has methods 
 for splitting a string over a single character, or a function that takes a single character and 
 returns a Boolean. However, it doesn't have any methods for splitting a string over a substring, 
 or doing it lazily.
  
 Create a new method, which can be used on lazy strings and substrings, and takes a separator 
 (String) and optionally 
 String.CompareOptions
  and 
 Locale
 , and returns a lazy sequence of 
 the ranges between each occurrence of the separator in the original string/ substring.
  
 [
  169 
 ]",NA
Index,NA,NA
Symbols,"@discardableResul
 t 
 about  74 
  
 using  74
  
 branching 
  
 about  44 
  
 condition lists  46, 47 
  
 if statement  45 
  
 switch statement  49",NA
A,"argument labels 
  
 adding, to function  69 
  
 excluding, from function  70
  
 break keyword 
  
 about  50 
  
 using  50",NA
C,"arithmetic operators 
  
 remainder operator  38 
  
 standard arithmetic operators  37 
 unary minus operator  38
  
 arrays 
  
 about  99 
  
 ArraySlice  103 
  
 index  101 
  
 working with  99, 101, 106-109
  
 ArraySlice  103, 104
  
 assignment operator 
  
 about  37 
  
 compound assignment operator  38
  
 CamelCase 
  
 about  140 
  
 using  140, 141
  
 Character data type 
  
 about  25 
  
 Character literal, constructing  26 
 values, assigning  26
  
 classes 
  
 about  89 
  
 defining  90 
  
 versus, structs  89
  
 closed range operator  42
  
 closures  79, 80",NA
B ,"code
  
 converting, from if to switch  54, 55
  
 BidirectionalCollection  100 
 bitwise operators  41 
  
 Boolean data type  25
  
 comparison operators 
  
 about  38 
  
 equality  39 
  
 inequality  39
  
 Bool value  25 compound assignment operators  38
  
 conditional unwrapping  16, 17",NA
D,"data types, Swift 
  
 about  19 
  
 Boolean  25 
  
 Character  25 
  
 numeric data types  20 
 string  27 
  
 working with  28, 29
  
 dictionaries 
  
 about  115 
  
 using  117-120 
  
 working with  116, 117
  
 do…catch 
  
 about  83 
  
 implementing  83",NA
E,"endIndex  101
  
 enum 
  
 about  30 
  
 basic syntax  30 
  
 raw values  31 
  
 using  32, 33
  
 enumerations. 
 See
   enum; 
 See
   enum
  
 Equatable  110
  
 error handling 
  
 about  83 
  
 do…catch statement  83 
  
 do without catch, using  85 
 guard statement  85, 87
  
 multiple catch blocks  84
  
 exception handling  87, 88",NA
F,"fallthrough keyword  50
  
 filter method 
  
 about  145 
  
 using  146
  
 flatMap method 
  
 about  148 
  
 using  149
  
 force unwrapped variable  13
  
 force unwrapping  15
  
 for…in statement 
  
 about  56, 57 
  
 array objects with index, iterating over  58 
 break control transfer statement  59 
  
 continue control transfer statement  59 for 
 loop where clause  58 
  
 objects, iterating over  57
  
 functional methods 
  
 about  145 
  
 filter  145 
  
 flatMap  148 
  
 map  146 
  
 reduce  150
  
 functional programming 
  
 about  143 
  
 implementing  151, 152
  
 function attributes  75, 76
  
 functions 
  
 about  68 
  
 argument labels, adding  69, 70 
  
 argument labels, excluding  70, 71 as 
 parameters  79 
  
 basic syntax  68 
  
 closures  80 
  
 creating, for receiving content from 
 asynchronous web service call  81, 82
  
 [
  174 
 ]",NA
G,"guard statement 
  
 about  85 
  
 using  86, 87",NA
H,NA,NA
L,"lazy operations 
  
 about  152 
  
 creating  156 
  
 implementing  154 
  
 lazy sequence  152, 153 
  
 sequence functions  156, 157 
 Sequence internals  155
  
 lazy version, of method 
  
  
 implementing  158-162, 164
  
 logical operators  40
  
 loops 
  
 about  55 
  
 for…in statement  56, 57 
  
 implementing  63, 64 
  
 while loop  61
  
 half-open range operator  42",NA
M,"Hashable  110 
  
 Hello, World program  3, 4, 
 6",NA
I,"if statement 
  
  
 about  44, 45 
  
  
 implementing  46 
  
  
 implementing, with multiple conditions  46 
  
 optional unwrapping  47 
  
 index type, arrays 
  
  
 about  101 
  
  
 common operations, utilizing  102 
  
 indices of character, string 
  
  
 identifying  127 
  
 infer data type  8 
  
 inout parameters  77, 78
  
 map method 
  
 about  146 
  
 using  146, 147
  
 multiple catch blocks  84
  
 MutableCollection  100",NA
N,"nil-coalescing operator  41
  
 NSRange 
  
  
 converting, to Range  139, 140
  
 numeric data types 
  
 about  20 
  
 appropriate numeric data type, selecting  21 
 built-in numeric data types  20 
  
 floating-point numbers, assigning  21 
  
 floating-point numbers, declaring  21 
  
 Integer variables, assigning  21 
  
 Integer variables, declaring  21 
  
 Int on 64-bit platform, versus 32-bit patform  20 
 numeric literal grouping  22
  
 [
  175 
 ]",NA
O,"one-sided range operator  42
  
 optional 
  
 about  12, 13 
  
 conditional unwrapping  16, 17 
 declaring  13 
  
 force unwrapping  15 
  
 nil values  14 
  
 values, accessing  15 
  
 working with  14",NA
R,"RandomAccessCollection  101
  
 range operators 
  
 about  41 
  
 closed range operator  42 
  
 half open range operator  42 
 one-sided range operator  42
  
 RangeReplaceableCollection  100
  
 ranges, of 
 substring 
  
  
 finding  133
  
 recursion  78
  
 reduce method 
  
 about  150 
  
 using  150",NA
S,"SetAlgebra  110
  
 sets 
  
 about  109 
  
 combining  112 
  
 comparing  113 
  
 duplicates, removing from sequence  113, 114 
 working with  112
  
 slices 
  
 creating  105 
  
 creating, range operators used  105
  
 startIndex  101
  
 string 
  
 about  27, 121 
  
 Characters, extracting  28 
  
 common operations, implementing  131 
 concatenation  27 
  
 creating  129 
  
 indices of character, identifying  127 
 instantiating  27 
  
 length, obtaining  28 
  
 number of spaces, counting  134-136 
 ranges of substring, finding  133, 134 text 
 operations, implementing  133 
  
 using  128
  
 string fundamentals 
  
 about  121 
  
 character  122 
  
 collection  123, 124 
  
 debugging  126 
  
 index  125, 126
  
 String index 
  
  
 working with  126
  
 StringProtocol  137
  
 structs 
  
 about  89 
  
 defining  90
  
 substrings 
  
 about  136 
  
 creating  138 
  
 NSRange, converting to Range  139, 140 
 parsing  139
  
 Swift 
  
 about  1 
  
 basic language syntax  2, 3 
 branching  44 
  
 constants  7 
  
 data types  19 
  
 Hello, World program  3, 4, 6
  
 [
  176 
 ]",NA
T,"ternary conditional operator  
 40 try? keyword 
  
  
 using  85 
  
 tuples 
  
  
 about  10, 11 
  
  
 creating  12 
  
 type cast 
  
  
 force unwrapping  15 
  
 type inference  8 
  
 type-safe language  8",NA
U,UnfoldSequence  162,NA
V,"variable naming  9 
  
  
 variables. 
 See
   Swift variables; 
 See 
  
 Swift variables 
  
 variadic parameters  76",NA
W,"while loop 
  
 about  61 
  
 repeat…while loop  62, 63 
  
 syntax rules  62 
  
 using  62
  
 switch statement 
  
 about  49 
  
 break keyword  50 
  
 fallthrough keyword  50 
  
 multiple patterns, matching in single case  52 
  
 optionals, evaluating with  53 
  
 syntax rules  50
  
 [
  177 
 ]",NA
