Larger Text,Smaller Text,Symbol
Data,NA,NA
Structures,NA,NA
& Algorithms,NA,NA
in Swift,"By Kelvin Lau & Vincent Ngo
  
 2",NA
Data Structures & Algorithms in Swift,"Kelvin Lau & Vincent Ngo
  
 Copyright ©2018 Razeware LLC.",NA
Notice of Rights,"All rights reserved. No part of this book or corresponding materials 
 (such as text, images, or source code) may be reproduced or 
  
 distributed by any means without prior written permission of the 
 copyright owner.",NA
Notice of Liability,"This book and all corresponding materials (such as source code) are 
 provided on an “as is” basis, without warranty of any kind, express of 
 implied, including but not limited to the warranties of 
  
 merchantability, fitness for a particular purpose, and 
  
 noninfringement. In no event shall the authors or copyright holders be 
 liable for any claim, damages or other liability, whether in action of 
 contract, tort or otherwise, arising from, out of or in connection with the 
 software or the use of other dealing in the software.",NA
Trademarks,"All trademarks and registered trademarks appearing in this book are 
 the property of their own respective owners.
  
 3",NA
About the authors,"Kelvin Lau is an author of this book. Kelvin is a physicist turned Swift 
 iOS Developer. While he's currently entrenched with iOS 
  
 development, he often reminisces of his aspirations to be part of the 
 efforts in space exploration. Outside of programming work, he's an 
 aspiring entrepreneur and musician. You can find him on Twitter: 
 @kelvinlauKL
  
  
 Vincent Ngo is an author of this book. A software developer by day, 
 and an iOS-Swift enthusiast by night, he believes that sharing 
  
 knowledge is the best way to learn and grow as a developer. Vincent 
 starts every morning with a homemade green smoothie in hand to fuel 
 his day. When he is not in front of a computer, Vincent is training to 
 play in small golf tournaments, doing headstands at various 
  
 locations while on a hiking adventure, or looking up how to make 
 tamago egg. You can find him on Twitter: 
 @vincentngo2
 .
  
 4",NA
About the editors,"Steven Van Impe is the technical editor of this book. Steven is a 
 computer science lecturer at the University College of Ghent, 
  
 Belgium. When he’s not teaching, Steven can be found on his bike, 
 rattling over cobblestones and sweating up hills, or relaxing around 
 the table, enjoying board games with friends. You can find Steven on 
 Twitter as 
 @svanimpe
 .
  
  
 Chris Belanger is the editor of this book. Chris is the Editor in Chief at 
 raywenderlich.com. He was a developer for nearly 20 years in various 
 fields from e-health to aerial surveillance to industrial controls. If there 
 are words to wrangle or a paragraph to ponder, he’s on the case.
  
 When he kicks back, you can usually find Chris with guitar in hand, 
 looking for the nearest beach. Twitter: 
 @crispytwit
 .
  
 5",NA
Book license,"By purchasing Data Structures & Algorithms in Swift, you have the 
 following license:
  
  
  
  
  
 You are allowed to use and/or modify the source code in Data 
 Structures & Algorithms in Swift in as many apps as you want, 
 with no attribution required.
  
 You are allowed to use and/or modify all art, images and designs 
 that are included in Data Structures & Algorithms in Swift in as 
 many apps as you want, but must include this attribution line 
 somewhere inside your app: “Artwork/images/designs: from Data 
 Structures & Algorithms in Swift, available at 
  
 www.raywenderlich.com”.
  
 The source code included in Data Structures & Algorithms in 
 Swift is for your personal use only. You are NOT allowed to 
  
 distribute or sell the source code in Data Structures & Algorithms 
 in Swift without prior authorization.
  
 This book is for your personal use only. You are NOT allowed to 
 sell this book without prior authorization, or distribute it to friends, 
 coworkers or students; they would need to purchase their own 
 copies.
  
 All materials provided with this book are provided on an “as is” basis, 
 without warranty of any kind, express or implied, including but not 
 limited to the warranties of merchantability, fitness for a particular 
 purpose and noninfringement. In no event shall the authors or 
 copyright holders be liable for any claim, damages or other liability, 
 whether in an action of contract, tort or otherwise, arising from, out of 
 or in connection with the software or the use or other dealings in the 
 software.
  
 All trademarks and registered trademarks appearing in this guide are 
  
 8",NA
Early access edition,"You’re reading an an early access edition of Data Structures & 
 Algorithms in Swift. This edition contains a sample of the chapters 
 that will be contained in the final release.
  
 We hope you enjoy the preview of this book, and that you’ll come 
 back to help us celebrate the full launch of Data Structures & 
 Algorithms in Swift later in 2018!
  
 The best way to get update notifications is to sign up for our monthly 
 newsletter. This includes a list of the tutorials that came out on 
 raywenderlich.com that month, any important news like book updates 
 or new books, and a list of our favorite development links for that 
 month. You can sign up here:
  
  
 www.raywenderlich.com/newsletter
  
 10",NA
Who this book is for,"This book is for developers who are comfortable with Swift and want 
 to ace whiteboard interviews, improve the performance of their code, 
 and ensure their apps will perform well at scale.
  
 If you’re looking for more background on the Swift language, we 
 recommend our book, the Swift Apprentice, which goes into depth on 
 the Swift language itself:
  
  
 https://store.raywenderlich.com/products/swift-apprentice
  
 If you want to learn more about iOS app development in Swift, we 
 recommend working through our classic book, the iOS Apprentice:
  
  
 https://store.raywenderlich.com/products/ios-apprentice
  
 11",NA
What you need,"To follow along with this book, you'll need the following:
  
  
  
 A Mac running macOS Sierra 10.12.6, at a minimum, with the 
 latest point release and security patches installed. This is so you 
 can install the latest version of the required development tool: 
 Xcode.
  
 Xcode 9 or later. Xcode is the main development tool for writing 
 code in Swift. You need Xcode 9 at a minimum, since that 
 version includes Swift 4. You can download the latest version of 
 Xcode for free from the Mac App Store, here: 
 apple.co/1FLn51R
 .
  
 If you haven't installed the latest version of Xcode, be sure to do that 
 before continuing with the book. The code covered in this book 
 depends on Swift 4 and Xcode 9 — you may get lost if you try to 
 work with an older version.
  
 12",NA
Book source code and forums ,"You can get the source code for the book here: 
  
 www.raywenderlich.com/store/data-structures-algorithms-
 swift/source-code 
  
 There, you’ll find all the code from the chapters for your use.
  
 We’ve also set up an official forum for the book at 
  
 forums.raywenderlich.com
 . This is a great place to ask questions 
 about the book or to submit any errors you may find.
  
 13",NA
About the cover,"The legendary, elusive kraken has captured the imagination of sailors, 
 artists and authors for hundreds of years. Most modern-day scientists 
 believe that the creature known as the kraken is most likely the giant 
 squid: a deep-water member of the Architeuthidae family that can 
 grow up to 43 feet in length!
  
 Little is known about the giant squid, due to its preference for cold, 
 deep-water habitats. It’s much like the data structures and algorithms 
 that lurk deep within software; although you may not yet understand 
 how data structures and algorithms form the basis of scalable, high-
 performance solutions, this book will be your own personal Nautilus 
 that will transport you 20,000 leagues under a sea of code!
  
 14",NA
Preface,"The study of data structures is one about efficiency. Given a particular 
 amount of data, what is the best way to store it to achieve a particular 
 goal?
  
 As a programmer, you regularly use a variety of collection types, such 
 as arrays, dictionaries, and sets. These are data structures that hold a 
 collection of data, each structure having its own performance 
  
 characteristics.
  
 As an example, consider the difference between an array and a set. 
 Both are meant to hold a collection of elements, but trying to find a 
 particular element in an array takes a lot longer than finding an 
 element in a set. On the other hand, you can order the elements an 
 array, but you can’t order the elements of a set.
  
 Data structures are a well-studied area, and the concepts are 
 language agnostic; a data structure from C is functionally and 
 conceptually identical to the same data structure in any other 
 language, such as Swift. At the same time, the high-level 
 expressiveness of Swift make it an ideal choice for learning these core 
 concepts without sacrificing too much performance.
  
 So why should you learn data structures and algorithms?",NA
Interviews,"When you interview for a software engineering position, chances are 
 you’ll be tested on data structures and algorithms. Having a strong 
 foundation in data structures and algorithms is the “bar” for many 
 companies with software engineering positions.",NA
Work,"Data structures are most relevant when working with large amounts 
  
 15",NA
Self-improvement,"Knowing about the strategies used by algorithms to solve tricky 
 problems gives you ideas for improvements you can make to your 
 own code. Swift’s Standard Library has small set of general purpose 
  
 collection types; they definitely don’t cover every case.
  
 And yet, as you will see, these primitives can be used as a great 
  
 starting point for building more complex and special purpose 
  
 constructs. Knowing more data structures than just the standard array 
 and dictionary gives you a bigger collection of tools you can use to 
 build your own apps.
  
 16",NA
Swift Standard Library,"Before you dive into the rest of this book, you’ll first look at a few data 
 structures that are baked into the Swift language. The Swift standard 
 library refers to the framework that defines the core components of the 
 Swift language. Inside, you’ll find a variety of tools and types to help 
 build your Swift apps.
  
 In this chapter you’ll focus on two data structures that the standard 
 library provides right out of the box: 
 Array
  and 
 Dictionary
 .",NA
Arrays,"An array is a general-purpose, generic container for storing a 
  
 collection of elements, and is used commonly in all sorts of Swift 
 programs. You can create an array by using an array literal, which is a 
 comma-separated list of values surrounded with square brackets. For 
 example:
  
 // An array of `String` elements
  
  
 let
  people = [
 ""Brian""
 , 
 ""Stanley""
 , 
 ""Ringo""
 ]
  
 This is a generic type in that it abstracts across any element type. The 
 element type has no formal requirements; it can be anything. In the 
 above example, the compiler type infers the elements to be 
 String 
 types.
  
 Swift defines arrays using protocols. Each of these protocols layers 
 more capability on the array. For example, an 
 Array
  is a 
 Sequence 
 which 
 means that you can iterate through it at least once. It is also a 
 Collection
  
 which means it can be traversed multiple times, non-destructively, and 
 it can be accessed using a subscript operator. Array is also a 
 RandomAccessCollection
  which makes guarantees about efficiency.
  
 17",NA
Order,"Elements in an array are explicitly ordered. Using the above 
 people 
 array as an example, 
 ""Brian""
  comes before 
 ""Stanley""
 .
  
 All elements in an array have a corresponding zero-based, integer 
 index. For example, the 
 people
  array from the above example has 
 three indices, one corresponding to each element.
  
 You can retrieve the value of an element in the array by writing the 
 following:
  
 people[
 0
 ] 
 // ""Brian""
  
  
 people[
 1
 ] 
 // ""Stanley""
  
  
 people[
 2
 ] 
 // ""Ringo""
  
 Order is defined by the array data structure and should not be taken 
 for granted. Some data structures, such as 
 Dictionary
 , have a weaker 
 concept of order.",NA
Random-access,"Random-access is a trait that data structures can claim if they can 
 handle element retrieval in constant O(1) time. For example, getting 
 ""Ringo""
  from the 
 people
  array takes constant time. Again, this 
 performance should not be taken for granted. Other data structures 
 such as linked lists and trees do not have constant time access.",NA
Array performance,18,NA
Insertion location,"The first factor is where you choose to insert the new element inside 
 the array. The most efficient scenario for adding an element to an 
 array is to append it at the end of the array:
  
 people.append(
 ""Charles""
 )
  
 print
 (people) 
 // prints [""Brian"", ""Stanley"", ""Ringo"", ""Charles""]
  
 Inserting 
 ""Charles""
  using the 
 append
  method will place the string at the 
 end of the array. This is a constant-time operation, and is the most 
 efficient way to add elements into an array. However, there may come 
 a time that you need to insert an element in a particular 
  
 location, such as in the very middle of the array. In such a scenario, 
 this is an O(n) operation.
  
 To help illustrate why that is the case, consider the following analogy. 
 You’re standing in line for the theater. Someone new comes along, to 
 join the lineup. What’s the easiest place to add people to the lineup? 
 At the end of course!
  
 If the newcomer tried to insert themselves into the middle of the line, 
 they would have to convince half the lineup to shuffle back to make 
 room.
  
 And if they were terribly rude, they’d try to insert themselves at the 
 head of the line. This is the worst-case scenario, because every single 
 person in the lineup would need to shuffle back to make room for this 
 new person in front!
  
 This is exactly how the array works. Inserting new elements from 
  
 19",NA
Dictionary,"A dictionary is another generic collection that holds key-value pairs. 
 For example, here’s a dictionary containing a user’s name and their 
 score:
  
 var
  scores: [
 String
 : 
 Int
 ] = [
 ""Eric""
 : 
 9
 , 
 ""Mark""
 : 
 12
 , 
 ""Wayne""
 : 
  
 Dictionaries don’t have any guarantees of order, nor can you insert at 
  
 20",NA
Where to go from here?,"This chapter covers two of the most common data structures in Swift, 
 and briefly highlights some trade-offs between the two. The rest of the 
 book will look at other data structures that have unique 
  
 performance characteristics that give them their edge in certain
  
 21",NA
Linked list,"A linked list is a collection of values arranged in a linear 
  
 unidirectional sequence. A linked list has several theoretical 
  
 advantages over contiguous storage options such as the Swift 
 Array:
  
  
 Constant time insertion and removal from the front of the list.
  
  
 Reliable performance characteristics.
  
  
 As the diagram suggests, a linked list is a chain of nodes. Nodes 
 have two responsibilities:
  
 1. Hold a value.
  
 2. Hold a reference to the next node. A 
 nil
  value represents the end 
  
 of the list.
  
  
 Open up the starter playground for this chapter so you can dive right 
 into the code.",NA
Node,"Create a new Swift file in the Sources directory and name it 
 Node.swift. Add the following to the file: 
  
  
 23",NA
LinkedList,"In the Sources directory, create a new file and name it 
 LinkedList.swift. Add the following to the file:
  
 publicstruct
 LinkedList
 <
 Value
 > {
  
 publicvar
  head: 
 Node
 <
 Value
 >? 
  
 publicvar
  tail: 
 Node
 <
 Value
 >?
  
 publicinit
 () {}
  
  
 publicvar
  isEmpty: 
 Bool
  { 
  
    
 return
  head == 
 nil
  
  
  } 
  
 }
  
 extension
 LinkedList
 : 
 CustomStringConvertible
  {
  
 publicvar
  description: 
 String
  { 
  
  
 guardlet
  head = head 
 else
  { 
  
  
  
 return
 ""Empty list""
  
  
  }
  
 return
 String
 (describing: head)
  
  
 25",NA
Adding values to the list,"As mentioned before, you’re going to provide an interface to manage 
 the 
 Node
  objects. You’ll first take care of adding values. There are 
 three ways to add values to a linked list, each having their own unique 
 performance characteristics:
  
 1. 
 push
 : Adds a value at the front of the list.
  
 2. 
 append
 : Adds a value at the end of the list.
  
 3. 
 insert(after:)
 : Adds a value after a particular node of the list.
  
 You’ll implement each of these in the next section and analyze their 
 performance characteristics.",NA
push,"Adding a value at the front of the list is known as a 
 push
  operation. 
 This is also known as head-first insertion. The code for it is 
  
 deliciously simple.
  
 Add the following method to 
 LinkedList
 :
  
 publicmutatingfunc
 push
 (
 _
  value: Value)
  {
  
  
 26",NA
append,"The next operation you’ll look at is 
 append
 . This is meant to add a 
 value at the end of the list, and is known as tail-end insertion.
  
 Head back into LinkedList.swift and add the following code just below 
 push
 :
  
 publicmutatingfunc
 append
 (
 _
  value: Value)
  {
  
  
 // 1
  
 guard
  !isEmpty 
 else
  {
  
  
  push(value)
  
 return
  
  
 27",NA
insert(after:),"The third and final operation for adding values is 
 insert(after:)
 . This 
 operation inserts a value at a particular place in the list, and 
 requires two steps:
  
 1. Finding a particular node in the list.
  
 2. Inserting the new node.
  
 First, you’ll implement the code to find the node where you want to 
 insert your value.
  
 Back in LinkedList.swift, add the following code just below 
 append
 :
  
 publicfunc
 node
 (at index: Int)
  -> 
 Node
 <
 Value
 >? {
  
 // 1
  
 var
  currentNode = head
  
 var
  currentIndex = 
 0
  
  
 // 2
  
 while
  currentNode != 
 nil
  && currentIndex < index {
  
  currentNode = currentNode!.next
  
  currentIndex += 
 1
  
  }
  
  
 return
  currentNode
  
  
 }
  
 node(at:)
  will try to retrieve a node in the list based on the given 
 index. Since you can only access the nodes of the list from the head 
 node, you’ll have to make iterative traversals. Here’s the play-by-
 play:
  
 1. You create a new reference to 
 head
  and keep track of the current 
  
 number of traversals.
  
 2. Using a 
 while
  loop, you move the reference down the list until 
  
 you’ve reached the desired index. Empty lists or out-of-bounds
  
 29",NA
Performance analysis,"Whew! You’ve made good progress so far. To recap, you’ve 
  
 implemented the three operations that add values to a linked list and 
 a method to find a node at a particular index.
  
  
 Next, you’ll focus on the opposite action: removal operations.
  
 31",NA
Removing values from the list,"There are three main operations for removing nodes:
  
 1. 
 pop
 : Removes the value at the front of the list.
  
 2. 
 removeLast
 : Removes the value at the end of the list.
  
 3. 
 remove(at:)
 : Removes a value anywhere in the list.
  
 You’ll implement all three and analyze their performance 
 characteristics.",NA
pop,"Removing a value at the front of the list is often referred to as 
 pop
 . 
 This operation is almost as simple as 
 push
 , so let’s dive right in.
  
 Add the following method to 
 LinkedList
 :
  
 @discardableResult
  
 publicmutatingfunc
 pop
 ()
  -> 
 Value
 ? { 
  
 defer
  {
  
    
  head = head?.next 
  
     
 if
  isEmpty {
  
      
  tail = 
 nil
  
    
  }
  
  
  } 
  
  
 return
  head?.value
  
 }
  
 pop
  returns the value that was removed from the list. This value is 
 optional, since it’s possible that the list is empty.
  
 By moving the 
 head
  down a node, you’ve effectively removed the first 
 node of the list. ARC will remove the old node from memory once the 
 method finishes, since there will be no more references attached to it. 
 In the event that the list becomes empty, you set 
 tail
  to 
 nil
 .
  
 32",NA
removeLast,"Removing the last node of the list is somewhat inconvenient.
  
 Although you have a reference to the 
 tail
  node, you can’t chop it off
  
 without having a reference to the node before it. Thus, you’ll have to
  
 do an arduous traversal. Add the following code just below 
 pop
 :
  
 @discardableResult
  
  
 publicmutatingfunc
 removeLast
 ()
  -> 
 Value
 ? {
  
  
 // 1
  
  
 guardlet
  head = head 
 else
  {
  
  
 returnnil
  
  
  }
  
  
 // 2
  
  
 guard
  head.next != 
 nilelse
  {
  
  
 return
  pop()
  
  
  }",NA
remove(after:),"The final remove operation is removing a particular node at a 
 particular point in the list. This is achieved much like 
  
 insert(after:)
 ; You’ll first find the node immediately before the node 
 you wish to remove, and then unlink it.
  
  
 Navigate back to LinkedList.swift and add the following method below 
 removeLast
 :
  
 @discardableResult
  
  
 publicmutatingfunc
 remove
 (after node: Node<Value>)
  -> 
 Value
  
  
 defer
  {
  
  
 35",NA
Performance analysis,"You’ve hit another checkpoint! To recap, you’ve implemented the 
 three operations that remove values from a linked list:
  
 At this point, you’ve defined an interface for a linked list that most 
 programmers around the world can relate to. However, there’s work 
 to be done to adorn the Swift semantics. In the next half of the 
 chapter, you’ll focus on making the interface as Swifty as possible.",NA
Swift collection protocols,"The Swift standard library has a set of protocols that help define 
 what’s expected of a particular type. Each of these protocols provides 
 certain guarantees on characteristics and performance. Of these set 
 of protocols, four are referred to as collection protocols.
  
 Here’s a small sampler of what each protocol represents:
  
 Tier 1, Sequence: A sequence type provides sequential access 
 to 
  
 37",NA
Becoming a Swift collection,"In this section, you’ll look into implementing the 
 Collection 
  
 protocol. A collection type is a finite sequence and provides 
  
 nondestructive sequential access. A Swift 
 Collection
  also allows for 
 access via a subscript , which is a fancy term for saying an index can 
 be mapped to a value in the collection.
  
 38",NA
Custom collection indexes,"A defining metric for performance of the 
 Collection
  protocol 
  
 methods is the speed of mapping an 
 Index
  to a value. Unlike other 
 storage options such as the Swift 
 Array
 , the linked list cannot achieve 
 O(1) subscript operations using integer indexes. Thus, your goal is to 
 define a custom index that contains a reference to its respective node.
  
 In LinkedList.swift, add the following extension:
  
 extension
 LinkedList
 : 
 Collection
  {
  
 publicstruct
 Index
 : 
 Comparable
  {
  
  
 publicvar
  node: 
 Node
 <
 Value
 >?
  
  
 staticpublicfunc
  ==
 (lhs: Index, rhs: Index)
  -> 
 Bool
  { 
   
  
 switch
  
 (lhs.node, rhs.node) { 
  
    
 caselet
  (
 left
 ?, 
 right
 ?): 
  
    
 returnleft
 .next === 
 right
 .next 
  
    
 case
  (
 nil
 , 
 nil
 ): 
  
    
 returntrue 
  
    
 default
 : 
  
    
 returnfalse
  
  
  }
  
  }
  
 staticpublicfunc
  <(lhs: Index, rhs: Index) -> 
 Bool
  { 
  
 guard
  lhs != rhs 
 else
  { 
  
  
 returnfalse
  
  }
  
  
 39",NA
Value semantics and copy-on-write,"Another important quality of a Swift collections is that they have value 
 semantics. This is implemented using copy-on-write, hereby known 
 as COW. To illustrate this concept, you’ll verify this behavior using 
 arrays. Write the following at the bottom of the playground page:
  
 example(of: 
 ""array cow""
 ) {
  
  
 let
  array1 = [
 1
 , 
 2
 ]
  
  
 var
  array2 = array1
  
  
 41",NA
Optimizing COW,"The O(n) overhead on every mutating call is unacceptable.
  
  
 There are two avenues that help alleviate this problem. The first is to 
 avoid copying when the nodes only have one owner.",NA
isKnownUniquelyReferenced,"In the Swift Standard Library lives a function named 
  
 isKnownUniquelyReferenced
 . This function can be used to determine 
 whether or not an object has exactly one reference to it. Let’s test this 
 out in the linked list COW example.
  
 In the last 
 example
  function call, find the line where you wrote 
 var 
 list2 = list
  and update that to the following:
  
 print
 (
 ""List1 uniquely referenced: 
 \(isKnownUniquelyReferenced(&list1.
  
 var
  list2 = list1
  
 print
 (
 ""List1 uniquely referenced: 
 \(isKnownUniquelyReferenced(&list1.
  
 You should see two new lines in the console:
  
 List1
  uniquely referenced: 
 true
  
  
 List1
  uniquely referenced: 
 false
  
 45",NA
Sharing nodes,"The second optimization is a partial sharing of nodes. As it turns out, 
 there are certain scenarios where you can avoid a copy. A 
  
 comprehensive evaluation of all the scenarios is beyond the scope of 
 this book, but you’ll try to get an understanding of how this works.
  
 Take a look at the following example (no need to write this down):
  
 var
  list1 = 
 LinkedList
 <
 Int
 >()
  
  
 (
 1
 ...
 3
 ).forEach { list1.append($
 0
 ) }
  
  
 var
  list2 = list1
  
 46",NA
Where to go from here?,"You’ve accomplished a lot in this chapter, and if you understood most 
 of what you’ve read, you’re in great shape.
  
 48",NA
Stacks,"Stacks are everywhere. Here are some common examples of 
 things you would stack:
  
  
 pancakes
  
  
 books
  
  
 paper
  
  
 cash
  
 The stack data structure is identical in concept to a physical stack of 
 objects. When you add an item to a stack, you place it on top of the 
 stack. When you remove an item from a stack, you always remove the 
 topmost item.",NA
Stack,"Stacks are useful, and also exceedingly simple. The main goal of 
 building a stack is to enforce how you access your data. If you had a 
 tough time with the linked list concepts, you'll bad glad to know that 
 stacks are comparatively trivial.
  
 There are only two essential operations for a stack:
  
  
 push
  - adding an element to the top of the stack
  
  
 pop
  - removing the top element of the stack
  
 This means you can only add or remove elements from one side of 
 the data structure. In computer science, a stack is known as the LIFO 
 (last in first out) data structure. Elements that are pushed in last are 
 the first ones to be popped out.
  
 49",NA
Implementation,"Open up the starter playground for this chapter. In the Sources folder 
 of your playground, create a file named Stack.swift. Inside the file, 
 write the following:
  
 publicstruct
 Stack
 <
 Element
 > {
  
  
 privatevar
  storage: [
 Element
 ] = []
  
  
 publicinit
 () { }
  
  
 }
  
  
 extension
 Stack
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
 let
  topDivider = 
 ""----top----\n""
  
 let
  bottomDivider = 
 ""\n-----------""
  
  
 let
  stackElements = storage
  
   
  
  .
 map
  { 
 ""
 \($
 0
 )
 ""
  }
  
   
  
  .reversed()
  
   
  
  .joined(separator: 
 ""\n""
 ) 
  
   
 return
  topDivider + stackElements + bottomDivider
  
  } 
  
 }
  
 50",NA
push and pop,"Add the following two operations to your 
 Stack
 :
  
 publicmutatingfunc
 push
 (
 _
  element: Element)
  {
  
  
  storage.append(element)
  
  
 }
  
  
 @discardableResult
  
  
 publicmutatingfunc
 pop
 ()
  -> 
 Element
 ? {
  
  
 return
  storage.popLast()
  
  
 }
  
 Fairly straightforward! Head back to the playground page and write 
 the following:
  
 example(of: 
 ""using a stack""
 ) {
  
 var
  stack = 
 Stack
 <
 Int
 >()
  
  stack.push(
 1
 )
  
  stack.push(
 2
 )
  
  stack.push(
 3
 )
  
  stack.push(
 4
 )
  
  
 print
 (stack)
  
  
 iflet
  poppedElement = stack.pop() {
  
 assert
 (
 4
  == poppedElement) 
  
 print
 (
 ""Popped: 
 \(poppedElement)
 ""
 ) }
  
 }
  
 You should see the following output:
  
 51",NA
Non-essential operations,"There are a couple of nice-to-have operations that make a stack 
 easier to use. Head back into Stack.swift and add the following to 
 Stack
 :
  
 publicfunc
 peek
 ()
  -> 
 Element
 ? {
  
  
 return
  storage.last
  
  
 }
  
  
 publicvar
  isEmpty: 
 Bool
  {
  
  
 return
  peek() == 
 nil
  
  
 }
  
 peek
  is an operation that is often attributed to the stack interface. The 
 idea of 
 peek
  is to look at the top element of the stack without 
  
 mutating its contents.",NA
Less is more,"You may have wondered if you could adopt the Swift collection 
 protocols for the stack. A stack's purpose is to limit the number of 
 ways to access your data, and adopting protocols such as 
 Collection 
 would go against this goal by exposing all the elements via iterators 
 and the subscript. In this case, less is more!
  
 You might want to take an existing array and convert it to a stack so 
 that the access order is guaranteed. Of course it would be possible to",NA
Where to go from here?,"Stacks are crucial to problems that search trees and graphs. Imagine 
 finding your way through a maze. Each time you come to a decision 
 point of left right or straight you can push all possible decisions onto 
 your stack. When you hit a dead end, simply backtrack by popping 
 from the stack and continuing until you escape or hit another dead 
 end.
  
 54",NA
Queues,"Lines are everywhere, whether you are lining up to buy tickets to your 
 favorite movie, or waiting for a printer machine to print out your 
 documents. These real-life scenarios mimic the queue data structure.
  
 Queues use FIFO or first-in-first-out ordering, meaning the first 
 element that was enqueued will be the first to get dequeued. Queues 
 are handy when you need to maintain the order of your elements to 
 process later.",NA
Common operations,"Let’s establish a protocol for queues:
  
 publicprotocol
 Queue
  {
  
  
  associatedtype 
 Element
  
  
 mutatingfunc
 enqueue
 (
 _
  element: Element)
  -> 
 Bool
  
  
 mutatingfunc
 dequeue
 ()
  -> 
 Element
 ?
  
  
 var
  isEmpty: 
 Bool
  { 
 get
  }
  
  
 var
  peek: 
 Element
 ? { 
 get
  }
  
  
 }
  
 The protocol describes the common operations for a queue:
  
  
  
  
  
 enqueue
 : Insert an element at the back of the queue. Returns 
 true 
 if 
 the operation was successful.
  
 dequeue
 : Remove the element at the front of the queue and 
 return it.
  
 isEmpty
 : Check if the queue is empty.
  
 peek
 : Return the element at the front of the queue without 
 removing it.
  
 55",NA
Example of a queue,"The easiest way to understand how a queue works is to see a working 
 example. Imagine a group of people waiting in line for a movie ticket.
  
 The queue currently holds Ray, Brian, Sam, and Mic. Once Ray has 
 received his ticket, he moves out of the line. By calling 
 dequeue()
 , Ray 
 is removed from the front of the queue.
  
 Calling 
 peek
  will return Brian since he is now at the front of the line.
  
 Now comes Vicki, who just joined the line to buy a ticket. By calling 
 enqueue(""Vicki"")
 , Vicki gets added to the back of the queue.
  
 In the following sections, you will learn to create a queue in four 
 different ways:
  
  
 Using an array
  
  
 Using a doubly linked list
  
 56",NA
Array-based implementation,"The Swift Standard Library comes with core set highly-optimized, 
 primitive data structures you can use to build higher level 
  
 abstractions with. One of them is 
 Array
 , a data structure that stores a 
 contiguous, ordered list of elements. In this section, you will use an 
 array to create a queue.
  
 Open the starter playground. To the QueueArray page, add 
 the following:
  
 publicstruct
 QueueArray
 <
 T
 >: 
 Queue
  {
  
  
 privatevar
  array: [
 T
 ] = []
  
  
 publicinit
 () {}
  
  
 }
  
 Here you’ve defined a generic 
 QueueArray
  struct that adopts the 
 Queue 
 protocol. Note that the associated type 
 Element
  is inferred by the type 
 parameter 
 T
 .
  
 Next, you’ll complete the implementation of 
 QueueArray
  to conform to 
 the 
 Queue
  protocol.",NA
Leveraging arrays,"Add the following code to 
 QueueArray
 :
  
 57",NA
Enqueue,"Adding an element to the back of the queue is easy. Just append 
 an element to the array. Add the following:
  
 publicmutatingfunc
 enqueue
 (
 _
  element: T)
  -> 
 Bool
  {
  
  
  array.append(element)
  
  
 returntrue
  
  
 }
  
 Regardless of the size of the array, enqueueing an element is an 
 O(1) operation. This is because the array has empty space at the 
 back.",NA
Dequeue,"Removing an item from the front requires a bit more work. Add the 
 following:
  
 publicmutatingfunc
 dequeue
 ()
  -> 
 T
 ? {
  
  
 return
  isEmpty ? 
 nil
  : array.removeFirst()
  
  
 }
  
 If the queue is empty, 
 dequeue
  simply returns 
 nil
 . If not, it removes the 
 element from the front of the array and returns it.
  
 59",NA
Debug and test,"For debugging purposes, you’ll have your 
 queue
  adopt the 
  
 CustomStringConvertible
  protocol. Add the following at the bottom of the 
 page:
  
 extension
 QueueArray
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
  
 return
  array.description
  
  
  }
  
  
 }
  
 Time to try out the queue you just implemented! Add the following to 
 the bottom of the page:
  
 var
  queue = 
 QueueArray
 <
 String
 >()
  
  
 queue.enqueue(
 ""Ray""
 )
  
  
 queue.enqueue(
 ""Brian""
 )
  
  
 queue.enqueue(
 ""Eric""
 )
  
  
 queue.dequeue()
  
  
 queue
  
  
 queue.peek
  
 This code puts Ray, Brian and Eric in the queue, then removes 
 Ray and peeks at Brian but doesn’t remove him.
  
 60",NA
Strengths and weaknesses,"Here is a summary of the algorithmic and storage complexity of the 
 array-based queue implementation. Most of the operations are 
 constant time except for 
 dequeue()
  which takes linear time. Storage 
 space is also linear.
  
  
 You have seen how easy it is to implement an array-based queue 
 by leveraging a Swift 
 Array
 . Enqueue is very fast thanks to an O(1) 
 append operation.
  
 There are some shortcomings to the implementation. Removing an 
 item from the front of the queue can be inefficient, as removal causes 
 all elements to shift up by one. This makes a difference for very large 
 queues. Once the array gets full, it has to resize and may have 
 unused space. This could increase your memory footprint over time.
  
 Is it possible to address these shortcomings? Let’s look at a 
 linked list-based implementation and compare it to a 
 QueueArray
 .",NA
Doubly linked list implementation,"Switch to the QueueLinkedList playground page. Within the page’s 
 Sources folder you will notice a 
 DoublyLinkedList
  class. You should 
 already be familiar with linked lists from Chapter 3, “Linked Lists”. A 
 doubly linked list is simply a linked list in which nodes also contain a 
 reference to the previous node.
  
 61",NA
Enqueue,"To add an element to the back of the queue simply add the following:
  
 publicfunc
 enqueue
 (
 _
  element: T)
  -> 
 Bool
  {
  
  
  list.append(element)
  
  
 returntrue
  
  
 }
  
  
 Behind the scenes, the doubly linked list will update its tail node’s 
 previous and next references to the new node. This is an O(1) 
 operation.",NA
Dequeue,"To remove an element from the queue, add the following:
  
 62",NA
Checking the state of a queue,"Similar to the array implementation, you can implement 
 peek
  and 
 isEmpty
  using the properties of the 
 DoublyLinkedList
 . Add the 
 following:
  
 publicvar
  peek: 
 T
 ? {
  
  
 return
  list.first?.value
  
  
 }
  
  
 publicvar
  isEmpty: 
 Bool
  {
  
  
 return
  list.isEmpty
  
  
 }
  
 63",NA
Debug and test,"For debugging purposes, you can add the following at the bottom of 
 the page:
  
 extension
 QueueLinkedList
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
  
 return
  list.description
  
  
  }
  
  
 }
  
 This will leverage the 
 DoublyLinkedList
 ’s default implementation for the 
 CustomStringConvertible
  protocol.
  
 That’s all there is to implementing a queue using a linked list! In the 
 QueueLinkedList page of playground, you can try the example:
  
 var
  queue = 
 QueueLinkedList
 <
 String
 >()
  
  
 queue.enqueue(
 ""Ray""
 )
  
  
 queue.enqueue(
 ""Brian""
 )
  
  
 queue.enqueue(
 ""Eric""
 )
  
  
 queue.dequeue()
  
  
 queue
  
  
 queue.peek
  
 This test code yields the same results as your 
 QueueArray 
 implementation.",NA
Strengths and weaknesses,"Let’s summarize of the algorithmic and storage complexity of the 
 doubly-linked-list-based queue implementation.
  
 64",NA
Ring buffer implementation,"A ring buffer, also known as a circular buffer, is a fixed-size array. 
 This data structure strategically wraps around to the beginning when 
 there are no more items to remove at the end. Let’s go over a simple 
 example of how a queue can be implemented using a ring buffer.
  
 65",NA
Enqueue,"Next add the method below:
  
 publicmutatingfunc
 enqueue
 (
 _
  element: T)
  -> 
 Bool
  {
  
  
 return
  ringBuffer.write(element)
  
  
 }
  
 To append an element to the queue, you simply call 
 write(_:)
  on the 
 ringBuffer
 . This increments the 
 write
  pointer by one.
  
 Since the queue has a fixed size, you must now return 
 true
  or 
 false 
 to 
 indicate whether the element has been successfully added. 
 enqueue(_:)
  is still an O(1) operation.",NA
Dequeue,"To remove an item from the front of the queue, add the following:
  
 publicmutatingfunc
 dequeue
 ()
  -> 
 T
 ? {
  
  
 return
  isEmpty ? 
 nil
  : ringBuffer.read()
  
 69",NA
Debug and test,"To see your results in the playground, add the following:
  
 extension
 QueueRingBuffer
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
  
 return
  ringBuffer.description
  
  
  }
  
  
 }
  
 This code creates a string representation of the Queue by 
 delegating to the underlying ring buffer.
  
 That’s all there is to it! Test your ring buffer-based queue by adding 
 the following at the bottom of the page:
  
 var
  queue = 
 QueueRingBuffer
 <
 String
 >(
 count
 : 
 10
 )
  
  
 queue.enqueue(
 ""Ray""
 )
  
  
 queue.enqueue(
 ""Brian""
 )
  
  
 queue.enqueue(
 ""Eric""
 )
  
  
 queue
  
  
 queue.dequeue()
  
  
 queue
  
  
 queue.peek
  
 This test code works just like the previous examples dequeuing 
 Ray and peeking at Brian.",NA
Strengths and weaknesses,"How does the ring-buffer implementation compare? Let’s look at a 
  
 70",NA
Double stack implementation,"Open the QueueStack playground page and start by adding a 
 generic 
 QueueStack
  as shown below:
  
 publicstruct
 QueueStack
 <
 T
 > : 
 Queue
  {
  
  
 privatevar
  leftStack: [
 T
 ] = []
  
  
 privatevar
  rightStack: [
 T
 ] = []
  
  
 publicinit
 () {}
  
  
 }
  
 The idea behind using two stacks is simple. Whenever you enqueue 
 an element, it goes in the right stack. When you need to dequeue an
  
 71",NA
Leveraging arrays,"Implement the common features of a queue, starting with the 
 following:
  
 publicvar
  isEmpty: 
 Bool
  {
  
  
 return
  leftStack.isEmpty && rightStack.isEmpty
  
  
 }
  
 To check if the queue is empty, simply check that both the left and 
 right stack are empty. This means there are no elements left to 
 dequeue and no new elements have been enqueued.
  
 Next add the following:
  
 publicvar
  peek: 
 T
 ? {
  
 return
  !leftStack.isEmpty ? leftStack.last : rightStack.first 
  
 }
  
 You know that peeking looks at the top element. If the left stack is not 
 empty, the element on top of this stack is at the front of the queue. If 
 the left stack is empty, the right stack will be reversed and placed in 
 the left stack. In this case, the element at the bottom of the right stack 
 is next in the queue.
  
 72",NA
Enqueue,"Next add the method below:
  
 publicmutatingfunc
 enqueue
 (
 _
  element: T)
  -> 
 Bool
  {
  
  
  rightStack.append(element)
  
  
 returntrue
  
  
 }
  
 Recall that the right stack is used to enqueue elements. You simply 
 push to the stack by appending to the array.
  
 Previously from implementing the 
 QueueArray
 , you know that 
 appending an element is an O(1) operation.",NA
Dequeue,"Removing an item from a two stack based implementation of a queue 
 is tricky. Add the following method:
  
 publicmutatingfunc
 dequeue
 ()
  -> 
 T
 ? {
  
  
 if
  leftStack.isEmpty { 
 // 1
  
  
 73",NA
Debug and test,"To see your results in the playground, add the following:
  
 extension
 QueueStack
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
  
 let
  printList = leftStack + rightStack.reversed()
  
  
 return
  printList.description
  
  
  }
  
  
 }
  
 Here you simply combine the left stack with the reverse of the right 
 stack, and you print all the elements.
  
 Let’s try out the double stack implementation:
  
 var
  queue = 
 QueueStack
 <
 String
 >()
  
  
 queue.enqueue(
 ""Ray""
 )
  
  
 queue.enqueue(
 ""Brian""
 )
  
  
 queue.enqueue(
 ""Eric""
 )
  
  
 queue.dequeue()
  
  
 queue
  
  
 queue.peek
  
 Just like all of the examples before, this code enqueues Ray, Brian 
 and Eric, dequeues Ray and then peeks at Brian.",NA
Strengths and weaknesses,"Let’s look at a summary of the algorithmic and storage complexity of 
 your two-stack-based implementation.
  
 75",NA
Where to go from here?,"You’ve learned a lot in this chapter! You implemented four varieties of 
 the queue and studied their strengths and weaknesses. You will see 
 queues come up again and again in future chapters as you learn 
 about more sophisticated algorithms.
  
 77",NA
Trees,"The tree is a data structure of profound importance. It is used to 
 tackle many recurring challenges in software development, such as:
  
  
 representing hierarchical relationships
  
  
 managing sorted data
  
  
 facilitating fast lookup operations
  
 There are many types of trees, and they come in various shapes 
 and sizes. In this chapter, you will learn the basics of using and 
  
 implementing a tree.",NA
Terminology,"There are many terms associated with trees, so you will get 
 acquainted with a couple right off the bat.",NA
Node,78,NA
Parent and child,"Trees are viewed starting from the top and branching towards the 
 bottom, just like a real tree, only upside-down.
  
 Every node (except for the topmost one) is connected to exactly one 
 node above it. That node is called a parent node. The nodes directly 
 below and connected to it are called its child nodes. In a tree, every 
 child has exactly one parent. That’s what makes a tree, a tree.",NA
Root,"The topmost node in the tree is called the root of the tree. It is the 
 only node that has no parent:
  
 79",NA
Leaf,"A node is a leaf if it has no children:
  
  
 You will run into more terms later on, but this should be enough to 
 get into the coding of trees.",NA
Implementation,"Open up the starter playground for this chapter to get started. A tree 
 is made up of nodes, so your first task is to create a 
 TreeNode
  class.
  
 Create a new file named TreeNode.swift and write the following 
 inside it:
  
 publicclass
 TreeNode
 <
 T
 > {
  
  
 publicvar
  value: 
 T
  
  
 publicvar
  children: [
 TreeNode
 ] = []
  
  
 80",NA
Traversal algorithms,"Iterating through linear collections such as arrays or linked lists is
  
 straightforward. Linear collections have a clear start and end:
  
  
 Iterating through trees is a bit more complicated:
  
 82",NA
Depth-first traversal,"Write the following at the bottom of TreeNode.swift:
  
 extension
 TreeNode
  {
  
  
 publicfunc
 forEachDepthFirst
 (visit: (TreeNode)
  -> 
 Void
 ) {
  
  
  visit(
 self
 )
  
  
  children.forEach {
  
  
  $
 0
 .forEachDepthFirst(visit: visit)
  
  
  }
  
  
  }
  
  
 }
  
 83",NA
Level-order traversal,"Write the following at the bottom of TreeNode.swift:
  
 extension
 TreeNode
  {
  
 publicfunc
 forEachLevelOrder
 (visit: (TreeNode)
  -> 
 Void
 ) {
  
  visit(
 self
 ) 
  
   
 var
  queue = 
 Queue
 <
 TreeNode
 >()
  
  
  children.forEach { queue.enqueue($
 0
 ) } 
  
   
 whilelet
  node = queue.dequeue() {
  
    
  visit(node)
  
    
  node.children.forEach { queue.enqueue($
 0
 ) }
  
  
  }
  
  }
  
 }
  
 forEachLevelOrder
  visits each of the nodes in level-order:
  
  
 86",NA
Search,"You already have a method that iterates through all the nodes, so 
 building a search algorithm shouldn’t take long. Write the following 
 at the bottom of TreeNode.swift:
  
 extension
 TreeNodewhereT
 : 
 Equatable
  {
  
  
 publicfunc
 search
 (
 _
  value: T)
  -> 
 TreeNode
 ? {
  
  
 var
  result: 
 TreeNode
 ?
  
  
  forEachLevelOrder { node 
 in
  
  
 if
  node.value == value {
  
  
 87",NA
Where to go from here?,88,NA
Binary Trees,"In the previous chapter, you looked at a basic tree where each node 
 can have many children. A binary tree is a tree where each node has 
 at most two children, often referred to as the left and right children:
  
  
 Binary trees serve as the basis for many tree structures and 
  
 algorithms. In this chapter, you’ll build a binary tree and learn about 
 the three most important tree traversal algorithms.",NA
Implementation,"Open the starter project for this chapter. Create a new file and name it 
 BinaryNode.swift. Add the following inside this file:
  
 publicclass
 BinaryNode
 <
 Element
 > {
  
  
 publicvar
  value: 
 Element
  
 publicvar
  leftChild: 
 BinaryNode
 ?
  
 publicvar
  rightChild: 
 BinaryNode
 ?
  
  
 publicinit
 (value: 
 Element
 ) {
  
 self
 .value = value
  
  }
  
 }
  
 In the main playground page, add the following:
  
 90",NA
Building a diagram,"Building a mental model of a data structure can be quite helpful in 
 learning how it works. To that end, you’ll implement a reusable 
 algorithm that helps visualize a binary tree in the console.
  
 91",NA
Traversal algorithms,"Previously, you looked at a level-order traversal of a tree. With a few 
 tweaks, you can make this algorithm work for binary trees as well. 
 However, instead of re-implementing level-order traversal, you’ll look 
 at three traversal algorithms for binary trees: in-order, pre-order, and 
 post-order traversals.",NA
In-order traversal,"In-order traversal visits the nodes of a binary tree in the following 
 order, starting from the root node:
  
  
  
  
 If the current node has a left child, recursively visit this child 
 first.
  
 Then visit the node itself.
  
 If the current node has a right child, recursively visit this child.
  
 Here’s what an in-order traversal looks like for your example tree:
  
 93",NA
Pre-order traversal,"Pre-order traversal always visits the current node first, then 
 recursively visits the left and right child:
  
  
 Write the following just below your in-order traversal method:
  
 publicfunc
 traversePreOrder
 (visit: (Element)
  -> 
 Void
 ) {
  
  
  visit(value)
  
  
  leftChild?.traversePreOrder(visit: visit)
  
  
  rightChild?.traversePreOrder(visit: visit)
  
  
 }
  
 95",NA
Post-order traversal,"Post-order traversal only visits the current node after the left and 
 right child have been visited recursively.
  
  
 In other words, given any node, you’ll visit its children before visiting 
 itself. An interesting consequence of this is that the root node is
  
 96",NA
Where to go from here?,"Each one of these traversal algorithms has both a time and space 
 complexity of O(n). While this version of the binary tree isn’t too 
 interesting, you saw that in-order traversal can be used to visit the 
 nodes in ascending order. Binary trees can enforce this behavior 
 by adhering to some rules during insertion. In the next chapter, 
 you’ll look at a binary tree with stricter semantics: the binary search 
 tree.",NA
Binary Search Trees,"A binary search tree (or BST) is a data structure that facilitates fast 
 lookup, addition, and removal operations. Each operation has an 
 average time complexity of O(log n), which is considerably faster than 
 linear data structures such as arrays and linked lists. A binary search 
 tree achieves this performance by imposing two rules on the binary 
 tree you saw in the previous chapter:
  
  
  
 The value of a left child must be less than the value of its parent. 
 The value of a right child must be greater than or equal to the 
 value of its parent.
  
 These rules let the tree act like a decision tree:
  
  
 Picking a side forfeits all the possibilities of the other side. Binary 
 search trees use this property to save you from performing 
  
 unnecessary checking.
  
 98",NA
Case study: array vs. BST,"To illustrate the power of binary search trees, you’ll look at some 
 common operations and compare the performance of arrays against 
 the binary search tree.
  
 Consider the following two collections:",NA
Lookup,"There’s only one way to do element lookups for an unsorted array. 
 You need to check every element in the array from the start:
  
  
 That’s why 
 array.contains(:)
  is an O(n) operation.
  
 This is not the case for binary search trees:
  
 99",NA
Insertion,"The performance benefits for the insertion operation follow a similar 
 story. Assume you want to insert 0 into a collection:",NA
Removal,101,NA
Implementation,"Open up the starter project for this chapter. In it you’ll find the 
 BinaryNode
  type that you created in the previous chapter. Create a 
 new file named BinarySearchTree.swift and add the following inside 
 the file:
  
 publicstruct
 BinarySearchTree
 <
 Element
 : 
 Comparable
 > {
  
  
 publicprivate
 (
 set
 ) 
 var
  root: 
 BinaryNode
 <
 Element
 >?
  
  
 publicinit
 () {}
  
  
 }
  
  
 extension
 BinarySearchTree
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
 return
  root?.description ?? 
 ""empty tree""
  
  }
  
 }
  
 By definition, binary search trees can only hold values that are 
 Comparable
 .
  
 Next, you’ll look at the 
 insert
  method.",NA
Inserting elements,"In accordance with the rules of the BST, nodes of the left child must 
  
 103",NA
Finding elements,"Finding an element in a BST requires you to traverse through its 
 nodes. It’s possible to come up with a relatively simple 
  
 implementation by using the existing traversal mechanisms you 
 learned about in the previous chapter.
  
 Add the following to the bottom of BinarySearchTree.swift:
  
 extension
 BinarySearchTree
  {
  
  
 107",NA
Optimizing contains,"You can rely on the rules of the BST to avoid needless 
 comparisons. Back in BinarySearchTree.swift, update the 
 contains
  
 method to the",NA
Removing elements,"Removing elements is a little more tricky, as there are a few different 
 scenarios you need to handle.
  
 109",NA
Case 1: Leaf node ,"Removing a leaf node is straightforward:
  
  
 Simply detaching the leaf node is enough.
  
 For non-leaf nodes however, there are extra steps to be taken.",NA
Case 2: Nodes with one child ,"When removing nodes with one child, you’ll need to reconnect that 
 one child with the rest of the tree:
  
  
 110",NA
Case 3: Nodes with two children,"Nodes with two children are a bit more complicated, so a more 
  
 complex example tree will serve better to illustrate how to handle this 
 situation. Assume you have the following tree and you want to 
  
 remove the value 25:
  
  
 Simply deleting the node presents a dilemma:
  
 111",NA
Implementation,"Open up BinarySearchTree.swift to implementing 
 remove
 . Add the 
 following code at the bottom of the file:
  
 privateextension
 BinaryNode
  {
  
  
 var
 min
 : 
 BinaryNode
  {
  
 return
  leftChild?.
 min
  ?? 
 self
  
  }
  
 }
  
  
 extension
 BinarySearchTree
  {
  
  
 publicmutatingfunc
 remove
 (
 _
  value: Element)
  {
  
  root = remove(node: root, value: value)
  
  }
  
 privatefunc
 remove
 (node: BinaryNode<Element>?, value: Element)
  
 114",NA
Where to go from here?,"The BST is a powerful data structure that can delivers great 
  
 performance when managing sorted data. In this chapter, you learned 
 about the 
 insert
 , 
 remove
 , and 
 contains
  methods of the binary search tree. 
 You also learned about its Achilles’ heel: the performance of 
 operations on a BST can degrade to O(n) if the tree becomes 
  
 unbalanced.
  
 In the next chapter, you’ll learn about a self-balancing binary search 
 tree: the AVL tree.
  
 117",NA
AVL Trees,"In the previous chapter, you learned about the O(log n) performance 
 characteristics of the binary search tree. However, you also learned 
 that unbalanced trees can deteriorate the performance of the tree, all 
 the way down to O(n). In 1962, Georgy Adelson-Velsky and Evgenii 
 Landis came up with the first self-balancing binary search tree: the 
 AVL Tree.",NA
Understanding balance,"A balanced tree is the key to optimizing the performance of the binary 
 search tree. In this section, you’ll learn about the three main states of 
 balance.",NA
Perfect balance,"The ideal form of a binary search tree is the perfectly balanced state. 
 In technical terms, this means every level of the tree is filled with 
 nodes, from top to bottom.
  
  
 Not only is the tree perfectly symmetrical, the nodes at the bottom 
 level are completely filled. This is the requirement for being perfectly 
 balanced.",NA
"""Good-enough"" balance",118,NA
Unbalanced,"Finally, there’s the unbalanced state. Binary search trees in this state 
 suffer from various levels of performance loss, depending on the 
 degree of imbalance.
  
  
 Keeping the tree balanced gives the find, insert and remove 
  
 operations an O(log n) time complexity. AVL trees maintain balance 
 by adjusting the structure of the tree when the tree becomes
  
 119",NA
Implementation,"Inside the starter project for this chapter is an implementation of the 
 binary search tree as created in the previous chapter. The only 
 difference is that all references to the binary search tree have been 
 renamed to AVL tree.
  
 Binary search trees and AVL trees share much of the same 
  
 implementation; In fact, all that you’ll be adding is the balancing 
 component. Open up the starter project to begin.",NA
Measuring balance,"To keep a binary tree balanced, you’ll need a way to measure the 
 balance of the tree. The AVL tree achieves this with a 
 height
  property 
 in each node. In tree-speak, the height of a node is the longest 
  
 distance from the current node to a leaf node:
  
  
 Open the starter playground for this chapter and add the following 
  
 120",NA
Rotations,"The procedures used to balance a binary search tree are known as 
 rotations. There are four rotations in total, for the four different ways 
 that a tree can become unbalanced. These are known as left rotation, 
 left-right rotation, right rotation, and right-left rotation.",NA
Left rotation,"The imbalance caused by inserting 40 into the tree can be solved by 
 a left rotation. A generic left rotation of node x looks like this:
  
  
 Before going into specifics, there are two takeaways from this before 
 and after comparison:
  
  
 In-order traversal for these nodes remains the same.
  
  
 The depth of the tree is reduced by 1 level after the rotation.
  
 123",NA
Right rotation,"Right rotation is the symmetrical opposite of left rotation. When a 
 series of left children is causing an imbalance, it’s time for a right 
 rotation. A generic right rotation of node x looks like this:
  
 125",NA
Right-left rotation,"You may have noticed that the left and right rotations balance nodes 
 that are all left children or all right children. Consider the case where 
 36 is inserted into the original example tree.
  
 126",NA
Left-right rotation,"Left-right rotation is the symmetrical opposite of the right-left 
 rotation. Here’s an example:
  
  
 1. You apply a left rotation to node 10.
  
 2. Now that nodes 25, 15, and 10 are all left children, you can apply 
  
 a right rotation to balance the tree.
  
 Add the following code just after 
 rightLeftRotate
 :
  
 privatefunc
 leftRightRotate
 (
 _
  node: AVLNode<Element>)
  -> 
 AVLNode 
  
 guardlet
  leftChild = 
 node.leftChild 
 else
  { 
  
    
 return
  node
  
  
  }
  
 128",NA
Balance,"The next task is to design a method that uses 
 balanceFactor
  to decide 
 whether a node requires balancing or not. Write the following method 
 below 
 leftRightRotate
 :
  
 privatefunc
 balanced
 (
 _
  node: AVLNode<Element>)
  -> 
 AVLNode
 <
 Element 
 switch
  
 node.balanceFactor { 
  
 case
 2
 : 
  
  
  
 // ...
  
 case
  -
 2
 : 
  
 // ...
  
  
 default
 : 
  
    
 return
  node
  
  
  } 
  
 }
  
 There are three cases to consider.
  
 1. A 
 balanceFactor
  of 2 suggests that the left child is “heavier”(that 
 is, contains more nodes) than the right child. This means you 
 want to use either right or left-right rotations.
  
 2. A 
 balanceFactor
  of -2 suggests that the right child is heavier than 
 the left child. This means you want to use either left or right-
 left rotations.
  
 3. The default case suggests that the particular node is balanced. 
  
 There’s nothing to do here except to return the node.
  
 The sign of the 
 balanceFactor
  can be used to determine if a single or 
  
 129",NA
Revisiting insertion,"You’ve already done the majority of the work. The remainder is fairly 
  
 130",NA
Revisiting remove,"Retrofitting the 
 remove
  operation for self-balancing is just as easy as 
 fixing insert. In 
 AVLTree
 , find 
 remove
  and replace the final 
 return 
 statement with the following:
  
 let
  balancedNode = balanced(node)
  
 balancedNode.height = 
 max
 (balancedNode.leftHeight, balancedNode.right
  
 return
  balancedNode
  
 Head back to the playground page and add the following code at 
 the bottom of the file:
  
 example(of: 
 ""removing a value""
 ) {
  
  
 var
  tree = 
 AVLTree
 <
 Int
 >()
  
  
  tree.insert(
 15
 )
  
  
  tree.insert(
 10
 )
  
  
  tree.insert(
 16
 )
  
  
  tree.insert(
 18
 )
  
  
 print
 (tree)
  
  
  tree.remove(
 10
 )
  
  
 print
 (tree)
  
  
 }",NA
Where to go from here?,"Whew! The AVL tree is the culmination of your search for the 
 ultimate binary search tree. The self-balancing property guarantees 
 that the 
 insert
  and 
 remove
  operations function at optimal 
  
 performance with an O(log n) time complexity.
  
 While AVL trees were the first self-balancing implementations of a 
 BST, others, such as the red-black tree and splay tree, have since 
 joined the party. If you’re interested, you check those out in the Swift 
 Algorithm Club. Find them at at: 
  
 https://github.com/raywenderlich/swift-algorithm-
  
 club/tree/master/Red-Black%20Tree
  and 
  
 https://github.com/raywenderlich/swift-algorithm-
  
 club/tree/master/Splay%20Tree
  respectively.
  
 133",NA
Tries,"The trie (pronounced as try) is a tree that specializes in storing data 
 that can be represented as a collection, such as English words:
  
  
 Each character in a string is mapped to a node. The last node in 
 each string is marked as a terminating node (a dot in the image 
 above).
  
 The benefits of a trie are best illustrated by looking at it in the context 
 of prefix matching.",NA
Example,"You are given a collection of strings. How would you build a 
 component that handles prefix matching? Here’s one way:
  
 class
 EnglishDictionary
  {
  
  
 privatevar
  words: [
 String
 ]
  
  
 func
 words
 (matching 
 prefix
 : String)
  -> [
 String
 ] {
  
  
 return
  words.
 filter
  { $
 0
 .hasPrefix(
 prefix
 ) }
  
  
  }
  
  
 }",NA
Implementation,"As always, open up the starter playground for this chapter.",NA
TrieNode ,"You’ll begin by creating the node for the trie. In the Sources directory, 
 create a new file named TrieNode.swift. Add the following to the file:
  
 publicclass
 TrieNode
 <
 Key
 : 
 Hashable
 > {
  
  
 // 1
  
  
 publicvar
  key: 
 Key
 ?
  
  
 // 2
  
  
 publicweakvar
  parent: 
 TrieNode
 ?
  
  
 // 3
  
  
 publicvar
  children: [
 Key
 : 
 TrieNode
 ] = [:]
  
  
 // 4
  
  
 publicvar
  isTerminating = 
 false
  
  
 137",NA
Trie,"Next, you’ll create the trie itself, which will manage the nodes. In the 
 Sources folder, create a new file named Trie.swift. Add the following 
 to the file:
  
 publicclass
 Trie
 <
 CollectionType
 : 
 Collection
 >
  
  
 whereCollectionType
 .
 Element
 : 
 Hashable
  {
  
  
 publictypealias
 Node
  = 
 TrieNode
 <
 CollectionType
 .
 Element
 >
  
  
 privatelet
  root = 
 Node
 (key: 
 nil
 , parent: 
 nil
 )
  
  
 publicinit
 () {}
  
  
 }
  
 138",NA
Insert,"Tries work with any type that conforms to 
 Collection
 . The trie will 
 take the collection and represent it as a series of nodes, where 
 each node maps to an element in the collection.
  
 Add the following method to 
 Trie
 :
  
 publicfunc
 insert
 (
 _
  collection: CollectionType)
  {
  
 // 1
  
 var
  current = root
  
  
 // 2
  
 for
  element 
 in
  collection {
  
 if
  current.children[element] == 
 nil
  {
  
  current.children[element] = 
 Node
 (key: element, parent: current)
  
  }
  
  current = current.children[element]!
  
  }
  
  
 // 3
  
  current.isTerminating = 
 true
  
 }
  
 Here’s what’s going on:
  
 1. 
 current
  keeps track of your traversal progress, which starts with 
  
 the root node.
  
 2. A trie stores each element of a collection in separate nodes. For 
  
 139",NA
Contains,"contains
  is very similar to 
 insert
 . Add the following method to 
 Trie
 :
  
 publicfunc
 contains
 (
 _
  collection: CollectionType)
  -> 
 Bool
  {
  
 var
  current = root
  
 for
  element 
 in
  collection {
  
 guardlet
  child = current.children[element] 
 else
  {
  
 returnfalse
  
  }
  
  current = child
  
  }
  
 return
  current.isTerminating
  
 }
  
 Here you traverse the trie in a way similar to 
 insert
 . You check every 
 element of the collection to see if it’s in the tree. When you reach the 
 last element of the collection, it must be a terminating element. If not, 
 the collection was not added to the tree and what you’ve found is 
 merely a subset of a larger collection.
  
 The time complexity of 
 contains
  is O(k), where k is the number of 
  
 140",NA
Remove,"Removing a node in the trie is a bit more tricky. You need to be
  
 particularly careful when removing each node, since nodes can be
  
 shared between two different collections. Write the following method
  
 just below 
 contains
 :
  
 publicfunc
 remove
 (
 _
  collection: CollectionType)
  {
  
  
 // 1
  
  
 var
  current = root
  
  
 for
  element 
 in
  collection {
  
  
 guardlet
  child = current.children[element] 
 else
  {
  
  
 return
  
  
  }
  
  
  current = child
  
  
  }
  
  
 guard
  current.isTerminating 
 else
  {",NA
Prefix matching,"The most iconic algorithm for the trie is the prefix matching 
 algorithm. Write the following at the bottom of Trie.swift:
  
 publicextension
 TriewhereCollectionType
 : 
 RangeReplaceableCollectio
  
 }
  
 Your prefix matching algorithm will sit inside this extension, where 
  
 143",NA
Where to go from here?,"In this chapter, you learned about the trie, a tree structure that 
 provides great performance metrics in regards to prefix matching. 
 Tries are often featured in coding interviews, so study up!
  
 146",NA
Binary Search,"Binary search is one of the most efficient searching algorithms with a 
 time complexity of O(log n). This is comparable with searching for an 
 element inside a balanced binary search tree.
  
 There are two conditions that need to be met before binary search 
 may be used:
  
  
  
 The collection must be able to perform index manipulation in 
 constant time. This means that the collection must be a 
 RandomAccessCollection
 .
  
 The collection must be sorted.",NA
Example,"The benefits of binary search are best illustrated by comparing it with 
 linear search. Swift’s 
 Array
  type uses linear search to implement its 
 index(of:)
  method. This means it traverses through the whole collection, 
 or until it finds the element:
  
 Binary search handles things differently by taking advantage of the 
 fact that the collection is already sorted.
  
 Here’s an example of applying binary search to find the value 31:
  
 147",NA
Step 1: Find middle index,"The first step is to find the middle index of the collection. This is 
 fairly straightforward:",NA
Step 2: Check the element at the middle index,"The next step is to check the element stored at the middle index. If it 
 matches the value you’re looking for, you return the index. Otherwise, 
 you’ll continue to Step 3.",NA
Step 3: Recursively call binary Search,"The final step is to recursively call binary search. However, this time 
 you’ll only consider the elements exclusively to the left or to the right of 
 the middle index, depending on the value you’re searching for. If the 
 value you’re searching for is less than the middle value, you search 
 the left subsequence. If it is greater than the middle value, you search 
 the right subsequence. Each step effectively removes half of the 
 comparisons you would otherwise need to perform.
  
 148",NA
Implementation,"Open the starter playground for this chapter. Create a new file in the 
 Sources folder named BinarySearch.swift. Add the following to the 
 file:
  
 // 1
  
 publicextension
 RandomAccessCollectionwhereElement
 : 
 Comparable
  
 // 2
  
 func
 binarySearch
 (
 for
  value: Element, 
 in
  range: Range<Index>? = 
  
  -> 
 Index
 ? {
  
  
 // more to come
  
  
  }
  
  
 }
  
 Things are fairly simple, so far:
  
 1. Since binary search only works for types that conform to 
  
  
 RandomAccessCollection
 , you add the method in an extension on
  
 149",NA
Where to go from here?,"Binary search is a powerful algorithm to learn and comes up often in 
 programming interviews. Whenever you read something along the 
 lines of “Given a sorted array...”, consider using the binary search 
 algorithm. Also, if you are given a problem that looks like it is going to 
 be O(n²) to search, consider doing some up-front sorting so you can 
 use binary searching to reduce it down to the cost of the sort at O(n 
 log n).
  
 151",NA
The Heap Data Structure,"A heap is a complete binary tree, also known as a binary heap, 
 that can be constructed using an array.
  
 Heaps come in two flavors:
  
 1. Max heap, where elements with a higher value have a higher 
  
 priority.
  
 2. Min heap, where elements with a lower value have a higher 
  
 priority.
  
 Have you seen the movie Toy Story, with the claw machine and the 
 squeaky little green aliens? Imagine that the claw machine is 
  
 operating on your heap structure, and will always pick the minimum 
 or maximum value, depending on the type of heap.",NA
The heap property,152,NA
Heap applications,"Some useful applications of a heap include:
  
  
  
  
  
 Calculating the minimum or maximum element of a collection 
 Heap Sort 
  
 Constructing a priority queue 
  
 Constructing graph algorithms like Prim’s or Dijkstra’s with a 
 priority queue.
  
  
 Note: You will learn about Priority Queues in Chapter 13, Heap 
 Sort in Chapter 17 and Dijkstra’s and Prim’s algorithms in 
 Chapter 22 and 23.
  
 154",NA
Common heap operations,"Open the empty starter playground for this chapter. Start by defining 
 the following basic 
 Heap
  type:
  
 struct
 Heap
 <
 Element
 : 
 Equatable
 > {
  
  
 var
  elements: [
 Element
 ] = []
  
  
 let
 sort
 : (
 Element
 , 
 Element
 ) -> 
 Bool
  
  
 init
 (
 sort
 : @escaping (
 Element
 , 
 Element
 ) -> 
 Bool
 ) {
  
  
 self
 .
 sort
  = 
 sort
  
  
  }
  
  
 }
  
 This type contains an array to hold the elements in the heap and a sort 
 function that defines how the heap should be ordered. By passing an 
 appropriate function in the initializer, this type can be used to create 
 both min and max heaps.",NA
How do you represent a heap?,"Trees hold nodes that store references to their children. In the case of 
 a binary tree, these are references to a left and right child. Heaps are
  
 155",NA
Removing from a heap,"A basic remove operation simply removes the root node from the 
 heap.
  
 Take the following max heap:
  
 159",NA
Implementation of remove,"Add the following method to 
 Heap
 :
  
 mutatingfunc
 remove
 ()
  -> 
 Element
 ? {
  
 guard
  !isEmpty 
 else
  { 
 // 1 
  
   
 returnnil
  
  }
  
  elements.swapAt(
 0
 , 
 count
  - 
 1
 ) 
 // 2 
 defer
  {
  
  
  siftDown(from: 
 0
 ) 
 // 4
  
  } 
  
 return
  elements.removeLast() 
 // 3
  
 }
  
 Here’s how this method works:
  
 1. Check to see if the heap is empty. If it is, return 
 nil
 .
  
 2. Swap the root with the last element in the heap.
  
 3. Remove the last element (the maximum or minimum value) and 
  
 return it.
  
 4. The heap may not be a max or min heap anymore, so you 
 must 
  
 perform a sift down to make sure it conforms to the 
 rules.
  
 Now to see how to sift down nodes. Add the following method after 
 remove()
 :
  
 mutatingfunc
 siftDown
 (from index: Int)
  {
  
 var
  parent = index 
 // 1 
  
 whiletrue
  { 
 // 2 
  
  
 letleft
  = leftChildIndex(ofParentAt: parent) 
 // 3 
  
 letright
  = 
 rightChildIndex(ofParentAt: parent)
  
 var
  candidate = parent 
 // 4
  
  
 162",NA
Inserting into a heap ,"Let’s say you insert a value of 7 to the heap below:
  
  
 First, you add the value to the end of the heap:
  
 164",NA
Implementation of insert,"Add the following method to 
 Heap
 :
  
 mutatingfunc
 insert
 (
 _
  element: Element)
  {
  
  elements.append(element)
  
  siftUp(from: elements.
 count
  - 
 1
 )
  
 }
  
  
 mutatingfunc
 siftUp
 (from index: Int)
  {
  
  
 var
  child = index
  
  
 166",NA
Removing from an arbitrary index,"Add the following to 
 Heap
 :
  
 mutatingfunc
 remove
 (at index: Int)
  -> 
 Element
 ? {
  
 guard
  index < elements.
 count
 else
  { 
  
 returnnil
 // 1
  
  } 
  
 if
  index == elements.
 count
  - 
 1
  {
  
 return
  elements.removeLast() 
 // 2
  
  
 167",NA
Searching for an element in a heap,"To find the index of the element you wish to delete, you must perform 
 a search on the heap. Unfortunately, heaps are not designed for fast 
 searches. With a binary search tree, you can perform a search in 
 O(log n) time, but since heaps are built using an array, and the node 
  
 ordering in an array is different, you can’t even perform a binary 
 search.
  
 Complexity: To search for an element in a heap is, in the worst-
 case, an O(n) operation, since you may have to check every 
 element in the array.
  
  
 func
 index
 (of element: Element, startingAt i: Int)
  -> 
 Int
 ? {
  
  
 if
  i >= 
 count
  { 
  
    
 returnnil
 // 1
  
  
  } 
  
  
 if
 sort
 (element, elements[i]) { 
  
    
 returnnil
 // 2
  
  
  } 
  
  
 if
  element == elements[i] { 
  
    
 return
  i 
 // 3
  
  
  } 
  
  
 iflet
  j = index(of: element, startingAt: leftChildIndex(ofParentAt 
  
  
  
 return
  j 
 // 4
  
  
  } 
  
  
 iflet
  j = index(of: element, startingAt: rightChildIndex(ofParentA 
  
  
  
 return
  j 
 // 5
  
  
  } 
  
  
 returnnil
 // 6 
  
 }
  
 Let’s go over this implementation:
  
 1. If the index is greater than the number of elements in the array, 
  
 the search failed. Return 
 nil
 .
  
 170",NA
Building a heap,"You now have all the necessary tools to represent a heap. To wrap 
 up this chapter, you’ll build a heap from an existing array of elements 
 and test it out.
  
 Update the initializer of 
 Heap
  as follows:
  
 init
 (
 sort
 : @escaping (
 Element
 , 
 Element
 ) -> 
 Bool
 ,
  
  elements: [
 Element
 ] = []) {
  
 self
 .
 sort
  = 
 sort
  
 self
 .elements = elements
  
  
 if
  !elements.isEmpty {
  
 for
  i 
 in
 stride
 (from: elements.
 count
  / 
 2
  - 
 1
 , through: 
 0
  
  siftDown(from: i)
  
  }
  
  
 171",NA
Testing,"Time to try it out. Add the following to your playground:
  
 172",NA
Where to go from here?,"Here is a summary of the algorithmic complexity of the heap 
 operations you implemented in this chapter.
  
 173",NA
Priority Queue,"Queues are simply lists that maintain the order of elements using first-
 in-first-out (FIFO) ordering. A priority queue is another version of a 
 queue that, instead of using FIFO ordering, dequeues elements in 
 priority order. For example, a priority queue can either be:
  
 1. Max-priority, where the element at the front is always the 
  
 largest.
  
 2. Min-priority, where the element at the front is always the 
  
 smallest.
  
  
 A priority queue is especially useful when you need to identify the 
 maximum or minimum value given a list of elements.",NA
Applications,"Some useful applications of a priority queue include:
  
 175",NA
Common operations,"In Chapter 5, Queues, you established the following protocol for 
 queues:
  
 publicprotocol
 Queue
  {
  
  
  associatedtype 
 Element
  
  
 mutatingfunc
 enqueue
 (
 _
  element: Element)
  -> 
 Bool
  
  
 mutatingfunc
 dequeue
 ()
  -> 
 Element
 ?
  
  
 var
  isEmpty: 
 Bool
  { 
 get
  }
  
  
 var
  peek: 
 Element
 ? { 
 get
  }
  
  
 }
  
 A priority queue has the same operations as a normal queue, so 
 only the implementation will be different.
  
 The priority queue will conform to the 
 Queue
  protocol and implement 
 the common operations:
  
  
 enqueue
 : Inserts an element into the queue. Returns 
 true
  if the 
 operation was successful.
  
 176",NA
Implementation,"You can create a priority queue in the following ways:
  
 1. Sorted array: This is useful to obtain the maximum or minimum 
 value of an element in O(1) time. However, insertion is slow and 
 will require O(n) since you have to insert it in order.
  
 2. Balanced binary search tree: This is useful in creating a double-
 ended priority queue, which features getting both the minimum 
 and maximum value in O(log n) time. Insertion is better than a 
 sorted array, also in O(log n) .
  
 3. Heap: This is a natural choice for a priority queue. A heap is more 
 efficient than a sorted array because a heap only needs to be 
 partially sorted. All heap operations are O(log n) except 
  
 extracting the min value from a min priority heap is a lightning fast 
 O(1). Likewise, extracting the max value from a max priority heap 
 is also O(1).
  
 Next you will look at how to use a heap to create a priority queue.
  
 Open up the starter playground to get started. In the Sources folder 
 you will notice the following files:
  
 1. Heap.swift: The heap data structure (from the previous chapter) 
 177",NA
Testing,"Add the following to your playground:
  
 var
  priorityQueue = 
 PriorityQueue
 (
 sort
 : >, elements: [
 1
 ,
 12
 ,
 3
  
  
 while
  !priorityQueue.isEmpty {
  
  
 print
 (priorityQueue.dequeue()!)
  
  
 }
  
 You’ll notice a priority queue has the same interface as a regular 
 queue. The previous code creates a max priority queue. Notice 
 that
  
 179",NA
Where to go from here?,"A priority queue is basically a heap that is useful when you need to 
 find the maximum or minimum element immediately.
  
 Not only did you learn how to implement a priority queue, you learned 
 to apply the heap data structure and conformed to the queue 
 protocol. Now that’s composition!
  
 180",NA
O(n²) Sorting Algorithms,"O(n²) time complexity is not great performance, but the sorting 
 algorithms in this category are easy to understand and useful in some 
 scenarios. These algorithms are space efficient; they only require 
 constant O(1) additional memory space. For small data sets, these 
 sorts compare very favorably against more complex sorts.
  
 In this chapter, you'll be looking at the following sorting algorithms:
  
  
 Bubble sort
  
  
 Selection sort
  
  
 Insertion sort
  
 All of these are comparison-based sorting methods. They rely on a 
 comparison method, such as the less-than operator, to order the 
 elements. The number of times this comparison gets called is how you 
 can measure a sorting technique's general performance.",NA
Bubble sort,"One of the simplest sorts is the bubble sort, which repeatedly 
  
 compares adjacent values and swaps them, if needed, to perform the 
 sort. The larger values in the set will therefore ""bubble up"" to the end 
 of the collection.",NA
Example,"Consider the following hand of cards:
  
 181",NA
Implementation,"Open up the Swift playground for this chapter to get started. In the 
 Sources directory of your playground, create a new file named 
 BubbleSort.swift. Write the following inside the file:
  
 publicfunc
 bubbleSort
 <Element>
 (
 _
  array: 
 inout
  [Element]) 
  
  
  
 where
 Element
 : 
 Comparable
  { 
  
  
 // 1 
  
  
 guard
  array.
 count
  >= 
 2
 else
  { 
  
    
 return
  
  
  } 
  
  
 // 2 
  
  
 for
  end 
 in
  (
 1
 ..<array.
 count
 ).reversed() { 
  
    
 var
  swapped = 
 false 
  
    
 // 3 
  
    
 for
  current 
 in
 0
 ..<end {
  
 if
  array[current] > array[current + 
 1
 ] {
  
  
 183",NA
Selection sort,"Selection sort follows the basic idea of bubble sort, but improves upon 
 this algorithm by reducing the number of 
 swapAt
  operations.
  
 Selection sort will only swap at the end of each pass. You'll see how 
 that works in the following implementation.",NA
Example,"Assume you have the following hand of cards:
  
  
 During each pass, selection sort will find the lowest unsorted value 
 and swap it into place:
  
 1. First, 3 is found as the lowest value. It is swapped with 9.
  
 2. The next lowest value is 4. It's already in the right place.
  
 3. Finally, 9 is swapped with 10.
  
 185",NA
Implementation,"In the Sources directory of your playground, create a new file named 
 SelectionSort.swift. Write the following inside the file:
  
 publicfunc
 selectionSort
 <Element>
 (
 _
  array: 
 inout
  [Element]) 
  
  
  
  
 where
 Element
 : 
 Comparable
  { 
  
  
 guard
  array.
 count
  >= 
 2
 else
  { 
  
     
 return
  
  
  } 
  
  
 // 1 
  
  
 for
  current 
 in
 0
 ..<(array.
 count
  - 
 1
 ) { 
  
     
 var
  lowest = current 
  
     
 // 2 
  
     
 for
  other 
 in
  (current + 
 1
 )..<array.
 count
  { 
  
       
 if
  array[lowest] > array[other] {
  
        
  lowest = other
  
      
  }
  
    
  } 
  
     
 // 3 
  
     
 if
  lowest != current {
  
      
  array.swapAt(lowest, current)
  
  }
  
  
 186",NA
Insertion sort,187,NA
Example,"The idea of insertion sort is similar to how you'd sort a hand of cards. 
 Consider the following hand:
  
  
 Insertion sort will iterate once through the cards, from left to right. 
 Each card is shifted to the left until it reaches its correct position.
  
 188",NA
Implementation,"In the Sources directory of your playground, create a new file named 
 InsertionSort.swift. Write the following inside the file:
  
 publicfunc
 insertionSort
 <Element>
 (
 _
  array: 
 inout
  [Element]) 
  
  
  
  
 where
 Element
 : 
 Comparable
  { 
  
  
 guard
  array.
 count
  >= 
 2
 else
  { 
  
     
 return
  
  
  } 
  
  
 // 1 
  
  
 for
  current 
 in
 1
 ..<array.
 count
  { 
  
     
 // 2 
  
     
 for
  shifting 
 in
  (
 1
 ...current).reversed() { 
  
       
 // 3 
  
       
 if
  array[shifting] < array[shifting - 
 1
 ] {
  
        
  array.swapAt(shifting, shifting - 
 1
 )
  
      
  } 
 else
  { 
  
        
 break
  
      
  }
  
    
  }
  
  
  } 
  
 }
  
 Here's what you did above:
  
 1. Insertion sort requires you to iterate from left to right once. This 
  
 loop does that.
  
 2. Here, you run backwards from the current index so you can shift 
  
 left as needed.
  
 3. Keep shifting the element left as long as necessary. As soon as 
 the element is in position, break the inner loop and start with the 
 next element.
  
 Head back to the main playground page and write the following at the 
 bottom:
  
 190",NA
Generalization,"In this section, you'll generalize these sorting algorithms for 
 collection types other than 
 Array
 . Exactly which collection types, 
 though, depends on the algorithm:
  
  
  
  
 Insertion sort traverses the collection backwards when shifting 
 elements. As such, the collection must be of type 
  
 BidirectionalCollection
 .
  
 Bubble sort and selection sort really only traverse the collection 
 front to back, so they can handle any 
 Collection
 .
  
 In any case, the collection must be a 
 MutableCollection
  as you 
 need to be able to swap elements.
  
 Head back to BubbleSort.swift and update the function to the 
  
 191",NA
Where to go from here?,"In the next chapters, you'll take a look at sorting algorithms that 
 perform better than O(n²). Up next is a sorting algorithm that uses a
  
 193",NA
Merge Sort,"Merge sort is one of the most efficient sorting algorithms. With a time 
 complexity of O(log n), it’s one of the fastest of all general-purpose 
 sorting algorithms. The idea behind merge sort is divide and conquer; 
 to break up a big problem into several smaller, easier to solve 
  
 problems and then combine those solutions into a final result. The 
 merge sort mantra is to split first and merge after.
  
 Assume you’re given a pile of unsorted playing cards:
  
  
 The merge sort algorithm works as follows:
  
 1. First, split the pile in half. You now have two unsorted piles:
  
  
 1. Now keep splitting the resulting piles until you can’t split 
  
  
 anymore. In the end, you will have one (sorted!) card in each pile:
  
 195",NA
Implementation,Open up the starter playground to get started.,NA
Split,"In the Sources folder in your playground, create a new file named 
 MergeSort.swift. Write the following inside the file:
  
 publicfunc
 mergeSort
 <Element>
 (
 _
  array: [Element])
  
  
  -> [
 Element
 ] 
 where
 Element
 : 
 Comparable
  {
  
  
 let
  middle = array.
 count
  / 
 2
  
  
 letleft
  = 
 Array
 (array[..<middle])
  
  
 letright
  = 
 Array
 (array[middle...])
  
  
 // ... more to come
  
  
 }
  
 Here you split the array into halves. Splitting once isn’t enough, 
 however; you have to keep splitting recursively until you can’t split any 
 more, which is when each subdivision contains just one element.=
  
 To do this, update 
 mergeSort
  as follows:
  
 publicfunc
 mergeSort
 <Element>
 (
 _
  array: [Element])
  
  
  -> [
 Element
 ] 
 where
 Element
 : 
 Comparable
  { 
 // 1 
  
 guard
  array.
 count
  > 
 1
 else
  { 
  
   
 return
  array
  
  }
  
 let
  middle = array.
 count
  / 
 2
  
  
 197",NA
Merge,"Your final step is to merge the 
 left
  and 
 right
  arrays together. To keep 
 things clean, you will create a separate 
 merge
  function for this.
  
 The sole responsibility of the merging function is to take in two 
 sorted
  
 arrays and combine them while retaining the sort order. Add the 
 following just below the 
 mergeSort
  function:
  
 privatefunc
 merge
 <Element>
 (
 _
 left
 : [Element], 
 _
 right
 : [Element])
   
  -> [
 Element
 ] 
 where
 Element
 : 
 Comparable
  { 
  
 // 1 
  
 var
  leftIndex = 
 0 
  
 var
  rightIndex = 
 0 
  
 // 2 
  
 var
  result: [
 Element
 ] = [] 
  
 // 3 
  
 while
  leftIndex < 
 left
 .
 count
  && rightIndex < 
 right
 .
 count
  { 
   
  
 let
  leftElement = 
 left
 [leftIndex] 
  
  
   
 let
  rightElement = 
 right
 [rightIndex]
  
 198",NA
Finishing up,"Complete the 
 mergeSort
  function by calling 
 merge
 . Because you call 
 mergeSort
  recursively, the algorithm will split and sort both halves 
 before merging them together.
  
 publicfunc
 mergeSort
 <Element>
 (
 _
  array: [Element])
  
  
  -> [
 Element
 ] 
 where
 Element
 : 
 Comparable
  { 
 guard
  array.
 count
  > 
 1
 else
  { 
  
   
 return
  array
  
  } 
  
 let
  middle = array.
 count
  / 
 2 
  
 letleft
  = mergeSort(
 Array
 (array[..< middle])) 
 letright
  = 
 mergeSort(
 Array
 (array[middle...])) 
 return
  merge(
 left
 , 
 right
 )
  
 }
  
 This is the final version of the merge sort algorithm. Here’s a 
 summary of the key procedures of merge sort:
  
 1. The strategy of merge sort is to divide and conquer, so that you 
  
 solve many small problems instead of one big problem.
  
 2. It has two core responsibilities: a method to divide the initial 
  
 array recursively, and a method to merge two arrays.
  
 3. The merging function should take two sorted arrays and produce 
  
 a single sorted array.
  
 Finally - time to see this in action. Head back to the main playground 
 page and test your merge sort with the following:
  
 example(of: 
 ""merge sort""
 ) {
  
  
 let
  array = [
 7
 , 
 2
 , 
 6
 , 
 3
 , 
 9
 ]
  
  
 200",NA
Performance,"The best, worst and average time complexity of merge sort is O(n log 
 n), which isn’t too bad. If you’re struggling to understand where n log n 
 comes from, think about how the recursion works:
  
  
  
 As you recurse, you split a single array into two smaller arrays. 
 This means an array of size 2 will need 1 level of recursion, an 
 array of size 4 will need 2 levels, an array of size 8 will need 3 
 levels, and so on. If you had an array of 1024 elements, it would 
 take 10 levels of recursively splitting in two to get down to 1024 
 single element arrays. In general, if you have an array of size n, 
 the number of levels is log2(n).
  
 A single recursion level will merge n elements. It doesn’t matter if 
 there are many small merges or one large one; the number of 
 elements merged will still be n at each level. This means the cost 
 of a single recursion is O(n).
  
 This brings the total cost to O(log n) × O(n) = O(n log n).
  
 The previous chapter’s sort algorithms were in-place and used 
 swapAt 
 to move elements around. Merge sort, by contrast, allocates 
  
 additional memory to do its work. How much? There are log2(n) levels 
 of recursion and at each level n elements are used. That makes the 
 total O(n log n) in space complexity.
  
 201",NA
Where to go from here?,"Merge sort is one of the hallmark sorting algorithms. It’s relatively 
 simple to understand, and serves as a great introduction to how 
 divide-and-conquer algorithms work. Merge sort is O(n log n) and this 
 implementation requires O(n log n) of space. If you are really clever 
 with your bookkeeping, you can reduce the memory required to O(n) 
 by discarding the memory that is not actively being used.
  
 202",NA
Radix Sort,"In this chapter, you’ll look at a completely different model of sorting. 
 So far, you’ve been relying on comparisons to determine the sorting 
 order. Radix sort is a non-comparative algorithm for sorting integers 
 in linear time.
  
 There are multiple implementations of radix sort that focus on 
  
 different problems. To keep things simple, in this chapter you’ll focus 
 on sorting base 10 integers while investigating the least significant 
 digit (LSD) variant of radix sort.",NA
Example,"To show how radix sort works, you’ll sort the following array:
  
 var
  array = [
 88
 , 
 410
 , 
 1772
 , 
 20
 ]
  
 Radix sort relies on the positional notation of integers, as shown here:
  
  
 First, the array is divided into buckets based on the value of the least 
 significant digit: the ones digit.
  
  
 203",NA
Implementation,"Open up the starter project for this chapter. In the Sources directory, 
 create a new file named RadixSort.swift. Add the following to the file:
  
 extension
 ArraywhereElement
  == 
 Int
  {
  
  
 publicmutatingfunc
 radixSort
 ()
  {
  
  
  }
  
  
 }
  
 Here you’ve added a 
 radixSort
  method to arrays of integers via an 
 extension. Start implementing the 
 radixSort
  method using the 
 following:
  
 publicmutatingfunc
 radixSort
 ()
  {
  
  
 // 1
  
  
 let
  base = 
 10
  
  
 // 2
  
  
 var
  done = 
 false
  
  
 205",NA
Bucket Sort,"Write the following inside the 
 while
  loop:
  
 // 1
  
 var
  buckets: [[
 Int
 ]] = .
 init
 (repeating: [], 
 count
 : base) 
 // 2 
  
 forEach {
  
  
  number 
 in 
  
  
 let
  remainingPart = number / digits 
  
  
 let
  digit = remainingPart % base
  
  
  buckets[digit].append(number) 
  
 } 
  
 // 3 
  
 digits *= base
  
 self
  = buckets.flatMap { $
 0
  }
  
 Here’s what you’ve written:
  
 206",NA
When do you stop?,"Your 
 while
  loop currently runs forever, so you’ll need a terminating 
 condition in there somewhere. You’ll do that as follows:
  
 1. At the beginning of the 
 while
  loop, add 
 done = true
 .
  
 2. Inside the closure of 
 forEach
 , add the following:
  
 if
  remainingPart > 
 0
  {
  
  
  done = 
 false
  
  
 }
  
 Since 
 forEach
  iterates over all the integers, as long as one of the 
 integers still has unsorted digits, you’ll need to continue sorting.
  
 With that, you’ve learned about your first non-comparative sorting 
 algorithm! Head back to the playground page and write the following 
 to try out your code:
  
 example(of: 
 ""radix sort""
 ) {
  
  
 var
  array = [
 88
 , 
 410
 , 
 1772
 , 
 20
 ]
  
  
 print
 (
 ""Original array: 
 \(array)
 ""
 )
  
  
  array.radixSort()
  
  
 print
 (
 ""Radix sorted: 
 \(array)
 ""
 )
  
  
 }
  
 207",NA
Where to go from here?,"Radix sort is one of the fastest sorting algorithms. The average time 
 complexity of radix sort is O(k × n), where k is the number of 
  
 significant digits of the largest number, and n is the number of 
 integers in the array.
  
 Radix sort works best when k is constant, which occurs when all 
 numbers in the array have the same count of significant digits. Its 
 time complexity then becomes O(n). Radix sort also incurs a O(n) 
 space complexity, as you need space to store each bucket.
  
 208",NA
Heap Sort ,"Heapsort is another comparison-based algorithm that sorts an array 
 in ascending order using a heap. This chapter builds on the heap 
 concepts presented in Chapter 12, ""The Heap Data Structure"".
  
 Heapsort takes advantage of a heap being, by definition, a partially 
 sorted binary tree with the following qualities: 
  
  
 1. In a max heap, all parent nodes are larger than their children.
  
  
 2. In a min heap, all parent nodes are smaller than their children. The 
 diagram below shows a heap with parent node values underlined:",NA
Getting started ,"Open up the starter playground. This playground already contains an 
 implementation of a max heap. Your goal is to extend 
 Heap
  so it can 
 also sort. Before you get started, let's look at a visual example of how 
 heap sort works.
  
 209",NA
Example ,"For any given unsorted array, to sort from lowest to highest, heap sort 
 must first convert this array into a max heap.
  
  
 This conversion is done by sifting down all the parent nodes so they 
 end up in the right spot. The resulting max heap is:
  
  
 Which corresponds with the following array:
  
  
 210",NA
Implementation,"Next, you’ll implement this sorting algorithm. The actual 
  
 implementation is very simple, as the heavy lifting is already done by 
 the 
 siftDown
  method:
  
 extension
 Heap
  {
  
 func
 sorted
 ()
  -> [
 Element
 ] { 
  
   
 var
  heap = 
 Heap
 (
 sort
 : 
 sort
 , elements: elements) 
 // 1 
   
 for
  index 
 in
  
 heap.elements.
 indices
 .reversed() { 
 // 2
  
  
  
  
 heap.elements.swapAt(
 0
 , index) 
 // 3
  
    
  heap.siftDown(from: 
 0
 , upTo: index) 
 // 4
  
  
  } 
  
   
 return
  heap.elements
  
  }
  
 }
  
 Here's what's going on:
  
 1. You first make a copy of the heap. After heap sort sorts the 
 elements
  array, it is no longer a valid heap. By working on a copy of 
 the heap, you ensure the heap remains valid.
  
 2. You loop through the array, starting from the last element.
  
 3. You swap the first element and the last element. This moves the 
  
 largest unsorted element to its correct spot.
  
 4. Because the heap is now invalid, you must sift down the new root 
 node. As a result, the next largest element will become the new 
 root.
  
 Note that in order to support heap sort, you've added an additional 
  
 213",NA
Performance,"Even though you get the benefit of in-memory sorting, the 
  
 performance of heap sort is O(n log n) for its best, worse and average 
 cases. This is because you have to traverse the whole list once, and 
 every time you swap elements you must perform a sift down, which is 
 an O(log n) operation.
  
 Heap sort is also not a stable sort because it depends on how the 
 elements are laid out and put into the heap. If you were heap sorting a 
 deck of cards by their rank, for example, you might see their suite 
 change order with respect to the original deck.",NA
Where to go from here?,"Heap sort is a natural application of the heap data structure and you 
 now should have a solid grasp on how heap sorting works. You will 
 use this as a fundamental building block in future chapters as you 
 build your algorithm repertoire.
  
 214",NA
Quicksort,"In the preceding chapters, you’ve learned to sort an array using 
 comparison-based sorting algorithms, merge sort, and heap sort.
  
 Quicksort is another comparison-based sorting algorithm. Much like 
 merge sort, it uses the same strategy of divide and conquer.
  
 One important feature of Quicksort is choosing a pivot point. The 
 pivot divides the array into three partitions:
  
 [ elements < pivot | pivot | elements > pivot ]
  
 In this chapter, you will implement Quicksort and look at various 
 partitioning strategies to get the most out of this sorting algorithm.",NA
Example,"Open up the starter playground. A naïve implementation of Quicksort 
 is provided in quicksortNaive.swift:
  
 publicfunc
 quicksortNaive
 <T: Comparable>
 (
 _
  a: [T])
  -> [
 T
 ] {
  
 guard
  a.
 count
  > 
 1
 else
  { 
 // 1 
  
  
 return
  a
  
  } 
  
 let
  pivot = a[a.
 count
  / 
 2
 ] 
 // 2 
  
 let
  less = a.
 filter
  { $
 0
  < pivot } 
 // 3 
  
 let
 equal
  = a.
 filter
  { $
 0
  == pivot } 
  
 let
  greater = a.
 filter
  { $
 0
  > pivot } 
  
 return
  quicksortNaive(less) + 
 equal
  + quicksortNaive(greater) 
  
 }
  
 Let’s look at how it works:
  
 1. This is a recursive function, so you must have a base case. There 
  
 must be more than one element in the array, otherwise there is
  
 215",NA
Partitioning strategies,"In this section, you will look at partitioning strategies and ways to 
  
 217",NA
Lomuto’s partitioning,"Lomuto’s partitioning algorithm always chooses the last element as 
 the pivot. Let’s look at how this works in code.
  
 In your playground, create a file called quicksortLomuto.swift and add 
 the following function declaration:
  
 publicfunc
 partitionLomuto
 <T: Comparable>
 (
 _
  a: 
 inout
  [T],
  
  
  low: Int, 
  
  
  high: Int)
  -> 
 Int
  
  
 }
  
 This function takes three arguments:
  
  
  
 a
  is the array you are partitioning.
  
 low
  and 
 high
  set the range within the array you will partition. 
 This range will get smaller and smaller with every recursion.
  
 The function returns the index of the pivot.
  
 Now implement the function as follows:
  
 let
  pivot = a[high] 
 // 1
  
  
 var
  i = low 
 // 2
  
 for
  j 
 in
  low..<high { 
 // 3
  
 if
  a[j] <= pivot { 
 // 4
  
  a.swapAt(i, j) 
 // 5
  
  i += 
 1
  
  }
  
 }
  
  
 a.swapAt(i, high) 
 // 6
  
 218",NA
Step-by-step,"Let’s look at a few steps of the algorithm to get a clear understanding 
 of how it works.
  
 Given the unsorted array below:
  
 [
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 8
 ]
  
 First, the last element 8 is selected as the pivot.
  
 0123456789101112
  
  
 [ 
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , |  
 8
   ]
  
  
  low                                        high
  
  
  i
  
  
  j
  
 Then, the first element 12 is compared to the pivot. It is not smaller 
 than the pivot, so the algorithm continues to the next element.
  
 0123456789101112
  
  
 [ 
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , |  
 8
   ]
  
  
  low                                        high
  
  
  i
  
  
  j
  
 The second element 0 is smaller than the pivot, so it is swapped with 
 the element currently at index 
 i
  (12) and 
 i
  is increased.
  
 0123456789101112
  
  
 [ 
 0
 , 
 12
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , |  
 8
   ]
  
  
  low                                         high
  
  
  i
  
  
  j
  
 The third element 3 is again smaller than the pivot, so another swap 
 occurs.
  
 220",NA
Hoare’s partitioning,"Hoare’s partitioning algorithm always chooses the first element as the 
 pivot. Let’s look at how this works in code.
  
 In your playground, create a file named quicksortHoare.swift and add 
 the following function:
  
 publicfunc
 partitionHoare
 <T: Comparable>
 (
 _
  a: 
 inout
  [T], low: Int, h 
 let
  pivot = a[low] 
 // 1 
  
 var
  i = low - 
 1
 // 2 
  
 var
  j = high + 
 1
  
 whiletrue
  { 
  
 repeat
  { j -= 
 1
  } 
 while
  a[j] > pivot 
 // 3 
 repeat
  { i += 
 1
  } 
 while
  a[i] < pivot 
 // 4
  
   
  
 if
  i < j { 
 // 5
  
   
   
  a.swapAt(i, j)
  
   
  } 
 else
  { 
  
   
    
 return
  j 
 // 6
  
   
  }
  
  
  } 
  
 }
  
 222",NA
Step-by-step,"Given the unsorted array below:
  
 [  
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 8
    ]
  
 First, 12 is set as the pivot. Then 
 i
  and 
 j
  will start running through the 
 array, looking for elements that are not lesser than (in the case of 
 i
 ) or 
 greater than (in the case of 
 j
 ) the pivot. 
 i
  will stop at element 12 and 
 j
  
 will stop at element 8.
  
 [  
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 ,  
 8
   ]
  
  
  p
  
  
  i                                         j
  
 223",NA
Effects of a bad pivot choice,"The most important part of implementing Quicksort is choosing the 
 right partitioning strategy.
  
 You have looked at three different partitioning strategies:
  
 1. Choosing the middle element as a pivot.
  
 2. Lomuto, or choosing the last element as a pivot.
  
 3. Hoare, or choosing the first element as a pivot.
  
 What are the implications of choosing a bad pivot?
  
 Let’s start with the following unsorted array:
  
 [
 8
 , 
 7
 , 
 6
 , 
 5
 , 
 4
 , 
 3
 , 
 2
 , 
 1
 ]
  
 If you use Lomuto’s algorithm, the pivot will be the last element 
 1
 . 
 This results in the following partitions:
  
 less: [ ]
  
  
 equal
 : [
 1
 ]
  
 225",NA
Dutch national flag partitioning,"A problem with Lomuto’s and Hoare’s algorithms is that they don’t 
 handle duplicates really well. With Lomuto’s algorithm, duplicates end 
 up in the less than partition and aren’t grouped together. With Hoare’s 
 algorithm, the situation is even worse as duplicates can be all over the 
 place.
  
 A solution to organize duplicate elements is using Dutch national flag 
 partitioning. This technique is named after the Dutch flag which has 
 three bands of colors: red, white and blue. This is similar to how you 
 create three partitions. Dutch national flag partitioning is a good 
 technique to use if you have lots of duplicate elements.
  
 Let’s look at how it’s implemented. Create a file named 
 quicksortDutchFlag.swift and add the following function:
  
 publicfunc
 partitionDutchFlag
 <T: Comparable>
 (
 _
  a: 
 inout
  [T], low: In
  
 let
  pivot = a[pivotIndex]
  
 var
  smaller = low 
 // 1
  
 227",NA
Step-by-step,"Let’s go over an example using the unsorted array below:
  
 [ 
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 8
  ]
  
 Since this algorithm is independent of a pivot selection strategy, 
 you’ll simply pick the last element 8. You could use median of three 
 instead. Next, you set up the indices 
 smaller
 , 
 equal
  and 
 larger
 :
  
 [
 12
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 8
 ]
  
  
  s
  
  
  e
  
  
  l
  
 The first element to be compared is 12. Since it is larger than the 
 pivot, it is swapped with the element at index 
 larger
  and this index is 
 decremented. Note that index 
 equal
  is not incremented so the 
  
 element that was swapped in (8) is compared next:
  
 [
 8
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 12
 ]
  
  
  s
  
  
  e
  
  
  l
  
 8 is equal to the pivot so you simply increment 
 equal
 :
  
 [
 8
 , 
 0
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 12
 ]
  
  
  s
  
  
  e
  
  
  l
  
 0 is smaller than the pivot so you swap the elements at 
 equal
  and 
 smaller
  and increase both pointers:
  
 [
 0
 , 
 8
 , 
 3
 , 
 9
 , 
 2
 , 
 21
 , 
 18
 , 
 27
 , 
 1
 , 
 5
 , 
 8
 , -
 1
 , 
 12
 ]
  
  
  s
  
  
 229",NA
Where to go from here?,"In this chapter, you learned another divide and conquer sorting 
 algorithm. Quicksort is all about choosing the right pivot for the job
  
 231",NA
Graphs,"What do social networks have in common with booking cheap flights 
 around the world? You can represent both of these real-world models 
 as graphs!
  
 A graph is a data structure that captures relationships between 
 objects. It is made up of vertices connected by edges.
  
 In the graph below, the vertices are represented by circles, and the 
 edges are the lines that connect them.",NA
Weighted graphs,"In a weighted graph, every edge has a weight associated with it that 
 represents the cost of using this edge. This lets you choose the 
 cheapest or shortest path between two vertices.
  
 Take the airline industry as an example, and think of a network with 
 varying flight paths:
  
 233",NA
Directed graphs,"As well as assigning a weight to an edge, your graphs can also have 
 direction. Directed graphs are more restrictive to traverse, as an 
 edge may only permit traversal in one direction.
  
 The diagram below represents a directed graph.
  
 234",NA
Undirected graphs ,"You can think of an undirected graph as a directed graph where all 
 edges are bidirectional.
  
 In an undirected graph:
  
  
 Two connected vertices have edges going back and forth.
  
  
 The weight of an edge applies to both directions.
  
 235",NA
Common operations,"Let's establish a protocol for graphs.
  
 Open up the starter project for this chapter. Create a new file named 
 Graph.swift and add the following inside the file:
  
 publicenum
 EdgeType
  {
  
 case
  directed 
  
 case
  undirected 
  
 }
  
 publicprotocol
 Graph
  {
  
  
  associatedtype 
 Element
  
 func
 createVertex
 (data: Element)
  -> 
 Vertex
 <
 Element
 > 
 func
 addDirectedEdge
 (from source: Vertex<Element>,
  
  to destination: 
 Vertex<Element>,
  
  weight: Double?) 
  
 func
 addUndirectedEdge
 (between source: Vertex<Element>,
  
  and destination: Vertex<Element>,
  
  
 236",NA
Defining a vertex,"Create a new file named Vertex.swift and add the following inside the 
 file:
  
 publicstruct
 Vertex
 <
 T
 > {
  
  
 publiclet
  index: 
 Int
  
  
 publiclet
  data: 
 T
  
  
 }
  
 Here you've defined a generic 
 Vertex
  struct. A vertex has a unique 
 index within its graph and holds a piece of data.
  
 You'll use 
 Vertex
  as the key type for a dictionary, so you need to 
 conform to 
 Hashable
 . Add the following extension to implement the 
 requirements for 
 Hashable
 :
  
 extension
 Vertex
 : 
 Hashable
  {
  
  
 publicvar
  hashValue: 
 Int
  {
  
 return
  index.hashValue
  
  }
  
  
 publicstaticfunc
  ==
 (lhs: Vertex, rhs: Vertex)
  -> 
 Bool
  {
  
 return
  lhs.index == rhs.index
  
  }
  
 238",NA
Defining an edge,"To connect two vertices, there must be an edge between them!
  
  
 Create a new file named Edge.swift and add the following inside the 
 file:
  
 publicstruct
 Edge
 <
 T
 > {
  
  
 publiclet
  source: 
 Vertex
 <
 T
 >
  
  
 publiclet
  destination: 
 Vertex
 <
 T
 >
  
  
 239",NA
Adjacency list,"The first graph implementation you'll learn uses an adjacency list. For 
 every vertex in the graph, the graph stores a list of outgoing edges.
  
 Take as an example the network below:
  
  
 The adjacency list below describes the network for the network of 
 flights depicted above:
  
 240",NA
Implementation ,"Create a new file named AdjacencyList.swift, and add the following:
  
 publicclass
 AdjacencyList
 <
 T
 >: 
 Graph
  {
  
  
 privatevar
  adjacencies: [
 Vertex
 <
 T
 >: [
 Edge
 <
 T
 >]] = [:]
  
  
 publicinit
 () {}
  
  
 // more to come ...
  
  
 }
  
 241",NA
Creating a vertex,"Add the following method to 
 AdjacencyList
 :
  
 publicfunc
 createVertex
 (data: T)
  -> 
 Vertex
 <
 T
 > {
  
  
 let
  vertex = 
 Vertex
 (index: adjacencies.
 count
 , data: data)
  
  
  adjacencies[vertex] = []
  
  
 return
  vertex
  
  
 }
  
 Here you create a new vertex and return it. In the adjacency list, you 
 store an empty array of edges for this new vertex.",NA
Creating a directed edge,"Recall that there are directed and undirected graphs.
  
  
 Start by implementing the 
 addDirectedEdge
  requirement. Add the 
 following method:
  
 242",NA
Creating an undirected edge,"You just created a method to add a directed edge between two 
 vertices. How would you create an undirected edge between 
 two vertices?
  
 Remember that an undirected graph can be viewed as a bidirectional 
 graph. Every edge in an undirected graph can be traversed in both 
 directions. This is why you'll implement 
 addUndirectedEdge
  on top of 
 addDirectedEdge
 . Because this implementation is reusable, you'll add it 
 as a protocol extension on 
 Graph
 .
  
 In Graph.swift, add the following extension:
  
 extension
 Graph
  {
  
 publicfunc
 addUndirectedEdge
 (between source: Vertex<Element>,
  
  and destination: 
 Vertex<Element>,
  
  weight: Double?)
  {
  
  addDirectedEdge(from: source, to: destination, weight: weight) addDirectedEdge(from: 
 destination, to: source, weight: weight)
  
  }
  
  
 }
  
 Adding an undirected edge is the same as adding two directed edges.
  
 Now that you've implemented both 
 addDirectionalEdge
  and 
  
 243",NA
Retrieving the outgoing edges from a vertex,"Back in AdjacencyList.swift, continue your work on conforming to 
 Graph
  by adding the following method:
  
 publicfunc
 edges
 (from source: Vertex<T>)
  -> [
 Edge
 <
 T
 >] {
  
  
 return
  adjacencies[source] ?? []
  
  
 }
  
 This is a straightforward implementation: you either return the stored 
 edges, or an empty array if the 
 source
  vertex is unknown.",NA
Retrieving the weight of an edge,"How much is the flight from Singapore to Tokyo?
  
 244",NA
Visualizing the adjacency list,"Add the following extension to 
 AdjacencyList
  so you can print a nice 
 description of your graph:
  
 extension
 AdjacencyList
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  {
  
 var
  result = 
 """" 
  
 for
  (vertex, edges) 
 in
  adjacencies { 
 // 1 
  
  
 var
  edgeString = 
 """" 
  
  
 for
  (index, edge) 
 in
  edges.enumerated() { 
 // 2 
  
 if
  index != 
 edges.
 count
  - 
 1
  {
  
  
  
  
  edgeString.append(
 ""
 \(edge.destination)
 , ""
 )
  
  } 
 else
  {
  
  
 245",NA
Building a network,"Let's go back to the flights example, and construct a network of flights 
 with the prices as weights.
  
 246",NA
Adjacency matrix,248,NA
Implementation,"Create a new file named AdjacencyMatrix.swift and add the following 
 to it:
  
 publicclass
 AdjacencyMatrix
 <
 T
 >: 
 Graph
  {
  
  
 privatevar
  vertices: [
 Vertex
 <
 T
 >] = []
  
  
 privatevar
  weights: [[
 Double
 ?]] = []
  
  
 publicinit
 () {}
  
  
 // more to come ...
  
  
 }
  
 Here you've defined an 
 AdjacencyMatrix
  that contains an array of 
 vertices and an adjacency matrix to keep track of the edges and their 
 weights.
  
 250",NA
Creating a Vertex,"Add the following method to 
 AdjacencyMatrix
 :
  
 publicfunc
 createVertex
 (data: T)
  -> 
 Vertex
 <
 T
 > {
  
 let
  vertex = 
 Vertex
 (index: vertices.
 count
 , data: data) vertices.append(vertex) 
 // 1 
  
 for
  i 
 in
 0
 ..<weights.
 count
  { 
 // 2
  
  
  weights[i].append(
 nil
 )
  
  } 
  
 let
  row = [
 Double
 ?](repeating: 
 nil
 , 
 count
 : vertices.
 count
 )  weights.append(row) 
  
 return
  vertex
  
 }
  
 To create a vertex in an adjacency matrix, you:
  
 1. Add a new vertex to the array.
  
 2. Append a 
 nil
  weight to every row in the matrix, as none of the 
  
 current vertices have an edge to the new vertex.
  
 251",NA
Creating edges,"Creating edges is as simple as filling in the matrix. Add the following 
 method:
  
 252",NA
Retrieving the outgoing edges from a vertex,"Add the following method:
  
 publicfunc
 edges
 (from source: Vertex<T>)
  -> [
 Edge
 <
 T
 >] {
  
 var
  edges: [
 Edge
 <
 T
 >] = [] 
  
 for
  column 
 in
 0
 ..<weights.
 count
  { 
  
   
 iflet
  weight = weights[source.index][column] {
   
  
  
 edges.append(
 Edge
 (source: source,
  
      
  destination: vertices[column],
   
  
   
  weight: weight))
  
  
  }
  
  } 
  
 return
  edges
  
 }
  
 To retrieve the outgoing edges for a vertex, you search the row for this 
 vertex in the matrix for weights that aren not 
 nil
 . Every non-
 nil 
 weight 
 corresponds with an outgoing edge. The destination is the vertex that 
 corresponds with the column in which the weight was found.",NA
Retrieving the weight of an edge,"It' i's very easy to get the weight of an edge; simply look up the value 
 in the adjacency matrix. Add this method:
  
 publicfunc
 weight
 (from source: Vertex<T>,
  
  
  to destination: Vertex<T>)
  -> 
 Double
 ? {
  
  
 253",NA
Visualize an adjacency matrix,"Finally, add the following extension so you can print out a nice, 
 readable description of your graph:
  
 extension
 AdjacencyMatrix
 : 
 CustomStringConvertible
  {
  
  
 publicvar
  description: 
 String
  { 
  
     
 // 1 
  
     
 let
  verticesDescription = vertices.
 map
  { 
 ""
 \($
 0
 )
 ""
  }
  
           
  .joined(separator: 
 ""\n"" 
   
   
 // 2 
  
     
 var
  grid: [
 String
 ] = [] 
  
     
 for
  i 
 in
 0
 ..<weights.
 count
  { 
  
       
 var
  row = 
 """" 
  
       
 for
  j 
 in
 0
 ..<weights.
 count
  { 
  
        
 iflet
  value = weights[i][j] {
  
          
  row += 
 ""
 \(value)
 \t""
  
        
  } 
 else
  {
  
          
  row += 
 ""ø\t\t""
  
        
  }
  
      
  }
  
      
  grid.append(row)
  
    
  } 
  
     
 let
  edgesDescription = grid.joined(separator: 
 ""\n""
 ) 
   
  
  
 // 3 
  
     
 return
 ""
 \(verticesDescription)
 \n\n
 \(edgesDescription)
 ""
  
  } 
  
 }
  
 Here are the steps:
  
 1. You first create a list of the vertices.
  
 2. Then you build up a grid of weights, row by row.
  
 3. Finally, you join both descriptions together and return them.
  
 254",NA
Building a network.,"You will be reusing the same example from 
 AdjacencyList
 :
  
  
 Go to the main playground page and replace:
  
 let
  graph = 
 AdjacencyList
 <
 String
 >()
  
 with:
  
 let
  graph = 
 AdjacencyMatrix
 <
 String
 >()
  
 AdjacencyMatrix
  and 
 AdjacencyList
  conform to the same protocol 
 Graph
 , 
 so the rest of the code stays the same.
  
 You should get the following output in your playground:
  
 0: Singapore
  
 1: Tokyo 
  
 2: Hong Kong 
  
 3: Detroit 
  
 4: San Francisco 
  
 5: Washington DC 
  
 6: Austin Texas
  
 7: Seattle
  
  
 255",NA
Graph analysis,"V represents vertices, and E represents edges.
  
 An adjacency list takes less storage space than an adjacency 
 matrix. An adjacency list simply stores the number of vertices and 
 edges needed. As for an adjacency matrix, recall that the number of 
 rows
  
 256",NA
Where to go from here?,"In this chapter you learned about different types of graphs 
  
 257",NA
Breadth-First Search,"In the previous chapter, you explored how graphs can be used to 
 capture relationships between objects. Remember that objects are just 
 vertices, and the relationships between them are represented by 
 edges.
  
  
 Several algorithms exist to traverse or search through a graph's 
 vertices. One such algorithm is the breadth-first search (BFS) 
 algorithm.
  
 BFS can be used to solve a wide variety of problems:
  
 1. Generating a minimum spanning tree.
  
 2. Finding potential paths between vertices.
  
 3. Finding the shortest path between two vertices.",NA
Example,"BFS starts off by selecting any vertex in a graph. The algorithm then 
 explores all neighbors of this vertex before traversing the neighbors of
  
 259",NA
Implementation,"Open up the starter playground for this chapter. This playground 
 contains an implementation of a graph that was built in the previous 
 chapter. It also includes a stack-based queue implementation which 
 you will use to implement BFS.
  
 In your main playground file, you will notice a pre-built sample 
 graph. Add the following below:
  
 extension
 Graph
  {
  
  
 func
 breadthFirstSearch
 (from source: Vertex<Element>)
  
  -> [
 Vertex
 <
 Element
 >] {
  
 var
  queue = 
 QueueStack
 <
 Vertex
 <
 Element
 >>()
  
 var
  enqueued: 
 Set
 <
 Vertex
 <
 Element
 >> = []
  
 var
  visited: [
 Vertex
 <
 Element
 >] = []
  
  
 // more to come
  
  
 return
  visited
  
  }
  
 }
  
 Here you've defined a method 
 breadthFirstSearch(from:)
  that takes in a 
 starting vertex. It uses three data structures:
  
 1. 
 queue
  keeps track of the neighboring vertices to visit next.
  
 264",NA
Performance,"When traversing a graph using breadth-first search, each vertex is 
 enqueued once. This has a time complexity of O(V) . During this 
 traversal, you also visit all the the edges. The time it takes to visit all 
 edges is O(E) . This means the overall time complexity for breadth-
 first search is O(V + E).
  
 The space complexity of BFS is O(V) since you have to store the 
 vertices in three separate structures: 
 queue
 , 
 enqueued
  and 
 visited
 .",NA
Where to go from here?,"Breadth-first search is an algorithm for traversing or searching a 
 graph. It's generally good to use this algorithm when your graph 
 structure has a lot of neighboring vertices, or when you need to find 
 out every possible outcome or path. Also it's good for generating a 
 minimum spanning tree as you will see in Chapter 23.
  
 267",NA
Depth-First Search,"In the previous chapter, you looked at breadth-first search where you 
 had to explore every neighbor of a vertex before going to the next 
 level. In this chapter, you will look at depth-first search, another 
 algorithm for traversing or searching a graph.
  
 There are a lot of applications for depth-first search:
  
  
 Topological sorting
  
  
 Detecting a cycle
  
  
 Path finding, such as in maze puzzles
  
  
 Finding connected components in a sparse graph
  
 To perform a depth-first search (DFS), you start with a given source 
 vertex and attempt to explore a branch as far as possible until you 
 reach the end. At this point, you would backtrack (move a step back) 
 and explore the next available branch until you find what you are 
 looking for, or you've visited all the vertices.",NA
Example,"Let's go through a DFS example. The example graph below is exactly 
 the same as the previous chapter. This is so you can see the 
 difference between BFS and DFS.
  
 268",NA
Implementation,"Open up the starter playground for this chapter. This playground 
 contains an implementation of a graph that as well as a stack which 
 you'll use to implement DFS.
  
 In your main playground file, you will notice a pre-built sample 
 graph. Add the following below:
  
 extension
 Graph
  {
  
  
 func
 depthFirstSearch
 (from source: Vertex<Element>)
  
  -> [
 Vertex
 <
 Element
 >] {
  
 var
  stack: 
 Stack
 <
 Vertex
 <
 Element
 >> = []
  
 var
  pushed: 
 Set
 <
 Vertex
 <
 Element
 >> = []
  
 var
  visited: [
 Vertex
 <
 Element
 >] = []
  
  
  stack.push(source)
  
  pushed.insert(source)
  
  visited.append(source)
  
  
 // more to come ...
  
  
 274",NA
Performance,"Depth-first search will visit every single vertex at least once. This has 
 a time complexity of O(V).
  
 When traversing a graph in DFS, you have to check all neighboring 
 vertices to find one available to visit. The time complexity of this is 
 O(E) , because in the worst case, you have to visit every single edge 
 in the graph.
  
 Overall the time complexity for depth-first search is O(V + E).
  
 The space complexity of depth-first search is O(V) since you have to 
 store vertices in three separate data structures: 
 stack
 , 
 pushed
  and 
 visited
 .",NA
Where to go from here?,"Depth-first search is another algorithm to traverse or search a graph.
  
 You have learned to leverage a stack to build DFS, how to use the 
 stack to keep track of how deep you are in a graph, and why it's a 
 good idea to keep a history of vertices in the event you need to 
 backtrack.
  
 In this chapter, you created an iterative version of DFS. However, a 
 recursive implementation is also possible. Check out the recursive 
 version on the Swift Algorithm Club repo at",NA
Dijkstra’s Algorithm,"Have you ever used the Google or Apple Maps app to find the 
 shortest or fastest from one place to another? Dijkstra’s algorithm is 
  
 particularly useful in GPS networks to help find the shortest path 
 between two places.
  
 Dijkstra’s algorithm is a greedy algorithm. A greedy algorithm 
  
 constructs a solution step-by-step, and picks the most optimal path at 
 every step. In particuar Dijkstra’s algorithm finds the shortest paths 
 between vertices in either directed or undirected graphs. Given a 
 vertex in a graph, the algorithm will find all shortest paths from the 
 starting vertex.
  
 Some other applications of Dijkstra’s algorithm include:
  
 1. Communicable disease transmission: Discover where biological 
  
 diseases are spreading the fastest.
  
 2. Telephone networks: Routing calls to highest-bandwidth paths 
  
 available in the network.
  
 3. Mapping: Finding the shortest and fastest paths are important to 
  
 pretty much everyone who travels.",NA
Example,"All the graphs you have looked at thus far have been undirected 
 graphs. Let’s change it up a little and work with a directed graph!
  
 Imagine the directed graph below represents a GPS network. The 
 vertices represent physical locations, and the edges between the 
 vertices represent one way paths of a given cost between 
 locations.
  
 279",NA
First pass,"From vertex A, look at all outgoing edges. In this case, you have three 
 edges:
  
  
 A to B, has a cost of 8.
  
  
 A to F, has a cost of 9.
  
  
 A to G, has a cost of 1.
  
 The remainder of the vertices will be marked as 
 nil
 , since there is no 
 direct path to them from A.
  
 280",NA
Second pass,"In the next cycle, Dijkstra’s algorithm looks at the lowest cost path 
 you have thus far. A to G has the smallest cost of 1, and is also the 
 shortest path to get to G. This is marked with a dark fill in the output 
 table.
  
  
 Now from the lowest cost path, vertex G, look at all the outgoing 
 edges. There is only one edge from G to C, and its total cost is 4. 
 This is because the cost from A to G to C is 1 + 3 = 4.
  
 Every value in the output table has two parts: the total cost to reach 
 that vertex, and the last neighbor on the path to that vertex. For 
 example, the value 4 G in the column for vertex C means that the cost
  
 281",NA
Third pass,"In the next cycle, you look at the next-lowest cost. According to the 
 table, the path to C has the smallest cost, so the search will continue 
 from C. You fill column C because you’ve found the shortest path to 
 get to C.
  
 Look at all of C’s outgoing edges:
  
  
 C to E has a total cost of 4 + 1 = 5.
  
  
 C to B has a total cost of 4 + 3 = 7.
  
 You’ve found a lower-cost path to B, so you replace the previous 
 value for B.
  
 282",NA
Fourth pass,"Now in the next cycle, ask yourself what is the next-lowest cost path? 
 According to the table, C to E has the smallest total cost of 5, so the 
 search will continue from E.
  
 You fill column E because you’ve found the shortest path. Vertex E 
 has the following outgoing edges:
  
  
  
 E to C has a total cost of 5 + 8 = 13. Since you have found 
 the shortest path to C already, disregard this path.
  
 E to D has a total cost of 5 + 2 = 7.
  
 E to B has a total cost of 5 + 1 = 6. According to the table, the 
  
 283",NA
Fifth pass,"Next, you continue the search from B.
  
 B has these outgoing edges:
  
 284",NA
Sixth pass,"In the next cycle, you continue the search from D.
  
 285",NA
Seventh pass,"F is next up.
  
 286",NA
Eighth pass,"You have covered every vertex except for H. H has two outgoing 
 edges to G and F. However, there is no path from A to H. This is why 
 the whole column for H is 
 nil
 .
  
 287",NA
Implementation,"Open up the starter playground for this chapter. This playground 
 comes with an adjacency list graph and a priority queue which you 
 will use to implement Dijkstra’s algorithm.
  
 The priority queue is used to store vertices that have not been visited. 
 It’s a min-priority queue so that every time you dequeue a vertex, it 
 gives you vertex with the current tentative shortest path.
  
 Open up Dijkstra.swift and add the following:
  
 publicenum
 Visit
 <
 T
 : 
 Hashable
 > {
  
  
 case
  start 
 // 1
  
  
 case
  edge(
 Edge
 <
 T
 >) 
 // 2
  
  
 }
  
 Here you defined an enum named 
 Visit
 . This keeps track of two 
 states:
  
 1. The vertex is the starting vertex.
  
 2. The vertex has an associated 
 edge
  that leads to a path back to the 
  
 starting vertex.
  
 Now define a class called 
 Dijkstra
 . Add the following after the code 
 you added above:
  
 publicclass
 Dijkstra
 <
 T
 : 
 Hashable
 > {
  
  
 publictypealias
 Graph
  = 
 AdjacencyList
 <
 T
 >
  
  
 let
  graph: 
 Graph
  
  
 publicinit
 (graph: 
 Graph
 ) {
  
  
 self
 .graph = graph
  
  
 289",NA
Helper methods,"Before building 
 Dijkstra
 , let’s create some helper methods that will 
 help create the algorithm.",NA
Tracing back to the start,"You need a mechanism to keep track of the total weight from the 
 current vertex back to the start vertex. To do this, you will keep track 
 of a dictionary named 
 paths
  that stores a 
 Visit
  state for every vertex.
  
 Add the following method to class 
 Dijkstra
 :
  
 privatefunc
 route
 (to destination: Vertex<T>,
  
  with paths: [Vertex<T> : Visit<T>])
  -> [
 Edge
  
 var
  vertex = destination 
 // 1
  
 var
  path: [
 Edge
 <
 T
 >] = [] 
 // 2
  
  
 290",NA
Calculating total distance,291,NA
Generating the shortest paths,"After the 
 distance
  method, add the following:
  
 publicfunc
 shortestPath
 (from start: Vertex<T>)
  -> [
 Vertex
 <
 T
  
  
 var
  paths: [
 Vertex
 <
 T
 > : 
 Visit
 <
 T
 >] = [start: .start] 
 // 1
  
  
 // 2
  
 var
  priorityQueue = 
 PriorityQueue
 <
 Vertex
 <
 T
 >>(
 sort
 : { 
  
 self
 .
 distance
 (to: $
 0
 , 
 with: paths) < 
  
  
 self
 .
 distance
 (to: $
 1
 , with: paths)
  
  })
  
  priorityQueue.enqueue(start) 
 // 3
  
  
 // to be continued
  
  
 }
  
 292",NA
Finding a specific path,"Add the following method to class 
 Dijkstra
 :
  
 publicfunc
 shortestPath
 (to destination: Vertex<T>,
  
  
  paths: [Vertex<T> : Visit<T>])
  -> [
  
  
 return
  route(to: destination, with: paths)
  
  
 }
  
 This simply takes the 
 destination
  vertex and the dictionary of 
 shortest and returns the path to the 
 destination
  vertex.",NA
Trying out your code,"Navigate to the main playground, and you will notice the graph above 
 has been already constructed using an adjacency list. Time to see 
 Dijkstra’s algorithm in action.
  
 294",NA
Performance,"In Dijkstra’s algorithm, you constructed your graph using an 
  
 adjacency list. You used a min-priority queue to store vertices and 
 extract the vertex with the minimum path. This has an overall 
 performance of O(log V). This is because the heap operations of 
 extracting the minimum element or inserting an element both take 
 O(log V).
  
 If you recall from the breadth-first search chapter, it takes O(V + E) to 
 traverse all the vertices and edges. Dijkstra’s algorithm is somewhat 
 similar to breadth-first search, because you have to explore all 
  
 neighboring edges.
  
 This time, instead of going down to the next level, you use a min-
 priority queue to select a single vertex with the shortest distance to 
 traverse down. That means it is O(1 + E) or simply O(E).
  
 So, combining the traversal with operations on the min-priority 
 queue, it takes O(E log V) to perform Dijkstra’s algorithm.",NA
Where to go from here?,"Remember that Dijkstra’s algorithm is useful for finding the shortest 
 paths between different endpoints. You greedily select the tentative 
 shortest path, by storing vertices within a priority queue. You also 
 created a path by using a 
 Visit
  state to track the edges back to the 
 start vertex.
  
 Whenever you see a network that has weighted edges and you need 
 to find the shortest path, think of your good friend Dijkstra!
  
 296",NA
Prim’s Algorithm,"In previous chapters, you’ve looked at depth-first and breadth-first 
 search algorithms. These algorithms form spanning trees.
  
 A spanning tree is a subgraph of an undirected graph, containing all of 
 the graph’s vertices, connected with the fewest number of edges. A 
 spanning tree cannot contain a cycle, and cannot be disconnected.
  
 Here’s an example of some spanning trees:
  
  
 From this undirected graph that forms a triangle, you can generate 
 three different spanning trees, where you require only two edges to 
 connect all vertices.
  
 In this chapter, you will look at Prim’s algorithm, a greedy algorithm 
 used to construct a minimum spanning tree. A greedy algorithm 
 constructs a solution step-by-step, and picks the most optimal path at 
 every step.
  
 A minimum spanning tree is a spanning tree with weighted edges 
 where the total weight of all edges is minimized. For example, you
  
 297",NA
Example,"Imagine the graph below represents a network of airports. The 
 vertices are the airports, and the edges between them represent the 
 cost of fuel to fly an airplane from one airport to the next.
  
  
 Let’s start working through the example:
  
 299",NA
Implementation,"Open up the starter playground for this chapter. This playground 
 comes with an adjacency list graph and a priority queue which you 
 will use to implement Prim’s algorithm.
  
 The priority queue is used to store the edges of the explored vertices. 
 It’s a min-priority queue so that every time you dequeue an edge, it 
 gives you the edge with the smallest weight.
  
 Start by defining a class 
 Prim
 . Open up Prim.swift and add the 
 following:
  
 publicclass
 Prim
 <
 T
 : 
 Hashable
 > {
  
  
 publictypealias
 Graph
  = 
 AdjacencyList
 <
 T
 >
  
  
 publicinit
 () {}
  
 303",NA
Helper methods,"Before building the algorithm, you’ll create some helper methods to 
 keep you organized and consolidate duplicate code.",NA
Copying a graph,"To create a minimum spanning tree, you must include all vertices 
 from the original graph. Add the following to class 
 Prim
 :
  
 internalfunc
 copyVertices
 (from graph: Graph, to graph2: Graph) 
  
 for
  vertex 
 in
  
 graph.vertices {
  
    
  graph2.createVertex(data: vertex.data)
  
  
  } 
  
 }
  
 This copies all of a graph’s vertices into a new graph.",NA
Finding edges,"Besides copying the graph’s vertices, you also need to find and store 
 the edges of every vertex you explore. Add the following to class 
 Prim
 :
  
 internalfunc
 addAvailableEdges
 (
  
   
 for
  vertex: Vertex<T>, 
  
   
 in
  graph: Graph,
  
  
  check visited: Set<Vertex<T>>,
  
  
  to priorityQueue: 
 inout
  PriorityQueue<Edge<T>>)
  { 
 for
  edge 
 in
  
 graph.edges(from: vertex) { 
 // 1 
  
   
 if
  !visited.
 contains
 (edge.destination) { 
 // 2
  
  
  
  
 priorityQueue.enqueue(edge) 
 // 3
  
  
  }
  
  }
  
 304",NA
Producing a minimum spanning tree ,"Add the following method to class 
 Prim
 :
  
 publicfunc
 produceMinimumSpanningTree
 (
 for
  graph: Graph)
  
  
  -> (cost: 
 Double
 , mst: 
 Graph
 ) { 
 // 1 
  
 var
  cost = 
 0.0
 // 2 
  
 let
  mst = 
 Graph
 () 
 // 3 
  
 var
  visited: 
 Set
 <
 Vertex
 <
 T
 >> = [] 
 // 4 
  
 var
  priorityQueue = 
 PriorityQueue
 <
 Edge
 <
 T
 >>(
 sort
 : { 
 // 5
  
  $
 0
 .weight ?? 
 0.0
  
 < $
 1
 .weight ?? 
 0.0
  
  }) 
  
 // to be continued
  
 }
  
 305",NA
Testing your code,"Navigate to the main playground, and you’ll see the graph above has 
 been already constructed using an adjacency list.
  
 Time to see Prim’s algorithm in action. Add the following code:
  
 let
  (cost,mst) = 
 Prim
 ().produceMinimumSpanningTree(
 for
 : graph)
  
 print
 (
 ""cost: 
 \(cost)
 ""
 )
  
 print
 (
 ""mst:""
 )
  
 print
 (mst.description)
  
 This constructs a graph from the example section. You’ll see the 
 following output:
  
 cost: 15.0
  
  
 mst:
  
  
 308",NA
Performance,"In the algorithm above you maintain three data structures:
  
 1. An adjacency list graph to build a minimum spanning tree. 
  
 Adding vertices and edges to an adjacency list is O(1) .
  
 2. A 
 Set
  to store all vertices you have visited. Adding a vertex to the 
 set and checking if the set contains a vertex also have a time 
 complexity of O(1).
  
 1. A min-priority queue to stores edges as you explore more 
  
 vertices. The priority queue is built on top of a heap and insertion 
 takes O(log E) .
  
 The worst-case time complexity of Prim’s algorithm is O(E log E). 
  
 309",NA
Where to go from here?,"This is a great example of using multiple data structures to build a 
 useful algorithm: a priority queue, a set, and an adjacency list are all 
 used to construct Prim’s algorithm.
  
 Given the plethora of networks and network-like relationship models 
 in the real world, you can apply Prim’s algorithm to many different 
 problems where you’re always seeking the lowest possible cost for a 
 network.
  
 310",NA
Conclusion,"We hope you learned a lot about data structures and algorithms in 
 Swift as you read this book — and had some fun in the process! 
 Knowing when and why to apply data structures and algorithms goes 
 beyond just acing that whiteboard interview. With the knowledge 
 you’ve gained here, you can easily and efficiently solve pretty much 
 any data manipulation or graph analysis issue put in front of you.
  
 If you have any questions or comments as you work through this 
 book, please stop by our forums at 
 http://forums.raywenderlich.com 
 and look for the particular forum category for this book.
  
 Thank you again for purchasing this book. Your continued support is 
 what makes the tutorials, books, videos, conferences and other things 
 we do at raywenderlich.com possible, and we truly appreciate it!
  
 Wishing you all the best in your continued algorithmic adventures,
  
 – Kelvin, Vincent, Ray, Steven, and Chris
  
 The Data Structures & Algorithms in Swift team
  
 311",NA
More Books You Might Enjoy,"We hope you enjoyed this book! If you’re looking for more, we have a 
 whole library of books waiting for you at 
  
 https://store.raywenderlich.com
 .",NA
New to iOS or Swift?,"Learn how to develop iOS apps in Swift with our classic, beginner 
 editions.",NA
iOS Apprentice,"https://store.raywenderlich.com/products/ios-apprentice
  
  
 The iOS Apprentice is a series of epic-length tutorials for beginners 
 where you’ll learn how to build 4 complete apps from scratch.
  
 Each new app will be a little more advanced than the one before, and 
 together they cover everything you need to know to make your own
  
 312",NA
Swift Apprentice,"https://store.raywenderlich.com/products/swift-apprentice
  
  
 This is a book for complete beginners to Apple’s brand new 
 programming language — Swift 4.
  
 Everything can be done in a playground, so you can stay focused 
 on the core Swift 4 language concepts like classes, protocols, and 
 generics.
  
 This is a sister book to the iOS Apprentice; the iOS Apprentice 
 focuses 313",NA
Experienced iOS developer?,"Level up your development skills with a deep dive into our many 
 intermediate to advanced editions.",NA
Data Structures and Algorithms in Swift,"https://store.raywenderlich.com/products/data-structures-and-
 algorithms-in-swift
  
  
 Understanding how data structures and algorithms work in code is 
 crucial for creating efficient and scalable apps. Swift’s Standard 
 Library has a small set of general purpose collection types, yet they 
 definitely don’t cover every case!
  
 In Data Structures and Algorithms in Swift, you’ll learn how to 
 implement the most popular and useful data structures, and when 
 and why you should use one particular datastructure or algorithm
  
 314",NA
Realm: Building Modern Swift Apps with Realm,NA,NA
Database,"https://store.raywenderlich.com/products/realm-building-modern-
 swift-apps-with-realm-database
  
  
 Realm Platform is a relatively new commercial product which allows 
 developers to automatically synchronize data not only across Apple 
 devices but also between any combination of Android, iPhone, 
 Windows, or macOS apps. Realm Platform allows you to run the 
 server software on your own infrastructure and keep your data in-
 house which more often suits large enterprises. Alternatively you can 
 use Realm Cloud which runs a Platform for you and you start syncing 
 data very quickly and only pay for what you use.
  
 In this book, you’ll take a deep dive into the Realm Database, learn 
  
 315",NA
Design Patterns by Tutorials,"https://store.raywenderlich.com/products/design-patterns-by-
 tutorials
  
  
 Design patterns are incredibly useful, no matter what language or 
 platform you develop for. Using the right pattern for the right job can 
 save you time, create less maintenance work for your team and 
  
 ultimately let you create more great things with less effort. Every 
 developer should absolutely know about design patterns, and how and 
 when to apply them. That's what you're going to learn in this book!
  
 Move from the basic building blocks of patterns such as MVC, 
  
 Delegate and Strategy, into more advanced patterns such as the 
 Factory, Prototype and Multicast Delegate pattern, and finish off with
  
 316",NA
Server Side Swift with Vapor,"https://store.raywenderlich.com/products/server-side-swift-with-
 vapor
  
  
 If you’re a beginner to web development, but have worked with Swift 
 for some time, you’ll find it’s easy to create robust, fully-featured web 
 apps and web APIs with Vapor 3.
  
 Whether you’re looking to create a backend for your iOS app, or want 
 to create fully-featured web apps, Vapor is the perfect platform for 
 you.
  
 This book starts with the basics of web development and introduces 
 the basics of Vapor; it then walks you through creating APIs and web 
 backends; creating and configuring databases; deploying to Heroku, 
 AWS, or Docker; testing your creations and more1",NA
iOS 11 by Tutorials,317,NA
Advanced Debugging and Reverse Engineering,"https://store.raywenderlich.com/products/advanced-apple-
 debugging-and-reverse-engineering
  
 318",NA
RxSwift: Reactive Programming with Swift,"https://store.raywenderlich.com/products/rxswift
  
 319",NA
Core Data by Tutorials,"https://store.raywenderlich.com/products/core-data-by-tutorials
  
 320",NA
iOS Animations by Tutorials,"https://store.raywenderlich.com/products/ios-animations-by-
 tutorials
  
 321",NA
watchOS by Tutorials,"https://store.raywenderlich.com/products/watchos-by-tutorials
  
 322",NA
tvOS Apprentice,"https://store.raywenderlich.com/products/tvos-apprentice
  
  
 323",NA
Want to make games?,"Learn how to make great-looking games that are deeply engaging and 
 fun to play!",NA
2D Apple Games by Tutorials,"https://store.raywenderlich.com/products/2d-apple-games-by-
 tutorials
  
  
 In this book, you will make 6 complete and polished mini-games, 
 from an action game to a puzzle game to a classic platformer!
  
 This book is for beginner to advanced iOS developers. Whether 
 you 
  
 324",NA
3D Apple Games by Tutorials,"https://store.raywenderlich.com/products/3d-apple-games-by-
 tutorials
  
  
 Through a series of mini-games and challenges, you will go from 
 beginner to advanced and learn everything you need to make your 
 own 3D game!
  
 This book is for beginner to advanced iOS developers. Whether 
 you are a complete beginner to making iOS games, or an 
 advanced iOS developer looking to learn about SceneKit, you will 
 learn a lot from this book!",NA
Unity Games by Tutorials,"https://store.raywenderlich.com/products/unity-games-by-tutorials
  
 325",NA
Want to learn Android or Kotlin?,"Get a head start on learning to develop great Android apps in Kotlin, 
 the newest first-class language for building Android apps.",NA
Android Apprentice,"https://store.raywenderlich.com/products/android-apprentice
  
 326",NA
Kotlin Apprentice,"https://store.raywenderlich.com/products/kotlin-apprentice
  
 327",NA
