Larger Text,Smaller Text,Symbol
Alan Thorn,NA,NA
TECHNOLOGY IN ACTION,™,NA
Pro ,NA,NA
Unity Game,NA,NA
Development,NA,NA
with ,NA,NA
C#,"REFINE YOUR UNITY DEVELOPMENT SKILLS 
 WHILE BUILDING A CROSS-PLATFORM  
 FIRST-PERSON SHOOTER WITH C# AND UNITY
 www.itbookshub.com",NA
Contents at a Glance,"About the Author .................................................................................................................
 xi
 About the Technical Reviewer ...........................................................................................
 xiii
 Acknowledgments ..............................................................................................................
 xv 
 Introduction ......................................................................................................................
 xvii 
 Chapter 1: Designing and Preparing
 ■
  
  ..................................................................................
 1
 Chapter 2: Getting Started
 ■
  
  ...............................................................................................
 37
 Chapter 3: Event Handling
 ■
  
  ...............................................................................................
 81
 Chapter 4: Power-Ups and Singletons
 ■
  
  ...........................................................................
 113
 Chapter 5: Player Controller
 ■
  
  ..........................................................................................
 147
 Chapter 6: Weapons
 ■
  
  .......................................................................................................
 179
 Chapter 7: Enemies
 ■
  
 ........................................................................................................
 217
 Chapter 8: Graphical User Interfaces
 ■
  
  ............................................................................
 255
 Chapter 9: Handling Persistent Data
 ■
  
  .............................................................................
 281
 Chapter 10: Reﬁnements and Improvements
 ■
  
  ................................................................
 303
 Index .................................................................................................................................
 319
 www.itbookshub.com",NA
Introduction,"One thing I really love about the games industry today is its “openness” compared to many 
 industries. To start out in the games industry you don’t need a degree. All you need is a computer. 
 And an Internet connection. If you log on online right now, you can immediately visit web sites 
 such as Blender, GIMP, Inkscape, and (of course) Unity to get access to professional-grade game 
 development software completely free of charge! The result is that almost anybody in any place on 
 any budget, from any background and at any age, can sit at a computer and be a game developer 
 right now
 .
 Of course, none of that openness 
 guarantees
  you’ll automatically 
 know
  how to use the tools, 
 or that you’ll even like the results you get from them. You need to bring a certain 
 something
 , an 
 understanding, to the tools to fully realize their power and potential in practice. To do that, you’ll 
 need to develop experience and to reﬁne your knowledge, and to learn techniques and workﬂows 
 using real-world examples, targeting your software of choice directly.
 This book focuses on Unity development speciﬁcally. And when it comes to Unity development, 
 there’s one area where developers feel troubled or somewhat lacking in power. That area is in 
 C# scripting. The general feel is that so much of the C# tutorials and guides out there today are 
 so abstract and formal that it’s difﬁcult to see how all of it should come together and be applied 
 properly in real-world cases to do what you need to do to give your games that professional edge. 
 You already know about variables, functions, loops, enumerations, and the fundamentals. But 
 what you need is something to take you further, to help you see how all these core features can be 
 combined in creative ways to produce a real-world, working game. The kind of game you can not 
 only play but study and see how it all comes together. This book aims to ﬁll that need so you can 
 become a more powerful game developer.",NA
What Is This Book About?,"This book will show you how to create a small but complete ﬁrst-person shooter game in the Unity 
 engine, step by step. In particular it’ll focus strongly on C# scripting, and on a range of related 
 ideas and techniques, for getting professional-grade results. We’ll explore a lot of ground, including 
 level design, vectors and mathematics, line-of-sight calculations, pathﬁnding and navigation, 
 www.itbookshub.com",NA
Who Is This Book For?,"Every technical book is written with a target audience in mind. That is, it’s written for a speciﬁc 
 “type” of reader. This means that when writing the book, I, the author, must make assumptions about 
 you, the reader. The assumptions are about the book-relevant topics I think you’ll already know, 
 before even starting to read this book. Speciﬁcally, I’ll assume you know the following:
 n
 How to use the Unity Editor to import assets and build levels
 n
 n
 How to create script ﬁles and write some basic code in C#
 n
 n
 How to use fundamental programming concepts like variables, functions, loops, 
 n
 and conditional statements
 n
 How to debug games using the Unity debugging tools
 n
 However, this book may not be for you if you’re completely new to game development, or if this is 
 your ﬁrst time using Unity, or if you’re completely new to programming speciﬁcally. In any of these 
 cases, I strongly recommend your picking up an introductory title before continuing with this book, 
 to ensure you get the most from it.
 www.itbookshub.com",NA
How Should This Book Be Read?,"This book has been written to be a complete C# scripting course. For this reason, you’ll probably 
 get the most from it by reading it from start to end, chapter by chapter, consulting the source code 
 and project ﬁles along the way. Further, it’d be really great if you could read this book while seated at 
 the computer with Unity in front of you, along with the book ﬁles, to make comparisons, testing, and 
 checking easier. You can read it on a train or plane or elsewhere and still beneﬁt; but the greatest 
 beneﬁt will come if you can readily switch between the book and your computer, following the steps 
 and instructions, and completing the exercises. There’s a lot to do in this book; it’s not intended to 
 simply be read. It expects you to follow along and join in.",NA
What Are the Companion Files?,"As mentioned earlier, this book has a practical focus. That means it encourages you not just to 
 read, but to do things. In each chapter, we’ll be working in software, using the features of Unity and 
 MonoDevelop, and other software, to create a working ﬁrst-person shooter game. This book has 
 been designed and conﬁgured for you to follow along with me, repeating the steps I take, while 
 understanding them too, to build a ﬁrst-person shooter in parallel. However, the book companion 
 ﬁles feature all the assets I’ve used and the projects I’ve made for you to use should you wish to 
 start at speciﬁc chapter or start from exactly the same place as me. 
 Each and every chapter features its own folder in the companion ﬁles, and features a start and end 
 project. The chapter begins with the 
 start
  project and move toward the 
 end
  project. Each chapter 
 features notes and comments directing you to the relevant companion ﬁles when appropriate; so 
 please be on the lookout for those as we progress. The Apress companion ﬁles for this book can be 
 found at 
 www.apress.com/9781430267461
 .
 www.itbookshub.com",NA
Chapter,NA,NA
 1,NA,NA
Designing and Preparing,"Welcome to Chapter 1, the beginning of a comprehensive and “professional” C# programming 
 course for the Unity engine. The core objective of this book is to thoroughly explore the development 
 of a first-person shooter (FPS) game from start to finish. Further, it aims to do so in a way that’ll 
 have strong practical relevance for you and your own projects. This book is intended to be read as 
 a complete course; meaning you should read it on a chapter-by-chapter basis, in sequence from 
 beginning to end, thinking of each chapter as an independent class or lesson. If you follow this 
 book carefully in order, sitting at the computer and working along with me in Unity, then by the end, 
 you should have completed a playable FPS game that runs on desktop platforms and has mobile 
 potential. But much more than this: you’ll have seen and explored many C# coding techniques that 
 have wider relevance and importance than only to the specific game created here. As we progress, 
 considering techniques and ideas, it’s important to see them in their broader context, as tools you 
 can use in your own ways and for your own games. Don’t just think of them as ideas limited to 
 this
  
 book and 
 this
  project— because they’re not.
 A further and final quality of this book, which makes it unique among the tutorial literature available 
 today, is its strong “professional” focus. The book title is 
 Pro Unity Game Development with C#,
  and 
 the word 
 Pro
  has an important meaning worth clarifying before getting started with development. 
 Pro (short for 
 professional
  ) and is especially vague in the games industry. This is because it means 
 different things to different people, and there’s little or no consensus about which definition is correct, 
 if any. To some, being a professional simply means your main income stems from making video 
 games. To others, you can also be a professional by making games part-time, or even as a hobby, 
 so long as you sell them for money. For others, being a professional is about having a recognized 
 degree or qualification from an established authority, like a university. And to others, professionalism 
 has nothing to do with money or education, and is about making games of a specific quality  
 and polish.
 Now, it’s not my intention to promote any of these definitions as correct exclusively. I want to capture 
 at least something of them all in this book when I use the term 
 professional
 . By “professional,” 
 I mean
  
 this book has a strong practical flavor and value, as opposed to a theoretical or academic flavor. Its 
 aim is 
 not
  to 
 introduce
  you to Unity or C# development as though you were a complete newcomer, 
 or to debate about the nuances or specifics of more advanced features. Rather, it assumes you’re 
 www.itbookshub.com",NA
Designing,"This is Chapter 1, so we’ll be thinking here about how to get started making a C# Unity game. When 
 most people begin making a game, there’s typically a strong temptation, born from excitement and  
 enthusiasm perhaps, to immediately fire up Unity and MonoDevelop, and to “jump in” and get started 
 in a free-form style. The desire for instant, tangible results like this can be strong indeed. But resist 
 it. Jumping into coding without any prior planning is almost always a recipe for disaster and drift; 
 not to mention wasted time! If you want professional quality results, then invest time ahead simply to 
 think, consider, and plan, and also to 
 write down
  the results of your thinking, whether that’s in words, 
 pictures, or diagram form—whatever best helps you remember your own thoughts.
 Maybe you think you know your own thoughts well and don’t need to write them down. But resist 
 this way of thinking, too. Get into the 
 habit
  of making written plans. Over time, we typically forget, 
 and our thoughts and ideas get fuzzy. But solid and dependable coding critically requires clarity of 
 mind, and that’s true no matter which programming language we use. Half the solution comes from 
 understanding the problem. The famous philosopher John Searle echoed this when he said, “If you 
 can’t say it clearly, you don’t understand it yourself.” So make written plans and work on the basis of 
 those. With that said, we’ll begin by writing a summary and overview of the game we’ll be making in 
 this book.",NA
Game Overview,"The FPS game we’ll make in this book will be titled 
 Crazy Mad Office Dude (
  hereafter referred to as 
 CMOD)
 , as shown in Figure 
 1-1
 . You can also visit my YouTube Channel at 
 www.youtube.com/user/
 alanthorngames
  to see the game in action. CMOD is an action-shooter in a deliberately comic and 
 cartoon style, played in first-person perspective (from the eyes of the game character). 
 www.itbookshub.com",NA
Game in Depth,"We’ve now established a general overview of the game to be made, CMOD as whole. In writing and 
 thinking about that, we have, however, relied on a range of smaller and dependent concepts. These 
 are constituent ingredients of the game. These concepts include the Player, Enemies, Power-Ups, 
 Weapons, Health, the Level, and more. In this section, we’ll itemize and catalog these, offering an 
 informative description of each. As we progress through the book, each concept will require its own 
 specific implementation in C# and Unity.
 �
 The Player.
  The Player in a first-person shooter usually has no substantial 
 graphical representation in the game world, except for his or her hand holding  
 a weapon at the bottom center of the screen. The Player is the character the 
 gamer controls and moves around during gameplay. It’s how the gamer interacts 
 with the world: such as destroying enemies, opening doors, pressing buttons, 
 and collecting power-ups. In addition, the Player also has a finite amount of 
 Health
 , a numerical property measuring his well-being. The higher this value, the 
 better for the Player
 . This value is reduced when Enemies successfully attack the 
 Player. When this value is 0 or below, the Player dies and is removed from the 
 game. Since CMOD will be a single-player game, as opposed to multiplayer, the 
 removal of the Player from the game constitutes 
 Game Over
  (the end of play).
 �
 The Enemies.
  CMOD features three main Enemy types or species, whose 
 shared aim is to kill the Player through attacks. These Enemies are as follows:
 �
 The 
 Drone
  (see Figure 
 1-2
 ), a genetically engineered bureaucrat with a penchant for 
 long questionnaires and customer surveys. This Enemy is the weakest of the three.  
 He attacks at close range using his bare fists.
 Figure 1-2.
  Enemy Type 1: Drone. Contains three main frame-sets of animation: Standing Still (Neutral), Running, and Attacking
 �
 Next is the 
 Tough Guy
  (see Figure 
 1-3
 ), a professional hit man employed by the 
 Corporation to eliminate those troublesome types who expect payment for their work, 
 including the Player! A Tough Guy is the only Enemy to have a range attack: he’ll fire a 
 pistol whenever the player enters his line of sight.
 www.itbookshub.com",NA
Developing the Design: Looking Ahead,"The previous sections, taken together in combination with the YouTube gameplay video (URL 
 provided earlier), should offer a strong enough and clear enough vision of CMOD. These resources 
 will constitute our game design document (GDD), a document clearly articulating the vision of the 
 game to make. For most games, the GDD will typically be longer and more comprehensive than 
 ours, but our GDD is sufficient and fit for purpose 
 in our case
 . The design may initially seem “simple” 
 (or maybe not!), but if it seems so to you, it’s important not to confuse simple with simplicity. The 
 game we’ve planned actually involves a lot of work, especially C# coding work. Each subsequent 
 chapter is dedicated to a specific aspect or subset of development. In this section, we’ll take a 
 sneak glimpse of that future work: a general guided tour through some of the main issues and 
 subjects we’ll visit throughout this book. This work ranges from using the Unity Editor and tools, 
 sometimes in new and creative ways, to heavy coding sessions in C# to create artificial intelligence 
 and pathfinding. Let’s see how these subjects, and our workload in general, are distributed across 
 the book on a chapter-by-chapter roadmap.
 �
 Chapter 2
  is concerned with establishing the foundations of our game. 
 Game development is a specialization of software engineering, and like most 
 engineering projects, it must begin by laying foundations. This involves lots of 
 work in the Unity Editor—especially level design work—using both the scene 
 and game views for assembling and building a level with modular environment 
 pieces. It’ll also involve lighting and lightmapping with the Beast lightmapper 
 to get an appropriate mood and look for our environment. In addition, we’ll 
 also look at processes for automating asset importing to fix some mesh import 
 issues we’ll encounter. By the end of Chapter 2, we’ll end up with a project that’s 
 ready to start customizing and defining through C# scripting.
 �
 Chapter 3
  starts our coding adventure! It’s where we 
 add
  code to our project. 
 It’ll explore 
 event-driven programming
  in depth, looking at what it is, how it 
 works, and how to integrate it into our project to get efficient results. It’ll also 
 explore why we should start implementing this kind of system before anything 
 else. Practically, every game needs to detect when things happen, such as when 
 the Player dies or collects a power-up, among others (these will all be important 
 events for us). In addition, other objects in the game need to know when those 
 events occur, so they can respond in specific ways. The Enemies, for example, 
 need to know when they’re close enough to the player to launch an attack; 
 otherwise, they’ll never know when to 
 start
  attacking. These issues concerning 
 events
  and 
 responses
  will lead us to develop a streamlined and dedicated 
 Notifications
  class; one capable of handling almost every kind of event and 
 response we could ever want in a game.
 �
 Chapter 4
  will see us using concepts such as class 
 inheritance
 , 
 Singletons,
  
 and 
 vector arithmetic
  for creating our four workable power-ups for the game: 
 the Cash Power-Up, the Upgrade Weapon Power-Up, the Ammo Power-Up and 
 the Health Restore Power-Up. Achieving this requires us to consider a range 
 of ideas. We’ll use the 
 Unity API
  to work with 
 Physics Colliders
 , 
 components
 , 
 and 
 2D sprites
  (part of the 2D functionality added in Unity 4.3). We’ll also 
 develop a range of different and interacting classes, and build our own 
 Billboard
  
 functionality to ensure sprites are always camera aligned. By the end of this",NA
Game Development Workflows,"Before jumping in and getting started with CMOD (reserved for the next chapter), I want to spend the rest 
 of this chapter sharing with you some Unity tips, tricks, and techniques that I frequently find helpful when 
 developing my own games. Making a game can be an intensive and heavy process, so it’s important 
 to develop a general workflow that you feel comfortable following. The advice presented here is not 
 essential in the sense that you 
 need
  to follow it to work along with this book. But rather, it’s presented 
 as a set of recommendations and suggestions that you may like to integrate into your own workflow, 
 wherever you think it can be improved. Feel free to use it or ignore it until you find a workflow you like.",NA
Tip #1: Interface Layout,"The layout and arrangement of the Unity interface is 
 critically
  important to the smoothness and speed 
 of your working. So much so that even the slightest interface change, perhaps in the alignment of a 
 panel or a dockable window, can have dramatic repercussions for your efficiency and speed in the long 
 term. Consequently, when working in Unity, it’s important to find a layout that supports your workflow 
 and needs from the very beginning to avoid unnecessary setbacks and frustration. Typically, the “ideal” 
 interface layout 
 for you
  will not be general but will vary depending on the project you’re developing. 
 For games using little or no animation, it’s likely you’ll never need the animation editor or the Mecanim 
 tools—and so you can hide those windows. Similarly, for games that never use Pathfinding or 
 Navigation, you’ll never need to see the NavMesh tools. For CMOD, however, we’ll need all those 
 things and more—but not necessarily throughout the whole of development. Figure 
 1-13
  shows the 
 layout I’m using for this project, which is based on the Default layout.
 Figure 1-13.
  Unity interface layout configured for developing CMOD",NA
Tip #2: Dual-Monitors,"A Dual-Monitor (or Multi-Monitor) configuration is one where two or more displays are connected to 
 the same PC or Mac, and together they show a wider desktop, which reaches across all monitors. 
 This means you get to arrange your windows and panels conveniently over an even wider screen area 
 than usual. If you’re fortunate enough to be using such a setup already, then you can make especially 
 good use of it in Unity. And if you don’t have this setup but your budget allows it, I highly recommend 
 investing in it. In Unity, Dual-Monitors are particularly useful in two contexts: scene editing (as shown 
 in Figure 
 1-15
 ) and scripting (as shown in Figure 
 1-16
 ). To jump between these two configurations, it’s 
 sensible to create two separate UI layouts: (DM-Editing) and (DM-Coding) – 
 DM = Dual Monitor
 .
 Figure 1-16.
  DM-Coding layout keeps a single monitor layout (in left monitor) for scene editing and inspector tools, and 
 MonoDevelop for coding (in right monitor)
 Figure 1-15.
  DM-Editing Layout separates scene editing tools (in left monitor) and property inspection tools and editors  
 (in right monitor)
 �
 DM-Editing.
  This mode is tailored to scene building, property tweaking, and all 
 other editor functionality that doesn’t involve heavy coding. The greatest benefit 
 of this layout is the large screen space dedicated to the Scene and Game 
 viewports in the left monitor, giving us an unencumbered and easy view of our 
 scene for level designing, testing, and debugging. By separating the scene and 
 game views in the left monitor from the editors in the right, we achieve a useful 
 kind of “decluttering” and spatial organization. This kind of functional separation 
 www.itbookshub.com",NA
Tip #3: Be Organized,"Game development in Unity (and more widely) involves working with lots of related resources, 
 including assets (such as meshes and textures) and code (such as C# source files). By “lots” of 
 resources, I mean hundreds and thousands, and sometimes even more! For the sake of simplicity 
 and sanity, therefore, it’s important to be organized from the outset and 
 to remain
  so throughout 
 development. It’s important to make organization a habit. However, saying that is one thing and 
 achieving it is another. So to stay organized while project managing and coding, keep the following 
 principles in mind:
 �
 Name and group assets.
  Every Unity project relies on assets. These include 
 meshes, textures, audio files, animations, materials, scripts, scenes, and 
 more. From the very beginning of your project, think seriously about how you’ll 
 organize and arrange these assets in terms of file names and the folders in 
 which you’ll put them. Don’t just import assets of every kind into your project 
 and then just leave them sitting together in the same folder. Doing that will 
 lead to confusion in the long term. You’ll grow weary of even looking at the 
 Project panel. Instead, you’ll need to group like items together, such as meshes 
 inside a 
 Meshes
  folder, and textures inside a 
 Textures
  folder (see the Project 
 panel in Figure 
 1-17
  for asset organization in CMOD). For larger projects, you 
 may even need to take organization further by creating 
 nested
  folders (folders 
 within folders), such as 
 Meshes/Enemies
  and 
 Meshes/Props
 . In addition, keep 
 a constant watch on your assets over your project’s lifetime to protect against 
 “stragglers.” Namely, assets that somehow wind up in the wrong folders, either 
 by accident or because you put them somewhere temporarily and then forgot to 
 put them back where they should be (it can easily happen!).",NA
Tip #4: Show Project Wizard on Start-up,"At start-up, Unity will, by default, always open the most recently used project if there’s one to 
 open; otherwise, it’ll display the Project Wizard to create a new project. Its decision to open the 
 most recent project first is usually a convenient feature that you’ll leave unchanged. But there are 
 times when this behavior can be problematic. If you’re working in a team and are using Unity in a 
 networked environment, it’s likely you’ve opened a project from a shared network drive. In itself, 
 doing that will not generally cause any major issues. However, Unity expects to open projects 
 on an exclusive basis—meaning that only one instance of the project may be open at a time. 
 Consequently, if you restart Unity and it seeks to reopen the shared project but finds it’s already 
 open by another user on the network, it’ll cancel the open operation altogether and will exit instead 
 of showing the Project Wizard. The result is that you’ll be permanently locked out of Unity until the 
 other user on the network finally decides to close the project, allowing you exclusive access again.
 Now, typically opening projects over networked drives is not something I’d recommend doing if 
 it can be easily avoided. But even so, there’s a way around this specific problem: specifically, by 
 forcing Unity to always show the Project Wizard on start-up, as opposed to opening the most recent 
 project. To achieve this, simply choose 
 Edit
  
 ➤
  
 Preferences
  from the Editor main menu. Then from 
 the General tab, enable the feature Always Show Project Wizard (see Figure 
 1-22
 ).",NA
Tip #5: Use FBX Meshes,"Unity officially accepts meshes in an extensive variety of file formats, including 
 Blend
 , 
 MA
 , 
 MB
 , 
 MAX
 ,  
 OBJ
  and 
 FBX
 , and others. These formats can be produced by a range of 3D applications, such as Maya, 
 3DS Max, Lightwave, Blender, Strata, Cinema4D, and more. Among all these file formats, however, two 
 main types may be identified: 
 Proprietary
  and 
 Exported
 . Proprietary files are those saved directly from 
 3D modeling software, using the common 
 File
  
 ➤
  
 Save
  command. Exported formats are those saved 
 using commands such as 
 File
  
 ➤
  
 Export
 . The ultimate purpose of both methods is to serialize or output 
 meshes to a persistent file, which can be opened and read by many applications. However, despite the 
 common aim, there are significant differences between the Proprietary and Exported files, which have 
 implications when working with Unity. The upshot is generally this: 
 Always use meshes from exported 
 formats
 —
 specifically FBX
  (see Figure 
 1-23
 ). Why should this advice be followed?",NA
Tip #6: Disable Ambient Lighting,"If you build a scene with some meshes but without any lighting, and then play-test it, you’ll see 
 that your scene doesn’t appear completely black as you’d expect it to. In other words, your scene 
 is not in total darkness—even though there are no lights! This base or default illumination is known 
 as 
 Ambient Light
 . It represents a non-shadow-casting light that is projected outward from the 
 scene origin in all directions infinitely, and it affects every mesh surface with equal intensity. That 
 is completely at odds with how “real world” lighting works, and so Ambient Light rarely produces 
 believable results. But it’s especially useful for lighting a scene during development and early  
 play-testing. It lets you see “what’s going on” before you’ve added any lights at all. But often  
 (after creating your own lighting), you’ll want to disable Ambient Light entirely.
 To do disable Ambient Light, select 
 Edit
  
 ➤
  
 Render Settings
  from the Editor main menu to show the 
 scene render settings in the Object Inspector. From the Inspector, use the Ambient Color swatch to 
 specify Black RGB (0, 0, 0)—meaning 
 no intensity
  (see Figure 
 1-24
 ).
 www.itbookshub.com",NA
Tip #7: Use Root GameObjects,"Every Unity scene is ultimately composed from a 
 hierarchy
  of GameObjects. GameObjects exist 
 within the scene in 
 relation
  to each other, and this relationship (as defined by the hierarchy) is 
 critically important to every object’s transformation (
 position
 , 
 rotation
  and 
 scale
 ). Specifically, child 
 objects inherit the transformations of their parents. That is, the child adds its own transform to 
 its parent’s. This feature is useful for making objects move and interact together believably. This 
 hierarchical relationship can be put to good use in many ways and not just at runtime; it can help at 
 design time, too.
 If you create an empty game object in your scene by choosing 
 GameObject
  
 ➤
  
 Create Empty
  from 
 the Editor menu, and then make it the ultimate parent of all objects, you’ll immediately have the 
 ability to transform your entire scene, should you ever need to reposition everything in one step while 
 building a level, or even at runtime (see Figure 
 1-25
 ).
 Figure 1-24.
  Disabling Ambient Light from the Render Settings menu",NA
Tip #8: Incremental Backups,"Making games takes time (sometimes a long time), and time is said to be a 
 wasting resource
  
 because once it’s spent and gone, there is no refund. You simply can’t get back time that’s passed. 
 So put a value on your time, give it respect, and invest it wisely when developing. One way you 
 respect your time and effort is by making 
 regular
  backups of your data to prevent repeating work in 
 the event of data loss. This is to protect you against unforeseen events, such as computer failures, 
 data corruption, virus attacks, and other accidents. For Unity projects, making a backup is really as 
 simple as making a copy of your project folder, and then archiving it onto a separate storage device, 
 such as an external hard drive or cloud-based storage, or both. Don’t make a backup on the same 
 storage as the original, and keep the backup in a different physical location. For example, if the 
 original files are at your office, then keep the backup at home. Be sure also to name your backups 
 appropriately—use a numbering or date-based system—so that it’s easy to quickly identify not just 
 the latest backup, but also to understand the ordering of backups from the earliest to the latest.
 Note
  More information on 
 BroadcastMessage
  can be found at the Unity documentation at  
 http://docs.unity3d.com/Documentation/ScriptReference/Component.BroadcastMessage.html
 .
 Figure 1-25.
  Creating Root GameObjects to control the scene hierarchy
 In addition, as we’ll see later, you can call 
 GameObject.BroadcastMessage
  on the Root object to send 
 an event or notification to every object in the scene, just by one line of code.",NA
Tip #9: Batch Renaming,"Sometimes you’ll be working with lots of similar game objects in a Unity scene, such as a batch of 
 enemies, or ammo crates, or power-ups, or trees, or rocks, and others. You’ll typically want each 
 object in the batch to have a similar but distinct name from all the others, such as 
 Tree_01
 , and 
 Tree_02
 , and 
 Tree_03
 , and so forth. Now, it can tedious and time-consuming to name each of these 
 objects individually. Unfortunately, Unity (at the time of writing) has no out-of-the-box functionality 
 to automate this process. So often it’s convenient to customize the Unity Editor and create our own 
 Batch Renaming functionality. In this section, therefore, I want to introduce you to a custom-made 
 Batch Rename tool, which is an editor extension that plugs into the Unity interface and offers simple 
 renaming functionality for multiple objects. The source code for this tool is listed in Listing 1-1 for 
 your viewing, and is also included in the Project Files (inside the 
 Chapter01
  folder).
 Listing 1-1 BatchRename.cs
 using UnityEngine;
 using UnityEditor;
 using System.Collections;
 public class BatchRename : ScriptableWizard
 {
         //Base name
         public string BaseName = ""MyObject_"";",NA
Tip #10: Showing Empty Objects in the Editor,"Empty objects are very useful, as we’ll see throughout later chapters. They serve a similar function 
 to Dummies (or Dummy objects) in 3D software. An 
 Empty
  is simply a GameObject that has no 
 renderable components. There’s nothing about an Empty that allows it to be seen, and so the player 
 never knows that they’re there. That’s part of 
 why
  they are useful. Their lack of visibility makes them 
 great for marking respawn points in the scene, or for acting as pivot points (a point around which 
 other objects revolve), or marking out regions in the level. However, despite their usefulness in-game, 
 Empty objects come with a drawback for the developer when working with them in the Scene Editor. 
 The problem is that Empty objects are only visible in the scene when they’re selected. When selected, 
 you can see the object’s Transform gizmo (as shown in Figure 
 1-29
 ). That helps you to know where 
 the object is. But when deselected, you can’t see the object anymore—you can’t even select it again 
 with your mouse because there’s nothing visible to select. To reselect the Empty, you’ll need to click 
 its name in the Hierarchy panel. This can be a tedious workflow. But thankfully, there’s a solution. That 
 is, there’s a way to show an Empty game object in the viewport without also making it visible to the 
 gamer at runtime.
 Figure 1-28.
  Completing the Rename operation",NA
Tip #11: Use the Stats Panel,"When play-testing and debugging your games inside the editor, be sure to make the 
 Stats panel
  your 
 friend; it is also known as the 
 Rendering Statistics window
 . It features lots of helpful information, 
 updated in real time while your game is playing. The Stats panel appears in the top-right corner of 
 the Game tab and offers an overview of how your game is performing in terms of frame rate and 
 resource usage, among others. It’s important to note that the Stats panel is 
 system specific
 , meaning 
 that it can help you understand how well your game is performing on the current hardware you’re 
 using. For this reason, always be sure to test and benchmark game performance on your target 
 hardware; that is, on the minimum specification for which your game is intended. To show the Stats 
 panel, activate the Game tab and click the Stats button from the viewport toolbar (see Figure 
 1-31
 ).
 Figure 1-31.
  Accessing the Stats panel
 There are many properties shown in this window. The following list details and explains some of 
 them, including 
 FPS
 , 
 Draw Calls
 , 
 Saved by Batching
 , 
 Tris
 , and 
 VRAM Usage
 .
 FPS
  (frames per second). This shows the number of frames that your game is actually rendering to 
 the screen each second. Generally, the higher and the more consistent this number, the better. There 
 is no ultimate right or wrong definitive answer as to what this number should be; it will vary over 
 time. The more important question is: Does your game look and perform as intended on your target 
 hardware? If the answer is No, then there’s a problem. And perhaps the Stats panel can help you 
 diagnose what it is. That being said, the FPS should not usually be less than 15 frames per second. 
 Below this rate, the human eye perceives stutter and lag, and that effect is exacerbated when the 
 FPS is not consistent—when it fluctuates radically up and down.",NA
Tip #12: Testing Resolution and Aspect Ratio,"If your game is intended for a specific resolution, such as 1920×1080 or 1024×768, or for a specific 
 aspect ratio, such as 16:9, then it’s useful to test your game in the Unity Editor at the appropriate 
 size. Achieving this is easier now than it ever has been. Switch to the Game tab, and then click the 
 Aspect drop-down box in the top-left corner. From here you can choose a range of preconfigured 
 resolutions and aspect ratios, or you can click the Plus icon at the bottom of the list to input your 
 own custom settings (see Figure 
 1-32
 ).
 www.itbookshub.com",NA
Conclusion,"This chapter achieved three main purposes. First, it detailed in overview the FPS game to be created 
 throughout this book, 
 Crazy Mad Office Dude
  (
 CMOD
 ). Second, it outlined the structure this book will 
 take to achieve that game—specifically, it detailed how the implementation work will be distributed across 
 chapters. And finally, in preparation for that work, it listed a range of practical and relevant guidelines and 
 workflows for using Unity in real-world projects. In short, by now you should be able to do the following:
 Understand the game to be created
 �
 Understand the elements that compose the game, including enemies, weapons, 
 �
 guns, power-ups, and more
 Appreciate how the implementation work for the game will be structured
 �
 Configure the Unity GUI for your comfort
 �
 Understand organization principles when working with project assets—storing 
 �
 assets in folders, using tagging, and naming game objects
 Understand the reasons for using FBX meshes
 �
 Read the Rendering Statistics window
 �
 Be committed to making regular backups of work
 �
 Use the Batch Rename tool
 �
 Understand the benefits of Root GameObjects
 �
 �
 Configure the resolution and aspect ratio for in-editor testing",NA
Chapter,NA,NA
 2,NA,NA
Getting Started,"In this chapter, we’ll start developing the FPS game, 
 Crazy Mad Office Dude
  (CMOD), from the very 
 beginning. This involves a wide breadth of steps; specifically, creating a new Unity project, importing 
 and configuring assets, building Prefabs and levels from modular environment pieces, building 
 lighting and lightmapping, and configuring a NavMesh for pathfinding. By the end of this chapter, 
 we’ll end up with a complete Unity project that’s entirely prepared and ready for C# scripting. This 
 project is also included in the book companion files, in case you want to skip this chapter and 
 concentrate just on C# coding, which begins in the next chapter. But I recommend working through 
 this chapter, too—because it features plenty of helpful tips and advice for Unity projects in general. 
 This chapter makes use of assets included in the book companion files, in 
 Chapter2/AssetsToImport
 . 
 So let’s fire up Unity, get the project files ready, and get started!",NA
Step 1: Create Folders,"Once you’ve created a new and empty Unity project, start thinking about project organization. Make 
 organization a priority—it can save you time. Create your project folders 
 first
  so you can quickly 
 arrange and categorize the assets you import right from the outset. For this project, the following 
 folders will be required: 
 Animation
 , 
 Audio
 , 
 Editor
 , 
 Materials
 , 
 Meshes
 , 
 Prefab
 , 
 Scenes
 , 
 Scripts
 , and 
 Textures
  (see Figure 
 2-1
 ). Once created, be sure to save the autogenerated default scene (
 Level_01
 ) 
 inside the 
 Scenes
  folder of the project, and from that point forward, save your work regularly using 
 the keyboard shortcut 
 Ctrl+S
  on Windows or 
 Cmd+S
  on a Mac.",NA
Step 2: Importing Textures and Meshes,"Importing meshes and textures is an interrelated process because meshes typically rely on textures. 
 Consequently, you can make importing run smoother and easier if you import textures 
 before
  
 meshes. By importing in this order, Unity detects which textures and materials to autoassign onto 
 your meshes at import time. This means your meshes will automatically show their texture in the 
 preview pane from the Object Inspector, and even on their thumbnails inside the Project panel. 
 However, importing in the reverse order causes meshes to appear a textureless gray, in both the 
 preview pane and Project panel, and usually this won’t change automatically, even after you’ve 
 imported the textures. So, working on this principle, import the texture first from the book project 
 files 
 AssetsToImport/Textures/mainTexture.png
  into the 
 Textures
  folder inside the Project panel. 
 For a single file like this, you can import using either the 
 Assets
  
 ➤
  
 Import New Asset
  menu option, 
 or by directly dragging and dropping the files from Explorer or Finder into the Unity Editor. The latter 
 method is preferable when importing multiple assets together. See Figure 
 2-2
  to see the imported 
 texture we’ll be using.
 Figure 2-1.
  Organizing project assets into folders
 Note
  This project will also make use of Standard Asset Packages that ship with Unity. Specifically, 
 Character 
 Controllers
  and 
 Standard Assets (Mobile)
 . These can be imported from the main menu by selecting 
 Assets 
 ➤
  
 Import Package 
 ➤
  
 Character Controller and Assets 
 ➤
  
 Import Package 
 ➤
  Standard Assets (Mobile)
 . 
 These packages include a First Person Controller asset that we’ll use later in the book.",NA
Step 3: FBX Meshes and Scale Factor,"Next, it’s time to import meshes, which are found in the book companion files at 
 AssetsToImport/Meshes
 . 
 Before doing so, however, there’s an “issue” to discuss relating to FBX files in general. Specifically, Unity 
 applies a default mesh 
 scale factor
  of 
 0.01
  to every imported FBX file. To see that, import a single FBX file 
 and check out the Scale Factor in the Object Inspector, as shown in Figure 
 2-3
 . The result is that every 
 imported FBX, by default, will appear in your scene 100 times smaller than its original size.
 Figure 2-3.
  FBX meshes are imported into Unity with a default scale factor of 0.01. This may not be what you want…
 The scale factor of 0.01 may, in fact, turn out to be suitable for your imported mesh, depending on 
 how it was modeled. But if it is, then presumably it’s only by accident. Typically, you’ll want the scale 
 factor to be 
 1.0
  and not 0.01. The value 1.0 means the mesh will appear at its original size, unless 
 it’s also being scaled in the scene. In any case, you can easily change the scale factor for a mesh 
 from the Object Inspector. But typing this in manually can be tedious. Instead, we can code an editor 
 extension to automate the process, forcing Unity to apply a scale factor of 1.0 to every imported 
 mesh. Let’s create this now, before importing our meshes.",NA
Step 4: Configuring Meshes,"After importing meshes into the project, there’s usually further configuring to do. First, when 
 importing meshes, Unity autocreates a new material inside a 
 Materials
  folder, which is further 
 nested inside the 
 Meshes
  folder—or wherever the meshes were stored. This material is assigned 
 automatically onto all imported meshes. Although we want to keep the material itself, the folder 
 organization is not neatly compatible with our own system and folder structure. So let’s move 
 the material into our original 
 Materials
  folder at the root of the project, and delete the empty 
 autogenerated 
 Material
  folder inside the 
 Meshes
  folder. This leads to a cleaner folder arrangement 
 (see Figure 
 2-5
 ).
 Figure 2-4.
  Imported meshes with Scale Factors of 1.0 and textured previews. Some meshes may appear rotated by 90 degrees 
 in the preview pane, but this is not a problem. They will appear at their correct orientation when added to the scene",NA
Step 5: Planning and Configuring Textures,"CMOD features only one texture, namely a 4096×4096 atlas. Its dimensions have been chosen 
 for two reasons. First, it’s a conventional power-2 size. Nearly every texture, except a GUI texture 
 or dedicated sprite, should be a power-2 size, for both performance and compatibility reasons. 
 However, the texture need not always be square. In short, a power-2 size means the texture’s width 
 and height (in pixels) may be any of the following sizes: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 
 2048, and 4096. Second, 4096 has been chosen, as opposed to any other power-2 size, because it’s 
 the 
 largest
  size supported by Unity and our target resolution is not clearly defined or known (I want 
 to support many screen sizes, resolutions and platforms).
 By making textures to the largest size possible therefore we can always downsize, if required, through 
 all the possible sizes that Unity supports. This is always preferable to making textures smaller than 
 needed, because 
 upsizing
  always incurs quality loss and blur, due to resampling. In general, make 
 textures exactly the size you need, and no smaller or larger. This is because 
 all
  resizing involves 
 resampling. But if you’re not sure about the sizes required, or if you need different sizes, then always 
 create your textures at the largest size, since downsizing incurs less degradation than upsizing.
 Note
  Through the Texture Properties dialog in the Object Inspector, Unity offers built-in features for resizing 
 textures “nondestructively.” That is, for resizing textures up or down, always based on the original. You can 
 simply select a texture in the Project panel and then pick a new size for it (see Figure 
 2-8
 ). Of course, this 
 still involves implicit resampling and quality loss as described earlier, but the resized versions are always 
 generated from the original imported texture and not from any other resized versions we may have generated 
 previously. This means any quality loss incurred through resizing is not accumulative, even if you resize 
 multiple times in succession.",NA
Step 6: Building Sprites,"Unity 4.3 introduced a range of features tailored for creating 2D games. These features primarily 
 include 
 Sprites
 , the 
 Sprite Editor
 , and the 
 Sprite Packer
 . As mentioned, CMOD will make use 
 of some of these features for creating billboard sprites in the level. These sprites will represent 
 enemies, power-ups, weapons, and other GUI elements, as shown in Figure 
 2-12
 .
 Figure 2-12.
  Sprites will be used to create enemies, power-ups, weapons, and more
 To add Sprite instances to a scene, we’ll need to generate Sprite assets. These are produced using 
 the Sprite Editor. In short, the Sprite Editor allows us to mark rectangular regions (UV rectangles) 
 inside an existing atlas texture to use as a sprite. Marking these regions manually with the mouse 
 can be a long and tedious process, but right now, there’s no quicker method. In addition, to make 
 the sprites accurately, you’ll probably need to work alongside your image editor application (such as 
 Photoshop or GIMP) to read and measure pixel coordinates and positions. Remember, I’ve already 
 created the sprites for you in the sample project, featured in the book project files, in the 
 Chapter2
  
 folder. The Sprite Editor can be accessed from the Texture Properties page by clicking the Sprite 
 Editor button (see Figure 
 2-13
 ).",NA
Step 7: Importing Audio,"Next, it’s time to import audio assets into the project. The book companion files for CMOD feature 
 only a few audio sound effects, created using the sound generator tool 
 SFXR
 , which can be 
 downloaded for free from 
 www.drpetter.se/project_sfxr.html
 . SFXR is software for procedurally 
 generating the kinds of sound effects commonly used in old-school video games, such as the 
 original 
 Super Mario Bros.
  and 
 Sonic the Hedgehog
 . For CMOD, there are a total of four sound 
 effects, all in WAV format, stored in the 
 Chapter2/AssetsToImport/Audio
  folder. These include 
 Explosion.wav
 , played whenever enemies are destroyed; 
 Powerup_Collect.wav
 , played whenever 
 the player collects a power-up object, such as cash or a weapon; 
 Weapon_Gun.wav
 , played whenever 
 the player fires the gun weapon; and finally, 
 Weapon_Punch.wav
 , played whenever the player uses the 
 default punch weapon. Go ahead and import all these sound effects into the Unity project, using 
 the conventional drag-and-drop method. Make sure the sounds are added to the 
 Audio
  folder in the 
 Project panel (see Figure 
 2-16
 ).
 Figure 2-16.
  Importing retro-style audio assets into the project. The audio assets for this book were generated using the free 
 program SFXR
 Every audio file for this project shares an important characteristic that requires us to adjust the 
 default import settings applied to them. Specifically, every audio file will be 
 2D
  and not 
 3D
 . That is, 
 none of our sounds are located at any specific 3D position in the scene. We don’t want or need their 
 volume to raise or lower based on the nearness or farness of the Player from others in the world. 
 Rather, the sounds should simply play in all speakers at a single and constant volume. Their purpose 
 is primarily that of feedback for the Player’s actions in-game, such as collecting a power-up or firing 
 a weapon. To adjust the default import settings to reflect this, select all imported audio assets, and 
 disable the 3D Sound check box from the Object Inspector (see Figure 
 2-17
 ). Once completed, all 
 audio assets are now successfully imported and configured ready-for-use in the scene.",NA
Step 8: Create Prefabs,"Importing assets is primarily about collating together and preparing the raw materials on which 
 our game will be founded and assembled. It’s essentially the lowermost layer or root stage of 
 development, on top of which all subsequent layers are made. Once importing is completed,  
 www.itbookshub.com",NA
Step 9: Scene Building,"When you’ve imported all relevant assets and established all Prefabs, it’s usually a good time to 
 start building your scene. Both Mesh assets and Prefabs will inevitably form the raw materials and 
 ingredients from which scene geometry is made. When inserting the first environment piece (whether a 
 mesh or a Prefab), I typically use the Transform properties in the Object Inspector to position it exactly 
 at the world origin, unless there’s a strong overriding reason not to do so. Doing this is not essential, 
 of course, as you can effectively position your meshes anywhere. But starting at the world origin and 
 building outward adds a certain degree of neatness and cleanliness to your mesh positions and scene 
 limits. This might at first seem a trivial preoccupation, but investing time upfront for good organization 
 and a desire for tidiness like this helps make development smoother. Ideally, development 
 should
  
 smoothly flow along from beginning to end, each step logically and reasonably following the previous.
 Figure 2-23.
  Breaking down environment pieces into Prefabs
 Note
  By level building from the origin and working outward, you can even improve performance on some 
 platforms, such as mobile devices.
 Once you’ve established a first piece in the scene, you can simply add your other pieces onto it, 
 repeating this procedure until your level is fully constructed as desired. For CMOD, I constructed the 
 scene in an ad-lib way: just adding different pieces together until I arrived at a design that felt right.",NA
Step 10: Lighting and Lightmapping,"Now it’s time to consider lighting and lightmapping for CMOD. For me, lightmapping is one of the 
 most fascinating ideas in game development. It was introduced as a limited solution to an intractable 
 problem; one which even today has no all-encompassing solution. The problem is that calculating 
 the effects of real-world lighting in a 3D environment—such as shadows, reflections, and indirect 
 illumination—is such a computationally expensive process that even the best consumer hardware 
 cannot approximate the effects with strong believability in 
 real time
 . Lightmapping is one of the 
 solutions to this problem. But it has important limitations, as we’ll see.
 Lightmapping is achieved in Unity via the Beast lightmapper, which is accessible from the main menu 
 via 
 Window
  
 ➤
  
 Lightmapping
  (see Figure 
 2-27
 ). This is a tool that casts rays of light into the scene, 
 outward from all light sources, and then traces how those rays bounce and react to scene geometry. 
 The purpose of this is to assess how bright or dark (and which color) the impacted surfaces should 
 be. This process can be time-consuming (in terms of hours or even days), but it lets developers 
 precalculate
  the effects of scene lighting at design time using the Unity Editor, and to bake the results 
 of that process into dedicated textures, known as 
 lightmaps
 . The lightmaps contain information 
 about shadows, color bleeding, indirect illumination, and more. Unity then automatically blends the 
 lightmaps onto the scene geometry at run-time, on top of the regular textures and materials, to make 
 the geometry 
 appear
  illuminated by the lights. Lightmapping is an intricate “trick,” but it can produce 
 powerful results. The famous author Arthur C. Clarke once said, “Any sufficiently advanced technology 
 is indistinguishable from magic,” and indeed, lightmapping has a certain kind of “magic” about it.
 Figure 2-27.
  Accessing the Beast lightmapper in Unity",NA
Step 11: Building a Navigation Mesh,"Later in this book, we’ll be creating three distinct Enemy characters to which we’ve been introduced 
 already. These are the 
 Drone
 , the 
 Tough Guy
 , and 
 Mr. Big Cheese
   To see these characters, check 
 out Figures 1-2, 1-3, and 1-4 in Chapter 1. As mentioned, these enemies will be “intelligent.” I use 
 the word 
 intelligent
  here in a narrow and precise sense. I mean the characters will not simply stand 
 around the scene motionlessly doing “nothing,” like props or inanimate objects. Instead, they’ll move 
 around and actively search for the Player. This process of “moving around” and “searching” for the 
 Player involves intelligence.
 The scene I’ve created for CMOD—assembled from environment pieces—consists of larger rooms 
 connected by narrow and winding corridors, as shown in Figure 
 2-29
 . These corridors have twists 
 and turns, and they also connect with one another to form junctions, points at which it’s possible to 
 travel in more than one direction. This kind of scene layout means that anytime an Enemy needs to 
 move, it must make 
 reasoned decisions
  about where it should go and how it should get there. The 
 enemy shouldn’t simply walk through walls and material objects. It’s supposed to avoid these. This 
 kind of obstacle avoidance is known as 
 navigation
 . Further, the enemy should move in a determined 
 and concerted way, travelling from one point to a clear destination elsewhere, as opposed to moving 
 erratically backward and forward with no sense of direction at all. This kind of route planning is known 
 as 
 pathfinding
 . Both of these concepts are achieved in different ways in Unity, but perhaps the most 
 common is through 
 navigation meshes
 . The details of implementing navigation and pathfinding are 
 considered in Chapter 7. However, in getting started with this project, and in generally building the 
 scene, some preliminary steps must be taken here for pathfinding. Specifically, we’ll build or 
 bake
  a 
 navigation mesh, much like we baked lighting through lightmaps. The navigation mesh will be used 
 later in Chapter 7, when creating enemies.
 Note
  Most navigation mesh features are included in the Unity free version, as of Unity 4.3. However,  
 off-mesh links (for connecting multiple NavMeshes), are a Pro Only feature.
 Note
  More information on lightmapping in Unity can be found at the Unity online documentation at 
 http://docs.unity3d.com/Documentation/Manual/LightmappingInDepth.html
 .
 In Unity terminology, an enemy is an agent (or more fully a 
 NavMesh Agent
 ). A NavMesh Agent is 
 simply any GameObject that must intelligently move around the scene when required. Whenever an 
 agent is told to move toward a destination (any Vector3 location within the scene), it first needs to 
 plan the most sensible route based on its current position, and then to follow that route while avoiding",NA
Conclusion,"This chapter charted the beginning of 
 Crazy Mad Office Dude
  in terms of project creation, asset 
 importing and configuration, as well as scene building and general project management. The 
 completed project so far can be found in the book companion files, inside the 
 Chapter2
  folder. The 
 scope of this chapter is vast, covering a range of powerful Unity features; features that together 
 would occupy many chapters in an introductory book. In doing this, many subjects were necessarily 
 discussed only briefly or parochially—that is, in ways specific to 
 this
  project. The reason is because 
 the 
 main
  focus of this book is on 
 C# development
  in Unity, as opposed to wider tasks such as 
 lightmapping and navigation meshes.
 Taken as a totality, this chapter documents everything you need to do and know for CMOD to take 
 the project from an empty state to one that’s prepped and ready for customization through C#. Of 
 course, this general preparation process and workflow applies more widely and to potentially many 
 more projects than CMOD. The principles put into practice here, such as the 
 modular building 
 method
  and 
 lightmapping
 , can be abstracted from their particular context for CMOD and seen 
 generally. But, the main point of this chapter is to show you a practical case study in Unity; one that 
 begins from an empty project and moves toward a state where we’re ready to start programming.  
 At this point, we’ve now reached that state, and before moving onward, let’s recap what we’ve 
 learned here. By now, you should be able to do the following:
 Create Unity projects and import and configure assets, as well as understand 
 �
 the rationale behind specific importing and organization techniques
 Apply a C# FBX ScaleFix to imported meshes, automatically customizing their 
 �
 scale to 1
 Appreciate import considerations around mesh colliders and lightmap UVs
 �
 Understand Texture Import settings and their relationship to Sprite assets
 �
 Know how to use the Sprite Editor to create sprites from atlas textures
 �
 Import and configure 2D audio files
 �
 Understand the modular building method and the importance of Prefabs
 �
 Generate usable lightmaps and work with Lightmap assets
 �
 Understand the importance of Lightmap settings
 �
 Generate navigation meshes
 �
 Understand how to edit Generation settings to produce appropriate navigation 
 �
 meshes for your scenes",NA
Chapter,NA,NA
 3,NA,NA
Event Handling,"Now we’re ready to begin game coding in C#, and there’s a lot to do. At this stage, you should have 
 a prepped Unity project available, either a project you’ve created manually by following along with 
 previous chapters or the ready-made project provided in the book companion files in the 
 Chapter2
  
 folder (as shown in Figure 
 3-1
 ). This project represents CMOD so far and includes one scene file with 
 a complete level, including meshes, prefabs, textures, lighting, and navigation. From this project, 
 we’ll begin in this chapter to add new behavior and functionality through C# scripting.
 Figure 3-1.
  The completed project so far, which can be found in the book companion files in the Chapter2 folder. In this chapter, 
 we’ll start add C# script by coding an event-handling system",NA
Events and Responses,"For game developers, game worlds are ultimately 
 deterministic
  systems. This means that, once 
 the game begins (the beginning of game time), everything else that follows does so 
 because
  of a 
 sequential flow of events. That is, everything that happens is a calculated 
 response
  to a related and 
 previous cause, which we may call an 
 event
 . For example, enemies attack the player 
 when
  he or she 
 comes into their line of sight 
 because
  there exists artificial intelligence (AI) functionality telling the 
 enemies to act that way under those very conditions. Similarly, the Player character fires its weapons 
 when it does, only because there exists an underlying mechanism watching for human input and for 
 responding to it when the player presses the designated “fire” button, whichever button that happens 
 to be. Seen in this way, a video game can be conceived as an integrated system of events and 
 responses. Specifically, an event happens and something else happens in response. And this process 
 goes on each and every frame, until the game is terminated in some way—hopefully by the player 
 pressing Quit as opposed to the game’s crashing from a bug! Among these events, two main kinds 
 can be identified: 
 gameplay-level events
  and 
 system-level events
 . These two terms are not part of an 
 industry standard vocabulary so much as terms I’m inventing here for convenience and description.
 �
 Gameplay-level events.
  These describe all events, which even a reflective and 
 thoughtful gamer might identify themselves during gameplay, as being events in 
 the game world. These include events such as 
 when the player presses a lever 
 on the wall
 —perhaps to unlock a door or open a secret passageway, or 
 when 
 an enemy is killed
 , or 
 when the player enters a room or region in the level
 , or 
 when all power-ups have been collected
 . The total number of possible events 
 belonging to this group is potentially infinite, but all of them happen 
 in the game 
 world
 . They are an integral part of the “fiction.”
 �
 System-level events.
  These events are in a fundamental sense hidden from 
 the gamer and exist outside the game world. These are the events that only the 
 game developer knows about and include all core events, which are part of the 
 underlying game mechanics. They pertain to the foundational wheels and cogs 
 of the game. Such events include 
 when the player saves and loads her game
 , 
 when an error occurs
 , 
 when the game is paused
 , 
 when the system resolution 
 is changed
 , or 
 when a network timeout occurs
 . Like gameplay-level events, 
 however, system-level events may be a potentially infinite in number. They may 
 not, of course, be infinite in practice because computers have a maximum 
 capacity. But they are potentially infinite in that there’s no obvious limit to the 
 number of events you could invent or think about.",NA
Event Handling,"Games, as we’ve seen, can be conceived as a chain of events and responses. Event handling is the 
 practice of 
 working
  with and 
 managing
  those events and responses in-game. Thus, event handling is 
 something we must engineer and build into a game. It’s not something that exists ready-made for us, 
 even with Unity. In this chapter, we’ll be using C# to engineer such a system. However, the question 
 arises as to why we should begin game development here, as opposed to elsewhere. After all, if 
 there are different ways to begin development, and none of them necessarily right or wrong, then it 
 surely cannot be wrong to begin elsewhere. And this is true. But nonetheless there are 
 compelling
  
 reasons to begin here. These are as follows:
 �
 Events are foundational.
  Events are everywhere in games. Whenever an 
 underlying action or function in code has the potential to effect something 
 else in-game, then in practice an event is happening, even if you don’t always 
 see it that way at the time. And every time you think it’d be useful for some 
 process to detect and respond to a situation happening elsewhere, you’ve just 
 thought about an event-and-response scenario. Events are thus so foundational 
 to games that it’s almost impossible to create any functionality or classes or 
 behavior without referring to them or using them. Consequently, since the 
 practice of making games is essentially an exercise in engineering and building, 
 it’s good practice to begin with foundations. It’s good practice to make those 
 foundations strong so they may sustain the complexities of the structure above.
 �
 Events are abstract.
  This means that events are relevant to almost every kind of 
 game. And something important and powerful comes from this; namely, events 
 are 
 not
  design-restrictive. That is, being so general and widely applicable, events 
 themselves never place constraints or limitations on how you should implement or 
 make the rest of your game. Events, for example, never say that enemies cannot 
 have range or magical attacks. They never require you to keep the vehicles in 
 your game to only ground-based ones, as opposed to airborne or seaborne ones. 
 Events as a concept really don’t care about these specifics or particular instances. 
 They have a more general and abstract nature that frees them from specifics. And 
 so in practice this frequently means that if you create events from the outset, you 
 don’t put any technical or logistical restrictions on the kinds of things you may have 
 elsewhere in the game. Thus, coding events empower you and never limit you. 
 There’s no good reason to narrow your horizons before it’s necessary to do so.",NA
Planning Event Handling,"Before jumping into coding an event-handling system, or any functionality for that matter, it’s a 
 good idea to plan and think ahead. This 
 reduces
  our chances of making mistakes and wasting time. 
 Of course, it doesn’t eradicate our chances entirely! In this chapter, we’ll code a 
 dedicated
  event-
 handling class, and there are strong reasons for doing this. Rather than list them, let’s see what they 
 are 
 in practice
 . Specifically, let’s consider some “simpler” and alternative ways of handling events, 
 and examine the attendant problems or limitations associated with them.
 Perhaps the simplest method to event handling is to forget about creating a dedicated class 
 altogether, and to code event-handler functionality directly into all the classes that need it. For 
 example, let’s imagine we need to detect an event, such as when Player health falls to 0 or below, so 
 we can kill the Player and display a “Game Over” message. The event is 
 when Player health falls to 0 
 or below
 , and the response is 
 die and show “Game Over”
 . This kind of functionality could be coded 
 into the 
 Player
  class, as shown in Listing 3-1.
 Listing 3-1. Player Class Detecting Death Events
 using UnityEngine;
 using System;
  
 //Player class
 public class Player: MonoBehaviour
 {
         //[...] Other stuff declared here
  
         //Health variable
         
 public int Health = 100;
          
         //[...] Other functions would be included here
  
         //Update function called on each frame
         void Update()
         {
                 //Check player health
                 
 If(Health <= 0)
                         Die(); //Is <= 0, then run death functionality
         }
 }
  
 Note
  The class coded in Listing 3-1, and in subsequent parts of this section, is hypothetical only. That is, 
 it’s an imaginary class used merely to demonstrate a point. It’s not necessary to code this class yourself or to 
 include it in the final CMOD project.",NA
Planning a Dedicated Event-Handling System,"The previous section justified the general desirability for taking a more focused and streamlined 
 approach toward events and event handling in games. In this section, we’ll establish the beginnings 
 of a dedicated and centralized C# event-handling class, which I’ll name the 
 NotificationsManager
 . 
 I’ll create the code for this class inside the script file 
 NotificationsManager.cs
 . In general, a game 
 or scene should have only 
 one
  active instance of this class in memory, and 
 no more
  than one. This 
 kind of object is known as a Singleton object, a concept considered further in the next chapter. In 
 short, the NotificationsManager will be singularly responsible for broadcasting 
 all
  events to 
 all
  other 
 objects that 
 must
  know about those events. In other words, its duty will be to 
 notify
  every object 
 in the game about every event it must handle, as and when the event happens. In essence, the 
 NotificationsManager will work as follows (also see Figure 
 3-2
 ).",NA
Getting Started with NotificationsManager,"Let’s now put our NotificationsManager plan into practice inside Unity. To create this class, we’ll 
 need to start by creating a new C# source file. I’ll explain how to do that here in case you need a 
 refresher, but for subsequent classes created throughout the rest of the book, I’ll assume you already 
 know how to do it. To create a new C# source file, right-click the 
 Scripts
  folder of the Project panel, 
 and select 
 Create
  
 ➤
  
 C# Script
  from the context menu (as shown in Figure 
 3-3
 ). Alternatively, you 
 can select 
 Assets
  
 ➤
  
 Create
  
 ➤
  
 C# Script
  from the application menu. Be sure to name the file 
 NotificationsManager.cs
 .
 Note
  The NotificationsManager developed will be based loosely on the well-known, third-party  
 class 
 NotificationsCenter
 , available online for free from the Unity Community web site at  
 http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter
 .
 However, although NotificationsManager will be based on 
 NotificationsCenter
 , it will take a slightly 
 different approach, as well as implement additional functionality. It’s worth mentioning, too, that you 
 don’t
  
 need to be familiar with the 
 NotificationsCenter
  to implement the NotificationsManager here. We’ll 
 explore NotificationsManager creation from the very beginning.",NA
Keeping Track of Notifications with .NET Dictionaries,"Thinking carefully about the 
 NotificationsManager
  class we know that (a) Posters must tell the 
 NotificationsManager when an event occurs, and (b) when told about an event, the NotificationsManager 
 should notify all registered Listeners 
 for that event
 . This entails that the Notifications Manager 
 must internally maintain a list of all listeners that should be notified for an event when it happens. 
 These listeners should be organized into lists by 
 event type
 . That is, for any event type (such as 
 OnPlayerHealthChange
 ) 
 there could be none, one, or more listeners
 . Regardless, however many or 
 however few objects are listening for an event, it’s the responsibility of the NotificationsManager to notify 
 them all whenever that event happens. And so ultimately our class has two main technical requirements: 
 we must maintain a list of 
 events
 , and for each type we must maintain a list of associated 
 listeners
 .",NA
Generic Classes and C#,"In the previous section, we added a two-dimensional dynamic array member to the 
 NotificationsManager to act as an organized and searchable collection of 
 Event a
 nd 
 Listener
  
 objects. This was implemented on line 08 of Listing 3-7, using the 
 Dictionary
  and 
 List
  classes from 
 the .NET Framework. In declaring both these classes in just one line, we relied on the concept of 
 Generic
  (or 
 Template
 ) classes. Let’s discuss these further here for clarity.
 If you go online and examine the Microsoft documentation for the 
 List
  class at  
 http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx
 , you’ll see from the title 
 section that List is written as 
 List<T>
 . Notice the 
 <T>
  post-fix in that title. What does that mean?
 In short, the post-fix 
 <T>
 , when applied to a class, means the class is 
 not
  strictly typed, and instead 
 uses 
 Generics,
  which are a loose, stand-in data type that mean whatever you want them to mean. It 
 means the 
 List
  class is not restricted to being a list of 
 integers
 , or a list of 
 strings
 , or a list of 
 chars
 , 
 or a list of 
 components
 . It can be 
 any
  of these if you want it to be, as well as any other data type you 
 may want it to be. Consequently, a list of integers can be made with
 List<
 int
 > MyIntegers = new List<
 int
 >();
 And a list of strings with
 List<
 string
 > MyStrings = new List<
 string
 >();
 And a list of components with
 List<
 Component
 > MyStrings = new List<
  
 Component
 >();
 This means that the first element in the list, at List[0], will be an integer for integer lists, a string for 
 string lists, and so on. This powerful data-type versatility that comes from using Generics is not just 
 restricted to the .NET 
 List
  class or to the .NET Framework itself. It is a C# language feature. The 
 Dictionary
  class also uses Generics. Let’s look at line 08 from Listing 3-7 again.
  
 private Dictionary<
 string
 , List<
 Component
 >> Listeners = new Dictionary<string, List<Component>>();
  
 Note
  To use the 
 Dictionary
  class, as well as the 
 List
  class, we must include the  
 System.Collections.Generic
  namespace (see line 03).
 More information on the 
 Dictionary
  class can be found online at  
 http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx
 .
 Information on the 
 List
  class can be found at  
 http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx
 .",NA
Registering As a Listener,"So the NotificationsManager now has a private Dictionary member, which makes use of 
 Generic 
 types
 , and this allows us to maintain a searchable list of potential listeners for events, and the 
 size of the list can grow and shrink over time. Each listener in the list is specified as being of type 
 Component
 , but thanks to class inheritance and polymorphism, it can really be of 
 any
  type 
 descended 
 from
  Component, including MonoBehaviour. For more information on polymorphism, see Chapter 10.  
 In essence, this means our list of listeners can be a wide mix of different types. In this section, we’ll 
 add functionality to the NotificationsManager that lets us 
 add
  a new Listener to the list. If an object 
 expects to be notified about any event, then it must previously have registered itself as a Listener 
 with the NotificationsManager. When an object registers itself as a Listener, it’s effectively saying, 
 “Hey, NotificationsManager. I want you to tell me about every occurrence of event X, as and when 
 it happens!” To achieve this functionality, a new public method 
 AddListener
  can be added to the 
 NotificationsManager (see Listing 3-8).
 Listing 3-8. Adding Listeners to the NotificationsManager
 01 //Function to add a listener for an notification to the listeners list
 02 public void 
 AddListener
 (Component Listener string NotificationName)
 03 {
 04         //Add listener to dictionary
 05         if(!Listeners.
 ContainsKey
 (NotificationName))
 06                 Listeners.Add (NotificationName, new List<Component>());
 07
 08         //Add object to listener list for this notification
 09         Listeners[NotificationName].
 Add
 (Listener);
 10 }
  
 The 
 AddListener
  method accepts two arguments: namely, 
 Sender
  and 
 NotificationName
 . The 
 Sender
  
 is a Component reference to the object that should become the registered listener. This is the object 
 that must be notified by the NotificationsManager, if and when the event occurs. 
 NotificationName
  
 is a string indicating the custom event type for which the Sender is listening. This is a user-defined 
 string naming the events for our game.",NA
Posting Notifications,"The 
 reason
  an object registers itself as a listener for an event in the first place is to 
 receive
  
 notifications when the event actually happens. So far, however, the NotificationsManager only 
 implements the 
 AddListener
  function, which just builds a list of listeners. The class doesn’t (yet) 
 notify those listeners when events happen. This posting behavior should be implemented now, 
 through the 
 NotificationsManager.PostNotification
  method. This method should be called by 
 any and all classes that 
 cause
  or 
 detect
  events. Effectively, these classes say “Ah ha! An event has 
 happened. I detected it. So now, I’ll tell the NotificationsManager. He’ll know what to do. He’ll pass 
 on this notification to all registered listeners for this event.” Take a look at Listing 3-10.
 Listing 3-10. Posting Notifications to the NotificationsManager
 01 //Function to post a notification to a listener
 02 public void 
 PostNotification
 (ComponentListener, string NotificationName)
 03 {
 04      //If no key in dictionary exists, then exit
 05      
 if(!Listeners.ContainsKey(NotificationName))
 06                      return;
 07
 08      //Else post notification to all matching listeners
 09      foreach(Component Listener in Listeners[NotificationName])
 10               Listener.
 SendMessage
 (NotificationName, Listener,  
 SendMessageOptions.DontRequireReceiver);
 11 }
  
 This is where the “magic” really happens for this class. The following points break it down.
 1. 
 Line 02.
  The 
 PostNotification
  function accepts two arguments: 
 Sender
  
 and 
 NotificationName
 . The 
 Sender
  argument refers to the component 
 or object that first detected or caused the event, and that notifies the 
 NotificationsManager. In other words, this argument will be a reference to 
 the object that invokes or calls the 
 NotificationsManager.PosNotification
  
 method. The 
 NotificationsName
  argument is a user-defined string indicating 
 the event that occurred.",NA
SendMessage and BroadcastMessage,"When working in Unity, and with the 
 component-based paradigm
 , (or with 
 entity-based 
 programming
 , as it’s sometimes called), the chances are high that’ll you be creating a lot of C# script 
 files and adding them to your game objects as components. The components you create, which 
 are classes, will be your own custom types, typically derived from 
 MonoBehaviour
 , or from other 
 descendent classes. As such, your classes will support a range of different variables and functions 
 to define their own behavior, making each class specific and unique. This is to be expected. 
 However, this raises a problem in C#, which is a strictly typed language. Specifically, there are often 
 times when you’ll want to work with many game objects together, invoking functions and behavior 
 on their components without having to know or worry about their specific data type and interface. 
 For example, due to a destructive explosion event in your game, you may want to destroy a batch 
 of different but nearby objects clustered together in the scene, such as enemies, power-ups, props, 
 and maybe even scenery parts.
 Before destroying the objects, however, it’d be useful to call a function or event on them all, notifying 
 them about their impending doom, so each has the opportunity to respond appropriately. Maybe 
 some objects play a destruction sound, while others flash red. In these cases, you’ll want to call 
 a function on 
 all
  the objects, but 
 without
  having to know anything specific about their component 
 classes or data types. You simply want to invoke a function in all components across multiple 
 objects, whatever their data type and interface may be. The 
 SendMessage
  and 
 BroadcastMessage
  
 functions both allow you to do this in different ways.",NA
Removing Listeners,"The NotificationsManager, with the help of 
 AddListener
  and 
 PostNotification
 , can now build a list of 
 registered listeners for events, and further notify those listeners when their events happen. But should 
 we do if a Listener no longer wants to be notified about an event? What if the Listener wants to 
 unregister itself as a listener, removing itself from the Dictionary entirely? Right now the Notifications 
 Manager doesn’t support this behavior. But we can easily add support for it. Consider Listing 3-11.
 Listing 3-11. Removing a Listener from the Dictionary
 01 //Function to remove a listener for a notification
 02 public void 
 RemoveListener
 (Component Sender, string NotificationName)
 03 {
 04         //If no key in dictionary exists, then exit
 05         if(!Listeners.ContainsKey(NotificationName))
 06                 return;
 07
 Figure 3-7.
  BroadcastMessage works like SendMessage, except it cascades function calls downward through the GameObject 
 hierarchy, rather than applying to only one GameObject
 Note
  If, after reading this section, you still don’t feel comfortable or familiar using 
 SendMessage
  and 
 BroadcastMessage
 , then don’t worry: both 
 SendMessage
  and 
 BroadcastMessage
  will be used 
 extensively in this book. We’ll get plenty of practice using them!
 SendMessage
  and 
 BroadcastMessage
  work for both the 
 Component
  and 
 GameObject
  classes. When 
 called on GameObjects, 
 SendMessage
  invokes a named function on 
 all
  attached Components. For single 
 Components, 
 SendMessage
  invokes a named function on only the specified Component.",NA
Removing Redundancies,"The 
 RemoveListener
  method is useful in cases where an object explicitly removes itself as a Listener 
 from the Dictionary. This is a respectful and tidy way to work, whenever an object no longer wants 
 event notifications. But the possibility remains that a valid 
 Listener
  object could be deleted from the 
 scene without ever calling 
 RemoveListener
  to remove itself from the Listener Dictionary. If that were 
 to happen, the associated entries in the Dictionary for that object would remain intact but become 
 null references and thus be redundant. This could later cause exceptions and errors when methods, 
 such as 
 PostNotification
 , iterate through all associated listeners, calling 
 SendMessage
 . It would be 
 problematic because we cannot legitimately call 
 SendMessage
  on null references, since no object 
 exists to support the function call. For this reason, we’ll need to add a new method, which can be 
 called to cycle through all listeners for all events, and to remove any redundancies if they are found 
 (see Listing 3-12).
 Listing 3-12. Removing All Redundancies from a Dictionary
 01 //------------------------------------------------
 02 //Function to remove redundant listeners - deleted and removed listeners
 03 public void 
 RemoveRedundancies
 ()
 04 {
 05         
 //Create new dictionary
 06          Dictionary<string, List<Component>> TmpListeners = new Dictionary<string, 
 List<Component>>();
 07
 08         //Cycle through all dictionary entries
 09         foreach(KeyValuePair<string, List<Component>> Item in Listeners)
 10         {
 11                 //Cycle through all listener objects in list, remove null objects
 12                 for(int i = Item.Value.Count-1; i>=0; i--)
 13                 {
 14                         //If null, then remove item",NA
Completing NotificationsManager,"We’ve now seen the core parts of the NotificationsManager—the things that make it work and 
 be what it is. Critically, this includes the 
 AddListener
 , 
 PostNotification
 , 
 RemoveListener
 , and 
 RemoveRedundancies
  methods. Together, these constitute the backbone or infrastructure of the  
 event-handling system. With just these methods, we can receive and send event notifications 
 to practically any kind of GameObject and Component in a Unity scene. Let’s see the 
 NotificationsManager
  class in full, leaving out no code, as shown in Listing 3-13. This class can also 
 be found in the book companion files, inside the 
 Chapter03
  folder.
 Listing 3-13. The Completed NotificationsManager Class (NotificationsManager.cs)
 01 //EVENTS MANAGER CLASS - for receiving notifications and notifying listeners
 02 //------------------------------------------------
 03 using UnityEngine;
 04 using System.Collections;
 05 using System.Collections.Generic;
 06 //------------------------------------------------
 07 public class NotificationsManager : MonoBehaviour
 08 {
 09         //Private variables
 10         //------------------------------------------------
 11         //Internal reference to all listeners for notifications
 12          private Dictionary<string, List<Component>> Listeners = new Dictionary<string, 
 List<Component>>();
 13
 14         //Methods
 15         //------------------------------------------------
 16         //Function to add a listener for an notification to the listeners list
 17         public void AddListener(Component Sender, string NotificationName)
 18         {
 19                 //Add listener to dictionary",NA
Working with the NotificationsManager,"So how does the NotificationsManager work in practice? Practically every subsequent chapter in 
 this book will use it, so we’ll see plenty of examples of the class at work. However, to distill the 
 basics into a simple project and to put things into perspective, let’s create a sample application here 
 that uses the NotificationsManager directly. The steps for creating this project follow.
 First, create a new Unity project, if you’ve not already done so. The project name and import 
 packages are not critical in themselves—since we’re simply building a test-project to try out the 
 NotificationsManager
  class. Be sure to the save the default autogenerated scene (I’ve named mine 
 TestingNotifications.scene
 ), and then import the 
 NotificationsManager.cs
  C# file from Windows 
 Explorer or Mac Finder into an appropriately named folder inside the Unity Project panel, such as 
 Scripts
  (see Figure 
 3-8
 ).",NA
Conclusion,"In this chapter, we established an abstract but highly important starting point for CMOD in the form 
 of a 
 NotificationsManager
  class. This class is general in the ultimate sense that it stands apart from 
 any particular game project, and has wider relevance to practically every game project imaginable, 
 including CMOD. Its purpose is to centrally receive a single notification from any object in a 
 Unity scene that detects and causes events. And then, having received that notification, it should 
 immediately go on to dispatch it to any and all objects that have registered an interest in the event—
 these objects being referred to as Listeners. Don’t be fooled by the simplicity and “shortness” of this 
 class. As we’ll see, it is powerful! At this point, you should be able to do the following:
 Create C# script files and define custom behavior
 �
 Understand the problems of events and event handling, as well as the need for 
 �
 streamlining and managing events
 Understand how the NotificationsManager works, and its relationship to 
 �
 Notifications and Listeners",NA
Chapter,NA,NA
 4,NA,NA
Power-Ups and Singletons,"CMOD will feature a total of four different power-up types, scattered around the level for collection. 
 First, the game-critical power-up of 
 Cash
  (see Figure 
 4-1
 ). Each level features multiple Cash 
 Power-Ups, and when all of these are collected without the Player dying, the level is classified 
 as complete. Second, a weapon-upgrade power-up that equips the Player with the gun weapon. 
 Third, an ammo-restore power-up to replenish the gun ammo back to maximum. And fourth, a 
 health-restore power-up to restore Player health back to maximum. All four of these power-ups 
 will be collected and applied when the Player collides with (or walks into) them. To implement 
 this behavior efficiently and to integrate it with the NotificationsManager (coded in the previous 
 chapter), we’ll make use of a very powerful type of C# object, known as a 
 Singleton
 . This object 
 was discussed briefly in the previous chapter, but here we’ll examine it in more detail. So let’s get 
 started at creating power-up objects for CMOD!",NA
Creating the Cash Power-Up,"The first power-up to address is perhaps the most significant in terms of general game-mechanics, 
 namely the Cash Power-Up. The Cash Power-Up is the most significant because without this power-up,  
 the player can’t complete the game. The aim of the player in any level of CMOD is to explore the 
 environment, collecting all Cash Power-Ups. When all Cash Power-Ups are collected, the level 
 is completed. Like all power-ups in CMOD, the Cash Power-Up will be sprite based. That is, its 
 appearance and form in the level will be based on a sprite from the main atlas texture, as opposed 
 to a “true” 3D mesh. As with the environment pieces configured in Chapter 2, we 
 could
  make the 
 power-up by simply dragging and dropping sprite instances into the scene, one sprite for each 
 power-up instance, and then customize each one with scripted components, one at a time. But an 
 easier way is simply to create 
 one
  power-up instance, and then package it as a Prefab that we’ll 
 reuse as many times as we need. That’s the approach we’ll take here. So to start creating the Cash 
 Power-Up, open the main atlas texture for the game in the Project panel, and drag and drop the 
 Cash Power-Up sprite from the texture into the scene hierarchy. This instantiates one cash sprite in 
 the scene—ready for scripting. Notice in Figure 
 4-2
  that I’ve applied some scaling to the sprite, to 
 better fit it into the level.
 Figure 4-1.
  Cash Power-Ups (with a scale of 0.3039) prepared and added to the level in the Unity Editor. The power-ups will be 
 created as a Prefab objects, with scripts attached, for easy reuse",NA
Power-Ups and Billboards,"If you add the Cash Power-Up sprite to the scene and then take a look at it in-game with a First 
 Person Controller, looking at the sprite from many possible angles, you’ll notice a problem, as seen 
 in Figure 
 4-3
 . Specifically, the Cash Power-Up looks like a cardboard cutout, completely flat. In fact, 
 it’s even possible to walk around the side of the power-up, catching it at an angle where it’s almost 
 lost from view entirely, because it has no thickness or depth. This is not a flaw or fault of the sprite 
 per se so much as it’s a 
 consequence
  of the sprite’s 2D-ness. A sprite is supposed to be 2D. This 
 is usually not a problem for 2D games that have fixed orthographic cameras always focused on 
 one side or aspect of the sprite, but when you mix 2D and 3D together, as in CMOD, the flatness of 
 sprites can become troublesome in this way.",NA
Billboards and Cached Transforms,"The critical feature of Billboard functionality is that it 
 rotates
  a sprite to face the camera. 
 Consequently, any 
 Billboard
  class must access the Transform component of a GameObject on 
 every frame, to achieve a permanent state of object rotation using any of Transform’s members or 
 functions, such as 
 Transform.rotation
 , or 
 Transform.Rotate
 , or 
 Transform.RotateAround
 . These 
 members and functions can be accessed easily for any component on a game GameObject by 
 referencing its internal property, known as 
 transform
  (lowercase t). For example, you may access an 
 object’s 
 Transform
  and translate it in world space with the following code in Listing 4-2.
 Listing 4-2. Using the transform Property
 void Update()
 {
        //Sets the object’s 
 world
  positon to 10, 10, 10
        transform.position = new Vector3(10, 10, 10);
 }
         
 Now, although the code in Listing 4-2 
 works
  and 
 achieves
  its purpose, it can still be improved in terms 
 of performance and efficiency, albeit marginally so. The main problem with the code is that, during 
 Update
 , a reference to transform is being made, which is a 
 C# property
  and 
 not
  a 
 member variable
 . This 
 means that every call to 
 transform
  indirectly invokes a function (
 Property
 ), which 
 returns
  a reference 
 to the Transform component. 
 transform
  does not, however, access an object’s Transform directly, as 
 a member variable would. Remember, C# properties were covered in depth in the previous chapter. 
 Because 
 transform
  is a property, there is a small optimization we can perform, known as 
 Cached 
 Transforms
 . Consider the refined Billboard class in Listing 4-3, which uses Cached Transforms.
 Listing 4-3. The Billboard Class Prepared for Action with Cached Transforms
 01 using UnityEngine;
 02 using System.Collections;
 03
 04 public class Billboard : MonoBehaviour
 05 {
 06     
 private Transform ThisTransform = null;
 07
 08     // Use this for initialization
 09     void Start ()
 10     {
 11             //Cache transform
 12             
 ThisTransform = transform;
 13     }
 14 }
  
 Listing 4-3 shows how, in just two lines of code, we can create a Cached Transform object.  
 In essence, using the 
 Start
  event (at line 09), we store a direct and local reference to an object’s 
 Transform
  component with the private Transform member 
 ThisTransform
 . 
 ThisTransform
  is a 
 member variable and not a property, and gives us direct and immediate access to the 
 transform
  
 component. Consequently, by using 
 ThisTransform
  instead of 
 transform
  on 
 Update
  functions, we 
 can reduce additional and unnecessary functional calls on every frame. This may initially seem a",NA
Billboards and Rotation,"For a sprite to truly act as a Billboard, it needs to continually rotate (around the Y axis) to face the 
 game camera, wherever it may be in the scene (see Figure 
 4-4
 ). We don’t need to worry about  
 Z and X rotations for CMOD, since the player cannot crouch, jump, or roll over to see the sprite from 
 underneath or above. Using Cached Transforms, we can achieve this rotation in only a few lines of 
 code. (Listing 4-4 shows the complete 
 Billboard
  class. Comments follow, and I recommend reading 
 the code sample through a few times—it uses many different concepts that we’ll explore.)
 Figure 4-4.
  CMOD sprites will need to rotate around the Y axis (YAW)
 Listing 4-4. Completing the Billboard Class
 01 using UnityEngine;
 02 using System.Collections;
 03
 04 public class Billboard : MonoBehaviour
 05 {
 06     private Transform ThisTransform = null;
 07
 08     // Use this for initialization
 09     void Start ()
 10     {
 11             //Cache transform",NA
Billboards and Bobbing,"We’re making good progress with the Cash Power-Up, but it still needs “something more” than just 
 the ability to act as a Billboard. To really “stand out” to the player as a collectible object, it needs to 
 move. True, the power-up 
 technically
  moves already, as it always rotates to face the camera, but this 
 movement is 
 practically
  imperceptible because it’s perfectly synchronized with the camera. So to 
 create perceptible movement, we’ll need to translate the power-up to move it. Specifically, we’ll add 
 a bobbing motion, making the power-up gently move up and then down in a loop (see Figure 
 4-6
  to 
 see the planned motion).
 Figure 4-6.
  Adding bobbing motion to the power-up to help it stand out as a collectible object
 The act of vacillating continuously between two extremes, such as moving up and down repeatedly, 
 is termed 
 PingPonging
 . To create a PingPong for object movement, then, we’ll need to create a 
 new C# class and component. I’ll call this class 
 PingPongDistance
 , since it’ll move the power-up up 
 and down by a specified distance, back and forth. The development of this class will also introduce 
 two highly important concepts in Unity—namely, 
 deltaTime
  and 
 coroutines
 . Let’s start the class, as 
 shown in Listing 4-5.
 Listing 4-5. PingPongDistance.cs: Starting a PingPong Class for Animating Power-Up Movement
 01 using UnityEngine;
 02 using System.Collections;
 03
 04 public class PingPongDistance : MonoBehaviour
 05 {
 06     private Transform ThisTransform = null;
 07",NA
Coroutines,"Before proceeding with the power-up PingPong movement, we’ll take a detour into the world 
 of coroutines, which will come in useful for us soon. In Unity, coroutines 
 act like
  threads or 
 asynchronous functions, if you’re familiar with those concepts. In short, typical functions in Unity 
 and C# act 
 synchronously
 . This means that, when an event (like 
 Start
 ) calls a function in a class, 
 the function performs its behavior sequentially, line by line from top to bottom, and then finally 
 terminates at the end, returning a value. When the function returns, the calling event will resume 
 its execution at the next line. But coroutines don’t seem to act that way. They act like they are 
 asynchronous (although they are not truly so). When you call a coroutine, it starts execution and 
 seems to “run in the background” 
 at the same time
  as other functions. With this ability comes great 
 power, as we’ll see. Consider the following Listing 4-6, which uses a coroutine; comments follow.
 Listing 4-6. Sample Coroutine
 01 using UnityEngine;
 02 using System.Collections;
 03
 04 public class PrintHelloWorld : MonoBehaviour
 05 {
 06     // Use this for initialization
 07     
 IEnumerator Start ()
 08     {
 09             //Start Coroutine
 10             
 StartCoroutine(Counter());
 11
 12             //Has finished
 13             Debug.Log (""Counter Finished"");
 14
 15             
 yield break;
 16     }
 17
 18     
 IEnumerator Counter()
 19     {
 20             for(int i=0; i<10; i++)
 21             {
 22                    Debug.Log (i.ToString() + "" Seconds have elapsed"");
 23                    
 yield return new WaitForSeconds(1.0f);
 24             }
 25     }
 26 }",NA
Power-Up Motion with Coroutines and deltaTime,"Listing 4-8 provides the complete class for 
 PingPongDistance
 . And this class is also included in 
 the book companion files for this chapter at 
 Chapter2/AssetsToImport
 . Rather than go into lengthy 
 descriptions here, let’s first see the code, and then I’ll offer comments.
 Listing 4-8.  PingPongDistance – Complete Class
 01 using UnityEngine;
 02 using System.Collections;
 03 //--------------------------------------------------------------
 04 public class PingPongDistance : MonoBehaviour
 05 {
 06     //Direction to move
 07     public Vector3 MoveDir = Vector3.zero;
 08
 09     //Speed to move - units per second
 10     public float Speed = 0.0f;
 11
 12     //Distance to travel in world units (before inverting direction and turning back)
 13     public float TravelDistance = 0.0f;
 14
 15     //Cached Transform
 16     private Transform ThisTransform = null;
 17
 18     //--------------------------------------------------------------
 19     // Use this for initialization
 20     IEnumerator Start ()
 21     {
 22             //Get cached transform
 23             ThisTransform = transform;
 24
 25             
 //Loop forever
 26             while(true)
 27             {
 28                    //Invert direction
 29                    MoveDir = MoveDir * -1;
 30
 31                    //Start movement
 32                    
 yield return StartCoroutine(Travel());
 33             }
 34     }
 35     //--------------------------------------------------------------
 36     //Travel full distance in direction, from current position
 37     IEnumerator Travel()
 38     {",NA
Exploring deltaTime,"Every game relies either directly or indirectly on the concept of time to get its work done. If objects 
 move
  or 
 animate
  or 
 change
 , then time is necessarily involved since every change must occur at a 
 specified moment and at a specified speed. For an object to 
 change
 , it must have been in a different 
 state at an earlier time; otherwise, no change could be said to have occurred 
 now
 . Thus, to represent 
 any kind of change in-game, a concept and measure of time is needed. Measuring time has been 
 problematic in games, however, historically speaking. Many older games measured time in terms of 
 frames, but this resulted in performance inconsistency across hardware, because different computers 
 could sustain different frame rates, and at different times. The result was that no two users on different 
 computers could be guaranteed the same experience, even if they started playing the same game at 
 the same time. So nowadays, many games measure time in a hardware-independent way, namely in 
 terms of seconds. And Unity offers many such time-measuring features through the 
 Time
  class.
 Note
  For more information on the 
 Time
  class, see the Unity documentation at  
 http://docs.unity3d.com/Documentation/ScriptReference/Time.html
 .
 An important member variable of the 
 Time
  class, which updates on each frame, is 
 deltaTime
 . In 
 mathematics and science, as well as video games, the term 
 delta
  typically means “change in” or 
 “difference.” Thus, deltaTime refers to 
 time difference
  or 
 change in time
 . Specifically, the variable 
 deltaTime
  expresses how much time (in seconds) has elapsed since the previous frame. For this 
 reason, because video games typically display many frames per second, this value will almost 
 always be a fractional value between 0 and 1, such as 0.03, or 0.5, or 0.111, and so forth. A value of 
 0.5 would mean that half a second has elapsed since the previous frame, and 1 would mean a whole 
 second, and 2 would mean 2 seconds, and so on. Normally, larger values such as 1, and 2, and 3 
 are indicative of lag and problems in your game, because the hardware is clearly unable to sustain 
 higher frame rates that would necessarily result in lower deltaTime values.
 Note
  For more information on deltaTime, see the Unity documentation at  
 http://docs.unity3d.com/Documentation/ScriptReference/Time-deltaTime.html
 .
 deltaTime is useful in Unity because it allows us to achieve frame-rate independence. Consider, for 
 example, a GameObject (such as a spaceship) that should travel in a straight line. Let’s say we want 
 to translate the spaceship on the X axis, over time, to produce movement. One way to implement 
 this behavior 
 without
  deltaTime would be as shown in Listing 4-9.
 Listing 4-9. Moving an Object Without deltaTime
 01 void Update()
 02 {
 03     //Update spaceship position on x axis each frame
 04     spaceship.position += new Vector3(5.0f,0,0);
 05 }",NA
Completing Power-Up Bobbing,"We’ve now seen deltaTime in action, for creating a sample case of a spaceship moving forward 
 along the X axis over time at a consistent speed. We’ve also seen in Listing 4-7 how deltaTime 
 can be applied to the 
 PingPongDistance
  class to create motion for power-ups. This means we can 
 now move further with the Cash Power-Up. So, back in the Unity Editor, just drag and drop the",NA
Power-Up Collision,"Things are looking good for the Cash Power-Up created so far. It exhibits Billboard functionality 
 using the 
 Billboard
  class, and also bobs gently up and down to accentuate its collectability, thanks 
 to the 
 PingPongDistance
  class. But all of these behaviors are essentially cosmetic features, and 
 none of them actually make the power-up collectible. To truly round-off and complete the power-up 
 object, we’ll want it to disappear from the level when collected by the player. And the player collects 
 the power-up simply by 
 walking through it
 . That is, by colliding with it. Therefore, to implement 
 power-up collection behavior, we’ll need to work with Physics Colliders, to detect when the Player 
 controller intersects the power-up bounding volume. So, before getting started at implementing this, 
 make sure Collider Visibility is enabled for the Scene viewport, allowing us to see colliders when we 
 create them. To do this, click the Gizmo button from the Scene toolbar and enable the 
 BoxCollider
  
 check box, if it’s not enabled already (see Figure 
 4-9
  to see how to do this).",NA
Handling Collision Events: Getting Started,"By using the Collider component of an object as a trigger volume, Unity can send all components on 
 an object an event call for each and every unique collision, allowing us to code custom responses 
 to the events when they happen. For Player collisions with the Cash Power-Up, we’ll want to do the 
 following: first, 
 increase the amount of cash collected
  in total for the Player; second, 
 play a collection 
 sound
 ; and third, 
 remove the power-up from the scene
  so the Player cannot collect it more than 
 once. To handle this behavior, we’ll code a new class that I’ll call 
 Powerup_Dollar
 . To implement this, 
 then, create a C# script file in the project named 
 Powerup_Dollar.cs
 . Be sure to add this script as a 
 component of the Cash Power-Up in the scene. A good start for this class might look like Listing 4-11.
 Listing 4-11. Powerup_Dollar.cs: Starting the Cash Power-Up Class
 01 //-------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //--------------------------------------------------------------
 05 public class Powerup_Dollar : MonoBehaviour
 06 {
 07     //Amount of cash to give player
 08     public float 
 CashAmount
  = 100.0f;
 09
 10     //Audio Clip for this object
 11     public AudioClip 
 Clip
  = null;
 12
 13     //Audio Source for sound playback
 14     private AudioSource 
 SFX
  = null;
 15     //--------------------------------------------------------------
 16 }
  
 �
 Lines 07-14.
  The Cash Power-Up declares three variables, of which one is 
 private. 
 CashAmount
  is a float expressing how much cash should be awarded to 
 the player when the power-up is collected. This allows us to specify different 
 values for each power-up, if we need to. The 
 Clip
  variable will specify which 
 audio file to play when the power-up is collected. In Chapter 2, audio assets 
 were imported into the project, and for this power-up I’ll be using the audio 
 file 
 powerup_collect.wav
 . This file is included in the book companion files, but 
 you can use any audio file you want. Finally, the 
 SFX
  variable refers to an 
 Audio 
 Source component
 , the component to play the 
 Clip
  audio file. This component 
 acts like a media player.",NA
Collisions and Responses,"Let’s move further with the 
 Powerup_Dollar
  class to handle collision events. For Unity game objects 
 with 
 Trigger
  components, the 
 OnTriggerEnter
  event is fired for the object when either a 
 RigidBody
  
 object or another 
 collider
 , such as the Player character, moves inside the trigger area (or volume). 
 The extents of the trigger are defined by the BoxCollider. There is also a partner 
 OnTriggerExit
  event, 
 which is invoked when the collider 
 leaves
  the trigger volume. However, in this book, we’ll only need to 
 deal with 
 OnTriggerEnter
 . Listing 4-12 shows the almost complete 
 Powerup_Dollar
  class (which can 
 be found in the chapter companion files in 
 Chapter04/AssetsToImport/
 ); comments follow.
 Listing 4-12. Moving Forward with Powerup_Dollar.cs
 01 //-------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //--------------------------------------------------------------
 05 public class Powerup_Dollar : MonoBehaviour
 06 {
 07     //Amount of cash to give player
 08     public float CashAmount = 100.0f;
 09
 10     //Audio Clip for this object
 11     public AudioClip Clip = null;
 12
 13     //Audio Source for sound playback
 14     private AudioSource SFX = null;
 15     //--------------------------------------------------------------
 16     void Start()
 17     {
 18             //Find sound object in scene
 19             GameObject SoundsObject = 
 GameObject.FindGameObjectWithTag(""sounds"");
 20
 21             //If no sound object, then exit
 22             if(SoundsObject == null) return;
 23
 24             //Get audio source component for sfx
 25             SFX = SoundsObject.GetComponent<AudioSource>();
 26     }
 27     //--------------------------------------------------------------
 28     //Event triggered when colliding with player
 29     
 void OnTriggerEnter(Collider Other)
 30     {
 31             //Is colliding object a player? Cannot collide with enemies
 32             
 if(!Other.CompareTag(""player"")) return;
 33
 34             //Play collection sound, if audio source is available
 35             if(SFX){SFX.PlayOneShot(Clip, 1.0f);}
 36
 37             //Hide object from level so it cannot be collected more than once
 38             
 gameObject.SetActive(false);
 39",NA
Introducing the GameManager,"The 
 Powerup_Dollar
  class implements the event 
 OnTriggerEnter
  to respond to player collisions. This 
 program structure and functionality works well insofar as it goes, but it really doesn’t go far enough. 
 While it’s useful for the 
 Powerup_Dollar
  class to respond to collision events as it does, there may 
 potentially be other classes that’ll want to respond to and handle power-up collection. Perhaps, 
 right now, we cannot conceive clearly of what those classes might be and how they might work 
 exactly, but it’d be a good idea to structure our code now so that in the future, any other class has, 
 at least, the potential and opportunity to respond directly to power-up collection events, should 
 they need to. Thankfully, we already have the beginnings of a solution to this problem through the 
 NotificationsManager
  class, created in the previous chapter. This class allows an event-receiver, 
 such as 
 Powerup_Dollar
 , to post event notifications to the NotificationsManager, which then relays 
 all notifications to all registered listener objects by way of function calls.
 However, an important consideration arises here. Our CMOD project doesn’t yet have any valid 
 instance of the NotificationsManager attached to an object in the scene. This means our project has 
 no valid instance of NotificationsManager to receive or broadcast events, even though the script file 
 is in our Project panel. I’ve deliberately put off discussing NotificationsManager instantiation until 
 now. This is because the NotificationsManager is a managerial, overarching class that applies not to 
 any one 
 particular instance
  of an object, but to all objects generally throughout the game. It needs 
 to receive and post event notifications between potentially 
 all
  objects in scene and a game. This 
 general and overarching quality is also likely to be shared by a range of other managerial classes. 
 One particular class is the 
 GameManager
 .
 The 
 GameManger
  is a special class in the sense that it’s the highest level class in a game. If we want 
 to restart or quit the game, then we’ll need a GameManager. If we want to save or load game states, 
 we’ll need a GameManager. And if we want an instance of NotificationsManager for handling events 
 throughout a game, then it’ll be a member instance of GameManager. In short, any high-level,  
 game-wide functionality that we’ll need should be implemented in GameManager. It’s effectively 
 the “boss” of our game’s logic. Given this, then, we’ll now start to implement GameManager, and in 
 doing this we’ll be able to handle game-wide events with NotificationsManager. So let’s get started 
 by creating a new C# script file 
 GameManager.cs
 .",NA
GameManager and Singletons,"The 
 GameManager
  is a general, managerial and overarching class of special significance in practically 
 every game. It has the single duty of representing and coordinating all high-level functionality, 
 including game restarts, game exits, load-and-save states, game pauses, and more. It’s notable 
 here, too, that I’ve referred to GameManager in terms of “the GameManager
 ”
  (singular)—as in the 
 one and only
  GameManager—as opposed to “a GameManager
 ”
  (where the possibility of 
 multiple
  
 instances is admitted). This is for good reason because, in general, we’ll 
 never need
  more than 
 one instance of GameManager throughout the duration of gameplay. The gamer can only play 
 one instance
  of our game at any time, and that active instance is represented entirely by a single 
 GameManager
 ,
  which is created at game-start and is terminated at game-end
 .
 Allowing for multiple GameManager instances would be confusing and game-breaking, since 
 multiple instances would necessarily conflict and fight for controlling the same game. Therefore, we 
 can safely establish here that not only will we never need more than one GameManager instance 
 at any one time, but there’s also good reason to create the class so that multiple instantiations of it 
 are not possible. This will be especially useful if other programmers should work on our code. This 
 kind of object, where only one instance can be made, is known as a Singleton. Classes designed 
 to produce Singleton objects are said to use the 
 Singleton design pattern
 . Thus, our 
 GameManager
  
 object should be a Singleton. But how can we create such an object?
 There are multiple solutions or methods for creating Singletons. The method illustrated here will be 
 through 
 static members
 . Let’s see this process, step by step (see Listing 4-13).
 Listing 4-13. Starting the Singleton Class
 01 //--------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //--------------------------------------------------------------
 05 public class GameManager : MonoBehaviour
 06 {
 07     //Internal reference to single active instance of object - for singleton behaviour
 08     
 private static GameManager instance = null;
 09 }
  
 Start by adding a 
 private static
  member of type 
 GameManager
  (line 08 in Listing 4-13). Being static, 
 the value of this member 
 would
  be shared across 
 all
  instances of 
 GameManager
 . This variable will be 
 null
  if there’s no valid instance of 
 GameManager
  active in the scene; otherwise, it’ll be a reference to a 
 previously declared instance of 
 GameManager
 . Next, see Listing 4-14.
 Listing 4-14. Expanding on the Singleton Class
 01 //--------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //--------------------------------------------------------------
 05 public class GameManager : MonoBehaviour
 06 {
 07     //--------------------------------------------------------------
 08     //C# property to retrieve currently active instance of object, if any",NA
GameManager and Event Handling,"GameManager
 ,
  right now, doesn’t implement any high-level functionality, such as Save-Game 
 and Restart-Game. It will do so later in this book. But for now, it just acts a Singleton, and that’s 
 fine. Often, while developing high-level classes like Game Managers and Notification Managers, 
 it’ll be necessary to jump back and forth between many classes, developing some parts sooner 
 and some later. This is normal and is usually required—and need not be any cause for concern or 
 the result of bad planning. Many classes implemented so far, such as the 
 NotificationsManager
  
 and 
 PingPongDistance
  were sufficiently generic and “low-level” that they never depended on other 
 classes and implementations to achieve their own functionality. But we don’t have that luxury with 
 the GameManager. It’ll have to be an ongoing project throughout CMOD development. One feature, 
 however, that we should implement right away into GameManager because it affects most other 
 classes, is event-handling functionality. Most classes will need to post or receive events, and they’ll 
 do this via GameManager; let’s see how in Listing 4-16. This code contains three major additions 
 that make use of the NotificationsManager; comments follow.
 Listing 4-16. Integration NotificationsManager into GameManager
 01 //--------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 
 [RequireComponent (typeof (NotificationsManager))]
  //Component for sending and receiving  
    notifications
 05 //--------------------------------------------------------------
 06 public class GameManager : MonoBehaviour
 07 {
 08     //--------------------------------------------------------------
 09     //C# property to retrieve currently active instance of object, if any
 10     public static GameManager Instance
 11     {
 12             get
 13             {
 14                    if (instance == null) instance = new GameObject (""GameManager""). 
                       AddComponent<GameManager>(); //create game manager object if required
 15                    return instance;
 16             }
 17     }
 18     //--------------------------------------------------------------
 19     //C# property to retrieve notifications manager
 20     
 public static NotificationsManager Notifications
 21     {
 22             get
 23             {
 Note
  For more information on 
 AddComponent
 , see the online Unity documentation at  
 http://docs.unity3d.com/Documentation/ScriptReference/GameObject.AddComponent.html
 .",NA
Completing the Cash Power-Up,"Back in Listing 4-12, we coded a Cash Power-Up object to respond directly to an 
 OnTriggerEnter
  event, 
 to handle player collisions. However, we also need this event to integrate with NotificationsManager 
 to notify all listener objects, in case they, too, need to respond when it happens. In other words, 
 the event 
 OnTriggerEnter
  of 
 Powerup_Dollar
  needs to be amended to post a notification to the 
 NotificationsManager. In this context, the NotificationsManager is accessible as a static member 
 variable of the globally accessible GameManager singleton. Consider the completed 
 Powerup_Dollar
  
 class in Listing 4-17, which posts an event notification.
 Listing 4-17. Completed Cash Power-Up
 01 //-------------------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //--------------------------------------------------------------
 05 public class Powerup_Dollar : MonoBehaviour
 06 {
 07     //Amount of cash to give player
 08     public float CashAmount = 100.0f;
 09
 10     //Audio Clip for this object
 11     public AudioClip Clip = null;
 12
 13     //Audio Source for sound playback
 14     private AudioSource SFX = null;
 15     //--------------------------------------------------------------
 16     void Start()
 17     {
 18             //Find sound object in scene
 19             GameObject SoundsObject = GameObject.FindGameObjectWithTag(""sounds"");
 20
 21             //If no sound object, then exit
 22             if(SoundsObject == null) return;
 23
 24             //Get audio source component for sfx
 25             SFX = SoundsObject.GetComponent<AudioSource>();
 26     }
 27     //--------------------------------------------------------------
 28     //Event triggered when colliding with player",NA
Making a Prefab from the Completed Power-Up,"The Cash Power-Up in the scene is now completed in terms of code and GameObject component 
 structure (see Figure 
 4-13
 ). The final code for the power-up is given in Listing 4-17. However, at 
 this stage of development, we have only 
 one
  power-up object, whereas our scene and the game 
 design requires us to have more. We could add further Cash Power-Ups in the 
 existing
  scene 
 by simple object duplication (
 Ctrl+D
 ), but these power-ups should also appear in 
 other
  scenes, 
 and perhaps other 
 games
 . To achieve this, then, the Power-Up should be turned into a Prefab for 
 infinite reusability.",NA
Creating Other Prefabs,"CMOD features not just Cash Power-Ups, which we’ve created in this chapter, but also ammo-restore, 
 health-restore, and weapon-upgrade power-ups. Despite the differences in these power-ups, however, 
 they share the same basic mechanic. They are Billboard sprites with colliders that respond directly to 
 player collisions, interacting with the NotificationsManager on a GameManager singleton. The chief 
 difference between them rests not in their mechanics, but in their responses to collisions. The Cash 
 Power-Up increases Player cash, while health-restore affects Player health, and weapon-upgrade 
 changes the Player weapon, and so on. Their differences rest in what they actually 
 do
  when a Player 
 collision occurs, but not in how collisions are fundamentally detected and handled.",NA
Conclusion,"This chapter was primarily dedicated to creating a Cash Power-Up object, and in so doing, we’ve 
 seen a lot of critical C# and scripting concepts. There’s a lot more work going on with our power-
 ups than there might seem at first glance. Once you open them and explore their innards, we see 
 they rely on physics, colliders, events, singletons, deltaTime, coroutines, and a host of other Unity 
 conventions. Having reached this far, however, we’re now in a strong position to begin development 
 of the Player character. This is considered in the next chapter. At this stage, you should be able to do 
 the following:
 Create C#-based power-ups for your own projects
 �
 Understand what Billboards are and how they work
 �
 Understand coroutines and yield statements
 �
 Use deltaTime to create frame-rate independent motion and animation
 �
 Apply basic vector arithmetic and quaternion rotation
 �
 Use the Unity Time class
 �
 Understand the Singleton design pattern
 �
 Create Singleton objects using static members
 �
 Understand how the Unity RequiresComponent works
 �
 Integrate NotificationsManager into your own games via Singletons
 �
 �
 Make Prefabs for your scenes",NA
Chapter,NA,NA
 5,NA,NA
Player Controller,"FPS games (first-person shooter games) are played, unsurprisingly, from a 
 first-person perspective
 . 
 This means that game events, and the game world, are seen through the eyes of the main game 
 character—as though 
 you
  were that person in that world. This perspective is perhaps one of the 
 most common kinds in contemporary video games. It’s used in some of the famous and biggest 
 selling games in history, including 
 Call of Duty
 , 
 Halo
 , 
 Skyrim
 , and others. CMOD too will be an FPS 
 game. Consequently, we’ll need first-person behavior. Thankfully, lots of the underpinning coding 
 work for this is created for us, from the standard Unity Character Controller packages (specifically 
 the 
 First Person Controller
 ). However, this package features important limitations that we’ll want 
 to overcome for CMOD. Throughout this chapter, we’ll examine the First Person Controller further, 
 refining and adapting it by creating our own customized 
 PlayerController
  class with first-person 
 functionality and more besides.",NA
Character Controllers and the First Person Controller,"The ready-made First Person Controller that ships with Unity is included in the 
 Character Controllers
  
 asset package, which can be imported into any project by selecting 
 Assets 
 ➤
  
 Import Package 
 ➤
  
 Character Controller
  from the application main menu. This package is included in both the Free 
 and Pro versions of Unity (see Figure 
 5-1
 ).",NA
Multiplatform Development,"To get started creating a cross-platform (universal) First Person Controller, let’s examine platform 
 support in Unity and the general cross-platform workflow for games. Unity 
 can
  build for many 
 platforms, including Windows, OS X, iOS, Android, Windows Phone, and more. The word 
 can
  is 
 important here, because despite the platforms officially 
 supported
  by Unity, 
 deploying
  to them 
 actually involves additional considerations and issues 
 for you
  as a developer. Not just technical 
 considerations about optimization and tweaking, but also economical and logistic considerations. 
 For example, to build and deploy to iOS devices, you’ll need an 
 Apple Developer License
 , as well as 
 a 
 Mac
  computer—you can’t build for iOS devices on a Windows PC, even with Unity Pro! Similarly, 
 to develop for Android, you’ll need to download and install the freely available 
 Android SDK
 , whether 
 you’re developing on Windows or Mac. Without these requisites, you won’t be able to develop and 
 properly test mobile applications—so it’s important to be aware of them.
 More information on developing for iOS can be found in the Unity official documentation at  
 http://docs.unity3d.com/Documentation/Manual/iphone-GettingStarted.html
 .
 More information on developing for Android can be found at  
 https://docs.unity3d.com/Documentation/Manual/android-GettingStarted.html
 .
 Once you’re configured and set to go for mobile development, you can start testing your game for 
 your chosen platform in Unity via the 
 Build Settings
  dialog. By choosing 
 File 
 ➤
  
 Build Settings… 
 from the application menu, you’ll display the Build settings. From here, you select your platform of 
 choice, and choose 
 Switch Platform
 . Doing this forces Unity to apply all relevant platform settings 
 to your project. Consequently, the next time you hit Play on the Unity toolbar, your game behaves as 
 though it were running on the chosen mobile device (see Figure 
 5-3
 ). With mobile apps such as 
 Unity 
 Remote
  installed on your device, you can also 
 control
  your game using a mobile device, such as a 
 tablet or phone.",NA
Beginning the Universal First Person Controller,"Unity ships with two First Person Controller prefabs, the default First Person Controller included in 
 the Standard Assets (Character Controller) package, and the mobile First Person Controller, included 
 in the Standard Assets (Mobile) package. The crucial difference between these two controllers is 
 their handling of user input. The desktop controller expects user input from keyboards and mice 
 exclusively, and the mobile controller from mobile devices exclusively; and neither accepts input 
 from the other method. Our aim here, therefore, is to forge a bridge between these two controllers, 
 resulting in a new controller prefab that automatically handles input from any device, desktop 
 or mobile. Before getting started, be sure to import both the desktop and mobile First Person 
 Controllers into your project, if they’re not imported already (see Figure 
 5-5
 ).
 Figure 5-4.
  Per-platform texture settings",NA
Platform Dependent Compilation,"The desktop and mobile controllers are now added and configured successfully in the scene. If you 
 run the game now, however, both controllers will be active and operational—working simultaneously: 
 desktop input controlling the desktop controller, and mobile input controlling the mobile controller. 
 That’s not what we want. The aim now is to code a C# script to deactivate the redundant controller 
 at scene start-up, leaving us with the relevant controller, based on the target platform. This can be 
 achieved using a Unity C# feature known as 
 Platform Dependent Compilation
 . To see this in action, 
 create a new C# script file, 
 ControlSwitcher.cs
 , and attach this as a component to the 
 Controls
  
 GameObject, created in the previous section (see Figure 
 5-10
 ). Then take a look at Listing 5-1 for 
 ControlSwitcher.cs
 , after which comments follow.
 Figure 5-10.
  Attaching a ControlSwitcher script to the Controls object. This script will deactivate the redundant First Person 
 Controller on scene start-up
 Listing 5-1. ControlSwitcher.cs: Deactivates Redundant First Person Controller
 01 //------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 //------------------------------------------------
 05 public class ControlSwitcher : MonoBehaviour
 06 {
 07      //------------------------------------------------
 08      //Reference to desktop first person controller (default)
 09      public GameObject DesktopFirstPerson = null;
 10
 11      //Reference to mobile first person controller
 12      public GameObject MobileFirstPerson = null;
 13
 14      //------------------------------------------------
 15      //Select appropriate first person control for platform",NA
Head Bobbing and Sine Waves,"Whenever the First Person Controller walks forward or backward, we want the camera to bob or 
 oscillate up and down smoothly in the Y axis. This is to simulate the involuntary head movement that 
 occurs naturally whenever most bipeds, like humans, move using their legs. We could, of course, 
 implement this behavior by resorting to the familiar bobbing motion technique created for the Cash 
 Power-Up in the previous chapter. But this motion was decidedly 
 linear
  and 
 mechanical
 . That is,",NA
First-Person Capsule Mesh,"Next, let’s get to work on creating a general 
 PlayerController.cs
  class for handling most high-level 
 player functionality. The first issue to address with this class concerns the player controllers. Both 
 the desktop and mobile First Person Controllers feature a renderable capsule mesh, which is both 
 visible in the Unity Editor 
 and
  at runtime. Normally, the capsule mesh is 
 not
  visible during gameplay, 
 but this is only because the controller camera is positioned in a specific way. In theory, the capsule 
 could
  be seen if reflective materials were used in the scene or if the camera were offset through 
 animation (and it will be later). There’s nothing either in principle or practice to prevent the capsule 
 mesh from being seen, and normally we don’t want it to be seen. So let’s hide it at runtime using 
 a C# script, as opposed to disabling it in the editor. This lets us continue seeing the capsule mesh 
 in the editor at design time. To get started, create a 
 PlayerController.cs
  file. This will be added 
 to each First Person Controller object—attached to the same object as the HeadBob script—the 
 object marked with the 
 player
  tag (see Figure 
 5-13
 ). This is important for later because this script 
 will also handle Player collision events with power-ups: specifically, cash allocation (see Listing 5-3; 
 comments follow).
 Figure 5-13.
  Adding the PlayerController script to First Person Controller objects
 Listing 5-3. PlayerController.cs: Disabling Capsule Meshes for First Person Controllers
 01 //------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 using System.Collections.Generic;
 05 //------------------------------------------------
 06 public class PlayerController : MonoBehaviour
 07 {
 08      //------------------------------------------------",NA
Handling Cash Collection,"Before proceeding, jump back to the previous chapter and consider Listing 4-11, especially lines 
 41 and 44. This sample implements the Cash Power-Up 
 OnTriggerEnter
  event, which is called 
 each and every time the Player collides with the power-up in the scene. Lines 41 and 44 retrieve a 
 PlayerController component, attached to the 
 Player
  GameObject, and increases its 
 Cash
  member. In 
 other words, the PlayerController needs to implement a 
 Cash
  variable to maintain its collected cash, 
 and this member should be increased for each Cash Power-Up collected. The Cash member should 
 be implemented as a 
 property
 , and not a public variable. Doing this is consistent with the event-
 handling functionality coded in Chapter 3, because properties allow us to 
 validate
  the assignment 
 of values to variables, giving us the opportunities to call functions and invoke event notifications. 
 For cash collection, we’ll need to verify whether the 
 collected cash
  exceeds or meets the 
 total cash
  
 available in the level. Remember, when the Player collects all available cash, the level is completed! 
 The 
 PlayerController
  class can be amended to support cash collection using the code in Listing 5-4.",NA
Life and Death: Getting Started,"Historically and philosophically, there’s much of interest to be said about the way video games 
 implement life and death. Here, CMOD uses the “traditional” approach where Player life or health 
 is expressed quantitatively as an integer between 0–100; 0 is death and 100 is full health. Similarly, 
 in keeping with retro side-scrollers where you can attack a phone booth and get a health-restoring 
 turkey out of it, CMOD allows you to pick up floating, restorative hamburger power-ups to restore 
 health. These tasty burgers have the power-up to heal bullet wounds and punch attacks. Death, 
 however, comes upon the Player when health reaches 0 or below; and this typically happens 
 because of enemy attacks. Here again, CMOD takes the traditional approach to death: when 
 death arrives, the scene is restarted and the Player respawns back to the level origin, allowing 
 a resurrection 
 ad infinitum
 . So let’s start implementing these concepts now, starting with a 
 consideration of death.
 When the Player dies, I’d like to play a small death-sequence before restarting the level in the form 
 of a camera animation. Specifically, the camera should roll over and fall to the ground. This simple 
 transformation-style animation can be recorded using the Unity Animation Editor, through  
 Window 
 ➤
  Animation
 . This editor works through key framing (see Figure 
 5-15
 ). There I’ve defined 
 two key frames for rotation and position, defining the motion for the camera as it falls to the ground. 
 I’m going to apply the animation to a newly created empty game object, 
 AnimatedCamera
 , which has 
 been parented to the First Person Controller camera (as we’ll see shortly), to keep the translation and 
 rotation 
 separate
  from the camera transformations themselves. When the animation is saved from 
 the editor, it’s added automatically as an animation clip asset in the Project panel. I’ve named the 
 asset 
 CameraDeath
 .
 Figure 5-15.
  Creating a basic camera fall animation using the Legacy Animation Editor",NA
Making Death: Scripting with Mecanim,"Together, the animation clip and the Animation Controller define the animation key frames and 
 general playback logic. But still, the act of triggering and playing the animation when death occurs 
 needs to be coded. This will be achieved by amending the 
 PlayerController.cs
  script (see Listing 
 5-5 for further PlayerController refines, followed by comments).
 Listing 5-5. Refining PlayerController for a Death Animation
 01 //------------------------------------------------
 02 using UnityEngine;
 03 using System.Collections;
 04 using System.Collections.Generic;
 05 //------------------------------------------------
 06 public class PlayerController : MonoBehaviour
 07 {
 08      //------------------------------------------------
 09      //Amount of cash player should collect to complete level
 10      public float CashTotal = 1400.0f;
 11",NA
Implementing Health,"The Player needs a health feature to keep track of his lifeline in-game. This feature is also important 
 for determining whether a death and respawn are required. Take a look at Listing 5-6 to see how 
 PlayerController is refined to implement health and death in full. Relevant changes are highlighted 
 in bold. Then, in subsequent sections, we’ll explore the code deeper to see how it works more 
 thoroughly. The full 
 PlayerController.cs
  file is included in the chapter companion files.
 Listing 5-6. PlayerController, Life and Death
 001 //------------------------------------------------
 002 using UnityEngine;
 003 using System.Collections;
 004 using System.Collections.Generic;
 005 //------------------------------------------------",NA
Health and Damage: Procedural Textures,"Listing 5-6 implemented the bulk of the 
 PlayerController
  class. This class features a health value, 
 defined as private integer member 
 health
  (line 22). Access to this value is controlled through the 
 public 
 Health
  property, which validates the health value each time it’s updated or changed. When 
 (and if) it reaches 0 or below, the Player death functionality is executed, as shown in line 87. Notice, 
 however, that additional functions and variables were added to PlayerController, besides simply 
 a 
 Health
  property. Of special significance is the 
 ApplyDamage
  coroutine, which can be called to 
 damage the Player. Damage in this sense might seem merely a matter of just reducing Player health, 
 but typically we want to do more. When the Player is damaged, we may want to play a sound and 
 flash the screen red to offer graphical feedback that damage has been taken. These effects are not 
 essential, but they emphasize a point to the gamer that something bad happened. The 
 ApplyDamage
  
 coroutine achieves this effect by fading a red texture into view. Let’s examine further exactly how it 
 does this (see Listing 5-7, which is an extract from Listing 5-6).",NA
GUIs,"The previous section demonstrated how fill textures can be generated procedurally. This section 
 explores how we can show textures on-screen quickly using the native GUI functionality. The Unity 
 GUI classes are designed to display GUI elements in screen space. And we can use them here to fill 
 a red texture across the screen. This happens in the native event 
 OnGUI
  (see Listing 5-8, which is an 
 extract of Listing 5-6).",NA
Conclusion,"So, reaching this far, we’ve created a working and flexible 
 PlayerController
  class offering universal 
 first-person functionality that works on both desktop and mobile devices, and can also collect 
 power-ups whenever it intersects them in the scene. Further, the controller implements health and 
 death functionality. By now, you should be able to do the following:
 Create a universal First Person Controller
 �
 Understand Platform Dependent Compilation
 �
 Understand sine waves and smooth motion
 �
 Create a head-bob animation for a camera
 �
 Integrate the PlayerController into the event and notification system
 �
 Handle collision events
 �
 Maintain collected cash
 �
 Generate procedural textures
 �
 Understand the limitations of GUIs and OnGUI
 �
 Use Mecanim and the Animator to define the logic for animations
 �
 �
 Maintain Player health",NA
Chapter,NA,NA
 6,NA,NA
Weapons,"Let’s quickly recap what we’ve done so far in CMOD. At this stage, we’ve created a complete 
 game environment with rooms and corridors, collectable power-up objects for health restore and 
 cash bonuses, a notifications manager class to send and dispatch events to game objects, and 
 a universal player controller for desktops and mobiles, including first-person functionality with a 
 complementary head bob. In this chapter, we’ll build on this existing work by adding weapons for 
 the Player character—specifically, a short-range fists/punch weapon (the default weapon) and a 
 long-range gun weapon, which can be collected through a weapons power-up. The purpose of these 
 weapons is to damage Enemy characters. Of course, 
 right now
 , we haven’t created any enemies for 
 CMOD—they’ll be coded in the 
 next
  chapter. But here we’ll at least make a start with weapons.  
 In creating these, a wide range of Unity and C# concepts will be explored in depth; specifically, sprite 
 and object animation, physics and rays, 
 object orientation
 , 
 class inheritance
  and 
 polymorphism
 .  
 So let’s get started . . .",NA
Weapons Overview,"CMOD features a total of two weapons that can be used by the Player character; though only one 
 weapon may be active and in use at any one time. These weapons are 
 fists that punch
  (as shown in 
 Figure 
 6-1
 ) and a 
 gun
  (as shown in Figure 
 6-2
 ). These weapons are considered in more detail next.
 Figure 6-1.
  The default fists/punch weapon",NA
Object Orientation: Classes and Instances,"This book assumes you’re already familiar with the basics of C# and coding in Unity. Part of that 
 fundamental knowledge includes a general understanding of objects and object orientation. Indeed, 
 we’ve already made extensive use of these concepts in creating many classes over previous 
 chapters, such as classes for events, power-ups, and player controllers. But before proceeding 
 further, let’s revisit object orientation to reinforce our understanding. Object orientation will be critical 
 for our work with weapons.",NA
Object Orientation: Inheritance,"CMOD supports two weapon types, as we’ve seen. This immediately suggests that we need to 
 create two separate C# classes: one for the fists/punch (
 Weapon_Punch.cs
 ) and another for the 
 gun (
 Weapon_Gun.cs
 ). This is correct, but a problem introduces itself regarding code and feature 
 duplication. The problem is that although the fist and gun weapons are separate and distinct objects, 
 there are still many similarities between the weapon types. Specifically, both are 
 weapons
 , both deal 
 a specified amount of 
 damage
  to enemies, both have a 
 recovery rate
  (the amount of time that should 
 elapse before the weapon can be reused after being fired), and both have a range (the distance from 
 the enemy at which the weapon is effective). These are numerous and significant features held 
 in 
 common
 , and not just across the two weapons we’re creating for CMOD in 
 this
  book, but across 
 almost 
 all
  weapons imaginable. We could, of course, disregard these similarities entirely and simply 
 jump into implementing our weapons straightaway, coding these properties 
 for each
  weapon. This 
 approach, however, is inefficient because it means we’re adding the 
 same
  kinds of properties to two 
 separate
  classes. We’re unnecessarily duplicating our workload and increasing the size of our code. 
 Instead, we can solve this problem using 
 class inheritance
  to develop a 
 base class
  for all weapons.
 Whenever we identify two separate classes—
 X
  and 
 Y
 —that share lots of behavior and functionality 
 in common, we’ve usually found good candidates for inheritance. Class inheritance allows you to 
 create a third class, 
 Z
 , known as a 
 base class
 , which defines all behaviors common to X and Y. 
 The classes X and Y (
 subclasses
 ) can then 
 inherit
  that functionality from the 
 base class
  Z, to save 
 you having to code it twice, once for X and again for Y. Base class Z is therefore a distillation of all 
 commonalities between X and Y. It’s not a class intended to be instantiated 
 on its own
 . Its purpose 
 is to be 
 inherited
  by other classes that wish to 
 reuse
  and recycle its behavior as though it were their 
 own. This kind of class is more formally known as an 
 abstract base class
 . So, let’s start coding  
 the Player weapons here, with the base class (see Listing 6-1, which demonstrates a base class 
 Weapon.cs
 ; comments follow).",NA
"Animations, Frames, and Prefabs","Before moving further, refining the derived gun classes to implement extended and specialized 
 functionality for each weapon, we’ll take a detour into animation. This might initially seem a misplaced 
 detour. But animation will play an important role for our two weapon classes, because both must 
 display a fire or attack animation each time the weapon is used. Consider Figures 
 6-1
  and 
 6-2
 , 
 which show not only each weapon, but also the frames of animation that should play when fired. 
 When the gamer presses the Fire button, we’ll want the active weapon to cycle through its frames of 
 animation, returning back to the original, neutral frame when completed. To achieve this, a new class 
 must be coded. Specifically, this class will accept an array of sprite objects in the scene (each sprite 
 representing a 
 single frame
  in an animation sequence) and it will hide and show all related sprites 
 (frames) in sequence to play back the complete animation, frame by frame. Take a look at the class in 
 Listing 6-4, called 
 SpriteShowAnimator.cs
 . Comments follow.
 Listing 6-4. SpriteShowAnimator.cs: Class to Display a Sprite Animation
 01 //This class maintains a collection of sprite objects as frames of animation
 02 //It shows and hides those frames according to a set of playback settings
 03 //--------------------------------------------------------------
 04 using UnityEngine;
 05 using System.Collections;
 06 //--------------------------------------------------------------
 07 public class SpriteShowAnimator : MonoBehaviour
 08 {
 09         //--------------------------------------------------------------
 10         //Playback types - run once or loop forever
 11         public enum ANIMATOR_PLAYBACK_TYPE {PLAYONCE = 0, PLAYLOOP = 1};
 12
 13         //Playback type for this animation
 14         public ANIMATOR_PLAYBACK_TYPE PlaybackType = ANIMATOR_PLAYBACK_TYPE.PLAYONCE;
 15
 16         //Frames per second to play for this animation
 17         
 public int FPS = 5;
 18
 19         //Custom ID for animation - used with function PlaySpriteAnimation
 20         public int AnimationID = 0;
 21
 22         //Frames of animation
 23         
 public SpriteRenderer[] Sprites = null;
 24
 25         //Should auto-play?
 26         public bool AutoPlay = false;
 27
 28         //Should first hide all sprite renderers on playback? or leave at defaults
 29         public bool HideSpritesOnStart = true;
 30
 31         //Boolean indicating whether animation is currently playing
 32         bool IsPlaying = false;",NA
Cameras: Layers and Rendering,"If you take a look at Figures 
 6-3
  and 
 6-4
 , you’ll likely see a potential problem emerging for the Player 
 weapons. Specifically, the Player weapons (whether a fists/punch or a gun) should (1) always appear 
 at the screen middle-bottom, and (2) appear at a consistent and believable size (see Figure 
 6-5
  
 for an example). Right now, Figures 
 6-3
  and 
 6-4
  show just how large the weapon sprites appear in 
 relation to the scene. And if the scene is played right now, the weapons are not appropriately aligned 
 on the screen either. Let’s address the second problem first.",NA
Cameras: Orthographic Size,"Perhaps the most common question I’m asked about 2D development in Unity is, “How can I make 
 a sprite appear on-screen at its true pixel size, minus all perspective distortion?” This question is, 
 in essence, about 
 pixel perfection
 . Perhaps you’ve created an image in Photoshop or GIMP, and 
 you want it to display in an orthographic camera at exactly the same size as the image file—pixel 
 for pixel. This section explores this issue as we scale and size the punch weapon to fit the weapon 
 camera. In short, the ultimate render size of an orthographic camera is controlled using the Size 
 member—although this member works in conjunction with other settings, as we’ll see. This member 
 determines how 
 world units
  relate to 
 pixels
  (see Figure 
 6-13
 ).
 Figure 6-13.
  The size member of orthographic cameras controls the size of graphical elements on-screen
 The main question for a developer interested in achieving pixel perfection from orthographic 
 cameras is, “What value should 
 size
  be for an orthographic camera?” To achieve a 1:1 ratio between 
 world units and pixels, the 
 size
  value should be 
 half the vertical height of the game window in pixels
  
 (That is: 
 Size = pxHeight/2
 ). Thus, for games with a resolution of 1024×768, a size value of 384 
 (768/2) is correct. This seems simple enough: but give it a try for CMOD.
 There’s a problem. Even if we set the camera size to 384 and the resolution to 1024×768 from the 
 Game tab, the weapon sprite appears too small—it’s barely visible. We know something is wrong 
 because the game texture size is 4096×4096 pixels, and the punch weapon within that texture has 
 been explicitly sized for a 1920×1080 HD display. This means, the weapon should appear much larger 
 than it does with a camera setting of 384, where 1 unit should equate to 1 pixel (see Figure 
 6-14
 ).  
 So what’s wrong?",NA
Weapon Implementation: Punching,"Let’s now return to the specific implementation of the punch weapon (
 Weapon_Punch.cs
 ), which 
 we started coding earlier in the chapter, in Listing 6-2. Now that we’ve coded a sprite animation 
 component, as well as configured the weapon sprites to render correctly for an orthographic 
 camera, we can make progress. Sometimes, like here, it’s helpful to develop multiple classes in 
 parallel, jumping back and forth, testing their interoperability. Take care when doing this, however, as 
 interoperability between classes can lead to 
 dependency injection
 . In other words, it can lead you to 
 create inhibiting and unnecessary dependences between classes, leaving your code scattered across 
 multiple source files, so that it’s difficult to ever change one of the classes in isolation. When that 
 happens, changing the implementation of one class has implications for the other dependencies, and 
 so on. This can cause a nightmare of spaghetti logic. Try, 
 wherever possible
 , to make your classes as",NA
Physics and Damage Dealing,"In Listing 6-5, the 
 Weapon
  class (
 Weapon_Punch.cs
 ) responded to gamer input and applies damage to 
 enemies within range of an attack whenever an attack is launched. The specific details of detecting 
 whether an Enemy is hit is handled using the physics system, and covers lines 62–82. These are 
 reproduced in Listing 6-6 and warrant further discussion.",NA
Weapon Changing and Polymorphism,"As soon as the Player collects more than one weapon, he’ll want the ability to change or cycle 
 between them on demand. Doing this requires some coding changes both to the weapon 
 classes and to the 
 PlayerController
  class, and we’ll see an Object Orientation feature, known 
 as 
 polymorphism
 , at work. The PlayerController will need to maintain a list of collected weapons 
 and make only one of them active for the Player at any one time. The weapons too will need to 
 be notified when they have become the active weapon and when deactivated. Before proceeding 
 further, however, this section assumes you have both a fists/punch and a gun weapon configured, 
 with their sprites set up to render in an orthographic camera (see Figure 
 6-18
  for the GameObject 
 setup that I’m using). Remember, you can always load up the 
 Start
  or 
 End
  projects included in the 
 book files to follow along (found in 
 Chapter06/Start
  and 
 Chapter06/End
 ).",NA
Completing the Punch and Gun Weapons,"The PlayerController has been sufficiently prepared and modified to support weapon switching. 
 It’s now time to update the two weapon classes themselves to support this behavior. Doing this is 
 required because the 
 PlayerController.EquipNextWeapon
  method calls on an 
 Equip
  function in the 
 Weapon
  class, to equip the weapon for the Player (line 172). This method is invoked not on the 
 Weapon
  
 class itself, but by using a 
 SendMessage
  function, allowing the derived classes to respond. And it’s 
 called for any newly equipped weapon, each and every time it’s equipped, giving it the opportunity 
 to perform any initialization code, such as displaying the default, idle sprite. Listing 6-8 lists the 
 completed 
 Weapon_Punch
  code, with additions highlighted in bold.
 Listing 6-8. Weapon_Punch.cs: Completed Punch Weapon
 001 //------------------------------------------------
 002 using UnityEngine;
 003 using System.Collections;
 004 //------------------------------------------------
 005 //Inherits from Weapon class
 006 public class Weapon_Punch : Weapon
 007 {
 008         //------------------------------------------------
 009         //Default Sprite to show for weapon when active and not attacking
 010         public SpriteRenderer DefaultSprite = null;
 011
 012         //Sound to play on attack
 013         public AudioClip WeaponAudio = null;
 014
 015         //Audio Source for sound playback
 016         private AudioSource SFX = null;
 017
 018         //Reference to all child sprite renderers for this weapon
 019         private SpriteRenderer[] WeaponSprites = null;
 020         //------------------------------------------------
 021         void Start()
 022         {
 023                 //Find sound object in scene
 024                 GameObject SoundsObject = GameObject.FindGameObjectWithTag(""sounds"");
 025
 026                 //If no sound object, then exit
 027                 if(SoundsObject == null) return;
 028
 029                 //Get audio source component for sfx
 030                 SFX = SoundsObject.GetComponent<AudioSource>();
 031
 032                 //Get all child sprite renderers for weapon
 033                 WeaponSprites = gameObject.GetComponentsInChildren<SpriteRenderer>();
 034
 035                 //Register weapon for weapon change events
 036                 
 GameManager.Notifications.AddListener(this, ""WeaponChange"");
 037         }",NA
Conclusion,"In this chapter we’ve implemented a complete weapon system. This includes the full implementation 
 of a punch and gun weapon, as well as a system for switching between weapons after both have 
 been collected. By now, your trigger finger is probably getting itchy to shoot some baddies and test 
 the damage code. We’ll see that in action in the upcoming chapter as we explore intelligent enemies. 
 By now, you should be able to do the following:
 Create weapon prefabs
 �
 Understand object orientation and inheritance
 �
 Understand how to create base classes and derived classes
 �
 Code weapons from a common abstract base class
 �
 Create basic sprite animation
 �
 Create orthographic cameras
 �
 Understand how to control camera depth and rendering
 �
 Understand how to achieve pixel-perfection with orthographic size
 �
 Create weapon cycling with polymorphism
 �
 Understand how using SendMessage creates object independence
 �
 �
 Create classes that work nicely with the event system",NA
Chapter,NA,NA
 7,NA,NA
Enemies,"Right now, CMOD is really starting to take shape. By investing extra time and forethought, as we’ve 
 been doing, in carefully applying well-established C# and Unity-scripting principles, CMOD not 
 only 
 works,
  but 
 works solidly
 . That is, it’s easy to expand upon and difficult to break. When game 
 development seems to flow like that, one stage naturally coming out of the previous and moving 
 smoothly in a logical sequence, we may generally take that as a “good sign.” Thus far, we’ve created 
 a complete game environment, an event system, a First Person Controller, head-bobbing behavior, 
 collectible power-ups, and damage-dealing weapons. But we’re still missing Enemy characters, and 
 that’s a crucial ingredient for CMOD and practically any shooter game.
 Essentially, we’re missing the 
 things
  we can actually shoot at, and which can also shoot us back, 
 if we’re not quick enough to defend ourselves. So now it’s time to fix this serious omission. 
 Specifically, we’ll develop enemies that can both take and deal damage with weapons, and who 
 also exhibit a degree of “intelligence,” to guide their behavior and actions during gameplay, making 
 them appear animated and alive. In achieving this, we’ll cover a lot of technical ground, and some 
 of it highly controversial in game development and beyond, exploring subjects such as artificial 
 intelligence, finite state machines, and pathfinding and navigation. So, let’s go!",NA
Meet the Bad Guys,"As discussed in Chapter 1 of this book, CMOD will feature a total three different Enemy types, all of 
 whom are dangerous to the Player in different ways. These are 
 the Drone
  (see Figure 
 7-1
 ), 
 the Tough 
 Guy
  (see Figure 
 7-2
 ), and 
 Mr. Big Cheese
  (see Figure 
 7-3
 ).",NA
Starting the Enemy Drone Prefab,"First, create a new and empty GameObject in the scene (named 
 Drone
 ), to represent the basis 
 for the Drone enemy character. As seen before, new objects are created with the shortcut key 
 Ctrl+Shift+N
 , or by selecting 
 GameObject
  
 ➤
  
 Create Empty
  from the menu. Often, however, the 
 new object is not centered at the world origin as you’d expect, but is positioned at an offset. Now, 
 this isn’t really problematic, because it’s easy to reset an object’s position by simply typing in 
 0, 0, 0
  
 into the 
 X, Y,
  and 
 Z
  fields of the 
 Transform
  component in the Object Inspector. But, there’s an even 
 quicker method still. Just click the 
 Cog
  icon in the Transform component, and choose 
 Reset
  from the 
 context menu, to reset the Transform component to its default values (see Figure 
 7-4
 ).
 Figure 7-4.
  A game object can be reset to zeroed values by choosing Reset from the component cog menu
 Next, drag and drop all Drone-related 
 sprites
  from the atlas texture in the project panel onto the 
 newly created empty in the scene, ensuring all sprite instances are added as child objects. Be sure 
 to drag and drop the sprites into the Hierarchy panel, and not the Scene viewport. Remember, 
 the hierarchical arrangement of objects in this way (many objects grouped as children beneath a 
 common parent) is crucial for easily generating Prefab objects further along the line. Prefabs expect 
 a single parent ancestor (see Figure 
 7-5
 ).",NA
Coding Enemy Damage,"The preliminaries taken so far have established the basics for the Drone prefab, but lots more awaits 
 us in terms of C# coding. Let’s start by considering the issue of 
 dealing damage
  to the Enemy. 
 When the Player fires a weapon at an Enemy that’s in range, the Enemy should take damage unless 
 there’s an overriding reason not to (such as an invincibility shield), and further, the Enemy should 
 be destroyed if the dealt damage reduces its health to 0 or below. In this game, we won’t need to 
 consider invincibility shields and other damage-reducing factors. I mention it here primarily because 
 for many games 
 it is
  a consideration. To implement the damage receiving functionality for the Drone, 
 as well as its other behaviors, we’ll code two classes, and we’ll use the object-oriented concept of 
 class inheritance
  to make them work together. Inheritance was introduced in the previous chapter 
 when considering weapon implementation. I’ll call these classes 
 Enemy
  (the base class for 
 all
  
 Enemies generally), and 
 Enemy_Drone
  (the derived class implementing 
 Drone-specific
  functionality). 
 These classes will be added in the C# script files 
 Enemy.cs
  and 
 Enemy_Drone.cs
 , respectively. Go 
 ahead and add these script files now, as shown in Figure 
 7-8
 .",NA
Improving Damage Dealing: Feedback,"Right now the Player deals damage to the Enemy, but we (as developers) only have the live-preview 
 of variable values in the Object Inspector to confirm that this behavior is truly working as intended 
 at runtime. There’s currently no visual or graphical indication 
 for the gamer
  that damage has been 
 sustained by the Enemy. Some might not regard this as a very big deal—after all, it works, and 
 isn’t that enough? However, this dismissal might be premature. Many academic studies have been",NA
"Enemies, Intelligence, and Philosophical Zombies","The problem with the enemy Drone created so far rests not so much in anything 
 he does
 , but in 
 what 
 he doesn’t do
 . Right now, he stands motionlessly on the spot wherever we put him, and he 
 takes damage when delivered. But he doesn’t move in any appropriate respect, he doesn’t fight 
 back, and he doesn’t even try to avoid attacks. In short, he doesn’t do anything we’d expect an 
 “intelligent” person to do in the same or similar circumstances. As a result, the Enemy is technically 
 functional but is practically unconvincing. And so to solve this issue, we enter naturally into the world 
 of 
 artificial intelligence
 . But what is that, really? What does it amount to in practice for CMOD? And 
 more importantly, what does it mean for your games?
 Artificial intelligence (AI) is a huge and controversial field. But a narrow part of it is worth considering 
 here very briefly, pertaining to philosophy. Within this field, there are some who consider the word 
 artificial
  in the term 
 artificial intelligence
  to be highly misleading and incorrect. They say, when you 
 really think about it, the only good basis you have for believing that other humans are intelligent 
 is from what 
 you personally observe them doing
 . Everybody could really be zombies, for all you 
 know. After all, you can’t open people’s heads and see them thinking. You can’t see their 
 thoughts
  
 Figure 7-11.
  The Enemy taking damage",NA
Finite State Machines (FSMs),"So let’s start creating intelligent enemies (notice that I didn’t say 
 artificially
  intelligent)! The three 
 Enemy types for CMOD (the Drone, the Tough Guy, and Mr. Big Cheese) will all 
 share
  the same 
 behavior; and so the intelligence will be coded into the 
 Enemy
  base class, and not into any of 
 the derivatives—allowing all the derived classes to inherit the functionality. For CMOD, the three 
 Enemies will work as follows in terms of intelligence:
 1. 
 When the level begins, 
 all
  Enemies will wander or 
 patrol
  around the 
 environment. They will continue doing this until they come close to the Player 
 and the Player enters their line of sight. That is, when the Player enters an 
 Enemy’s 
 observation radius
 .
 2. 
 When the Player enters an Enemy’s observation radius, the Enemy will 
 change its behavior. Specifically, it will stop patrolling, and will start pursuing 
 or 
 chasing
  the Player.
 3. 
 The Enemy will continue to chase the Player until 
 either
  the Player leaves 
 the Enemy’s observation radius (the Player outruns the Enemy), or when the 
 Enemy comes within 
 attacking distance
  to the Player.
 4. 
 If the Player leaves the Enemy’s observation radius, the Enemy returns back 
 to a Patrol state, wandering the level repeatedly.
 5. 
 If the Enemy enters attacking distance to the Player, the Enemy will change 
 behavior again. Specifically, he will change from chasing to attacking.
 6. 
 When an Enemy is attacking the Player, he will continue to deal damage 
 using his weapon, until either the Player dies, or the Player is no longer within 
 attacking distance.
 Together these conditions and this logic define the general intelligence pattern for the Enemy. This 
 kind of system is called a 
 finite state machine
 , 
 because
  the Enemy can be in only one state at any 
 one time (Patrol, Chase, or Attack), and all of these states are known in advance and are connected 
 to one another by relationships in a complete system. That is, the Enemy can change from any one 
 state to another, only when certain conditions happen. We may start to define the states for this 
 machine in the 
 Enemy
  class using C# code with an 
 enum
 , as shown in Listing 7-5.
 Listing 7-5. Defining the States for an FSM
 01 using UnityEngine;
 02 using System.Collections;
 03
 04 public class Enemy : MonoBehaviour
 05 {
 06      //Enum of states for FSM
 07      
 public enum ENEMY_STATE {PATROL = 0, CHASE = 1, ATTACK=2};
 08",NA
Changing Between States,"Each of the three states for the Enemy will be implemented as separate coroutines, with each 
 respective coroutine repeating every frame for as long as the state is active. To achieve this, we’ll 
 need three coroutines, one for each state, and a function to manage and change between states. 
 The 
 Enemy
  class be updated as shown in Listing 7-6; comments follow.
 Listing 7-6. Moving Further with FSMs: Defining State Relationships with Coroutines
 001 using UnityEngine;
 002 using System.Collections;
 003
 004 public class Enemy : MonoBehaviour
 005 {
 006      //Enum of states for FSM
 007      public enum ENEMY_STATE {PATROL = 0, CHASE = 1, ATTACK=2};
 008
 009      //Current state of enemy - default is patrol
 010      public ENEMY_STATE ActiveState = ENEMY_STATE.PATROL;
 011
 012      //Current health of this enemy
 013      public int Health = 100;
 014
 015      //Reference to active PlayerController component for player
 016      protected PlayerController PC = null;
 017
 018      //Enemy cached transform
 019      protected Transform ThisTransform = null;
 020
 021      //Reference to Player Transform
 022      protected Transform PlayerTransform = null;
 023
 024       //Total distance enemy must be from player, in Unity Units, before chasing them  
 (entering chase state)
 025      
 public float ChaseDistance = 10.0f;
 026
 027      //Total distance enemy must be from player before attacking them
 028      
 public float AttackDistance = 0.1f;
 029
 030      //------------------------------------------------",NA
Preparing for State Implementation,"In the previous section, we coded the main logic governing the enemy FSM. This included all its 
 states (Patrol, Chase, and Attack), all of which are controlled through specific coroutines in the 
 class. And finally, we implemented a function (
 ChangeState
 ) to switch between states whenever the 
 appropriate conditions arise during gameplay; and generally, these conditions relate to the amount 
 of distance between the Enemy and the Player at any time. Together, this functionality represents 
 the core of the enemy FSM, but so far the states are not “fleshed out.” The various states can 
 handle state switching, allowing us to immediately change from one state to another, but none of 
 them actually make the Enemy 
 do anything
  else. The Chase state doesn’t make the Enemy chase 
 the Player, the Patrol state doesn’t make the Enemy patrol, and the Attack state doesn’t make the 
 Enemy attack. So now it’s time to implement these.",NA
The Patrol State,"In the Patrol state, the Enemy will wander the scene, traveling from its current position to a randomly 
 selected destination elsewhere in the level. Achieving this requires some amendment to the 
 Enemy
  
 class. Let’s see some of the changes to the 
 AI_Patrol
  coroutine, as shown in Listing 7-7. In-depth 
 comments follow.
 Listing 7-7. Updating the Patrol State Coroutine
 01      //------------------------------------------------
 02      //AI Function to handle patrol behaviour for enemy
 03      //Can exit this state and enter chase
 04      IEnumerator AI_Patrol()
 05      {
 06             //Stop Agent - NavMeshAgent – declared as a member of the class. See Code 7-9
 07             
 Agent.Stop();
 08
 09             //Loop forever while in patrol state
 10             while(ActiveState == ENEMY_STATE.PATROL)
 11             {
 12                     
 //Get random destination on map
 13                     Vector3 randomPosition = Random.insideUnitSphere * PatrolDistance;
 14
 15                     //Add as offset from current position
 16                     randomPosition += ThisTransform.position;
 17
 18                     
 //Get nearest valid position
 19                     NavMeshHit hit;
 20                     NavMesh.SamplePosition(randomPosition, out hit, PatrolDistance, 1);
 21
 Figure 7-14.
  The navigation mesh marks out walkable space in the level",NA
Refining the Patrol State,"The Patrol state is now operational in the sense that our Enemy character moves around the scene, 
 traveling intelligently to a random destination using the navigation mesh feature. But there’s a problem: 
 he doesn’t animate while moving. The character moves, in terms of 
 position and rotation
  within the",NA
The Chase and Attack States,"Having seen the fundamentals of creating an FSM through previous sections, let’s now put it all 
 together. Here we’ll finalize the enemy Drone character, complete with Patrol, Chase, and Attack 
 states. Consider Listings 7-9 and 7-10 for the complete 
 Enemy
  class and the relevant changes to the 
 Enemy_Drone
  classes. Get ready for some longer code listings! Comments on critical code additions 
 and changes follow.
 Listing 7-9. Final Enemy.cs Class with a Completed FSM
 001 //Sets up FSM for enemy AI
 002 //------------------------------------------------
 003 using UnityEngine;
 004 using System.Collections;
 005 using System.Collections.Generic;
 006 //------------------------------------------------
 007 public class Enemy : MonoBehaviour
 008 {
 009      //Enemy types
 010      public enum ENEMY_TYPE {Drone = 0, ToughGuy = 1, Boss=2};
 011
 012      //Type of this enemy
 013      public ENEMY_TYPE Type = ENEMY_TYPE.Drone;
 014
 015      //Custom ID of this enemy
 016      public int EnemyID = 0;
 017
 018      //Current health of this enemy
 019      public int Health = 100;
 020
 021      //Attack Damage - amount of damage this enemy deals to player when attacking
 022      public int AttackDamage = 10;
 023
 024      //Recovery delay in seconds after launching an attack
 025      public float RecoveryDelay = 1.0f;
 026
 027      //Enemy cached transform
 028      protected Transform ThisTransform = null;
 029
 030      //------------------------------------------------
 031      //AI Properties
 032
 033      //Reference to NavMesh Agent component
 034      
 protected NavMeshAgent Agent = null;
 035
 036      //Reference to active PlayerController component for player
 037      protected PlayerController PC = null;
 038
 039      //Reference to Player Transform
 040      protected Transform PlayerTransform = null;
 041",NA
Adding More Enemy Types,"Implementation of the Drone enemy is now completed, which means we can “Prefab” him! That is, 
 we can now create a Prefab for this enemy, ready to duplicate and position him in the level wherever 
 we need additional Drone enemies. But, of course, CMOD will feature more than simply the Drone 
 enemies; there’s the Tough Guy and Mr. Big Cheese, too. They are tougher and meaner Enemies. 
 However, their implementation requires only two additional classes, one for each Enemy type: 
 Enemy_ToughGuy
  and 
 Enemy_Boss
 . Both of these classes will derive from the base 
 Enemy
  class. This 
 means that all the core AI functionality and behavior inherited by the 
 Drone
  will also be inherited by 
 the Tough Guy and Mr. Big Cheese.
 In fact, the only critical ways in which the Tough Guy and Mr. Big Cheese differ from the Drone, and 
 from each other, is in terms of their 
 damage strength
 , their 
 health,
  and their 
 attack range
 . In all other 
 respects, all of the Enemies are identical—even though they may seem very different to the gamer. This 
 is significant because it shows that, through class inheritance and by using varied assets, it’s possible 
 to create the appearance of great variety and divergence atop a common and shared codebase.
 Given the similarities between the Enemy types, the source code for the Tough Guy and Mr. Big 
 Cheese will not be listed here, although it can be found in the book companion files for Chapter 7, 
 should you need further guidance on how to implement additional enemies. Take a look at Figure 
 7-19
   
 for a level full of dangerous Enemies. Congratulations! You’ve now implemented another critical and 
 core mechanic into the FPS game CMOD.
 Note
  Be sure to configure the attack, patrol, and chase distances for the Enemy component in the Object 
 Inspector. For the Drone, I’ve used a Chase of 10, a Patrol of 30, and an Attack of 2. Also be sure to set the 
 Stopping Distance of the NavMeshAgent component to 1.5 or less, to stop the Enemy from walking through 
 the Player, but to allow enough “closeness” to make an attack possible.
 Figure 7-19.
  CMOD, up and running with multiple Enemy types",NA
Summary,"By now, CMOD is really looking good! We have almost everything we need for an enjoyable game: 
 a Player character, an environment to explore, power-ups, weapons, interesting enemies, and—in 
 addition—the enemies are intelligent. Next up, we’ll consider the issue of graphical user interfaces 
 (GUIs) to add further polish to the game. Specifically, we’ll create a main menu for the game, 
 allowing the gamer to restart, exit, and load and save the game. At this point, you should be able to 
 do the following:
 Create an Enemy prefab
 �
 Create a Drone, Tough Guy, and Mr. Big Cheese enemy
 �
 Understand how to deal and receive damage to and from the Player
 �
 Understand what AI is and its purpose in games
 �
 Understand what an FSM is and how it works
 �
 Create an FSM for the Enemy character AI
 �
 Understand the NavMeshAgent component and how it works with NavMeshes
 �
 Understand what pathfinding and navigation is
 �
 Create C# script files that use the navigation system
 �
 Create agents that can move around the scene intelligently
 �
 �
 Create different Enemy types through class inheritance",NA
Chapter,NA,NA
 8,NA,NA
Graphical User Interfaces,"In this chapter we’ll create a basic graphical user interface (GUI) system for CMOD. This includes 
 a main menu and a HUD (head-up display). The main menu will appear when the user presses the 
 Escape key on the keyboard, allowing him to restart, load, save, and exit the game. And the head-up 
 display will continually show Player health, as well as the ammo status for the active weapon. In 
 creating the GUI, we’ll explore a range of subjects, including screen dimensions, the aspect ratio, 
 widgets, anchoring, GUI scaling, and resolution independence. As always, these subjects apply 
 practically, not just for CMOD or Unity specifically, but for game engines and games, as well as 
 software and web sites in general. So, let’s get started with creating GUIs.",NA
GUIs in Games,"Graphical user interfaces refer to, in sum, all 2D graphics rendered in screen space, such as 
 menus, health bars, and buttons. These let the gamer interact with the game, performing critical 
 functions. Using GUIs, gamers can load and save their game states, monitor their health status, 
 consult minimaps and radar displays, see the ammo status of their weapons, and lots more besides, 
 depending on the types of games they’re playing.
 GUIs are, in many respects, unique among all other assets and objects in a video game. Specifically, 
 they’re 
 not
  supposed to exist 
 within
  the game world itself. Enemies, like the drone and boss 
 characters for CMOD, live within the game world and interact directly with the Player, attacking or 
 chasing. Weapons and props also exist in game space; they can be collected and used by the Player 
 to attack Enemies. With these objects and more, the Player can 
 do
  things, and the presence of these 
 objects makes a substantive difference on the course of events 
 in-game
 . But GUIs are different. 
 They work at a different level; existing outside the game space, and working at a level of abstraction 
 from the game. Their purpose is either to 
 provide information
  in an 
 augmented reality
  sense, such as 
 displaying the health status of the Player, or to provide access to fundamental game functionality at 
 a system level, such as 
 exiting
 , 
 restarting
 , or 
 pausing
  the game.",NA
Getting Started with GUIs,"Since we’ll be using the Unity 4.3 2D sprite functionality to create a GUI for CMOD, our first steps 
 in GUI development will resemble the first steps for creating weapons. Specifically, we’ll create an 
 orthographic camera
  in the scene (to render graphics in 2D), with a 
 Depth Only
  value set for the 
 Clear Flag
  field in the Object Inspector. And we’ll also restrict camera rendering to only a designated 
 GUI layer using the 
 Culling Mask
  field. More in-depth instructions on how to configure a dedicated 
 2D camera in Unity is covered in Chapter 6. You can also see the GUI camera setup and object 
 arrangement I’ve used in Figure 
 8-1
  (and this project is included in the book companion files  
 /Chapter08/
 ).",NA
Resolution Dependence and Independence,"Now that we have a GUI camera in place in the scene, we can start thinking carefully about adding 
 GUI widgets to the mixture—that is, visual controls (such as buttons and images) constituting the GUI. 
 When considering this (specifically, considering how to position and draw GUI graphics on-screen), 
 a very significant problem arises relating to screen sizes. The problem is that different devices, 
 hardware, and systems support 
 different
  resolutions (pixel dimensions), and so your game may not 
 always appear at single, default resolution. You can, of course, configure your game in Unity (through 
 Player Settings
 ) to run at only 
 one
  resolution, rejecting all other resolutions, but this exclusionary",NA
Main Menu and Aspect Ratio,"The relative 
 anchoring system
  created in the previous section works insofar as it will 
 position
  
 graphical elements on the screen consistently across multiple resolutions, as we’ll see shortly. The 
 system could, of course, be taken even further to support hierarchical anchoring with multiple local 
 spaces and embedded offsets. But this kind of elaboration and additional complexity will not be 
 required for CMOD. Here, the system will be used to position a menu and its buttons on the screen. 
 The menu is shown in Figure 
 8-4
 .
 When considering the main menu graphic, as well as any other GUI graphic, a new problem presents 
 itself. Even though the menu will always be positioned at screen center (0.5, 0.5), there are still 
 questions: What should the 
 size
  and the 
 dimensions
  of the menu be? Should we simply render the 
 menu at its default size (559×549 pixels) for every resolution? Or should we 
 scale
  the graphic up or 
 down to always encompass the same screen 
 proportions
  for every resolution (a relative size)? If we 
 accept the first solution (an absolute size), then (like absolute positioning) we place concrete limits 
 on the number of resolutions we can practically support: specifically, we cannot support resolutions 
 smaller than the menu graphic, otherwise the menu will not fit entirely on the screen (the edges will 
 be cut off). Additionally, if the screen resolution is much larger than expected, the menu may appear 
 much smaller than desired at the screen’s center. Now, the second option is to use 
 scaling
 . This is 
 one route we could take to support every possible resolution, but it entails complications due to 
 aspect ratio. What are those complications? How do we overcome them? And what is 
 aspect ratio
  
 anyway?
 Aspect ratio is the 
 relationship
  between the screen width and the screen height in pixels. Aspect 
 ratio can be calculated using the formula 
 AR = Screen Width/Screen Height
 . This decimal can 
 resolve to a simplified ratio. The most common ratios are: 4:3, 5:4, 16:10, and 16:9 (widescreen). 
 The problem with aspect ratio regarding image scaling is that an image (like the menu) made at 
 one resolution and aspect ratio cannot be up- or downscaled to a different size and aspect ratio 
 without distortion. Specifically, an image scaled across multiple aspect ratios will scale nonuniformly: 
 it’ll either appear more squashed or more expanded in one dimension only. This can lead to ugly 
 graphics. So, the solution that developers have traditionally sought has been to either create multiple 
 versions of GUI graphics at different aspect ratios, switching between the versions at runtime to 
 accommodate the active resolution, 
 or
  to scale the graphics uniformly (in both dimensions) within 
 certain constraints to accommodate the active resolution to an extent, but avoiding graphical 
 distortions at the same time.
 For CMOD, however, we’ll take the former approach of avoiding the scaling issue altogether. We’ll 
 use a fixed size for the menu, setting the minimum resolution at 1024×768, meaning that the menu 
 will show at this resolution and higher. With this solution in mind, we can create the following new 
 GUI class for rendering the menu graphic (see Listing 8-3).",NA
Testing the Main Menu,"The GUI classes created so far all make use of the 
 [ExecuteInEditMode]
  directive, meaning they run 
 and operate in the background, even when the Unity Editor is not in Play mode. This feature allows 
 us to preview and see the effects of our GUI in real time; but this comes with important limitations. 
 Specifically, we’ll need to use the 
 Game
  tab (not the Scene tab) to preview our GUI, since this view 
 shows us the complete consolidation of scene cameras. So let’s switch to the Game tab; the GUI 
 menu is then displayed in the viewport (see Figure 
 8-7
 ).
 Figure 8-6.
  Changing the sprite Mesh Type from Tight to Full Rect",NA
Adding Buttons to the Main Menu,"The main menu graphic in Figure 
 8-4
  already features the button graphics “built-in”—that is, the 
 image already features the button objects. In most games, this will not be the case. Typically, 
 GUI button graphics are isolated as separate sprites and are overlaid atop the menu background 
 to support additional functionality, such as animations and hover states when the cursor moves 
 over the buttons. But here, the buttons are built into the menu, and this will still serve our needs. 
 Now, there are many ways the button functionality could be handled in CMOD; for example, each 
 button could detect presses as they happen, and then internally handle the responses, performing 
 appropriate on-click functionality. But for CMOD, our buttons will be “hollow” in the sense that 
 they’ll exist only to 
 detect button presses
 , and then they’ll trigger a system-wide event using the 
 NotificationsManager, allowing any other listening processes to respond as needed when clicks 
 happen. Other processes, if any, will essentially handle button presses. To get started on creating 
 clickable buttons, create five new game objects, one for each button, as children of the menu, 
 resetting their transforms to (0, 0, 0). The buttons are named 
 button_Cancel
 , 
 button_Exit
 ,  
 button_Load
 , 
 button_Restart
 , and 
 button_Save
  (see Figure 
 8-9
 ).
 Figure 8-9.
  Adding button objects to the scene as children of the menu object
 Next, add a 
 Box Collider
  component to each button object (
 Component
  
 ➤
  
 Physics
  
 ➤
  
 Box Collider
 ) 
 to approximate the button volume on-screen to allow click detection. Use the Game tab to align 
 the colliders with the button graphics on the menu in the viewport. Remember, if you don’t see 
 the collider gizmo outline in the Game view, then click the Gizmos drop-down box to enable the 
 Colliders option (see Figure 
 8-10
 ).",NA
Handling Button Presses,"The buttons for the main menu GUI are almost empty shells. Their task is simply to post notifications 
 into the event system when clicks are made and the menu is visible. The real “core” functionality 
 to be invoked from button presses will actually occur in other classes listening for the button-press 
 events. The main menu supports the functions: 
 Restart
  (to restart the level), 
 Load Game
  (to restore 
 a previously saved game), 
 Save Game
  (to save the current game state to persistent storage), 
 Cancel
  
 (to close the menu and resume the game), and 
 Exit
  (to terminate the game). The next chapter 
 will consider the implementation of loading and saving games. In this section, we’ll perform the 
 Restart, Cancel, and Exit feature set. Actually, considering Listing 8-3, the 
 GUIOptions
  class already 
 features the code we need to respond to menu cancelling. At line 26, the menu registers for the 
 HideOptions
  event, which is invoked when the Cancel button is pressed. The remaining two features, 
 Restart and Exit can be added into the GameManager (see Listing 8-5 for a revised 
 Start
  function 
 for 
 GameManager
  class, as well as the relevant methods; this class is also included in the book 
 companion files for 
 /Chapter08/
 ).
 Figure 8-12.
  Configuring colliders to detect mouse down events",NA
HUD: Ammo and Health Statuses,"CMOD now has a complete and working main menu for the GUI, except for load and save game 
 functionality, which are covered in the next chapter. Here, we’ll focus our attention on some basic 
 text displays for a head-up display using the font rendering features provided by the 
 GUI
  class and 
 its associated structures. The text created will display the Player health and any remaining ammo for 
 the active weapon. To achieve this, two C# classes will be coded, namely a label class (
 GUILabel
 ) for 
 displaying text, and a 
 GUIUpdate
  class, which relies on the label classes to display text on the screen, 
 describing health and ammo. Let’s start with the label class, as shown in Listing 8-6.
 Note
  Line 37 of Listing 8-5 will terminate game execution using the 
 Application.Quit
  function. You 
 could adapt this code as follows to support application quitting from the editor, too:
  
 #if UNITY_EDITOR
         UnityEditor.EditorApplication.isPlaying = false;
 #else
         Application.Quit();
 #endif
  
 More information on the high-level 
 Application
  class can be found in the Unity documentation at 
 https://docs.unity3d.com/Documentation/ScriptReference/Application.html
 .
 Note
  A head-up display (or HUD) refers to all on-screen graphical displays that appear while the game is 
 being played (such as health bar and score).
 Often, game developers avoid dynamic font rendering, as used here, for performance reasons. Instead, they 
 typically use a 
 font atlas texture
 —that is, a texture file containing each alphanumeric character in a font set. 
 Text is then shown on-screen in-game like a regular sprite or texture, with various letters in the text combined 
 like sprites to form complete text statements and sentences. There are many programs available to produce 
 font atlas textures. One includes BMFont (
 www.angelcode.com/products/bmfont/
 ). Dynamic fonts are 
 used here, however, to demonstrate basic GUI functionality and how to quickly render text on-screen. One 
 exceptional case to using atlas font textures might be rendering text from Asian-based languages, in which 
 the full character set is often too large to store inside a texture that performs well across multiple platforms.",NA
Summary,"Splendid. CMOD is now looking really great. We have almost everything we need to complete the 
 game, and to think about taking it further by adding extra levels, characters, weapons, power-ups, 
 and more. In this chapter, we added further polish by creating a basic but functional GUI interface, 
 relying partially on the older 
 GUI
  class, but also taking into consideration some of Unity’s newer 
 features, such as 2D sprites, seeing how they can be creatively applied to create GUI graphics that 
 will perform better overall than the standard GUI functionality. At this point, you should be able to do 
 the following:
 Understand what a GUI is
 �
 Understand what a HUD is
 �
 Render text on-screen using labels and the GUI class
 �
 Understand concepts such as resolution and aspect ratio
 �
 �
 Appreciate the benefits of relative positioning through anchoring",NA
Chapter,NA,NA
 9,NA,NA
Handling Persistent Data,"CMOD is looking good now, and we could improve it even further by adding more levels and 
 environments, such as rooftop levels, basements levels, and even exterior levels. If we did that, 
 however, it’d be useful for gamers to be able to save their games so that the next time they played, 
 they could resume from where they left off, preventing them from repeating their actions every 
 time. In other words, if we’re to expand the game, it’d be helpful for the gamer to have save-game 
 functionality. Achieving this effectively means we’ll need to store game data 
 persistently
  on the local 
 computer, between playing sessions, so that even between powering the computer off and on, the 
 save-game data persists to be restored. Thankfully, Unity and Mono offer a range of handy features 
 and classes for handling persistent data, and these will constitute the focus of this chapter as we 
 implement load-and-save game functionality for CMOD. So let’s go!",NA
"Persistent Data: PlayerPrefs, Binary Data, and More","Persistent data
  is a catch-all term for any game data that should remain across playing sessions. 
 Unlike most game data, which is volatile and terminates when the game ends, persistent data 
 is stored locally on the hard drive or other storage, and can be retrieved again for later playing 
 sessions, even if the computer has been turned off or restarted in the interim. Hence, such data is 
 said to 
 persist
 . The most common use of persistent data is for storing game states, allowing gamers 
 to resume from where they left off. Other uses include storing character profiles, screenshots, voice 
 recordings, preferences and settings, network information, and also game licensing data. For CMOD, 
 we’ll be creating save-game functionality only.
 Unity offers two main ways to create persistent data: one is to use the Player Preferences class, 
 which acts like a cross-platform database with key values, and the other is to use system files  
 (such as binary files and XML files). Before proceeding with our work on CMOD, I want to briefly 
 consider the options that we 
 won’t
  be using throughout the rest of this chapter to give you an 
 overview and appraisal of those features, and to explain why we won’t be using them here.",NA
Player Preferences Class,"Perhaps the easiest and quickest way to save persistent data with Unity on all platforms is to use 
 the 
 PlayerPrefs
  class. This class abstracts itself from the local file system so that we don’t have 
 to worry about file names or specific file system paths. Instead, we can treat it like a key-value 
 database. We write values to the database using integer, float, and string values, and data such as 
 the game’s brightness, whether the game should run in full-screen mode, the name of the gamer, 
 and more. And we then read back those values, across playing sessions, by simply querying the 
 appropriately named keys. As we do this, Unity internally handles all specifics about how data 
 is written to and read from persistent storage. More information on 
 PlayerPrefs
  can be found in 
 the online Unity documentation at 
 https://docs.unity3d.com/Documentation/ScriptReference/
 PlayerPrefs.html
 . Consider Listing 9-1, where some sample data is written to persistent storage 
 with the 
 PlayerPrefs
  class.
 Listing 9-1. Saving Data with the PlayerPrefs Class
 PlayerPrefs.SetString(""PlayerName"", ""John Smith"");
 PlayerPrefs.SetInt(""LastLevel"", 10);
 PlayerPrefs.SetFloat(""Brightness"", 0.7f);
 PlayerPrefs.Save();
  
 �
 The 
 PlayerPrefs
  is a static class, meaning it can be accessed anywhere in a  
 C# script file; its scope is global.
 �
 The 
 PlayerPrefs
  class automatically saves and commits all changes on a clean 
 application exit, and so in theory, the final call to the 
 Save
  method is optional. 
 However, the 
 Save
  function will not be called automatically if the application 
 terminates prematurely, such as an unexpected crash. So it’s often good 
 practice to call the 
 Save
  method after making 
 PlayerPrefs
  changes.
 Saved data can also be retrieved through the 
 PlayerPrefs
  class at any time across all playing 
 sessions using the 
 GetString
 , 
 GetInt
 , and 
 GetFloat
  methods (see Listing 9-2).
 Listing 9-2. Loading Data with the PlayerPrefs Class
 string Name = PlayerPrefs.GetString(""PlayerName"");
 int LastLevel = PlayerPrefs.SetInt(""LastLevel"");
 float Brightness = PlayerPrefs.SetFloat(""Brightness"");
  
 Saving and loading data with 
 PlayerPrefs
  really is as simple as Listings 9-1 and 9-2 show.  
 From this, the question may arise as to exactly where on the local file system the data is stored.  
 The answer is: it depends on the user operating system. For Windows users, 
 PlayerPrefs
  data is 
 stored in the system registry, and for other systems, it’s stored in local files in different locations. 
 The Unity online documentation features more information on this. However, the 
 PlayerPrefs
  class 
 will not be used further in this chapter for storing CMOD data. This is because 
 PlayerPrefs
  is 
 intended for storing only user preferences data—that is, smaller, bite-sized pieces of data for holding 
 brightness settings, as well as the gamer’s name, game difficulty, full-screen vs. windowed mode, 
 and more. For CMOD, we’ll need to store a lot more data than this: specifically, the transform data 
 for nearly every moveable object, including the Player and the Enemies. To achieve this, we must 
 move away from 
 PlayerPrefs
  and adopt a custom file-based solution.",NA
File-Based Persistence,"The second and most flexible method for storing persistent data in Unity is to resort to the Mono 
 Framework for saving data to a file on local storage. Using this method, two main approaches are 
 available: data can be saved to a 
 binary proprietary file
  or to a 
 human-readable text-based file
  like 
 XML. Both represent file-based forms of persistent storage. The difference rests in whether the 
 gamer can open the saved file and see and edit the contents. The traditional approach in game 
 development is to use a proprietary file, primarily to prevent the user from breaking the game by 
 changing the data—intentionally or accidentally—to invalid values. But it’s also to prevent cheating, 
 too, which can happen when gamers tweak the data (intentionally giving themselves extra lives, or 
 more health, or more items).
 Unity allows saving to this kind of format by using the 
 BinaryFormatter
  class. But in this book, we’ll 
 actually choose the more open and human-readable XML route for creating saved games. There 
 are two main reasons for this: first, a human-readable XML file allows us to easily debug not only 
 save-game functionality, but the game in general. It lets us see the value of objects, consolidated 
 into a single XML file; and we can also change the values and see the changes reflected in-game. 
 And second, an open save-game file also permits other developers and third parties to easily write 
 extensions or plug-ins for the game, adding their own data without breaking the XML scheme 
 already in place. This means we can quickly establish a potential community of “modders” or 
 “modifiers.” So, for this chapter, we’ll avoid the binary format route, and choose the XML-based 
 saved-game file. When creating your own games, you’ll need to make judgments about which",NA
Saving with XML,"Saved games for CMOD will be saved in the XML format. XML stands for E
 X
 tensible 
 M
 arkup 
 L
 anguage, and it uses a hierarchical text-based structure for saving data. There are alternative  
 text-based formats available, which are gaining popularity in games today. One is JSON (JavaScript 
 Object Notation), which features a more abbreviated and slim-line syntax than XML, making it a 
 particularly attractive option for streaming text-based data across networks. But currently, JSON 
 is not supported natively by Unity or the Mono Framework (as of version 4.3). This means that you 
 must rely on custom-made parsers or third-party parsers to read from and write to JSON files. For 
 CMOD and this book in general, I stick to the native tools and classes that work out-of-the-box with 
 Unity. Hence, I’ll choose the XML file format, which is powerful, versatile, and long established.
 Note
  A freely available third-party class for parsing JSON data can be found at 
 http://wiki.unity3d.
 com/index.php/SimpleJSON
 . When using third-party code, be sure to read the source file comments and 
 summary thoroughly.
 Let’s now take a look at the saved-game XML file structure to be used for CMOD. In sum, there are 
 several data items we’ll need to save to offer complete load-and-save functionality. Specifically, 
 for the Player, we’ll need to save 
 transformation
  (position, rotation, and scale data), 
 collected cash
 , 
 collected weapon
  (if any), and 
 health
 . For the Enemy, we’ll store 
 transformation
 , 
 unique ID
  (to identify 
 the Enemy type), and 
 health
 . This data can be consolidated into a single XML file, as shown in 
 Listing 9-3 (this sample features only one Enemy alongside Player data for the sake of brevity—though 
 the “real” file will feature more Enemies).
 Listing 9-3. Sample XML Data for a CMOD Saved Game
 <?xml version=""1.0"" encoding=""Windows-1252""?>
 <GameData xmlns:xsi=""
 http://www.w3.org/2001/XMLSchema-instance
 "" xmlns:xsd=""
 http://www.w3.org/2001/
 XMLSchema
 "">
   <Enemies>
     <DataEnemy>
       <PosRotScale>
         <X>1.94054472</X>",NA
Getting Started with XML: Serialization,"There are two main methods for saving data to XML in Unity using the Mono Framework classes. 
 One method (the manual method) is to create an XML file in code, node by node, through looping 
 and iteration, saving each element of data as nodes are created, using a class such as 
 XmlDocument
 . 
 The other method (used here) is to use 
 serialization
  through the 
 XMLSerializer
  class. By using 
 serialization, you may effectively stream or snapshot a class in memory, translate it to a text-based 
 XML version, and then write it to a persistent file—one that can be accessed later in other gaming 
 sessions to automatically rebuild the class that was saved. Thus, by consolidating all save-game 
 data into a single class, we can create a save-game state quickly and effectively. This method 
 can spare us a lot of coding and extra work, 
 but
  it only works with 
 specific
  data types (and not all 
 data types). This means that, before we can work with serialization itself, we’ll need to code some 
 new custom classes and structures to hold all game data, but using only data types supported by 
 serialization. We’ll then need to populate this class with valid game data prior to saving to ensure 
 that all appropriate data is saved. Listing 9-4 lists a new 
 LoadSaveManager
  class created in the file 
 LoadSaveManager.cs
 . This file includes new serializable classes and structures that can be saved to 
 an XML file.
 Listing 9-4. Starting a LoadSaveManager Class
 01 //Loads and Saves game state data to and from xml file
 02 //-----------------------------------------------
 03 using UnityEngine;
 04 using System.Collections;
 05 using System.Collections.Generic;
 06 using System.Xml;
 07 using System.Xml.Serialization;
 08 using System.IO;
 09 //-----------------------------------------------
 10 public class LoadSaveManager : MonoBehaviour
 11 {
 12      //Save game data
 13      [XmlRoot(""GameData"")]
 14      
 public class GameStateData
 15      {
 16              //-----------------------------------------------
 17              
 public struct DataTransform
 18              {
 19                      public float X;
 20                      public float Y;
 21                      public float Z;
 22                      public float RotX;
 23                      public float RotY;
 24                      public float RotZ;
 25                      public float ScaleX;
 26                      public float ScaleY;
 27                      public float ScaleZ;
 28              }
 29              //-----------------------------------------------
 30              //Data for enemy",NA
Loading from and Saving to an XML File,"The 
 LoadSaveManager
  class is managerial, insofar as it oversees the general loading and saving 
 process from and to an XML file. This class features a critical member, namely 
 GameState
 , which 
 consolidates all the serializable game data to be saved to a file and loaded from a file. Effectively, the 
 GameState
  member will represent a game state in memory, as we’ll see later. The question then arises 
 as to how this class can be saved to XML and loaded from XML. To achieve this, the 
 LoadSaveManager
  
 class be amended with two new functions. These are listed in Listing 9-5. Comments follow.
 Listing 9-5. Adding Load and Save Functionality into the LoadSaveManager Class
 01 //-----------------------------------------------
 02 //Saves game data to XML file
 03 public void Save(string FileName = ""GameData.xml"")
 04 {
 05      //Clear existing enemy data
 06      GameState.Enemies.Clear();
 07
 08      //Call save start notification
 09      GameManager.Notifications.PostNotification(this, ""SaveGamePrepare"");
 10
 11      //Now save game data
 12      XmlSerializer Serializer = new XmlSerializer(typeof(GameStateData));
 13      FileStream Stream = new FileStream(FileName, FileMode.Create);
 14      Serializer.Serialize(Stream, GameState);
 15      Stream.Close();
 16
 17      //Call save end notification
 18      GameManager.Notifications.PostNotification(this, ""SaveGameComplete"");
 19 }
 20 //-----------------------------------------------
 21 //Load game data from XML file
 22 public void Load(string FileName = ""GameData.xml"")
 23 {
 24      //Call load start notification
 25      GameManager.Notifications.PostNotification(this, ""LoadGamePrepare"");
 26
 27      XmlSerializer Serializer = new XmlSerializer(typeof(GameStateData));
 28      FileStream Stream = new FileStream(FileName, FileMode.Open);
 29      GameState = Serializer.Deserialize(Stream) as GameStateData;
 30      Stream.Close();
 31",NA
Completing the GameManager Class,"The 
 LoadSaveManager
  class is now completed. But on its own it can achieve nothing; since none of 
 its functionality is integrated into the main game logic or mechanics. Now it’s time to connect the 
 LoadSaveManager into the GameManager to start making things work together. To start, drag and 
 drop the LoadSaveManager script from the Project panel onto the 
 GameManager
  object in the scene 
 to add a LoadSaveManager component to the object (see Figure 
 9-4
 ).",NA
Completing the PlayerController Class,"The GameManager now supports the 
 LoadGame
  and 
 SaveGame
  functions. Whenever an object, such 
 as the main menu, calls these functions via the NotificationsManager, the GameManager will invoke 
 the appropriate loading and saving behavior implicitly. In fact, if you run CMOD now and test this 
 code, clicking the save-game button on the main menu should immediately generate a save-game 
 XML file—a file populated with XML data. This file will be saved in the 
 persistentDataPath
 , which 
 could be one among a variety of folders on your system, depending on your system configuration. 
 You can easily find where the folder is located on your computer by using the 
 Debug.Log
  function to 
 print the 
 persistentDataPath
  variable to the console during Play mode. If you examine the generated 
 XML file, however, you’ll see it’s just populated with 
 default
  XML data and not any data related to 
 the game state specifically. This is because neither the Enemies object nor the Player object ever 
 populates the 
 LoadSaveManager.GameStateData
  variable. These classes should effectively take action 
 when receiving a 
 SaveGamePrepare
  event call (to save game data), and a 
 LoadGameComplete
  event call 
 (to load game data). These events are generated by the LoadSaveManager, shown in Listing 9-5.
 So let’s now amend the 
 PlayerController
  class first to respond to load and save events in a way 
 that integrates effectively with the LoadSaveManager. See Listing 9-7 for two new event functions 
 added to the 
 PlayerController
  class. For brevity and clarity, the rest of the class is not shown here 
 (the 
 PlayerController
  is defined in Chapter 5). Remember to register the class as a listener for the 
 two events with the NotificationsManager in the 
 Start
  event. Chapter 3 features more information on 
 the NotificationsManager, if you need a refresher.
 Listing 9-7. Completing the PlayerController Class
 01      //------------------------------------------------
 02      //Function called when saving game
 03      
 public void SaveGamePrepare(Component Sender)
 04      {
 05              //Get Player Data Object
 06               LoadSaveManager.GameStateData.DataPlayer PlayerData = GameManager.StateManager.
 GameState.Player;
 07",NA
Completing the Enemy Class,"Just as we needed to update the 
 PlayerController
  class to respond to load-and-save game events, 
 we also need to update the 
 Enemy
  base class, allowing all Enemies to load and save their data. The 
 newly added functions to the 
 Enemy.cs
  class are listed in Listing 9-8; these support load and save 
 functionality. The full class listing (minus loading and saving) is shown in Chapter 7, if you want to 
 see it. Remember, all source code for CMOD is included in the project files, and the completed 
 CMOD Unity project is also included in the files for this chapter.
 Listing 9-8. Completing the Enemy Class
 01      //------------------------------------------------
 02      //Function called when saving game
 03      
 public void SaveGamePrepare(Component Sender)
 04      {
 05              //Create enemy data for this enemy
 06               LoadSaveManager.GameStateData.DataEnemy ThisEnemy =  
 new LoadSaveManager.GameStateData.DataEnemy();
 07
 08              //Fill in data for current enemy
 09              ThisEnemy.EnemyID = EnemyID;
 10              ThisEnemy.Health = Health;
 11              ThisEnemy.PosRotScale.X = ThisTransform.position.x;
 12              ThisEnemy.PosRotScale.Y = ThisTransform.position.y;
 13              ThisEnemy.PosRotScale.Z = ThisTransform.position.z;
 14              ThisEnemy.PosRotScale.RotX = ThisTransform.localEulerAngles.x;
 15              ThisEnemy.PosRotScale.RotY = ThisTransform.localEulerAngles.y;
 16              ThisEnemy.PosRotScale.RotZ = ThisTransform.localEulerAngles.z;
 17              ThisEnemy.PosRotScale.ScaleX = ThisTransform.localScale.x;
 18              ThisEnemy.PosRotScale.ScaleY = ThisTransform.localScale.y;
 19              ThisEnemy.PosRotScale.ScaleZ = ThisTransform.localScale.z;
 20",NA
Testing Save and Load Functionality,"Now we’ve got enough for everything to work together seamlessly for loading and saving games 
 in CMOD. In sum, we’ve created a LoadSaveManager that integrates with the 
 GameManager
  class, 
 and we also amended the 
 PlayerController
  and 
 Enemy
  classes to respond directly to load and save 
 events through the NotificationsManager. Let’s test this now from Unity. Simply press the Play button 
 on the editor toolbar, make some changes in-game, and then display the main menu using the 
 Escape key on the keyboard. Finally, click Save and exit the game (see Figure 
 9-5
 ).",NA
Summary,"Great! You’ve now completed CMOD. It has everything we planned for in the earlier chapters: a 
 complete environment to explore, an event-handling system, collectible power-ups, a First Person 
 Controller, weapons, intelligent enemies, a GUI system, and now load and save functionality. In 
 achieving this, we’ve seen a lot of C# scripting features. But, before moving onto the next chapter to 
 round things out for this course, let’s recap what we’ve covered in this chapter. By now, you should 
 be able to do the following:
 Understand what persistent data is
 �
 Use the PlayerPrefs class to store basic user preferences and settings
 �
 Understand the limitations of PlayerPrefs
 �
 Be aware of persistent storage alternatives, such as storing to files
 �
 Understand the difference between binary/proprietary files and text-based files
 �
 Be aware of some text-based file formats common in games, such as XML  
 �
 and JSON
 Understand serialization
 �
 Create a LoadSaveManager with XML serialization
 �
 Create classes with serializable data types
 �
 Integrate your existing game with a new save-game framework
 �
 Understand the Application.PersistentDataPath variable
 �
 Figure 9-7.
  Restoring a game from the main menu",NA
Chapter,NA,NA
 10,NA,NA
Refinements and Improvements,"Splendid! You’ve reached the final chapter of the book. CMOD is now complete and feature-filled. 
 True, it’s a relatively short game with just one level, two weapons, and three enemy types. And many 
 gamers might even mistake the game for being “simple.” But we know now that this is really more of 
 a simplification than anything else. Despite being small, CMOD makes use of an extensive range of 
 Unity features and C# nuances, and these in turn depend on concepts and theory that’s far  
 from obvious.
 In Chapter 2, we constructed a level using the modular building technique, added lightmapping for 
 static lighting, and configured enemies and power-up objects using Prefabs. In Chapter 3, we laid 
 the foundations for CMOD in terms of scripting and class design by creating a NotificationsManager 
 to support an event-driven paradigm, allowing objects to post game events when they happen, and 
 for registered listeners to be automatically notified of the events. This class came in handy for all 
 subsequent chapters.
 In Chapter 4, we moved forward to create collectible power-up objects in the level, such as health 
 restore, ammo restore, new weapons, and cash. In doing this, we saw the singleton design pattern, 
 and implemented camera-aligned billboards for sprite objects. In addition, we created PingPong 
 motion with coroutines to move the power-ups gently up and down to emphasize their collectible 
 nature. In Chapter 5, we applied concepts such as sine waves and universal First Person Controllers 
 to create a cross-platform 
 PlayerController
  class that allowed the Player to move around the level 
 in first-person mode.
 In Chapter 6, we explored issues of class inheritance and polymorphism by creating a base weapon 
 class to support a range of derived classes, implementing customized weapon functionality for the 
 punch and the pistol weapons. Further, these weapons were coded to use physics and ray casting 
 to attack and deal damage to enemy targets in range when fired. In Chapter 7, the native Unity 
 NavMesh asset came to our aid as we implemented intelligent Enemy characters that not only found 
 their way around the level, avoiding obstacles, but also exhibited patrol, chase and attack behaviors 
 using finite state machines.",NA
Level Changing,"As it stands, CMOD features only one level or scene. Consequently, the most obvious way in which 
 CMOD could be expanded is by adding more levels. The general idea would be that, on collecting all 
 cash power-ups in one level, the Player would progress to the next. And this process would repeat 
 for as many levels as there were in the game. Or maybe, you’d even create procedurally generated 
 levels (levels autogenerated at runtime), potentially allowing the game to progress indefinitely—or 
 until the gamer’s patience expired! Whichever route you choose, you’ll likely want the ability to change 
 levels in-game, moving from the Player from one level to the next. Thankfully, Unity makes this 
 task easy with the 
 Application
  class. This class supports several level loading methods. The most 
 commonly used is 
 LoadLevel
 , which looks like Listing 10-1.
 Listing 10-1. Loading a Level Using Application.LoadLevel
 Application.LoadLevel(1); 
 Note
  More information on the 
 Application
  class can be found in the online Unity documentation at 
 https://docs.unity3d.com/Documentation/ScriptReference/Application.html
 .
 Levels can be loaded either by number (ID) or by name (that is, the scene name, excluding the 
 .scene
   
 file extension). However, for 
 LoadLevel
  to work as intended, all levels in the game must be included 
 in the 
 levels list
 . This list can be accessed by choosing 
 File
  
 ➤
  
 Build Settings
  from the application 
 menu. From there, scene files can be dragged and dropped from the Project panel into the levels list. 
 You can also rearrange the order of scene files within the list by dragging and dropping items. Each 
 level is assigned a unique number or ID, shown in the right-hand column (see Figure 
 10-1
 ). This ID 
 can be passed to the 
 LoadLevel
  function to load the appropriate level.",NA
Event Handling,"The event-handling system created in Chapter 3 was termed the 
 NotificationsManager
 . It was 
 created as a Singleton object. Using this class, a 
 Poster
  may dispatch a notification about an 
 event as it happens, such as an enemy-destroyed event, and the NotificationsManager responds 
 by immediately invoking event calls in any registered 
 Listeners
  for that event, allowing them to act 
 as required. By centralizing event handling through a single managerial class, every other class 
 has an independent and effective way to respond to almost any event without directly affecting 
 the implementation of any other class. In Chapter 3, the event framework was implemented by 
 using the 
 SendMessage
  function of 
 GameObject
 . This function can be called on a per object basis 
 and invokes any functions of a matching name on any components attached to the object. See 
 Chapter 3 for a refresher if required, and also the relevant Unity documentation at  
 http://docs.unity3d.com/Documentation/ScriptReference/GameObject.SendMessage.html
 .  
 The 
 SendMessage
  function works like the 
 BroadcastMessage
  function, except that 
 BroadcastMessage
  
 cascades invocation downward through all child objects in the scene hierarchy.
 In many situations, as with CMOD, you can get away with using 
 SendMessage
  and 
 BroadcastMessage
  
 without any problems. But both of these functions rely on deeper underlying code that 
 can
  be 
 computationally expensive, leading to performance issues. This primarily (though not exclusively) 
 results from an internal process known as 
 reflection
 . If your game makes frequent and extensive 
 use of either 
 SendMessage
  or 
 BroadcastMessage
 , and you’re experiencing performance issues, then 
 it’s time to seriously rethink your code and to consider alternatives. And indeed, there are many 
 alternatives.
 The biggest problems that we faced when coding the event-handling system was how to invoke 
 events on listeners that could potentially be of any data type. A Listener could be any kind of class, 
 and because we can’t know in advance which type it is, then we don’t know which functions it 
 supports and which functions we can call. The 
 SendMessage
  and 
 BroadcastMessage
  methods allow 
 us to easily get around this problem, because they simply require us to provide a function name 
 by 
 string
 , and they execute that function for us across all components in an object, regardless of object 
 data types—provided the function exists in the first place. So, when considering alternatives for 
 event handling, we need solutions that will allow us to achieve a similar kind of behavior. There are at 
 least two possibilities in C: 
 interfaces
  and 
 delegates
 .",NA
Interfaces,"Interfaces are a powerful feature native to C#, and not Unity specifically. They let you create a 
 special kind of runtime polymorphism and they offer a solution to effective event handling. Let’s see 
 how in practice. In short, with a C# interface you start by defining one or more functions together, as 
 shown in Listing 10-4.",NA
Delegates,"Interfaces simulate polymorphism among classes of different types. Delegates, in contrast, work at 
 the function or method level, as opposed to the class level. Imagine that you can treat a function 
 like a variable: you can create a 
 variable
  and store a reference in it to a 
 function
  elsewhere, even to a 
 function in a 
 different
  class. And then imagine that you could later 
 execute
  that variable, 
 invoking
  the 
 function it references. This is effectively what delegates let you achieve. A delegate is a special object 
 referencing a function. This means that we can create a NotificationsManager by maintaining an array 
 of delegates, referencing the functions for many different listener objects. The only standard or rule 
 the listeners must obey for this to work effectively is that their event functions maintain the same  
 prototype—that is, has the same argument list and return type. Let’s see this in action across two 
 different script files: one for the NotificationsManager and one for the Listener (see Listings 10-8 and 10-9).  
 Then give it a test in Unity.
 Listing 10-8. NotificationsManager.cs: Defines an Interface and Notifications Manager Using Delegates
 using UnityEngine;
 using System.Collections;
 using System.Collections.Generic;
  
 public class NotificationsManager : MonoBehaviour
 {
         //Define even types here...
          public enum EVENT_TYPE {ON_ENEMYDESTROYED = 0, ON_LEVELRESTARTED = 1, ON_POWERUPCOLLECTED = 2,  
 ON_KEYPRESS=3};
  
         //Declare listener delegate
         
 public delegate void ListenerDelegate(NotificationsManager.EVENT_TYPE EType, int Param);
  
         //Array of listener delegates
         
 private List<ListenerDelegate> Listeners = new List<ListenerDelegate>();",NA
Write Shorter Code,"The famous computer scientist Ken Thompson is often attributed as saying, “One of my most 
 productive days was throwing away 1000 lines of code.” And another computer scientist, Edsger 
 W. Dijkstra, echoed a similar idea when he said, “Simplicity is a prerequisite for reliability.” Here, 
 there’s the idea that simplicity is preferred wherever possible. In programming, this often means 
 not resorting to needless complexity and excess; and keeping your code shorter, tidier, and more 
 readable, while still being reliable and efficient. Achieving this in practice is actually harder than it 
 sounds, and it’s often something you develop with experience. But there are tips and techniques 
 you can use right now to write shorter and clearer C# code that’s often easier to read and maintain. 
 Some general tips follow.",NA
Ternary Operator,"The term 
 ternary
  is Latin, meaning “composed of three parts.” This name describes the three-part 
 nature of the ternary operator in C#, which is essentially a form of abbreviation. It is sometimes call 
 the 
 conditional operator
 . Often, when coding games, you’ll need to check a specific condition using 
 an 
 if-else
  statement. Then, based on the outcome of the check, you’ll need to assign a variable 
 some specific value, in both the 
 if
  and the 
 else
  blocks; something like what’s shown in Listing 10-10.
 Listing 10-10. Assigning Variables Based on Conditions
 if(DoorClosed == true)
 {
         MonsterState = MONSTER_STATE.Idle;
 }
 else
 {
         MonsterState = MONSTER_STATE.Attack;
 }
  
 The ternary operator lets you shorten code like this into only one line using the 
 ?
  and the 
 :
  symbols.  
 Using the ternary operator, Listing 10-10 could be abbreviated into Listing 10-11.
 Listing 10-11. Using the Ternary Operator
 DoorClosed  = (DoorClosed == true) ? MONSTER_STATE.Idle : MONSTER_STATE.Attack;",NA
Null-Coalesce Operator,"In programming, the value 
 null
  means nothing, emptiness, oblivion, nothingness. It expresses 
 invalidity. One common task in programming is to assign a value to a variable on the basis of a null 
 check, to ensure we’re working only with valid data. Consider Listing 10-12.
 Listing 10-12. Check for Null Values on Assignment
 if(DroneEnemy != null)
         EnemyReference = DroneEnemy;
 else
         EnemyReference = BossEnemy;
  
 This kind of statement could, of course, be shortened using the ternary operator that we’ve seen 
 already, but for null checks specifically, it can be shortened even further with the null-coalesce 
 operator, as shown in Listing 10-13.
 Listing 10-13. Shortening with Null-Coalesce
 DroneEnemy = DroneEnemy ?? BossEnemy;",NA
Automatic Properties,"C# properties are useful because they give you the chance to perform additional functionality, such 
 as validation, when specific variables are set or read in a class. Sometimes, however, you don’t really 
 need to perform any functionality on setting or getting variables, apart from basic assignment. In 
 these cases, you could just use a public variable directly instead of a property. But, you may also 
 want to keep the variable wrapped behind a property anyway, so you can later implement validation 
 without breaking any existing code. You could do this the long way, as shown in Listing 10-14.
 Listing 10-14. Properties as Accessors
 class MyData
 {
         //Private member
         private string sName;
  
         //Public property
         public string Name
         {
                 
 get{return sName;}
                 
 set{sName = value;}
         }
 }
  
 However, a shorter alternative to write accessor methods like this is using 
 automatic properties
 . 
 The equivalent code can be written as shown in Listing 10-15.",NA
C# Features or Quirks?,"Let’s now consider some other, more controversial, features of C# that are helpful for coding games, 
 such as when expanding on CMOD, or are at least useful to know, if nothing else. These features are 
 controversial in the sense that some developers cannot see or don’t accept their usefulness in any 
 circumstances, except for the most obscure or remote cases, while others declare their usefulness in 
 many circumstances. Let’s see what these are.",NA
Private Does Not Mean Inaccessible,"Let’s say you declare a class with a 
 private
  variable, as shown in Listing 10-18. You may think that 
 the variable is protected in that no other instances could ever access it, but for the instance to which 
 it belongs. The variable is not public but private, and so surely no other instances can access it, 
 right? Wrong.
 Listing 10-18. A Class with a Private Variable
 public class MyClass
 {
         private string Name = ""DefaultString"";
 }",NA
goto is C# Teleportation,"There’s one statement in programming that nearly every programmer seems to dislike. It’s been 
 termed “bad practice” and has received such wide condemnation that it’s easy to wonder why 
 newer languages like C# even added the feature in the first place. That feature is the infamous 
 goto
  
 statement (pronounced 
 go to
 ), which allows program execution to suddenly divert from its normal 
 course and jump to a different, specified location in the source file. Thus, it’s a kind of teleport 
 feature. Some people recommend never using 
 goto
  at all, because its teleporting nature obfuscates 
 code, making it difficult to follow and understand. And yet, in moderation, 
 goto
  can prove useful and 
 sometimes cleaner for breaking out of loops early (see Listing 10-20).
 Listing 10-20. Using goto
 void Search(int Index)
 {
         int[,] IntArray = new int[4, 2] { { 2, 2 }, { 5, 5 }, { 5, 1 }, { 2, 8 } };
  
         for(int i = 0; i < IntArray.GetLength(0); i++)
         {
                 for (int j = 0; j < IntArray.GetLength(1); j++)
                 {
                         if (IntArray[i, j].Equals(Index))
                         {
                                 
 goto Found;
                         }
                 }
         }
  
         
 Found:
                 Debug.Log(""GameObject Found"");
 }",NA
Static is Omnipresent,"The 
 static
  keyword was considered in Chapter 4, when creating Singleton objects. In short, using the 
 static keyword, you can add variables that completely cut across instance scope boundaries—that 
 is, variables that retain their value not for a 
 specific
  instance of a class, but for all instances. If you 
 need to create a value that applies to 
 all
  instances of a class, as though it were a 
 shared
  variable, 
 then static variables can come in handy (see Listing 10-21 for use of a static variable in a class).
 Listing 10-21. Using Static Variables
 using UnityEngine;
 using System.Collections;
  
 public class MyClass
 {
         //Variable will be shared for all instances
         
 static public int MyVar = 50;
  
         //Variable will differ among instances
         public string Name = """";
  
         //prints static variable to console
         public void PrintMyVar()
         {
                 Debug.Log (MyVar);
         }
 }
  
 public class Sample : MonoBehaviour
 {
         void Start()
         {
                 //Delcare instances of MyClass
                 MyClass C1 = new MyClass();
                 MyClass C2 = new MyClass();
  
                 //Static variable set to 100
                 
 MyClass.MyVar = 100;
  
                 //Both classes will print 100 because they share the variable
                 C1.PrintMyVar();
                 C2.PrintMyVar();
         }
 } 
 Note
  Take care with memory management when using static objects. Unity will not automatically clean or 
 delete static references, even between scene switches.",NA
Braces Define Scope,"When thinking about variables and scope, it’s easy to think in terms of global variables living 
 application-wide, class variables as being class-wide, local variables as being function-wide, and 
 block variables as existing inside loops and 
 if
  statements. But the braces symbols 
 { }
  can be used 
 inside any function on their own, without the presence of a surrounding loop or 
 if
  statement in order 
 to control variable scope, if required (see Listing 10-22).
 Listing 10-22. Unconventional Block Scope
 void Start()
 {
  
        
 {
                 //Scope inside braces
                 string Name = ""Bob"";
                 Debug.Log(Name);
         
 }
  
         //Variable not accessible here – will generate a compile error
         Name = ""John"";
         Debug.Log(Name);
 }",NA
Summary,"So now we’ve reached the end of this intensive C# course in professional game development 
 with the Unity engine. We’ve covered a lot of ground. CMOD is completed, and having read this 
 chapter, you’re now better positioned to make potential improvements and refinements, such as 
 adding more levels and refining the event system using either interfaces or delegates. In addition, 
 you’ve seen potential tips and tricks to keep in mind when using C# that can really help boost  
 your productivity.
 Now, although there’s lots more to see and learn (as there always will be), you can still use 
 and reuse the concepts here, with practically limitless potential. Using only the code and ideas 
 presented in this book, you can produce amazing results. And I hope that this book brings you 
 game-development success. So with that said, let me congratulate you on completing the book 
 and creating a cartoon first-person shooter that rests on solid code—with the potential to be 
 expanded even further. This is Alan Thorn, signing off.
 But before I do so, let’s recap what this chapter has offered. After completing this chapter, you 
 should be able to do the following:
 Understand ways in which CMOD can be expanded
 �
 Know how to load new levels with Application.LoadLevel
 �
 Load levels asynchronously and additively
 �
 �
 Improve the event system with interfaces",NA
A,NA,NA
 ,NA,NA
■,"Ambient Occlusion (AO), 
 69
 Application.persistentDataPath, 
 295
 Artiﬁcial intelligence (AI), 
 230
 Automatic properties, 
 312",NA
B,NA,NA
 ,NA,NA
■,"Batch Rename tool
 access, 
 30
 imports, 
 29
 operation, 
 30–31
 source code, 
 27–28
 Billboards, 
 115
 bobbing, 
 121
 cached transforms, 
 117–118
 component, 
 221
 C# script ﬁle, 
 116
 rotations
 CMOD, Z and X rotations, 
 118
 LateUpdate, 
 119
 Quaternions, 
 120
 vector subtraction, 
 119
 sprite 2D consequences, 
 115
 Box Collider component, 
 221
 BroadcastMessage function, 
 100
 BroadcastMessage method, 
 306",NA
C,NA,NA
 ,NA,NA
■,"Cameras
 layers and rendering
 CullingMask
 , 
 192
 Depth and Clear Flags properties, 
 190–191
 First Person Controller, 
 190
 new GameObject, 
 189
 Object Inspector, 
 191–192
 Player weapons, 
 188
 2D graphics, 
 190
 orthographic size
 pixel perfection, 
 194–195
 size value, 
 196
 weapon sprite, 
 194–195
 Cash Power-Up
 cash sprite, 
 114–115
 GameObject component, structure, 
 142–143
 Powerup_Dollar class, 
 141
 Prefab creation, 
 143–144
 C# features
 braces symbols, 
 316
 goto, 
 314
 private variable, 
 313
 static variables, 
 315
 Crazy Mad Ofﬁce Dude (CMOD), 
 3.
   
 See also
  First-person shooter (FPS) game
 billboard sprites
 application, 
 51
 Sprite assets, 
 53
 Sprite Editor, 
 51–53
 C# features (
 see
  C# features)
 create project folder, 
 37
 event handling (
 see
  Event handling system)
 FBX mesh and scale factor, 
 40–41
 import audio, 
 54
 lighting and lightmapping
 adding, scene, 
 65–66
 AO, 
 69
 Beast lightmapper, Unity, 
 64
 Bounce Boost and Intensity, 
 67,
  
 69
 directional lights, 
 66
 effects calculation, 3D environment, 
 64
 illumination, 
 72
 information generation, 
 70–71
 Project panel, 
 70,
  
 72",NA
Index,319,NA
D,NA,NA
 ,NA,NA
■,"Damage event, 
 228
 The Drone, 
 218",NA
E,NA,NA
 ,NA,NA
■,"Enemies
 artiﬁcial intelligence, 
 230
 Chase and Attack states
 ﬁnal Enemy.cs Class, 
 246
 relevant additions, 
 251
 damage dealing
 amending Enemy_Drone, 
 229
 conﬁguring color animation, 
 228
 Enemy base class, 
 223
 Enemy_Drone derived class, 
 223–224
 Object Inspector, 
 225
 PingPongSpriteColor.cs, 
 226
 the Drone, 
 217–218
 Enemy Drone prefab
 Billboard component, 
 222
 BoxCollider component, 
 222
 Drone sprites, 
 220
 reset object’s position, 
 219
 SpriteShowAnimator components, 
 221
 FSMs, 
 232
 Mr. Big Cheese, 
 217–218
 multiple Enemy types, 
 253
 Patrol State
 Coroutine, 
 239
 Enemy_Drone script, 
 243–244
 Enemy in motion, 
 244
 Enemy pathﬁnding cylinder, 
 245
 state implementation, 
 236
 state relationships, 
 233
 super-intelligent, 
 231
 the Tough Guy, 
 217–218
 truly clever enemy, 
 231
 Event handling system
 abstract, 
 83
 action/function, 
 83
 BroadcastMessage function, 
 100–101
 component-based paradigm, 
 99
 C# scripting, 
 81–82
 delegate, 
 309
 ﬁre button, 
 82
 gameplay-level events, 
 82
 Generic classes, 
 95
 IListener interface, 
 307
 .NET dictionary
 dynamic arrays, 
 93
 technical requirements, 
 92
 two-dimensional array, 
 93
 NotiﬁcationsManager class, 
 306
 compile-time errors, 
 91
 completion, 
 103
 C# script ﬁle, 
 89–90
  
 320
 Index
 Crazy Mad Ofﬁce Dude (CMOD) (
 cont.
 )",NA
F,NA,NA
 ,NA,NA
■,"First-person controller, 
 147
 capsule mesh, 
 162
 character controllers, 
 147
 AudioListener component, 
 148
 head bobbing, 
 150
 platform speciﬁc, 
 149
 Prefab object, 
 148
 Death Animation
 Die coroutine, 
 171
 PlayerController, 
 169–171
 Respawn time variable, 
 171
 GUIs, 
 175
 handling cash collection, 
 163
 head bobbing, 
 159
 life and health
 health implementation, 
 171–174
 procedural textures, 
 174–175
 multiplatform development
 Build Settings dialog, 
 150
 GameObject organization, 
 154
 per-platform texture settings, 
 151
 Platform Dependent Compilation  
 feature, 
 153
 renaming, 
 155
 tagging objects, 
 156
 texture assets, 
 151
 Unity Remote, 
 150
 platform dependent compilation, 
 157
 Awake event, 
 158
 ControlSwitcher script, 
 157
 #if directive, 
 158
 public variables, 
 158
 Player life and health
 Animator components, 
 167
 Death trigger parameter, 
 168
 traditional approach, 
 166
 Unity Animation Editor, 
 166
 sine waves, 
 158
 Standard-Assets package, 
 152
 Unity project, import, 
 147
 First-person shooter (FPS) game
 Batch Renaming (
 see
  Batch Rename tool)
 Cash Power-Ups, 
 3,
  
 5–6
 CMOD
 Ammo Power-Up, 
 6
 asset labeling, 
 17
 code comments, 
 20–21
 creation, 
 2–3
 disable Ambient Lighting, 
 24
 Dual-Monitors, 
 14
 Empty Objects, 
 31
 enemy types, 
 4–5
 FBX meshes, 
 22
  
 321
 Index",NA
G,NA,NA
 ,NA,NA
■,"Game design document (GDD), 
 10
 Graphical user interfaces (GUIs)
 aspect ratio, 
 263
 games, 
 255
 HUD (
 see
  Head-up display (HUD))
 main menu
 button graphics, 
 269
 button presses, 
 272
 class, 
 263
 screen position, 
 262
 SetOptionsVisible function, 
 265
 size and dimensions, 
 263
 Sprite Renderer component, 
 265
 testing, 
 267
 texture-wire display, 
 266
 orthographic camera, 
 256
 resolution
 independence, 
 259
 pixel padding class, 
 262
 positioning component, 
 260
 UI camera conﬁguration, 
 259
 GUI.Label function, 
 275
 GUIUpdateStats class, 
 278",NA
H,NA,NA
 ,NA,NA
■,"Head-up display (HUD)
 font rendering features, 
 274
 Player health and ammo status
 displaying text and GUIUpdate  
 class, 
 274
 GUIUpdateStats component, 
 278
 label components, 
 277",NA
I,NA,NA
 ,NA,NA
■,"IListener interface, 
 307",NA
 ,NA,NA
"J, K",NA,NA
■,"JavaScript Object Notation (JSON), 
 284",NA
L,NA,NA
 ,NA,NA
■,"LoadLevel function, 
 304
 LoadSaveManager class, 
 287",NA
 ,NA,NA
M,NA,NA
■,"Mathf.Clamp utility function, 
 278
 Mr. Big Cheese, 
 217–218",NA
N,NA,NA
 ,NA,NA
■,"Navigation Mesh (NavMesh)
 agent, 
 73
 intelligence, 
 73
 marks, 
 239
 Navigation Static, 
 75
 obstacle avoidance, 
 73
 pathﬁnding, 
 73
 Radius setting, 
 78
 scene ﬂoor, 
 78–79
 scene geometry, 
 76
 tools, 
 74–75
 viewport, 
 77
 NavMeshAgent component, 
 237
 NotiﬁcationsManager class, 
 306
 Null-coalesce operator, 
 312
  
 322
 Index
 First-person shooter (FPS) game (
 cont.
 )",NA
O,NA,NA
 ,NA,NA
■,"Object orientation
 class, 
 181
 inheritance
 abstract base class, 
 181–182
 Boolean, 
 183
 MonoBehaviour, 
 182
 public class variables, 
 183
 Weapon_Gun.cs, 
 181,
  
 183
 Weapon_Punch.cs, 
 181,
  
 183
 instances, 
 181
 OnEventOccured function, 
 307",NA
 ,NA,NA
"P, Q",NA,NA
■,"Persistent data
 binary proprietary ﬁle, 
 283
 deﬁnition, 
 281
 human-readable text-based ﬁle, 
 283
 PlayerPrefs class, 
 282
 XML (
 see
  EXtensible Markup Language (XML))
 persistentDataPath, 
 295
 PostNotiﬁcation function, 
 98
 Power-Ups
 ammo-restore, 
 113
 billboards (
 see
  Billboards)
 bobbing, 
 128
 cash, 
 113–114,
  
 141
 Collider Visibility, 
 129
 collisions
 event handling, 
 132
 responses, 
 133
 coroutines
 asynchronous functions, 
 122
 Counter Finished, 
 123
 IEnumerator, 
 123
 PingPongDistance class, 
 125
 StartCoroutine, 
 123
 Travel coroutine, 
 126
 WaitForSeconds statement, 
 124
 yield break, 
 124
 deltaTime
 distance calculation, 
 128
 frequent Update, 
 128
 moving objects, 
 127
 Time class, 
 127
 time difference, 
 127
 world units per second, 
 128
 GameManager
 event handling, 
 139
 NotiﬁcationsManager, 
 135
 Powerup_Dollar class, 
 135
 singletons, 
 136
 GameObject.FindGameObjectWithTag 
 function, 
 134
 health-restore, 
 113
 OnTriggerEnter function, 
 134
 SetActive function, 
 135
 weapon-upgrade, 
 113",NA
R,NA,NA
 ,NA,NA
■,"RemoveListener function, 
 102
 RemoveRedundancies method, 
 102",NA
S,NA,NA
 ,NA,NA
■,"SendMessage function, 
 100
 SendMessage method, 
 306
 Singletons, 
 113
 API function, 
 138
 Awake event, 
 138
 design pattern, 
 136
 instance, 
 137
 private static member, 
 136
 static members, 
 136
 Source and Dest colors, 
 228
 SpriteShowAnimator component, 
 220
 State implementation, 
 236
 Super-intelligent, 
 231",NA
 ,NA,NA
"T, U, V",NA,NA
■,"The Tough Guy, 
 218
 Transform component, 
 219
 Transition time, 
 228
 Truly clever enemy, 
 231
 TryGetValue method, 
 97",NA
 ,NA,NA
W,NA,NA
■,"Weapon system
 attack animation, 
 184,
  
 188
 cameras (
 see
  Cameras)
 ﬁsts/punch weapon, 
 179–180,
  
 186
 FPS public member, 
 186
  
 323
 Index",NA
 ,NA,NA
"X, Y, Z",NA,NA
■,"XmlDocument class, 
 287
 XMLSerializer class, 
 287
  
 324
 Index
 Weapon system (
 cont.
 )",NA
Pro Unity Game ,NA,NA
Development with C#,NA,NA
Alan horn,NA,NA
Contents,"About the Author .................................................................................................................
 xi
 About the Technical Reviewer ...........................................................................................
 xiii
 Acknowledgments ..............................................................................................................
 xv
  
 Introduction ......................................................................................................................
 xvii 
 Chapter 1: Designing and Preparing
 ■
  
  ..................................................................................
 1
 Designing ......................................................................................................................................
 2
 Game Overview .............................................................................................................................
 2
 Game in Depth ...............................................................................................................................
 4
 Developing the Design: Looking Ahead .......................................................................................
 10
 Game Development Workﬂows ...................................................................................................
 12
 Tip #1: Interface Layout ...............................................................................................................
 12
 Tip #2: Dual-Monitors ..................................................................................................................
 14
 Tip #3: Be Organized ...................................................................................................................
 15
 Tip #4: Show Project Wizard on Start-up .....................................................................................
 21
 Tip #5: Use FBX Meshes ..............................................................................................................
 22
 Tip #6: Disable Ambient Lighting .................................................................................................
 24
 Tip #7: Use Root GameObjects ....................................................................................................
 25",NA
About the Author,"Alan Thorn
  is a freelance game developer and author with over 12 years  
 of industry experience. He is the founder of London-based game studio 
 Wax Lyrical Games, and is the creator of the award-winning adventure 
 game 
 Baron Wittard: Nemesis of Ragnarok
 . He has worked freelance on 
 over 500 projects worldwide, including games, simulators, kiosks, and 
 augmented reality software for game studios, museums, and theme 
 parks. He is currently working on an upcoming adventure game, 
 Mega 
 Bad Code
 .
 Alan has also spoken on game development at venues throughout 
 Europe, and is the author of 11 books on game development, including 
 Learn Unity for 2D Game Development
  (Apress, 2013), 
 Unity 4 
 Fundamentals
  (Focal Press, 2013), and 
 UDK Game Development
  (Cengage Learning, 2011). He is 
 also a frequent contributor at the online video training library 3DMotive.com. More information on 
 Alan Thorn and Wax Lyrical Games can be found at 
 www.alanthorn.net
  and 
 www.waxlyricalgames.com
 ,  
 as well as Alan’s YouTube channel at 
 http://goo.gl/xwD0U4
  and on Twitter at 
 https://twitter.com/thorn_alan
 .",NA
About the Technical ,NA,NA
Reviewer,"Marc Schärer
  is an interactive media software engineer creating 
 cutting-edge interactive media experiences for training, education, and 
 entertainment with his company, Gayasoft (
 www.gayasoft.net
 ), located 
 in Switzerland, using Unity since its early days in 2007.
 Marc has a strong background in 3D graphics, network technology, 
 software engineering, and interactive media. Starting programming at 
 the age of 11, he later studied computer science and computational 
 science and engineering at the Swiss Federal Institute of Technology 
 Zurich before working with various teams in North America, Oceania, 
 and Japan to create compelling interactive experiences.
 With the rise of serious games, interactive education, and immersive 
 experiences, Gayasoft’s focus is on researching options and 
 technologies for the next generation of interactive and immersive 
 experiences, applying state-of-the-art augmented and virtual reality 
 (AR/VR) technologies (such as Vuforia, Metaio, and Oculus Rift) and intuitive, innovative input 
 technologies (such as Razer Hydra, STEM, Thalmic Myo, Leap Motion, and Emotive Insight).",NA
Acknowledgments,"This book would not have been possible if it hadn’t been for the efforts and ﬁne work of many 
 people, all of whom were a pleasure to work with. There are simply too many people and I can’t list 
 them all here. But I feel special mention should go to: Michelle Lowman for helping to get this book 
 started in the ﬁrst place, Kevin Shea for keeping things on track, and Marc Schärer for ensuring 
 technical correctness. In addition, I’d like to thank Douglas Pundick, Tim Moore, Kimberly Burton, 
 and Dhaneesh Kumar for their editorial and production work; as well as everybody else at Apress. 
 And ﬁnally, I’d like to thank you, the reader, for purchasing this book and taking the time to improve 
 your C# skills. I hope the book proves highly useful for you. 
 —Alan Thorn 
 2014, London",NA
