Larger Text,Smaller Text,Symbol
TABLE OF CONTENTS,"Foreword xv 
  
 Preface xvii 
  
 PART 
 I 
 INTRODUCTION
  
 1 
  
 Object-Oriented Analysis and Design    3
  
 Applying UML and Patterns in OOA/D    3 
  
 Assigning Responsibilities    6 
  
 What Is Analysis and Design?    6 
  
 What Is Object-Oriented Analysis and Design?    7 
  
 An Example    7 
  
 The UML    10
  
 2 
  
  
 Further Readings    11 
  
 Iterative Development and the Unified Process    13
  
 The Most Important UP Idea: Iterative Development    14 
  
 Additional UP Best Practices and Concepts    18 
  
 The UP Phases and Schedule-Oriented Terms    19 
  
 The UP Disciplines (was Workflows)    20 
  
 Process Customization and the Development 
 Case    23 
  
 The Agile UP    24 
  
 The Sequential ""Waterfall"" Lifecycle    25 
  
 You Know You Didn't Understand the UP When...    26
  
 3 
  
  
 Further Readings    26 
  
 Case Study: The NextGen POS System    29
  
 The NextGen POS System    29 
  
 Architectural Layers and Case Study Emphasis    30 
  
 The Book's Strategy: Iterative Learning and Development    31
  
 PART 
 II 
 INCEPTION
  
 4 
  
 Inception    35
  
 Inception: An Analogy    36 
  
 Inception May Be Very Brief   36 
  
 What Artifacts May Start in Inception?    37
  
 5 
  
  
 You Know You Didn't Understand Inception When...    38 
 Understanding Requirements    41
  
 Types of Requirements 
  
 6 
  
  
 42 Further Readings    43 
  
 Use-Case Model: Writing Requirements in Context    45
  
 Goals and Stories    46 
  
 Background    46 
  
 Use Cases and Adding Value    47 
  
 Use Cases and Functional Requirements    48 
  
 Use Case Types and Formats    49 
  
 Fully Dressed Example: Process Sale    50 
  
 Explaining the Sections    54 
  
 Coals and Scope of a Use Case    59 
  
 Finding Primary Actors, Goals, and Use Cases    63 
  
 Congratulations: Use Cases Have Been Written, and Are Imperfect    67 
 Write Use Cases in an Essential Ul-Free Style    68 
  
 Actors    70 
  
 Use 
 Case 
 Diagrams    71 
  
 Requirements in Context and Low-Level Feature Lists    73 
  
 Use Cases Are Not Object-Oriented    75
  
 vii",NA
FOREWORD,"Programming is fun, but developing quality software is hard. In between the nice 
 ideas, the requirements or the ""vision,"" and a working software product, there is 
 much more than programming. Analysis and design, defining how to solve the 
 problem, what to program, capturing this design in ways that are easy to 
 communicate, to review, to implement, and to evolve is what lies at the core of this 
 book. This is what you will learn.
  
 The Unified Modeling Language (UML) has become the universally-accepted 
 language for software design blueprints. UML is the visual language used to convey 
 design ideas throughout this book, which emphasizes how developers really apply 
 frequently used UML elements, rather than obscure features of the language.
  
 The importance of patterns in crafting complex systems has long been recog-nized in 
 other disciplines. Software design patterns are what allow us to describe design 
 fragments, and reuse design ideas, helping developers leverage the expertise of others. 
 Patterns give a name and form to abstract heuristics, rules and best practices of 
 object-oriented techniques. No reasonable engineer wants to start from a blank slate, 
 and this book offers a palette of readily usable design patterns.
  
 But software design looks a bit dry and mysterious when not presented in the context 
 of a software engineering process. And on this topic, I am delighted that for his 
 second edition, Craig Larman has chosen to embrace and introduce the Unified 
 Process, showing how it can be applied in a relatively simple and low-ceremony 
 way. By presenting the case study in an iterative, risk-driven, architecture-centric 
 process, Craig's advice has realistic context; he exposes the dynamics of what really 
 happens in software development, and shows the external forces at play. The design 
 activities are connected to other tasks, and they no longer appear as a purely cerebral 
 activity of systematic transformations or creative intuition. And Craig and I are 
 convinced of the benefits of iterative development, which you will see abundantly 
 illustrated throughout.
  
 So for me, this book has the right mix of ingredients. You will learn a systematic 
 method to do Object-Oriented Analysis and Design (OOA/D) from a great teacher, a 
 brilliant methodologist, and an ""OO guru"" who has taught it to thou-sands around the 
 world. Craig describes the method in the context of the Uni-
  
 xv",NA
PREFACE,"Thank you for reading this book! This is a practical introduction to object-ori-
 ented analysis and design (OOA/D), and to related aspects of iterative develop-
 ment. I am grateful that the first edition was received as a popular introduction to 
 OOA/D throughout the world, translated into many languages. Therefore, this 
 second edition builds upon and refines—rather than replaces—the content in the 
 first. I want to sincerely thank all the readers of the first edition.
  
 Here is how the book will benefit you.
  
 Design robust and 
 maintainable 
  
 object systems.
  
 Follow a roadmap 
 through require-
  
 ments, analysis, 
  
 design, and 
 coding.
  
 Use the UML to 
  
 illustrate analysis 
 and design models.
  
 Improve designs by 
 applying the 
  
 ""gang-of-four"" and 
 GRASP design 
  
 patterns.
  
 Learn efficiently by 
 following a refined 
 presentation.
  
 Learn from a 
  
 realistic exercise.
  
 First, 
 the use of object technology has proliferated in the development of soft-
 ware, and mastery of OOA/D is critical for you to create robust and maintain-
 able object systems.
  
 Second, 
 if you are new to OOA/D, you are understandably challenged about how 
 to proceed through this complex subject; this book presents a well-defined 
 roadmap—the Unified Process—so that you can move in a step-by-step process 
 from requirements to code.
  
 Third, 
 the Unified Modeling Language (UML) has emerged as the standard 
 notation for modeling; so it is useful for you to be conversant in it. This book 
 teaches the skills of OOA/D using the UML notation.
  
 Fourth, 
 design patterns communicate the ""best practice"" idioms and solutions 
 that object-oriented design experts apply in order to create systems. In this book 
 you will learn to apply design patterns, including the popular ""gang-of-four"" pat-
 terns, and the GRASP patterns, which communicate fundamental principles of 
 responsibility assignment in object design. Learning and applying patterns will 
 accelerate your mastery of analysis and design.
  
 Fifth, 
 the structure and emphasis in this book is based on years of experience in 
 training and mentoring thousands of people in the art of OOA/D. It reflects that 
 experience by providing a refined, proven, and efficient approach to learning the 
 subject so your investment in reading and learning is optimized.
  
 Sixth, 
 it exhaustively examines a single case study—to realistically illustrate the 
 entire OOA/D process, and goes deeply into thorny details of the problem; it is a 
 realistic exercise.
  
 Translate to code.       
 Seventh, 
 it shows how to map object design artifacts to code in Java.
  
 Design a layered 
 architecture.
  
 Eighth, 
 it explains how to design a layered architecture and relate the graphi-cal 
 user interface layer to domain and technical services layers.
  
 XVII",NA
Acknowledgments,"First, a very special thanks to my friends and colleagues at Valtech, world-class 
 object developers and iterative development experts, who in some way contrib-
 uted to, supported, or reviewed the book, including Chris Tarr, Michel Ezran, 
 Tim Snyder, Curtis Hite, Celso Gonzalez, Pascal Roques, Ken DeLong, Brett 
 Schuchert, Ashley Johnson, Chris Jones, Thomas Liou, Darryl Gebert, Frank 
 Rodorigo, Jean-Yves Hardy, and many more than I can name.
  
 To Philippe Kruchten for writing the foreword, reviewing, and helping in so 
 many ways.
  
 To Martin Fowler and Alistair Cockburn for many insightful discussions on pro-
 cess and design, quotes, and reviews.
  
 To John Vlissides and Cris Kobryn for the kind quotes.
  
 To Chelsea Systems and John Gray for help with some requirements inspired by 
 their Java technology ChelseaStore POS system.
  
 To Pete Goad and Dave Astels at TogetherSoft for their support.
  
 Many thanks to the other reviewers, including Steve Adolph, Bruce Anderson, 
 Len Bass, Gary K. Evans, Al Goerner, Luke Hohmann, Eric Lefebvre, David 
 Nunn, and Robert J. White.
  
 Thanks to Paul Becker at Prentice-Hall for believing the first edition would be a 
 worthwhile project, and to Paul Petralia and Patti Guerrieri for shepherding the 
 second.
  
 Finally, a special thanks to Graham Glass for opening a door.",NA
About the Author,"Craig Larman serves as Director of Process for Valtech, an international con-
 sulting company with divisions in Europe, Asia, and North America, specializ-
 ing in e-business systems development, object technologies, and iterative 
 development with the Unified Process.
  
 Since the mid 1980s, Craig has helped thousands of developers to apply object-
 oriented programming, analysis, and design, and assisted organizations adopt 
 iterative development practices.
  
 xx",NA
P,NA,NA
ART,NA,NA
1,NA,NA
I,NA,NA
NTRODUCTION,NA,NA
Chapter 1,NA,NA
O,NA,NA
BJECT,NA,NA
-,NA,NA
O,NA,NA
RIENTED,NA,NA
 A,NA,NA
NALYSIS ,NA,NA
AND ,NA,NA
D,NA,NA
ESIGN,"The shift of focus (to patterns) will have a profound and 
  
 enduring effect on the way we write 
 programs.
  
 —
 Ward Cunningham and Ralph Johnson",NA
Objectives,"•
  
 •
  
 •
  
 Compare and contrast analysis and design. 
  
 Define object-oriented analysis and design (OOA/D). 
 Illustrate a brief example.",NA
1.1       Applying UML and Patterns in OOA/D,"What does it mean to have a good object design? This book is a tool to help devel-
 opers and students learn core skills in object-oriented analysis and design 
 (OOA/D). These skills are essential for the creation of well-designed, robust, and 
 maintainable software using object technologies and languages such as Java, C++, 
 Smalltalk, and C#.
  
 The proverb ""owning a hammer doesn't make one an architect"" is especially true 
 with respect to object technology. Knowing an object-oriented language (such as 
 Java) is a necessary but insufficient first step to create object systems. Knowing 
 how to ""think in objects"" is also critical.
  
 This is an 
  
 introduction
  
 This is an introduction to OOA/D while applying the Unified Modeling Lan-guage 
 (UML), patterns, and the Unified Process. It is not meant as an advanced text; it 
 emphasizes mastery of the fundamentals, such as how to assign respon-sibilities to 
 objects, frequently used UML notation, and common design pat-",NA
Many Other Skills Are Important,"Building software involves myriad skills and steps beyond requirements analy-
  
 sis, OOA/D, and object-oriented programming. For example, usability engineer-
  
 ing and user interface design are critical to success; so is database design.
  
 However, this introduction emphasizes OOA/D, and does not attempt to cover all 
  
 topics in software development. It is one piece of a larger picture.
  
 5",NA
1.2       Assigning Responsibilities,"There are many possible activities and artifacts in introductory OOA/D, and a 
 wealth of principles and guidelines. Suppose we must choose a single practical 
 skill from all the topics discussed here—a ""desert island"" skill. What would it 
 be?
  
 A critical, fundamental ability in OOA/D is to skillfully assign responsibilities 
 to software components.
  
 Why? Because it is one activity that must be performed—either while drawing a 
 UML diagram or programming—and it strongly influences the robustness, 
 maintainability, and reusability of software components.
  
 Of course, there are other necessary skills in OOA/D, but responsibility assign-
 ment is emphasized in this introduction because it tends to be a challenging skill to 
 master, and yet vitally important. On a real project, a developer might not have the 
 opportunity to perform any other analysis or design activities—the ""rush to code"" 
 development process. Yet even in this situation, assigning respon-sibilities is 
 inevitable.
  
 Consequently, the design steps in this book emphasize principles of responsibil-
 ity assignment.
  
 Nine fundamental principles in object design and responsibility assignment 
 are presented and applied. They are organized in a learning aid called the 
 GRASP patterns.",NA
1.3       What Is Analysis and Design?,"Analysis 
 emphasizes an 
 investigation 
 of the problem and requirements, rather 
 than a solution. For example, if a new computerized library information system 
 is desired, how will it be used?
  
 ""Analysis"" is a broad term, best qualified, as in 
 requirements analysis 
 (an inves-
 tigation of the requirements) or 
 object analysis 
 (an investigation of the domain 
 objects).
  
 Design 
 emphasizes a 
 conceptual solution 
 that fulfills the requirements, rather 
 than its implementation. For example, a description of a database schema and 
 software objects. Ultimately, designs can be implemented.
  
 6",NA
1.4      What Is Object-Oriented Analysis and Design?,"During 
 object-oriented analysis, 
 there is an emphasis on finding and describ-ing the 
 objects—or concepts—in the problem domain. For example, in the case of the library 
 information system, some of the concepts include 
 Book, Library, 
 and 
 Patron.
  
 During 
 object-oriented design, 
 there is an emphasis on defining software objects 
 and how they collaborate to fulfill the requirements. For example, in the library 
 system, a 
 Book 
 software object may have a 
 title 
 attribute and a 
 getChap-ter 
 method 
 (see Figure 1.2).
  
 Finally, during implementation or object-oriented programming, design objects are 
 implemented, such as a 
 Book 
 class in Java.
  
 domain concept
  
 title
  
 Book
  
 visualization of
  
 domain concept
  
 public class Book
  
 representation in an 
  
 object-oriented 
  
 programming language
  
 { 
  
 private String title;
  
 public Chapter getChapter(int) {...}
  
 }
  
 Figure 1.2 Object-orientation emphasizes representation of objects.",NA
1.5       An Example,"Before diving into the details of requirements analysis and 
 OOA/D, this section presents a birds-eye view of a few key 
 steps and diagrams, using a simple example—a ""dice game"" in 
 which a player rolls two die. If the total is seven, they win; 
 otherwise, they lose.
  
  
 7",NA
Define Use Cases,"Requirements analysis may include a description of related domain processes; 
 these can be written as 
 use cases.
  
 Define use cases
  
 Define domain
  
 Define
  
 Define design
  
 interaction
  
 model
  
 class diagrams
  
 diagrams
  
 Use cases are not an object-oriented artifact—they are simply written stories. 
 However, they are a popular tool in requirements analysis and are an important 
 part of the Unified Process. For example, here is a brief version of the 
 Play a 
 Dice Game 
 use case:
  
 Play a Dice Game: 
 A player picks up and rolls the dice. If the 
 dice face value total seven, they win; otherwise, they lose.",NA
Define a Domain Model,"Object-oriented analysis is concerned with creating a description of the domain 
 from the perspective of classification by objects. A decomposition of the domain 
 involves an identification of the concepts, attributes, and associations that are 
 considered noteworthy. The result can be expressed in a 
 domain model, 
 which 
 is illustrated in a set of diagrams that show domain concepts or objects.
  
 Define use cases
  
 Define domain
  
 Define
  
 Define design
  
 interaction
  
 model
  
 class diagrams
  
 diagrams
  
 For example, a partial domain model is shown in Figure 1.3.
  
 name
  
 Player
  
 1
  
 Rolls
  
 2
  
 Die
  
 1
  
 faceValue
  
 2
  
 Plays
  
 1
  
 DiceGame
  
 1
  
 Includes
  
 Figure 1.3 Partial domain model of the dice game.",NA
Define Interaction Diagrams,"Object-oriented design is concerned with defining software objects and their col-
 laborations. A common notation to illustrate these collaborations is the 
 interac-tion 
 diagram. 
 It shows the flow of messages between software objects, and thus the 
 invocation of methods.
  
 Define use cases
  
 Define domain
  
 Define
  
 Define design
  
 interaction
  
 model
  
 class diagrams
  
 diagrams
  
 For example, assume that a software implementation of the dice game is desired. The 
 interaction diagram in Figure 1.4 illustrates the essential step of playing, by sending 
 messages to instances of the 
 DiceGame 
 and 
 Die 
 classes.
  
 :DiceGame
  
 die1 : Die
  
 die2 : Die
  
 play()
  
 roll()
  
 fv1 := getFaceValue()
  
 roll()
  
 fv2 := getFaceValue()
  
 Figure 1.4 Interaction diagram illustrating messages between software objects.
  
 Notice that although in the real world a 
 player 
 rolls the dice, in the software design 
 the 
 DiceGame 
 object ""rolls"" the dice (that is, sends messages to 
 Die 
 objects). 
 Software object designs and programs do take some inspiration from real-world 
 domains, but they are 
 not 
 direct models or simulations of the real world.
  
 9",NA
Define Design Class Diagrams,"In addition to a 
 dynamic 
 view of collaborating objects shown in interaction dia-grams, 
 it is useful to create a 
 static 
 view of the class definitions with a 
 design class diagram. 
 This illustrates the attributes and methods of the classes.
  
 Define use cases
  
 Define domain
  
 Define
  
 Define design
  
 interaction
  
 model
  
 class diagrams
  
 diagrams
  
 For example, in the dice game, an inspection of the interaction diagram leads to the 
 partial design class diagram shown in Figure 1.5. Since a 
 play 
 message is sent to a 
 DiceGame 
 object, the 
 DiceGame 
 class requires a 
 play 
 method, while class 
 Die 
 requires 
 a 
 roll 
 and 
 getFaceValue 
 method.
  
 In contrast to the domain model, this diagram does not illustrate real-world con-cepts; 
 rather, it shows software classes.
  
 DiceGame
  
 1
  
 2
  
 Die
  
 die1 : Die
  
 faceValue : int
  
 die2 : Die
  
 getFaceValue() : int
  
 play()
  
 roll()
  
 Figure 1.5 Partial design class diagram.",NA
Summary,"The dice game is a simple problem, presented to focus on a few steps and arti-facts in 
 analysis and design. To keep the introduction simple, not all the illus-trated UML 
 notation was explained. Future chapters explore analysis and design and these artifacts 
 in closer detail.",NA
1.6       The UML,"To quote:
  
 The Unified Modeling Language (UML) is a language for speci-fying, 
 visualizing, constructing, and documenting the artifacts of software 
 systems, as well as for business modeling and other non-software 
 systems [OMG01].
  
 The UML has emerged as the de facto and de jure standard diagramming nota-tion for 
 object-oriented modeling. It started as an effort by Grady Booch and Jim Rumbaugh in 
 1994 to combine the diagramming notations from their two popu-
  
 10",NA
Why Won't We See Much UML fora Few Chapters?,"This is not just a UML notation book, but one that explores the larger picture of 
 applying the UML, patterns, and an iterative process in the context of software 
 development. The UML is primarily applied during OOA/D, which is normally 
 preceded by requirements analysis. Therefore, the initial chapters present an 
 introduction to the important topics of use cases and requirements analysis, which are 
 then followed by chapters on OOA/D and more UML details.",NA
1.7       Further Readings,"A very readable and popular summary of essential UML notation is 
 UML Dis-tilled, 
 by Martin Fowler.
  
 A succinct and popular introduction to the Unified Process (and its refinement in the 
 Rational Unified Process) is 
 The Rational Unified Process
 —
 An Introduc-tion 
 by 
 Philippe Kruchten.
  
 For a detailed discussion of UML (version 1.3) notation, 
 The Unified Modeling 
 Language Reference Manual 
 and 
 The Unified Modeling Language User Guide, 
 by 
 Booch, Jacobson, and Rumbaugh are worthwhile. Note that these texts were not 
 meant for learning how to do object modeling or OOA/D—they are UML dia-gram 
 notation references.
  
 For a description of the current version of the UML, the on-line 
 OMG Unified 
 Modeling Language Specification 
 at www.omg.org is necessary. UML revision 
 work and soon-to-be released versions can be found at www.celigent.com/uml.
  
 There are many books on software patterns, but the seminal classic is 
 Design 
 Patterns, 
 by Gamma, Helm, Johnson, and Vlissides. It is truly required reading
  
 1. The UML 2.0 effort includes exploration of the goal of simplifying and reducing 
 the notation. This book presents high-use UML likely to survive future 
 simplification.
  
 11",NA
Chapter 2,NA,NA
ITERATIVE DEVELOPMENT AND ,NA,NA
THE UNIFIED PROCESS,"People are more important than any process.
  
 Good people with a good process will outperform 
 good people with no process every time.
  
 —
 Grady Booch",NA
Objectives,"•
  
 •
  
 •
  
 Provide motivation for the content and order of subsequent chapters. 
 Define an iterative and adaptive process. 
  
 Define fundamental concepts in the Unified Process.",NA
Introduction,"Iterative development is a skillful approach to software development, and lies at 
 the heart of how OOA/D is presented in this book. The Unified Process is an 
 example iterative process for projects using OOA/D, and it shapes the book's 
 presentation. Consequently, it is useful to read this chapter so that these core 
 concepts and their influence on the book's structure are clear.
  
 This chapter summarizes a few key ideas; please see Chapter 37 for further dis-
 cussion of the UP and iterative process practices.
  
 Informally, a 
 software development process 
 describes an approach to build-ing, 
 deploying, and possibly maintaining software. The 
 Unified Process 
 [JBR99] has 
 emerged as a popular software development process for building object-oriented 
 systems. In particular, the 
 Rational Unified Process or RUP
  
 13",NA
What If I Don't Care About the UP?,"The UP is used as an example process within which to explore requirements analysis 
 and OOA/D, since it is necessary to introduce the subject in the context of some 
 process, and the UP (or the RUP refinement) is relatively widely used. Also, the UP 
 presents common activities and best practices. Nevertheless, the central ideas of this 
 book—such as use cases and design patterns—are indepen-dent of any particular 
 process, and apply to many.",NA
2.1       The Most Important UP Idea: Iterative Development,"The UP promotes several best practices, but one stands above the others: 
 itera-tive 
 development. 
 In this approach, development is organized into a series of short, fixed-
 length (for example, four week) mini-projects called 
 iterations; 
 the outcome of each is 
 a tested, integrated, and executable system. Each iteration includes its own 
 requirements analysis, design, implementation, and testing activities.
  
 The iterative lifecycle is based on the successive enlargement and refinement of a 
 system through multiple iterations, with cyclic feedback and adaptation as core drivers 
 to converge upon a suitable system. The system grows incremen-tally over time, 
 iteration by iteration, and thus this approach is also known as 
 iterative and 
 incremental development 
 (see Figure 2.1).
  
 14",NA
Embracing Change: Feedback and Adaptation,"The subtitle of one book that discusses iterative development is 
 Embrace Change 
 [BeckOO]. This phrase is evocative of a key attitude of iterative develop-ment: Rather 
 than fighting the inevitable change that occurs in software devel-opment by trying 
 (usually unsuccessfully) to fully and correctly specify, freeze, and ""sign off"" on a 
 frozen requirement set and design before implementation, iterative development is 
 based on an attitude of embracing change and adapta-tion as unavoidable and indeed 
 essential drivers.
  
 This is not to say that iterative development and the UP encourages an uncon-trolled 
 and reactive ""feature creep""-driven process. Subsequent chapters explore how the UP 
 balances the need—on the one hand—to agree upon and stabilize a set of requirements, 
 with—on the other hand—the reality of changing require-ments, as stakeholders clarify 
 their vision or the marketplace changes.
  
 Each iteration involves choosing a small subset of the requirements, and quickly 
 designing, implementing, and testing. In early iterations the choice of require-ments 
 and design may not be exactly what is ultimately desired. But the act of swiftly taking a 
 small step, before all requirements are finalized, or the entire design is speculatively 
 defined, leads to rapid feedback—feedback from the users, developers, and tests (such 
 as load and usability tests).
  
 This early feedback is worth its weight in gold; rather than 
 speculating 
 on the correct 
 requirements or design, the feedback from realistic building and testing something 
 provides crucial practical insight and an opportunity to modify or adapt understanding 
 of the requirements or design. End-users have a chance to quickly see a partial system 
 and say, ""Yes, that's what I asked for, but now that I try it, what I really want is 
 something slightly different.""
 1
  This ""yes...but"" pro-cess is not a sign of failure; rather, 
 early and frequent structured cycles of ""yes...buts"" are a skillful way to make progress 
 and discover what is of real value to the stakeholders. Yet, as mentioned, this is not an 
 endorsement of chaotic and reactive development in which developers continually 
 change direction—a mid-dle way is possible.
  
 In addition to requirements clarification, activities such as load testing will prove if the 
 partial design and implementation are on the right path, or if in the
  
 1. Or more likely, ""You didn't understand what I wanted!""
  
 16",NA
Benefits of Iterative Development,"Benefits of iterative development include:
  
 •
  
 early rather than late mitigation of high risks (technical, requirements, 
  
 objectives, usability, and so forth) 
  
 •
  
 early visible progress 
  
 •
  
 early feedback, user engagement, and adaptation, leading to a refined sys 
  
 tem that more closely meets the real needs of the stakeholders 
  
 •
  
 managed complexity; the team is not overwhelmed by ""analysis paralysis"" or 
  
 very long and complex steps 
  
 •
  
 the learning within an iteration can be methodically used to improve the 
  
 development process itself, iteration by iteration",NA
Iteration Length and Timeboxing,"The UP (and experienced iterative developers) recommends an iteration length between 
 two and six weeks. Small steps, rapid feedback, and adaptation are central ideas in 
 iterative development; long iterations subvert the core motiva-tion for iterative 
 development and increase project risk. Much less than two weeks, and it is difficult to 
 complete sufficient work to get meaningful through-put and feedback; much more than 
 six or eight weeks, and the complexity becomes rather overwhelming, and feedback is 
 delayed. A very long iteration misses the point of iterative development. Short is good.
  
 A key idea is that iterations are 
 timeboxed, 
 or fixed in length. For example, if the next 
 iteration is chosen to be four weeks long, then the partial system should be integrated, 
 tested, and stabilized by the scheduled date—date slippage is dis-couraged. If it seems 
 that it will be difficult to meet the deadline, the recom-mended response is to remove 
 tasks or requirements from the iteration, and include them in a future iteration, rather 
 than slip the completion date. Chapter 37 summarizes reasons for timeboxing.
  
 Massive teams (for example, several hundred developers) may require longer than six-
 week iterations to compensate for the overhead of coordination and communication; 
 but no more than three to six months is recommended. For example, the successful 
 replacement in the 1990s of the Canadian air traffic control system was developed with 
 an iterative lifecycle and other UP practices. It involved 150 programmers and was 
 organized into six-month iterations.
 2
  But note that even in the case of an overall six-
 month project iteration, a subsystem team of 10 or 20 developers can break down their 
 work into a series of six one-month iterations.
  
 A six-month iteration is the exception for massive teams, not the rule. To reiter-ate, the 
 UP recommends that normally an iteration should be between two and six weeks in 
 duration.",NA
2.2       Additional UP Best Practices and Concepts,"The central idea to appreciate and practice in the UP is short timeboxed itera-tive, 
 adaptive development.
  
 Another implicit, but core, UP idea is the use of object technologies, including 
 OOA/D and object-oriented programming.
  
 2. Philippe Kruchten, who also led the development of the RUP, served as chief 
 architect for the project.
  
 18",NA
2.3      The UP Phases and Schedule-Oriented Terms,"A UP project organizes the work and iterations across four major phases:
  
 1.Inception
 — approximate vision, business case, scope, vague estimates.
  
 2.Elaboration
 —refined vision, iterative implementation of the core architec 
 ture, resolution of high risks, identification of most requirements and scope, 
 more realistic estimates.
  
 3.Construction
 —iterative implementation of the remaining lower risk and 
  
 easier elements, and preparation for deployment.
  
 4.Transition
 —beta tests, deployment.
  
 These phases are more fully defined in subsequent chapters.
  
 This is 
 not 
 the old ""waterfall"" or sequential lifecycle of first defining all the 
 requirements, and then doing all or most of the design.
  
 Inception is not a requirements phase; rather, it is a kind of feasibility phase, 
 where just enough investigation is done to support a decision to continue or stop.
  
 Similarly, elaboration is not the requirements or design phase; rather, it is a phase 
 where the core architecture is iteratively implemented, and high risk issues are 
 mitigated.
  
 Figure 2.3 illustrates common schedule-oriented terms in the UP. Notice that one 
 development cycle (which ends in the release of a system into production) is 
 composed of many iterations.
  
 19",NA
2.4       The UP Disciplines (was Workflows),"The UP describes work activities, such as writing a use case, within 
 disciplines 
  
 (originally called 
 workflows).
 3
 Informally, a discipline is a set of activities (and 
  
 related artifacts) in one subject area, such as the activities within requirements 
  
 analysis. In the UP, an 
 artifact 
 is the general term for any work product: code, 
  
 Web graphics, database schema, text documents, diagrams, models, and so on.
  
 There are several disciplines in the UP; this book focuses on some artifacts in 
  
 the following three:
  
 •
  
 Business Modeling
 —When developing a single application, this includes 
  
 domain object modeling. When engaged in large-scale business analysis or 
  
 business process reengineering, this includes dynamic modeling of the busi 
  
 ness processes across the entire enterprise.
  
 •
  
 Requirements
 —Requirements analysis for an application, such as writing 
  
 use cases and identifying non-functional requirements.
  
 •
  
 Design
 —All aspects of design, including the overall architecture, objects, 
  
 databases, networking, and the like.
  
 3. In 2001, the old UP term ""workflow"" was replaced by the new term ""discipline"" in 
  
 order to harmonize with an international standardization effort called the OMG 
  
 SPEM; because of its prior meaning in the UP, many continue to use the term work-
  
 flow to mean discipline, although this is not strictly correct. The term ""workflow"" took 
  
 on a new but slightly different meaning within the UP: On a particular project, it is a 
  
 particular sequence of activities (perhaps 
 across 
 disciplines)—a flow of work.
  
 20",NA
Disciplines and Phases,"As illustrated in Figure 2.4, during one iteration work goes on in most or all dis-
 ciplines. However, the relative effort across these disciplines changes over time. 
 Early iterations naturally tend to apply greater relative emphasis to require-ments 
 and design, and later ones less so, as the requirements and core design stabilize 
 through a process of feedback and adaptation.
  
 Relating this to the UP phases (inception, elaboration, ...), Figure 2.5 illustrates 
 the changing relative effort with respect to the phases; please note these are 
 suggestive, not literal. In elaboration, for example, the iterations tend to have a
  
 4. Diagram adapted from the RUP product.",NA
Book Structure and UP Phases and Disciplines,"With respect to the phases and disciplines, what is the focus of the case study? 
 Answer:
  
 The case study emphasizes the inception and elaboration phase. It focuses on 
 some artifacts in the Business Modeling, Requirements, and Design disci-
 plines, as this is where requirements analysis, OOA/D, patterns, and the UML 
 are primarily applied.
  
  
 The earlier chapters introduce activities in inception; later chapters explore sev-
 eral iterations in elaboration. The following list and Figure 2.6 describe the 
 organization with respect to the UP phases.
  
 1.The inception phase chapters introduce the basics of requirements analysis. 
  
 2.Iteration 1 introduces fundamental OOA/D and how to assign responsibili 
  
 ties to objects. 
  
 3.Iteration 2 focuses on object design, especially on introducing some high-use 
  
 ""design patterns."" 
  
 4.Iteration 3 introduces a variety of subjects, such as architectural analysis 
  
 and framework design.",NA
2.5       Process Customization and the Development Case ,NA,NA
Optional Artifacts,"Some UP practices and principles are invariant, such as iterative and risk-driven 
 development, and continuous verification of quality.
  
 However, a key insight into the UP is that all activities and artifacts (models, 
 diagrams, documents, ...) are 
 optional
 —well, maybe not the code! The set of pos-
 sible artifacts described in the UP should be viewed like a set of medicines in a 
 pharmacy. Just as one does not indiscriminately take many medicines, but matches 
 the choice to the ailment, likewise on a UP project, a team should select a small 
 subset of artifacts that address its particular problems and needs. In general, focus 
 on a 
 small 
 set of artifacts that demonstrate high practical value.",NA
The Development Case,"The choice of UP artifacts for a project may be written up in a short document 
 called the 
 Development Case 
 (an artifact in the Environment discipline). For 
 example, Table 2.1 could be the Development Case describing the artifacts for 
 the ""NextGen Project"" case study explored in this book.
  
 Subsequent chapters describe the creation of some of these artifacts, including the 
 Domain Model, Use-Case Model, and Design Model.
  
 The example artifacts presented in this case study are by no means sufficient for, 
 or suitable for, all projects. For example, a machine control system may ben-efit 
 from doing many state diagrams. A Web-based e-commerce system may require a 
 focus on user interface prototypes. A ""green-field"" new development
  
  
 23",NA
2.6       The Agile UP,"Methodologists speak of processes as heavy vs. light, and predictive vs. adaptive. A 
 heavy process 
 is a pejorative term meant to suggest one with the following qualities 
 [FowlerOO]:
  
 •
  
 •
  
 •
  
 •
  
 many artifacts created in a bureaucratic atmosphere 
 rigidity and control 
  
 elaborate, long-term, detailed planning 
  
 predictive rather than adaptive 
  
 A predictive process 
 is one that attempts to plan and predict the activities and resource 
 (people) allocations in detail over a relatively long time span, such as the majority of a 
 project. Predictive processes usually have a ""waterfall"" or sequential lifecycle—first, 
 defining all the requirements; second, defining a detailed design; and third, 
 implementing. In contrast, an 
 adaptive process 
 is one that accepts change as an 
 inevitable driver and encourages flexible adapta-tion; they usually have an iterative 
 lifecycle. An 
 agile process 
 implies a light and adaptive process, nimble in response to 
 changing needs.
  
 The UP was not meant by its authors to be either heavy or predictive, although its large 
 optional set of activities and artifacts have understandably led to that
  
 24",NA
"2.7       The Sequential ""Waterfall"" Lifecycle","In contrast to the iterative lifecycle of the UP, an old alternative was the sequen-
  
 tial, linear, or ""waterfall"" lifecycle [RoyceTO]. In common usage, it defined 
 steps similar to the following:
  
 1.Clarify, record, and commit to a set of complete and frozen requirements. 
  
 2.Design a system based on these requirements. 
  
 3.Implement, based on the design. 
  
 A two year study reported in the 
 MIT Sloan Management Review 
 of successful 
  
 software projects identified four common factors for success; iterative develop-
  
 ment, rather than a waterfall process, was first on the list [MacCormackO!!.•''
  
 A brief description of its problems, and how they are mitigated by iterative 
  
 development, is presented in Chapter 37.
  
 5. The others were: 2) at least daily incorporation of new code into a complete system 
 build, and rapid feedback on design changes (via testing); 3) a team experienced in 
 shipping multiple products; and 4) an early focus on building and proving a 
 cohesive architecture. Three of these four factors are explicit practices in the UP.
  
 25",NA
2.8       You Know You Didn't Understand the UP When...,"Here are some signs that indicate when you have not understood what it means to 
 adopt the UP and iterative development in the agile spirit intended by the UP.
  
 •
  
 You think that inception = requirements, elaboration = design, and con 
  
 struction 
 = implementation (that is, superimposing a waterfall lifecycle on 
  
 to the UP). 
  
 •
  
 You think that the purpose of elaboration is to fully and carefully define 
  
 models, 
 which are translated into code during construction. 
  
 •
  
 You try to define most of the requirements before starting design or imple 
  
 mentation. 
  
 •
  
 You try to define most of the design before starting implementation; you try 
  
 to fully define and commit to an architecture before iterative programming 
  
 and testing. 
  
 •
  
 A ""long time"" is spent doing requirements or design work before program 
  
 ming starts. 
  
 •
  
 You believe that a suitable iteration length is four months long, rather than 
  
 four weeks long (excluding projects with hundreds of developers). 
  
 •
  
 You think UML diagramming and design activities are a time to fully and 
  
 accurately define designs and models in great detail, and of programming as 
  
 a simple mechanical translation of these into code. 
  
 •
  
 You think that adopting the UP means to do many of the possible activities 
  
 and create many documents, and thinks of or experiences the UP as a for 
  
 mal, fussy process with many steps to be followed. 
  
 •
  
 You try to plan a project in detail from start to finish; you try to specula- 
  
 tively predict all the iterations, and what should happen in each one. 
  
 •
  
 You want believable plans and estimates for projects before the elaboration 
  
 phase is finished.",NA
2.9       Further Readings,"A very readable introduction to the UP and its refinement in the RUP is 
 The Rational 
 Unified Process
 —
 An Introduction 
 by Philippe Kruchten, the lead architect of the RUP.
  
 A description of the original UP can be found in 
 The Unified Software Develop-ment 
 Process 
 by Jacobson, Booch, and Rumbaugh. It is worth study, but Kruchten's 
 introduction is recommended first, as it is smaller and more suc-cinct, and the RUP 
 updates and refines the original UP.
  
 26",NA
Chapter 3,NA,NA
CASE STUDY,NA,NA
:,NA,NA
 THE NEXTGEN ,NA,NA
POS ,NA,NA
SYSTEM,"Few things are harder to put up with than a good example.
  
 —
 Mark Twain",NA
Introduction,"This chapter briefly describes the case study. If you understand the problem 
 domain, it may be skipped. Indeed, this problem was chosen because it is 
 familiar, but rich with interesting design and architectural problems, and thus 
 allows one to concentrate on how to do analysis and design, rather than explain 
 the problem and domain.",NA
3.1       The NextGen POS System,"The case study is the NextGen point-of-sale (POS) system. In this apparently 
 straightforward problem domain, we shall see that there are very interesting 
 requirement and design problems to solve. In addition, it is a realistic problem; 
 organizations really do write POS systems using object technologies.
  
 A POS system is a computerized application used 
  
 various service applications, such as a third-party tax calculator and inventory 
 control. These systems must be relatively fault-tolerant; that is, even if remote 
 services are temporarily unavailable (such as the inventory system), they must still 
 be capable
  
  
 (in part) to record sales and handle payments; it is 
 typically used in a retail store. It includes hardware 
 components such as a computer and bar code scanner, 
 and software to run the system. It interfaces to",NA
3.2       Architectural Layers and Case Study Emphasis,"A typical object-oriented information system is designed in terms of several 
 architectural layers or subsystems (see Figure 3.1). The following is not a com-plete 
 list, but provides an example:
  
 •
  
 •
  
 User Interface
 —graphical interface; windows.
  
 Application Logic and Domain Objects—
 software objects representing 
  
 domain concepts (for example, a software class named 
 Sale) 
 that fulfill 
 application requirements.
  
 •
  
 Technical Services
 —general purpose objects and subsystems that provide 
  
 supporting technical services, such as interfacing with a database or error 
 logging. These services are usually application-independent and reusable across 
 several systems.
  
 OOA/D is generally most relevant for modeling the application logic and tech-
 nical service layers.
  
 The NextGen case study primarily emphasizes the problem domain objects, allo-
 cating responsibilities to them to fulfill the requirements of the application. Object-
 oriented design is also applied to create a technical service subsystem for interfacing 
 with a database.
  
 In this design approach, the UI layer has very little responsibility; it is said to be 
 thin. 
 Windows do 
 not 
 contain code that performs application logic or process-ing. Rather, 
 task requests are forwarded on to other layers.
  
 30",NA
3.3      The Book's Strategy: Iterative Learning and ,NA,NA
Development,"This book is organized to follow an iterative development strategy. OOA/D is 
 applied to the NextGen POS system in multiple iterations; the first iteration is for 
 some core functions. Later iterations expand the functionality of the system (see 
 Figure 3.2). In conjunction with iterative development, the 
 presentation 
 of 
 analysis and design topics, UML notation, and patterns are introduced itera-tively 
 and incrementally. In the first iteration, a core set of analysis and design topics 
 and notation is presented. The second iteration expands into new ideas, UML 
 notation, and patterns. And likewise in the third iteration.
  
 Iteration 1
  
 Introduces just those
  
 Iteration 2
  
 Iteration 3
  
 analysis and design
  
 skills related to
  
 Additional analysis and
  
 Likewise.
  
 iteration one.
  
 design skills introduced.
  
 Figure 3.2 Learning path follows iterations.
  
 31",NA
PART2 ,NA,NA
INCEPTION,NA,NA
Chapter 4,NA,NA
INCEPTION,"Le mieux est I'ennemi du bien (The best is the enemy of the good).
  
 —
 Voltaire",NA
Objectives,"•
  
 •
  
 Define the inception step. 
  
 Motivate the following chapters in this section.",NA
Introduction,"This chapter defines the inception phase of a project. If process ideas are not your 
 priority, or you prefer to first focus on learning the main practical activity in this 
 phase—use case modeling—then this chapter can be skipped.
  
 Most projects require a short initial step in which the following kinds of ques-
 tions are explored:
  
 •
  
 •
  
 •
  
 •
  
 •
  
 What is the vision and business case for this project? 
 Feasible? 
  
 Buy and/or build? 
  
 Rough estimate of cost: Is it $10K-100K or in the millions? 
 Should we proceed or stop? 
  
 Defining the vision and obtaining an order-of-magnitude (unreliable) estimate 
 necessitates doing some requirements exploration. However, the purpose of the 
 inception step is not to define all the requirements, or generate a believable esti-
 mate or project plan. At the risk of over-simplification, the idea is to do just 
 enough investigation to form a rational, justifiable opinion of the overall pur-pose 
 and feasibility of the potential new system, and decide if it is worthwhile to invest 
 in deeper exploration (the purpose of the elaboration phase).
  
 35",NA
4.1        Inception: An Analogy,"In the oil business, when a new field is being considered, some of the steps 
 include:
  
 1.Decide if there is enough evidence or a business case to even justify explor 
  
 atory drilling. 
  
 2.If so, do measurements and exploratory drilling. 
  
 3.Provide scope and estimate information. 
  
 4.Further steps... 
  
 The inception phase is like step one in this analogy. In step one people do not 
 predict how much oil there is, or the cost or effort to extract it. It is premature— 
 there is insufficient information. Although it would be nice to be able to answer 
 ""how much"" and ""when"" questions without the cost and effort of the exploration, 
 in the oil business it is understood to not be realistic.
  
 In UP terms, the realistic exploration step is the elaboration phase. The preced-
 ing inception phase is akin to a feasibility study to decide if it is even worth 
 investing in exploratory drilling. Only after exploration (elaboration) do we have 
 the data and insight to make somewhat believable estimates and plans. There-
 fore, in iterative development and the UP, plans and estimates are not to be con-
 sidered reliable in the inception phase. They merely provide an order-of-
 magnitude sense of the level of effort, to aid the decision to continue or not.",NA
4.2       Inception May Be Very Brief,"The intent of inception is to establish some initial common vision for the objec-
 tives of the project, determine if it is feasible, and decide if it is worth some 
 seri-
  
 36",NA
4.3       What Artifacts May Start in Inception?,"Table 4.1 lists common inception (or early elaboration) artifacts and indicates the 
 issues they address. Subsequent chapters will examine some of these in greater 
 detail, especially the Use-Case Model. A key insight regarding iterative development 
 is to appreciate that these are only partially completed in this phase, will be refined 
 in later iterations, and should not even be created unless it is deemed likely they will 
 add real practical value. And since it is inception, the investigation and artifact 
 content should be light.
  
 For example, the Use-Case Model (to be described in following chapters) may list 
 the 
 names 
 of most of the expected use cases and actors, but perhaps only describe 
 10% of the use cases in detail—done in the service of developing a rough high-level 
 vision of the system scope, purpose, and risks.
  
 Note that some programming work may occur in inception in order to create ""proof 
 of concept"" prototypes, to clarify a few requirements via (typically) Ul-ori-ented 
 prototypes, and to do programming experiments for key ""show stopper"" technical 
 questions.
  
 Artifact
 1
  
 Comment
  
 Vision and Business Case
  
 Describes the high-level goals and constraints, the business 
 case, and provides an executive summary.
  
 Use-Case Model
  
 Describes the functional requirements, and related non-func-
 tional requirements.
  
 Supplementary Specification
  
 Describes other requirements.
  
 Glossary
  
 Key domain terminology.
  
 Risk List & Risk Management 
 Plan
  
 Describes the business, technical, resource, schedule risks, and 
 ideas for their mitigation or response.
  
 Prototypes and proof-of-concepts
  
 To clarify the vision, and validate technical ideas.
  
 Iteration Plan
  
 Describes what to do in the first elaboration iteration.
  
 37",NA
Isn't That a Lot of Documentation?,"Recall that artifacts should be considered optional. Choose to create only those that 
 really add value for the project, and drop them if their worth is not proved.
  
 The point of an artifact is not the document or diagram itself, but the thinking, analysis, 
 and proactive readiness (and then its recording, to avoid re-invention or having to repeat 
 things verbally). As General Eisenhower said, ""In preparing for battle I have always 
 found that plans are useless, but planning indispens-able"" [Nixon90, BFOO].
  
 Record artifacts digitally and online—available on the project's website—rather than on 
 paper.
  
 Note also that UP artifacts from previous projects can be reused on later ones. It is 
 common for there to be many similarities in risk, project management, testing, and 
 environment artifacts across projects. All UP projects will (or should) organize artifacts 
 the same way, with the same names (Risk List, Development Case, and so on). This 
 simplifies finding reusable artifacts from prior projects on new UP engagements.",NA
4.4       You Know You Didn't Understand Inception When...,"•
  
 •
  
 •
  
 •
  
 It is more than ""a few"" weeks long for most projects. 
  
 There is an attempt to define most of the requirements. 
  
 Estimates or plans are expected to be reliable. 
  
 You define the architecture; rather, this should be done iteratively in 
  
 elaboration. 
  
 38",NA
Chapter 5,NA,NA
UNDERSTANDING ,NA,NA
REQUIREMENTS,"Fast, Cheap, Good: Choose any two. 
  
 —
 anonymous",NA
Objectives,"•
  
 •
  
 Define the FURPS+ model. 
  
 Relate types of requirements to UP artifacts.",NA
Introduction,"Not all requirements are created equal. This chapter introduces the FURPS+ 
 requirements categories.
  
 Requirements 
 are capabilities and conditions to which the system—and more 
 broadly, the project—must conform [JBR99]. A prime challenge of requirements 
 work is to find, communicate, and remember (that usually means record) what is 
 really needed, in a form that clearly speaks to the client and development team 
 members.
  
 The UP promotes a set of best practices, one of which is 
 manage requirements. 
 This does not refer to the waterfall attitude of attempting to fully define and sta-
 bilize the requirements in the first phase of a project, but rather—in the context of 
 inevitably changing and unclear stakeholder's wishes—""a systematic approach to 
 finding, documenting, organizing, and tracking the changing requirements of a 
 system"" [RUP]; in short, doing it skillfully and not being sloppy. Note the word 
 changing', 
 the UP embraces change in requirements as a fundamental driver on 
 projects. 
 Finding 
 is another important term; that is,
  
 41",NA
5.1       Types of Requirements,"In the UP, requirements  are categorized according to the FURPS+ model 
 [Grady92], a useful mnemonic with the following meaning:
 1
  
 •
  
 •
  
 •
  
 Functional
 —features, capabilities, security.
  
 Usability
 —human factors, help, documentation.
  
 Reliability
 —frequency of failure, recoverability, predictability.
  
 1. There are several systems of requirements categorization and quality attributes pub-
 lished in books and by standards organizations, such as ISO 9126 (which is similar to 
 the FURPS+ list), and several from the Software Engineering Institute (SE1); any can 
 be used on a UP project.
  
 42",NA
5.2       Further Readings,"References related to requirements with use cases are covered in a subsequent 
 chapter. Use-case-oriented requirements texts, such as 
 Writing Effective Use Cases 
 [CockburnOl] are the recommended starting point in requirements study, rather than 
 more general (and usually, traditional) requirements texts.
  
 43",NA
Chapter 6,NA,NA
USE,NA,NA
-,NA,NA
CASE MODEL,NA,NA
:,NA,NA
 WRITING ,NA,NA
REQUIREMENTS IN CONTEXT,"The indispensable first step to getting the things 
  
  
 you want out of life: decide what you want.
  
 —
 Ben Stein",NA
Objectives,"•
  
 •
  
 •
  
 •
  
 Identify and write use cases. 
  
 Relate use cases to user goals and elementary business processes. Use 
 the brief, casual, and fully dressed formats, in an essential style. Relate 
 use case work to iterative development.",NA
Introduction,"This chapter is worth studying during a first read of the book because use cases 
 are a widely used mechanism to discover and record requirements (especially 
 functional); they influence many aspects of a project, including OOA/D. It is 
 worth both knowing about and creating use cases.
  
 Writing use cases—stories of using a system—is an excellent technique to 
 understand and describe requirements. This chapter explores key use case con-
 cepts and presents sample use cases for the NextGen application.
  
 The UP defines the 
 Use-Case Model 
 within the Requirements discipline. 
 Essentially, this is the set of all use cases; it is a model of the system's function-
 ality and environment.
  
 45",NA
6.1       Goals and Stories,"Customers and end users have goals (also known as 
 needs 
 in the UP) and want 
 computer systems to help meet them, ranging from recording sales to estimat-ing 
 the flow of oil from future wells. There are several ways to capture these goals 
 and system requirements; the better ones are simple and familiar because this 
 makes it easier—especially for customers and end users—to contribute to their 
 definition or evaluation. That lowers the risk of missing the mark.
  
 Use cases are a mechanism to help keep it simple and understandable for all 
 stakeholders. Informally, they are stories of using a system to meet goals. Here is 
 an example 
 brief format 
 use case:
  
 Process Sale: 
 A customer arrives at a checkout with items to 
 purchase. The cashier uses the POS system to record each pur-
 chased item. The system presents a running total and line-item 
 details. The customer enters payment information, which the 
 system validates and records. The system updates inventory. The 
 customer receives a receipt from the system and then leaves with 
 the items.
  
 Use cases often need to be more elaborate than this, but the essence is discover-
 ing and recording functional requirements by writing stories of using a system to 
 help fulfill various stakeholder goals; that is, cases 
 of use.
 ]
  It isn't supposed to be 
 a difficult idea, although it may indeed be difficult to discover or decide what is 
 needed, and write it coherently at a useful level of detail.
  
 Much has been written about use cases, and while worthwhile, there is always the 
 risk among creative, thoughtful people to obscure a simple idea with layers of 
 sophistication. It is usually possible to spot a novice use-case modeler (or a 
 serious Type A analyst) by an over-concern with secondary issues such as use 
 case diagrams, use case relationships, use case packages, optional attributes, and 
 so forth, rather than writing the stories. That said, a strength of the use case 
 mechanism is the capacity to scale both up and down in terms of sophistica-tion 
 and formality, depending on need.",NA
6.2       Background,"The idea of use cases to describe functional requirements was introduced in 1986 
 by Ivar Jacobson [Jacobson92], a main contributor to the UML and UP. 
 Jacobson's use case idea was seminal and widely appreciated; simplicity and
  
 1. The original term in Swedish literally translates as ""usage case.""
  
 46",NA
:  6.3       Use Cases and Adding Value,"First, some informal definitions: an 
 actor 
 is something with behavior, such as a 
 person (identified by role), computer system, or organization; for example, a 
 cashier.
  
 A scenario 
 is a specific sequence of actions and interactions between actors and 
 the system under discussion; it is also called a 
 use case instance. 
 It is one par-
 ticular story of using a system, or one path through the use case; for example, the 
 scenario of successfully purchasing items with cash, or the scenario of failing to 
 purchase items because of a credit card transaction denial.
  
 Informally then, a 
 use case 
 is a collection of related success and failure scenar-
 ios that describe actors using a system to support a goal. For example, here is a 
 casual format 
 use case that includes some alternate scenarios:
  
 Handle Returns
  
 Main Success Scenario: 
 A customer arrives at a checkout with 
 items to return. The cashier uses the POS system to record each 
 returned item ...
  
 Alternate Scenarios:
  
 If the credit authorization is reject, inform the customer and ask 
 for an alternate payment method.
  
 If the item identifier is not found in the system, notify the Cash-
 ier and suggest manual entry of the identifier code (perhaps it is 
 corrupted).
  
 If the system detects failure to communicate with the external tax 
 calculator system, ...
  
 An alternate, but similar definition of a use case is provided by the RUP:
  
 A set of use-case instances, where each instance is a sequence of 
 actions a system performs that yields an observable result of 
 value to a particular actor [RUP].
  
 47",NA
6.4       Use Cases and Functional Requirements,"Use cases are requirements; primarily they are functional requirements that indicate 
 what the system will do. In terms of the FURPS+ requirements types, they emphasize 
 the ""F"" (functional or behavioral), but can also be used for other types, especially when 
 those other types strongly relate to a use case. In the UP—and most modern methods—
 use cases are the central mechanism that is recommended for their discovery and 
 definition. Use cases define a promise or contract of how a system will behave.
  
 To be clear: Use cases 
 are 
 requirements (although not all requirements). Some think of 
 requirements only as ""the system shall do..."" function or feature lists. Not so, and a key 
 idea of use cases is to (usually) reduce the importance or use of detailed older-style 
 feature lists and rather, write use cases for the functional requirements. More on this 
 point in a later section.
  
 Use cases are text documents, not diagrams, and use-case modeling is primarily an act 
 of writing text, not drawing. However, the UML defines a use case dia-gram to 
 illustrate the names of use cases and actors, and their relationships.
  
 2. Originally from the aptly titled 
 Uses Cases: Requirements in Context 
 |GKOO| 
 (chapter title adapted with permission of the authors).
  
 48",NA
6.5       Use Case Types and Formats,NA,NA
Black-Box Use Cases and System Responsibilities,"Black-box use cases 
 are the most common and recommended kind; they do not 
 describe the internal workings of the system, its components, or design. Rather, the 
 system is described as having 
 responsibilities, 
 which is a common unifying 
 metaphorical 
 theme 
 in 
 object-oriented 
 thinking—software 
 elements 
 have 
 responsibilities and collaborate with other elements that have responsibilities.
  
 By defining system responsibilities with black-box use cases, it is possible to specify 
 what 
 the system must do (the functional requirements) without deciding 
 how 
 it will 
 do it (the design). Indeed, the definition of ""analysis"" versus ""design"" is sometimes 
 summarized as ""what"" versus ""how."" This is an important theme in good software 
 development: During requirements analysis avoid making ""how"" decisions, and 
 specify the external behavior for the system, as a black box. Later, during design, 
 create a solution that meets the specification.
  
 Black-box style
  
 Not
  
 The system records the sale.
  
 The system writes the sale to a data-
 base. ...or (even worse): 
  
 The system generates a SQL INSERT 
 statement for the sale...",NA
Formality Types,"Use cases are written in different formats, depending on need. In addition to the 
 black-box versus white-box 
 visibility 
 type, use cases are written in varying 
 degrees 
 of 
 formality:
  
 •
  
 brief
 —terse one-paragraph summary, usually of the main success scenario. 
  
 The prior 
 Process Sale 
 example was brief.
  
 •
  
 casual
 —informal paragraph format. Multiple paragraphs that cover vari 
  
 ous scenarios. The prior 
 Handle Returns 
 example was casual.
  
 •
  
 fully dressed
 —the most elaborate. All steps and variations are written in 
  
 detail, and there are supporting sections, such as preconditions and success 
 guarantees.
  
 The following example is a fully dressed case for our NextGen case study.
  
 49",NA
6.6       Fully Dressed Example: Process Sale,"Fully dressed use cases show more detail and are structured; they are useful in order to 
 obtain a deep understanding of the goals, tasks, and requirements. In the NextGen POS 
 case study, they would be created during one of the early requirements workshops in a 
 collaboration of the system analyst, subject matter experts, and developers.",NA
The usecases.org Format,"Various format templates re available for fully dressed use cases. However, per-haps 
 the most widely used and shared format is the template available at www.usecases.org. 
 The following example illustrates this style.
  
 Please note that this is the book's primary case study example of a detailed use case; it 
 shows many common elements and issues.
  
 Use Case UC1: Process Sale
  
 Primary Actor: 
 Cashier 
  
 Stakeholders and Interests:
  
 - Cashier: Wants accurate, fast entry, and no payment errors, as cash drawer short 
  
 ages are deducted from his/her salary. 
  
 - Salesperson: Wants sales commissions updated. 
  
 - Customer: Wants purchase and fast service with minimal effort. Wants proof of pur 
  
 chase to support returns. 
  
 - Company: Wants to accurately record transactions and satisfy customer interests. 
  
 Wants to ensure that Payment Authorization Service payment receivables are 
 recorded. Wants some fault tolerance to allow sales capture even if server compo 
 nents (e.g., remote credit validation) are unavailable. Wants automatic and fast 
 update of accounting and inventory. 
  
 - Government Tax Agencies: Want to collect tax from every sale. May be multiple 
 agen 
  
 cies, such as national, state, and county. 
  
 - Payment Authorization Service: Wants to receive digital authorization requests in the 
 correct format and protocol. Wants to accurately account for their payables to the 
 store. 
  
 Preconditions: 
 Cashier is identified and authenticated.
  
 Success Guarantee (Postconditions): 
 Sale is saved. Tax is correctly calculated. 
 Accounting and Inventory are updated. Commissions recorded. Receipt is generated. 
 Payment authorization approvals are recorded.
  
 Main Success Scenario (or Basic Flow): 
  
 1. Customer arrives at POS checkout with goods and/or services to purchase. 
 2. Cashier starts a new sale. 
  
 3. Cashier enters item identifier. 
  
 4. System records sale line item and presents item description, price, and running 
 total. Price calculated from a set of price rules. 
  
 Cashier repeats steps 3-4 until indicates done.
  
 50",NA
The Two-Column Variation,"Some prefer the two-column or conversational format, which emphasizes the fact that 
 there is an interaction going on between the actors and the system. It was first proposed 
 by Rebecca Wirfs-Brock in [Wirfs-Brock93], and is also pro-moted by Constantine and 
 Lockwood to aid usability analysis and engineering [CL99]. Here is the same content 
 using the two-column format:
  
 Use Case UC1: Process Sale
  
 Primary Actor: ... 
  
 ... as before ...
  
 Main Success Scenario:
  
 Actor Action (or Intention)
  
 System Responsibility
  
 1. Customer arrives at a POS checkout 
  
 with goods and/or services to 
  
 purchase. 
  
 2. Cashier starts a new sale. 
  
 3. Cashier enters item identifier. 
  
 4. Records each sale line item and pre 
  
 sents item description and running 
  
 total. 
  
 Cashier repeats steps 3-4 until indi-
 cates done.
  
 5. System presents total with taxes 
  
 calculated. 
  
 6. Cashier tells Customer the total, and 
  
  
 asks for payment. 
  
 7. Customer pays. 
  
 8. Handles payment.
  
  
 53",NA
The Best Format?,"There isn't one best format; some prefer the one-column style, some the two-col-
 umn. Sections may be added and removed; heading names may change. None of 
 this is particularly important; the key thing is to write the details of the main 
 success scenario and its extensions, in some form. [Cockburnl] summarizes many 
 usable formats.
  
 Personal Practice
  
 This is my practice, not a recommendation. For some years, I used the two-
 column format because of its clear visual separation in the conversation. 
 However, I have reverted to a one-column style as it is more compact and 
 easier to format, and the slight value of the visually separated conversation does 
 not for me outweigh these benefits. I find it still simple to visually iden-tify the 
 different parties in the conversation (Customer, System, ...) if each party and 
 the System responses are usually allocated to their own steps.",NA
6.7       Explaining the Sections,NA,NA
Preface Elements,"Many optional preface elements are possible. Only place elements at the start 
 which are important to read before the main success scenario. Move extraneous 
 ""header"" material to the end of the use case.
  
 Primary Actor: 
 The principal actor that calls upon system services to fulfill a goal.",NA
Important: Stakeholders and Interests List,"This list is more important and practical than may appear at first glance. It sug-
 gests and bounds what the system must do. To quote:
  
 54",NA
Preconditions and Success Guarantees (Postconditions),"Preconditions 
 state what 
 must always 
 be true before beginning a scenario in the use 
 case. Preconditions are 
 not 
 tested within the use case; rather, they are conditions that are 
 assumed to be true. Typically, a precondition implies a sce-nario of another use case that 
 has successfully completed, such as logging in, or the more general ""cashier is identified 
 and authenticated."" Note that there are conditions that must be true, but are not of 
 practical value to write, such as ""the system has power."" Preconditions communicate 
 noteworthy assumptions that the use case writer thinks readers should be alerted to.
  
 Success guarantees 
 (or 
 postconditions) 
 state what must be true on success-ful 
 completion of the use case—either the main success scenario or some alter-nate path. 
 The guarantee should meet the needs of all stakeholders.
  
 Preconditions: 
 Cashier is identified and authenticated.
  
 Success Guarantee (Postconditions): 
 Sale is saved. Tax is correctly calculated. 
 Accounting and Inventory are updated. Commissions recorded. Receipt is generated.",NA
Main Success Scenario and Steps (or Basic Flow),"This has also been called the ""happy path"" scenario, or the more prosaic ""Basic Flow."" 
 It describes the typical success path that satisfies the interests of the
  
 55",NA
Extensions (or Alternate Flows),"Extensions are very important. They indicate all the other scenarios or branches, 
 both success and failure. Observe in the fully dressed example that the Extensions 
 section was considerably longer and more complex than the Main Success 
 Scenario section; this is common and to be expected. They are also known as 
 ""Alternative Flows.""
  
 In thorough use case writing, the combination of the happy path and extension 
 scenarios should satisfy ""nearly"" all the interests of the stakeholders. This point is 
 qualified, because some interests may best be captured as non-functional
  
 3. Note that the system under discussion itself should be considered an actor when it plays 
  
 an actor role collaborating with other systems.
  
 56",NA
Special Requirements,"If a non-functional requirement, quality attribute, or constraint relates specifi-
 cally to a use case, record it with the use case. These include qualities such as 
 performance, reliability, and usability, and design constraints (often in I/O 
 devices) that have been mandated or considered likely.
  
 Special Requirements:
  
 - Touch screen Ul on a large flat panel monitor. Text must be visible from 1 meter.- 
 Credit authorization response within 30 seconds 90% of the time. 
  
 - Language internationalization on the text displayed. 
  
 - Pluggable business rules to be insertable at steps 2 and 6. 
  
 Recording these with the use case is classic UP advice, and a reasonable location 
 when first writing the use case. However, many practitioners find it useful to 
 ultimately consolidate all non-functional requirements in the Supplementary 
 Specification, for content management, comprehension, and readability, because 
 these requirements usually have to be considered as a whole during architec-tural 
 analysis.",NA
Technology and Data Variations List,"Often there are technical variations in 
 how 
 something must be done, but not what, 
 and it is noteworthy to record this in the use case. A common example is a
  
 58",NA
6.8       Goals and Scope of a Use Case,"How should use cases be discovered? It is common to be unsure if something is a valid 
 (or more practically, a useful) use case. Tasks can be grouped at many lev-els of 
 granularity, from one or a few small steps, up to enterprise-level activities.
  
 At what level and scope should use cases be expressed?
  
 The following sections examine the simple ideas of elementary business pro-cesses and 
 goals as a framework for identifying the use cases for an application.",NA
Use Cases for Elementary Business Processes,"Which of these is a valid use case?
  
 •
  
 •
  
 •
  
 Negotiate a Supplier Contract 
 Handle Returns 
  
 Log In 
  
 59",NA
Use Cases and Goals,"Actors have goals (or needs) and use applications to help satisfy them. Conse-
 quently, an EBP-level use case is called a 
 user 
 goal-level user case, to empha-size 
 that it serves (or should serve) to fulfill a goal of a user of the system, or the 
 primary actor.
  
 And it leads to a recommended procedure:
  
 1.Find the user goals. 
  
 2.Define a use case for each. 
  
 This is slight shift in emphasis for the use-case modeler. Rather than asking 
 ""What are the use cases?"", one starts by asking: ""What are your goals?"" In fact, 
 the name of a use case for a user goal should reflect its name, to emphasize this 
 viewpoint—Goal: capture or process a sale; use case: 
 Process Sale.
  
 Note that because of this symmetry, the EBP guideline can be equally applied to 
 decide if a goal or a use case is at a suitable level.
  
 Thus, here is a key idea regarding investigating user goals vs. investigating use 
 cases:
  
 Imagine we are together in a requirements workshop. We could ask either:
  
 •
  
 •
  
 ""What do you do?"" (roughly a use case-oriented question) or, 
 ""What are your goals?"" 
  
 Answers to the first question are more likely to reflect current solutions and 
 procedures, and the complications associated with them.
  
 Answers to the second question, especially combined with an investigation to 
 move higher up the goal hierarchy (""what is the goal of that goal?"") open up 
 the vision for new and improved solutions, focus on adding business value, 
 and get to the heart of what the stakeholders want from the system under 
 discussion.
  
 61",NA
Example: Applying the EBP Guideline,"As the system analyst responsible for the NextGen system requirements discov-ery, you 
 are investigating user goals. The conversation goes like this: During a requirements 
 workshop:
  
 System analyst: 
 ""What are some of your goals in the context of using a POS 
 system?"" 
  
 Cashier: 
 ""One, to quickly log in. Also, to capture sales."" 
  
 System analyst: 
 ""What do you think is the higher level goal motivating log-ging in?"" 
  
 Cashier: 
 ""I'm trying to identify myself to the system, so it can validate that I'm 
 allowed to use the system for sales capture and other tasks."" 
 System analyst: 
 ""Higher 
 than that?"" 
  
 Cashier: 
 ""To prevent theft, data corruption, and display of private company 
 information.""
  
 Note the analyst's strategy of searching up the goal hierarchy to find higher level user 
 goals that still satisfy the EBP guideline, to get at the real intent behind the action, and 
 also to understand the context of the goals.
  
 ""Prevent theft, ..."" is higher than a user goal; it may be called an enterprise goal, and is 
 not an EBP. Therefore, although it can inspire new ways of thinking about the problem 
 and solutions (such as eliminating POS systems and cashiers completely), we will set it 
 aside for now.
  
 Lowering the goal level to ""identify myself and be validated"" appears closer to the user 
 goal level. But is it at the EBP level? It does not add observable or mea-surable 
 business value. If the CEO asked, ""What did you do today?"" and you said ""I logged in 
 20 times!"", she would not be impressed. Consequently, this is a secondary goal, always 
 in the service of doing something useful, and is not an EBP or user goal. By contrast, 
 ""capture a sale"" does fit the criteria of being an EBP or user goal.
  
 As another example, in some stores there is a process called ""cashing in"", in which a 
 cashier inserts their own cash drawer tray into the terminal, logs in, and tells the system 
 how much cash is in drawer. 
 Cashing In 
 is an EBP-level (or user goal level) use case; 
 the log in step, rather than being a EBP-level use case, is a subfunction goal in support 
 of the goal of cashing in.",NA
Subfunction Goals and Use Cases,"Although ""identify myself and be validated"" (or ""log in"") has been eliminated as a user 
 goal, it is a goal at a lower level, called a 
 subfunction goal
 —subgoals that support a 
 user goal. Use cases should only occasionally be written for these subfunction goals, 
 although it is a common problem that use case experts observe when asked to evaluate 
 and improve (usually simplify) a set of use cases.
  
 62",NA
Goals and Use Cases Can Be Composite,"Goals are usually composite, from the level of an enterprise (""be profitable""), to 
 many supporting intermediate goals while using applications (""sales are cap-
 tured""), to supporting subfunction goals within applications (""input is valid"").
  
 Similarly, use cases can be written at different levels to satisfy these goals, and 
 can be composed of lower level use cases.
  
 These varying goal and use case levels are a common source of confusion in 
 identifying the appropriate level of use cases for an application. The EBP 
 guideline provides guidance to filter out excessive low-level use cases.",NA
"6.9       Finding Primary Actors, Goals, and Use Cases","Use cases are defined to satisfy the user goals of the primary actors. Hence, the 
 basic procedure is:
  
 1.Choose the system boundary. Is it just a software application, the hardware and 
 application as a unit, that plus a person using it, or an entire organiza tion? 
  
 2.Identify the primary actors—those that have user goals fulfilled through 
  
 using services of the system. 
  
 3.For each, identify their user goals. Raise them to the highest user goal level 
  
 that satisfies the EBP guideline. 
  
 4.Define use cases that satisfy user goals; name them according to their goal. 
 Usually, user goal-level use cases will be one-to-one with user goals, but 
 there is at least one exception, as will be examined. 
  
 63",NA
Step 1: Choosing the System Boundary,"For this case study, the POS system itself is the system under design; every-
 thing outside of it is outside the system boundary, including the cashier, pay-
 ment authorization service, and so on.
  
 If it is not clear, defining the boundary of the system under design can be clari-
 fied by defining what is outside—the external primary and supporting actors. 
 Once the external actors are identified, the boundary becomes clearer. For 
 example, is the complete responsibility for payment authorization within the 
 system boundary? No, there is an external payment authorization service actor.",NA
Steps 2 and 3: Finding Primary Actors and Goals,"It is artificial to strictly linearize the identification of primary actors before user 
 goals; in a requirements workshop, people brainstorm and generate a mixture of 
 both. Sometimes, goals reveal the actors, or vice versa.
  
 Guideline: Emphasize brainstorming the primary actors first, as this sets up the 
 framework for further investigation.
  
 Reminder Questions to Find Actors and Goals
  
 In addition to obvious primary actors and user goals, the following questions help 
 identify others that may be missed:
  
 Who starts and stops the system? 
 Who does user and security 
  
 management?
  
 Is there a monitoring process that 
 restarts the system if it fails?
  
 How are software updates handled? 
 Push or pull update?
  
 Who does system administration?
  
 Is ""time"" an actor because the sys-
 tem does something in response to a 
 time event?
  
 Who evaluates system activity or 
 performance?
  
 Who evaluates logs? Are they 
 remotely retrieved?
  
 Primary and Supporting Actors
  
 Recall that primary actors have user goals fulfilled through using services of the 
 system. They call upon the system to help them. This is in contrast to 
 support-ing 
 actors, 
 which provide services to the system under design. For now, the focus is 
 on finding the primary actors, not the supporting ones.
  
 64",NA
Step ,NA,NA
4: Define Use Cases,"In general, define one EBP-level use case for each user goal. Name the use case similar 
 to the user goal—for example, Goal: process a sale; Use Case: 
 Process Sale.
  
 Also, name use cases starting with a verb.
  
 A common exception to one use case per goal is to collapse CRUD (create, retrieve, 
 update, delete) separate goals into one CRUD use case, idiomatically called 
 Manage 
 <X>. 
 For example, the goals ""edit user,"" ""delete user,"" and so forth are all satisfied by 
 the 
 Manage Users 
 use case.
  
 ""Define use cases"" has several levels of effort, ranging from a few minutes to simply 
 record names, up to weeks to write fully dressed versions. The later UP process section 
 of this chapter puts this work—when and how much—in the context of iterative 
 development and the UP.",NA
"6.10     Congratulations: Use Cases Have Been Written, and Are ",NA,NA
Imperfect,NA,NA
The Need for Communication and Participation,"The NextGen POS team is writing use cases in multiple requirements work-shops over a 
 series of short development iterations, incrementally adding to the set, and refining and 
 adapting based on feedback. Subject matter experts, cash-iers, and programmers actively 
 participate in the writing process. There are no intermediaries between the cashiers, 
 other users, and the developers; rather, there is direct communication.
  
 Good, but not good enough. Written requirement specifications give the illusion of 
 correctness; they are not. The use cases and other requirements still will not be 
 correct—guaranteed. They will lack critical information and contain wrong
  
 67",NA
6.11     Write Use Cases in an Essential Ill-Free Style ,NA,NA
New and Improved! The Case for Fingerprinting,"Investigating and asking about goals rather than tasks and procedures encour-
 ages a focus on the essence of the requirements—the intent behind them. For 
 example, during a requirements workshop, the cashier may say one of his goals 
 is to ""log in."" The cashier was probably thinking of a GUI, dialog box, user ID, 
 and password. This is a mechanism to achieve a goal, rather than the goal itself. 
 By investigating up the goal hierarchy (""What is the goal of that goal?""), the sys-
 tem analyst arrives at a mechanism-independent goal: ""identify myself and get 
 authenticated,"" or an even higher goal: ""prevent theft ..."".
  
 This discovery process can open up the vision to new and improved solutions. 
 For example, keyboards and mice with biometric readers, usually for a finger-
 print, are now common and inexpensive. If the goal is ""identification and 
 authentication"" why not make it easy and fast, using a biometric reader on the 
 keyboard? But properly answering that question involves some usability analy-
 sis work as well, such as knowing the typical users' profiles. Are their fingers 
 covered in grease? Do they have fingers?",NA
Essential Style Writing,"This idea has been summarized in various use case guidelines as ""keep the user 
 interface out; focus on intent"" [Cockburn0l]. Its motivation and notation has been 
 most fully explored by Larry Constantine in the context of creating better user 
 interfaces (UIs) and doing usability engineering [Constantine94, CL99]. 
 Constantine calls the writing style 
 essential 
 when it avoids UI details and 
 focuses on the real user intent.
 5
  
 5. The term comes from ""essential models"" in 
 Essential Systems Analysis 
 |MP84|.
  
 68",NA
Contrasting Examples,"Essential Style
  
 Assume that the 
 Manage Users 
 use case requires identification and authentica-
 tion. The Constantine-inspired essential style uses the two-column format. 
 However, it can be written in one column.
  
  
 Actor Intention 
  
 1. Administrator identifies self. 
  
 System Responsibility 
 2. Authenticates identity.
  
 3. . . .
  
 In the one-column format this is shown as:
  
 1. Administrator identifies self. 
  
 2. System authenticates identity. 
  
 3. ... 
  
 The design solution to these intentions and responsibilities is wide open: 
 bio-metric readers, graphical user interfaces (GUIs), and so forth.
  
 Concrete Style—Avoid During Early Requirements Work
  
 In contrast, there is a 
 concrete use case 
 style. In this style, user interface deci-
 sions are embedded in the use case text. The text may even show window screen
  
 69",NA
6.12 ,NA,NA
Actors,"An actor is anything with behavior, including the system under discussion (SuD) 
 itself when it calls upon the services of other systems.
 6
  Primary and supporting 
 actors will appear in the action steps of the use case text. Actors are not only 
 roles played by people, but organizations, software, and machines. There are 
 three kinds of external actors in relation to the SuD:
  
 • 
  
 Primary actor
 —has user goals fulfilled through using services of the SuD. 
 For example, the cashier.
  
 )
      Why identify? To find user goals, which drive the use cases.
  
 • 
  
 Supporting actor
 —provides a service (for example, information) to the 
 SuD. The automated payment authorization service is an example. Often a 
 computer system, but could be an organization or person.
  
 )
     Why identify? To clarify external interfaces and protocols.
  
 • 
  
 Offstage actor
 —has an interest in the behavior of the use case, but is not 
 primary or supporting; for example, a government tax agency.
  
 )
    Why identify? To ensure that 
 all 
 necessary interests are identified 
 and satisfied. Offstage actor interests are sometimes subtle or easy 
 to miss unless these actors are explicitly named.
  
 6. This was a refinement and improvement to alternate definitions of actors, including 
 those in early versions of the UML and UP [Cockburn97]. Older definitions 
 inconsis-tently excluded the SuD as an actor, even when it called upon services of 
 other sys-tems. All entities may play multiple 
 roles, 
 including the SuD.
  
 70",NA
6.13     Use Case Diagrams,"The UML provides use case diagram notation to illustrate the names of use cases can 
 actors, and the relationships between them ( see Figure 6.2) 
  
 system boundary
  
 NextGen
  
 communication
  
 alternate
  
 Process Sale
  
 notation for
  
 Cashier
  
 Handle Returns
  
 Payment
  
 a computer
  
 system actor
  
 Authorization
  
 Service
  
 actor
  
 Process Rental
  
 «actor»
  
 Tax Calculator
  
 «actor»
  
 Cash In
  
 «actor»
  
 Accounting
  
 System
  
 Sales Activity
  
 System
  
 Analyze Activity
  
 «actor»
  
 HR System
  
 Manage Security
  
 System
  
 Manage Users
  
 use case
  
 Administrator
  
 . . .
  
 Figure 6.2 Partial use case context diagram.
  
 Use case diagrams and use case relationships are secondary in use case work. 
 Use cases are text documents. Doing use case work means to write text.
  
 A common sign of a novice (or academic) use-case modeler is a preoccupation 
 with use case diagrams and use case relationships, rather than writing text. World-
 class use case experts such as Anderson, Fowler, Cockburn, among oth-ers, 
 downplay use case diagrams and use case relationships, and instead focus on 
 writing. With that as a caveat, a simple use case diagram provides a succinct
  
 71",NA
Diagramming Suggestions,"Figure 6.3 offers some diagram advice. Notice the actor box with the symbol «actor». 
 This symbol is called a UML 
 stereotype; 
 it is a mechanism to catego-rize an element 
 in some way. A stereotype name is surrounded by guillemets symbols—special single-
 character brackets (not ""«"" and ""»"" ) most widely known by their use in French 
 typography to indicate a quote.
  
 For a use case context 
  
 diagram, limit the use cases to 
  
 user-goal level use cases.
  
 NextGen
  
 Process Sale
  
 «actor»
  
 Payment
  
  
 Authorization 
  
  
 Service 
 Cashier
  
 . . .
  
 primary actors on 
  
 supporting actors 
  
 the left 
  
 on the right
  
 Figure 6.3 Notation suggestions.",NA
A Caution on Over-Diagramming,"To reiterate, the important use case work is to write text, not diagram or focus on use 
 case relationships. If an organization is spending many hours (or worse, days) 
 working on a use case diagram and discussing use case relationships, rather than 
 focussing on writing text, relative effort has been misplaced.",NA
6.14     Requirements in Context and Low-Level Feature Lists,"As implied by the title of the book 
 Uses Cases: Requirements in Context 
 [GK00], a 
 key motivation of the use case idea is the consideration and organization of 
 requirements in the context of the goals and scenarios of using a system. That's a 
 good thing—it improves cohesion and comprehension. However, use cases are not 
 the only necessary requirements artifact. Some non-functional require-ments, domain 
 rules and context, and other hard-to-place elements are better captured in the 
 Supplementary Specification, which is described in the next chapter.
  
 One idea behind use cases is to replace detailed, low-level feature lists (which were 
 common in traditional requirements methods) with use cases (with some exceptions). 
 These lists tended to look as follows, usually grouped into func-tional areas:
  
 ID
  
 Feature
  
 FEAT1 .9
  
 The system shall accept entry of item identifiers.
  
 73",NA
High-Level System Feature Lists Are Acceptable,"It is common and useful to summarize system functionality with a terse, high-level 
 feature list called system features in a Vision document. In contrast to 100 pages of 
 low-level, detailed features, a system features list tends to include only a few dozen 
 items. The list provides a very succinct summary of system functionality, independent 
 of the use case view. For example:
  
 Summary of System Features
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 sales capture 
  
 payment authorization (credit, debit, check) 
  
 system administration for users, security, code and constants tables, and so on 
  
 automatic offline sales processing when external components fail 
  
 real-time transactions, based on industry standards, with third-party systems, including inventory, 
  
 accounting, human resources, tax calculators, and payment authorization services 
  
 • 
  
 definition and execution of customized ""pluggable"" business rules at fixed, common points in the 
  
 processing scenarios 
  
 •   …
  
 This is explored in the next chapter.
  
 74",NA
When Are Detailed Feature Lists Appropriate?,"Sometimes use cases do not really fit; some applications call out for a feature-
 driven viewpoint. For example, application servers, database products, and other 
 middleware or back-end systems need to be primarily considered and evolved in 
 terms 
 of features 
 (""We need XML support in the next release""). Use cases are not 
 a natural fit for these applications or the way they need to evolve in terms of 
 market forces.",NA
6.15     Use Cases Are Not Object-Oriented,"There is nothing object-oriented about use cases; one is not doing object-oriented 
 analysis if writing use cases. This is not a defect, but a point of clarification. 
 Indeed, use cases are a broadly applicable requirements analysis tool that can be 
 applied to non-object-oriented projects, which increases their usefulness as a 
 requirements method. However, as will be explored, use cases are a pivotal input 
 into classic OOA/D activities.",NA
6.16     Use Cases Within the UP,"Use cases are vital and central to the UP, which encourages 
 use-case driven 
 development. 
 This implies:
  
 •
  
 •
  
 •
  
 •
  
 Requirements are primarily recorded in use cases (the Use-Case Model); 
 other requirements techniques (such as functions lists) are secondary, if used 
 at all. 
  
 Use cases are an important part of iterative planning. The work of an itera tion 
 is—in part—defined by choosing some use case scenarios, or entire use cases. 
 And use cases are a key input to estimation. 
  
 Use-case realizations 
 drive the design. That is, the team designs collabo 
 rating objects and subsystems in order to perform or realize the use cases.
  
 Use cases often influence the organization of user manuals. 
  
 The UP distinguishes between system and business use cases. 
 System use cases 
 are what have been examined in this chapter, such as 
 Process Sale. 
 They are 
 created in the Requirements discipline, and are part of the Use-Case Model.
  
 Business use cases 
 are less commonly written. If done, they are created in the 
 Business Modeling discipline as part of a large-scale business process reengi-
 neering effort, or to help understand the context of a new system in the busi-ness. 
 They describe a sequence of actions of a business as a whole to fulfill a goal of a 
 business actor 
 (an actor in the business environment, such as a customer or 
 supplier). For example, in a restaurant, one business use case is 
 Serve a Meal.
  
 75",NA
Use Cases and Requirements Specification Across the Iterations,"This section reiterates a key idea in the UP and iterative development: The tim-ing 
 and level of effort of requirements specification across the iterations. Table 6.1 
 presents a sample (not a recipe) which communicates the UP strategy of how 
 requirements are developed.
  
 Note that a technical team starts building the production core of the system when 
 only perhaps 10% of the requirements are detailed, and in fact, there is a deliberate 
 delay in continuing with concerted requirements work until near the end of the first 
 elaboration iteration.
  
 This is the key difference in iterative development to a waterfall process: Pro-
 duction-quality development of the core of a system starts quickly, long before all 
 the requirements are known.
  
 Discipline
  
 Artifact
  
  
 Co Incep 
  
 1 week
  
 mments and L 
  
  
 Elab 1 
  
  
 4 weeks
  
 evel of Requi 
  
 Elab 2 
  
  
 4 weeks
  
 rements Effor 
  
 Elab 3 
  
 3 weeks
  
 t 
  
  
 Elab 4 
 3 weeks
  
 Requirements
  
 Use-
 Case 
 Model
  
 2-day require-
  
 ments work-
  
 shop. Most use 
  
 cases identified by 
 name, and 
  
 summarized in a 
 short paragraph. 
 Only 
 10% 
 writ-
 ten in detail.
  
 Near the end of 
 this iteration, 
  
 host a 2-day 
  
 requirements 
  
 workshop.
  
 Obtain insight 
  
 and feedback 
  
 from the imple-
 mentation work, 
 then complete 
  
 30% of the use 
  
 cases in detail.
  
 Near the end of 
 this iteration, 
  
 host a 2-day 
  
 requirements 
  
 workshop.
  
 Obtain insight 
  
 and feedback 
  
 from the imple-
 mentation work, 
 then complete 
  
 50% of the use 
  
 cases in detail.
  
 Repeat, com-
  
 plete 707 of all 
 use cases in 
  
 detail.
  
 Repeal with the 
 goal of 80-90% of 
 the use cases 
  
 clarified and 
  
 written in detail. 
 Only a small por-
 tion of these 
  
 have been built 
  
 in elaboration; 
  
 the remainder 
  
 are done in con-
 struction.
  
 Design
  
 Design 
 Modelnone
  
 none
  
 Design for a 
  
 small set of high-
 risk architectur-
 ally significant 
  
 requirements.
  
 repeat
  
 repeat
  
 Repeat. The high 
 risk and archi-
  
 tecturally signifi-
 cant aspects 
  
 should now be 
  
 stabilized.
  
 Implementa-
 tion
  
 Implementa-
 tion Model 
  
 (code, etc.)
  
 none
  
 Implement these. 
  
 Repeat. 5% of the 
 final system is 
  
 built.
  
 Repeat. 10% of 
 the final system 
 is built.
  
 Repeat. 15% of 
 the final system 
 is built.
  
 Project Man-
 agement
  
 SW 
 Develop-
 ment Plan
  
 Very vague esti-
 mate of total 
  
 effort.
  
 Estimate starts 
 to take shape.
  
 a little better...
  
 a little bettor...
  
 Overall project 
  
 duration, major 
 milestones, 
  
 effort, and cost 
  
 estimates can 
  
 now be ralionally 
 committed to.
  
 Table 6.1 Sample requirements effort across the early iterations; this is not a 
 recipe.
  
 76",NA
Timing of UP Artifact Creation,"Table 6.2 illustrates some UP artifacts, and an example of their start and refine-ment 
 schedule. The Use-Case Model is started in inception, with perhaps only 10% of the use 
 cases written in any detail. The majority are incrementally writ-ten over the iterations of 
 the elaboration phase, so that by the end of elabora-tion, a large body of detailed use 
 cases and other requirements (in the Supplementary Specification) are written, 
 providing a realistic basis for estima-tion through to the end of the project.
  
 Discipline
  
 Artifact 
  
 Iteration->
  
 Incep. I1
  
 Elab.
  
 El. .En
  
 Const. 
 CL..Cn
  
 Trans. 
 T1..T2
  
 Business Modeling
  
 Domain Model
  
  
 s 
  
  
  
 Requirements
  
 Use-Case Model
  
 s 
  
 r 
  
  
  
 Vision
  
 s 
  
 r 
  
  
  
 Supplementary Specification
  
 s 
  
 r 
  
  
  
 Glossary
  
 s 
  
 r 
  
  
  
 Design
  
 Design Model
  
  
 s 
  
 r 
  
  
 SW Architecture Document
  
  
 s 
  
  
  
 Data Model
  
  
 s 
  
 r 
  
  
 Implementation
  
 Implementation Model
  
  
 s 
  
 r 
  
 r
  
 Project Management
  
 SW Development Plan
  
 s 
  
 r 
  
 r 
  
 r 
  
 Testing
  
 Test Model
  
  
 s 
  
 r 
  
  
 Environment
  
 Development Case
  
 s 
  
 r 
  
  
  
 Table 6.2 Sample UP artifacts and timing. s - start; r - refine",NA
Use Cases Within Inception,"The following discussion expands on the information in Table 6.1.
  
 Not all use cases are written in their fully dressed format during the inception phase. 
 Rather, suppose there is a two-day requirements workshop during the early NextGen 
 investigation. The earlier part of the day is spent identifying goals and stakeholders, 
 and speculating what is in and out of scope of the project. An actor-goal-use case table 
 is written and displayed with the computer projector. A use case context diagram is 
 started. After a few hours, perhaps 20 user goals (and thus, user goal level use cases) 
 are identified, including 
 Process
  
 77",NA
Use Cases Within Elaboration,"The following discussion expands on the information in Table 6.1.
  
 This is a phase of multiple timeboxed iterations (for example, four iterations) in which 
 risky, high-value, or architecturally significant parts of the system are incrementally 
 built, and the ""majority"" of requirements identified and clarified. The feedback from 
 the concrete steps of programming influences and informs the team's understanding of 
 the requirements, which are iteratively and adap-tively refined. Perhaps there is a two-
 day requirements workshop in each iteration—four workshops. However, not all use 
 cases are investigated in each workshop. They are prioritized; early workshops focus 
 on a subset of the most important use cases.
  
 Each subsequent short workshop is a time to adapt and refine the vision of the core 
 requirements, which will be unstable in early iterations, and stabilizing in later ones. 
 Thus, there is an iterative interplay between requirements discovery, and building parts 
 of the software.
  
 78",NA
Use Cases Within Construction,"The construction step is composed of timeboxed iterations (for example, 20 itera-tions 
 of two weeks each) that focus on completing the system, once the risky and core 
 unstable issues have settled down in elaboration. There will still be some minor use 
 case writing and perhaps requirements workshops, but much less so than in elaboration. 
 By this step, the majority of core functional and non-func-tional requirements should 
 have iteratively and adaptively stabilized. That does not mean to imply requirements are 
 frozen or investigation finished, but the degree of change is much lower.",NA
6.17     Case Study: Use Cases in the NextGen Inception Phase,"As described in the previous section, not all use cases are written in their fully dressed 
 form during inception. The Use-Case Model at this phase of the case study could be 
 detailed as follows:
  
 Fully Dressed
  
 Casual
  
 Brief
  
 Process Sale 
  
 Handle Returns
  
 Process Rental 
  
 Analyze Sales Activity 
 Manage Security
  
 … 
  
 Cash In 
  
 Cash Out 
  
 Manage Users 
  
 Start Up 
  
 Shut Down 
  
 Manage System 
 Tables
 …",NA
6.18     Further Readings,"The most popular use-case guide, translated into several languages, is 
 Writing Effective 
 Use Cases 
 [Cockburn0l].
 7
  This has emerged with good reason as the
  
 79",NA
6.19     UP Artifacts and Process Context ,"As 
 illustrated in Figure 6.5, use cases influence many UP artifacts.
  
  
 Figure 6.5 Sample UP artifact influence.
  
 81",NA
Chapter 7,NA,NA
IDENTIFYING OTHER ,NA,NA
REQUIREMENTS,"When ideas fail, words come in very handy. 
  
 —
 Johann Wolfgang von Goethe",NA
Objectives,"Write a Supplementary Specification, Glossary, and Vision. 
  
 Compare and contrast system features with use cases. Relate the 
  
 Vision to other artifacts, and to iterative development. Define 
  
 quality attributes.",NA
Introduction,"It is not sufficient to write use cases. There are other kinds of requirements that 
 need to be identified, such as documentation, packaging, supportability, licens-
 ing, and so forth. These are captured in the 
 Supplementary Specification.
  
 The 
 Glossary 
 captures terms and definitions; it can also play the role of a data 
 dictionary.
  
 The Vision 
 summarizes the ""vision"" of the project. It serves to tersely communi-
 cate the big ideas regarding why the project was proposed, what the problems are, 
 who the stakeholders are, what they need, and what the proposed solution looks 
 like.
  
 To quote:
  
 The Vision defines the stakeholders' view of the product to be 
 developed, specified in terms of the stakeholders' key needs and
  
 83",NA
7.1        NextGen POS Examples,"The purpose of the following examples is not to present an exhaustive Vision, 
 Glossary, or Supplementary Specification, as some of the sections—although 
 useful for a project—are not relevant to the learning objectives.
 1
  The book's goal 
 is core skills in object design, use case requirements analysis, and object-ori-
 ented analysis, not POS problems or Vision statements. Therefore, only some 
 sections are briefly touched upon in order to make connections between prior and 
 future work, highlight noteworthy issues, provide a feel for the contents, and 
 move forward quickly.",NA
7.2       NextGen Example: (Partial) Supplementary Specification,"Supplementary Specification
  
 Revision History
  
 Version
  
 Date
  
 Description
  
 Author
  
 Inception draft
  
 Jan 10, 2031
  
 First draft. To be refined primarily during elabora-
 tion.
  
 Craig Larman
  
  
  
  
  
 Introduction
  
 This document is the repository of all NextGen POS requirements not captured in the use cases.
  
 Functionality
  
 (Functionality common across many use cases) 
  
 Logging and Error Handling 
 Log all errors to 
  
 persistent storage. 
 Pluggable Business Rules
  
 At various scenario points of several use cases (to be defined) support the ability to customize the func-
  
 tionality of the system with a set of arbitrary rules that execute at that point or event.
  
 Security
  
 All usage requires user authentication.
  
 1. Scope creep is not only a problem in requirements, but in 
 writing 
 about requirements.
  
 84",NA
7.3       Commentary: Supplementary Specification,"The Supplementary Specification 
 captures other requirements, information, and 
 constraints not easily captured in the use cases or Glossary, including sys-tem-wide 
 ""URPS+"" quality attributes or requirements. Note that requirements specific to a use 
 case can (and probably should) be first written with the use case, in a 
 Special 
 Requirements 
 section, but some prefer to also consolidate all of them in the 
 Supplementary Specification.. Elements of the Supplementary Specification could 
 include:
  
 •FURPS+  requirements—functionality,  usability,  reliability, 
 performance, 
  
 and supportability 
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 reports 
  
 hardware and software constraints (operating and networking systems, ...) 
 development constraints (for example, process or development tools) other design 
 and implementation constraints 
  
 internationalization concerns (units, languages, ...) 
  
 documentation (user, installation, administration) and help 
  
 licensing and other legal concerns 
  
 packaging 
  
 standards (technical, safety, quality) 
  
 physical environment concerns (for example, heat or vibration) 
  
 operational concerns (for example, how do errors get handled, or how often 
  
 to do backups?) 
  
 •
  
 •
  
 domain or business rules 
  
 information in domains of interest (for example, what is the entire cycle of 
  
 credit payment handling?) 
  
 Constraints 
 are not behaviors, but some other kind of restriction on the design 
  
 or project. They are also requirements, but are commonly called ""constraints"" to 
  
 emphasize their 
 restrictive 
 influence. For example:
  
 Must use Oracle (we have a licensing arrangement with them). 
  
 Must run on Linux (it will lower cost).
  
 88",NA
Quality Attributes,"Some requirements are called 
 quality attributes 
 [BCK98] (or ""-ilities"") of a system. 
 These include usability, reliability, and so forth. Note that these refer to the qualities of 
 the system, not that these attributes are necessarily of high quality (the word is 
 overloaded in English). For example, the quality of support-ability might deliberately 
 be chosen to be low if the product is not intended to serve a long-term purpose.
  
 They are of two types:
  
 1.
  
 Observable at execution (functionality, usability, reliability, performance, ...) 
  
 2.Not observable at execution (supportability, testability, ...) 
  
 Functionality is specified in the use cases, as are other quality attributes related to 
 specific use cases (for example, the performance qualities in the 
 Process Sale 
 use 
 case).
  
 Other system-wide FURPS+ quality attributes are described in the Supplemen-tary 
 Specification.
  
 Although functionality is a valid quality attribute, in common usage, the term ""quality 
 attribute"" is most often meant to imply ""qualities of the system other than 
 functionality."" Herein, the term is likewise used. This is not exactly the same as non-
 functional requirements, which is a broader term including 
 every-thing 
 but functionality 
 (for example, packaging and licensing).
  
 When we put on our ""architect hat,"" the system-wide quality attributes (and thus the 
 Supplementary Specification where one records them) are especially interesting 
 because—as will be introduced in Chapter 32—architectural analy-sis and design are 
 largely concerned with the identification and resolution of the quality attributes in the 
 context of the functional requirements. For example, suppose one of the quality 
 attributes is that the NextGen system must be quite fault-tolerant when remote services 
 fail. From an architectural viewpoint, that will have an overarching influence on large-
 scale design decisions.
  
 Quality attributes have interdependencies and involve trade-offs. As a simple example 
 in the POS, ""very reliable (fault-tolerant)"" and ""easy to test"" are in
  
 89",NA
Domain (Business) Rules,"Domain rules [Ross97, GK00] dictate how a domain or business may operate. 
 They are not requirements of any one application, although an application's 
 requirements are often by domain rules. Company policies, physical laws, and 
 government laws are common domain rules.
  
 They are commonly called 
 business rules, 
 which is the most common type, but 
 that term is limited, as some software applications are for non-business prob-
 lems, such as weather simulation or military logistics. A weather simulation has 
 ""domain rules"" that influence the application requirements, related to physical 
 laws and relationships.
  
 It is often useful to identify and record those domain rules that influence the 
 requirements, usually realized in the use cases, because they can clarify incom-
 plete or ambiguous use case content. For example, in the NextGen POS, if some-
 one asks if the 
 Process Sale 
 use case should be written with an alternative to 
 allow credit payments without signature capture, there is a business rule 
 (RULE1) that clarifies whether this will not be allowed by any credit authoriza-
 tion company.
  
 Caution 
  
 Rules are not application requirements. Do not record system features as rules. 
 They describe the constraints and behaviors of how the domain works, not the 
 application.",NA
Information in Domains of Interest,"It is often valuable for a subject matter expert to write (or provide URLs to) some 
 explanation of domains related to the new software system (sales and accounting, 
 the geophysics of underground oil/water/gas flows, ...), to provide context and 
 deeper insight for the development team. It may contain pointers to important 
 literature or experts, formulas, laws, or other references. For exam-ple, the arcana 
 of UPC and EAN coding schemes, and bar code symbology, must be understood 
 to some degree by the NextGen team.
  
 90",NA
7.4       NextGen Example: (Partial) Vision,"Vision
  
 Revision History
  
 Version
  
 Date
  
 Description
  
 Author
  
 inception draft
  
 Jan 10, 2031
  
 First draft. To be refined primarily during elabora-
 tion.
  
 Craig Larman
  
  
  
  
  
 Introduction
  
 The analysis in 
 this example is 
 illustrative, but 
 fictitious.
  
 We envision a next generation fault-tolerant point-of-sale (POS) application, NextGen POS, with the 
 flexibility to support varying customer business rules, multiple terminal and user interface 
 mechanisms, and integration with multiple third-party supporting systems.
  
 Positioning
  
 Business Opportunity
  
 Existing POS products are not adaptable to the customer's business, in terms of varying business 
 rules and varying network designs (for example, thin client or not; 2, 3, or 4 tier architectures). In 
 addition, they do not scale well as terminals and business increase. And, none can work in either on-
 line or off-line mode, dynamically adapting depending on failures. None easily integrate with many 
 third-party systems. None allow for new terminal technologies such as mobile PDAs. There is 
 marketplace dissatisfaction with this inflexible state of affairs, and demand for a POS that rectifies 
 this.
  
 Problem Statement
  
 Traditional POS systems are inflexible, fault intolerant, and difficult to integrate with third-party 
 systems. This leads to problems in timely sales processing, instituting improved processes that don't 
 match the software, and accurate and timely accounting and inventory data to support measurement 
 and planning, among other concerns. This affects cashiers, store managers, system administrators, 
 and corporate management.
  
 Product Position Statement
  
 —Terse 
 summary of who the system is for, its outstanding features, and what differentiates it from 
 the competition.
  
 Alternatives and Competition...
  
 Understand who 
  
 the players are, and 
 their problems.
  
 Stakeholder 
 Descriptions 
  
 Market Demographics...
  
 Stakeholder (Non-User) Summary... User Summary... 
  
 Key High-Level Goals and Problems of the Stakeholders
  
  91",NA
7.5       Commentary: Vision,NA,NA
Are We Solving the Same Problem? The Right Problem?,"The Problem Statement
  
 During early requirements work in the inception phase, collaborate to define a 
 terse problem statement; it will reduce the likelihood that stakeholders are try-ing 
 to solve slightly different problems, and is usually quickly created. Occasion-
  
 93",NA
System Features,NA,NA
—,NA,NA
Functional Requirements,"Use cases are not necessarily the only way one needs to express functional requirements 
 for the following reasons:
  
 •
  
 They are detailed. Stakeholders often want a short summary that identifies 
  
 the most noteworthy functions. 
  
 •
  
 What  about  simply  listing the  use  case  names  
 (Process  Sale, 
  
 Handle 
  
  
 Returns, 
 ...) to summarize the functionality? First, the list may still be too 
  
 long. Also, the names can hide interesting functionality stakeholders really 
  
 want to know about; that is, the level of granularity can obscure noteworthy 
  
 functions. For example, suppose that the description of automated payment 
  
 authorization functionality is embedded in the 
 Process Sale 
 use case. A 
  
 reader of 
 a list of use case names cannot tell if the system will do payment 
  
 authorization. 
 Furthermore, one may wish to group a set of use cases into 
  
 one feature (for brevity), 
 such as 
 System administration for users, security, 
  
 code and constants tables, and so 
 forth.
  
 •
  
 Some noteworthy functionality is naturally expressed as short statements 
  
 that do not conveniently map to use case names or Elementary Business 
  
 Process-
 level goals. It may span or be orthogonal to the use cases. For exam 
  
 ple, during the 
 first NextGen requirements workshop, someone might say 
  
 ""The system should be 
 able to do transactions with existing third-party 
  
 accounting, inventory, and tax 
 calculation systems."" This statement of func 
  
 tionality does not represent one 
 particular use case, but is a comfortable and 
  
 succinct way to express, record, 
 and communicate features. 
  
 )
  As a stronger variation of the last point, some applications call out 
 primarily for a description of functionality as features; use cases are not a 
 natural fit. This is common, for example, with middle-ware products 
 such as application servers—use cases are not really motivated. Suppose 
 the team is considering their next release. During a requirements 
 discussion, people (such as mar-keting) will say, ""The next version needs 
 EJB 2.0 entity bean sup-port."" The requirements are primarily conceived 
 in terms of a list of features, not use cases.
  
 Therefore, an alternative, a complementary way to express system functions is with 
 features, 
 or more specifically in this context, 
 system features, 
 which are high-level, 
 terse statements summarizing system functions. More formally, in
  
 95",NA
Notation and Organization,"First and foremost, short high-level descriptions are important. One should be 
 able to read the system features list quickly.
  
 It is not necessary to include the canonical ""The system shall do..."" or a variant 
 phrase, although it is common.
  
 Here is a features example at a high level, for a large multi-system project of 
 which the POS is just one element:
  
 96",NA
Other Requirements in the Vision,"In the Vision, system features briefly summarize functional requirements 
 expressed in detail in the use cases. Likewise, the Vision 
 can 
 summarize other 
 requirements (for example, reliability and usability) that are detailed in the 
 Special 
 Requirements 
 sections of use cases, and in the Supplementary Specifica-tion (SS). 
 However, there is some risk of unhelpful duplication. For example, the RUP 
 product provides templates for the Vision and SS that contain identical or similar 
 sections for other requirements such as usability, reliability, perfor-mance, and so 
 forth. Such duplication is inevitably awkward to maintain. Fur-
  
 97",NA
"Vision, Features, or Use Cases",NA,NA
—,NA,NA
Which First?,"It is not useful to be rigid about the order of some artifacts. While collaborating 
 to create different requirements artifacts, a synergy emerges in which working on 
 one influences and helps clarify another. Nevertheless, a suggested sequence is:
  
 1.Write a brief first draft of the Vision. 
  
 2.Identify user goals and the supporting use cases. 
  
 3.Write some use cases and start the Supplementary Specification. 
  
 4.Refine the Vision, summarizing information from these.",NA
7.6       NextGen Example: A (Partial) Glossary,"Glossary
  
 Revision History
  
 Version
  
 Date
  
 Description
  
 Author
  
 Inception draft
  
 Jan 10, 2031
  
 First draft. To be refined primarily during 
 elabora-tion.
  
 Craig Larman
  
  
  
  
  
 98",NA
7.7      Commentary: Glossary (Data Dictionary),"In its simplest form, the 
 Glossary 
 is a list of noteworthy terms and their defini-
 tions. It is surprisingly common that a term, often technical or particular to the 
 domain, will be used in slightly different ways by different stakeholders; this 
 needs to be resolved to reduce problems in communication and ambiguous 
 requirements.
  
 Suggestion
  
 Start the Glossary early. I'm reminded of an experience working with simu-
 lation experts, in which the seemingly innocuous, but important, word ""cell"" 
 was discovered to have slippery and varying meanings among the group 
 members.
  
 The goal is not to record all possible terms, but those that are unclear, ambigu-
 ous, or which require some kind of noteworthy elaboration, such as format infor-
 mation or validation rules.",NA
Glossary as Data Dictionary,"In the UP, the Glossary also plays the role of a 
 data dictionary, 
 a document that 
 records data about the data—that is, 
 metadata. 
 During inception the glos-sary 
 should be a simple document of terms and descriptions. During elabora-tion, it 
 may expand into a data dictionary.
  
 99",NA
Units,"As Martin Fowler underscores in 
 Analysis Patterns 
 [Fowler96], units (currency, 
 measures, ...) must be considered, especially in this age of internationalized soft-
 ware applications. For example, in the NextGen system, which will hopefully be 
 sold to many customers in different countries, 
 price 
 cannot be just a raw num-ber. 
 It must be in a 
 Money 
 or 
 Currency 
 unit that captures the notion of varying 
 currencies.",NA
Composite Terms,"The Glossary is not only for atomic terms such as ""product price."" It can and 
 should include composite elements such as ""sale"" (which includes other ele-
 ments, such as date and location), and nicknames used to describe a collection of 
 data transmitted between actors in the use cases. For example, in the 
 Process Sale 
 use case, consider the following statement:
  
 System sends payment authorization request to an external 
 Payment Authorization Service, and requests payment approval.
  
 ""Payment authorization request"" is a nickname for an aggregate of data, which 
 needs to be explained in the Glossary.",NA
7.8       Reliable Specifications: An Oxymoron?,"Written requirements can promote the illusion that the real requirements are 
 understood and well-defined, and can (early on) be used to reliably estimate and 
 plan the project. This illusion is more true for non-software developers; pro-
  
 100",NA
7.9       Online Artifacts at the Project Website,"Since this is a book, these examples and the preceding use cases have a static and 
 perhaps paper-oriented feel. Nevertheless, these should be digital artifacts 
 recorded only online at the project website. And instead of being plain static doc-
 uments, they may be hyperlinked, or recorded in tools other than a word proces-
 sor or spreadsheet. For example, the Glossary could be stored in a database table.",NA
7.10     Not Much UML During Inception?,"The purpose of inception is to collect just enough information to establish a com-
 mon vision, decide if moving forward is feasible, and if the project is worth seri-
 ous investigation in the elaboration phase. As such, beyond simple UML use case 
 diagrams, not much diagramming is often motivated. There is more focus in 
 inception on understanding the basic scope and 10% of the requirements, 
 expressed in textual forms. In practice, and thus in this presentation, most UML 
 diagramming will occur in the next phase—elaboration.",NA
7.11     Other Requirement Artifacts Within the UP,"As in the prior use case chapter, Table 7.1 summarizes a sample of artifacts and 
 their timing. All requirements artifacts are started in inception, and primarily 
 worked on through elaboration.
  
 101",NA
Inception,"It should not be the case that these requirements artifacts are finalized in the inception 
 phase. Indeed, they will barely be started.
  
 Stakeholders need to decide if the project is worth serious investigation; that real 
 investigation occurs during elaboration, not inception. During inception, the Vision 
 summarizes the project idea in a form to help decision makers deter-mine if it is worth 
 continuing, and where to start.
  
 Since most requirements work occurs during elaboration, the Supplementary 
 Specification should be only lightly developed during inception, highlighting 
 noteworthy quality attributes (for example, the NextGen POS must have recov-erability 
 when external services fail) that expose major risks and challenges.
  
 Input into these artifacts could be generated during an inception phase require-ments 
 workshop, both through explicit consideration of its topics, and indirectly via use case 
 analysis. Draft, readable artifacts will not get written in the work-shop, but afterwards 
 by the system analyst.",NA
Elaboration,"Through the elaboration iterations, the ""vision"" and the Vision are refined, based upon 
 feedback from incrementally building parts of the system, adapting, and multiple 
 requirements workshops over several development iterations.
  
 Through ongoing requirements investigation and iterative development, the other 
 requirements will become more clear and can be recorded in the SS. The quality 
 attributes (for example, reliability) identified in the SS will be key driv-
  
 102",NA
Construction,"By construction, the major requirements—both functional and otherwise— should be 
 stabilized—not finalized, but settled down to minor pertubation. Therefore, the SS and 
 Vision are unlikely to experience much change in this phase.
  
 103",NA
7.12     Further Readings,"Vision and Supplementary Specification-like documents are not new. They are used 
 on many projects and described in many requirements books. Most such books 
 implicitly assume the waterfall attitude that the objective is to get them detailed and 
 correct at the beginning, and commit to them, before moving on to design and 
 implementation. In that sense, their traditional descriptions are not helpful, although 
 they otherwise provide good advice for possible sections and their content.
  
 Most books on software architecture include discussion of requirements analysis for 
 quality attributes of the application, since these quality requirements tend to strongly 
 influence architectural design. One example is 
 Software Architecture 
 in Practice 
 [BCK98].
  
 Business rules get an exhaustive treatment in 
 The Business Rule Book 
 [Ross97]. The 
 book presents a broad, deep, and thoroughly-considered theory of business rules, but 
 the method is not well-connected to other modern requirements tech-niques such as 
 use cases, or to iterative development.
  
 104",NA
7.13     UP Artifacts and Process Context ,"Artifact influence emphasizing the Vision, Supplementary Specification, and 
  
 Glossary are show in Figure 7.1.
  
  
 Figure 7.1 Sample UP artifact influence.
  
 105",NA
Chapter 8,NA,NA
FROM INCEPTION TO ,NA,NA
ELABORATION,"The hard and stiff breaks. The supple prevails.
  
 —Tao Te Ching",NA
Objectives,"• 
 Define the elaboration step.
  
 • 
 Motivate the following chapters in this section.",NA
Introduction,"Elaboration is the initial series of iterations during which:
  
 •
  
 •
  
 •
  
 the majority of requirements are discovered and stabilized the 
 major risks are mitigated or retired 
  
 the core architectural elements are implemented and proven 
  
 Rarely, the architecture is not a risk—for example, if building a website like oth-
 ers the team has successfully built, with the same tools and similar require-
 ments—in which case, it does not have to be a focus of these early iterations. In 
 that case, critical but non-architecturally significant features or use cases may be 
 implemented.
  
 It is in this phase that the book emphasizes an introduction to OOA/D, applying 
 the UML, patterns, and architecture.
  
 107",NA
8.1        Checkpoint: What Happened in Inception?,"The inception step of the NextGen POS project may last only one week. The arti-
 facts created should be brief and incomplete, the phase quick, and the investiga-tion 
 light.
  
 It is not the requirements phase of the project, but a short step to determine basic 
 feasibility, risk, and scope, and decide if the project is worth more serious 
 investigation, which occurs in elaboration. Not all activities that could reason-ably 
 occur in inception have been covered; this exploration emphasizes require-ments-
 oriented artifacts. Some likely activities and artifacts in inception include:
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 a short requirements workshop 
  
 most actors, goals, and use cases named 
  
 most use cases written in brief format; 10-20% of the use cases are written in 
 fully dressed detail to improve understanding of the scope and complexity most 
 influential and risky quality requirements identified 
  
 version one of the Vision and Supplementary Specification written 
  
 risk list 
  
 )
 For example, leadership really wants a demo at the POSWorld trade 
 show in Hamburg, in 18 months. But the effort for 
 a 
 demo cannot yet 
 be even roughly estimated until deeper investigation.
  
 •
  
 •
  
 •
  
 technical proof-of-concept prototypes and other investigations to explore the 
 technical feasibility of special requirements (""Does Java Swing work prop erly 
 on touch-screen displays?"") 
  
 user interface-oriented prototypes to clarify the vision of functional 
 requirements 
  
 recommendations on what components to buy/build/reuse, to be refined in 
 elaboration 
  
 )
      For example, a recommendation to buy a tax calculation 
 package.
  
 • 
  
 high-level 
 candidate 
 architecture and components proposed
  
 )
  This is not a detailed architectural description, and it is not meant to be 
 final or correct. Rather, it is brief speculation to use as a starting point 
 of investigation in elaboration. For example, ""A Java client-side 
 application, no application server, Oracle for the data-base, ..."" In 
 elaboration, it may be proven worthy, or discovered to be a poor idea 
 and rejected.
  
 •
  
 •
  
 plan for the first iteration 
  
 candidate tools list 
  
 108",NA
8.2      On to Elaboration,"Elaboration is the initial series of iterations during which the team does serious 
 investigation, implements (programs and tests) the core architecture, clarifies most 
 requirements, and tackles the high-risk issues. In the UP, ""risk"" includes business 
 value. Therefore, early work may include implementing scenarios that are deemed 
 important, but are not especially technically risky.
  
 Elaboration often consists of between two and four iterations; each iteration is 
 recommended to be between two and six weeks, unless the team size is massive. Each 
 iteration is timeboxed, meaning its end date is fixed; if the team is not likely to meet 
 the date, requirements are placed back on the future tasks list, so that the iteration can 
 end on time with a stable and tested release.
  
 Elaboration is not a design phase or a phase when the models are fully devel-oped in 
 preparation for implementation in the construction step—that would be an example of 
 superimposing waterfall ideas on to iterative development and the UP.
  
 During this phase, one is not creating throw-away prototypes; rather, the code and 
 design are production-quality portions of the final system. In some UP descriptions, 
 the potentially misunderstood term 
 ""architectural prototype"" 
 is used to describe the 
 partial system. This is not meant to be a prototype in the sense of a discardable 
 experiment; in the UP, it means a production subset of the final system. More 
 commonly it is called the 
 executable architecture or 
 architectural baseline.
  
 Elaboration in one sentence:
  
 Build the core architecture, resolve the high-risk elements, define most require-
 ments, and estimate the overall schedule and resources.
  
 Some key ideas and best practices that will manifest in elaboration include:
  
 •
  
 •
  
 •
  
 do short timeboxed risk-driven iterations 
  
 start programming early 
  
 adaptively design, implement, and test the core and risky parts of the 
  
 architecture 
  
 •
  
 •
  
 •
  
 test early, often, realistically 
  
 adapt based on feedback from tests, users, developers 
  
 write most of the use cases and other requirements in detail, through a 
  
 series of workshops, once per elaboration iteration 
  
 109",NA
What Is Architecturally Significant in Elaboration?,"Early iterations build and prove the core architecture. For the NextGen POS project—
 indeed, most—this will include:
  
 •
  
 Employing ""wide and shallow"" design and implementation; or ""designing at 
  
 the seams"" as Grady Booch has called it.
  
 )
  That is, identifying the separate processes, layers, packages, and 
 subsystems, and their high-level responsibilities and interfaces. Partially 
 implement these in order to connect them and clarify the interfaces. 
 Modules may contain mostly ""stubbed"" code.
  
 •
  
 Refining the inter-module local and remote interfaces (this includes the fin 
  
 est details of the parameters and return values).
  
 )
  For example, the interface to the object which will wrap access to third-
 party accounting systems.
  
 )
  Version one of an interface is seldom perfect. Early attention to stress 
 testing, ""breaking,"" and refining the interfaces supports later multi-team 
 parallel work relying on stable interfaces.
  
 •
  
 Integrating existing components.
  
 )
     For example, a tax calculator.
  
 •
  
 Implementing simplified end-to-end scenarios that force design, implemen 
  
 tation, and test across many major components.
  
 )
  For example, the main success scenario 
 of Process Sale, 
 using the credit 
 payment extension scenario.
  
 Elaboration phase testing is important, to obtain feedback, adapt, and prove that the 
 core is robust. Early testing for the NextGen project will include:
  
 •
  
 Usability testing of the user interface for 
 Process Sale.
  
 •Testing of recovery when remote services, such as the credit authorizer, fail.
  
 •
  
 Testing of high load to remote services, such as load on the remote tax calcu 
  
 lator.",NA
8.3       Planning the Next Iteration,"Planning and project management are important but large topics. Some key ideas are 
 briefly presented here, and an introduction is given in Chapter 36.
  
 110",NA
8.4       Iteration 1 Requirements and Emphasis: Fundamental ,NA,NA
OOA/D Skills,"In this case study, Iteration 1 of the elaboration phase emphasizes a range of 
 fundamental and common OOA/D skills used in building object systems, such as 
 assigning responsibilities to objects. Of course, many other skills and steps— such as 
 database design, usability engineering, and UI design—are needed to build software, 
 but they are out of scope in this introduction to OOA/D and the UP.",NA
Iteration 1 Requirements,"The requirements for the first iteration of the NextGen POS application follow:
  
 •
  
 Implement a basic, key scenario of the 
 Process Sale 
 use case: entering items 
  
 and receiving a cash payment. 
  
 •
  
 Implement a 
 Start Up 
 use case as necessary to support the initialization 
  
 needs of the iteration. 
  
 •
  
 Nothing fancy or complex is handled, just a simple happy path scenario, and 
  
 the design and implementation to support it. 
  
 •
  
 There is no collaboration with external services, such as a tax calculator or 
  
 product database. 
  
 •
  
 No complex pricing rules are applied. 
  
 The design and implementation of the supporting UI would also be done, but is not 
 covered.
  
 Subsequent iterations will grow on this foundation.
  
 112",NA
Incremental Development for the Same Use Case Across Iterations,"Note that not all requirements in the 
 Process Sale 
 use case are being handled in 
 iteration 1. It is common to work on varying scenarios or features of the same use 
 case over several iterations and gradually extend the system to ultimately handle 
 all the functionality required (see Figure 8.1). On the other hand, short, simple use 
 cases may be completed within one iteration.
  
 1 
  
 2 
  
 3 
  
 . . .
  
  
  
 Use Case 
  
 Use Case 
  
 Use Case
  
 Process Sale Process Sale Process Sale
  
  
  
  
 A use case or feature is 
 often too complex to 
  
 complete in one short 
 iteration.
  
 Therefore, different part or 
 scenarios must be 
  
 allocated to different 
  
 iterations.
  
 Feature: 
  
 Logging
  
 Use Case 
  
 Process Rentals
  
  
 Figure 8.1 Use case implementation may be spread across iterations.",NA
8.5       What Artifacts May Start in Elaboration?,"Table 8.1 lists 
 sample 
 artifacts that may be started in elaboration, and indicates 
 the issues they address. Subsequent chapters will examine some of these in 
 greater detail, especially the Domain Model and Design Model. For brevity, the 
 table excludes artifacts that may have begun in inception (and were listed in 
 Chapter 4); it introduces artifacts that are more likely to start in elaboration. Note 
 these will not be completed in one iteration; rather, they will be refined over a 
 series of iterations.
  
  
 Artifact 
 Domain Model
  
 Design Model
  
 Comment
  
 This is a visualization of the domain concepts; it is similar to a 
 static information model of the domain entities.
  
 This is the set of diagrams that describes the logical design. 
 This includes software class diagrams, object interaction dia- 
 grams, package diagrams, and so forth.
  
 113",NA
8.6       You Know You Didn't Understand Elaboration When...,"• 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 It is more than ""a few"" months long for most projects. 
  
 It only has one iteration (with rare exceptions for well-understood problems) 
 Most requirements were defined before elaboration. 
  
 The risky elements and core architecture are not being tackled. 
  
 It does not result in an 
 executable 
 architecture; there is no production-code 
 programming. 
  
 It is considered primarily a requirements phase, preceding an implementa- 
 tion phase in construction. 
  
 There is an attempt to do a full and careful design before programming. There  
 is  minimal  feedback  and  adaptation;  users  are  not  continually engaged in 
 evaluation and feedback 
  
 There is no early and realistic testing. 
  
 The architecture is speculatively finalized before programming. 
  
 It is considered a step to do the proof-of-concept programming, rather than 
 programming the production core executable architecture. 
  
 There are not multiple short requirements workshops that adapt and refine the 
 requirements based on feedback from the prior and current iterations. 
  
 If a project exhibits these symptoms, the elaboration phase was not understood.
  
 114",NA
PARTS,NA,NA
ELABORATION ,NA,NA
ITERATION ,NA,NA
1,NA,NA
Chapter 9,NA,NA
USE,NA,NA
-,NA,NA
CASE MODEL,NA,NA
: ,NA,NA
DRAWING SYSTEM ,NA,NA
SEQUENCE DIAGRAMS,"In theory, there is no difference between theory 
  
  
 and practice. But, in practice, there is.
  
 —
 Jan L.A. van de Snepscheut",NA
Objectives,"Identify system events.
  
 Create system sequence diagrams for use cases.",NA
Moving on to Iteration 1,"The NextGen POS project has entered the first real development iteration. Some 
 light requirements work was done in inception to help decide if the project was 
 worth more serious investigation. Planning for the first iteration has been 
 completed, and it has been decided to tackle a simple cash-only success scenario 
 of Process Sale 
 (with no remote collaborations), with the goal of starting a ""wide 
 and shallow"" design and implementation that touches on many major architec- 
 tural elements of the new system. In the first iteration, many tasks related to 
 establishing the environment (tools, people, process, and setting) occur; this will 
 be skipped.
  
 Rather, we turn our attention to use case and domain modeling analysis. Before 
 starting iteration 1 design work, some further investigation of the problem 
 domain is useful. Part of this investigation is the clarification of the input and 
 output system events related to our system, which can be illustrated in UML 
 sequence diagrams.
  
 117",NA
Introduction,"A system sequence diagram is a fast and easily created artifact that illustrates 
 input and output events related to the systems under discussion. The UML con- 
 tains notation in the form of sequence diagrams to illustrate events from exter- 
 nal actors to a system.",NA
9.1       System Behavior,"Before proceeding to a logical design of how a software application will work, it 
 is useful to investigate and define its behavior as a ""black box."" 
 System behav- 
 ior 
 is a description 
 of what 
 a system does, without explaining how it does it. One 
 part of that description is a system sequence diagram. Other parts include the use 
 cases, and system contracts (to be discussed later).",NA
9.2       System Sequence Diagrams,"Use cases describe how external actors interact with the software system we are 
 interested in creating. During this interaction an actor generates events to a 
 system, usually requesting some operation in response. For example, when a 
 cashier enters an item's ID, the cashier is requesting the POS system to record 
 that item's sale. That request event initiates an operation upon the system.
  
 It is desirable to isolate and illustrate the operations that an external actor requests 
 of a system, because they are an important part of understanding sys- tem 
 behavior. The UML includes 
 sequence diagrams 
 as a notation that can illustrate 
 actor interactions and the operations initiated by them.
  
 A system sequence diagram 
 (SSD) is a picture that shows, for a particular 
 scenario of a use case, the events that external actors generate, their order, and 
 inter-system events. All systems are treated as a black box; the emphasis of the 
 diagram is events that cross the system boundary from actors to systems.
  
 An SSD should be done for the main success scenario of the use case, and fre- 
 quent or complex alternative scenarios.
  
 The UML does not define something called a ""system"" sequence diagram, but 
 simply a sequence diagram. The qualification is used to emphasize its applica- 
 tion to systems as black boxes. Later, sequence diagrams will be used in another 
 context—to illustrate the design of interacting software objects to fulfill work.
  
 118",NA
9.3      Example of an SSD,"An SSD shows, for a particular course of events within a use case, the external actors 
 that interact directly with the system, the system (as a black box), and the system 
 events that the actors generate (see Figure 9.1). Time proceeds downward, and the 
 ordering of events should follow their order in the use case.
  
 System events may include parameters.
  
 This example is for the main success scenario of the 
 Process Sale 
 use case. It indicates 
 that the cashier generates 
 makeNewSale, enteritem, endSale, 
 and 
 makePayment 
 system 
 events.
  
 system as black box
  
 the name could be ""NextGenPOS"" but ""System"" keeps i
  
 the "":"" and underline imply an instance, and are explaine 
  
 later chapter on sequence diagram notation in the UML
  
 external actor to 
 system
  
 : Cashier
  
 Process Sale Scenario
  
 :System
  
 box may enlose an 
 iteration area
  
 makeNewSale()
  
  
 the * [...] is an iteration 
 marker and clause 
  
 indicating the box is for 
 iteration
  
 enterItem(itemID, quantity)
  
 description, total
  
 * [more items]
  
 return value(s) 
  
 associated with the 
  
 previous message
  
 endSale()
  
 a message with 
 parameters
  
 total with taxes
  
 it is an abstractio 
 representing the 
 system event of 
  
 entering the 
  
 payment data by 
 some mechanism
  
 an abstraction that 
 ignores presentation 
 and medium
  
 makePayment(amount)
  
 the return line is 
  
 optional if nothing is 
 returned
  
 change due, receipt
  
 Figure 9.1 SSD for a 
 Process Sale 
 scenario.
  
 119",NA
9.4       Inter-System SSDs ,"SSDs can also be used to illustrate collaborations between systems, such as 
  
 between the NextGen POS and the external credit payment authorizer. How- 
  
 ever, this is deferred until a later iteration in the case study, since this iteration 
  
 does not include remote systems collaboration.",NA
9.5 SSDs and Use Cases ,"An SSD shows system events for a scenario of a use case, therefore it is gener- 
  
 ated from inspection of a use case (see Figure 9.2).
  
 Simple cash-only 
 Process Sale
  scenario:
  
 : Cashier
  
 makeNewSale()
  
 :System
  
  
 1. Customer arrives at a POS checkout with 
 goods and/or services to purchase. 2. 
 Cashier starts a new sale.
  
 3. Cashier enters item identifier.
  
 4. System records sale line item and 
 presents item description, price, and 
 running total.
  
 Cashier repeats steps 3-4 until indicates 
 done.
  
 5. System presents total with taxes 
 calculated.
  
 6. Cashier tells Customer the total, and 
 asks for payment.
  
 7. Customer pays and System handles 
 payment.
  
 ...
  
 enterItem(itemID, quantity)
  
 description, total
  
 * [more items]
  
 endSale()
  
 total with taxes
  
 makePayment(amount)
  
 change due, receipt
  
 Figure 9.2 SSDs are derived from use cases.",NA
9.6       System Events and the System Boundary,"To identify system events, it is necessary to be clear on the choice of system 
 boundary, as discussed in the prior chapter on use cases. For the purposes of 
 software development, the system boundary is usually chosen to be the software
  
 120",NA
9.7      Naming System Events and Operations,"System events (and their associated system operations) should be expressed at the 
 level of intent rather than in terms of the physical input medium or inter- face widget 
 level.
  
 It also improves clarity to start the name of a system event with a verb (add..., 
 enter..., end..., make...), as in Figure 9.4, since it emphasizes the command ori- 
 entation of these events.
  
 Thus ""enteritem"" is better than ""scan"" (that is, laser scan) because it captures the 
 intent of the operation while remaining abstract and noncommittal with respect to 
 design choices about what interface is used to capture the system event.
  
 121",NA
9.8       Showing Use Case Text,"It is sometimes desirable to show at least fragments of use case text for the sce- 
 nario, to clarify or enhance the two views (see Figure 9.5). The text provides the 
 details and context; the diagram visually summarizes the interaction.",NA
9.9       SSDs and the Glossary,"The terms shown in SSDs (operations, parameters, return data) are terse. These 
 may need proper explanation so that during design work it is clear what is com- 
 ing in and going out. If this was not explicated in the use cases, the Glossary 
 could be used.
  
 However, as always when discussing the creation of artifacts other than code (the 
 heart of the project), be suspicious. There should be some truly meaningful use or 
 decision made with the Glossary data, otherwise it is simply low-value 
 unnecessary work.
  
 122",NA
9.10     SSDs Within the UP,"SSDs are part of the Use-Case Model—a visualization of the interactions implied in 
 the use cases. SSDs were not explicitly mentioned in the original UP description, 
 although the UP creators are aware of and understand the useful- ness of such 
 diagrams. SSDs are an example of the many possible skillful analy- sis and design 
 artifacts or activities that the UP or RUP documents do not mention.",NA
Phases,"Inception
 —SSDs are not usually motivated in inception.
  
 Elaboration
 —Most SSDs are created during elaboration, when it is useful to identify 
 the details of the system events to clarify what major operations the system must be 
 designed to handle, write system operation contracts (discussed in Chapter 13), and 
 possibly support estimation (for example, macroestimation with unadjusted function 
 points and COCOMO II).
  
 123",NA
9.11      Further Readings,"Variations of diagrams that illustrate the I/O events for a system treated as a black 
 box have been in widespread use for decades; for example, in telecommu- nications 
 as call-flow diagrams. They were especially popularized in object-ori- ented methods 
 via their use in the Fusion method |Coleman+94|, which provided a detailed example 
 of the relationship of SSDs and system operations to other analysis and design 
 artifacts.
  
 124",NA
9.12     UP Artifacts ,"Sample relationships of SSDs to other artifacts are shown in Figure 9.6.
  
 Business 
 Modeling
  
 Sample UP Artifacts
  
 Domain 
  
 Model
  
 Partial 
 artifacts, 
  
 refined in each 
  
   
 iteration.
  
 Use-Case Model
  
  
 parameter or 
  
 return data may be 
  
 elaborated in the 
  
 Glossary
  
 :System
  
 Requirements
  
 text 
  
 use 
  
 cases
  
 Glossary
  
 . . .
  
 system 
  
 events & 
 data
  
 system 
  
 sequence 
 diagrams
  
 system 
  
 operations
  
 system 
  
 operation 
  
 contracts
  
 Design
  
 Test 
  
 Plan
  
  
 Design Model
  
 design objects 
 to handle the 
 system events
  
  
 Software 
  
 Architecture Doc.
  
 Software 
  
 Dev. Plan
  
  
  
  
  
  
  
  
  
  
 Project 
 Management
  
 Test
  
 Environment
  
 Development 
  
 Case
  
  
 Figure 9.6 Sample UP artifact influence.
  
 125",NA
Chapter 10,NA,NA
DOMAIN MODEL,NA,NA
- ,NA,NA
VISUALIZING ,NA,NA
CONCEPTS,"It's all very well in practice, but it will never work in theory.
  
 —
 anonymous management maxim",NA
Objectives ,"Identify conceptual classes related to the current iteration 
 requirements.
  
 Create an initial domain model.
  
 Distinguish between correct and incorrect attributes.
  
 Add 
 specification 
 conceptual classes, when appropriate.
  
 Compare and contrast conceptual and implementation views.",NA
Introduction,"A domain model is widely used as a source of inspiration for designing software 
 objects, and will be a required input to several subsequent artifacts discussed in 
 this book. Therefore, it is important to read this chapter if the subject of domain 
 modeling is unfamiliar.
  
 A domain model illustrates meaningful (to the modelers) conceptual classes in a 
 problem domain; it is the most important artifact to create during object-ori- 
 ented analysis.
 1
  This chapter explores introductory skills in creating domain
  
 1. Use cases are an important requirements analysis artifact, but are not object-
 oriented. 
  
 They emphasize a process view of the domain.
  
 127",NA
10.1     Domain Models,"The quintessential object-oriented step in analysis or investigation is the decom- 
 position of a domain of interest into individual conceptual classes or objects— the 
 things we are aware of. A 
 domain model 
 is a 
 visual 
 representation of con- ceptual 
 classes or real-world objects in a domain of interest [MO95, Fowler96]. They have 
 also been called 
 conceptual models 
 (the term used in the first edi- tion of this book), 
 domain object models, and analysis object models.
 2
  
 The UP defines a Domain Model
 3
  as one of the artifacts that may be created in the 
 Business Modeling discipline.
  
 Using UML notation, a domain model is illustrated with a set of 
 class dia- grams 
 in 
 which no operations are defined. It may show:
  
 • 
  
 • 
  
 • 
  
 domain objects or conceptual classes 
 associations between conceptual classes 
 attributes of conceptual classes 
  
 For example, Figure 10.1 shows a partial domain model. It illustrates that the 
 conceptual class 
 of Payment 
 and 
 Sale 
 are significant in this domain, that a 
 Pay-
  
 2. They are also related to conceptual entity relationship models, which are capable of 
 showing purely conceptual views of domains, but that have been widely re-
 interpreted as data models for database design. Domain models are not data models. 
  
 3. Capitalization of Domain Model is used when I wish to emphasize it as an 
 official 
  
 model defined in the UP, vs. the general well-known concept of 
 ""domain models."" 
  
 128",NA
*,"1..
 *
  
 association
  
 1
  
 Stocked-in
  
 Contained-in
  
 1
  
 1
  
 attributes
  
 Sale
  
 Store
  
 date 
  
 time
  
 address 
  
 name
  
 1
  
 1
  
 Houses
  
 Paid-by
  
 1..
 *
  
 1
  
 Captured-on 
  
 Register
  
 Payment
  
 1
  
 amount
  
 Figure 10.1 Partial domain model—a visual dictionary. The numbers at each end of 
 the line indicate multiplicity, which is described in a subsequent chapter.",NA
Key Idea: Domain Model,NA,NA
—,NA,NA
A Visual Dictionary of Abstractions,"Please reflect on Figure 10.1 for a moment. It visualizes and relates some words or 
 conceptual classes in the domain. It also depicts an 
 abstraction 
 of the concep- tual 
 classes, because there are many things one could communicate about regis- ters, sales, 
 and so forth. The model displays a partial view, or abstraction, and ignores 
 uninteresting (to the modelers) details.
  
 The information it illustrates (using UML notation) could alternatively have been 
 conveyed in prose, in statements in the Glossary or elsewhere. But it is easy to 
 comprehend the discrete elements and their relationships in this visual language, since 
 a significant percentage of the brain participates in visual pro- cessing—it is a human 
 strength.
  
 Thus, the domain model may be considered a 
 visual dictionary 
 of the notewor- thy 
 abstractions, domain vocabulary, and information content of the domain.
  
 129",NA
Domain Models Are not Models of Software Components,"A domain model, as shown in Figure 10.2, is a visualization of things in the real- 
 world domain of interest, 
 not 
 of software components such as a Java or C++ class 
 (see Figure 10.3), or software objects with responsibilities. Therefore, the 
  
 following elements are not suitable in a domain model:
  
 • 
  
 • 
  
 Software artifacts, such as a window or a database, unless the domain being 
 modeled is of software concepts, such as a model of graphical user interfaces. 
  
 Responsibilities or methods.
 4
  
 Sale
  
 visualization of a rea 
  
 world concept in the 
  
 domain of interest
  
 date 
  
 time
  
 it is a 
 not 
 a picture of a 
  
 software class
  
 Figure 10.2 A domain model shows real-world conceptual classes, not software 
 classes.
  
 SalesDatabase
  
 Sale
  
 date
  
 time
  
 software artifact; not part of 
 domain model
  
 software class; not part of 
 domain model
  
 print()
  
 Figure 10.3 A domain model does not show software artifacts or classes.
  
 4. In object modeling, we usually speak of responsibilities related to software compo- 
 nents. And methods are purely a software concept. But, the domain model describes 
 real-world concepts, not software components. Considering object responsibilities 
 dur- ing 
 design 
 work is very important; it is just not part of this model. One valid 
 case in which responsibilities may be shown in a domain model is if it includes 
 human worker roles (such as Cashier), and the modeler wishes to record the 
 responsibilities of these human workers.
  
 130",NA
Conceptual Classes,"The domain model illustrates conceptual classes or vocabulary in the domain. 
  
 Informally, a conceptual class is an idea, thing, or object. More formally, a con- 
  
 ceptual class may be considered in terms of its symbol, intension, and extension 
  
 [MO95] (see Figure 10.4).
  
 • 
  
 Symbol
 —words or images representing a conceptual class.
  
 • 
  
 Intension
 —the definition of a conceptual class.
  
 • 
  
 Extension
 —the set of examples to which the conceptual class applies.
  
 For example, consider the conceptual class for the event of a purchase transac- 
  
 tion. I may choose to name it by the symbol 
 Sale. 
 The intension of a 
 Sale 
 may 
  
 state that it ""represents the event of a purchase transaction, and has a date and 
  
 time."" The extension 
 of Sale 
 is all the examples of sales; in other words, the set 
  
 of all sales.
  
 Sale 
  
 concept's symbol
  
 date
  
 time
  
 ""A sale represents the event 
  
 of a purchase transaction. It 
  
 has a date and time.""
  
 sale-1
  
 concept's intension
  
 sale-3
  
 sale-2
  
 concept's extension
  
 sale-4
  
 Figure 10.4 A conceptual class has a symbol, intension, and extension.
  
 When creating a domain model, it is usually the symbol and intensional view of a 
 conceptual class that are of most practical interest.
  
 131",NA
Domain Models and Decomposition,"Software problems can be complex; decomposition—divide-and-conquer—is a 
 common strategy to deal with this complexity by division of the problem space 
 into comprehensible units. In 
 structured analysis, 
 the dimension of decompo- 
 sition is by processes or 
 functions. 
 However, in object-oriented analysis, the 
 dimension of decomposition is fundamentally by things or entities in the domain.
  
 A central distinction between object-oriented and structured analysis is: divi- 
 sion by conceptual classes (objects) rather than division by functions.
  
 Therefore, a primary analysis task is to identify different concepts in the prob- 
 lem domain and document the results in a domain model.",NA
Conceptual Classes in the Sale Domain,"For example, in the real-world domain of sales in a store, there are the concep- 
 tual classes 
 of Store, Register, 
 and 
 Sale. 
 Therefore, our domain model, shown in 
 Figure 10.5, may include 
 Store, Register, 
 and 
 Sale.
  
  
 Store
  
  
  
 Register
  
  
  
 Sale
  
  
 Figure 10.5 Partial domain model in the domain of the store.",NA
10.2     Conceptual Class Identification,"Our goal is to create a domain model of interesting or meaningful conceptual 
 classes in the domain of interest (sales). In this case, that means concepts related 
 to the use case 
 Process Sale.
  
 In iterative development, one incrementally builds a domain model over several 
 iterations in the elaboration phase. In each, the domain model is limited to the 
 prior and current scenarios under consideration, rather than a ""big bang"" model 
 which early on attempts to capture all possible conceptual classes and relation- 
 ships. For example, this iteration is limited to a simplified cash-only 
 Process Sale 
 scenario; therefore, a partial domain model will be created to reflect just that—not 
 more.
  
 The central task is therefore to identify conceptual classes related to the scenar- 
 ios under design.
  
 132",NA
Strategies to Identify Conceptual Classes,"Two techniques are presented in the following sections:
  
 1. Use a conceptual class category list. 
  
 2. Identify noun phrases. 
  
 Another excellent technique for domain modeling is the use of 
 analysis pat- 
 terns, 
 which are existing partial domain models created by experts, using pub- 
 lished resources such as 
 Analysis Patterns 
 [Fowler96] and 
 Data Model Patterns 
 [Hay96].",NA
Use a Conceptual Class Category List,"Start the creation of a domain model by making a list of candidate conceptual 
 classes. Table 10.1 contains many common categories that are usually worth 
 considering, though not in any particular order of importance. Examples are 
 drawn from the store and airline reservation domains.
  
 133",NA
Finding Conceptual Classes with Noun Phrase Identification,"Another useful technique (because of its simplicity) suggested in [Abbot83] is 
 linguistic analysis: identify the nouns and noun phrases in textual descriptions of 
 a domain, and consider them as candidate conceptual classes or attributes.
  
 Care must be applied with this method; a mechanical noun-to-class mapping 
 isn't possible, and words in natural languages are ambiguous.
  
 Nevertheless, it is another source of inspiration. The fully dressed use cases are 
  
 an excellent description to draw from for this analysis. For example, the current 
 scenario of the 
 Process Sale 
 use case can be used.
  
 Main Success Scenario (or Basic Flow): 
  
 1. Customer 
 arrives at a 
 POS checkout 
 with 
 goods 
 and/or 
 services 
 to 
 purchase. 
 2. Cashier 
 starts a new 
 sale. 
  
 3. Cashier 
 enters 
 item identifier. 
  
 4. System records 
 sale line item 
 and presents 
 item description, price, 
 and running 
 total. 
 Price calculated from a set of price rules. 
  
 Cashier repeats steps 2-3 until indicates done.
  
 5. System presents total with 
 taxes 
 calculated. 
  
 6. Cashier tells Customer the total, and asks for 
 payment.
  
 7. Customer pays and System handles payment. 
  
 8. System logs the completed 
 sale 
 and sends sale and payment information to the 
 external 
 Accounting 
 (for accounting and 
 commissions) 
 and 
 Inventory 
 systems (to 
 update inventory). 
  
 9. System presents 
 receipt.
  
 10.Customer leaves with receipt and goods (if any).
  
 Extensions (or Alternative Flows):
  
 7a. Paying by cash: 
  
  
 1. Cashier enters the cash 
 amount tendered.
  
 135",NA
10.3     Candidate Conceptual Classes for the Sales Domain,"From the Conceptual Class Category List and noun phrase analysis, a list is generated 
 of candidate conceptual classes for the domain. The list is constrained to the 
 requirements and simplifications currently under consideration—the sim- plified 
 scenario 
 of Process Sale.
  
 Register 
  
 Item 
  
 Store 
  
 Sale 
  
 Payment
  
 ProductSpecificatio
 n 
  
 SalesLineItem 
  
 Cashier 
  
 Customer 
  
 Manager
  
 ProductCatalog
  
 There is no such thing as a ""correct"" list. It is a somewhat arbitrary collection of 
 abstractions and domain vocabulary that the modelers consider noteworthy. 
 Nevertheless, by following the identification strategies, similar lists will be pro- duced 
 by different modelers.
  
 136",NA
Report Objects,NA,NA
—,NA,NA
Include Receipt in the Model?,"A receipt is a record of a sale and payment and a relatively prominent concep- tual 
 class in the domain, so should it be shown in the model?
  
 Here are some factors to consider:
  
 • 
  
 A receipt is a report of a sale. In general, showing a report of other informa- 
  
 tion in a domain model is not useful since all its information is derived from other 
 sources; it duplicates information found elsewhere. This is one reason to exclude 
 it. 
  
 • 
  
 A receipt has a special role in terms of the business rules: it usually confers 
  
 the right to the bearer of the receipt to return bought items. This is a reason to 
 show it in the model. 
  
 Since item returns are not being considered in this iteration, 
 Receipt 
 will be excluded. 
 During the iteration that tackles the 
 Handle Returns 
 use case, it would be justified to 
 include it.",NA
10.4     Domain Modeling Guidelines,NA,NA
How to Make a Domain Model,"Apply the following steps to create a domain model:
  
 1.    List the candidate conceptual classes using the Conceptual Class Cate- gory 
 List and noun phrase identification techniques related to the current requirements 
 under consideration.
  
 2.    Draw them in a domain model.
  
 3.    Add the associations necessary to record relationships for which there is a 
 need to preserve some memory (discussed in a subsequent chapter).
  
 4.    Add the attributes necessary to fulfill the information requirements (dis- 
 cussed in a subsequent chapter).
  
 An adjunct useful method is to learn and copy analysis patterns, which are dis- cussed 
 in a later chapter.
  
 137",NA
On Naming and Modeling Things: The Mapmaker ,"The mapmaker strategy applies to both maps and domain models.
  
 Make a domain model in the spirit of how a cartographer or mapmaker works:
  
 •     Use the existing names in the territory. 
  
 •     Exclude irrelevant features. 
  
 •     Do not add things that are not there.
  
 A domain model is a kind of map of concepts or things in a domain. This spirit 
 emphasizes the analytical role of a domain model, and suggests the following:
  
 • 
  
 • 
  
 • 
  
 A mapmaker uses the names of the territory—they do not change the names 
 of cities on a map. For a domain model, this means 
 use the vocabulary of the 
 domain when naming conceptual classes and attributes. 
 For example, if 
 developing a model for a library, name  the customer a 
 ""Borrower"" 
 or 
 ""Patron""
 —the terms used by the library staff. 
  
 A mapmaker deletes things from a map if they are not considered relevant to 
 the purpose of the map; for example, topography or populations need not be 
 shown. Similarly, a domain model may exclude conceptual classes in the 
 problem domain not pertinent to the requirements. For example, we may 
 exclude 
 Pen 
 and 
 PaperBag 
 from our domain model (for the current set of 
 requirements) since they do not have any obvious noteworthy role. 
  
 A mapmaker does not show things that are not there, such as a mountain that 
 does not exist. Similarly, the domain model should exclude things 
 not 
 in the 
 problem domain under consideration. 
  
 The principle is also named the 
 Use the Domain Vocabulary 
 strategy [Coad95].",NA
A Common Mistake in Identifying Conceptual Classes ,"Perhaps the most common mistake when creating a domain model is to repre- sent 
 something as an attribute when it should have been a concept. A rule of thumb to 
 help prevent this mistake is:
  
 If we do not think of some conceptual class X as a number or text in the real 
 world, X is probably a conceptual class, not an attribute.
  
 138",NA
10.5     Resolving Similar Conceptual Classes—Register ,NA,NA
"vs. ""POST""","POST stands for point-of-sale terminal. In computerese, a terminal is any end-point 
 device in a system, such as a client PC, a wireless networked PDA, and so forth. In 
 earlier times, long before POSTs, a store maintained a 
 register
 —a book that logged 
 sales and payments. Eventually, this was automated in a mechanical ""cash register."" 
 Today, a POST fulfills the role of the register (see Figure 10.6).
  
 A register is a thing that records sales and payments, but so is a POST. However, the 
 term 
 register 
 seems somewhat more abstract and less implementation oriented than 
 POST. 
 So, in the domain model, should the symbol 
 Register 
 be used instead 
 of 
 POST?
  
 First, as a rule of thumb, a domain model is not absolutely correct or wrong, but 
 more or less useful; it is a tool of communication.
  
 139",NA
*,"Sale
  
  
 or?
  
 Records 
 
  
 Register
  
  
 1",NA
*,"Sale
  
  
 Figure 10.6 POST and register are similar conceptual classes.",NA
10.6     Modeling the ,NA,NA
Unreal ,NA,NA
World,"Some software systems are for domains that find very little analogy in natural or 
 business domains; software for telecommunications is an example. It is still possible 
 to create a domain model in these domains, but it requires a high degree of abstraction 
 and stepping back from familiar designs.
  
 For example, here are some candidate conceptual classes related to a telecom- 
 munication switch: 
 Message, Connection, Port, Dialog, Route, Protocol.",NA
10.7     Specification or Description Conceptual Classes,"The following discussion may at first seem related to a rare, highly specialized issue. 
 However, it turns out that the need for specification conceptual classes (as will be 
 defined) is common in many domain models. Thus, it is emphasized.
  
 5. Note that in earlier times a 
 register 
 was just one possible implementation of how 
 to 
  
 record sales. The term has acquired a generalized meaning over time.
  
 140",NA
The Need for Specification or Description Conceptual Classes,"The preceding problem illustrates the need for a concept of objects that are spec- 
 ifications or descriptions of other things. To solve the 
 Item 
 problem, what 
 is 
 needed is a 
 ProductSpecification 
 (or 
 ItemSpecification, ProductDescription, 
 ...) 
 conceptual class that records information about items. A 
 ProductSpecification 
 does not represent an 
 Item, 
 it represents a description of information 
 about 
 items. 
 Note that even if all inventoried items are sold and their corresponding 
 Item 
 software instances are deleted, the 
 ProductSpecifications 
 still remain.
  
 Description or specification objects are strongly related to the things they 
 describe. In a domain model, it is common to state that an 
 XSpecification 
 Describes an X 
 (see Figure 10.7).
  
 The need for specification conceptual classes is common in sales and product 
 domains. It is also common in manufacturing, where a 
 description 
 of a manufac- 
 tured thing is required that is distinct from the thing itself. Time and space have 
 been taken in motivating specification conceptual classes because they are very 
 common; it is not a rare modeling concept.
  
 141",NA
"10.8     UML Notation, Models, and Methods: Multiple ",NA,NA
Perspectives,"The UP defines something called a Domain Model, which is illustrated with UML 
 notation. However, there is no term ""Domain Model"" to be found in the official UML 
 documentation. This points to an important insight:
  
 The UML simply describes raw diagram types, such as class diagrams and 
 sequence diagrams. It does not superimpose a method or modeling perspec- tive 
 on these. Rather, a process (such as the UP) applies raw UML in the con- text of 
 methodologist-defined models.
  
 For example, raw UML class diagramming notation can be used to create pic- tures of 
 domain conceptual classes (a domain model), software classes, rela- tional database 
 tables, and so forth.
  
 Thus, do not confuse the basic UML diagram notation with its application to 
 visualizing various kinds of models defined by methodologists (see Figure 10.9). 
  
 This point applies not only to UML class diagrams, but to most UML notation.
  
 As another example of raw diagrams being interpreted differently in different models, 
 UML sequence diagrams can be used to illustrate messaging between software objects 
 (as in the UP Design Model), or interaction between people and parties in the real 
 world (as in the UP Business Object Model).
  
 This insight was emphasized in the Syntropy object-oriented method [CD94], and 
 reiterated by Martin Fowler in 
 UML Distilled 
 [FSOO]. That is, the same dia- 
 gramming notation may be used for three perspectives and types of models:
  
 1. 
  
 Essential or conceptual perspective
 —the diagrams are interpreted as 
 describing things in the real world or domain of interest.
  
 2. Specification perspective
 —the diagrams (using the same notation as for essential 
 models) are interpreted as describing software abstractions or components with 
 specifications and interfaces, but no commitment to a par- ticular implementation 
 (for example, not specifically a class in C# or Java).
  
 3. Implementation perspective
 —the diagrams (using the same notation as for 
 essential models) are interpreted as describing software implementa- tions in a 
 particular technology and language (such as Java).
  
 144",NA
Superimposing Terminology: UML vs. Methods,"In the raw UML, the rectangular boxes shown in Figure 10.9 are called 
 classes, 
 but 
 note that in the UML, this term encompasses a variety of phenomenon— physical 
 things, software things, events, and so forth.
 6
  A process or method will superimpose 
 alternative terminology on top of the UML. For example, in the UP, when the UML 
 boxes are drawn in the Domain Model, they may be called 
 domain concepts 
 or 
 conceptual classes; 
 the Domain Model offers a concep- tual perspective. In the UP, 
 when UML boxes are drawn in the Design Model, they are officially called 
 design 
 classes; 
 the Design Model offers a specification or implementation perspective, as 
 desired by the modeler.
  
 Regardless of the definition, the bottom line is that it is useful to distinguish between 
 the perspective of an analyst looking at real-world concepts such as a sale (a 
 conceptual perspective), and software designers specifying software com- ponents 
 such as a 
 Sale 
 software class (a specification or implementation per- spective).
  
 The UML can be used to illustrate both perspectives with very similar notation and 
 terminology, so it is important to bear in mind which perspective is being taken.
  
 A UML class is a special case of the very general UML model element 
 classifier
 — 
 something with structural features and/or behavior, including classes, actors, inter- 
 faces, and use cases.
  
 145",NA
10.9     Lowering the Representational Gap,"Please consider Figure 10.10. Why do books and educators discussing object 
 design common only show the use of software classes whose names reflect 
 domain vocabulary? Why choose a software class name such as 
 Sale, 
 and what 
 does a 
 Sale 
 do?
  
 Simply, choosing names that reflect the domain vocabulary 
 (Sale) 
 enhances quick 
 comprehension and provides a clue as to what to expect from the chunk of code in 
 a 
 Sale 
 software class. We have a mental or domain model of the domain in 
 question (for example, a store selling things). In the real world, we know that a 
 sale has a date. Consequently, if we create a Java class named 
 Sale, 
 and give it the 
 responsibility of knowing about a real sale and its date, then the Java class 
 Sale 
 somewhat corresponds to our mental or domain model of the real domain; that is, 
 it appeals to our ""intuitions"" of the domain.
  
 The Domain Model provides a visual dictionary of the domain vocabulary and 
 concepts from which to draw inspiration for the naming of some things in the 
 software design.
  
 This relates to the issue of 
 representational gap 
 or semantic gap—the gap 
 between our mental model of the domain and its representation in software.
  
 146",NA
10.10   Example: The NextGen POS Domain Model,"The list of conceptual classes generated for the NextGen POS domain may be 
 represented graphically (see Figure 10.11) to show the start of the Domain Model.
  
  
 Register
  
  
  
 Item
  
  
  
 Store
  
  
  
 Sale
  
  
  
 Sales 
  
 LineItem
  
  
  
 Cashier
  
  
  
 Customer
  
  
  
 Manager
  
  
  
 Payment
  
  
  
 Product 
 Catalog
  
  
  
 Product 
  
 Specification
  
  
 Figure 10.11 Initial Domain Model.
  
 Consideration of attributes and associations for the Domain Model will be deferred to 
 subsequent chapters.",NA
10.11    Domain Models Within the UP,"As suggested in the example of Table 10.2, a Domain Model is usually both started 
 and completed in elaboration.",NA
Inception,"Domain models are not strongly motivated in inception, since inception's pur- pose is 
 not to do a serious investigation, but rather to decide if the project is worth deeper 
 investigation in an elaboration phase.
  
 148",NA
Elaboration,"The Domain Model is primarily created during elaboration iterations, when the need 
 is highest to understand the noteworthy concepts and map some to soft- ware classes 
 during design work.
  
 Although ironically a significant number of pages will be devoted to explaining 
 domain object modeling, in experienced hands the development of a (partial, 
 incrementally growing) domain model in each iteration should only take a few hours. 
 This is further shortened by the use of predefined analysis patterns.",NA
The UP Business Object Model vs. Domain Model,"The UP Domain Model is an official variation of the less common UP Business 
 Object Model (BOM). The UP BOM—not to be confused with how other people or 
 methods may define a BOM, which is a widely used term with different mean- 
 ings—is a kind of enterprise model used to describe the entire business. It may be 
 used when doing business process engineering or reengineering, independent of any 
 one software application (such as the NextGen POS). To quote:
  
 [The UP BOM] serves as an abstraction of how business workers 
 and business entities need to be related and how they need to 
 collaborate in order to perform the business. [RUP]
  
 The BOM is represented with several different diagrams (class, activity, and 
 sequence) that illustrate how the entire enterprise runs (or should run). It is most 
 useful if doing enterprise-wide business process engineering, but that is a less 
 common activity than creating a single software application.
  
 149",NA
10.12   Further Readings,"Odell's 
 Object-Oriented Methods: A Foundation 
 provides a solid introduction to 
 conceptual domain modeling. Cook and Daniel's 
 Designing Object Systems 
 is 
 also useful.
  
 Fowler's 
 Analysis Patterns 
 offers worthwhile patterns in domain models, and is 
 definitely recommended. Another good book that describes patterns in domain 
 models is Hay's 
 Data Model Patterns: Conventions of Thought. 
 Advice from data 
 modeling experts who understand the distinction between pure conceptual mod- 
 els and database schema models can be very useful for domain object modeling.
  
 Java Modeling in Color with UML 
 [CDL99] has more relevant domain modeling 
 advice than the title suggests. The authors identify common patterns in related 
 types and their associations; the color aspect is really a visualization of the com- 
 mon categories of these types, such as 
 descriptions 
 (blue), 
 roles 
 (yellow), and 
 moment-intervals 
 (pink). Color is used to aid in seeing the patterns.
  
 Since the original work by Abbot, linguistic analysis has acquired more sophisti- 
 cated techniques for object-oriented analysis, generally called natural language 
 modeling, or a variant. See [Moreno97] as an example.
  
 150",NA
10.13   UP Artifacts ,"Artifact influence emphasizing the Domain Model is shown in Figure 
 10.12.
  
 Business 
 Modeling
  
 Sample UP Artifacts
  
 Domain 
  
 Model
  
 Partial 
 artifacts, 
  
 refined in each 
  
   
 iteration.
  
 *
  
 *
  
 the domain objects, 
  
 attributes, and associations 
 that undergo state changes
  
 Use-Case Model
  
 :System
  
 Requirements
  
 text 
  
 use 
  
 cases
  
  
 use 
  
 case 
  
 diagrams
  
 Glossary
  
 . . .
  
 system 
  
 sequence 
 diagrams
  
 system 
  
 operations 
 system 
  
 operation 
  
  
 contracts
  
 Design
  
 Test 
  
 Plan
  
  
 Design Model
  
 the system operations are 
 handled by designing 
  
 software to fulfill the post-
 conditions of the 
  
 contracts
  
  
 Software 
  
 Architecture Doc.
  
 Software 
  
 Dev. Plan
  
  
  
 Project 
 Management
  
 Test
  
 Environment
  
 Development 
  
 Case
  
  
 Figure 10.12 Sample UP artifact influence.
  
 151",NA
Chapter 11,NA,NA
DOMAIN MODEL,NA,NA
: ,NA,NA
ADDING ,NA,NA
ASSOCIATIONS,NA,NA
Objectives,"•     Identify associations for a domain model.
  
 •     Distinguish between need-to-know and comprehension-only 
 associations.",NA
Introduction,"It is useful to identify those associations of conceptual classes that are needed to 
 satisfy the information requirements of the current scenarios under develop- 
 ment, and which aid in comprehending the domain model. This chapter explores 
 the identification of suitable associations, and adds associations to the domain 
 model for the NextGen case study.",NA
11.1     Associations,"An 
 association 
 is a relationship between types (or more specifically, instances of 
 those types) that indicates some meaningful and interesting connection (see 
 Figure 11.1).
  
 153",NA
Criteria for Useful Associations,"Associations worth noting usually imply knowledge of a relationship that needs 
 to be preserved for some duration—it could be milliseconds or years, depending 
 on context. In other words, between what objects do we need to have some mem- 
 ory of a relationship? For example, do we need to remember what 
 SalenLineItem 
 instances are associated with a 
 Sale 
 instance? Definitely, otherwise it would not 
 be possible to reconstruct a sale, print a receipt, or calculate a sale total.
  
 Consider including the following associations in a domain model:
  
 •     Associations for which knowledge of the relationship needs to be pre- 
 served for some duration (""need-to-know"" associations).
  
 •     Associations derived from the Common Associations List.
  
 By contrast, do we need to have memory of a relationship between a current 
 Sale 
 and a 
 Manager? 
 No, the requirements do not suggest that any such rela- tionship 
 is needed. It is not wrong to show a relationship between 
 a Sale 
 and 
 Manager, 
 but it is not compelling or useful in the context of our requirements.
  
 This is an important point. On a domain model with n different conceptual 
 classes, there can be n-(n-l) associations to other conceptual classes—a poten- 
 tially large number. Many lines on the diagram will add ""visual noise"" and make 
 it less comprehensible. Therefore, be parsimonious about adding association 
 lines. Use the criterion guidelines suggested in this chapter.",NA
11.2     The UML Association Notation,"An association is represented as a line between classes with an association name. 
 The association is inherently bidirectional, meaning that from instances of either 
 class, logical traversal to the other is possible.
  
 154",NA
11.3     Finding Associations—Common Associations List,"Start the addition of associations by using the list in Table 11.1.
  
 It contains common categories that are usually worth considering. Examples are 
  
 drawn from the store and airline reservation domains.
  
 155",NA
High-Priority Associations,"Here are some high-priority association categories that are invariably useful to 
  
 include in a domain model:
  
 • 
  
 • 
  
 • 
  
 A is a 
 physical or logical part 
 of B. 
  
 A is 
 physically or logically contained 
 in/on B. 
 A is 
 recorded in 
 B.",NA
11.4     Association Guidelines,"•     Focus on those associations for which knowledge of the relationship needs 
 to be preserved for some duration (""need-to-know"" associations).
  
 •     It is more important to identify 
 conceptual classes 
 than to identify 
 associations.
  
 •     Too many associations tend to confuse a domain model rather than illu- 
 minate it. Their discovery can be time-consuming, with marginal benefit.•    
 Avoid showing redundant or derivable associations.",NA
11.5     Roles ,"Each end of an association is called a 
 role. 
 Roles may optionally have:
  
 • 
  
 • 
  
 • 
  
 name 
  
 multiplicity expression 
  
 navigability 
  
 Multiplicity is examined next, and the other two features are discussed in later 
  
 chapters.
  
 157",NA
Multiplicity ,"Multiplicity 
 defines how many instances of a class 
 A 
 can be associated with 
 one instance of a class 
 B 
 (see Figure 11.3).
  
 Store
  
 1
  
 Stocks",NA
*,"Item
  
  
 multiplicity of the role 
  
 Figure 11.3 Multiplicity on an association.
  
 For example, a single instance of a 
 Store 
 can be associated with ""many"" (zero or 
 more, indicated by the * ) 
 Item 
 instances.
  
 Some examples of multiplicity expressions are shown in Figure 11.4.",NA
*,"T
  
  
  
 1..
 *
  
 T
  
  
  
 1..40
  
 T
  
  
  
 5
  
 T
  
  
     
 zero or more;
  
 ""many""
  
 one or more
  
 one to 40
  
 exactly 5
  
  
 3, 5, 8
  
 T
  
  
 Figure 11.4 Multiplicity values.
  
 exactly 3, 5, or 
  
 The multiplicity value communicates how many instances can be validly associ- 
 ated with another, at a particular moment, rather than over a span of time. For 
 example, it is possible that a used car could be repeatedly sold back to used car 
 dealers over time. But at any particular moment, the car is only 
 Stocked-by 
 one 
 dealer. The car is not 
 Stocked-by 
 many dealers at any particular moment. Simi- 
 larly, in countries with monogamy laws, a person can be 
 Married-to 
 only one 
 other person at any particular moment, even though over a span of time, they may 
 be married to many persons.
  
 158",NA
*,"Multiplicity should ""1"" or ""0..1""?
  
 The answer depends on our interest in using the model. Typically and practically, the muliplicity co domain 
 constraint that we care about being able to check in software, if this relationship was imple in software objects 
 or a database.  For example, a particular item may become sold or discarded, a stocked in the store. From 
 this viewpoint, ""0..1"" is logical, but ...
  
 Do we care about that viewpoint? If this relationship was implemented in software, we would proba that an 
 Item 
 software instance would always be related to 1 particular 
 Store 
 instance, otherwise it indicates a fau 
 corruption in the software elements or data.
  
 This partial domain model does not represent software objects, but the multiplicities record constra value is 
 usually related to our interest in building software or databases (that reflect our real-world d checks. From this 
 viewpoint, ""1"" may be the desired value.
  
 Figure 11.5 Multiplicity is context dependent.
  
 Rumbaugh gives another example 
 of Person 
 and 
 Company 
 in the 
 Works-for 
 asso- 
 ciation [Rumbaugh91]. Indicating if a 
 Person 
 instance works for one or many 
 Company 
 instances is dependent on the context of the model; the tax depart- ment 
 is interested in 
 many; 
 a union probably only 
 one. 
 The choice usually prac- tically 
 depends on whom we are building the software for, and thus the valid 
 multiplicities in an implementation.",NA
11.6     How Detailed Should Associations Be?,"Associations are important, but a common pitfall in creating domain models is to 
 spend too much time during investigation trying to discover them.
  
 It is critical to appreciate the following:
  
 159",NA
11.7     Naming Associations,"Name an association based on a 
 TypeName-VerbPhrase-TypeName 
 format 
 where the verb phrase creates a sequence that is readable and meaningful in the 
 model context.
  
 Association names should start with a capital letter, since an association repre- 
 sents a classifier of links between instances; in the UML, classifiers should start 
 with a capital letter. Two common and equally legal formats for a compound 
 association name are:
  
 •    
 Paid-by 
  
 •
     PaidBy
  
 In Figure 11.6, the default direction to read an association name is left to right or 
 top to bottom. This is not a UML default, but a common convention.
  
 Store
  
  
  
  
  
  
 1 
  
 Cont
  
 1..
 *
  
 ains
  
  
  
  
 Register
  
 Captures
  
 Sale
  
 Paid-by
  
 Payment
  
 1 1..
 *
  
 1 
  
 1
  
 Airline
  
 1 
  
 Employs
  
 1..
 *
  
 1
  
 Person
  
 1
  
 Assigned-to
  
 Flight
  
 
 Assigned-to 
 * 
  
 1
  
 Plane
  
 *
  
 *
  
 Supervises
  
 Figure 11.6 Association names.
  
 160",NA
11.8     Multiple Associations Between Two Types,"Two types may have multiple associations between them; this is not uncommon. 
 There is no outstanding example in our POS case study, but an example from the 
 domain of the airline is the relationships between a 
 Flight 
 (or perhaps more 
 precisely, a 
 FlightLeg) 
 and 
 an Airport 
 (see Figure 11.7); the flying-to and flying- 
 from associations are distinctly different relationships, which should be shown 
 separately.",NA
*,"Flight
  
 Flies-to 1
  
 Airport
  
 Flies-from
  
 1",NA
*,Figure 11.7 Multiple associations.,NA
11.9     Associations and Implementation,"During domain modeling, an association is 
 not 
 a statement about data flows, instance 
 variables, or object connections in a software solution; it is a statement that a 
 relationship is meaningful in a purely conceptual sense—in the real world. Practically 
 speaking, many of these relationships will typically be imple- mented in software as 
 paths of navigation and visibility (both in the Design Model and Data Model), but their 
 presence in a conceptual (or essential) view of a domain model does not require their 
 implementation.
  
 When creating a domain model, we may define associations that are not neces- sary 
 during implementation. Conversely, we may discover associations that need to be 
 implemented but were missed during domain modeling. In these cases, the domain 
 model can be updated to reflect these discoveries.
  
 Suggestion 
  
 Should prior investigative models such as a domain model be updated with 
 insights (such as new associations) revealed during implementation work? Do 
 not bother unless there is some future practical use for the model. If it is just 
 (as is sometimes the case) a temporary artifact used to provide inspira- tion for 
 a later step, and will not be meaningfully used later on, why update it? Avoid 
 making or updating any documentation or model unless there is a concrete 
 justification for future use.
  
 Later on we will discuss ways to implement associations in an object-oriented 
 programming language (the most common is to use an attribute that references
  
 161",NA
11.10   NextGen POS Domain Model Associations,"We can now add associations to our POS domain model. We should add those 
 associations which the requirements (for example, use cases) suggest or imply a 
 need to remember, or which otherwise are strongly suggested in our perception of 
 the problem domain. When tackling a new problem, the common categories of 
 associations presented earlier should be reviewed and considered, as they repre- 
 sent many of the relevant associations that typically need to be recorded.",NA
Unforgettable Relationships in the Store,"The following sample of associations is justified in terms of a need-to-know. It is 
 based on the use cases currently under consideration.
  
 Register Records Sale 
  
 Sale Paid-by Payment
  
 ProductCatalog Records Prod- 
 uctSpecification
  
 To know the current sale, gener- 
 ate a total, print a receipt.
  
 To know if the sale has been paid, 
 relate the amount tendered to the 
 sale total, and print a receipt.
  
 To retrieve an 
 ProductSpecifica- 
 tion, 
 given an itemID.",NA
Applying the Category of Associations Checklist ,"We will run through the checklist, based on previously identified types, consid- 
 ering the current use case requirements.
  
 Category
  
 System
  
 A
 is a physical part of B
  
 Register 
 — 
 CashDrawer
  
 A
 is a logical part of B
  
 SalesLineItem 
 — 
 Sale
  
 A
 is physically contained in/on B
  
 Register 
 — 
 Store 
  
 Item 
 — 
 Store
  
 162",NA
11.11    NextGen POS Domain Model,"The domain model in Figure 11.8 shows a set of conceptual classes and associa- 
 tions that are candidates for our POS application. The associations were prima- 
 rily derived from the candidate association checklist.",NA
Preserve Only Need-to-Know Associations?,"The set of associations shown in the domain model of Figure 11.8 were, for the 
 most part, mechanically derived from the association checklist. However, it may 
 be desirable to be more choosy in the associations included in our domain model. 
 Viewed as a tool of communication, it is undesirable to overwhelm the domain
  
 163",NA
* ,"Sales 
  
 LineItem",NA
*,"Described-by
  
 1
  
 Product 
  
 Catalog
  
 1
  
 Contains
  
 Product 
  
 Specification
  
 1..
 *
  
  
 Describes",NA
*,"Item
  
 1
  
 Used-by",NA
*,"1
  
 Store
  
 1
  
 Stocks",NA
*,"1..
 *
  
 1..*
  
 Logs-
  
 completed
  
 
  
 1
  
 Houses
  
 Contained-in
  
 1
  
 1..
 *
  
 Manager
  
 Sale
  
 Register
  
 Captured-on
  
 1
  
 Started-by 
 1
  
 1
  
 1
  
 1
  
 Paid-by
  
 1
  
 1
  
 Initiated-by
  
 1
  
 
  Records-sales-on
  
 1
  
 1
  
 Initiated-by
  
 1
  
 1
  
 Payment
  
 Customer
  
 Cashier
  
 Figure 11.8 A partial domain model.",NA
Associations for Need-to-Know vs. Comprehension,"A strict need-to-know criterion for maintaining associations will generate a min- 
 imal ""information model"" of what is needed to model the problem domain— 
 bounded by the current requirements under consideration. However, this 
 approach may create a model that does not convey (to us or anyone else) a full 
 understanding of the domain.
  
 In addition to being a need-to-know model of information about things, the 
 domain model is a tool of communication in which we are trying to understand 
 and communicate to others important concepts and their relationships. From this 
 viewpoint, deleting some associations that are not strictly demanded on a
  
 165",NA
Chapter 12,NA,NA
DOMAIN MODEL,NA,NA
: ,NA,NA
ADDING ,NA,NA
ATTRIBUTES,"Any sufficiently advanced bug is indistinguishable from a feature.
  
 —
 Rich Kulawiec",NA
Objectives,"•     Identify attributes in a domain model. 
  
 •     Distinguish between correct and incorrect attributes.",NA
Introduction,"It is useful to identify those attributes of conceptual classes that are needed to 
 satisfy the information requirements of the current scenarios under develop- ment. 
 This chapter explores the identification of suitable attributes, and adds attributes 
 to the domain model for the NextGen domain model.",NA
12.1      Attributes,"An attribute 
 is a logical data value of an object.
  
 Include the following attributes in a domain model: Those for which the 
 requirements (for example, use cases) suggest or imply a need to remember 
 information.
  
 167",NA
12.2     UML Attribute Notation,"Attributes are shown in the second compartment of the class box (see Figure 12.1). 
 Their type may optionally be shown.
  
 Sale 
  
 date 
  
 startTime : Time
  
 attributes
  
 Figure 12.1 Class and attributes.",NA
12.3     Valid Attribute Types,"There are some things that should not be represented as attributes, but rather as 
 associations. This section explores valid attributes.",NA
Keep Attributes Simple,"Intuitively, most simple attribute types are what are often thought of as primi- tive 
 data types, such as numbers. The type of an attribute should not normally be a 
 complex domain concept, such as a 
 Sale or Airport. 
 For example, the follow- ing 
 currentRegister 
 attribute in the 
 Cashier 
 class in Figure 12.2 is undesirable because its 
 type is meant to be a 
 Register, 
 which is not a simple attribute type (such as 
 Number 
 or 
 String). 
 The most useful way to express that a 
 Cashier 
 uses a 
 Register 
 is with an 
 association, not with an attribute..
  
 The attributes in a domain model should preferably be simple attributes or 
  
 data types.
  
 Very common attribute data types include: 
 Boolean, Date, Number, String 
 (Text), Time 
  
 Other common types include: 
 Address, Color, Geometries (Point, Rectangle), 
 Phone Number, Social Security Number, Universal Product Code (UPC), 
 SKU, ZIP or postal codes, enumerated types
  
 168",NA
Conceptual vs. Implementation Perspectives: What About Attributes in ,NA,NA
Code?,"The restriction that attributes in the domain model be only of simple data types does 
 not 
 imply 
 that C++ or Java attributes (data members, instance fields) must only be of simple, primitive 
 data types. The domain model focuses on pure conceptual statements about a problem 
 domain, not software components.
  
 Later, during design and implementation work, it will be seen that the associations between 
 objects expressed in the domain model will often be implemented as attributes that reference 
 other complex software objects. However, this is but one of a number of possible design 
 solutions to implement an association, and so the decision should be deferred during domain 
 modeling.
  
 169",NA
Data Types,"Attributes should generally be 
 data types. 
 This is a UML term that implies a set of 
 values for which unique identity is not meaningful (in the context of our model or 
 system) [RJB99]. For example, it is not (usually) meaningful to distin- guish between:
  
 • 
  
 • 
  
 • 
  
 • 
  
 Separate instances of the 
 Number 
 5. 
  
 Separate instances of the 
 String 
 'cat'. 
  
 Separate instances of 
 PhoneNumber 
 that contain the same number. 
  
 Separate instances 
 of Address 
 that contain the same address. 
  
 By contrast, it 
 is 
 meaningful to distinguish (by identity) between two separate 
 instances of a 
 Person 
 whose names are both ""Jill Smith"" because the two instances can 
 represent separate individuals with the same name.
  
 In terms of software, there are few situations where one would compare the memory 
 addresses of instances of 
 Number, String, PhoneNumber, 
 or 
 Address; 
 only value-based 
 comparisons are relevant. By contrast, it is conceivable to com- pare the memory 
 addresses 
 of Person 
 instances, and to distinguish them, even if they had the same 
 attribute values, because their unique identity is important.
  
 Thus, all primitive types (number, string) are UML data types, but not all data types are 
 primitives. For example, 
 PhoneNumber 
 is a non-primitive data type.
  
 These data type values are also known as 
 value objects.
  
 The notion of data types can get subtle. As a rule of thumb, stick to the basic test of 
 ""simple"" attribute types: Make it an attribute if it is naturally thought of as number, 
 string, boolean, date, or time (and so on); otherwise, represent it as a separate 
 conceptual class.
  
 If in doubt, define something as a separate conceptual class rather than as an 
 attribute.",NA
12.4     Non-primitive Data Type Classes,"The type of an attribute may be expressed as a non-primitive class in its own right in a 
 domain model. For example, in the POS system there is an item iden- tifier. It is 
 typically viewed as just a number. So should it be represented as a non-primitive 
 class? Apply this guideline:
  
 170",NA
Where to Illustrate Data Type Classes?,"Should the 
 ItemID 
 class be shown as a separate conceptual class in a domain model? It 
 depends on what you want to emphasize in the diagram. Since 
 ItemID
  
 171",NA
12.5     Design Creep: No Attributes as Foreign Keys,"Attributes should not be used to relate conceptual classes in the domain model. The 
 most common violation of this principle is to add a kind of 
 foreign key attribute, 
 as is 
 typically done in relational database designs, in order to associ- ate two types. For 
 example, in Figure 12.5 the 
 currentRegisterNumber 
 attribute in the 
 Cashier 
 class is 
 undesirable because its purpose is to relate the 
 Cashier 
 to a 
 Register 
 object. The better 
 way to express that a 
 Cashier 
 uses a 
 Register 
 is with an association, not with a foreign 
 key attribute. Once again, relate types with an association, not with an attribute.
  
 There are many ways to relate objects—foreign keys being one—and we will defer how 
 to implement the relation until design, in order to avoid 
 design 
 creep.
  
 172",NA
12.6     Modeling Attribute Quantities and Units,"Most numeric quantities should not be represented as plain numbers. Consider price or 
 velocity. These are quantities with associated units, and it is common to require 
 knowing the unit, and to support conversions. The NextGen POS soft- ware is for an 
 international market and needs to support prices in multiple cur- rencies. In the general 
 case, the solution is to represent 
 Quantity 
 as a distinct conceptual class, with an 
 associated 
 Unit 
 [Fowler96]. Since quantities are con- sidered data types (unique 
 identity of instances is not important), it is accept- able to collapse their illustration 
 into the attribute section of the class box (see Figure 12.6). It is also common to show 
 Quantity 
 specializations. 
 Money 
 is a kind of quantity whose units are currencies. 
 Weight 
 is a quantity with units such as kilograms or pounds.
  
 Payment
  
 not useful
  
 amount : Number
  
 Payment
  
 quantities are pure data 
  
 values, so suitable to show in 
 attribute section
  
 better
  
 amount : Quantity
  
 Payment
  
 variation: 
 Money
 is a
  
 specialized Quality whose
  
 unit is a currency
  
 amount : Money
  
  
 Payment
  
 Has-amount
  
 Quantity
  
 Is-in
 
  
 Unit",NA
* ,"1
  
 amount : Number",NA
* ,"1
  
 ...",NA
12.7     Attributes in the NextGen Domain Model ,"The attributes chosen reflect the requirements for this iteration—the Process 
  
 Sale 
 scenarios of this iteration.
  
 Payment
  
 Product- 
  
 Specification
  
 Sale 
  
 SalesLineItem
  
 Store
  
 amount
 —To determine if sufficient payment was 
 provided, and to calculate change, an amount (also 
 known as ""amount tendered"") must be captured.
  
 description
 —To show the description on a display 
 or receipt.
  
 id
 —To look up a 
 ProductSpecification, 
 given an 
 entered itemID, it is necessary to relate them to a 
 id.
  
 price
 —To calculate the sales total, and show the 
 line item price.
  
 date, time
 —A receipt is a paper report of a sale. It 
 normally shows date and time of sale.
  
 quantity
 —To record the quantity entered, when 
 there is more than one item in a line item sale (for 
 example, 
 five 
 packages of tofu).
  
 address, name
 —The receipt requires the name and 
 address of the store.
  
 Register
  
  
  
 Item
  
  
  
 Store
  
 name : Text
  
 address : Address
  
 Sale
  
 date : Date 
 time : Time
  
  
  
 Sales 
  
 LineItem
  
 quantity : Integer
  
  
  
 Cashier
  
  
  
  
 Customer
  
  
  
  
 Manager
  
  
  
  
 Payment
  
 amount : Money
  
  
  
 Product 
  
 Catalog
  
  
  
  
 Product 
  
 Specification
  
 price : Money id: 
 ItemID
  
 description : Text
  
 Figure 12.7 Domain model showing attributes.
  
 174",NA
12.8     Multiplicity From SalesLineItem to Item,"It is possible for a cashier to receive a group of like items (for example, six tofu 
 packages), enter the 
 itemID 
 once, and then enter a quantity (for example, six). 
 Consequently, an individual 
 SalesLineItem 
 can be associated with more than one 
 instance of an item.
  
 The quantity that is entered by the cashier may be recorded as an attribute of the 
 SalesLineItem 
 (Figure 12.8). However, the quantity can be calculated from the 
 actual multiplicity value of the relationship, so it may be characterized as a 
 derived attribute
 —one that may be derived from other information. In the UML, 
 a derived attribute is indicated with a ""/"" symbol.
  
 SalesLineItem
  
 0..1
  
 Records-sale-of
  
 1
  
 Item
  
 Each line item records a 
 separate item sale.
  
 For example, 1 tofu package
  
 SalesLineItem
  
 0..1
  
 Records-sale-of
  
 1..
 *
  
 Item
  
 Each line item can record a 
 group of the same kind of ite 
 For example, 6 tofu package
  
 SalesLineItem
  
 0..1
  
 Records-sale-of
  
 Item
  
 1..
 *
  
 /quantity
  
 derived attribute from 
  
 the multiplicity value
  
 Figure 12.8 Recording the quantity of items sold in a line item.",NA
12.9     Domain Model Conclusion,"Combining the conceptual classes, associations, and attributes discovered in the 
 previous investigation yields the model illustrated in Figure 12.9.
  
 A relatively useful domain model for the domain of the POS application has been 
 created. There is no such thing as a single correct model. All models are 
 approximations of the domain we are attempting to understand. A good domain 
 model captures the essential abstractions and information required to under- stand 
 the domain in the context of the current requirements, and aids people in 
 understanding the domain—its concepts, terminology, and relationships.
  
 175",NA
*,"Store 
  
  
 Used-by",NA
*,"Stocks 
  
 Item",NA
* ,"Describes
  
 quantity 
  
 1 address
  
 name 
  
 1",NA
* ,"1..*
  
 1..
 *
  
 Contained-in 
  
 completed 
  
  
 Logs-
  
 1 Houses
  
 1 
 
 1..
 *
  
 Sale",NA
* ,"Register
  
 date
  
 Captured-on 
  
 1 
  
  
  
 Started-by
  
 1 
  
  
 Manager
  
 time 1 
  
 1
  
 Paid-by 
  
 1 1
  
 Initiated-by 
  
 1 
  
 
  Records-sales-on
  
 1 
  
 1 1
  
 Payment 
  
 Customer 
  
 Cashier
  
 amount
  
 Figure 12.9 A partial domain model.",NA
Chapter 13 ,NA,NA
USE,NA,NA
-,NA,NA
CASE MODEL,NA,NA
: ,NA,NA
ADDING DETAIL ,NA,NA
WITH,NA,NA
OPERATION CONTRACTS,"A verbal contract isn't worth the paper it's written on.
  
 —
 Samuel Goldwyn",NA
Objectives,•     Create contracts for system operations.,NA
Introduction,"Contracts for operations can help define system behavior; they describe the out- 
 come of executing system operation in terms of state changes to domain objects. 
 This chapter explores their use.",NA
13.1      Contracts,"Use cases are the primary mechanism in the UP to describe system behavior, and 
 are usually sufficient. However, sometimes a more detailed description of system 
 behavior has value. Contracts describe detailed system behavior in terms of state 
 changes to objects in the Domain Model, after a system operation has executed.
  
 177",NA
System Operations and the System Interface,"Contracts may be defined for 
 system operations
 —operations that the system as a 
 black box offers in its public interface to handle incoming system events. System 
 operations can be identified by discovering these system events, as shown in 
 Figure 13.1.
  
 : Cashier
  
 :System
  
 makeNewSale()
  
 addLineItem(itemID, quantity)
  
 these input system events 
 invoke 
 system operations
  
 the system event
  
 description, total 
  
 * [more items]
  
 makeNewSale
  invokes a 
 system operation called 
  
 makeNewSale
  and so forth
  
 this is the same as in object-
  
 endSale()
  
 oriented programming when 
 we say the message 
 foo
  
 invokes the method (handling
  
 total with taxes 
  
 operation) 
 foo
  
 makePayment(amount)
  
 change due, receipt
  
 Figure 13.1 System operations handle input system events.
  
 The entire set of system operations, across all use cases, defines the public system 
 interface, viewing the system as a single component or class. In the UML, the 
 system as a whole can be represented by a class.",NA
13.2     Example Contract: enterltem,"Before examining the reason to write a contract, an example is worthwhile. The 
 following describes a contract for the 
 enterltem 
 system operation.
  
 178",NA
13.3     Contract Sections,"A description of each section in a contract is shown in the following schema.
  
 Operation: Cross 
  
 References: 
  
 Preconditions:
  
 Postconditions:",NA
13.4     Postconditions,"Name of operation, and parameters 
  
 (optional) Use cases this operation can occur within 
  
 Noteworthy 
 assumptions 
 about the state of the system or 
 objects in the Domain Model before execution of the opera-
 tion. These will not be tested within the logic of this operation, 
 are assumed to be true, and are non-trivial assumptions the 
 reader should know were made.
  
 -The state of objects in the Domain Model after completion of 
 the operation. Discussed in detail in a following section.
  
 Notice that each of the postconditions in the 
 enterltem 
 example included a cate-
 gorization such as 
 instance creation 
 or 
 association formed. 
 Here is a key point:
  
 The postconditions describe changes in the state of objects in the Domain 
 Model. Domain Model state changes include instances created, associations 
 formed or broken, and attributes changed.
  
 179",NA
Postconditions Are Related to the Domain Model,"These postconditions are expressed in the context of the Domain Model objects. 
 What instances can be created?—those from the Domain Model; What associa-
 tions can be formed?—those in the Domain Model; and so on.",NA
An Advantage of Postconditions: Analytical Detail,"Expressed in a declarative state-change fashion, the contract is an excellent tool 
 for requirements analysis that describes the state changes required of a system 
 operation (in terms of the Domain Model objects) without having to describe 
 how 
 they are to be achieved. In other words, the software design and solution can be 
 deferred, and one can focus analytically on 
 what 
 must happen, rather than how it 
 is to be accomplished. Furthermore, the postconditions support fine-grained detail 
 and specificity in declaring what the outcome of the operation must be.
  
 180",NA
The Spirit of Postconditions: The Stage and Curtain,"Express postconditions in the past tense, to emphasize they are declarations about a 
 state change in the past. For example:
  
 •
  
 (better) A 
 SalesLineltem 
 was created, 
  
 rather than 
  
 •
  
 (worse) Create a 
 SalesLineltem.
  
 Think about postconditions using the following image: The 
  
 system and its objects are presented on a theatre stage.
  
 1.
  
 Before the operation, take a picture of the stage. 
  
 2.Close the curtains on the stage, and apply the system operation 
 (background 
  
 noise of clanging, screams, and screeches...).
  
 3.
 Open the curtains and take a second picture.
  
 4.Compare the before and after pictures, and express as postconditions the 
  
 changes in the state of the stage (A 
 SalesLineltem was created...).",NA
"If Contracts Are Used, How Complete Should Postconditions Be?","First, contracts may not be needed. This question is discussed in a subsequent section. 
 But assuming some contracts are desired, generating a complete and detailed set of 
 postconditions for a system operation is not likely—or even neces-sary—during 
 requirements work. Treat their creation as an initial best guess, with the understanding 
 that the contracts will not be complete. Their early cre-ation—even if incomplete—is 
 certainly better than deferring this investigation
  
 181",NA
13.5     Discussion—enterltem Postconditions,"The following section dissects the motivation for the postconditions of the 
 enter-
 Item 
 system operation.",NA
Instance Creation and Deletion,"After the 
 itemID 
 and 
 quantity 
 of an item have been entered, what new object 
 should have been created? A 
 SalesLineltem. 
 Thus:
  
 • 
  
 A 
 SalesLineltem 
 instance 
 sll 
 was created (instance creation).
  
 Note the naming of the instance. This name will simplify references to the new 
 instance in other post-condition statements.",NA
Attribute Modification,"After the itemID and quantity of an item have been entered by the cashier, what 
 attributes of new or existing objects should have been modified? The 
 quantity 
 of 
 the 
 SalesLineltem 
 should have become equal to the 
 quantity 
 parameter. Thus:
  
 • 
  
 sll.quantity 
 became 
 quantity 
 (attribute modification).",NA
Associations Formed and Broken,"After the 
 itemID 
 and 
 quantity 
 of an item have been entered by the cashier, what 
 associations between new or existing objects should have been formed or broken? 
 The new 
 SalesLineltem 
 should have been related to its 
 Sale, 
 and related to its 
 ProductSpeciflcation. 
 Thus:
  
 •
  
 •
  
 sli 
 was associated with the current 
 Sale 
 (association formed). 
  
 sli 
 was associated with a 
 ProductSpeciflcation, 
 based on 
 ItemID 
 match 
 (association formed). 
  
 182",NA
13.6 ,NA,NA
Writing Contracts Leads to Domain Model Updates,"It is common during the creation of the contracts to discover the need to record 
 new conceptual classes, attributes, or associations in the Domain Model. Do not 
 be limited to the prior definition of the Domain Model; enhance it as you make 
 new discoveries while thinking through the operation contracts.",NA
13.7 ,NA,NA
When Are Contracts Useful? Contracts vs. Use Cases?,"The use cases are the main repository of requirements for the project. They may 
 provide most or all of the detail necessary to know what to do in the design, in 
 which case, contracts are not helpful. However, there are situations where the 
 details and complexity of required state changes are awkward to capture in use 
 cases.
  
 For example, consider an airline reservation system and the system operation 
 addNewReservatlon. 
 The complexity is very high regarding all the domain 
 objects that must be changed, created, and associated. These fine-grained details 
 can 
 be written up in the use case associated with this operation, but it will make 
 the use case extremely detailed (for example, noting each attribute in all the 
 objects that must change).
  
 Observe that the contract post-condition format offers and encourages a very 
 precise, analytical, exacting language that supports detailed thoroughness.
  
 If, just based on the use cases and through ongoing (verbal) collaboration with a 
 subject matter expert, the developers can comfortably understand what to do, then 
 avoid writing contracts.
  
 However, in those situations were there is high complexity and detailed preci-
 sion adds value, contracts are another requirements tool.
  
 They will not be practically motivated very often, so if a team is making con-tracts 
 for every system operation of every use case, it is a warning that either the use 
 cases are poorly done, there is not enough ongoing collaboration or access to a 
 subject matter expert, or the team is doing too much unnecessary documentation.
  
 This NextGen POS case study shows more contracts than are probably necessary, 
 for educational reasons. In practice, most of the details they record are obviously 
 inferable from the use case text. On the other hand, ""obvious"" is a very slippery 
 concept.
  
 183",NA
13.8     Guidelines: Contracts,"Apply the following advice to create contracts:
  
 To make contracts: 
  
 1.Identify system operations from the SSDs. 
  
 2.For system operations that are complex and perhaps subtle in their 
  
 results, or 
 which are not clear in the use case, construct a contract. 
  
 3.To describe the postconditions, use the following categories: o    
 instance creation and deletion 
  
 o    attribute modification 
  
 o    associations formed and broken",NA
Advice on Writing Contracts,"
  
 State the postconditions in a declarative, passive past tense form 
 (was 
 ...) 
  
 to emphasize the declaration of a state change rather than a design of how it is 
 going to be achieved. For example:
  
 
 (better) A 
 SalesLineltem 
 was created. .) 
  
 
 (worse) Create a 
 SalesLineltem.
  
 
  
 Remember to establish a memory between existing objects or those 
  
 newly created by defining the forming of an association. For example, it is 
 not enough that a new 
 SalesLineltem 
 instance is created when the 
 enterltem 
 operation occurs. After the operation is complete, it should also be true that 
 the newly created instance was associated with 
 Sale; 
 thus:
  
 
 The  
 SalesLineltem  
 was  associated with  the  
 Sale  
 (association 
  
 formed).",NA
The Most Common Mistake in Creating Contracts,"The most common problem is forgetting to include the 
 forming of associations. 
 Particularly when new instances are created, it is very likely that associations to 
 several objects need be established. Don't forget!
  
 184",NA
13.9     NextGen POS Example: Contracts,NA,NA
System Operations of Process Sale ,"Contract CO1: makeNewSale
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 makeNewSale() 
  
 Use Cases: Process Sale 
  
 none
  
 - A Sale instance s was created (instance creation). 
  
 - s was associated with the Register (association formed). - 
 Attributes of s were initialized. 
  
 Note the vague description in the last post-condition. If sufficient, this is fine.
  
 On a project, all these particular postconditions are so obvious from the use case that 
 the 
 makeNewSale 
 contract should probably not be written.
  
 Recall one of the guiding principles of healthy process and the UP: Keep it as light as 
 possible, and avoid all artifacts unless they really add value.
  
 Contract CO2: enterltem
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 enterltem(itemlD : ItemID, quantity : integer) 
 Use Cases: Process Sale There is a sale 
 underway.
  
 - 
 A SalesLineltem instance sli was created (instance cre 
  
 ation).
  
 - 
 sli was associated with the current Sale (association 
 formed). 
  
 - 
 sli.quantity became quantity (attribute modification). 
 - 
 sli 
 was associated with a ProductSpecification, based on 
 itemID match (association formed). 
  
 Contract COS: endSale
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 endSaleQ 
  
 Use Cases: Process Sale 
  
 There is a sale underway.
  
 - 
 Sale.isComplete became true (attribute modification).
  
  
 185",NA
13.10   Changes to the Domain Model,"There is one datum suggested by these contracts that is not yet represented in the 
 domain model: completion of item entry to the sale. The 
 endSale 
 specification 
 modifies it, and it is probably a good idea later during design work for the 
 makePayment 
 operation to test it, to disallow payments until a sale is complete.
  
 One way to represent this information is with an 
 isComplete 
 attribute in the 
 Sale, 
 of 
 boolean data type:
  
  
  
 There are alternatives, especially considered during design work. One technique is 
 called the 
 State pattern, 
 which is explored in Chapter 34. Another is the use of 
 ""session"" objects that track the state of a session and disallow out-of-order operations; 
 this too will be explored later.",NA
"13.11   Contracts, Operations, and the UML",NA,NA
Contracts in the UML: Operation Specifications,"The UML formally defines 
 operations. 
 To quote:
  
 An operation is a specification of a transformation or query that an object 
 may be called to execute [RJB99]
  
 186",NA
Operation Contracts Expressed with the OCL,"Associated with the UML is a formal language called the Object Constraint Lan-guage 
 (OCL) [WK99], which can be used to express constraints in models. The OCL could be 
 used instead of the informal natural language used in this chapter; 
  
  
 Further OCL details are beyond the scope of this introduction.
  
 the UML allows any format for an operation specification.
  
 187",NA
Contracts in Design by Contract,"The pre- and post-condition contract form used for UML operation specifications has 
 been promoted for many years by Bertrand Meyer, formalized in a design approach 
 called 
 Design by Contract 
 [Meyer97 (first ed. 1989)], although its origin is from 
 earlier work in the 1960s on formal specification languages. In Design by Contract, 
 contracts are also written for operations of fine-grained classes, not only the public 
 operations of systems or subsystems.
  
 In addition, Design by Contract promotes the inclusion of an 
 invariant 
 section, as is 
 common in thorough contract specifications. Invariants define things that must not 
 change state before and after the operation has executed. Invariants have not been 
 used in this chapter for the sake of simplicity.",NA
Programming Language Support for Contracts,"Some languages, such as Eiffel, have first-class support for invariants and pre-and 
 postconditions. There are pre-processors that provide similar support in Java.",NA
13.12   Operation Contracts Within the UP,"A pre- and postcondition contract is a well-known style to specify an operation in the 
 UML. In the UML, operations exists at many levels, from System, down to fine-
 grained classes, such as 
 Sale. 
 Operation specification contracts for the System level 
 are part of the Use-Case Model, although they were not formally highlighted in the 
 original RUP or UP documentation; their inclusion in this model was verified with the 
 RUP authors.
 1",NA
Phases,"Inception
 —Contracts are not motivated during inception—they are too detailed.
  
 Elaboration
 —If used at all, most contracts will be written during elaboration, when 
 most use cases are written. Only write contracts for the most complex and subtle 
 system operations.
  
 1. Private communication.
  
 188",NA
13.13   Further Readings,"Operation contracts come out of the formal specifications area, and have been used 
 and refined since the 1960s, such as in the Vienna Development Method (VDM) 
 [BJ78]; there is a wealth of literature on VDM and other formal specifi-cation 
 languages.
  
 Bertrand Meyer contributed to a much wider awareness of formal specifications 
 and contracts with the inclusion of pre- and postconditions within the Eiffel lan-
 guage; his 
 Object-Oriented Software Construction 
 provides details. He is respon-
 sible for the notion of 
 Design by Contract.
  
 Within the UML, operation contracts can also be specified more rigorously in the 
 Object Constraint Language (OCL), for which Warmer and Kleppe's 
 The Object 
 Constraint Language: Precise Modeling with UML 
 is required reading.
  
 191",NA
Chapter 14,NA,NA
FROM REQUIREMENTS TO ,NA,NA
DESIGN IN THIS ITERATION,NA,NA
Introduction,"So far, the case study has emphasized investigation of the requirements, concepts, 
 and operations related to a system. Following the UP guidelines, perhaps 10% of 
 the requirements were investigated in inception, and a slightly deeper 
 investigation was started in this first iteration of elaboration. The following 
 chapters are a shift in emphasis toward designing a solution for this iteration in 
 terms of collaborating software objects.",NA
"14.1     Iteratively Do the Right Thing, Do the Thing Right","The requirements and object-oriented analysis has focused on learning to 
 do the 
 right thing; 
 that is, understanding some of the outstanding goals for the Next-Gen 
 POS, and related rules and constraints. By contrast, the following design work 
 will stress 
 do the thing right; 
 that is, skillfully designing a solution to satisfy the 
 requirements for this iteration.
  
 193",NA
"14.2     Didn't That Take Weeks To Do? No, Not Exactly.","After many chapters of detailed discussion, it must surely seem like the prior 
 modeling would take weeks of effort. Not so. When one is comfortable with the 
 skills of use case writing, domain modeling, and so forth, the duration to do all 
 the actual modeling that has been explored so far is realistically just 
 a few 
 days.
  
 However, that does not mean that only a few days have passed since the start of 
 the project. Many other activities, such as proof-of-concept programming, finding 
 resources (people, software, ...), planning, setting up the environment, and so on, 
 could consume a few weeks of preparation.",NA
14.3     On to Object Design,"During object design, a logical solution based on the object-oriented paradigm is 
 developed. The heart of this solution is the creation of 
 interaction diagrams, 
 which illustrate how objects collaborate to fulfill the requirements.
  
 After—or in parallel with—drawing interaction diagrams, (design) 
 class dia-
 grams 
 can be drawn. These summarize the definition of the software classes (and 
 interfaces) that are to be implemented in software.
  
 In terms of the UP, these artifacts are part of the 
 Design Model.
  
 In practice, the creation of interaction and class diagrams happens in parallel 
 and synergistically, but their introduction is linear in this case study, for 
 simplicity and clarity.",NA
The Importance of Object Design Skill vs. UML Notation Skill,"The following chapters explore the creation of these artifacts, or more precisely, 
 the object design skills underlying their creation. What is important is knowing
  
 194",NA
Chapter 15,NA,NA
INTERACTION DIAGRAM ,NA,NA
NOTATION,"Cats are smarter than dogs. You can't 
  
 get eight cats to pull a sled through snow.
  
 —JeffVaidez",NA
Objectives,"Read basic UML interaction (sequence and collaboration) diagram 
 notation.",NA
Introduction,"The following chapters explore object design. The language used to illustrate the 
 designs is primarily interaction diagrams. Thus, it is advisable to at least skim the 
 examples in this chapter and get familiar with the notation before moving on.
  
 The UML includes 
 interaction diagrams 
 to illustrate how objects interact via 
 messages. This chapter introduces the notation, while subsequent chapters focus 
 on using them in the context of learning and doing object design for the NextGen 
 POS case study.",NA
Read the Following Chapters for Design Guidelines,"This chapter introduces notation. To create well-designed objects, design princi-
 ples must also be understood. After acquiring some familiarity with the notation 
 of interaction diagrams, it is important to study the following chapters on these 
 principles and how to apply them while drawing interaction diagrams.
  
 197",NA
15.1     Sequence and Collaboration Diagrams,"The term 
 interaction diagram, 
 is a generalization of two more specialized UML 
 diagram types; both can be used to express similar message interactions:
  
 •
  
 collaboration diagrams 
  
 •
  
 sequence diagrams 
  
 Throughout the book, both types will be used, to emphasize the flexibility in 
 choice.
  
 Collaboration diagrams 
 illustrate object interactions in a graph or network 
 format, in which objects can be placed anywhere on the diagram, as shown in 
 Figure 15.1.
  
  
 Figure 15.1 Collaboration diagram 
  
  
 Figure 15.2 Sequence diagram. 
  
 Each type has strengths and weaknesses. When drawing diagrams to be pub-lished 
 on pages of narrow width, collaboration diagrams have the advantage of allowing 
 vertical expansion for new objects; additional objects in a sequence dia-grams 
 must extend to the right, which is limiting. On the other hand, collabora-tion 
 diagram examples make it harder to easily see the sequence of messages.
  
 198",NA
15.2     Example Collaboration Diagram: makePayment,"Figure 15.3 Collaboration diagram.
  
 The collaboration diagram shown in Figure 15.3 is read as follows: 
  
 1.The message 
 makePayment is 
 sent to an instance of a 
 Register. 
 The sender is 
 not identified. 
  
 2.The 
 Register 
 instance sends the 
 makePayment 
 message to a 
 Sale 
 instance. 
 3.The 
 Sale 
 instance creates an instance of a 
 Payment.
  
 199",NA
15.3     Example Sequence Diagram: makePayment,": Sale 
  
 : Sale
  
 makePayment(cashTendered)
  
 makePayment(cashTendered)
  
 create(cashTendered)
  
 : Payment
  
 implies Sale objects have a
  
 responsibility to create Payments
  
 Figure 15.4 Sequence diagram.
  
 The sequence diagram shown in Figure 15.4 has the same intent as the prior 
 collaboration diagram.",NA
15.4     Interaction Diagrams Are Valuable,"A common problem in object technology projects is a lack of appreciation for the 
 value of doing object design via the medium of interaction diagrams. A related 
 problem is doing them in a vague way, such as showing messages to objects that 
 actually require much further elaboration; for example, showing the message 
 runSimulation 
 to some 
 Simulation 
 object, but not continuing on with the more 
 detailed design, as though by virtue of a well-named message the design is mag-
 ically complete.
  
 Some non-trivial time and effort should be spent in the creation of interaction 
 diagrams, as a reflection of thinking through details of the object design. For 
 example, if the length of the timeboxed iteration is two weeks, perhaps a half or 
 full day near the start of the iteration should be spent on their creation (and in 
 parallel, class diagrams), before proceeding to programming. Yes, the design 
 illustrated in the diagrams will be imperfect and is speculative, and it will be 
 modified during programming, but it will provide a thoughtful, cohesive, com-
 mon starting point for inspiration during programming.
  
 Create interaction diagrams in pairs, not alone. The collaborative design will 
 be improved, and the partners will learn quickly from each other.
  
 Note that it is primarily during this step that the application of design skill is 
 required, in terms of patterns, idioms, and principles. Relatively speaking, the 
 creation of use cases, domain models, and other artifacts is easier than the
  
 200",NA
15.5     Common Interaction Diagram Notation ,NA,NA
Illustrating Classes and Instances,"The UML has adopted a simple and consistent approach to illustrate 
 instances 
 vs. 
 classifiers (see Figure 15.5):
  
 •     
 For 
 any kind of UML element (class, actor, ...), an instance uses the same graphic 
  
 symbol as the type, but the designator string is underlined.
  
 Sale
  
 :Sale
  
 s1: Sale
  
 class
  
 instance
  
 named instance
  
 Figure 15.5 Class and instances.
  
 Therefore, to show an instance of a class in an interaction diagram, the regular class 
 box graphic symbol is used, but the name is underlined.
  
 A name can be used to uniquely identify the instance. If none is used, note that a "":"" 
 precedes the class name.
  
 201",NA
Basic Message Expression Syntax,"The UML has a standard syntax for message expressions:
  
 return := message(parameter : parameterType) : returnType
  
 Type information may be excluded if obvious or unimportant. For 
 example:
  
 spec := getProductSpect(id) 
  
 spec := 
 getProductSpect(id:ItemID) spec 
 := getProductSpect(id:ItemID)
  
 ProductSpecification",NA
15.6     Basic Collaboration Diagram Notation,NA,NA
Links,"A link 
 is a connection path between two objects; it indicates some form of navi-
 gation and visibility between the objects is possible (see Figure 15.6). More for-
 mally, a link is an instance of an association. For example, there is a link—or path of 
 navigation—from a 
 Register 
 to a 
 Sale, 
 along which messages may flow, such as the 
 makePayment 
 message.
  
 : Register
  
 1: makePayment(cashTendered)
  
  
 :Sale
  
 2: foo()
  
 2.1: bar()
  
 Figure 15.6 Link lines. 
  
 link line
  
 Note that multiple messages, and messages both ways, can flow along the same 
 single link.",NA
Messages,"Each message between objects is represented with a message expression and small 
 arrow indicating the direction of the message. Many messages may flow
  
 202",NA
"Messages to ""self"" or ""this""","A 
 message can be sent from an object to itself (Figure 15.8). This is illustrated by a link 
 to itself, with messages flowing along the link.
  
 msg1()
  
 : Register
  
 1: clear()
  
 Figure 15.8 Messages to ""this.""",NA
Creation of Instances,"Any message can be used to create an instance, but there is a convention in the UML 
 to use a message named 
 create 
 for this purpose. If another (perhaps less obvious) 
 message name is used, the message may be annotated with a special feature called a 
 UML stereotype, like so: 
 «create».
  
 The 
 create 
 message may include parameters, indicating the passing of initial values. 
 This indicates, for example, a constructor call with parameters in Java.
  
 203",NA
Message Number Sequencing,"The order of messages is illustrated with 
 sequence numbers, 
 as shown in Figure 
 15.10. The numbering scheme is:
  
 1.The first message is not numbered. Thus,
 msg1() 
 is unnumbered. 
  
 2.The order and nesting of subsequent messages is shown with a legal num bering 
 scheme in which nested messages have a number appended to them. Nesting 
 is denoted by prepending the incoming message number to the out going 
 message number. 
  
 not numbered
  
 msg1()
  
 :ClassA
  
 1: msg2()
  
 :ClassB
  
 legal numbering
  
 1.1: msg3()
  
 :ClassC
  
 In Figure 15.11 a more complex case is shown.
  
 204",NA
Conditional Messages,"A conditional message (Figure 15.12) is shown by following a sequence number 
 with a conditional clause in square brackets, similar to an iteration clause. The 
 message is only sent if the clause evaluates to 
 true.
  
 conditional message, with test
  
 message1()
  
 : Foo
  
 1 [ color = red ] :  calculate()
  
 : Bar
  
 Figure 15.12 Conditional message.",NA
Mutually Exclusive Conditional Paths,"The example in Figure 15.13 illustrates the sequence numbers with mutually 
 exclusive conditional paths.
  
 205",NA
Iteration or Looping,"Iteration notation is shown in Figure 15.14. If the details of the iteration clause 
 are not important to the modeler, a simple '*' can be used.
  
 runSimulation()
  
 : Simulator
  
 1 * [i:=1..N]: num := nextInt()
  
 : Random
  
 iteration is indicated with a * and an optional
  
 iteration clause following the sequence number
  
 Figure 15.14 Iteration.
  
 206",NA
Iteration Over a Collection (Multiobject),"A common algorithm is to iterate over all members of a collection (such as a list 
 or map), sending a message to each. Often, some kind of iterator object is 
 ultimately used, such as an implementation of 
 java.util.Iterator 
 or a C++ standard 
 library iterator. In the UML, the term 
 multiobject 
 is used to denote a set of 
 instances—a collection. In collaboration diagrams, this can be summarized as 
 shown in Figure 15.15.
  
 t := getTotal()
  
 : Sale
  
 1 *: st := getSubtotal()",NA
*,":SalesLineItem 
  
 :SalesLineItem
  
 double box indicates a multiobject (collection)
  
 these two * symbols used together imply 
  
 iteration over the multiobject and sending the 
 getSubtotal 
 message to each member
  
 for example, a 
 List 
 object containing many 
 SalesLineItem 
 objects
  
 Figure 15.15 Iteration over a multiobject.
  
 The ""*"" multiplicity marker at the end of the link is used to indicate that the 
 message is being sent to each element of the collection, rather than being 
 repeatedly sent to the collection object itself.",NA
Messages to a Class Object,"Messages may be sent to a class itself, rather than an instance, to invoke class or 
 static methods. 
 A message is shown to a class box whose name is not underlined, 
 indicating the message is being sent to a class rather than an instance (see Figure 
 15.16).
  
 message to class, or a
  
 static method call
  
 msg1()
  
 : InstanceOfFoo
  
 list := synchronizedList( aList )
  
 java.util.Collections
  
 not underlined,
  
 therefore a class
  
 Figure 15.16 Messages to a class object (static method invocation).
  
 207",NA
15.7     Basic Sequence Diagram Notation,NA,NA
Links,"Unlike collaboration diagrams, sequence diagrams do not show links.",NA
Messages,"Each message between objects is represented with a message expression on an 
 arrowed line between the objects (see Figure 15.17). The time ordering is orga-nized 
 from top to bottom.
  
 : Register 
  
 : Sale
  
 msg1() 
  
  
 msg2()
  
 msg3()
  
 msg4()
  
 msg5()
  
 Figure 15.17 Messages and focus of control with activation boxes.",NA
Focus of Control and Activation Boxes,"As illustrated in Figure 15.17, sequence diagrams may also show the focus of control 
 (that is, in a regular blocking call, the operation is on the call stack) using an 
 activation box. 
 The box is optional, but commonly used by UML prac-titioners.
  
 208",NA
Illustrating Returns,"A sequence diagram may optionally show the return from a message as a dashed 
 open-arrowed line at the end of an activation box (see Figure 15.18). Many 
 practitioners exclude them. Some annotate the return line to describe what is 
 being returned (if anything) from the message.
  
 : Register : Sale
  
 msg1() 
  
  
 msg2()
  
 msg3()
  
 msg4()
  
 msg5()
  
 Figure 15.18 Showing returns.",NA
"Messages to ""self"" or ""this""","A message can be illustrated as being sent from an object to itself by using a 
 nested activation box (see Figure 15.19).
  
 : Register
  
 msg1()
  
 clear()
  
 Figure 15.19 Messages to ""this.""
  
 209",NA
Creation of Instances,": Register
  
 : Sale
  
 note that newly created
  
 objects are placed at their
  
 creation ""height""
  
 makePayment(cashTendered) 
  
  
 create(cashTendered) 
  
 : Payment
  
 authorize()
  
 an object lifeline shows the extent of
  
 the life of the object in the diagram
  
 Figure 15.20 Instance creation and object lifelines.",NA
Object Lifelines and Object Destruction,"Figure 15.20 also illustrates 
 object lifelines
 —the vertical dashed lines under-neath 
 the objects. These indicate the extent of the life of the object in the diagram. In 
 some circumstances it is desirable to show explicit destruction of an object (as in 
 C++, which does not have garbage collection); the UML lifeline notation provides 
 a way to express this destruction (see Figure 15.21).
  
 : Sale
  
 create(cashTendered)
  
 : Payment
  
 the «destroy» stereotyped
  
 ...
  
 message, with the large
  
 X and short lifeline
  
 «destroy»",NA
X,"indicates explicit object
  
 destruction
  
 Figure 15.21 Object destruction",NA
Conditional Messages ,"A conditional message is shown in Figure 15.22. 
  
 message1()
  
 : Foo
  
 [ color = red ] calculate()
  
 : Bar
  
 Figure 15.22 A conditional message.",NA
Mutually Exclusive Conditional Messages ,"The notation for this case is a kind of angled message line emerging from a com-
  
 mon point, as illustrated in Figure 15.23.
  
 message1()
  
 : A
  
 [ x < 10 ] calculate()
  
 : B
  
 : C
  
 [ x > 15 ] calculate()
  
 Figure 15.23 Mutually exclusive conditional messages.",NA
Iteration for a Single Message ,"Iteration notation for one message is shown in Figure 15.24.
  
 : Simulator 
  
 : Random
  
 runSimulation()
  
 * [i:=1..N]: num := nextInt()
  
 Figure 15.24 Iteration for one message.
  
 211",NA
Iteration of a Series of Messages,"Notation to indicate iteration around a series of messages is shown in Figure 
 15.25.",NA
Iteration Over a Collection (Multiobject),"In sequence diagrams, iteration over a collection is shown in Figure 15.26.
  
 With collaboration diagrams the UML specifies a '*' multiplicity marker at the 
 end of the role (next to the multiobject) to indicate sending a message to each 
 element rather than repeatedly to the collection itself. However, the UML does 
 not specify how to indicate this with sequence diagrams.",NA
Messages to Class Objects,"As in a collaboration diagram, class or static method calls are shown by not 
 underlining the name of the classifier, which signifies a class object rather than 
 an instance (see Figure 15.27).
  
 : Simulator
  
 : Random
  
 : Programmer
  
 runSimulation()
  
 hours := nextInt()
  
 work( hours )
  
 * [i:=1..N]
  
 eat()
  
 Figure 15.25 Iteration for a sequence of 
  
 212",NA
Chapter 16,NA,NA
GRASP: ,NA,NA
DESIGNING OBJECTS ,NA,NA
WITH RESPONSIBILITIES,"The most likely way for the world to be destroyed, most 
 experts agree, is by accident. That's where we come in; 
 we're computer professionals. We cause accidents.
  
 —
 Nathaniel Borenstein",NA
Objectives ,"Define patterns.
  
 Learn to apply five of the GRASP patterns.",NA
Introduction,"Object design is sometimes described as some variation of the following:
  
 After identifying your requirements and creating a domain model, 
 then add methods to the software classes, and define the 
 messaging between the objects to fulfill the requirements.
  
 Such terse advice is not especially helpful, because there are deep principles and 
 issues involved in these steps. Deciding what methods belong where, and how the 
 objects should interact, is terribly important and anything but trivial. It takes 
 careful explanation, applicable while diagramming and programming.
  
 And this is a critical step—this is at the heart of what it means to develop an 
 object-oriented system, not drawing domain model diagrams, package diagrams, 
 and so forth.
  
 215",NA
GRASP as a Methodical Approach to Learning Basic Object ,NA,NA
Design,"It 
 is 
 possible to communicate the detailed principles and reasoning required to grasp 
 basic object design, and to learn to apply these in a methodical approach that removes 
 the magic and vagueness.
  
 The GRASP patterns are a learning aid to help one understand essential object 
 design, and apply design reasoning in a methodical, rational, explainable way. This 
 approach to understanding and using design principles is based on 
 patterns of 
 assigning responsibilities.",NA
16.1      Responsibilities and Methods,"The UML defines a 
 responsibility 
 as ""a contract or obligation of a classifier"" 
 [OMG01]. Responsibilities are related to the obligations of an object in terms of its 
 behavior. Basically, these responsibilities are of the following two types:
  
 •
  
 •
  
 knowing 
  
 doing 
  
 Doing 
 responsibilities of an object include:
  
 o    doing something itself, such as creating an object or 
  
 doing a calculation
  
 o    initiating action in other objects
  
 ocontrolling and coordinating activities in other objects 
  
 Knowing 
 responsibilities of an object include:
  
 o    knowing about private encapsulated data 
  
 o    knowing about related objects
  
 o    knowing about things it can derive or calculate
  
 Responsibilities are assigned to classes of objects during object design. For example, 
 I may declare that ""a 
 Sale 
 is responsible for creating 
 SalesLineltems"" 
 (a doing), or ""a 
 Sale 
 is responsible for knowing its total"" (a knowing). Relevant responsibilities 
 related to ""knowing"" are often inferable from the domain model, because of the 
 attributes and associations it illustrates.
  
 The translation of responsibilities into classes and methods is influenced by the 
 granularity of the responsibility. The responsibility to ""provide access to rela-tional 
 databases"" may involve dozens of classes and hundreds of methods, pack-aged in a 
 subsystem. By contrast, the responsibility to ""create a 
 Sale"" 
 may involve only one or 
 few methods.
  
 216",NA
16.2     Responsibilities and Interaction Diagrams,"The purpose of this chapter is to help methodically apply fundamental principles 
 for assigning responsibilities to objects. This will often be done while pro-
 gramming. Within the UML artifacts, a common context where these 
 responsibilities (implemented as methods) are considered is during the creation of 
 interaction diagrams (which are part of the UP Design Model), whose basic 
 notation we examined in the previous chapter.
  
 : Sale
  
 makePayment(cashTendered)
  
 create(cashTendered)
  
 : Payment
  
 implies Sale objects have a
  
 responsibility to create Payments
  
 Figure 16.1 Responsibilities and methods are related.
  
 Figure 16.1 indicates that 
 Sale 
 objects have been given a responsibility to create 
 Payments, 
 which is invoked with a 
 makePayment 
 message and handled with a 
 corresponding 
 makePayment 
 method. Furthermore, the fulfillment of this 
 responsibility requires collaboration to create the 
 SalesLineltem 
 object and invoke 
 its constructor.
  
 In summary, interaction diagrams show choices in assigning responsibilities to 
 objects. When created, decisions in responsibility assignment are made, which 
 are reflected in what messages are sent to different classes of objects. This 
 chapter emphasizes fundamental principles—expressed in the GRASP patterns—
 to guide choices in where to assign responsibilities. These choices are reflected in 
 interaction diagrams.
  
 217",NA
16.3     Patterns,"Experienced object-oriented developers (and other software developers) build up a 
 repertoire of both general principles and idiomatic solutions that guide them in the 
 creation of software. These principles and idioms, if codified in a structured format 
 describing the problem and solution, and given a name, may be called 
 patterns. 
 For 
 example, here is a sample pattern:
  
 Pattern Name: 
  
 Solution:
  
 Problem It Solves:
  
 Information Expert 
  
 Assign a responsibility to the class that has the 
 information needed to fulfill it.
  
 What is a basic principle by which to assign 
 responsibilities to objects?
  
 In object technology, a 
 pattern 
 is a named description of a problem and solution 
  
 that can be applied to new contexts; ideally, it provides advice in how to apply it in 
 varying circumstances, and considers the forces and trade-offs.
 1
  Many patterns 
  
 provide guidance for how responsibilities should be assigned to objects, given a 
  
 specific category of problem. 
  
 Most simply,  a 
 pattern
  is a named problem/solution pair that can be applied in 
 new context, with advice on how to apply it in novel situations and discussion 
 of its trade-offs. 
  
 ""One person's pattern is another person's primitive building block"" is an object 
  
 technology adage illustrating the vagueness of what can be called a pattern 
  
 [GHJV94]. This treatment of patterns will bypass the issue of what is appropriate 
  
 to label a pattern, and focus on the pragmatic value of using the pattern style as 
  
 a vehicle for naming, presenting, learning, and remembering useful software 
  
 engineering principles.",NA
Repeating Patterns,"New pattern 
 could be considered an oxymoron, if it describes a new idea. The very 
 term ""pattern"" is meant to suggest a repeating thing. The point of patterns is not to 
 express new design ideas. Quite the opposite is true—patterns attempt to codify 
 existing 
 tried-and-true knowledge, idioms, and principles; the more honed and widely 
 used, the better.
  
 1. The formal notion of patterns originated with the (building) architectural patterns 
 of Christopher Alexander [AIS77]. Patterns for software originated in the 1980s 
 with Kent Beck, who became aware of Alexander's pattern work in architecture, 
 and then were developed by Beck with Ward Cunningham [BC87, Beck94].",NA
Patterns Have Names,"All patterns ideally have suggestive names. Naming a pattern, technique, or principle 
 has the following advantages:
  
 •
  
 •
  
 It supports chunking and incorporating that concept into our understanding and 
 memory. 
  
 It facilitates communication. 
  
 Naming a complex idea such as a pattern is an example of the power of abstrac-tion—
 reducing a complex form to a simple one by eliminating detail. Therefore, the GRASP 
 patterns have concise names such as 
 Information Expert, Creator, Protected 
 Variations.
  
 Naming Patterns Improves Communication
  
 When a pattern is named, we can discuss with others a complex principle or design 
 idea with a simple name. Consider the following discussion between two software 
 designers, using a common vocabulary of patterns 
 (Creator, Factory, 
 and so on) to 
 decide upon a design:
  
 Fred: 
 ""Where do you think we should place the responsibility for creating a 
 SalesLineltem? 
 I think a 
 Factory.""
  
 Wilma: 
 ""By 
 Creator, 
 I think 
 Sale 
 will be suitable."" 
  
 Fred: 
 ""Oh, right—I agree.""
  
 Chunking design idioms and principles with commonly understood names facili-tates 
 communication and raises the level of inquiry to a higher degree of abstraction.",NA
16.4     GRASP: Patterns of General Principles in ,NA,NA
Assigning ,NA,NA
Responsibilities,"To summarize the preceding introduction:
  
 •
  
 •
  
 The skillful assignment of responsibilities is extremely important in object design. 
  
 Determining the assignment of responsibilities often occurs during the cre ation 
 of interaction diagrams, and certainly during programming. 
  
 219",NA
How to Apply the GRASP Patterns,"The following sections present the first five GRASP patterns:
  
 •
  
 •
  
 •
  
 •
  
 •
  
 Information Expert 
  
 Creator 
  
 High Cohesion 
  
 Low Coupling 
  
 Controller 
  
 There are others, introduced in a later chapter, but it is worthwhile mastering these 
 five first because they address very basic, common questions and funda-mental 
 design issues.
  
 Please study the following patterns, note how they are used in the example 
 interaction diagrams, and then apply them during the creation of new interaction 
 diagrams. Start by 
 mastering Information Expert, Creator, Controller, High 
 Cohesion, 
 and 
 Low Coupling. 
 Later, learn the remaining patterns.",NA
16.5     The UML Class Diagram Notation,"A UML class box used to illustrate software classes often shows three compart-
 ments; the third illustrates the methods of the class, as shown in Figure 16.2.
  
 2. Technically, one should write ""GRAS Patterns"" rather than ""GRASP Patterns,"" but 
 the 
  
 latter sounds better.
  
 220",NA
16.6     Information Expert (or Expert),"Solution   
 Assign a responsibility to the information expert—the class that has the 
 infor-
 mation 
 necessary to fulfill the responsibility.
  
 Problem   
 What is a general principle of assigning responsibilities to objects?
  
 A Design Model may define hundreds or thousands of software classes, and an 
 application may require hundreds or thousands of responsibilities to be fulfilled. 
 During object design, when the interactions between objects are defined, we 
 make choices about the assignment of responsibilities to software classes. Done 
 well, systems tend to be easier to understand, maintain, and extend, and there is 
 more opportunity to reuse components in future applications.
  
 Example   
 In the NextGEN POS application, some class needs to know the grand total of a
  
 sale.
  
  
 By this advice, the statement is:
  
 Who should be responsible for knowing the grand total of a sale""?
  
 By 
 Information Expert, 
 we should look for that class of objects that has the 
 information needed to determine the total.
  
 Now we come to a key question: Do we look in the Domain Model or the Design 
 Model to analyze the classes that have the information needed? The Domain 
 Model illustrates conceptual classes of the real-world domain; the Design Model 
 illustrates software classes.
  
 221",NA
*,"Described-by
  
 1
  
 Product
  
 Sales
  
 Specification
  
 LineItem
  
 description
  
 quantity
  
 price
  
 itemID
  
 Figure 16.3 Associations of Sale.
  
 What information is needed to determine the grand total? It is necessary to know about 
 all the 
 SalesLineltem 
 instances of a sale and the sum of their subtotals. A 
 Sale 
 instance 
 contains these; therefore, by the guideline of Information Expert, 
 Sale 
 is a suitable 
 class of object for this responsibility; it is an 
 information expert 
 for the work.
  
 As mentioned, it is in the context of the creation of interaction diagrams that these 
 questions of responsibility often arise. Imagine we are starting to work through the 
 drawing of diagrams in order to assign responsibilities to objects. A partial interaction 
 diagram and class diagram in Figure 16.4 illustrate some decisions.
  
 222",NA
*,":SalesLineItem 
 :SalesLineItem
  
 getTotal()
  
 SalesLineItem
  
 quantity
  
 New method 
  
 getSubtotal()
  
 Figure 16.5 Calculating the Sale total
  
 To fulfill the responsibility of knowing and answering its subtotal, a 
 Sales-
 Lineltem 
 needs to know the product price.
  
 The 
 ProductSpecification 
 is an information expert on answering its price; there-
 fore, a message must be sent to it asking for its price.
  
 The design is shown in Figure 16.6.
  
 In conclusion, to fulfill the responsibility of knowing and answering the sale's 
 total, three responsibilities were assigned to three design classes of objects as 
 follows.
  
 223",NA
*,":SalesLineItem 
 :SalesLineItem
  
 getTotal()
  
 1.1: p := getPrice()
  
 SalesLineItem
  
 quantity
  
 :Product 
  
 Specification
  
 getSubtotal()
  
 Product 
  
 Specification
  
 description 
  
 price 
  
 itemID
  
 New method 
  
 getPrice()
  
 Figure 16.6 Calculating the 
 Sale 
 total.
  
 Discussion 
 Information Expert is frequently used in the assignment of responsibilities; it is a basic 
 guiding principle used continuously in object design. Expert is not meant to be an 
 obscure or fancy idea; it expresses the common ""intuition"" that objects do things 
 related to the information they have.
  
 Notice that the fulfillment of a responsibility often requires information that is spread 
 across different classes of objects. This implies that there are many ""partial"" 
 information experts who will collaborate in the task. For example, the sales total 
 problem ultimately required the collaboration of three classes of objects.
  
 224",NA
16.7     Creator,"Solution   
 Assign class B the responsibility to create an instance of class A if one or more of 
  
 the following is true:
  
 •
  
 •
  
 •
  
 •
  
 •
  
 B 
 aggregates 
 A objects. 
  
 B 
 contains 
 A objects. 
  
 B 
 records 
 instances of A objects. 
  
 B 
 closely uses 
 A objects. 
  
 B 
 has the initializing data 
 that will be passed to A when it is created (thus B 
 is an Expert with respect to creating A). 
  
 B is a 
 creator 
 of A objects.
  
 If more than one option applies, prefer a class B which 
 aggregates 
 or 
 contains 
 class A.
  
 Problem   
 Who should be responsible for creating a new instance of some class?
  
 The creation of objects is one of the most common activities in an object-oriented 
 system. Consequently, it is useful to have a general principle for the assignment 
 of creation responsibilities. Assigned well, the design can support low coupling, 
 increased clarity, encapsulation, and reusability.
  
 226",NA
*,"Described-by
  
 1
  
 Product
  
 Sales
  
 Specification
  
 LineItem
  
 description
  
 quantity
  
 price
  
 itemID
  
 Figure 16.7 Partial domain model.
  
 Since a Sate contains (in fact, aggregates) many 
 SalesLineltem 
 objects, the Cre-ator 
 pattern suggests that 
 Sale 
 is a good candidate to have the responsibility of creating 
 SalesLineltem 
 instances.
  
 This leads to a design of object interactions as shown in Figure 16.8.
  
 : Register 
  
 : Sale
  
 makeLineItem(quantity) 
  
  
 create(quantity) 
  
 : SalesLineItem
  
 Figure 16.8 Creating a SalesLineltem.
  
 This assignment of responsibilities requires that a 
 makeLineltem 
 method be defined 
 in Sate.
  
 Once again, the context in which these responsibilities were considered and decided 
 upon was while drawing an interaction diagram. The method section of
  
 227",NA
16.8     Low Coupling,"Solution   
 Assign a responsibility so that coupling remains low.
  
 Problem    
 How to support low dependency, low change impact, and increased reuse?
  
 Coupling 
 is a measure of how strongly one element is connected to, has knowl-
 edge of, or relies on other elements. An element with low (or weak) coupling is 
 not dependent on too many other elements; ""too many"" is context-dependent, but 
 will be examined. These elements include classes, subsystems, systems, and so 
 on.
  
 A class with high (or strong) coupling relies on many other classes. Such classes 
 may be undesirable; some suffer from the following problems:
  
 •
  
 •
  
 •
  
 Changes in related classes force local changes. 
  
 Harder to understand in isolation. 
  
 Harder to reuse because its use requires the additional presence of the classes 
 on which it is dependent. 
  
 Example   
 Consider the following partial class diagram from a NextGen case study:
  
  
 Assume we have a need to create a 
 Payment 
 instance and associate it with the 
 Sale. 
 What class should be responsible for this? Since a 
 Register 
 ""records"" a 
 Pay-
 ment 
 in the real-world domain, the Creator pattern suggests 
 Register 
 as a candi-
 date for creating the 
 Payment. 
 The 
 Register 
 instance could then send an 
 addPayment 
 message to the 
 Sale, 
 passing along the new 
 Payment 
 as a parameter. 
 A possible partial interaction diagram reflecting this is shown in Figure 16.9.
  
 makePayment()
  
 : Register
  
 1: create()
  
 p : Payment
  
 2: addPayment(p)
  
 :Sale
  
 Figure 16.9 Register creates Payment.
  
 This assignment of responsibilities couples the 
 Register 
 class to knowledge of the 
 Payment 
 class.
  
 229",NA
16.10   Controller,"Solution 
 Assign the responsibility for receiving or handling a system event message to a class 
 representing one of the following choices:
  
 •     Represents the overall system, device, or subsystem 
 (facade controller).
  
 •Represents a use case scenario within which the system event occurs, often 
  
 named 
  
 <UseCaseName>Handler, 
  
 <UseCaseName>Coordinator, 
  
 or 
  
 <Use-CaseName>Session 
 (use-case or session controller).
  
 o Use the same controller class for all system events in the same use 
  
 case 
 scenario.
  
 o Informally, a session is an instance of a conversation with an actor. 
 Sessions can be of any length, but are often organized in terms of use 
 cases (use case sessions).
  
 Corollary: 
 Note that ""window,"" ""applet,"" ""widget,"" ""view,"" and ""document"" classes 
 are not on this list. Such classes should 
 not 
 fulfill the tasks associated with system 
 events, they typically receive these events and delegate them to a controller.
  
 Problem   
 Who should be responsible for handling an input system event?
  
 An input 
 system event 
 is an event generated by an external actor. They are associated 
 with 
 system operations
 —operations of the system in response to system events, just 
 as messages and methods are related.
  
 For example, when a cashier using a POS terminal presses the ""End Sale"" button, he is 
 generating a system event indicating ""the sale has ended."" Similarly, when a writer 
 using a word processor presses the ""spell check"" button, he is generating a system 
 event indicating ""perform a spell check.""
  
 A Controller 
 is a non-user interface object responsible for receiving or handling a 
 system event. A Controller defines the method for the system operation.
  
 Example 
 In the NextGen application, there are several system operations, as illustrated in Figure 
 16.13, showing the system itself as a class or component (which is legal in the UML).
  
 System
  
 endSale() 
  
 enterItem() 
  
 makeNewSale() 
  
 makePayment() 
  
 . . .
  
 Figure 16.13 System operations associated with the system events.
  
 237",NA
16.11   Object Design and CRC Cards,"Although not formally part of the UML, another device sometimes used to help 
 assign responsibilities and indicate collaboration with other objects are 
 CRC 
 cards 
 (Class-Responsibility-Collaborator cards) [BC89]. These were pioneered by 
 Kent Beck and Ward Cunningham, who are largely responsible for encourag-ing 
 objects designers to think more abstractly in terms of responsibility assign-ment 
 and collaborations, and also for the use of patterns.
  
 245",NA
16.12   Further Readings,"The metaphor of 
  
 collaborating objects 
  
 with 
  
 responsibilities, 
  
 or 
  
 Responsibility-Driven Design, 
 especially emerged from the influential object 
  
 work in Smalltalk at Tektronix in Portland, from Kent Beck, Ward Cunningham, 
  
 Rebecca Wirfs-Brock, and others. 
 Designing Object-Oriented Software 
 [WWW90] 
  
 is the landmark text, and as relevant today as when it was written.
  
 Two other recommended texts emphasizing fundamental object design princi-
 ples are 
 Object-Oriented Design Heuristics 
 by Riel, and 
 Object Models 
 by Coad.
  
 246",NA
Chapter 17,NA,NA
DESIGN MODEL,NA,NA
: ,NA,NA
USE,NA,NA
-,NA,NA
CASE,NA,NA
REALIZATIONS ,NA,NA
WITH ,NA,NA
GRASP ,NA,NA
PATTERNS,"To invent, you need a good imagination and a pile of junk.
  
 —
 Thomas Edison",NA
Objectives,"• 
 • 
 • 
  
 Design use-case realizations. 
  
 Apply the GRASP patterns to assign responsibilities to classes. Use the 
 UML interaction diagram notation to illustrate the design of objects.",NA
Introduction,"This chapter explores how to create a design of collaborating objects with 
 responsibilities. Particular attention is given to the application of the GRASP 
 patterns to develop a well-designed solution. Please note that the GRASP pat-
 terns as such or by name are not the important thing; they are just a learning aid to 
 help talk about and methodically do fundamental object design.
  
 This chapter communicates the principles, using the NextGen POS example, by 
 which an object-oriented designer assigns responsibilities and establishes object 
 interactions—a core skill in object-oriented development.
  
 247",NA
17.1      Use-Case Realizations,"To quote, ""A use-case realization describes how a particular use case is realized 
 within the design model, in terms of collaborating objects"" [RUP]. More pre-
 cisely, a designer can describe the design of one or more 
 scenarios 
 of a use case; 
 each of these is called a use-case realization. Use-case realization is a UP term or 
 concept used to remind us of the connection between the requirements expressed 
 as use cases, and the object design that satisfies the requirements.
  
 UML interaction diagrams are a common language to illustrate use-case real-
 izations. And as was explored in the prior chapter, there are principles and pat-
 terns of object design, such as Information Expert and Low Coupling, that can be 
 applied during this design work.
  
 To review, Figure 17.20 (near the end of this chapter) illustrates the relationship 
 between some UP artifacts:
  
 • 
  
 • 
  
 • 
  
 • 
  
 The use case suggests the system events that are explicitly shown in system 
 sequence diagrams. 
  
 Details of the effect of the system events in terms of changes to domain 
 objects may optionally be described in system operation contracts. 
  
 The system events represent messages that initiate interaction diagrams, 
 which illustrate how objects interact to fulfill the required tasks—the use case 
 realization. 
  
 The interaction diagrams involve message interaction between software 
 objects whose names are sometimes inspired by the names of conceptual 
 classes in the Domain Model, plus other classes of objects. 
  
 248",NA
17.2     Artifact Comments,NA,NA
Interaction Diagrams and Use-Case Realizations,"In the current iteration we are considering various scenarios and system events 
 such as:
  
 •      
 Process Scale: makeNewSale, enterItem, endSale, makePayment 
  
 If collaboration diagrams are used to illustrate the use-case realizations, a dif-
 ferent collaboration diagram will be required to show the handling of each sys-
 tem event message. For example (Figure 17.1):
  
 makeNewSale()
  
 :Register
  
 1: ???()
  
 enterItem()
  
 :Register
  
 1: ???()
  
 endSale()
  
 :Register
  
 1: ???()
  
 makePayment()
  
 :Register
  
 1: ???()
  
 Figure 17.1 Collaboration diagrams and system event message handling.
  
 On the other hand, if sequence diagrams are used, it 
 may 
 be possible to fit all 
 system event messages on the same diagram, as in Figure 17.2.
  
  
 : Register
  
  
  
  
  
 : ProductCatalog
  
  
  
  
 : Sale
  
 makeNewSale() 
  
  
 enterItem 
  
 (itemID, quantity)
  
 create() 
  
 spec := getProductSpec( itemID )
  
 addLineItem( spec, quantity )
  
 . . .
  
 endSale() 
  
 makePayment(...)
  
 . . . 
  
 . . .
  
 Figure 17.2 One sequence diagram and system event message handling.
  
 249",NA
Contracts and Use-Case Realizations,"To reiterate, it may be possible to design use-case realizations directly from the use 
 case text. In addition, for some system operations, contracts may have been written that 
 add greater detail or specificity. For example:
  
 Contract CO2: enterltem
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 enterltem(itemlD : ItemID, quantity : integer) Use 
 Cases: Process Sale There is a sale underway.
  
 - A SalesLineltem instance sli was created (instance 
 cre-ation).
  
  
 In conjunction with contemplating the use case text, for each contract, we work through 
 the postcondition state changes and design message interactions to sat-isfy the 
 requirements. For example, given this partial 
 enterItem 
 system opera-
  
 250",NA
Caution: The Requirements Are Not Perfect,"It is useful to bear in mind that previously written use cases and contracts are only a 
 guess of what must be achieved. The history of software development is one of 
 invariably discovering that the requirements are not perfect, or have changed. This is not 
 an excuse to ignore trying to do a good requirements job, but a recognition of the need 
 to continuously engage customers and subject mat-ter experts in review and feedback on 
 the growing system's behavior.
  
 An advantage of iterative development is that it naturally supports the discov-ery of new 
 analysis and design results during design and implementation work. The spirit of 
 iterative development is to capture a ""reasonable"" degree of infor-mation during 
 requirements analysis, filling in details during design and imple-mentation.",NA
The Domain Model and Use-Case Realizations,"Some of the software objects that interact via messages in the interaction dia-grams are 
 inspired from the Domain Model, such as a 
 Sale 
 conceptual class and 
 Sale 
 design 
 class. The choice of appropriate responsibility placement using the GRASP patterns 
 relies, in part, upon information in the Domain Model. As men-tioned, the existing 
 Domain Model is not likely to be perfect; errors and omis-sions are to be expected. 
 You will discover new concepts that were previously missed, ignore concepts that 
 were previously identified, and do likewise with associations and attributes.",NA
Conceptual vs. Design Classes,"Recall that the UP Domain Model does not illustrate software classes, but may be used 
 to inspire the presence and names of some software classes in the
  
 251",NA
17.3     Use-Case Realizations for the NextGen Iteration,"The following sections explore the choices and decisions made while designing a 
 use-case realization with objects based on the GRASP patterns. The explana-
 tions are intentionally detailed, in an attempt to illustrate that there does not have 
 be any ""hand waving"" in the creation of well-designed interaction dia-grams; 
 their construction is based on justifiable principles.
  
 252",NA
17.4     Object Design: makeNewSale,"The 
 makeNewSale 
 system operation occurs when a cashier requests to start a new 
 sale, after a customer has arrived with things to buy. The use case may have been 
 sufficient to decide what was necessary, but for this case study we wrote 
 contracts for all the system events, for explanation and completeness.
  
 Contract CO1: makeNewSale
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 makeNewSale() 
  
 Use Cases: Process Sale 
  
 none
  
 - A Sale instance s was created (instance creation). - s was 
 associated with the Register (association formed). - 
 Attributes of s were initialized.",NA
Choosing the Controller Class,"Our first design choice involves choosing the controller for the system operation 
 message 
 enterItem. 
 By the Controller pattern, here are some choices:
  
 represents the overall ""system,"" device, 
 or subsystem
  
 represents a receiver or handler of all 
 system events of a use case scenario.
  
 Register, POSSystem 
  
 ProcessSaleHandler, 
  
 ProcessSaleSession
  
 Choosing a facade controller like 
 Register 
 is satisfactory if there are only a few 
 system operations and the facade controller is not taking on too many responsi-
 bilities (in other words, if it is becoming incohesive). Choosing a use-case con-
 troller is suitable when there are many system operations and we wish to distribute 
 responsibilities in order to keep each controller class lightweight and focused (in 
 other words, cohesive). In this case, 
 Register 
 will suffice, since there are only a 
 few system operations.
  
 This 
 Register 
 is a software object in the Design Model. It 
 is 
 not a real physical 
 register but a software abstraction whose name was chosen to lower the rep-
 resentational gap between our concept of the domain and the software.
  
 253",NA
by Controller,NA,NA
:Register,NA,NA
makeNewSale(),Figure 17.6 Applying the GRASP Controller pattern.,NA
Creating a New Sale ,"A software 
 Sale 
 object must be created, and the GRASP Creator pattern sug-
 gests assigning the responsibility for creation to a class that aggregates, con-
 tains, or records the object to be created.
  
 by Creator 
  
 and 
  
 Controller
  
 :Register
  
 create()
  
 Register creates a 
 Sale by Creator
  
 :Sales 
  
 LineItem
  
 by Creator, Sale 
  
 creates an empty 
  
 multiobject (such as 
 a List) which will 
  
 eventually hold 
  
 SalesLineItem 
  
 instances
  
 makeNewSale()
  
 :Sale
  
 create()
  
  
 this activation is implied to be within the 
 constructor of the Sale instance
  
 CAUTION: 
  
 This is 
 not 
 a SalesLineItem instance. This is a 
 collection object (such as a List) that can hold 
 SalesLineitem objects.
  
 Figure 17.7 Sale and multiobject creation.",NA
Conclusion,"The design was not difficult, but the point of its careful explanation in terms of 
 Controller and Creator was to illustrate that the details of a design can be 
 rationally and methodically decided and explained in terms of principles and 
 patterns, such as GRASP.",NA
17.5     Object Design: enterltem,"The 
 enterItem 
 system operation occurs when a cashier enters the 
 itemID 
 and 
 (optionally) the quantity of something to be purchased. Here is the complete 
 contract:
  
 Contract CO2: enterltem
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 enterltem(itemlD : ItemID, quantity : integer) Use 
 Cases: Process Sale There is an underway sale.
  
 - A SalesLineltem instance sli was created (instance cre-
 ation).
  
 - sli was associated with the current Sale (association 
 formed). 
  
 - sli.quantity became quantity (attribute modification). - sli 
 was associated with a ProductSpecification, based on 
 itemID match (association formed). 
  
  
 255",NA
Choosing the Controller Class,"Our first choice involves handling the responsibility for the system operation message 
 enterItem. 
 Based on the Controller pattern, as for 
 makeNewSale, 
 we will continue to 
 use 
 Register 
 as a controller.",NA
Display Item Description and Price?,"Because of a design principle called 
 Model-View Separation, 
 it is not the 
 responsibility of non-GUI objects (such as a 
 Register 
 or 
 Sale) 
 to get involved in output 
 tasks. Therefore, although the use case states that the description and price are 
 displayed after this operation, the design will be ignored at this time.
  
 All that is required with respect to responsibilities for the display of information is that 
 the information is known, which it is in this case.",NA
Creating a New SalesLineItem,"The 
 enterItem 
 contract postconditions indicate the creation, initialization, and 
 association of a 
 SalesLineItem. 
 Analyzing the Domain Model reveals that a 
 Sale 
 contains 
 SalesLineItem 
 objects. Taking inspiration from the domain, a software 
 Sale 
 may similarly contain software 
 SalesLineItem. 
 Hence, by Creator, a soft-ware 
 Sale 
 is 
 an appropriate candidate to create a 
 SalesLineItem.
  
 The 
 Sale 
 can be associated with the newly created 
 SalesLineItem 
 by storing the new 
 instance in its collection of line items. The postconditions indicate that the new 
 SalesLineItem 
 needs a quantity, when created; therefore, the 
 Register 
 must pass it 
 along to the Safe, which must pass it along as a parameter in the 
 create 
 message (in 
 Java, that would be implemented as a constructor call with a parameter).
  
 Therefore, by Creator, a 
 makeLineItem 
 message is sent to a 
 Sale 
 for it to create a 
 SalesLineItem. 
 The 
 Sale 
 creates a 
 SalesLineItem, 
 and then stores the new instance in 
 its permanent collection.
  
 The parameters to the 
 makeLineItem 
 message include the 
 quantity, 
 so that the 
 SalesLineItem 
 can record it, and likewise the 
 ProductSpecification 
 which matches the 
 itemID.
  
 256",NA
Finding a ProductSpecification,"The 
 SalesLineItem 
 needs to be associated with the 
 ProductSpecification 
 that matches 
 the incoming 
 itemID. 
 This implies it is necessary to retrieve a 
 Product-Specification, 
 based on an 
 itemID 
 match.
  
 Before considering 
 how 
 to achieve the lookup, it is useful to consider 
 who 
 should be 
 responsible for it. Thus, a first step is:
  
 Start assigning responsibilities by clearly stating the responsibility.
  
 To restate the problem:
  
 Who should be responsible for knowing a 
 ProductSpecification, 
 based on an 
 itemID 
 match?
  
 This is neither a creation problem nor one of choosing a controller for a system 
 event. Now we see our first application of Information Expert in the design.
  
 In many cases, the Expert pattern is the principal one to apply. Information Expert 
 suggests that the object that has the information required to fulfill the responsibility 
 should do it. Who knows about all the 
 ProductSpecification 
 objects?
  
 Analyzing the Domain Model reveals that the 
 ProductCatalog 
 logically contains all 
 the 
 ProductSpecifications. 
 Once again, taking inspiration from the domain, we 
 design software classes with similar organization: a software 
 ProductCatalog 
 will 
 contain software 
 ProductSpecifications.
  
 With that decided, then by Information Expert 
 ProductCatalog 
 is a good candi-date 
 for this lookup responsibility since it knows all the 
 ProductSpecification 
 objects.
  
 This may be implemented, for example, with a method called 
 getSpecification.
 1",NA
Visibility to a ProductCatalog,"Who should send the 
 getSpecification 
 message to the 
 ProductCatalog 
 to ask for a 
 ProductSpecification?
  
 It is reasonable to assume that a 
 Register 
 and 
 ProductCatalog 
 instance were 
 created during the initial 
 Start Up 
 use case, and that there is a permanent con-
 nection from the 
 Register 
 object to the 
 ProductCatalog 
 object. With that assump-
  
 1. The naming of accessing methods is of course idiomatic to each language. Java always 
 uses the 
 object.getFoo() 
 form, C++ tends to use 
 object.foo(), 
 and C# uses 
 object.Foo, 
 which hides (like Eiffel and Ada) if it is a method call or direct access of a public 
 attribute. The Java style is used in the examples.
  
 257",NA
Retrieving ProductSpecifications from a Database,"In the final version of the NextGen POS application, it is unlikely that all the 
 ProductSpecifications 
 will actually be in memory. They will most likely be stored in 
 a relational or object database and retrieved on demand; some may be cached in the 
 client process for performance or fault-tolerance reasons. However, the issues 
 surrounding retrieval from a database will be deferred for now in the interest of 
 simplicity. It will be assumed that all the 
 ProductSpecifications 
 are in memory.
  
 Chapter 34 explores the topic of database access of persistent objects, which is a 
 large topic usually influenced by the choice of technologies, such as J2EE, .NET, 
 and so forth.",NA
The enterItem Object Design,"Given the above discussion, the interaction diagram in Figure 17.8 reflects the 
 decisions regarding the assignment of responsibilities and how objects should 
 interact. Observe that considerable reflection was done to arrive at this design, based 
 on the GRASP patterns; the design of object interactions and responsibil-ity 
 assignment require some deliberation.",NA
Messages to Multiobjects,"Notice that the interpretation of a message sent to a multiobject in the UML is that it 
 is a message to the collection object itself, rather than an implicit broad-cast to the 
 collection's members. This is especially obvious for generic collection operations 
 such as 
 find 
 and 
 add.
  
 For example, in the 
 enterItem 
 interaction diagram:
  
 •
  
 The 
 find 
 message sent to the 
 ProductSpecification 
 multiobject is a message 
 being sent once to the collection data structure represented by the multiob ject 
 (such as a Java 
 Map).
  
 o The language-independent and generic 
 find 
 message will, during 
 programming, be translated for a specific language and library. 
 Perhaps it will actually be 
 Map.get 
 in Java. The message 
 get 
 could 
 have been used in the diagram; 
 find 
 was used to make the point that 
 design diagrams may require some mapping to different lan-guages 
 and libraries.
  
 •
  
 The 
 add 
 message sent to the 
 SalesLineItem 
 multiobject is to add an element to 
 the collection data structure represented by the multiobject (such as a Java 
 List).
  
 259",NA
17.6     Object Design: endSale,"The 
 endSale 
 system operation occurs when a cashier presses a button indicating the 
 end of a sale. Here is the contract:
  
 Contract CO3: endSale
  
  
 Operation: Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 endSale() 
  
 Use Cases: Process Sale 
  
 There is an underway sale.
  
 Sale.isComplete became true (attribute modification).",NA
Choosing the Controller Class,"Our first choice involves handling the responsibility for the system operation message 
 endSale. 
 Based on the Controller GRASP pattern, as for e
 nterItem, 
 we will continue to 
 use 
 Register 
 as a controller.",NA
Setting the Sale.isComplete Attribute,"The contract postconditions state:
  
 •      
 Sale.isComplete 
 became 
 true 
 (attribute modification).
  
 As always, Expert should be the first pattern considered unless it is a controller or 
 creation problem (which it is not).
  
 Who should be responsible for setting the 
 isComplete 
 attribute of the 
 Sale 
 to true?
  
 By Expert, it should be the 
 Sale 
 itself, since it owns and maintains the 
 isCom-plete 
 attribute. Thus the 
 Register 
 will send a 
 becomeComplete 
 message to the 
 Sale 
 to set it to 
 true.
  
 endSale()
  
 :Register
  
 1: becomeComplete()
  
 s :Sale
  
 by Controller
  
 by Expert
  
 Figure 17.9  Completion of item entry.
  
 260",NA
"UML Notation to Show Constraints, Notes, and Algorithms","Figure 17.9 shows the 
 becomeComplete 
 message, but does not communicate the details 
 of what happens in the 
 becomeComplete 
 method (although it is admit-tedly trivial in this 
 case). Sometimes in the UML we wish to use text to describe the algorithm of a method, 
 or specify some constraint.
  
 For these needs, the UML provides both 
 constraints and notes. 
 A UML con-straint is 
 some semantically meaningfully information attached to a model ele-ment. UML 
 constraints are text enclosed in { } braces; for example, { x > 20 ). Any informal or 
 formal language can be used for the constraint, and the UML especially includes the 
 OCL (object constraint language) [WK99] if one desires to use that.
  
 A UML note is a comment that has no semantic impact, such as date of creation or 
 author.
  
 A note is always shown in a 
 note box 
 (a dog-eared text box).
  
 A constraint may be shown as simple text with braces, which is suitable for short 
 statements. However, long constraints may be also placed within a ""note box,"" in 
 which case the so-called note box actually holds a constraint rather than a note. The 
 text in the box is within braces, to indicate it is a constraint.
  
 In Figure 17.10 both styles are used. Note that the simple constraint style (in braces but 
 not in a box) just shows a statement which must hold true (the classic meaning of a 
 constraint in logic). On the other hand, the ""constraint"" in the note box shows a Java 
 method implementation of the constraint. Both styles are legal in the UML for a 
 constraint.
  
 a constraint implementation in a note box
  
 observe the outer braces around the method 
  
 signifying a constraint within a note box
  
 { 
  
 public void becomeComplete( ) 
  
 {
  
  
  isComplete = true; 
  
 } 
  
 }
  
 a constraint that doesn't define the 
  
 algorithm, but specifies what must hold as true
  
 { s.isComplete = true }
  
 endSale()
  
 :Register
  
 1: becomeComplete()
  
 s : Sale
  
 // a note 
  
 created by Craig
  
 Figure 17.10 Constraints and notes.
  
 261",NA
Calculating the Sale Total,"Consider this fragment of the 
 Process Sale 
 use case:
  
 Main Success 
 Scenario: 
  
 1. Customer arrives ... 
  
 2. Cashier tells System to create a new sale. 
  
 3. Cashier enters item identifier. 
  
 4. System records sale line item and ... 
  
 Cashier repeats steps 3-4 until indicates done. 
  
 5. System presents total with taxes calculated. 
  
 In step 5, a total is presented (or displayed). Because of the Model-View Separa-tion 
 principle, we should not concern ourselves with the design of how the sale total will be 
 displayed, but it is necessary to ensure that the total is known. Note that no design 
 class currently knows the sale total, so we need to create a design of object interactions 
 that satisfies this requirement.
  
 As always, Information Expert should be a pattern to consider unless it is a con-troller 
 or creation problem (which it is not).
  
 It is probably obvious the 
 Sale 
 itself should be responsible for knowing its total, but 
 just to make the reasoning process to find an Expert crystal clear—with a simple 
 example—please consider the following analysis.
  
 1.
  
 State the responsibility:
  
 o    Who should be responsible for knowing the sale total?
  
 2.Summarize the information required:
  
 o    The sale total is the sum of the subtotals of all the sales line-items.
  
 o    sales line-item subtotal := line-item quantity * product 
  
 description price
  
 3.
  
 List the information required to fulfill this responsibility and the classes that 
 know this information.
  
  
 Information Required for 
 Sale Total
  
 Information Expert
  
 ProductSpecification.price
  
 ProductSpecification
  
 SalesLineItem. quantity
  
 SalesLineItem
  
 all the 
 SalesLineItems 
 in the cur-
 rent Sale
  
 Sale
  
 262",NA
The Sale-getTotal Design,"Given the above discussion, it is now desirable to construct an interaction dia-
 gram that illustrates what happens when a 
 Sale 
 is sent a
  getTotal 
 message. The 
 first message in this diagram is
  getTotal, 
 but observe that the
  getTotal 
 message is 
 not a system event.
  
 This leads to the following observation:
  
 Not every interaction diagram starts with a system event message; they can 
 start with any message for which the designer wishes to show interactions.
  
 The interaction diagram is shown in Figure 17.11. First, the
  getTotal 
 message is 
 sent to a 
 Sale 
 instance. The 
 Sale 
 will then send a 
 getSubtotal 
 message to each 
 related 
 SalesLineItem 
 instance. The 
 SalesLineItem 
 will in turn send a 
 getPrice 
 message to its associated 
 ProductSpecifications.
  
 263",NA
*,": SalesLineItem
  
 1 *: st := getSubtotal()
  
 tot := getTotal()
  
 1.1: pr := getPrice()
  
 recall this special notation to 
  
 indicate iteration over the 
  
 elements of a collection
  
 :ProductSpecification
  
 Figure 17.11 Sale-getTotal interaction diagram.
  
 Since arithmetic is not (usually) illustrated via messages, the details of the cal-
 culations can be illustrated by attaching algorithms or constraints to the dia-gram that 
 defines the calculations.
  
 Who will send the 
 getTotal 
 message to the 
 Sale? 
 Most likely, it will be an object in the 
 UI layer, such as a Java 
 JFrame.
  
 Observe in Figure 17.12 the use of algorithm notes and constraints, to communi-cate 
 details 
 of getTotal and getSubtotal.",NA
17.7     Object Design: makePayment,"The 
 makePayment 
 system operation occurs when a cashier enters the amount of cash 
 tendered for payment. Here is the complete contract:
  
 Contract CO4: makePayment
  
  
 Operation: 
 Cross 
 References: 
  
 Preconditions:
  
 Postconditions:
  
 makePayment( amount: Money) Use 
 Cases: Process Sale There is an 
  
 underway sale.
  
 - A Payment instance p was created (instance creation). - 
 p.amountTendered became amount (attribute modification). 
  
 - p was associated with the current Sale (association 
 formed). 
  
 - The current Sale was associated with the Store (associa 
 tion formed); (to add it to the historical log of completed 
 sales). 
  
  
 A design will be constructed to satisfy the postconditions of 
 makePayment.
  
 264",NA
Creating the Payment,"One of the contract postconditions states:
  
 •      A 
 Payment 
 instance p was created (instance creation).
  
 This is a creation responsibility, so the Creator GRASP pattern should be 
 applied.
  
 Who records, aggregates, most closely uses, or contains a 
 Payment? 
 There is 
 some appeal in stating that a 
 Register 
 logically records a 
 Payment, 
 because in the 
 real domain a ""register"" records account information, so it is a candidate by the 
 goal of reducing the representational gap in the software design. Addition-ally, it 
 is reasonable to expect that a 
 Sale 
 software will closely use a 
 Payment; 
 thus, it 
 may be a candidate.
  
 Another way to find a creator is to use the Expert pattern in terms of who is the 
 Information Expert with respect to initializing data—the amount tendered in this 
 case. The 
 Register 
 is the controller which receives the system operation 
 makePayment 
 message, so it will initially have the amount tendered. Conse-
 quently the 
 Register 
 is again a candidate.
  
 265",NA
Logging a Sale,"Once complete, the requirements state that the sale should be placed in an his-torical 
 log. As always, Information Expert should be an early pattern considered unless it is a 
 controller or creation problem (which it is not), and the responsibil-ity should be stated:
  
 Who is responsible for knowing all the logged sales, and doing the 
  
 logging?
  
 266",NA
* ,"1
  
 Store
  
 ...
  
 addSale(s : Sale) 
 ...
  
 Store is responsible for 
  
 knowing and adding 
  
 completed Sales.
  
 Acceptable in early 
  
 development cycles if the 
  
 Store has few 
  
 responsibilities.
  
 Sale
  
 ...
  
 ...
  
 s-completed
 ",NA
* ,"1
  
 SalesLedger
  
 ...
  
 addSale(s : Sale) 
 ...
  
 SalesLedger is responsible 
  
 for knowing and adding 
  
 completed Sales.
  
 Suitable when the design 
  
 grows and the Store 
  
 becomes uncohesive.
  
 Figure 17.14 Who should be responsible for knowing the completed sales?
  
 Note also that the postconditions of the contract indicate relating the 
 Sale 
 to the 
 Store. 
 This is an example where the postconditions may not be what we want to 
 actually achieve in the design. Perhaps we didn't think of a 
 SalesLedger 
 earlier, but 
 now that we have, we choose to use it instead of a 
 Store. 
 If this were the case, 
 SalesLedger 
 would ideally be added to the Domain Model as well, as it is a name of 
 a concept in the real-world domain. This kind of discovery and change during design 
 work is to be expected.
  
 In this case, we will stick with the original plan of using the 
 Store 
 (see Figure 17.15).
  
 267",NA
Calculating the Balance,"The 
 Process Sale 
 use case implies that the balance due from a payment be printed on 
 a receipt and displayed somehow.
  
 Because of the Model-View Separation principle, we should not concern our-selves 
 with how the balance will be displayed or printed, but it is necessary to ensure that it 
 is known. Note that no class currently knows the balance, so we need to create a 
 design of object interactions that satisfies this requirement.
  
 As always, Information Expert should be considered unless it is a controller or 
 creation problem (which it is not), and the responsibility should be stated:
  
 Who is responsible for knowing the balance?
  
 To calculate the balance, the sale total and payment cash tendered are required. 
 Therefore, 
 Sale 
 and 
 Payment 
 are partial Experts on solving this problem.
  
 If the 
 Payment 
 is primarily responsible for knowing the balance, it would need 
 visibility to the 
 Sale, 
 in order to ask the 
 Sale 
 for its total. Since it does not cur-rently 
 know about the 
 Sale, 
 this approach would increase the overall coupling in the 
 design—it would not support the Low Coupling pattern.
  
 In contrast, if the 
 Sale 
 is primarily responsible for knowing the balance, it needs 
 visibility to the 
 Payment, 
 in order to ask it for its cash tendered. Since the 
 Sale",NA
17.8     Object Design: startup,NA,NA
When to Create the startup Design?,"Most, if not all, systems have a 
 Start Up 
 use case, and some initial system oper-
 ation related to the starting up of the application. Although this 
 startUp 
 system 
 operation is the earliest one to execute, delay the development of an interaction 
 diagram for it until after all other system operations have been considered. This 
 ensures that information has been discovered concerning the initialization 
 activities required to support the later system operation interaction diagrams.
  
 Do the initialization design last.
  
 269",NA
How Applications Start Up,"The 
 startUp 
 operation abstractly represents the initialization phase of execu-tion when 
 an application is launched. To understand how to design an interac-tion diagram for 
 this operation, it is helpful to understand the contexts in which initialization can occur. 
 How an application starts and initializes is dependent on the programming language 
 and operating system.
  
 In all cases, a common design idiom is to ultimately create an 
 initial domain object, 
 which is the first software ""domain"" object created.
  
 A note on terminology: As will be explored, applications are organized into logi-cal 
 layers that separate the major concerns of the application. These include a UI layer (for 
 UI concerns) and a ""domain"" layer (for domain logic concerns). The domain layer of 
 the Design Model is composed of software classes whose names are inspired from the 
 domain vocabulary, and which contain application logic. Virtually all the design 
 objects we have considered, such as 
 Sale 
 and 
 Register, 
 are domain objects in the 
 domain layer of the Design Model.
  
 The initial domain object, once created, is responsible for the creation of its direct 
 child domain objects. For example, if a 
 Store 
 is chosen as the initial domain object, it 
 may be responsible for the creation 
 of a Register 
 object.
  
 The place where this initial domain object is created is dependent on the object 
 technology chosen. For example, in a Java application, the 
 main 
 method may create it, 
 or delegate the work to a 
 factory 
 object that creates it.
  
 public class Main {
  
 public static void main( String [] args ) 
  
  {
  
 // Store is the initial domain object.
  
 // The Store creates some other domain objects.
  
 Store store = new Store ( ) ;
  
 Register register = store. getRegister ();
  
  } 
  
  } 
  
 ProcessSaleJFrame frame = new ProcessSaleJFrame ( 
 register ); 
 …",NA
Interpretation of the startup System Operation,"The preceding discussion illustrates that the 
 startUp 
 system operation is a lan-guage-
 independent abstraction. During design, there is variation in where the initial object is 
 created, and whether or not it takes control of the process. The initial domain object 
 does not usually take control if there is a GUI; otherwise, it often does.
  
 270",NA
The POS Application startup Operation,"The 
 startUp 
 system operation occurs when a manager powers on the POS sys-
 tem and the software loads. Assume that the initial domain object is 
 not 
 respon-
 sible for taking control of the process; control will remain in the UI layer (such as 
 a Java 
 JFrame) 
 after the initial domain object is created. Therefore, the inter-
 action diagram for the 
 startUp 
 operation may be reinterpreted solely as a 
 cre-
 ate() 
 message sent to create the initial object.",NA
Choosing the Initial Domain Object,"What should the class of the initial domain object be?
  
 Choose as an initial domain object a class at or near the root of the contain-
 ment or aggregation hierarchy of domain objects. This may be a facade con-
 troller, such as 
 Register, 
 or some other object considered to contain all or most 
 other objects, such as a 
 Store.
  
 Choosing between these alternatives may be influenced by High Cohesion and 
 Low Coupling considerations. In this application, the 
 Store 
 is chosen as the ini-
 tial object.",NA
Persistent Objects: ProductSpecification,"The 
 ProductSpecification 
 instances will reside in a persistent storage medium, 
 such as relational or object database. During the 
 startUp 
 operation, if there are 
 only a few of these objects, they may all be loaded into the computer's direct 
 memory. However, if there are many, loading them all would consume too much
  
 271",NA
Store--create() Design,"The tasks of creation and initialization derive from the needs of the prior design 
 work, such as the design for handling 
 enterItem 
 and so on. By reflecting on the prior 
 interaction designs, the following initialization work can be identified:
  
 • 
  
 A 
 Store, Register, ProductCatalog 
 and 
 ProductSpecifications 
 need to be 
 created.
  
 •  
 The 
 ProductCatalog 
 needs to be associated with 
 ProductSpecifications.
  
 •  
 Store 
 needs to be associated with 
 ProductCatalog.
  
 •  
 Store 
 needs to be associated with 
 Register.
  
 •  
 Register 
 needs to be associated with 
 ProductCatalog.
  
 Figure 17.17 shows a design. The 
 Store 
 was chosen to create the 
 ProductCatalog 
 and 
 Register 
 by the Creator pattern. 
 ProductCatalog 
 was likewise chosen to cre-ate 
 the 
 ProductSpecifications. 
 Recall that this approach to creating the specifi-cations is 
 temporary. In the final design, they will be materialized from a database, as needed.
  
 UML notation: 
 Observe that the creation of all the 
 ProductSpecification 
 instances 
 and their addition to a container happens in a repeating section, indi-cated by the ""*"" 
 following the sequence numbers.
  
 An interesting deviation between modeling the real-world domain and the design is 
 illustrated in the fact that the software 
 Store 
 object only creates 
 one Register 
 object. 
 A real store may house 
 many 
 real registers or POS terminals. However, we are 
 considering a software design, not real life. In our current requirements, our software 
 Store 
 only needs to create a single instance of a soft-ware 
 Register.
  
 Multiplicity between classes of objects in the Domain Model and Design Model 
 may not be the same.
  
 272",NA
17.9     Connecting the UI Layer to the Domain Layer,"As has been briefly discussed, applications are organized into logical layers that 
 separate the major concerns of the application, such as the UI layer (for UI con-
 cerns) and a ""domain"" layer (for domain logic concerns).
  
 Common designs by which objects in the UI layer obtain visibility to objects in 
 the domain layer include the following:
  
 • 
  
 • 
  
 An initializing routine (for example, a Java 
 main 
 method) creates both a UI 
 and a domain object, and passes the domain object to the UI. 
  
 A UI object retrieves the domain object from a well-known source, such as a 
 factory object that is responsible for creating domain objects. 
  
 The sample code shown before is an example of the first approach: 
  
 public  class  Main 
  
 { 
  
 273",NA
17.10   Use-Case Realizations Within the UP,"Use-case realizations are part of the UP Design Model. This chapter has empha-sized 
 drawing interaction diagrams, but it is common and recommended to draw class 
 diagrams in parallel. Class diagrams are examined in Chapter 19.
  
 Discipline
  
 Artifact 
  
 Iteration->
  
 Incep. I1
  
 Elab.
  
 E1..En
  
 Const. 
 C1..Cn
  
 Trans. 
 T1..T2
  
 Business Modeling
  
 Domain Model
  
  
 s
  
  
  
 Requirements
  
 Use-Case Model (SSDs)
  
 s
  
 r
  
  
  
 Vision
  
 s
  
 r
  
  
  
 Supplementary Specification
  
 s
  
 r
  
  
  
 Glossary
  
 s
  
 r
  
  
  
 Design
  
 Design Model
  
  
 s
  
 r
  
  
 SW Architecture Document
  
  
 s
  
  
  
 Data Model
  
  
 s
  
 r
  
  
 Implementation
  
 Implementation Model
  
  
 s
  
 r
  
 r
  
 Project Management
  
 SW Development Plan
  
 s
  
 r
  
 r
  
 r
  
 Testing
  
 Test Model
  
  
 s
  
 r
  
  
 Environment
  
 Development Case
  
 s
  
 r
  
  
  
 Table 17.1 Sample UP artifacts and timing. s - start; r - refine",NA
Phases,"Inception
 —The Design Model and use-case re alizations will not usually be started 
 until elaboration because it involves detailed design decisions which are premature 
 during inception.
  
 Elaboration
 —During this phase, use-case realizations may be created for the most 
 architecturally significant or risky scenarios of the design. However, UML 
 diagramming will not be done for every scenario, and not necessarily in com-plete and 
 fine-grained detail. The idea is to do interaction diagrams for the key use-case 
 realizations that benefit from some forethought and exploration of alternatives, 
 focusing on the major design decisions.
  
 Construction-
  
 problems.
  
 -Use-case realizations are created for remaining design
  
 276",NA
UP Artifacts and Process Context ,"Sample UP Artifact Relationships for Use-Case Realization 
  
  
 Domain Model
  
 Sale
  
 1
  
 1..
 *
  
 Sales 
  
 LineItem
  
 . . .
  
 date 
  
 . . .
  
 . . .
  
 quantity
  
 domain objects
  
 the domain objects, attributes, and 
  
 associations that undergo state changes
  
 Use-Case Model
  
 conceptual 
  
 classes in 
  
 the 
  
 domain 
  
 inspire the 
  
 names of 
  
 some 
  
 software 
  
 classes in 
  
 the design
  
 Process Sale
  
 : System
  
 system
  
 Operation: makeNewSale
  
 : Cashier
  
 make 
  
 NewSale()
  
 1. Customer 
 arrives ...
  
 2. Cashier 
 makes new 
 sale.
  
 3. Cashier 
 enters item 
 identifier.
  
 4....
  
 Post-conditions:
  
 - 
 . . .
  
 system 
 events
  
 enterItem 
  
 (id, quantity)
  
 operations
  
 Operation: enterItem
  
 endSale()
  
 Post-conditions:
  
 - A 
 SalesLineItem 
 instance 
 sli 
 was created
  
 -
  . . .
  
 makePayment 
  
 (amount)
  
 Use Cases
  
 System Sequence Diagrams
  
 Contracts
  
 in addition to the use
  
 some ideas and inspiration for the post-
 conditions derive from the use cases
  
 cases, requirements that 
 must be satisfied by the 
 design of the software
  
 use-case 
  
 realization
  
 Design Model
  
 : Register
  
 : ProductCatalog
  
 makeNewSale()
  
 create()
  
 : Sale
  
 enterItem 
  
 (itemID, quantity)
  
 spec := getSpecification( itemID )
  
 addLineItem( spec, quantity )
  
 . . .
  
 endSale()",NA
. . .,". . .
  
 Figure 17.20 Sample UP artifact influence.
  
 277",NA
17.11    Summary,"Designing object interactions and assigning responsibilities is at the heart of object 
 design. These choices have can have a profound impact on the extensibil-ity, 
 clarity, and maintainability of an object software system, plus on the degree and 
 quality of reusable components. There are principles by which the choices of 
 responsibility assignment can be made; the GRASP patterns summarize some of 
 the most general and common used by object-oriented designers.
  
 278",NA
Chapter 18,NA,NA
DESIGN MODEL,NA,NA
: ,NA,NA
DETERMINING ,NA,NA
VISIBILITY,"A mathematician is a device for turning coffee into theorems.
  
 —
 Paul Erdos",NA
Objectives,"• 
  
 • 
  
 • 
  
 Identify four kinds of visibility. 
  
 Design to establish visibility. 
  
 Illustrate kinds of visibility in the UML notation.",NA
Introduction,"Visibility is the ability of one object to see or have reference to another. This 
 chapter explores design issues related to visibility.",NA
18.1     Visibility Between Objects,"The designs created for the system events 
 (enterItem, 
 and so on) illustrate mes-
 sages between objects. For a sender object to send a message to a receiver object, 
 the sender must be visible to the receiver—the sender must have some kind of 
 reference or pointer to the receiver object.
  
 For example, the 
 getSpecification 
 message sent from a 
 Register 
 to a 
 ProductCat-
 a/og 
 implies that the 
 ProductCatalog 
 instance is visible to the 
 Register 
 instance, 
 as shown in Figure 18.1.
  
 279",NA
18.2     Visibility,"In common usage, 
 visibility 
 is the ability of an object to ""see"" or have a refer-ence to 
 another object. More generally, it is related to the issue of scope: Is one resource 
 (such as an instance) within the scope of another? There are four com-mon ways that 
 visibility can be achieved from object A to object 
 B:
  
 m
 Attribute visibility
 —B is an attribute of A.
  
 •  
 Parameter visibility
 —B is a parameter of a method of A.
  
 •  
 Local visibility
 —B is a (non-parameter) local object in a method of A.
  
 •  
 Global visibility
 —B is in some way globally visible.
  
 1. In this and subsequent code examples, language simplifications may be made for 
 the 
  
 sake of brevity and clarity.
  
 280",NA
Attribute Visibility,"Attribute visibility 
 from A to B exists when B is an attribute of A. It is a rela-
 tively permanent visibility because it persists as long as A and B exist. This is a 
 very common form of visibility in object-oriented systems.
  
 To illustrate, in a Java class definition for 
 Register, 
 a 
 Register 
 instance may have 
 attribute visibility to a 
 ProductCatalog, 
 since it is an attribute (Java instance 
 variable) of the 
 Register.
  
 public  class  Register 
  
 {
  
 … 
  
 private  ProductCatalog  catalog; 
  
 … 
  
 }
  
 This visibility is required because in the 
 enterItem 
 diagram shown in Figure 18.2, 
 a 
 Register 
 needs to send the 
 getSpecification 
 message to a
  ProductCatalog:
  
 class Register 
  
 {
  
  ...
  
  private ProductCatalog catalog; 
 ...
  
 }
  
 { 
  
 public void enterItem(itemID, qty) {
  
  ...
  
  spec = catalog.getSpecification(itemID) ...
  
 } 
  
 }
  
 enterItem 
  
 (itemID, quantity)
  
 : Register
  
 : ProductCatalog
  
 spec := getSpecification( itemID )
  
 Figure 18.2 Attribute visibility.
  
 281",NA
Parameter Visibility,"Parameter visibility 
 from A to B exists when B is passed as a parameter to a method 
 of A. It is a relatively temporary visibility because it persists only within the scope of 
 the method. After attribute visibility, it is the second most common form of visibility in 
 object-oriented systems.
  
 To illustrate, when the 
 makeLineItem 
 message is sent to a 
 Sale 
 instance, a 
 Prod-
 uctSpecification 
 instance is passed as a parameter. Within the scope of the 
 makeLineItem 
 method, 
  
 the 
 Sale 
 has 
  
 parameter 
  
 visibility 
  
 to 
  
 a 
 ProductSpecifica-tion 
 (see Figure 18.3).
  
 enterItem(id, qty) 
  
  
 2: makeLineItem(spec, qty) 
  
  
 :Register 
  
  
 :Sale
  
 1: spec := getSpecification(id) 
  
  
 2.1: create(spec, qty
  
 :Product 
  
 Catalog
  
 { 
  
 makeLineItem(ProductSpecification spec, int qty) {
  
  ...
  
  sl = new SalesLineItem(spec, qty);
  
  ...
  
 } 
  
 }
  
 sl : SalesLineItem
  
 Figure 18.3 Parameter visibility.
  
 It is common to transform parameter visibility into attribute visibility. For example, 
 when the 
 Sale 
 creates a new 
 SalesLineItem, 
 it passes a 
 ProductSpecifi-cation 
 in to its 
 initializing method (in C++ or Java, this would be its 
 constructor). 
 Within the 
 initializing method, the parameter is assigned to an attribute, thus establishing attribute 
 visibility (Figure 18.4).",NA
Local Visibility,"Local visibility 
 from A to B exists when B is declared as a local object within a 
 method of A. It is a relatively temporary visibility because it persists only within the 
 scope of the method. After parameter visibility, it is the third most common form of 
 visibility in object-oriented systems.
  
 282",NA
Global Visibility,"Global visibility 
 from A to B exists when B is global to A. It is a relatively per-
 manent visibility because it persists as long as A and B exist. It is the least com-
 mon form of visibility in object-oriented systems.
  
 One way to achieve global visibility is to assign an instance to a global variable, 
 which is possible in some languages, such as C++, but not others, such as Java.
  
 283",NA
18.3     Illustrating Visibility in the UML ,"The UML includes notation to show the kind of visibility in a collaboration dia-gram 
 (see Figure 18.6). These adornments are optional and not normally called for; they 
 are useful when clarification is needed.
  
 «association» is used for 
  
 attribute visibility
  
 :A
  
 2: msg()
  
 1: msg()
  
  
 «association»
  
 :B
  
 «parameter»
  
 :C
  
 3: msg()
  
 «local»
  
 :D
  
 4: msg()
  
 «global»
  
 :E
  
 Figure 18.6 Implementation stereotypes for visibility.
  
 284",NA
Chapter 19,NA,NA
DESIGN MODEL,NA,NA
: ,NA,NA
CREATING ,NA,NA
DESIGN CLASS DIAGRAMS,"To iterate is human, to recurse, divine.
  
 —
 anonymous",NA
Objectives,"Create design class diagrams (DCDs).
  
 Identify the classes, methods, and associations to show in a DCD.",NA
Introduction,"With the completion of interaction diagrams for use-case realizations for the 
 current iteration of the NextGen POS application, it is possible to identify the 
 specification for the software classes (and interfaces) that participate in the soft-
 ware solution, and annotate them with design details, such as methods.
  
 The UML has notation for showing design details in class diagrams; in this 
 chapter, we explore it and create DCDs.",NA
19.1     When to Create DCDs,"Although this presentation of DCDs 
 follows 
 the creation of interaction dia-grams, 
 in practice they are usually created in parallel. Many classes, method names and 
 relationships may be sketched out very early in design by applying responsibility 
 assignment patterns, prior to the drawing of interaction dia-grams. It is possible 
 and desirable to do a little interaction diagramming, then update the DCDs, then 
 extend the interaction diagrams some more, and so on.
  
 285",NA
19.2     Example DCD,"The DCD in Figure 19.1 illustrates a partial software definition of the 
 Register 
  
 and 
 Sale 
 classes.
  
 Three section box for
  
 class definition. 
  
 Navigability
  
 Sale
  
 Register
  
 Captures date
  
 isComplete : Boolean
  
 1 
  
 1 time
  
 enterItem(...)
  
 makeLineItem(...)
  
 methods; there are parameters, but unspecified 
  
 type information
  
 Figure 19.1 Sample design class diagram.
  
 In addition to basic associations and attributes, the diagram is extended to illus-
  
 trate, for example, the methods of each class, attribute type information, and 
  
 attribute visibility and navigation between objects.",NA
19.3     DCD and UP Terminology,"A design class diagram 
 (DCD) illustrates the specifications for software 
  
 classes and interfaces (for example, Java interfaces) in an application. Typical 
  
 information includes:
  
 • classes, associations and attributes 
  
 • interfaces, with their operations and constants 
  
 • methods 
  
 • attribute type information 
  
 • navigability 
  
 • dependencies 
  
 In contrast to conceptual classes in the Domain Model, design classes in the 
  
 DCDs show definitions for software classes rather than real-world concepts.
  
 286",NA
19.4     Domain Model vs. Design Model Classes,"To reiterate, in the UP Domain Model, a 
 Sale 
 does not represent a software defi-
 nition; rather, it is an abstraction of a real-world concept about which we are 
 interested in making a statement. By contrast, DCDs express—for the software 
 application—the definition of classes as software components. In these dia-grams, 
 a 
 Sale 
 represents a software class (see Figure 19.2).
  
 Concept; conceptual class
  
 Domain Model
  
 Register
  
 1
  
 Captures
  
 1
  
 Sale
  
 date 
  
 isComplete : Boolean 
 time
  
 Design Model
  
 Register
  
 1
  
 Captures
  
 1
  
 Sale
  
 ...
  
 date 
  
 isComplete : Boolean 
 time
  
 endSale() 
  
 enterItem(...) 
  
 makePayment(...)
  
 makeLineItem(...)
  
 software class
  
 Figure 19.2 Domain model vs. Design Model classes.",NA
19.5     Creating a NextGen POS DCD,NA,NA
Identify Software Classes and Illustrate Them,"The first step in the creation of DCDs as part of the solution model is to identify 
 those classes that participate in the software solution. These can be found by 
 scanning all the interaction diagrams and listing the classes mentioned.
  
 287",NA
Add Method Names,"The methods of each class can be identified by analyzing the interaction dia-grams. For 
 example, if the message 
 makeLineItem 
 is sent to an instance of class 
 Sale, 
 then class 
 Sale 
 must define a 
 makeLineItem 
 method (see Figure 19.4).
  
 In general, the set of all messages sent to a class X across all interaction dia-grams 
 indicates the majority of methods that class X must define.
  
 Inspection of all the interaction diagrams for the POS application yields the allocation 
 of methods shown in Figure 19.5.
  
 288",NA
Method Name Issues,"The following special issues must be considered with respect to method names:• 
  
 interpretation of the 
 create 
 message 
  
 • 
  
 depiction of accessing methods 
  
 • 
  
 interpretation of messages to multiobjects 
  
 • 
  
 language-dependent syntax",NA
Method Names,NA,NA
—,NA,NA
create,"The 
 create 
 message is a possible UML language independent form to indicate 
 instantiation and initialization. When translating the design to an object-ori-ented 
 programming language, it must be expressed in terms of its idioms for 
 instantiation and initialization. There is no actual 
 create 
 method in C++, Java,
  
 289",NA
Method Names,NA,NA
—,NA,NA
Accessing Methods,"Accessing methods 
 retrieve (accessor method) or set (mutator method) 
 attributes. In some languages (such as Java) it is a common idiom to have an 
 accessor and mutator for each attribute, and to declare all attributes private (to 
 enforce data encapsulation). These methods are usually excluded from depiction 
 in the class diagram because of the high noise-to-value ratio they generate; for n 
 attributes, there are 2n uninteresting methods. For example, the 
 Product-
 Specification's getPrice 
 (or 
 price) 
 method is not shown, although present, 
 because 
 getPrice 
 is a simple accessor method.",NA
Method Names,NA,NA
—,NA,NA
Multiobjects,"A message to a multiobject is interpreted as a message to the container/collec-
 tion object itself. For example, the following 
 find 
 message to the multiobject is 
 meant be interpreted as a message to the container/collection object, such as to a 
 Java 
 Map, 
 a C++ 
 map 
 or a Smalltalk 
 Dictionary 
 (see Figure 19.6).
  
 1: spec := getSpecification(id)
  
  
 :Product 
  
 Catalog
  
 1.1: spec := find(id)
  
 The 
 find 
 message is to the 
 container object, not to a 
 ProductSpecification.
  
 :Product
  
 Specification
  
 Figure 19.6 Message to a multiobject.
  
 Therefore, the 
 find 
 method is not part of the 
 Productspecification 
 class; rather, it 
 is part of the multiobject's interface. Consequently, it is incorrect to add 
 find 
 as a 
 method to the 
 Productspecification 
 class.",NA
Method Names,NA,NA
—,NA,NA
Language-Dependent Syntax,"Some languages, such as Smalltalk, have a syntax that is very different from the 
 basic UML format of 
 methodName(parameterList). 
 It is recommended that the basic 
 UML format be used, even if the planned implementation language uses a different 
 syntax. The translation should ideally take place during code generation time, 
 instead of during the creation of the class diagrams. However, the UML does allow 
 other syntax for method specification.",NA
Adding More Type Information,"The types of the attributes, method parameters, and method return values may all 
 optionally be shown. The question as to whether to show this information or not 
 should be considered in the following context:
  
 The DCD should be created by considering the audience.
  
 • 
  
 • 
  
 If it is being created in a CASE tool with automatic code generation, full and 
 exhaustive details are necessary. 
  
 If it is being created for software developers to read, exhaustive low-level 
 detail may adversely affect the noise-to-value ratio. 
  
  
 For example, is it necessary to show all the parameters and their type informa-tion? 
 It depends on how obvious the information is to the intended audience.
  
 The design class diagram in Figure 19.7 shows more type information.",NA
Adding Associations and Navigability,"Each end of an association is called a role, and in the DCDs the role may be dec-
 orated with a navigability arrow. Navigability is a property of the role that indicates 
 that it is possible to navigate uni-directionally across the association from objects of 
 the source to target class. Navigability implies visibility—usually attribute visibility 
 (see Figure 19.8).
  
 291",NA
* ,"SalesLineItem
  
 Register
  
 date : Date 
  
 isComplete : Boolean 
 time : Time
  
 endSale() 
  
 enterItem(...) 
  
 makeNewSale() 
  
 makePayment(...)
  
 quantity : Integer
  
 1
  
 becomeComplete() 
 makeLineItem(...) 
 makePayment(...) 
 getTotal()
  
 getSubtotal()
  
 Logs-completed
 ",NA
*,"1
  
 Paid-by
  
 1
  
 Payment
  
 amount : Money
  
 ...
  
 Figure 19.10 Associations with navigability adornments.
  
 Note that this is not exactly the same set of associations that was generated for the 
 class diagrams in the Domain Model. For instance, there was no 
 Looks-in 
 association 
 between 
 Register 
 and 
 ProductCatalog 
 in the domain model—it was not discovered as 
 an important lasting relationship at that time. But during the creation of the interaction 
 diagrams, it was decided that a 
 Register 
 software object should have a lasting 
 connection to a software 
 ProductCatalog 
 in order to look up 
 ProductSpecifications.",NA
Adding Dependency Relationships,"The UML includes a general 
 dependency relationship, 
 which indicates that one 
 element (of any kind, including classes, use cases, and so on) has knowledge of 
 another element. It is illustrated with a dashed arrow line. In class diagrams the 
 dependency relationship is useful to depict non-attribute visibility between 
 classes; in other words, parameter, global, or locally declared visibility. By con-
 trast, plain attribute visibility is shown with a regular association line and a 
 navigability arrow. For example, the 
 Register 
 software object receives a return 
 object of type 
 ProductSpecification 
 from the specification message it sent to a 
 ProductCatalog. 
 Thus 
 Register 
 has a short-term locally declared visibility to 
 ProductSpecifications. 
 And 
 Sale 
 receives a 
 ProductSpecification 
 as a parameter 
 in the 
 makeLineItem 
 message; it has parameter visibility to one.
  
 These non-attribute visibilities may be illustrated with the dashed arrow line 
 indicating a dependency relationship (see Figure 19.11). There is no significance 
 in the curving of the dependency lines; it is graphically convenient.
  
 1
  
 Store
  
 Uses
  
 Contains
  
 ProductSpecification
  
 address : Address 
 name : Text
  
 1
  
 1
  
 addSale(...)
  
 ProductCatalog
  
 1..
 *
  
 description : Text 
 price : Money 
  
 itemID: ItemID
  
 1
  
 Looks-in
  
 1
  
 ...
  
 1
  
 getSpecification(...)
  
 Contains
  
 ...
  
 Houses
  
 1 
  
 Describes
  
 1
  
 1
  
 Sale",NA
* ,"SalesLineItem
  
 ...
  
 Register
  
 Captures
  
 date : Date 
  
 isComplete : Boolean
  
 time : Time
  
 1..
 *
  
 quantity : Integer
  
 endSale() 
  
 enterItem(...) 
  
 makeNewSale() 
  
 makePayment(...)
  
 1
  
 1
  
 becomeComplete() 
 makeLineItem(...) 
 makePayment(...) 
 getTotal()
  
 1
  
 getSubtotal()
  
 Logs-completed
 ",NA
*,"1
  
 Paid-by
  
 1
  
 Payment
  
 amount : Money
  
 A dependency of Register knowing about 
 ProductSpecification.
  
 ...
  
 Recommended when there is parameter,
  
 global or locally declared visibility.
  
 Figure 19.11 Dependency relationships indicating non-attribute visibility.
  
 295",NA
19.6     Notation for Member Details,"The UML provides a rich notation to describe features of class and interface members, 
 such as visibility, initial values, and so on. An example is shown in Figure 19.12.
  
 SampleClass
  
 java.awt.Font
  
 «interface»
  
 Runnable
  
 classAttribute 
  
 + publicAttribute
  
 - privateAttribute 
  
 attributeWithVisibilityUnspecified 
  
 attribute1 : type 
  
 burgers : List of VeggieBurger 
  
 attribute2 : type = initial value 
  
 finalConstantAttribute : int = 5  { frozen } 
 /derivedAttribute
  
 plain : Integer = 0 { frozen } 
 bold : Integer = 1 { frozen } 
 name : String 
  
 style : Integer = 0 
  
 ...
  
 run()
  
 + getFont(name : String) : Font + 
 getName() : String 
  
 ...
  
 AlarmClock
  
 classMethod() 
  
 + «constructor» SampleClass(int) 
  
 methodWithVisibilityUnspecified() 
  
 methodReturnsSomething() : Foo 
  
 abstractMethod() 
  
 abstractMethod2() { abstract }   // alternate 
  
 + publicMethod()
  
 - privateMethod() 
  
 # protectedMethod() 
  
 ~ packageVisibleMethod() 
  
 finalMethod() { leaf } 
  
 methodWithoutSideEffects() { query } 
  
 synchronizedMethod() { guarded } 
  
 method1WithParms(in parm1:String, inout parm2:int) 
 method2WithParms(parm1:String, parm2:float) 
  
 method3WithParms(parm1, parm2) 
  
 method4WithParms(String, int) 
  
 methodWithParmsAndReturn(parm1: String) : Foo 
 methodWithParmsButUnspecified(...) : Foo 
  
 methodWithParmsAndReturnBothUnspecified()
  
 java.awt.Toolkit 
  
  
  
 or 
  
 java.awt.Toolkit { abstract }
  
 run() 
  
 ...
  
 ...    // there are attributes, but not shown
  
 an empty 
  
 compartment 
  
 without ellipsis 
  
 means there is 
  
 definitely no 
  
 members (in 
  
 this case, no 
  
 attributes)
  
 # createButton(target : Button) : ButtonPeer + 
 getColorModel() : ColorModel
  
 ...
  
 FinalClass { leaf }
  
 ...  // there are methods, but not shown
  
 Figure 19.12 Some UML class diagram member notation details.",NA
Visibility Defaults in the UML?,"If no explicit visibility marker is shown for an attribute or method, what is the default? 
 Answer: there isn't a default. If none is shown, it implies ""not specified"" in the UML. 
 However, there is a common convention to assume that attributes are private and 
 methods public, unless otherwise noted.
  
 The current iteration of the NextGen POS design class diagram (see Figure 19.13) does 
 not have many interesting member details; all attributes are private and all methods 
 public.
  
 296",NA
Notation for Method Bodies in DCDs (and Interaction Diagrams),"A method body can be shown as illustrated in Figure 19.14 in both a DCD and an 
 interaction diagram.
  
 UML notation
 : 
  
 A method body implementation may be shown in a UML note box. It should be placed within braces, wh 
 signifies it is semantic influence (it is more than just a comment).
  
 The synax may be pseudo-code, or any language.
  
 It is common to exclude the method signature (public void ...), but it is legal to include it.
  
 Register
  
 {
  
  ProductSpecification spec = catalog.getSpecification(id); 
 sale.makeLineItem(spec, qty);
  
 }
  
 ...
  
 endSale() 
  
 enterItem(id, qty) 
  
 makeNewSale() 
  
 makePayment(cashTendered)
  
 { 
  
 public void enterItem( id, qty ) 
  
 {
  
 297
  
 } 
  
 }
  
  ProductSpecification spec = catalog.getSpecification(id); 
 sale.makeLineItem(spec, qty);
  
 Figure 19.14 Method body notation.",NA
"19.7     DCDs, Drawing, and CASE Tools","CASE tools can reverse-engineer (generate) DCDs from source code. In Chapter 
 35 on drawing and CASE tools, there is a brief discussion on the process context 
 and the practice of drawing DCDs.",NA
19.8     DCDs Within the UP,"DCDs are part of the use-case realizations and thus members of the UP Design 
 Model.
  
 Discipline
  
 Artifact 
  
 Iteration->
  
 Incep. I1
  
 Elab.
  
 El. .En
  
 Const. 
 C1..Cn
  
 Trans. 
 T1..T2
  
 Business Modeling
  
 Domain Model
  
  
 s
  
  
  
 Requirements
  
 Use-Case Model (SSDs)
  
 s
  
 r
  
  
  
 Vision
  
 s
  
 r
  
  
  
 Supplementary Specifications
  
 s
  
 r
  
  
  
 Glossary
  
 s
  
 r
  
  
  
 Design
  
 Design Model
  
  
 s
  
 r
  
  
 SW Architecture Document
  
  
 s
  
  
  
 Data Model
  
  
 s
  
 r
  
  
 Implementation
  
 Implementation Model
  
  
 s
  
 r
  
 r
  
 Project Management
  
 SW Development Plan
  
 s
  
 r
  
 r
  
 r
  
 Testing
  
 Test Model
  
  
 s
  
 r
  
  
 Environment
  
 Development Case
  
 s
  
 r
  
  
  
 Table 19.1 Sample UP artifacts and timing. s - start; r - refine",NA
Phases,"Inception
 —The Design Model and DCDs will not usually be started until elab-
 oration because it involves detailed design decisions, which are premature dur-
 ing inception.
  
 Elaboration
 —During this phase, DCDs will accompany the use-case realiza-tion 
 interaction diagrams; they may be created for the most architecturally sig-nificant 
 classes of the design.
  
 Note that CASE tools can reverse-engineer (generate) DCDs from source code. It 
 is recommended to generate DCDs regularly from the source code, to visualize 
 the static structure of the system.
  
 Construction
 —DCDs will continue to be generate d from the source code as an 
 aid in visualizing the static structure of the system.
  
 298",NA
19.9     UP Artifacts,"299
  
 Artifact influence emphasizing the DCDs is shown in Figure 19.15. 
  
 Sample UP Artifact Relationships for Design Class Diagrams 
  
  
 Domain Model
  
 inspires 
  
 the names 
  
 and 
  
 attributes 
  
 of some 
  
 software 
  
 classes in 
  
 the design
  
 Register
  
 1
  
 1
  
 Sale
  
 . . .
  
 . . .
  
 date 
  
 . . .
  
 . . .
  
 suggests domain 
  
 concepts
  
 Use-Case Model
  
  
 requires UCRs 
  
 Design Model
  
 : Register
  
 : ProductCatalog
  
 makeNewSale()
  
 spec := getSpecification( itemID ) 
  
 . . .
  
 use-case
  
 realizations 
  
 (UCRs)
  
 enterItem 
  
 (itemID, quantity)
  
 the design classes
  
 discovered while 
  
 designing UCRs are 
  
 summarized in DCDs
  
 Register
  
 ProductCatalog
  
 ...",NA
*,"1
  
 ...
  
 design 
  
 class
  
 makeNewSale() 
  
 enterItem(...) 
  
 ...
  
 getSpecification(...) 
 ...
  
 diagrams 
  
 (DCDs)
  
 Sale
  
 . . .
  
 date 
  
 ...
  
 ...
  
 . . . 
  
 . . .
  
 Figure 19.15 Sample UP artifact influence.",NA
Chapter 20,NA,NA
IMPLEMENTATION MODEL,NA,NA
: ,NA,NA
MAPPING DESIGNS TO CODE,"Beware of bugs in the above code; I 
  
 have only proved it correct, not tried it.
  
 —
 Donald Knuth",NA
Objectives,Map design artifacts to code in an object-oriented language.,NA
Introduction,"With the completion of interaction diagrams and DCDs for the current iteration 
 of the NextGen application, there is sufficient detail to generate code for the 
 domain layer of objects.
  
 The UML artifacts created during the design work—the interaction diagrams and 
 DCDs—will be used as input to the code generation process.
  
 The UP defines the Implementation Model. This contains the implementation 
 artifacts such as the source code, database definitions, JSP/XML/HTML pages, 
 and so forth. Thus, the code being created in this chapter is part of the Imple-
 mentation Model.",NA
Language Samples,"Java 
 is used for the examples because of its widespread use and familiarity. 
 However, this is not meant to imply a special endorsement of Java; C#, Visual 
 Basic, C++, Smalltalk, Python, and many more languages are amenable to the 
 object design principles and mapping to code presented in this case study.
  
 301",NA
20.1      Programming and the Development Process,"The prior design work should not be taken to imply that there is no prototyping or 
 design while programming; modern development tools provide an excellent 
 environment to quickly explore alternate approaches, and some (or even lots) design-
 while-programming is usually worthwhile.
  
 However, some developers find that a little forethought with visual modeling before 
 programming is helpful, especially those who are comfortable with visual thinking or 
 diagrammatic languages.
  
 Suggestion
  
 For a two-week iteration, consider spending at least a half-day near the start of the 
 iteration doing some visual modeling design work, before moving on to 
 programming. Use simple ""tools"" that support quick creative diagramming, such as 
 a whiteboard and digital camera. If you find a UML computer-aided software 
 engineering (CASE) tool that is equally fast, easy, and convenient, excellent.
  
 The creation of code in an object-oriented programming language—such as Java or 
 C#—is not part of OOA/D; it is an end goal. The artifacts created in the UP Design 
 Model provide some of the information necessary to generate the code.
  
 A strength of OOA/D and OO programming—when used with the UP—is that they 
 provide an end-to-end roadmap from requirements through to code. The various artifacts 
 feed into later artifacts in a traceable and useful manner, ulti-mately culminating in a 
 running application. This is not to suggest that the road will be smooth, or can simply be 
 mechanically followed—there are too many variables. But having a roadmap provides a 
 starting point for experimen-tation and discussion.",NA
Creativity and Change During Implementation,"Some decision-making and creative work was accomplished during design work. It will 
 be seen during the following discussion that the generation of the code— in this 
 example—is a relatively mechanical translation process.
  
 However, in general, the programming work is not a trivial code generation step—quite 
 the opposite. Realistically, the results generated during design are an incomplete first 
 step; during programming and testing, myriad changes will be made and detailed 
 problems will be uncovered and resolved.
  
 Done well, the design artifacts will provide a resilient core that scales up with elegance 
 and robustness to meet the new problems encountered during pro-
  
 302",NA
Code Changes and the Iterative Process,"A strength of an iterative and incremental development process is that the results 
 of a prior iteration can feed into the beginning of the next iteration (see Figure 
 20.1). Thus, subsequent analysis and design results are continually being refined 
 and enhanced from prior implementation work. For example, when the code in 
 iteration N deviates from the design of iteration N (which it inevitably will), the 
 final design based on the implementation can be input to the analysis and design 
 models of iteration N+l.
  
 Iterative Cycles
  
 of Development
  
 Requirements 
  
 Analysis
  
 Requirements 
 Analysis
  
 Requirements 
  
 Analysis
  
 Design
  
 Design
  
 Design
  
 Implementation 
  
 and Testing
  
 Implementation 
 and Testing
  
 Implementation 
  
 and Testing
  
 Time
  
  
 Figure 20.1 Implementation in an iteration influences later design.
  
 An early activity within an iteration is to synchronize the design diagrams; the 
 earlier diagrams of iteration N will not match the final code of iteration N, and 
 they need to be synchronized before being extended with new design results.",NA
"Code Changes, CASE Tools, and Reverse-Engineering","It is desirable for the diagrams generated during design to be semi-automati-cally 
 updated to reflect changes in the subsequent coding work. Ideally this should be 
 done with a CASE tool that can read source code and automatically generate, for 
 example, package, class, and sequence diagrams. This is an aspect of 
 reverse-
 engineering
 —the activity of generating diagrams from source (or sometimes, 
 executable) code.
  
 303",NA
20.2     Mapping Designs to Code,"Implementation in an object-oriented programming language requires writing source 
 code for:
  
 • class and interface definitions 
  
 • method definitions 
  
 The following sections discuss their generation in Java (as a typical case).",NA
20.3     Creating Class Definitions from DCDs,"At the very least, DCDs depict the class or interface name, superclasses, method 
 signatures, and simple attributes of a class. This is sufficient to create a basic class 
 definition in an object-oriented programming language. Later discussion will explore 
 the addition of interface and namespace (or package) information, among other details.",NA
Defining a Class with Methods and Simple Attributes,"From the DCD, a mapping to the basic attribute definitions (simple Java instance 
 fields) and method signatures for the Java definition of 
 SalesLineItem 
 is 
 straightforward, as shown in Figure 20.2.
  
 public class SalesLineItem 
  
 { 
  
 private int quantity;
  
 public SalesLineItem(ProductSpecification spec, int qty) { ... }
  
 public Money getSubtotal() { ... }
  
 }
  
 SalesLineItem",NA
*,"Described-by
  
 1
  
 ProductSpecification
  
 quantity : Integer
  
 description : Text 
 price : Money 
  
 itemID : ItemID
  
 getSubtotal() : Money
  
 ...
  
 Figure 20.2 SalesLineItem in Java.
  
 304",NA
Adding Reference Attributes,"A reference attribute 
 is an attribute that refers to another complex object, not to a 
 primitive type such as a String, Number, and so on.
  
 The reference attributes of a class are suggested by the associations and nav-
 igability in a class diagram.
  
 For example, a 
 SalesLineItem 
 has an association to a 
 ProductSpecification, 
 with 
 navigability to it. It is common to interpret this as a reference attribute in class 
 SalesLineItem 
 that refers to a 
 ProductSpecification 
 instance (see Figure 20.3).
  
 In Java, this means that an instance field referring to a 
 ProductSpecification 
 instance 
 is suggested.
  
 Simple attribute
  
 Reference attribute
  
 public class SalesLineItem 
  
 { 
  
 private int quantity;
  
 private ProductSpecification productSpec;
  
 public SalesLineItem(ProductSpecification spec, int qty) {... }
  
 public  Money getSubtotal() { ... } 
  
 }
  
 SalesLineItem",NA
*,"Described-by
  
 1
  
 ProductSpecification
  
 description : Text 
 price : Money 
  
 itemID : ItemID
  
 quantity : Integer
  
 getSubtotal() : Money
  
 ...
  
  
 Figure 20.3 Adding reference attributes.
  
 Note that reference attributes of a class are often implied, rather than 
  
 explicit, in a DCD.
  
 305",NA
Reference Attributes and Role Names,"The next iteration will explore the concept of role names in static structure dia-grams. 
 Each end of an association is called a role. Briefly, a 
 role name 
 is a name that 
 identifies the role and often provides some semantic context as to the nature of the role.
  
 If a role name is present in a class diagram, use it as the basis for the name of the 
 reference attribute during code generation, as shown in Figure 20.4.
  
 public class SalesLineItem 
  
 { 
  
 ...
  
 private int quantity;
  
 private ProductSpecification productSpec; 
  
 }
  
 SalesLineItem",NA
*,"Described-by
  
 1
  
 ProductSpecification
  
 description : Text 
 price : Money 
  
 itemID : ItemID
  
 quantity : Integer
  
 productSpec
  
 getSubtotal() : Money
  
 ...
  
 Role name used in 
  
 attribute name.
  
 Figure 20.4 Role names may be used to generate instance variable names.",NA
Mapping Attributes,"The 
 Sale 
 class illustrates that in some cases one must consider the mapping of 
 attributes from the design to the code in different languages. Figure 20.5 illus-trates the 
 problem and its resolution.",NA
Creating Methods from Interaction Diagrams,"An interaction diagram shows the messages that are sent in response to a method 
 invocation. The sequence of these messages translates to a series of statements in 
 the method definition. The 
 enterltem 
 interaction diagram in Figure 20.6 illustrates 
 the Java definition of the 
 enterltem 
 method.
  
 In this example, the 
 Register 
 class will be used. A Java definition is shown in 
 Figure 20.7.
  
 enterItem(id, qty)
  
 :Register
  
 2: makeLineItem(spec, qty)
  
 :Sale
  
  
 1: spec := getSpecification(id)
  
 :Product 
  
 Catalog
  
 1.1: spec := find(id)
  
 :Product
  
 Specification
  
 2.2: add(sl)
  
 SalesLineItem
  
 :SalesLineItem
  
 Figure 20.6 The enterltem interaction diagram.
  
 307",NA
The Register-enterltem Method,"public class Register 
  
 { 
  
 private ProductCatalog catalog; 
  
 private Sale sale;
  
 public Register(ProductCatalog pc) {...}
  
 Looks-in
  
 1
  
 ProductCatalog
  
 public  void endSale() {...} 
  
 public  void enterItem(ItemID id, int qty) {...} 
  
 public void makeNewSale() {...} 
  
 public  void makePayment(Money cashTendered) {...} }
  
 ...
  
 getSpecification(...)
  
 1
  
 1
  
 Captures
  
 1
  
 Sale
  
 Register
  
 date : Date 
  
 isComplete : Boolean 
 time : Time
  
 ...
  
 endSale() 
  
 enterItem(id: ItemID, qty : Integer) 
  
 makeNewSale() 
  
 makePayment(cashTendered : Money)
  
 becomeComplete() 
 makeLineItem(...) 
 makePayment(...) 
 getTotal()
  
 Figure 20.7 The Register class.
  
 The 
 enterltem 
 message is sent to a 
 Register 
 instance; therefore, the 
 enterltem 
 method is defined in class 
 Register.
  
 public  void enterltem ( ItemID  itemID,   int  qty)
  
 Message 1: 
 A getSpecification 
 message is sent to the 
 ProductCatalog 
 to retrieve a 
 ProductSpecification.
  
 ProductSpecif ication  spec   =  catalog. getSpecif ication(   itemID   ); 
  
 Message 2: 
 The 
 makeLineltem 
 message is sent to the 
 Sale. 
  
 sale .makeLineltemf spec,   qty);
  
 In summary, each sequenced message within a method, as shown on the interac-tion 
 diagram, is mapped to a statement in the Java method.
  
 The complete 
 enterltem 
 method and its relationship to the interaction diagram is 
 shown in Figure 20.8.",NA
Container/Collection Classes in Code,"It is often necessary for an object to maintain visibility to a group of other objects; 
 the need for this is usually evident from the multiplicity value in a class diagram—
 it may be greater than one. For example, a 
 Sale 
 must maintain visi-bility to a group 
 of 
 SalesLineltem 
 instances, as shown in Figure 20.9.
  
 In OO programming languages, these relationships are often implemented with 
 the introduction of a intermediate container or collection. The one-side class 
 defines a reference attribute pointing to a container/collection instance, which 
 contains instances of the many-side class.
  
 For example, the Java libraries contain collection classes such as 
 ArrayList 
 and 
 HashMap, 
 which implement the 
 List 
 and 
 Map 
 interfaces, respectively. Using 
 ArrayList, 
 the 
 Sale 
 class can define an attribute that maintains an ordered list 
 of 
 SalesLineltem 
 instances.
  
 The choice of collection class is of course influenced by the requirements; key-
 based lookup requires the use of a 
 Map, 
 a growing ordered list requires a 
 List, 
 and 
 so on.",NA
Exceptions and Error Handling,"Exception handling has been ignored so far in the development of a solution. This 
 was intentional to focus on the basic questions of responsibility assignment and 
 object design. However, in application development, it is wise to consider 
 exception handling during design work, and certainly during implementation.
  
 309",NA
7     Defining the Sale--makeLineltem Method,"As a final example, the 
 makeLineltem 
 method of class 
 Sale 
 can also be written by 
 inspecting the 
 enterltem 
 collaboration diagram. An abridged version of the 
 interaction diagram, with the accompanying Java method, is shown in Figure 
 20.10.
  
 enterItem(id, qty)
  
 :Register
  
 { 
  
 }
  
  lineItems.add( new SalesLineItem(spec, qty) );
  
 2: makeLineItem(spec, qty)
  
 :Sale
  
 2.2: add(sl)
  
 2.1: create(spec, qty
  
  
 SalesLineItem 
  
 :SalesLineItem
  
 sl: SalesLineItem
  
 Figure 20.10 Sale-makeLineltem method.
  
 310",NA
* ,"SalesLineItem
  
 Register
  
 date : Date 
  
 isComplete : Boolean 
 time : Time
  
 ...
  
 Captures
  
 1..
 *
  
 quantity : Integer
  
 endSale() 
  
 enterItem(...) 
  
 makeNewSale() 
  
 makePayment(...)
  
 1
  
 1
  
 becomeComplete() 
 makeLineItem(...) 
 makePayment(...) 
 getTotal()
  
 1
  
 getSubtotal()
  
 Logs-completed
 ",NA
*,"1
  
 Paid-by
  
 1
  
 Payment
  
 1
  
 amount : Money
  
 ...
  
 Figure 20.11 Possible order of class implementation and testing.",NA
20.8 ,NA,NA
Order of Implementation,"Classes need to be implemented (and ideally, fully unit tested) from least-cou-
 pled to most-coupled (see Figure 20.11). For example, possible first classes to 
 implement are either 
 Payment 
 or 
 ProductSpecification; 
 next are classes only 
 dependent on the prior implementations—
 ProductCatalog 
 or 
 SalesLineltem.",NA
20.9 ,NA,NA
Test-First Programming,"An excellent practice promoted by the Extreme Programming (XP) method 
 [BeckOO], and applicable to the UP (as most XP practices are), is 
 test-first pro-
 gramming. 
 In this practice, unit testing code is written 
 before 
 the code to be 
 tested, and the developer writes unit testing code for 
 all 
 production code. The 
 basic rhythm is to write a little test code, then write a little production code, make 
 it pass the test, then write some more test code, and so forth.
  
 311",NA
Summary of Mapping Designs to Code,"The translation process from DCDs to class definitions, and from interaction 
 diagrams to methods, is relatively straightforward. There is still lots of room for 
 decision-making, design changes, and exploration during programming work, but 
 some of the big design ideas have been considered prior to the programming.",NA
Introduction to the Program Solution,"This section presents a sample domain object layer program solution in Java for 
 this iteration. The code generation is largely derived from the design class dia-
 grams and interaction diagrams defined in the design work, based on the princi-
 ples of mapping designs to code as previously explored.
  
 The main point of this listing is to show that there is a translation from design 
 artifacts to a foundation of code. This code defines a simple case; it is not meant 
 to illustrate a robust, fully developed Java program with synchro-nization, 
 exception handling, and so on.
  
 Class Payment
  
 public class Payment { 
  
 private Money amount; 
  
 public Payment( Money cashTendered ){ amount = cashTendered; } 
 public Money getAmount() { return amount; } }
  
 Class ProductCatalog
  
 public class ProductCatalog { 
  
  
 private Map productSpecifications = new HashMap();
  
 313",NA
Class ProductSpecification,"public class ProductSpecification { 
  
 private ItemID id; 
  
 private Money price; 
  
 private String description;
  
 public ProductSpecification 
  
  
  
 ( ItemID id. Money price. String description ) 
 { 
   
 this.id = id; 
  
  
 this.price = price; 
  
  
  
 this.description = description; }
  
 public ItemID getltemlDO { return id;} 
  
 public Money getPrice() { return price; }
  
 public String getDescription() { return description; }
  
 }",NA
Class Sale,"public class Sale 
  
 { 
  
  
  
 private List lineltems = new ArrayListO; 
 private Date date = new Date(); 
  
 private boolean isComplete = false; 
  
 private Payment payment;
  
 public Money getBalanceO { 
  
 return payment.getAmount().minus( getTotal() ); }
  
 public void becomeComplete() { isComplete = true; } 
  
 public boolean isComplete() { return isComplete; }
  
 public void makeLineltem
  
 ( ProductSpecification spec, int quantity ) { 
  
 lineltems.add( new SalesLineltem( spec, quantity ) ); 
 }
  
 public Money getTotal() 
  
 { 
  
  
 Money total = new MoneyO; 
  
  
   
 Iterator i = lineltems.iterator( ) ; 
  
 while ( i.hasNextO ) 
  
  
     
 { 
  
  
     
 SalesLineltem sli = (SalesLineltem) i.nextO; 
  
  
    
 total.add( sli.getSubtotal() ); 
  
  
    
 }
  
 return total; }
  
 315",NA
Class SalesLineltem,"public class SalesLineltem { 
  
 private int quantity; 
  
 private ProductSpecification productSpec;
  
 public SalesLineltem (ProductSpecification spec, int quantity ) { 
  
 this.productSpec = spec; 
  
 this.quantity = quantity; }
  
 public Money getSubtotal() { 
  
 return productSpec.getPrice().times( quantity ); } }",NA
Class Store,"public class Store 
  
 { 
  
  
 private ProductCatalog catalog = new ProductCatalog(); 
  
 private Register register = new Register( catalog );
  
 public Register getRegister() { return register; } }",NA
PART ,NA,NA
4 ,NA,NA
ELABORATIO,NA,NA
N ITERATION ,NA,NA
2,NA,NA
Chapter,NA,NA
ITERATION ,NA,NA
2 ,NA,NA
AND ITS ,NA,NA
REQUIREMENTS,NA,NA
Iteration 2 Emphasis: Object Design and Patterns,"The inception phase chapters and those for iteration 1 in the elaboration phase 
 emphasized a range of fundamental analysis and object design skills, in order to 
 share information on a breadth of common steps in building object systems.
  
 In this iteration, the case study just emphasizes:
  
 • 
  
 • 
  
 • 
  
 essential object design 
  
 the use of patterns to create a solid design 
 application of the UML to visualize the models 
  
 These are primary objectives of the book, and critical skills.
  
 There is minimal discussion of requirements analysis or domain modeling, and 
 the explanation of the design is more succinct, now that (in iteration 1) a detailed 
 explanation of the basics of how to think in objects has been presented.
  
 Many other analysis, design, and implementation activities would of course occur 
 in this iteration, but these are de-emphasized in favor of sharing informa-tion 
 about how to do object design.",NA
From Iteration 1 to 2,"When iteration 1 ends, the following should be accomplished:
  
 • 
  
 All the software has been vigorously tested: unit, acceptance, load, usability, 
 and so on. The idea in the UP is to do early, realistic, and continuous verifi 
 cation of quality and correctness, so that early feedback guides the develop 
 ers to adapt and improve the system, finding its ""true path.""
  
 319",NA
Simplifications in the Case Study,"In a skillful UP project, the requirements chosen for the early iterations are 
 organized by risk and high business value, so that the high-risk issues are iden-
 tified and resolved early. However, if this case study exactly followed that strat-
 egy, it would not be possible to help explain fundamental ideas and principles of 
 OOA/D in the early iterations. Therefore, some license is taken with the prioriti-
 zation of requirements, preferring those that support the educational goals, rather 
 than project risk goals.
  
 320",NA
Iteration 2 Requirements,"Iteration 2 of the NextGen POS application handles several interesting 
 requirements:
  
 1. Support for variations in third-party external services. For example, differ ent 
 tax calculators must be connectable to the system, and each has a unique 
 interface. Likewise with different accounting systems and so forth. Each will 
 offer a different API and protocol for a core of common functions. 
  
 2. Complex pricing rules. 
  
 3. Pluggable business rules. 
  
 4. A design to refresh a GUI window when the sale total changes. 
  
 These requirements will only be considered (for this iteration) in the context of 
 scenarios of the 
 Process Sale 
 use case.
  
 Note that these are not newly discovered requirements; they were identified 
 during inception. For example, the original 
 Process Sale 
 use case indicates the 
 pricing problem:
  
 Main Success Scenario:
  
 1. Customer arrives at a POS checkout with goods and/or services to purchase. 
  
 2. Cashier tells System to create a new sale. 
  
 3. Cashier enters item identifier. 
  
 4. System records sale line item and presents item description, price, and running total. 
  
 Price calculated from a set of price rules.
  
 Furthermore, sections in the Supplementary Specification record details of the 
 domain rules for pricing, and indicate the need to support varying external
  
 systems:
  
 Supplementary Specification
  
 Interfaces
  
 Software Interfaces
  
 For most external collaborating systems (tax calculator, accounting, inventory, ... ) we need to be able to 
  
 plug in varying systems and thus varying interfaces.
  
 321",NA
Incremental Development for the Same Use Case Across Iterations,"Because of these requirements, we are revisiting the 
 Process Sale 
 use case in iteration 
 2, but implementing more scenarios, so that the system incrementally grows. It is 
 common to work on varying scenarios or features of the same use case over several 
 iterations and gradually extend the system to ultimately handle all the functionality 
 required. On the other hand, short, simple use cases may be completely implemented 
 within one iteration.
  
 Iteration 1 made simplifications so that the problem and solution were not overly 
 complex to explore. Once again—for the same reason—a relatively small amount of 
 additional functionality is considered.
  
 In a development project the requirements chosen for this iteration in the book would 
 not be the undisputed choice—another possibility is updating inventory, credit 
 payment handling, or a completely different use case. However, this choice is rich with 
 valuable learning opportunities.",NA
I     Refinement of Analysis-oriented Artifacts in this Iteration ,NA,NA
Use-Case Model: Use Cases,"No refinement is required of the use cases as a result of the chosen requirements for 
 this iteration, although they may change as a result of other insights.
  
 However, in addition to object design and programming, a parallel activity of a second 
 short requirements workshop will occur in this iteration, within which more use cases 
 will be investigated and written in detail. The previously fully dressed use cases (for 
 example, 
 Process Sale) 
 will be revisited and probably
  
 J3£2_",NA
Use-Case Model: SSDs,"This iteration includes adding support for third-party external systems with 
 varying interfaces, such as a tax calculator. The NextGen POS system will be 
 remotely communicating with external systems. Consequently, the SSDs should 
 be updated to reflect at least some of the inter-system collaborations, in order to 
 clarify what the new system-level events are.
  
 Figure 21.1 illustrates an SSD for one scenario of paying by credit, which 
 requires collaboration with several external systems. Even though the design of 
 paying by credit is not handled in this iteration, the designer (me) has drawn an 
 SSD based on it (and probably several others as well), to better understand the 
 inter-system collaboration, and thus the required support for varying interfaces in 
 the external systems.",NA
Domain Model,"After a little experience in domain modeling, a modeler can estimate if a set of 
 new requirements will have a minor or major impact on the Domain Model in 
 terms of many new concepts, associations, and attributes. In contrast to the prior 
 iteration, the requirements being tackled this time do not involve many new 
 domain concepts. A brief survey of the new requirements suggests something like 
 PriceRule 
 as a domain concept, but there are probably not dozens of new things.
  
 In this situation, it is quite reasonable to skip refining the Domain Model, move 
 quickly on to design work, and let the discovery of new domain concepts occur 
 during object design, when the designers are thinking through a solution. A sign 
 of process maturity with the UP is understanding when creating an artifact will 
 add significant value, or is a kind of mechanical ""make work"" step, and better 
 skipped.
  
 This flexibility is a double-edged sword. All too often, the flexibility to skip pre-
 programming activities occurs out of an overly optimistic belief that the problem 
 can be solved simply by rushing to code. If it truly can, great, because program-
 ming is the work that really matters, not drawing domain models. On the other 
 hand, most developers have stories where a little reflection, investigation, and 
 forethought before programming would have reduced pain and suffering.
  
 323",NA
Use-Case Model: System Operation Contracts,"No new system operations are being considered in this iteration, and thus con-tracts 
 are not required. In any event, contracts are just an option to consider when the 
 detailed precision they offer is an improvement over the descriptions in the use cases.
  
 324
  
 : Cashier
  
 Process Sale
  
 «actor»
  
 :CreditAuthorization 
 Service
  
 «actor»
  
 :Accounts
  
 Pay by Credit Scenario
  
 :NextGenPOS 
 System
  
 «actor»
  
 :TaxCalculator
  
 makeNewSale()
  
 enterItem(itemID, quantity)
  
 description, total
  
 * [more items]
  
 endSale()
  
 taxLineItems := 
  
 getTaxes( sale )
  
 total with taxes
  
 makeCreditPayment 
  
 (credNum, expiryDate)
  
 reply := requestApproval(request)
  
 postReceivable( receivable )
  
 postSale( sale )
  
 Figure 21.1 An SSD scenario that illustrate some external systems",NA
Chapter,NA,NA
22,NA,NA
GRASP: ,NA,NA
MORE PATTERNS ,NA,NA
FOR ASSIGNING ,NA,NA
RESPONSIBILITIES,"Luck is the residue of design. 
  
 —
 Branch Rickey",NA
Objectives,•      Learn to apply the remaining GRASP patterns.,NA
Introduction,"Previously, we explored the application of the first five GRASP patterns:
  
 • 
  
 Information Expert, Creator, High Cohesion, Low Coupling, and Controller 
  
 The final four GRASP patterns are: 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Polymorphism 
  
 Indirection 
  
 Pure Fabrication 
  
 Protected Variations 
  
 Once these have been explained, we will have a rich and shared vocabulary with 
 which to discuss designs. And as some of the ""gang-of-four"" (GoF) design pat-
 terns (such as Strategy and Factory) are also introduced (in subsequent chapters), 
 that vocabulary will grow. A short sentence such as, ""I suggest a Strategy 
 generated from a Factory to support Protected Variations and low coupling with 
 respect to 
 <X>"" 
 communicates lots of information about the design, since pattern 
 names tersely convey a complex design concept.
  
 325",NA
1     Polymorphism,"Solution 
 When related alternatives or behaviors vary by type (class), assign responsibility for 
 the behavior—using polymorphic operations—to the types for which the behavior 
 varies.
 1
  
 Corollary: 
 Do not test for the type of an object and use conditional logic to per-
 form varying alternatives based on type.
  
 Problem 
 How to handle alternatives based on type? How to create pluggable software 
 components?
  
 Alternatives based on type
 —Conditional variation is a fundamental theme in 
 programs. If a program is designed using if-then-else or case statement condi-
 tional logic, then if a new variation arises, it requires modification of the case 
 logic. This approach makes it difficult to easily extend a program with new vari-
 ations because changes tend to be required in several places—wherever the con-
 ditional logic exists,
  
 Pluggable software components
 —Viewing components in client-server relation-
 ships, how can you replace one server component with another, without affecting 
 the client?
  
 Example 
 In the NextGen POS application, there are multiple external third-party tax cal-
 culators that must be supported (such as Tax-Master and Good-As-Gold Tax-Pro); 
 the system needs to be able to integrate with different ones. Each tax calculator has 
 a different interface, and so there is similar but varying behavior to adapt to each 
 of these external fixed interfaces or APIs. One product may sup-port a raw TCP 
 socket protocol, another may offer a SOAP interface, and a third may offer a Java 
 RMI interface.
  
 What objects should be responsible for handling these varying external tax cal-
 culator interfaces?
  
 1. Polymorphism 
 has several related meanings. In this context, it means ""giving the same 
 name to services in different objects"" [Coad95] when the services are similar or related. 
 The different object types usually implement a common interface or are related in an 
 implementation hierarchy with a common superclass, but this is lan-
  
 guage-dependent; for example, dynamic binding languages such as Smalltalk do not 
 require this.
  
 326",NA
Fabrication,"Assign a highly cohesive set of responsibilities to an artificial or convenience class 
 that does not represent a problem domain concept—something made up, to support 
 high cohesion, low coupling, and reuse.
  
 Such a class is 
 a fabrication 
 of the imagination. Ideally, the responsibilities assigned 
 to this fabrication support high cohesion and low coupling, so that the design of the 
 fabrication is very clean, 
 or pure
 —hence a pure fabrication.
  
 Finally, a pure fabrication implies making something up, which we do when we're 
 desperate!
  
 What object should have the responsibility, when you do not want to violate High 
 Cohesion and Low Coupling, or other goals, but solutions offered by Expert (for 
 example) are not appropriate?
  
 Object-oriented designs are sometimes characterized by implementing as soft-ware 
 classes representations of concepts in the real-world problem domain to lower the 
 representational gap; for example a 
 Sale 
 and 
 Customer 
 class. However, there are many 
 situations in which assigning responsibilities only to domain layer software classes 
 leads to problems in terms of poor cohesion or coupling, or low reuse potential.
  
 For example, suppose that support is needed to save 
 Sale 
 instances in a relational 
 database. By Information Expert, there is some justification to assign this 
 responsibility to the 
 Sale 
 class itself, because the sale has the data that needs to be 
 saved. But consider the following implications:
  
 • 
  
 • 
  
 The task requires a relatively large number of supporting database-oriented 
 operations,  none related to the concept of sale-ness,  so the 
 Sale  
 class becomes 
 incohesive. 
  
 The 
 Sale 
 class has to be coupled to the relational database interface (such as 
 JDBC in Java technologies), so its coupling goes up. And the coupling is not even 
 to another domain object, but to a particular kind of database 
  
 interface. 
  
 329",NA
22.3     Indirection,"Solution 
 Assign the responsibility to an intermediate object to mediate between other 
  
 components or services so that they are not directly coupled.
  
 The intermediary creates an 
 indirection 
 between the other components.
  
 Problem 
 Where to assign a responsibility, to avoid direct coupling between two (or more) 
 things? How to de-couple objects so that low coupling is supported and reuse 
 potential remains higher?
  
 Examples  TaxCalculatorAdapter
  
 These objects act as intermediaries to the external tax calculators. Via polymor-
 phism, they provide a consistent interface to the inner objects and hide the vari-
 ations in the external APIs. By adding a level of indirection and adding 
 polymorphism, the adapter objects protect the inner design against variations in 
 the external interfaces (see Figure 22.3).
  
 332",NA
1     Protected Variations,"Solution 
 Identify points of predicted variation or instability; assign responsibilities to create 
 a stable interface around them.
  
 Note: The term ""interface"" is used in the broadest sense of an access view; it does 
 not literally only mean something like a Java or COM interface.
  
 Problem 
 How to design objects, subsystems, and systems so that the variations or insta-
 bility in these elements does not have an undesirable impact on other elements?
  
 Example 
 For example, the prior external tax calculator problem and its solution with 
 Polymorphism illustrate Protected Variations (Figure 22.1). The point of insta-
 bility or variation is the different interfaces or APIs of external tax calculators. 
 The POS system needs to be able to integrate with many existing tax calculator 
 systems, and also with future third-party calculators not yet in existence.
  
 By adding a level of indirection, an interface, and using polymorphism with var-
 ious 
 ITaxCalculatorAdapter 
 implementations, protection within the system from 
 variations in external APIs is achieved. Internal objects collaborate with a stable 
 interface; the various adapter implementations hide the variations to the external 
 systems.
  
 Discussion 
 Protected Variations (PV) was first published as a pattern by Cockburn in 
 [VCK96], although this very fundamental design principle has been around for 
 decades under various terms.
  
 Mechanisms Motivated by PV
  
 PV is a root principle motivating most of the mechanisms and patterns in pro-
 gramming and design to provide flexibility and protection from variations.
  
 At one level, the maturation of a developer or architect can be seen in their growing 
 knowledge of ever-wider mechanisms to achieve PV, to pick the appro-priate PV 
 battles worth fighting, and their ability to choose a suitable PV solution. In the 
 early stages, one learns about data encapsulation, interfaces, and polymorphism—
 all core mechanisms to achieve PV. Later, one learns techniques such as rule-based 
 languages, rule interpreters, reflective and metadata designs, virtual machines, and 
 so forth—all of which can be applied to protect against some variation.
  
 For example:
  
 Core Protected Variations Mechanisms
  
 Data encapsulation, interfaces, polymorphism, indirection, and standards are 
 motivated by PV. Note that components such as brokers and virtual machines are 
 complex examples of indirection to achieve PV.
  
 334",NA
Chapter 23,NA,NA
DESIGNING USE,NA,NA
-,NA,NA
CASE ,NA,NA
REALIZATIONS WITH ,NA,NA
GoF ,NA,NA
DESIGN PATTERNS,"Anything you can do, I can do meta. 
  
 —
 Daniel Dennett",NA
Objectives,"•      Apply GRASP and GoF design patterns to the design of the NextGen 
  
 case study.",NA
Introduction,"This chapter explores object design for use-case realizations for the next iteration 
 of the NextGen case study, which tackles support for external third-party services 
 whose interfaces may vary, more complex product pricing rules, and pluggable 
 business rules.
  
 In the context of the design problems that will be discussed, new high-use UML 
 notation will also be introduced.
  
 The emphasis is to show how to apply the GoF and more basic GRASP patterns. 
 It attempts to illustrate that object design and the assignment of responsibilities 
 can be explained and learned based on the application of patterns—a vocabulary 
 of principles and idioms that can be combined to design objects.
  
 341",NA
The Gang-of-Four Patterns,"The additional patterns presented in this chapter are drawn from 
 Design Pat-terns 
 [GHJV95], a seminal and extremely popular work that presents 23 patterns useful 
 during object design. Since the book was written by four authors, these patterns 
 have become known as the ""Gang-of-Four""—or ""GoF""—patterns.
 1
  
 This chapter provides an introduction to some of the high-use GoF patterns; 
 subsequent chapters present more.
 2
  A thorough study of the 
 Design Patterns 
 book 
 is recommended to grow as an object designer, although that book assumes the 
 reader is already a designer with some experience; this book offers an intro-
 duction.",NA
A Shared Vocabulary,"In addition to the visual vocabulary of UML notation, by the end of this chapter 
 we will have a richer shared vocabulary of design, in terms of pattern names. Thus, 
 it will be possible to increasingly communicate software design ideas pri-marily in 
 UML diagrams, with some attached notes that indicate the patterns (Indirection, 
 Strategy, ...) being applied.",NA
1     Adapter (GoF),"The problem explored in the previous chapter to motivate the Polymorphism 
 pattern, and its solution, is more specifically an example of the GoF 
 Adapter 
 pattern.
  
 Adapter 
  
 Context / Problem
  
 How to resolve incompatible interfaces, or provide a stable interface to similar 
 components with different interfaces?
  
 Solution
  
 Convert the original interface of a component into another interface, through an 
 intermediate adapter object.
  
 To review: The NextGen POS system needs to support several kinds of external 
 third-party services, including tax calculators, credit authorization services,
  
 1. With a tangential reference to Chinese politics. 
  
 2. In practice, perhaps approximately 15 of these 23 patterns are frequently used. 
  
 342",NA
"Polymorphism, Indirection, and Protected Variations (GRASP)","The previous application of the Adapter pattern is a specialization of the GRASP 
 building blocks. It offers Protected Variations from changing external interfaces or 
 third-party packages through the use of an Indirection object that applies interfaces 
 and Polymorphism.
  
 Note that most more complex or specialized patterns can be analyzed in terms of the 
 basic GRASP family. There are hundreds of published design patterns, and although it 
 is helpful to study these to accelerate learning, understanding their underlying basic 
 themes (Protected Variations, Low Coupling, Polymorphism, Indirection, ...) helps us 
 to cut through the myriad details and see the essential ""alphabet"" of design techniques 
 being applied.",NA
Naming Convention: Embed Pattern Name in Type Name?,"Notice that the type names include the pattern name ""Adapter."" This is a rela-tively 
 common style and has the advantage of easily communicating to others reading the 
 code or diagrams what design patterns are being used.",NA
"""Analysis"" Discoveries During Design: Domain Model","Observe that in the Adapter design in Figure 23.1, the 
 getTaxes 
 operation returns a 
 list of 
 TaxLineltems. 
 That is, on deeper reflection and investigation of how taxes are 
 handled and tax calculators work, the designer (me) realized that a list of tax line 
 items are associated with a sale, such as state tax, federal tax, and so forth (there is 
 always the chance governments will invent new taxes!).
  
 In addition to being a newly created software class in the Design Model, this is a 
 domain concept. It is normal and common to discover noteworthy domain concepts 
 and refined understanding of the requirements during design or program-ming—
 iterative development supports this kind of incremental discovery.
  
 Should this discovery be reflected in the Domain Model (or Glossary)? If the Domain 
 Model will be used in the future as a source of inspiration for later design work, or as a 
 visual learning aid to communicate the key domain concepts, then adding it could have 
 value. Figure 23.3 illustrates an updated Domain Model.
  
  
 ...
  
 ...
  
  
 Sale
  
 1
  
 Contains
  
 date
  
 time
  
 1
  
  
 ...
  
 ...
  
  
 Contains
  
 1..
 *
  
 1..
 *
  
 Sales 
  
 LineItem
  
 Tax 
  
 LineItem
  
 description 
  
 percentage 
  
 amount
  
 quantity
  
 Figure 23.3 Updated partial Domain Model.",NA
Maintain the Domain Model?,"To put a finer point on the above comment about updating the Domain Model: Note 
 that the architecture of the Design Model will usually be organized into layers (which 
 is discussed in greater detail in a subsequent chapter). One of these layers of design 
 classes will be called the 
 domain layer; 
 it will contain software classes whose names 
 and structure take inspiration from the domain vocabulary and concepts 
 (Sale, 
 TaxLineltem, 
 and so forth).
  
 345",NA
Factory (GoF),"The adapter raises a new problem in the design: In the prior Adapter pattern solution 
 for external services with varying interfaces, who creates the adapters? And how to 
 determine which class of adapter to create, such as 
 TaxMaster-Adapter 
 or 
 GoodAsGoldTaxProAdapterl
  
 If some domain object creates them, the responsibilities of the domain object are 
 going beyond pure application logic (such as sales total calculations) and into other 
 concerns related to connectivity with external software components.
  
 This point underscores another fundamental design principle (usually considered an 
 architectural design principle): Design to maintain a 
 separation of concerns. 
 That is, 
 modularize or separate distinct concerns into different areas, so that each has a 
 cohesive purpose. For example, the domain layer of software objects emphasizes 
 relatively pure application logic responsibilities, whereas a different group of objects is 
 responsible for the concern of connectivity to external systems.
  
 346",NA
23.4     Singleton (GoF),"The 
 ServicesFactory 
 raises another new problem in the design: who creates the 
 factory itself, and how is it accessed?
  
 First, observe that only one instance of the factory is needed within the process. 
 Second, quick reflection suggests that the methods of this factory may need to be 
 called from various places in the code, as different places need access to the 
 adapters for calling on the external services. Thus, there is a visibility problem: 
 how to get visibility to this single 
 ServicesFactory 
 instance?
  
 One solution is pass the 
 ServicesFactory 
 instance around as a parameter to 
 wherever a visibility need is discovered for it, or to initialize the objects that need 
 visibility to it, with a permanent reference. This is possible but inconve-nient; an 
 alternative is the 
 Singleton 
 pattern.
  
 Occasionally, it is desirable to support global visibility or a single access point to 
 a single instance of a class rather than some other form of visibility. This is true 
 for the 
 ServicesFactory 
 instance.
  
 348",NA
UML Shorthand for Singleton Access in Interaction Diagrams,"A UML notation that implies—but does not explicitly show—the 
 getlnstance 
 message in an interaction diagram is to add a « singleton»  stereotype to the 
 instance, as in Figure 23.6. This approach avoids having to explicitly show the 
 (uninteresting) 
 getlnstance 
 message to the class before sending a message to the 
 singleton instance.",NA
Implementation and Design Issues,"A Singleton 
 getlnstance 
 method is often frequently called. In multi-threaded 
 applications, the creation step of the 
 lazy initialization 
 logic is a critical section 
 requiring thread concurrency control. Thus, assuming the instance is lazy 
 initialized, it is common to wrap the method with concurrency control. In Java, 
 for example:
  
 public   static   synchronized  ServicesFactory getlnstance() { 
  
  
  
 if   (   instance  ==  null   ) { 
  
  
  
 //   critical   section  if multithreaded application 
  
  
 instance   =  new  ServicesFactory(); } 
  
  
 return  instance; }
  
 350",NA
I     Singleton (GoF),"The 
 ServicesFactory 
 raises another new problem in the design: who creates the factory 
 itself, and how is it accessed?
  
 First, observe that only one instance of the factory is needed within the process. 
 Second, quick reflection suggests that the methods of this factory may need to be 
 called from various places in the code, as different places need access to the adapters 
 for calling on the external services. Thus, there is a visibility problem: how to get 
 visibility to this single 
 ServicesFactory 
 instance?
  
 One solution is pass the 
 ServicesFactory 
 instance around as a parameter to wherever a 
 visibility need is discovered for it, or to initialize the objects that need visibility to it, 
 with a permanent reference. This is possible but inconvenient; an alternative is the 
 Singleton 
 pattern.
  
 Occasionally, it is desirable to support global visibility or a single access point to a 
 single instance of a class rather than some other form of visibility. This is true for the 
 ServicesFactory 
 instance.
  
 34R",NA
UML Shorthand for Singleton Access in Interaction Diagrams,"A UML notation that implies—but does not explicitly show—the 
 getlnstance 
  
 message in an interaction diagram is to add a « singleton»  stereotype to the 
  
 instance, as in Figure 23.6. This approach avoids having to explicitly show the 
  
 (uninteresting) 
 getlnstance 
 message to the class before sending a message to the 
  
 singleton instance.",NA
Implementation and Design Issues,"A Singleton 
 getlnstance 
 method is often frequently called. In multi-threaded 
  
 applications, the creation step of the 
 lazy initialization 
 logic is a critical sec-
  
 tion requiring thread concurrency control. Thus, assuming the instance is lazy 
  
 initialized, it is common to wrap the method with concurrency control. In Java, 
  
 for example:
  
 public   static   synchronized  ServicesFactory getlnstance() {
  
 if   (   instance  ==  null   ) 
  
 {
  
 //   critical   section  if  multithreaded  application 
  
 instance  =  new ServicesFactory(); }
  
 return  instance; }",NA
23.5     Conclusion of the External Services with ,NA,NA
Varying Interfaces Problem,"A combination of Adapter, Factory, and Singleton patterns have been used to 
 provide Protected Variations from the varying interfaces of external tax calcula-
 tors, accounting systems, and so forth. Figure 23.7 illustrates a larger context of 
 using these in the use-case realization.
  
 This design may not be ideal, and there is always room for improvement. But one 
 of the goals strived for in this case study is to illustrate that at least a design can 
 be constructed from a set of principles or pattern ""building blocks,"" and that there 
 is a methodical approach to doing and explaining a design. It is my sincere hope 
 that it is possible to see how the design in Figure 23.7 arose from reasoning based 
 on Controller, Creator, Protected Variations, Low Coupling, High Cohesion, 
 Indirection, Polymorphism, Adapter, Factory, and Singleton.
  
 Note how succinct a designer can be in conversation or documentation when there 
 is a shared understanding of patterns. I can say, ""To handle the problem of 
 varying interfaces for external services, let's use Adapters generated from a 
 Singleton Factory."" Object designers really do have conversations that sound like 
 this; using patterns and pattern names supports raising the level of abstraction in 
 design communication.
  
 352",NA
Strategy (GoF) ,"create()
  
 :Store
  
 create()
  
 :Register
  
 «singleton»
  
 :ServicesFactory
  
 IAccountingAdapter
  
  
 accountingAdapter :=
  
  getAccountingAdapter()
  
 [ instance == null ] 
 create()
  
 : SAPAccounting 
 Adapter
  
 :Register
  
 accountingAdapter: 
  
 SAPAccountingAdapter
  
 IAccountingAdapter
  
 makePayment()
  
 create(cashTendered)
  
 : Payment
  
 SOAP over 
  
 HTTP
  
 «system»: 
 SAP
  
 postSale( sale )
  
 xxx
  
 Figure 23.7 Adapter, Factory, and Singleton patterns applied to the design.",NA
23.6     Strategy (GoF),"The next design problem to be resolved is to provide more complex pricing logic, 
 such as a store-wide discount for the day, senior citizen discounts, and so forth.
  
 The pricing strategy (which may also be called a rule, policy, or algorithm) for a 
 sale can vary. During one period it may be 10% off all sales, later it may be $10 
 off if the sale total is greater than $200, and myriad other variations. How do we 
 design for these varying pricing algorithms?
  
 353",NA
Creating a Strategy with a Factory,"There are different pricing algorithms or strategies, and they change over time. Who 
 should create the strategy? A straightforward approach is to apply the Fac-tory pattern 
 again: a 
 PricingStrategyFactory 
 can be responsible for creating all strategies (all the 
 pluggable or changing algorithms or policies) needed by the application. As with the 
 SeruicesFactory, 
 it can read the name of the implemen-tation class of the pricing 
 strategy from a system property (or some external data source), and then make an 
 instance of it. With this partial 
 data-driven design 
 (or reflective design) one can 
 dynamically change at any time—while the NextGen POS application is running—the 
 pricing policy, by specifying a different class of Strategy to create.
  
 355",NA
*,"1
  
 «interface»
  
 ISalePricingStrategy
  
 getTotal() 
  
 ...
  
 pricingStrategy
  
 getTotal( Sale ) : Money
  
 getTotal() 
  
 { 
  
 ...
  
 return pricingStrategy.getTotal( this )
  
 PercentDiscount 
  
 PricingStrategy
  
 AbsoluteDiscount 
  
 OverThreshold 
  
 PricingStrategy
  
 percentage : float
  
 }
  
 discount : Money 
  
 threshold : Money
  
 getTotal( Sale ) : Money
  
 getTotal( Sale ) : Money
  
 Figure 23.10 Context object needs attribute visibility to its strategy.
  
 UML notation
 —Observe that in Figure 23.10 the reference via a directed associ-ation 
 is to the interface 
 ISalePricingStrategy, 
 not to a concrete class. This indi-cates that the 
 reference attribute in the 
 Sale 
 will be declared in terms of the interface, not a class, so 
 that any implementation of the interface can be bound to the attribute.
  
 Note that because of the frequently changing pricing policy (it could be every hour), 
 it is 
 not 
 desirable to cache the created strategy instance in a field of the 
 PricingStrategyFactory, 
 but rather to re-create one each time, by reading the external 
 property for its class name, and then instantiating the strategy.
  
 And as with most factories, the 
 PricingStrategyFactory 
 will be a singleton (one 
 instance) and accessed via the Singleton pattern (see Figure 23.11).",NA
Summary,"Protected Variations with respect to dynamically changing pricing policies has 
 been achieved with the Strategy and Factory patterns. Strategy builds on Poly-
 morphism and interfaces to allow pluggable algorithms in an object design.
  
 ted Patterns   
 Strategy is based on Polymorphism, and provides Protected Variations with 
  
 respect to changing algorithms. Strategies are often created by a Factory.",NA
Composite (GoF) and Other Design Principles,"To raise yet another interesting requirements and design problem: How do we 
 handle the case of multiple, conflicting pricing policies? For example, suppose a 
 store has the following policies in effect today (Monday):
  
 • 
  
 20% senior discount policy 
  
 • 
  
 preferred customer discount of 15% off sales over $400 
  
 • 
  
 on Monday, there is $50 off purchases over $500 
  
 • 
  
 buy 1 case of Darjeeling tea, get 15% discount off of everything 
  
 Suppose a senior who is also a preferred customer buys 1 case of Darjeeling tea, 
 and $600 of veggieburgers (clearly an enthusiastic vegetarian who loves chai). 
 What pricing policy should be applied?
  
 358",NA
*,"1
  
 «interface»
  
 ISalePricingStrategy
  
 1..
 *
  
 getTotal() 
 ...
  
 pricingStrategy
  
 getTotal( Sale ) : Money
  
 pricingStrategies
  
 PercentageDiscount 
 PricingStrategy
  
 AbsoluteDiscount 
 OverThreshold 
  
 PricingStrategy
  
 Composite 
  
 PricingStrategy
  
 percentage : float
  
 discount : Money 
 threshold : Money
  
 add( ISalePricingStrategy ) 
 getTotal( Sale ) : Money
  
 getTotal( Sale ) : Money
  
 getTotal( Sale ) : Money
  
  
 {
  
  return sale.getPreDiscountTotal() * 
 percentage 
  
 }
  
 CompositeBestForCustomer 
 PricingStrategy
  
 CompositeBestForStore 
 PricingStrategy
  
 getTotal( Sale ) : Money
  
 getTotal( Sale ) : Money
  
 { 
  
 lowestTotal = INTEGER.MAX 
  
 for each ISalePricingStrategy strat in pricingStrategies
  
  {
  
  total := strat.getTotal( sale )
  
  lowestTotal = min( total, lowestTotal )
  
  } 
  
 return lowestTotal 
  
 }
  
 Observe that in this design, the composite classes such as 
 CompositeBest-
 ForCustomerPricingStrategy 
 inherit an attribute 
 pricingStrategies 
 that contains",NA
Creating Multiple SalePricingStrategies,"With the Composite pattern, we have made a group of multiple (and conflicting) 
 pricing strategies look to the 
 Sale 
 object like a single pricing strategy. The com-
 posite object that contains the group also implements the 
 ISalePricingStrategy 
 interface. The more challenging (and interesting) part of this design problem is: 
 When do we create these strategies?
  
 A desirable design will start by creating a Composite that contains the present 
 moment's store discount policy (which could be set to 0% discount if none is 
 active), such as some 
 PercentageDiscountPricingStrategy. 
 Then, if at a later step 
 in the scenario, another pricing strategy is discovered to also apply (such as 
 senior discount), it will be easy to add it to the composite, using the inherited 
 CompositePricingStrategy.add 
 method.
  
 There are three points in the scenario where pricing strategies may be added to 
 the composite:
  
 1. Current store-defined discount, added when the sale is created. 
  
 2. Customer type discount, added when the customer type is communicated to the 
 POS. 
  
 3. Product type discount (if bought Darjeeling tea, 15% off the overall sale), 
 added when the product is entered to the sale. 
  
 363",NA
Observer Is Not Only for Connecting Uls and Model Objects,"The previous example illustrated connecting a non-UI object to a UI object with 
 Observer. However, other uses are common.
  
 The most prevalent use of this pattern is for GUI widget event handling, in both 
 Java technologies (AWT and Swing) and in Microsoft's .NET. Each widget is a 
 publisher of GUI-related events, and other objects can subscribe to interest in 
 these. For example, a Swing 
 JButton 
 publishes an ""action event"" when it is 
 pressed. Another object will register with the button so that when it is pressed, 
 the object is sent a message and can take some action.
  
 As another example, Figure 23.26 illustrates an 
 AlarmClock, 
 which is a pub-
 lisher of alarm events and various subscribers. This example is illustrative in that 
 it emphasizes that many classes can implement the 
 AlarmListener 
 inter-face, 
 many objects can simultaneously be registered listeners, and all can react to the 
 ""alarm event"" in their own unique way.
  
 377",NA
*,"«interface»Al
 armListener
  
 onAlarmEvent( source, time )
  
 AlarmWindow
  
 Beeper
  
 ReliabilityWatchDog
  
 onAlarmEvent( source, time ) 
 ...
  
 {
  
  check that all required processes 
 are executing normally 
  
 }
  
 onAlarmEvent( source, time ) 
 ...
  
 onAlarmEvent( source, time ) ...
  
 {
  
  display notification dialog 
 box 
  
 }
  
 {
  
  beep 
  
 }
  
 Figure 23.26 Observer applied to alarm events, with different subscribers.",NA
One Publisher Can Have Many Subscribers for an Event,"As suggested in Figure 23.26, one publisher instance could have from zero to many 
 registered subscribers. For example, one instance of an 
 AlarmClock 
 could have three 
 registered 
 AlarmWindows, 
 four 
 Beepers, 
 and one 
 ReliabilityWatchDog. 
 When an 
 alarm event happens, all eight of these 
 AlarmListeners 
 are notified via an 
 onAlarmEvent.
  
 378",NA
Implementation,NA,NA
Events,"In both the Java and C# .NET implementations of Observer, an ""event"" is com-
 municated via a regular message, such as 
 onPropertyEvent. 
 Moreover, in both 
 cases, the event is more formally defined as a class, and filled with appropriate 
 event data. The event is then passed as a parameter in the event message.
  
 For example:
  
 class PropertyEvent extends Event 
  
 {
  
  }
  
 private Object sourceOfEvent; 
 private String propertyName; 
 private Object oldValue; 
  
 private Object newValue; 
  
 //...
  
 //...
  
 class Sale 
  
 {
  
 private void publishPropertyEvent( 
  
   
 String name, Object old, Object new ) 
  
 { 
  
   
  
 PropertyEvent evt = new PropertyEvent( this, 
   
   
 ""sale.total"", old, new);
  
  }
  
 for each AlarmListener al in alarmListeners 
  
 al.onPropertyEvent( evt ); 
  
 //. . . 
  
  }",NA
Java,"When the JDK 1.0 was released in January 1996, it contained a weak publish-
 subscribe implementation based on a class and interface called 
 Observable 
 and 
 Observer, 
 respectively. This was essentially copied without improvement from 
 an early 1980s approach to publish-subscribe implemented in Smalltalk.
  
 Therefore, in late 1996, as part of the JDK 1.1 effort, the Observable-Observer 
 design was effectively replaced by the more robust Java Delegation Event Model 
 (DEM) version of publish-subscribe, although the original design was kept for 
 backward-compatibility (but in general to be avoided).
  
 The designs that have been described in this chapter are consistent with the DEM, 
 but slightly simplified to emphasize the core ideas.
  
 379",NA
Summary,"Observer provides a way to loosely couple objects in terms of communication. 
 Publishers know about subscribers only through an interface, and subscribers can 
 register (or de-register) dynamically with the publisher.
  
 Related Patterns 
 Observer is based on Polymorphism, and provides Protected Variations in terms 
 of protecting the publisher from knowing the specific class of object, and number 
 of objects, that it communicates with when the publisher generates an event.",NA
23.10   Conclusion,"The main lesson to draw from this exposition is that objects can be design and 
 responsibilities assigned with the support of patterns. These provide an explain-
 able set of idioms by which well-designed object-oriented systems can be built.",NA
23.11    Further Readings,"Design Patterns 
 by Gamma, Helm, Johnson, and Vlissides is the seminal pat-
 terns text, and essential reading for all object designers.
  
 Each year there is a ""Pattern Languages of Programs"" (PLOP) conference, from 
 which is published an annual compendium of patterns, in the series 
 Pattern 
 Languages of Program Design, 
 volumes 1, 2, and so forth. The entire series is 
 recommended.
  
 Pattern-Oriented Software Architecture, 
 volumes 1 and 2, furthered the discus-
 sion of patterns to larger-scale architectural concerns. Volume 1 presented a tax-
 onomy of patterns.
  
 There are hundreds of published patterns. 
 The Pattern Almanac 
 by Rising sum-
 marizes a respectable percentage of them.
  
 380",NA
PART ,NA,NA
5 ,NA,NA
ELABORATIO,NA,NA
N ITERATION ,NA,NA
3,NA,NA
Chapter 24,NA,NA
ITERATION ,NA,NA
3 ,NA,NA
AND ITS ,NA,NA
REQUIREMENTS,NA,NA
24.1      Iteration 3 Requirements,"• 
  
 • 
  
 • 
  
 • 
  
 Provide failover to local services when the remote  services  cannot be 
 accessed. For example, if the remote product database can't be accessed, use a 
 local version with cached data. 
  
 Provide support for POS device handling, such as the cash drawer and coin 
 dispenser. 
  
 Handle credit payment authorization. 
  
 Support for persistent objects.",NA
24.2     Iteration 3 Emphasis,"Inception and iteration 1 explored a variety of fundamental issues in require-
 ments analysis and OOA/D. Iteration 2 narrowly emphasized object design. This 
 third iteration takes a broader view again, exploring a wide variety of analysis 
 and design topics, including:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 relating use cases 
  
 generalization and specialization 
  
 state modeling 
  
 layered architectures 
  
 the design of packages 
  
 architectural analysis 
  
 more GoF design patterns 
  
 the design of frameworks—in particular, a persistence framework 
  
 383",NA
Chapter 25,NA,NA
RELATING USE CASES,NA,NA
Objectives,"•      Relate use cases with 
 include 
 and 
 extend 
 associations.",NA
Introduction,"Use cases can be related to each other. For example, a subfunction use case such 
 as 
 Handle Credit Payment 
 may be part of several regular use cases, such as 
 Pro-
 cess Sale 
 and 
 Process Rental. 
 Organizing use cases into relationships has no 
 impact on the behavior or requirements of the system. Rather, it is simply an 
 organization mechanism to (ideally) improve communication and comprehen-
 sion of the use cases, reduce duplication of text, and improve management of the 
 use case documents.",NA
A Caution,"In some organizations working with use cases, unproductive time has been spent 
 debating how to relate use cases in a use case diagram, rather than the important 
 use case work: writing text. Consequently, although this chapter dis-cusses 
 relating use cases, the subject and its effort should be put in perspective: It has 
 some value, but the important work is writing use case text. Specifying the 
 requirements is done by writing, not by organizing use cases, which is an 
 optional step to possibly improve their comprehension or reduce duplication. If a 
 team starts off use-case modeling by spending hours (or worse, days) discussing 
 a use case diagram and use case relationships (""Should that be an include or an 
 extend relationship? Should we specialize this use case?""), rather than quickly 
 focusing on writing the key use case text, relative effort was misplaced.
  
 385",NA
25.1     The include Relationship,"This is the most common and important relationship.
  
 It is common to have some partial behavior that is common across several use cases. 
 For example, the description of paying by credit occurs in several use cases, including 
 Process Sale, Process Rental, Contribute to Lay-away Plan, 
 and so forth. Rather than 
 duplicate this text, it is desirable to separate it into its own subfunction use case, and 
 indicate its inclusion. This is simply refactoring and linking text to avoid duplication.
 1
  
 For example: 
 UC1: 
  
 Process Sale
  
 Main Success Scenario: 
  
 1 . Customer arrives at a POS checkout with goods and/or services to 
 purchase. 7. Customer pays and System handles payment.
  
 Extensions: 
  
 7b. Paying by credit: Include 
 Handle Credit Payment. 7c. 
 Paying by check: 
 Include 
 Handle Check Pavment.
  
 UC7: Process Rental
  
 Extensions: 
  
 6b. Paying by credit: Include 
 Handle Credit Payment.
  
 UC12: Handle Credit Payment
  
 Level: Subfunction Main Success Scenario: 
  
 1. Customer enters their credit account information. 
  
 2. System sends payment authorization request to an external Payment Authorization 
 Service System, and requests payment approval.
  
 1. It is helpful if the links are implemented with navigable hyperlinks as well.
  
 386",NA
Using include with Asynchronous Event Handling,"Yet another use of the include relationship is to describe the handling of an 
 asynchronous event, such as when a user is able to, at any time, select or branch to a 
 particular window, function, or web page, or within a range of steps.
  
 In fact, the use case notation to support this asynchronous branching was already 
 explored in the introduction to use cases in Chapter 6, but at that time the addition of 
 calling out to an included sub-use case was not discussed.
  
 The basic notation is to use the 
 a*, b*, ... 
 style labels in the Extensions section. Recall 
 that these imply an extension or event that can happen at any time. A minor variation is 
 a range label, such as 
 3-9, 
 to be used when the asynchronous event can occur within a 
 relatively large range of the use case steps, but not all.
  
 387",NA
Summary,"The include relationship can be used for most use case relationship problems. To 
 summarize:
  
 Factor out subfunction use cases and use the 
 Include 
 relationship when: •      
 They are duplicated in other use cases.
  
 •     A use case is 
 very 
 complex and long, and separating it into subunits aids 
 comprehension.
  
 As will be explained, there are other relationships: extend and generalization. But 
 Cockburn, an expert use-case modeler, advises to prefer the include rela-tionship over 
 extend or generalization:
  
 As a first rule of thumb, always use the 
 include 
 relationship between 
 use cases. People who follow this rule report they and their readers 
 have less confusion with their writing than people who mix 
 include 
 with 
 extend and generalizes 
 [Cockburn0l].",NA
"25.2     Terminology: Concrete, Abstract, Base, and Addition Use ",NA,NA
Cases,"A concrete use case 
 is initiated by an actor and performs the entire behavior desired by 
 the actor [RUP]. These are the elementary business process use cases. For example, 
 Process Sale 
 is a concrete use case. By contrast, an 
 abstract use case 
 is never 
 instantiated by itself; it is a subfunction use case that is part of another use case. 
 Handle Credit Payment 
 is abstract; it doesn't stand on its own, but is always part of 
 another story, such as 
 Process Sale.
  
 A 
 use case that includes another use case, or that is extended or specialized by another 
 use case is called a 
 base use case. 
 Process Sale 
 is a base use case with
  
 388",NA
25.3     The extend Relationship,"Suppose a use case's text should not be modified (at least not significantly) for 
 some reason. Perhaps continually modifying the use case with myriad new 
 extensions and conditional steps is a maintenance headache, or the use case has 
 been baselined as a stable artifact, and can't be touched. How to append to the 
 use case without modifying its original text?
  
 The 
 extend 
 relationship provides an answer. The idea is to create an extending 
 or addition use case, and within it, describe where and under what condition it 
 extends the behavior of some base use case. For example:
  
 UC1: Process Sale (the base use case)
  
 Extension Points: 
 VIP Customer, 
 step 1 . 
 Payment, 
 step 7. Main Success 
 Scenario: 
  
 1 . Customer arrives at a POS checkout with goods and/or services to purchase. 
  
 …
  
 7. Customer pays and System handles payment.
  
 … 
  
 UC15: Handle Gift Certificate Payment (the extending use case)
  
 … 
  
 Trigger: Customer wants to pay with gift certificate. 
 Extension Points: Payment in Process Sale. Level: 
 Subfunction Main Success Scenario: 
  
 1 . Customer gives gift certificate to Cashier. 2. 
  
 Cashier enters gift certificate ID.
  
 … 
  
 This is an example of an 
 extend 
 relationship. Note the use of an 
 extension point, 
 and that the extending use case is triggered by some condition. Exten-sion points 
 are labels in the base use case which the extending use case refer-ences as the 
 point of extension, so that the step numbering of the base use case can change 
 without affecting the extending use case—indirection yet again.
  
 Sometimes, the extension point is simply ""At any point in use case X."" This is 
 especially common in systems with many asynchronous events, such as a word 
 processor (""do a spell check now,"" ""do a thesaurus lookup now""), or reactive con-
 trol systems. Note however, as described in the prior include relationship sec-
  
 389",NA
25.4     The generalize Relationship,"Discussion of the generalize relationship is outside the scope of this introduc-
 tion. However, note that use case experts have been successfully doing use case 
 work without this optional relationship, which adds another level of complexity 
 to use cases, and there is not yet agreement by practitioners on the best-practice 
 guidelines of how to get value from this idea. A common observation by use case 
 consultants is that complications result and unproductive time is spent on the 
 addition of many use case relationships.
  
 390",NA
25.5     Use Case Diagrams,"Figure 25.1 illustrates the UML notation for the include relationship, which is the 
 only one being used in the case study, following the advice of use-case experts to 
 keep things simple and prefer the include relationship.
  
 NextGen POS
  
 Process Sale
  
 Cashier
  
 «include»
  
 «include»
  
 «actor»
  
 Accounting 
  
 System
  
 «include»
  
 Customer
  
 Handle Check 
 Payment
  
 Handle Cash 
 Payment
  
 Handle Credit 
  
 Payment
  
 «actor»
  
 Credit 
  
 Authorization 
 Service
  
 «include»
  
 «include»
  
 «include»
  
 UML notation: 
  
 the base use 
  
 case points to 
  
 the included use 
  
 case
  
 Process Rental
  
 Handle Returns
  
 Manage Users
  
 ...
  
 Figure 25.1 Use case include relationship in the Use-Case Model. 
  
 The extend relationship notation is illustrated in Figure 25.2.
  
 Process Sale
  
 Extension Points: 
  
 Payment 
  
 VIP Customer
  
 «extend»
  
 Payment, if Customer 
  
 presents a gift certificate
  
 Handle Gift Certificate 
  
 Payment
  
 UML notation: 
  
 1. The extending use case 
 points to the base use case.
  
 2. The condition and 
  
 extension point can be 
  
 shown on the line.
  
 Figure 25.2 The extend relationship.
  
 391",NA
Chapter 26,NA,NA
MODELING GENERALIZATION,"Crude classifications and false generalizations 
  
  
 are the curse of the organized life.
  
 —
 A generalization by H.G. Wells",NA
Objectives,"•      Create generalization-specialization hierarchies. 
  
 •      Identify when showing a subclass is worthwhile. 
  
 •      Apply the ""100%"" and ""Is-a"" tests to validate subclasses.",NA
Introduction,"Generalization and specialization are fundamental concepts in domain model-ing 
 that support an economy of expression; further, conceptual class hierarchies are 
 often the basis of inspiration for software class hierarchies that exploit inheritance 
 and reduce duplication of code.",NA
26.1     New Concepts for the Domain Model,"As in iteration 1, the UP Domain Model may be incrementally developed by con-
 sidering the concepts in the requirements for this iteration. Techniques such as 
 the 
 Concept Category List 
 and noun phrase identification will help. An effective 
 approach to developing a robust and rich domain model is to study the work of 
 other authors on this subject, such as {Fowler96]. The myriad subtle modeling 
 issues they explore are beyond the scope of this book.
  
 393",NA
Concepts Category List ,"Table 26.1 shows some noteworthy concepts being considered in this iteration. 
  
 Table 26.1 Category Concepts List
  
 Category
  
 Examples
  
 physical or tangible objects
  
 CreditCard, Check
  
 specifications, designs or descriptions 
 of things
  
  
 places
  
  
 transactions
  
 CashPayment, CreditPayrnent, 
 CheckPayment
  
 transaction line items
  
  
 roles of people
  
  
 containers of other things
  
  
 things in a container
  
  
 other computer or electro-mechanical 
 systems external to our system
  
 CreditAuthorizationService, 
 CheckAuthorizationService
  
 abstract noun concepts
  
  
 organizations
  
 CreditAuthorizationService, 
 CheckAuthorizationService
  
 events
  
  
 rules and policies
  
  
 catalogs
  
  
 records of finance, work, contracts, 
 legal matters
  
 AccountsReceivable
  
 financial instruments and services
  
  
 manuals, books
  
  
 394",NA
Noun Phrase Identification from the Use Cases,"To reiterate, noun phrase identification cannot be mechanically applied to iden-tify 
 relevant concepts to include in the domain model. Judgement must be applied and 
 suitable abstractions developed, since natural language is ambigu-ous and relevant 
 concepts are not always explicit or clear in existing text. How-ever, it is a practical 
 technique in domain modeling since it is straightforward.
  
 This iteration handles the scenarios of the 
 Process Sale 
 use case for credit and check 
 payments. The following shows some noun phrase identification from these 
 extensions:",NA
Use Case UC1: Process Sale,"Extensions: 
  
 7b. Paying by credit: 
  
  
  1 . Customer enters their credit account information. 
  
  2. System sends payment authorization request to an external Payment Autho-
 rization Service System, and requests payment approval.
  
 2a. System detects failure to collaborate with external system:  
 1. System signals error to Cashier. 
  
  2. Cashier asks Customer for alternate payment.  
  
 3. System receives payment approval and signals approval to Cashier. 
  
 3a. System receives payment denial: 
  
  1. System signals denial to Cashier.  
  
 2. Cashier asks Customer for alternate payment. 
  
 4. System records the credit payment, which includes the payment approval. 5. 
 System presents credit payment signature input mechanism. 
  
 6. Cashier asks Customer for a credit payment signature. Customer enters signature. 
  
 7c. Paying by check: 
  
 1. The Customer writes a check, and gives it and their driver's license to the 
  
 Cashier. 
  
 2. Cashier writes the driver's license number on the check, enters it, and requests 
  
 check payment authorization. 
  
 3. Generates a check payment request and sends it to an external Check Autho-
 rization Service. 
  
 4. Receives a check payment approval and signals approval to Cashier. 
  
 5. System records the check payment, which includes the payment approval.",NA
Authorization Service Transactions,"The noun phrase identification reveals concepts such as 
 CreditPaymentRequest 
 and 
 CreditApprovalReply. 
 These may in fact be viewed as types of transactions with 
 external services, and in general, it is useful to identify such transactions because 
 activities and processes tend to revolve around them.
  
 395",NA
26.2     Generalization,"The concepts 
 CashPayment, CreditPayment, 
 and 
 Check Payment 
 are all very sim-ilar. 
 In this situation, it is possible (and useful
 1
 ) to organize them (as in F'igure 
 26.1) into a 
 generalization-specialization class hierarchy 
 (or simply 
 class 
 hierarchy) 
 in which 
 the 
 superclass 
 Payment 
 represents a more general con-cept, and the 
 subclasses 
 more 
 specialized ones.
  
 these are conceptual 
  
 classes, not software 
  
 classes
  
 Cash 
  
 Payment
  
 Payment
  
 Check 
  
 Payment
  
 superclass
  - more general 
 concept
  
 Credit 
  
 Payment
  
 subclass
  - more 
  
 specialized concept
  
 Figure 26.1 Generalization-specialization hierarchy.
  
 Note that the discussion of classes in this chapter refers to 
 conceptual 
 classes, not 
 software classes.
  
 Generalization 
 is the activity of identifying commonality among concepts and defining 
 superclass (general concept) and subclass (specialized concept) rela-tionships. It is a 
 way to construct taxonomic classifications among concepts which are then illustrated in 
 class hierarchies.
  
 Identifying a superclass and subclasses is of value in a domain model because their 
 presence allows us to understand concepts in more general, refined and abstract terms. 
 It leads to economy of expression, improved comprehension and a reduction in repeated 
 information. And although we are focusing now on the UP Domain Model and not the 
 software Design Model, the later design and implementation of super- and subclass as 
 software classes that use inheritance yields better software.
  
 1. Later in the chapter, we will investigate reasons to define class hierarchies.
  
 396",NA
26.3     Defining Conceptual Superclasses and Subclasses,"Since it is valuable to identify conceptual super- and subclasses, it is useful to 
 clearly and precisely understand generalization, superclasses, and subclasses in 
 terms of class definition and class sets.
 2
  This following sections explore these.",NA
Generalization and Conceptual Class Definition,"What is the relationship of a conceptual superclass to a subclass?
  
 A conceptual superclass definition is more general or encompassing than a 
 subclass definition.
  
 For example, consider the superclass 
 Payment 
 and its subclasses 
 (CashPayment, 
 and so on). Assume the definition 
 of Payment 
 is that it represents the transac-tion 
 of transferring money (not necessarily cash) for a purchase from one party
  
 2. That is, a class's intension and extension. This discussion was inspired by |MO95|.
  
 397",NA
Generalization and Class Sets,"Conceptual subclasses and superclasses are related in terms of set membership.
  
 All the members of a conceptual subclass set are 
 members of their superclass set.
  
 For example, in terms of set membership, all instances of the set 
 CreditPayment 
 are also members of the set 
 Payment. 
 In a Venn diagram, this is shown as in 
 Figure 26.4.
  
 Payment
  
 CashPayment
  
 CreditPayment
  
 CheckPayment
  
 Figure 26.4 Venn diagram of set relationships.
  
 398",NA
Conceptual Subclass Definition Conformance,"When a class hierarchy is created, statements about superclasses that apply to 
 subclasses are made. For example, Figure 26.5 states that all 
 Payments 
 have 
 an 
 amount 
 and are associated with a 
 Sale.
  
 Cash 
  
 Payment
  
 Payment
  
 Pays-for
  
 1
  
 Sale
  
 amount :  Money
  
 1
  
 Credit 
  
 Payment
  
 Check 
  
 Payment
  
 Figure 26.5 Subclass conformance.
  
 All 
 Payment 
 subclasses must conform to having an amount and paying for a 
 Sale. 
 In general, this rule of conformance to a superclass definition is the 
 100% 
  
 Rule:
  
 100% Rule 
  
 100% of the conceptual superclass's definition should be applicable to the 
 sub-class. The subclass must conform to 100% of the superclass's:
  
 •      attributes 
  
 •      associations",NA
Conceptual Subclass Set Conformance,"A conceptual subclass should be a member of the set of the superclass. Thus, 
 CreditPayment 
 should be a member of the set 
 of Payments.
  
 Informally, this expresses the notion that the conceptual subclass 
 is a kind of 
 superclass. 
 CreditPayment is a kind of Payment. 
 More tersely, 
 is-a-kind-of 
 is 
 called 
 is-a.
  
 399",NA
What Is a Correct Conceptual Subclass?,"From the above discussion, apply the following tests
 3
  to define a correct 
 subclass when constructing a domain model:
  
 A potential subclass should conform to the:  •      
 100% Rule (definition conformance)  •      Is-a 
 Rule (set membership conformance)",NA
26.4     When to Define a Conceptual Subclass,"Rules to ensure that a subclass is correct have been examined (the Is-a and 100% 
 rules). However, 
 when 
 should we even bother to define a subclass? First, a 
 definition: A 
 conceptual class partition 
 is a division of a conceptual class into 
 disjoint subclasses (or 
 types 
 in Odell's terminology) [MO95].
  
 The question may be restated as: 
  
 ""When is it useful to show a conceptual class partition?""
  
 For example, in the POS domain, 
 Customer 
 may be correctly partitioned (or sub-
 classed) into 
 MaleCustomer 
 and 
 FemaleCustomer. 
 But, is it relevant or useful to 
 show this in our model (see Figure 26.6)?
  
 3. These rule names have been chosen for their mnemonic support rather than precision.
  
 400",NA
Motivations to Partition a Conceptual Class into Subclasses,"The following are strong motivations to partition a class into subclass:
  
 Create a conceptual subclass of a superclass when: 
  
 1.   The subclass has additional attributes of interest. 
  
 2.   The subclass has additional associations of interest.
  
 3.   The subclass concept is operated on, handled, reacted to, or manipulated 
 differently than the superclass or other subclasses, in ways that are of 
 interest.
  
 4.    The subclass concept represents an animate thing (for example, animal, 
 robot) that behaves differently than the superclass or other subclasses, in 
 ways that are of interest.
  
 Based on the above criteria, it is not compelling to partition 
 Customer 
 into the 
  
 subclasses 
 MaleCustomer 
 and 
 FemaleCustomer 
 because they have no additional 
  
 attributes or associations, are not operated on (treated) differently, and do not 
  
 behave differently in ways that are of interest
 4
 .
  
 Table 26.2 shows some examples of class partitions from the domain of pay-
  
 ments and other areas, using these criteria.
  
 4. Men and women do exhibit different shopping habits. However, these are not 
  
 relevant to our current use case requirements—the criterion that bounds our 
  
 investigation.
  
 401",NA
26.5     When to Define a Conceptual Superclass,"Generalization into a common superclass is usually advised when commonality is 
 identified among potential subclasses. The following are motivations to gener-alize and 
 define a superclass:
  
 Create a conceptual superclass in a generalization relationship to subclasses 
 when:
  
 •      The potential conceptual subclasses represent variations of a similar 
 concept.
  
 •      The subclasses will conform to the 100% and Is-a rules.
  
 •      All subclasses have the same attribute which can be factored out and 
 expressed in the superclass.
  
 •      All subclasses have the same association which can be factored out and 
 related to the superclass.
  
 The following sections illustrate these points.",NA
26.6     NextGen POS Conceptual Class Hierarchies ,NA,NA
Payment Classes,"Based on the above criteria for partitioning the 
 Payment 
 class, it is useful to cre-ate a 
 class hierarchy of various kinds of payments. The justification for the superclass and 
 subclasses is shown in Figure 26.7.",NA
Authorization Service Classes,"Credit and check authorization services are variations on a similar concept, and have 
 common attributes of interest. This leads to the class hierarchy in Figure 26.8.
  
 403",NA
*,"Paid-with
  
 1
  
 1
  
 CreditCard
  
 Check
  
 Figure 26.7 Justifying Payment subclasses.
  
 superclass justified by 
 common attributes and 
 associations
  
 Authorizes-payments-of",NA
 * ,Store,NA
* ,"AuthorizationService
  
 address 
  
 name 
  
 additional associations 
 phoneNumber
  
  
 Credit 
  
   
 Check 
 Authorization Authorization Service 
  
 Service
  
   
 1 
  
    
 Authorizes",NA
* ,"Credit 
  
 Payment
  
   
 1 
  
    
 Authorizes",NA
* ,"Check 
  
 Payment
  
  
 Figure 26.8 Justifying the AuthorizationService hierarchy.",NA
Authorization Transaction Classes,"Modeling the various kinds of authorization service transactions (requests and 
  
 replies) presents an interesting case. In general, transactions with external ser-
  
 vices are useful to show in a domain model because activities and processes tend 
  
 to revolve around them. They are important concepts.
  
 Should the modeler illustrate 
 every 
 variation of an external service transaction? 
  
 It depends. As mentioned, domain models are not necessarily correct or wrong, 
  
 but rather more or less useful. They are useful, because each transaction class is 
  
 related to different concepts, processes, and business rules.
 5
  
 A second interesting question is the degree of generalization that is useful to 
  
 show in the model. For argument's sake, let us assume that every transaction 
  
 has a date and time. These common attributes, plus the desire to create an ulti-
  
 mate generalization for this family of related concepts, justifies the creation of 
  
 PaymentAuthorizationTransaction.
  
 But is it useful to generalize a reply into a 
 CreditPaymentAuthorizationReply 
  
 and 
 CheckPaymentAuthorizationReply, 
 as shown in Figure 26.9, or is it suffi-
  
 cient to show less generalization, as depicted in Figure 26.10?
  
 Payment
  
 Authorization
  
 Concepts too fine grained? 
 Transaction
  
 Useful to show this degree of
  
 partitioning? date
  
 time
  
 Payment 
  
 Payment
  
 Authorization 
  
 Authorization
  
 Reply 
  
 Request
  
 CreditPayment 
  
 CheckPayment 
  
 CreditPayment 
  
 CheckPayment
  
 Authorization 
  
 Authorization 
  
 Approval 
  
 Approval
  
 Reply 
  
 Reply 
 Request 
  
 Request
  
 Each transaction is
  
 handled differently, so
  
 CreditPayment 
  
 CreditPayment 
  
 CheckPayment 
  
 CheckPayment it is useful to partition
  
 Approval 
  
 Denial 
  
 Approval 
  
 Denial them into discrete
  
 Reply 
  
 Reply Reply 
  
 Reply 
  
 classes.
  
 Figure 26.9 One possible class hierarchy for external service transactions.
  
 5. In telecommunications domain models, it is similarly useful to identify each kind 
 of 
  
 exchange or switch message.
  
 405",NA
26.7     Abstract Conceptual Classes,"It is useful to identify abstract classes in the domain model because they con-strain 
 what classes it is possible to have concrete instances of, thus clarifying the rules of 
 the problem domain.
  
 If every member of a class C must also be a member of a subclass, then class 
 C is called an abstract conceptual class.
  
 For example, assume that every 
 Payment 
 instance must more specifically be an 
 instance of the subclass 
 CreditPayment, CashPayment, 
 or 
 CheckPayment. 
 This is 
 illustrated in the Venn diagram of Figure 26.11 (b). Since every 
 Payment 
 mem-ber is 
 also a member of a subclass, 
 Payment 
 is an abstract conceptual class by definition.
  
 By contrast, if there can be 
 Payment 
 instances that are not members of a sub-class, it 
 is not an abstract class, as illustrated in Figure 26.11 (a).
  
 406",NA
Abstract Class Notation in the UML,"To review, the UML provides a notation to indicate abstract classes—the class 
  
 name is italicized (see Figure 26.12).
  
 Payment
  
 abstract class 
  
 indicated by italics
  
 amount :  Money
  
 Cash 
  
 Payment
  
 Credit 
  
 Payment
  
 Check 
  
 Payment
  
 Figure 26.12 Abstract class notation.
  
 407",NA
26.8     Modeling Changing States,"Assume that a payment can either be in an unauthorized or authorized state, and it is 
 meaningful to show this in the domain model (it may not really be, but assume so for 
 the discussion). As shown in Figure 26.13, one modeling approach is 
  
 to 
  
 define 
  
 subclasses 
  
 of 
  
 Payment: 
  
 UnauthorizedPayment 
  
 and 
 AuthorizedPay-ment. 
 However, note that a payment does not stay in one of these 
 states; it typically transitions from unauthorized to authorized. This leads to the 
 following guideline:
  
 Do not model the states of a concept X as subclasses of X. Rather, either: 
 •      Define a state hierarchy and associate the states with X, or
  
 states in state diagrams instead.
  
 •      Ignore showing the states of a concept in the domain model; show the 
  
 not useful
  
 Payment
  
 these subclasses are 
  
 changing states of the 
  
 superclass
  
 Unauthorized 
 Payment
  
 Authorized 
  
 Payment
  
 Payment
  
 *
  
 Is-in
  
 1
  
 PaymentState
  
 better
  
 Unauthorized 
  
 State
  
 Authorized 
  
 State
  
 Figure 26.13 Modeling changing states.
  
 408",NA
26.9     Class Hierarchies and Inheritance in Software,"This discussion of conceptual class hierarchies has not mentioned 
 inheritance, 
 because the discussion is focused on a domain model of things in the world, not 
 software artifacts. In an object-oriented programming language, a software sub-class 
 inherits 
 the attribute and operation definitions of its superclasses by the creation 
 of 
 software class hierarchies. Inheritance 
 is a software mechanism to make 
 superclass things applicable to subclasses. It supports refactoring code from 
 subclasses and pushing it up class hierarchies. Therefore, inheritance has no real part 
 to play in the discussion of the domain model, although it most defi-nitely does when 
 we transition to the design and implementation view.
  
 The conceptual class hierarchies generated here may or may not be reflected in the 
 Design Model. For example, the hierarchy of authorization service transac-tion 
 classes may be collapsed or expanded into alternate software class hierar-chies, 
 depending on language features and other factors. For instance, C++ templatized 
 classes can sometimes reduce the number of classes.
  
 409",NA
Chapter 27,NA,NA
REFINING THE DOMAIN MODEL,"PRESENT, n. That part of eternity dividing the domain of 
  
 disappointment from the realm of hope.
  
 —
 Ambrose Bierce",NA
Objectives,"•      Add association classes to the Domain Model. 
  
 •      Add aggregation relationships. 
  
 •      Model the time intervals of applicable information. •      
 Choose how to model roles. 
  
 •      Organize the Domain Model into packages.",NA
Introduction,"This chapter explores additional useful ideas and notation available for domain 
 modeling and applies them to refine aspects of the NextGen POS Domain 
 Model.",NA
27.1     Association Classes,"The following domain requirements set the stage for association classes:
  
 • 
  
 • 
  
 Authorization services assign a merchant ID to each store for identification 
 during communications. 
  
 A payment authorization request from the store to an authorization service 
 needs the merchant ID that identifies the store to the service. 
  
 411",NA
*,"a better model, but not yet 
 as useful as possible",NA
*,"AuthorizationService
  
 Authorizes-payments-via
  
 1..
 *
  
 address 
  
 name 
  
 phoneNumber
  
 ServiceContract
  
 
 Sells
  
 1..
 *
  
 merchantID
  
 Figure 27.2 First attempt at modeling the merchantID problem.
  
 The above principle suggests that something like the model in Figure 27.2 is 
 more appropriate. In the business world, what concept formally records the
  
 412",NA
Guidelines,"Guidelines for adding association classes include the following:
  
 Clues that an association class might be useful in a domain model: 
  
 •      An attribute is related to an association.
  
 •      Instances of the association class have a life-time dependency on the 
  
 association.
  
 •      There is a many-to-many association between two concepts, and informa-
  
 tion associated with the association itself.
  
 413",NA
27.2     Aggregation and Composition ,"Aggregation 
 is a kind of association used to model whole-part relationships 
 between things. The whole is called the 
 composite.
  
 For instance, physical assemblies are organized in aggregation relationships, 
 such as a 
 Hand 
 aggregates 
 Fingers.",NA
Aggregation in the UML ,"Aggregation is shown in the UML with a hollow or filled diamond symbol at the 
 composite end of a whole-part association (see Figure 27.5).
  
 414",NA
Composite Aggregation,NA,NA
—,NA,NA
Filled Diamond,"Composite aggregation, or composition, 
 means that the part is a member of 
 only 
 one composite object, and that there is an existence and disposition depen-dency of the 
 part on the composite. For example, a hand is in a composition rela-tionship to a finger.
  
 In the Design Model, composition and its existence dependency implication indi-cates 
 that composite software objects create (or caused the creation of) the part software 
 objects (for example, 
 Sale 
 creates 
 SalesLineItem).
  
 But in the Domain Model, since it does not represent software objects, the notion of the 
 whole creating the part is seldom relevant (a real sale does not cre-ate a real sales line 
 item). However, there is still an analogy. For example, in a ""human body"" domain 
 model, one thinks of the hand as including the fingers, so if one says, ""A hand has come 
 into existence,"" we understand this to also mean that fingers have come into existence 
 as well.
  
 Composition is signified with a filled diamond. It implies that the composite solely 
 owns the part, and that they are in a tree structure parts hierarchy; it is the most 
 common form of aggregation shown in models.
  
 For example, a finger is a part of at most one hand (we hope!), thus the aggrega-tion 
 diamond is filled to indicate composite aggregation (see Figure 27.6).
  
 1. Recall that each end of an association is a role, and that a UML role has 
 various prop
 erties, such as 
 multiplicity, name, navigability 
 and 
 isAggregate.
  
 415",NA
Shared Aggregation,NA,NA
—,NA,NA
Hollow Diamond,"Shared aggregation 
 means that the multiplicity at the composite end may be 
 more than one, and is signified with a hollow diamond. It implies that the part 
 may be simultaneously in many composite instances. Shared aggregation sel-
 dom (if ever) exists in physical aggregates, but rather in nonphysical concepts.
  
 For instance, a UML package may be considered to aggregate its elements. But 
 an element may be referenced in more than one package (it is owned by one, and 
 referenced in others), which is an example of shared aggregation (see Figure 
 27.7).
  
 UMLPackage",NA
*,References,NA
*,"UMLElement
  
 shared aggregation
  
 Figure 27.7 Shared aggregation. 
  
 416",NA
How to Identify Aggregation,"In  some cases,  the presence of aggregation is  obvious—usually in physical 
 assemblies. But sometimes, it is not clear.
  
 On aggregation: If in doubt, leave it out.
  
 Here are some guidelines that suggest when to show aggregation:
  
 Consider showing aggregation when:
  
 •      The lifetime of the part is bound within the lifetime of the composite — 
  
 there is a create-delete dependency of the part on the whole.
  
 •      There is an obvious whole-part physical or logical assembly.
  
 •      Some properties of the composite propagate to the parts, such as the 
  
 location.
  
 •     Operations applied to the composite propagate to the parts, such as 
  
 destruction, movement, recording.
  
 Other than something being an obvious assembly of parts, the next most useful clue is 
 the presence of a create-delete dependency of the part on the whole.",NA
A Benefit of Showing Aggregation,"Identifying and illustrating aggregation is 
 not 
 profoundly important; it is quite feasible 
 to exclude it from a domain model. Most—if not all—experienced domain modelers 
 have seen unproductive time wasted debating the fine points of these associations.
  
 Discover and show aggregation because it has the following benefits, most of which 
 relate to the design rather than the analysis, which is why its exclusion from the domain 
 model is not very significant.
  
 •
  
 It clarifies the domain constraints regarding the eligible existence of the part 
 independent of the whole. In composite aggregation, the part may not exist outside 
 of the lifetime of the whole.
  
 ) During design work, this has an impact on the create-delete dependencies 
 between the whole and part software classes and database elements (in 
 terms of referential integrity and cascading delete paths).
  
 •
  
 It assists in the identification of a creator (the composite) using the GRASP 
 Creator pattern.
  
 417",NA
Aggregation in the POS Domain Model,"In the POS domain, the 
 SalesLineItems 
 may be considered a part of a composite 
 Sale; 
 in general, transaction line items are viewed as parts of an aggregate 
 transaction (see Figure 27.8). In addition to conformance to that pattern, there is a 
 create-delete dependency of the line items on the 
 Sale
 —their lifetime is bound 
 within the lifetime of the 
 Sale.
  
 By 
  
 similar justification, 
  
 Product-Specifications.
  
 ProductCatalog 
  
 is 
  
 an 
  
 aggregate 
  
 of 
  
 Sale
  
 1
  
 1..
 *
  
 SalesLineItem
  
 1..
 *
  
 Product 
  
 Specification
  
 Product 
  
 Catalog
  
 1
  
 Figure 27.8 Aggregation in the point-of-sale application.
  
 No other relationship is a compelling combination that suggests whole-part 
 semantics, a create-delete dependency, and ""If in doubt, leave it out.""",NA
27.3     Time Intervals and Product Prices—Fixing an Iteration 1 ,NA,NA
"""Error""","In 
  
 the 
  
 first 
  
 iteration, 
  
 SalesLineltems 
  
 were 
  
 associated 
  
 with 
 Product-Specifications, 
 that recorded the price of an item. This was a reasonable 
 simplification for early iterations, but needs to be amended. It raises the 
 interesting— and widely applicable—issue of 
 time intervals 
 associated with 
 information, contracts, and the like.
  
 If a 
 SalesLineItem 
 always retrieved the current price recorded in a 
 Product-
 Specification, 
 then when the price was changed in the object, old sales would 
 refer to new prices, which is incorrect. What is needed is a distinction between 
 the historical price when the sale was made, and the current price.
  
 Depending on the information requirements, there are at least two ways to model 
 this. One is to simply copy the product price into the 
 SalesLineltem, 
 and maintain 
 the current price in the 
 ProductSpecification.
  
 418",NA
27.5     Roles as Concepts vs. Roles in Associations,"In a domain model, a real-world role—especially a human role—may be modeled 
 in a number of ways, such as a discrete concept, or expressed as a role in an 
 association.
 2
  For example, the role of cashier and manager may be expressed in at 
 least the two ways illustrated in Figure 27.11.
  
 The first approach may be called ""roles in associations""; the second ""roles as con-
 cepts."" Both approaches have advantages.
  
 Roles in associations are appealing because they are a relatively accurate way to 
 express the notion that the same instance of a person takes on multiple (and 
 dynamically changing) roles in various associations. I, a person, simultaneously 
 or in sequence, may take on the role of writer, object designer, parent, and so on.
  
 On the other hand, roles as concepts provides ease and flexibility in adding 
 unique attributes, associations, and additional semantics. Furthermore, the 
 implementation of roles as separate classes is easier because of limitations of 
 current popular object-oriented programming languages—it is not convenient to 
 dynamically mutate an instance of one class into another, or dynamically add 
 behavior and attributes as the role of a person changes.
  
 2. For simplicity, other excellent solutions such as those discussed in |Fowler96| are 
  
 ignored.
  
 420",NA
27.6     Derived Elements,"A derived element can be determined from others. Attributes and associations are 
 the most common derived elements. When should derived elements be shown?
  
 Avoid showing derived elements in a diagram, since they add complexity 
 without new information. However, add a derived element when it is prom-
 inent in the terminology, and excluding it impairs comprehension.
  
 For example, a 
 Sale total 
 can be derived from 
 SalesLineItem 
 and 
 Product-
 Specification 
 information (see Figure 27.12). In the UML, it is shown with a ""/"" 
 preceding the element name.
  
 Sale
  
 date 
  
 /total 
  
 time
  
 derived attribute
  
 Figure 27.12 Derived attribute.
  
 421",NA
27.4     Association Role Names,"Each end of an association is a role, which has various properties, such as:
  
 • 
  
 name 
  
 • 
  
 multiplicity 
  
 A role name identifies an end of an association and ideally describes the role 
 played by objects in the association. Figure 27.10 shows role name examples.
  
 An explicit role name is not required—it is useful when the role of the object is 
 not clear. It usually starts with a lowercase letter. If not explicitly present, assume 
 that the default role name is equal to the related class name, though starting with 
 a lowercase letter.
  
 As covered previously during a discussion of mapping designs to code, roles 
 used in DCDs may be interpreted as the basis for attribute names during code 
 gener-ation.
  
 419",NA
27.7     Qualified Associations,"A qualifier 
 may be used in an association; it distinguishes the set of objects at the far 
 end of the association based on the qualifier value. An association with a 
 qualifier is a 
 qualified association.
  
 For example, 
 ProductSpecifications 
 may be distinguished in a 
 ProductCatalog 
 by their 
 itemID, 
 as illustrated in Figure 27.14 (b). As contrasted in Figure 27.14 (a) vs. (b), 
 qualification reduces the multiplicity at the far end from the qualifier, usually down 
 from many to one. Depicting a qualifier in a domain model com-municates how, in the 
 domain, things of one class are distinguished in relation to another class. They should 
 not, in the domain model, be used to express design decisions about lookup keys, 
 although that is suitable in other diagrams illustrating design decisions.
  
 Qualifiers do not usually add compelling useful new information, and we can fall into 
 the trap of ""design-think."" However, used judiciously, they can sharpen understanding 
 about the domain. The qualified associations between 
 Product-Catalog 
 and 
 ProductSpecification 
 provide a reasonable example of a value-added qualifier.
  
 (a)
  
 (b)
  
  
 Product 
  
 Catalog
  
 Contains
  
 Product 
  
 Specification
  
 1 
  
 1..
 *
  
  
 Product 
  
 Catalog
  
 itemID
  
 1
  
 Contains
  
 1
  
 Product 
  
 Specification
  
 qualifier
  
 multiplicity reduced to 1
  
 Figure 27.14 Qualified association.
  
 422",NA
27.8     Reflexive Associations,"A concept may have an association to itself; this is known as a 
 reflexive associ-
 ation
 3
 (see Figure 27.15).
  
 Person
  
 2 
  
 parent",NA
* ,"child
  
 Creates 
 
  
 Figure 27.15 Reflexive association.",NA
27.9     Ordered Elements,"If associated objects are ordered, this can be shown as in Figure 27.16. For example, 
 the 
 SalesLineItems 
 must be maintained in the order entered.
  
 ...
  
 Sale
  
 1
  
 1..
 * 
 {ordered}
  
 SalesLineItem
  
 there is some kind of 
 ordering, such as by 
 order added
  
 Figure 27.16 Ordered elements.",NA
27.10   Using Packages to Organize the Domain Model,"A domain model can easily grow large enough that it is desirable to factor it into 
 packages of strongly related concepts, as an aid to comprehension and parallel analysis 
 work in which different people do domain analysis within different sub-domains. The 
 following sections illustrate a package structure for the UP Domain Model.",NA
UML Package Notation,"To review, a UML package is shown as a tabbed folder (see Figure 27.17). Subor-
 dinate packages may be shown within it. The package name is within the tab if
  
 3.  [MO95] constrains the definition of reflexive associations further.
  
 423",NA
Ownership and References,"An element is 
 owned 
 by the package within which it is defined, but may be 
 refer-
 enced 
 in other packages. In that case, the element name is qualified by the pack-
 age name using the pathname format 
 PackageName::ElementName 
 (see Figure 
 27.18). A class shown in a foreign package may be modified with new associa-
 tions, but must otherwise remain unchanged.
  
 Core Elements
  
  
  
 Store
  
 1
  
 Has
  
 1..
 *
  
 Register
  
  
  
 Sales
  
  
 Core Elements:: 
  
 Register
  
 1
  
 Captures
  
 1
  
 Sale
  
  
  
 Figure 27.18 A referenced class in a package.",NA
Package Dependencies,"If a model element is in some way dependent on another, the dependency may be 
 shown with a dependency relationship, depicted with an arrowed line. A pack-age 
 dependency indicates that elements of the dependent package in some way know 
 about or are coupled to elements in the target package.
  
 For example, if a package references an element owned by another, a depen-dency 
 exists. Thus, the 
 Sales 
 package has a dependency on the 
 Core Elements 
 package (see 
 Figure 27.19).
  
 424",NA
POS Domain Model Packages,"Based on the above criteria, the package organization for the POS Domain Model is 
 shown in Figure 27.21.
  
 Domain
  
  
   
  
  
  
  
  
 Payments
  
  
  
  
  
 Products
  
  
  
  
  
 Sales
  
  
 Core/Misc
  
  
 Authorization 
 Transactions
  
   
 Figure 27.21 Domain concept packages.",NA
Core/Misc Package,"A 
 Core/Misc package (see Figure 27.22) is useful to own widely shared concepts or 
 those without an obvious home. In later references, the package name will be 
 abbreviated to 
 Core.
  
 There are no new concepts or associations particular to this iteration in this package.
  
 Core/Misc
  
  
  
 Store
  
 1
  
 Houses
  
 1..
 *
  
 Register
  
 Manager
  
 address 
 name
  
 Employs
  
 1..
 *
  
 1
  
  
 Figure 27.22 Core package.
  
 426",NA
Payments,"As in iteration 1, new associations are primarily motivated by a need-to-know criterion. 
 For example, there is a need to remember the relationship between 
 CreditPayment 
 and 
 CreditCard. 
 In contrast, some associations are added more for comprehension, such as 
 DriversLicense Identifies Customer 
 (see Figure 27.23).
  
 Note that 
 PaymentAuthorizationReply 
 is expressed as an association class. A reply 
 arises out of association between a payment and its authorization service.
  
 Payments
  
  
  
 CashPayment
  
 Payment
  
 *
  
 1
  
 
 Authorizes-payments-of
  
 1..
 *
  
 Core::Store
  
 ServiceContract
  
 AuthorizationService
  
 amount
  
 address 
  
 name 
  
 phoneNumber
  
 merchantID
  
 Credit 
  
 Payment
  
 Paid-by 
  
  
 1
  
 Check
  
 Check 
  
 Payment
  
 1
  
 *
  
 Authorized-by
  
 1
  
 Check 
  
 Authorization 
 Service
  
 Credit 
  
 Authorization 
 Service
  
 amountTendered
  
 *
  
 *
  
 *
  
 Authorized-by
  
 1
  
 Logs 
 
  
 1
  
 Establishes-
  
 credit-for 
 
  
 Establishes-
  
 identity-for 
 
  
 Authorization Transactions:: 
 PaymentAuthorizationReply
  
 1
  
 1
  
 Accounts 
  
 Receivable
  
 CreditCard
  
 DriversLicense
  
 - CheckPayments have 
 CheckPaymentReplies
  
 expiryDate 
  
 number
  
 number
  
 1 
  
 1
  
 Identifies
  
 1
  
 Abused-by
 
  
 1
  
 Sales::Customer
  
 - CreditPayments have 
 CreditPaymentReplies
  
  
 Figure 27.23 Payments package.",NA
Products,"With the exception of composite aggregation, there are no new concepts or asso-
 ciations particular to this iteration (see Figure 27.24).
  
 427",NA
*,"Product 
  
 Specification
  
 ProductCatalog
  
 1
  
 1..
 *
  
 description 
  
 price 
  
 itemID
  
 1
  
 Records-sale-of
 
  
 Describes
  
 Core:: 
  
 Store
  
 1
  
 Stocks",NA
*,NA,NA
*,"1
  
 Item
  
  
  
 Figure 27.24 Products package.",NA
Sales,"With the exception of composite aggregation and derived attributes, there are no new 
 concepts or associations particular to this iteration (see Figure 27.25).
  
  
 Sales
  
  
  
 Tax 
  
 LineItem
  
 1..
 *
  
 1
  
 Customer
  
 Captured-on
 
  
 1
  
 Core:: 
  
 Register
  
 1
  
 1 
  
 1
  
 Initiates
  
 Records-sales-on
 
  
 1
  
 Sale
  
 1
  
 SalesLineItem
  
 Cashier
  
 date 
  
 isComplete 
 time
  
 1
  
 1..
 *
  
 description 
 percentage 
 amount
  
 /quantity",NA
*,"
 Logs-completed
  
 Core:: 
  
 Store
  
 1
  
  
 Figure 27.25 Sales package.",NA
Authorization Transactions,"Although providing meaningful names for associations is recommended, in some 
 circumstances it may not be compelling, especially if the purpose of the associa-
 tion is considered obvious to the audience. A case in point is the associations 
 between payments and their transactions. Their names have been left unspeci-fied 
 because we can assume the audience reading the class diagram in Figure 27.26 
 will understand that the transactions are for the payment; adding the names 
 merely makes the diagram more busy.
  
 Authorization Transactions
  
  
  
 CreditPayment 
 Approval 
  
 Reply
  
 Receives
  
 *
  
 Sends
  
 1
  
 Core:: 
  
 Store
  
 1
  
 1
  
 Payments:: 
  
 Authorization 
 Service
  
 1
  
 Sends
  
 Receives
  
 CreditPayment 
 Denial 
  
 Reply
  
 *
  
 Payment
  
 *
  
 Payment
  
 Authorization
  
 Payment 
  
 Authorization
  
 *
  
 Transaction
  
 Authorization
  
 Reply
  
 date 
  
 time
  
 Request
  
 CheckPayment 
 Approval 
  
 Reply
  
 CreditPayment 
 Approval 
  
 Request
  
 CheckPayment 
 Approval 
  
 Request
  
 CheckPayment 
 Denial 
  
 Reply
  
 1
  
 1
  
 1
  
 1
  
 1
  
 1
  
 1
  
 1
  
 1
  
 1
  
 Payments:: 
  
 CheckPayment
  
 1
  
 Payments:: 
  
 CreditPayment
  
 1
  
  
 Figure 27.26 Authorization transaction package.
  
 Is this diagram too detailed, showing too many specializations? It depends. The 
 real criteria is usefulness. Although it is not incorrect, does it add any value in 
 improving understanding of the domain? The answer should influence how many 
 specializations to illustrate in a domain model.
  
 429",NA
Chapter 28,NA,NA
ADDING NEW ,NA,NA
SSDs ,NA,NA
AND ,NA,NA
CONTRACTS,"Virtue is insufficient temptation. 
  
 —
 George Bernard Shaw",NA
Objectives,•     Define SSDs and system operation contracts for the current iteration.,NA
28.1      New System Sequence Diagrams,"In the current iteration, the new payment handling requirements involve new 
 collaborations with external systems. To review, SSDs use sequence diagram 
 notation to illustrate inter-system collaborations, treating each system as a black-
 box. It is useful to illustrate the new system events in SSDs in order to clarify:
  
 • 
  
 • 
  
 new system operations that the NextGen POS system will need to support 
 calls to other systems, and the responses to expect from these calls",NA
Common Beginning of Process Sale Scenario,"The SSD for the beginning portion of a basic scenario includes 
 makeNewSale, 
 enterItem 
 and 
 endSale 
 system events; it is common regardless of the payment 
 method (see Figure 28.1).
  
 431",NA
Credit Payment,"This credit payment scenario SSD starts after the common beginning (see Fig-ure 
 28.2).
  
  
  
 :NextGenPOS 
 System
  
  
  
 «actor»
  
 :CreditAuthorization 
 Service
  
  
  
 «actor»
  
 :Accounts
  
  
 :Customer
  
 makeCreditPayment
  
 (credNum, expiryDate)
  
 reply := requestApproval( request )
  
 postReceivable( receivable )
  
 postSale( sale )
  
 Figure 28.2 Credit payment SSD.
  
 In both cases of credit and check payments, a simplifying assumption is made 
 (for this iteration) that the payment is exactly equal to the sale total, and thus a 
 different ""tendered"" amount does not have be an input parameter.
  
 432",NA
Check Payment,"The SSD for the check payment scenario is shown in Figure 28.3.
  
  
 :Cashier
  
  
 :NextGenPOS 
 System
  
  
  
 makeCheckPayment
  
  
  
 «actor»
  
 :CheckAuthorization 
 Service
  
  
  
  
 reply := requestApproval(request)
  
 Figure 28.3 Check payment SSD.
  
 According to the use case, the cashier must enter the driver's license number for 
  
 validation.",NA
28.2     New System Operations ,"In this iteration, the new system operations that our system must handle are:
  
 •  
 makeCreditPayment
  
 •  
 makeCheckPayment
  
 433",NA
28.3     New System Operation Contracts,"To review, system operation contracts are an optional requirements artifact (part of 
 the Use-Case Model) that adds fine detail regarding the results of a sys-tem operation. 
 Sometimes, the use case text is itself sufficient, and these con-tracts are not necessary. 
 But on occasion, they bring value by their precise and detailed approach to 
 identifying what happens when a complex operation is invoked on the system, in 
 terms of state changes to objects defined in the Domain Model.
  
 Here are contracts for the new system operations:
  
 Contract CO5: makeCreditPayment
  
 Operation: Cross 
  
 References: 
  
 Preconditions:
  
 Postconditions:
  
 makeCreditPayment( creditAccountNumber, expiryDate) 
 Use Cases: Process Sale 
  
 An underway sale exists and all items have been 
 entered.
  
 - a CreditPayment pmt was created 
  
 - pmt was associated with the current Sale sale 
  
 - a CreditCard cc was created; cc.number = 
  
  
 creditAccountNumber, cc.expiryDate = expiryDate 
  
 - cc was associated with pmt 
  
 - a CreditPaymentRequest cpr was created 
  
 - pmt was associated with cpr 
  
 - a ReceivableEntry re was created 
  
 - re was associated with the external AccountsReceivable 
 - sale was associated with the Store as a completed sale 
  
 Note the postcondition indicating the association of a new receivable entry in 
 accounts receivable. Although this responsibility is outside the bounds of the 
 NextGen system, the accounts receivable system is within the control of the 
 business, and so the statement has been added as a correctness check.
  
 For example, during testing, it is clear from this post-condition that the accounts 
 receivable system should be tested for the presence of a new receivable entry.
  
 434",NA
Chapter 29,NA,NA
MODELING BEHAVIOR IN ,NA,NA
STATECHART DIAGRAMS,"Usability is like oxygen
 —
 you never notice it until it is missing.
  
 —
 anonymous",NA
Objectives,Create statechart diagrams for classes and use cases.,NA
Introduction,"The UML includes statechart diagram notation to illustrate the events and states of 
 things—transactions, use cases, people, and so forth. The most impor-tant 
 notational features are shown, but there are others not covered in this introduction.
  
 The use of statechart diagrams is emphasized for showing system events in use 
 cases, but they may additionally be applied to any class.",NA
"29.1      Events, States, and Transitions","An 
 event 
 is a significant or noteworthy occurrence. For example: 
  
  
 A telephone receiver is taken off the hook.
  
  
 A state 
 is the condition of an object at a moment in time—the time 
 between events. For example:
  
 437",NA
29.2     Statechart Diagrams,"A UML statechart diagram, as shown in Figure 29.1, illustrates the interesting 
 events and states of an object, and the behavior of an object in reaction to an 
 event. Transitions are shown as arrows, labeled with their event. States are 
 shown in rounded rectangles. It is common to include an initial pseudo-state, 
 which automatically transitions to another state when the instance is created.
  
 Telephone
  
 initial state
  
 Idle
  
 off hook
  
 Active
  
 state
  
 on hook
  
 transition event
  
 Figure 29.1 Statechart diagram for a telephone.
  
 A statechart diagram shows the lifecycle of an object: what events it experi-
 ences, its transitions, and the states it is in between these events. It need not 
 illustrate every possible event; if an event arises that is not represented in the 
 diagram, the event is ignored as far as the statechart diagram is concerned. 
 Therefore, we can create a statechart diagram that describes the lifecycle of an 
 object at arbitrarily simple or complex levels of detail, depending on our needs.
  
 438",NA
Subject of a Statechart Diagram,"A statechart diagram may be applied to a variety of UML elements, including:
  
 • 
  
 • 
  
 classes (conceptual or software) 
 use cases 
  
 Since an entire ""system"" may be represented by a class, it too may have its own 
 statechart diagram.",NA
29.3     Statechart Diagrams in the UP?,"There is not one model in the UP called the ""state model."" Rather, any element 
 in any model (Design Model, Domain Model, and so forth) may have a 
 statechart to better understand or communicate its dynamic behavior in response 
 to events. For example, a statechart associated with the 
 Sale 
 design class of the 
 Design Model is itself part of the Design Model.",NA
29.4     Use Case Statechart Diagrams,"A useful application of statechart diagrams is to describe the legal sequence of 
 external system events that are recognized and handled by a system in the con-
 text of a use case. For example:
  
 > During the 
 Process Sale 
 use case in the NextGen POS application, it 
 is not legal to perform the 
 makeCreditPayment 
 operation until the 
 endSale 
 event has happened.
  
 > During the 
 Process Document 
 use case in a word processor, it is not 
 legal to perform the File-Save operation until the File-New or File-
 Open event has happened.
  
 A statechart diagram that depicts the overall system events and their sequence 
 within a use case is a kind of 
 use case statechart diagram. 
 The use case 
 statechart diagram in Figure 29.2 shows a simplified version of the system events 
 for the 
 Process Sale 
 use case in the POS application. It illustrates that it is not 
 legal to generate a 
 makePayment 
 event if an 
 endSale 
 event has not previ-ously 
 caused the system to transition to the 
 WaitingForPayment 
 state.
  
 439",NA
Utility of Use Case Statechart Diagrams,"The number of system events and their legal order for the 
 Process Sale 
 use case 
 are (so far) relatively trivial, thus the use of a statechart diagram to show legal 
 sequence may not seem compelling. But for a complex use case with myriad sys-
 tem events—such as when using a word processor—a statechart diagram that 
 illustrates the legal order of external events is helpful.
  
 Here's how: During design and implementation work, it is necessary to create 
 and implement a design that ensures no out-of-sequence events occur, otherwise 
 an error condition is possible. For example, the system should not be allowed to 
 receive a payment unless a sale is complete; code must be written to guarantee 
 that.
  
 Given a set of use case statechart diagrams, a designer can methodically develop 
 a design that ensures correct system event order. Possible design solutions 
 include:
  
  
  
  
  
 hard-coded conditional tests for out-of-order events 
  
 use of the 
 State 
 pattern (discussed in a subsequent chapter) 
  
 disabling widgets in active windows to disallow illegal events (a desirable 
 approach) 
  
 a state machine interpreter that runs a state table representing 
 a 
 use case 
 statechart diagram
  
 In a domain with many system events, the conciseness and thoroughness of use 
 case statechart diagrams help a designer ensure that nothing is missed.
  
 440",NA
29.5     Use Case Statechart Diagrams for the POS Application,NA,NA
Process Sale,"Process Sale 
  
 Process Sale
  
 WaitingForSale
  
 makeNewSale
  
 EnteringItems
  
 enterItem
  
 authorized
  
 makeCashPayment
  
 endSale
  
 WaitingForPayment
  
 makeCreditPayment
  
 AuthorizingPayment makeCheckPayment
  
 Figure 29.3 A sample statechart.",NA
29.6     Classes that Benefit from Statechart Diagrams,"In addition to statechart diagrams for use cases or the overall system, they may 
 be created for virtually any type or class.",NA
State-Independent and State-Dependent Objects,"If an object always responds the same way to an event, then it is considered 
 state-
 independent 
 (or modeless) with respect to that event. For example, if an object 
 receives a message, and the responding method always does the same thing—the 
 method will typically have no conditional logic. The object is state-independent 
 with respect to that message. If, for all events of interest, an object always reacts 
 the same way, it is a 
 state-independent object. 
 By contrast, 
 state-dependent 
 objects 
 react differently to events depending on their state.
  
 Create statecharts for state-dependent objects with complex behavior.
  
 441",NA
Common State-dependent Classes,"Following is a list of common objects which are usually state-dependent, and for 
 which it may be useful to create a statechart diagram:
  
 Use cases
  
 ο 
  
 Viewed as a class, the 
 Process Sale 
 use case reacts differently to the 
 endSale 
 event dependent of if a sale is underway or not.
  
 Stateful sessions
 —These are server-side software objects representing 
 ongoing sessions or conversations with a client; for example, EJB stateful 
 session objects.
  
 ο 
  
 ο 
  
 Another very common example is server-side handling of web client 
 application and presentation flow logic; for example, a Java technology 
 servlet helper or ""controller"" that remembers the state of the session 
 with a Web client, and controls the transitions to new web pages, or the 
 modified display of the current web page, based upon the state of the 
 session or conversation.
  
 A stateful session can usually be viewed as a software class repre-
 senting a use case. Recall that one of the GRASP Controller pattern 
 variants is a use case controller, which is a use case stateful session 
 object.
  
 Systems
 —This is a class representing the overall application or system.
  
 ο 
  
 The 
 ""POS system."" 
  
 Windows 
  
 ο 
  
 The Edit-Paste action is only valid if there is something in the 
 ""clipboard"" to paste.
  
 Controllers
 —These are GRASP controller objects.
  
 ο 
  
 The 
 Register 
 class, which handles the 
 enterltem 
 and 
 endSale 
 system 
 events.
  
 Transactions
 —These are ways a transaction (a sale, order, payment) reacts 
 to an event is often dependent on its current state within its overall lifecycle.
  
 ο 
  
 If a 
 Sale 
 received a 
 makeLineltem 
 message after the 
 endSale 
 event, it 
 should either raise an error condition or be ignored.
  
 442",NA
29.7     Illustrating External and Interval Events ,NA,NA
Event Types,"It is useful to categorize events as follows:
  
 External event
 —Also known as a system event, is caused by something (for 
 example, an actor) outside our system boundary. SSDs illustrate exter-nal events. 
 Noteworthy external events precipitate the invocation of system operations to 
 respond to them.
  
 ο 
  
 When a cashier presses the ""enter item"" button on a POS terminal, an 
 external event has occurred.
  
 Internal event
 —Caused by something inside our system boundary. In terms of 
 software, an internal event arises when a method is invoked via a message or signal 
 that was sent from another internal object. Messages in interaction diagrams suggest 
 internal events.
  
 ο 
  
 When 
 a Sale 
 receives a 
 makeLineltem 
 message, an internal event has 
 occurred.
  
 Temporal event
 —Caused by the occurrence of a specific date and time or passage 
 of time. In terms of software, a temporal event is driven by a real-time or simulated-
 time clock.
  
 ο 
  
 Suppose that after an 
 endSale 
 operation occurs, a 
 makePayment 
 operation 
 must occur within five minutes, otherwise the current sale is automatically 
 purged.",NA
Statechart Diagrams for Internal Events,"A 
 statechart diagram can show 
 internal 
 events that typically represent mes-sages 
 received from other objects. Since interaction diagrams also show mes-sages and their 
 reactions (in terms of other messages), why use a statechart diagram to illustrate 
 internal events and object design? The object design para-digm is that of objects that 
 collaborate via messages to fulfill tasks; the UML interaction diagrams directly 
 illustrates that paradigm. It is somewhat incon-gruous to use a statechart diagram to 
 show a design of object messaging and interaction.
 1
  
 443",NA
29.8     Additional Statechart Diagram Notation,"The UML notation for statechart diagrams contains a rich set of features that are 
 not exploited in this introduction. Three significant features are:
  
  
  
  
 transition actions transition 
 guard conditions nested states",NA
Transition Actions and Guards,"A transition can cause an action to fire. In a software implementation, this may 
 represent the invocation of a method of the class of the statechart diagram.
  
 A transition may also have a conditional guard—or boolean test. The 
  
 transition only occurs if the test passes.
  
 1. A reader of OOA/D literature will encounter periodical and textbook examples of 
 com- plex statechart diagrams that are devoted to 
 internal 
 events and the object's 
 reaction to them. Essentially, their creators have replaced the paradigm of object 
 interaction and collaboration via messages with the paradigm of objects as state 
 machines, and have used statechart diagrams to design the behavior of objects, rather 
 than using col- laboration diagrams. Abstractly, the two views are equivalent. 
  
 2. One reasonable use of statechart diagrams to show object design based on internal 
 events is when code is to be produced with a code generator that is driven by the 
 state- chart diagrams, or when a state machine interpreter will be used to run the 
 software system. 
  
 444",NA
Nested States,"A state allows nesting to contain substates; a substate inherits the transitions of its 
 superstate (the enclosing state). This is a key contribution of the Harel state-chart 
 diagram notation that UML is based on, as it leads to succinct statechart 
 diagrams. Substates may be graphically shown by nesting them in a superstate 
 box.
  
 Idle
  
 [valid subscriber]
  
 PlayingDialTone
  
 Active
  
 Talking
  
 digit
  
 digit
  
 connected
  
 Dialing
  
 complete
  
 Connecting
  
 Figure 29.5 Nested states.
  
 For example, when a transition to the 
 Active 
 state occurs, creation and transi-tion 
 into the 
 PlayingDialTone 
 substate occurs. No matter what substate the
  
 445",NA
29.9     Further Readings,"The application of state models to OOA/D is well-covered in 
 Designing Object 
 Systems 
 by Cook and Daniels. 
 Doing Hard Time 
 by Douglass also provides an 
 excellent discussion of state modeling; the content emphasizes real-time sys-tems, 
 but is broadly applicable.
  
 446",NA
Chapter 30,NA,NA
DESIGNING THE LOGICAL ,NA,NA
ARCHITECTURE WITH ,NA,NA
PATTERNS,NA,NA
Objectives,"Design a logical architecture in terms of layers and partitions with the 
 Layers pattern.
  
 Illustrate the logical architecture using UML package diagrams. 
  
 Apply the Facade, Observer and Controller patterns.",NA
Introduction,"First, to set the expectation level, this is an 
 introduction 
 to the topic of logical 
 architecture, a fairly large topic.
  
 The prior iterations emphasized a strongly related group of ""domain"" software 
 objects' in the Design Model (such as 
 Sale 
 and 
 Payment). 
 No attention was paid 
 to the user interface or access to resources such as a database. The motivation 
 was to keep things simple and focus on core object design skills.
  
 However, a typical system is composed of many logical packages, such as a user 
 interface package, a database access package, and so forth. Each package groups 
 a set of cohesive responsibilities (e.g., database access). This is the basic practice 
 of modularization to support a separation of concerns.
  
 This chapter briefly explores logical architectures, and communication and cou-
 pling between packages.
  
 447",NA
30.1     Software Architecture,"One definition of 
 software architecture is:
  
 An architecture is the set of significant decisions about the orga-
 nization of a software system, the selection of the structural ele-
 ments and their interfaces by which the system is composed, 
 together with their behavior as specified in the collaborations 
 among those elements, the composition of these structural and 
 behavioral elements into progressively larger subsystems, and the 
 architectural style that guides this organization---these ele-ments 
 and their interfaces, their collaborations, and their com-position. 
 [BRJ99]
  
 Regardless of the definition (and there are many) the common theme in all soft-
 ware architecture definitions is that it has to do with the large scale—the Big 
 Ideas in the forces, organization, styles, patterns, responsibilities, collabora-tions, 
 connections, and motivations of a system (or a system of systems), and major 
 subsystems.
  
 In software development, architecture is thought of as both a noun and a verb.
  
 As a noun, the architecture includes—as the prior definition indicates—the 
 organization and structure of the major elements of the system. Beyond this static 
 definition, it includes the system behavior, especially in terms of large scale 
 responsibilities of systems and subsystems, and their collaborations. In terms of a 
 description, the architecture includes the 
 motivations 
 or rationale for why the 
 system is designed the way it is.
  
 As a verb, architecture is part investigation and part design work; for clarity, the 
 term is best qualified, as in architectural investigation or architectural design.
  
 Architectural investigation 
 involves identifying those functional and (espe-
 cially) non-functional requirements that have (or should have) a significant 
 impact on the system design, such as market trends, performance, cost, main-
 tainability, and points of evolution. Broadly, it is requirements analysis with a 
 focus on those requirements that have special influence on the major system 
 design decisions.
  
 Architectural design 
 is the resolution of these forces and requirements in the 
 design of the software, the hardware and networking, operations, policies, and so 
 forth.
  
 In the UP, architectural investigation and design are together called 
 architec-
 tural analysis, 
 the process of which is briefly introduced in Chapter 32.
  
 448",NA
Architectural Dimensions and Views in the Unified Process,"The architecture of a system encompasses several dimensions. For example:
  
  
  
 The logical architecture, which describes the system in terms of its conceptual 
 organization in layers, packages, major frameworks, classes, interfaces, and 
 subsystems.
  
 The deployment architecture, which describes the system in terms of the 
 allocation of processes to processing units, and the network configuration.
  
 The Unified Process suggests six views of the architecture (logical, deployment, 
 and so on), all of which are defined in Chapter 32.
  
 This chapter focuses on a logical view of the architecture.",NA
Architectural Patterns and Pattern Categories,"There are well-known best practices in architectural design, especially regard-ing 
 large-scale logical architecture, and these have been written as patterns, such as 
 Layers. The first book dedicated to the subject of architectural patterns 
 was 
 Pattern-Oriented Software Architecture 
 (POSA) [BMRSS96].
  
 The POSA book also offered a simple, useful categorization of patterns at differ-
 ent levels:
  
 1. Architectural patterns
 —related to the large-scale and 
  
 coarse-grained 
  
 design, and typically applied during the early iterations (the elaboration 
 phase) when the major structures and connections are established.
  
 ο 
  
 The Layers patterns, which structures a system into major layers.
  
 2. Design patterns
 —related to the small and medium-scale design of objects 
  
 and frameworks. Applicable to designing a solution for connecting the large 
 scale  elements  defined via  architectural patterns,  and  during detailed 
  
 design work for any local design aspect. Also known as micro-architectural 
 patterns.
  
 ο 
 The Facade pattern, which can be used to provide the interface 
  
 from one layer to the next.
  
 ο 
 The Strategy pattern, to allow pluggable algorithms.
  
 3. Idioms
 —language or implementation-oriented low-level design solutions.
  
 ο 
 The Singleton pattern, to ensure global access to a single instance of 
 a class.
  
 449",NA
30.2     Architectural Pattern: Layers,"Solution   
 The essential ideas of the Layers pattern [BMRSS96] are simple:
  
 Organize the large-scale logical structure of a system into discrete layers of 
 distinct, related responsibilities, with a clean, cohesive separation of con-
 cerns such that the ""lower"" layers are low-level and general services, and the 
 higher layers are more application specific.
  
 Collaboration and coupling is from higher to lower layers; lower-to-higher 
 layer coupling is avoided.
  
 A layer is a large-scale element, often composed of several packages or sub-
 systems.
  
 The Layers pattern relates to the logical architecture; that is, it describes the 
 conceptual organization of the design elements into groups, independent of their 
 physical packaging or deployment.
  
 Layers defines a general N-tier model for the logical architecture; it produces a 
 layered architecture. 
 It has been applied and written about so often as a pat-tern 
 that the 
 Pattern Almanac 2000 
 [Rising00] lists over 100 patterns that are variants 
 of or related to the Layers pattern.
  
 Problems
  
 Source code changes are rippling throughout the system—many parts of the 
 systems are highly coupled. 
  
 Application logic is intertwined with the user interface, and so can not be 
 reused with a different interface, nor distributed to another processing node.
  
 Potentially general technical services or business logic is intertwined with 
 more application-specific logic, and so can not be reused, distributed to 
 another node, or easily replaced with a different implementation.
  
 450",NA
Inter-Layer and Inter-Package Coupling,"It is also informative to include a diagram in the logical view that illustrates 
 noteworthy coupling between the layers and packages. A partial example is 
 illustrated in Figure 30.3.
  
 453",NA
Inter-Layer and Inter-Package Interaction Scenarios,"Package diagrams show static information. To understand the dynamics of how 
 objects across the layers connect and communicate, an interaction diagram is 
 informative. In the spirit of an ""architectural view"" which hides uninteresting 
 details, and emphasizes what the architect wants to convey, an interaction dia-
  
 455",NA
Relaxed Layered Coupling,"The layers in most layered architectures are 
 not 
 coupled in the same limited sense as a 
 network protocol based on the OSI 7-Layer Model. In the protocol model, there is 
 strict restriction that elements of layer N only access the services of the immediate 
 lower layer N-l.
  
 This is rarely followed in information system architectures. Rather, the stan-dard is a 
 ""relaxed layered"" or ""transparent layered"" architecture IBMRSS96], in which elements 
 of a layer collaborate with or are coupled to several other layers.
  
 Comments on typical coupling between layers:
  
 All higher layers have dependencies on the Technical Services and Founda tions 
 layer.
  
 ο 
  
 For example, in Java all layers depend 
 onjava.util 
 package 
 elements.
  
 It is primarily the Domain layer that has dependency on the Business Infra 
 structure layer.",NA
External Resources or External Database Layer at the Bottom?,"Most systems rely on external resources or services, such as an Oracle database 
 and a Novell LDAP naming and directory service. These are 
 physical 
 implemen-
 tation components, not a layer in the 
 logical 
 view of the architecture.
  
 Showing external resources such as a particular database in a layer ""below"" the 
 Foundation layer (for example) mixes up the logical view and the deployment or 
 implementation views of the architecture.
  
 Rather, in terms of the logical view of the architecture and its layers, access to a 
 particular set of persistent data (such as inventory data) can be viewed as a sub-
 domain of the Domain Layer—the Inventory subdomain. And the general 
 services that provide access to databases may be viewed as a Technical Service 
 partition—the Persistence service. See Figure 30.12.
  
 463",NA
Fuzzy Set Membership in Different Layers,"Some elements are strongly a member of one layer; a 
 Math 
 class is part of the 
 Foundation layer. However, especially between the Technical Services and Foun-
 dation layers, and Domain and Business Infrastructure, some elements are harder 
 to classify, because the differentiation between these layers is, roughly, ""high"" 
 versus ""low,"" or ""specific"" versus ""general."" which are fuzzy set terms. This is 
 normal, and it is seldom necessary to decide upon a definitive categoriza-tion—the 
 development team may consider an element roughly part of the Tech-nical 
 Services and/or Foundations layer considered as a group, broadly called the 
 Infrastructure layer.
 2
  
 For example:
  
 Suppose this is a Java technologies project, and the open source logging 
 framework 
 Log4J 
 (part of the Jakarta project) has been chosen. Is 
 logging part of the Technical Service or Foundation layer? Log4J is a 
 low-level, small, general framework. It is moderately a member of both 
 the Technical Services and the Foundations fuzzy sets.
  
 2. Note that there are not well-established naming conventions for layers, and name 
 overloading and contradiction in the architecture literature is common.
  
 465",NA
30.3     The Model-View Separation Principle,"This principle has been discussed several times; this section summarizes it. 
  
 What kind of visibility should other packages have to the Presentation layer?
  
 471",NA
"Model-View Separation and ""Upward"" Communication","How can windows obtain information to display? Usually, it is sufficient for 
 them to send messages to domain objects, querying for information which they 
 then display in widgets—a 
 polling or pull-from-above 
 model of display 
 updates.
  
 Presentation
  
 ProcessSale 
  
 Frame
  
 UIFacade
  
 Sale
  
 Not a Swing or GUI class.
  
 Just a plain object which 
  
 adds a level of indirection to 
 the GUI objects
  
 Domain
  
 UIFacades are 
  
 occasionally used when a 
 push-from-below 
  
 communication model is 
 required.
  
 Register
  
 Figure 30.16 A Presentation layer UIFacade is occasionally used for push-from-
 below designs.
  
 However, a polling model is sometimes insufficient. For example, polling every 
 second across thousands of objects to discover only one or two changes, which 
 are then used to refresh a GUI display, is not efficient. In this case it is more effi-
 cient for the few changing domain objects to communicate with windows to cause 
 a display update as the state of domain objects changes. Typical situations of this 
 case include:
  
 Monitoring applications, such as telecommunications network management.
  
 Simulation applications which require visualization, such as aerodynamics 
 modeling.
  
 In these situations, a 
 push-from-below 
 model of display update is required. 
 Because of the restriction of the Model-View Separation pattern, this leads to the 
 need for ""indirect"" communication from lower objects up to windows—push-ing 
 up notification to update from below.
  
 There are two common solutions:
  
 1. The Observer pattern, via making the GUI object simply appear as an object 
  
 that implements an interface such as 
 PropertyListener.
  
 2. A Presentation facade object. That is, adding a facade within the Presenta tion 
 layer that receives requests from below. This is an example of adding 
 Indirection to provide Protected Variation if the GUI changes. For example, 
 see Figure 30.16. 
  
 473",NA
30.4     Further Readings,"There's a wealth of literature on layered architectures, both in print and on the 
 Web. A series of patterns in 
 Pattern Languages of Program Design, 
 volume 1, 
 [CS95] first address the topic in pattern form, although layered architectures have 
 been used and written about since at least the 1960s; volume 2 continues with 
 further layers-related patterns. 
 Pattern-Oriented Software Architecture 
 vol-ume 1 
 [BMRSS96] provides a good treatment of the Layers pattern.
  
 474",NA
Chapter 31,NA,NA
ORGANIZING THE,NA,NA
DESIGN AND IMPLEMENTATION,NA,NA
MODEL PACKAGES,"If you were plowing a field, which would you 
  
 rather use? Two strong oxen or 1024 chickens?
  
 —
 Seymour Cray",NA
Objectives,"Organize packages to reduce the impact of changes. 
  
 Know alternative UML package structure notation.",NA
Introduction,"If some package X is widely depended upon by the development team, it is unde-
 sirable for X to be very unstable (going through many new versions), since it 
 increases the impact on the team in terms of constant version re-synchroniza-tion and 
 fixing dependent software that breaks in response to changes in X 
 (ver-
 sion 
 thrashing).
  
 This sounds and is obvious, but sometimes a team does not pay attention to 
 identifying and stabilizing the most depended-upon packages, and ends up expe-
 riencing more version thrashing than necessary.
  
 This chapter builds on the previous chapter's introduction to layers and pack-ages, by 
 suggesting more fine-grained heuristics for the organization of pack-ages, to reduce 
 these kinds of change impact. The goal is to create a robust physical package design.
  
 475",NA
Source Code Physical Design in the Implementation Model,"This issue is an aspect of 
 physical design
 -the UP Implementation Model for 
 source code packaging.
  
 While simply diagramming a package design on a whiteboard or CASE tool, we can 
 arbitrarily place types in any functionally cohesive package without impact. But 
 during source code physical design—the organization of types into physical units of 
 release as Java or C++ ""packages""—our choices will influence the degree of 
 developer impact when changes in those packages occur, if there are many 
 developers sharing a common code base.",NA
31.1      Package Organization Guidelines,NA,NA
Guideline: Package Functionally Cohesive Vertical and Horizontal ,NA,NA
Slices,"The basic ""intuitive"" principle is modularization based on functional cohesion— 
 types are grouped together that are strongly related in terms of their participa-tion in 
 a common purpose, service, collaborations, policy, and function. For example, all the 
 types in the NextGen 
 Pricing 
 package are related to product pricing. The layers and 
 packages in the NextGen design are organized by func-tional groups.
  
 In addition to the usually sufficient informal guesswork on grouping by function (""I 
 think class 
 SalesLineltem 
 belongs in 
 Sales"") 
 another clue to functional group-ing is a 
 cluster of types with strong internal coupling and weaker extra-cluster coupling. For 
 example, 
 Register 
 has a strong coupling to 
 Sale, 
 which has a strong coupling to 
 SalesLineltem.
  
 1. In C++ the packages may be realized as namespaces, but more likely it means the 
 organization of the source code into separate physical directories—one for each 
 ""package.""
  
 476",NA
Guideline: Package a Family of Interfaces,"Place a family of functionally related 
 interfaces 
 in a separate package—separate 
 from implementation classes. This is not primarily for the case of one or two 
 related interfaces, but rather when there is a family of perhaps three or more 
 interfaces. The Java technologies EJB package 
 javax.ejb 
 is an example: It is a 
 package of at least twelve interfaces; implementations are in separate packages.",NA
Guideline: Package by Work and by Clusters of Unstable Classes,"The context for this discussion is that packages are usually the basic unit of 
 development work and of release. It is less common to work on and release just 
 one class.
  
 Suppose 1) there is an existing large package P1 with thirty classes, and 2) there 
 is a work trend that a particular subset often classes (Cl through C10) is regularly 
 modified and re-released.
  
 In this case, refactor P1 into Pl-a and Pl-b, where Pl-b contains the ten fre-
 quently worked on classes.
  
 Thus, the package has been refactored into more stable and less stable subsets, or 
 more generally, into groups related to work. That is, if most types in a pack-age 
 are worked on together, then it is a useful grouping.
  
 477",NA
Guideline: Most Responsible Are Most Stable,"If the most responsible (depended-on) packages are unstable, there is a greater 
 chance of widespread change dependency impact. As an extreme case, if a widely 
 used utility package such as 
 com.foo.util 
 changed frequently, many things could 
 break. Therefore, Figure 31.1 illustrates an appropriate depen-dency structure.
  
 com.foo.nextgen. 
  
 ui.swing
  
 Less Stable:
  
 -more dependent
  
 -concrete, detailed
  
 com.foo.nextgen.
  
 domain.sales
  
 com.foo.nextgen.
  
 domain.payments
  
 com.foo.util
  
 com.foo.nextgen.
  
 domain.posruleengine
  
 More Stable:
  
 -less dependent
  
 -concrete, detailed code is stabilized 
 due to refinement or mandate.
  
 -abstract classes &
  
  
  interfaces & facades
  
 The more depended-on packages should be the most stable, 
  
 because when they do change, they could have the largest
  
 impact
  
 Figure 31.1 More responsible packages should be more stable.
  
 Visually, the lower packages in this diagram should be the most stable. There are 
 different ways to increase stability in a package:",NA
Guideline: Factor out Independent Types,"Organize types that can be used independently or in different contexts into sep-
 arate packages. Without careful consideration, grouping by common functional-
 ity may not provide the right level of granularity in the factoring of packages.
  
 For example, suppose that a subsystem for persistence services has been defined 
 in one package 
 com.foo.seruice.persistence. 
 In this package are two very general 
 utility/helper classes 
 JDBCUtililities 
 and 
 SQLCommand. 
 If these are general 
 utilities for working with JDBC (Java's services for relational database access), 
 then they can be used independently of the persistence subsystem, for any occa-
 sion when the developer is using JDBC. Therefore, it is better to migrate these 
 types into a separate package, such as 
 com.foo.util.jdbc. 
 Figure 31.2 illustrates.
  
 worse 
  
 com.foo.service.persistence
  
 DBFacade
  
  
 better 
  
 com.foo.service.persistence
  
 DBFacade
  
 Schema 
  
 Mapping
  
 ...
  
 Schema 
  
 Mapping
  
 ...
  
 com.foo.util.jdbc
  
 JDBCUtilties
  
 SQLCommand
  
 JDBCUtilties
  
 SQLCommand
  
 Figure 31.2 Factoring out independent types.
  
 479",NA
Guideline: Use Factories to Reduce Dependency on Concrete ,NA,NA
Packages,"One way to increase package stability is to reduce its dependency on concrete 
 classes in other packages. Figure 31.3 illustrates the ""before"" situation.
  
 Sales 
  
 Payments
  
 Register 
  
 CreditPayment
  
 Persistence
  
  // in some methods of Register and PaymentMapper 
 CreditPayment pmt = new CreditPayment();
  
 Payment 
  
 Mapper
  
 Figure 31.3 Direct coupling to concrete package due to creation.
  
 Suppose that both 
 Register 
 and 
 PaymentMapper 
 (a class that maps payment 
 objects to/from a relational database) create instances of 
 CreditPayment 
 from 
 package 
 Payments. 
 One mechanism to increase the long-term stability of the 
 Sales 
 and 
 Persistence 
 packages is to stop explicitly creating concrete classes 
 defined in other packages 
 (CreditPayment 
 in 
 Payments).
  
 We can reduce the coupling to this concrete package by using a factory object 
 that creates the instances, but whose create methods return objects declared in 
 terms of interfaces rather than classes. See Figure 31.4.
  
 Domain Object Factory Pattern
  
 The use of domain object factories with interfaces for the creation of 
 all 
 domain 
 objects is a common design idiom. I have seen it mentioned informally in design 
 literature as the Domain Object Factory pattern, but do not know of a reference 
 to it formally written as a pattern.",NA
Guideline: No Cycles in Packages,"If a group of packages have cyclic dependency then they may need to be treated 
 as one larger package in terms of a release unit. This is undesirable because 
 releasing larger packages (or package aggregates) increases the likelihood of 
 affecting something.
  
 480",NA
31.2     More UML Package Notation,"Finally, while on the subject of packages, the UML provides alternate notation to 
 illustrate outer and inner packages. Sometimes it is awkward to draw an outer 
 package box around inner packages. Alternatives are shown in Figure 31.6.
  
 Presentatio 
  
 n
  
 Presentation:: 
 Swing
  
 Presentation:: 
  
 Text
  
 Swing
  
 Text
  
 Domain
  
 Log4J
  
 Domain:: 
  
 Sales
  
 Sales
  
 Domain:: 
  
 POSRuleEngine
  
 POSRuleEngine
  
 Technical Services:: 
  
 Jess
  
 Jess
  
 Technical 
  
 Services
  
 Figure 31.6 Alternate UML approaches to showing packages structure, using 
 UML path names, or the circle-cross symbol.
  
 482",NA
31.3     Further Readings,"Most of the detailed work—not surprisingly—on improving package design to 
 reduce dependency impact comes from the C++ community, although the princi-
 ples apply to other languages. Martin's 
 Designing Object-Oriented 
 C++ 
 Applica-
 tions Using the Booch Method 
 [Martin95] provides good coverage, as does 
 Large-
 Scale 
 C++ 
 Software Design 
 [Lakos96]. The subject is also introduced in 
 Java 2 
 Performance and Idiom Guide 
 [GL99].
  
 483",NA
Chapter 32,NA,NA
INTRODUCTION,NA,NA
TO ARCHITECTURAL ANALYSIS,NA,NA
AND THE SAD,"Error, no keyboard - press F1 to continue, 
  
 —early PC BIOS message",NA
Objectives,"Create architectural factor tables.
  
 Create technical memos that record architectural decisions. 
 Know basic principles of architectural design.
  
 Know resources for learning architectural patterns.",NA
Introduction,"The essence of architectural analysis is to identify factors which should influ-ence 
 the architecture, understand their variability and priority, and resolve them. The 
 difficult part is knowing what questions to ask, weighing the trade-offs, and 
 knowing the many ways to resolve an architecturally significant factor, ranging 
 from benign neglect, to fancy designs, to third-party products.
  
 In the UP, the architectural factors are recorded in the Supplementary Specifi-
 cation, and the architectural decisions that resolve them are recorded in the 
 Software Architecture Document 
 (SAD, described in more detail near the end of 
 this chapter).
  
 Architectural analysis starts early, during the inception phase, and is a focus of the 
 elaboration phase; it is a high-priority and very influential activity in soft-
  
 485",NA
32.1     Architectural Analysis,"Architectural analysis 
 is concerned with the identification and resolution of the 
 system's non-functional (for example, quality) requirements, in the context of the 
 functional requirements.
  
 In the UP, the term encompasses both architectural investigation (identifica-tion) 
 and architectural design (resolution). Here are some examples of the many issues 
 to be identified and resolved at an architectural level:
  
 How do reliability and fault-tolerance requirements affect the design?
  
 ο 
  
 For example, in the NextGen POS, for what remote services (e.g., 
 tax calculator) will fail-over to local services be allowed? Why? Do 
 they provide exactly the same services locally as remotely, or are 
 there differences?
  
 How do the licensing costs of purchased subcomponents affect 
  
 profitability?
  
 ο 
  
 For example, the producer of the excellent database server, 
 Clue-
 less, 
 wants 2% of each NextGen POS sale, if their product is used as 
 a subcomponent. Using their product will speed development (and 
 time to market) because it is robust and provides many services, and 
 many developers know it, but at a price. Should the team instead use 
 the less robust, open source 
 YourSQL 
 database server? At what risk? 
 How does it restrict the ability to charge for the NextGen product?
  
 How does distribution of services affect the quality requirements and 
 functional requirements?
  
 ο 
  
 For example, using a remote (single, centralized) tax calculator 
 reduces the footprint of each NextGen client, reduces licensing fees 
 (only one copy is needed), and minimizes the custom configu-
  
 486",NA
Common Steps in Architectural Analysis,"There are several methods of architectural analysis. Common to most of these is 
 some variation of the following steps:
  
 1.
  
 Identify and analyze the non-functional requirements that have an impact on 
 the architecture. Functional requirements are also relevant (especially in terms 
 of variability or change), but the non-functional are given thorough attention. 
 In general, all these may be called 
 architectural factors 
 (also known as the 
 architectural drivers).
  
 ο 
  
 This step could be characterized as regular requirements analysis, but 
 since it is done in the context of identifying architectural impact and 
 deciding high-level architectural solutions, it is considered a part of 
 architectural analysis in the UP.
  
 ο 
  
 In terms of the UP, some of these requirements will be roughly identified 
 and recorded in the Supplementary Specification or use cases during 
 inception. During architectural analysis, which occurs in early 
 elaboration, the team investigates these requirements more closely.
  
 2.For those requirements with a significant architectural impact, analyze 
 alternatives and create solutions that resolve the impact. These are 
 archi 
 tectural decisions.
  
 ο 
  
 Decisions range from ""remove the requirement,"" to a custom solution, to 
 ""stop the project,"" to ""hire an expert.""
  
 This presentation introduces these basic steps in the context of the NextGen POS 
 case study. For simplicity, it avoids architectural deployment issues such as the 
 hardware and operating system configuration, which are very context and time 
 sensitive.
  
 487",NA
32.2     Types and Views of Architecture,"Some descriptions of architecture define different types, such as the ""application 
 architecture"" (allocation of features to components) or ""system architecture"" (hardware 
 and operating system configuration).
  
 In the UP, there is a similar specialization of information, but these are described in 
 ""views"" of the architecture, which summarize and emphasize a par-ticular perspective. 
 For example, the 
 logical view 
 of the architecture, which was introduced in Chapter 30, 
 summarizes the organization and functionality of the major software elements (such as 
 the layers)—it is similar to the term appli-cation architecture. The 
 deployment view 
 summarizes the system topology, communications, and mapping of executable elements 
 to processing nodes—it is similar to the term system architecture.
  
 The UP defines six views of the architecture, which are described in detail near the end 
 of this chapter. Concretely, the views combine text and diagrams, and— if described at 
 all—are recorded in the SAD.
  
 Architectural analysis is related to the architectural views because the architec-tural 
 decisions are reflected in, and described in, one or more architectural views.",NA
32.3,NA,NA
The Science: Identification and Analysis of Architectural ,NA,NA
Factors,NA,NA
Architectural Factors,"Any and all of the FURPS+ requirements may have a significant influence on the 
 architecture of a system, ranging from reliability, to schedule, to skills, and to cost 
 constraints. For example, a case of tight schedule with limited skills and sufficient 
 money probably favors buying or outsourcing to specialists, rather than building all 
 components in-house.
  
 However, the factors with the strongest architectural influence tend to be within the 
 high-level FURPS+ categories of functionality, reliability, performance, sup-
 portability, implementation, and interface (see Chapter 5 for a detailed breakdown). 
 Interestingly, it is usually the non-functional quality attributes (such as reliability or 
 performance) that give a particular architecture its unique flavor, rather than its 
 functional requirements. For example, the design in the Next-Gen system to support 
 different third-party components with unique interfaces, and the design to support 
 easily plugging in different sets of business rules.
  
 In the UP, these factors with architectural implications are called 
 architectur-ally 
 significant requirements. 
 ""Factors"" is used here for brevity.
  
 488",NA
Quality Scenarios,"When defining quality requirements during architectural factor analysis, 
 qual-ity 
 scenarios
 1
 are recommended, as they define measurable (or at least observ-able) 
 responses, and thus can be verified. It is not much use to vaguely state ""the 
 system will be easy to modify"" without some measure of what that means.
  
 Quantifying some things, such as performance goals and mean time between 
 failure, are well known practices, but quality scenarios extend this idea and 
 encourages recording all (or at least, most) factors as measurable statements.
  
 Quality scenarios are short statements of the form <stimulus> <measurable 
 response>; for example:
  
 When the completed sale is sent to the remote tax calculator to add the 
 taxes, the result is returned within 2 seconds ""most"" of the time, measured in 
 a production environment under ""average"" load conditions.
  
 When a bug report arrives from a NextGen beta test volunteer, reply with a 
 phone call within 1 working day.
  
 Note that ""most"" and ""average"" will need further investigation and definition by 
 the NextGen architect; a quality scenario is not really valid until it is testable, 
 which implies fully specified. Also, observe the qualification in the first quality 
 scenario in terms of the environment to which it applies. It does little good to 
 specify a quality scenario, verify that it passes in a lightly loaded development 
 environment, but fail to evaluate it in a realistic production environment.
  
 Pick Your Battles
  
 A caution: Writing these quality scenarios can be a mirage of usefulness. It's 
 easy to 
 write 
 these detailed specifications, but not to realize them. Will anyone 
 ever really test them? How and by whom? A strong dose of realism is required 
 when writing these; there's no point in listing many sophisticated goals if no one 
 will ever really follow through on testing them.
  
 There is a relationship here to the ""pick your battles"" discussion that was pre-
 sented in an earlier chapter on the Protected Variations pattern. What are the 
 really critical make-or-break quality scenarios? For example, in an airline reser-
 vation system, consistently fast transaction completion under very high load 
 conditions is truly critical to the success of the system—it must definitely be
  
 1. A term used in various architectural methods promoted by the Software Engineering 
  
 Institute (SEI); for example, in 
 the Architecture Based Design 
 method.
  
 489",NA
Describing Factors,"One important goal of architectural analysis is to understand the influence of the 
 factors, their priorities, and their variability (immediate need for flexibility and future 
 evolution). Therefore, most architectural methods (for example, see [HNS00]) 
 advocate creating a table or tree with variations of the following infor-mation (the 
 format varies depending on the method). The following style shown in Table 32.1 is 
 called a 
 factor table, 
 which in the UP is part of the Supplemen-tary Specification.
  
 Factor
  
 Measures and 
  
 quality scenarios
  
 Variability (current flexibility and future evolu-
 tion)
  
 Impact of factor (and its vari-
 ability) on stakeholders, 
  
 architecture and other factors
  
 Prior-
  
 ity for 
 Suc-
  
 cess
  
 Diffi-
  
 culty 
 or 
  
 Risk
  
 Reliability — Recoverability
  
 Recovery from 
 remote service 
 failure
  
 When a remote ser-
 vice fails, reestablish 
 connectivity with it 
 within 1 minute of its 
 detected re-avail-
  
 ability, under normal 
 store load in a pro-
 duction environment.
  
 current flexibility - our SME says local 
  
 client-side simplified services are acceptable 
 (and desirable) until reconnection is possible. 
 evolution - within 2 years, some retailers may 
 be willing to pay for full local replication of 
 remote services (such as the tax calculator). 
 Probability? High.
  
 High impact on the 
 large-scale design.
  
 Retailers really dislike it when 
 remote services fail, as it pre-
 vents or restricts them from 
 using a POS to make sales.
  
 H
  
 M
  
  
  
  
  
  
  
 Table 32.1 Sample factor table. Legend: H-high. M-medium. SME-subject 
 matter expert.
  
 Notice the categorization scheme: 
 Reliability
 —
 Recoverability 
 (from the FURPS+ 
 categories). This isn't presented as the best or only scheme, but it is useful to group 
 architectural factors into categories. For example, certain categories (such as 
 reliability and performance) strongly relate to identifying and defining test plans, 
 and thus it is useful to group them.
  
 The basic priority and risk code values of H/M/L are simply suggestive of using 
 some codes the team finds useful; there are a variety of coding schemes (numeric 
 and qualitative) from different architectural methods and standards (such as ISO 
 9126). A caution: If the extra effort of using a more complex scheme does not lead 
 to any practical action, it isn't worthwhile.
  
 490",NA
Factors and UP Artifacts,"The central functional requirements repository in the UP are the use cases, and they, 
 along with the Vision and Supplementary Specification, are an important source of 
 inspiration when creating a factor table. In the use cases, the 
 Special Requirements, 
 Technology Variations, 
 and 
 Open Issues 
 should be reviewed, and their implied or 
 explicit architectural factors consolidated in the Supplementary Specification.
  
 It is reasonable to at first record use-case related factors with the use case during its 
 creation, because of the obvious relationship, but it is ultimately more convenient (in 
 terms of content management, tracking, and readability) to consolidate all the 
 architectural factors in one location—in the factor table in the Supplementary 
 Specification.",NA
Use Case UC1: Process Sale,"Main Success 
 Scenario: 
  
 1. ...
  
 Special Requirements:
  
 - Credit authorization response within 30 seconds 90% of the time. 
  
 - Somehow, we want robust recovery when access to remote services such the inven 
  
 tory system is failing. 
  
 Technology and Data Variations List:
  
 2a. Item identifier entered by bar code laser scanner (if bar code is present) or keyboard.
  
 Open Issues:
  
 - What are the tax law variations? 
  
 - Explore the remote service recovery issue.",NA
32.4     Example: Partial NextGen POS Architectural Factor Table ,"The partial factor table in Table 32.2 shows some factors related to later discussion.
  
 491",NA
32.5     The Art: Resolution of Architectural Factors,"One could say the 
 science 
 of architecture is the collection and organization of 
 information about the architectural factors, as in the factor table. The 
 art 
 of architecture 
 is making skillful choices to resolve these factors, in light of trade-offs, 
 interdependencies, and priorities.
  
 Adept architects have knowledge in a variety of areas (for example, architec-tural styles 
 and patterns, technologies, products, pitfalls, and trends) and apply this to their 
 decisions.",NA
"Recording Architectural Alternatives, Decisions, and Motivation","Ignoring for now principles of architectural decision-making, virtually all archi-tectural 
 methods recommend keeping a record of alternative solutions, deci-sions, influential 
 factors, and motivations for the noteworthy issues and decisions.
  
 Such records have been called 
 technical memos 
 [Cunningham96J, issue cards 
 [HNS00], and 
 architectural approach documents 
 (SEI architectural proposals), with 
 varying degrees of formality and sophistication. In some meth-ods, these memos are the 
 basis for yet another step of review and refinement.
  
 In the UP, the memos should be recorded in the SAD.
  
 An important aspect of the technical memo is the 
 motivation 
 or rationale. When a 
 future developer or architect needs to modify the system,
 2
  it is immensely helpful to 
 understand the motivations behind the design, such as 
 why 
 a particu-lar approach to 
 recovery from remote service failure in the NextGen POS was chosen and others 
 rejected, in order to make informed decisions about changing the system.
  
 Explaining the rationale of rejecting the alternatives is important, as during future 
 product evolution, an architect may reconsider these alternatives, or at least want to 
 know what alternatives were considered, and why one was chosen.
  
 A sample technical memo follows that records an architectural decision for the 
 NextGen POS. The exact format is, of course, not important. Keep it simple and just 
 record information that will help the future reader make an informed deci-sion when 
 changing the system.
  
 2. Or when four weeks have passed and the original architect has forgotten their 
 own rationale!
  
 493",NA
Priorities,"There is a hierarchy of goals that guides architectural decisions:
  
 1.    Inflexible constraints, including safety and legal compliance, 
  
 o  
 The NextGen POS must correctly apply tax policies.
  
 494",NA
Basic Architectural Design Principles,"The core design principles explored in much of this book that were applicable to small-scale 
 object design are still dominant principles at the large-scale architectural level:
  
 • 
  
 • 
  
 • 
  
 low coupling 
  
 high cohesion 
  
 protected variation (interfaces, indirection, service lookup, and so forth) 
  
 However, the granularity of the components is larger—it is low coupling between applications, 
 subsystems, or process rather than between small objects. 
  
 496",NA
Promotion of Architectural Patterns,"An exploration of architectural patterns and how they could apply (or misapply) to 
 the NextGen case study is out of scope in this introductory text. 
  
 However, a few pointers:
  
 Probably the most common mechanism to achieve low coupling, protected 
 variation, and a separation of concerns at the architectural level is the Layers 
 pattern, which has been introduced a previous chapter. This is an example of the 
 most common separation technique—modularizing concerns into separate 
 components or layers.
  
 There is a large and growing body of written architectural patterns. Studying 
 these is the fastest way I know of to learn architectural solutions. Please see the 
 recommended readings.",NA
32.6     Summary of Themes in Architectural Analysis,"One theme to note is that ""architectural"" concerns are especially related to 
 nonfunctional requirements, and include an awareness of the business or market 
 context of the application. At the same time, the functional requirements (for 
 example, processing sales) cannot be ignored; they provide the context within 
 which these concerns must be resolved. Further, identification of their variability 
 is architecturally significant.
  
 A second theme is that architectural concerns involve system-level, large-scale, 
 and broad problems whose resolution usually involves large-scale or fundamental 
 design decisions; for example, the choice of—or even use of—an application 
 server.
  
 A third theme in architectural analysis is interdependencies and trade-offs. For 
 example, improved security may affect performance or usability, and most 
 choices affect cost.
  
 A fourth theme in architecture analysis is the generation and evaluation of 
 alternative solutions. A skilled architect can offer design solutions that involve 
 building new software, and also suggest solutions (or partial solutions) using 
 commercial or publicly available software and hardware. For example, recovery 
 in a remote server of the NextGen POS can be achieved through designing and 
 programming ""watchdog"" processes, or perhaps through clustering, replication, 
 and failover services offered by some operating system and hardware 
 components. Good architects know third-party hardware and software products. 
  
 499",NA
32.7     Architectural Analysis within the ,NA,NA
UP ,NA,NA
Caution: Waterfall Architectural ,NA,NA
Analysis,"Architectural analysis methods and books often implicitly encourage 
  
 waterfall-style extensive 
  
 architectural 
  
 design 
  
 decisions 
  
 before 
  
 implementation. In iterative development and UP, apply these ideas in the 
  
 context of small steps, feedback, and adaptation, rather than attempting to 
  
 fully resolve the architecture before programming. Tackle implementation 
  
 of the riskiest or most difficult solutions in early iterations, and adjust the 
  
 architectural solutions based on feedback and growing insight.",NA
Architectural Information in the UP Artifacts,"•    
 The architectural factors (for example, in a factor table) are recorded in 
  
 the 
 Supplementary Specification.
  
 •      The architectural decisions are recorded in the SAD. This includes the 
  
 technical memos and descriptions of the architectural views.",NA
The SAD and Its Architectural Views,"In addition to the UML package, class, and interaction diagrams, another key 
 artifact in the UP Design Model is the SAD. It describes the big ideas in the 
 architecture, including the decisions of architectural analysis. Practically, it is a 
 learning aid 
 for developers who need to understand the essential ideas of the 
 system.
  
 When someone joins the team, a project coach can say, ""Welcome to the NextGen 
 project! Please go to the project website and read the ten page SAD in order to get 
 an introduction to the major ideas."" During a later release, when new people work 
 on the system, the SAD is a key learning aid.
  
 500",NA
Phases,"Inception
 —If it is unclear if it is technically possible to satisfy the architecturally 
  
 significant 
  
 requirements, the 
  
 team may 
  
 implement 
  
 an 
  
 architectural 
  
 proof-of-concept 
 (POC) to determine feasibility. In the UP, its creation and 
  
 assessment is called 
 Architectural Synthesis. 
 This is distinct from plain old small 
  
 POC programming experiments for isolated technical questions. An architectural POC 
  
 lightly covers 
 many 
 of the architecturally significant requirements to assess their 
  
 combined 
 feasibility.
  
 Elaboration
 —A major goal of this phase is to implement the core risky architectural elements, 
 thus most architectural analysis is completed during elaboration. It is normally expected that 
 the majority of factor table, technical memo, and SAD content can be completed by the end of 
 elaboration.
  
 Transition
 —Although ideally the architecturally  significant factors and decisions were 
 resolved long before transition, the SAD will need a review and possible revision at the end of 
 this phase to ensure it accurately describes the final deployed system.
  
 Subsequent evolution cycles
 —Before the design of new versions, it is common to revisit 
 architectural factors and decisions. For example, the decision in version 1.0 to create a single 
 remote tax calculator service, rather than one duplicated on each POS node, could have been 
 motivated by cost (to avoid multiple licenses). But perhaps in the future the cost of tax 
 calculators is reduced, and thus, for fault tolerance or performance reasons, the architecture is 
 changed to use multiple local tax calculators.
  
 504",NA
32.8     Further Readings,"There is a growing body of architecture-related patterns, and general 
 software architecture advice. Suggestions:
  
 •  
 Pattern-Oriented Software Architecture, 
 both volumes. 
  
 •  
 Software Architecture in Practice 
 [BCK98]. 
  
 •  
 Pattern Languages of Program Design, 
 all volumes. Each volume has a sec 
  
 tion on architecture-related patterns.
  
 • 
  
 Online Web articles on architectural patterns (such as J2EE 
 architectures), 
  
 available at Sun, IBM, and other websites. 
  
 •  
 Online Web articles on architecture available at the Carnegie Mellon Uni 
  
 versity Software Engineering Institute (SEI), which has long been a center 
  
 of architecture investigation (
 www.sei.cmu.edu
 ).
  
 505",NA
Chapter 33,NA,NA
DESIGNING MORE USE,NA,NA
-,NA,NA
CASE ,NA,NA
REALIZATIONS WITH ,NA,NA
OBJECTS ,NA,NA
AND PATTERNS,"On two occasions I have been asked (by members of Parliament), 
 ""Pray, Mr. Babbage, if you put into the machine wrong figures, will 
 the right answers come out?"" I am not able rightly to apprehend the 
 kind of confusion of ideas that could provoke such a question.
  
 —
 Charles 
  
 Babbage",NA
Objectives,Apply GRASP and GoF patterns in the design.,NA
Introduction,"This chapter explores some partial designs for the current iteration, handling 
 requirements such as failover to local services, POS device handling, and 
 payment authorization.",NA
33.1      Failover to Local Services; Performance with ,NA,NA
Local Caching,"One of the NextGen requirements is some degree of recovery from remote 
 service failure, such as a (temporarily) unavailable product database.
  
 507",NA
33.2     Handling Failure,"The preceding design provides a solution for client-side caching of 
 ProductSpecification 
 objects in a persistent file, to improve performance, 
 and also to provide at least a partial fall-back solution if the external 
 products service can't be accessed. Perhaps 10,000 products are cached 
 in the local file, which may satisfy most requests for product information 
 even when the external service fails.
  
 What to do in the case where there isn't a local cache hit and access to the 
 external products service fails? Suppose that the stakeholders asked us 
 create a solution that signals the cashier to manually enter the price and 
 description, or cancel the line item entry.
  
 512",NA
Throwing Exceptions,"A straightforward approach to signaling the failure under consideration is to 
 throw an exception.
  
 Exceptions are especially appropriate when dealing with resource failures 
 (disk, memory, network or database access, and other external services).
  
 An exception will be thrown from within the persistence subsystem (actually, 
 probably starting from within something like a Java JDBC implementation), where 
 a failure to use the external products database is first detected. The exception will 
 unwind the call stack back up to an appropriate point for its han-dling.
 1
  
 Suppose that the original exception (using Java as an example) is a 
 java.sql.SQLException. 
 Should a 
 SQLException 
 per se be thrown all the way up 
 to the presentation layer? No. It is at the wrong level of abstraction. This leads to 
 a common exception handling pattern: 
  
 1. Checked vs. unchecked exception handling is not covered, as it is not supported in all 
  
 popular OO languages—C++, C#, and Smalltalk, for example. 
  
 514",NA
Exceptions in the UML,"This is an appropriate time to introduce the UML notation for throwing
 3
  and catching 
 exceptions.
  
 2. 
 Resolving an exception near the level at which it was raised is a laudable but difficult 
  
 goal, because the requirement for how to handle an error is often application-specific. 
 3. 
 Officially in the UML, one 
 sends 
 an exception, but 
 throws 
 is a sufficient and more 
  
 familiar usage.
  
 515",NA
Handling Errors,"One side of the design has been considered: throwing exceptions, in terms 
 of converting, naming, and illustrating them. The other side is the handling of 
 an exception.
  
 517",NA
33.3     Failover to Local Services with a Proxy (GoF),"Failover to a local service for the product information was achieved by 
 inserting the local service in front of the external service; the local service is 
 always tried first. However, this design is not appropriate for all services; 
 sometimes the external service should be tried first, and a local version second. 
 For example, consider the posting of sales to the accounting service. Business 
 wants them posted as soon as possible, for real-time tracking of store and 
 register activity.
  
 In this case, another GoF pattern can solve the problem: Proxy. Proxy is a 
 simple pattern, and widely used in its 
 Remote Proxy 
 variant. For example, in 
 Java's RMI and in CORBA, a local client-side object (called a ""stub"") is 
 called upon to access a remote object's services. The client-side stub is a local 
 proxy, or a representative for a remote object.
  
 519",NA
33.4 ,NA,NA
Designing for Non-Functional or Quality Requirements,"Before moving on to the next section, notice that the design work up to this 
 point in the chapter did not relate to business logic, but to non-functional or 
 quality requirements related to reliability and recovery.
  
 Interestingly—and this a key point in software architecture—it is common 
 that the large-scale themes, patterns, and structures of the software 
 architecture are shaped by the designs to resolve the non-functional or quality 
 requirements, rather than the basic business logic.",NA
33.5 ,NA,NA
Accessing External Physical Devices with Adapters; ,NA,NA
Buy vs. Build,"Another requirement in this iteration is to interact with physical devices that 
 comprise a POS terminal, such as opening a cash drawer, dispensing change 
 from the coin dispenser, and capturing a signature from the digital signature 
 device.
  
 The NextGen POS must work with a variety of POS equipment, including that 
 sold by IBM, Epson, NCR, Fujitsu, and so forth.
  
 Fortunately, the software architect has done some investigation, and has 
 discovered that there is now an industry standard, UnifiedPOS (www.nrf-
 arts.org), that defines standard object-oriented interfaces (in the UML sense) 
 for all common POS devices. Furthermore, there is the JavaPOS 
 (www.javapos.com)—a Java mapping of the Unified POS.
  
 Therefore, in the Software Architecture Document, the architect adds a 
 technical memo to communicate this significant architectural choice:
  
 523",NA
33.6     Abstract Factory (GoF) for Families of Related Objects,"The JavaPOS implementations will be purchased from manufacturers. For 
 example
 5
 :
  
 //   IBM's  drivers 
  
 com.ibm.pos.jpos.CashDrawer   (implements   jpos.CashDrawer) 
  
 com.ibm.pos.jpos.CoinDispenser   (implements   jpos.CoinDispenser)
  
 //  NCR's  drivers 
  
 com.ncr.posdrivers.CashDrawer   (implements   jpos.CashDrawer) 
 com.ncr.posdrivers.CoinDispenser   (implements 
  
 jpos.CoinDispenser)
  
 Now, how to design the NextGen POS application to use the IBM Java 
 drivers if IBM hardware is used, NCR drivers if appropriate, and so forth?
  
 Note that there are families of classes 
 (CashDrawer+CoinDispenser+...) 
 that 
 need to be created, and each family implements the same interfaces.
  
 5. These are fictitious package names.
  
 525",NA
An Abstract Class Abstract Factory,"A common variation on Abstract Factory is to create an abstract class factory that is 
 accessed using the Singleton pattern, reads from a system property to decide which of its 
 subclass factories to create, and then returns the appropriate subclass instance. This is 
 used, for example, in the Java libraries with the 
 java.awt.Toolkit 
 class, which is an 
 abstract class abstract factory for creating families of GUI widgets for different operating 
 system and GUI subsystems.
  
 The advantage of this approach is that it solves this problem: How does the application 
 know which abstract 
  
 factory 
  
 to 
  
 use? 
  
 IBMJavaPOSDevicesFactory? 
 NCRJavaPOSDevicesFactory?
  
 The following refinement solves this problem. Figure 33.16 illustrates the solution.
  
 With this abstract class factory and Singleton pattern 
 getlnstance 
 method, objects can 
 collaborate with the abstract superclass, and obtain a reference to one of its subclass 
 instances. For example, consider the statement:
  
 CashDrawer  =  JavaPOSDevicesFactory.getlnstance( ).getNewCashDrawer ()
 ;
  
 The expression 
 JavaPOSDevicesFactory.getlnstance( ) 
 will return an instance of 
 IBMJavaPOSDevicesFactory 
 or 
 NCRJavaPOSDevicesFactory, 
 depending on the system 
 property that is read in. Notice that by changing the external system property 
 ""jposfactory.classname"" 
 (which is the class name as a String) in a properties file, the 
 NextGen system will use a different family of JavaPOS drivers. Protected Variations with 
 respect to a changing factory has been achieved with a data-driven (reading a properties 
 file) and reflective programming design, using the 
 c. newInstance( ) 
 expression.
  
 Interaction with the factory will occur in a 
 Register. 
 By the goal of low representational 
 gap, it is reasonable for the software 
 Register 
 (whose name is suggestive of the overall 
 POS terminal) to hold a reference to devices such as 
 CashDrawer. 
 For example:
  
 class Register 
  
 { 
  
 private jpos.CashDrawer CashDrawer; 
  
 private jpos.CoinDispenser CoinDispenser;
  
 public Register() { 
  
  
 CashDrawer = 
  
  
  
 JavaPOSDevicesFactory.getlnstance().getNewCashDrawer(); 
  
  
 //…. 
  
 } 
  
 //… 
  
 } 
  
 527",NA
33.7     Handling Payments with Polymorphism and Do It Myself,"One of the common ways to apply polymorphism (and Information Expert) is 
  
 in the context of what Peter Coad calls the ""Do It Myself"" strategy or 
  
 pattern [Coad95].That is: 
  
 528",NA
Fine-Grained Classes?,"Consider the creation of the 
 CreditCard, DriversLicense, 
 and 
 Check 
 software 
 objects. Our first impulse might be to record the data they hold simply in their 
 related payment classes, and eliminate such fine-grained classes. However, it is 
 usually a more profitable strategy to use them; they often end up providing use-ful 
 behavior and being reusable. For example, the 
 CreditCard 
 is a natural Expert on 
 telling you its credit company type (Visa, MasterCard, and so on). This behavior 
 will turn out to be necessary for our application.",NA
Credit Payment Authorization,"The system must communicate with an external credit authorization service, and 
 we have already created the basis of the design based on adapters to support 
 this.
  
 Relevant Credit Payment Domain Information
  
 Some context for the upcoming design:
  
 • POS systems are physically connected with external authorization services in 
 several ways, including phone lines (which must be dialed) and always-on 
 broadband Internet connections.
  
 531",NA
33.8     Conclusion,"The point of this case study was not to show the correct solution—there isn't a 
 single best solution, and I'm sure readers can improve on what I've suggested. 
 My sincere hope has been to demonstrate that doing object design can be 
 reasoned through by core principles such as low coupling and the application 
 of patterns, rather than being a mysterious process.",NA
Caution: Pattern-itis,"This presentation has used GoF design patterns at many points, which is one 
 point of the case study as a learning aid. But, there have been reports of 
 designers excessively force-fitting patterns in a creative frenzy of pattern-itis. I 
 think a conclusion to draw from this is that patterns require study in multiple 
 examples to be well-digested. A popular learning vehicle is a lunchtime or 
 after-work study group in which participants shares ways they have seen or 
 could see the application of patterns, and discuss a section of a patterns book.
  
 535",NA
Chapter 34,NA,NA
DESIGNING A PERSISTENCE ,NA,NA
FRAMEWORK WITH PATTERNS,"Le temps est un grand professeur, mais 
  
 malheureusement il tue tous ses eleves 
  
 (Time is a great teacher, but unfortunately it kills all its pupils).
  
 —
 Hector Berlioz",NA
Objectives,"• 
  
 • 
  
 • 
  
 Design part of a framework with the Template Method, State, and 
 Command patterns. 
  
 Introduce issues in object-relational (O-R) mapping. 
  
 Implement lazy materialization with Virtual Proxies.",NA
Introduction,"The NextGen application—like most—requires storing and retrieving information in a 
 persistent storage mechanism, such as a relational database (RDB). This chapter 
 explores the design of a framework for storing persistent objects.
  
 It is usually better to get or buy than build one of these, either as a standalone product 
 or as part of container-managed persistence for entity beans if using EJBs and other 
 Java technologies. Building an industrial-strength O-R persistence service can consume 
 person-years of effort, and there are subtle issues requiring specialized expertise. 
 Furthermore, technologies such as those based on the Java Data Objects (JDO) 
 specification offer partial solutions.
  
 Therefore, the intention is not to show an industrial-strength framework or suggest 
 ignoring technologies like JDO, but rather to use a persistence framework as a vehicle 
 for explaining general framework design with patterns, because it
  
 537",NA
34.1     The Problem: Persistent Objects,"Assume that in the NextGen application, 
 ProductSpecification 
 data resides in 
 a relational database. It must be brought into local memory during application 
 use. 
 Persistent objects 
 are those that require persistent storage, such as 
 ProductSpecification 
 instances.",NA
Storage Mechanisms and Persistent Objects,"Object databases
 —If an object database is used to store and retrieve objects, 
 no additional custom or third-party persistence services are required. This is 
 one of several attractions for its use.
  
 Relational databases
 —Because of the prevalence of RDBs, their use is often 
 required, rather than the more convenient object databases. If this is the case, 
 a number of problems arise due to the mismatch between record-oriented and 
 object-oriented representations of data; these problems are explored later. A 
 special O-R mapping service is required.
  
 Other
 —In addition to RDBs, it is sometimes desirable to store objects in 
 other storage mechanisms or formats, such as flat files, XML structures, Palm 
 OS PDB files, hierarchical databases, and so on. As with relational databases, 
 a representation mismatch exists between objects and these non-object-
 oriented formats. And as with RDBs, special services are required to make 
 them work with objects.",NA
34.2     The Solution: A Persistence Service from a ,NA,NA
Persistence Framework,"A persistence framework 
 is a general-purpose, reusable, and extendable set of 
 types that provides functionality to support persistent objects. A 
 persistence service 
 (or subsystem) actually provides the service, and will be created with a persistence 
 framework. A persistence service is usually written to work with RDBs, in which 
 case it is also called an 
 O-R mapping service. 
 Typically, a per-sistence service 
 must translate objects into records (or some other form of struc-
  
 tured data such as XML) and save them in a database, and translate 
  
 records into objects when retrieving from a database.
  
 In terms of the layered architecture of the NextGen application, a 
  
 persistence service is a subsystem within the technical services layer.
  
 538",NA
34.3     Frameworks,"At the risk of oversimplification, a framework is an 
 extendable 
 set of objects for 
 related functions. The quintessential example is a GUI framework, such as 
 Java's AWT or Swing.
  
 The signature quality of a framework is that it provides an implementation for the 
 core and unvarying functions, and includes a mechanism to allow a developer to 
 plug in the varying functions, or to extend the functions. 
  
 For example, Java's Swing GUI framework provides many classes and 
 interfaces for core GUI functions. Developers can add specialized widgets by 
 subclassing from the Swing classes and overriding certain methods. Developers 
 can also plug in varying event response behavior to predefined widget classes 
 (such as JButton) by registering listeners or subscribers based on the Observer 
 pattern. That's a framework. 
  
 In general, a 
 framework:
  
 •  
 Is a cohesive set of interfaces and classes that collaborate to provide 
 services for the core, unvarying part of a logical subsystem. 
  
 •  
 Contains concrete (and especially) abstract classes that define 
 interfaces to conform to, object interactions to participate in, and other 
 invariants. 
  
 •  
 Usually (but not necessarily) requires the framework user to define sub 
 classes of existing framework classes to make use of, customize, and 
 extend the framework services. 
  
 •  
 Has abstract classes that may contain both abstract and concrete 
 methods. 
  
 •  
 Relies on the 
 Hollywood Principle
 — 
 ""Don't call us, we'll call you."" 
 Thismeans that 
 the user-defined classes (for example, new 
  
 subclasses) willreceive messages from the predefined framework classes. These 
 are usuallyhandled by implementing superclass abstract methods. 
  
 The following persistence framework example will demonstrate these principles.",NA
Frameworks Are Reusable,"Frameworks offer a high degree of reuse—much more so than individual 
 classes. Consequently, if an organization is interested (and who isn't?) in 
 increasing its degree of software reuse, then it should emphasize the 
 creation of frameworks.
  
 539",NA
34.4 ,NA,NA
Requirements for the Persistence Service and ,NA,NA
Framework,"For the NextGen POS application, we need a persistence service to be built with a 
 persistence framework (which could be used to also create other persistence 
 services). Let's call the framework PFW (Persistence Framework). PFW is a 
 simplified framework—a full-blown, industrial-strength persistence framework is 
 outside the scope of this introduction.
  
 The framework should provide functions such as:
  
 • 
  
 store and retrieve objects in a persistent storage mechanism 
  
 •  
 commit 
 and 
 rollback 
 transactions 
  
 The design should be extendable to support different storage mechanisms and 
 formats, such as RDBs, records in flat files, or XML in files.",NA
34.5 ,NA,NA
Key Ideas,"The following key ideas will be explored in subsequent sections:
  
 •  
 Mapping
 —There must be some mapping between a class and its 
 persistentstore (for example, a table in a database), and between object 
 attributes andthe fields (columns) in a record. That is, there must be a 
 schema mapping 
 between the two schemas.
  
 •  
 Object identity
 —To easily relate records to objects, and to ensure there are 
 no inappropriate duplicates, records and objects have a unique object 
 identifier.
  
 •  
 Database mapper
 —A Pure Fabrication database mapper is responsible 
  
 for 
 materialization and dematerialization.
  
 •  
 Materialization and dematerialization
 —Materialization is the act of 
 transforming a non-object representation of data (for example, records) 
 from a persistent store into objects. Dematerialization is the opposite 
 activity (also known as passivation).
  
 • 
  
 Caches—Persistence services cache materialized objects for performance. 
  
 •  
 Transaction state of object
 —It is useful to know the state of 
  
 objects in terms of their relationship to the current transaction. For example, it 
 is use ful to know which objects have been modified (are 
 dirty) 
 so that it is 
 possible to determine if they need to be saved back to their persistent store.
  
 •  
 Transaction operations
 —Commit and rollback operations.
  
 •  
 Lazy materialization
 —Not all objects are materialized at once; a 
  
 particular instance is only materialized on-demand, when needed.
  
 540",NA
34.6     Pattern: Representing Objects as Tables,"How do you map an object to a record or relational database 
 schema?
  
 The 
 Representing Objects as Tables 
 pattern [BW96] proposes 
 defining a table in an RDB for each persistent object class. Object 
 attributes containing primitive data types (number, string, boolean, and 
 so on) map to columns.
  
 If an object has only attributes of primitive data types, the mapping is 
 straightforward. But as we will see, matters are not that simple, since 
 objects may have attributes that refer to other complex objects, while 
 the relational model requires that values be atomic (that is, First 
 Normal Form) (see Figure 34.1).
  
  
 Manufacturer
  
 name 
  
 city 
  
 ...
  
 ...
  
  
 : Manufacturer 
 name = Now&Zen 
 city = Mumbai
  
 MANUFACTURER TABLE
  
 s
  
 name
  
 city
  
 Now&Zen
  
 Mumbai
  
 Celestial 
  
 Shortening
  
 San Ramon
  
 Figure 34.1 Mapping objects and tables.",NA
34.7     UML Data Modeling Profile,"While on the subject of RDBs, not surprisingly, the UML has become a 
 popular notation for 
 data models. 
 Note that one of the official UP 
 artifacts is the Data Model, which is part of the Design discipline. 
 Figure 34.2 illustrates some notation in the UML for data modeling.
  
 aggregate signifies a referential constraint: a ProductSpecification
  
 row can't exist without a related Manufacturer row
  
 «Table»
  
 Manufacturer
  
 1
  
 PK - primary key 
 FK - foreign key
  
 *
  
 «Table»
  
 ProductSpecification
  
 «PK» OID : char(16) 
  
 Name : varchar(100) 
  
 City : varchar(50)
  
 «PK» OID : char(16) 
  
 Description : varchar(100) 
 ...
  
 «FK» Manu_OID : char(16)
  
 Figure 34.2 UML Data Modeling Profile example.
  
 541",NA
34.8     Pattern: Object Identifier,"It is desirable to have a consistent way to relate objects to records, and to be able 
 to ensure that repeated materialization of a record does not result in duplicate 
 objects.
  
 The 
 Object Identifier 
 pattern [BW96] proposes assigning an 
 object identifier 
 (OID) to each record and object (or proxy of an object).
  
 An OID is usually an alphanumeric value; each is unique to a specific object. 
 There are various approaches to generating unique IDs for OIDs, ranging from 
 unique to one database, to globally unique: database sequence generators, the 
 High-Low key generation strategy [Ambler00], and others.
  
 Within object land, an OID is represented by an OID interface or class that 
 encapsulates the actual value and its representation. In an RDB, it is usually 
 stored as a fixed length character value.
  
 Every table will have an OID as primary key, and each object will (directly or 
 indirectly) also have an OID. If every object is associated with an OID, and 
 every table has an OID primary key, every object can be uniquely mapped to 
 some row in some table (see Figure 34.3).
  
 MANUFACTURER TABLE
  
 Manufacturer
  
 : Manufacturer 
 city = Mumbai 
  
 name = Now&Zen 
 oid = xyz123
  
 OID
  
 name
  
 city
  
 city 
  
 name 
  
 oid : OID 
  
 ...
  
 xyz123
  
 Now&Zen
  
 Mumbai
  
 abc345
  
 Celestial 
  
 Shortening
  
 San Ramon
  
 ...
  
 This is a simplified design. 
  
 In reality, the OID may be 
  
 placed in a Proxy class.
  
 primary key
  
 Figure 34.3 Object identifiers link objects and records.
  
 This is a simplified view of the design. In reality, the OID may not actually be 
 placed in the persistent object—although that is possible. Instead, it may be
  
 542",NA
34.9     Accessing a Persistence Service with a Facade,"Step one in the design of this subsystem is to define a facade for its services; 
 recall that Facade is a common pattern to provide a unified interface to a 
 subsystem. To begin, an operation is needed to retrieve an object given an OID. 
 But in addition to an OID, the subsystem needs to know what type of object to 
 materialize; therefore, the class type will also be provided. Figure 34.4 illustrates 
 some operations of the facade and its use in collaboration with one of the 
 NextGen service adapters.
  
 IProductsAdapter
  
 PersistenceFacade
  
  1
  
 : DBProductsAdapter
  
 «singleton»
  
 : PersistenceFacade
  
 ...
  
 getInstance() : PersistenceFacade 
  
 obj := get(...)
  
 get( OID, Class ) : Object
  
 put( OID, Object )
  
 ...
  
  // example use of the facade
  
 OID oid = new OID(""XYZ123"");
  
 ProductSpecification ps = (ProductSpecification) PersistenceFacade.getInstance().get( oid, ProductSpecification.class );
  
 Figure 34.4 The PersistenceFacade.",NA
34.10   Mapping Objects: Database Mapper or Database ,NA,NA
Broker Pattern,"The 
 PersistenceFacade
 —as true of all facades—does not do the work itself, but 
 delegates requests to subsystem objects.
  
 Who should be responsible for materialization and dematerialization of 
 objects (for example, a 
 ProductSpecification) 
 from a persistent store?
  
 543",NA
Metadata-Based Mappers,"More flexible, but more involved, is a mapper design based on 
 metadata 
 (data about data). 
 In contrast to hand-crafting individual mapper classes for different persistent types, 
 metadata-based mappers dynamically generate the mapping from an object schema to 
 another schema (such as relational) based on reading in metadata that describes the 
 mapping, such as ""TableX maps to Class Y; column Z maps to object property P"" (it gets 
 much more complex). This approach is feasible for languages with reflective programming 
 capabilities, such as Java, C#, or Smalltalk, and awkward for those that don't, such as C++.
  
 With metadata-based mappers, we can change the schema mapping in an external store and 
 it will be realized in the running system, without changing source code—Protected 
 Variations with respect to schema variations. 
  
 545",NA
34.11 ,NA,NA
Framework Design with the Template Method Pattern,"The next section describes some of the essential design features of the 
 Database Mappers, which are a central part of the PFW. These design features 
 are based on the Template Method GoF design pattern [GHJV95].
 2 
 This 
 pattern is at the heart of framework design,
 3
  and is familiar to most OO 
 programmers by practice if not by name.
  
 The idea is to define a method (the Template Method) in a superclass that 
 defines the skeleton of an algorithm, with its varying and unvarying parts. 
 The Template Method invokes other methods, some of which are methods 
 that may be overridden in a subclass. Thus, subclasses can override the 
 varying methods in order to add their own unique behavior at points of 
 variability (see Figure 34.6).",NA
34.12 ,NA,NA
Materialization with the Template Method ,NA,NA
Pattern,"If we were to program two or three mapper classes, some commonality in the 
 code would become apparent. The basic repeating algorithm structure for 
 materializing an object is:
  
 if   (object   in  cache) 
  
 return 
  
 it else 
  
 create  the  object   from  its   representation  in  storage 
  
  
 save 
 object  in cache 
  
 return  it
  
 The point of variation is how the object is created from storage.
  
 We will create the 
 get 
 method to be the template method in an abstract 
 superclass 
 AbstractPersistenceMapper 
 that defines the template, and use a 
 hook method in subclasses for the varying part. Figure 34.7 shows the 
 essential design. 
  
 2. This pattern is unrelated to C++ templates. It describes the template of an 
  
 algorithm. 
  
 3. More specifically, of whitebox frameworks. These are usually class hierarchy 
 andsubclassing-oriented frameworks that require the user to know something 
 about theirdesign and structure; hence, whitebox. 
  
 546",NA
The UP and the Software Architecture Document,"In terms of the UP and documentation, recall that the SAD is a learning aid for future 
 developers, which contains architectural views of key noteworthy ideas. Including 
 diagrams such as Figure 34.9 and Figure 34.10 in the SAD for the NextGen project is 
 very much in the spirit of the kind of information an SAD should contain.",NA
Synchronized or Guarded Methods in the UML,"The 
 AbstractPersistenceMapper—get 
 method contains critical section code that is not 
 thread safe—the same object could be being materialized concurrently on different 
 threads. As a technical service subsystem, the persistence service needs to be 
 designed with thread safety in mind. Indeed, the entire subsystem may be distributed 
 to a separate process on another computer, with the 
 PersistenceFacade 
 transformed 
 into a remote server object, and with many threads simultaneously running in the 
 subsystem, serving multiple clients.
  
 The method should therefore have thread concurrency control—if using Java, add the 
 synchronized 
 keyword. Figure 34.11 illustrates a synchronized method in a class 
 diagram.
  
 { 
  
 // Java 
  
 public final synchronized Object get( OID oid ) 
 { ... 
 }
  
 {guarded} means a ""synchronized"" method; that is, 
 only 1 thread may execute at a time within the family 
 of guarded methods of this object.
  
 }
  
 Abstract 
  
 PersistenceMapper
  
 IMapper
  
 + get( OID) : Object   {leaf, guarded} 
  
 ...
  
 Figure 34.11 Guarded methods in the UML.
  
 551",NA
34.13   Configuring Mappers with a MapperFactory,"Similar to previous examples of factories in the case study, the configuration of 
 the 
 PersistenceFacade 
 with a set 
 of IMapper 
 objects can be achieved with a 
 factory object, 
 MapperFactory. 
 However, as a slight twist, it is desirable to not 
 name each mapper with a different operation. For example, this is not desirable:
  
 class  MapperFactory
  
 public   IMapper getProductSpecificationMapper() {...} public   
 IMapper  getSaleMapper()    {...}
  
 This does not support Protected Variations with respect to a growing list of 
 mappers—and it will grow. Consequently, the following is preferred:
  
 class  MapperFactory
  
 public  Map  getAllMappers( )    {...}
  
 }
  
 where 
 the java. util.Map 
 (probably implemented with a 
 HashMap) 
 keys are the 
 Class 
 objects (the persistent types), and the 
 IMappers 
 are the values.
  
 Then, the facade can initialize its collection 
 of IMappers 
 as 
  
 follows: class  PersistenceFacade
  
 private   java.util.Map mappers   =
  
 MapperFactory.getlnstance( ).getAllMappers( );
  
 The factory can assign a set 
 of IMappers 
 using a data-driven design. That is, the 
 factory can read system properties to discover which 
 IMapper 
 classes to 
 instantiate. If a language with reflective programming capabilities is used, such as 
 Java, then the instantiation can be based on reading in the class names as strings, 
 and using something like a 
 Class.newlnstance 
 operation for instantiation. Thus, 
 the mapper set can be reconfigured without changing the source code.",NA
34.14   Pattern: Cache Management,"It is desirable to maintain materialized objects in a local cache to improve 
 performance (materialization is relatively slow) and support transaction 
 management operations such as a commit.
  
 The Cache Management 
 pattern [BW96] proposes making the Database 
 Mappers responsible for maintaining its cache. If a different mapper is used for 
 each class of persistent object, each mapper can maintain its own cache.",NA
34.15   Consolidating and Hiding SQL Statements in One Class,"Hard-coding SQL statements into different RDB mapper classes is not a terrible 
 sin, but it can be improved upon. Suppose instead:
  
 •  
 There is a single Pure Fabrication class (and it's a singleton) 
 RDBOpera- tlons 
 where all SQL operations (SELECT, INSERT, ...) are consolidated. 
  
 •  
 The RDB mapper classes collaborate with it to obtain a DB record or record 
  
 set (for example, 
 ResultSet).
  
 •  
 Its interface looks something like this: 
  
 class  RDBOperations
  
 {
  
 public ResultSet getProductSpecificationData( OID oid ) {...}
  
 public ResultSet getSaleData( OID oid ) {...}
  
 }
  
 So that, for example, a mapper has code like this:
  
 class ProductSpecificationRDBMapper extends AbstractPersistenceMapper
  
 {
  
 protected Object getObjectFromStorage( OID oid )
  
 { 
  
 ResultSet   rs   =
  
 RDBOperations.getlnstance( ).getProductSpecificationData(   oid   );
  
 ProductSpecification ps   =  new ProductSpecification O; 
  
 ps.setPrice(   rs.getDouble(   ""PRICE""   )    ); 
  
 ps.setOID(   oid   ); return ps;
  
 The following benefits accrue from this Pure Fabrication:
  
 •  
 Ease of maintenance and performance tuning by an expert. SQL optimiza tion 
 requires a SQL aficionado, rather than an object programmer. With all the 
 SQL embedded in this one class, it is easy for the SQL expert to find and work 
 on it. 
  
 •  
 Encapsulation of the access method and details. For example, hard-coded SQL 
 could be replaced by a call to a stored procedure in the RDB in order to obtain 
 the data. Or a more sophisticated metadata-based approach to gen erating the 
 SQL could be inserted, in which SQL is dynamically generated from a 
 metadata schema description read from an external source.",NA
34.16   Transactional States and the State Pattern,"Transactional support issues can get complex, but to keep things simple for the 
 present—to focus on the GoF State pattern—assume the following:
  
 • 
  
 • 
  
 Persistent objects can be inserted, deleted, or modified. 
  
 Operating on a persistent object (for example, modifying it) does not cause 
  
 an immediate database update; rather, an explicit 
 commit 
 operation must be 
  
 performed. 
  
 In addition, the response to an operation depends on the transactional state of the 
 object. As an example, responses may be as shown in the statechart of Figure 
 34.12.
  
 [new (not from DB)]
  
 [ from DB]
  
 State chart: PersistentObject
  
 New
  
 commit / insert
  
 OldClean
  
 save 
  
 rollback / reload 
 commit / update
  
 OldDirty
  
 Legend: 
  
 New--newly created; not in DB 
 Old--retrieved from DB 
  
 Clean--unmodified 
  
 Dirty--modified
  
  
 delete 
  
 delete
  
 rollback / reload
  
 OldDelete
  
 Deleted
  
 commit / delete
  
 Figure 34.12 Statechart for PersistentObject.
  
 For example, an ""old dirty"" object is one retrieved from the database and then 
 modified. On a commit operation, it should be updated to the database—in 
 contrast to one in the ""old clean"" state, which should do nothing (because it hasn't 
 changed). Within the object-oriented PFW, when a delete or save operation is 
 performed, it does not immediately cause a database delete or save; rather, the 
 persistent object transitions to the appropriate state, awaiting a commit or rollback 
 to really do something.
  
 As a UML comment, this is a good example of where a statechart is helpful in 
 succinctly communicating information that is otherwise awkward to express.
  
 554",NA
34.17   Designing a Transaction with the Command Pattern,"The last section took a simplified view of transactions. This section extends the 
 discussion, but does not cover all transaction design issues. Informally, a 
 transaction is a unit of work—a set of tasks—whose tasks must all complete 
 successfully, or none must be completed. That is, its completion is atomic.
  
 8. There are others, including hard-coded conditional logic, state 
 machine interpreters, and code generators driven by state tables.
  
 556",NA
34.18   Lazy Materialization with a Virtual Proxy,"It is sometimes desirable to defer the materialization of an object until 
 it is absolutely required, usually for performance reasons. For 
 example, suppose that 
 ProductSpecification 
 objects reference a 
 Manufacturer 
 object, but only very rarely does it need to be 
 materialized from the database. Only rare scenarios cause a request 
 for manufacturer information, such as manufacturer rebate scenarios 
 in which the company name and address are required.
  
 The deferred materialization of ""children"" objects is known as 
 lazy 
 materialization. 
 Lazy materialization can be implemented using the 
 Virtual Proxy GoF pattern—one of many variations of Proxy.
  
 A Virtual Proxy 
 is a proxy for another object (the 
 real subject) 
 that 
 materializes the real subject when it is first referenced; therefore, it 
 implements lazy materialization. It is a lightweight object that stands 
 for a ""real"" object that may or may not be materialized.
  
 559",NA
*,"Proxy-for
  
 1
  
 return manufacturer.getAddress()
  
 Proxy
  
 }
  
 realSubject : 
 IManufacturer
  
 - getRealSubject() : IManufacturer
  
 realSubject
  
 + getAddress()
  
 ...
  
 {
  
 3
  
 {
  
 2
  
 if ( realSubject == null )
  
  realSubject = PersistenceFacade.get(oid, Manufacturer.class);
  
 return getRealSubject().getAddress()
  
 return realSubject;
  
 }
  
 }
  
 Figure 34.16 Manufacturer Virtual Proxy.
  
 560",NA
Implementation of a Virtual Proxy,"The implementation of a Virtual Proxy varies by language. The details are out-
 side the scope of this chapter, but here is a synopsis:
  
 Language
  
 Virtual Proxy Implementation
  
 C++
  
 Define a templatized smart pointer class. No 
 IManufacturer 
 interface definition is actually needed.
  
 Java
  
 The 
 ManufacturerProxy 
 class is implemented. The 
 IManu-facturer 
 interface is defined.
  
 However, these are not normally manually coded. Rather, 
 one creates a code generator that analyzes the subject 
 classes (e.g., 
 Manufacturer) 
 and generates 
 IManufacturer 
 and 
 ProxyManufacturer.
  
 Another Java alternative is the Dynamic Proxy API.
  
 Smalltalk
  
 Define a Virtual Morphing Proxy (or Ghost Proxy), which 
 uses 
 #doesNotUnderstand: 
 and 
 #become: 
 to morph into the 
 real subject. No 
 IManufacturer 
 definition is needed.",NA
Who Creates the Virtual Proxy?,"Observe in Figure 34.16 that the 
 ManufacturerProxy 
 collaborates with the 
 PersistenceFacade 
 in order to materialize its real subject. But who creates the 
 ManufacturerProxy? 
  
 Answer: 
  
 The database 
  
 mapper 
  
 class 
  
 for 
 Product-Specification. 
 The mapper class is responsible for deciding, when it 
 materializes an object, which of its ""child"" objects should also be eagerly 
 materialized, and which should be lazily materialized with a proxy.
  
 Consider these alternative solutions: one uses eager materialization, the other 
 lazy materialization.
  
 // EAGER MATERIALIZATION OF MANUFACTURER
  
 class ProductSpecificationRDBMapper extends AbstractPersistenceMapper 
 { 
  
 protected Object getObjectFromStorage( OID oid ) 
  
 { 
  
 ResultSet 
 rs = 
  
  
 RDBOperations.getlnstance().getProductSpecificationData( oid );
  
 ProductSpecification ps = new ProductSpecification(); 
 ps.setPrice( rs.getDouble( ""PRICE"" ) );
  
 561",NA
34.19   How to Represent Relationships in Tables,"The code in the prior section relies on 
 a 
 MANU_OID foreign key in the 
 PRODUCT_SPEC table to link to a record in the MANUFACTURER table. This 
 highlights the question: How are object relationships represented in the rela-
 tional model?
  
 The answer is given in the 
 Representing Object Relationships as Tables
  
 pattern [BW96], which proposes the following:
  
 one-to-one 
 associations
  
 Place an OID foreign key in one or both tables representing the 
 objects in relationship.
  
 Or, create an associative table that records the OIDs of each object in 
 relationship.",NA
34.20   PersistentObject Superclass and Separation of Concerns,"A common partial design solution to providing persistence for objects is to create an 
 abstract technical services superclass 
 PersistentObject 
 that all persistence objects 
 inherit from (see Figure 34.17). Such a class usually defines attributes for 
 persistence, such as a unique OID, and methods for saving to a database.
  
 This is not wrong, but it suffers from the weakness of coupling the class to the 
 PersistentObject 
 class—domain classes end up extending a technical services class.
  
 PersistentObject
  
 possible design, but problematic in terms 
  
 of coupling and mixing the technical 
  
 service concern of persistence with the 
  
 application logic of a domain object.
  
 Product 
  
 Specification
  
 Figure 34.17 Problems with a PersistentObject superclass.
  
 This design does not illustrate a clear separation of concerns. Rather, technical 
 services concerns are mixed with domain layer business logic concerns by virtue of 
 this extension.
  
 On the other hand, ""separation of concerns"" is not an absolute virtue that must be 
 followed at all costs. As discussed in the Protected Variations introduction, designers 
 need to pick their battles at the truly likely points of expensive insta-bility. If in a 
 particular application making the classes extend from 
 Persistent-Object 
 leads to a neat 
 and easy solution and does not create longer-term design or maintenance problems, 
 why not? The answer lies in understanding the evolution of the requirements and 
 design for the application. It is also influenced by the language: those with single 
 inheritance (such as Java) have had their single precious superclass 
 consumed.
  
 563",NA
34.21    Unresolved Issues,"This has been a very brief introduction to the problems and design solutions in a 
 persistence framework and service. Many important issues have been glossed 
 over, including:
  
 • 
  
 dematerializing objects
  
 o Briefly, the mappers must define 
 putObjectToStorage. 
 methods. 
 Dematerializing composition hierarchies requires collaboration 
 between multiple mappers and the maintenance of associative 
 tables (if an RDB is used).
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 materialization and dematerialization of collections 
 queries for groups of objects 
  
 thorough transaction handling 
  
 error handling when a database operation fails 
 multiuser access and locking strategies 
  
 security—controlling access to the database 
  
 564",NA
PART ,NA,NA
6,NA,NA
SPECIAL TOPICS,NA,NA
Chapter 35,NA,NA
O,NA,NA
N ,NA,NA
D,NA,NA
RAWING AND ,NA,NA
T,NA,NA
OOLS,"Bubbles don't crash. 
  
 —
 Bertrand Meyer",NA
Objectives,"Learn tips for drawing UML diagrams on a project. 
  
 Illustrate some common functions in UML CASE tools.",NA
Introduction,"On a real project, doing some analysis or design while drawing UML diagrams 
 does not happen neatly as in the pages of a book. It happens in the context of a 
 busy software development team working in offices or rooms, scribbling on 
 whiteboards and perhaps using a tool, and often with a tendency to want to start 
 programming rather than work through some details via diagramming. If the 
 UML tool or process of drawing is bothersome or fussy, or feels less valuable 
 than programming, it will be avoided.
  
 This chapter offers some suggestions on striking a balance between program-
 ming and drawing, and on fostering a supportive environment to make drawing 
 convenient and useful rather than awkward.",NA
35.1     On Speculative Design and Visual Thinking,"The designs illustrated in UML diagrams will be incomplete, and only serve as a 
 ""springboard"" to the programming. Too much diagramming before programming 
 leads to time wasted in speculative design directions, or time wasted fussing with 
 UML tools. There's nothing like real code to tell you what works. Bertrand 
 Meyer said it best: ""Bubbles don't crash.""
  
 567",NA
35.2     Suggestions for UML Drawing Within the Development ,NA,NA
Process,NA,NA
Level of Effort,"As a guideline, consider diagramming in pairs for the following period, before 
 serious programming in the iteration.
  
 2-week iteration
  
 half-day to one-day near the start of the iteration (e.g., 
 Monday or Tuesday)
  
 4-week iteration
  
 one or two days near the start
  
 In both cases, drawing does not have to stop after this early focussed effort. Dur-
 ing the iteration, developers may head—ideally in pairs—""to the whiteboard"" for 
 short sessions to sketch out ideas before more programming. And they may do 
 another longer half-day session partway through the iteration, as they hit a 
 complex problem within the scope of their initial task, or finish their first task 
 and move on to a second.
  
 568",NA
Other Suggestions,"•
  
 •
  
 •
  
 •
  
 •
  
 •
  
 •
  
 Draw in pairs, not alone. Most importantly, the synergy leads to better 
 designs. Secondly, the pair quickly learns design skills from each other, and 
 thus both become better designers. It is hard to grow as a software designer 
 when one designs in isolation. Regularly rotate with new drawing/design 
 partners to gain broad exposure to another's knowledge. 
  
 To clarify a point alluded to several times, in iterative processes (such as the 
 UP), the programmers are also the designers; there is not a separate team that 
 draws designs and hands them over to programmers. The developers put on 
 their UML hats, and draw a little. Then they put on their program mer hats 
 and implement, and continue to design while programming. 
  
 If there are ten developers, suppose that there are five drawing teams work 
 ing for one day at different whiteboards. If the architect spends time rotat ing 
 through the five teams, he or she will come to see points of dependency, 
 conflict, and cross-pollinating ideas. The architect can then act as a liaison to 
 bring the designs into some harmony, and clarify the dependencies. 
  
 Hire a technical writer for the project and educate the writer in some UML 
 notation and basic OOA/D concepts (so he or she understand the context). 
 Have the writer help by doing the ""fussy work"" with UML CASE tools, 
 reverse-engineering diagrams from code, printing and displaying large plot 
 ter prints of diagrams, and so forth. The developers spend their (more 
 expensive) time doing what they do best: figuring out designs and program 
 ming. A technical writer supports them by handling diagram management, in 
 addition to true technical writing responsibilities such as working on the end-
 user documents. This is known as the Mercenary Analyst pattern 
 [Coplien95a]. 
  
 Arrange the development area with many large whiteboards in close 
 proximity. 
  
 To generalize, maximize the work environment for convenient drawing on 
 walls. Create a ""drawing-friendly"" and ""hanging diagrams""-friendly environ 
 ment. You can't expect a successful visual modeling culture in an environ 
 ment where developers are struggling to draw on small two-foot by three- 
 foot whiteboards, regular size computer monitors, or pieces of paper. Com 
 fortable drawing takes very large, open drawing spaces—physical or virtual. 
  
 As an adjunct to whiteboards, use thin plastic ""static cling"" white sheets (they 
 come in packages of 20 or more) that can be placed on the walls; they are 
 available at many stationary stores. They remain attached to the wall by static 
 cling, and can be used like a whiteboard with an erasable marker. These can 
 be plastered across a wall space to create massive, temporary ""whiteboards."" 
 I have coached groups where we wallpapered every wall—top to bottom—of 
 the project room with these, and found them a great communi cation aid. 
  
 569",NA
35.3     Tools and Sample Features,NA,NA
This Book Is Tool-Neutral,"It would be slightly odd not to mention any UML CASE (computer-aided soft-ware 
 engineering) tools, because the book is in part about drawing in the UML, which 
 happens with a CASE tool, or at a whiteboard. At the same time, not all tools can be 
 equally covered, and proper evaluations are beyond the scope of the book. To be 
 impartial:
  
 This book does not endorse any UML CASE tool. The following examples are 
 only to illustrate some typical and key features found in UML CASE tools.",NA
Tools Have Inconsistent UML Conformance,"Few tools draw all UML notation correctly, conforming to the current version of the 
 UML specification—or indeed any version. Although this would be nice, it should 
 not be a factor in choosing a tool, because much more important is its functionality 
 and ease 
 of use.",NA
Example One,"In Figure 35.1 and Figure 35.2, Together from TogetherSoft is used to illustrate and 
 define two key functions of a UML CASE tool: 
 forward-engineering and reverse 
 engineering. 
 These functions are at the heart of what distinguishes a UML CASE 
 tool from a drawing tool.
  
 571",NA
35.4     Example Two,"In Figure 35.3 and Figure 35.4, Rational Rose is used to illustrate some other core 
 functions in a UML CASE tool.
  
 Drawing class 
  
 diagrams, which 
  
 are used to 
  
 generate code, is 
  
 a key function in 
  
 a UML CASE 
  
 tool.
  
 Figure 35.3 Creating class diagrams.
  
 Organizing 
  
 diagrams in 
  
 packages is a key 
  
 UML CASE tool 
  
 feature. By 
  
 clicking on a 
  
 package, one 
  
 zooms into its 
  
 contents.
  
 Figure 35.4 Managing packages.
  
 573",NA
UML CASE Tool Vendor Requests,"I suggest consumers make four requests of UML CASE tool vendors: 
 1.Implement correct, current UML notation in the tool. 
  
 2.Have the CASE tool development team itself seriously draw, read, and review 
 UML diagrams (including reverse-engineered diagrams) in the pro cess of 
 building the UML tool itself. 
  
 3.Use version N of the UML tool to create version N+l. 
  
 4.Provide support for reverse- and forward-engineering of sequence diagrams; 
 most tools only support this for class diagrams. 
  
 Microsoft advocates that tool creators ""eat their own dogfood."" Good advice.
  
 574",NA
Chapter,NA,NA
INTRODUCTION TO ITERATIVE ,NA,NA
PLANNING AND PROJECT ,NA,NA
ISSUES,"Prediction is very difficult, especially if it's about the future.
  
 —
 anonymous",NA
Objectives,"•
  
 •
  
 •
  
 •
  
 •
  
 Rank requirements and risks. 
  
 Compare and contrast adaptive and predictive planning. 
  
 Define the UP Phase Plan and Iteration Plan. 
  
 Introduce requirements tracking tools for iterative development. 
 Suggest how to organize project artifacts.",NA
Introduction,"Project planning and management issues are large topics, but a brief explora-
 tion of some key questions related to iterative development and the UP is help-
 ful, such as:
  
 •
  
 •
  
 •
  
 What to do in the next iteration? 
  
 How to track requirements in iterative development? 
 How to organize project artifacts? 
  
 575",NA
36.1      Ranking Requirements,NA,NA
"Early Iteration Drivers: Risk, Coverage, Criticality, Skills ",NA,NA
Development,"What to do in the earliest iterations? Organize requirements and iterations by 
 risk, coverage, and Criticality [Kruchten00]. Requirement risk includes both 
 technical complexity and other factors, such as uncertainty of effort, poor speci-
 fication, political problems, or usability. Ranking requirement risks is to be con-
 trasted with ranking project risks, which is covered in a later section.
  
 Coverage implies that all major parts of the system are at least touched on in 
 early iterations—perhaps a ""wide and shallow"" implementation across many 
 components. Criticality refers to functions of high business value; that is, pri-
 mary functions should have at least partial implementations for main success 
 scenarios in the earlier iterations, even if not technically risky.
  
 On some projects, another driver is skills development—a goal is to help the 
 team master new skills such as adopting object technologies. On such projects, 
 skills development is a heavily weighted prioritization factor which tends to 
 reorganize the iterations into less risky or simpler requirements in early itera-
 tions, motivated by learning rather than risk reduction goals.",NA
What to Rank?,"The UP is use-case driven, which includes the practice of ranking use cases (and 
 scenarios of use cases) for implementation. Also, some requirements are 
 expressed as high-level features unrelated to a particular use case, usually 
 because they span many use cases or are a general service, such as logging ser-
 vices. These non-use case functions will be recorded in the Supplementary Spec-
 ification. Therefore, include both use cases and other high-level features in a 
 ranking list.
  
 Requirement
  
 Type
  
 … 
  
 Process Sale
  
 UC
  
 … 
  
 Logging
  
 Feature
  
 … 
  
 … 
  
 … 
  
 … 
  
 576",NA
Group Qualitative Methods for Ranking,"Based on the drivers, requirements are ranked, and high priorities are handled in early 
 iterations. The ranking may be informal and qualitative, generated in a group meeting 
 by members mindful of these drivers.
  
 Suggestion
  
 To informally prioritize requirements, tasks, or risks via a group meeting, use 
 iterative ""dot voting."" List the items on a whiteboard. Everyone gets, for example, 
 20 sticky dots. As a group, and in silence (to reduce influence), all approach the 
 board and apply dots to the items, reflecting the voter's priori-ties. A voter can 
 assign many dots to one item. On completion, sort and dis-cuss. Then do a second 
 round of silent dot voting to reflect updated insight based on first round voting and 
 discussion. This second round provides the feedback and adaptation by which 
 decisions improve.
  
 The requirements or risk ranking will be done before iteration 1, but then again before 
 iteration 2, and so forth.",NA
Quantitative Methods for Ranking,"Group discussion and something like dot voting for requirements or risk rank-ing are 
 probably sufficient—a fuzzy qualitative approach. For the more quanti-tatively 
 minded, variations on the following have been used. The example values and weights 
 are only suggestive; the point is that numeric values and weights can be used to reason 
 about priorities.
  
 Requirement
  
 Type
  
 AS
  
 Risk
  
 Criticality
  
 W. Sum
  
  
 Process Sale
  
 UC
  
 3
  
 2
  
 3
  
 15
  
 Logging
  
 Feat
  
 3
  
 0
  
 1
  
 7
  
 1
  
 0
  
 2
  
 Handle Returns
  
 UC
  
 0
  
 ...
  
 ...
  
 ...
  
 ...
  
 ...
  
 ...
  
  
  
 AS: architecturally significant 
  
 Weight 
  
 Range
  
 2 
  
 0-3
  
 Risk: tech, complex, novel,... 
  
 3 
  
 0-3
  
 Criticality: 
 early 
 high biz value 
  
 1 
  
 0-3
  
 On any project, the exact values should not be taken too seriously; on comple-tion, the 
 numeric scoring can be used to help group the requirements into fuzzy sets of high, 
 medium, and low ranking. Clearly, 
 Process Sale 
 appears important to work on in early 
 iterations.
  
 577",NA
Ranking the NextGen POS Requirements,"Based on some ranking method, a fuzzy grouping of requirements is possible. In terms 
 of UP artifacts, this ranking is recorded in the UP Software Development Plan. 
  
 Rank 
  
 Requirement 
  
 (use case or feature) 
  
 Comment 
  
 High 
  
 Process Sale 
  
 Logging 
  
 Sore high on all ranking criteria. 
 Pervasive. Hard to add late. 
  
 Medium 
  
 Maintain Users 
  
 Authenticate User 
  
 Affects security subdomain. 
  
 Important process but not too difficult. 
  
 Low 
  
 Cash Out 
  
 Shut Down 
  
 … 
  
 Easy, minimal effect on architecture. 
 Ditto. 
  
 …",NA
"The ""Start Up"" and ""Shut Down"" Use Cases","Virtually all systems have a 
 Start Up 
 use case, implicit if not explicit. Although it may 
 not rank high by other criteria, it is necessary to tackle at least some sim-plified version 
 of 
 Start Up 
 in the first iteration so that the initialization assumed by other cases is 
 provided. Within each iteration, the 
 Start Up 
 use case is incrementally developed to 
 satisfy the start up needs of the other use cases. Similarly, systems often have a 
 Shut, 
 Down 
 use case. In some systems, it is quite complex, such as shutting down an active 
 telecommunications switch. In terms of planning, if simple, these use cases can be 
 informally listed in the Iteration Plan, such as ""implement startup and shutdown as 
 required."" Obviously, com-plex versions need more careful requirements and planning 
 attention.",NA
A Caveat: Project Planning vs. Learning Goals,"The book goal is to offer a learning aid for introductory analysis and design, rather 
 than actually run the NextGen POS project. Therefore, some license has been taken in 
 the choice of what is tackled in the early iterations of the case study, motivated by 
 learning rather than project goals.
  
 578",NA
36.2     Ranking Project Risks,"A useful method to prioritize overall project risks is to estimate their probability 
 and impact (in cost, time, or effort). The estimates may be quantitative (which 
  
 are 
  
 usually 
  
 very 
  
 speculative) 
  
 or 
  
 simply 
  
 qualitative 
  
 (for 
  
 example, 
  
 high-medium-low, based on discussion and group dot-voting). The worst risks are 
 naturally those both probable and of high impact. For example:
  
  
 Risk
  
 Prob-
  
 ability
  
 Impact
  
 Mitigation Ideas
  
 Insufficient number and 
 quality of skilled 
  
 object-oriented 
  
 developers.
  
 H
  
 H
  
 Read the book.
  
 Hire temporary consultants. 
  
 Classroom education & mentoring. 
 Design and programming in pairs.
  
 Demo not ready for the 
 upcoming POS-World 
 con-vention in Hamburg.
  
 M
  
 H
  
 Hire temporary consultants who 
 are specialists in Java POS 
  
 systems development.
  
 Identify ""sexy"" requirements that 
 show well in a demo, and prioritize 
 those, over others.
  
 Maximize the use of pre-built
  
 components.
  
  
  
  
  
 In terms of UP artifacts, this is part of the Software Development Plan.",NA
36.3     Adaptive vs. Predictive Planning,"One of the big ideas of iterative development is to adapt based on feedback, 
 rather than to attempt to predict and plan 
 in detail 
 the entire project. Conse-
 quently, in the UP, one creates an Iteration Plan for only the 
 next 
 iteration. 
 Beyond the next iteration the detailed plan is left open, to adaptively adjust as the 
 future unfolds (see Figure 36.1). In addition to encouraging flexible, oppor-
 tunistic behavior, one simple reason for not planning the entire project in detail is 
 that in iterative development not all the requirements, design details, and thus 
 steps are known near the start of the project.
 1
  Another is the preference to trust 
 the planning judgement of the team as they proceed. Finally, suppose there was a 
 fine-grained detailed plan laid out at the start of the project, and the team 
 ""deviates"" from it to exploit better insight in how to best run the project.
  
 579",NA
OK,"?
  
 Planning the next iteration,
  
 MILESTONE: A date (perhaps two months in future) and set of
  
 and possibly part of the
  
 objectives is established.
  
 following, is reasonable.
  
 Beyond that, it is predictive, 
  
 In adaptive iterative development and planning we 
 do 
 commit to 
 speculative, and anti-
  
 target dates and objectives at the macro-level, but the detailed path 
 adaptive. 
  
 to the milestone is not fully planned iteration by iteration, to 
  
 encourage adaptively finding the best path to the milestone.
  
 Figure 36.1 Milestones are important, but avoid detailed predictive planning into the 
 far future.
  
 However, there 
 are 
 still goals and milestones; adaptive development doesn't mean the 
 team doesn't know where they are going, or the milestone dates and objectives. In 
 iterative development, the team still does commit to dates and objectives, but the 
 detailed path to these is flexible. For example, the NextGen team may set a milestone 
 that in three months, use cases 
 Process Sale, Handle Returns, 
 and 
 Authenticate User, 
 and the logging and pluggable rules features will be completed. But—and this is the 
 key point—the fine-grained plan or path of two-week timeboxed iterations to that 
 milestone is not defined in detail. The order of steps, or what to do in each iteration 
 over the following three months, is not fixed. Rather, just the next two-week iteration is 
 planned, and the team adapts step by step, working to fulfill the objectives by the 
 milestone date. Of course, dependencies in components and resources naturally 
 constrain some ordering of the work, but not all activities need to be planned and 
 scheduled in fine-grained detail.
  
 1. They aren't really or reliably known on a ""waterfall"" project either, although detailed 
  
 planning for the entire project may occur as though they were.",NA
36.4     Phase and Iteration Plans,"At a macro level, it is possible to establish milestone dates and objectives, but at 
 the micro level, the plan to the milestone is left flexible except for the near future 
 (for example, the next four weeks). These two levels are reflected in the UP 
 Phase Plan and Iteration Plan, 
 both of which are part of the composite Software 
 Development Plan. The Phase Plan lays out the macro-level milestone dates and 
 objectives, such as the end of phases and mid-phase pilot test mile-stones. The 
 Iteration Plan defines the work for the current and next iteration— not all 
 iterations (see Figure 36.2).
  
 Short; a few pages.
  
 Estimates phase and Phase Plan
  
 and their objectives.
  
 milestone end dates,
  
 milestone
  
 inc. 
  
 elaboration 
  
 construction 
  
 transition
  
 Detailed planning in an
  
 Iteration Plan is like a rolling Iteration Plan
  
 wave that is only highly specific
  
 around the present and the
  
 near future (for example, the
  
  
 next iteration).
  
 Figure 36.2 Phase and Iteration Plans.
  
 During inception, the milestone estimates in the Phase Plan are vague ""guessti-
 mates."" As elaboration progresses, the estimates improve. One goal of the 
 elabo-
  
 581",NA
36.5     Iteration Plan: What to Do in the Next Iteration?,"The UP is use-case driven, which in part implies that work is organized around 
 use-case completion. That is to say, an iteration is assigned to implement one or 
 more use cases, or scenarios of use cases when the complete use case is too com-
 plex to complete in one iteration. And since some requirements are not expressed 
 as use cases, but rather as features, such as logging or pluggable busi-ness rules, 
 these too are allocated to one or more iterations (see Figure 36.3).
  
 A use case or feature is
  
 1
  
 2
  
 3
  
 . . .
  
 often too complex to
  
 complete in one short
  
  
  
  
 iteration.
  
 Therefore, different parts
  
 Use Case
  
 Use Case
  
 Use Case
  
 or scenarios must be
  
 Process Sale
  
 Process Sale
  
 Process Sale
  
 allocated to different
  
  
  
  
 iterations.
  
 Use Case
  
 Feature: 
  
 Logging
  
 Process Rentals
  
  
 Figure 36.3 Work allocated to an iteration.
  
 Usually, the first iteration of elaboration is consumed with myriad overhead tasks 
 such as tool and component installation and tweaking, requirements clar-
 ification, and so forth.
  
 The ranking of requirements guides the choice of early work. For example, the 
 Process Sale 
 use case is clearly important. Therefore, we start to tackle it in the 
 first iteration. Yet, not all scenarios 
 of Process Sale 
 are implemented in the first 
 iteration. Rather, some simple, happy path scenario, such as for a cash-only pay-
 ment, is chosen. Although the scenario is simple, its implementation starts to 
 develop some core elements of the design.
  
 582",NA
36.6     Requirements Tracking Across Iterations,"The task of creating the first Iteration Plan brings us to a noteworthy issue in iterative 
 development, illustrated in Figure 36.3.
  
 As indicated in the last section, not all scenarios 
 of Process Sale 
 will be imple-
 mented in the first iteration. Indeed, this complex use case may take many two-week 
 iterations over a six-month period to complete. Each iteration will tackle new 
 scenarios or parts of scenarios.
  
 When fulfilling all the scenarios of a use case in one iteration is not possible, there 
 arises a problem in requirements tracking. How does one record what parts of a use 
 case are complete, are currently being worked on, or are not yet done? A 
 requirements tool built for the job provides one solution.
  
 Rational's RequisitePro offers an example, and is worth a moment's study to 
 understand how these tools work to track partially completed use cases across 
 iterations. This is not an endorsement of the tool, but the presentation is offered to 
 illustrate one solution to this very important tracking problem.",NA
An Example Requirements Management Tool,"RequisitePro integrates with Microsoft Word so that one may enter and edit 
 requirements in Word, select a phrase, and define the selected phrase as a tracked 
 requirement in RequisitePro.
  
 Each requirement can have a variety of attributes, such as status, risk, and so forth 
 (see Figure 36.4 and Figure 36.5). With such a tool, the problem of tracking partial 
 use case completion across iterations is manageable.
  
 All statements in the main success and extension scenarios can be individually 
 represented as tracked requirements, and each identified with various status values 
 such as 
 proposed, approved, 
 and so on.
  
 583",NA
36.7     The (In)Validity of Early Estimates,"Garbage in, garbage out. Estimates done with unreliable and fuzzy information are 
 unreliable and fuzzy. In the UP it is understood that estimates done during inception are 
 not dependable (this is true of all methods, but the UP acknowl-edges it). Early 
 inception estimates merely provide guidance if the project is worthy of some real 
 investigation in elaboration, to generate a good estimate. After the first elaboration 
 iteration there is some realistic information to pro-duce a rough estimate. After the 
 second iteration, the estimate starts to develop credibility (see Figure 36.6).
  
 Useful estimates require investment in some elaboration iterations.
  
 inc. 
  
 elaboration 
  
 construction
  
  
  
  
 Estimates during inception are 
  
 At the end of 
  
 After two elaboration iterations, 
 not 
 used to commit to project 
  
 elaboration iteration 
  
 and more so by the end, there 
 duration and effort. Rather, they 
  
 1, a believable 
  
  
 has been enough realistic provide guidance to decide if it 
 is 
  
 estimate 
 starts 
 to 
  
 investigation to generate and 
 worth continuing on to 
  
 emerge. 
  
 commit to overall project effort 
 elaboration and doing some 
  
  
  
 and duration estimates. 
 realistic investigation.
  
 Figure 36.6 Estimation and project phases.
  
 This is not to imply that it is impossible or worthless to attempt early, accurate 
 estimates. If possible, very good. However, most organizations do not find this to be 
 the case, for reasons that include continuous introduction of new technolo-gies, novel 
 applications, and many other complications. Thus, the UP advocates some realistic 
 work in elaboration before generating estimates used for project planning and 
 budgeting.",NA
36.8     Organizing Project Artifacts,"The UP organizes artifacts in terms of workflows. The Use-Case Model and Sup-
 plementary Specifications are part of the Requirements discipline. The Software
  
 585",NA
36.9     Some Team Iteration Scheduling Issues ,NA,NA
Parallel Development Teams,"A large project is usually broken into parallel development efforts, where multi-
 ple teams work in parallel. One way to organize the teams is along architectural 
 lines: by layers and subsystems. Another organizational structure is by feature 
 set, which may very well correspond to architectural organization.
  
 586",NA
Teams on Different Iteration Lengths,"Sometimes, developing a subsystem (such as the persistence service) to any 
 meaningfully usable level requires a relatively long time, especially during its 
 early stages. Rather than stretch the overall iteration length for all teams, an 
 alternative is to keep the iterations short (in general, a worthy goal) for most 
 teams, and of double length for the ""slower"" team (see Figure 36.8).
  
  
  
 Iteration
  
 Iteration
  
 Iteration
  
 Domain Layer
  
 User Interface
  
 Team
  
 Team
  
  
 Persistence
  
 Services Team
  
 Figure 36.8 Varying iteration lengths.",NA
Team Speed and Incremental Process Adoption,"In addition to needing longer iterations for massive teams, another reason to 
 lengthen an iteration (for example, from three weeks to four), is related to the 
 speed and experience of the team. A team new to many of the practices or tech-
 nologies will naturally go slower, and needs more time to complete an iteration. 
 Less experienced teams benefit from 
 slightly 
 longer and fewer iterations than 
 more experienced teams.
  
 Note that iterative development provides a mechanism to improve estimating 
 speed: the actual progress in early iterations informs estimates for later ones.
  
 Related to this is the strategy 
 of incremental process adoption. 
 In early iter-
 ations, less experienced teams take on a small set of practices. As the team 
 members digest and master these, add more—assuming they're useful! For 
 example, in early iterations the team may do one daily system build and test. In 
 later iterations, it may adopt continuous integration and system testing (which 
 happens many times each day) with a continuous integration tool such as the 
 open-source Cruise Control (cruisecontrol.sourceforge.net).
  
 587",NA
36.10   You Know You Didn't Understand Planning in the UP ,NA,NA
When...,"•
  
 •
  
 •
  
 All the iterations are speculatively planned in detail, with the work and 
 objectives for each iteration predicted. 
  
 Early estimates in inception or the first iteration of elaboration are expected to 
 be reliable, and are used to make long-term project commitments; to gen eralize, 
 reliable estimates are expected with trivial or light-weight investi gation. 
  
 Easy problems or low-risk issues are tackled in early iterations. 
  
 If an organization's estimation and planning process looks something like the 
 following, planning in the UP was not understood:
  
 1.At the start of an annual planning phase, new systems or features are iden 
  
 tified at a high level; for instance, ""Web system for account management."" 
  
 2.Technical managers are given a short period to speculatively estimate the effort 
 and duration for large, expensive, or risky projects, often involving new 
 technologies. 
  
 3.The plan and budget of projects are established for the year. 
  
 4.Stakeholders are concerned when actual projects do not match original esti 
  
 mates. Go to Step 1. 
  
 This approach lacks realistic and iteratively refined estimation based upon seri-ous 
 investigation as promoted by the UP.",NA
36.11    Further Readings,"Software Project Management: A Unified Framework 
 by Royce provides an itera-
 tive and UP perspective on project planning and management.
  
 Cockburn's 
 Surviving Object-Oriented Projects: A Manager's Guide 
 contains more 
 useful information on iterative planning, and the transition to iterative and object 
 technology projects.
  
 Kruchten's 
 The Rational Unified Process: An Introduction 
 contains useful chap-ters 
 specifically on planning and project management in the UP.
  
 As a caution, there are some books that purport to discuss planning for ""itera-tive 
 development"" or the ""Unified Process"" that actually belie a waterfall or pre-dictive 
 approach to planning.
  
 Rapid Development 
 [McConnell96] is an excellent overview of many practices and 
 issues in planning and project management, and project risks.
  
 588",NA
Chapter,NA,NA
COMMENTS ON ITERATIVE ,NA,NA
DEVELOPMENT AND THE ,NA,NA
UP,"You should use iterative development only on 
  
  
 projects that you want to succeed.
  
 —
 Martin Fowler",NA
Objectives,"•
  
 •
  
 •
  
 Introduce and expand on some UP topics. 
  
 Introduce other practices applicable to iterative development. 
  
 Examine how the iterative lifecycle can help reduce some development 
  
 problems.",NA
37.1     Additional UP Best Practices and Concepts,"The central idea to appreciate and practice in the UP is short timeboxed itera-tive, 
 adaptive development. Some additional best practices and key concepts in the UP 
 include:
  
 • Tackle high-risk and high-value issues in early iterations—
 For exam-
 ple, if 
 the new system is a server application that has to handle 2,000 con-current 
 clients with sub-second transaction response time, do not wait for many months 
 (or years) to design and implement this high risk require-ment. Rather, quickly 
 focus on designing, programming, and proving the essential software 
 components and architecture for this risky issue; leave the easier work till later 
 iterations. The idea is to drive down the high risks in the early iterations, so that 
 the project does not ""fail late,"" which is a char-acteristic of waterfall projects that 
 defer hard, risky concerns till later in the lifecycle. Better to ""fail early"" if at all, 
 by doing the hard things first. Thus, the UP is said to be 
 risk driven. 
 Finally, 
 notice that risk comes in many
  
 589",NA
37.2     The Construction and Transition Phases,NA,NA
Construction,"Elaboration ends when the high risk issues have been resolved, the architec-tural core 
 or skeleton is complete, and ""most"" requirements are understood. At the end of 
 elaboration, it is possible to more realistically estimate the remaining effort and 
 duration for the project.
  
 It is followed by the 
 construction phase, 
 whose purpose is essentially to finish 
 building the application, alpha testing, prepare for beta testing (in the transi-tion 
 phase), and prepare for deployment, through activities such as writing the user guides 
 and online help. It is sometimes summarized as putting the ""flesh on the skeleton"" 
 created in elaboration. Whereas elaboration can be character-
  
 1. It is also a motivation for the use of color in diagramming (unless some team 
 members 
  
 have a color blindness). For example, see [CDL99].
  
 591",NA
Transition,"Construction ends when the system is deemed ready for operational deploy-ment, 
 and all supporting materials are complete, such as user guides, training materials, and 
 so on. It is followed by the 
 transition phase, 
 whose purpose is to put the system into 
 production use. This may include activities such as beta testing, reacting to beta test 
 feedback, fine-tuning, data conversion, training, marketing roll-out, parallel 
 operation of the old and new system, and the like.",NA
37.3     Other Interesting Practices,"This is not an exhaustive list, but some interesting practices—not explicitly doc-
 umented in the UP—that have been of value on iterative projects include:
  
 •
  
 •
  
 • 
  
 The SCRUM 
 process pattern [BDSSSOO]; see also www.controlchaos.com. 
 The most concrete is a daily ""15-minute"" stand-up SCRUM meeting. The 
 project coach asks from each person: 1) items done since last meeting; 2) goals 
 for next day; and 3) blocks for the coach to remove. I've also asked each 
 member for noteworthy insights he or she want to share with the team. The 
 meeting promotes adaptive, emergent team behavior, fine-grained measure 
 ment of progress, high density communication, and project socialization. Other 
 key ideas include: The team is freed of all external distractions, has no 
 additional work added (from outside the team) during an iteration, and 
 management's job is to remove all blocks and distractions, so the team can 
 focus.
  
 Some 
 Extreme Programming 
 (XP) [BeckOO] practices, such as 
 test-first 
 programming: 
 Write a unit test 
 before 
 the code to be tested, and write tests for 
 virtually all classes. If working in Java, 
 JUnit 
 (www.junit.org) is a popular, free 
 unit testing framework. Write a little test, write a little code, make it pass, repeat. 
 Writing the test 
 first 
 is essential to experience the value of this approach.
  
 Continuous integration, 
 another XP practice; see [BeckOO] for an intro duction 
 and www.martinfowler.com for details. The UP includes the best- practice of 
 integrating the entire system at least once every iteration. This is often shortened 
 to the practice of a 
 daily build. 
 Continuous 
 integration shortens this still further, 
 integrating all new checked-in code (at least) every few hours. Although this can 
 be done manually, an alternative is to
  
 592",NA
37.4     Motivations for Timeboxing an Iteration,"There are at least four motivations for timeboxing an iteration.
  
 First, 
 Parkinson's law. 
 Parkinson wryly observed that ""Work expands so as to fill 
 the time available for its completion"" [Parkinson58]. Distant or 
 fuzzy 
 comple-tion 
 dates (for example, six months away), exacerbate this effect. Near the start of a 
 project, it can feel like there is plenty of time to proceed leisurely. But if the end date 
 for the next iteration is only 
 two weeks 
 away, and an executable, tested partial system 
 must be in place on that date, the team has to focus, make deci-sions, and get moving.
  
 Second, 
 prioritization and decisiveness. 
 Short timeboxed iterations force a 
 development team to make decisions regarding the priority of work and risks, 
 identify what is of highest business or technical value, and estimate some work. For 
 example, if embarking on the first iteration, chosen to be exactly four weeks in 
 length, there is not much latitude to be vague—concrete decisions about what will 
 really be done within the first four weeks must be made.
  
 Third, 
 team satisfaction. 
 Short timeboxed iterations lead to a quick and repeating 
 sense of completion, competency, and closure. On regular two- or four-week cycles, 
 the team has the experience of finishing something, rather than work lingering on for 
 months without completion. These psychological factors are important for individual 
 work satisfaction, and for building team confidence.
  
 Fourth, 
 stakeholder confidence. 
 When a team makes a public commitment to 
 producing something executable and stable within a short time period, on a par-
 ticular date, such as two weeks in the future, and does so, business and other 
 stakeholders develop increased confidence in the team and the project.",NA
"37.5     The Sequential ""Waterfall"" Lifecycle","In contrast to the iterative lifecycle of the UP, an old alternative is the sequential, 
 linear, or ""waterfall"" lifecycle [Royce70], associated with heavy and predictive 
 processes. In common usage, a waterfall lifecycle defines steps similar to the 
 following:
  
 1.
  
 2. 
  
 Clarify, record, and commit to a set of final requirements. 
 Design a system based on these requirements.
  
 593",NA
Some Problems with the Waterfall Lifecycle,"The building metaphor has outlived its usefulness. It is time to 
 change again. If, as I believe, the conceptual structures we con-
 struct today are too complicated to be accurately specified in 
 advance, and too complex to be built faultlessly, then we must 
 take a radically different approach (iterative, incremental 
 development).
  
 —
 Frederick Brooks, ""No Silver Bullet,"" The Mythical Man-Month
  
 Within a certain time scale, doing some requirements before design, and some 
 design before implementation, is inevitable and sensible. For a short two month 
 project, a sequential lifecycle is workable. And a single iteration in iterative 
 development is like a short waterfall project.
  
 However, difficulties start to arise as the time scale lengthens. The complexity 
 becomes high, speculative decisions increase and compound, there is no feed-
 back, and in general high risk issues are not being tackled early enough. By def-
  
 594",NA
Mitigation of Some Problems with the Waterfall Lifecycle,"Iterative development is not a magic bullet for the challenges of software devel-
 opment. Yet, it offers support to reduce some problems exacerbated by a linear 
 waterfall lifecycle.
  
 Problem: Delayed Risk Mitigation
  
 Risks come in many forms: the wrong design, the wrong set of requirements, a 
 strange political environment, lack of skills or resource, usability, and so forth.
  
 In a waterfall lifecycle, there is 
 not 
 an active attempt to identify and mitigate the 
 riskiest issues first. As an example, the wrong architecture for a high-load high-
 availability website can cause costly delays, or worse. In a waterfall pro-cess, 
 validation of the architecture's suitability happens 
 long 
 after all require-ments and 
 all design are specified (inevitably imperfectly), during the later major step of 
 implementation. This could be many months or even years after inception of the 
 project (see Figure 37.1). And there is no shortage of stories where separate teams 
 have built subsystems over a long period, and then attempted to integrate these 
 and start overall system testing near the end of the project—with predictably 
 painful results.
  
 595",NA
37.6     Usability Engineering and User Interface Design,"There is probably no skill with a greater disparity between its importance to 
 successful software and its lack of formal attention and education than 
 usabil-ity 
 engineering 
 and user interface (UI) design. Although outside the scope of this 
 introduction to OOA/D and the UP, note that the UP does include recogni-tion of this 
 activity; usability and UI models are part of the Requirements disci-pline. In UP 
 terminology, 
 use-case storyboards 
 can be used to abstractly describe the interface 
 elements, and the navigation between them, as related to use-case scenarios.
  
 Useful books include 
 Software for Use 
 by Constantine and Lockwood, 
 The Usability 
 Engineering Lifecycle 
 by Mayhew, and 
 GUI Bloopers 
 by Johnson.",NA
37.7     The UP Analysis Model,"The UP contains an artifact called the 
 Analysis Model; 
 it is not necessary, and few 
 create it. The 
 Analysis Model 
 is perhaps not ideally named, as it is actu-ally a kind of 
 design model. In conventional usage (for example, see [Cole-man+94, MO95, 
 Fowler96]), an analysis model suggested essentially a domain object model—an 
 investigation and description of domain concepts. 
  
 But the UP
  
 599",NA
37.8     The RUP Product,"The RUP product is a cohesive and well-crafted Web-based documentation set 
 (HTML pages) sold by Rational Software that describes the Rational Unified 
 Process, an updated and detailed refinement to the more general UP. It describes all 
 artifacts, activities, and roles, provides guidelines, and includes templates for most 
 artifacts (see Figure 37.4).
  
  
 Figure 37.4 The RUP product.
  
 The UP can be applied or adopted with the aid of process mentors and books; the 
 basic ideas, such as iterative development, are described in this and other books.
  
 600",NA
37.9     The Challenge and Myths of Reuse,"The UP is developed with object technology (OT) projects in mind, and the adop-tion 
 of OT has often been promoted in order to achieve software 
 reuse. 
 Signifi-cant reuse 
 is a laudable goal, but difficult. It is a function of much more than adopting OT and 
 writing classes; OT is but one enabling technology in a suite of technical, 
 organizational, and social changes that have to occur to see meaning-ful reuse. 
 Certainly, libraries of classes for technical services, such as the Java technology 
 libraries, provide a great example of reuse, but I am referring to the difficulty of 
 reuse of code created within an organization, not core libraries.
  
 In a survey of organizations that had adopted OT, they were asked the actual value of 
 its adoption. Interesting, reuse was at the 
 bottom 
 of the list |Cutter97|. Among 
 experienced OT practitioners and organizations, this is not a surprise: They know that 
 the popular press's description of OT for reuse is to some degree a myth; most 
 organization see little of it. This is not to imply it isn't a valuable goal, or that there is 
 no reuse—it is worthy, and there has been some. But not the high levels of reuse 
 some articles and books suggest. And many an experi-enced OT developer can tell 
 you a war story about the misguided large-scale attempt by an organization to create 
 the grand ""reusable libraries"" or services for the company, spending a year and 
 million dollars, and ending with a failed project, or one that misses the mark. Reuse 
 is hard, and arguably more a func-tion of social and organizational issues than 
 technical ones.
  
 Does this mean OT is without value? Not at all, but its value has been incor-rectly 
 associated primarily with reuse, rather than how it most prominently helps in 
 practice: flexibility, ease of change, and complexity management. The same survey 
 [Cutter97] lists the top values actually experienced by adopting OT: easier 
 application maintenance and cost savings. Object systems—if designed well—are 
 relatively easier or faster to modify and extend, than if using non-OT technologies. 
 This is important; many organizations find that the major-ity of the overall long-term 
 cost of an application is in revision and maintenance, not original development, and 
 thus, strategies to reduce revision costs are important. Although it is rational to want 
 to reduce new system development costs, there is a certain irony that few 
 stakeholders ask the follow-up question, ""How can we reduce the cost to revise and 
 maintain it?"" when that is often the largest expense. It is here that OT can make a 
 contribution, in addition to its power and elegance in tackling complex systems.
  
 601",NA
Chapter,NA,NA
MORE UMLNOTATION,NA,NA
38.1     General Notation,NA,NA
Stereotypes and Property Specifications with Tags,"Stereotypes are used in the UML to classify an element (see Figure 38.1). 
  
  
 Figure 38.1 Stereotypes and properties.
  
 603",NA
Package Interfaces,A package can he illustrated as implementing an interface (see Figure 38.2).,NA
Dependency ,"Dependencies can exist between any elements, but they are probably most often 
 used in UML package diagrams to illustrate package dependencies (see Figure 38.3)
  
  
 Figure 38.3 Dependencies.",NA
38.2     Implementation Diagrams,"The UML defines several diagrams that can be used to illustrate implementa-tion 
 details. The most commonly used is a deployment diagram, to illustrate the 
 deployment of components and processes to processing nodes.
  
 604",NA
Component Diagrams,"To quote: A 
 component 
 represents a modular, deployable, and replaceable part 
 of a system that encapsulates implementation and exposes a set of interfaces 
 [OMG01]. It may, for example, be source code, binary, or executable. Examples 
 include executables such as a browser or HTTP server, a database, a DLL, or a 
 JAR file (such as for an Enterprise Java Bean). UML components are usually 
 shown within deployment diagrams, rather than on their own. Figure 38.4 illus-
 trates some common notation.
  
  
 Figure 38.4 UML components.",NA
Deployment Diagrams ,"A deployment diagram shows how instances of components and processes are 
 configured for run-time execution on instances of processing 
 nodes 
 (something 
 with memory and processing services; see Figure 38.5).
  
 605",NA
"38.3     Template (Parameterized, Generic) Class","Template classes and their instantation are shown in Figure 38.6. 
  
  
 Figure 38.6 Template classes.
  
 606",NA
38.4     Activity Diagrams,"A UML activity diagram 
 offers rich notation to show a sequence of activities. It may 
 be applied to any purpose (such as visualizing the steps of a computer algorithm), but is 
 considered especially useful for visualizing business work-flows and processes, or use 
 cases. One of the UP workflows (disciplines) is 
 Busi-ness Modeling; 
 its purpose is to 
 understand and communicate ""the structure and the dynamics of the organization in 
 which a system is to be deployed"" [RUP]. A key artifact of the Business Modeling 
 discipline is the 
 Business Object Model 
 (a superset of the UP Domain Model), which 
 essentially visual-izes how a business works, using UML class, sequence, and activity 
 diagrams. Thus, activity diagrams are especially applicable within the Business 
 Modeling discipline of the UP.
  
 Some of the outstanding notation includes parallel activities, swimlanes, and action-
 object flow relationships, as illustrated in Figure 38.7 (adapted from [OMGOl, FS00]). 
 Formally, an activity diagram is considered a special kind of UML statechart diagram 
 in which the states are actions, and event transition is automatically triggered by action 
 completion.
  
 607",NA
BIBLIOGRAPHY,"Abbot83 Abbott, R. 1983. Program Design by Informal English Descriptions. 
 Communications of the ACM 
 vol. 
 26(11).
  
 AIS77 Alexander, C., Ishikawa, S., and Silverstein, M. 1977. A 
 Pattern 
  
 Language
 —
 Towns-Build-ing-Construction. 
 Oxford University Press.
  
 Ambler00   Ambler, S. 2000. 
 The Unified Process—Elaboration Phase. 
 Lawrence, KA.: R&D Books
  
 Ambler00a Ambler, S., Constantine, L. 2000. Enterprise-Ready Object IDs. 
 The Unified Process— 
  
 Construction Phase. 
 Lawrence, KA.: R&D Books
  
 Ambler00b Ambler, S. 2000. Whitepaper: 
 The Design of a. Robust Persistence, Layer For Relational 
 Databases, 
 www.ambysoft.com.
  
 BDSSS00 Beedle, M., Devos, M., Sharon, Y., Schwaber, K., and Sutherland, J. 2000. SCRUM: A Pat-tern 
 Language for Hyperproductive Software Development. 
 Pattern Languages of Pro-gram Design 
 vol. 4. Reading, MA.: Addison-Wesley
  
 BC87 Beck, K., and Cunningham, W. 1987. 
 Using Pattern Languages for Object-Oriented Pro-
  
 grams. 
 Tektronix Technical Report No. CR-87-43.
  
 BC89 Beck, K., and Cunningham, W. 1989. A Laboratory for Object-oriented Thinking. 
 Proceed-
  
 ings of OOPSLA 89. 
 SIGPLAN Notices, Vol. 24, No. 10.
  
 BCK98 Bass, L., Clements, P., and Kazman, R. 
 Software Architecture in Practice. 
 Reading, MA.: 
  
 Addison-Wesley.
  
 Beck94  Beck, K. 1994. Patterns and Software Development. 
 Dr. Dobbs Journal. 
 Fob 1994.
  
 Beck00 Beck, K. 2000. 
 Extreme Programming Explained,
 —
 Embrace Change. 
 Reading, MA.: Addi-
  
 son-Wesley.
  
 BF00 Beck, K., Fowler, M., 2000. 
 Planning Extreme Programming. 
 Reading, MA.: 
  
 Addison-Wos-ley.
  
 BJ78 Bj0rner, D., and Jones, C. editors. 1978. The Vienna Development Method: The 
  
 Meta-Language, 
 Lecture Notes in Computer Science, 
 vol. 61. Springer-Verlag.
  
 BJR97 Booch, G., Jacobson, L, and Rumbaugh, J.  1997. The UML specification documents. Santa Clara, 
 CA.: Rational Software Corp. See documents at www.rational.com.
  
 BMRSS96 Buschmann, F, Meunier, R., Rohnert, H., Sommerlad, P.,and Stal, M. 1996. 
 Pattern-Ori-
  
 ented Software Architecture: A System of Patterns. 
 West Sussex, England: Wiley
  
 Boehm88 Boehm. B. 1988. A Spiral Model of Software Development and Enhancement. 
 IEEE Com-
  
 puter. 
 May 1988.
  
 609",NA
GLOSSARY,"abstract class 
  
 abstraction
  
 active object 
  
 aggregation
  
 analysis 
  
 architecture
  
 association
  
 attribute
  
 A class that can be used only as a superclass of some other class; no objects of an 
 abstract class may be created except as instances of a subclass.
  
 The act of concentrating the essential or general qualities of similar things. Also, the 
 resulting essential characteristics of a thing.
  
 An object with its own thread of control.
  
 A property of an association representing a whole-part relationship and (usually) life-
 time containment.
  
 An investigation of a domain that results in models describing its static and dynamic 
 characteristics. It emphasizes questions of ""what,"" rather than ""how.""
  
 Informally, a description of the organization, motivation, and structure of a system. 
 Many different levels of architectures are involved in developing software systems, 
 from physical hardware architecture to the logical architecture of an application 
 framework.
  
 A description of a related set of links between objects of two classes. 
  
 A named characteristic or property of a class.
  
 class
  
 class attribute
  
 class hierarchy 
  
 class method
  
 classification 
  
 collaboration
  
 In the UML, ""The descriptor of a set of objects that share the same attributes, 
 operations, methods, relationships, and behavior"" [RJB99]. May be used to represent 
 software or conceptual elements.
  
 A characteristic or property that is the same for all instances of a class. This information 
 is usually stored in the class definition.
  
 A description of the inheritance relations between classes. 
  
 A method that defines the behavior of the class itself, as opposed to the behavior of its 
 instances.
  
 Classification defines a relation between a class and its instances. The classification 
 mapping identifies the extension of a class.
  
 Two or more objects that participate in a client/server relationship in order to provide a 
 service.
  
 615",NA
INDEX,"abstract class 407 abstract 
  
 conceptual class 406 Abstract 
  
 Factory 525 abstract use case 
  
 388 activation box 208 active 
  
 class 5 12 active object 5 12 
  
 activity diagram 607 actor 47, 
  
 68 
  
  
   
 offstage 70 
  
  
     
 primary 70 
  
  
    
 supporting 70 Adapter 342 
  
 adaptive development   16 adaptive 
  
 process 24 adaptive vs. predictive 
  
 planning 579 addition use case 389 
  
 aggregation  228,414 
  
  
  
 composite 415 
  
  
  
 shared 416 
  
 agile process 24 
  
 agile UP 24 
  
 analysis 6 analysis 
  
 and design 
  
  
 definition 6 Analysis 
  
 Model  599 analysis object 
  
 models   128 analysis 
  
 patterns   I 33 
  
 architectural 
  
  
  
 analysis 448,486,487 
  
  
 baseline   109 
  
 decisions 487 
  
  
 design 448 
  
 design principles 496 
  
  
  
 factors 487, 488 
  
  
 investigation 448 
  
  
 patterns 449 
  
  
 patterns-promotion of 499 
  
  
  
 proof-of-concept 504 
  
  
  
 prototype   109 
  
 synthesis 504 
  
 view 501 
  
  
       
 data 502 deployment 
  
  
       
 502 implementation 
  
  
       
 502 logical  501 
  
  
       
 process 502 use case 
  
  
       
 502 
  
 architectural approach documents 493 
  
 architecturally significant requirements 488
  
 architecture 448 
  
  
       
 cross-cutting concerns 497 
  
  
       
 factor table 490 
  
  
       
 issue cards 493 
  
  
      
 layered 450 
  
  
       
 separation of concerns 497 
  
  
      
 technical memos 493 
  
  
     
 type 488 
  
  
      
 views 488 
  
 architecture-centric 590 
  
 artifacts 20 
  
  
     
 organizing 585 
  
 aspect-oriented programming 498 
 association   153 
  
  
     
 criteria for useful   154 
  
  
      
 emphasize need-to-know   163 
  
     
 finding with list   155 
  
  
     
 guidelines   1 57 
  
  
     
 high-priority ones   157 
  
  
    
 level of detail   159 
  
  
     
 link 202 
  
  
    
 multiple between types   161 
  
     
 multiplicity  158 
  
  
    
 naming   160 
  
  
   
 navigability 291 
  
  
    
 qualified 422 
  
  
   
 reflexive 423 
  
  
   
 role names 419 
  
  
   
 UML notation  154 
  
 association class 41 3 
  
 asynchronous message 5 16 
  
 attribute   167 
  
  
    
 and quantities   173 
  
  
   
 data type   168, 170 
  
  
   
 derived   175,421 
  
  
   
 no foreign keys   172 
  
  
  
 non-primitive types   170 
  
  
   
 simple   168 
  
  
  
 UML notation   168 
  
  
 valid types   168",NA
B,"base use case 388 
  
 behavior 
  
  
 class 216 
  
  
  
 system   1 1 8 
  
 behavioral decomposition  33 1 
  
 benefits of iterative development 
  
 17 black-box use cases 49 boundary 
 objects 240 brief use case 49",NA
D,"daily build 592 
  
 data dictionary 43, 99 
  
 data holder objects 463 
  
 Data Model  541 
  
 data modeling 541 
  
 data models 541 
  
 data type   168, 170 
  
 data view 502 
  
 data-driven design  348 
  
 DCD 286 
  
 Delegation Event Model  372 
  
 dependency relationship 295, 604 
  
 deployment diagram 605 
  
 deployment view 488, 502 
  
 derived attribute   175 
  
 design 6 
  
 speculative 567 Design 
  
 by Contract   188, 191 
  
 design class   145, 146 
  
 design class diagram   10, 
  
 286
  
 622",NA
E,"eager initialization  351 
  
 EBP 60 
  
 elaboration   19, 107 elementary 
 business process 60 engage users 590 
 entity objects 240 
  
 Environment discipline 21 error 
 definition 514 essential use case style 
 68 estimates 585 estimation 585 
 event 437 
  
   
   
 external 443 
  
   
   
 internal 443 
  
   
  
 temporal 443 evolution 
  
 point 338, 496 exceptions in 
  
 UML 515 executable 
  
 architecture   109 Expert 221 
  
   
 application 257, 260, 262 
  
 extend use case relationship 389 
 extension   I 3 I extension point 389 
 Extreme Programming 27, 592
  
 Facade 368 factor table 490 
  
 Factory 346 failure 
  
 definition 514 fault 
  
 definition 514 feature of 
  
 system 96 focus of control 
  
 208 forward-engineering 571 
  
 framework 539 
  
  
 persistence 538 fully 
  
 dressed use case 49 
  
 functional requirements 43",NA
G,"Gang of Four patterns 342 
  
 generalization 396 
  
  
   
 abstract class notation 407 
  
  
   
 and conceptual class sets 398 
  
  
   
 and conceptual classes 397 
  
  
   
 conformance 399 
  
  
   
 overview 396 
  
  
   
 partitioning 401 
  
  
   
 subclass validity tests 400 
  
  
 UML notation 397 
  
 generic class 606 Glossary 
  
 artifact 83, 98, 99 GRASP 
  
 patterns 
  
  
   
 Controller 237 
  
  
   
 Creator 226 
  
  
 Expert 221 
  
  
 High Cohesion 232 
  
  
   
 Indirection 332 
  
  
 Low Coupling 229 
  
 Polymorphism  326 
  
  
 Protected Variations 334 
  
  
 Pure Fabrication 329 
  
 guarded methods 55 1",NA
H,"heavy process 24 High 
  
 Cohesion 232 Hollywood 
  
 Principle 539
  
 idioms 449 implementation 
  
 21 implementation class 
  
 146 implementation diagram 
  
 604 Implementation Model 
  
 476 implementation view 
  
 502",NA
N,"navigability 291 
  
 nodes 605 
  
 non-functional requirements 43 
 Supplementary Specification 
 notes in UML 261
  
 84",NA
o,"object 
  
  
 active 512 
  
  
 in UML 201 
  
  
 lifelines 210 
  
  
 persistent 538 object-oriented 
 analysis 7 object-oriented analysis 
 and design 
  
  
  
 definition 7 
  
  
  
 dice game example 7 
  
 object-oriented design  7 
  
 Observer 372 OCL  187,261 
  
 offstage actor 70 Open-Closed 
  
 Principle 339 operation 
  
 specification   1 87 operations 
  
 186 organizing artifacts 585
  
 JUnit 592
  
 layered architecture 450 
  
 lazy initialization 350 
  
 link 202 
  
 Liskov Substitution Principle 335 
 logical view 488,501 
  
 Low Coupling 229 
  
 LSP 335",NA
M,"message 
  
 asynchronous 5 16 
  
 UML notation  202. 
  
 208 
  
 metadata 99, 545 
  
 method   187 
  
  
 from collaboration diagram 307 
 Model-View Separation 256,471 
 modular designs 235 
  
 Moment-Interval 419 
  
 multiobject 207 
  
 multiplicity   158
  
 package 371 
  
  
  
 dependencies 424 
  
  
  
 interface 604 
  
  
  
 notation 482 
  
  
  
 organization guidelines 476 
  
  
  
 ownership 424 
  
  
  
 reference 424 
  
  
 UML notation 423 
  
 parameterized class 606 
  
 path name 456 pattern 
  
 4,218 
  
  
  
 Abstract Factory 525 
  
  
 Adapter 342 
  
  
   
 Command 535 
  
  
   
 Composite 358 
  
  
   
 Controller 237 
  
  
   
 Convert Exceptions 5 15 
  
  
   
 Creator 226 
  
  
  
 Do It Myself 225, 326, 528 
  
  
  
 Expert 221 
  
  
  
 Facade 368 
  
  
  
 Factory 346 
  
  
  
 High Cohesion 232 
  
  
  
 Indirection 332 
  
  
  
 Layers 450
  
 624",NA
Q,"qualified association 422 
  
 qualifier 422 
  
 quality 
  
 continuous verification 590 
  
 quality attributes 43, 89 quality 
  
 scenario 489",NA
R,"ranking requirements 576 
  
 ranking risk 579 
  
 Rational Unified Process   13 
  
 Redirection Proxy 520 
  
 reference attribute 305, 356 
  
 reflexive association 423 
  
 relational cohesion 477 
  
 Remote Proxy 519 
  
 replicates 463 
  
 representational decomposition  331 
  
 representational gap   146 
  
 requirements 41 
  
  
   
 functional in Use-Case Model 45 
  
  
   
 management 591 
  
  
   
 non-functional in Supplementary Specification 
  
  
  
 84 
  
  
   
 overview 41 
  
  
   
 ranking 576 
  
  
  
 tracking 583 
  
 Requirements discipline 20 
  
 responsibilities 216 
  
  
   
 and interaction diagrams 217 
  
  
   
 and methods 216 
  
  
  
 doing 216 
  
  
   
 importance of 6 
  
  
  
 knowing 216 
  
  
  
 patterns 218 
  
 Responsibility-Driven Design  246 
  
 return in sequence diagram 209 
  
 reuse 601 
  
 reverse-engineering 303,571 
  
 risk 579 
  
 risk-driven development 589 
  
 role  157 
  
  
  
 name 306 
  
  
 versus concept 420 
  
 RUP  13 
  
  
 product 600
  
 625",NA
s,"SAD 500 
  
 scenario 47 
  
 scheduling issues 586 
  
 schema mapping 540 
  
 SCRUM 592 
  
 separation of concerns 346,497 
  
 sequence diagram   118, 198 
  
  
  
 activation box 208 
  
  
 conditional message 21 I 
  
  
  
 instance creation 210 
  
  
  
 iteration 21 1 
  
  
  
 iteration over a message series 212 
  
  
  
 iteration over collection 212 
  
  
 lifelines 210 
  
  
  
 message to class 212 
  
  
  
 message to self 209 
  
  
  
 messages 208 
  
  
  
 mutually exclusive conditional 211 
  
  
 object destruction 210 
  
  
 return 209 simple 
  
 attribute   168 
  
 Singleton 348 
  
  
  
 UML shorthand notation  350 
  
 software architecture 448 Software 
  
 Architecture Document 500 software 
  
 class   146 Software Development Plan 
  
 1 12 software development process 
  
 13 specialization 396 state 437 
  
  
   
 modeling 408 State 
  
 pattern 186 statechart 
  
 diagram 438 
  
  
 example 441 
  
  
 for use case 439 
  
  
 guard conditions 444 
  
  
 nested states 444, 445 
  
 overview 437 
  
 transition actions 444 
  
 state-independent 441 
  
 static methods 207 
  
 stereotype 72, 327, 603 
  
 Strategy 353 structured 
  
 analysis   132 subclass 
  
 363 
  
  
 conformance 399 
  
  
 creating 400 
  
  
 partitioning 401 
  
  
 validity tests 400 
  
 subfunction goal 62 
  
 superclass 
  
  
 creating 403 
  
 Supplementary Specification artifact 83, 84, 88 
 supporting actor 70 SWEBOK 44
  
 symbol   131 
  
 synchronized methods 55 1 
  
 system behavior  1 18 
  
  
  
 overview   1 18 
  
 system boundary   120 
  
 system event 237 
  
  
 naming  121 system 
  
 feature 96 system operation 237 
 system operations   178 system 
 sequence diagram   I 18 
  
  
 showing use case text  122 
 system use cases 75
  
 technical memos 493 template 
  
 class 606 Template Method 546 test-
 first programming 311, 592 threads 
 in the UML 5 12 three-tier 
 architecture 470 tier 466 
  
 time intervals 418 
  
 timeboxing  18 
  
  
 motivation 593 
  
 transition  19,438, 
  
 592",NA
u,"UI design 599 
  
 UML  10 
  
  
   
 CASE tools 571 
  
  
   
 Data Modeling Profile 541 
  
  
  
 drawing suggestions 568 
  
  
  
 overview   10 
  
  
  
 profile 542 
  
  
  
 profiles 541 
  
  
 visual modeling 590 
  
 Unified Process   13 UP 
  
 13 
  
  
   
 agile 24 
  
  
  
 best practices and concepts 589 
  
  
 phases   19 
  
 usability engineering 599 
  
 use case 47 
  
  
   
 abstract 388 
  
  
   
 addition 389 
  
  
  
 and development process 75 
  
  
 base 388 
  
  
  
 black-box 49 
  
  
  
 brief 49 
  
  
  
 business 75 
  
  
  
 casual 49 
  
  
  
 concrete 388 
  
  
  
 elementary business process 60
  
 626",NA
V,"value objects 
  
 170,463 variation 
  
 point 338 Virtual 
  
 Proxy 559 visibility 
  
 258, 280 
  
  
  
 attribute  281 
  
  
 global  283 
  
  
  
 local  282 
  
  
  
 parameter 282 
  
 visibility defaults in UML 296 
  
 Vision artifact 83,91,93 
  
 visual modeling 590 visual 
  
 thinking 567",NA
w,"waterfall lifecycle 25, 593 
  
  
  
 mitigation of problems with iterative 595 
  
  
 problems 594 whitebox 
  
 frameworks  546 workflow 
  
 20 
  
 and discipline 20",NA
X,"XP 27, 68, 592
  
 627",NA
