Larger Text,Smaller Text,Symbol
The Coder’s Apprentice ,NA,NA
Learning Programming with Python 3,NA,NA
Pieter Spronck,NA,NA
The Coder’s Apprentice ,NA,NA
Learning Programming with Python 3,NA,NA
Pieter Spronck,"Version 
 1.0.16 
  
 November 11, 
 2017",NA
Preface,"Computational technology causes the world to change rapidly.
  
 Almost 30 years ago I got my first job as a computer programmer. At the time, only larger 
 companies with a big administrative overload used computers. Or rather, “a 
 computer,”because it was rare for a company to have more than one. There were no 
 personal comput-ers, no Internet, no mobile phones. People still used typewriters.
  
 In those 30 years, the way people work and live has undergone huge changes. That is ex-
 ceptionally clear when looking at the kind of work that people do. Mailmen, for instance, 
 delivered the mail twice per day when I was a kid – now they deliver mail twice per week, 
 which means that the contingent of professional mailmen has been decimated. Bank of-fices 
 are closed because banking can be done much easier online. Information desks can be 
 manned by digital avatars or be replaced by online information systems. Large de-partment 
 stores go out of business because people make their purchases online, leading to an 
 enormous decline in the need for having salespeople. And though this has currently caused a 
 small increase in the demand for people who work in transportation, we can see self-driving 
 cars on the horizon, replacing the need to have any chauffeurs at all.
  
 These are all “low profile” jobs, but “high profile” jobs aren’t safe either. I have taught 
 programming to professional journalists, who told me that computers are taking over large 
 parts of their jobs, writing basic articles and doing automated background research – they 
 wanted to take my courses because they realized that without skills in digital technology, 
 they would be out of a job in a few years time. Programs have been developed that take over 
 a menial but oh-so time consuming part of lawyers’ jobs, namely researching case histories. 
 Computers can write music, produce paintings, and even sculpt – why would you have 
 someone hammer away at a block of granite for six months when a 3D-printer can produce a 
 sculpture with a few hours of work? Even designing and running scientific experiments has 
 been offloaded to computers in some research domains.
  
 In the 30 years in which I have been a professional worker, I have seen the job market 
 change from hardly incorporating computers at all, to a situation in which the need for 
 human employees has been reduced considerably – regardless the job. And that change has 
 not come to an end yet.
  
 This does not mean that there is no place for humans in the job market. It does mean, 
 however, that only humans who can make contributions that a computer has a hard time 
 making on its own, can be assured of a job. In the near future, employability will be invari-
 ably linked to the ability to integrate the power of humans and computers in a way that 
 enhances both of them.
  
 The problem is that to be able to use computers to improve the quality of one’s work, it does 
 not suffice to be able to use a word processor or spreadsheet. One should actually be able to",NA
Acknowledgments,"Many thanks to Allen B. Downey, who wrote the excellent Python 2 book
  Think Python: How 
 to Think Like a Computer Scientist
 . I myself learned Python programming from his book, and 
 used the L
 A
 TEX template that he graciously provided as the basis for this book. Downey 
 recently released a Python 3 version of his book. If you are already familiar with",NA
Contributor list,"• “oajns” indicated some spelling mistakes in Chapter 9 and in Appendices C and D 
  
 (fixed in version 1.0.4).
  
 • Larry Cali pointed out an error in the code for Exercise 4.3, which could give prob-lems 
 with floating-point values which Python cannot store exactly. I fixed the exercise and 
 made a remark on this in Chapter 3 (fixed in version 1.0.5).
  
 • Isaac Kramer noted a problem in Exercise 9.5, which made the issue in the code un-
 noticable. I fixed this to make the error actually occur as I explain in the Answers 
 section (fixed in version 1.0.6).
  
 • Ruud van Cruchten indicated that my discussion of providing multi-line commen-tary in 
 Chapter 4 was incomplete and could lead to problems. I have extended the text in this 
 respect (fixed in version 1.0.7).
  
 • Nade Kang pointed out that the answer to Exercise 7.9 (second guessing game) could 
  
 be confusing. I changed the code a little to compensate (fixed in version 1.0.7).
  
 • Shiyu Zhang noticed that listing 8.16 contained useless parameters. I corrected this 
  
 (fixed in version 1.0.8).
  
 • Mustafa Amjed indicated several spelling and logical mistakes in the first 100 pages 
  
 (fixed in version 1.0.8).
  
 • Woodgirl Martyr indicated a spelling mistake in Chapter 1 (fixed in version 1.0.9).",NA
Contents,"Preface 
  
 v
  
 1
  
 Introduction
  
 1
  
 2
  
 1.1
  
 How to use this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 1.2
  
 Prerequisites and assumptions
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
  
 1.3
  
 Why Python?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.4
  
 Python’s limitations as a programming language . . . . . . . . . . . . . . .
  
 4
  
 1.5
  
 What does it mean “to think like a programmer?”
  
 . . . . . . . . . . . . . .
  
 4
  
 1.6
  
 The art of programming
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5
  
 1.7
  
 Start small, grow big
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.8
  
 Python 2 or Python 3?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.9
  
 Practice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 Using Python
  
 11
  
 3
  
 2.1
  
 Getting Python
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 2.2
  
 Creating Python programs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 2.3
  
 Running Python programs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.4
  
 Reference material . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 Expressions
  
 15
  
 3.1
  
 Displaying results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 3.2
  
 Data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 3.3
  
 Expressions
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 3.4
  
 Style . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21",NA
Chapter 1,NA,NA
Introduction,"Computers are wonderful machines. While most machines (cars, television sets, mi-
 crowaves) have a specific purpose which they excel at accomplishing, computers are pur-
 poseless machines that can be taught to accomplish anything. The power to make a com-
 puter do your bidding is called “programming.”
  
 Nowadays, in any scientific and professional endeavor, people have to deal with large 
 volumes of data. Those who are able to leverage the power of computers to make use of such 
 data, i.e., those who can program, are far better able to do their jobs than those who are not. 
 In fact, it can be argued that in the very near future, those who do not possess programming 
 skills will become unemployable. Therefore, I feel that it is necessary for anyone to acquire 
 basic skills in this area during their education.
  
 Being able to write computer programs not only entails knowing what specific code state-
 ments mean and do; it also entails having the ability think like a programmer, and to ana-
 lyze problems from the perspective of solving them with a computer program. Such skills 
 cannot be learned from a book, they can only be learned by actually creating programs.
  
 This book has been designed to teach the basics of the Python 3 computer language. Stu-
 dents will not only learn to use the language, but also do their first practical exercises with it.
  
 The book is not only catering towards people who are naturally inclined towards program-
 ming. It is meant to also be used by those who have no particular aptitude for program-ming. 
 This is exemplified by texts which try to be extensive and foresee problems that might arise 
 when trying to understand certain concepts.",NA
1.1 ,NA,NA
How to use this book,"This book is meant to be used as a course. It is not meant as a Python language reference. 
 You do not need a book as a language reference, as an excellent language reference can be 
 found on the Internet (http://docs.python.org).
  
 The chapters of this book are written to be studied in sequential order. For a brief course on 
 the basics of the Python language, using it for “imperative programming,” you should",NA
1.2 ,NA,NA
Prerequisites and assumptions,"This book assumes that you have no programming skills at all, but are willing to learn. You 
 should also have the ability to think in abstractions.
  
 You should realize that learning how to program might take a significant time investment. It 
 does not suffice to just read the material and do the occasional small exercises. You will have 
 to practice with the material and also do larger exercises, if you really want to gain the 
 ability to create programs. If you stick to the basic chapters (everything up to dealing with 
 text files), if you have no programming knowledge at all, you should count on having to 
 invest between 100 and 200 hours to get to the finish, depending on aptitude. Learning 
 everything that the book has to offer will take between 200 and 400 hours.
  
 Note that this book will not try to teach you to be a professional programmer. It teaches the 
 initial skills that any professional programmer also acquired during his or her education. 
 After teaching those initial skills, the book ends. For most people, this is enough to deal with 
 programming tasks they encounter, and provides a sufficient basis to learn more if there is a 
 need.",NA
1.3,NA,NA
Why Python?,"Python has become a language of choice for teaching people how to program. It is a power-
 ful language, that is easy to use, and that offers all the possibilities that any other computer 
 language offers. It is easily portable between different operating systems. It is freely avail-
 able. For beginning programmers, it has the advantage that it enforces writing readable 
 code. Python is also a language that is used for many practical applications, either as a ba-sis 
 for complete programs, or as an extension to programs written in a different language.
  
 The main advantage of using Python is that it allows you to focus on “thinking like a pro-
 grammer,” rather than learning all the arcane intricacies of a language. Here is an example of 
 the difference between using Python, and using some other popular programming lan-
 guages: The first program that anybody writes in any language, is
  Hello World
 . This is a 
 program that displays the text “Hello, world!” on the screen. In the highly popular com-puter 
 language C++,
  Hello World
  is coded as follows:
  
 #include <iostream> 
  
 int main() { 
  
  
 std::cout << ""Hello, world!""; 
  
 }
  
 In C#, Microsoft’s popular variant of C++, it is:
  
 using System; 
  
 namespace HelloWorld { 
  
  
 class Hello { 
  
  
  
 static void Main() { 
  
  
  
  
 Console.WriteLine( ""Hello, world!"" ); 
  
  
  
 Console.ReadKey(); 
  
  
  
 } 
  
  
 } 
  
 }
  
 In Objective-C, Apple’s C++ variation, the code becomes even worse:
  
 #import <Foundation/Foundation.h> 
  
 int main ( int argc, const char * argv[] ) { 
  
  
 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; 
  
 NSLog 
 (@""Hello, world!""); 
  
  
 [pool drain]; 
  
  
 return 0; 
  
 }
  
 In Java, which is taught as the first language to many computer science students, it is:
  
 class Hello { 
  
  
 public static void main( String[] args ) { 
  
  
 System.out.println( ""Hello, world!"" ); 
  
 } 
  
 }
  
 Now compare this to writing
  Hello World
  in Python:
  
 print( ""Hello, world!"" )
  
 I think we can agree that the Python version of this program is much more readable and 
 understandable – even without knowing the language – than any of the other languages.",NA
1.4,NA,NA
Python’s limitations as a programming language,"Python is a general-purpose programming language. This means that it can be used for 
 anything and everything you would ever want to do with computer languages. Can you 
 therefore conclude that once you have learned Python, you will never need to learn another 
 language?
  
 The answer is that it depends on what you need to do with computer programming. While 
 Python can be used for anything, it is not the most suitable language for everything. For 
 instance, most game programmers use C++ or C# to create their programs, because these 
 languages produce very fast executables, and speed is of utmost importance for games. 
 People who create complex statistical models have their own computer languages too. 
 Sometimes you need to write programs that interact with other programs which require the 
 use of a specific language. And for some problems languages with a different philoso-phy to 
 writing programs are better suitable.
  
 All in all, while Python basically has no limitations as a programming language, for specific 
 problems specific other languages might be better suitable. Still, for many people Python 
 suffices to do everything they need to do for their studies and job. Moreover, Python is a 
 great language to learn programming with, and once you understand and can use Python, 
 you have a very strong basis to learn any other programming language. That is why I believe 
 it is the language of choice to teach programming to beginners.",NA
1.5 ,NA,NA
What does it mean “to think like a programmer?”,"This book is not only meant to teach you to use Python, but, more importantly, to teach you 
 how to think like a programmer, because thinking like a programmer is a necessity to 
 understand what you can use computers for and how you should use them. But what 
 does“thinking like a programmer” entail? I will answer this question by illustrating it with 
 performing a specific task:
  
 Suppose that you have a deck of cards, each card with a different number on it. You have to 
 sort these cards from low to high, lowest card on top. Most people are able to do that. Also, 
 most people, when you ask them how they do it, will look at you mystified, and answer: 
 “Well,... I just sort them low to high... what do you mean with how do I do it?”Other people 
 may say: “I first seek the highest card, and put it down. Then I seek the next highest card, and 
 put it on top of the highest card. Etcetera.” While this more or less explains how they sort 
 cards, if you then ask them: “But how do you seek the highest card?,” most of them, again, 
 will look at you mystified.
  
 The problem is that if you need to explain to a computer how to sort a deck of cards, you 
 cannot assume that the computer can infer anything from vague statements, even if such 
 statements would be completely clear to a human. You cannot tell the computer: “Seek the 
 highest card,” because even if the computer would understand English, it would ask you how 
 it should seek the highest card. You will have to be very explicit about it. You have to say 
 something like “Take the top card from the deck and hold it in you left hand. Then do the 
 following until the deck runs out: take the top card from the deck in your right hand. If the 
 value of the card in your right hand is higher than the value of the card in your left hand, put 
 the left-hand card in the discard pile and put the right-hand card in your left hand. 
 Otherwise, put the right-hand card in the discard pile. Once the deck has run out and your 
 right hand is empty, the card in your left hand is the highest card.”",NA
1.6 ,NA,NA
The art of programming,"Programming is an art form. A teacher of programming in many ways is comparable to a 
 teacher of art.
  
 Most people have had art classes in secondary school. An art teacher first teaches about art 
 materials: pencils and paper, different colors of pencils, different hardness of pencils, 
 erasers, inks, ink pens, paints, etcetera. The students use the knowledge acquired to create 
 their first drawings. Then the art teacher makes them familiar with art techniques: mixing 
 paints to get different colors, special kinds of paints that create special effects, combining 
 techniques, how to use perspective, etcetera. Students get assignments like “draw a cat,”and 
 the art teacher assesses their results both from the use of materials and the mastery of 
 techniques, as well as from an artistic perspective of what makes a good likeness of a cat.
  
 A teacher of programming has similar tasks. At first he teaches students about the core 
 principles behind programming languages, basic statements that every programming lan-
 guage has, and how these can be used to create simple programs. Then he delves into more 
 advanced techniques, by which students can construct more complex programs, and can 
 incorporate advanced functionalities in easier ways. Students get assignments like “create a 
 program that alphabetizes a text,” and the teacher assesses their results both from their use 
 of programming techniques, as well as from the perspective of how well they manage to 
 accomplish the task set.
  
 From the art teacher’s perspective, for an assignment that asks students to draw a cat, a 
 student who drew a circle with two triangles on top and two dots in the middle, arguably 
 drew a cat but has no grasp of the use of materials. A student who hands in a beautiful",NA
1.7 ,NA,NA
"Start small, grow big","This is not the only Python book available, although most books that I have seen assume 
 quite a bit of knowledge and past experience on the part of the student. Books that are aimed 
 at absolute beginners are rare. Still, several alternatives for this book, even free alternatives, 
 exist.
  
 A problem that I have with most Python books aimed at beginners is that they attempt to 
 make programming attractive by focusing from the start on applications that are im-
 mediately useful or entertaining. “Learn Python by Programming Games!” is a typical 
 approach that I have encountered.
  
 Such a setup is misleading. First of all, if you examine a book that teaches Python using 
 games, you will discover that the games used are very simple word and number games, 
 rather than the next
  Halo
 ,
  Civilization
 ,
  Bejeweled
 , or even
  Flappy Bird
 . This generally is not 
 what the student would expect from a book on game programming. Moreover, you will",NA
1.8 ,NA,NA
Python 2 or Python 3?,"Different versions of Python exist. At the moment of creating this book, the most popular 
 versions are Python 2 and Python 3. Python 3 is, as can be expected, an update of Python 2. 
 Python 2 programs are, unfortunately, not completely compatible with Python 3. Since a lot 
 of Python 2 code is still in use, Python 2 is still an active language, and still being maintained.
  
 The reason why Python 3 was created is to resolve a number of inconsistencies and id-
 iosyncrasies in the Python 2 language. For people new to programming, this is a big plus, 
 because there are less “weird” language elements they need to learn and understand if they 
 choose Python 3 instead of Python 2.
  
 To give an example, when you calculate 7/4 in Python 2, the answer is 1, and not 1.75 as you 
 might expect. The reason is that both 7 and 4 are whole numbers (“integers”), and therefore 
 the result of their division is a whole number. If you want to make sure that the result is 
 1.75, you must make at least one of the numbers involved a floating-point number. 
 Therefore, 7.0/4 gives the result 1.75. This is how almost all computer languages do 
 calculations. Naturally, for people who are not familiar with programming computers, this is 
 counter-intuitive. Python 3 has resolved this issue, and automatically does the floating-point 
 conversion when a floating-point result would be expected, i.e., in Python 3, 7/4 gives the 
 result 1.75. Many Python 2 programs, however, are written with the assumption that 
 integer-division rounds down, which means that, when you run them as Python 3 programs, 
 they no longer give the desired results. Thus, Python 2 and Python 3 are not compatible.
  
 Since Python 3 is more intuitive than Python 2, and since nowadays most Python programs 
 and modules have been converted to Python 3, this book is written for Python 3. If you ever 
 have to revert back to Python 2, it is not hard to make the change. An overview of the",NA
1.9 ,NA,NA
Practice,"Most chapters have small exercises sprinkled throughout the text. These exercises are there 
 to enlighten a point or for you to do a quick check if you understood the material up to that 
 moment. You should try to do these exercises immediately when you encounter them. 
 Answers to these exercises are seldom provided, because if you understood the material, 
 they should be really easy to do, while if you did not understand the material, you should 
 either re-read the chapter until you do, or ask someone for assistance.
  
 At the end of most chapters, a separate “Exercises” section is given, with one or more 
 numbered exercises. You are supposed to do all of these exercises, and you should be able to 
 do them independently (i.e., without help of other people and without looking up solutions 
 from outside sources). Answers to these numbered exercises are provided in the back of the 
 book, in Appendix F, and can also be downloaded from the website associated with this book 
 (http://www.spronck.net/pythonbook). I wish to stress the following points:
  
 • You should work on the numbered exercises until you have solved them. Do not dabble 
 a bit and then look up the answer. Such an approach is utterly useless. There is no way 
 that you are going to learn programming if you do not think about algo-rithms, write 
 code, and test code. If you cannot solve an exercise even after you have worked on it 
 for quite some time, it is better to ask for assistance than to just look up the answer. 
 Being unable to solve an exercise means that there is something in the material that 
 you have not grasped yet, and it is important that you identify what that is, and get to 
 grips with it.
  
 • You should do all of the exercises. The only way to learn programming is by prac-ticing. 
 You will have to write lots and lots of code before you have internalized the practice of 
 programming. The few exercises that I place at the end of the chapters are not enough 
 to accomplish that, but at least they are a start. If you cannot even bother to do all of 
 those, you should not bother to try to learn programming.
  
 • You should try to do the exercises independently. Working in teams on the exercises 
 will allow one member of the team to learn, while the rest sits by and learns noth-ing. 
 Students often say that they have a method of learning from assignments that involves 
 working on them in small groups and discussing. That may be fine for an-alyzing texts 
 or setting up an experiment, but in general does not work for coding. Watching 
 someone write code teaches you very little about writing code. You have to write code 
 by yourself.
  
 • For none of the exercises you need information that was not discussed in the book up to 
 that point. While there definitely may be easier ways to do some of the exercises if you 
 would use Python constructs that I did not discuss yet at the time you get to the 
 exercises, you do not need them. The purpose of the exercises is to practice with the 
 discussed material. They are not meant to let you investigate future material. Even if",NA
Exercises,"Exercise 1.1
  Get together with another person, and do the following exercise. Get four 
 playing cards with different values. Shuffle them, and put them face-down on the table. One 
 of you has to sort the cards, from low to high. This person is allowed to move the cards 
 around, but is not allowed to look at their face sides. However, this person is allowed to 
 point at two of the cards, after which the other one picks up those two cards, looks at their 
 faces, and then puts them back and says which of the two is higher. Count how often such a 
 comparison is made. Once the first person is satisfied that the cards are sorted, they are 
 turned over to check if they are indeed sorted correctly.
  
 In this exercise, the first person basically takes the role of a computer program, that follows 
 instructions without actually understanding values. The second person takes the role of the 
 computer processor, which can perform certain functions for the program, in this case, 
 comparing numbers.
  
 If you did not manage to sort the cards correctly, think about how you can accomplish this 
 task under the given circumstances, and after that try it once more. If you did sort them 
 correctly and needed more than six comparisons, think about how you can do it with six 
 comparisons. If you managed to do it with six comparisons, think about if you can do it with 
 less than six. If you did it with less than six, think about if your procedure is guaranteed to 
 sort any collection of four cards.
  
 Exercise 1.2
  After doing the first exercise, together with your partner write down ex-act 
 instructions, in plain English, on how to sort cards under the circumstances described above. 
 Get a third person and ask this person to take your instructions and follow them, while one 
 of you two takes the role of processor. Ask the third person to perform the steps as literally 
 as possible, without trying to interpret meaning. This exercise is most illustra-tive if the 
 third person has no idea what the exact function of the instructions is. Once the sorting 
 procedure has finished, check if the result is correct.
  
 Your textual description is comparable to a real program. If the third person is unable to 
 follow the steps, you seem to have made a syntax error. If the person can follow the steps",NA
Chapter 2,NA,NA
Using Python,"As explained in the introduction, you will need to write and run Python code to learn any-
 thing from this book. That means that you need a computer on which Python is installed, and 
 you need to know how to write and run Python programs. This chapter will explain to you 
 how to get “up and running” with Python.",NA
2.1 ,NA,NA
Getting Python,"To run Python programs, you need a “Python interpreter.” Fortunately, Python interpreters 
 are freely available for almost every machine in existence. Visit http://www.python.org to 
 download a Python interpreter for your computer. Make sure that you get a Python 3 
 interpreter. Install it. After the installation finishes, in principle you are ready to write and 
 run Python programs.
  
 It does not matter which operating system you use, whether it is Windows, Mac OS X, Linux, 
 or something else: you write the same code for every machine. You can even take a program 
 that you wrote on one machine and copy it to another, which may have a different operating 
 system, and it will probably still run as intended (unless the program has some system-
 specific content, but I will get to that in a much later chapter).
  
 Some Python courses use an online system in which students write Python code. That is a 
 possible approach, but it has three disadvantages: (1) there are free systems which are very 
 limited and therefore less useful; (2) there are paid systems which cost money and also have 
 you deal with some peculiarities (as they run in a browser); and (3) at some point you will 
 have to run Python on your own computer anyway, so why not start with it? That said, if you 
 prefer to start with an online system and only move towards a locally installed version of 
 Python in a later chapter, that is certainly possible.",NA
2.2 ,NA,NA
Creating Python programs,"Python programs are created in the form of files. By convention, the name of the file that 
 contains a Python program has the extension .py.",NA
2.3,NA,NA
Running Python programs,"Once you have created a Python program, you see the program name displayed in the folder 
 where you saved it. You can try to run it in the same way that you run other pro-grams (e.g., 
 by double-clicking on it). For many Python programs, when you activate them in this way, 
 you either see nothing happening, or a quick flash of a black window, after which nothing 
 happens anymore. The reason is that Python programs run in a “command-line shell” of the 
 operating system. If you are not a Linux user, this is probably not some-thing that you are 
 used to. Basically, what happens is that Python opens the command-line shell, runs the 
 program, and when the program finishes, closes the shell, giving you the feeling that nothing 
 has happened. But something did happen; you just did not notice it.
  
 For the purpose of most of this book, you should simply run programs in the editor that you 
 use, as I describe for IDLE above. You may open the command-line shell (which usu-ally is a 
 somewhat hidden option in the list of installed programs on your machine, falling under 
 System Commands) and “manually” run Python programs from that shell, but there seldom 
 is a need to do that.",NA
2.4 ,NA,NA
Reference material,"Besides this book, you might occasionally want to reference the Python manual. The eas-iest 
 way to do that is using the Internet. Just search for “Python” with whatever you are 
 interested in, and you will quickly see links that lead straight into the Python manuals (the 
 Python manuals are stored at http://docs.python.org). You might also run into links that 
 lead you to code that solves a problem for you directly. While that is great by the time you 
 have to use Python for practical problems, it does not help you to learn. So my advice is that 
 you avoid such links while trying to learn programming.
  
 When you install Python, there usually is a manual installed in a Doc folder under the Python 
 folder. You can use it if, for some reason, you are not connected to the Internet.
  
 If you are interested in another book besides this one, I recommend the classic
  Think Python: 
 How to Think Like a Computer Scientist
 , by Allen B. Downey. It is freely available from 
 http://greenteapress.com/wp/. A version for Python 3 was released in 2016. The main 
 differences with my book as far as content is concerned, is that my book has more exercises, 
 is aimed more at people who are completely new to programming, takes more time for 
 topics that I know are hard for students who have no real aptitude for programming, and 
 covers a few important topics that Downey’s book lacks, such as extensive file processing.
  
 Besides this book and other books like it to learn Python from, there are several open video 
 courses available. I do not believe that it is possible to learn programming mainly from 
 watching a video. The only way to learn programming is by doing.
  
 I have included a troubleshooting appendix (Appendix A) to explain the most common 
 problems that you may encounter during the writing and running of programs.",NA
Exercises,"Exercise 2.1
  Download Python and install it on the machine of your choice. Run IDLE. 
 Create a file hello.py, in which you place the code of the
  Hello World
  program shown in 
 Chapter 1 – it consists of one line of code, namely:
  
 print( ""Hello, world!"" )
  
 Run the program, and observe how the text “Hello, world!” is displayed in the IDLE shell.
  
 Exercise 2.2
  In the IDLE shell you can type commands on the IDLE prompt (>>>). Give the 
 command print(7/4). You will see that it prints the answer 1.75. Then give the com-mand 
 7/4 (i.e., without print). Observe that it also prints the answer 1.75.
  
 The reason is that the IDLE shell will always display the result of a command. The result of 
 7/4 is 1.75, and therefore it displays 1.75. The result of a print command is nothing, so the 
 shell displays nothing – however, the print command causes the display of whatever is 
 within the parentheses, which is the value resulting from dividing 7 by 4, which is 1.75. 
 Therefore, in both cases you see 1.75, but one is the result of the use of the print command, 
 while the other is the result of the shell showing you the evaluation of a calculation.
  
 Now write a Python program that contains only the command 7/4. Before you run it, think 
 about what you expect to happen when you run it. Will the shell display 1.75? Will it display 
 nothing? Or will you see an error?
  
 Check if your expectation is correct.",NA
Chapter 3,NA,NA
Expressions,"Welcome to the first real programming chapter. In this chapter I discuss “expressions,”which 
 are straightforward calculations which you can also do with any simple calculator. It is a 
 small start, but you are going to need such expressions for every chapter after this one.",NA
3.1 ,NA,NA
Displaying results,"When you write an expression in the Python shell, and you run it, the result of the expres-
 sion is shown below it. For instance, if you type the following command in the shell and 
 press Enter, you see the result 12.
  
 5 + 7
  
 However, as I showed in Exercise 2.2, a program that contains the statement 5 + 7 will not 
 produce a result in the shell. Instead, you have to explicitly display everything that you want 
 to see, even if it is on the last line of the program.
  
 So, even though this chapter is about expressions, the first thing I need to explain is not an 
 expression, but a function, that allows you to display results. The function that does that is 
 print. I already showed the print function in Chapters 1 and 2.
  
 The print function is used as follows: you write the word print, followed by an opening 
 parenthesis, followed by whatever you want to display, followed by a closing parenthesis.
  
 For example (and I showed this one before):
  
 print(
  ""Hello, world!""
  )
  
 If you run this code (by saving it into a Python file and running it in IDLE), you will see that it 
 displays the text “Hello, world!” in the shell.
  
 By the way, when referring to a function by name in a text, authors of texts about program-
 ming often put an opening and closing parenthesis after the name of the function, to indi-
 cate that it is a function name. From now on, I will follow this convention. Moreover, in-stead 
 of referring to a “function,” authors sometimes call it a “statement” or a “command.”",NA
3.2 ,NA,NA
Data types,"Before I can get to expressions, there is one more topic that requires some discussion, and 
 that is data types. Specifically, there are three different data types that you need to be aware 
 of at this time: strings, integers, and floats.
  
 3.2.1 Strings
  
 A string is a text, consisting of zero or more characters. In Python, a string is enclosed by 
 either double quotes, or single quotes. In principle, it does not matter which of the two you 
 use, i.e.,
  ""orange""
  is equivalent to
  'orange'
 . However, if you have a text which contains a 
 single quote, if you want to avoid problems you will have to enclose it in double quotes, i.e.,
  
 ""I can't stand it""
  is a legal string, while
  'I can'
 t stand it
 '
  is not. Vice versa for double quotes in 
 a string, of course.
  
 What if a string contains both double quotes and single quotes? You can solve that issue by 
 putting a backslash (\) in front of the single or double quote that is part of the string to tell 
 Python to treat that single or double quote as a character of the string rather than something 
 that ends the string, i.e.,
  'I can\'t stand it'
  is a legal string. You can see that when you try to 
 print it:",NA
3.3 ,NA,NA
Expressions,"Finally, I can get to the topic of this chapter, which is “expressions.” An expression is a 
 combination of one or more values (such as strings, integers, or floats) using operators, 
 which result in a new value. In other words, you can think of expressions as calculations.
  
 3.3.1 Basic calculations
  
 Basic calculations combine two values with one operator in between them. Some straight-
 forward operators are:
  
 + addition
  
 -subtraction
  
 * multiplication
  
 / division
  
 // integer division
  
 ** power
  
 % modulo
  
 Here are some examples:
  
 print( 15+4 ) 
  
 print( 15-4 ) 
  
 print( 15*4 ) 
  
 print( 15/4 ) 
  
 print( 15//4 ) 
  
 print( 15**4 ) 
  
 print( 15%4 )",NA
3.4,NA,NA
Style,"You might have noticed that in my example code I use white spaces a lot. For instance, for 
 parentheses attached to functions, I almost always have a white space after the opening 
 parenthesis and before the closing parenthesis. In calculations, I often have white spaces 
 around operators if that makes the calculations better readable. I also often insert empty 
 lines in my code to make it more readable, and consistently use four spaces as indentations.
  
 Most of these things are just “style.” The white spaces next to the parentheses and around 
 operators are not necessary, Python understands the code just as well when they are gone.
  
 These four statements are all equivalent:
  
 # All equivalent statements 
  
 print( 2 + 3 ) 
  
 print(2+3) 
  
 print( 2+3)
  
 print
  
 (
  
 2
  
 +
  
 3
  
 )
  
  
 Attaching the opening parenthesis to a function is something that almost every program-mer 
 does, but for the rest, styles of placing white spaces differ between programmers (my style of 
 placing a space before the closing parenthesis is rare). You can choose your own",NA
What you learned,"In this chapter, you learned about:
  
 • Using the print() function to display results
  
 • Data types string, integer, and float
  
 • Calculations
  
 • Basic string expressions
  
 • Type casting between strings, integers, and floats, using str(), int(), and float()",NA
Exercises,"Exercise 3.1
  The cover price of a book is $24.95, but bookstores get a 40 percent 
 discount. Shipping costs $3 for the first copy and 75 cents for each additional copy. Calculate 
 the total wholesale costs for 60 copies.
  
 Exercise 3.2
  Can you identify and explain the errors in the following lines of code? 
 Correct them.
  
 exercise0302.py
  
 print(
  ""A message""
  ).
  
 print(
  ""A message ' ) 
  
 print( 
  
 ' A messagef"" ' )
  
 Exercise 3.3
  When something is wrong with your code, Python will raise errors. Often 
 these will be “syntax errors” that signal that something is wrong with the form of your code 
 (e.g., the code in the previous exercise raised a SyntaxError). There are also “runtime 
 errors,” which signal that your code was in itself formally correct, but that something went 
 wrong during the code’s execution. A good example is the ZeroDivisionError, which in-
 dicates that you tried to divide a number by zero (which, as you may know, is not allowed). 
 Try to make Python raise such a ZeroDivisionError.",NA
Chapter 4,NA,NA
Variables,"When working with program code, very often you are designing a procedure (or “algo-
 rithm”) that solves a problem in a general way. For instance, in the previous chapter one of 
 the exercises had you calculate the wholesale price for a stack of books, for a given book 
 price and a given number of books. The code you wrote did not solve this problem for a 
 general case, but only for the specific case of 60 books costing 24.95 per book. If you want to 
 write code that solves problems in a more general way, you need to use variables that store 
 values.",NA
4.1 ,NA,NA
Variables and values,"A variable is a labeled place in the computer memory that you can use to store a value in. The 
 label you can choose yourself, and is usually called the “variable name.”
  
 To create a variable (i.e., choose the variable name), you must “assign” it a value. The assign-
 operator is the equals (
 =
 ) symbol. To the left of it you put the variable name, and to the right 
 of it you put the value that you want to store in the variable. This is best illustrated with an 
 example:
  
 x = 5 
  
 print( x )
  
 In the code block above, two things happen. First, I create a variable with the name x and 
 give it a value, in this case 5. This is called an “assignment.” I then display the contents of the 
 variable x, using print(). Note that print( x ) does not display the letter x, but actually 
 displays the value that was assigned to x.
  
 The variable x behaves pretty much like a box on which you write an x with a thick, black 
 marker to be able to find it later. You can put something in the box, and then look into the 
 box to see what you put in (though only one thing at a time will fit in the box). You can refer 
 to the contents of the box by using the name written on the box. The term “variable”means 
 the variable name, i.e., the letter x on the box. The term “value” means the value that is 
 stored in the variable, i.e., the contents of the box.",NA
4.2,NA,NA
Variable names,"So far, I have only used variables called x, y, and z (and one erroneous days_in_a_year). 
 However, you are free to choose the names of your variables as you like them, provided that 
 you follow a few simple rules, namely:
  
 • A variable name must consist of only letters, digits, and/or underscores (_)
  
 • A variable name must start with a letter or an underscore
  
 • A variable name should not be a reserved word
  
 “Reserved words” (or “keywords”) are:
  
 False
  
 class
  
 finally
  
 is
  
 return
  
 None
  
 continue
  
 for
  
 lambda
  
 try
  
 True
  
 def
  
 from
  
 nonlocal
  
 while
  
 and
  
 del
  
 global
  
 not
  
 with
  
 as
  
 elif
  
 if
  
 or
  
 yield
  
 assert
  
 else
  
 import
  
 pass
  
 break
  
 except
  
 in
  
 raise",NA
4.3 ,NA,NA
Debugging variables,"Typically, when things go wrong in a program, the reason is that variables are holding values 
 that you did not expect them to have when writing the code. A good way of “de-bugging” 
 your code (i.e., finding out where problems are and fixing them) is printing the variable 
 names and values in appropriate places. For instance, the following code gives an error when 
 you run it.
  
 listing0401.py
  
 nr1 = 5 
  
 nr2 = 4 
  
 nr3 = 5 
  
 print( nr3 / (nr1 % nr2) ) 
  
 nr1 = nr1 + 1 
  
 print( nr3 / (nr1 % nr2) ) 
  
 nr1 = nr1 + 1",NA
4.4 ,NA,NA
Soft typing,"All variables have a data type. In many programming languages, the type of a variable is 
 given when the variable is first created. For instance, in C++, when you create a variable you 
 declare the type in front of it, like so:
  
 int secs_per_week = 7 * 24 * 60 * 60;
  
 This is called “hard typing,” and it has the advantage that if you create a variable that you 
 intend to be of a certain type, but then assign it a value of a different type, the program can 
 announce that you made a mistake. This avoids some annoying and confusing errors that 
 might occur.
  
 In Python, you do not “declare” the type of a variable, but a variable still has a type, namely 
 the type of the value that was assigned to it. This entails that if you assign a new value to a 
 variable, its type might change. This is called “soft typing.” (Note: I am personally of the 
 opinion that Python would be an even better language to teach people programming if it had 
 hard typing instead of soft typing, and I am not alone in that opinion, but Guido van Rossum, 
 the original creator of Python, disagrees.)
  
 The types that you have seen until now are integer, float, and string. You can use the function 
 type() to see what the type of a variable is.
  
 a = 3 
  
 print( type( a ) ) 
  
 a = 3.0 
  
 print( type( a ) ) 
  
 a =
  ""3.0"" 
  
 print( type( a ) )
  
 Since variables have a type, the effect of operators might change depending on the types of 
 the variables involved. For instance, in the following code, the addition operator (
 +
 ) is used 
 twice, but its effect changes due to the types of the variables involved.",NA
4.5 ,NA,NA
Shorthand operators,"Using the operators you have learned about above, you can change the variables in your 
 code as many times as you want. You can assign new values to existing variables. Very often, 
 you want to make changes to existing variables. For instance, it is common in code that you 
 want to add 1 to a number (you will find out why that is in a later chapter). Since this occurs 
 fairly often, Python offers some shorthand notation to deal with changes to variables.
  
 The following code:
  
 number_of_bananas = 100 
  
 number_of_bananas = number_of_bananas + 1 print( 
 number_of_bananas )
  
 is equivalent to:
  
 number_of_bananas = 100 
  
 number_of_bananas += 1 
  
 print( number_of_bananas )
  
 The difference is in the second line. If you want to add something to a variable, you can write 
 += as the assignment operator and to the right-hand side of the += the thing that you want to 
 add to the variable. This saves you the trouble of repeating the variable name at",NA
4.6,NA,NA
Comments,"Since the code that you have to write has now increased to more than five lines or so, it has 
 become sufficiently complex to warrant discussing the use of comments. Comments are texts 
 in code that Python ignores, but that explain parts of the code. Comments are not only useful 
 to other people which might need to use or change your code, but also to yourself, as you 
 may need to change your own code some time after you wrote it and you might not 
 remember exactly what you did.
  
 There are two main ways to include comments in Python code. The first is to use a hash 
 mark (#), which turns everything to the right of the hash mark on the line into commentary 
 (of course, this is only the case if the hash mark is not part of a string). The second is to use 
 triple double-quotes or triple single-quotes to indicate the start and end of some 
 commentary, which may be spread over multiple lines. In this case, the starting triple quotes 
 should always be at the start of a line, and you cannot use this way of commenting in an 
 indented code block. The reason is that you are basically placing a multi-line string in your 
 code (more on this in Chapter 10).
  
 Learn more about comments by studying the code below.
  
 listing0403.py
  
 # comment: insert your code here.
  
 # BTW: Have you noticed that everything right of the hash mark 
 print(
  ""Something...""
  )
  # 
 is ignored by your python interpreter? 
 print(
  ""and something else..""
  )
  # Use this to 
 comment your code!
  
 """"""Another way of commenting on your code is via triple quotes-- these can be distributed 
 over multiple """""" # lines 
  
 ' ' ' which can also be done with single quotes ' ' ' 
  
 # but be careful # with 
 there being quotes IN your comments when you use this # multi-line method 
  
 print(
  ""Done.""
  )",NA
What you learned,"In this chapter, you learned about:
  
 • What variables are
  
 • Assigning a value to a variable
  
 • Legal names for variables
  
 • Good names for variables
  
 • Soft typing
  
 • Debugging code in which variables might have unexpected values
  
 • Shorthand statements for changing variable values
  
 • Code commentary",NA
Exercises,"Exercise 4.1
  Define three variables var1, var2 and var3. Calculate the average of these 
 variables and assign it to average. Print the average. Add three comments.
  
 Exercise 4.2
  Write code that can compute the surface of circle, using the variables radius 
 and pi = 3.14159. The formula, in case you do not know, is radius times radius times pi. Print 
 the outcome of your program as follows: “The surface area of a circle with radius ...
  
 is ...”
  
 Exercise 4.3
  Write code that classifies a given amount of money (which you store in a 
 variable named amount), specified in cents, as greater monetary units. Your code lists the 
 monetary equivalent in dollars (100 ct), quarters (25 ct), dimes (10 ct), nickels (5 ct), and 
 pennies (1 ct). Your program should report the maximum number of dollars that fit in the 
 amount, then the maximum number of quarters that fit in the remainder after you subtract 
 the dollars, then the maximum number of dimes that fit in the remainder after you subtract 
 the dollars and quarters, and so on for nickels and pennies. The result is that you express the 
 amount as the minimum number of coins needed.
  
 Exercise 4.4
  Can you think of a way to swap the values of two variables that does not 
 need a third variable as a temporary storage? In the code block below, try to implement the 
 swapping of the values of a and b without using a third variable. To help you out, the first 
 step to do this is already given. You just need to add two more lines of code.
  
 exercise0404.py
  
 a = 17 
  
 b = 23 
  
 print(
  ""a =""
 , a,
  ""and b =""
 , b ) 
  
 a += b 
  
 # add two more lines of code here to cause swapping of a and b 
 print(
  ""a =""
 , a,
  ""and b 
 =""
 , b )",NA
Chapter 5,NA,NA
Simple Functions,"Up to this point, I have already introduced some basic “functions,” such as print() and int(). 
 In this chapter these functions will be discussed a bit more in-depth, and a few other 
 functions will be introduced, which will be helpful in the coming chapters. In Chapter 8, I will 
 discuss how you can create your own functions.",NA
5.1 ,NA,NA
Elements of a function,"A function is a block of reusable code that performs some action. To get a function to do its 
 job, you “call” it, with some appropriate parameters if the function requires them. The idea is 
 that you do not need to have knowledge about how a function performs its action.
  
 You only need to know three things:
  
 • The name of the function
  
 • The parameters it needs (if any)
  
 • The return value of the function (if any)
  
 These will now be discussed in turn.
  
 5.1.1 
  
 Function name
  
 Each function has a name. Like a variable name, a function name may consist of letters, 
 digits, and underscores, and cannot start with a digit. Almost all standard Python functions 
 consist only of lower case letters. Usually a function name expresses concisely what the 
 function does.
  
 When referring to a function, it is convention to use the name, and put an opening and 
 closing parenthesis after the name, as functions are always called in code with such paren-
 theses.",NA
5.2 ,NA,NA
Some basic functions,"At this point, I introduce some basic functions that you can use in your Python programs.
  
 5.2.1 Type casting
  
 I already introduced the type casting functions, but now I have explained more details of 
 functions, I can give a complete description.
  
 • float() has one parameter and returns a floating-point representation of the value of 
 that parameter. If the parameter holds an integer, it returns the same value as a float 
 (if you print it, you will see .0 added). If the parameter holds a float, it returns the same 
 value. If the parameter holds a string which can be interpreted as an integer or a float, 
 it returns that interpretation as a float; otherwise it will give a runtime error.
  
 • int() has one parameter and returns an integer representation of the value of that 
 parameter. If the parameter holds an integer, it returns the same integer. If the param-
 eter holds a float, it returns the integer part of the float, i.e., the float value rounded 
 down. If the parameter holds a string, and the string contains only digits, option-ally 
 with a preceding minus-sign, it returns the integer represented by those digits; 
 otherwise it will give a runtime error.
  
 • str() has one parameter and returns a string representation of the value of that pa-
  
 rameter.
  
 Exercise
  What will happen if you run the following code? If you do not know, try it and 
 find out.
  
 print( 10 * int(
  ""100,000,000""
  ) )
  
 Exercise
  The code above gives a runtime error. Fix it by removing a few characters.",NA
5.3,NA,NA
Modules,"Python offers some basic functions, some of which are introduced above. Besides those, 
 Python offers a large assortment of so-called “modules,” which contain many more useful 
 functions. To use functions from a module in your program, you have to import the mod-ule, 
 by writing a line import <modulename> at the top of your code. You can then use all the 
 functions in the module, though you have to precede the function calls with the name of the 
 module and a period, e.g., to call the sqrt() function from the math module (which calculates 
 the square root of a number), you call math.sqrt() after importing math.
  
 Alternatively, you can import only specific functions from a module, by stating: 
 from <modulename> import <function1>, <function2>, <function3>, ...
  
 The main advantage of importing specific functions from a module in this way is that in your 
 code, you no longer need to precede the call to a function with the module name.
  
 For example:
  
 import math 
  
 print( math.sqrt( 4 ) )
  
 is equivalent to:
  
 from math import sqrt 
  
 print( sqrt( 4 ) )
  
 If you want to rename something that you import from a module, you can do so with the 
 keyword as. This might be useful when you use multiple modules that contain things with 
 equal names.
  
 from math import sqrt as squareroot print( 
 squareroot( 4 ) )
  
 I will now introduce some functions from two standard modules that are often used, and 
 some functions from a module which was developed for this book (you will learn to de-velop 
 your own modules later). There are many more modules besides the ones introduced here, 
 some of which will come up later in the book, and others which you will have to look",NA
What you learned,"In this chapter, you learned about:
  
 • What functions are
  
 • Function names
  
 • Function parameters
  
 • Function return values
  
 • Details of type casting with float(), int(), and str()
  
 • Basic calculation functions abs(), max(), min(), pow(), and round()
  
 • len()
  
 • input()
  
 • Details of the print() function
  
 • String formatting using format()
  
 • What modules are
  
 • The math module functions exp(), log(), log10(), and sqrt()
  
 • The random module functions random(), randint(), and seed()
  
 • The pcinput module functions getInteger(), getFloat(), getString(), and 
  
 getLetter()",NA
Exercises,"Exercise 5.1
  Ask the user to enter a string. Then print the length of that string. Use the 
 input() function rather that the getString() function from pcinput, as the getString() function 
 removes leading and trailing spaces.
  
 Exercise 5.2
  The Pythagorean theorem states that of a right triangle, the square of the 
 length of the diagonal side is equal to the sum of the squares of the lengths of the other two 
 sides (or
  a
 2
 +
  b
 2
 =
  c
 2
 ). Write a program that asks the user for the lengths of the two sides that 
 meet at a right angle, then calculate the length of the third side (in other words: take the 
 square root of the sum of the squares of the two sides that you asked for), and display it in a 
 nicely formatted way. You may ignore the fact that the user can enter negative or zero 
 lengths for the sides.
  
 Exercise 5.3
  Ask the user to enter three numbers. Then print the largest, the smallest, and 
 their average, rounded to 2 decimals.
  
 Exercise 5.4
  Calculate the value of e to the power of -1, 0, 1, 2, and 3, and display the 
 results, with 5 decimals, in a nicely formatted manner.
  
 Exercise 5.5
  Suppose you want to generate a random integer between 1 and 10 (1 and 10 
 both included), but from the random module you only have the random() function available 
 (you can use functions from other modules, though). How do you do that?",NA
Chapter 6,NA,NA
Conditions,"In program code, there are often statements that you only want to execute when certain 
 conditions hold. Every programming language therefore supports conditional statements. In 
 this chapter I will explain how to use conditions in Python.",NA
6.1 ,NA,NA
Boolean expressions,"A conditional statement, often called an “if”-statement, consists of a test and one or more 
 actions. The test is a so-called “boolean expression.” The actions are executed when the test 
 evaluates to True. For instance, an app on a smartphone might give a warning if the battery 
 level is lower than 5%. This means that the app needs to check if a certain variable 
 battery_level is lower than the value 5, i.e., if battery_level < 5 evaluates to True. If the 
 variable battery_level holds the value 17, then battery_level < 5 evaluates to False.
  
 6.1.1 
  
 Booleans
  
 True and False are so-called “boolean values” that are predefined in Python. True and False 
 are actually the
  only
  boolean values, and anything that is not False, is True.
  
 You might wonder what the data type of True and False is. The answer is that they are of the 
 type bool. However, in Python every value can be interpreted as a boolean value, regardless 
 of its data type. I.e., when you test a condition, and your test is of a value that is not True or 
 False, it will still be interpreted as either True or False.
  
 The following values are interpreted as False:
  
 • The special value False
  
 • The special value None (which you encountered in Chapter 5)
  
 • Every numerical value that is zero, e.g., 0 and 0.0
  
 • Every empty sequence, e.g., an empty string (
 """"
 )",NA
6.2 ,NA,NA
Conditional statements,"Conditional statements are, as the introduction to this chapter said, statements consisting of 
 a test and one or more actions, whereby the actions only get executed if the test evaluates to 
 True. Conditional statements are also called “if-statements,” as they are written using the 
 special keyword if.
  
 Here is an example:
  
 x = 5 
  
 if x == 5: 
  
 print(
  ""x equals 5""
  )
  
 The syntax of the if statement is as follows:
  
 if <boolean expression>:
  
 <statements>
  
 Note the colon (:) after the boolean expression, and the fact that <statements> is indented.
  
 6.2.1 
  
 Code blocks
  
 In the syntactic description of the if statement above, you see that the <statements> 
 are“indented,” i.e., they are placed one tabulation to the right. This is intentional and neces-
 sary. Python considers statements that are following each other and that are at the same 
 level of indentation part of a code block. The code block underneath the first line of the if 
 statement is considered to be the list of actions that are executed when the boolean expres-
 sion evaluates to True. For example:
  
 listing0603.py
  
 x = 7 
  
 if x < 10: 
  
 print(
  ""This line is only executed if x < 10.""
  ) print(
  ""And the same holds 
 for this line.""
  ) print(
  ""This line, however , is always executed.""
  )",NA
6.3 ,NA,NA
Early exits,"Occasionally it happens that you want to exit a program early when a certain condition 
 arises. For instance, your program asks the user for a value, and then processes that value 
 extensively. But if the user enters a value that cannot be processed, the program should just 
 end. You could code that as follows:
  
 from pcinput import getInteger
  
 num = getInteger(
  ""Please enter a positive integer: ""
  ) if num < 0: 
  
  
 print(
  ""You should have entered a positive integer!""
  ) else: 
  
  
 print(
  ""Now I am processing your integer""
 , num ) 
  
  
 print(
  ""Lots and lots of processing""
  ) 
  
  
 print(
  ""Hundreds of lines of code here""
  )
  
 It is a bit irritating that most of your program is already one indent deep, while you would 
 have preferred to leave the program at the error message, and then have the rest of the 
 program at the top indent level.
  
 You can do that using a special function exit() that is found in the module sys. The code 
 above becomes:
  
 listing0609.py
  
 from pcinput import getInteger 
  
 from sys import exit
  
 num = getInteger(
  ""Please enter a positive integer: ""
  ) if num < 0:",NA
What you learned,"In this chapter, you learned about:
  
 • What boolean expressions are
  
 • Boolean values True and False
  
 • Comparisons with <, <=, ==, >, >=, and !=
  
 • The in operator
  
 • Logical operators and, or, and not
  
 • Conditional statements using if, elif, and else
  
 • Code blocks
  
 • Indentation
  
 • Nested conditions
  
 • Using exit()",NA
Exercises,"Exercise 6.1
  Grades are values between zero and 10 (both zero and 10 included), and are 
 always rounded to the nearest half point. To translate grades to the American style, 8.5 to 10 
 become an “A,” 7.5 and 8 become a “B,” 6.5 and 7 become a “C,” 5.5 and 6 become a “D,” and 
 other grades become an “F.” Implement this translation, whereby you ask the user for a 
 grade, and then give the American translation. If the user enters a grade lower than zero or 
 higher than 10, just give an error message. You do not need to handle the user entering 
 grades that do not end in .0 or .5, though you may do that if you like – in that case, if the user 
 enters such an illegal grade, give an appropriate error message.",NA
Chapter 7,NA,NA
Iterations,"Computers do not get bored. If you want the computer to repeat a certain task hundreds of 
 thousands of times, it does not protest. Humans hate too much repetition. Therefore, 
 repetitious tasks should be performed by computers. All programming languages sup-port 
 repetitions. The general class of programming constructs that allow the definition of 
 repetitions are called “iterations.” A term which is even more common for such tasks 
 is“loops.”
  
 This chapter explains all you need to know about loops in Python. Students who are com-
 pletely new to programming often find loops the first really hard topic in programming that 
 they encounter. If that is the case for you, then make sure you take your time for this chapter, 
 and work on it until you understand it completely. Loops are such a basic concept in 
 programming that you need to understand them in all their details. Each and every chapter 
 after this one needs loops.",NA
7.1 ,NA,NA
while,NA,NA
 loop,"Suppose you have to ask the user for five numbers, then add them up, and show the total. 
 With the material from the previous chapters, you would program that as follows:
  
 from pcinput import getInteger
  
 num1 
 = 
 getInteger(
  
 ""Number 
 1: 
 ""
  
 ) 
  
 num2 
 = 
 getInteger(
  
 ""Number 
 2: 
 ""
  
 ) 
  
 num3 
 = 
 getInteger(
  
 ""Number 
 3: 
 ""
  
 ) 
  
 num4 
 = 
 getInteger(
  
 ""Number 
 4: 
 ""
  
 ) 
  
 num5 = getInteger(
  ""Number 5: ""
  )
  
 print(
  ""Total is""
 , num1 + num2 + num3 + num4 + num5 )
  
 But what if I want you to ask the user for 500 numbers? Are you going to create a block of 
 code of more than 500 lines long? Surely there must be an easier way to do this?
  
 Of course there is. You can use a loop to do this.",NA
7.2 ,NA,NA
for,NA,NA
 loop,"An alternative way of implementing loops is by using a for loop. for loops tends to be easier 
 and safer to use than while loops, but cannot be applied to all iteration problems. while loops 
 are more general. In other words, everything that a for loop can do, a while loop can do too, 
 but not the other way around.
  
 The syntax of a for loop is as follows:
  
 for <variable> in <collection>:
  
 <statements>
  
 A for loop gets presented with a collection of items, and it will process these items, in order, 
 one by one. Every cycle through the loop will put one item in the variable given next to the 
 for, and can then be used in the code block under the for. The variable does not need to exist 
 before the for loop is encountered. If it does, it gets overwritten. It is a real variable, by the 
 way, in the sense that it still exists after the loop has finished. It will contain the last value 
 that it got assigned during the processing of the loop.
  
 At this point you might wonder what a “collection” is. There are many different kinds of 
 collections in Python, and in this section I will introduce a few. In later chapters collections 
 will be discussed in more detail.
  
 7.2.1 
  
 for
  loop with strings
  
 The only collection introduced until now is the string. A string is a collection of characters, 
 e.g., the string
  ""banana""
  is a collection of the characters
  ""b""
 ,
  ""a""
 ,
  ""n""
 ,
  ""a""
 ,
  ""n""
 , and 
 ""a""
 , in that 
 specific order. The following code loops through each of these letters:
  
 for letter in
  ""banana""
 : 
  
  
 print( letter ) 
  
 print(
  ""Done""
  )
  
 While this code is fairly trivial, let’s go through it step by step (I did not make a flow chart, as 
 that is not easy for for loops).
  
 When the for loop is encountered, Python takes the collection (i.e., the string
  ""banana""
 ) and 
 turns it into an “iterable.” What that is exactly I will get to in Chapter 23, but for now assume 
 that it is a list of all the letters in the string, in the order that they appear in the string. Python 
 then takes the first of those letters, and puts it in the variable letter. It then executes the code 
 block below the for.
  
 The code block contains only one statement, which is the printing of letter. So the pro-gram 
 prints “b,” and then loops back to the for. Python then takes the next letter, which is",NA
7.3 ,NA,NA
Loop control statements,"There are three extra statements that help you control the flow in a loop. They are else, 
 break, and continue. They work with both while and for loops.
  
 7.3.1 
 else
  
 Just like with an if statement, you can add an else statement to the end of a while or for loop. 
 The code block for the else is executed whenever the loop ends, i.e., when the boolean 
 expression for the while loop evaluates to False, or when the last item of the collection of the 
 for loop is processed. Here is an example for a while loop:
  
 listing0706.py
  
 i = 0 
  
 while i < 5: 
  
  
  
 print( i ) 
  
  
 i += 1 
  
 else: 
  
  
  
 print(
  ""The loop ends, i is now""
 , i ) print(
  ""Done""
  )
  
 This code is equivalent to the flow chart in Figure 7.2. When you look at the flow chart you 
 might think it does not make much sense to use an else, but it can be powerful when 
 combined with a break (which follows next).
  
 Here is an example of using else for a for loop:
  
 listing0707.py
  
 for fruit in (
  ""apple""
 ,
  ""orange""
 ,
  ""strawberry""
  ): 
  
 print( fruit ) 
  
 else: 
  
  
 print(
  ""The loop ends, fruit is now""
 , fruit ) print(
  ""Done""
  )
  
 Notice that after the while loop above, the value of i is 5. The value of fruit after the for loop 
 above is the last item that it encountered, i.e.,
  ""strawberry""
 .
  
 7.3.2 
 break
  
 The break statement allows you to break out of a loop prematurely. I.e., when Python 
 encounters the break statement, it will no longer process the remainder of the code block",NA
7.4 ,NA,NA
Nested loops,"You can put a loop inside another loop.
  
 That is a simple statement, but it is one of the hardest concepts for students to wrap their 
 minds around.
  
 Let’s first look at an example of a double-nested loop, i.e., a loop which contains one other 
 loop. Usually programmers talk about an “outer loop” and an “inner loop.” The inner loop is 
 part of the code block for the outer loop.
  
 listing0711.py
  
 for i in range( 3 ): 
  
  
 print(
  ""Entering the outer loop for i =""
 , i ) 
  
  
 for j in range( 3 ): 
  
  
  
 print(
  "" 
  
  
 Entering the inner loop for j =""
 , j ) 
  
  
 print(
  "" 
  
 (i,j) = ({},{})""
 .format( i, j ) ) 
  
  
 print(
  "" 
  
  
  
 Leaving the inner loop for j =""
 , j ) 
  
 print(
  ""Leaving the outer loop 
 for i =""
 , i )
  
 Study this code and its output until you fully understand it!
  
 The code first gives i the value 0, and then lets j take on the values 0, 1, and 2. It then gives i 
 the value 1, and then lets j take on the values 0, 1, and 2. Finally, it gives i the value 2, and 
 then lets j take on the values 0, 1, and 2. So this code runs through all possible pairs of (i,j) 
 with i and j being 0, 1, or 2.
  
 Notice how variables for the outer loop are also accessible by the inner loop. i exists in both 
 the outer and the inner loop.
  
 Suppose that you want to print all pairs (i,j) where i and j can take on the values 0 to 3, but j 
 must be higher than i. Code that does that is:",NA
7.5,NA,NA
The loop-and-a-half,"Suppose you want to ask the user for two numbers in a loop. For every two numbers that the 
 user enters, you want to show their multiplication. You allow the user to stop the program 
 when he enters zero for any of the numbers. For some reason, if the numbers are dividers of 
 each other, that is an error and the program also stops, but with an error message. Finally, 
 you will not process numbers higher than 1000 or smaller than zero, but that is not an error; 
 you just want to allow the user to enter new numbers. How do you program that? Here is a 
 first attempt:
  
 listing0712.py
  
 from pcinput import getInteger
  
 x = 3 
  
 y = 7
  
 while (x != 0) and (y != 0) and (x%y != 0) and (y%x != 0): x = getInteger(
  ""Enter 
 number 1: ""
  ) 
  
 y = getInteger(
  ""Enter number 2: ""
  ) 
  
 if (x > 1000) or (y > 1000) or (x < 0) or (y < 0):
  
 3
 Unless you use them in a function, then you can exit the function at any time and so interrupt both the inner and 
 the outer loop. But that will follow in Chapter 8.",NA
7.6 ,NA,NA
Being smart about loops,"To complete this chapter, I want to discuss a few strategies on loop design, and, in general, 
 the design of algorithms.
  
 7.6.1 
  
 When to use a loop
  
 If you roll five 6-sided dice, how big is the probability that you roll five sixes? The answer is 
 1/
 (
 6
 5
 )
 , but suppose that you did not know that, and wanted to use a simulation to estimate 
 the probability. You can imitate the rolling of a die using randint(), and so you can imitate 
 the rolling of five dice this way. You can check whether they all show a 6. You can do that a 
 large number of times, and then divide the number of times that you rolled five sixes by the 
 number of times that you rolled five dice, to get an estimate. When I put this problem to 
 students (in a slightly more complicated form, so that the answer cannot easily be 
 calculated), I often get code that looks like this:",NA
7.7 ,NA,NA
On designing algorithms,"At this point in the book, you will often run into exercises and coding problems for which 
 you are unsure how to solve them. I gave an example of such a problem above (finding of ten 
 numbers the largest, the smallest, and the number divisible by 3), and the solution I came to. 
 Such a solution approach is called an “algorithm.” But how do you design such algorithms?
  
 I often see students typing code without really knowing what they are doing. They are trying 
 to solve a problem but do not know how, so they start typing. You may realize that this is not 
 a good approach to creating solutions (even though experimenting a bit might help).
  
 What you have to do in such a situation is sit back, leave the keyboard alone, and think“How 
 would I solve this problem as a human?” Try to write down what you would do if you would 
 do it by hand. It does not matter if what you would do is a very boring task that you would 
 never want to do by hand – you have a computer to do the boring things for you.
  
 Once you have figured out what you would do, then try to think about how you would 
 translate that to code. Because basically, that is what you need to tell the computer: the steps 
 that you as a human would take to get to a solution. If you really cannot think of any way that 
 you as a human would use to solve a problem, then you sure as hell won’t be able to tell the 
 computer how to do it for you.",NA
What you learned,"In this chapter, you learned about:",NA
Exercises,"Since loops are incredibly important and students often have problems with them, I pro-vide 
 a considerable number of exercises here. I recommend that you do them all. You will learn a 
 lot.
  
 Exercise 7.1
  Write a program that lets the user enter a number. Then the program dis-
 plays the multiplication table for that number from 1 to 10. E.g., when the user enters 12, the 
 first line printed is “1 * 12 = 12” and the last line printed is “10 * 12 = 120”.
  
 Exercise 7.2
  If you did the previous exercise with a while loop, then do it again with a for 
 loop. If you did it with a for loop, then do it again with a while loop. If you did not use a loop 
 at all, you should be ashamed of yourself.
  
 Exercise 7.3
  Write a program that asks the user for ten numbers, and then prints the 
 largest, the smallest, and how many are divisible by 3. Use the algorithm described earlier in 
 this chapter.
  
 Exercise 7.4
  “99 bottles of beer” is a traditional song in the United States and Canada. It is 
 popular to sing on long trips, as it has a very repetitive format which is easy to memorize, 
 and can take a long time to sing. The song’s simple lyrics are as follows: “99 bottles of beer 
 on the wall, 99 bottles of beer. Take one down, pass it around, 98 bottles of beer on the wall.” 
 The same verse is repeated, each time with one fewer bottle. The song is completed when 
 the singer or singers reach zero. Write a program that generates all the verses of the song 
 (though you might start a bit lower, for instance with 10 bottles). Make sure that your loop is 
 not endless, and that you use the proper inflection for the word “bottle.”
  
 Exercise 7.5
  The Fibonacci sequence is a sequence of numbers that starts with 1, 
 followed by 1 again. Every next number is the sum of the two previous numbers. I.e., the 
 sequence starts with 1, 1, 2, 3, 5, 8, 13, 21,... Write a program that calculates and prints the 
 Fibonacci sequence until the numbers get higher than 1000.",NA
Chapter 8,NA,NA
Functions,"In Chapter 5 I described how to use simple functions, and how to import functions from 
 modules. This chapter is about how to write your own functions and modules. If you do not 
 remember what Chapter 5 said about functions, re-read that chapter before continuing with 
 this one.",NA
8.1 ,NA,NA
Why create functions?,"Why would you want to create a function? There are several different reasons why you want 
 to have a function:
  
 • You may need a particular functionality for your code that you want to develop in 
 independence of the rest of the code. If you put such a functionality in a function, that 
 means that after developing and testing the functionality you can use it without 
 thinking about it anymore.
  
 • You may need a particular functionality that returns in different places in your code, 
 and rather than copy it to all these places, you write a function for it which you call in 
 all these places.
  
 • You may need a particular functionality in your code that you need to control using 
 parameters. If you put it in a function, the parameters become clearer and the code 
 becomes more readable and easy to maintain.
  
 • Your program may just be getting too long to keep a solid grasp on its contents, and you 
 feel you can improve readability and maintainability by splitting off inherently 
 connected blocks into functions.
  
 • You may have problems solving a big problem in one go, and decide to divide it into 
 sub-problems (which is usually a good idea). You can now create a function for each of 
 these sub-problems, and by connecting them together, solve the big problem.
  
 • Your program may contain deeply nested conditions or loops, and would benefit 
 enormously as far as readability is concerned by moving some of the deeper nestings 
 into functions.
  
 • You may want to re-use code in different programs, and functions are a good way to 
  
 transfer code between programs.",NA
8.2 ,NA,NA
Creating functions,"Chapter 5 described how each function has a name, may have some parameters, and may 
 have a return value. When you create your own functions, you need to define each of these.
  
 To create a function, you use the following syntax:
  
 def <function_name>( <parameter_list> ):
  
 <statements>
  
 The function name must meet the same requirements that variable names must meet, i.e., 
 only letters, digits, and underscores, and it cannot start with a digit. The parameter list 
 consists of zero or more variable names, with commas in between. The code block below the 
 function definition must be indented.
  
 Finally, be aware that Python must have “seen” your function definition before it sees the call 
 to it in your code. Therefore it is convention to place all function definitions at the top of a 
 program, right under the import statements.
  
 8.2.1 How Python deals with functions
  
 To be able to create functions, you have to know how Python deals with functions. Look at 
 the small Python program below. It defines one function, called goodbyeWorld(). That 
 function has no parameters. The code block for the function prints the line “Goodbye, world!”
  
 The rest of the program is not part of a function. We often call the parts of a program that are 
 not inside a function the “main” program. The main program prints the line “Hello, world!,” 
 and then calls the function goodbyeWorld().
  
 def goodbyeWorld(): 
  
  
 print(
  ""Goodbye , world!""
  )
  
 print(
  ""Hello, world!""
  ) 
  
 goodbyeWorld()",NA
8.3 ,NA,NA
Scope and lifetime,"Scope refers to visibility. In particular, when discussing the scope of a variable, it refers to 
 the places in a program where a variable is visible and can be changed. Lifetime refers to 
 how long a variable exists in memory. Lifetime is closely related to scope, which is why I 
 discuss them in one section.
  
 8.3.1 Scope of variables
  
 In general, the scope of a variable is at least the code block in which it is created, and all the 
 code blocks that are nested within that code block at a deeper indent level. The follow code 
 demonstrates how the scope of variables is defined for Python:
  
 5
 A little anecdote on the side here: I once heard someone extol the intellect of a certain programmer by 
 saying“when I see his code, I don’t understand any of it!” When someone would say that about my code, I would feel 
 deeply ashamed.",NA
8.4 ,NA,NA
Managing program complexity,"Suppose that Python would not have built-in max() and min() function, and neither do you 
 have knowledge of (or are allowed to) use anything of the chapters after this one. You get the 
 following assignment:
  
 Write a program that processes two groups of three numbers (you can write the program for 
 fixed numbers, but later on you will add that the user enters these numbers). It adds up the 
 lowest numbers of each of the groups, the middle numbers of each of the groups, and the 
 highest numbers of each of the groups. It then prints these three results.
  
 How do you do this? You can start with something like:
  
 # First initialize variables in group 1 (num11, num12, num13) # and in group 2 
 (num21, num22, num23) to some values.
  
 smallest1 = 0 
  
 smallest2 = 0 
  
 medium1 = 0 
  
 medium2 = 0 
  
 largest1 = 0 
  
 largest2 = 0
  
 if num11 < num12: 
  
 if num11 < num13: 
  
  
  
 smallest1 = num11",NA
8.5 ,NA,NA
Modules,"Creating a module is very simple. You just create a Python file, with extension .py, and place 
 functions in it. You can then import this Python file in another Python program (you just use 
 the name of the file without the extension .py; the file should be either in the same folder as 
 the program, or in a standard Python modules location), and access its functions just as you 
 access functions from regular Python modules, i.e., you either import specific functions from 
 the module, or you import the module as a whole, and call its functions by using the 
 <module>.<function>() syntax.
  
 8.5.1 
 main()
  
 When examining other people’s Python programs, in particular those that contain func-tions 
 that you might want to import, you often see a construct like shown below:
  
 def main():
  
 if __name__ == '__main__':
  
 main()
  
 The function main() contains the core of the program, and may call other functions.
  
 There is no need to understand this exactly, but what happens here is the following: the 
 Python file that contains the code can run as a program, or the functions that it contains can 
 be imported into other programs. The construction shown here ensures that the pro-gram 
 only executes main() (which is the core program) if the program is run as a separate 
 program, rather than being loaded as a module. If, instead, the program is loaded as a 
 module into another program, only its functions can be accessed, and the code for main() is 
 ignored.
  
 If the Python file that contains such a construct is predominantly used as a module, the 
 main() function usually contains some code that tests the functions in the module. This is 
 useful during development time.
  
 Here is an example of such a construction:",NA
8.6 ,NA,NA
Anonymous functions,"The concept of “anonymous functions” should be considered optional material: they are 
 rarely used, and never needed. However, for completeness I discuss them here.
  
 Python allows a program to create a function that has no name. The function can be as-
 signed to a variable, and the variable can then be used as if it is a function. To create an 
 anonymous function, you use the following syntax:
  
 lambda <parameters>: <statement>
  
 lambda is a keyword. 
  
 <parameters> is a sequence of parameter names, separated by 
 comma’s if there is more than one. <statement> is one single statement. The anonymous 
 function does not need the keyword return, but the value of <statement> is used as return 
 value.
  
 For instance, the following code creates an anonymous function that calculates the square of 
 its parameter. The function gets assigned to a variable f. f can then be called as a function, to 
 calculate the squares of numbers.
  
 f = lambda x: x*x 
  
 print( f(12) )
  
 This code is exactly the same as the following code:
  
 def f( x ): 
  
  
 return x*x 
  
 print( f(12) )",NA
What you learned,"In this chapter, you learned about:
  
 • The purpose of functions
  
 • Creating functions
  
 • Parameters and arguments
  
 • Returning values from functions with return
  
 • Naming conventions for functions
  
 • Commenting functions
  
 • Variable scope and lifetime
  
 • Local and global variables
  
 • Using functions to manage program complexity
  
 • Creating modules
  
 • Using a main() function
  
 • Anonymous functions",NA
Exercises,"In these exercises you write functions. Of course, you should not only write the functions, 
 you should also write code to test them. For practice, you should also comment your 
 functions as explained above.
  
 Exercise 8.1
  Create a function that gets a number as parameter, and then prints the 
 multiplication table for that number from 1 to 10. E.g., when the parameter is 12, the first 
 line printed is “1 * 12 = 12” and the last line printed is “10 * 12 = 120.”",NA
Chapter 9,NA,NA
Recursion,"Recursion is a special technique that can be used now you are able to create and use func-
 tions. Recursion can be very elegant and powerful, but students often find it hard to em-ploy. 
 That is why I decided to spend a separate chapter on it. If, while studying this chapter, you 
 feel that it is getting too complex for you, feel free to skip it for the time being. The following 
 chapters are a lot easier again.",NA
9.1 ,NA,NA
What is recursion?,"Recursion is a technique whereby a function calls itself. In a bit more general sense, it is 
 when a function makes calls in such a way that the function itself is still being executed while 
 it gets called again (e.g., function a() calls function b(), which calls function a() again).
  
 This might sound weird when you first encounter it, but there is nothing against a function 
 calling other functions, and a function can call any function that has been defined by the time 
 that the call takes place. And since a function is defined by the time its code gets executed, it 
 can call itself.
  
 “But,” one might say: “if a function calls itself, then it calls itself again, and again, and again... 
 Doesn’t that mean it gets into an endless process, similar to an endless loop?” The answer is 
 that there is certainly a danger, with sloppy coding, that a recursive function gets into an 
 endless loop, but recursive functions should be designed in such a way that that does not 
 happen.
  
 There exist many problems for which recursion is the most elegant solution. Therefore it is 
 important that you are aware of the technique, and know how and when to apply it... and its 
 limitations.",NA
9.2 ,NA,NA
Recursive definitions,"An example of a recursive definition is the definition of the factorial, which was already 
 introduced in the previous two chapters. In those chapters I gave the following definition",NA
What you learned,"In this chapter, you learned about:
  
 • Recursive functions
  
 • When to use (and when not to use) recursive functions
  
 • The purpose of recursive functions
  
 • Using return values from recursive functions",NA
Exercises,"Exercise 9.1
  A recursive definition of the
  n
 th number of the Fibonacci sequence fib(n) 
 states that fib(n) is equal to fib(n-1) + fib(n-2). Moreover, fib(1) and fib(2) are both 1. Write 
 a recursive function that you can call with an integer argument n that returns the
  n
 th 
 number of the Fibonacci sequence.
  
 Exercise 9.2
  To get a bit more insight into how recursion works, add a depth parameter 
 to your Fibonacci function from the previous exercise, that starts at zero and gets increased 
 by 1 for every deeper call. On entry of the function, print with what number argument it",NA
Chapter 10,NA,NA
Strings,"Until now, most examples and exercises have been using numbers. You might have been 
 wondering by this time if programming is just for number manipulation. In daily life, it is far 
 more commonplace to deal with textual information.
  
 The reason that dealing with texts was postponed until this point, is that dealing with 
 numbers is simply easier than dealing with texts. But in the present chapter, the first steps 
 are taken to learn to manipulate textual information.
  
 Texts, in programming languages, are dealt with in the form of strings. This chapter is on the 
 details of strings, and on readily-available functions to juggle them.",NA
10.1 ,NA,NA
What you already know about strings,"In Chapter 3, strings were quickly introduced. The brief discussion in that chapter ended 
 with the statement that a string is a text, enclosed by either single or double quotes, which 
 might be of any length, including zero characters long. The chapter also explained that you 
 can concatenate two strings using the
  +
 , and that you can create a string that is the repetition 
 of a shorter string by using a
  ∗
 . For example:
  
 s1 =
  ""apple"" 
  
 s2 = 
  
 ' banana ' 
  
 print( s1 ) 
  
 print( s2 ) 
  
 print( s1 + s2 ) 
  
 print( 3 * s1 ) 
  
 print( s2 * 3 ) 
  
 print( 2 * s1 + 2 * s2 )
  
 Chapter 5 introduced the format() function to format strings. It also explained how you can 
 get the length of a string using the len() function.
  
 String comparisons were explained in Chapter 6, in particular the fact that the comparison 
 operators compare strings using alphabetical rules, whereby capitals are always lower in",NA
10.2,NA,NA
Multi-line strings,"Strings in Python may span across multiple lines. This can be useful when you have a very 
 long string, or when you want to format the output of the string in a certain way. Multi-line 
 strings can be achieved in two ways:
  
 • With single or double quotes, and an indication that the remainder of the string con-
  
 tinues on the next line with a backslash.
  
 • With triple single or double quotes.
  
 I first demonstrate how this works when you use the regular string enclosure with one 
 double or single quote at each end of the string:
  
 listing1001.py
  
 long =
  ""I ' m fed up with being treated like sheep. What ' s the \ point of going abroad if 
 you ' re just another tourist carted \
  
 around in buses surrounded by sweaty mindless oafs from \
  
 Kettering and Coventry in their cloth caps and their cardigans \
  
 and their transistor radios and their Sunday Mirrors , \
  
 complaining about the tea -' Oh they don ' t make it properly \ here, do they, not like at 
 home ' - and stopping at Majorcan \ bodegas selling fish and chips and Watney ' s Red 
 Barrel and \
  
 calamaris and two veg and sitting in their cotton frocks \ squirting Timothy White ' s 
 suncream all over their puffy raw \
  
 swollen purulent flesh 
  
 ' cos they 
  
 ' overdid it on the first day . ' "" 
 print( long )
  
 As you can see when you run the code, Python interprets this example as a single line of text. 
 The backslash (\) can actually be included after any Python statement to indicate that it 
 continues on the next line, and it can be quite useful for that, for instance when you write 
 long calculations.
  
 The recommended way to write multi-line strings in Python is, however, to use triple dou-
 ble or single quotes. I indicated earlier that you can use those to write multi-line comments. 
 Such comments are basically large strings in the middle of your Python program, which do 
 nothing as they are not assigned to a variable.
  
 Here is an example of a long string with triple double quotes:",NA
10.3 ,NA,NA
Escape sequences,"""\n"" is a so-called “escape sequence.” An escape sequence is a string character written as a 
 backslash followed by a code, which can be one or multiple characters. Python interprets 
 escape sequences in a string as a special character.",NA
10.4 ,NA,NA
Accessing characters of a string,"As I showed several times before, a string is a collection of characters in a specific order. You 
 can access the individual characters of a string using indices.
  
 10.4.1 String indices
  
 Each symbol in a string has a position, this position can be referred to by the index number 
 of the position. The index numbers start at 0 and then increase to the length of the string. 
 The following table shows the word “python” in the first row and the indices for each letter 
 in the second and third rows:
  
 p
  
 y
  
 t
  
 h
  
 o
  
 n
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 -6 -5 -4 -3 -2 -1
  
 As you can see, you can use positive indices, which start at the first letter of the string and 
 increase until the end of the string is reached, or negative indices, which start with -1 for the 
 last letter of the string and decrease until the first letter of the string is reached.
  
 As the length of a string s is len(s), the last letter of the string has index len(s)-1. With 
 negative indices, the first letter of the string has index -len(s).
  
 If a string is stored in a variable, the individual letters of the string can be accessed by the 
 variable name and the index of the requested letter between square brackets ([]) next to it.",NA
10.5,NA,NA
Strings are immutable,"A core property of strings is that they are immutable. This means that they cannot be 
 changed. For instance, you cannot change a character of a string by assigning a new value to 
 it. As a demonstration, the following code leads to a runtime error if you try to run it:
  
 fruit =
  ""oringe"" 
  
 fruit[2] =
  ""a"" 
  
 # Runtime error!
  
 print( fruit )
  
 If you want to make a change to a string, you have to create a new string that contains the 
 change; you can then assign the new string to the existing variable if you want. For instance:
  
 fruit =
  ""oringe"" 
  
 fruit = fruit[:2] +
  ""a""
  + fruit[3:] print( fruit )
  
 The reasons for why strings are immutable are beyond the scope of this book. Just remem-
 ber that if you want to modify a string you need to overwrite the entire string, and you 
 cannot modify individual indices.",NA
10.6 ,NA,NA
string,NA,NA
 methods,"There is a collection of methods that are designed to operate on strings. All of these meth-
 ods are applied to a string to perform some operation. Since strings are immutable, they 
 never change the string they work on, but they always return a changed version of the string.",NA
10.7 ,NA,NA
Character encoding,"All systems use a particular way of encoding characters. The basic encoding that (al-most) 
 every system supports is the standard ASCII code. This is a 7-bits code, which can represent 
 128 different characters. Several of these (in particular those with the lowest-numbered 
 encodings) are control characters that have a special function. Most of these special 
 functions are only useful for archaic computer systems, but the tabulation, new-line, and 
 backspace characters are found amongst them. If you only use characters on a standard US 
 keyboard, you are limited to ASCII characters.
  
 Nowadays, many systems use Unicode. Unicode supports far more characters. There are 
 different formats for storing characters in Unicode. The best-known is UTF-8, which uses 
 one byte for each of the ASCII characters, but multiple bytes for all the other characters (a 
 byte is a group of 8 bits, whereby each bit contains either a 1 or a zero). Other Unicode 
 encodings use multiple bytes to store any character. Python, be default, works with UTF-8, 
 which means that it also supports regular ASCII encodings.
  
 10.7.1 ASCII
  
 Below I display the ASCII table. The only characters I have left off are those which are control 
 sequences. These have the numbers zero to 31, and 127. 32 is the space. I also",NA
What you learned,"In this chapter, you learned about:
  
 • Strings
  
 • Multi-line strings
  
 • Accessing string characters with positive and negative indices
  
 • Slices
  
 • Immutability of strings
  
 • strip(), upper(), lower(), find(), replace(), split(), and join()
  
 • Escape sequences
  
 • ASCII and UTF-8 encodings",NA
Exercises,"Exercise 10.1
  Count how many of each vowel (a, e, i, o, u) there are in a text string, and 
 print the count for each vowel with a single formatted string. Remember that vowels can be 
 both lower and uppercase.
  
 Exercise 10.2
  Below is a text with several characters enclosed in square brackets [ and ]. 
 Scan the text and print out all characters which are between square brackets.
  
 exercise1002.py
  
 text =
  """"""And sending tinted postcards of places they don ' t realise they haven ' t even 
 visited to 
  
 ' All at nu[m]ber 22, weather
  
 w[on]derful, our room is marked with an 
  
 ' X '. Wish you were here. Food 
 very greasy but we ' ve found a charming li[t]tle local place hidden awa[y ]in the back 
 streets where they serve Watney ' s Red
  
 Barrel and cheese and onion cris[p]s and the accordionist pla[y]s ""Maybe i[t ] ' s because I ' 
 m a Londoner "" ' and spending four days on
  
 the tarmac at Luton airport on a five-day package tour wit[h] n[o]thing to eat but dried 
 Watney ' s sa[n]dwiches...""""""",NA
Chapter 11,NA,NA
Tuples,"A tuple is a group of one or more values that are treated as a whole. This chapter explains 
 how to recognize and use tuples.",NA
11.1 ,NA,NA
Using tuples,"A tuple is a group of one or more values, separated by commas. Normally, tuples are writ-ten 
 with parentheses around them, but the parentheses are not actually necessary (except in 
 circumstances where otherwise confusion would arise). For example:
  
 t1 = (
 ""apple""
 ,
  ""orange""
 ) 
  
 print( type( t1 ) ) 
  
 t2 =
  ""banana""
 ,
  ""cherry"" 
  
 print( type( t2 ))
  
 You can mix data types within tuples. You can even put tuples in tuples.
  
 t1 = (
 ""apple""
 , 3, 1.4) 
  
 t2 = (
 ""apple""
 , 3, 1.4, (
 ""banana""
 , 5))
  
 To find out how many elements a tuple contains, you can use the len() function.
  
 t1 = (
 ""apple""
 ,
  ""orange""
 ) 
  
 t2 = (
 ""apple""
 , 3, 1.4) 
  
 t3 = (
 ""apple""
 , 3, 1.4, (
 ""banana""
 , 5)) print( len( t1 ) ) 
  
 print( len( t2 ) ) 
  
 print( len( t3 ) )
  
 Note that in this example, the length of t3 is 4, and not 5. The last element of t3 is the tuple 
 (
 ""banana""
 , 5), which counts as one element.
  
 You can use a for loop to access individual elements of a tuple in sequence.",NA
11.2 ,NA,NA
Tuples are immutable,"Just like strings, tuples are immutable. This means that you cannot assign a new value to one 
 element of a tuple. The example below will produce a runtime error when run.
  
 t1 = (
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ) t1[0] =
  ""orange""",NA
11.3,NA,NA
Applications of tuples,"Tuples are not used often in Python code (except as return values of functions). A logical 
 application of tuples would be to deal with values that always occur in small collections. 
 However, object orientation (Chapter 20 and further) offers many tools and techniques to 
 deal with such small collections, which means that programmers usually revert to object 
 orientation when they need something like that.
  
 For the moment, here is an example of the use of tuples in an application. Suppose that you 
 have to write a program that deals with geometric figures in 2-dimensional space. A concept 
 that you need is that of a point: a location in 2D space that is identified by two coordinates. 
 Rather than write functions that always require a separate X-coordinate and a separate Y-
 coordinate, you can specify that coordinates are always communicated in the form of tuples.
  
 listing1103.py
  
 from math import sqrt 
  
 # Returns the distance between two points in 2-dimensional space. # The points are the 
 parameters of the function; each point is a # tuple of two numeric values.",NA
What you learned ,"In this chapter, you learned about:
  
  
 • Tuples
  
  
 • Tuple assignments",NA
Exercises,"Exercise 11.1
  A complex number is a number of the form a + b
 i
 , whereby a and b are 
 constants, and
  i
  is a special value that is defined as the square root of -1. Of course, you never 
 try to actually calculate what the square root of -1 is, as that gives a runtime error; in 
 complex numbers, you always let the
  i
  remain. For instance, the complex number 3 + 2
 i 
 cannot be simplified any further. Addition of two complex numbers a + b
 i
  and c + d
 i
  is 
 defined as (a + c) + (b + d)
 i
 . Represent a complex number as a tuple of two numeric values, 
 and create a function that calculates the addition of two complex numbers.
 8
  
 Exercise 11.2
  Multiplication of two complex numbers a + b
 i
  and c + d
 i
  is defined as (a*c - 
 b*d) + (a*d + b*c)
 i
 . Write a function that calculates the multiplication of two complex 
 numbers.
  
 Exercise 11.3 
  
 Consider the definition of a new datatype. 
  
 The new datatype is the 
 inttuple. 
  
 An inttuple is defined as being either an integer, or a tuple consisting of 
 inttuples. You see an example of an inttuple in the code block below. Write a func-tion that 
 prints all the integer values stored in an inttuple. Hint: Since the inttuple is defined 
 recursively, a recursive function is probably the right approach. If you skipped Chapter 9, 
 you probably should skip this exercise too. Use the isinstance() function (ex-plained in 
 Chapter 8) to determine whether you are dealing with an integer or a tuple. If you do this 
 correctly, for the inttuple given below, the function will print the numbers 1 to 20 
 sequentially.
  
 exercise1103.py
  
 inttuple = ( 1, 2, ( 3, 4 ), 5, ( ( 6, 7, 8, ( 9, 10 ), 11 ), 12, 
  
 13 ), ( ( 14, 15, 16 ), ( 17, 18, 19, 
 20 ) ) )
  
 8
 Actually, Python supports a separate data type complex that represents complex numbers, so there is not really 
 a need to deal with complex numbers as tuples, but for the purpose of practicing with tuples this exercise works 
 fine.",NA
Chapter 12,NA,NA
Lists,"Lists are ordered collections of data items, just like tuples. The major difference with tuples 
 is that lists are mutable. This makes them a highly flexible data structure, that you will find 
 many uses for.",NA
12.1 ,NA,NA
List basics,"A list is a collection of elements.
  
 The elements of a list are
  ordered
 . Because they are ordered, you can access each of the 
 elements of a list using an index, just like you can access the characters of a string, and just 
 like you can access the elements of a tuple. Indices start at zero, just as with strings.
  
 In Python, lists are recognizable from the fact that they enclose their elements in square 
 brackets ([]). You can get the number of elements in a list by using the len() function. You 
 can use a for loop to traverse the elements of a list. You can mix data types in a list. You can 
 apply the max(), min() and sum() functions to a list. You can test for the existence of an 
 element in a list using the in operator (or for the non-existence by using not in).",NA
12.2 ,NA,NA
Lists are mutable,"Because lists are mutable, you can change the contents of a list.
  
 To overwrite an element of a list, you can assign a new value to it.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ,
  ""orange""
 ] print( fruitlist ) 
  
 fruitlist[2] =
  ""strawberry"" 
  
 print( fruitlist )
  
 You can also overwrite list slices by assigning a new list to the slice. The slice you remove 
 need not be of equal length to the new list you insert.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ,
  ""orange""
 ] print( fruitlist ) 
  
 fruitlist[1:3] = [
 ""raspberry""
 ,
  ""strawberry""
 ,
  ""blueberry""
 ] print( fruitlist )
  
 You can insert new elements into a list by assigning them to an empty slice.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ,
  ""orange""
 ] print( fruitlist ) 
  
 fruitlist[1:1] = [
 ""raspberry""
 ,
  ""strawberry""
 ,
  ""blueberry""
 ] print( fruitlist )
  
 You can delete elements from a list by assigning an empty list to a slice.",NA
12.3 ,NA,NA
Lists and operators,"Lists support the use of the operators
  +
  and
  ∗
 . These operators work similar as to how they 
 work for strings.
  
 You can add two lists together with the
  +
  operator, the result of which is a list which 
 contains the elements of both lists involved. Of course, you have to assign the result to a 
 variable to store it.
  
 You can multiply a list by a number to create a list that contains the elements of the original 
 list, repeated as often as the number indicates. This can be a fast approach to create a list 
 with all equal elements.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ] + [
 ""cherry""
 ,
  ""durian""
 ] print( fruitlist ) 
  
 numlist = 10 * [0] 
  
 print( numlist )
  
 Note: With the
  +
  you can add a list to another list, but you cannot add a new element to a list, 
 unless you turn that new element into a list with a single element by putting two square 
 brackets around it. If you try to add something to a list that is not a list, Python will try to 
 interpret it as a list – if it can do that (which it can, for instance, for a string, which it can 
 consider a list of letters); it will then still do the addition but the result will not be what you 
 want. For instance, the code below tries to add a ""cherry"" to a list, but only the second 
 addition actually does what is intended.
  
 listing1202.py
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ] 
  
 fruitlist +=
  ""cherry"" 
  
 print( fruitlist )
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ] 
  
 fruitlist += [
 ""cherry""
 ] 
  
 print( fruitlist )",NA
12.4,NA,NA
List methods,"Python supports many methods to change lists or get information from them. You do not 
 need to import a module to use them. Since they are methods, you call them using the syntax 
 <list>.<method>().
  
 Important!
  Lists are mutable and these methods actually change the list! It is not as you are 
 used to with string methods, where the methods create a new string, and return it, while the 
 original string remains. Most list methods have an irrevocable effect on the list they work on. 
 Usually they have no return value, and you do not need one either, as the purpose of the 
 methods is to change the list.
  
 12.4.1 
 append()
  
 append() attaches an item at the end of a list. You call the method with the item you wish to 
 add as argument.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] print( fruitlist ) 
  
 fruitlist.append(
  ""orange""
  ) 
  
 print( fruitlist )
  
 An alternative for using the append() method is to add a list with one new element to the 
 existing list with a
  +
 , and assign the resulting list to the original list variable. However, the 
 append() method is preferable as it is more readable. <list>.append(<element>) is equiv-
 alent to <list>[len(<list>):] = [<element>], or simply <list> += [<element>].
  
 12.4.2 
 extend()
  
 extend() makes a list longer by appending the elements of another list at the end. You call 
 the method with the list of which you want to add the elements as argument.
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] 
  
 print( fruitlist ) 
  
 fruitlist.extend( [
 ""raspberry""
 ,
  ""strawberry""
 ,
  ""blueberry""
 ] ) print( fruitlist )
  
 Just as with the append() method, you can extend an existing list with a new list by simply 
 using the
  +
  operator, and assigning the result to the original list variable. And just as with the 
 append() method, the extend() method is preferable. <list>.extend(<addlist>) is equivalent 
 to <list>[len(<list>):] = <addlist>.
  
 12.4.3 
 insert()
  
 insert() allows you to insert an element at a specific position in a list. It is called with two 
 arguments, the first being the index of the location where you wish to insert the new 
 element, and the second the new element itself. To insert an element at the front of the list, 
 you can use index 0.",NA
12.5,NA,NA
Aliasing,"If you assign a variable that contains a list to another variable, you might expect that you 
 create a copy of the list in the second variable. But you are not doing that. You are actually 
 creating an
  alias
  for the list, i.e., a new variable that is referring to the same list. This means 
 that the new variable can be treated as a list, but any change that you make to the list it 
 refers to, is visible in the original list variable, and vice versa. They are not different lists.
  
 listing1208.py
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] newfruitlist = fruitlist 
  
 print( fruitlist ) 
  
 print( newfruitlist ) 
  
 newfruitlist[2] =
  ""orange"" 
  
 print( fruitlist ) 
  
 print( newfruitlist )
  
 Every variable in Python has an identification number. You can see it with the id() func-tion. 
 The ID number indicates which memory spot the variable refers to. For an alias of a list, the 
 ID is the same as for the original list.
  
 listing1209.py
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] newfruitlist = fruitlist 
  
 print( id( fruitlist ) ) 
  
 print( id( newfruitlist ) )
  
 If you want to create a copy of a list, you can do so using a little trick. Instead of using 
 <newlist> = <oldlist>, you use the command <newlist> = <oldlist>[:].
  
 listing1210.py
  
 fruitlist = [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] newfruitlist = fruitlist 
  
 verynewfruitlist = fruitlist[:]
  
 print( id( fruitlist ) ) 
  
 print( id( newfruitlist ) ) 
  
 print( id( verynewfruitlist ) )
  
 fruitlist[2] =
  ""orange"" 
  
 print( fruitlist ) 
  
 print( newfruitlist ) 
  
 print( verynewfruitlist )
  
  
 12.5.1
  
 is
  
 The keyword is is introduced to compare the identities of two variables.",NA
12.6 ,NA,NA
Nested lists,"The elements of a list may be lists themselves (which also may contains lists, etcetera). This 
 is a good way to create a matrix in a program. For instance, you can create a Tic-Tac-Toe 
 board, where a dash (-) represents an empty cell, as follows:
  
 board = [ [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ], [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ], [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ] ]
  
 The first row of the board is represented by board[0], the second row by board[1], and the 
 third row by board[2]. If you want to access the first cell of the first row, that is board[0][0], 
 the second cell is board[0][1] and the third cell is board[0][2]. For ex-ample, the following 
 code places an “X” in the middle of the board, and an “O” in the upper right corner. It also 
 displays the board in a nice way (with markers for rows and columns around it).
  
 listing1216.py
  
 def display_board( b ): 
  
  
 print(
  "" 
  
  
 1 2 3""
  ) 
  
  
 for row in range( 3 ): 
  
  
  
 print( row+1, end=
 "" ""
 ) 
  
  
  
 for col in range( 3 ): 
  
  
  
  
 print( b[row][col], end=
 "" ""
  ) 
  
  
 print()
  
 board = [ [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ], [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ], [
 ""-""
 ,
  ""-""
 ,
  ""-""
 ] ] board[1][1] =
  ""X"" 
  
 board[0][2] =
  ""O"" 
  
 display_board( board )",NA
12.7,NA,NA
List casting,"You can type cast a sequence of elements to a list using the list() function. The code below 
 turns a tuple into a list.
  
 t1 = (
  ""apple""
 ,
  ""banana""
 ,
  ""cherry""
  ) print( t1 ) 
  
 print( type( t1 ) ) 
  
 fruitlist = list( t1 ) 
  
 print( fruitlist ) 
  
 print( type( fruitlist ) )",NA
12.8 ,NA,NA
List comprehensions,"List comprehensions are a concise way to create lists. They are typical for Python, but you do 
 not find them in many other programming languages. They are not actually needed, as you 
 can use functions to achieve the same effect, but as they are often used in examples 
 (especially by people who want to show off their Python abilities to create short statements 
 that have extensive effects), I thought it prudent to discuss them. If you are never going to 
 use them in your own code, that is fine as they are completely optional. But you should be 
 able to recognize them in other people’s code.
  
 Suppose that you want to create a list consisting of the squares of the numbers 1 to 25. A 
 function that creates such a list is:
  
 def squareslist(): 
  
  
  
 squares = [] 
  
  
 for i in range( 1, 26 ): 
  
  
   
 squares.append( i*i ) 
  
  
  
 return squares
  
 sl = squareslist() 
  
 print( sl )
  
 In Python, you can create that list with one single statement, namely as follows:
  
 sl = [ x*x for x in range( 1, 26 ) ] print( sl )
  
 Now suppose that you want to create this list, but want to leave out (for some reason) the 
 squares of any numbers that end in 5. That would add at least two lines to the function 
 above, but with list comprehensions you can still do it with that single line:
  
 sl = [ x*x for x in range( 1, 26 ) if x%10 != 5] print( sl )
  
 A list comprehension consists of an expression in square brackets, followed by a for clause, 
 followed by zero or more for and/or if clauses. The result is a list that contains the",NA
What you learned,"In this chapter, you learned about:
  
 • Lists
  
 • Mutability of lists
  
 • Using
  +
  and
  ∗
  with lists
  
 • List methods append(), extend(), insert(), remove(), pop(), index(), count(), 
  
 sort(), and 
 reverse()
  
 • del with lists
  
 • Aliasing
  
 • The keyword is
  
 • Creating list copies
  
 • Creating deep copies of lists using deepcopy()
  
 • Using lists as arguments
  
 • Nested lists
  
 • List casting
  
 • List comprehensions",NA
Exercises,"Exercise 12.1
  A magic 8-ball, when asked a question, provides a random answer from a 
 list. The code below contains a list of possible answers. Create a magic 8-ball program that 
 asks a question, then gives a random answer.",NA
Chapter 13,NA,NA
Dictionaries,"Strings, tuples and lists are ordered data structures, which entails that they can be indexed. 
 Not all data is naturally ordered, which is why Python offers dictionaries as a way to struc-
 ture unordered data.",NA
13.1 ,NA,NA
Basics of dictionaries,"Dictionaries are unordered collections of elements. To identify an element, you have to know 
 the element’s “key.”
  
 Basically, dictionaries store “key-value pairs.” Any immutable data type can function as a 
 key. A very common type to use as key is the string.
  
 You create dictionaries using curly brackets {}, similar to how you create lists using square 
 brackets. An empty dictionary you create by assigning {} to a variable. You can create a 
 dictionary with contents by describing every element of the dictionary between the curly 
 brackets using the syntax <key>:<value>, and commas between the elements.
  
 Here a dictionary fruitbasket is created, that contains three key-value pairs, namely the key 
 ""apple""
  with value 3, the key
  ""banana""
  with value 5, and the key
  ""cherry""
  with value 50.
  
 fruitbasket = {
  ""apple""
 :3,
  ""banana""
 :5,
  ""cherry""
 :50 }
  
 To access the value belonging to a specific key, you use the same syntax as you would use for 
 a list, except that you write the key in the place where you would write the index for a list.
  
 fruitbasket = {
  ""apple""
 :3,
  ""banana""
 :5,
  ""cherry""
 :50 } print( 
 fruitbasket[
 ""banana""
 ] )
  
 You can use a for loop to traverse a dictionary. The variable in the for loop gets access to all 
 the keys.",NA
13.2 ,NA,NA
Dictionary methods,This section describes the dictionary methods that are most often used.,NA
13.3,NA,NA
Keys,"As I said, any immutable data type can be a dictionary key. This means that strings, inte-gers, 
 and floats can all be used as keys. You may remember that tuples are also immutable, which 
 entails that you can use tuples as keys. This can occasionally be useful.
  
 A very straightforward example of tuples being useful as keys is a dictionary in which you 
 want to store information associated with points in two-dimensional space (a discussion of 
 which was given in Chapter 11). There is no good way in which you can store the 
 identification of a point in a single number or string. It is not impossible (for instance, you 
 could store the number-pair as their string-representations, concatenated with a comma in 
 between) but it becomes ambiguous and convoluted (for instance, the string-keys
  ""2,3""
 , 
 ""2, 
 3""
 ,
  ""+2,+3""
 , and
  ""02,03""
  would all be representing the same tuple but different keys).",NA
13.4 ,NA,NA
Storing complicated values,"Until now I only considered the case in which a dictionary stores a single value of a simple 
 data type. However, it is possible to store much more complex values in dictionaries. Val-ues 
 can be arbitrary Python objects. For example, you can store a list with each key. Below a 
 dictionary is used to store the students who are following a course. The course is identified 
 by its course number, while the students are identified by their student numbers.
  
 listing1308.py
  
 courses = {
  
 ' 880254 '
  :[
  ' u123456 '
  ,
  
 ' u383213 '
  ,
  
 ' u234178 '
  ],
  
 ' u234178 '
  ]}
  
 ' 822177 '
  :[
  ' u123456 '
  ,
  
 ' u223416 '
  ,
  
 ' u234178 '
  ],
  
 ' 822164 '
  :[
  ' u123456 '
  ,
  
 ' u223416 '
  ,
  
 ' u383213 '
  ,
  
 for c in courses: 
  
  
 print( c ) 
  
  
 for s in courses[c]: 
  
  
  
 print( s, end=
 "" ""
  ) 
  
  
 print()
  
 Suppose that you do not only want to store the student numbers for a course number, but 
 also the name of the course, the ECTS value of the course, and for each student number also 
 the grade. You can do that (for example) by storing the value for a course number as a 
 dictionary, with three keys, namely
  ""name""
 ,
  ""ects""
 , and
  ""students""
 . The value for
  ""name"" 
 is 
 the course name as a string, the value for
  ""ects""
  is the ECTS as an integer, and the value for
  
 ""students""
  is another dictionary, which contains student numbers as keys and grades as 
 values.
  
 listing1309.py
  
 courses = {
  
 ' 880254 '
  : {
  ""name""
 :
 ""RS: Data Processing""
 ,
  ""ects""
 :3,
  
 ""students""
 :{
  ' u123456 '
  :8, 
  
 ' u383213 '
  :7.5, 
 ' u234178 '
  :6} },
  
 ' 822177 '
  : {
  ""name""
 :
 ""Understanding Intelligence""
 ,
  ""ects""
 :6,
  
 ""students""
 :{
  ' u123456 '
  :5, 
  
 ' u223416 '
  :7, 
  
 ' u234178 '
  :9} },",NA
13.5 ,NA,NA
Lookup speed,"Lists and dictionaries are the two most-used data structures in Python. While often it is clear 
 when you should use which data structure, it is helpful if you know a little bit about how 
 Python processes these data structures in case you have a choice.
  
 Suppose that you read a large bunch of numbers from a file. The numbers are all different 
 and can be anything. You later need to compare the numbers on another list to the numbers 
 that you read from the file.
  
 Should you use a list or a dictionary to store the numbers that you read from the file? Since 
 they are just numbers, without extra data, a list seems to be the best option. There is, 
 however, a problem if you use a list here. Check out the following code, in which a list of 
 10000 numbers is created, and after that some code checks for 10000 different numbers 
 whether they are on the list (which none of them are).
  
 listing1310.py
  
 from datetime import datetime 
  
 numlist = [] 
  
 for i in range( 10000 ): 
  
  
  
 numlist.append( i ) 
  
 start = datetime.now() 
  
 count = 0 
  
 for i in range( 10000, 20000 ): 
  
  
 if i in numlist: 
  
  
   
 count += 1 
  
 end = datetime.now() 
  
 print(
  ""{}.{} seconds needed to find {} numbers""
 .format( 
  
  
 (end - start).seconds , (end - start).microseconds ,count ) )",NA
What you learned,"In this chapter, you learned about:
  
 9
 Technically, Python stores the keys for the dictionary in a so-called “hash table.” I will not explain the details here, 
 and just tell you that a hash table allows for very fast look-up of keys at the cost of some memory.",NA
Excercises,"Exercise 13.1
  Write a program that takes a text (for instance the one given below), splits 
 it into words (where everything that is not a letter is considered a word boundary), and 
 case-insensitively builds a dictionary that stores for every word how often it occurs in the 
 text. Then print all the words with their quantities in alphabetical order.
  
 exercise1301.py
  
 text =
  """"""How much wood would a woodchuck chuck If a 
 woodchuck could chuck wood?
  
 He would chuck, he would, as much as he could, And chuck as 
 much as a woodchuck would 
  
 If a woodchuck could chuck wood.""""""
  
 Exercise 13.2
  The code block below shows a list of movies. For each movie it also shows 
 a list of ratings. Convert this code in such a way that it stores all this data in one dictionary, 
 then use the dictionary to print the average rating for each movie, rounded to one decimal.
  
 exercise1302.py
  
 movies = [
 ""Monty Python and the Holy Grail""
 , 
  
 ""Monty Python ' s Life of Brian""
 , 
  
 ""Monty Python ' s Meaning of Life""
 , 
  
 ""And Now For Something Completely Different""
 ]
  
 grail_ratings = [ 9, 10, 9.5, 8.5, 3, 7.5,8 ] 
  
 brian_ratings = [ 10, 10, 0, 9, 1, 8, 7.5, 8, 6, 9 ] life_ratings = [ 7, 6, 5 ] 
  
 different_ratings = [ 6, 5, 6, 6 ]
  
 Exercise 13.3
  A library contains books. Books have a writer, identified by last name and 
 first name. Books also have a title. Books also have a location number that identifies where 
 they can be found in the library. Librarians want to be able to locate a specific book if they 
 know writer and title, and they want to be able to list all the books that they have of a 
 specific writer. What data structure would you use to store the books?",NA
Chapter 14,NA,NA
Sets,"Sets are unordered data structures, which contain only unique elements. Few program-ming 
 languages support sets natively, but Python is one of them. Sets are not used often, but 
 occasionally they provide a nice solution to a problem that you are trying to solve, when you 
 need to ensure that you only have unique solution items.",NA
14.1 ,NA,NA
Basics of sets,"Sets are unordered collections of elements. You cannot access specific elements using an 
 index or a key. The only way to access items in a set is by using a for loop, or by testing for 
 the existence of elements in the set using the in operator.
  
 You have to think of sets in the mathematical sense. In mathematics, a set is a collection of 
 elements, all unique, and elements can be part of a specific set, or not part of the set. You use 
 special set operators to combine sets in different ways.
  
 Python uses dictionaries to implement sets; specifically, it implements the elements of a set 
 as dictionary keys. Thus, only immutable data types can be set elements. Sets themselves, 
 however, are mutable.
  
 Since Python uses dictionaries to implement sets, you might think that you can create an 
 empty set by assigning {} to a variable. That, however, does not work as it creates an empty 
 dictionary, not an empty set. Instead, you create an empty set by assigning a call to the 
 function set() to a variable.
  
 To create a set with some elements already in it, you can assign the elements to the variable 
 between curly brackets. Alternatively, you can call the set() function with a list of the 
 elements as argument.
  
 fruitset = {
  ""apple""
 ,
  ""banana""
 ,
  ""cherry""
  } print( fruitset )
  
 If you want to create a set consisting of the different characters in a string, you can call set() 
 with the string as argument.",NA
14.2 ,NA,NA
Set methods,"To manipulate the contents of sets, the following methods are supported. This is not a 
 complete list of set methods, but these are the most common ones.
  
 14.2.1 
 add()
  and
  update()
  
 Adding new items to a set you can do using the add() method, to add one new element that 
 you provide as an argument. If you want to add multiple new elements at once, you can use 
 the update() method, which you provide with a list of the new elements as argument. You 
 can also use update() with a tuple as argument, and you can even use it with a string as 
 argument. If you use it with a string, it will consider each letter of the string as a separate 
 element to add.
  
 Since sets can only contain unique elements, any duplicate element that you try to add will 
 be ignored.
  
 listing1402.py
  
 fruitset = {
  ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ,
  ""mango""
  } print( fruitset ) 
  
 fruitset.add(
  ""apple""
  ) 
  
 fruitset.add(
  ""elderberry""
  ) 
  
 print( fruitset ) 
  
 fruitset.update( [
 ""apple""
 ,
 ""apple""
 ,
 ""apple""
 ,
 ""strawberry""
 , 
  
 ""strawberry""
 ,
 ""apple""
 ,
 ""mango""
 ] ) 
  
 print( fruitset )",NA
14.3 ,NA,NA
Frozensets,"Python supports a variant on the set type, namely the frozenset. You create a frozenset by 
 using the frozenset() function. The elements of a frozenset, once assigned, can-not be 
 changed. You therefore have to create the frozenset immediately when you call the 
 frozenset() function, because it is impossible to add or remove elements later. I.e., frozensets 
 are immutable.
  
 All the regular set methods work for frozensets, except for those that try to change the set. 
 Trying to use such a method for a frozenset will lead to a syntax error.
  
 fruit1 = frozenset( [
 ""apple""
 ,
  ""banana""
 ,
  ""cherry""
 ] ) fruit2 = frozenset( 
 [
 ""banana""
 ,
  ""cherry""
 ,
  ""durian""
 ] )
  
 print( fruit1.union( fruit2 ) )",NA
What you learned,"In this chapter, you learned about:",NA
Exercises,"Exercise 14.1
  A famous syllogism says:
  All men are mortal. Socrates is a man. Therefore 
 Socrates is mortal.
  In the code block below you see some sets. The first is the set of all things 
 (I know a few are missing, but for the sake of argument). The second is the set of all men 
 (assuming that the first set indeed contains all things). The third set contains everything that 
 is mortal (again, assuming...). Using set operators and methods, show that indeed (a) all men 
 are mortal, (b) Socrates is a man, and (c) Socrates is mortal. Also shows that (d) there are 
 mortal things that are not men, and (e) there are things that are not mortal.
  
 exercise1401.py
  
 allthings = {
 ""Socrates""
 ,
  ""Plato""
 ,
  ""Eratosthenes""
 ,
  ""Zeus""
 ,
  ""Hera""
 , 
  
 ""Athens""
 ,
  ""Acropolis""
 ,
  
 ""Cat""
 ,
  ""Dog""
 } 
  
 men = {
 ""Socrates""
 ,
  ""Plato""
 ,
  ""Eratosthenes""
 } 
  
 mortalthings = {
 ""Socrates""
 ,
 ""Plato""
 ,
 ""Eratosthenes""
 ,
 ""Cat""
 ,
 ""Dog""
 }
  
 Exercise 14.2
  Write a program that first produces three sets of numbers between 1 and 
 1000, the first all those numbers that are divisible by 3, the second all those numbers that 
 are divisible by 7, and the third all those numbers that are divisible by 11. It is easiest to do 
 that with list comprehension, but it is not necessary. Now produce sets of all the numbers 
 between 1 and 1000 that (a) are divisible by 3, 7, and 11, (b) are divisible by 3 and 7, but not 
 by 11, (c) that are not divisible by 3, 7, or 11. The shortest solution has only one line of code 
 for each of the six sets.",NA
Chapter 15,NA,NA
Operating System,"Until now, we considered Python programs as self-contained functionalities. Python pro-
 grams, however, run on a computer, and occasionally the program must deal with com-puter 
 intricacies. This will start to play a major role from Chapter 16 onward, when I will discuss 
 file handling. To deal with the computer, Python offers a series of standard func-tionalities in 
 the os module, whereby os is a common abbreviation for “operating system.”This chapter 
 explains the most important functions from the os module.",NA
15.1 ,NA,NA
Basics of operating systems,"A computer consists of hardware, while programs consist of software. The software uses 
 facilities offered by the hardware. While in the early days of computer programming, pro-
 grammers accessed hardware directly (for instance, to make a pixel visible on a computer 
 screen, a programmer placed a value in a specific memory address that was directly cou-pled 
 to the screen – an approach called “poking”), nowadays hardware is so complex and diverse 
 that this is no longer a viable approach. Let alone the fact that if you want to write a program 
 that runs on multiple computers, you cannot afford to access hardware directly as hardware 
 differs from computer to computer.
  
 Therefore, programs access hardware functionalities through an “operating system.” An 
 operating system can be seen as a layer between programs and hardware, that offers pro-
 grams high-level functions to get the hardware to work. Typical operating systems in use 
 nowadays on personal computers are Microsoft’s “Windows,” Apple’s “Mac OS,” and the 
 open-source OS “Linux” (though there are many more). Each of these exists in multiple 
 variants, often differentiated by numbers or “builds,” and sometimes (in the case of Linux) 
 by a company name. Regardless, they all offer functionalities that allow accessing hard-ware.
  
 The problem is that while all of them offer such functionalities, the functionalities are not 
 named in consistent ways, and have different parameterizations. This means that if you want 
 to write Python programs that access hardware by directly “talking” to the operat-ing 
 system, your program is not portable to other operating systems. This is where the os 
 module comes in. The os module offers functions that you can use to access the hardware",NA
15.2 ,NA,NA
Command prompt,"When you are working with a mouse-driven user interface (UI), which is standard for Win-
 dows and Mac OS, and is used by many Linux users too, you are actually interacting with a 
 visual representation of the system, specifically, of the file system. Programs and doc-uments 
 are represented by “icons,” which have a name. They are grouped by “folders,”which are 
 actually “directories” of the file system. You can create new folders, delete docu-ments, 
 rename programs, change security settings, etcetera. All these actions you can also execute 
 by directly typing commands, in an environment that is often called the “command prompt” 
 or “command shell.”
  
 Most Linux users are familiar with a command shell, but for many Windows and Mac users 
 this is not something that they are aware of. Both Windows and Mac actually have a program 
 that allows you to work in the command shell. On Windows, you find the“command prompt” 
 as one of the “accessories” or “system tools.” On Macs, this is called the “Terminal.” If you 
 start that program, you get confronted by a window with a black background and a blinking 
 prompt. Here you can type commands that the system will execute for you.
  
 The commands that you can give depend on the system that you are using. This book is not 
 meant to teach you how to use it, but I want to tell you at least that you can run Python 
 programs directly from the command prompt by typing the command:
  
 python <programname>.py
  
 As long as Python can be found on your system, and the program is actually found in the 
 current working directory (i.e., the place in the computer’s file system where you currently 
 are), or you have specified the complete path for the program, then it will run the program. 
 This can actually be quite handy if you have written a program that processes files and you 
 want to process many files in a “batch.” Again, this goes a bit too far for this book, but you 
 might get to a point in your career where this is extremely useful.
  
 The commands that you can give are things like “change the current working 
 directory,”“make a new directory,” “remove an empty directory,” “list all the files in the 
 directory,”“delete a file,” etcetera. Again, it depends on the operating system what exactly the 
 com-mands are that you need to give to achieve these things.
  
 Exercise
  On your system, find the command shell and run the program. On Windows, type 
 “dir” to see the files in the current directory. On Macs and Linux, this command is usually 
 “ls.” After doing this, you can close the command shell again.",NA
15.3,NA,NA
File system,"A computer’s file system consists of a tree-like structured organization of directories and
  
 files.
  
 There is one “root” directory, which is the main access point for all other directories. The
  
 root directory is identified by a slash (/) or backslash (\), depending on the operating
  
 system. Under Windows it is a backslash, under Mac OS and Linux it is a forward slash.
  
 However, Windows now also supports the forward slash. I recommend using the forward
  
 slash in most cases, as in strings the backslash indicates a special symbol, so if you want
  
 to use a backslash in a string as a directory separator, you have to use a double backslash.
  
 This tends to be confusing, which is why I recommend using the forward slash.
  
 “Under” the root-directory there are multiple other directories, each identified by a name,
  
 and usually also multiple files, each identified by a name. Under each directory there may
  
 be more directories and files.
  
 Each operating system has certain restrictions on what file and directory names can be
  
 used, but in general most characters are supported. It is convention that regular files have
  
 an extension, which is placed at the end of the file name, and separated from the filename
  
 with a period. The extension identifies what kind of file it is, for instance, an executable
  
 program (.exe), a flat text file (.txt), or a Python file (.py). It is also convention that
  
 directory names do not have such an extension. However, this is not a rule, and you may
  
 certainly encounter files without, and directories with an extension. Note that in the visual
  
 environment, extensions for files are often hidden, but they are there – you just do not see
  
 them.
  
 To 
  
 uniquely 
  
 identify 
  
 a 
  
 file, 
  
 you 
  
 need 
  
 to 
  
 know 
  
 its 
  
 exact
  
 “path”from 
  
 the
  
 root 
  
 to 
  
 the 
  
 file, 
  
 following 
  
 the 
  
 directories. 
  
 The 
  
 path 
  
 name 
  
 for 
  
 the 
  
 file 
  
 is
  
 /<directory>/<directory>/.../<filename>. 
  
 Under Windows, a drive letter can
  
 be placed in front of this path, making it <drive>:/<directory>/<directory>/...
  
 /<filename>. For instance, if under Windows, on the “C” drive, under the root there is
  
 a directory “Python34,” under which there is a directory “Lib,” in which you can find a
  
 file “os.py,” the path for that file is C:/Python34/Lib/os.py. Under Windows, this path is
  
 case insensitive, so you can use only lower case letters if you like. That is not the case for
  
 all operating systems, though.
  
 When you are working in the file system (and you always are working in the file system,
  
 even if you do not realize that), there is a “current directory,” which is identified by a
  
 period (.). If you want to access a file in the current directory, you do not need to know
  
 the complete path; it is enough to know the file name. One directory “higher” than the
  
 current directory (i.e., the “parent” directory) is identified by a double period (..). The
  
 parent directory of the root is the root itself.
  
 Finally, it should be noted that most operating systems support a method that allows you
  
 to access files, without knowing the path, even if those files are not in the current directory.
  
 Under Windows, for instance, you can set a PATH environment variable that contains a
  
 string that lists all the directories that Windows will search when you use a filename that
  
 is for a file that is not in the current directory. How to adapt such an environment variable
  
 is not part of this book, though.",NA
15.4,NA,NA
os,NA,NA
 functions,"The os module supports many functions that allow you to affect the file system. I will 
 mention only a few of them, as many of them are actually a bit dangerous to use (you can 
 easily delete files that you wanted to keep) and you do not need them anyway. If you are 
 really interested in manipulating the file system, you can read up on the dozens of other 
 functions that os supports.
  
 15.4.1 
 getcwd()
  
 getcwd() returns the current working directory as a string.
  
 from os import getcwd 
  
 print( getcwd() )
  
  
 15.4.2
  
 chdir()
  
 chdir() changes the current working directory. The new directory is provided as a string 
 argument.
  
 from os import getcwd , chdir
  
 home = getcwd() 
  
 print( home ) 
  
 chdir(
  ""..""
  ) 
  
 print( getcwd() ) 
  
 chdir( home ) 
  
 print( getcwd() )
  
  
 15.4.3
  
 listdir()
  
 listdir() returns a list of all the files and directories in the directory that is given as argument. 
 The names are given in arbitrary order. Notice that they do not include the full path name.
  
 from os import listdir
  
 flist = listdir(
  "".""
  ) 
  
 for name in flist: 
  
 print( name )
  
  
 15.4.4
  
 system()
  
 system() gets a string argument that is a command, that Python executes on the command 
 line. You can use it to do anything that the operating system supports, including running 
 other programs. There are better ways to execute other programs, though (look for func-
 tions that start with “exec”).",NA
What you learned,"In this chapter, you learned about:
  
 • Operating systems
  
 • Command prompt
  
 • File systems
  
 • Functions getcwd(), chdir(), listdir(), and system()",NA
Exercises,"Exercise 15.1
  Write a program that lists all the files and directories in the current direc-
 tory, displaying them with their full path names.",NA
Chapter 16,NA,NA
Text Files,"One of the most important uses of Python for data processing is the reading, changing, and 
 writing of text files. Data is often stored in text files, because text files can be easily 
 transferred between different programs. There are multiple standardized formats for text 
 files, such as “comma-separated values” (CSV) files. Python supports particular text file 
 formats through modules, some of which will be discussed later. This chapter focusses on 
 opening, reading, writing, and closing of any text file, regardless of format.",NA
16.1 ,NA,NA
Flat text files,"When programmers refer to “text files” or “flat text files,” they mean files in which all 
 characters are meant to be read as regular characters, like you would type on a keyboard. 
 For instance, Python program files are flat text files, as are HTML files. Word processor 
 documents, however, are not flat text files, and neither are images. If you want to know 
 whether a file is a text file or not, you can try to open it in a text editor (such as the editor for 
 the IDLE environment, which comes with Python). If you see only readable text, the file is 
 likely to be a text file. Otherwise, it is a so-called “binary file” (binary files are discussed in 
 Chapter 18).
  
 Text files consist of lines of text. At the end of a line, there is a “newline” symbol, which in 
 Python is the character ""\n"". Different operating systems use slightly different ways of 
 storing this character in a text file: some Windows programs store it as ""carriage return plus 
 line feed"" (""\r\n""), while on Linux it is always stored as a single ""\n"". As long as you ac-cess a 
 file from Python as a regular text file, Python will convert the characters that it reads to the 
 standard ""\n"", and vice versa when it writes. So you do not need to worry about such 
 differences (except when you need to transfer text files between operating systems).
  
 16.1.1 
  
 File handles and pointers
  
 When you work with a file in a program, you have to open the file. Opening a file provides a 
 so-called “file handle.” A file handle can be seen as an access point to the file. It contains a 
 “pointer” that indicates a particular place in the file. That pointer is used when you read",NA
16.2 ,NA,NA
Reading text files,"To read the contents of a file, you must first open it, then read the contents, then close it.
  
 16.2.1 
  
 Opening a file using
  open()
  
 To open a file, you use the open() function.
  
 The open() function gets two arguments, of which the second one is optional. The first 
 argument is the name of the file. If the file is not in the current directory, you have to include 
 the complete path to the file so that Python can find it. The second argument is the“mode.” 
 The mode indicates how you want to treat the file. The default mode (which is picked when 
 you do not supply the second argument) is opening the file as a text file for reading only. 
 How you set other modes is discussed later.
  
 The open() function returns a file handle, which you use for all the remaining functionali-
 ties.
  
 Rather than writing <handle> = open( <filename> ), you will often see Python pro-grams 
 that write this as open( <filename> ) as <handle>. These two ways of writing",NA
16.3 ,NA,NA
Writing text files,"Writing a text file is similar to reading. You open the file, write to it, and close it.
  
 16.3.1 Opening a file for writing
  
 To open a file for writing, and writing only, you give the value
  ""w""
  as the second argument to 
 the open() function. If the file does not exist yet, it will create it. If it does exist, it will delete 
 its contents.",NA
16.4 ,NA,NA
Appending to text files,"“Appending” refers to writing at the end of an existing file. When you open a file for 
 appending, the contents are not erased, but the file pointer is placed at the end of the file, 
 where you can then write new data. You open a file in “append” mode by using
  ""a""
  as the 
 mode argument when opening the file.
  
 The code below first displays the contents of “pc_writetest.tmp” (which should exist by 
 now). It then asks the user for lines which are appended to the file. Finally, it displays the 
 contents of the new file. I took the liberty of creating this little program in a slightly-better 
 structured manner than before, using a constant for the filename that is repeated three times 
 in the program, and using a function to display the file contents as this functionality is 
 needed twice.
  
 listing1607.py
  
 FILENAME =
  ""pc_writetest.tmp""
  
 def displaycontents( filename ): 
  
 fp = open( filename ) 
  
 print( fp.read() ) 
  
 fp.close()
  
 displaycontents( FILENAME )
  
 fp = open( FILENAME ,
  ""a""
  ) 
  
 while True: 
  
  
  
 text = input(
  ""Please enter a line of text: ""
  ) if text ==
  """"
 : 
  
  
   
 break 
  
 fp.write( text+
 ""\n""
  ) 
  
 fp.close()
  
 displaycontents( FILENAME )",NA
16.5,NA,NA
os.path,NA,NA
 methods,"At this point you know everything you need to handle text files in Python. However, there 
 are several handy functions that make your life easier when dealing with files. These are 
 collected in the os.path module. As per usual, I am not going to list all of them, but I will list 
 the ones that you will use the most.
  
 In these functions, the term “path” refers to a filename or a directory name, complete with 
 parent directories (and drive letter). The parent directories (and drive letter) do not need to 
 be there explicitly, but even if they are not, implicitly they still are as each file and each 
 directory is located in a particular place in the file system.
  
 16.5.1 
  
 exists()
  
 The function exists() gets a path as argument, and returns True if that path exists, and False 
 if it does not.
  
 from os.path import exists
  
 if exists(
  ""pc_rose.txt""
  ): 
  
  
 print(
  ""Rose exists""
  ) 
  
 else: 
  
  
 print(
  ""Rose does not exist""
  )
  
 if exists(
  ""pc_tulip.txt""
  ): 
  
  
 print(
  ""Tulip exists""
  ) 
  
 else: 
  
  
 print(
  ""Tulip does not exist""
  )
  
  
 16.5.2
  
 isfile()
  
 isfile() tests if the path that is supplied as argument is a file. If it is, it returns True. If it is not, 
 it returns False. If the path does not exist, the function also returns False.
  
 from os.path import isfile
  
 if isfile(
  ""pc_rose.txt""
  ): 
  
  
 print(
  ""Rose is a file""
  ) 
  
 else: 
  
  
 print(
  ""Rose is not a file""
  )
  
  
 16.5.3
  
 isdir()
  
 isdir() tests if the path that is supplied as argument is a directory. If it is, it returns True. If it 
 is not, it returns False. If the path does not exist, the function also returns False.",NA
16.6,NA,NA
File encoding,"Text files use an “encoding,” i.e., a system that prescribes how characters in the files
  
 are supposed to be interpreted.
  
 This encoding may differ between operating sys-
  
 tems.
  
 You can see the preferred encoding that your system uses with a call to
  
 sys.getfilesystemencoding().
  
  
 from sys import getfilesystemencoding print( 
 getfilesystemencoding() )
  
 If you read a text file which uses a different encoding than your file system prefers, you may 
 get a UnicodeDecodeError. Whether or not you get this error for a particular file, is related to 
 your operating system. An annoying consequence of that is that when you port Python code 
 that reads a file to another system, a file that could be read by your code previously may 
 cause your code to crash after the port.
 10
  
 An easy way to get around this problem is by adding an extra parameter when opening a file, 
 which indicates the encoding mechanism that you want to use when reading the file. You do 
 this by adding a parameter encoding=<encodingname>, where <encodingname> is a string 
 that can have a variety of values, for which some typical ones are:
  
 10
 I have to make note of some Python behavior that seems bizarre when you first encounter it: you may get this 
 error when your file contains characters in an encoding that is not supported by your system in lines that you are 
 not even trying to read! E.g., suppose that there is such an erroneous character on line 10 of your file, but you are 
 only trying to read the first 5 lines before closing the file again – your program may still crash! I suspect that this is 
 related to the buffering of data: rather than reading exactly what you ask Python to read, Python reads data in 
 bigger chunks, so that the program is faster when you actually want to go through the whole file. So, by trying to be 
 smart, Python may saddle you up with problems that you did not expect could arise. It is good to be aware of such 
 issues.",NA
What you learned,"In this chapter, you learned about:
  
 • Text files
  
 • File pointers",NA
Exercises,"Exercise 
 16.1
  
 Write 
 a 
 program 
 that 
 reads 
 the 
 contents 
 of 
 the 
 file 
 “pc_woodchuck.txt,”splits it into words (where everything that is not a letter is considered a 
 word boundary), and case-insensitively builds a dictionary that stores for every word how 
 often it occurs in the text. Then print all the words with their quantities in alphabetical 
 order.
  
 Exercise 16.2
  Do the same thing as you did for the previous exercise, but now process the 
 text line by line. This is something that you would have to do if you had to process a very 
 long text.
  
 Exercise 16.3 
   
 Write a program that processes the contents of “pc_woodchuck.txt,”line 
 by line. 
  
 It creates an output file in the current working directory 
 called“pc_woodchuck.tmp,” which has the same contents as “pc_woodchuck.txt,” except that 
 all the vowels are removed (case-insensitively). At the end, display how many characters you 
 read, and how many characters you wrote.
  
 Exercise 16.4
  Write a program that determines how many words of 2 or more letters the 
 files “pc_woodchuck.txt,” “pc_jabberwocky.txt” and “pc_rose.txt” have in common. You have 
 to treat the words case-insensitively, and, as always, any character that is not a letter can be 
 treated as a word boundary. If your program is correct, you will find three such words.
  
 Exercise 16.5 
  
 For the three files that you used in the previous exercise, count for each of 
 them how often each letter (case-insensitively) occurs. Calculate for each let-ter and each file 
 the fraction <number of occurrences of letter in the file>/<total number of letters in the 
 file>. 
  
 Write an outputfile (any name, as long as you can safely overwrite it) with 
 extension .csv, that contains 26 lines, each line for-matted as follows: 
  
 ""<letter>"",<fraction 
 for first file>,<fraction for second file>,<fraction for third file>. The first line should have 
 letter a, the second let-ter b, etcetera. The fractions should be stored with 5 decimals. Finally, 
 display the contents of the outputfile. As the outputfile is a CSV file, you should also be able 
 to load it in a spreadsheet program.
  
 A quick check to see if you did things correctly is that all of the fractions must be between 
 zero and 1, and the fraction for “e” should be highest for both “pc_jabberwocky.txt” and",NA
Chapter 17,NA,NA
Exceptions,"Sometimes runtime errors occur not because you made a programming mistake, but be-
 cause your program encountered a situation that you could not foresee when you wrote it. 
 This is particularly relevant when you deal with files: for instance, when you access a file on 
 a USB-stick, and the user pulls out the USB-stick during the file processing, obviously an 
 error occurs that you cannot really account for in your code. Every runtime error raises a so-
 called “exception,” and you can “capture” such exceptions if you want to deal with them in 
 your program, rather than make the program end abruptly.",NA
17.1 ,NA,NA
Errors and exceptions,"When you try to run a Python program, Python first does a quick check to see if all the 
 statements in the program meet the basic Python syntax requirements. If they do not, 
 Python announces a “syntax error” and will not run the program.
  
 If no syntax errors are encountered, Python will run the program, but may encounter state-
 ments that generate errors while trying to execute them. Such statements cause a “runtime 
 error.” You have seen runtime errors many times while writing code (don’t try to deny it).
  
 In general, you try to fix runtime errors by extending or changing your code. For instance, 
 the following program causes a runtime error when you enter a zero as input:
  
 from pcinput import getInteger
  
 num = getInteger(
  ""Please enter a number: ""
  ) 
  
 print(
  ""3 divided by {} is {}""
 .format( num, 3/num ) ) print(
  ""Goodbye!""
  )
  
 Python tells you what kind of error it is, namely a ZeroDivisionError. To fix it, you can 
 change the program:
  
 from pcinput import getInteger 
  
 num = getInteger(
  ""Please enter a number: ""
  )",NA
17.2 ,NA,NA
Exception handling,"To handle exceptions explicitly in your program, you use a try ... except clause. There are 
 different ways of applying this clause.
  
 17.2.1 
 try
  ...
  except
  
 The most basic form of the try ... except clause has the following syntax:
  
 try:
  
 <statements>
  
 except:
  
 <exception handling>
  
 When the <statements> between try: and except: are executed and raise an ex-ception, 
 Python immediately jumps to the <exception handling> statements and exe-cutes those, 
 after which the program continues as normal, at the first line below the <exception 
 handling> statements. If no exceptions are raised during the execution of the <statements>, 
 the <exception handling> statements are skipped.
  
 Using exception handling, the code at the start of this chapter can be written as follows to 
 avoid runtime errors:
  
 listing1701.py
  
 from pcinput import getInteger
  
 num = getInteger(
  ""Please enter a number: ""
  ) 
  
 try: 
  
  
 print(
  ""3 divided by {} is {}""
 .format( num, 3/num ) ) except: 
  
  
 print(
  ""Division by zero is not allowed""
  ) 
  
 print(
  ""Goodbye!""
  )",NA
17.3 ,NA,NA
File handling exceptions,"Any problem with accessing files, whether it is the inability to find a file, a problem with 
 reading or writing a file, or trying to open a protected system file or even a directory, leads 
 to an IOError exception. Since problems with file access are quite common and usually at 
 least partly outside the realm of control of the program, it is a good idea to handle IOError 
 exceptions in your programs when you can.
  
 Since many different things can go wrong with files, the args tuple explained above might be 
 used to provide better information on what you have to do to handle the problem. For 
 instance, if your program asked the user to supply a filename, and when you open that file 
 you get an IOError, if the error number (the first element of the tuple) indicates that the file 
 does not exist (2), then an appropriate response might be to simply report this to the user 
 and ask for a new name.
  
 The error numbers are defined in the errno module, which you can import in your pro-gram. 
 The module offers constants that you can use instead of the actual numbers, which is the 
 convention. The most common error numbers are:
  
 • errno.ENOENT: No such file or directory. You get this when you try to access a file 
  
 that does not exist.",NA
17.4 ,NA,NA
Raising exceptions,"You are allowed to raise exceptions yourself. For that, you use the keyword raise, and follow 
 that with one of the known exceptions (potentially, you could create your own, new 
 exceptions if you like, but you need to have studied Chapters 20 and 22 before you are ready 
 for it). You can give the exception arguments of any kind that you like.
  
 You might wonder why you would want to raise your own exceptions. The answer is that 
 when you create a module, when an error occurs (for instance because the main program 
 that uses the module passes arguments to a function that are of an incorrect type), it is bad 
 form to print an error message. It is much better to just raise an exception, and let the main 
 program handle the exception. Here is an example of raising an exception:",NA
What you learned,"In this chapter, you learned about:
  
 • Exception handling
  
 • except, else, and finally
  
 • ZeroDivisionError, IndexError, KeyError, IOError, ValueError, TypeError, and
  
 FileNotFoundError
  
 • Getting exception information
  
 • File handling exceptions
  
 • Raising and re-raising exceptions",NA
Exercises,"Exercise 17.1
  Which exceptions can the code below raise? Extend the code to handle all 
 of them in a reasonable manner.
  
 exercise1701.py
  
 numlist = [ 100, 101, 0,
  ""103""
 , 104 ] 
  
 i1 = int( input(
  ""Give an index: ""
  ) ) 
  
 print(
  ""100 /""
 , numlist[i1],
  ""=""
 , 100 / numlist[i1] )",NA
Chapter 18,NA,NA
Binary Files,"“Binary files” is the term used to refer to all files that are not text files. Executable programs 
 are binary files, as are image files, movies, word processor documents, and many other file 
 types. It is not common to use Python to process binary files (usually binary files are not 
 handled by general-purpose programming languages, but by special-purpose programs), but 
 it is possible. This chapter will explain how to deal with binary files.",NA
18.1 ,NA,NA
Opening and closing binary files,"The handling of binary files is quite similar to the handling of text files. You have to open() a 
 file when you want to access its contents, close() it when you are finished, read() from the 
 file and write() to the file.
  
 When you open a binary file, you have to indicate to Python that you want to handle this file 
 in “binary mode.” You do this by adding a letter
  ""b""
  to the mode argument. For instance, to 
 open a file in “binary read” mode, the mode argument should be
  ""rb""
 . You can also open a file 
 both for reading and writing; reading and writing you indicate with mode 
 ""r+""
 , so reading 
 and writing in binary mode is
  ""r+b""
  (while it is also possible to open text files in
  ""r+""
  mode, I 
 did not indicate it in Chapter 16, as it seldom makes sense to open text files in this mode). 
 Just as with text files, if you open a binary file in write-mode, with 
 ""wb""
 , the file gets emptied. 
 The mode
  ""w+b""
  will open a file for both reading and writing, but also empties the file to 
 start with.
  
 When you open a file for both reading and writing, if the file pointer is not at the end of the 
 file, when you write you actually overwrite.
  
 You can open any file in binary mode, even text files. However, when you open text files in 
 binary mode, you treat them like binary files, which means that Python does not do the 
 automatic conversion of newline characters.
  
 Closing a binary file is no different from closing a text file.
  
 fp = open(
  ""pc_rose.txt""
 ,
  ""rb""
  ) 
  
 fp.close()",NA
18.2 ,NA,NA
Reading a binary file,"As binary files do not know the concept of “lines,” the only way to read from a binary file is to 
 use the read() method. If you use read() without argument, it reads the whole file (starting at 
 the file pointer). If you give the method an integer as parameter, that integer indicates the 
 number of bytes that are read from the file (starting at the file pointer, and reading at 
 maximum until the end of the file).
  
 A “byte,” if you do not know, is an 8-bit character, i.e., a number between zero and 255, 
 which is stored in the smallest possible memory unit that a computer supports. The regular 
 characters on a keyboard are each stored in a single byte, and the characters in a string are 
 also each a byte, though limited to a specific range of numbers.
  
 18.2.1 Byte strings
  
 Here we enter one of the more obscure parts of the Python language. When you read from a 
 binary file, the read() method does not return a regular string – it returns a “byte 
 string.”There are some subtle differences between regular strings and byte strings. To show 
 you these differences, I first have to tell you that you can indicate that a string is a byte string 
 by placing a letter b in front of it. So
  ""Hello, world
 ""! is a string, while
  b""Hello, world
 ""! is a 
 byte string.",NA
18.3 ,NA,NA
Writing a binary file,"You write to a binary file using the write() method. The difference with writing to text files is 
 that you have to supply a byte string as argument, rather than a regular string. The following 
 code creates a binary file with some text in it.
  
 listing1805.py
  
 from os.path import getsize
  
 FILENAME =
  ""pc_binarytest.tmp"" 
  
 fp = open( FILENAME ,
  ""wb""
  ) 
  
 fp.write(
  b""And now for something completely different...\x0A\ 
 \x00\x00\x00\x00\xD4\xE8\xE5\xA0\xD3\xF0\xE1\xEE\xE9\xF3\xE8\xA0\ 
 \xC9\xEE\xF1\xF5\xE9\xF3\xE9\xF4\xE9\xEF\xEE\x00\x00\x00""
  ) fp.close() 
  
 print( getsize( FILENAME ),
  ""bytes written""
  )
  
 Run the code above to create the binary file. The code below opens it in text mode (you can 
 do that, as Python cannot know that it actually is a binary file), reads the contents, and prints 
 the contents. You will see some readable text and some unreadable characters.
  
 listing1806.py
  
 FILENAME =
  ""pc_binarytest.tmp"" 
  
 fp = open( FILENAME , encoding=
 ""latin -1""
  ) while True: 
  
  
  
 buffer = fp.readline() 
  
  
 if buffer ==
  """"
 : 
  
  
    
 break 
  
  
  
 print( buffer ) 
  
 fp.close()",NA
18.4 ,NA,NA
Positioning the file pointer,"The file “pc_binarytest.tmp” actually contains a few secret words, which you cannot rec-
 ognize when printing the file. I am going to use them as an illustration on how to move the 
 file pointer.
  
 The file pointer indicates where in the file you start reading or writing. You can move the file 
 pointer with the seek() method. seek() gets two integer arguments, of which the second one 
 is optional. The first argument is a relative byte position. The second is the position relative 
 to which you want to move the file pointer.
  
 The second argument can be 0, 1, or 2. 0 means “relative to the beginning of the file,” 1 
 means “relative to the current file pointer position,” and 2 means “relative to the end of the 
 file.” If you do not specify a second argument, it is assumed to be 0. In the os module there 
 are constants for this argument: os.SEEK_SET is 0, os.SEEK_CUR is 1, and os.SEEK_END is 2.
  
 The first parameter indicates how many bytes you move from the indicated position. When 
 starting at the beginning of the file, it should be a positive number; when starting at the end 
 of the file, it should be a negative number; when starting somewhere in the middle of the file, 
 it can be positive or negative. For instance, the statement fp.seek(5) is equivalent to 
 fp.seek(5,0), which moves the file pointer 5 bytes up from the start of the file, placing it at the 
 sixth byte.
  
 Should you wish to know at which position the file pointer is currently placed, you can use 
 the tell() method. Both seek() and tell() can be called for text files too, but are not very useful 
 then.
  
 Now, the secret words are found starting at position 50, and run for a length of 23 bytes. The 
 encoding is such that if you subtract 128 from byte values, you get the ordinals for the 
 letters. So, here is how you get the words out of the file:
  
 listing1807.py
  
 fp = open(
  ""pc_binarytest.tmp""
 ,
  ""rb""
  ) 
  
 print(
  ""1. Current position of the file pointer is""
 , fp.tell() ) fp.seek( 50 ) 
  
 print(
  ""2. Current position of the file pointer is""
 , fp.tell() ) buffer = fp.read( 23 ) 
  
 print(
  ""3. Current position of the file pointer is""
 , fp.tell() ) fp.close()
  
 print( buffer ) 
  
 s =
  """" 
  
 for c in buffer: 
  
  
 s += chr( c-128 ) 
  
 print(
  ""The secret words are:""
 , s )
  
 The seek() method is particularly useful when you open a file in “reading and writing”mode 
 (
 ""r+b""
 ). It allows you to move through the file, reading where you need to read, and 
 (over)writing where you need to (over)write.",NA
What you learned,"In this chapter, you learned about:
  
 • Using binary files for reading, writing, and reading plus writing
  
 • Binary read() and write()
  
 • Byte strings
  
 • Conversion between strings and byte strings using encode() and decode()
  
 • seek() and tell() methods",NA
Exercises,"Exercise 18.1
  Create a simple file encryption program. Open a file and read it in binary 
 mode. For each byte, if it is smaller than 128, add 128; if it is bigger than or equal to 128, 
 subtract 128. Overwrite the byte with new value. Test the program on a copy of a text file 
 (make sure it is a copy, because you will destroy the file). Check the contents of the 
 encrypted file: they should be a mess. However, when you run the program again, the 
 original file should be restored. If it isn’t, you have a bug in your program. Aren’t you glad 
 you were only working on a copy?
  
 Exercise 18.2 
  
 The fourteen most common letters in the English language are: 
 etaoinshrdlcum. Write a text compression program based on this fact. The compression 
 program stores these letters in half-bytes. A half-byte can take the numbers zero to 15. If you 
 only use the numbers 1 to 15, each number can represent one of these fourteen most 
 common letters, and you can use the number 15 for the space. So you can store two of these 
 letters (or space) in a byte (the value for the whole byte would be 16 times the value for the 
 first letter, plus the second letter). If in the text you encounter a letter that is not amongst 
 these fifteen, you indicate that by storing a zero-half-byte, followed by a whole byte that 
 represents the unencoded letter. Of course, in this setup it is possible that the full byte is 
 actually divided over two bytes, namely the second half-byte of one byte, and the first half-
 byte of the other byte.
  
 Hint: an easy approach is to build a list of half-bytes. For the most common letters, you store 
 their index-value for the string ""etaoinshrdlcum "" plus 1 (which is a value in the range 1 to 
 15; notice that the last character in the string is the space). For the other charac-ters, you 
 store three half bytes, namely zero, followed by the ordinal value of the character divided by 
 16 (rounded down), followed by that ordinal value modulo 16. Once the half-byte-list is 
 finished, you can turn it into a byte list by taking pairs of half-bytes, multiplying the first by 
 16 and adding the second. Create a byte string using bytes() casting.",NA
Chapter 19,NA,NA
Bitwise Operators,"Chapter 18 discussed dealing with binary files. When binary files are used, you are no longer 
 working with characters and numbers; rather, you are working with bytes. To ma-nipulate 
 information on the level of bytes, Python offers a number of so-called “bitwise operators.” 
 You will not need these often, but when you delve into binary file manipula-tion, they might 
 come in handy.",NA
19.1 ,NA,NA
Bits and bytes,"A bit is the smallest size data unit that a computer can handle. A single bit can have only two 
 different values, namely 1 and zero.
  
 While ""prehistoric"" computers were indeed programmed by directly dealing with single 
 ones and zeroes, very quickly computers were introduced that handled groups of bits. The 
 smallest unit in that respect is the “byte,” which consists of 8 bits. Today, the concept of a 
 byte still permeates most computer languages, even though computers have been en-hanced 
 to use larger collections of bytes as smallest data units (notably, most computers today 
 either deal with 32-bits or 64-bits data units).
  
 19.1.1 
  
 Binary counting
  
 A byte consists of 8 bits, which you can display as a sequence of ones and zeroes, e.g., 
 11010010. 
  
 As such, a byte can be used to represent a number in binary code. If a byte 
 is used to represent a positive number, that number can be calculated by multiplying the 
 right-most bit by 1, the bit next to that by 2, the bit next to that by 4, etcetera, and adding up 
 all those values. 
  
 For instance, the sequence 11010010 is 
 1*128+1*64+0*32+1*16+0*8+0*4+1*2+0*1, which is 210. Note that this is similar to cal-
 culating the value of decimal numbers, where the rightmost digit is multiplied by 1, the digit 
 next to that by 10, the digit next to that by 100, etcetera, and adding up all those re-sulting 
 values. It is also similar to hexadecimal counting, which was discussed in Chapter 10.
  
 When bits are numbered, by convention numbering starts at zero at the rightmost end, and 
 numbers are increased when counting to the left, i.e., the rightmost bit has number 0, the",NA
19.2 ,NA,NA
Manipulating bits,"Python offers a variety of operators that allow the manipulation of data items at the level of 
 bits. These are the following:
  
 << 
  
 shift left
  
 >> 
  
 shift right
  
 & 
  
 bitwise and
  
 | 
  
 bitwise or
  
 ~ 
  
 bitwise not
  
 ^ 
  
 bitwise exclusive or
  
 They are used as follows.",NA
19.3,NA,NA
Usefulness of bitwise operations,"Anything that you can do with bitwise operators, you can also do with general calcula-tions, 
 with the advantage of general calculations that they can do much more than bitwise 
 operators. So what is the use of bitwise operators?
  
 Bitwise operations are incredibly fast. Much, much faster than regular calculations. So 
 should you use them when making calculations, when it is opportune to do so? The answer is 
 no, for two reasons:
  
 • Python is already smart enough to recognize that some calculations can be executed 
  
 using bitwise operators, so it will make the conversion for you.
  
 • If you really want a fast program, you should not use Python at all.
  
 Another use that is often mentioned, is that they facilitate storing boolean values in a small 
 storage space. For instance, if I have eight booleans that I want to store, I can use a tuple of 
 eight booleans, which amounts to at least eight bytes of space, or encode all eight of them in 
 one byte using bitwise operators. However, in today’s computers space is of little concern, so 
 only if you are talking about huge,
  huge
  data collections you might get worried about space.
  
 So what is the use of bitwise operators then? They are actually of fairly little use, unless you 
 have to create programs that need to work “close to the machine.” Occasionally you have to 
 deal with data structures that are most naturally handled using bitwise operators. They may 
 also help when you need to manipulate the content of binary files.
  
 To give an example: colors are usually encoded as three bytes, for the red, green, and blue 
 channel. A color number is thus a three-byte number. Bitwise operators are a natural way to 
 distinguish the separate color channels from a color number. Here is a function that does 
 that:
  
 listing1901.py
  
 def getRGB( color ): 
  
 blue = color & 255 
  
 green = (color >> 8) & 255 
  
 red = (color >> 16) & 255 
  
 return red, green, blue
  
 r, g, b = getRGB( 223567 ) 
  
 print(
  ""red={}, green={}, blue={}""
 .format( r, g, b ) )",NA
What you learned,"In this chapter, you learned about:
  
 • Binary counting
  
 • Character and number encoding
  
 • Bitwise operators <<, >>, &, |, ~, and ^",NA
Exercises,"Exercise 19.1 
  
 Encode a string using the bitwise exclusive or (xor) and the pattern 
 00101010 as mask. Display the resulting string. Then decode it, and display the decoded 
 string, which should be the same as the original string.
  
 Exercise 19.2
  Write a function that gets an integer, a boolean, and a number. The integer 
 is used to store booleans. Each bit in the integer represents True or False. The bits of the 
 integer are numbered as the convention indicates, with the rightmost bit having number 
 zero, the bit next to that number 1, etcetera. If the boolean parameter is True, the function 
 sets the bit corresponding to the number parameter in the integer to 1. If the boolean 
 parameter is False, the function clears the bit corresponding to the number parameter in the 
 integer (i.e., it sets it to 0). The function then returns the integer.
  
 Also write a function that gets an integer and a number as parameters, and returns True if 
 the bit corresponding to the number is set to 1, and False otherwise.
  
 To test the functions, it helps to create an extra function that displays the bits in the number. 
 The display function can make use of the function that gets the bit values.",NA
Chapter 20,NA,NA
Object Orientation,"The chapters until this point covered an approach to programming that is often referred to 
 as “structured programming” or “imperative programming,” wherein a program is con-
 sidered a sequence of statements, decisions, and loops. You can solve any programming 
 problem with a structured programming approach. However, in the last decades several 
 other programming “paradigms” have been coined up, which help designing and imple-
 menting large-scale programs. One of the most successful paradigms is “object orienta-tion,” 
 and most modern programming languages support the object oriented paradigm. Python is, 
 in fact, an object oriented language.
  
 While object orientation tends to provide a natural way to look at problems and solutions, 
 designing an object oriented program can be quite hard. The reason that it is hard, is that 
 you have to really think about your approach to a problem in all of its aspects, before you 
 start coding. For bigger problems, this can be daunting, especially when you lack experience 
 with programming. However, for bigger problems you have to spend a lot of time designing 
 your solution anyway, and an object oriented approach may be quite helpful in creating it. 
 Moreover, you will find that most modules provide object oriented implementations, and 
 that object orientation can be helpful for many smaller problems too.
  
 Since object orientation is a broad topic, several chapters will be spent on it, of which this 
 one is the first. It discusses the basics of object orientation, leaving the more specialized (and 
 powereful!) aspects of object orientation for later chapters.",NA
20.1 ,NA,NA
The object oriented world,"While I am typing this, I am sitting at my kitchen table. Next to me is a bowl of fruit. There 
 are some apples in the bowl. While these apples share certain features, they have their 
 differences too. They share their name, their price, and their age, but they all have (slightly) 
 different weights. There are also some oranges in the bowl. Like the apples, they are fruits, 
 but they have a lot of differences with apples: different names, different colors, different 
 trees that they grow from. Still, they share some things with apples that all fruits share, and 
 make them different from, for instance, the table I am sitting at. I can eat a fruit, i.e., I can eat 
 apples and I can eat oranges. I am not going to try to eat a table.",NA
20.2 ,NA,NA
Classes and objects,"Now the basic philosophies of object orientation are out of the way, I am going to dis-cuss 
 how to use object orientation in Python. It starts with creating new classes using the 
 keyword class.
  
 20.2.1 
 class
  
 A class can be considered a new data type. Once a class is created, you can assign instances of 
 the class to variables. To start simple, I am going to create a class that represents a point in 
 2D space. I name this class Point (the naming of classes is restricted to the same 
 requirements as the naming of variables, and it is convention to let the names of classes start 
 with a capital). Creating this class in Python is incredibly easy:",NA
20.3,NA,NA
Methods,"I already introduced to you the three methods __init__(), __repr__(), and __str__(). These are 
 predefined methods that every class has. As they were defined by the Python developers, 
 they have the eccentric names that start and end with a double underscore. There are 
 several more of such methods, which I will discuss in later chapters.
  
 You can also define your own methods for a class. Such methods get names similar to names 
 you give to functions, and tend to follow the same conventions: starting with a lower case 
 letter, and if there are different words either have underscores between them or capitalize 
 the first letter of the second and later words. The prefix is is used for methods that provide a 
 True/False statement about the object, the prefix get is used to get a value from an object, 
 and the prefix set is used to set a value for an object.
  
 For instance, for a point I can create a method distance_from_origin(), which calculates the 
 distance from the point (0,0) to the given point.
  
 listing2006.py
  
 from math import sqrt
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({}, {})""
 .format( self.x, self.y ) 
  
 def 
 distance_from_origin( self ): 
  
  
  
  
 return sqrt( self.x* self.x + self.y* self.y )
  
 p = Point( 3.5, 5.0 ) 
  
 print( p.distance_from_origin() )
  
 You may also create methods that change the object in some way. For instance, the “trans-
 lation” of points over a distance is defined as a specific shift in the horizontal and in the 
 vertical direction. A method translate() gets two arguments (beyond the self reference), 
 which are the horizontal and vertical shifts.
  
 listing2007.py
  
 from math import sqrt
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({}, {})""
 .format( self.x, self.y ) 
  
 def translate( self, 
 shift_x , shift_y ): 
  
  
  
 self.x += shift_x 
  
  
  
 self.y += shift_y",NA
20.4 ,NA,NA
Nesting objects,"Objects can be part of other objects. For instance, a rectangle can be defined as a point that 
 indicates its top-left corner, a width, and a height. As such, the class Rectangle can be defined 
 as follows:
  
 listing2008.py
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({}, {})""
 .format( self.x, self.y )
  
 class Rectangle: 
  
  
 def __init__( self, point, width, height ): 
  
  
  
 self.point = point 
  
  
  
 self.width = width 
  
  
  
 self.height = height 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""[{},w={},h={}]""
 .format( self.point, self.width, 
  
  
  
 self.height )
  
 p = Point( 3.5, 5.0 ) 
  
 r = Rectangle( p, 4.0, 2.0 ) 
  
 print( r )
  
 In this definition, the Rectangle object contains a Point object.
  
 Exercise
  Create a different version of the Rectangle class, that instead of the top-left 
 corner point, width, and height, gets the top-left corner point and the lower-right corner 
 point.
  
 20.4.1 Copies and references
  
 Below is a copy of the code above, expanded with a few extra lines that make a change to the 
 Point p.",NA
20.5,NA,NA
Memory management,"The following discussion could have occurred in many earlier places in the book, but I post-
 poned it until now because it tends to first come up when dealing with object orientation and 
 the creation of large objects. However, it is rather technical, and the central message is going 
 to be “don’t worry about it,” so I did not want to touch upon it earlier. The topic is: what 
 happens in the memory of the computer when you create a large number of big objects?
  
 For instance, the following code creates 10,000 instances of the class Point, which it places in 
 a list. You can safely run this code.
  
 listing2011.py
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
 self.x = x 
  
  
  
 self.y = y
  
 pointlist = []
  
 for i in range( 100 ): 
  
  
 for j in range( 100 ): 
  
  
 p = Point( i, j ) 
  
  
  
  
 pointlist.append( p )
  
 print(
  ""There are""
 , len( pointlist ),
  ""points in the list""
  )
  
 10,000 is not “large” and Point does not produce a “big” object, but you can imagine that 
 something similar is done with many more instances of a bigger object. If you wonder how 
 much memory this program needs, the answer is that that is hard to determine in the code,",NA
What you learned,"In this chapter, you learned about:
  
 • Classes and objects
  
 • The keyword class
  
 • Creating objects
  
 • __init__(), __repr__(), and __str__()
  
 • Methods
  
 • Nesting objects
  
 • Relationships via aliases
  
 • Memory management",NA
Exercises,"Exercise 20.1
  Create a version of the Rectangle class that is safe by assuring that both 
 width and height are positive values (how you do that is up to you). Expand it with meth-ods 
 that calculate its surface area and its circumference. Also provide a method that returns the 
 bottom-right corner of the rectangle as a Point. Finally, create a method that gets a sec-ond 
 Rectangle object as parameter, and returns the overlapping area of the two rectangles as a 
 new Rectangle object (the last one is much harder than the other ones).
  
 Exercise 20.2
  A student has a last name, a first name, a date of birth (either a year, 
 month, and day, or a datetime object if you took the liberty of studying the datetime module 
 already), and an administration number. A course has a name and a number. Students can 
 enroll in courses. Create a class Student and a class Course. Create several students and 
 several courses. Enroll each student in some of the courses. Display a list of students, 
 showing their number, first name, last name, and age, and per student which courses he or 
 she is enrolled in.",NA
Chapter 21,NA,NA
Operator Overloading,"Operator overloading is a powerful feature of object orientation that allows you to integrate 
 your new classes into programs in a natural way. Operator overloading is always based on 
 the definition of some special methods, that have the typical __<name>__() structure.",NA
21.1 ,NA,NA
The idea behind operator overloading,"When you write Python programs with basic data types, without thinking you use opera-tors 
 to add, subtract, multiply, and divide values, to compare values, and to apply all kinds of 
 standard functionalities. Such interactions are not defined by default for classes you de-fine 
 yourself, but Python allows you to specify what should happen when one applies such an 
 interaction to instances of your class. This is called “operator overloading.”
  
 For instance, suppose that you define a class that represents quaternions.
 11
 You know that 
 adding and multiplying quaternions are well-defined operations. Therefore, you might want 
 to define what happens when you combine two of your quaternions with a
  +
  oper-ator. 
 Python allows you to specify that. In fact, Python allows you to specify what the
  + 
 operator 
 does for any of your new classes.
  
 Isn’t that great? You can define a class Student, and then define that if you add two stu-dents 
 together with a
  +
  operator, that their ages are added up. Wonderful, isn’t it? No, it isn’t. It 
 obviously makes no sense to add up two students. You might start thinking about what a 
 natural interpretation of adding up two students would entail, but the answer is that 
 everything that you can come up with is far-fetched. You should not define an addi-tion 
 operator for classes which have no natural addition defined. This is one of the dangers of 
 operator overloading: if you apply it without thinking, you get nonsensical programs.
  
 Still, operator overloading has powerful applications. In the rest of this chapter I will 
 introduce some of the most common applications of operator overloading.
  
 By the way, operator overloading is a typical example of “polymorphism,” a concept that 
 allows a function to have different results depending on the type of its arguments. Poly-
 morphism is often hailed as one of the powerful features of object orientation.
  
 11
 Quaternions are an extension of complex numbers. They consist of 4-dimensional numbers, with a real factor 
 and three imaginary factors called i, j, and k, with specific definitions for the multiplication of these factors.
  
 Details are not important for this book, they are just an example of numbers that are not native to Python.",NA
21.2,NA,NA
Comparisons,"In Chapter 20 I discussed that objects can be aliases of each other, but that you can also make 
 actual copies. What happens if you try to compare them?
  
 listing2101.py
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({}, {})""
 .format( self.x, self.y )
  
 p1 = Point( 3, 4 ) 
  
 p2 = Point( 3, 4 ) 
  
 p3 = p1 
  
 print( p1 is p2 ) 
  
 print( p1 is p3 ) 
  
 print( p1 == p2 ) 
  
 print( p1 == p3 )
  
 The keyword is compares object identities. Since p3 is an alias for p1, p1 is p3 returns True, 
 while p1 is p2 returns False. However, since p1 and p2 refer to the same point in 2D space, it 
 would be nice if p1 == p2 would return True, i.e., that the == would do a value comparison 
 (as you would expect). It does not. That is not surprising, as Python does not know how to 
 compare the values of Points, and therefore the == does the only comparison that Python 
 knows how to do, namely an identity comparison. However, you can instruct Python how to 
 compare two points using the == operator, by defining an __eq__() method:
  
 listing2102.py
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({}, {})""
 .format( self.x, self.y ) 
  
 def __eq__( self, p ): 
  
  
  
  
 return self.x == p.x and self.y == p.y
  
 p1 = Point( 3, 4 ) 
  
 p2 = Point( 3, 4 ) 
  
 p3 = p1 
  
 print( p1 is p2 ) 
  
 print( p1 is p3 ) 
  
 print( p1 == p2 ) 
  
 print( p1 == p3 )
  
 The __eq__() method tells Python, in this case, what to do when two objects of the type",NA
21.3 ,NA,NA
Calculations,"There are methods available to define what should happen when you combine an instance of 
 a class with a value using a regular calculation operator. The most important of these are:
  
 • __add__() for addition (+)
  
 • __sub__() for subtraction (-)
  
 • __mul__() for multiplication (*)
  
 • __truediv__() for division (/)
  
 • __floordiv__() for integer division (//)
  
 • __mod__() for modulo (%)
  
 • __pow__() for power (**)
  
 • __lshift__() for left shift (<<)
  
 • __rshift__() for right shift (>>)
  
 • __and__() for bitwise and (&)
  
 • __or__() for bitwise or (|)
  
 • __xor__() for bitwise xor (^)
  
 For example, for quaternions the addition is defined as:
  (
 A
  +
  Bi
  +
  Cj
  +
  Dk
 ) + (
 E
  +
  Fi
  + 
 Gj
  +
  Hk
 ) 
 = (
 A
  +
  E
 ) + (
 B
  +
  F
 )
 i
  + (
 C
  +
  G
 )
 j
  + (
 D
  +
  H
 )
 k
 . Naturally, you can also add inte-gers and floats to 
 quaternions. This can be implemented as follows:",NA
21.4 ,NA,NA
Unary operators,"Unary operators are operators which work only on the object itself, so not in combination 
 with another object. A typical example is using the minus (-) sign in front of a number to turn 
 it into a negative number. You can overload some of the unary operators, and also some of 
 the basic functions that work on an object.
  
 • __neg__() implements the negation (-) of an object
  
 • __pos__() implements placing a plus (+) in front of an object (usually without effect)
  
 • __invert__() implements the bitwise not (~)
  
 • __abs__() implements taking the object’s absolute value when using the abs() func-
  
 tion
  
 • __int__() implements taking the (rounded down) integer value of an object when 
  
 using the int() function; must return an integer
  
 • __float__() implements taking the floating-point value of an object when using the 
  
 float() function; must return a float
  
 • __round__() implements rounding using the round() function. An optional second 
 argument can be given to specify the number of decimals; must return an integer or a 
 float
  
 • __bytes__() implements representing the object as a byte string. It is in that respect 
  
 similar to the __str__() method which was discussed in Chapter 20
  
 listing2106.py
  
 class Quaternion: 
  
  
 def __init__( self, a, b, c, d ): 
  
  
  
 self.a, self.b, self.c, self.d = a, b, c, d",NA
21.,NA,NA
5,NA,NA
Sequences,"A special kind of class is the sequence class.
  
 You have seen several sequence classes,
  
 namely tuples, lists, dictionaries, and sets. Such classes contain a sequence of elements, that 
 can be accessed using indices or keys. You can create such classes yourself, by over-loading 
 several methods that support changing or getting information on the elements of the class.
  
 • __len__() implements the len() function, which should return an integer that indi-
  
 cates the number of elements in the object.
  
 • __getitem__() implements returning the element with the key (or index) that is sup-plied 
 as argument. This method is called when the object is referred to with a value between 
 square brackets after it, e.g., x[key] with x the object and key the key or index of the 
 element. If key is an index and the index is not appropriately refer-ring to an object, 
 then you are supposed to raise an IndexError (see Chapter 17). If key is something else 
 (as with, for instance, a dictionary) and it is not appropriately referring to an object, 
 then you are supposed to raise a KeyError. When key is an index, for a complete 
 implementation it should also support slices (implemented as so-called slice objects).
  
 • __setitem__() implements assigning a value to an element of the object which has the 
 key or index that is given as argument, and the value as second argument. This method 
 is called when a value is assigned to the object with a key or index value between 
 square brackets after it, e.g., x[key] = value.",NA
What you learned,"In this chapter, you learned about:
  
 • Operator overloading
  
 • Overloading comparison operators using __eq__(), __ne__(), __gt__(), __ge__(), 
  
 __lt__(), and __le__()
  
 • NotImplemented
  
 • __bool__()
  
 • Overloading calculation using __add__(), __sub__(), __mul__(), __truediv__(), __floordiv__(), 
 __mod__(), __pow__(), __lshift__(), __rshift__(), __and__(), __or__(), and __xor__()
  
 • Righthand versions of overloading calculation operators
  
 • Shorthand versions of overloading calculation operators
  
 • Overloading unary operators __neg__(), __pos__(), __invert__(), __abs__(), 
  
 __int__(), 
 __float__(), __round__(), and __bytes__()
  
 • Overloading operators 
  
 for 
  
 sequence 
  
 classes 
  
 __len__(), 
  
 __getitem__(), 
  
 __setitem__(), __delitem__(), __missing__(), and __contains__()",NA
Exercises,"Exercise 21.1 
  
 A playing card consists of a suit (""Hearts"", ""Spades"", ""Clubs"", ""Diamonds"") 
 and a value (2, 3, 4, 5, 6, 7, 8, 9, 10, ""Jack"", ""Queen"", ""King"", ""Ace""). Implement a Card class. 
 Implement that cards are equal when they have an equal rank, and that the other 
 comparisons use the ranks in the order given above (2 lowest, Ace highest). Test the class.
  
 Exercise 21.2
  Use the Card class as given above. Now also create a Drawpile class. A 
 Drawpile consists of a sequence of cards. The cards are supposed to form a pile with the top 
 card having the lowest index, and the bottom card the highest index. Implement the __len__() 
 and __getitem__() methods. Create an add() method to add a card to the draw pile at the 
 bottom, and a draw() method to remove the top card from a draw pile and return it. Test the 
 class.",NA
Chapter 22,NA,NA
Inheritance,"Inheritance allows you to create new classes based on existing ones, just by indicating the 
 difference. It is an extremely powerful concept that allows for the creation of highly flexible, 
 easily maintainable programs.",NA
22.1 ,NA,NA
Class inheritance,"In Chapter 20 I gave the example of Apple and Orange both being subclasses of a class Fruit, 
 and Student and Teacher both being subclasses of a class Person. You can imple-ment such a 
 hierarchy of classes and subclasses using “inheritance.”
  
 Basically, inheritance is really simple. When you define a new class, between parentheses 
 you can specify another class. The new class inherits all the attributes and methods of the 
 other class, i.e, they are automatically part of the new class.
  
 listing2201.py
  
 class Person: 
  
  
 def __init__( self, firstname , lastname , age ): 
  
  
  
 self.firstname = firstname 
  
  
  
 self.lastname = lastname 
  
  
  
 self.age = age 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""{} {}""
 .format( self.firstname , self.lastname ) 
  
 def underage( self 
 ): 
  
  
  
  
 return self.age < 18
  
 class Student( Person ): 
  
  
 pass
  
 albert = Student(
  ""Albert""
 ,
  ""Applebaum""
 , 19 ) print( albert ) 
  
 print( albert.underage() )
  
 As you can see, the Student class inherits all properties and methods of the class Person.",NA
22.2 ,NA,NA
Interfaces,"An interface is a class that specifies attributes and methods without an actual implemen-
 tation of the methods. The idea is that subclasses implement the methods, while functions 
 can be defined as working on the interface class, under the assumption that the methods will 
 be filled in. Such functions can then be called with instances of the subclasses.
  
 For good understanding, it is probably better to give an example.
  
 Suppose that I want to design an application that works with vehicles. Maybe it is a travel-
 planning application that calculates how to get from point A to point B. The application will 
 have a map containing all possible points and connections between the points. It will also 
 have a list of vehicles, with certain vehicles being restricted to specific points, and 
 connecting only specific points (e.g., planes will only be available at airports, and only 
 connect to specific other airports, while boats are only found in harbors and connect to 
 specific other harbors). The application gets a start and end point as input, and provides a 
 list of the sort: take the car to drive from start point to point X, take the plane to fly from 
 point X to point Y, take the bus to drive from point Y to point Z, and then walk from point Z to 
 the end point.",NA
What you learned,"In this chapter, you learned about:
  
 • Inheritance
  
 • Overriding",NA
Exercises,"Exercise 22.1
  Below I give a Rectangle class that is created with the x and y coordinate of 
 the top-left corner, a width w, and a height h. Now create a Square class that inherits as much 
 as possible from the Rectangle class.
  
 exercise2201.py
  
 class Rectangle: 
  
  
 def __init__( self, x, y, w, h ): 
  
  
  
 self.x = x 
  
  
  
 self.y = y 
  
  
  
 self.w = w 
  
  
  
 self.h = h 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""[({},{}),w={},h={}]""
 .format( self.x, self.y, 
  
  
  
 self.w, self.h ) 
  
  
 def area( self ): 
  
  
  
  
 return self.w * self.h 
  
  
 def circumference( self ): 
  
  
  
  
 return 2*( self.w + self.h)
  
  
 Exercise 22.2
  
 A Rectangle and a Square can be considered shapes.
  
 There are, of
  
 course, different kinds of shapes which are defined differently, but share with rectangles and 
 squares that they have an area and circumference. Define an interface class Shape, of which 
 Rectangle and Square are sub(sub)classes. Also define a class Circle that you derive from 
 Shape.
  
 Exercise 22.3
  In the Iterated Prisoner’s Dilemma, two strategies play against each other 
 over multiple rounds. Every round, the strategies can decide to either Coorperate (C) or 
 Defect (D). If both cooperate, they both get 3 points. If both defect, they both get 1 point. If 
 one cooperates and one defects, the one that defects gets 6 points, and the one that cooper-
 ates gets nothing. The goal for each strategy is to score as many points as possible.
  
 Below a simple version of the Iterated Prisoner’s Dilemma is coded. A strategy to play the 
 game is defined by the class Strategy. The main loop lets two strategies play each other for 
 100 rounds (it is not hard to create a main loop that lets more than two strategies play each 
 other in pairs, but that increases the size of the code quite a bit and is not important for the 
 exercise). Strategy has not implemented the choice() method. To create a strategy, you 
 inherit a new class from Strategy, and code the choice() method. Optionally you can also 
 implement the lastmove() method, and extend the __init__() method.",NA
Chapter 23,NA,NA
Iterators and Generators,"Iterators allow your classes to be used in for ... in ... statements. Generators are an easy way 
 to create iterators.",NA
23.1 ,NA,NA
Iterators,"You have used the for ... in ... command on many occasions. You may have noticed that it can 
 be used for many different applications.
  
 listing2301.py
  
 for i in [1,2,3,4]: 
  
  
 print( i, end=
 "" ""
  ) 
  
 print() 
  
 for i in (
  ""pi""
 , 3.14, 22/7 ): 
  
  
 print( i, end=
 "" ""
 ) 
  
 print() 
  
 for i in range( 3, 11, 2 ): 
  
  
 print( i, end=
 "" ""
 ) 
  
 print() 
  
 for c in
  ""Hello""
 : 
  
  
 print( c, end=
 "" ""
  ) 
  
 print() 
  
 for key in {
  ""apple""
 :1,
  ""banana""
 :3 }: 
  
 print( key, 
 end=
 "" ""
  )
  
 List, strings, and dictionaries are all “iterables,” which means they can be used in such for ... 
 in ... expressions. Many other objects can also be used as iterables. You can actually ensure 
 that your own classes can be used as iterables as well.
  
 An “iterator” is an object that returns a new item every time you call the next() function with 
 the object as argument. When there are no items left, it raises a StopIteration ex-ception. If 
 you want to avoid the exception, you can give an optional second argument to next(), which 
 is returned when the iterator is exhausted. You can turn an iterable into an iterator object 
 using the built-in function iter().",NA
23.2,NA,NA
Generators,"A generator is a function that emulates the behavior of an iterable object. In general, im-
 plementing a generator is shorter and easier than creating an iterable. Several standard 
 functions are implemented as generators, for example range().
  
 Generators are based on the yield keyword. When calling __next__() on a generator, the 
 function is executed until yield is reached, then the value that is associated with yield is 
 returned. At that point, the function “waits” until __next__() is called again, after which it 
 continues until yield is reached again. StopIteration is raised automatically when the 
 function ends.",NA
23.3 ,NA,NA
itertools,NA,NA
 module,"The itertools module contains a collection of functions that allow advanced manipula-tion of 
 iterators. Taken to the extreme, they allow for a sort of “iterator algebra” that can be used to 
 implement specialized tools in Python. Here I just highlight a few of the basic functions from 
 itertools that you might find handy at times.",NA
What you learned,"In this chapter, you learned about:
  
 • Iterators
  
 • Iterables
  
 • __iter__(), __next__(), and StopIteration
  
 • Different approaches to implementing iterable objects• 
 zip()
  
 • Generators
  
 • yield
  
 • Generator expressions
  
 • itertools
  
 functions
  
 chain(),
  
 zip_longest(),
  
 product(),
  
 permutations(),
  
 combinations(), and combinations_with_replacement()",NA
Exercises,"Exercise 23.1
  Create a program that asks the user to enter positive integers. The user can 
 enter as many as desired, and indicates that the last integer was entered by supplying zero. 
 The program the prints all numbers between 1 and 100 that are not divisible by any of the 
 integers entered. Print those numbers in a for ... in ... loop, using an iterator to produce the 
 numbers.
  
 Exercise 23.2
  Create a generator that produces factorials. The first value returned is 1!, 
 the second 2!, the third 3!, etcetera, up to 10!. Do not calculate the factorial every time from 
 scratch, but retain the value that you used in the previous cycle and use that.
  
 Exercise 23.3
  Ask the user to enter a word. Produce all anagrams of that word. If the 
 word contains multiple copies of a letter, it is acceptable if you produce certain anagrams 
 multiple times. For example, if the word is
  ""ape""
 , you produce
  ""aep""
 ,
  ""ape""
 ,
  ""eap""
 ,
  ""epa""
 , 
 ""pae""
 , and
  ""pea""
  (in any order).
  
 Exercise 23.4
  Do the previous exercise, but now make sure that all anagrams are unique, 
 even if the word contains repetitions of letters. For example, if the word is
  ""bee""
 , you 
 produce
  ""bee""
 ,
  ""ebe""
 , and
  ""eeb""
 .
  
 Exercise 23.5
  The ""subset sum"" problem asks the question whether a list of integers 
 contains a subset of integers that, when summed, gives zero as answer. For instance, for the 
 list [1, 4, -3, -5, 7] the answer is “yes,” as 1 + 4 - 5 = 0. However, for the list [1, 4, -3, 7] the 
 answer is “no,” as there is no subset of integers that adds up to zero. Write a program that 
 solves the “subset sum” problem for a list of integers. If there is a solution, print it; if not, 
 report that there is no solution.
  
 This is a repetition of one of the exercises of Chapter 12 (Lists). In that chapter I said that 
 you have to solve the exercise recursively. However, using the itertools module, you can now 
 solve it without recursion (though I suspect that recursion still is used within the itertools 
 module – you, however, do not have to).
  
 Exercise 23.6
  Write a program that produces all possible sub-dictionaries from a dic-
 tionary, and stores them in a list. For instance, if the dictionary is {
 ""a""
 :1,
 ""b""
 :2}, the program 
 produces [{},{
 ""a""
 :1},{
 ""b""
 :2},{
 ""a""
 :1,
 ""b""
 :2}] (the ordering of the list does not matter). Again, use 
 the itertools module.
  
 Exercise 23.7
  Write a program that determines how you can place eight queens on a 
 chess board in such a way that none of them attacks any of the other ones. This is a classic 
 problem that sounds like it has little to do with this chapter, but when you consider that you 
 may solve it using the permutations() function in a smart way, you will find that this 
 program can be surprisingly short.",NA
Chapter 24,NA,NA
Command Line Processing,"In Chapter 15 I mentioned that when handling large volumes of data spread over multiple 
 files, you occasionally might want to write a Python program that supports command-line 
 processing. This chapter tells you how to do that.",NA
24.1 ,NA,NA
The command line,"Chapter 15 explained how you can get access to your computer’s “command prompt”. If you 
 do not remember, please go refresh your memory. The chapter also explained that you can 
 start Python programs directly from the command prompt with the command:
  
 python <programname>.py
  
 This works as long as your system knows how to find Python and the program resides in the 
 current directory. If the program is not in the current directory, it will still work as long as 
 you specify the complete path to the program in the command.
  
 24.1.1 
  
 Batch processing
  
 Suppose you have written a program that asks a user for a filename and maybe for a few 
 extra parameters, then processes the file with the indicated name using the parameters. I 
 then ask you to run that program on all the files in a specific directory. The directory 
 contains over 10,000 files. What will you do?
  
 You might adapt the program so that instead of asking for the name of file and processing 
 that file, it processes all files in a directory, using parameters that are not asked of the user. If 
 the parameters that you have to use differ per file, there has to be a way to know what they 
 are (perhaps you can derive them from the file name), so it should be possible to calculate 
 them. This solves your problem. But then I ask you to run your program on a bunch of 
 different directories. What will you do?
  
 You can adapt your program so that it contains a list of all the directories that you need to 
 process, then work through them one by one. And every time that I ask you to add an extra 
 directory, just change the program. Regardless what I ask you, you can always adapt",NA
24.2,NA,NA
Flexible command line processing,"When I code Python programs, I prefer working from an editor. There are a few editors that 
 support supplying command line arguments to a program when testing it, but most do not. 
 So I want to develop my programs in such a way that I can build them as if they process 
 command line arguments, but that I can test them directly from an editor, and only need to 
 test whether or not they actually process command line parameters correctly once.
  
 I do that as follows:
  
 For every parameter that can be controlled via the command line, I create a global variable. I 
 fill these global variables with default values. In the rest of the program, I use these variables 
 as if they are constants. Only at the very start of the main program I check for the existence 
 of command line arguments, and if I find those, I overwrite the variables with values that are 
 supplied on the command line.
  
 The advantage of this approach is that I can develop my program without using command 
 line arguments. If I want to use different values for the command line arguments for test-ing, 
 I simply use different values for the variables in which I will store the command line 
 arguments. I can even set up the program in such a way that it will either fill a variable via a 
 command line argument, or will ask the user for the value if it was not supplied on the 
 command line.
  
 Typically, such code looks as follows:
  
 listing2401.py
  
 import sys
  
 # 3 variables for holding the command line parameters
  
 inputfile =
  ""input.txt"" 
  
 outputfile =
  ""output.txt"" 
  
 shift = 3
  
 # Processing the command line parameters
  
 # (works with 0, 1, 2, or 3 parameters) 
  
 if len( sys.argv ) > 1: 
  
  
 inputfile = sys.argv[1] 
  
 if len( sys.argv ) > 2: 
  
  
 outputfile = sys.argv[2] 
  
 if len( sys.argv ) > 3: 
  
 try: 
  
  
   
 shift = int( sys.argv[3] ) 
  
  
 except TypeError: 
  
  
   
 print( sys.argv[3],
  ""is not an integer.""
  ) 
  
  
  
 sys.exit(1)
  
 In this code, three command line arguments are supported: the first two are strings, and the 
 third is an integer. The third one is immediately converted from a string (which a command 
 line argument always is) to an integer, and the program is aborted if this conversion fails. I 
 could have built in more checks for demonstration, but I assume that at this point in your 
 programming career that does not pose any problems to you.",NA
What you learned,"In this chapter, you learned about:
  
 • Command line arguments
  
 • sys.argv
  
 • Flexible command line processing",NA
Exercises,"Exercise 24.1
  Create a program that can be started with zero or more numerical argu-
 ments. If it gets presented with a non-numerical argument, the program gives an error 
 message. If it gets presented with only numerical arguments, it adds them up and prints the 
 sum. Test the program on the command line.",NA
Chapter 25,NA,NA
Regular Expressions,"When you are facing a problem with text mining, data processing, finding patterns in large 
 collections of data, or scraping data from web pages, and you explore the Internet to find a 
 solution to your problem, you will find that often the very first answer given to questions in 
 this respect is “Why don’t you use regular expressions?” or even “Just use regex,” without 
 further explanations. Rather smug answers, as many people have never heard of regular 
 expressions, and if they have, might find them scary and incomprehensible. In fact, at first 
 glance they come over as so arcane and confusing that most people rather shy away than 
 delve into them. Which is a pity, as regular expressions are a powerful tool that should not 
 be missing in the toolbox of anyone who deals with unstructured data on a regular basis.
  
 In this chapter I will explain how to write and use basic regular expressions with Python. 
 You will find them indeed a powerful way to quickly express and discover complex and 
 diverse patterns in data, providing access to functionalities that would be very hard to 
 implement in vanilla Python. While this chapter does not contain a complete overview of 
 regular expressions, after studying it you will be able to understand and use regular 
 expressions for most, if not all, pattern-matching problems that you encounter in practice, 
 and be confident in telling the uninitiated: “You should use regular expressions to solve your 
 problems.” Now you can feel smug too!",NA
25.1 ,NA,NA
Regular expressions with Python,"Regular expressions are text strings that describe a “pattern” that can be found in textual 
 data. For example, the regular expression a+ describes a pattern that consists of a sequence 
 of one or more times the letter “a.” In the string “aardvark” this pattern can be found twice, 
 namely as the “aa” at the start of the string, and the single “a” in the second half of the string.
  
 A regular expression always consists of a string, which may contain any character. Some 
 characters are “meta-characters” which have a special meaning in regular expressions. You 
 should be careful when using them (how you should use them will be discussed later). The 
 meta-characters are:
  
 . ^ $ * + ? { } [ ] \ | ( )
  
 I will discuss how to write regular expressions later in this chapter. First, I need to discuss 
 how to use regular expressions in Python code.",NA
25.2,NA,NA
Writing regular expressions,"Now the basics of using regular expression in Python via the re module have been ex-
 plained, I can get into the actual writing of regular expressions.
  
 25.2.1 Regular expressions with square brackets
  
 The simplest regular expression is a string of characters, which describes a pattern consist-
 ing of exactly that string of characters. You may also describe a range of characters using 
 square brackets [ and ]. For instance, the regular expression [aeiou] describes any of the 
 characters
  ""a""
 ,
  ""e""
 ,
  ""i""
 ,
  ""o""
 , or
  ""u""
 . This means that if [aeiou] is part of a regular ex-pression, 
 at that location in the pattern one of these letters must reside (note: exactly one of them, so 
 not multiple). For instance, to search for the words
  ""ball""
 ,
  ""bell""
 ,
  ""bill""
 , 
 ""boll""
  and
  ""bull""
 , the 
 regular expression b[aeiou]ll can be used.
  
 listing2503.py
  
 import re
  
 slist = re.findall(
  r""b[aeiou]ll""
 ,
  ""Bill Gates and Uwe Boll \ drank Red Bull at a football 
 match in Campbell.""
  ) 
  
 print( slist )
  
 Exercise
  Change the regular expression above so that it not only finds the words ""ball"" and 
 ""bell"", but also ""Bill"", ""Boll"", and ""Bull"".
  
 You can use a dash within the square brackets between two characters to indicate that they 
 represent not only these two characters, but also all the characters in between. For instance, 
 the regular expression [a-dqx-z] is equivalent to [abcdqxyz]. To describe any of the letters of 
 the alpabet, either as capital or lower case, you can use [A-Za-z].
  
 Moreover, if you place a caret (^) right next to the opening square bracket, that means that 
 you want the opposite of what is within the square brackets. For instance, [^0-9] indicates 
 any character except for a digit.
  
 25.2.2 Special sequences
  
 In a regular expression, just like in strings, the backslash character (\) indicates that the 
 character that follows it has a special meaning, i.e., it is an escape sequence. The escape",NA
25.3 ,NA,NA
Grouping,"As shown above, when parentheses are used in regular expressions, they create so-
 called“groups.” Take for instance the regular expression (\d{1,2})-(\d{1,2})-(\d{4}), which 
 describes a sequence that could represent a date: one or two digits, followed by a dash, 
 followed by one or two digits, followed by a dash, followed by four digits (if you do not 
 understand this regular expression, check back in previous sections of this chapter until you 
 do understand it). This expression contains three groups: the first containing one or two 
 digits, the second containing one or two digits, and the third one containing the four digits at 
 the end. The code below searches for this pattern in a string.
  
 listing2507.py
  
 import re
  
 pDate = re.compile(
  r""(\d{1,2})-(\d{1,2})-(\d{4})""
  ) 
  
 m = pDate.search(
  ""In response to your letter of 25-3-2015, \ I decided to hire a 
 hitman to get you.""
  ) 
  
 if m: 
  
  
 print(
  ""Date {}; day {}; month {}; year {}""
 .format( 
  
  
  
 m.group(0), m.group(1), m.group(2), m.group(3) ) )
  
 When you run the code, you see that it not only gets out the result as a whole (using the 
 method group() or group(0)), but that you can also access each of the groups that is found in 
 the result, using methods group(1) for the day, group(2) for the month, and group(3) for the 
 year. You can also use the method groups() to get a tuple with all the groups.
  
 25.3.1 
 findall()
  and groups
  
 The findall() methods returns a list of pattern objects. In the examples where it was used 
 until now, it returned a list of strings. Indeed, pattern objects are strings if there is at most 
 one group in the regular expression. If there are multiple groups, pattern objects are actually 
 tuples that contain all the groups.
  
 listing2508.py
  
 import re
  
 pDate = re.compile(
  r""(\d{1,2})-(\d{1,2})-(\d{4})""
  ) 
  
 datelist = pDate.findall(
  ""In response to your letter of \ 
  
 25-3-2015, on 27-3-2015 I decided to hire a hitman to get you.""
  )",NA
25.4 ,NA,NA
Replacing,"While regular expressions are mainly used for searching, you can also use regular expres-
 sions to replace substrings in a string with different substrings. You can use the sub() 
 method for this. sub() gets as arguments the to-be-replaced pattern, the replacement, and 
 the string. The sub() method returns the new string (remember that strings are immutable, 
 so sub() will not actually change your original string, even if it is stored in a variable; you will 
 have to store its return value if you want access to the new string).
  
 The replacement is usually just a string, but it may contain references to groups in the 
 original pattern. You will have to use a format that is different from the \x format shown 
 before. If you want to refer to group x in the pattern (x being a number), you write \g<x>. 
 The reason for the difference is disambiguation; it allows you to distinguish a reference to, 
 for instance, group 2 followed by a character zero, from a reference to group 20.
  
 import re
  
 s = re.sub(
  r""([iy])se""
 ,
  ""\g<1>ze""
 ,
  ""Whether you categorise , \ emphasise , or analyse , 
 you should use American spelling!""
  ) print( s )",NA
What you learned,"In this chapter you learned about:
  
 • What regular expressions are
  
 • Which meta-characters can be used in regular expressions",NA
Exercises,"Exercise 25.1
  Assume that a word consist of only letters from the alphabet (upper case 
 or lower case). Write some code that uses a regular expression to make a list of all the words 
 in a text.
  
 Exercise 25.2
  Using a regular expression and the findall() method, create a list of all the 
 occurrences of the word “the” a sentence. Print the number of items in the list. Your code 
 should handle the problem in a case-insensitive way. Make sure that you do not count the 
 letter combination “the” when it occurs as part of another word (e.g., “thesaurus” or“ether”).
  
 Exercise 25.3
  A person’s full name consists of two words, next to each other, consisting 
 of only letters from the alphabet, all lower case except for the first one, which is upper case. 
 Between the two words there should only be white spaces. The words start and end at a 
 word boundary. E.g., according to this specification Cardinal Richelieu is a name, but Charles 
 d’Artagnan is not, and neither is Gilbert duPrez, Joe DiMaggio, or Unit X1138. Under this 
 assumption, use a regular expression to list all the two-word combinations in a sentence 
 which are probably names of persons.
  
 Exercise 25.4
  As a follow-up to the previous exercise, now assume that a person’s name 
 consists of two or more words that meet the criteria spelled out above. Use a regular 
 expression to extract all names.",NA
Chapter 26,NA,NA
File Formats,"Data is usually stored in files, which are constructed according to a specific file format. 
 Standardized file formats often are supported by Python using a particular module. In this 
 chapter, I discuss some of more common file formats and the modules that support them.",NA
26.1 ,NA,NA
Comma-Separated Values (CSV),"Comma-Separated Values (CSV) is the most common text file format that is used for im-
 porting and exporting data to and from spreadsheets and databases. The general format says 
 that each line contains one record (a record is a complete entity), listing each of the fields of 
 the record in a specific order, separating the fields by commas. The first line of the file may 
 or may not consist of names for the fields in the CSV file.
  
 The code below loads and displays the contents of a typical CSV file. Appendix E explains 
 how to get this CSV file.
  
 fp = open(
  ""pc_inventory.csv""
  ) 
  
 print( fp.read().strip() ) 
  
 fp.close()
  
 Unfortunately, the CSV format is not standardized, and different software packages tend to 
 use slightly different implementations of CSV files. However, over the years the differ-ent 
 conventions used by the major software packages have converged to something of a 
 standard, that is implemented in the Python csv module. The module supports “dialects”of 
 CSV formats to handle files from different sources.
  
 Instead of using the csv module, if you have to deal with an excentric CSV format that the 
 module does not support, you can try to design your own interpretation of lines of the file 
 using regular expressions. You can also try to design your own dialect. Neither option is very 
 appealing.
  
 26.1.1 
  
 CSV
  reader()
  
 The csv module contains a reader() function that provides access to a CSV file. The reader() 
 function gets a file handle as argument, and returns an iterator that allows you",NA
26.2 ,NA,NA
Pickling,"Suppose that you want to store a certain data structure in a file, for instance, a list of tuples. 
 One way of doing that is to turn the tuples into strings and write those into the file, one line 
 for every tuple. When you then later want to rebuild the data structure in a program, you 
 read the file, unravel the lines, and reconstruct the list of tuples. As you can imagine, this 
 encompasses a considerable amount of quite difficult code.
  
 Fortunately, you do not have to write such code. Python offers a solution for storing data 
 structures in files, including both structure and content, which is called “pickling.” You can 
 write the whole data structure to the file in one go, if you just open a binary file for writing, 
 and call the function dump() from the pickle module with the data structure as first 
 argument, and the file handle as second argument.
  
 listing2603.py
  
 from pickle import dump
  
 cheeseshop = [ (
 ""Roquefort""
 , 12, 15.23), 
  
 (
 ""White Stilton""
 , 25, 19.02), (
 ""Cheddar""
 , 5, 0.67) ]
  
 fp = open(
  ""pc_cheese.pck""
 ,
  ""wb""
  ) dump( 
 cheeseshop , fp ) 
  
 fp.close()
  
 print(
  ""Cheeseshop was pickled""
  )
  
 To read the contents of a pickle file, you use the function load() from the pickle module. 
 load() gets a handle to the file as argument. Do not forget to open the file in binary mode.
  
 listing2604.py
  
 from pickle import load
  
 fp = open(
  ""pc_cheese.pck""
 ,
  ""rb""
  ) buffer = load( 
 fp ) 
  
 fp.close()
  
 print( type( buffer ) ) 
  
 print( buffer )",NA
26.3,NA,NA
JavaScript Object Notation (JSON),"JavaScript Object Notation (JSON) is a file format that is often used in modern applications, in 
 particular those that communicate via web services. It is supported by many languages 
 (JavaScript amongst them, of course). It is similar to pickling in the sense that it stores in-
 memory objects to files, retaining their structure. A difference with pickling is that JSON files 
 are in human-readable format.
  
 The json module works equivalent to the pickle module, with a dump() function that writes 
 data structures to a file, and a load() function to load data structures from a file. The file 
 must be a text file, and not a binary file.
  
 listing2606.py
  
 from json import dump, load
  
 cheeseshop = [ (
 ""Roquefort""
 , 12, 15.23), 
  
  
 (
 ""White Stilton""
 , 25, 19.02), (
 ""Cheddar""
 , 5, 0.67) ]
  
 fp = open(
  ""pc_cheese.json""
 ,
  ""w""
  ) dump( 
 cheeseshop , fp ) 
  
 fp.close()",NA
26.4 ,NA,NA
HTML and XML,"HTML and XML are standard formats that are used to display information on webpages. 
 They consist of readable text files, with many instructions on formatting. It is a common task 
 for data miners to “scrape” data from webpages. You can use regular expressions for that, 
 but if the webpages are reasonably well-formatted, the “Beautiful Soup” module may help 
 you out.
  
 The Beautiful Soup module is named bs4 in Python (naturally, bs3 came before it, and it may 
 get more updates later). It contains the BeautifulSoup class that you can use to load and 
 interpret HTML and XML files. bs4 is not part of the standard Python package; you have to 
 install it separately, which is quite a hassle, unless you use a tool called pip which comes 
 standard with Python 3.
  
 There are alternative modules that can ease the pain of web scraping for you, notably lxml, 
 but Beautiful Soup seems to be the most popular.
  
 Since all such modules require separate installations, I will not discuss them here. I only 
 wish to indicate that if you need to do web scraping (and it is likely you have to do that at 
 some point), you should check out some of the standard tools available for that before you 
 delve into eccentric regular expression-design.",NA
What you learned,"In this chapter, you learned about:",NA
Exercises,"Exercise 26.1
  Open the file “pc_inventory.csv” and read its contents using reader(). Write 
 the contents to a different CSV file, using a space as delimiter and a single quote as quotation 
 character. Open the file you created as text file and display its contents to check them.
  
 Exercise 26.2
  Load the contents from the file “pc_inventory.csv,” and put them in a list of 
 lists (each line in the file being one list in the list of lists). Store the list in JSON format. Open 
 the file you created as a text file and display its contents to examine them.",NA
Chapter 27,NA,NA
Various Useful Modules,"At this point in the book, everything that you really need to know to be an accomplished 
 Python programmer – or maybe even an accomplished programmer in general – has been 
 covered. I want to quickly highlight a few useful modules that do not need a chapter of their 
 own. I will not give many details; once you know what the purpose of a module is, you can 
 look up more information on it in the Python reference.",NA
27.1 ,NA,NA
datetime,"The datetime module contains functions that allow the manipulation of date and time. The 
 module contains various classes for date and time manipulation, of which the most 
 important ones are datetime, timedelta, date, and time. datetime contains attributes year, 
 month, day, hour, minute, second, microsecond, and tzinfo (the last attribute pro-vides time 
 zone information). date and time contain subsets of these attributes. Objects of these types 
 are immutable.
  
 I restrict myself to discussing the datetime and timedelta classes, though related func-tions 
 and methods exist for the other classes.
  
 datetime objects hold a date and a time. Amongst the methods for datetime objects are:
  
 • now() creates a datetime object that contains the current day and time. You would 
  
 typically use a class call to get a value for now().
  
 • datetime() creates a datetime object using given arguments. The first three argu-ments 
 are not optional, and are year, month, and day. The others, hour, minute, second, 
 microsecond, and tzinfo are optional. Arguments can either be given in this order, or 
 by specifying <argument>=<value>, with <argument> an argument name as specified 
 above.
  
 from datetime import datetime 
  
 print( datetime.now() )",NA
27.2,NA,NA
collections,"The collections module contains handy classes that allow you to manipulate iterables such as 
 strings, tuples, lists, dictionaries, and sets. collections offers many interesting functionalities, 
 most of which are a bit eccentric, making it unlikely that you will need to use them soon. I 
 discuss two of them, namely the Counter class and the deque class.
  
 A Counter object is a similar to a dictionary, which contains items as keys, and for each of the 
 items a “count” as value. You create a Counter object by providing the sequence of which you 
 want to count the items as argument. It has some useful methods, such as:
  
 • most_common() gets an integer as argument and returns a list containing the items that 
 have the highest count, as many as the integer argument indicates. The items on the 
 list are 2-tuples, the first element of a tuple being the counted item, and the second 
 element being the count. They are ordered from most common to least common. If no 
 integer argument is specified, the list contains all the items.
  
 • update() gets an iterable as argument and “adds in” the items of the iterable.",NA
27.3,NA,NA
urllib,"The urllib module allows you to access web pages in the same way that you access files. 
 There are two modules of main interest: urllib.request contains functions to access Inter-net 
 content, and urllib.error contains definition for exceptions that can be raised. You can also 
 use urllib to communicate with webpages; if you want to do so, you need to study the 
 urllib.parse module. For now, I only give a simple example in which you want to open a 
 webpage and read its contents.
  
 listing2703.py
  
 from urllib.request import urlopen 
  
 from urllib.error import HTTPError , URLError from sys 
 import exit
  
 try: 
  
  
 u = urlopen(
  ""http://www.python.org""
  ) except 
 HTTPError as e: 
  
  
  
 print(
  ""HTTP Error""
 , e ) 
  
  
  
 sys.exit()",NA
27.4 ,NA,NA
glob,"The glob module provides a function glob() to produce lists of files based on a wildcard 
 search pattern that is provided as argument. The wildcard search uses Unix conventions, 
 most of which also hold on other systems. They are as follows:
  
 • A question mark (?) in a file name indicates any character
  
 • A Kleene star (*) in a file name indicates any sequence of characters
  
 • A sequence of characters between square brackets ([]) indicates any of these charac-
 ters; a dash may be used to indicate a sequence that runs from the character to the left 
 of the dash to the character to the right of the dash
  
 For instance, the wildcard search
  ""A[0-9]?B.*""
  looks for all files that start with the letter A, 
 followed by a digit, followed by any character, followed by a B, with any extension. It 
 depends on the operating system whether this is a case-sensitive or case-insensitive search.
  
 Do not confuse a wildcard search pattern with a regular expression. While they have some 
 superficial resemblance (such as an asterisk indicating “a series of any characters” in both of 
 them), they are nothing alike. Wildcard searches only support the patterns listed above 
 (some of which have a different meaning for regular expressions), and are only used for glob 
 and when directly communicating with the system via the command prompt.
  
 from glob import glob 
  
 glist = glob(
  ""*. pdf""
  ) 
  
 for name in glist: 
  
  
 print( name )
  
 The glob module also contains a function iglob(), which has the same functionality as glob(), 
 but produces an iterator instead of a list.
  
 Exercise
  Use glob() to list all Python files in the current directory.",NA
27.5,NA,NA
statistics,"The statistics module gives you access to various common statistical functions. All of these 
 functions get as argument a sequence or iterator of numbers (integers or floats).
  
 • mean() calculates the mean (or average) of a sequence of numbers
  
 • median() calculates the median of a sequence of numbers, i.e., the “middle” number
  
 • mode() calculates the mode of a sequence of numbers, i.e., the number that occurs 
  
 most 
 often
  
 • stdev() calculates the standard deviation of a sequence of numbers
  
 • variance() calculates the variance of a sequence of numbers
  
 There are a few more functions in the statistics module, but these are the most-used ones. 
 For more advanced statistical calculations, there are other modules available, which I do not 
 discuss in this book.
  
 These functions may raise a StatisticsError. This is particularly relevant in the case of the 
 mode() function, as it is generated when no unique mode can be found.
  
 listing2704.py
  
 from statistics import mean, median , mode, stdev, variance , \
  
 StatisticsError
  
 data = [ 4, 5, 1, 1, 2, 2, 2, 3, 3, 3 ]
  
 print(
  ""mean:""
 , mean( data ) ) 
  
 print(
  ""median:""
 , median( data ) ) 
  
 try: 
  
  
 print(
  ""mode:""
 , mode( data ) ) 
  
 except StatisticsError as e: 
  
  
 print( e ) 
  
 print(
  ""st.dev.: {:.3f}""
 .format( stdev( data ) ) ) print(
  ""variance: {:.3f}""
 .format( 
 variance( data ) ) )
  
 Note that for a sequence with an even number of numbers, the median is the average of the 
 two “middle” numbers. There are different ways of calculating the median in case of an even 
 number of numbers; if you want to use a different one, examine other functions in the 
 statistics module.
  
 As for the mode, in the literature you find multiple definitions of what the mode is sup-posed 
 to be. The general definition is “the most common number,” but what if there are multiple of 
 those? What if each number is unique? The version of the mode that the statistics module 
 supports does not seem to be the most common one.",NA
What you learned,"In this chapter, you learned about:",NA
Exercises,"Exercise 27.1
  Use the Counter class to list the five most common letters in a text, with 
 their counts.
  
 Exercise 27.2
  Create a program that asks the user for numbers, until the user enters zero. 
 It then prints the mean, median, and mode of these numbers. The statistics module can be 
 used for the mean and median; however, for the mode, print all those numbers that have the 
 highest count, even if that entails that you print more than one number. By definition, for a 
 number to be the mode it must occur at least twice; so if every number only occurs once, 
 there is no mode. Hint: Consider using the Counter class to construct the mode.",NA
Epilogue,"If you made it through the book and managed to do most of the exercises all by your-self: 
 Congratulations! You have become a programmer. You have internalized the basics of 
 dealing with any programming language, and should be able to solve most of the pro-
 gramming problems that you encounter in your career as a student or as a professional 
 worker. If you need to learn another programming language, by now you have a solid basis 
 to quickly get to grips with any other language. Even better, you have learned to approach 
 problems like programmers do, which is a valuable skill that you will find many uses for.
  
 Future editions of this book should have even more information and more interesting prob-
 lems to work on. This will all be optional material, but if you enjoy programming as much as 
 I do, you might want to check it out.
  
 If you have any remarks on the contents of the present version of the book, I’ll be glad to 
 receive your message at pythonbook@spronck.net.",NA
Appendix A,NA,NA
Troubleshooting,"When I run code I get an ImportError
  
 Check the name of the file that your code tries to import. If it is supposed to be one of the 
 standard Python libraries, you probably made a spelling mistake in the name. Either that, or 
 you added .py to the name – you should not do that. If the error concerns pcinput or pcmaze, 
 then probably you either did not build these files (check Appendix C or D to solve the 
 problem), or you placed them in a location that Python has no access to. In the last case, 
 make sure you copy them to the same place as where you keep your Python programs.
  
 I get a FileNotFoundError: [Errno 2]
  
 You try to open a file that Python cannot find. You might have forgotten to include the 
 complete pathname in the file name, or you think the file is located in the current directory 
 while actually it is not. Or maybe your code tries to use one of the standard test files that I 
 use for the book, and you do not have those yet. If that is the case, check Appendix E to learn 
 how to make them.
  
 I get a SyntaxError but I have no idea what I did wrong
  
 When one or more syntax errors are reported, you should try to solve the one reported first. 
 Further errors are often caused by the first one. The line of code where Python discovered 
 the error is reported with the error. Check that line. Also check the line above it: it might 
 very well happen that you made an error in a line of code, but Python only notices it when it 
 processes the next line. Syntax highlighting may also give an indication of where you made 
 your mistake. Common syntax errors that beginning programmers make are forgetting to 
 include a colon (:) at the end of an if, while, or for statement, misspelling the name of 
 variables that they created, or making errors in indentation.
  
 I get a SyntaxError that reports a “Non-UTF-8 code”
  
 You have used a character in your program that Python cannot process. For instance, you 
 might have placed your own name in the code (maybe even only in a comment), and your",NA
Appendix B,NA,NA
Differences with Python 2,"This appendix contains an overview of the differences between Python 2 and Python 3, as far 
 as they relate to the contents of this book and as far as I am aware of them. You can ignore 
 this appendix if you are only going to use Python 3.
  
 Operators
  
 The division operator (/) in Python 2 works differently from the one in Python 3. In Python 
 3, it is automatically assumed that if you use division, you need floating-point numbers, so 
 the division will assume that all numbers involved are floats, and will always result in a float. 
 In Python 2, it is assumed that the division will be of the type that is “most detailed”for the 
 numbers involved, i.e., if you divide two numbers and at least one is a float, it will be a 
 floating-point division and the result is a float, but if you divide two integers, it will be an 
 integer division and the result will be an integer (if the resulting number would 
 mathematically have decimals, then the decimals are simply removed). The way Python 2 
 works is similar to what most programming languages do, but the way Python 3 works is 
 more intuitive and leads to fewer errors.
  
 Reserved words
  
 In Python 3, print and exec are no longer reserved words (or keywords), as they are now 
 functions. However, True, False, and None are now keywords, as is the word nonlocal.
  
 Basic functions
  
 A small difference between Python 2 and Python 3 is that when using the type() function, 
 where Python 3 displays the word class, Python 2 displays the word type. The reason is that 
 in Python 3, all types are actually implemented as classes.
  
 The format() function was implemented in later versions of Python 2, but did not exist in the 
 earlier versions. Instead, it supported a style of formatting, using “percentage-codes,”similar 
 to what is used in languages such as C++. This was directly implemented in the",NA
Appendix C,NA,NA
pcinput.py,"In many of the exercises in this book, it is useful to have a function available that accepts 
 inputs of a certain type. I created a module called pcinput which contains a number of such 
 functions. During many of the exercises in this book, I assume that you have that module 
 available. To get it, download it from http://www.spronck.net/pythonbook, or copy the code 
 below to a file called “pcinput.py,” and make sure that it is located in same folder where you 
 keep the files with your own code.
  
 Note that these functions are rather ugly as they print error messages if something is wrong. 
 However, nicer functions would be more difficult to use (you would have to know about 
 exceptions, which are not covered until Chapter 17). For the purpose of learning to code 
 Python, they work fine.
  
 Each of the functions asks the user to supply a value of a certain type (a float, an integer, a 
 string, or a capital letter), and returns that value. You can call each of the functions with a 
 string as argument, that will be used as prompt.
  
 pcinput.py
  
 def getFloat( prompt ): 
  
  
 while True: 
  
  
  
 try: 
  
  
  
   
 num = float( input( prompt ) ) 
  
  
  
  
 except ValueError: 
  
  
  
   
 print(
  ""That is not a number -- please try again""
  ) 
   
  
  
  
 continue 
  
  
  
  
 return num
  
 def getInteger( prompt ): 
  
  
 while True: 
  
  
  
 try: 
  
  
  
   
 num = int( input( prompt ) ) 
  
  
  
  
 except ValueError: 
  
  
  
   
 print(
  ""That is not an integer -- please try again""
  ) 
  
  
  
  
  
 continue 
  
  
  
  
 return num",NA
Appendix D,NA,NA
pcmaze.py,"In Chapter 9 an example of searching a maze is presented. In that example a module pcmaze 
 is used, that I wrote for this book. The module contains a specific maze, and functions to 
 access features of the maze. To create the module, download it from http://www.spronck. 
 net/pythonbook, or copy the code below to a file called “pcmaze.py,” and make sure that it is 
 located in same folder where you keep the files with your own code.
  
 pcmaze.py
  
 def connected( x, y ): 
  
  
 if x > y: 
  
  
  
  
 return connected( y, x ) 
  
  
 if (x,y) in ((1,5) ,(2,3),(3,7),(4,8),(5,6),(5,9),(6,7), 
  
  
 (8,12) ,(9,10) 
 ,(9,13) ,(10,11) ,(10,14) ,(11,12) ,(11,15),
  
  
 (15,16)): 
  
  
  
 return True 
  
 return False
  
 def entrance(): 
  
  
 return 1
  
 def exit(): 
  
  
 return 16",NA
Appendix E,NA,NA
Test Text Files,"In Chapter 16 several small text files are used to demonstrate functionalities. Moreover, in 
 Chapter 26 I use a CSV file as demonstration. You can download these files either from 
 http://www.spronck.net/pythonbook, or create them yourself. The contents of these files 
 are given below: just create them with any text editor (you can even do that with IDLE), 
 saving them under the name that is given as title. The first one is a small excerpt from 
 Shakespeare’s
  Romeo and Juliet
 , the second is a traditional English tongue twister, and the 
 third one is taken from Lewis Carroll’s
  Through the Looking Glass
 . The last one is an example 
 CSV file that I built.",NA
pc_rose.txt ,"'Tis but thy name that is my enemy.
  
 What's Montague? it is nor hand, nor foot, 
  
 Nor arm, nor face, nor any other part 
  
 What's in a name? That which we call a rose 
  
 So Romeo would, were he not Romeo call'd, 
  
 Retain that dear perfection which he owes 
  
 Without that title. Romeo, doff thy name; 
  
 And for that name, which is no part of thee, 
  
 Take all myself.",NA
pc_woodchuck.txt,"How much wood would a woodchuck chuck 
  
 If a woodchuck could chuck wood?
  
 He would chuck, he would, as much as he could, And 
 chuck as much as a woodchuck would 
  
 If a woodchuck could chuck wood.",NA
pc_jabberwocky.txt,"JABBERWOCKY 
  
 'Twas brillig, and the slithy toves 
  
 Did gyre and gimble in the wabe; 
  
 All mimsy were the borogoves, 
  
 And the mome raths outgrabe.
  
 'Beware the Jabberwock, my son!
  
 The jaws that bite, the claws that catch!
  
 The frumious Bandersnatch!' 
  
 Beware the Jubjub bird, and shun
  
 He took his vorpal sword in hand: 
  
 Long time the manxome foe he sought--
  
 So rested he by the Tumtum tree, 
  
 And stood awhile in thought.
  
 And as in uffish thought he stood, 
  
 The Jabberwock, with eyes of flame, 
  
 Came whiffling through the tulgey wood, 
  
 And burbled as it came!
  
 One, two! One, two! And through and through 
  
 The vorpal blade went snicker-snack! 
  
 He left it dead, and with its head 
  
 He went galumphing back.
  
 'And hast thou slain the Jabberwock?
  
 O frabjous day! Callooh! Callay!' 
  
 He chortled in his joy.
  
 'Twas brillig, and the slithy toves 
  
 Did gyre and gimble in the wabe; 
  
 All mimsy were the borogoves, 
  
 And the mome raths outgrabe.",NA
pc_inventory.csv,"ID,CATEGORY,NAME,STOCK,UNITPRICE 
  
 1,Fruit,apple,1000,0.87 
  
 2,Fruit,banana,2500,0.34 
  
 3,Fruit,cherry,11225,0.07 
  
 4,Fruit,durian,0,5.52 
  
 5,Cheese,Roquefort,46,12.23 
  
 6,Cheese,Blue Stilton,1,19.88 
  
 7,Cheese,Gouda,7,11.99",NA
Appendix F,NA,NA
Answers to Exercises,"This appendix provides answers to most of the exercises. They are also available in file 
 format from http://www.spronck.net/pythonbook.
  
 Note that it is useless to look up answers to exercises if you have not spent a significant 
 amount of time trying to solve the exercises. You can only learn programming by doing. Only 
 use the answers to compare them with your own, completed solutions, or as a final resort 
 should you have no idea how to solve a problem. However, if you cannot solve a problem, it 
 is usually better to return to an earlier part of the book that contains information that you 
 evidently did not understand or forgot about.
  
 Note that very often, the answers given here are only one of many possible ways to solve a 
 problem. If you have found a different way to solve a problem, that might be just fine, though 
 make sure you test your answer extensively to ensure that it is correct.
  
 Moreover, while the answers given here are usually efficient, efficiency is not the first goal 
 when writing code. You should first make sure that your code solves the problem at hand, 
 before you look into making the code more efficient. Readability and maintainability are far 
 more important than efficiency.",NA
Chapter 1,"Answer 1.1
  A straightforward sorting procedure that first identifies the highest card, then 
 the next highest card, then the lowest-but-one, and then the lowest card, needs six compar-
 isons. You could perform it, for instance, as follows:
  
 Number the cards from 1 to 4, left to right. The number is tied to the spot where the card is, 
 i.e., when you switch two cards, they exchange numbers. Compare cards 1 and 2, and switch 
 them if 1 is higher than 2. Compare cards 2 and 3, and switch them if 2 is higher than 3. 
 Compare cards 3 and 4, and switch them if 3 is higher than 4. Now the highest card will be 
 the number 4. Then, compare cards 1 and 2 again, and switch them if 1 is higher than 2. 
 Compare cards 2 and 3 again, and switch them if 2 is higher than 3. Now the next-highest 
 card is number 3. Finally, compare cards 1 and 2 and switch them if 1 is higher than 2. You 
 have now sorted the four cards, with six comparisons.",NA
Chapter 2,"Answer 2.1
  You now have Python running on your computer. Congratulations!",NA
Chapter 3,"Answer 3.1
  
 answer0301.py
  
 print( 60 * (0.6 * 24.95 + 0.75) + (3 - 0.75) )
  
  
 Answer
  
 3.2
  
 Each
  
 of
  
 the
  
 lines
  
 should
  
 be
  
 either
  
 print(
  ""A message""
  )
  
 or
  
 print(
  'A message'
  ). The error in the first line is that it ends in a period. That pe-riod should 
 be removed. The error in the second line is that it contains something that is supposed to be 
 a string, but starts with a double quote while it ends with a single quote. Either the double 
 quote should become a single quote, or the single quote should become a double quote. The 
 third line is actually syntactically correct, but probably it was meant to be print(
  'A message'
  
 ), so the f"" should be removed.
  
 Answer 3.3
  
 answer0303.py
  
 print( 1/0 )
  
 Answer 3.4
  The problem is that there is one closing parenthesis missing in the first line of 
 code. I actually deleted the closing parenthesis that should be right of the 6, but you cannot 
 know that; you can only count the parentheses in the first statement and see that there is 
 one less closing parenthesis than there are opening parentheses.
  
 The confusing part of this error message is that it says that the error is in the second line of 
 code. The second line of the code, however, is fine. The reason is that since Python has not 
 seen the last required closing parenthesis on the first line, it starts looking for it on the 
 second line. And while doing that, it notices that something is going wrong, and it reports the 
 error. Basically, while trying to process the second line, Python finds that it cannot do that, 
 so it indicates that there is an error with the second line.
  
 You will occasionally encounter this in your own code: an error is reported for a certain line 
 of code, but the error is actually made in one of the previous lines. Such errors often 
 encompass the absence of a required parenthesis or single or double quote. Keep this in 
 mind.
  
 Answer 3.5
  
 answer0305.py
  
 print( str( (14 + 535) % 24 ) +
  "".00""
  )",NA
Chapter 4 ,"Answer 4.1 
  
  
 answer0401.py
  
 # This program calculates the average of three variables , # var1, var2, and var3 
  
 var1 = 12.83 
  
 var2 = 99.99 
  
 var3 = 0.12 
  
 average = (var1 + var2 + var3) / 3
  # Calculate the average 
 print( average )
  # May look 
 a bit ugly, but we might make this # look a bit better when we have learned about 
 formatting
  
 Answer 4.2 
  
  
 answer0402.py
  
 pi = 3.14159 
  
 radius = 12 
  
 print(
  ""The surface area of a circle with radius""
 , 
  
 radius ,
  ""is""
 , pi * 
 radius * radius )
  
 Answer 4.3 
  
  
 answer0403.py
  
 CENTS_IN_DOLLAR = 100 
  
 CENTS_IN_QUARTER = 25 
  
 CENTS_IN_DIME = 10 
  
 CENTS_IN_NICKEL = 5
  
 amount = 1156 
  
 cents = amount
  
 dollars = int( cents / CENTS_IN_DOLLAR ) cents -= dollars * 
 CENTS_IN_DOLLAR 
  
 quarters = int( cents / CENTS_IN_QUARTER ) cents -= 
 quarters * CENTS_IN_QUARTER 
  
 dimes = int( cents / CENTS_IN_DIME ) 
  
 cents -= dimes * CENTS_IN_DIME 
  
 nickels = int( cents / CENTS_IN_NICKEL ) cents -= nickels * 
 CENTS_IN_NICKEL 
  
 cents = int( cents )
  
 print( amount / CENTS_IN_DOLLAR ,
  ""consists of:""
  ) print(
  ""Dollars:""
 , 
 dollars ) 
  
 print(
  ""Quarters:""
 , quarters ) 
  
 print(
  ""Dimes:""
 , dimes ) 
  
 print(
  ""Nickels:""
 , nickels )",NA
Chapter 5,"Answer 5.1
  
 answer0501.py
  
 s = input(
  ""Enter a string: ""
  ) 
  
 print(
  ""You entered""
 , len( s ),
  ""characters""
  )
  
 Answer 5.2
  
 answer0502.py
  
 from pcinput import getFloat 
  
 from math import sqrt
  
 side1 = getFloat(
  ""Please enter the length of the first side: ""
  ) side2 = getFloat(
  ""Please enter 
 the length of the second side: ""
 ) side3 = sqrt( side1 * side1 + side2 * side2 ) 
  
 print(
  ""The length of the diagonal is {:.3f}.""
 .format( side3 ) )
  
 Answer 5.3
  
 answer0503.py
  
 from pcinput import getFloat
  
 num1 = getFloat(
  ""Please enter number 1: ""
  ) num2 = 
 getFloat(
  ""Please enter number 2: ""
  ) num3 = getFloat(
  
 ""Please enter number 3: ""
  )
  
 print(
  ""The largest is""
 , max( num1, num2, num3 ) ) 
  
 print(
  ""The smallest is""
 , min( num1, num2, num3 ) ) 
  
 print(
  ""The average is""
 , round( (num1 + num2 + num3)/3, 2 ) )",NA
Chapter 6 ,"Answer 6.1 
  
  
 answer0601.py
  
 from pcinput import getFloat
  
 grade = getFloat(
  ""Please enter a grade: ""
  ) 
  
 check = int( grade * 10 ) 
  
 if grade < 0 or grade > 10: 
  
  
 print(
  ""Grades have to be in the range 0 to 10.""
  ) 
  
 elif check%5 != 0 or check != grade *10: 
  
  
 print(
  ""Grades should be rounded to the nearest half point.""
 ) elif grade >= 8.5: 
  
  
 print(
  ""Grade A""
  ) 
  
 elif grade >= 7.5: 
  
  
 print(
  ""Grade B""
  ) 
  
 elif grade >= 6.5: 
  
  
 print(
  ""Grade C""
  ) 
  
 elif grade >= 5.5: 
  
  
 print(
  ""Grade D""
  ) 
  
 else: 
  
  
 print(
  ""Grade F""
  )",NA
Chapter 7 ,"Answer 7.1 
  
  
 answer0701.py
  
 from pcinput import getInteger
  
 num = getInteger(
  ""Give a number: ""
  ) i = 1 
  
 while i <= 10: 
  
  
  
 print( i,
  ""*""
 , num,
  ""=""
 , i* num ) 
  
 i += 1
  
 Answer 7.2 
  
  
 answer0702.py
  
 from pcinput import getInteger
  
 num = getInteger(
  ""Give a number: ""
  ) for i in range( 
 1, 11 ): 
  
  
 print( i,
  ""*""
 , num,
  ""=""
 , i* num )
  
 Answer 7.3 
  
  
 answer0703.py
  
 from pcinput import getInteger
  
 TOTAL = 10 
  
 largest = 0 
  
 smallest = 0 
  
 div3 = 0
  
 for i in range( TOTAL ): 
  
  
  
 num = getInteger(
  ""Please enter number ""
 +str( i+1 )+
 "": ""
  ) if num%3 == 0: 
  
  
   
 div3 += 1 
  
 if i == 0: 
  
  
   
  
 smallest = num 
  
  
   
  
 largest = num 
  
  
   
  
 continue",NA
Chapter 8,"Answer 8.1
  
 answer0801.py
  
 from pcinput import getInteger
  
 # multiplicationtable gets an integer as parameter. # It prints the 
 multiplication table for that integer.
  
 def multiplicationtable( n ): 
  
  
 i = 1 
  
  
  
 while i <= 10: 
  
  
   
  
 print( i,
  ""*""
 , n,
  ""=""
 , i*n ) 
  
  
 i 
 += 1
  
 num = getInteger(
  ""Give a number: ""
  ) 
 multiplicationtable( num )",NA
Chapter 9,"Answer 9.1
  
 answer0901.py
  
 def fib( n ): 
  
 if n <= 2: 
  
  
   
 return 1 
  
  
  
 return fib( n-1 ) + fib( n-2 )
  
 print( fib( 20 ) )
  
 Answer 9.2
  
 answer0902.py
  
 def fib( n, depth ): 
  
  
   
 indent = 6 * depth *
  "" "" 
  
  
  
 print(
  ""{}fib({})""
 .format( indent , n ) ) 
  
 if n <= 2: 
  
  
    
 print(
  ""{}return {}""
 .format( indent , 1 ) ) 
  
  
  
   
 return 1 
  
  
  
 value = fib( n-1, depth+1 ) + fib( n-2, depth+1 ) 
  
  
 print(
  
 ""{}return {}""
 .format( indent , value ) ) 
  
  
  
 return value
  
 print( fib( 5, 0 ) )
  
 Answer 9.3
  Since the Fibonacci sequence can just as easily be implemented as an iterative 
 function (you did this in the previous chapter), doing it as a recursive function is not a good 
 idea. The reasons are the same as for the factorial, explained in the chapter. There is the 
 additional reason that the recursive definition basically calculates all terms of the sequence 
 multiple times, as you can see when you look at the output for the second exercise, while 
 calculating them just once suffices.
  
 Answer 9.4
  
 answer0904.py
  
 def gcd( m, n ): 
  
 if m % n == 0: 
  
  
   
 return n 
  
  
  
 return gcd( n, m%n )
  
 print( gcd( 7*5*13 , 2*3*7*11 ) )
  
 Interestingly, while the definition of the algorithm distinguishes the smallest and the largest 
 number, you actually do not have to make that distinction in your code. If you call the 
 function with the two exchanged, it just leads to one extra recursive call.",NA
Chapter 10,"Answer 10.1
  
 answer1001.py
  
 text =
  """"""And Saint Attila raised the hand grenade up on high, saying, ""O Lord, bless this 
 thy hand grenade , that with it thou mayst blow thine enemies to tiny bits, in thy mercy."" 
 And the Lord did grin. And the people did feast upon the lambs, and sloths, and carp, and 
 anchovies , and orangutans , and 
  
 breakfast cereals , and fruit bats, and large chu...""""""",NA
Chapter 11,"Answer 11.1
  I created display_complex() to nicely format complex numbers (it will not 
 show a real part which is zero, or a 1 in front of the
  i
 , or clump a plus and minus together). 
 Creating such a function was not a requirement.
  
 answer1101.py
  
 def add_complex( c1, c2 ): 
  
  
 return (c1[0] + c2[0], c1[1] + c2[1])
  
 def display_complex( c ): 
  
  
 s =
  ""("" 
  
  
 if c[1] == 0: 
  
  
    
   
 return str( c[0] ) 
  
  
  
 elif c[0] != 0: 
  
  
    
 s += str( c[0] ) 
  
  
    
  
 if c[1] > 0: 
  
  
    
    
 s +=
  ""+"" 
  
  
 if c[1] != 1: 
  
  
    
  
 if c[1] == -1: 
  
  
    
    
 s +=
  ""-"" 
  
  
    
  
 else: 
  
  
    
    
 s += str( c[1] ) 
  
  
 s +=
  ""i)"" 
  
  
   
 return s
  
 num1 = (2,1) 
  
 num2 = (0,2) 
  
 print( display_complex( num1 ),
  ""+""
 , display_complex( num2 ), 
  
 ""=""
 , 
 display_complex( add_complex( num1, num2 ) ) )
  
 Answer 11.2
  I used a less nice version of display_complex() for this solution.",NA
Chapter 12,"Answer 12.1
  
 answer1201.py
  
 from random import choice 
  
 answers = [
  ""It is certain""
 ,
  ""It is decidedly so""
 ,
  ""Without a \ doubt""
 ,
  ""Yes, definitely""
 ,
  ""You 
 may rely on it""
 ,
  ""As I see it, \ yes""
 ,
  ""Most likely""
 ,
  ""Outlook good""
 ,
  ""Yes""
 ,
  ""Signs point to yes""
 , 
 ""Reply hazy try again""
 ,
  ""Ask again later""
 ,
  ""Better not tell you \ now""
 ,
  ""Cannot predict now""
 ,
  
 ""Concentrate and ask again""
 ,
  ""Don ' t \ count on it""
 ,
  ""My reply is no""
 ,
  ""My sources say no""
 ,
  
 ""Outlook \ not so good""
 ,
  ""Very doubtful""
  ] 
  
 input(
  ""Ask the magic 8-ball your question: ""
  ) 
  
 print(
  ""The magic 8-ball says:""
 , choice( answers ) )",NA
Chapter 13,"Answer 13.1
  
 answer1301.py
  
 text =
  """"""How much wood would a woodchuck chuck If a 
 woodchuck could chuck wood?
  
 He would chuck, he would, as much as he could, And chuck as 
 much as a woodchuck would 
  
 If a woodchuck could chuck wood.""""""
  
 def clean( s ): 
  
  
  
 news =
  """" 
  
  
 s = s.lower() 
  
  
  
 for c in s: 
  
  
    
 if c >=
  ""a""
  and c <=
  ""z""
 : 
  
  
    
  
 news += c 
  
  
    
 else: 
  
  
    
  
 news +=
  "" "" 
  
  
   
 return news
  
 worddict = {} 
  
 for word in clean( text ).split(): 
  
  
 worddict[word] = worddict.get( word, 0 ) + 1
  
 keylist = list( worddict.keys() ) 
  
 keylist.sort() 
  
 for key in keylist: 
  
  
 print(
  ""{}: {}""
 .format( key, worddict[key] ) )
  
 Answer 13.2
  
 answer1302.py
  
 movies = { 
  
 ""Monty Python and the Holy Grail""
 : 
  
  
 [ 9, 10, 9.5, 8.5, 3, 7.5,8 ], 
  
  
 ""Monty Python ' s Life of Brian""
 : 
  
  
 [ 10, 10, 0, 9, 1, 8, 7.5, 8, 6, 9 ], 
  
  
 ""Monty Python ' s Meaning of Life""
 : 
  
  
 [ 7, 6, 5 ], 
  
  
 ""And Now For Something Completely Different""
 : 
  
 [ 6, 5, 6, 6 ] }",NA
Chapter 14,"Answer 14.1
  
 answer1401.py
  
 allthings = {
 ""Socrates""
 ,
  ""Plato""
 ,
  ""Eratosthenes""
 ,
  ""Zeus""
 ,
  ""Hera""
 , 
  
 ""Athens""
 ,
  ""Acropolis""
 ,
  
 ""Cat""
 ,
  ""Dog""
 }
  
 men = {
 ""Socrates""
 ,
  ""Plato""
 ,
  ""Eratosthenes""
 } 
  
 mortalthings = {
 ""Socrates""
 ,
 ""Plato""
 ,
 ""Eratosthenes""
 ,
 ""Cat""
 ,
 ""Dog""
 }
  
 print( men.issubset( mortalthings ) )
  # (a) 
  
 print(
  ""Socrates""
  in men )
  # (b) 
  
 print(
  ""Socrates""
  in mortalthings )
  # (c) 
  
 print( len( mortalthings.difference( men ) ) > 0 )
  # (d) 
 print( len( allthings.difference( 
 mortalthings ) ) > 0 )
  # (e)
  
 Answer 14.2
  
 answer1402.py
  
 set3 = set( [3*x for x in range( 1, int( 1001/3 )+1 )] ) set7 = set( [7*x for x in 
 range( 1, int( 1001/7 )+1 )] ) set11 = set( [11*x for x in range( 1, int( 1001/11 )+1 
 )] )
  
 seta = set3 & set7 & set11
  
 setb = (set3 & set7) - set11
  
 setc = set( range( 1, 1001 ) ) - set3 - set7 - set11",NA
Chapter 15 ,"Answer 15.1 
  
  
 answer1501.py
  
 from os import listdir , getcwd 
  
 flist = listdir(
  "".""
  ) 
  
 for name in flist: 
  
  
 print( getcwd() +
  ""/""
  + name )",NA
Chapter 16 ,"Answer 16.1
  The code below is mostly a copy of some code you had to write in Chapter 13. 
 The only difference is that the text here is not provided as a string, but read from a file.
  
 answer1601.py
  
 def clean( s ): 
  
  
  
 news =
  """" 
  
  
 s = s.lower() 
  
  
  
 for c in s: 
  
  
    
 if c >=
  ""a""
  and c <=
  ""z""
 : 
  
  
    
  
 news += c 
  
  
    
 else: 
  
  
    
  
 news +=
  "" "" 
  
  
   
 return news
  
 fp = open(
  ""pc_woodchuck.txt""
  ) 
  
 text = fp.read() 
  
 fp.close()
  
 wdict = {} 
  
 for word in clean( text ).split(): 
  
  
 wdict[word] = wdict.get( word, 0 ) + 1
  
 keylist = list( wdict.keys() ) 
  
 keylist.sort() 
  
 for key in keylist: 
  
  
 print(
  ""{}: {}""
 .format( key, wdict[key] ) )
  
 Answer 16.2 
  
  
 answer1602.py
  
 def clean( s ): 
  
 news =
  """" 
  
 s = s.lower() 
  
 for c in s:",NA
Chapter 17,"Answer 17.1
  The code can generate a ValueError when you enter something that is not an 
 integer, an IndexError when you give an index outside the range {-5,4}, a ZeroDivisionError 
 when you enter index 2, and a TypeError when you enter index 3. The code below does the 
 most straightforward handling, but you can also build a loop around the code so that the 
 user gets asked for new inputs until it works.
  
 answer1701.py
  
 numlist = [ 100, 101, 0,
  ""103""
 , 104 ] 
  
 try: 
  
  
 i1 = int( input(
  ""Give an index: ""
  ) ) 
  
  
  
 print(
  ""100 /""
 , numlist[i1],
  ""=""
 , 100 / numlist[i1] ) except ValueError: 
  
  
  
 print(
  ""You did not enter an integer""
  ) 
  
 except IndexError: 
  
  
  
 print(
  ""You should specify an index between -5 and 4""
  ) except 
 ZeroDivisionError: 
  
  
  
 print(
  ""It looks like the list contains a zero""
  ) 
  
 except TypeError: 
  
  
  
 print(
  ""it looks like there is a non-numeric item""
  ) except: 
  
  
  
 print(
  ""Something unexpected happened""
  ) 
  
  
  
 raise",NA
Chapter 18,"Answer 18.1
  For this program I created a copy of “pc_rose.txt” and called 
 it“pc_rose_copy.txt.” To demonstrate what happens, I display the contents of the file be-fore 
 and after the encryption process.
  
 answer1801.py
  
 FILENAME =
  ""pc_rose_copy.txt"" 
  
 def display_contents( filename ): 
  
  
 fp = open( filename ,
  ""rb""
  )",NA
Chapter 19 ,"Answer 19.1 
  
  
 answer1901.py
  
 s =
  ""Hello, world!"" 
  
 mask = (1<<5) | (1<<3) | (1<<1) 
  
 # 00101010
  
 code =
  """" 
  
 for c in s: 
  
  
 code += chr(ord(c)^mask) 
  
 print( code )
  
 decode =
  """" 
  
 for c in code: 
  
  
 decode += chr(ord(c)^mask) 
  
 print( decode )",NA
Chapter 20 ,"Answer 20.1 
  
  
 answer2001.py
  
 from copy import copy 
  
 class Point: 
  
  
 def __init__( self, x=0.0, y=0.0 ):",NA
Chapter 21 ,"Answer 21.1 
  
  
 answer2101.py
  
 SUITS = [
 ""Hearts""
 ,
 ""Spades""
 ,
 ""Clubs""
 ,
 ""Diamonds""
 ] RANKS = 
 [
 ""2""
 ,
 ""3""
 ,
 ""4""
 ,
 ""5""
 ,
 ""6""
 ,
 ""7""
 ,
 ""8""
 ,
 ""9""
 ,
 ""10""
 , 
 ""Jack""
 ,
 ""Queen""
 ,
 ""King""
 ,
 ""Ace""
 ]
  
 class Card: 
  
  
 def __init__( self, suit, rank ): 
  
  
  
 self.suit = suit
  # used as index in the SUITS list 
   
  
 self.rank = rank
  # used as index in the RANKS list 
  
 def __repr__( self ): 
  
  
  
  
 return
  ""({},{})""
 .format( self.suit, self.rank ) 
  
 def __str__( self ): 
  
  
  
  
 return
  ""{} of {}""
 .format( RANKS[self.rank], \ 
  
  
  
  
  
 SUITS[self.suit] ) 
  
  
 def __eq__( self, c ): 
  
  
  
 if isinstance( c, Card ): 
  
  
  
   
 return self.rank == c.rank 
  
  
  
  
 return NotImplemented 
  
  
 def __gt__( self, c ): 
  
  
  
 if isinstance( c, Card ): 
  
  
  
   
 return self.rank > c.rank 
  
  
  
  
 return NotImplemented 
  
  
 def __ge__( self, c ): 
  
  
  
 if isinstance( c, Card ): 
  
  
  
   
 return self.rank >= c.rank 
  
  
  
  
 return NotImplemented
  
 c5 = Card( 2, 3 ) 
  
 d5 = Card( 3, 3 ) 
  
 sk = Card( 1, 11 ) 
  
 print(
  ""{}, {}, {}""
 .format( c5, d5, sk ) ) print( c5 == d5 ) 
  
 print( c5 == sk ) 
  
 print( c5 > sk ) 
  
 print( c5 >= sk )",NA
Chapter 22 ,"Answer 22.1 
  
  
 answer2201.py
  
 class Rectangle: 
  
  
 def __init__( self, x, y, w, h ): 
  
  
  
 self.x, self.y, self.w, self.h = x, y, w, h 
  
  
 def __repr__( self ): 
  
  
  
  
 return
  ""[({},{}),w={},h={}]""
 .format( self.x, self.y, 
  
  
  
  
 self.w, self.h ) 
  
  
 def area( self ): 
  
  
  
  
 return self.w * self.h 
  
  
 def circumference( self ): 
  
  
  
  
 return 2*( self.w + self.h)
  
 class Square( Rectangle ): 
  
  
 def __init__( self, x, y, w ): 
  
  
  
 super().__init__( x, y, w, w )
  
 s = Square( 1, 1, 4 ) 
  
 print( s, s.area(), s.circumference() )
  
 Answer 22.2 
  
  
 answer2202.py
  
 from math import pi 
  
 class Shape: 
  
  
 def area( self ):",NA
Chapter 23 ,"Answer 23.1 
  
  
 answer2301.py
  
 from pcinput import getInteger
  
 class NotDividableBy: 
  
  
 def __init__( self ): 
  
  
  
  
 self.seq = list( range( 1, 101 ) ) 
  
 def 
 __iter__( self ): 
  
  
  
   
 return self 
  
  
 def __next__( self ): 
  
  
  
  
 if len( self.seq ) > 0: 
  
  
  
    
   
 return self.seq.pop(0) 
  
  
  
  
 raise StopIteration() 
  
  
 def process( self, num ): 
  
  
  
 i = len( self.seq )-1 
  
  
  
  
 while i >= 0: 
  
  
  
    
  
 if self.seq[i]%num == 0: 
  
  
  
    
    
 del self.seq[i] 
  
  
  
    
 i -= 1",NA
Chapter 24,"Answer 24.1
  
 answer2401.py
  
 import sys
  
 total = 0 
  
 for i in sys.argv[1:]: 
  
  
 try: 
  
  
   
 total += float( sys.argv[i] ) 
  
  
  
 except TypeError: 
  
  
   
 print( sys.argv[i],
  ""is not a number.""
  ) 
   
  
 sys.exit(1)
  
 print(
  ""The arguments add up to""
 , total )",NA
Chapter 25,"Answer 25.1
  
 answer2501.py
  
 import re
  
 sentence =
  ""The price of a 2-room apartment in Manhattan \ starts at 1 million dollars 
 , and may actually be the 10-fold \ of that on 42nd Street.""
  
 pword = re.compile(
  r""[A-Za-z]+""
  ) wordlist = 
 pword.findall( sentence ) for word in wordlist: 
  
  
 print( word )
  
 Answer 25.2
  
 answer2502.py
  
 import re
  
 sentence =
  ""The word ether can be found in my thesaurus \ using the archaic 
 spelling 
  
 ' aether '. ""
  
 pthe = re.compile(
  r""\bthe\b""
 , re.I ) thelist = 
 pthe.findall( sentence ) print( len( thelist ) )",NA
Chapter 26 ,"Answer 26.1 
  
  
 answer2601.py
  
 from csv import reader , writer
  
 fp = open(
  ""pc_inventory.csv""
 , newline=
  ' '
  ) 
  
 fpo = open(
  ""pc_writetest.csv""
 ,
  ""w""
 , newline=
  ' '
  ) 
  
 csvreader = reader( fp ) 
  
 csvwriter = writer( fpo, delimiter=
  ' '
  , quotechar=
 "" ' ""
  ) for line in csvreader: 
  
 csvwriter.writerow( line ) 
  
 fp.close() 
  
 fpo.close()
  
 fp = open(
  ""pc_writetest.csv""
  ) 
  
 print( fp.read() ) 
  
 fp.close()
  
 If you did it correctly, you notice the quotes around “Blue Stilton,” which are there because it 
 contains a space, which is the delimiter.",NA
Chapter 27 ,"Answer 27.1 
  
  
 answer2701.py
  
 from collections import Counter 
  
 sentence =
  ""Your mother was a hamster and \ your father 
 smelled of elderberries."" 
  
 sentence2 =
  """" 
  
 for c in sentence.lower():
  
 if c >=
  
 ' a '
  and c <=
  
 ' z '
  :
  
  
  
 sentence2 += c 
  
 clist = Counter( sentence2 ).most_common( 5 ) for c in clist: 
  
  
 print(
  ""{}: {}""
 .format( c[0], c[1] ) )
  
 Answer 27.2 
  
  
 answer2702.py
  
 from collections import Counter 
  
 from pcinput import getInteger 
  
 from statistics import mean, median from sys 
 import exit",NA
Index,"__abs__(), 247 
  
 __add__(), 245 
  
 __and__(), 245 
  
 __bool__(), 245 
  
 __bytes__(), 247 
  
 __contains__(), 249 
 __delitem__(), 249 
 __eq__(), 243 
  
 __float__(), 247 
  
 __floordiv__(), 245 
 __ge__(), 243 
  
 __getitem__(), 249 
 __gt__(), 243 
  
 __iadd__(), 247 
  
 __iand__(), 247 
  
 __ifloordiv__(), 247 
 __ilshift__(), 247 
  
 __imod__(), 247 
  
 __imul__(), 247 
  
 __init__(), 231 
  
 __int__(), 247
  
 __pow__(), 245 
  
 __radd__(), 246 
  
 __rand__(), 246 
  
 __repr__(), 233 
  
 __rfloordiv__(), 246 
  
 __rlshift__(), 246 
  
 __rmod__(), 246 
  
 __rmul__(), 246 
  
 __ror__(), 246 
  
 __round__(), 247 
  
 __rpow__(), 246 
  
 __rrshift__(), 246 
  
 __rshift__(), 245 
  
 __rsub__(), 246 
  
 __rtruediv__(), 246 
  
 __rxor__(), 246 
  
 __setitem__(), 249 
  
 __str__(), 234 
  
 __sub__(), 245 
  
 __truediv__(), 245 
  
 __xor__(), 245
  
 __invert__(), 247 
  
 __ior__(), 247 abs(), 39 
  
 __ipow__(), 247 abstract class, 256 
  
 __irshift__(), 247 add(), 176 
  
 __isub__(), 247 
  
 addition, 18 __iter__(), 250, 262 algorithm, 25 
  
 __itruediv__(), 247 algorithm design, 83 __ixor__(), 247 alias, 155, 242 
  
 __le__(), 243 
  
 and, 51 __len__(), 245, 249 anonymous function, 113 __lshift__(), 245 
 append(), 150, 295 __lt__(), 243 appendleft(), 295 
  
 __missing__(), 249 
  
 argparse, 274 __mod__(), 245 args, 205 
  
 __mul__(), 245 argument, 36, 95 
  
 __ne__(), 243 argv, 272 
  
 __neg__(), 247 
  
 art, 5 __next__(), 262 ASCII, 136, 220 
  
 __or__(), 245 ascii, 198 
  
 __pos__(), 247 assignment, 25, 50",NA
