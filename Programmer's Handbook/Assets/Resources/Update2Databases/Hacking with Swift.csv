Larger Text,Smaller Text,Symbol
PROJECTS 1-39,NA,NA
Contents,NA,NA
About this Book ,NA,NA
11,NA,NA
Introduction: Swift for Complete Beginners ,NA,NA
15 ,"How to install Xcode and create a playground 
  
  
 Variables and constants 
  
  
 Types of Data 
  
  
 Operators 
  
  
 String interpolation 
  
  
 Arrays 
  
  
 Dictionaries 
  
  
 Conditional statements 
  
  
 Loops 
  
  
 Switch case 
  
  
 Functions 
  
  
 Optionals 
  
  
 Optional chaining 
  
  
 Enumerations 
  
  
 Structs 
  
  
 Classes 
  
  
 Properties 
  
  
 Static properties and methods 
  
  
 Access control 
  
  
 Polymorphism and type casting 
  
  
 Closures 
  
  
 Wrap up",NA
Project 1: Storm Viewer ,NA,NA
96 ,"Setting up 
  
  
 Deleting skeleton code 
  
  
 Listing our images 
  
  
 Introducing Interface Builder 
  
  
 Sending new data 
  
  
 Final tweaks 
  
  
 Wrap up",NA
Project 2: Guess the Flag ,NA,NA
135 ,"Setting up
  
 www.hackingwithswift.com 
  
 2",NA
Project 3: Social Media ,NA,NA
166 ,"About technique projects 
  
  
 Activity View Controllers 
  
  
 Twitter and Facebook 
  
  
 Wrap up",NA
Project 4: Easy Browser ,NA,NA
176 ,"Setting up 
  
  
 Creating a simple browser 
  
  
 Choosing a website 
  
  
 Monitoring page loads 
  
  
 Refactoring for the win 
  
  
 Wrap up",NA
Project 5: Word Scramble ,NA,NA
199 ,"Setting up 
  
  
 Reading from disk 
  
  
 Pick a word, any word 
  
  
 Prepare for submission 
  
  
 Returning values 
  
  
 Or else what?
  
 Wrap up",NA
Project 6: Auto Layout ,NA,NA
229 ,"Setting up 
  
  
 Advanced Auto Layout 
  
  
 Auto Layout in code 
  
  
 Sizes, metrics and priorities 
  
  
 Wrap up",NA
Project 7: Whitehouse Petitions ,NA,NA
244 ,"Setting up 
  
  
 Creating the basic UI 
  
  
 Parsing JSON 
  
  
 Rendering a petition 
  
  
 Finishing touches 
  
  
 Wrap up
  
 www.hackingwithswift.com 
  
 3",NA
Project 8: 7 Swifty Words ,NA,NA
267 ,"Setting up 
  
  
 Buttons… buttons everywhere.
  
 Loading a level 
  
 It's play time!
  
 Property observers 
  
 Wrap up",NA
Project 9: Grand Central Dispatch ,NA,NA
285 ,"Setting up 
  
  
 Why is locking the UI bad?
  
 GCD 101 
  
 Back to the main thread 
  
 Wrap up",NA
Project 10: Names to Faces ,NA,NA
295 ,"Setting up 
  
  
 Designing UICollectionView cells 
  
  
 Data sources and delegates 
  
  
 Importing photos 
  
  
 Custom classes 
  
  
 Connecting up the people 
  
  
 Wrap up",NA
Project 11: Pachinko ,NA,NA
317 ,"Setting up 
  
  
 Falling boxes 
  
  
 Bouncing balls 
  
  
 Spinning slots 
  
  
 Collision detection 
  
  
 Scores on the board 
  
  
 Special effects 
  
  
 Wrap up",NA
Project 12: NSUserDefaults ,NA,NA
347 ,"Setting up 
  
  
 Reading and writing basics 
  
  
 Fixing Project 10 
  
  
 Wrap up
  
 www.hackingwithswift.com 
  
 4",NA
Project 13: Instafilter ,NA,NA
358 ,"Setting up 
  
  
 Designing the interface 
  
  
 Importing a picture 
  
  
 Applying filters 
  
  
 Saving to the photo library 
  
  
 Wrap up",NA
Project 14: Whack-a-Penguin ,NA,NA
376 ,"Setting up 
  
  
 Getting up and running 
  
  
 Penguin, show thyself 
  
  
 Whack to win 
  
  
 Wrap up",NA
Project 15: Animation ,NA,NA
398 ,"Setting up 
  
  
 Preparing for action 
  
  
 Switch, case, animate 
  
  
 Transform!
  
 Wrap up",NA
Project 16: JavaScript Injection ,NA,NA
412 ,"Setting up 
  
  
 Making a shell app 
  
  
 Adding an extension 
  
  
 What do you want to get? 
  
  
 Establishing communication 
  
  
 Hacking with JavaScript 
  
  
 Fixing the keyboard 
  
  
 Wrap up",NA
Project 17: Swifty Ninja ,NA,NA
434 ,"Setting up 
  
  
 Basics quick start 
  
  
 Shaping up for action 
  
  
 Enemy or bomb?
  
 Follow the sequence 
  
 Slice to win 
  
 Game over, man 
  
 Wrap up
  
 www.hackingwithswift.com 
  
 5",NA
Project 18: iAd and Debugging ,NA,NA
474 ,"Setting up 
  
  
 iAd in 10 minutes 
  
  
 Debugging in Xcode 
  
  
 Wrap up",NA
Project 19: Capital Cities ,NA,NA
486 ,"Setting up 
  
  
 Up and running with MapKit 
  
  
 Annotations and accessory views 
  
  
 Wrap up",NA
Project 20: Fireworks Night ,NA,NA
498 ,"Setting up 
  
  
 Ready... aim... fire!
  
 Swipe to select 
  
 Making things go bang 
  
 Wrap up",NA
Project 21: Local Notifications ,NA,NA
517 ,"Setting up 
  
  
 Scheduling notifications 
  
  
 Acting on responses 
  
  
 Wrap up",NA
Project 22: Detect-a-Beacon ,NA,NA
528 ,"Setting up 
  
  
 Requesting location 
  
  
 Hunting the beacon 
  
  
 Wrap up",NA
Project 23: Space Race ,NA,NA
540 ,"Setting up 
  
  
 Space: the final frontier 
  
  
 Bring on the enemies!
  
 Making contact 
  
 Wrap up",NA
Project 24: Swift Extensions,NA,NA
553,"6
  
 www.hackingwithswift.com",NA
Project 25: Selfie Share ,NA,NA
567 ,"Setting up 
  
  
 Importing photos again 
  
  
 Going peer to peer 
  
  
 Invitation only 
  
  
 Wrap up",NA
Project 26: Marble Maze ,NA,NA
584 ,"Setting up 
  
  
 Loading a level 
  
  
 Tilt to move 
  
  
 Contacting but not colliding 
  
  
 Wrap up",NA
Project 27: Core Graphics ,NA,NA
605 ,"Setting up 
  
  
 Creating the sandbox 
  
  
 Drawing into a context 
  
  
 Ellipses and checkerboards 
  
  
 Transforms and lines 
  
  
 Images and text 
  
  
 Wrap up",NA
Project 28: Secret Swift ,NA,NA
628 ,"Setting up 
  
  
 The basic text editor 
  
  
 Writing somewhere safe 
  
  
 Touch to activate 
  
  
 Wrap up",NA
Project 29: Exploding Monkeys ,NA,NA
642 ,"Setting up 
  
  
 Building the environment 
  
  
 Mixing UIKit and SpriteKit 
  
  
 Unleash the bananas!
  
 Destructible terrain
  
 www.hackingwithswift.com 
  
 7",NA
Project 30: Instruments ,NA,NA
673 ,"Setting up 
  
  
 What are we working with? 
  
  
 What can Instruments tell us?
  
 Fixing the bugs 
  
 Wrap up",NA
Project 31: Multibrowser ,NA,NA
687 ,"Setting up 
  
  
 UIStackView by example 
  
  
 UIStackView in Swift 2 
  
  
 Removing views from a UIStackView 
  
  
 iPad multitasking in iOS 9 
  
  
 Wrap up",NA
Project 32: SwiftSearcher ,NA,NA
708 ,"Setting up 
  
  
 Automatically resizing UITableViewCells with NSAttributedString and Dynamic Type 
  
 How to use SFSafariViewController to browse a web page 
  
  
 How to add Core Spotlight to index your app content 
  
  
 Wrap up",NA
Project 33: What's that Whistle? ,NA,NA
733 ,"Setting up 
  
  
 Recording from the microphone: AVAudioRecorder 
  
  
 Animating UIStackView subview layout 
  
  
 Writing to iCloud with CloudKit: CKRecord and CKAsset 
  
  
 A hands-on guide to the CloudKit dashboard 
  
  
 Reading from iCloud with CloudKit: CKQueryOperation and NSPredicate 
  
  
 Working with CloudKit records: CKReference, fetchRecordWithID, and saveRecord 
  
 Delivering notifications with CloudKit push messages: CKSubscription and 
  
  
  
 saveSubscription 
  
  
 Wrap up",NA
Project 34: Four in a Row ,NA,NA
804 ,"Setting up 
  
  
 Creating the interface with UIStackView 
  
  
 Preparing for basic play 
  
  
 Adding in players: GKGameModelPlayer 
  
  
 Detecting wins and draws in Four in a Row
  
 www.hackingwithswift.com 
  
 8",NA
Project 35: Random Numbers ,NA,NA
848 ,"Setting up 
  
  
 Generating random numbers in iOS 8 and earlier 
  
  
 Generating random numbers with GameplayKit: GKRandomSource 
  
  
 Choosing a random number source: GKARC4RandomSource and other GameplayKit 
  
  
 options 
  
  
 Shaping GameplayKit random numbers: GKRandomDistribution, GKShuffledDistribution 
  
  
 and GKGaussianDistribution 
  
  
 Shuffling an array with GameplayKit: arrayByShufflingObjectsInArray() 
  
  
 Wrap up",NA
Project 36: Crashy Plane ,NA,NA
867 ,"Setting up 
  
  
 Creating a player: ResizeFill vs AspectFill 
  
  
 Sky, background and ground: parallax scrolling with SpriteKit 
  
  
 Creating collisions and making random numbers with GameplayKit 
  
  
 Pixel-perfect physics in SpriteKit, plus explosions and more 
  
  
 Background music with SKAudioNode, an intro, plus game over 
  
  
 Wrap up",NA
Project 37: Psychic Tester ,NA,NA
901 ,"Setting up 
  
  
 Laying out the cards: addChildViewController() 
  
  
 Animating a 3D flip effect using transitionWithView() 
  
  
 Adding a CAGradientLayer with IBDesignable and IBInspectable 
  
  
 Creating a particle system using CAEmitterLayer 
  
  
 Wiggling cards and background music with AVAudioPlayer 
  
  
 How to measure touch strength using 3D Touch 
  
  
 Communicating between iOS and watchOS: WCSession 
  
  
 Designing a simple watchOS app to receive data 
  
  
 Wrap up",NA
Project 38: GitHub Commits ,NA,NA
941 ,"Setting up 
  
  
 Designing a Core Data model 
  
  
 Adding Core Data to our project: NSPersistentStoreCoordinator
  
 www.hackingwithswift.com 
  
 9",NA
Project 39: Unit testing with XCTest ,NA,NA
998 ,"Setting up 
  
  
 Creating our first unit test using XCTest 
  
  
 Loading our data and splitting up words: filter() 
  
  
 Counting unique strings in an array 
  
  
 measureBlock(): How to optimize our slow code and adjust the baseline 
  
  
 Filtering using functions as parameters 
  
  
 Updating the user interface with filtering 
  
  
 User interface testing with XCTest 
  
  
 Wrap up",NA
Appendix: The Swift Knowledge Base,NA,NA
1043,"10
  
 www.hackingwithswift.com",NA
About this book ,"The 
 Hacking with Swift
  tutorial series is designed to make it easy for beginners to get 
 started coding for iPad and iPhone using the Swift programming language.
  
 My teaching method skips out a lot of theory. It skips out the smart techniques that transform 20 
 lines of easy-to-understand code into 1 line of near-magic. It ignores coding conventions by the 
 dozen. And perhaps later on, once you've finished, you'll want to go back and learn all the 
 theory I so blithely walked past. But let me tell you this: the problem with learning theory by 
 itself is that your brain doesn't really have any interest in remembering stuff just for the sake of 
 it.
  
 You see, here you'll be learning to code on a Need To Know basis. Nearly everything you 
 learn from me will have a direct, practical application to something we're working on. That 
 way, your brain can see exactly why a certain technique is helpful and you can start using it 
 straight away.
  
 This book has been written on the back of my personal motto: ""Programming is an art. Don't 
 spend all your time sharpening your pencil when you should be drawing."" We'll be doing some 
 ""sharpening"" but a heck of a lot more ""drawing"" – if that doesn't suit your way of learning, you 
 should exit now.",NA
The three golden rules ,"The series is crafted around a few basic tenets, and it's important you understand them 
 before continuing:
  
 1. Follow the series: The tutorials are designed to be used in order, starting at the beginning 
 and working through to the end. The reason for this is that concepts are introduced 
  
 sequentially on a need-to-know basis – you only learn about something when you really have to 
 in order to make the project work.
  
 2. Don't skip the games and techniques: The tutorials follow a sequence: app, game, 
 technique, app, game, technique, etc. That is, you develop an app, then you develop a game, 
 then we focus on a particular iOS component together to help make your apps better. 
  
 The apps and games are, of course, standalone projects that you can go on to develop as 
  
 www.hackingwithswift.com 
  
 11",NA
"Xcode, Swift and iOS ","I'm not going to talk much, because I want to get straight into coding. However, there are 
 some points you do need to know:
  
  • You should install the latest Xcode from the Mac App Store. It's free, and includes 
 everything you need to make iOS apps in the iOS Simulator. Most of the projects in this 
 series will be developed in the simulator, but a couple will require a device because the 
 technology isn't available in the simulator – things like Touch ID and the accelerometer, for 
 example. Projects that require a device also require you to have an active iOS developer 
 account with Apple so that you can deploy your project to a device.
  
  • Swift is a relatively new language, and is evolving quickly. Every new release of Xcode 
 seems to change something or other, and often that means code that used to work now no 
 longer does. At the time of writing, Swift is mature enough that the changes are relatively 
 minor, so hopefully you can make them yourself. If not, check to see if there's an update of 
 the project files on 
 hackingwithswift.com
 .
  
  • These projects are designed to work with iOS 9.0 or later, which is the version that runs on 
 the majority of devices. You can downgrade them to 7.0 with relatively few changes if you 
 desperately want to maximise your reach, but it's really not worth it at this point.
  
 Important note:
  if any bugs are found in the project files, or if Swift updates come out that 
 force syntax changes, I'm going to be making changes to the projects on the website and 
 updating this book as needed. Please make sure you read the release notes for each project 
 to see what's changed, and 
 follow me on Twitter @twostraws
  if you want to be notified of 
 updates.
  
 I'm also happy to answer questions on Twitter if you encounter problems, so please feel free 
 to get in touch!
  
 Swift, the Swift logo, Xcode, Instruments, Cocoa Touch, Touch ID, AirDrop, iBeacon, iPhone, 
 iPad, Safari, App Store, Mac and OS X are trademarks of Apple Inc., registered in the U.S. 
 and other countries.
  
 Hacking with Swift is copyright Paul Hudson. All rights reserved. No part of this book or 
 corresponding materials (such as text, images, or source code) may be reproduced or 
 distributed by any means without prior written permission of the copyright owner.
  
 www.hackingwithswift.com 
  
 13",NA
Dedication ,"This book is dedicated to my daughter Charlotte, aka ""Bonk"", who has provided lots of hugs 
 and lots of happiness at every point in its creation.
  
 www.hackingwithswift.com 
  
 14",NA
Introduction ,NA,NA
Swift for Complete ,NA,NA
Beginners,NA,NA
If you want to learn the language all at once before ,NA,NA
"you start making apps, this is for you.",NA,NA
How to install Xcode and create a ,NA,NA
playground ,"Xcode is Apple's programming application for developers. It's free from the Mac App Store, 
 and it's required to do iPhone and iPad development. So, your first action is to 
 click here to 
 install Xcode from the Mac App Store
  – it's quite a big download, so start downloading it 
 now and carry on reading.
  
 While that's downloading, I can explain a couple of the absolute basics to you:
  
  • 
 iOS
  is the name of the operating system that runs on all iPhones and iPads. It's 
 responsible for all the basic operations of the phone, such as making phone calls, drawing 
 on the screen, and running apps.
  
  • 
 Swift
  is Apple's modern programming language that lets you write apps for iOS. It contains 
 the functionality for building programs, but doesn't handle anything like user interfaces, audio or 
 networking.
  
  • 
 Swift 1.2
  was the first major update to Swift, tweaking various language features and 
 improving others.
  
  • 
 Swift 2
  is the second major update to Swift, and it's the version used across all of Hacking 
 with Swift.
  
  • 
 UIKit
  is Apple's user interface toolkit. It contains things like buttons, text boxes, navigation 
 controls and more, and you drive it using Swift.
  
  • 
 Cocoa Touch
  is the name given for Apple's vast collection of frameworks for iOS. It 
 includes UIKit to do user interfaces, but also SpriteKit for making 2D games, SceneKit for 
 making 3D games, MapKit for maps, Core Graphics for drawing, Core Animation for 
 animating things, iAd for placing adverts, and much more.
  
  • 
 NeXTSTEP
  is an operating system created by a company that Steve Jobs founded called 
 NeXT. It was bought by Apple, at which point Jobs was placed back in control of the company, 
 and put NeXTSTEP technology right into the core of Apple's development platform.
  
  • 
 iOS Simulator
  is a tool that comes with Xcode that looks and works almost exactly like a real 
 iPhone or iPad. It lets you test your app very quickly without having to use a real device.
  
  • 
 Playgrounds
  are miniature Swift testing environments that let you type code and see the 
 results immediately. You don't build real apps with them, but they are great for learning. We'll 
 be using playgrounds in this introduction.
  
  • 
 Crashes
  are when your code goes disastrously wrong and your app cannot recover. If a 
 user is running your app it will just disappear and they'll be back on the home screen. If 
 you're running in Xcode, you'll see a crash report.
  
 www.hackingwithswift.com 
  
 16",NA
Variables and constants ,"Every useful program needs to store data at some point, and in Swift there are two ways to do 
 it: variables and constants. A variable is a data store that can have its value changed 
 whenever you want, and a constant is a data store that you set once and can never change. 
 So, variables have values that can vary, and constants have values that are constant – easy, 
 right?
  
 Having both these options might seem pointless, after all you could just create a variable then 
 never change it – why does it need to be made a constant? Well, it turns out that many 
 programmers are – shock! – less than perfect at programming, and we make mistakes. One of 
 the advantages of separating constants and variables is that Xcode will tell us if we've made a 
 mistake. If we say, ""make this date a constant, because I know it will never change"" then 10 
 lines later try to change it, Xcode will refuse to build our app.
  
 Constants are also important because they let Xcode make decisions about the way it builds 
 your app. If it knows a value will never change, it is able to apply optimizations to make your 
 code run faster.
  
 In Swift, you make a variable using the 
 var
  keyword, like this:
  
 var name = ""Tim McGraw"" 
 Let's put that into a playground so you can start getting feedback. Delete everything in there 
 apart from the 
 import UIKit
  line (that's the bit that pulls in Apple's core iOS framework and it's 
 need later on), and add that variable. You should see the picture below.
  
 www.hackingwithswift.com 
  
 18",NA
Types of Data ,"There are lots of kinds of data, and Swift handles them all individually. You already saw one 
 of the most important types when you assigned some text to a variable, but in Swift these 
 are called a 
 String
  – literally a string of characters.
  
 Strings can be long (e.g. a million letters or more), short (e.g. 10 letters) or even empty (no 
 letters), it doesn't matter: they are all strings in Swift's eyes, and all work the same. Swift 
 knows that 
 name
  should hold a string because you assign a string to it when you create it: 
 ""Tim McGraw"". If you were to rewrite your code to this it would stop working:
  
 var name 
 name = ""Tim McGraw"" 
 This time Xcode will give you an error message that won't make much sense just yet: ""Type 
 annotation missing in pattern"". What it means is, ""I can't figure out what data type 
 name
  is 
 because you aren't giving me enough information.""
  
 At this point you have two options: either create your variable and give it an initial value on 
 one line of code, or use what's called a type annotation, which is where you tell Swift what 
 data type the variable will hold later on, even though you aren't giving it a value right now.
  
 You've already seen how the first option looks, so let's look at the second: type annotations. 
 We know that 
 name
  is going to be a string, so we can tell Swift that by writing a colon then 
 String
 , like this:
  
 var name: String 
 name = ""Tim McGraw"" 
 You'll have no errors now, because Swift knows what type of data 
 name
  will hold in the 
 future.
  
 Note:
  some people like to put a space before and after the colon, making 
 var name : String
 , 
 but they are 
 wrong
  and you should try to avoid mentioning their wrongness in polite 
  
 www.hackingwithswift.com 
  
 21",NA
Float and Double ,"Let's look at two more data types, called 
 Float
  and 
 Double
 . This is Swift's way of storing 
 numbers with a fractional component, such as 3.1, 3.141, 3.1415926, and -16777216.5. There 
 are two data types for this because you get to choose how much accuracy you want, but most 
 of the time it doesn't matter so the official Apple recommendation is always to use 
 Double
  
 because it has the highest accuracy.
  
 Try putting this into your playground:
  
 var latitude: Double  
 latitude = 36.166667 
 var longitude: Float  
 longitude = -86.783333 
 You can see both numbers appear on the right, but look carefully because there's a tiny 
 discrepancy. We said that 
 longitude
  should be equal to -86.783333, but in the results pane 
 you'll see -86.78333 – it's missing one last 3 on the end. Now, you might well say, ""what 
 does 0.000003 matter amongst friends?"" but this is ably demonstrating what I was saying 
 about accuracy.
  
 Because these playgrounds update as you type, we can try things out so you can see 
 exactly how 
 Float
  and 
 Double
  differ. Try changing the code to be this:
  
 var longitude: Float  
 longitude = -86.783333  
 longitude = -186.783333  
 longitude = -1286.783333  
 longitude = -12386.783333  
 longitude = -123486.783333 
 www.hackingwithswift.com 
  
 23",NA
Boolean ,"Swift has a built-in data type that can store whether a value is true or false, called a 
 Bool
 , 
 short for Boolean. Bools don't have space for ""maybe"" or ""perhaps"", only absolutes: true or 
 false. For example:
  
 var stayOutTooLate: Bool 
 stayOutTooLate = true 
 var nothingInBrain: Bool 
 nothingInBrain = true 
 var missABeat: Bool 
 missABeat = false",NA
Using type annotations wisely ,"As you've learned, there are two ways to tell Swift what type of data a variable holds: assign a 
 value when you create the variable, or use a type annotation. If you have a choice, the first is 
 always preferable because it's clearer. For example:
  
 var name = ""Tim McGraw"" 
 www.hackingwithswift.com
  
 25",NA
Operators ,"Operators are those little symbols you learned in your very first math classes: + to add, - to 
 subtract, * to multiply, / to divide, = to assign value, and so on. They all exist in Swift, along 
 with a few extras.
  
 Let's try a few basics – please type this into your playground:
  
 var a = 10  
 a = a + 1  
 a = a - 1  
 a = a * a 
 In the results pane, you'll see 10, 11, 10 and 100 respectively. Now try this:
  
 var b = 10  
 b += 10  
 b -= 10 
 += is an operator that means ""add then assign to."" In our case it means ""take the current 
 value of 
 b
 , add 10 to it, then put the result back into 
 b
 ."" As you might imagine, -= does the 
 same but subtracts rather than adds. So, that code will show 10, 20, 10 in the results pane.
  
 Some of these operators apply to other data types. As you might imagine, you can add two 
 doubles together like this:
  
 var 
 a 
 = 
 1.1  
 var 
 b 
 = 
 2.2  
 var c = a + b 
 www.hackingwithswift.com
  
 27",NA
Comparison operators ,"Swift has a set of operators that perform comparisons on values. For example:
  
 var 
 a 
 = 
 1.1  
 var 
 b 
 = 
 2.2  
 var c = a + b 
 c > 3  
 c >= 3  
 c > 4  
 c < 4 
 That shows off greater than (>), greater than or equal (>=), and less than (<). In the results 
 window you'll see true, true, false, true – these are Booleans, because the answer to each of 
 these statements can only ever be true or false.
  
 If you want to check for equality, you can't use = because already has a meaning: it's used to 
 give a variable a value. So, Swift has an alternative in the form of ==, meaning ""is equal to."" For 
 example:
  
 www.hackingwithswift.com 
  
 28",NA
String interpolation ,"This is a fancy name for what is actually a very simple thing: combining variables and 
 constants inside a string.
  
 Clear out all the code you just wrote and leave only this:
  
 var name = ""Tim McGraw"" 
 If we wanted to print out a message to the user that included their name, string interpolation is 
 what makes that easy: you just write a backslash, then an open parenthesis, then your code, 
 then a close parenthesis, like this:
  
 var name = ""Tim McGraw"" 
 ""Your name is \(name)"" 
 The results pane will now show ""Your name is Tim McGraw"" all as one string, because string 
 interpolation combined the two for us.
  
 Now, we could have written that using the + operator, like this:
  
 var name = ""Tim McGraw"" 
 ""Your name is "" + name 
 …but that's not as efficient, particularly if you're combining multiple variables together. In 
 addition, string interpolation in Swift is smart enough to be able to handle a variety of 
 different data types automatically. For example:
  
 var name = ""Tim McGraw"" 
 var age = 25 
 var latitude = 36.166667 
 www.hackingwithswift.com 
  
 30",NA
Arrays ,"Arrays let you group lots of values together into a single collection, then access those values 
 by their position in the collection. Swift uses type inference to figure out what type of data your 
 array holds, like so:
  
 var oddNumbers = [2, 4, 6, 8] 
 var songs = [""Shake it Off"", ""You Belong with Me"", ""Back to December""] 
 As you can see, Swift uses brackets to mark the start and end of an array, and each item in 
 the array is separated with a comma.
  
 When it comes to reading items out an array, there's a catch: Swift starts counting at 0. This 
 means the first item is 0, the second item is 1, the third is 2, and so on. Try putting this into 
 your playground:
  
 var songs = [""Shake it Off"", ""You Belong with Me"", ""Back to December""] 
 songs[0] 
 songs[1] 
 songs[2] 
 That will print ""Shake it Off"", ""You Belong with Me"", and ""Back to December"" in the results 
 pane.
  
 An item's position in an array is called its index, and you can read any item from the array just 
 by providing its index. However, you do need to be careful: our array has three items in, which 
 means indexes 0, 1 and 2 work great. But if you try and read 
 songs[3]
  your 
  
 playground will stop working – and if you tried that in a real app it would crash!
  
 Because you've created your array by giving it three strings, Swift knows this is an array of 
 strings. You can confirm this by using a special command in the playground that will print out 
 the data type of any variable, like this:
  
 www.hackingwithswift.com 
  
 32",NA
Creating arrays ,"If you make an array using the syntax shown above, Swift creates the array and fills it with the 
 values we specified. Things aren't quite so straightforward if you want to create the array then 
 fill it later – this syntax doesn't work:
  
 var songs: [String] 
 songs[0] = ""Shake it Off"" 
 The reason is one that will seem needlessly pedantic at first, but has deep underlying 
 performance implications so I'm afraid you're just stuck with it. Put simply, writing 
 var songs: 
 [String]
  tells Swift ""the 
 songs
  variable will hold an array of strings,"" but 
 it doesn't actually 
 create that array
 . It doesn't allocate any RAM, or do any of the work to actually create a Swift 
 array. It just says that at some point there will be an array, and it will hold strings.
  
 There are a few ways to express this correctly, and the one that probably makes most sense 
 at this time is this:
  
 var songs: [String] = [] 
 That uses a type annotation to make it clear we want an array of strings, and it assigns an 
 empty array (that's the 
 []
  part) to it.
  
 You'll also commonly see this construct:
  
 www.hackingwithswift.com 
  
 34",NA
Array operators,"You can use a limited set of operators on arrays. For example, you can merge two arrays by 
  
 using the + operator, like this:
  
 var songs = [""Shake it Off"", ""You Belong with Me"", ""Love Story""] 
 var songs2 = [""Today was a Fairytale"", ""White Horse"", ""Fifteen""] 
 var both = songs + songs2 
 You can also use += to add and assign, like this:
  
 both += [""Everything has Changed""] 
 www.hackingwithswift.com
  
 35",NA
Dictionaries ,"As you've seen, Swift arrays are a collection where you access each item using a numerical 
 index, such as 
 songs[0]
 . Dictionaries are another common type of collection, but they differ 
 from arrays because they let you access values based on a key you specify.
  
 To give you an example, let's imagine how we might store data about a person in an array:
  
 var person = [""Taylor"", ""Alison"", ""Swift"", ""December"", ""taylorswift.com""] 
 To read out that person's middle name, we'd use 
 person[1]
 , and to read out the month they 
 were born we'd use 
 person[3]
 . This has a few problems, not least that it's difficult to remember 
 what index number is assigned to each value in the array! And what happens if the person has 
 no middle name? Chances are all the other values would move down one place, causing chaos 
 in your code.
  
 With dictionaries we can re-write this to be far more sensible, because rather than arbitrary 
 numbers you get to read and write values using a key you specify. For example:
  
 var person = [""first"": ""Taylor"", ""middle"": ""Alison"", ""last"": ""Swift"", ""month"": ""December"", ""website"": 
 ""taylorswift.com""]  
 person[""middle""]  
 person[""month""] 
 It might help if I use lots of whitespace to break up the dictionary on your screen, like this:
  
 var person = [ 
  ""first"": ""Taylor"", 
  ""middle"": ""Alison"", 
  ""last"": ""Swift"", 
  ""month"": ""December"", 
  ""website"": ""taylorswift.com"" 
 www.hackingwithswift.com 
  
 36",NA
Conditional statements ,"Sometimes you want code to execute only if a certain condition is true, and in Swift that is 
 represented primarily by the 
 if
  and 
 else
  statements. You give Swift a condition to check, then a 
 block of code to execute if that condition is true.
  
 You can optionally also write 
 else
  and provide a block of code to execute if the condition is 
 false, or even 
 else if
  and have more conditions. A ""block"" of code is just a chunk of code 
 marked with an open brace – 
 {
  – at its start and a close brace – 
 }
  – at its end.
  
 Here's a basic example:
  
 var action: String  
 var person = ""hater"" 
 if person == ""hater"" { 
  action = ""hate""  
 } 
 That uses the == (equality) operator introduced previously to check whether the string inside 
 person
  is exactly equivalent to the srting ""hater"". If it is, it sets the 
 action
  variable to ""hate"". 
 Note that open and close braces, also known by their less technical name of ""curly brackets"" – 
 that marks the start and end of the code that will be executed if the condition is true.
  
 Let's add 
 else if
  and 
 else
  blocks:
  
 var action: String  
 var person = ""hater"" 
 if person == ""hater"" { 
  action = ""hate""  
 } else if person == ""player"" { 
  action = ""play"" 
 www.hackingwithswift.com 
  
 38",NA
Evaluating multiple conditions ,"You can ask Swift to evaluate as many conditions as you want, but they all need to be true in 
 order for Swift to execute the block of code. To check multiple conditions, use the 
 && 
 operator 
 – it means ""and"". For example:
  
 var action: String  
 var stayOutTooLate = true  
 var nothingInBrain = true 
 if stayOutTooLate && nothingInBrain { action = 
 ""cruise""  
 } 
 Because 
 stayOutTooLate
  and 
 nothingInBrain
  are both true, the whole condition is true, and 
 action
  gets set to ""cruise."" Swift uses something called short-circuit evaluation to boost 
 performance: if it is evaluating multiple things that all need to be true, and the first one is false, 
 it doesn't even both evaluating the rest.
  
 www.hackingwithswift.com 
  
 39",NA
Looking for the opposite of truth ,"This might sound deeply philosophical, but actually this is important: sometimes you care 
 whether a condition is not true, i.e. is false. You can do this with the ! (not) operator that was 
 introduced earlier. For example:
  
 if !stayOutTooLate && !nothingInBrain { 
  action = ""cruise"" 
 } 
 This time, the 
 action
  variable will only be set if both 
 stayOutTooLate
  and 
 nothingInBrain 
 are false – the ! has flipped them around.
  
 www.hackingwithswift.com 
  
 40",NA
Loops ,"Computers are great at doing boring tasks billions of times in the time it took you to read this 
 sentence. When it comes to repeating tasks in code, you can either copy and paste your code 
 multiple times, or you can use 
 loops
  – simple programming constructs that repeat a block of 
 code for as long as a condition is true.
  
 To demonstrate this, I want to introduce you to a special debugging function called 
 print()
 : 
 you give it some text to print, and it will print it. If you're running in a playground like we are, 
 you'll see your text appear in the results window. If you're running a real app in Xcode, you'll 
 see your text appear in Xcode's log window. Either way, 
 print()
  is a great way to get a sneak 
 peek at the contents of a variable.
  
 Take a look at this code:
  
 print(""1 
 x 
 10 
 is 
 \(1 
 * 
 10)"")  
 print(""2 
 x 
 10 
 is 
 \(2 
 * 
 10)"")  
 print(""3 
 x 
 10 
 is 
 \(3 
 * 
 10)"")  
 print(""4 
 x 
 10 
 is 
 \(4 
 * 
 10)"")  
 print(""5 
 x 
 10 
 is 
 \(5 
 * 
 10)"")  
 print(""6 
 x 
 10 
 is 
 \(6 
 * 
 10)"")  
 print(""7 
 x 
 10 
 is 
 \(7 
 * 
 10)"")  
 print(""8 
 x 
 10 
 is 
 \(8 
 * 
 10)"")  
 print(""9 
 x 
 10 
 is 
 \(9 
 * 
 10)"")  
 print(""10 x 10 is \(10 * 10)"") 
 When it has finished running, you'll have the 10 times table in your playground results pane. 
 But it's hardly efficient code, and in fact a much cleaner way is to loop over a range of 
 numbers using what's called the closed range operator, which is three periods in a 
  
 row: 
 ...
 Using the closed range operator, we could re-write that whole thing in three lines:
  
 for i in 1...10 { 
  print(""\(i) x 10 is \(i * 10)"")  
 } 
 www.hackingwithswift.com 
  
 41",NA
Looping over arrays ,"Swift provides a very simple way to loop over all the elements in an array. Because Swift 
 already knows what kind of data your array holds, it will go through every element in the 
 array, assign it to a constant you name, then run a block of your code. For example, we 
 could print out a list of great songs like this:
  
 var songs = [""Shake it Off"", ""You Belong with Me"", ""Back to December""] 
 for song in songs { 
  print(""My favorite song is \(song)"") } 
 You can also use the 
 for i in
  loop construct to loop through arrays, because you can use that 
 constant to index into an array. We could even use it to index into two arrays, like this:
  
 var people = [""players"", ""haters"", ""heart-breakers"", ""fakers""] var actions = [""play"", ""hate"", 
 ""break"", ""fake""] 
 www.hackingwithswift.com 
  
 43",NA
Inner loops ,"You can put loops inside loops if you want, and even loops inside loops inside loops – 
 although you might suddenly find you're doing something 10 million times, so be careful!
  
 We can combine two of our previous loops to create this:
  
 var people = [""players"", ""haters"", ""heart-breakers"", ""fakers""] var actions = [""play"", ""hate"", 
 ""break"", ""fake""] 
 www.hackingwithswift.com 
  
 44",NA
While loops ,"There's a third kind of loop you'll see, which repeats a block of code until you tell it to stop. 
  
 This is used for things like game loops where you have no idea in advance how long the game 
 will last – you just keep repeating ""check for touches, animate robots, draw screen, check for 
 touches…"" and so on, until eventually the user taps a button to exit the game and go back to 
 the main menu.
  
 These loops are called 
 while
  loops, and they look like this:
  
 var counter = 0 
 www.hackingwithswift.com 
  
 45",NA
Switch case ,"You've seen 
 if
  statements and now loops, but Swift has another type of flow control called 
 switch/case
 . It's easiest to think of this as being an advanced form of 
 if
 , because you can 
 have lots of matches and Swift will execute the right one.
  
 In the most basic form of a 
 switch/case
  you tell Swift what variable you want to check, the 
 provide a list of possible cases for that variable. Swift will find the first case that matches 
 your variable, then run its block of code. When that block finishes, Swift exits the whole 
 switch/case
  block.
  
 Here's a basic example:
  
 let liveAlbums = 2 
 switch liveAlbums {  
 case 0: 
  print(""You're just starting out"") 
 case 1: 
  print(""You just released iTunes Live From SoHo"") 
 case 2: 
  print(""You just released Speak Now World Tour"") 
 default: 
  print(""Have you done something new?"") } 
 We could very well have written that using lots of 
 if
  and 
 else if
  blocks, but this way is clearer 
 and that's important.
  
 www.hackingwithswift.com 
  
 48",NA
Functions ,"Functions let you define re-usable pieces of code that perform specific pieces of 
  
 functionality. Usually functions are able to receive some values to modify the way they work, 
 but it's not required.
  
 Let's start with a simple function:
  
 func favoriteAlbum() { 
  print(""My favourite is Fearless"") 
 } 
 If you put that code into your playground, nothing will be printed. And yes, it is correct. The 
 reason nothing is printed is that we've placed the ""My favourite is Fearless"" message into a 
 function called 
 favoriteAlbum()
 , and that code won't be called until we ask Swift to run the 
 favoriteAlbum()
  method. To do that, add this line of code:
  
 favoriteAlbum() 
 That runs the function (or ""calls"" it), so now you'll see ""My favourite is Fearless"" printed out.
  
 As you can see, you define a function by writing 
 func
 , then your function name, then open and 
 close parentheses, then a block of code marked by open and close braces. You then call that 
 function by writing its name followed by an open and close parentheses.
  
 Of course, that's a silly example – that function does the same thing no matter what, so there's 
 no point it existing. But what if we wanted to print a different album each time? In that case, we 
 could tell Swift we want our function to accept a value when it's called, then use that value 
 inside it.
  
 Let's do that now:
  
 func favoriteAlbum(album: String) { 
  print(""My favourite is \(album)"") 
 www.hackingwithswift.com 
  
 50",NA
Return values ,"Swift functions can return a value by writing 
 ->
  then a data type. Once you do this, Swift will 
 ensure that your function will return a value no matter what, so again this is you make a 
 promise about what your code does.
  
 As an example, let's write a function that returns true if an album is one of Taylor Swift's, or 
 false otherwise. This needs to accept one parameter (the name of the album to check) and 
 will return a Boolean. Here's the code:
  
 func albumsIsTaylor(name: String) -> Bool { if name == 
 ""Taylor Swift"" { return true } if name == ""Fearless"" { return 
 true } if name == ""Speak Now"" { return true } if name == 
 ""Red"" { return true } 
  if name == ""1989"" { return true } 
  return false  
 } 
 If you wanted to try your new 
 switch/case
  knowledge, this function is a place where it would 
 work well.
  
 You can now call that by passing the album name in and acting on the result:
  
 if albumsIsTaylor(""Red"") { 
  print(""That's one of hers!"")  
 } else { 
  print(""Who made that?!"")  
 } 
 if albumsIsTaylor(""Blue"") { 
  print(""That's one of hers!"") 
 www.hackingwithswift.com 
  
 52",NA
Optionals ,"Swift is a very safe language, by which I mean it works hard to ensure your code never fails 
 in surprising ways.
  
 One of the most common ways that code fails is when it tries to use data that is bad or 
 missing. For example, imagine a function like this:
  
 func getHaterStatus() -> String { 
  return ""Hate"" 
 } 
 That function doesn't accept any parameters, and it returns a string: ""Hate"". But what if today 
 is a particularly sunny day, and those haters don't feel like hating – what then? Well, maybe 
 we want to return nothing: this hater is doing no hating today. Now, when it comes to a string 
 you might think an empty string is a great way to communicate nothing, and that might be true 
 sometimes. But how about numbers – is 0 an ""empty number""? Or -1?
  
 Before you start trying to create imaginary rules for yourself, Swift has a solution: optionals. 
 An optional value is one that might have a value or might not.
  
 When we used 
 -> String
  it means ""this will definitely return a string,"" which means this 
 function cannot return no value, and thus can be called safe in the knowledge that you'll 
 always get a value back. If we wanted to tell Swift that this function might return a value or it 
 might not, we need to use this instead:
  
 func getHaterStatus() -> String? { 
  return ""Hate"" 
 } 
 Note the extra question mark: that means ""optional string."" Now, in our case we're still 
 returning ""Hate"" no matter what, but let's go ahead and modify that function further: if the 
 weather is sunny, the haters have turned over a new leaf and have given up their life of 
  
 www.hackingwithswift.com 
  
 54",NA
Force unwrapping optionals,"www.hackingwithswift.com 
  
 60",NA
Implicitly unwrapped optionals ,"You can also use this exclamation mark syntax to create implicitly unwrapped optionals, 
 which is where some people really start to get confused. So, please read this carefully!
  
  • A regular variable must contain a value. Example: 
 String
  must contain a string, even if that 
 is string empty, i.e. 
 """"
 .
  
  • An optional variable might contain a value, or might not. It must be unwrapped before it is 
 used. Example: 
 String?
  might contain a string, or it might contain nil. The only way to find out 
 is to unwrap it.
  
  • An implicitly unwrapped optional might contain a value, or might not. But it does 
 not
  need to 
 be unwrapped before it is used. Swift won't check for you, so you need to be extra careful. 
 Example: 
 String!
  might contain a string, or it might contain nil – and it's down to you to use it 
 appropriately.
  
 There are two main times you're going to meet implicitly unwrapped optionals. The first is 
 when you're working with Apple's APIs: these frequently return implicitly unwrapped optionals 
 because their code pre-dates Swift and that was how things were done in Ye Olde Ages Of 
 Programming.
  
 The second is when you're working with user interface elements in UIKit. These need to be 
 declared up front, but you can't use them until they have been created by iOS – and it likes 
 to create user interface elements at the last possible moment to avoid any unnecessary 
 work. Having to continually unwrap values you definitely know will be there is annoying, so 
 these are made implicitly unwrapped.
  
 www.hackingwithswift.com 
  
 62",NA
Optional chaining ,"Working with optionals can feel a bit clumsy sometimes, and all the unwrapping and 
 checking can become so onerous that you might be tempted to throw some exclamation 
 marks to force unwrap stuff so you can get on with work. Be careful, though: if you force 
 unwrap an optional that doesn't have a value, your code will crash.
  
 Swift has two techniques to help make your code less complicated. The first is called 
 optional chaining, which lets you run code only if your optional has a value. Put the below 
 code into your playground to get us started:
  
 func albumReleasedYear(year: Int) -> String? { switch year { 
  case 2006: return ""Taylor Swift"" 
  case 2008: return ""Fearless"" 
  case 2010: return ""Speak Now"" 
  case 2012: return ""Red"" 
  case 2014: return ""1989"" 
  default: return nil 
  }  
 } 
 let album = albumReleasedYear(2006)  
 print(""The album is \(album)"") 
 That will output ""The album is Optional(""Taylor Swift"")"" into the results pane.
  
 If we wanted to convert the return value of 
 albumReleasedYear()
  to be uppercase letters 
 (that is, ""TAYLOR SWIFT"" rather than ""Taylor Swift"") we could use the 
 uppercaseString 
 value of that string. For example:
  
 let str = ""Hello world""  
 print(str.uppercaseString) 
 www.hackingwithswift.com 
  
 64",NA
The nil coalescing operator ,"This simple Swift feature makes your code much simpler and safer, and yet has such a 
 grandiose name that many people are scared of it. This is a shame, because the nil 
 coalescing operator will make your life easier if you take the time to figure it out!
  
 www.hackingwithswift.com 
  
 65",NA
Enumerations ,"Enumerations – usually just called ""enum"" and pronounced ""ee-num"" - are a way for you to 
 define your own kind of value in Swift. In some programming languages they are simple little 
 things, but Swift adds a huge amount of power to them if you want to go beyond the basics.
  
 Let's start with a simple example from earlier:
  
 func getHaterStatus(weather: String) -> String? { if weather == 
 ""sunny"" { 
   return nil 
  } else { 
   return ""Hate"" 
  }  
 } 
 That function accepts a string that defines the current weather. The problem is, a string is a 
 poor choice for that kind of data – is it ""rain"", ""rainy"" or ""raining""? Or perhaps ""showering"", 
 ""drizzly"" or ""stormy""? Worse, what if one person writes ""Rain"" with an uppercase R and 
 someone else writes ""Ran"" because they weren't looking at what they typed?
  
 Enums solve this problem by letting you define a new data type, then define the possible 
 values it can hold. For example, we might say there are five kinds of weather: sun, cloud, 
 rain, wind and snow. If we make this an enum, it means Swift will accept only those five 
 values – anything else will trigger an error. And behind the scenes enums are usually just 
 simple numbers, which are a lot faster than strings for computers to work with.
  
 Let's put that into code:
  
 enum WeatherType { 
  case Sun, Cloud, Rain, Wind, Snow  
 } 
 func getHaterStatus(weather: WeatherType) -> String? { 
 www.hackingwithswift.com 
  
 67",NA
Enums with additional values ,"One of the most powerful features of Swift is that enumerations can have values attached to 
 them that you define. To extend our increasingly dubious example a bit further, I'm going to 
 add a value to the 
 .Wind
  case so that we can say how fast the wind is. Modify your code to 
 this:
  
 enum WeatherType { 
  case Sun 
  case Cloud 
  case Rain 
  case Wind(speed: Int) 
  case Snow  
 } 
 As you can see, the other cases don't need a speed value – I put that just into wind. Now for 
 the real magic: Swift lets us add extra conditions to the 
 swift/case
  block so that a case will 
 match only if those conditions are true. This uses the 
 let
  keyword to access the value inside a 
 case, then the 
 where
  keyword for pattern matching.
  
 Here's the new function:
  
 func getHaterStatus(weather: WeatherType) -> String? { switch weather { 
  case .Sun: 
 www.hackingwithswift.com 
  
 70",NA
Structs ,"Structs are complex data types, meaning that they are made up of multiple values. You then 
 create an instance of the struct and fill in its values, then you can pass it around as a single 
 value in your code. For example, we could define a 
 Person
  struct type that contains two 
 properties: 
 clothes
  and 
 shoes
 :
  
 struct Person { 
  var clothes: String 
  var shoes: String 
 } 
 When you define a struct, Swift makes them very easy to create because it automatically 
 generates what's called a memberwise initializer. In plain speak, it means you create the 
 struct by passing in initial values for its two properties, like this:
  
 let taylor = Person(clothes: ""T-shirts"", shoes: ""sneakers"") 
 let other = Person(clothes: ""short skirts"", shoes: ""high heels"") 
 Once you have created an instance of a struct, you can read its properties just by writing the 
 name of the struct, a period, then the property you want to read:
  
 print(taylor.clothes) 
 print(other.shoes) 
 If you assign one struct to another, Swift copies it behind the scenes so that it is a complete, 
 standalone duplicate of the original. Well, that's not strictly true: Swift uses a technique called 
 ""copy on write"" which means it only actually copies your data if you try to change it.
  
 To help you see how struct copies work, put this into your playground:
  
 www.hackingwithswift.com 
  
 72",NA
Classes ,"Swift has another way of build complex data types called classes. They look similar to 
 structs, but have a number of important differences, including:
  
  • You don't get an automatic memberwise initializer for your classes; you need to write your 
 own.
  
  • You can define a class as being based off another class, adding any new things you want. 
 • If you copy an object, both copies point at the same data by default.
  
 All three of those are massive differences, so I'm going to cover them in more depth before 
 continuing.",NA
Initializing an object ,"If we were to convert our 
 Person
  struct into a 
 Person
  class, Swift wouldn't let us write this:
  
 class Person { 
  var clothes: String 
  var shoes: String 
 } 
 This is because we're declaring the two properties to be 
 String
 , which if you remember 
 means they absolutely must have a value. This was fine in a struct because Swift 
  
 automatically produces a memberwise initializer for us that forced us to provide values for 
 the two properties, but this doesn't happen with classes so Swift can't be sure they will be 
 given values.
  
 There are three solutions: make the two values optional strings, give them default values, or 
 write our own initializer. The first option is clumsy because it introduces optionals all over our 
 code where they don't need to be. The second option works, but it's a bit wasteful unless 
 those default values will actually be used. That leaves the third option, and really it's the right 
 one: write our own initializer.
  
 www.hackingwithswift.com 
  
 74",NA
Class inheritance ,"The second difference between classes and structs are that classes can build on each other to 
 produce greater things, known as 
 class inheritance
 . This is a technique used extensively in 
  
 www.hackingwithswift.com 
  
 75",NA
Values vs References ,"When you copy a struct, the whole thing is duplicated, including all its values. This means that 
 changing one copy of a struct doesn't change the other copies – they are all individual. With 
 classes, each copy of an object points at the same original object, so if you change one they 
 all change. Swift calls structs ""value types"" because they just point at a value, and classes 
 ""reference types"" because objects are just shared references to the real value.
  
 This is an important difference, and it means the choice between structs and classes is an 
 important one:
  
  • If you want to have one shared state that gets passed around and modified in place, you're 
 looking for classes. You can pass them into functions or store them in arrays, modify them in 
 there, and have that change reflected in the rest of your program.
  
 www.hackingwithswift.com 
  
 79",NA
Properties ,"Structs and classes (collectively: ""types"") can have their own variables and constants, and 
 these are called properties. These let you attach values to your types to represent them 
 uniquely, but because types can also have methods you can have them behave according to 
 their own data.
  
 Let's take a look at an example now:
  
 struct Person { 
  var clothes: String 
  var shoes: String 
  func describe() { 
   print(""I like wearing \(clothes) with \(shoes)"") }  
 } 
 let taylor = Person(clothes: ""T-shirts"", shoes: ""sneakers"") let other = Person(clothes: 
 ""short skirts"", shoes: ""high heels"") taylor.describe()  
 other.describe() 
 As you can see, when you use a property inside a method it will automatically use the value 
 that belongs to the same object.",NA
Property observers ,"Swift lets you add code to be run when a property is about to be changed or has been 
 changed. This is frequently a good way to have a user interface update when a value 
  
 www.hackingwithswift.com 
  
 81",NA
Computed properties ,"It's possible to make properties that are actually code behind the scenes. We already used the 
 uppercaseString
  property of strings, for example – that's something that gets calculated as 
 needed, rather than every string always storing an uppercase version of itself.
  
 To make a computed property, place an open brace after your property then use either 
 get
  or 
 set
  to make an action happen at the appropriate time. For example, if we wanted to add a 
 ageInDogYears
  property that automatically returned a person's age multiplied by seven, we'd 
 do this:
  
 struct Person { 
  var age: Int 
  var ageInDogYears: Int { 
   get { 
   
  
  return age * 7 
   } 
  }  
 } 
 var fan = Person(age: 25)  
 print(fan.ageInDogYears) 
 Computed properties are common in Apple's code, but less common in user code. Many 
 programmers prefer to use methods because their behavior is clearer.
  
 www.hackingwithswift.com 
  
 83",NA
Static properties and methods ,"Swift lets you create properties and methods that belong to a type, rather than to instances 
 of a type. This is helpful for organizing your data meaningfully by storing shared data.
  
 Swift calls these shared properties ""static properties"", and you create one just by using the 
 static
  keyword. Once that's done, you access the property by using the full name of the 
 type. Here's a simple example:
  
 struct TaylorFan { 
  static var favoriteSong = ""Shake it Off"" 
  var name: String 
  var age: Int  
 } 
 let fan = TaylorFan(name: ""James"", age: 25) 
 print(TaylorFan.favoriteSong) 
 So, a Taylor Swift fan has a name and age that belongs to them, but they all have the same 
 favorite song.
  
 Because static methods belong to the class rather than to instances of a class, you can't use it 
 to access any non-static properties from the class.
  
 www.hackingwithswift.com 
  
 84",NA
Access control ,"This is an important feature and one you need to understand, but sadly it's one that doesn't 
 work in Swift playgrounds so you'll just have to take my word for it. Access control lets you 
 specify what data inside structs and classes should be exposed to the outside world, and you 
 get to choose three modifiers:
  
  • Public: this means everyone can read and write the property.
  
  • Internal: this means only your Swift code can read and write the property.
  
  • Private: this means that only Swift code in the same file as the type can read and write the 
 property.
  
 Most of the time you don't need to specify access control, but sometimes you'll want to 
 explicitly set a property to be private because it stops others from accessing it directly. This 
 is useful because your own methods can work with that property, but others can't, thus 
 forcing them to go through your code to perform certain actions.
  
 To declare a property private, just do this:
  
 class TaylorFan { 
  private var name: String! 
 } 
 Reminder: this does nothing on Swift playgrounds, because one playground is effectively one 
 file and thus can read and write any data it likes.
  
 www.hackingwithswift.com 
  
 85",NA
Polymorphism and type casting ,"Because classes can inherit from each other (e.g. 
 CountrySinger
  can inherit from 
 Singer
 ) it 
 means one class is effectively a superset of another: class B has all the things A has, with a 
 few extras. This in turn means that you can treat B as type B or as type A, depending on your 
 needs.
  
 Confused? Let's try some code:
  
 class Album { 
  var name: String 
  init(name: String) { 
   self.name = name 
  }  
 } 
 class StudioAlbum: Album { 
  var studio: String 
  init(name: String, studio: String) { 
  self.studio = 
 studio 
   super.init(name: name) 
  }  
 } 
 class LiveAlbum: Album { 
  var location: String 
  init(name: String, location: String) { self.location = 
 location 
  super.init(name: name) 
 www.hackingwithswift.com 
  
 86",NA
Converting types with type casting ,"You will often find you have an object of a certain type, but really you know it's a different 
 type. Sadly, if Swift doesn't know what you know, it won't build your code. So, there's a 
 solution, and it's called type casting: converting an object of one type to another.
  
 Chances are you're struggling to think why this might be necessary, but I can give you a very 
 simple example:
  
 www.hackingwithswift.com 
  
 89",NA
Closures ,"You've met integers, strings, doubles, floats, Booleans, arrays, dictionaries, structs and 
 classes so far, but there's another type of data that is used extensively in Swift, and it's 
 called a closure. These are complicated, but they are so powerful and expressive that they 
 are used pervasively in Cocoa Touch, so you won't get very far without understanding them.
  
 A closure can be thought of as a variable that holds code. So, where an integer holds 0 or 
 500, a closure holds lines of Swift code. It's different to a function, though, because closures 
 are a data type in their own right: you can pass a closure as a parameter or store it as a 
 property. Closures also capture the environment where they are created, which means they 
 take a copy of the values that are used inside them.
  
 You never 
 need
  to design your own closures so don't be afraid if you find the following quite 
 complicated. However, Cocoa Touch will often ask you to write closures to match its needs, 
 so you at least need to know how they work. Let's take a Cocoa Touch example first:
  
 let vw = UIView() 
 UIView.animateWithDuration(0.5, animations: { 
  vw.alpha = 0 
 }) 
 UIView
  is a data type in UIKit that represents the most basic kind of user interface container. 
  
 Don't worry about what it does for now, all that matters is that it's the basic user interface 
 component. 
 UIView
  has a method called 
 animateWithDuration()
  and it lets you change the 
 way your interface looks using animation – you describe what's changing and over how many 
 seconds, and Cocoa Touch does the rest.
  
 The 
 animateWithDuration()
  method takes two parameters in that code: the number of 
 seconds to animate over, and a closure containing the code to be executed as part of the 
 animation. I've specified half a second as the first parameter, and for the second I've asked 
 UIKit to adjust the view's alpha (that's opacity) to 0, which means ""completely transparent.""
  
 This method needs to use a closure because UIKit has to do all sorts of work to prepare for 
 the animation to begin, so what happens is that UIKIt takes a copy of the code inside the 
  
 www.hackingwithswift.com 
  
 93",NA
Trailing closures ,"As closures are used so frequently, Swift can apply a little syntactic sugar to make your code 
 easier to read. The rule is this: if the last parameter to a method takes a closure, you can 
 eliminate that parameter and instead provide it as a block of code. For example, we could 
 convert the previous code to this:
  
 let vw = UIView() 
 UIView.animateWithDuration(0.5) { 
  vw.alpha = 0 
 } 
 It does make your code shorter and easier to read, so this syntax form – known as trailing 
 closure syntax – is preferred.
  
 www.hackingwithswift.com 
  
 94",NA
Wrap up ,"That's the end of our tour around the Swift programming language. I haven't tried to cover 
 everything in the language, but that's OK because you have all the important stuff, all the 
 sometimes-important stuff, and all the nice-to-know stuff – the interesting-but-rarely-used 
 features you'll either come across in a later project or through extended experience with the 
 language.
  
 If you find yourself a bit confused about how exactly some features are used, don't worry: as 
 soon as you start coding apps with Swift things will start to make a lot more sense!
  
 At this point, you have two options: start on Project 1 of Hacking with Swift, where you make 
 your initial iOS app and recap some of the basic features of Swift, or if you're really 
  
 desperate to learn more about the language I have four articles that teach you 
 the new 
 features of Swift 2.0 by example
 .
  
 www.hackingwithswift.com 
  
 95",NA
Project 1 ,NA,NA
Storm ,NA,NA
Viewer,NA,NA
Get started coding in Swift by making an image viewer ,NA,NA
app and learning key concepts.,NA,NA
Setting up ,"In this project you'll produce an application that lets users scroll through a list of images, 
 then select one to view. It's deliberately simple, because there are many other things you'll 
 need to learn along the way, so strap yourself in – this is going to be long!
  
 Launch Xcode, and choose ""Create a new project"" from the welcome screen. Choose Master-
 Detail Application from the list and click Next. For Product Name enter Project1, then make 
 sure you have Swift selected for language and Universal for devices.
  
  
 Creating a new Master-Detail Application project in Xcode.
  
 One of the fields you'll be asked for is ""Organisation Identifier"", which is a unique identifier 
 usually made up of your personal web site domain name in reverse. For example, I would use 
 com.hackingwithswift
  if I were making an app. You'll need to put something valid in there if 
 you're deploying to devices, but otherwise you can just use 
 com.example
 .
  
 www.hackingwithswift.com 
  
 97",NA
Deleting skeleton code ,"Apple's example contains lots of code we don't need, so let's zap it: select the file 
  
 MasterViewController.swift to open it for editing. Around line 17 you'll see the code starting 
 with 
 override func viewDidLoad() {
 , and there'll be some more lines of code until it reaches 
 a 
 }
  on a line all by itself on line 28. If you're not sure which 
 }
  I mean, it's the one that is aligned 
 directly beneath the first letter in 
 override
 .
  
 No line numbers?
  If your Xcode isn't showing line numbers by default, I suggest you turn 
 them on. Go to the Xcode menu and choose Preferences, then choose the Text Editing tab 
 and make sure ""Line numbers"" is checked.
  
 This block of code is the 
 viewDidLoad()
  method, which is code that gets called when the 
 system has finished creating the screen and is giving you the chance to configure it.
  
 The method starts at the 
 func viewDidLoad() {
  line and ends on the 
 }
  not far below. These 
 symbols, known as 
 braces
  (or sometimes 
 curly brackets
 ) are used to mark chunks of code, 
 and it's convention to indent lines inside braces so that it's easy to identify where code 
 blocks start and end. But enough of the theory: almost everything inside this method is not 
 needed, so delete its contents except for the line 
 super.viewDidLoad()
 .
  
 Note: when I say ""delete its contents"" I mean leave the 
 func viewDidLoad() {
  and 
 }
  intact, 
 but remove everything in between except for that one line. So, it should look like this:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
 } 
 This method does nothing now, but that's OK: we'll be filling it in later.
  
 Next up, look for the 
 insertNewObject()
  method, which starts with 
 func insertNewObject() {
  
 and ends with a closing brace a few lines later. Delete the entire method – yes, even the 
 func 
 insertNewObject(sender: AnyObject) {
  and 
 }
  parts.
  
 These methods start with 
 func
 , which is short for ""function"", which for nearly all intents and 
 purposes is identical to a method in Swift. There is one small exception, but you won't come 
  
 www.hackingwithswift.com 
  
 101",NA
Listing our images ,"The images I've provided you with come from the National Oceanic and Atmospheric 
 Administration (NOAA), which is a US government agency and thus produces public domain 
 content that we can freely reuse. Once they are copied into your project, Xcode will 
 automatically build them into your finished app so that you can access them.
  
 Behind the scenes, an iOS (and OS X) app is actually a directory containing lots of files: the 
 binary itself (that's the compiled version of your code, ready to run), all the media assets your 
 app uses, any visual layout files you have, plus a variety of other things such as metadata and 
 security entitlements.
  
 These app directories are called bundles, and they have the file extension .app. Because our 
 media files are loose inside the folder, we can ask the system to tell us all the files that are in 
 there then pull out the ones we want. You may have noticed that all the images start with the 
 name ""nssl"" (short for National Severe Storms Laboratory), so our task is simple: list all the 
 files in our app's directory, and pull out the ones that start with ""nssl"".
  
 As I said before, the 
 viewDidLoad()
  method starts at 
 func viewDidLoad() {
  and ends at the 
 } 
 a few lines later. We're going to put some more code into that method, just beneath the line 
 that says 
 super.viewDidLoad()
 :
  
 let fm = NSFileManager.defaultManager() 
 let path = NSBundle.mainBundle().resourcePath! 
 let items = try! fm.contentsOfDirectoryAtPath(path) 
 for item in items { 
  if item.hasPrefix(""nssl"") { 
  objects.append(item) 
  } 
 } 
 I already told you that any data types that start with UI belong to Apple's iOS development 
 kit, but that's only partially true. UI stands for User Interface, and so these types primarily 
  
 www.hackingwithswift.com 
  
 105",NA
Introducing Interface Builder ,"As you saw when you first ran the template app, selecting a date brought in a new screen 
 showing the date all by itself. This was all done with a smooth animation from left to right, 
 and included adding a Back button so you can get back to the previous screen. You might 
 also have noticed that you can swipe from the left edge to the right to go back to the table 
 view.
  
 All this behavior was provided for us by two important iOS data types: 
  
 UISplitViewController
  and 
 UINavigationController
 . From those names you can divine two 
 things:
  
 1. The ""UI"" means it's a user interface component designed for iOS. 
 2. The ""Controller"" part means it provides functionality.
  
 Controllers are part of the holy trinity of software development: Model, View, Controller. In an 
 ideal world, every part of your app can be split into one of these three types: it's either a model 
 (something that describes the data you are working with), a view (the user interface of your 
 app), or a controller (the code that sends model data to and from the view).
  
 In reality, things are rarely this clean, and it's extremely common to have a Fat Controller 
 problem: lots of code that ought to be in models and views ends up in your controller. It's not 
 ideal, but you can always go back later and rewrite the code to be neater. (Spoiler: you will 
 never do this.)
  
 Now, you might be thinking that you haven't written any code using split view controllers or 
 navigation controllers, and you'd be right. This is because Apple has a dedicated tool for 
 editing the visual layouts of your apps, and it's called Interface Builder. You'll see the file 
 Main.storyboard in your project, so select that now to show Interface Builder.
  
 Interface Builder (also known as the storyboard editor) is designed to show a visual flow of 
 your program. You will need to zoom out, though: your user interface is surprisingly 
  
 complicated for such a simple app! Hold down Cmd and tap the - key once to zoom out one 
 level. You should now be able to see that there are five squares arranged on the screen: one 
 saying Split View Controller, two saying Navigation Controller, one saying Table View and one 
 saying ""Detail view content goes here.""
  
 www.hackingwithswift.com 
  
 110",NA
Sending new data ,"In making this layout change, we've broken our code – you'll notice there's a red line in the 
 scroll bar of our code editor, and also a red warning symbol at the top of the Xcode window. 
 This is because other parts of DetailViewController.swift reference the 
 UILabel
 , and we've just 
 deleted that property. So we need to make a few changes to this file so that it knows how to 
 handle our new data, then make some final changes to MasterViewController.swift in order to 
 pass the new data correctly.
  
 First, look for this code in DetailViewController.swift:
  
 var detailItem: AnyObject? { 
  didSet { 
  // Update the view. 
  self.configureView() 
  } 
 } 
 This declares a property called 
 detailItem
 , giving it the type 
 AnyObject?
  – that's Swift's way 
 of saying it might be any kind of object, or it might nothing at all. But this property has a twist, 
 because it has a property observer attached, in the form of 
 didSet
 .
  
 The 
 didSet
  property observer is a block of code that will be executed any time this 
  
 property's value has been changed. There's also a corresponding 
 willSet
  property observer 
 that can execute code just before a property is changed, but it's not used as often as 
 didSet
 .
  
 In this code, 
 didSet
  is being used to call 
 self.configureView()
 , which means ""call the 
 configureView()
  method on myself."" The 
 self.
  isn't actually needed, so you can delete it if 
 you want. You might be interested to know that there are two trains of thought with regards 
 to using ""self."" when referring to variables and methods.
  
 The first group of people never like to use 
 self.
  unless it's required, because when it's 
 required it's actually important and meaningful, so using it in places where it isn't required 
 can confuse matters. The other group of people always like to use 
 self.
  whenever it's 
 possible, even when it's not required. To be fair to this group, using 
 self.
  everywhere was 
  
 www.hackingwithswift.com 
  
 125",NA
Final tweaks ,"At this point you have a working project: you can press Cmd+R to run it, flick through the 
 images in the table, then tap one to view it. But before this project is complete, there are two 
 other small changes we're going to make that makes the end result a little more polished.
  
 First, you might have noticed that all the images are being stretched to fill the screen. This 
 isn't an accident – it's the default setting of 
 UIImageView
 . This takes just a few clicks to fix: 
 choose Main.storyboard, select the image view in the detail view controller, then choose the 
 Attributes Inspector. This is in the right-hand pane, near the top, and is the fourth of six 
 inspectors, just to the left of the ruler icon.
  
 If you don't fancy hunting around for it, just press Cmd+Alt+4 to bring it up. The stretching is 
 caused by the view mode, which is a dropdown button that defaults to ""Scale to Fit."" Change 
 that to be ""Aspect Fit,"" and this first problem is solved.
  
  
 The Aspect Fit content mode for UIImageViews forces them to resize their images so they are 
 fully visible.
  
 If you were wondering, Aspect Fit sizes the image so that it's all visible. There's also Aspect 
  
 www.hackingwithswift.com 
  
 131",NA
Wrap up ,"This has been a very simple project in terms of what it can do, but you've also learned a huge 
 amount about Swift, Xcode and storyboards. I know it's not easy, but trust me: you've made it 
 this far, so you're through the hardest part.
  
 To give you an idea of how far you've come, here are just some of the things we've covered: 
 constants and variables, method overrides, table views and image views, app bundles, 
 NSFileManager
 , typecasting, arrays, loops, optionals, view controllers, storyboards, outlets, 
 Auto Layout, 
 UIImage
  and more.
  
 Yes, that's a 
 huge
  amount, and to be brutally honest chances are you'll forget half of it. But 
 that's OK, because we all learn through repetition, and if you continue to follow the rest of 
 this series you'll be using all these and more again and again until you know them like the 
 back of your hand.
  
 If you want to spend a little more time on this app, try investigating the 
 title
  property of your 
 two view controllers. This lets you customise the text that appears in the navigation bar at the 
 top when the view controller is being shown – it's easy to make this show the name of the 
 image that was selected.
  
 www.hackingwithswift.com 
  
 134",NA
Project 2 ,NA,NA
Guess the ,NA,NA
Flag,NA,NA
"Make a game using UIKit, and learn about ",NA,NA
"integers, buttons, colors and actions.",NA,NA
Setting up ,"In this project you'll produce a game that shows some random flags to users and asks them to 
 choose which one belongs to a particular country. After the behemoth that was the 
 introductory project, this one will look quite easy in comparison – you've already learned about 
 things like outlets, image views, arrays and Auto Layout, after all.
  
 (PS: If you skipped project 1 thinking it would all be about history or some other tedium, you 
 were wrong. This project will be very hard if you haven't completed project 1!)
  
 However, one of the keys to learning is to use what you've learned several times over in 
 various ways, so that your new knowledge really sinks in. The purpose of this project is to do 
 exactly that: it's not complicated, it's about giving you the chance to use the things you just 
 learned so that you really start to internalize it all.
  
 So, launch Xcode, and choose ""Create a new project"" from the welcome screen. Choose 
 Single View Application from the list and click Next. For Product Name enter ""Project2"", then 
 make sure you have Swift selected for language and iPhone for devices. Now click Next again 
 and you'll be asked where you want to save the project – your desktop is fine.
  
  
 Creating a new Single View Application in Xcode.
  
 www.hackingwithswift.com 
  
 136",NA
Designing your layout ,"When working on my own projects, I find designing the user interface the easiest way to 
 begin any project – it's fun, it's immediately clear whether your idea is feasible, and it also 
 forces you to think about user journeys while you work. This project isn't complicated, but 
 still Interface Builder is where we're going to begin.
  
 A Single View Application project template gives you one 
 UIViewController
 , called 
  
 ViewController
 , and a storyboard called Main.storyboard that contains the layout for our 
 single view controller. Choose that storyboard now to open Interface Builder, and you'll see a 
 big, blank space ready for your genius to begin.
  
  
 The Single View Application gives you one, large, empty view controller to customize.
  
 In our game, we're going to show users three flags, with the name of the country to guess 
 shown in the navigation bar at the top. What navigation bar? Well, there isn't one, or at least not 
 yet. Single View Application projects don't come with a navigation controller as standard, but it's 
 trivial to add one: click inside the view controller, then go to the Editor menu and choose Embed 
 In > Navigation Controller.
  
 With the new navigation controller in place, scroll so you can see our empty view controller 
  
 www.hackingwithswift.com 
  
 138",NA
Making the basic game work ,"We're going to create an array of strings that will hold all the countries that will be used for our 
 game, and at the same time we're going to create two more properties that will hold the 
 player's current score – it's a game, after all!
  
 Let's start with the new properties. Add these two lines directly beneath the 
 @IBOutlet
  lines 
 you added earlier in ViewController.swift:
  
 var countries = [String]() 
 var score = 0 
 The first line is something you saw in project 1: it creates a new property called 
 countries 
 that 
 will hold a new array of strings. The second one is new, but hopefully it's easy enough to guess: 
 it creates a new property called 
 score
  and gives it the value 0. These two lines ultimately do 
 similar things, but the way they work is different.
  
  • 
 var a = 0
  tells Swift that we want to put the number 0 into 
 score
 . 0 is what's known as an 
 integer (
 Int
  in Swift), which means it's a whole number. 556 is an integer. 100000001 is an 
 integer. 3.14159 is not, because it's not a whole number. By ""whole number"" I mean a number 
 that has nothing after its decimal point, but for the sake of clarity I should add that integers 
 can be negative too.
  
  • 
 var a = [String]()
  This tells Swift that we want to put an array of strings into 
 a
 . The syntax 
 looks a little strange because it both declares what type we want, which is 
 [String]
 , and also 
 creates it: those 
 ()
  literally make this a method call that creates the 
 [String]
  array.
  
 What you're seeing here is called 
 type inference
 . Type inference means that Swift figures out 
 what data type a variable or constant should be based on what you put into it. This means a) 
 you need to put the right thing into your variables otherwise they'll have a different type from 
 what you expect, b) you can't change your mind later and try to put an integer into an array, 
 and c) you only have to give something an explicit type if Swift's inference is wrong.
  
 To get you started, here are some example type inferences:
  
  • 
 var score = 0
  This makes an 
 Int
  (integer), so it holds whole numbers.
  
  • 
 var score = 0.0
  This makes a 
 Double
 , which is one of several ways of holding decimal 
  
 www.hackingwithswift.com 
  
 147",NA
Guess which flag?,"Our current code chooses the first three items in the countries array, and places them into 
 the three buttons on our view controller. This is fine to begin with, but really we need to 
 choose random countries each time. There are two ways of doing this:
  
  • Pick three random numbers, and use those to read the flags from the array. 
 • Shuffle up the order of the array, then pick the first three items.
  
 Both approaches are valid, but the former takes a little more work because we need to 
 ensure that all three numbers are different – it'd be even less fun if all three flags were the 
 French flag!
  
 The second approach is easy to do, but there's a catch: we're going to use a new iOS library 
 called GameplayKit. You see, randomness is a complicated thing, and it's easy to write some 
 code that you think randomises an array perfectly when actually it generates a predictable 
 sequence. As a result, we're going to use a new library in iOS 9 called GameplayKit that does 
 all this hard work for us.
  
 Now, you might think, ""why would I want to use something called GameplayKit for apps?"" But 
 the simple answer is: because it's there, because all devices have it built right in, and because 
 it's available in all your projects, whether games or apps. GameplayKit can do a lot more than 
 just shuffling an array, but we'll get on to that much later.
  
 For now, look at the top of your ViewController.swift file and you'll find a line of code that 
 says 
 import UIKit
 . Just before that, add this new line:
  
 import GameplayKit 
 With that done, we can start using the functionality given to us by GameplayKit. At the start 
 of the 
 askQuestion()
  method, just before you call the first 
 setImage()
  method, add this line 
 of code:
  
 countries =  
 GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(countrie s) as! [String] 
 www.hackingwithswift.com
  
 154",NA
From outlets to actions ,"I said we'd return to Interface Builder, and now the time has come: we're going to connect the 
 ""tap"" action of our 
 UIButtons
  to some code. So, select Main.storyboard, then change to the 
 assistant editor so you can see the code alongside the layout.
  
 Warning:
  please read the following text very carefully. In my haste, I screw this up all the 
 time, and I don't want it to confuse you!
  
 Select the first button, then Ctrl+drag from it down to the space in your code immediately 
 after the end of the 
 askQuestion()
  method. If you're doing it correctly, you should see a 
 tooltip saying, ""Insert Outlet, Action, or Outlet Collection."" When you let go, you'll see the 
 same popup you normally see when creating outlets, but here's the catch: 
 don't choose 
 outlet
 .
  
  
 Creating an action in the Xcode assistant editor is very similar to creating an outlet.
  
 That's right: where it says ""Connection: Outlet"" at the top of the popup, I want you to change 
 that to be Action. If you choose Outlet here (which I do all too often because I'm in a rush), 
  
 www.hackingwithswift.com 
  
 157",NA
Wrap up ,"This is another relatively simple project, but it's given you the chance to go over some 
 concepts in a little more detail, while also cramming in a few more concepts alongside. 
 Going over things again in a different way is always helpful to learning, so I hope you don't 
 view this game (or any of the games we'll make in this series!) as a waste of time.
  
 Yes, in this project we revisited Interface Builder, Auto Layout, outlets and other things, but at 
 the same time you've learned about @2x and @3x images, asset catalogs, integers, doubles, 
 floats, operators (
 +=
  and 
 -=
 ), 
 UIButton
 , enums, 
 CALayer
 , 
 UIColor
 , random numbers, actions, 
 string interpolation, 
 UIAlertController
 , and more. And you have a finished game too!
  
 If you feel like working on this app some more, see if you can figure out how to place a 
 UILabel
  onto the view controller and connect it via an outlet, then show the player's score in 
 there rather than in a 
 UIAlertController
 . You'll need to use your label's 
 text
  property along 
 with string interpolation to make it work. Good luck!
  
 www.hackingwithswift.com 
  
 165",NA
Project 3 ,NA,NA
Social ,NA,NA
Media,NA,NA
Let users share to Facebook and Twitter by ,NA,NA
modifying project 1.,NA,NA
About technique projects ,"As you should know, this series follows the order app, game, technique. Project 1 was an 
 app letting users browse images on their phone, project 2 was a game that lets players 
 guess flags, so now it's time for the first technique project.
  
 The goal with technique projects is to pick out one iOS technology and focus on it in depth. 
 Some will be easy, some others not so much, but I promise to try to keep them as short as 
 possible because I know you want to focus on making real things.
  
 This first technique project is going to be really simple, because we're going to modify 
 project 1 to do something it doesn't currently do: allow users to share images with their 
 friends.
  
 www.hackingwithswift.com 
  
 167",NA
Activity View Controllers ,"Sharing things using iOS uses a standard, powerful component that other apps can plug 
 into. As a result, it should be your first port of call when adding sharing to an app. This 
 component is called 
 UIActivityViewController
 : you tell it what kind of data you want to 
 share, and it figures out how best to share it.
  
 As we're working with images, 
 UIActivityViewController
  will automatically gives us 
 functionality to share by iMessage, by email and by Twitter and Facebook, as well as saving 
 the image to the photo library, assigning it to contact, printing it out via AirPrint, and more. It 
 even hooks into AirDrop and the iOS 8 extensions system so that other apps can read the 
 image straight from us.
  
 Best of all, it takes just a handful of lines of code to make it all work. But before we touch 
 UIActivityViewController
 , we first need to give users a way to trigger sharing, and the way 
 we're going to use is to add a bar button item.
  
 Project 1, if you recall, used a 
 UINavigationController
  to let users move between two 
 screens. By default, a 
 UINavigationController
  has a bar across the top, called a 
  
 UINavigationBar
 , and as developers we can add buttons to this navigation bar that call our 
 methods.
  
 Let's create one of those buttons now. First, take a copy of your existing Project1 folder (the 
 whole thing), and rename it to be Project3. Now launch it in Xcode, open the file 
  
 DetailViewController.swift, and find the 
 viewDidLoad()
  method. It's mostly empty right now – 
 it just calls 
 super.viewDidLoad()
  then 
 configureView()
 . Directly beneath 
 configureView()
 , I 
 want you to add this code:
  
 navigationItem.rightBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Action, target: self, action: ""shareTapped"") 
 This is easily split into two parts: on the left we're assigning to the 
 rightBarButtonItem
  of our 
 view controller's 
 navigationItem
 . This is navigation item is used by the navigation bar so that 
 it can show relevant information. In this case, we're setting the right bar button item, which is a 
 button that appears on the right of the navigation bar when this view controller is visible.
  
 www.hackingwithswift.com 
  
 168",NA
Twitter and Facebook ,"OK, so I would feel guilty if I didn't spend a 
 little
  more time with you showing you other ways to 
 share things, in particular there's built-in support for Facebook and Twitter sharing in iOS and 
 both are quite easy to use.
  
 iOS includes a framework called ""Social"", which is designed to post to social networks like 
 Facebook and Twitter. We can use both of these in our app to share the image the user is 
 looking at, and it has the added benefit that the user is immediately prompted to enter their 
 tweet / Facebook post – there's no initial view controller there asking them how they want to 
 share.
  
 Happily, using the Social framework to post to social media is also straightforward, and has 
 the advantage of simple method calls that are self-describing. In fact, I'm just going to go 
 ahead and show you the code, and see what you think:
  
 let vc = SLComposeViewController(forServiceType: 
 SLServiceTypeFacebook) 
 vc.setInitialText(""Look at this great picture!"") 
 vc.addImage(detailImageView.image!) 
 vc.addURL(NSURL(string: ""http://www.photolib.noaa.gov/nssl"")) 
 presentViewController(vc, animated: true, completion: nil) 
 Apart from the 
 SLComposeViewController
  component, which as you can see is created 
 with the Facebook service type, the only other new thing in there is 
 NSURL
 . This is a new 
 data type, and one that might seem a little redundant at first: it stores and processes URLs 
 like www.yoursite.com.
  
 Now, clearly to you and me a URL is a text string, so it seems strange to have a dedicated 
 class when a plain old string would do. However, iOS uses URLs for more things than just 
 websites. For example, you can get a file URL to a local file, or you can get a URL to a 
 document securely stored in iCloud. And even if it were just about website URLs, even then 
 there's things like ""is it HTTP or HTTPS?"" and ""is there a username and password in the 
 URL?""
  
 We're going to use 
 NSURL
  again in the next project, but right now its use is quite simple: 
  
 www.hackingwithswift.com 
  
 172",NA
Wrap up ,"This was a deliberately short technique project taking an existing app and making it better. I 
 hope you didn't get too bored, and hope even more that some of the new material sunk in 
 because we covered 
 UIBarButtonItem
 , 
 UIActivityViewController
 , the Social framework, 
 and 
 NSURL
 .
  
 I hope you can see how trivial it is to add social media to your apps, and it can make a huge 
 difference to helping spread the word about your work once your apps are on the App Store. 
  
 I hope this project has also shown you how easy it is to go back to previous projects and 
 improve them with only a little extra effort.
  
 www.hackingwithswift.com 
  
 175",NA
Project 4 ,NA,NA
Easy ,NA,NA
Browser,NA,NA
"Embed Web Kit and learn about delegation, KVO, ",NA,NA
classes and UIToolbar.,NA,NA
Setting up ,"In this project you're going to build on your new knowledge of 
 UIBarButtonItem
 , 
  
 UIAlertController
  and 
 NSURL
  by producing a simple web browser app. Yes, I realise this is 
 another easy project, but learning is as much about tackling new challenges as going over 
 what you've already learned.
  
 To sweeten the deal, I'm going to use this opportunity to teach you lots of new things: 
 WKWebView
  (Apple's extraordinary web widget), 
 UIToolbar
  (a toolbar component that holds 
 UIBarButtonItem
 s), 
 UIProgessView
 , delegation, classes and structs, key-value observing, 
 and how to create your views in code. Plus, this is the last easy app project, so enjoy it while it 
 lasts!
  
 To get started, create a new Xcode project using the Single View Application template, and 
 call it Project4. Choose iPhone for the device, and make sure Swift is selected for the 
 language, then save the project on your desktop. Open up Main.storyboard, select the view 
 controller, and choose Editor > Embed In > Navigation Controller – that's our storyboard 
 finished.
  
 www.hackingwithswift.com 
  
 177",NA
Creating a simple browser ,"In projects 1 and 2, we used Interface Builder for a lot of layout work, but here our layout will be 
 so simple we can do the entire thing in code. You see, before we were adding buttons and 
 images to our view, but in this project the web view is going to take up all the space so it might 
 as well 
 be
  the view controller's main view.
  
 So far, we've been using the 
 viewDidLoad()
  method to configure our view once its layout has 
 loaded. This time we need to override the actual loading of the view – we don't want that empty 
 thing on the storyboard, we want our own code. It will still be placed inside the navigation 
 controller, but the rest is up to us.
  
 Open ViewController.swift for editing, and 
 before
 viewDidLoad()
  put this:
  
 override func loadView() { 
  webView = WKWebView() 
  webView.navigationDelegate = self 
  view = webView 
 } 
 It isn't at all necessary to put 
 loadView()
  before 
 viewDidLoad()
  – you could put it anywhere 
 between 
 class ViewController: UIViewController {
  down to the last closing brace in the file. 
  
 But I do encourage you to structure your methods in an organised way, and because 
 loadView()
  gets called before 
 viewDidLoad()
  it makes sense to position the code above it 
 too.
  
 Anyway, there are only three things we care about, because by now you should understand 
 why we need to use the 
 override
  keyword. (Hint: it's because there's a default 
  
 implementation, which is to load the layout from the storyboard!) First, we create a new 
 instance of Apple's 
 WKWebView
  web browser component and assign it to a variable called 
 webView
 . Third, we make our view (the root view of the view controller) that web view.
  
 Yes, I missed out the second line, and that's because it introduces new concept: delegation. 
  
 Delegation is what's called a 
 programming pattern
  – a way of writing code – and it's used 
 extensively in iOS. And for good reason: it's easy to understand, easy to use, and extremely 
  
 www.hackingwithswift.com 
  
 178",NA
Choosing a website ,"We're going to lock this app down so that it opens websites selected by the user. The first 
 step to doing this is to give the user the option to choose from one of our selected websites, 
 and that means adding a button to the navigation bar.
  
 Somewhere in 
 viewDidLoad()
  (but always after it has called 
 super.viewDidLoad()
 ), add this:
  
 navigationItem.rightBarButtonItem = UIBarButtonItem(title: ""Open"", style: .Plain, target: self, 
 action: ""openTapped"") 
 We did exactly this in the previous project, except here we're using a custom title for our bar 
 button rather than a system icon. It called the 
 openTapped()
  method, which doesn't exist, 
 when the button is tapped, so let's add that now. Put this method below 
 viewDidLoad()
 :
  
 func openTapped() { 
  let ac = UIAlertController(title: ""Open page…"", message: nil, preferredStyle: .ActionSheet) 
  ac.addAction(UIAlertAction(title: ""apple.com"", style: .Default, handler: openPage)) 
  ac.addAction(UIAlertAction(title: ""hackingwithswift.com"", style: .Default, handler: 
 openPage)) 
  ac.addAction(UIAlertAction(title: ""Cancel"", style: .Cancel, handler: nil)) 
  presentViewController(ac, animated: true, completion: nil) 
 } 
 Warning:
  if you did 
 not
  set your app to be targeted for iPhone at the beginning of this chapter, 
 the above code will not work correctly. Yes, I know I told you to set iPhone, but a lot of people 
 skip over things in their rush to get ahead. If you chose iPad or Universal, you will need to add 
 ac.popoverPresentationController?.barButtonItem = 
  
 self.navigationItem.rightBarButtonItem
  to the 
 openTapped()
  method before presenting the 
 alert controller.
  
 www.hackingwithswift.com 
  
 184",NA
Monitoring page loads ,"Now is a great time to meet two new 
 UIView
  subclasses: 
 UIToolbar
  and 
 UIProgressView
 . 
 UIToolbar
  holds and shows a collection of 
 UIBarButtonItem
  objects that the user can tap on. 
 We already saw how each view controller has a 
 rightBarButton
  item, so a 
 UIToolbar
  is like 
 having a whole bar of these items. 
 UIProgressView
  is a colored bar that shows how far a 
 task is through its work, sometimes called a ""progress bar.""
  
 The way we're going to use 
 UIToolbar
  is quite simple: all view controllers automatically come 
 with a 
 toolbarItems
  array that automatically gets read in when the view controller is active 
 inside a 
 UINavigationController
 .
  
 This is very similar to the way 
 rightBarButtonItem
  is shown only when the view controller is 
 active. All we need to do is set the array, then tell our navigation controller to show its toolbar, 
 and it will do the rest of the work for us.
  
 We're going to create two 
 UIBarButtonItems
  at first, although one is special because it's a 
 flexible space. This is a unique 
 UIBarButtonItem
  type that acts like a spring, pushing other 
 buttons to one side until all the space is used.
  
 In 
 viewDidLoad()
 , put this new code directly below where we set the 
 rightBarButtonItem
 :
  
 let spacer = UIBarButtonItem(barButtonSystemItem: .FlexibleSpace, target: nil, action: nil) 
 let refresh = UIBarButtonItem(barButtonSystemItem: .Refresh, target: self, action: 
 ""refreshTapped"") 
 toolbarItems = [spacer, refresh] 
 navigationController?.toolbarHidden = false 
 The first line is new, or at least part of it is: we're creating a new bar button item using the 
 special system item type 
 .FlexibleSpace
 , which creates a flexible space. It doesn't need a 
 target or action because it can't be tapped. The second line you've seen before, although 
 now we're calling the 
 refreshTapped()
  method.
  
 The last two lines are new: the first puts an array containing the flexible space and the refresh 
  
 www.hackingwithswift.com 
  
 188",NA
Refactoring for the win ,"Our app has a fatal flaw, and there are two ways to fix it: double up on code, or refactor. 
 Cunningly, the first option is nearly always the easiest, and yet counter-intuitively also the 
 hardest.
  
 The flaw is this: we let users select from a list of websites, but once they are on that website 
 they can get pretty much anywhere else they want just by following links. Wouldn't it be nice if 
 we could check every link that was followed so that we can make sure it's on our safe list?
  
 One solution – doubling up on code – would have us writing the list of accessible websites 
 twice: once in the 
 UIAlertController
  and once when we're checking the link. This is 
  
 extremely easy to write, but it can be a trap: you now have two lists of websites, and it's down 
 to you to keep them both up to date. And if you find a bug in your duplicated code, will you 
 remember to fix it in the other place too?
  
 The second solution is called refactoring, and it's effectively a rewrite of the code. The end 
 result should do the same thing, though. The purpose of the rewrite is to make it more 
 efficient, make it easier to read, reduce its complexity, and to make it more flexible. This last 
 use is what we'll be shooting for: we want to refactor our code so there's a shared array of 
 allowed websites.
  
 Up where we declared our two properties 
 webView
  and 
 progressView
 , add this:
  
 var websites = [""apple.com"", ""hackingwithswift.com""] 
 That's an array containing the websites we want the user to be able to visit.
  
 With that array, we can modify the web view's initial web page so that it's not hard-coded. In 
 viewDidLoad()
 , change the initial web page to this:
  
 let url = NSURL(string: ""https://"" + websites[0])! 
 webView.loadRequest(NSURLRequest(URL: url)) 
 www.hackingwithswift.com
  
 194",NA
Wrap up ,"Another project done, another huge pile of things learned. You should be starting to get into 
 the swing of things by now, but don't let yourself become immune to your success. In this 
 tutorial alone you've learned about 
 loadView()
 , 
 WKWebView
 , delegation, classes and structs, 
 NSURLRequest
 , 
 UIToolbar
 , 
 UIProgressView
 , KVO and more, so you should be proud of 
 your fantastic accomplishments!
  
 There is a lot of scope for improvement with this project, so where you start is down to you. I 
 would suggest at the very least that you investigate changing the initial view controller to a 
 table view like in project 1, where users can go choose their website from a list rather than just 
 having the first in the array loaded up front.
  
 Once you have completed project 5, you might like to return here to add in the option to load 
 the list of websites from a file, rather than having them hard-coded in an array.
  
 www.hackingwithswift.com 
  
 198",NA
Project 5 ,NA,NA
Word ,NA,NA
Scramble,NA,NA
Create an anagram game while learning about ,NA,NA
closures and booleans.,NA,NA
Setting up ,"Projects 1 to 4 were all fairly easy, because my goal was to teach you as much about Swift 
 without scaring you away, while also trying to make something useful. But now that you're 
 hopefully starting to become familiar with the core tools of iOS development, it's time to 
 change up a gear and tackle something a bit meatier.
  
 In this project you're going to learn how to make a word game that deals with anagrams, but as 
 per usual I'll be hijacking it as a method to teach you more about iOS development. This time 
 around we're going back to the table views as seen in project 1, but you're also going to learn 
 how to load text from files, how to ask for user input in 
 UIAlertController
 , and get a little more 
 insight to how closures work.
  
 In Xcode, create a new Master-Detail Application called Project5. Select iPhone for your 
 target, then click Next to save it somewhere. Right-click on DetailViewController.swift in the 
 project navigator (the pane on the left showing all your files; Cmd+1 shows it), then choose 
 Delete and click ""Move to Trash"" when prompted.
  
 Doing this will cause quite a few errors to appear in your project, but it's easily fixed – we just 
 need to delete quite a bit of Apple's template! First, open the AppDelegate.swift file, and look 
 for this code near the top of the file:
  
 func application(application: UIApplication,  
 didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { 
  // Override point for customization after application launch. 
  let splitViewController = self.window!.rootViewController as! UISplitViewController 
  let navigationController =  
 splitViewController.viewControllers[splitViewController.viewControlle rs.count-1] as! 
 UINavigationController 
 navigationController.topViewController!.navigationItem.leftBarButtonI tem = 
 splitViewController.displayModeButtonItem() 
  splitViewController.delegate = self 
  return true 
 } 
 www.hackingwithswift.com
  
 200",NA
Reading from disk ,"We're going to make an anagram game, where the user is asked to make words out of a 
 larger word. We're going to put together a list of possible starter words for the game, and 
 that list will be stored in a separate file. But how we get the text from the file into the app? 
 Well, it turns out that Swift's 
 String
  data type makes it a cinch – thanks, Apple!
  
 If you haven't already downloaded the assets for this project from 
 hackingwithswift.com
 , 
 please do so now. In the Content folder you'll find the file start.txt. Please drag that into your 
 Xcode project, making sure that ""Copy items if needed"" is checked.
  
 The start.txt file contains over 12,000 eight-letter words we can use for our game, all stored 
 one word per line. We need to turn that into an array of words we can play with. Behind the 
 scenes, those line breaks are marked with a special line break character that is usually 
 expressed as ""\n"". So, we need to load that word list into a string, then split it into an array by 
 breaking up wherever we see 
 \n
 .
  
 First, go to the start of your class and make a new array. There will be an existing one there 
 from Apple's template, so put this alongside:
  
 var allWords = [String]() 
 While you're there, you might as well change Apple's array to be 
 [String]
  rather than 
 [AnyObject]
 , because we'll only ever be storing strings in there. You'll need to adjust the 
 table view's 
 cellForRowAtIndexPath
  method from this:
  
 let object = objects[indexPath.row] as NSDate 
 cell.textLabel!.text = object.description 
 …to this:
  
 let object = objects[indexPath.row] 
 cell.textLabel!.text = object 
 www.hackingwithswift.com
  
 204",NA
"Pick a word, any word ","This game will prompt the user to enter a word that can be made from the eight-letter prompt 
 word. For example, if the eight-letter word is ""agencies"", the user could enter ""cease."" We're 
 going to solve this with 
 UIAlertController
 , because it's a nice fit, and also gives me the chance 
 to introduce some new teaching. I'm all about ulterior motives!
  
 Add this code to 
 viewDidLoad()
 , just after the call to 
 super
 :
  
 navigationItem.rightBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""promptForAnswer"") 
 That creates a new UIBarButtonItem using the ""add"" system item, and configured it to run a 
 method called 
 promptForAnswer()
  when tapped. This method is going to show a 
  
 UIAlertController
  with space for the user to enter an answer, and when the user clicks 
 Submit to that alert controller the answer is checked to make sure it's valid.
  
 Before I give you the code, let me explain what you need to know.
  
 You see, we're about to use a closure, and things get a little complicated. As a reminder, 
 these are chunks of code that can be treated like a variable – we can send the closure 
 somewhere, where it gets stored away and executed later. To make this work, Swift takes a 
 copy of the code and captures any objects it references, so it can use them later.
  
 But there's a problem: what if the closure references the view controller? Then what could 
 happen is a strong reference cycle: the view controller owns an object that owns a closure 
 that owns the view controller, and nothing could ever be destroyed.
  
 I'm going to try (and likely fail!) to give you a metaphorical example, so please bear with me. 
  
 Imagine if you built two cleaning robots, red and blue. You told the red robot, ""don't stop 
 cleaning until the blue robot stops,"" and you told the blue robot ""don't stop cleaning until the 
 red robot stops."" When would they stop cleaning? Never, because neither will make the first 
 move.
  
 This is the problem we are facing with a strong reference cycle: object A owns object B, and 
 object B owns a closure that referenced object A. And when closures are created, they 
  
 www.hackingwithswift.com 
  
 209",NA
Prepare for submission ,"OK, you can breathe again: we're done with closures for now. I know that wasn't easy, but 
 once you understand basic closures you really have come a long in your Swift adventure.
  
 We're going to do some much easier coding now, because believe it or not we're not that far 
 from making this game actually work!
  
 First, let's make your code compile again, because right now it's calling 
 self.submitAnswer() 
 and we haven't made that method yet. So, add this new method somewhere in the class:
  
 func submitAnswer(answer: String) { 
 } 
 That's right, it's empty – it's enough to make the code compile cleanly so we can carry on.
  
 We have now gone over the structure of a closure: trailing closure syntax, unowned self, a 
 parameter being passed in, then the need for 
 self.
  to make capturing clear. We haven't really 
 talked about the actual content of our closure, because there isn't a lot to it:
  
 let answer = ac.textFields![0] 
 self.submitAnswer(answer.text!) 
 The first line force unwraps the array of text fields (it's optional because there might not be 
 any; we can force unwrap because we know we added one), then tells Swift to treat it as a 
 UITextField
 . The second line pulls out the text from the text field and passes it to our (all-
 new-albeit-empty) 
 submitAnswer()
  method.
  
 This method needs to check whether the player's word can be made from the given letters. It 
 needs to check whether the word has been used already, because obviously we don't want 
 duplicate words. It also needs to check whether the word is actually a valid English word, 
 because otherwise the user can just type in nonsense.
  
 If all three of those checks pass, 
 submitAnswer()
  needs to add the word to the 
 objects
  
 www.hackingwithswift.com 
  
 216",NA
Returning values ,"None of our custom methods have returned values so far. We used the 
 return
  keyword 
 briefly in project 4 to exit the web view's 
 decidePolicyForNavigationAction
  method early, 
 but it didn't send any data back. So, let's take things another step forward.
  
 As I said, the 
 return
  keyword exits a method at any time it's used. If you use 
 return
  by itself, it 
 exits the method and does nothing else. But if you use 
 return
  with a value, it sends that value 
 back to whatever called the method.
  
 Before you can send a value back, you need to tell Swift that you expect to return a value. Swift 
 will automatically check that a value is returned and it's of the right data type, so this is 
 important. We just put in stubs (empty methods that do nothing) for three new methods, each of 
 which returns a value. Let's take a look at one in more detail:
  
 func wordIsOriginal(word: String) -> Bool { 
  return true 
 } 
 The method is called 
 wordIsOriginal()
 , and it takes one parameter that's a string. But before 
 the opening brace there's something new: 
 -> Bool
 . This tells Swift that the method will return a 
 boolean value, which is the name for a value that can be either true or false.
  
 The body of the method has just one line of code: 
 return true
 . This is how the 
 return 
 statement 
 is used to send a value back to its caller: we're returning true from this method, so the caller 
 can use this method inside an 
 if
  statement to check for true or false.
  
 This method can have as much code as it needs in order to evaluate fully whether the word 
 has been used or not, including calling any other methods it needs. We're going to change it 
 so that it calls another method, which will check whether our 
 objects
  array already contains 
 the word that was provided. Replace its current 
 return true
  code with this:
  
 return !objects.contains(word) 
 www.hackingwithswift.com
  
 220",NA
Or else what?,"There remains one problem to fix with our code, and it's quite a tedious problem. If the word is 
 possible and original and real, we add it to the list of found words then insert it into the table 
 view. But what if the word isn't possible? Or if it's possible but not original? In this case, we 
 reject the word and don't say why, so the user gets no feedback.
  
 So, the final part of our project is to give users feedback when they make an invalid move. 
 This is tedious because it's just adding 
 else
  statements to all the 
 if
  statements in 
  
 submitAnswer()
 , each time configuring a message to show to users.
  
 Here's the adjusted method:
  
 func submitAnswer(answer: String) { 
  let lowerAnswer = answer.lowercaseString 
  let errorTitle: String 
  let errorMessage: String 
  if wordIsPossible(lowerAnswer) { 
  
  if wordIsOriginal(lowerAnswer) { 
  
  
  if wordIsReal(lowerAnswer) { 
  
  
  
  objects.insert(answer, atIndex: 0) 
  
  let indexPath = NSIndexPath(forRow: 0, inSection: 0) 
  
 tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) 
  
  
  return 
  
  } else { 
  
  
  errorTitle = ""Word not recognised"" 
  
  
  errorMessage = ""You can't just make them up, you know!"" 
  } 
  } else { 
 www.hackingwithswift.com 
  
 225",NA
Wrap up ,"You've made it this far, so your Swift learning really is starting to come together, and I hope 
 this project has shown you that you can make some pretty advanced things with your 
 knowledge.
  
 In this project, you learned a little bit more about 
 UITableView
 : how to reload their data and 
 how to insert rows. You also learned how to add text fields to 
 UIAlertController
  so that you 
 can accept user input. But you also learned some serious core stuff: more about Swift strings, 
 closures, method return values, booleans, 
 NSRange
 , and more. These are things you're 
 going to use in dozens of projects over your Swift coding career, and things we'll be returning 
 to again and again in this series.
  
 You may already have plans for how you'd like to improve this game, but if not here are four 
 ideas to get you started:
  
 1. Disallow answers that are shorter than three letters. The easiest way to accomplish this is 
 to put a check into 
 wordIsReal()
  that returns false if the word length is under three letters.
  
 2. Refactor all the 
 else
  statements we just added so that they call a new method called 
 showErrorMessage()
 . This should accept an error message and a title, and do all the 
 UIAlertController
  work from there.
  
 3. Disallow answers that are just the start word. Right now, if the start word is ""agencies"" the 
 user can just submit ""agencies"" as an answer, which is too easy – stop them from doing that.
  
 4. Fix our start.txt loading code. If we the 
 pathForResource()
  call returns 
 nil
  we load an array 
 containing one word: silkworm. But what if 
 pathForResource()
  succeeds, but creating an 
 NSString
  using 
 contentsOfFile
  fails? Then the array is empty! Make a new 
  
 loadDefaultWords()
  method that can be used for both failures.
  
 www.hackingwithswift.com 
  
 228",NA
Project 6 ,NA,NA
Auto ,NA,NA
Layout,NA,NA
Get to grips with Auto Layout using practical examples ,NA,NA
and code.,NA,NA
Setting up ,"In this technique project you're going to learn more about Auto Layout, the powerful and 
 expressive way iOS lets you design your layouts. We used it in project 2 to make sure our 
 flag buttons were positioned correctly, but that project has a problem: if you rotate your 
 device, the flags don't fit on the screen!
  
 So, we're first going to fix project 2 so that it demonstrates more advanced Auto Layout 
 techniques (while also making the flags stay on the screen correctly!), then take a look at 
 ways you can use Auto Layout in code.
  
 First: take a copy of project 2, call it project6a, then open it in Xcode. All set? Then let's 
 begin…
  
 www.hackingwithswift.com 
  
 230",NA
Advanced Auto Layout ,"When you run the project, it looks fine in portrait, but is unplayable on landscape because 
 some of the buttons are hidden. You have two options: either disable landscape mode, or 
 make your layout work across both orientations.
  
 Disabling orientations isn't a great solution, but sometimes it's the 
 right
  solution. Most games, 
 for example, fix their orientation because it just doesn't make sense to support both. If you 
 want to do this, press Cmd+1 to show the project navigator on the left of your Xcode window, 
 select your project (it's the first item in the pane), then to the right of where you just clicked will 
 appear another pane showing ""PROJECT"" and ""TARGETS"", along with some more 
 information in the center.
  
 Please note:
  This project and targets list can be hidden by clicking the disclosure button in 
 the top-left of the project editor (directly beneath the icon with four squares), and you may 
 find yours is already hidden. I strongly recommend you show this list – hiding it will only 
 make things harder to find, so please make sure it's visible!
  
 In the picture below you can see the project editor, with the device orientations at the bottom. 
 This is the collapsed view of projects and targets, so there's a dropdown arrow at the top that 
 says ""Project2"" (just above where it says Identity in bold), and to the left of that is the button to 
 show the projects and targets list.
  
 www.hackingwithswift.com 
  
 231",NA
Auto Layout in code ,"Create a new Single View Application project in Xcode, name it Project6b and set its target to 
 be iPhone. We're going to create some views by hand, then position them using Auto Layout. 
  
 Put this into your 
 viewDidLoad()
  method:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
  let label1 = UILabel() 
  label1.translatesAutoresizingMaskIntoConstraints = false 
 label1.backgroundColor = UIColor.redColor() 
  label1.text = ""THESE"" 
  let label2 = UILabel() 
  label2.translatesAutoresizingMaskIntoConstraints = false 
 label2.backgroundColor = UIColor.cyanColor() 
  label2.text = ""ARE"" 
  let label3 = UILabel() 
  label3.translatesAutoresizingMaskIntoConstraints = false 
 label3.backgroundColor = UIColor.yellowColor() 
  label3.text = ""SOME"" 
  let label4 = UILabel() 
  label4.translatesAutoresizingMaskIntoConstraints = false 
 label4.backgroundColor = UIColor.greenColor() 
  label4.text = ""AWESOME"" 
  let label5 = UILabel() 
  label5.translatesAutoresizingMaskIntoConstraints = false 
 label5.backgroundColor = UIColor.orangeColor() 
 www.hackingwithswift.com 
  
 235",NA
"Sizes, metrics and priorities ","We have a working layout now, but it's quite basic: the labels aren't very high, and without a 
 rule regarding the bottom of the last label it's possible the views might be pushed off the 
 bottom edge.
  
 To begin to fix this problem, we're going to add a constraint for the bottom edge saying that 
 the bottom of our last label must be at least 10 points away from the bottom of the view 
 controller's view. We're also going to tell Auto Layout that we want each of the five labels to 
 be 88 points high. Replace the previous vertical constraints with this:
  
 view.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat(""V :|[label1(==88)]-
 [label2(==88)]-[label3(==88)]-[label4(==88)]- 
 [label5(==88)]-(>=10)-|"", options: [], metrics: nil, views:  
 viewsDictionary)) 
 The difference here is that we now have numbers inside parentheses: 
 (==88)
  for the labels, 
 and 
 (>=10)
  for the space to the bottom. Note that when specifying the size of a space, you 
 need to use the - before and after the size: a simple space, -, becomes 
 -(>=10)-
 .
  
 We are specifying two kinds of size here: 
 ==
  and 
 >=
 . The first means ""exactly equal"" and the 
 second ""greater than or equal to."" So, our labels will be forced to be an exact size, and we 
 ensure that there's some space at the bottom while also making it flexible – it will definitely be 
 at least 10 points, but could be 100 or more depending on the situation.
  
 Actually, wait a minute. I didn't want 88 points for the label size, I meant 80 points. Go ahead 
 and change all the labels to 80 points high.
  
 Whoa there! It looks like you just received an email from your IT director: he thinks 80 points 
 is a silly size for the labels; they need to be 64 points, because all good sizes are a power of 
 2.
  
 And now it looks like your designer and IT director are having a fight about the right size. A 
 few punches later, they decide to split the difference and go for a number in the middle: 72. 
 So please go ahead and make the labels all 72 points high.
  
 Bored yet? You ought to be. And yet this is the kind of pixel-pushing it's easy to fall into, 
  
 www.hackingwithswift.com 
  
 240",NA
Wrap up ,"There are two types of iOS developer in the world: those who use Auto Layout, and fools. It 
 has bit of a steep learning curve (and we didn't even use the hard way of adding 
  
 constraints!), but it's an extremely expressive way of creating great layouts that adapt 
 themselves automatically to whatever device they find themselves running on – now and in 
 the future.
  
 Most people recommend you do as much as you can inside Interface Builder, and with good 
 reason – you can drag lines about until you're happy, you get an instant preview of how it all 
 looks, and it will warn you if there's a problem (and help you fix it.) But, as you've seen, 
 creating constraints in code is remarkably easy thanks to the Visual Format language, so you 
 might find yourself mixing the two to get the best results.
  
 www.hackingwithswift.com 
  
 243",NA
Project 7 ,NA,NA
Whitehouse ,NA,NA
Petitions,NA,NA
Make an app to parse Whitehouse petitions using ,NA,NA
JSON and a tab bar.,NA,NA
Setting up ,"This project will take a data feed from a website and parse it into useful information for users. 
 As per usual, this is just a way of teaching you some new iOS development techniques, but let's 
 face it – you already have two apps and two games under your belt, so you're starting to build 
 up a pretty good library of work!
  
 This time, you'll be learning about 
 UITabBarController
 , 
 NSData
 , and more. You'll also be 
 using a data format called JSON, which is a popular way to send and receive data online. It's 
 not easy to find interesting JSON feeds that are freely available, but the option we'll be going for 
 is the ""We the people"" Whitehouse petitions in the US, where Americans can submit requests 
 for action, and others can vote on it.
  
 Some are entirely frivolous (""We want the US to build a Death Star""), but it has good, clean 
 JSON that's open for everyone to read, which makes it perfect. Lots to learn, and lots to do, 
 so let's get started: create a new project in Xcode by choosing the Master-Detail Application 
 template. Now name it Project7, set its target to be iPad, and save it somewhere.
  
 www.hackingwithswift.com 
  
 245",NA
Creating the basic UI ,"The Master-Detail application template gives us a lot of stuff we don't need, but rather than 
 delete it we're just going to modify it as needed. For the user interface we need to make only a 
 handful of changes, so please open Main.storyboard in Interface Builder.
  
 In your storyboard, you'll see there are two navigation controllers: one at the top that connects 
 to a table view on its right, and another at the bottom that connects to a view saying ""Detail 
 view content goes here"" on its right. Choose the top one, then choose Editor > Embed In > Tab 
 Bar Controller. Like 
 UINavigationController
 , 
 UITabBarController
  is a common element in iOS 
 user interface design. A tab bar is that strip of icons across the bottom that shows various 
 screens, and it appears in the App Store, in the music app, in the phone app, and more.
  
  
 Interface Builder can embed a view controller directly inside a tab bar controller with one menu 
 click.
  
 Behind the scenes, 
 UITabBarController
  manages an array of view controllers that the user 
 can choose between. You can do often do most of the work inside Interface Builder, but not in 
 this project. We're going to use one tab to show recent petitions, and another to show 
  
 www.hackingwithswift.com 
  
 246",NA
Parsing JSON ,"JSON – short for JavaScript Object Notation – is a way of describing data. It's not the easiest to 
 read yourself, but it's compact and easy to parse for computers, which makes it popular online 
 where bandwidth is at a premium.
  
 In project 6 you learned about using dictionaries with Auto Layout, and in this project we're 
 going to use dictionaries more extensively. What's more, we're going to put dictionaries 
 inside an array to make an array of dictionaries, which should keep our data in order.
  
 You declare a dictionary using square brackets, then entering its key type, a colon, and its 
 value type. For example, a dictionary that used strings for its keys and 
 UILabel
 s for its values 
 would be declared like this:
  
 var labels = [String: UILabel]() 
 And as you'll recall, you declare arrays just by putting the data type in brackets, like this:
  
 var strings = [String]() 
 Putting these two together, we want to make an array of dictionaries, with each dictionary 
 holding a string for its key and another string for its value. So, it looks like this:
  
 var objects = [[String: String]]() 
 Put that in place of the current 
 objects
  definition at the top of MasterViewController.swift – it 
 holds 
 AnyObject
  right now, which won't do the job.
  
 It's now time to parse some JSON, which means to process it and examine its contents. This 
 isn't easy in Swift, so a number of helper libraries have appeared that do a lot of the heavy 
 lifting for you. We're going to use one of them now: download the files for this project from 
 GitHub
  then look for a file called SwiftyJSON.swift. Add that your project, making sure ""Copy 
  
 www.hackingwithswift.com 
  
 250",NA
Rendering a petition ,"After all the JSON parsing, it's time for something easy: we need to update the 
  
 DetailViewController
  class so that it can draw the petition content in a nice way. The easiest 
 way for rendering complex content from the web is nearly always to use a 
 WKWebView
 , and 
 we're going to use the same technique from project 4 to modify 
 DetailViewController
  so it has 
 a web view.
  
 Replace 
 all
  the 
 DetailViewController
  code with this:
  
 import UIKit  
 import WebKit 
 class DetailViewController: UIViewController { var webView: 
 WKWebView! 
  var detailItem: [String: String]! 
  override func loadView() { 
  
  webView = WKWebView() 
  
  view = webView 
  } 
  override func viewDidLoad() { 
   super.viewDidLoad() 
  }  
 } 
 This is almost identical to the code from project 4, but you'll notice I've added a 
 detailItem 
 property that will contains our dictionary of data.
  
 That was the easy bit. The hard bit is that we can't just drop the petition text into the web view, 
 because it will probably look tiny. Instead, we need to wrap it in some HTML, which is a 
  
 www.hackingwithswift.com 
  
 259",NA
Finishing touches ,"Before this project is finished, we're going to make two changes. First, we're going to add 
 another tab to the 
 UITabBarController
  that will show popular petitions, and second we're 
 going to make our 
 NSData
  loading code a little more resilient by adding error messages.
  
 As I said previously, we can't really put the second tab into our storyboard because both tabs 
 will host a 
 MasterViewController
  and doing so would require me to duplicate the view 
 controllers in the storyboard. You can do that if you want, but please don't – it's a 
  
 maintenance nightmare!
  
 Instead, we're going to leave our current storyboard configuration alone, then create the 
 second view controller using code. This isn't something you've done before, but it's not hard 
 and we already took the first step, as you'll see.
  
 Open the file AppDelegate.swift. This has been in all our projects so far, but it's not one 
 we've had to work with until now. Look for the 
 didFinishLaunching
  method, which should 
 be at the top of the file. This gets called by iOS when the app is ready to be run, and we're 
 going to hijack it to insert a second 
 MasterViewController
  into our tab bar.
  
 It should already have some default Apple code in there, but we're going to add some more 
 just before the 
 return true
  line:
  
 let tabBarController = splitViewController.viewControllers[0] as! UITabBarController 
 let storyboard = UIStoryboard(name: ""Main"", bundle: nil) 
 let vc =  
 storyboard.instantiateViewControllerWithIdentifier(""NavController"") as! 
 UINavigationController 
 vc.tabBarItem = UITabBarItem(tabBarSystemItem: .TopRated, tag: 1) 
 tabBarController.viewControllers?.append(vc) 
 Every line of that is new, so let's dig in deeper:
  
 www.hackingwithswift.com 
  
 262",NA
Wrap up ,"As your Swift skill increases, I hope you're starting to feel the balance of these projects move 
 away from explaining the basics and toward presenting and dissecting code. Working with 
 JSON is something you're going to be doing time and time again in your Swift career, and 
 you've cracked it in about an hour of work – while also learning about 
 NSData
 , 
  
 UITabBarController
 , and more. Not bad!
  
 If you're looking to extend this project some more, you might like to look at the original API 
 documentation – it's at 
 https://petitions.whitehouse.gov/developers
  and contains lots of 
 options. If you add more view controllers to the tab bar, you'll find you can add up to five 
 before you start seeing a ""More"" button. This More tab hides all the view controllers that 
 don't fit into the tab bar, and it's handled for you automatically by iOS.
  
 www.hackingwithswift.com 
  
 266",NA
Project 8 ,NA,NA
7 Swifty ,NA,NA
Words,NA,NA
Build a word-guessing game and master strings once ,NA,NA
and for all.,NA,NA
Setting up ,"This is the final game you'll be making with UIKit; every game after this one will use Apple's 
 SpriteKit library for high-performance 2D drawing. To make this last UIKit effort count, we're 
 going to have a fairly complicated user interface so you can go out with a bang. We're also 
 going to mix in some great new Swift techniques, including property observers, searching 
 through arrays, modulo, array enumeration, ranges and more!
  
 Of course, you're probably wondering what kind of game we're going to make, and I have some 
 bad news for you: it's another word game. But there's good news too: it's a pretty darn 
 awesome word game, based on the popular indie game 7 Little Words. This will also be our first 
 game exclusively targeting iPad, and you'll soon see why – we're using a lot of space in our 
 user interface!
  
 So, go ahead and create a new Single View Application project in Xcode, this time selecting 
 iPad for your device, then save it somewhere. Now go to the project editor and deselect 
 Portrait and Upside Down orientations.
  
 What's that? You don't know where the project editor is? I'm sure I told you to remember 
 where the project editor was! OK, here's how to find it, one last time, quoted from project 6:
  
 Press Cmd+1 to show the project navigator on the left of your Xcode window, select your 
 project (it's the first item in the pane), then to the right of where you just clicked will appear 
 another pane showing ""PROJECT"" and ""TARGETS"", along with some more information in the 
 center. The left pane can be hidden by clicking the disclosure button in the top-left of the project 
 editor, but hiding it will only make things harder to find, so please make sure it's visible!This 
 view is called the project editor, and contains a huge number of options that affect the way your 
 app works. You'll be using this a lot in the future, so remember how to get here! Select Project 2 
 under TARGETS, then choose the General tab, and scroll down until you see four checkboxes 
 called Device Orientation. You can select only the ones you want to support.
  
 www.hackingwithswift.com 
  
 268",NA
Buttons... buttons everywhere.,"Our user interface for this game is going to have two large 
 UILabel
 s, one small 
 UILabel
 , one 
 large 
 UITextField
 , twenty (count 'em!) big 
 UIButton
 s, then two small 
 UIButton
 s. This is 
 probably the most complicated user interface we're going to make in this entire series, so 
 don't worry if it takes you 20 minutes or so to put together – the end result is definitely worth it!
  
 The picture below shows how your finished layout should look if you've followed all the 
 instructions. If you're seeing something slightly different, that's OK. If you're seeing 
 something 
 very
  different, you should probably try again!
  
  
 Your finished layout should look like this.
  
 Our game is designed for iPads, and specifically for iPads in landscape orientation. Using a 
 square Interface Builder canvas is great for when you want to support a variety of devices 
 where things resize, but here we want one single design with lots of things on. So, we're 
 going to make the canvas the exact right size: go to the file inspector (Alt+Cmd+1) and 
 deselect the checkbox that says, ""Use Size Classes"".
  
 www.hackingwithswift.com 
  
 269",NA
Loading a level ,"This game asks players to spell seven words out of various letter groups, and each word 
 comes with a clue for them to guess. It's important that the total number of letter groups 
 adds up to 20, as that's how many buttons you have. I created the first level for you, and it 
 looks like this:
  
 HA|UNT|ED: Ghosts in residence  
 LE|PRO|SY: A Biblical skin disease  
 TW|ITT|ER: Short but sweet online chirping OLI|VER: Has 
 a Dickensian twist  
 ELI|ZAB|ETH: Head of state, British style SA|FA|RI: The 
 zoological web  
 POR|TL|AND: Hipster heartland 
 As you can see, I've used the pipe symbol to split up my letter groups, meaning that one 
 button will have ""HA"", another ""UNT"", and another ""ED"". There's then a colon and a space, 
 followed by a simple clue. This level is in the files for this project you should download from 
 GitHub
 . You should copy level1.txt into your Xcode project as you have done before.
  
 Our first task will be to load the level and configure all the buttons to show a letter group. 
 We're going to need three arrays to handle this: one to store all the buttons, one to store the 
 buttons that are currently being used to spell an answer, and one for all the possible solutions. 
 Further, we need two integers: one to hold the player's score, which will start at 0 but 
 obviously change during play, and one to hold the current level.
  
 So, declare these properties just below the current 
 @IBOutlet
 s from Interface Builder:
  
 var letterButtons = [UIButton]()  
 var activatedButtons = [UIButton]()  
 var solutions = [String]() 
 var score = 0  
 var level = 1 
 www.hackingwithswift.com 
  
 272",NA
It's play time!,"We need to add three more methods to our view controller in order to finish this game: one to 
 handle letter buttons being tapped, another to handle the current word being cleared, and a 
 third to handle the current word being submitted. The first two are extremely easy, so let's get 
 those done so we can get onto the serious stuff.
  
 First, we already used the 
 addTarget()
  method in 
 viewDidLoad()
  to make all our letter 
 buttons call the method 
 letterTapped()
 , and you should remember that actually had to 
 specify 
 letterTapped:
  because we want to receive the button that was tapped as a 
 parameter for our method. Add this method now somewhere in your code:
  
 func letterTapped(btn: UIButton) { 
  currentAnswer.text = currentAnswer.text! + btn.titleLabel!.text! 
  activatedButtons.append(btn) 
  btn.hidden = true 
 } 
 That does three things: gets the text from the title label of the button that was tapped and 
 appends it to the current text of the answer text field, then appends the button to the 
 activatedButtons
  array, and finally hides the button. We need to force unwrap both the title 
 label and its text, because both might not exist – and yet we know they do.
  
 The 
 activatedButtons
  array is being used to hold all buttons that the player has tapped 
 before submitting their answer. This is important because we're hiding each button as it is 
 tapped, so when the user taps ""Clear"" we need to know which buttons are currently in use 
 so we can re-show them. You already created an empty 
 @IBAction
  method for clear being 
 tapped, so fill it in like this:
  
 @IBAction func clearTapped(sender: AnyObject) { 
  currentAnswer.text = """" 
  for btn in activatedButtons { 
  btn.hidden = false 
 www.hackingwithswift.com 
  
 279",NA
Property observers ,"There's one last thing to cover before this project is done, and it's really small and really 
 easy: property observers.
  
 Right now we have a property called 
 score
  that is set to 0 when the game is created and 
 increments by one whenever an answer is found. But we don't do anything with that score, 
 so our score label is never updated.
  
 One solution to this problem is to use something like 
 scoreLabel.text = ""Score: \(score)"" 
 whenever the score value is changed, and that's perfectly fine to begin with. But what 
 happens if you're changing the score from several places? You need to keep all the code 
 synchronised, which is unpleasant.
  
 Swift has a simple and classy solution called property observers, and it lets you execute code 
 whenever a property has changed. To make them work, you need to declare your data type 
 explicitly (in our case we need an 
 Int
 ), then use either 
 didSet
  to execute code when a 
 property has just been set, or 
 willSet
  to execute code before a property has been set.
  
 In our case, we want to add a property observer to our 
 score
  property so that we update the 
 score label whenever the score value was changed. So, change your 
 score
  property to this:
  
 var score: Int = 0 { 
  didSet { 
  scoreLabel.text = ""Score: \(score)"" 
  } 
 } 
 Note that when you use a property observer like this, you need to explicitly declare its type 
 otherwise Swift will complain.
  
 Using this method, any time 
 score
  is changed by anyone, our score label will be updated. 
 That's it, the project is done!
  
 www.hackingwithswift.com 
  
 283",NA
Wrap up ,"Yes, it took quite a lot of storyboard work to get this project going, but I hope it has shown 
 you that you can make some great games using just the UIKit tools you already know.
  
 Of course, at the same time as making another game, you've made several steps forward in 
 your iOS development quest, this time learning about 
 addTarget()
 , 
 enumerate()
 , 
  
 countElements()
 , 
 find()
 , 
 join()
 , 
 stringByReplacingOccurrencesOfString()
 , property 
 observers, range operators and the difference between Swift strings and 
 NSString
 .
  
 Looking at that list, it should be clear that you are increasingly dealing with specific bits of 
 code (i.e., functions like 
 find()
 ) when you're developing UIKit projects. This is because you're 
 starting to build up a great repertoire of code, so there is simply less to teach. That's not to 
 say there isn't a lot of new things still to come – in fact, the next few projects all introduce 
 several big new things – but it does mean your knowledge is starting to mature.
  
 If you're looking to improve this project, see if you can make it deduct points if the player 
 makes an incorrect guess - this is just a matter of extending the 
 submitAnswer()
  method so 
 that if 
 find()
  failed to find the guess then you remove points.
  
 www.hackingwithswift.com 
  
 284",NA
Project 9 ,NA,NA
Grand Central ,NA,NA
Dispatch,NA,NA
Learn how to run complex tasks in the background ,NA,NA
with GCD.,NA,NA
Setting up ,"In this technique project we're going to return to project 7 to solve a critical problem using 
 one of the most important Apple frameworks available: Grand Central Dispatch, or GCD. I 
 already mentioned the problem to you, but here's a recap from project 7:
  
 By downloading data from the internet in 
 viewDidLoad()
  our app will lock up until all the data 
 has been transferred. There are solutions to this, but to avoid complexity they won't be covered 
 until project 9.
 We're going to solve this problem by using GCD, which will allow us to fetch the 
 data without locking up the user interface. But be warned: even though GCD might seem easy 
 at first, it opens up a new raft of problems, so be careful!
  
 If you want to keep your previous work for reference, take a copy of project 7 now and call it 
 project 9. Otherwise, just modify it in place.
  
 www.hackingwithswift.com 
  
 286",NA
Why is locking the UI bad?,"The answer is two-fold. First, we used 
 NSData
 's 
 contentsOfURL
  to download data from the 
 internet, which is what's known as a 
 blocking
  call. That is, it blocks execution of any further 
 code in the method until it has connected to the server and fully downloaded all the data.
  
 Second, behind the scenes your app actually executes multiple sets of instructions at the 
 same time, which allows it to take advantage of having two CPU cores, or even three as in the 
 iPad Air 2. Each CPU can be doing something independently of the others, which hugely 
 boosts your performance. These code execution processes are called 
 threads
 , and come with 
 a number of important provisos:
  
 1. Threads execute the code you give them, they don't just randomly execute a few lines from 
 viewDidLoad()
  each. This means by default your own code executes on only one CPU, 
 because you haven't created threads for other CPUs to work on.
  
 2. All user interface work must occur on the main thread, which is the initial thread your 
 program is created on. If you try to execute code on a different thread, it might work, it might 
 fail to work, it might cause unexpected results, or it might just crash.
  
 3. You don't get to control when threads execute, or in what order. You create them and give 
 them to the system to run, and the system handles executing them as best it can.
  
 4. Because you don't control the execution order, you need to be extra vigilant in your code to 
 ensure only one thread modifies your data at one time.
  
 Points 1 and 2 explain why our call is bad: if all user interface code must run on the main 
 thread, and we just blocked the main thread by using 
 NSData
 's 
 contentsOfURL
 , it causes 
 the entire program to freeze – the user can touch the screen all they want, but nothing with 
 happen. When the data finally downloads (or just fails), the program will unfreeze. This is a 
 terrible experience, particularly when you consider that iPhones are frequently on poor-
 quality data connections.
  
 Broadly speaking, if you're accessing any remote resource, you should be doing it on a 
 background thread
  – i.e., any thread that is not the main thread. If you're executing any slow 
 code, you should be doing it on a background thread. If you're executing any code that can be 
 run in parallel – e.g. adding a filter to 100 photos – you should be doing it on multiple 
 background threads.
  
 The power of GCD is that it takes away a lot of the hassle of creating and working with multiple 
 threads, known as 
 multithreading
 . You don't have to worry about creating and destroying 
 threads, and you don't have to worry about ensuring you have created the optimal 
  
 www.hackingwithswift.com 
  
 287",NA
GCD 101 ,"We're going to use 
 dispatch_async()
  twice: once to push some code to a background 
 thread, then once more to push code back to the main thread. This allows us to do any 
 heavy lifting away from the user interface where we don't block things, but then update the 
 user interface safely on the main thread – which is the only place it can be safely updated.
  
 When you call 
 dispatch_async()
 , you must tell it where you want the code to run. GCD works 
 with a system of queues, which are much like a real-world queue: they are First In, First Out 
 (FIFO) blocks of code. What this means is that your GCD calls don't create threads to run in, 
 they just get assigned to one of the existing threads for GCD to manage.
  
 GCD creates for you a number of queues, and places tasks in those queues depending on how 
 important you say they are. All are FIFO, meaning that each block of code will be taken off the 
 queue in the order they were put in, but more than one code block can be executed at the same 
 time so the finish order isn't guaranteed.
  
 ""How important"" some code is depends on something called ""quality of service"", or QoS, 
 which decides what level of service this code should be given. Obviously at the top of this is 
 the main queue, which runs on your main thread, and should be used to schedule any work 
 that must update the user interface immediately even when that means blocking your program 
 from doing anything else. But there are four background queues that you can use, each of 
 which has their own QoS level set:
  
 1. User Interactive: this is the highest priority background thread, and should be used when 
 you want a background thread to do work that is important to keep your user interface 
 working. This priority will ask the system to dedicate nearly all available CPU time to you to 
 get the job done as quickly as possible.
  
 2. User Initiated: this should be used to execute tasks requested by the user that they are now 
 waiting for in order to continue using your app. It's not as important as user interactive work – 
 i.e., if the user taps on buttons to do other stuff, that could should be executed first – but it is 
 important because you're keeping the user waiting.
  
 3. The Utility queue: this should be used for long-running tasks that the user is aware of, but 
 not necessarily desperate for now. If the user has requested something and can happily leave 
 it running while they do something else with your app, you should use Utility.
  
 4. The Background queue: this is for long-running tasks that the user isn't actively aware of, or 
 at least doesn't care about its progress or when it completes.
  
 Those QoS queues affect the way the system prioritises your work: User Interactive and User 
  
 www.hackingwithswift.com 
  
 289",NA
Back to the main thread ,"With this change, our code is both better and worse. It's better because it no longer blocks the 
 main thread while the JSON downloads from Whitehouse.gov. It's worse because we're 
 pushing work to the background thread, 
 and any further code called in that work will also be 
 on the background thread
 .
  
 So, if the download fails, 
 loadError()
  will be called on the background thread and its 
 UIAlertController
  will be created and shown on the background thread. If the download 
 succeeds, the JSON will be parsed on the background thread and the table view's 
 reloadData()
  will be called on the background thread.
  
 Now, it's OK to parse the JSON there, but 
 it's never OK to do user interface work on the 
 background thread
 .
  
 That's so important it bears repeating twice: 
 it's never OK to do user interface work on the 
 background thread
 .
  
 If you're on a background thread and want to execute code on the main thread, you need to call 
 dispatch_async()
  again, this time using the function 
 dispatch_get_main_queue() 
 because 
 you want to run on the main thread. There are two ways we could modify our code to have 
 dispatch_get_main_queue()
  before every call to 
 showError()
  and 
 parseJSON()
 , but that's 
 both ugly and inefficient.
  
 Instead, it's better to place the 
 dispatch_async()
  call inside 
 showError()
 , wrapping up the 
 whole 
 UIAlertController
  code, and also inside 
 parseJSON()
 , but only where the table view is 
 being reloaded. The actual JSON parsing can happily stay on the background thread.
  
 So, inside the 
 parseJSON()
  method find this code:
  
 tableView.reloadData() 
 …and replace it this new code, bearing in mind again the need for 
 [unowned self] in
  and 
 self.
  to keep away strong reference cycles:
  
 dispatch_async(dispatch_get_main_queue()) { [unowned self] in 
 www.hackingwithswift.com 
  
 292",NA
Wrap up ,"Although I've tried to simplify things as much as possible, GCD still isn't easy. That said, it's 
 much easier than the alternatives: GCD automatically handles thread creation and 
  
 management, automatically balances based on available system resources, and 
  
 automatically factors in Quality of Service to ensure your code runs as efficiently as possible. 
 The alternative is doing all that yourself!
  
 There's a lot more we could cover (not least how to create your own queues!) but really you 
 have more than enough to be going on with, and certainly more than enough to complete the 
 rest of this series. We'll be using GCD again, so it might help to keep this reference close to 
 hand!
  
 www.hackingwithswift.com 
  
 294",NA
Project 10 ,NA,NA
Names to ,NA,NA
Faces,NA,NA
Get started with UICollectionView and the photo library.,NA,NA
Setting up ,"This is a fun, simple and useful project that will let you create an app to help store names of 
 people you've met. If you're a frequent traveller, or perhaps just bad at putting names to faces, 
 this project will be perfect for you.
  
 And yes, you'll be learning lots along the way: this time you'll meet 
  
 UICollectionViewController
 , 
 UIImagePickerController
  and 
 NSUUID
 . Plus you'll get to do 
 more with your old pals 
 CALayer
 , 
 UIAlertController
 , 
 NSData
  and closures. But above all, 
 you're going to learn how to make a new data type from scratch for the first time.
  
 Create a new Single View Application project in Xcode, call it Project10, set its target to any 
 device you want, then save it somewhere. This should be second nature to you by now – 
 you're becoming a veteran!
  
 www.hackingwithswift.com 
  
 296",NA
Designing UICollectionView cells ,"Open Interface Builder with Main.storyboard, then embed the initial view controller inside a 
 navigation controller. Now, using the object library (Ctrl+Alt+Cmd+3) search for a Collection 
 View and drag it onto the view controller so that it takes up the full space. 
 Important:
  don't 
 choose the one with a yellow icon, because that's a Collection View Controller rather than a 
 UICollectionView
 . They are different!
  
 With the collection view selected, go to the size inspector and set Cell Size to have the width 
 140 and height 180. Now set the section insets for top, bottom, left and right to all be 10.
  
 Collection views are extremely similar to table views, with the exception that they display as 
 grids rather than as simple rows. But while the display is different, the underlying method calls 
 are so similar that you would be able to dive right in if it weren't for the fact that we need to 
 write all the code ourselves this time – there's no collection view template code we can 
 modify!
  
 Using the assistant editor, create an outlet for the collection view called 
 collectionView
 , then 
 return back to the standard editor. Trying to edit a storyboard while you can only see half the 
 screen isn't easy!
  
 When you create a collection view, you get one initial collection view cell defined for you, 
 called a 
 prototype
 . This is the empty square you'll see in the top-left corner. This works the 
 same as with table views; you'll remember we changed the initial cell in project 7 so that we 
 could add subtitles.
  
 Select that collection view cell now, then go to the attributes inspector and change its 
 Background from ""Default"" (transparent) to white. Now place a 
 UIImageView
  in there, with X: 
 10, Y:10, width 120 and height 120. We'll be using this to show pictures of people's faces.
  
 Place a 
 UILabel
  in there too, with X:10, Y:134, width 120 and height 40. In the attributes 
 inspector, change the label's font by clicking the T button and choosing ""Custom"" for font, 
 ""Marker Felt"" for family, and ""Thin"" for style. Give it the font size 16, which is 1 smaller than 
 the default, then set its alignment to be centered and its number of lines property to be 2.
  
 www.hackingwithswift.com 
  
 297",NA
Data sources and delegates ,"In project 4 we made ourselves the delegate of a 
 WKWebView
 's navigation, and as soon as 
 that happened there were compiler problems. We also had to tell Swift that we conformed to 
 the 
 WKNavigationDelegate
  protocol in order to make the code work.
  
 WKNavigationDelegate
  is a very easy protocol to conform to, because all its methods are 
 optional. That means you don't need to implement anything, you just need to say that you 
 conform to the protocol.
  
 When you make your view controller to be the data source and delegate of a collection using 
 a storyboard, you won't get any compiler problems, but the code won't work. You don't get any 
 compiler problems because the compiler doesn't check storyboard connections, but the code 
 won't work because the 
 UICollectionViewDataSource
  protocol has two non-optional 
 methods that we need to implement.
  
 The best next step from here is to tell Swift in code that your view controller conforms to the 
 UICollectionViewDataSource
  and 
 UICollectionViewDelegate
  protocols, because that way it 
 can make sure your code is valid. So, go to ViewController.swift and modify your view 
 controller's class definition to this:
  
 class ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate 
 { 
 Once you've made this change, you'll see compiler errors because we don't fully conform to 
 the 
 UICollectionViewDataSource
  protocol. Specifically, you must tell the collection view how 
 many items of data it should expect and what each item should contain. To begin with, let's 
 put together the most basic implementation that allows our code to build cleanly. Add these 
 two methods:
  
 func collectionView(collectionView: UICollectionView, 
 numberOfItemsInSection section: Int) -> Int { 
  return 10 
 } 
 func collectionView(collectionView: UICollectionView,  
 www.hackingwithswift.com 
  
 302",NA
Importing photos ,"There are lots of events that make up the 
 UICollectionViewDelegate
  protocol to handle 
 when the user interacts with a cell, but we'll come back to that later. For now, let's look at 
 how to import pictures using 
 UIImagePickerController
 . This new class is designed to let 
 users select an image from their camera to import into an app. When you first create a 
 UIImagePickerController
 , iOS will automatically ask the user whether the app can access 
 their photos.
  
 First, we need to create a button that lets users add people to the app. This is as simple as 
 putting the following into the 
 viewDidLoad()
  method:
  
 navigationItem.leftBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""addNewPerson"") 
 The 
 addNewPerson()
  method is where we need to use the 
 UIImagePickerController
 , but 
 it's so easy to do I'm just going to show you the code:
  
 func addNewPerson() { 
  let picker = UIImagePickerController() 
  picker.allowsEditing = true 
  picker.delegate = self 
  presentViewController(picker, animated: true, completion: nil) 
 } 
 There are only two interesting things in there. First, we set the 
 allowsEditing
  property to be 
 true, which allows the user to crop the picture they select. Second, when you set 
 self
  as the 
 delegate, you'll need to conform not only to the 
 UIImagePickerControllerDelegate 
 protocol, 
 but also the 
 UINavigationControllerDelegate
  protocol.
  
 The first of those protocols is useful, telling us when the user either selected a picture or 
 cancelled the picker. The second, 
 UINavigationControllerDelegate
 , really is quite pointless 
  
 www.hackingwithswift.com 
  
 305",NA
Custom classes ,"You already created your first custom class when you created the collection view cell. But 
 this time we're going to do something very simple: we're going to create a class to hold 
 some data for our app. So far you've seen how we can create arrays of strings by using 
 [String]
 , but what if we want to hold an array of 
 people
 ?
  
 Well, the solution is to create a custom class. Create a new file (you remember my explicit, 
 ""read this carefully"" instructions, right?) and choose Cocoa Touch Class. Click Next and 
 name the class Person, type 
 NSObject
  for ""Subclass of"", then click Next and Create to 
 create the file.
  
 NSObject
  is what's called a 
 universal base class
  for all Cocoa Touch classes. That means all 
 UIKit classes ultimately come from 
 NSObject
 , as do all NS objects like 
 NSString
 . You don't 
 have to inherit from 
 NSObject
  in Swift, but you did in Objective C and in fact there are some 
 behaviors you can only have if you do inherit from it. More on that in project 12, but for now 
 just make sure you inherit from 
 NSObject
 .
  
 We're going to add two properties to our class: a name and a photo for every person. So, 
 add this inside the 
 Person
  definition:
  
 var name: String 
 var image: String 
 When you do that, you'll see errors: ""Class 'Person' has no initializers."" This is a term I've 
 skipped over so far, but now is a good time to introduce it: an initializer method is something 
 that creates instances of a class. You've been using these all along: the 
 contentsOfFile 
 method for 
 NSString
  is an initializer, as is 
 UIAlertController(title:message:preferredStyle:)
 .
  
 Swift is telling you that you aren't satisfying one of its core rules: objects of type 
 String
  can't 
 be empty. Remember, 
 String!
  and 
 String?
  can both be 
 nil
 , but plain old 
 String
  can't – it must 
 have a value. Without an initializer, it means the object will be created and these two variables 
 won't have values, so you're breaking the rules.
  
 To fix this problem, we need to create an 
 init()
  method that accepts two parameters, one for 
 the name and one for the image. We'll then save that to the object so that both variables 
  
 www.hackingwithswift.com 
  
 310",NA
Connecting up the people ,"We need to make three final changes to this project in order to finish: show the correct 
 number of items, show the correct information inside each cell, then make it so that when 
 users tap a picture they can set a person's name.
  
 Those methods are all increasingly difficult, so we'll start with the first one. Right now, your 
 collection view's 
 numberOfItemsInSection
  method just has 
 return 10
  in there, so you'll see 
 10 items regardless of how many people are in your array. This is easily fixed:
  
 func collectionView(collectionView: UICollectionView, 
 numberOfItemsInSection section: Int) -> Int { 
  return people.count 
 } 
 Next, we need to update the collection view's 
 cellForItemAtIndexPath
  method so that it 
 configures each 
 PersonCell
  cell to have the correct name and image of the person in that 
 position in the array. This takes a few steps:
  
  • Pull out the person from the 
 people
  array at the correct position.
  
  • Set the 
 name
  label to the person's name.
  
  • Create a 
 UIImage
  from the person's image filename, adding it to the value from 
 getDocumentsDirectory()
  so that we have a full path for the image.
  
 We're also going to use this opportunity to give the image views a border and slightly rounded 
 corners, then give the whole cell matching rounded corners, to make it all look a bit more 
 interesting. This is all done using 
 CALayer
 , so that means we need to convert the 
 UIColor
  to 
 a 
 CGColor
 . Anyway, here's the new code:
  
 func collectionView(collectionView: UICollectionView, 
 cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell { 
  let cell =  
 collectionView.dequeueReusableCellWithReuseIdentifier(""Person"", forIndexPath: 
 indexPath) as! PersonCell 
 www.hackingwithswift.com 
  
 313",NA
Wrap up ,"UICollectionView
  and 
 UITableView
  are the most common ways of showing lots of 
  
 information in iOS, and you now know how to use both. You should be able to go back to 
 project 1 and recognise a lot of very similar code, and that's by intention – Apple has made it 
 easy to learn both view types by learning either one.
  
 You've also learned another batch of iOS development, this time 
 UIImagePickerController
 , 
 NSUUID
 , custom classes and more. You might not realise it yet, but you have enough 
 knowledge now to make a huge range of apps!
  
 If you wanted to take this app further you could add a second 
 UIAlertController
  that is shown 
 when the user taps a picture, and asks them whether they want to rename the person or 
 delete them.
  
 You could also try 
 picker.sourceType = .Camera
  when creating your image picker, which 
 will tell it to create a new image by taking a photo. This is only available on devices (not on 
 the simulator!) so you might want to check the return value of 
  
 UIImagePickerController.isSourceTypeAvailable()
  before trying to use it!
  
 Before we finish, you may have spotted one problem with this app: if you quit the app and 
 relaunch, it hasn't remembered the people you added. Worse, the JPEGs are still stored on 
 the disk, so your app takes up more and more room without having anything to show for it!
  
 This is quite intentional, and something we'll return to fix in project 12. Before then, let's take a 
 look at another game…
  
 www.hackingwithswift.com 
  
 316",NA
Project 11 ,NA,NA
Pachinko,NA,NA
Dive into SpriteKit to try your hand at fast 2D games.,"www.hackingwithswift.com 
  
 317",NA
Setting up ,"This project is going to feel like a bit of a reset for you, because we're going to go back to 
 basics. This isn't because I like repeating myself, but instead because you're going to learn a 
 wholly new technology called SpriteKit.
  
 So far, everything you've made has been based on UIKit, Apple's user interface toolkit for 
 iOS. We've made several games with it, and it really is very powerful, but even UIKit has its 
 limits – and fast 2D games aren't its strong suit.
  
 A much better solution is called SpriteKit, and it's Apple's fast and easy toolkit designed 
 specifically for 2D games. It includes sprites, fonts, physics, particle effects and more, and 
 it's built into every iOS device. What's not to like?
  
 So, this is going to be a long tutorial because you're going to learn an awful lot. To help keep 
 you sane, I've tried to make the project as iterative as possible. That means we'll make a 
 small change and discuss the results, then make another small change and discuss the 
 results, until the project is finished.
  
 And what are we building? Well, we're going to produce a game similar to pachinko, although a 
 lot of people know it by the name ""Peggle."" To get started, create a new project in Xcode and 
 choose Game. Name it Project11, set it to target iPad, set its Game Technology to be SpriteKit, 
 then save it somewhere.
  
 Before we start, please configure your project so that it runs only in landscape mode.
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 318",NA
Falling boxes ,"The first thing you should do is run your game and see what a default SpriteKit template game 
 looks like. You should see a large gray window saying ""Hello, World!"", and when you tap a 
 spinning spaceship should appear. In the bottom right is a node count (how many things are 
 on screen right now) and a frame rate. You're aiming for 60 frames per second all the time, if 
 possible.
  
 From the project navigator, select Images.xcassets, then choose the spaceship image and 
 and press the delete key. Now go to GameScene.swift, and delete everything inside the 
 didMoveToView()
  and 
 touchesBegan()
  methods (but leave the methods themselves.)
  
 With the template stuff deleted, I'd like you to import the assets for the project. If you haven't 
 already downloaded the code for this project, please do so now. You should copy the entire 
 Content folder from the example project into your own, making sure the ""Copy items if needed"" 
 box is checked.
  
 Let's kick off this project by ditching the gray background and replacing it with a picture. If 
 you want to place an image in your game, the class to use is called 
 SKSpriteNode
 , and it 
 can load any picture from your app bundle just like 
 UIImage
 .
  
 To place a background image, we need to load the file called background.jpg, then position it in 
 the center of the screen. Unlike UIKit, SpriteKit works with the center of objects – i.e., the point 
 0,0 refers to the horizontal and vertical center of a node. Also unlike UIKit, SpriteKit's Y axis 
 starts at the bottom edge, so a higher Y number places a node higher on the screen. To place 
 the background image in the center of a landscape iPad, we need to place it at the position 
 X:512, Y:384.
  
 We're going to do two more things, both of which are only needed for this background. First, 
 we're going to give it the blend mode 
 .Replace
 . Blend modes determine how a node is drawn, 
 and SpriteKit gives you many options. The 
 .Replace
  option means ""just draw it, ignoring any 
 alpha values,"" which makes it fast for things without gaps such as our 
  
 background. We're also going to give the background a 
 zPosition
  of -1, which in our game 
 means ""draw this behind everything else.""
  
 To add any node to the current screen, you use the 
 addChild()
  method. As you might expect, 
 SpriteKit doesn't use 
 UIViewController
  like our UIKit apps have done. Yes, there is a view 
 controller in your project, but it's there to host your SpriteKit game. The equivalent of screens in 
 SpriteKit are called 
 scenes
 .
  
 www.hackingwithswift.com 
  
 319",NA
Bouncing balls ,"You're not going to get rich out of red rectangles, so let's use balls instead. Take the box code 
 out (everything after 
 let location =
  in 
 touchesBegan()
 ) and replace it with this instead:
  
 let ball = SKSpriteNode(imageNamed: ""ballRed"")  
 ball.physicsBody = SKPhysicsBody(circleOfRadius: ball.size.width / 2.0)  
 ball.physicsBody!.restitution = 0.4  
 ball.position = location  
 addChild(ball) 
 There are two new things there. First, we're using the 
 circleOfRadius
  initializer for 
 SKPhysicsBody
  to add circular physics to this ball, because using rectangles would look 
 strange. Second, we're giving the ball's physics body a restitution (bounciness) level of 0.4, 
 where values are from 0 to 1.
  
 (NB: the physics body of a node is optional, because it might not exist. We know it exists 
 because we just created it, so you'll always see 
 physicsBody!
  to force unwrap the optional.)
  
 When you run the game now, you'll be able to tap on the screen to drop bouncy balls. It's 
 fractionally more interesting, but let's face it: this is still a dreadful game.
  
 Easily fixed, though: we're going to add something for the balls to bounce off. In the Content 
 folder I provided you with is a picture called ""bouncer.png"", so we're going to place that in the 
 game now.
  
 Just before the end of the 
 didMoveToView()
  method, add this:
  
 let bouncer = SKSpriteNode(imageNamed: ""bouncer"") bouncer.position = 
 CGPoint(x: 512, y: 0)  
 bouncer.physicsBody = SKPhysicsBody(circleOfRadius: bouncer.size.width 
 / 2.0)  
 bouncer.physicsBody!.dynamic = false  
 addChild(bouncer) 
 www.hackingwithswift.com 
  
 324",NA
Spinning slots ,"The purpose of the game will be to drop your balls in such a way that they land in good slots 
 and not bad ones. We have bouncers in place, but we need to fill the gaps between them with 
 something so the player knows where to aim.
  
 We'll be filling the gaps with two types of target slots: good ones (colored green) and bad ones 
 (colored red). As with bouncers, we'll need to place a few of these, which means we need to 
 make a method. This needs to load the slot base graphic, position it where we said, then add 
 it to the scene, like this:
  
 func makeSlotAt(position: CGPoint, isGood: Bool) { var slotBase: 
 SKSpriteNode 
  if isGood { 
  
  slotBase = SKSpriteNode(imageNamed: ""slotBaseGood"") } else { 
  
  slotBase = SKSpriteNode(imageNamed: ""slotBaseBad"") } 
  slotBase.position = position 
  addChild(slotBase)  
 } 
 Unlike 
 makeBouncerAt()
 , this method has a second parameter – whether the slot is good or 
 not – and that affects which image gets loaded. But first, we need to call the new method, so 
 add these lines just before the calls to 
 makeBouncerAt
  in 
 didMoveToView()
 :
  
 makeSlotAt(CGPoint(x: 128, y: 0), isGood: true) 
 makeSlotAt(CGPoint(x: 384, y: 0), isGood: false) 
 makeSlotAt(CGPoint(x: 640, y: 0), isGood: true) 
 makeSlotAt(CGPoint(x: 896, y:0), isGood: false) 
 www.hackingwithswift.com
  
 327",NA
Collision detection ,"Just by adding a physics body to the balls and bouncers we already have some collision 
 detection because the objects bounce off each other. But it's not being detected by 
 us
 , 
 which means we can't do anything about it.
  
 In this game, we want the player to win or lose depending on how many green or red slots 
 they hit, so we need to make a few changes:
  
 1. Add rectangle physics to our slots.
  
 2. Name the slots so we know which is which, then name the balls too.
  
 3. Make our scene the contact delegate of the physics world – this means, ""tell us when 
 contact occurs between two bodies."" 
  
 4. Create a method that handles contacts and does something appropriate.
  
 The first step is easy enough: add these two lines just before you call 
 addChild()
  for 
 slotBase
 :
  
 slotBase.physicsBody = SKPhysicsBody(rectangleOfSize: slotBase.size) 
 slotBase.physicsBody!.dynamic = false 
 The slot base needs to be non-dynamic because we don't want it to move out of the way 
 when a player ball hits.
  
 The second step is also easy, but bears some explanation. As with UIKit, it's easy enough to 
 store a variable pointing at specific nodes in your scene for when you want to make 
 something happen, and there are lots of times when that's the right solution.
  
 But for general use, Apple recommends assigning names to your nodes, then checking the 
 name to see what node it is. We need to have three names in our code: good slots, bad slots 
 and balls. This is really easy to do – just modify your 
 makeSlotAt()
  method so the 
  
 SKSpriteNode
  creation looks like this:
  
 if isGood { 
  slotBase = SKSpriteNode(imageNamed: ""slotBaseGood"") 
  slotGlow = SKSpriteNode(imageNamed: ""slotGlowGood"") 
 www.hackingwithswift.com 
  
 331",NA
Scores on the board ,"To make a score show on the screen we need to do two things: create a score integer that 
 tracks the value itself, then create a new node type, 
 SKLabelNode
 , that displays the value to 
 players.
  
 The 
 SKLabelNode
  class is somewhat similar to 
 UILabel
  in that it has a 
 text
  property, a font, a 
 position, an alignment, and so on. Plus we can use Swift's string interpolation to set the text of 
 the label easily, and we're even going to use the property observers you learned about it project 
 8 to make the label update itself when the score value changes.
  
 Declare these properties at the top of your class:
  
 var scoreLabel: SKLabelNode! 
 var score: Int = 0 { 
  didSet { 
   scoreLabel.text = ""Score: \(score)"" }  
 } 
 We're going to use the Chalkduster font, then align the label to the right and position it on the 
 top-right edge of the scene. Put this code into your 
 didMoveToView()
  method, just before the 
 end:
  
 scoreLabel = SKLabelNode(fontNamed: ""Chalkduster"") scoreLabel.text 
 = ""Score: 0""  
 scoreLabel.horizontalAlignmentMode = .Right  
 scoreLabel.position = CGPoint(x: 980, y: 700)  
 addChild(scoreLabel) 
 That places the label into the scene, and the property observer automatically updates the 
  
 www.hackingwithswift.com 
  
 336",NA
Special effects ,"Our current 
 destroyBall()
  method does nothing much, it just removes the ball from the game. 
 But I made it a method for a reason, and that's so that we can add some special effects now, in 
 one place, so that however a ball gets destroyed the same special effects are used.
  
 Perhaps unsurprisingly, it's remarkably easy to create special effects with SpriteKit. In fact, it 
 has a built-in particle editor to help you create effects like fire, snow, rain and smoke almost 
 entirely through a graphical editor. I already created an example particle effect for you (which 
 you can customise soon, don't worry!) so let's take a look at the code first.
  
 Modify your 
 destroyBall()
  method to this:
  
 func destroyBall(ball: SKNode) { 
  if let fireParticles = SKEmitterNode(fileNamed: ""FireParticles"") { 
  fireParticles.position = ball.position 
  addChild(fireParticles) 
  } 
  ball.removeFromParent() 
 } 
 The 
 SKEmitterNode
  class is new and powerful: it's designed to create high-performance 
 particle effects in SpriteKit games, and all you need to do is provide it with the filename of the 
 particles you designed and it will do the rest. Once we have an 
 SKEmitterNode
  object to work 
 with, we position it where the ball was then use 
 addChild()
  to add it to the scene.
  
 If you run the app now, you'll see the balls explode in a fireball when they touch a slot – a 
 pretty darn amazing effect given how little code was written!
  
 But the real fun is yet to come, because the code for this project is now all done and you get to 
 play with the particle editor. In Xcode, look in the Content folder you dragged in and select the 
 FireParticles.sks file to load the particle editor.
  
 The particle editor is split in two: the center area shows how the current particle effect looks, 
  
 www.hackingwithswift.com 
  
 343",NA
Wrap up ,"This project is done, and it's been a long one, but I hope you look at the results and think it 
 was all worth it. Plus, you've once again learned a lot: SpriteKit, physics, blend modes, 
 radians and 
 CGFloat
 .
  
 You’ve got the firm foundations of a real game here, but there's lots more you can do to 
 make it even better. Here are some ideas to get you started:
  
  • The Content folder you copied in has other ball pictures rather than just ballRed. Generate a 
 random number and choose ball colors randomly.
  
  • Right now, users can tap anywhere to have a ball created there, which makes the game too 
 easy. Try to force the Y value of new balls so they are near the top of the screen.
  
  • Give players a limit of five balls, then remove obstacle boxes when they are hit. Can they 
 clear all the pins with just five balls? You could make it so that landing on a green slot gets 
 them an extra ball.
  
  • Make clicking on an obstacle box in editing mode removes it.
  
 And if you were wondering how to get rid of the node and frames per second counts in your 
 game, look inside the GameViewController.swift file for these two lines:
  
 skView.showsFPS = true 
 skView.showsNodeCount = true 
 www.hackingwithswift.com
  
 346",NA
Project 12 ,NA,NA
NSUserDefault,NA,NA
s,NA,NA
Learn how to save user settings and data for later use.,NA,NA
Setting up ,"This is our fourth technique project, and we're going to go back to project 10 and fix its 
 glaring bug: all the names and faces you add to the app don't get saved, which makes the 
 app rather pointless!
  
 We're going to fix this using a new class called 
 NSUserDefaults
  and a new protocol called 
 NSCoding
 . We'll also be using the class 
 NSKeyedUnarchiver
  that you just met in project 11, 
 along with its counterpart: 
 NSKeyedArchiver
 . Putting all these together, we're going to 
 update project 10 so that it saves its 
 people
  array whenever anything is changed, then loads 
 when the app runs.
  
 We're going to be modifying project 10, so if you want to preserve the old code take a copy 
 now and call it project 12.
  
 www.hackingwithswift.com 
  
 348",NA
Reading and writing basics ,"You can use 
 NSUserDefaults
  to store any basic data type for as long as the app is installed. 
 You can write basic types such as 
 Bool
 , 
 Float
 , 
 Double
 , 
 Int
 , 
 String
 , or 
 NSURL
 , but you can 
 also write more complex types such as arrays, dictionaries and 
 NSDate
  – and even 
 NSData 
 values.
  
 When you write data to 
 NSUserDefaults
 , it automatically gets loaded when your app runs so 
 that you can read it back again. This makes using it really easy, but you need to know that it's a 
 bad idea to store lots of data in there because it will slow loading of your app. If you think your 
 saved data would take up more than say 100KB, 
 NSUserDefaults
  is almost certainly the wrong 
 choice.
  
 Before we get into modifying project 12, we're going to do a little bit of test coding first to try 
 out what 
 NSUserDefaults
  lets us do. You might find it useful to create a fresh Single View 
 Application project just so you can test out the code.
  
 To get started with 
 NSUserDefaults
 , you create a new instance of the class like this:
  
 let defaults = NSUserDefaults.standardUserDefaults() 
 Once that's done, it's easy to set a variety of values – you just need to give each one a unique 
 key so you can reference it later. These values nearly always have no meaning outside of what 
 you use them for, so just make sure the key names are memorable.
  
 Here are some examples:
  
 let defaults = NSUserDefaults.standardUserDefaults() 
 defaults.setInteger(25, forKey: ""Age"") 
 defaults.setBool(true, forKey: ""UseTouchID"") 
 defaults.setDouble(M_PI, forKey: ""Pi"") 
 In older versions of iOS, you needed to tell iOS when it was a good time to save the defaults 
 data to disk, but this isn't needed (or even recommended!) any more.
  
 www.hackingwithswift.com 
  
 349",NA
Fixing Project 10 ,"You've just learned all the core basics of working with 
 NSUserDefaults
 , but we're just 
 getting started. You see, above and beyond integers, dates, strings, arrays and so on, you 
 can also save any kind of data inside 
 NSUserDefaults
  as long as you follow some rules.
  
 What happens is simple: you use the 
 archivedDataWithRootObject()
  method of 
  
 NSKeyedArchiver
 , which turns an object graph into an 
 NSData
  object, then write that to 
 NSUserDefaults
  as if it were any other object. If you were wondering, ""object graph"" means 
 ""your object, plus any objects it refers to, plus any objects those objects refer to, and so on.""
  
 The rules are very simple:
  
 1. All your data types must be one of the following: boolean, integer, float, double, string, 
 array, dictionary, 
 NSDate
 , or a class that fits rule 2.
  
 2. If your data type is a class, it must conform to the 
 NSCoding
  protocol, which is used for 
 archiving object graphs.
  
 3. If your data type is an array or dictionary, all the keys and values must match rule 1 or rule 
 2.
  
 Many of Apple's own classes support 
 NSCoding
 , including but not limited to: 
 UIColor
 , 
 UIImage
 , 
 UIView
 , 
 UILabel
 , 
 UIImageView
 , 
 UITableView
 , 
 SKSpriteNode
  and many more. 
 But your own classes do not, at least not by default. If we want to save the 
 people
  array to 
 NSUserDefault
  we'll need to conform to the 
 NSCoding
  protocol.
  
 The first step is to modify your 
 Person
  class to this:
  
 class Person: NSObject, NSCoding { 
 When we were working on this code in project 10, there were two outstanding questions:
  
  • Why do we need a class here when a struct will do just as well? (And in fact better, 
 because structs come with a default initializer!)
  
  • Why do we need to inherit from 
 NSObject
 ?
  
 It's time for the answers to become clear. You see, working with 
 NSCoding
  requires you to 
 use objects, or, in the case of strings, arrays and dictionaries, structs that are 
  
 www.hackingwithswift.com 
  
 353",NA
Wrap up ,"You 
 will
  use 
 NSUserDefaults
  in your projects. That isn't some sort of command, just a 
 statement of inevitability. If you want to save any user settings, or if you want to save 
 program settings, it's just the best place for it. And I hope you'll agree it is (continuing a 
 trend!) easy to use and flexible, particularly when your own classes conform to 
 NSCoding
 .
  
 One proviso you ought to be aware of: please don't consider 
 NSUserDefaults
  to be safe, 
 because it isn't. If you have user information that is private, you should consider writing to 
 the keychain instead – something we'll look at in project 28.
  
 www.hackingwithswift.com 
  
 357",NA
Project 13 ,NA,NA
Instafilter,NA,NA
Make a photo manipulation program using Core ,NA,NA
Image filters and a UISlider.,"www.hackingwithswift.com 
  
 358",NA
Setting up ,"In project 10 you learned how to use 
 UIImagePickerController
  to select and import a picture 
 from your user's photo library. In this project, we're going to add the reverse: writing images 
 back to the photo library. But because you're here to learn as much as possible, I'm also going 
 to introduce you to another UIKit component, 
 UISlider
 , and also a little bit of Core Image, which 
 is Apple's high-speed image manipulation toolkit.
  
 The project we're going to make will let users choose a picture from their photos, then 
 manipulate it with a series of Core Image filters. Once they are happy, they can save the 
 processed image back to their photo library.
  
 To get started, create a new Single View Application project in Xcode and name it Project13. 
 You can target iPad, iPhone or Universal – whichever you feel like.
  
 www.hackingwithswift.com 
  
 359",NA
Designing the interface ,"Select your Main.storyboard file to open Interface Builder, then embed the view controller 
 inside a navigation controller.
  
 Bring up the object library, then search for ""UIView"" and drag a view into your controller. Give it 
 a width of 600 and height of 430, with X:0 and Y:64. This should place it just below the 
 navigation controller, occupying most of the screen. In the attributes inspector, give the view the 
 background color ""Dark Gray Color"".
  
 Create an image view, and place it inside the view you just created. I'd like you to indent it by 
 10 points on every side – i.e., width 580, height 410, X:10, Y:10. Change the image's view 
 mode from ""Scale to fill"" to ""Aspect Fit"". Don't place any more views inside the gray view – 
 everything else should be placed directly on the main (white) view.
  
 That's the top part of the UI complete. For the bottom part, start by creating a label with 
 width 70, height 20, X:28, Y:512. Give it the text ""Intensity"" and make it right-aligned. Now 
 drop a slider next to it, giving it width 470, X:104, Y:508. You can't adjust the height for 
 sliders, so leave it at the default.
  
 Finally, place two buttons. The first button should be 120 wide and 44 high, with X:16, Y:540. 
 Give it the title ""Change Filter"". The second button should be 60 wide by 44 high, with X:524, 
 Y:540. Give it the title ""Save"".
  
 In the picture below you can see how your finished layout should look.
  
 www.hackingwithswift.com 
  
 360",NA
Importing a picture ,"We already have two outlets at the top of our class: one for the image view and one for the 
 slider. We need another property, in which we will store a 
 UIImage
  containing the image that 
 the user selected. So, add this beneath the two outlets:
  
 var currentImage: UIImage! 
 Our first task will be to import a photo from the user's photo library. This is almost identical to 
 project 10, so I'm going to explain only the important bits. If you missed out project 10, you 
 should have paid heed to my warning not to skip projects!
  
 First we need to add a button to the navigation bar that will allow users to import a photo 
 from their library. Put these two lines into your 
 viewDidLoad()
  method:
  
 title = ""YACIFP"" 
 navigationItem.rightBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""importPicture"") 
 Alright, so the first one isn't needed – it just sets the title to be YACIFP, short for ""Yet Another 
 Core Image Filters Program."" (Spoiler: the App Store is full of them!) If you're feeling a bit less 
 cynical than me, try ""Instafilter"" for a title instead. But what matters is the second line, because 
 it starts the import process.
  
 Here's the 
 importPicture()
  method – it's almost identical to the import method from project 
 10, so again no explaining required:
  
 func importPicture() { 
  let picker = UIImagePickerController() 
  picker.allowsEditing = true 
  picker.delegate = self 
  presentViewController(picker, animated: true, completion: nil) 
 www.hackingwithswift.com 
  
 364",NA
Applying filters ,"You're probably getting tired of hearing me saying this, but Core Image is yet another super-
 fast and super-powerful framework from Apple. It does only one thing, which is to apply 
 filters to images that manipulate them in various ways.
  
 One downside to Core Image is it's not very guessable, so you need to know what you're doing 
 otherwise you'll waste a lot of time. It's also not able to take advantage of Swift's type safety, so 
 you need to be careful when using it because the compiler won't help you as much as you're 
 used to.
  
 To get started, we need to add two more properties to our class, so put these underneath the 
 currentImage
  property:
  
 var context: CIContext! 
 var currentFilter: CIFilter! 
 The first is a Core Image context, which is the Core Image component that handles 
 rendering. We create it here and use it throughout our app, because creating a context is 
 computationally expensive so we don't want to keep doing it.
  
 The second is a Core Image filter, and will store whatever filter we have activated. This filter 
 will be given various input settings before we ask it to output a result for us to show in the 
 image view.
  
 We want to create both of these in 
 viewDidLoad()
 , so put this just before the end of the 
 method:
  
 context = CIContext(options: nil) 
 currentFilter = CIFilter(name: ""CISepiaTone"") 
 That creates a default Core Image context, then creates an example filter that will apply a 
 sepia tone effect to images. It's just for now; we'll let users change it soon enough.
  
 www.hackingwithswift.com 
  
 367",NA
Saving to the photo library ,"I know it's fun to play around with Core Image filters (and you've only seen some of them!), but 
 we have a project to finish so I want to introduce you to a new function: 
  
 UIImageWriteToSavedPhotosAlbum()
 . This method does exactly what its name says: give it 
 a 
 UIImage
  and it will write the image to the photo album.
  
 This method takes four parameters: the image to write, who to tell when writing has finished, 
 what method to call, and any context. The context is just like the context value you can use with 
 KVO, as seen in project 4, and again we're not going to use it here. The first two parameters 
 are quite simple: we know what image we want to save (the processed one in the image view), 
 and we also know that we want 
 self
  (the current view controller) to be notified when writing has 
 finished.
  
 The third parameter is ugly. It needs to be a string that lists the method in our view controller 
 that will be called, and it needs to be a particular format: 
  
 methodName:parameterName:parameterName. We're going to use 
  
 ""image:didFinishSavingWithError:contextInfo:""
 , which will call a method that looks like 
 this:
  
 func image(image: UIImage, didFinishSavingWithError error: NSErrorPointer, 
 contextInfo:UnsafePointer<Void>) { 
 It's ugly, it's unavoidable, and it's a bit of a wart in iOS. To be fair, though, the fact that it 
 stands out so much is testament to the fact that there are so few warts around!
  
 Putting it all together, here's the finished 
 save()
  method:
  
 @IBAction func save(sender: AnyObject) { 
  UIImageWriteToSavedPhotosAlbum(imageView.image!, self, 
 ""image:didFinishSavingWithError:contextInfo:"", nil) 
 } 
 From here on it's easy, because we just need to write the 
 didFinishSavingWithError
  
 www.hackingwithswift.com 
  
 373",NA
Wrap up ,"This has been the briefest possible introduction to Core Image, yet we still managed to make 
 something useful, using 
 UISlider
  for the first time and even writing images to the photo album! 
 Unless you really do intend to make Yet Another Core Image Filters Program (best of luck!) 
 your use of Core Image will mostly be about manipulating a picture in a very specific way, 
 using a filter you have hand-crafted to look great.
  
 If you want to try other filters, search on Google for ""Core Image Filter Reference"" and have a 
 read – it will list the input keys for each of them so that you can get really fine-grained control 
 over the filters.
  
 If you want to spend more time working on this app, you could start by making the Change 
 Filter button change title to show the name of the current filter. If you fancy something bigger, 
 then you should definitely investigate having separate sliders to control each of the input keys 
 you care about. For example, one for radius and one for intensity. If you want to tackle 
 something small, see if you can make tapping ""Save"" do nothing if there is no image loaded.
  
 www.hackingwithswift.com 
  
 375",NA
Project 14 ,NA,NA
Whack-a-,NA,NA
Penguin,NA,NA
Build a game using SKCropNode and a sprinkling of ,NA,NA
Grand Central Dispatch.,NA,NA
Setting up ,"It's time for another game, and we'll be using more of SpriteKit to build a whack-a-mole-style 
 game, except with penguins because Whack-a-Penguin isn't trademarked. You're going to 
 learn about 
 SKCropNode
 , 
 SKTexture
  and some more types of 
 SKAction
 , and we'll also use 
 dispatch_after()
  to execute closures after a delay.
  
 Create a new SpriteKit game project in Xcode, named Project14 and targeting iPad, then 
 delete the spaceship image and most of the example code just like you did in project 11. Now 
 download the files for this project from 
 GitHub
  and copy the assets from the Content folder 
 into your Xcode project. Please also copy in the file Helper.swift; we'll be using it later.
  
 Before we get into the code, please disable Portrait and Upside Down orientations because 
 this game will run only in landscape mode.
  
 All set? Open up GameScene.swift and get whacking!
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 377",NA
Getting up and running ,"We already went over the basics of SpriteKit in project 11, so this time we're going to move a 
 little faster: modify your 
 didMoveToView()
  method so it reads this:
  
 override func didMoveToView(view: SKView) { 
  let background = SKSpriteNode(imageNamed: ""whackBackground"") 
 background.position = CGPoint(x: 512, y: 384) 
  background.blendMode = .Replace 
  background.zPosition = -1 
  addChild(background) 
  gameScore = SKLabelNode(fontNamed: ""Chalkduster"") gameScore.text = 
 ""Score: 0"" 
  gameScore.position = CGPoint(x: 8, y: 8) 
  gameScore.horizontalAlignmentMode = .Left 
  gameScore.fontSize = 48 
  addChild(gameScore)  
 } 
 For that to work properly, you'll need to add two properties to the top of the class:
  
 var gameScore: SKLabelNode! 
 var score: Int = 0 { 
  didSet { 
   gameScore.text = ""Score: \(score)"" }  
 } 
 www.hackingwithswift.com
  
 378",NA
"Penguin, show thyself ","We want the slots to manage showing and hiding penguins themselves as needed, which 
 means we need to give them some properties and methods of their own. The two things a 
 slot needs to know are ""am I currently visible to be whacked by the player?"" and ""have I 
 already been hit?"" The former avoids players tapping on slots that are supposed to be 
 invisible; the latter so that players can't whack a penguin more than once.
  
 To track this data, put these two properties at the top of your 
 WhackSlot
  class:
  
 var visible = false 
 var isHit = false 
 Showing a penguin for the player to tap on will be handled by a new method called 
 show()
 . 
 This will make the character slide upwards so it becomes visible, then set 
 visible
  to be true 
 and 
 hit
  to be false. The movement is going to be created by a new 
 SKAction
 , called 
 moveByX(_:y:duration:)
 .
  
 This method will also decide whether the penguin is good or bad – i.e., whether the player 
 should hit it or not. This will be done using a 
 RandomInt()
  function that I bundled into 
 Helper.swift for you to make random number generation easier: one-third of the time the 
 penguin will be good; the rest of the time it will be bad.
  
 To make it clear to the player which is which, we have two different pictures: penguinGood 
 and penguinEvil. We can change the image inside our penguin sprite by changing its 
 texture 
 property. This takes a new class called 
 SKTexture
 , which is to 
 SKSpriteNode
  sort of what 
 UIImage
  is to 
 UIImageView
  – it holds image data, but isn't responsible for showing it.
  
 Changing the character node's texture like this is helpful because it means we don't need to 
 keep adding and removing nodes. Instead, we can just change the texture to match what kind 
 of penguin this is, then change the node name to match so we can do tap detection later on.
  
 However, all the above should only happen if the slot isn't already visible, because it could 
 cause havoc. So, the very first thing the method needs to do is check whether 
 visible
  is true, 
 and if so exit.
  
 www.hackingwithswift.com 
  
 385",NA
Whack to win ,"To bring this project to a close, we still need to do two major components: letting the player 
 tap on a penguin to score, then letting the game end after a while. Right now it never ends, so 
 with 
 popupTime
  getting lower and lower it means the game will become impossible after a 
 few minutes.
  
 We're going to add a 
 hit()
  method to the 
 WhackSlot
  class that will handle hiding the 
 penguin. This needs to wait for a moment (so the player still sees what they tapped), move 
 the penguin back down again, then set the penguin to be invisible again.
  
 We're going to use an 
 SKAction
  for each of those three things, which means you need to 
 learn some new uses of the class:
  
  • 
 SKAction.waitForDuration()
  creates an action that waits for a period of time, measured in 
 seconds.
  
  • 
 SKAction.runBlock()
  will run any code we want, provided as a closure. ""Block"" is 
 Objective C's name for a Swift closure.
  
  • 
 SKAction.sequence
  takes an array of actions, and executes them in order. Each action 
 won't start executing until the previous one finished.
  
 We need to use 
 SKAction.runBlock()
  in order to set the penguin's 
 visible
  property to be 
 false rather than doing it directly, because we want it to fit into the sequence. Using this 
 technique, it will only be changed when that part of the sequence is reached.
  
 Put this method into the 
 WhackSlot
  class:
  
 func hit() { 
  isHit = true 
  let delay = SKAction.waitForDuration(0.25) 
  let hide = SKAction.moveByX(0, y:-80, duration:0.5) 
  let notVisible = SKAction.runBlock { [unowned self] in self.visible = false } 
  charNode.runAction(SKAction.sequence([delay, hide, notVisible])) 
 } 
 www.hackingwithswift.com
  
 391",NA
Wrap up ,"You have another game under your belt, and I hope your brain is already starting to bubble up 
 ideas for things you can do to improve it. Plus, you learned more skills, not least 
  
 SKCropNode
 , 
 SKTexture
 , GCD's 
 dispatch_after()
 , the 
 *=
  and 
 -=
  operators, forcing method 
 labels, plus lots of new 
 SKAction
  types, so it's all time well spent.
  
 If you're looking to improve this project, you could start by adding a smoke-like particle effect to 
 be used when the penguins are hit, and perhaps a separate mud-like effect when they go into 
 or come out of a hole. You could also record your own voice saying ""Game over!"" and have it 
 play when the game ends. Try experimenting with the difficulty and see what you come up with 
 – is it easier or harder if the penguin show/hide animation happens at random speeds?
  
 www.hackingwithswift.com 
  
 397",NA
Project 15 ,NA,NA
Animation,NA,NA
"Bring your interfaces to life with animation, and ",NA,NA
meet switch/case at the same time.,"www.hackingwithswift.com 
  
 398",NA
Setting up ,"As we're just before the half-way point of this series, it's time to introduce one of the most 
 important techniques in iOS development: animation. Sadly, many people don't consider 
 animation important at all, which makes for some thoroughly awful user interface design.
  
 Animation – making things move, scale, and so on – of your views is not only about making 
 things pretty, although that's certainly a large part. It's main purpose is to gives users a sense of 
 what's changing and why, and it helps them make sense of a state change in your program. 
 When you use a navigation controller to show a new view controller, we don't just want it to 
 appear. Instead, we want it to slide in, making it clear that the old screen hasn't gone away, it's 
 just to the left of where we were.
  
 You're almost certainly tired of hearing me say this, but iOS has a ridiculously powerful 
 animation toolkit that's also easy to use. I know, I'm a broken record, right?
  
 Well, don't just take my word for it – let's try out some animation together so you can see 
 exactly how it works. You're also going to meet switch/case for the first time and learn about 
 the 
 CGAffineTransform
  struct, both of which will serve you just as well as animations. So, 
 create a new Single View Application project in Xcode, name it Project15 and set its target to 
 be iPad.
  
 Please download the files for this project from 
 GitHub
  and copy its Content folder into your 
 Xcode project. Finally, set the orientation to be landscape only. Animation of course works in 
 all orientations, but it's easier to work with a fixed size for now.
  
 www.hackingwithswift.com 
  
 399",NA
Preparing for action ,"Open Interface Builder with Main.storyboard and place a button on there with the title ""Tap"". 
  
 Give it width 46 and height 44, with X:277 and Y:542. We need to add some Auto Layout 
 constraints, so select the button in the document outline and Ctrl-drag diagonally on it. The 
 popup menu will offer ""Width"", ""Height"" and ""Aspect Ratio""; please add Width and Height.
  
 We want our button to always stay near the bottom of the view controller, so Ctrl-drag from the 
 button to the view directly above it and choose ""Bottom Space to Bottom Layout Guide."" Now 
 Ctrl-drag the same way again and choose ""Center Horizontally in Container.""
  
 That's it for Auto Layout, so please switch to the assistant view so we can add an action and 
 an outlet. Ctrl-drag from the button to your code to create an outlet for it called 
 tap
 . Then Ctrl-
 drag again to create an action for the button called 
 tapped()
 .
  
 Every time the user taps the ""Tap"" button, we're going to execute a different animation. This 
 will be accomplished by cycling through a counter, and moving an image view. To make all 
 that work, you need to add two more properties to the class:
  
 var imageView: UIImageView! 
 var currentAnimation = 0 
 There isn't an image view in the storyboard – we're going to create it ourself in 
 viewDidLoad()
  using an initializer that takes a 
 UIImage
  and makes the image view the 
 correct size for the image.
  
 Add this code to 
 viewDidLoad()
 :
  
 imageView = UIImageView(image: UIImage(named: ""penguin"")) 
 imageView.center = CGPoint(x: 512, y: 384) 
 view.addSubview(imageView) 
 That places the penguin in the middle of an iPad-sized landscape screen, ready for us to 
 animate.
  
 www.hackingwithswift.com 
  
 400",NA
"Switch, case, animate ","The 
 currentAnimation
  property can have a value between 0 and 7, each one triggering a 
 different animation. You might be tempted to write code like this:
  
 if currentAnimation == 0 { 
  anim1()  
 } else if currentAnimation == 1 { 
  anim2()  
 } else if currentAnimation == 2 { 
  andSoOn()  
 } 
 But that's not a very efficient way of checking a variable for multiple possible values, so 
 programming languages have a different syntax for doing exactly that, known as switch/ 
 case. Using this syntax, we could more or less rewrite the previous code like this:
  
 switch currentAnimation {  
 case 0: 
  anim1()  
 case 1: 
  anim2()  
 case 3: 
  andSoOn()  
 } 
 I say ""more or less rewrite"" because Swift wants to make sure your code is as safe as 
 possible, and one of the checks it executes is that your switch/case statements are 
 exhaustive – that every possible outcome is catered for.
  
 As a result, you will frequently need to include a 
 default
  case block to match any value not 
  
 www.hackingwithswift.com 
  
 402",NA
Transform!,"Our code now has the perfect structure in place to let us dabble with animations freely, so it's 
 time to learn about 
 CGAffineTransform
 . This is a structure that represents a specific kind of 
 transform that we can apply to any 
 UIView
  object or subclass.
  
 Unless you're into mathematics, affine transforms can seem like a black art. But Apple does 
 provide some great helper functions to make it easier: there are functions to scale up a view, 
 functions to rotate, functions to move, and functions to reset back to default.
  
 All of these functions return a 
 CGAffineTransform
  value that you can put into a view's 
 transform
  property to apply it. As we'll be doing this inside an animation block, the transform 
 will automatically be animated. This illustrates one of the many powerful things of Core 
 Animation: you tell it what you want to happen, and it calculates all the intermediary states 
 automatically.
  
 Let's start with something simple: when we're at 
 currentAnimation
  value 0, we want to 
 make the view 2x its default size. Change the switch/case code to this:
  
 switch self.currentAnimation { 
 case 0: 
  self.imageView.transform = CGAffineTransformMakeScale(2, 2) 
 default: 
  break 
 } 
 That uses a new function, 
 CGAffineTransformMakeScale()
 , which takes an X and Y scale 
 value as its two parameters. A value of 1 means ""the default size,"" so 
 2, 2
  will make the view 
 twice its normal width and height. By default, UIKit animations have an ""ease in, ease out"" 
 curve, which means the movement starts slow, accelerates, then slows down again before 
 reaching the end.
  
 Run the app now and tap the button to watch the penguin animate from 1x to 2x its size over 
 one second, all by setting the transform inside an animation. You can keep tapping the 
  
 www.hackingwithswift.com 
  
 406",NA
Wrap up ,"Core Animation is an extraordinary toolkit, and UIKit wraps it in a simple and flexible set of 
 methods. And because it's so simple to use, you really have no excuse for not using it. If 
 you're moving something around conceptually (e.g., moving an email to a folder, showing a 
 palette of paint brushes, rolling a dice, etc) then move it around 
 visually
  too. Your users will 
 thank you for it!
  
 You also learned a little about switch/case as a way of evaluating multiple possible values. 
  
 Although you haven't seen much of it yet, Swift's switch/case syntax is actually one of the 
 most powerful and expressive I've ever come across, although it can bend your brain a little. 
  
 In this project we were only matching simple values, but trust me: it can do so much more.
  
 If you want to put your new-found animation skill into practice, try going back to project 8 – 7 
 Swifty Words – and making the letter group buttons fade out when they are tapped. We were 
 using the 
 hidden
  property, but you'll need to switch to 
 alpha
  because 
 hidden
  is either true or 
 false, it has no animatable values between.
  
 www.hackingwithswift.com 
  
 411",NA
Project 16 ,NA,NA
JavaScript ,NA,NA
Injection,NA,NA
Extend Safari with a cool feature for JavaScript developers.,NA,NA
Setting up ,"Welcome to the second half of the series! From here on in, the apps you create will be looking 
 beyond plain UIKit to explore some of the other great ways you can use Apple's tools to 
 produce great apps. In this project you're going to create a Safari extension, which lets us 
 embed a version of our app directly inside Safari's action menu, then manipulate Safari data in 
 interesting ways.
  
 What do I mean by ""interesting ways""? Well, our little Safari extension is going to read in the 
 URL and page title that the user was visiting, then show them a large text area they can type 
 JavaScript into. When the extension is dismissed, we'll execute that JavaScript in Safari – like 
 Mozilla's Greasemonkey extension, just for iOS.
  
 This is the first of two projects that are 
 hard
 . This is not because I want to torture you, but 
 because your skills are improving and it's time to tackle bigger things. In this project, the 
 actual amount of code you're going to be writing is quite small, because most of the code will 
 be provided for us by Xcode. However, it's dense, and there's a lot to take in, so it might feel 
 like slow going.
  
 At the very least, the project will still be useful and you'll learn a lot too – not least about 
 Safari extensions and a new class called 
 NSNotificationCenter
 .
  
 Let's get started: create a new Single View Application project in Xcode, name it Project16 
 and set it to target iPhone.
  
 www.hackingwithswift.com 
  
 413",NA
Making a shell app ,"Safari extensions are launched from within the Safari action menu, but they ship inside a 
 parent app. That is, you can't ship an extension by itself – it needs have an app alongside it. 
 Frequently the app does very little, but it must at least be present.
  
 There are two common ways to use the app side of the extension: to show help information, 
 or to show basic settings for the user to adjust. We're going to go with the first option, 
 although to skip writing lots of help text we'll just be using ""Hello, world!""
  
 Open your apps Main.storyboard file and drop a 
 UILabel
  into the view controller. Give it the 
 text ""Hello, world!"" then make it large enough to fit. Now drag it so that horizontal and vertical 
 blue alignment lines appear, meaning that it's centered. In the document outline, Ctrl-drag 
 from the label to the view just above it, and select ""Center Horizontally in Container"" and 
 ""Center Vertically in Container.""
  
 When you add those two constraints, you'll probably see some orange boxes around your 
 label – one is wholly orange, and one has a dashed line. These orange markers mean your 
 views don't match your constraints: the solid orange lines mean ""this is where you view is,"" 
 and the dashed orange lines mean ""this is where your view will be when your code runs.""
  
 The reason for the difference is because labels have a default size of whatever fits their 
 current text. We drew out the size by hand, and in my case I drew it too large, so Xcode is 
 telling me when the code runs the label will be smaller. You can fix this warning by going to 
 the Editor menu and choosing Resolve Auto Layout Issues > Update Frames, which will 
 make the label the size Auto Layout thinks it ought to be.
  
 That's the entire app complete. We're not going to add any more to it here because it's really 
 not the point; we're going to focus on the extension from here on.
  
 www.hackingwithswift.com 
  
 414",NA
Adding an extension ,"Extensions are miniature apps in their own right, and as such need their own space in your 
 code. That doesn't mean you can't share code and resources between your extensions and 
 your app, just that it's not automatic.
  
 To get started with a fresh extension, go to the File menu and choose New > Target. When 
 you're asked to choose a template, select iOS > Application Extension > Action Extension, 
 then click Next. For the name just call it Extension, make sure Action Type is set to ""Presents 
 User Interface"", then click Finish.
  
  
 Creating a new Action Extension target effectively creates a separate chunk of source code to 
 manage inside your project.
  
 When you create an extension inside an app, Xcode will ask you whether you want to activate 
 its scheme. Check the ""Do not show this message again"" box then click Activate. With this 
 change, when you run your code, you'll actually launch the extension – it's perfect for our 
 needs right now.
  
 Once your extension has been created, it will appear in the project navigation in its own 
  
 www.hackingwithswift.com 
  
 415",NA
What do you want to get?,"Inside the Extension group in the project navigator is a file called Info.plist. You have one for 
 your app too, and in fact all apps have one. This plist (that's short for property list, 
  
 remember) contains metadata about apps and extensions: what language is it, what version 
 number is it, and so on.
  
 For extensions, this plist also describes what data you are willing to accept and how it should 
 be processed. Look for the key marked NSExtension and open its disclosure indicator: you 
 should see NSExtensionAttributes, NSExtensionMainStoryboard and 
 NSExtensionPointIdentifier. It's that first one we care about, because it modifies the way our 
 extension behaves.
  
 Open up the disclosure arrow for NSExtensionAttributes and you should see 
  
 NSExtensionActivationRule, then String, then TRUEPREDICATE. Change String to be 
 Dictionary, then click the small + button to the left of Dictionary, and when it asks you for a key 
 name change ""New item"" to be 
  
 ""NSExtensionActivationSupportsWebPageWithMaxCount"". You can leave the new item as a 
 string (it doesn't really matter), but change its value to be 1 – that's the empty space just to the 
 right of String.
  
 Adding this value to the dictionary means that we only want to receive web pages – we aren't 
 interested in images or other data types.
  
 Now select the NSExtensionAttributes line itself, and click the + button that appears next to 
 the word Dictionary. Replace ""New item"" with ""NSExtensionJavaScriptPreprocessingFile"", 
 then give it the value ""Action"". This tells iOS that when our extension is called, we need to run 
 the JavaScript preprocessing file called Action.js, which will be in our app bundle. Make sure 
 you type ""Action"" and not ""Action.js"", because iOS will append the "".js"" itself.
  
 In the picture below you can see how your extension's property list should look. Make sure 
 you enter the key names precisely, because there is no room for error.
  
 www.hackingwithswift.com 
  
 418",NA
Establishing communication ,"To begin with, all we're going to do is send some data from Safari to our extension to make 
 sure everything is set up correctly – after all, it's been quite a bit of hassle so far with nothing 
 to show for it!
  
 First, we're going to modify Action.js to send two pieces of data to our extension: the URL 
 the user was visiting, and the title of the page. Go to Action.js and modify the 
 run()
  function 
 to this:
  
 run: function(parameters) { 
  parameters.completionFunction({""URL"": document.URL, ""title"": document.title }); 
 }, 
 JavaScript is quite a murky language, so you might be staring at that blankly. If I were to put it 
 in plain English, what it means is ""tell iOS the JavaScript has finished preprocessing, and give 
 this data dictionary to the extension."" The data that is being sent has the keys ""URL"" and 
 ""title"", with the values being the page URL and page title.
  
 As with the previous JavaScript, don't worry about the nitty-gritty. Tthere are many volumes of 
 books on learning JavaScript and I don't intend to repeat them here.
  
 Now that data is being sent from JavaScript, data will be received in Swift. In 
 ActionViewController.swift, replace the 
 // do stuff!
  comment with this:
  
 let itemDictionary = dict as! NSDictionary 
 let javaScriptValues =  
 itemDictionary[NSExtensionJavaScriptPreprocessingResultsKey] as!  
 NSDictionary 
 print(javaScriptValues) 
 Before I explain what that code does, please run the code. I'm saying this because if you're 
 like me then you're probably desperate to see anything working at this point, so let's at least 
  
 www.hackingwithswift.com 
  
 421",NA
Hacking with JavaScript ,"Our extension is going to let users type in JavaScript, so before we get onto more coding we're 
 going to add a basic user interface. Open MainInterface.storyboard, then delete its 
 UIImageView and navigation bar. Once that's done, embed the view controller in a navigation 
 controller.
  
 We're going to use a new UIKit component called 
 UITextView
 . You already met 
 UITextField 
 in 
 project 5, and it's useful for letting users enter text into a single-line text box. But if you want 
 multiple lines of text, you need 
 UITextView
 , so search for ""textview"" in the object library and 
 drag one into your view so that it takes up all the space. Delete the template ""Lorem ipsum"" text 
 that is in there.
  
 Use Resolve Layout Issues > Add Missing Constraints to add automatic Auto Layout 
 constraints. If you find you're having trouble with text going behind the navigation bar, try 
 deleting the top vertical constraint and replacing it with a constraint against the top layout 
 guide. Now use the assistant editor to create an outlet named 
 script
  for the text view in 
 ActionViewController.swift, and while you're there you can delete the 
 UIImageView
  outlet 
 that Xcode made for you.
  
 That's everything for Interface Builder, so switch back to the standard editor, open 
 ActionViewController.swift and add these two properties to your class:
  
 var pageTitle = """" 
 var pageURL = """" 
 We're going to store these two because they are being transmitted by Safari. We'll use the 
 page title to show useful text in the navigation bar, and the URL is there for you to use 
 yourself if you make improvements.
  
 You already saw that we're receiving the data dictionary from Safari, because we used the 
 print()
  function to output its values. Replace the 
 print()
  call with this:
  
 self.pageTitle = javaScriptValues[""title""] as! String 
 self.pageURL = javaScriptValues[""URL""] as! String 
 www.hackingwithswift.com 
  
 425",NA
Fixing the keyboard ,"Before we're done, there's a bug in our extension, and it's a bad one – or at least it's bad 
 once you spot it. You see, when you tap to edit a text view, the iOS keyboard automatically 
 appears so that user can start typing. But if you try typing lots, you'll notice that you can 
 actually type underneath the keyboard because the text view hasn't adjusted its size 
 because the keyboard appeared.
  
 If you don't see a keyboard when you tap to edit, it probably means you have the Connect 
 Hardware Keyboard setting turned on. Press Shift+Cmd+K to disable the hardware keyboard 
 and use the on-screen one.
  
 Having our view adjust to the presence of a keyboard is tricky, because there are a number of 
 situations you need to cope with. For example, various keyboards are different heights, the user 
 can rotate their device at will, they can connect a hardware keyboard when they need to, and 
 there's even the QuickType bar that can be shown or hidden on demand.
  
 In all the years I've done iOS development, I've seen at least a dozen ways of coping with 
 keyboards, and few of them are easy. Even Apple's example solution requires fiddling around 
 with constraints, which isn't ideal. I've tried to put together a solution that copes with all 
 possibilities and also requires as little code as possible. If you manage to find something even 
 simpler, do let me know!
  
 We can ask to be told when the keyboard state changes by using a new class called 
 NSNotificationCenter
 . Behind the scenes, iOS is constantly sending out notifications when 
 things happen – keyboard changing, application moving to the background, as well as any 
 custom events that applications post. We can add ourselves as an observer for certain 
 notifications and a method we name will be called when the notification occurs, and will even be 
 passed any useful information.
  
 When working with the keyboard, the notifications we care about are 
  
 UIKeyboardWillHideNotification
  and 
 UIKeyboardWillChangeFrameNotification
 . The first 
 will be sent when the keyboard has finished hiding, and the second will be shown when any 
 keyboard state change happens – including showing and hiding, but also orientation, 
 QuickType and more.
  
 It might sound like we don't need 
 UIKeyboardWillHideNotification
  if we have 
  
 UIKeyboardWillChangeFrameNotification
 , but in my testing just using 
  
 UIKeyboardWillChangeFrameNotification
  isn't enough to catch a hardware keyboard 
  
 www.hackingwithswift.com 
  
 429",NA
Wrap up ,"I'll tell you what: 
 I'm
  feeling tired and I didn't even have to learn anything to write this project – I 
 can't imagine how tired you are! But please don't be too disheartened: extensions are new in 
 iOS 8 and developers are still trying to figure out the best way to use them.
  
 Some of the code isn't pleasant to work with, and certainly I wish iOS would just figure out text 
 view insets automatically for keyboards, but you're through it now so your project is done. 
 Even though this was a hard project, I did cut quite a few corners in this project to make the 
 code as easy as possible, so again I want to encourage you to try creating another extension 
 and see how Apple's example code is different from mine.
  
 If you'd like to make improvements to this project, you could try combining a number of 
 techniques together to make a pretty awesome app. You're already receiving the URL of the 
 site the user is on, so why not use 
 NSUserDefaults
  to save the user's JavaScript for each site? 
 You should convert the URL to an 
 NSURL
  object in order to use its 
 host
  property. If you 
 wanted to be really fancy, you could let users name their scripts, then select one to load view 
 using a 
 UITableView
 .
  
 www.hackingwithswift.com 
  
 433",NA
Project 17 ,NA,NA
Swifty Ninja,NA,NA
Learn to draw shapes in SpriteKit while making a fun ,NA,NA
and tense slicing game.,"www.hackingwithswift.com 
  
 434",NA
Setting up ,"I don't want to put you off, but this is by far the longest project in the series. It's not the most 
 complicated
 , but it's long, coming in just short of 500 lines in total. That said, I hope it'll be worth 
 it, because the end result is great: we're going to make a Fruit Ninja-style game, where slicing 
 penguins is good and slicing bombs is bad. I think I must unconsciously have something 
 against penguins…
  
 Anyway, in this project you're going to be creating your own enums for the first time, you're 
 going to meet 
 SKShapeNode
  and 
 AVAudioPlayer
 , you're going to create 
 SKAction
  groups, 
 you're going to create shapes with 
 UIBezierPath
 , learn about default parameters, and more. 
 So, it's the usual recipe: make something cool, and learn at the same time.
  
 This is the second of two projects that are hard – not because I'm trying to set you back, just 
 because they are more complex than the others. This project is hard because you need to 
 write a lot of code before you can start to see results, which I personally find frustrating. I 
 much prefer it when I can write a few lines, see the result, write a few lines more, see the 
 result again, and so on. That isn't possible here, so I suggest you make some coffee before 
 you begin.
  
 Still here? OK!
  
 Create a new SpriteKit project in Xcode, name it Project17, set its target to be iPad, then do 
 the usual cleaning job: remove all the code from 
 didMoveToView()
  and 
 touchesBegan()
 , 
 then delete the spaceship graphics from Images.xcassets. Please also download the files for 
 this project from 
 GitHub
 , then copy its Content folder and Helper.swift files into your Xcode 
 project.
  
 Please force the app to be landscape only before continuing.
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 435",NA
Basics quick start ,"The only way we can get through this project with our sanity intact is by whizzing through the 
 things you know already so I can spend more time focusing on the new bits. So, be prepared 
 for abrupt changes of pace: fast, slow, fast, slow, as appropriate.
  
 Open up GameScene.swift and put this into 
 didMoveToView()
 :
  
 let background = SKSpriteNode(imageNamed: ""sliceBackground"") 
 background.position = CGPoint(x: 512, y: 384) 
 background.blendMode = .Replace 
 background.zPosition = -1 
 addChild(background) 
 physicsWorld.gravity = CGVector(dx: 0, dy: -6) 
 physicsWorld.speed = 0.85 
 createScore() 
 createLives() 
 createSlices() 
 The last three are all methods we'll create in a moment, but first there are two new lines in 
 there. The default gravity of our physics world is -0.98, which is roughly equivalent to Earth's 
 gravity. I'm using a slightly lower value so that items stay up in the air a bit longer.
  
 Gravity is expressed using a new data type called 
 CGVector
 , which looks and works like a 
 CGPoint
  except it takes ""delta x"" and ""delta y"" as its parameters. ""Delta"" is a fancy way of 
 saying ""difference"", in this case from 0. Vectors are best visualised like an arrow that has its 
 base always at 0,0 and its tip at the point you specify. We're specifying X:0 and Y:-6, so our 
 vector arrow is pointing straight down.
  
 I'm also telling the physics world to adjust its speed downwards, which causes all movement to 
 happen at a slightly slower rate.
  
 www.hackingwithswift.com 
  
 436",NA
Shaping up for action ,"Like I already explained, we're going to keep an array of the user's swipe points so that we 
 can draw a shape resembling their slicing. To make this work, we're going to need five new 
 methods, one of which you've met already. They are: 
 touchesBegan()
 , 
 touchesMoved()
 , 
 touchesEnded()
 , 
 touchesCancelled()
  and 
 redrawActiveSlice()
 .
  
 You already know how 
 touchesBegan()
  works, and the other three ""touches"" methods all 
 work the same way. There's a subtle difference between 
 touchesEnded()
  and 
  
 touchesCancelled()
 : the former is called when the user stops touching the screen, and the 
 latter is called if the system has to interrupt the touch for some reason – e.g. if a low memory 
 warning appears. We're going to make 
 touchesCancelled()
  just call 
 touchesEnded()
 , to 
 avoid duplicating code.
  
 First things first: add this new property to your class so that we can store swipe points:
  
 var activeSlicePoints = [CGPoint]() 
 We're going to tackle the three easiest methods first: 
 touchesMoved()
 , 
 touchesEnded()
  and 
 touchesCancelled()
 . All the touches 
 touchesMoved()
  method needs to do is figure out where 
 in the scene the user touched, add that location to the slice points array, then redraw the slice 
 shape, so that's easy enough:
  
 override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { 
  guard let touch = touches.first else { return } 
  let location = touch.locationInNode(self) 
  activeSlicePoints.append(location) 
  redrawActiveSlice() 
 } 
 www.hackingwithswift.com
  
 441",NA
Enemy or bomb?,"In this section we're going to look at just one method, which should tell you immediately that 
 this is a 
 complicated
  method. This method is called 
 createEnemy()
 , and is responsible for 
 launching either a penguin or a bomb into the air for the player to swipe. That's it – that's all it 
 does. And yet it's going to take quite a lot of code because it takes quite a lot of 
  
 functionality in order to make the game complete:
  
 1. Should this enemy be a penguin or a bomb? 
  
 2. Where should be it created on the screen?
  
 3. What direction should it be moving in?
  
 It should be obvious that 3) relies on 2) – if you create something on the left edge of the 
 screen, having it move to the left would make the game impossible for players!
  
 An additional complexity is that in the early stages of the game we sometimes want to force a 
 bomb, and sometimes force a penguin, in order to build a smooth learning curve. For 
 example, it wouldn't be fair to make the very first enemy a bomb, because the player would 
 swipe it and lose immediately.
  
 We're going to specify what kind of enemy we want using an enum. You've used enums 
 already (not least in project 2), but you've never created one before. To make 
 createEnemy() 
 work, we need to declare a new enum that tracks what kind of enemy should be created: 
 should we force a bomb always, should we force a bomb never, or use the default 
  
 randomisation?
  
 Add this 
 above
  your class definition in GameScene.swift:
  
 enum ForceBomb { 
  case Never, Always, Default 
 } 
 You can now use those values in your code, for example like this:
  
 if forceBomb == .Never { 
  enemyType = 1 
 www.hackingwithswift.com 
  
 449",NA
Follow the sequence ,"You've come so far already, and really there isn't a lot to show for your work other than being 
 able to draw glowing slice shapes when you move touches around the screen. But that's all 
 about to change, because we're now about to create the interesting code – we're going to 
 make the game actually create some enemies.
  
 Now, you might very well be saying, ""but Paul, we just wrote the enemy creating code, and I 
 never want to see it again!"" You're right (and I never want to see it again either!) but it's a bit 
 more complicated: the 
 createEnemy()
  method creates one enemy as required. The code 
 we're going to write now will call 
 createEnemy()
  in different ways so that we get varying 
 groups of enemies.
  
 For example, sometimes we want to create two enemies at once, sometimes we want to 
 create four at once, and sometimes we want to create five in quick sequence. Each one of 
 these will call 
 createEnemy()
  in different ways.
  
 There's a 
 lot
  to cover here, so let's get started: add this new enum before the 
 ForceBomb 
 enum you added a few minutes ago:
  
 enum SequenceType: Int { 
  case OneNoBomb, One, TwoWithOneBomb, Two, Three, Four, Chain, FastChain 
 } 
 That outlines the possible types of ways we can create enemy: one enemy that definitely is a 
 bomb, one that might or might not be a bomb, two where one is a bomb and one isn't, then 
 two/three/four random enemies, a chain of enemies, then a fast chain of enemies.
  
 The first two will be used exclusively when the player first starts the game, to give them a 
 gentle warm up. After that, they'll be given random sequence types from 
 TwoWithOneBomb 
 to 
 FastChain
 .
  
 We're going to need quite a few new properties in order to make the plan work, so please 
 add these now:
  
 www.hackingwithswift.com 
  
 457",NA
Slice to win ,"We need to modify 
 touchesMoved()
  to detect when users slice penguins and bombs. The 
 code isn't complicated, but it 
 is
  long, so I'm going to split it into three. First, here's the 
 structure – place this just before the end of 
 touchesMoved()
 :
  
 let nodes = nodesAtPoint(location) 
 for node in nodes { 
  if node.name == ""enemy"" { 
  // destroy penguin 
  } else if node.name == ""bomb"" { 
  // destroy bomb 
  } 
 } 
 Now, let's take a look at what destroying a penguin should do. It should:
  
 1. Create a particle effect over the penguin.
  
 2. Clear its node name so that it can't be swiped repeatedly.
  
 3. Disable the 
 dynamic
  of its physics body so that it doesn't carry on falling.
  
 4. Make the penguin scale out and fade out at the same time.
  
 5. After making the penguin scale out and fade out, we should remove it from the scene. 
 6. Add one to the player's score.
  
 7. Remove the enemy from our 
 activeEnemies
  array.
  
 8. Play a sound so the player knows they hit the penguin.
  
 Replace the 
 // destroy penguin
  with this, following along with my numbered comments:
  
 // 1 
 let emitter = SKEmitterNode(fileNamed: ""sliceHitEnemy"")! 
 emitter.position = node.position 
 addChild(emitter) 
 www.hackingwithswift.com 
  
 465",NA
"Game over, man ","You are now within reach of the end of this project, and not a moment too soon, I suspect. 
 You'll be pleased to know that you're just two methods away from the end, and neither of 
 them are particularly taxing.
  
 First is the 
 subtractLife()
  method, which is called when a penguin falls off the screen without 
 being sliced. It needs to subtract 1 from the 
 lives
  property that we created what seems like 
 years ago, update the images in the 
 livesImages
  array so that the correct number are crossed 
 off, then end the game if the player is out of lives.
  
 To make it a bit clearer that something bad has happened, we're also going to add playing a 
 sound and animate the life being lost – we'll set the X and Y scale of the life being lost to 1.3, 
 then animate it back down to 1.0.
  
 Here's the code:
  
 func subtractLife() { 
  lives -= 1 
  runAction(SKAction.playSoundFileNamed(""wrong.caf"", 
 waitForCompletion: false)) 
  var life: SKSpriteNode 
  if lives == 2 { 
  
  life = livesImages[0] 
  } else if lives == 1 { 
  
  life = livesImages[1] 
  } else { 
  
  life = livesImages[2] 
  
  endGame(triggeredByBomb: false) 
  } 
 www.hackingwithswift.com 
  
 470",NA
Wrap up ,"You've just finished two hard projects back to back, and regardless of how much you have 
 learned you deserve kudos for all your patience. This project required you to follow several 
 long steps before you could see your code run. I hope it was worth it, and I hope in 
 retrospect that you can see why all the code was needed.
  
 Along the way, you've learned all about 
 SKShapeNode
 , 
 AVAudioPlayer
 , 
 UIBezierPath
 , 
 custom enums, default method parameters, and more, so you're several steps closer to your 
 goal of being an experienced Swift developer. Well done!
  
 If you're looking to improve this project some more, and you're able to steer yourself away 
 from the particle editor for a few minutes, why not have a go at removing the magic numbers 
 in the 
 createEnemy()
  method. Instead, define them as constant properties of your class, 
 giving them useful names. You could also try adding a new and fast-moving type of enemy 
 that awards the player bonus points if they hit it.
  
 www.hackingwithswift.com 
  
 473",NA
Project 18 ,NA,NA
iAd and ,NA,NA
Debugging,NA,NA
A double bill of learning teaches you how to place ,NA,NA
adverts and debug your code.,NA,NA
Setting up ,"With two hard projects under your belt, let's take a breather and try some easier stuff: iAd, 
 Apple's advertising network. How easy is iAd? So easy that I decided this technique project 
 was so short I needed to add something else to make it worth your time, so I added a section 
 debugging with Xcode.
  
 To get started with iAd, create a new Single View Application project in Xcode, named 
 Project18 and targeting any device you like.
  
 www.hackingwithswift.com 
  
 475",NA
iAd in 10 minutes ,"Can iAd really be taught in ten minutes? Absolutely, and I won't even need to rush. This is 
 because the hard work of iAd is done in two places: Interface Builder and iTunes Connect 
 (iTC). You haven't met iTC yet, but it's the content management system for app developers 
 that lets you create apps, set prices, upload screenshots, and more. iTC is also where you 
 opt in to iAd, and then you get paid through your normal payment method.
  
 So: all the enabling, all the contracts, all the payment and so on are handled through iTunes 
 Connect. The next job is taken care of by Interface Builder: it has an iAd object in its object 
 library, and you can just place your advert where you want it in a view controller, and 
 constraints, and you're almost done.
  
 To make things a little more interesting, I'm going to show you how to create an iAd advert in 
 code. This is actually a fairly common thing to do, because many apps that show adverts also 
 have an in-app purchase to remove those ads. Making your adverts in code means you can 
 manage that process much more efficiently.
  
 First, you need to import the iAd coding framework, so put this at the top, just before the 
 import UIKit
  line:
  
 import iAd 
 Now add this property so we can reference the iAd banner view throughout our class:
  
 var bannerView: ADBannerView! 
 The actual act of creating an iAd for your screen is a matter of using the 
 ADBannerView 
 class. Apple's guidelines for using this class say that you should only have one visible at a 
 time, that you should share the view across view controllers if possible, and that you should 
 hide it if no ads are showing.
  
 We're going to create the banner view and start it as hidden. Then, by setting ourself as the 
 delegate, we'll get told by iAd if a banner loaded or not, at which point we can choose to 
 show the advert.
  
 www.hackingwithswift.com 
  
 476",NA
Debugging in Xcode ,"Using iAd is so easy that I figured you'd want more. And you're still reading, so I guess I was 
 right! To give you a little more bang for your buck, I'm going to walk you through some of the 
 ways you can find problems in your code and fix them – a process known as 
 debugging
 . 
 Please create a new Single View Application project named Project18b and targeting iPhone.
  
 We're going to start with the absolute easiest, which is the 
 print()
  function. This prints a 
 message into the Xcode debug console that can say anything you want, because users won't 
 see it in the UI. The ""scattershot"" approach to bug fixing is to litter your code with calls to 
 print()
  
 then follow the messages to see what's going on.
  
 You'll meet lots of people telling you how bad this is, but the truth is it's the debugging method 
 everyone starts with – it's easy, it's natural, and it often gives you enough information to solve 
 your problem. Use it with Swift's string interpolation to see the contents of your variables when 
 your app is running.
  
 One level up from 
 print()
  are assertions, which are debug-only checks that will force your 
 app to crash if a specific condition isn't true. When you ship your app to the App Store, 
 Xcode automatically disables your assertions so they have no impact on performance.
  
 Here's a very basic example:
  
 assert(1 == 1, ""Maths failure!"") 
 assert(1 == 2, ""Maths failure!"") 
 As you can see 
 assert()
  takes two parameters, and they are something to check, and a 
 message to print out of the check fails. If the check evaluates to false, your app will be forced 
 to crash because you know it's not in a safe state, and you'll see the error message in the 
 debug console.
  
 The advantage to assertions is that their check code is never executed in a live app, so your 
 users are never aware of their presence. This is different from 
 print()
 , which would remain in 
 your code if you shipped it, albeit mostly invisible.
  
 Because calls to 
 assert()
  are ignored in release builds of your app, you can do complex 
  
 www.hackingwithswift.com 
  
 481",NA
Wrap up ,"I couldn't in good conscience show you iAd by itself, because it's just so darn easy to use. But 
 on the flip side, it at least means you got a lightning intro to Xcode debugging. There are lots 
 of options to choose from, and you will, I promise, use all of them at some point. Yes, even 
 print()
 .
  
 There's more to learn about debugging, such as the Step Into and Step Out commands, but 
 realistically you need to start with what you have before you venture any further. I would much 
 rather you mastered three of the debugging tools available to you rather than having a weak 
 grasp of all of them.
  
 www.hackingwithswift.com 
  
 485",NA
Project 19 ,NA,NA
Capital Cities,NA,NA
Teach users about geography while you learn ,NA,NA
about MKMapView and annotations.,"www.hackingwithswift.com 
  
 486",NA
Setting up ,"It's time for another app project, and this time you're going to learn about 
 MapKit
  – Apple's 
 mapping framework that lets us drops pins, plan routes, and zoom around the world with just a 
 few swipes.
  
 Working with MapKit requires you to learn quite a few new classes, so I've tried to construct a 
 project simple enough that we can focus on the mapping element. In this project you'll make 
 an app that shows the locations of capital cities around the world, and when one of them is 
 tapped you can bring up more information.
  
 Create a new Single View Application project in Xcode, name it Project19 and set its target to 
 be iPhone. Now go to Interface Builder for your view controller, and embed it inside a 
 navigation controller. Search for ""map"" in the object library, drop a map view into your view 
 controller so that it occupies the full view, then use Resolve Auto Layout Issues > Add Missing 
 Constraints so that it stays next to each edge.
  
 Now, run your program and… crash? Oh dear. Time for some code!
  
 www.hackingwithswift.com 
  
 487",NA
Up and running with MapKit ,"Select your project in the project navigator – it's the top thing, with a blue icon next to it. In the 
 center of the Xcode window you'll see lots of options, and this is usually where you limit the 
 orientation of your app. But this time, I want you to go up to the list of tabs and change from 
 General to Capabilities, because we're going to ask that our app be allowed to use maps.
  
 There are lots of capabilities you can request on this screen, but the one we're looking for 
 right now is called simply ""Maps"". Find it, then change its switch from Off to On. You should 
 be able to try running your app again, because this time will work.
  
 In the picture below you can see the Entitlements tab showing map support being enabled.
  
  
 You must use the Entitlements tab to enable support for MapKit.
  
 You'll see a default map view, and you can pan around, zoom in and out, and so on. If you 
 were wondering, you need to hold down Alt to trigger a virtual ""pinch"" gesture – just click and 
 drag as if you were moving one finger, and the other ""finger"" will move in the opposite 
  
 www.hackingwithswift.com 
  
 488",NA
Annotations and accessory views ,"Every time the map needs to show an annotation, it calls a 
 viewForAnnotation
  method on 
 its delegate. We don't implement that method right now, so the default red pin is used with 
 nothing special – although as you've seen it's smart enough to pull out the title for us.
  
 Customising an annotation view is a little bit like customising a table view cell or collection view 
 cell, because iOS automatically reuses annotation views to make best use of memory. If there 
 isn't one available to reuse, we need to create one from scratch using the 
  
 MKPinAnnotationView
  class.
  
 Our custom annotation view is going to look a lot like the default view, with the exception that 
 we're going to add a button that users can tap for more information. So, they tap the pin to see 
 the city name, then tap its button to see more information. In our case, it's those fascinating 
 facts I spent literally tens of seconds writing.
  
 There are a couple of things you need to be careful of here. First, 
 viewForAnnotation
  will be 
 called for your annotations, but also Apple's. For example, if you enable tracking of the user's 
 location then that's shown as an annotation and you don't want to try using it as a capital city. 
 If an annotation is not one of yours, just return 
 nil
  from the method to have Apple's default 
 used instead.
  
 Second, adding a button to the view isn't done using the 
 addTarget()
  method you already 
 saw in project 8. Instead, you just add the button and the map view will send a message to 
 its delegate (us!) when it's tapped.
  
 Here's a breakdown of what the method will do:
  
 1. Define a reuse identifier. This is a string that will be used to ensure we reuse annotation 
 views as much as possible.
  
 2. Check whether the annotation we're creating a view for is one of our 
 Capital
  objects. 
 3. Try to dequeue an annotation view from the map view's pool of unused views.
  
 4. If it isn't able to find a reusable view, create a new one using 
 MKPinAnnotationView
  and 
 sets its 
 canShowCallout
  property to be true. This triggers the popup with the city name. 5. 
 Create a new 
 UIButton
  using the built-in 
 .DetailDisclosure
  type. This is a small blue ""i"" 
 symbol with a circle around it.
  
 6. If it can reuse a view, update that view to use a different annotation.
  
 7. If the annotation isn't from a capital city, it must return 
 nil
  so iOS uses a default view.
  
 www.hackingwithswift.com 
  
 493",NA
Wrap up ,"I tried to keep this project as simple as possible so that you can focus on the map 
  
 component, because there's a lot to learn: 
 MKMapView
 , 
 MKAnnotation
 , 
  
 MKPinAnnotationView
 , 
 CLLocationCoordinate2D
  and so on, and all must be used before 
 you get a finished product.
  
 Again, we've only scratched the surface of what maps can do in iOS, but that just gives you 
 more room to extend the app yourself! Try adding a 
 UIAlertController
  action sheet that lets 
 users specify how they want to view the map. There's a 
 mapType
  property that draws the 
 maps in different ways. For example, 
 .Satellite
  gives a satellite view of the terrain.
  
 If you want to try something harder, you could typecast the return value from 
  
 dequeueReusableAnnotationViewWithIdentifier()
  so that it's an 
 MKPinAnnotationView
 . 
 This will always be the case, because that's what we're creating. But once you typecast the 
 return value, it means you can change the 
 pinColor
  property to either 
 .Red
 , 
 .Green 
 or 
 .Purple
 . With that information, try to add a ""Favorite"" button to cities: regular cities are red, 
 favorites are green.
  
 www.hackingwithswift.com 
  
 497",NA
Project 20 ,NA,NA
Fireworks ,NA,NA
Night,NA,NA
Learn about timers and color blends while making ,NA,NA
things go bang!,NA,NA
Setting up ,"In this game project we're going to let users create fireworks displays using their fingers. 
 They'll need to touch fireworks of the same color, then shake their device to make them 
 explode. Shaking an iPad isn't the most pleasant user experience, but I had to find 
 some 
 way of teaching you about shake gestures!
  
 On the topic of what you'll learn, you're going to meet 
 NSTimer
 , you're going to use sprite 
 color blending, and you're going to try the 
 followPath()
  SpriteKit action.
  
 Create a new SpriteKit project in Xcode, name it project 20, and set its target to be iPad. 
 Force its orientation to be landscape. Now download the files for this project from 
 GitHub 
 and drag the Content folder into your Xcode project.
  
 You should, like always with SpriteKit, delete the existing spaceship image from 
 Images.xcassets and delete the contents of the 
 didMoveToView()
  and 
 touchesBegan() 
 methods.
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 499",NA
Ready... aim... fire!,"To get the game up and running quickly, we're going to work on the three methods required to 
 launch some fireworks: 
 didMoveToView()
  (will create a timer that launches fireworks every six 
 seconds), 
 createFirework()
  (will create precisely one firework at a specific X/Y position) and 
 launchFireworks()
  (will call 
 createFirework()
 ; designed to create firework spreads.)
  
 First, the easy stuff: we need to add some properties to our class:
  
  • 
 gameTimer
  will be a new class called 
 NSTimer
 . We'll use this to call the 
 launchFireworks()
  method every six seconds.
  
  • 
 fireworks
  will be an array of 
 SKNode
  objects. Fireworks, like the bomb fuse in project 17, 
 will have a container node, an image node and a fuse node. This avoids accidental taps 
 triggered by tapping on the fuse of a firework.
  
  • 
 leftEdge
 , 
 bottomEdge
  and 
 rightEdge
  are used to define where we launch fireworks from. 
 Each of them will be just off screen to one side.
  
  • 
 score
  will track the player's score. I'm going to give you a 
 didSet
  property observer but 
 leave it blank for you to fill in later – you should know how to show a score label by now!
  
 The only thing that's new in there is the 
 NSTimer
  class, and we'll come to that in a moment. 
 First, add these properties now:
  
 var gameTimer: NSTimer! 
 var fireworks = [SKNode]() 
 let leftEdge = -22 
 let bottomEdge = -22 
 let rightEdge = 1024 + 22 
 var score: Int = 0 { 
  didSet { 
  // your code here 
  } 
 } 
 www.hackingwithswift.com
  
 500",NA
Swipe to select ,"Now that you can see fireworks shooting across your screen, it's time to reveal the difficulty 
 element. You see, every game needs some challenge, and in our case the challenge is to 
 destroy fireworks in groups of the same color. We're going to make it so that players can 
 select only one color of firework at a time, so if they choose two red then touch a green, the 
 two red will become deselected.
  
 So, the challenge will be to select and detonate fireworks based on their color, and as you'll 
 see shortly we're going to heavily bias scores so that players receive many more points for 
 larger groups.
  
 What we're going to code now is the touch handling method, 
 checkForTouches()
 . We're 
 going to call this from 
 touchesBegan()
  and 
 touchesMoved()
  so that users can either tap to 
 select fireworks or just swipe across the screen.
  
 The method needs to start by figuring out where in the scene the player touches, and what 
 nodes are at that point. It will then loop through all nodes under the point to find any with the 
 name ""firework"". When it finds one, it will set its name to be ""selected"" rather than ""firework"" 
 and change its 
 colorBlendFactor
  value to be white. That will disable the color blending 
 entirely, making the firework white.
  
 Here's the 
 checkForTouches()
  method with that functionality in there:
  
 func checkForTouches(touches: Set<UITouch>) { 
  guard let touch = touches.first else { return } 
  let location = touch.locationInNode(self) 
  let nodes = nodesAtPoint(location) 
  for node in nodes { 
  if node.isKindOfClass(SKSpriteNode.self) { 
  let sprite = node as! SKSpriteNode 
  if sprite.name == ""firework"" { 
  sprite.name = ""selected"" 
 www.hackingwithswift.com 
  
 509",NA
Making things go bang ,"This is easily the best bit of the game, mostly because it involves even more particle systems. 
 There are three things we need to create: a method to explode a single firework, a method to 
 explode all the fireworks (which will call the single firework explosion method), and some code 
 to detect and respond the device being shaken.
  
 First, the code to explode a single firework. Put this somewhere in your game scene:
  
 func explodeFirework(firework: SKNode) { 
  let emitter = SKEmitterNode(fileNamed: ""explode"")! 
  emitter.position = firework.position 
  addChild(emitter) 
  firework.removeFromParent() 
 } 
 You should be able to read that once and know exactly what it does: it creates an explosion 
 where the firework was, then removes the firework from the game scene.
  
 The 
 explodeFireworks()
  method is next, and is only fractionally more complicated. It will be 
 triggered when the user wants to set off their selected fireworks, so it needs to loop through 
 the 
 fireworks
  array (backwards again!), pick out any selected ones, then call 
  
 explodeFirework()
  on it.
  
 As I said earlier, the player's score needs to go up by more when they select more fireworks, 
 so about half of the 
 explodeFireworks()
  method is taken up with figuring out what score to 
 give the player.
  
 There's one small piece of extra complexity: remember, the 
 fireworks
  array stores the 
 firework container node, so we need to read the firework image out of its 
 children
  array.
  
 Enough talk – here's the code:
  
 func explodeFireworks() { 
 www.hackingwithswift.com 
  
 513",NA
Wrap up ,"I've enjoyed making this project, so I hope you enjoyed following along. Plus you have yet 
 more Swift coding experience under your belt, now complete with 
 NSTimer
 , 
 followPath()
 , 
 color blending and, yes, even the shake gesture – although I wouldn't be surprised if you 
 switch to having a button on the screen to make explosions easier!
  
 There's a lot more you can do with this foundation behind you. How about adding a score 
 label? Or perhaps adding different fireworks spread types, for example one where fireworks 
 launch from the left and right? Or if you fancy a bigger challenge, how about making the game 
 end after a certain number of launches? You will need to use the 
 invalidate()
  method of 
 NSTimer
  to stop it from repeating.
  
 www.hackingwithswift.com 
  
 516",NA
Project 21 ,NA,NA
Local ,NA,NA
Notifications,NA,NA
"Send reminders, prompts and alerts even when your ",NA,NA
app isn't running.,NA,NA
Setting up ,"This is going to be the easiest technique project in the entire series, and I expect you're 
 extremely relieved to hear that because it can be hard going always having to learn new 
 things!
  
 What you're going to learn about are local notifications, which let you send reminders to your 
 user's lock screen to show them information when your app isn't running. If you set a reminder 
 in your calendar, making it pop up on your lock screen at the right time is a local notification.
  
 These aren't the same as push notifications, and in fact they are quite a different beast from a 
 development perspective. I would love to cover push notifications here, but they require a 
 dedicated server (or service, if you outsource) to send from and that's outside the remit of this 
 course.
  
 To get started, create a new Single View Application project in Xcode, name it Project21, and 
 set it to target any device.
  
 www.hackingwithswift.com 
  
 518",NA
Scheduling notifications ,"Open Main.storyboard in Interface Builder and place two buttons, one above the other. The 
 first should have the title ""Register Local"" and the second the title ""Schedule Local"". Add 
 whatever constraints you think sensible, but ideally make them centered horizontally so they 
 fit any device. Using the assistant editor, create an action for each: 
 registerLocal()
  and 
 scheduleLocal()
 . Now go back to the standard editor and switch to ViewController.swift.
  
 Let me explain how this project needs to work. First, you can't post messages to the user's 
 lock screen unless you have their permission. This was changed in iOS 8, but it's quite 
 sensible – it would, after all, be awfully annoying if any app could bother you when it pleased.
  
 So, in order to send local notifications in our app, we first need to request permission, and 
 that's what we'll put in the 
 registerLocal()
  method. You register your settings based on what 
 you actually need, and that's done with a class called 
 UIUserNotificationSettings
 . For this 
 example we're going to request an alert (a message to show), along with a badge (for our 
 icon) and a sound (because users just 
 love
  those.)
  
 Once you've created your notification settings object, it's just a matter of calling the 
  
 registerUserNotificationSettings()
  method to tell iOS what you want, and it will then prompt 
 the user if needed. If you requested access before and were denied, nothing will be shown.
  
 Change your 
 registerLocal()
  method to be this:
  
 @IBAction func registerLocal(sender: AnyObject) { 
  let notificationSettings = UIUserNotificationSettings(forTypes: [.Alert, .Badge, .Sound], 
 categories: nil) 
 UIApplication.sharedApplication().registerUserNotificationSettings(no tificationSettings) 
 } 
 Helpful tip: if you want to test allowing or denying permission, just reset the simulator and run 
 the app again to get a clean slate. Choose the iOS Simulator menu then ""Reset Content and 
 Settings"" to make this happen.
  
 www.hackingwithswift.com 
  
 519",NA
Acting on responses ,"There's one more thing to learn before we're done with notifications, and that's what happens 
 to your application when it's given a notification to process. So far we've just been scheduling 
 them, but if the user swipes on a notification to unlock their device, your app is launched and 
 given the notification to process. Also, what happens if the user is actually inside your app 
 while one of your notifications fires?
  
 These are two separate cases under the hood, and both need to be addressed 
  
 independently. In your AppDelegate.swift file we've already briefly looked at the 
  
 didFinishLaunchingWithOptions
  method, but we didn't look at what the ""options"" might be. 
 Well, if your app was lauched from a notification, this is how iOS will tell you, so let's take a 
 closer look now.
  
 First, this is how 
 launchOptions
  is defined:
  
 [NSObject: AnyObject]? 
 Translated, it's an optional dictionary where an NSObject (or subclass) will be the key and 
 any object can be the value.
  
 In order to read information about the notification, we need first to unwrap this optional so 
 that we have a real dictionary on our ends. Then we need to look up the (
 *deep breath*
 ) 
 UIApplicationLaunchOptionsLocalNotificationKey
  key. Yes, that's absurdly long. If that 
 exists, it will be a 
 UILocalNotification
  object, so we need to conditionally typecast it using 
 as?
 .
  
 Once we have the 
 UILocalNotification
  object, we need to see if it has a 
 userInfo
  value, which 
 means more optional unwrapping. And finally, if we've made it this far, we will have the same 
 data we set for 
 userInfo
  back when scheduling the notification, so you can do with it as you 
 please.
  
 Modify your 
 didFinishLaunchingWithOptions
  method to this:
  
 func application(application: UIApplication,  
 didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)  
 www.hackingwithswift.com 
  
 524",NA
Wrap up ,"That was easy, right? And yet it's such a great feature to have, because now your app can 
 talk to users even when it isn't running. You want to show a step count for how far they've 
 walked? Local notification. You want to trigger an alert because it's their turn to play in a 
 game? Local notification. You want to send them marketing messages to make them buy 
 more stuff? Actually, just don't do that, you bad person.
  
 If you're curious about push notifications then check out something like 
 pushwizard.com
 , 
 because you need a server somewhere that can store which devices to send to and handle 
 delivery of the messages.
  
 www.hackingwithswift.com 
  
 527",NA
Project 22 ,NA,NA
Detect-a-,NA,NA
Beacon,NA,NA
Learn to find and range iBeacons using our first project ,NA,NA
for a physical device.,NA,NA
Setting up ,"Apple introduced iBeacon technology with iOS 7, and it's helped make the Internet of Things 
 hypefest even more stratospheric. In this project you're going to learn to detect and range 
 beacons, which in turn means learning how to ask your user for their location. With this, you'll 
 have all the tools required to make your own location-aware apps – just scatter a few beacons 
 around your house!
  
 If you don't have any iBeacons at home, that's OK because most people don't. Instead, I 
 recommend you install the app ""Locate Beacon"" on your iPad or iPhone, because that comes 
 with an iBeacon transmitter built in, making it perfect for testing. You also need an iOS device 
 that's compatible with iBeacons, which means iPhone 4s or later, 3rd generation iPad or later, 
 iPad Mini or later, or 5th generation iPod Touch or later. I'm afraid the iOS Simulator won't 
 work, but you can at least follow along with the code. Please ensure you have Bluetooth 
 enabled on your device.
  
 If you've never pushed an app to a real device before, you need to make sure you select the 
 device from the list of destinations. You can do this by clicking where it says ""Project22"" to the 
 right of the play and stop buttons, or by going to the Product menu and choosing Destination 
 then selecting your device. If it comes up with ""ineligible"" it means your device is running an 
 older version of iOS than your project is designed for, so you may need to go to your project 
 settings (where you configure orientation) and change Deployment Target to match.
  
 Create a new Single View Application project in Xcode, name it Project22 and set its target to 
 be whichever of the above devices you own.
  
 www.hackingwithswift.com 
  
 529",NA
Requesting location ,"It should come as no surprise that Apple considers a user's location to be private, and that 
 means we need to ask for permission to use it. From iOS 8 onwards, how you ask for 
 permission depends on what you're trying to do: would you like the user's location only when 
 your app is running, or would you like a user's location even when your app isn't running?
  
 You might think that you'd only ever want location access when your app is running. After all, 
 what's the point in asking for information when your app isn't around to use it?
  
 There are times you'll want both. For example, if you're creating a map app that shows users 
 how to get from their current location to your nearest store, you'll only need their location 
 when the app is being used. But if you're creating an app that needs to be woken up when the 
 user reaches a location, then you'll need access even when the app isn't running – iOS 
 monitors the user's location on your behalf and automatically starts your app as needed.
  
 Requesting location access requires a change to your apps Info.plist file, which is the 
 property list file we met in project 16. Depending on whether you want ""always"" access or 
 just ""when in use"" you need to set one key or the other. Select your property list, then go to 
 the Editor menu and choose Add Item. Now change the name of your new item to either:
  
  • 
 NSLocationAlwaysUsageDescription
  if you want to have the user's location even when 
 the app isn't running.
  
  • 
 NSLocationWhenInUseUsageDescription
  if you only want the user's location when the 
 app is running.
  
 You should make sure the type is set to String, then in the value field enter some text to 
 explain to users 
 why
  you want their location. For example, ""We want to help you find your 
 nearest store."" When your user is prompted to grant location access, this text will be shown 
 alongside Apple's own descriptive message.
  
 www.hackingwithswift.com 
  
 530",NA
Hunting the beacon ,"If everything is working, you should have received a large iOS confirmation prompt asking 
 whether you grant the user access to their location. This message is really blunt, so users 
 hopefully take a few moments to read it before continuing.
  
 But that prompt is not the only way iOS helps users guard their privacy. If you went for ""when in 
 use"", you'll still get location information while your app is in the background if you enable the 
 background capability, and iOS will notify users that this is happening by making the device 
 status bar blue and saying ""YourAppName is using your location."" If you went for ""always"", iOS 
 will wait a few days then ask the user if they still want to grant permission, just to be fully sure.
  
 Assuming everything went well, let's take a look at how we actually range beacons. First, we 
 use a new class called 
 CLBeaconRegion
 , which is used to identify a beacon uniquely. 
  
 Second, we give that to our 
 CLLocationManager
  object by calling its 
  
 startMonitoringForRegion()
  and 
 startRangingBeaconsInRegion()
  methods. Once that's 
 done, we sit and wait. As soon as iOS has anything tell us, it will do so.
  
 iBeacons are identified using three pieces of information: a universally unique identifier 
 (UUID), plus a major number and a minor number. The first number is a long hexadecimal 
 string that you can create by running the 
 uuidgen
  in your Mac's terminal. It should identify 
 you or your store chain uniquely.
  
 The major number is used to subdivide within the UUID. So, if you have 10,000 stores in your 
 supermarket chain, you would use the same UUID for them all but give each one a different 
 major number. That major number must be between 1 and 65535, which is enough to identify 
 every McDonalds and Starbucks outlet combined!
  
 The minor number can (if you wish) be used to subdivide within the major number. For 
 example, if your flagship London store has 12 floors each of which has 10 departments, you 
 would assign each of them a different minor number.
  
 The combination of all three identify the user's precise location:
  
  • 
 UUID:
  You're in a Acme Hardware Supplies store. 
 • 
 Major:
  You're in the Glasgow branch.
  
  • 
 Minor:
  You're in the shoe department on the third floor.
  
 www.hackingwithswift.com 
  
 535",NA
Wrap up ,"Working with iBeacon locations is different from working with maps. The technology is often 
 called 
 micro-location
  because it can tell the difference between a few centimeters and a meter 
 or more. Plus it works inside, which is somewhere GPS continues to be poor, and 
 understandably.
  
 What you've produced is designed to do ranging, but you could easily make it ignore the range 
 data and just focus on whether a beacon is present. For example, if the beacon in your house is 
 present (regardless of range), you could make your app show home-related tasks that you have 
 pre-configured.
  
 www.hackingwithswift.com 
  
 539",NA
Project 23 ,NA,NA
Space Race,NA,NA
Dodge space debris while you learn about per-,NA,NA
pixel collision detection.,"www.hackingwithswift.com 
  
 540",NA
Setting up ,"In this game project we'll seek to answer the question, ""how fast can you make a fun game 
 in SpriteKit?"" Spoiler warning: the answer is very fast. And that's even when you ignore 
 learning about advancing particle systems, linear and angular damping, and per-pixel 
 collision detection.
  
 The game we're going to produce is a very simple survival game: our player will have to pilot a 
 spaceship safely through a field of space junk. The longer they stay alive the higher their 
 score will be, but they need to keep moving otherwise certain death awaits!
  
 Remarkably, we're going to make this project in just over 100 lines of code. To begin, create a 
 new SpriteKit project in Xcode, name it Project23 and set its target to be iPad. Configure it 
 work only in landscape, then download the files for this project and copy the Content folder 
 into your project. Now delete the spaceship from Images.xcassets and all the code from inside 
 didMoveToView()
  and 
 touchesBegan()
 .
  
 All done? Start the clock – let's see how long it takes to make this game!
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 541",NA
Space: the final frontier ,"To begin with we're going to place a handful of things that are required to make our game 
 work: a starfield (not a static background picture this time), the player image, plus a score 
 label. Those three things will use an 
 SKEmitterNode
 , an 
 SKSpriteNode
  and an 
  
 SKLabelNode
  respectively, so let's declare them as properties now:
  
 var starfield: SKEmitterNode! 
 var player: SKSpriteNode! 
 var scoreLabel: SKLabelNode! 
 var score: Int = 0 { 
  didSet { 
  scoreLabel.text = ""Score: \(score)"" 
  } 
 } 
 As per usual, we're using a property observer to update the score label as needed.
  
 In order to get those properties set up with meaningful values, we're going to put a lot of 
 code into 
 didMoveToView()
  so that everything is created and positioned up front.
  
 I'm not going to bore you by going through every line of code – three quarters of it you 
 should know by heart at this point! – but I do want to point out a few interesting things.
  
 First, the starfield particle emitter is positioned at X:1024 Y:384, which is the right edge of the 
 screen and half way up. If you created particles like this normally it would look strange, because 
 most of the screen wouldn't start with particles and they would just stream in from the right. But 
 by using the 
 advanceSimulationTime()
  method of the emitter we're going to ask SpriteKit to 
 simulate 10 seconds passing in the emitter, thus updating all the particles as if they were 
 created 10 seconds ago. This will have the effect of filling our screen with star particles.
  
 Second, because the spaceship is an irregular shape and the objects in space are also 
  
 www.hackingwithswift.com 
  
 542",NA
Bring on the enemies!,"The point of our game is for the spaceship to survive while random ""space debris"" gets thrown 
 at it. I've included three items of various shapes in this example, but you can add more easily 
 enough. As long as the player stays alive their score ticks upwards, so clearly it's going to take 
 some quick movement to get the highest score.
  
 To add enemies and time to the game, we need to declare four new properties:
  
 var possibleEnemies = [""ball"", ""hammer"", ""tv""] 
 var gameTimer: NSTimer! 
 var gameOver = false 
 The 
 possibleEnemies
  array contains the names of the three images that can be used as 
 space debris in the game: a ball, a hammer and a TV. You met 
 NSTimer
  in project 20, and 
 we'll be using it here to create new enemies regularly. Finally, 
 gameOver
  is a simple boolean 
 that will be set to true when we should stop increasing the player's score.
  
 We need to create a new enemy on a regular basis, so the first thing to do is create a 
 scheduled timer. I'm going to give it a timer interval of 0.35 seconds, so it will create about 
 three enemies a second. Put this code into 
 didMoveToView()
 :
  
 gameTimer = NSTimer.scheduledTimerWithTimeInterval(0.35, target: self, selector: 
 ""createEnemy"", userInfo: nil, repeats: true) 
 Creating an enemy needs to use techniques that you've mostly seen already: it will shuffle 
 the 
 possibleEnemies
  array, create a sprite node using the first item in that array, position it 
 off the right edge and with a random vertical position, then add it to the scene.
  
 That part is old. The new part is the way we're going to create the physics body of the debris: 
 we're going to use per-pixel collision again, tell it to collide with the player, make it move to the 
 left at a fast speed, and give it some angular velocity. But we're also going to set to 0 its 
 linearDamping
  and 
 angularDamping
  properties, which means its movement and rotation will 
 never slow down over time. Perfect for a frictionless space environment!
  
 www.hackingwithswift.com 
  
 546",NA
Making contact ,"Check your clock, because remarkably we're just two methods away from finishing this 
 game! Predictably, the two methods are critically important: one to move the player around 
 the screen, and one to handle collisions between the player and the space debris.
  
 Handling player movement is as simple as implementing the 
 touchesMoved()
  method. We 
 will, like always, need to use the 
 locationInNode()
  method to figure out where on the screen 
 the user touched. But this time we're going to clamp the player's Y position, which in plain 
 English means that we're going to stop them going above or below a certain point, keeping 
 them firmly in the game area.
  
 I'll be clamping the player's position so they can't overlap the score label, and I'll apply the 
 same restriction on top so that the player has a symmetrical channel to fly through. This is a 
 cinch to do, so here's the 
 touchesMoved()
  method:
  
 override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { 
  guard let touch = touches.first else { return } 
  var location = touch.locationInNode(self) 
  if location.y < 100 { 
  location.y = 100 
  } else if location.y > 668 { 
  location.y = 668 
  } 
  player.position = location 
 } 
 Our last task is to end the game when the player hits any piece of space debris. This is all code 
 you know already: we're going to create a particle emitter, position it where the player is (or 
 was!), and add the explosion to the scene while removing the player. In this game we're also 
 going to set 
 gameOver
  to be true so that the 
 update()
  method stops adding to their 
  
 www.hackingwithswift.com 
  
 550",NA
Wrap up ,"That's it! We just made a game in 20 minutes or so, which shows you just how fast SpriteKit 
 is. I even showed you how per-pixel collision detection works (it's so easy!), how to advance 
 particle systems so they start life with some history behind them, and how to adjust linear and 
 angular damping so that objects don't slow down over time.
  
 If you're tempted to work on this project some more, you could start by fixing a bug: if the player 
 gets in a difficult position, they can just remove their finger from the screen then touch 
 somewhere else to have the spaceship immediately jump there. How could you fix this? Well, 
 one easy way is to add code for 
 touchesEnded()
  that terminates the game if the player stops 
 touching the screen.
  
 If you're looking for something bigger to try, how about turn this game into a full space shooter. 
 To do this, you need to create lasers going the opposite way, then make those lasers also 
 collide with the space debris. In terms of controls, it wouldn't be hard to use 
  
 touchesMoved()
  to move the player and 
 touchesBegan()
  to fire lasers.
  
 www.hackingwithswift.com 
  
 552",NA
Project 24 ,NA,NA
Swift ,NA,NA
Extensions,NA,NA
Try your hand at improving the built-in data types of Swift.,NA,NA
Setting up ,"There's one technique I've been patiently waiting to show you since this series started, and 
 now is the right time: extensions. Cunningly, this is not at all the same thing I already showed 
 you in project 16, which was when we created an extension to Safari. This time we're going to 
 create extensions for Swift – literally extending the language so it can do more things.
  
 This isn't complicated, honest. We're not trying to make Swift do things it wasn't designed to do; 
 in fact, I'd wager that language extensions are used in nearly all major projects that are 
 shipping today. Why? Because they let you attach functionality to data types you didn't create. 
 You've seen time and time again how we can add any methods we want to our own classes. 
 Well, extensions let you do that to other classes and structs, including Apple's own.
  
 There isn't enough in extensions to give you an intellectual challenge, so you're going to 
 learn about extensions while using a Swift playground. We haven't used these yet because 
 they haven't been appropriate, but now is a good chance. I'm also going to take this 
 opportunity to outline in more detail the differences between functions and methods.
  
 In Xcode, go to the File menu and choose New > Playground. Name it Project24, make sure 
 iOS is selected as the platform, then choose Next and save it somewhere you can find later. 
  
 Swift playgrounds are split into two columns: the left half contains your code, the right 
 contains your output.
  
 www.hackingwithswift.com 
  
 554",NA
Adding to integers ,"I've been asking you to use a file called Helper.swift several times so far in this series, and it's 
 basically a collection of interesting functions that do a handful of difficult tasks. However, that 
 file is messy: it has function names like 
 RandomCGFloat()
  and 
 RandomColor()
  mixed 
 together even though they do quite different things.
  
 This gets confusing. It gets confusing because we don't know where these functions come 
 from, it gets confusing because we're filling the code completion database with global 
 functions that have similar names, and it gets confusing because these functions don't all 
 take uniform parameters. Extensions can help us fix the first two, because it lets us move 
 these global functions to be methods inside a class or struct.
  
 We're going to start with an extremely simple extension so you can get a basic grip on how 
 things work before moving on to more complicated examples.
  
 Let's start with an extension that adds one to an integer. Yes, I realise this is essentially just 
 += 1
 , but we're starting simple. Put this in your playground:
  
 import UIKit 
 var myInt = 0 
 This code will be evaluated immediately, so in the right column you'll see 0. This tells you that 
 the 
 myInt
  variable has the value 0. Now add this to the playground, just beneath the 
 import 
 UIKit
  statement:
  
 extension Int { 
  func plusOne() -> Int { 
  return self + 1 
  } 
 } 
 www.hackingwithswift.com
  
 555",NA
Cleaning up the mess ,"I've been using the words 
 function
  and 
 method
  a lot so far, but haven't stopped to explain the 
 difference. Well, there is a difference, but it's not really that important despite what many 
 pedants might tell you. Heck, even Swift uses 
 func
  for both functions and methods.
  
 The main difference between a function and a method is that a method belongs to a particular 
 class, struct or enum. Methods that belong to a class have access to all the class's data, and 
 are useful because they help to encapsulate functionality. This means that an object owns its 
 data, and the same object is responsible for manipulating that data using its methods. 
 Functions, however, are global beasts: they don't belong to a particular class, so they can be 
 called anywhere.
  
 There is one other difference between the two in Swift, and that's how parameters are 
 handled. In project 14 we used a method called 
 show()
  to show enemies, and it accepted as 
 a parameter how long to wait until hiding the enemies. As I said then, this would by default be 
 callable like this:
  
 show(1) 
 Problem is, the 1 is meaningless. As a result, Apple makes their own method names longer to 
 try to describe what the first parameter is doing, for example they would probably have called 
 that method 
 showWithHideDelay()
  so that when you call it with 
 1
  you could read the code 
 aloud and have it make sense.
  
 The solution we used at the time was to force a label on the parameter. In Swift, this is called 
 an external parameter name, and it means that we had to call 
 show(hideTime: 1)
  to make 
 the call work.
  
 This concept of internal parameter name (the name you use inside the method/function) and 
 external parameter name (the name you use when calling the method/function) is where 
 Swift's use of methods and functions can get confusing. Here are the rules:
  
 1. By default, methods and functions have automatic external parameter names, but not for 
 the first parameter. This means you call things like 
 obj.myFunc(1, age: 101, sound: ""Moo"", 
 alive: false)
 . The first parameter doesn't have a forced external name because of Apple's use 
 of 
 veryLongDescriptiveMethodNames()
 .
  
 www.hackingwithswift.com 
  
 559",NA
Extensions for brevity ,"Like I said earlier, it's extremely common for developers to use extensions to add 
  
 functionality to things. In some ways, extensions are similar to subclasses, because we could 
 easily subclass 
 UIView
  and add new methods to it like this:
  
 func fadeOut(duration: NSTimeInterval) { 
  UIView.animateWithDuration(duration) { [unowned self] in 
  self.alpha = 0 
  } 
 } 
 So why use extensions at all? The main reason is extensibility: extensions work across all 
 data types, and they don't conflict when you have more than one. That is, we could make a 
 UIView
  subclass that adds 
 fadeOut()
 , but what if we find some open source code that 
 contains a 
 spinAround()
  method? We would have to copy and paste it in to our subclass, or 
 perhaps even subclass again.
  
 With extensions you can have ten different pieces of functionality in ten different files – they 
 can all modify 
 UIView
  directly, and you don't need to subclass anything. A common naming 
 scheme for naming your extension files is Type+Modifier.swift, for example Array 
  
 +Shuffling.swift. That's a file we've used multiple times so far, and now you can look inside it 
 and see that's an extension to the 
 Array
  type.
  
 Having extensions in different files also means you can reuse individual extensions just by 
 copying a file into a project. That's what we've been doing with the array shuffling code: 
 every time we've needed it, we've just copied the file into our project and immediately the 
 shuffle()
  method is available.
  
 If you find yourself wanting to make views fade out often, an extension is perfect for you. If 
 you find yourself trimming whitespace off strings frequently, you'll probably get tired of using 
 this monstrosity:
  
 str =  
 str.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewli 
 www.hackingwithswift.com 
  
 564",NA
Wrap up ,"Swift extensions are the smart way to add functionality to existing types, and you're going to 
 meet them time and time again – and hopefully write quite a few of your own too. They aren't 
 all-encompassing, because they don't let you add properties to a class whereas a full 
 subclass would, but they are easy to use and easy to share so I'm sure you'll use them 
 frequently.
  
 In this project, you've also learned a little of how useful Swift playgrounds can be for 
 prototyping code, because the immediate feedback you get makes it extremely easy to try 
 things out and make quick adjustments.
  
 www.hackingwithswift.com 
  
 566",NA
Project 25 ,NA,NA
Selfie Share,NA,NA
Make a multipeer photo sharing app in just 150 lines ,NA,NA
of code.,"www.hackingwithswift.com 
  
 567",NA
Setting up ,"This project is going to give you some practice with collection views, the image picker and 
 GCD, but at the same time introduce you to a new technology called the multipeer 
  
 connectivity framework. This is a way to let users form impromptu connections to each other 
 and send data, rather like BitTorrent.
  
 The app we're going to make will show photos of your choosing in a collection view. That 
 much is easy enough, because we did pretty much that already in project 10. But this time 
 there's a subtle difference: when you add a photo it's going to automatically send it to any 
 other devices you are currently connected to, and any photos they select will appear for you.
  
 Create a new Single View Application project in Xcode, naming it Project25 and selecting any 
 device you want. Please note: the nature of peer-to-peer apps is that you need to have at least 
 two copies of your app running, one to send and one to receive. Because the iOS simulator 
 only lets you run one simulated app at a time, this means you'll need to have one physical 
 device alongside your simulator.
  
 www.hackingwithswift.com 
  
 568",NA
Importing photos again ,"We've used the 
 UIImagePickerController
  class twice now: once in project 10 and again in 
 project 13, so I hope you're already comfortable with it. We also used a collection view in 
 project 10, but we haven't used it since so you might not be quite so familiar with it.
  
 Open Main.storyboard in Interface Builder, then embed the default view controller inside a 
 navigation controller. Now place a collection view so that it fills the screen and set its 
 background to be white.
  
 With the collection view selected, set cell size to be 145 wide and 145 high, and give all four 
 section insets a value of 10. Click inside the prototype cell that Xcode made for you and give it 
 the reuse identifier ""ImageView"". Finally, drop an image view into the cell so that it occupies all 
 its space, and give it the tag 1000.
  
 All the constraints in this project can be made automatically, so go to the Editor menu and 
 choose Resolve Auto Layout Issues > Add Missing Constraints.
  
 Before we're done with the storyboard, please make our view controller the data source and 
 delegate of the collection view – Ctrl-drag from the collection view to the view controller icon 
 just above the view. Now use the assistant editor to create an outlet for it called 
  
 collectionView
 .
  
 Go back to the standard editor and open up ViewController.swift, because we're finished with 
 the user interface and can plug in the code. Note that almost all of this has been covered in 
 other projects, so we're not going to waste much time here when there are far more 
  
 interesting things around the corner!
  
 To start, add a right bar button item that uses the system's camera icon and calls an 
 importPicture()
  method that we'll write shortly. I'm also going to customise the title of the 
 view controller so that it isn't empty, so here's the new 
 viewDidLoad()
  method:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
  title = ""Selfie Share"" 
  navigationItem.rightBarButtonItem =  
 www.hackingwithswift.com 
  
 569",NA
Going peer to peer ,"Add a left bar button item to our view controller, using the ""add"" system icon, and making it call 
 a method called 
 showConnectionPrompt()
 . We're going to make that method ask users 
 whether they want to connect to an existing session with other people, or whether they want to 
 create their own. Here's the code for the bar button item – put this in 
 viewDidLoad()
 :
  
 navigationItem.leftBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: 
 ""showConnectionPrompt"") 
 Asking users to clarify how they want to take an action is of course the purpose of 
  
 UIAlertController
  as an action sheet, and our 
 showConnectionPrompt()
  method is going to 
 use one to ask users what kind of connection they want to make. Put this code into your view 
 controller:
  
 func showConnectionPrompt() { 
  let ac = UIAlertController(title: ""Connect to others"", message: nil, preferredStyle: 
 .ActionSheet) 
  ac.addAction(UIAlertAction(title: ""Host a session"", style: .Default, handler: 
 startHosting)) 
  ac.addAction(UIAlertAction(title: ""Join a session"", style: .Default, handler: 
 joinSession)) 
  ac.addAction(UIAlertAction(title: ""Cancel"", style: .Cancel, handler: nil)) 
  presentViewController(ac, animated: true, completion: nil) 
 } 
 Now, here's where it gets trickier. Multipeer connectivity requires four new classes:
  
 1. 
 MCSession
  is the manager class that handles all multipeer connectivity for us.
  
 2. 
 MCPeerID
  identifies each user uniquely in a session.
  
 3. 
 MCAdvertiserAssistant
  is used when creating a session, telling others that we exist and 
 handling invitations.
  
 www.hackingwithswift.com 
  
 573",NA
Invitation only ,"Merely by saying that we conform to the 
 MCSessionDelegate
  and 
  
 MCBrowserViewControllerDelegate
  protocols, your code won't build any more. This is 
 because the two protocols combined have seven required methods that you need to 
 implement just to be compatible.
  
 Helpfully, for this project you can effectively ignore three of them, two more are trivial, and one 
 further is just for diagnostic information in this project. That leaves only one method that is 
 non-trivial and important to the program.
  
 Let's tackle the ones we can effectively ignore. Of course, you can't 
 ignore
  required methods, 
 otherwise they wouldn't be required. But these methods aren't ones that do anything useful to 
 our program, so we can just create empty methods. Remember, once you've said you 
 conform to a protocol, Xcode's code completion is updated so you can just start typing the first 
 few letters of a method name in order to have Xcode prompt you with a list to choose from.
  
 Here are the three methods that we need to provide, but don't actually need any code inside 
 them:
  
 func session(session: MCSession, didReceiveStream stream: NSInputStream, 
 withName streamName: String, fromPeer peerID: MCPeerID) { 
 } 
 func session(session: MCSession, didStartReceivingResourceWithName resourceName: String, 
 fromPeer peerID: MCPeerID, withProgress progress: NSProgress) { 
 } 
 func session(session: MCSession, didFinishReceivingResourceWithName resourceName: String, 
 fromPeer peerID: MCPeerID, atURL localURL: NSURL, withError error: NSError?) { 
 www.hackingwithswift.com 
  
 577",NA
Wrap up ,"Multipeer connectivity is something that used to be awfully hard, but in iOS it's only 150 lines of 
 code to produce this entire app – and over half of that is code for the collection view and the 
 image picker! The advantage it has compared to traditional data sharing over Wi-Fi is that 
 multipeer can use an existing Wi-Fi network, or can silently create a new Wi-Fi network or even 
 a Bluetooth network depending on what's available. All this is an implementation detail that 
 Apple solves on your behalf.
  
 If you'd like to take this project further, add a button that will show a table view listing the 
 names of all devices currently connected to the session. You could also try sending text 
 messages across the wire – there's a 
 dataUsingEncoding()
  method for strings that 
 converting a string to an 
 NSData
 . Use it with the parameters 
 NSUTF8Encoding
  and 
 false
 .
  
 www.hackingwithswift.com 
  
 583",NA
Project 26 ,NA,NA
Marble Maze,NA,NA
Respond to device tilting by steering a ball around a ,NA,NA
vortex maze.,"www.hackingwithswift.com 
  
 584",NA
Setting up ,"In this game project you'll create a rolling ball game for iPad, using the accelerometer – you 
 tip your device, and the balls rolls in that direction, hopefully avoiding holes as you go.
  
 Along with the accelerometer, you're also going to learn how to load levels, how to have fine-
 grained contact bitmasks, how to reverse arrays, and how to write code that executes in the 
 simulator but not on devices (or vice versa). So, you learn things, you make a cool game, and I 
 get to bask in the warmth of knowing that your Swift mastery is growing more than ever.
  
 Create a new SpriteKit project, name it Project26, and set it for iPad only. Make sure it uses a 
 fixed 
 landscape right
  orientation, which is more restrictive than we usually use. We can't 
 enable landscape left because we'll be tilting the device in all directions, and it would be 
 annoying to have the device rotate because we tipped the iPad too far!
  
 Please delete the spaceship picture and delete the contents of the 
 didMoveToView()
  and 
 touchesBegan()
  methods in GameScene.swift. Now download the files for this project from 
 GitHub
  and copy its Content folder into your project.
  
 In this project we're going to use the accelerometer, which is not supported in the iOS 
 Simulator. To make things easier, we're going to add some code that lets you control the 
 game through touch – it's nowhere near as fun, but at least it can be tested in the simulator.
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 585",NA
Loading a level ,"We're going to start this project by looking at the biggest method in the project, and perhaps 
 even the entire Hacking with Swift series. It's called 
 loadLevel()
  and is responsible for loading 
 a level file from disk and creating SpriteKit nodes onscreen.
  
 The method isn't long because it's complicated, it's long just because it does a lot. When you 
 finish this project one of the suggested ways to improve the code is to split this method off into 
 small methods, so you should pay close attention to how it works!
  
 At the core of the method it loads a level file from disk, then splits it up by line. Each line will 
 become one row of level data on the screen, so the method will loop over every character in 
 the row and see what letter it is. Our game will recognise five possible options: a space will 
 mean empty space, ""x"" means a wall, ""v"" means a vortex (deadly to players), ""s"" means a star 
 (awards points), and ""f"" means level finish.
  
 Using this kind of very simple level text format means that you can write your levels in a text 
 editor, and visually see exactly how they will look in your game. You've already tackled most 
 of the code required for the skeleton of 
 loadLevel()
 , but there are a few things I want to 
 highlight:
  
  • We'll be using the 
 enumerate()
  function again. In case you've forgotten, this loops over an 
 array, extracting each item and its position in the array.
  
  • We'll be positioning items as we go. Each square in the game world occupies a 64x64 
 space, so we can find its position by multiplying its row and column by 32. But: remember that 
 SpriteKit calculates its positions from the center of objects, so we need to add 32 to the X and 
 Y coordinates in order to make everything lines up on our screen.
  
  • You might also remember that SpriteKit uses an inverted Y axis to UIKit, which means for 
 SpriteKit Y:0 is the bottom of the screen whereas for UIKit Y:0 is the top. When it comes to 
 loading level rows, this means we need to read them in reverse so that the last row is created 
 at the bottom of the screen and so on upwards.
  
 Here's the initial code for 
 loadLevel()
 :
  
 func loadLevel() { 
  if let levelPath = NSBundle.mainBundle().pathForResource(""level1"", ofType: ""txt"") { 
  if let levelString = try? String(contentsOfFile: levelPath,  
 www.hackingwithswift.com 
  
 586",NA
Tilt to move ,"We're going to control this game using the accelerometer that comes as standard on all iPads, 
 but it has a problem: it doesn't come as standard on any Macs, which means we either resign 
 ourselves to testing only on devices or we put in a little hack. This course isn't calling Giving 
 Up with Swift, so we're going to add a hack – in the simulator you'll be able to use touch, and 
 on devices you'll have to use tilting.
  
 To get started, add this property so we can reference the player throughout the game:
  
 var player: SKSpriteNode! 
 We're going to add a dedicated 
 createPlayer()
  method that loads the sprite, gives it circle 
 physics, and adds it to the scene, but it's going to do three other things that are important.
  
 First, it's going to set the physics body's 
 allowsRotation
  property to be false. We haven't 
 changed that so far, but it does what you might expect – when false, the body no longer 
 rotates. This is useful here because the ball looks like a marble: it's shiny, and those 
 reflections wouldn't rotate in real life.
  
 Second, we're going to give the ball a 
 linearDamping
  value of 0.5, which applies a lot of 
 friction to its movement. The game will still be hard, but this does help a little by slowing the 
 ball down naturally.
  
 Finally, we'll be combining three values together to get the ball's 
 contactTestBitMask
 : the 
 star, the vortex and the finish.
  
 Here's the code for 
 createPlayer()
 :
  
 func createPlayer() { 
  player = SKSpriteNode(imageNamed: ""player"") 
  player.position = CGPoint(x: 96, y: 672) 
  player.physicsBody = SKPhysicsBody(circleOfRadius: player.size.width / 
 2) 
  player.physicsBody!.allowsRotation = false 
  player.physicsBody!.linearDamping = 0.5 
 www.hackingwithswift.com 
  
 593",NA
Contacting but not colliding ,"All the game is missing now is some challenge, and that's where our star and vortex level 
 elements come in. Players will get one point for every star they collect, and lose one point 
 every time they fall into a vortex. To track scores, we need a property to hold the score and a 
 label to show it, so add these now:
  
 var scoreLabel: SKLabelNode! 
 var score: Int = 0 { 
  didSet { 
   scoreLabel.text = ""Score: \(score)"" }  
 } 
 We're going to show the label in the top-left corner of the screen, so add this to 
 didMoveToView()
 :
  
 scoreLabel = SKLabelNode(fontNamed: ""Chalkduster"") scoreLabel.text 
 = ""Score: 0""  
 scoreLabel.horizontalAlignmentMode = .Left  
 scoreLabel.position = CGPoint(x: 16, y: 16)  
 addChild(scoreLabel) 
 When a collision happens, we need to figure out whether it was the player colliding with a 
 star, or the star colliding with a player – the same semi-philosophical problem we had in 
 project 11. And our solution is identical too: figure out which is which, then call another 
 method.
  
 First, we need to make ourselves the contact delegate for the physics world, so make your 
 class conform to 
 SKPhysicsContactDelegate
  then add this line in 
 didMoveToView()
 :
  
 www.hackingwithswift.com 
  
 600",NA
Wrap up ,"There's something wonderfully tactile about using the accelerometer to affect gravity in a 
 game, because it feels incredibly realistic even though we're not using particularly good 
 graphics. SpriteKit is of course doing most of the hard work of collision detection, and Core 
 Motion takes away all the complexity of working with accelerometers, so again it's our job to 
 sew the components together to make something bigger than the sum of its parts.
  
 There are two things you should immediately tackle if you want to continue working on this 
 project. First, have a go at refactoring the 
 loadLevel()
  method so that it's made up of 
 multiple smaller methods. This will make your code easier to read and easier to maintain, at 
 least it will do if you do a good job!
  
 Second, when the player finally makes it to the finish marker, nothing happens. What should 
 happen? Well, that's down to you now. You could easily design several new levels and have 
 them progress through, but could you add things that make the new levels different – perhaps 
 a teleport that moves the player from one point in the level to another? Add a new letter type 
 in 
 loadLevel()
 , add another collision type to our enum, then see what you can do. Have fun!
  
 www.hackingwithswift.com 
  
 604",NA
Project 27 ,NA,NA
Core ,NA,NA
Graphics,NA,NA
Draw 2D shapes using Apple's high-speed drawing ,NA,NA
framework.,NA,NA
Setting up ,"You're probably tired of me saying this: iOS is full of powerful and easy to use programming 
 frameworks. It's true, and you've already met UIKit, SpriteKit, Core Animation, Core Motion, 
 Core Image, Core Location, Grand Central Dispatch and more. But how would you feel if I 
 said that we've yet to use one of the biggest, most powerful and most important frameworks of 
 all?
  
 Well, it's true. And in this technique project we're going to right that wrong. The framework is 
 called Core Graphics, and it's responsible for device-independent 2D drawing – when you 
 want to draw shapes, paths, shadows, colors or so on, you'll want Core Graphics. Being 
 device-independent means you can draw things to the screen or draw them a PDF without 
 having to change your code.
  
 Create a new Single View Application project, name it Project27 and set its target to be iPad. 
 We're going to create a Core Graphics sandbox that's similar to project 15's Core Animation 
 sandbox – a button you can type will trigger Core Graphics drawing in different ways.
  
 If you haven't already downloaded the files for this project, please do so now from 
 GitHub
 , 
 then copy the mouse picture into your project.
  
 www.hackingwithswift.com 
  
 606",NA
Creating the sandbox ,"Open Main.storyboard in Interface Builder, then place an image view in there that's 512x512 
 in size, with X:44 and Y:44. Now place a button centered beneath it, and give it the title 
 ""Redraw"".
  
 For constraints, please place a width and height constraint on the image view so that it's 
 always 512x512, then make it center vertically and horizontally inside the view controller. The 
 button should be centered horizontally, but place a vertical space constraint between it and 
 the image view so that it always stays just below it.
  
 We're going to need to reference the image view in code, so please switch to the assistant 
 editor and create an outlet for it called 
 imageView
 . While you're there, you should also 
 create an action for the button being tapped, called 
 redrawTapped()
 .
  
 Switch back to the standard editor, and open up ViewController.swift because that's our user 
 interface done; the rest is code!
  
  
 Here's our basic layout: a big UIImageView with a UIButton underneath.
  
 We're going to use a similar code structure to project 15: a property that we increment 
  
 www.hackingwithswift.com 
  
 607",NA
Drawing into a context ,"Carl Sagan once said, ""if you wish to make an apple pie from scratch, you must first invent 
 the universe."" Filling in the 
 drawRectangle()
  method doesn't require you to invent the 
 universe, but it 
 does
  require a fair amount of Core Graphics learning before you get to the 
 actual drawing part. I will, of course, try to remove as much of it as I can so that the 
 remaining bits are important.
  
 The most important thing to understand is that, like Core Animation, Core Graphics sits at a 
 lower technical level than UIKit. This means it doesn't understand classes you know like 
 UIColor
  and 
 UIBezierPath
 , so you either need to use their counterparts (
 CGColor
  and 
 CGPath
  respectively), or use helper methods from UIKit that convert between the two.
  
 To be fair to Apple, they have written some great helper code that seamlessly blends UIKit and 
 Core Graphics, so a lot of the time you don't need to worry about it. Take for example creating a 
 256x256 image. Using 
 UIImage
  you don't need to care whether it's retina or not, but when 
 you're creating a Core Graphics context you need to tell it whether you want 1x, 2x or 3x scale. 
 Helpfully, Apple also lets you specify 0 for scale, to mean ""use whatever is right for the current 
 device.""
  
 Another important thing to understand about Core Graphics is that it's written in C, not in 
 Objective C. That doesn't mean 
 you
  need to code in C any more than using SpriteKit means 
 you need to write in Objective C, but you'll find it uses different data types from what you're 
 used to. Being a C framework also means that everything is a function; there aren't any 
 methods around here.
  
 Thirdly, you need to understand that Core Graphics differentiates between creating a path and 
 drawing a path. That is, you can add lines, squares and other shapes to a path as much as 
 you want to, but none of it will do anything until you actually draw the path. Think of it like a 
 simple state machine: you configure a set of states you want (colors, transforms, and so on), 
 then perform actions. You can even maintain multiple states at a time by pushing and popping 
 in order to backup and restore specific states.
  
 Finally, you should know that Core Graphics is extremely fast: you can use it for updating 
 drawing in real time, and you'll be very impressed. Core Graphics can work on a background 
 thread – something that UIKit can't do – which means you can do complicated drawing without 
 locking up your user interface.
  
 It's time to start looking at some code, so here are the four functions you'll be using lots of 
  
 www.hackingwithswift.com 
  
 610",NA
Ellipses and checkerboards ,"Add a case to your 
 redrawTapped()
  method to call a new method: 
 drawCircle()
 . This will… 
 wait for it… 
 draw a circle
 . So, your switch/case should look like this:
  
 switch currentDrawType {  
 case 0: 
  drawRectangle() 
 case 1: 
  drawCircle() 
 default: 
  break  
 } 
 There are several ways of drawing rectangles using Core Graphics, but the method we used 
 in 
 drawRectangle()
  is particularly useful because in order to draw a circle we need to change 
 just one line of code. This is because drawing circles (or indeed any elliptical shape) in Core 
 Graphics is done by specifying its rectangular bounds.
  
 So, where before you had:
  
 CGContextAddRect(context, rectangle) 
 …you can now use this:
  
 CGContextAddEllipseInRect(context, rectangle) 
 It even has the same parameters! So, the full 
 drawCircle()
  method is this:
  
 www.hackingwithswift.com 
  
 615",NA
Transforms and lines ,"Add another case to your switch/case block, and make this one call another new method 
 named 
 drawRotatedSquares()
 . This is going to demonstrate how we can apply transforms to 
 our context before drawing, and how you can stroke a path without filling it.
  
 To make this happen, you need to know three new Core Graphics functions:
  
 1. 
 CGContextTranslateCTM()
  translates (moves) the current transformation matrix (CTM). 
 2. 
 CGContextRotateCTM()
  rotates the current transformation matrix.
  
 3. 
 CGContextStrokePath()
  strokes the path with your specified line width, which is 1 if you 
 don't set it explicitly.
  
 The current transformation matrix (CTM) is very similar to those 
 CGAffineTransform 
 modifications we used in project 15, except its application is a little different in Core Graphics. 
 In UIKit, you rotate drawing around the center of your view, as if a pin was stuck right through 
 the middle. In Core Graphics, you rotate around the top-left corner, so to avoid that we're 
 going to move the CTM half way into our image first so that we've effectively moved the 
 rotation point.
  
 This also means we need to draw our rotated squares so they are centered on our center: for 
 example, setting their top and left coordinates to be -128 and their width and height to be 256.
  
 Here's the code for the method:
  
 func drawRotatedSquares() { 
  UIGraphicsBeginImageContextWithOptions(CGSize(width: 512, height: 512), false, 0) 
  let context = UIGraphicsGetCurrentContext() 
  CGContextTranslateCTM(context, 256, 256) 
  let rotations = 16 
  let amount = M_PI_2 / Double(rotations) 
  for _ in 0 ..< rotations { 
  CGContextRotateCTM(context, CGFloat(amount)) 
 www.hackingwithswift.com 
  
 620",NA
Images and text ,"Add one final case to your switch/case statement calling a method 
 drawImagesAndText()
 , 
 because no discussion of Core Graphics would be useful without telling you how to draw 
 images and text to your context.
  
 If you have a string in Swift, how can you place it into a graphic? The answer is simpler than 
 you think: all strings have a built-in method called 
 drawWithRect()
  that draws the string in a 
 rectangle you specify. Even better, you get to customise the font and size, the formatting, the 
 line wrapping and more all with that one method.
  
 Remarkably, the same is true of 
 UIImage
 : any image can be drawn straight to a context, and 
 it will even take into account the coordinate reversal of Core Graphics.
  
 Before you're able to draw a string to the screen, you need to meet two more classes: 
 UIFont
  
 and 
 NSMutableParagraphStyle()
 . The former defines a font name and size, e.g. Helvetica 
 Neue size 26, and the latter is used to describe paragraph formatting options, such as line 
 height, indents and alignment.
  
 When you draw a string to the screen, you do using a dictionary of attributes that describes all 
 the options you want to apply. We want to apply a custom font and custom paragraph style – 
 that bit is easy enough. But the 
 keys
  for the dictionary are special Apple constants: 
 NSFontAttributeName
  and 
 NSParagraphStyleAttributeName
 .
  
 To help make the code clearer, here's a bulleted list of all the things the method needs to do:
  
 1. Create a context, but this time we don't need a reference to it.
  
 2. Define a paragraph style that aligns text to the center.
  
 3. Create an attributes dictionary containing that paragraph style, and also a font. 
 4. Draw a string to the screen using the attributes dictionary.
  
 5. Load an image from the project and draw it to the context.
  
 6. Retrieve a 
 UIImage
  of the context's data, the end drawing.
  
 7. Update the image view with the finished result.
  
 Below is that the same process, now coded in Swift. As per usual, the number comments 
 match the list above:
  
 func drawImagesAndText() { 
  // 1 
 www.hackingwithswift.com 
  
 624",NA
Wrap up ,"I could easily have written twice as much about Core Graphics, because it's capable of some 
 extraordinary effects.Clipping paths, gradients, blend modes and more are just a few lines of 
 code away, so there really is no excuse not to give them a try! And if you don't give it a try 
 yourself, don't worry: we'll be drawing with Core Graphics in project 29, so you can't avoid it!
  
 This project has given you a sandbox where you can play around with various Core Graphics 
 techniques easily, so I would highly encourage you to spend another hour or two tinkering 
 with the code in your project. Use code completion to try new functions, change my values to 
 others to see what happens, and so on. Playing with code like this can help you to discover 
 new functionality, and will also help you remember more later. Have fun!
  
 www.hackingwithswift.com 
  
 627",NA
Project 28 ,NA,NA
Secret Swift,NA,NA
Save user data securely using the device keychain ,NA,NA
and Touch ID.,"www.hackingwithswift.com 
  
 628",NA
Setting up ,"This project will introduce you to two important iOS technologies together: Touch ID and the 
 keychain. The former is used to identify users biometrically using the fingerprint sensor on 
 iPhones and iPads; the latter is a secure, encrypted data storage area on every device that 
 you can read and write to.
  
 Of course, there's little point learning about technologies without using them, so this project 
 will have you build a secure text editor. Users can type whatever they want and have it saved, 
 but to read it again they'll need to unlock the app using Touch ID.
  
 You might remember in project 12 that I said 
 NSUserDefaults
  is great for its simplicity but 
 isn't good for private data. Well, the keychain is securely encrypted, so we can be assured 
 that data we put there is safe.
  
 This project is modelled on project 16, the Safari extension where users could type 
  
 JavaScript. This means we'll need to use the same keyboard detection and adjustment code – 
 if you already completed project 16, you might find it easiest to copy and paste your code as 
 needed.
  
 Make a new Single View Application project in Xcode, named Project28 and targeted at any 
 device you want.
  
 www.hackingwithswift.com 
  
 629",NA
The basic text editor ,"Open Main.storyboard in Interface Builder, and embed the default view controller inside a 
 navigation controller. Now place a text view (
 not
  a text field!) in the center and use Editor > 
 Resolve Auto Layout Issues > Add Missing Constraints to place Auto Layout constraints.
  
 Delete the ""Lorem ipsum"" text in the text view, give it a white background color if it does not 
 already have one, then use the assistant editor to make an outlet for it called 
 secret
 . That's us 
 done with the storyboard for now; switch back to the standard editor and open 
  
 ViewController.swift.
  
 We need to add the same code we used in project 16 to make the text view adjust its content 
 and scroll insets when the keyboard appears and disappears. This code is identical apart from 
 the outlet is called 
 secret
  now rather than 
 script
 . First, put this into 
  
 viewDidLoad()
 :
  
 let notificationCenter = NSNotificationCenter.defaultCenter() 
 notificationCenter.addObserver(self, selector: ""adjustForKeyboard:"", name: 
 UIKeyboardWillHideNotification, object: nil) 
 notificationCenter.addObserver(self, selector: ""adjustForKeyboard:"", name: 
 UIKeyboardWillChangeFrameNotification, object: nil) 
 As a reminder, that asks iOS to tell us when the keyboard changes or when it hides. As a 
 double reminder: the hide is required because we do a little hack to make the hardware 
 keyboard toggle work correctly – see project 16 if you don't remember why this is needed.
  
 Here's the 
 adjustKeyboard()
  method, which again is identical apart from the outlet name to 
 that seen in project 16:
  
 func adjustForKeyboard(notification: NSNotification) { 
  let userInfo = notification.userInfo! 
  let keyboardScreenEndFrame =  
 (userInfo[UIKeyboardFrameEndUserInfoKey] as! NSValue).CGRectValue() 
  let keyboardViewEndFrame = view.convertRect(keyboardScreenEndFrame,  
 www.hackingwithswift.com 
  
 630",NA
Writing somewhere safe ,"When the app first runs, users should see a totally innocuous screen, with nothing secret 
 visible. But we also don't want secret information to be visible when the user leaves the app 
 for a moment then comes back, or if they double-tap the home button to multitask – doing so 
 might mean that the app is left unlocked, which is the last thing we want.
  
 To make this work, let's start by giving the view controller a totally innocuous title that 
 absolutely won't make anyone wonder what's going on. Put this into 
 viewDidLoad()
 :
  
 title = ""Nothing to see here"" 
 Next we're going to create two new methods: 
 unlockSecretMessage()
  to load the message 
 into the text view, and 
 saveSecretMessage()
 . But before we do that, I want to introduce you 
 to a helpful class called 
 KeychainWrapper
 , which we'll be using to read and write keychain 
 values.
  
 This class was not made by Apple; instead, it's open source software released under the MIT 
 license, which means we can use it in our own projects as long as the copyright message 
 remains intact. This class is needed because working with the keychain is 
 complicated
  – far 
 harder than anything we have done so far. So instead of using it directly, we'll be using this 
 wrapper class that makes the keychain work like 
 NSUserDefaults
 .
  
 If you haven't already downloaded this project's files from 
 GitHub
 , please do so now. In there 
 you'll find the file KeychainWrapper.swift; please copy that into your Xcode project to make the 
 class available.
  
 The first of our two new methods, 
 unlockSecretMessage()
 , needs to show the text view, then 
 load the keychain's text into it. Loading strings from the keychain using 
  
 KeychainWrapper
  is as simple as using its 
 stringForKey()
  method, but the result is optional 
 so you should unwrap it once you know there's a value there.
  
 Here it is:
  
 func unlockSecretMessage() { 
  secret.hidden = false 
 www.hackingwithswift.com 
  
 633",NA
Touch to activate ,"This part of the project requires a Touch ID-capable device, although I'll be showing you a 
 hack to make it work on the simulator by bypassing checks at two points.
  
 Touch ID is part of the Local Authentication framework, and our code needs to three things:
  
 1. Check whether the device is capable of supporting biometric authentication.
  
 2. If so, request that the Touch ID begin a check now, giving it a string containing the reason 
 why we're asking.
  
 3. If we get success back from Touch ID it means this is the device's owner so we can unlock 
 the app, otherwise we show a failure message.
  
 One caveat that you must be careful of: when we're told whether Touch ID was successful or 
 not, it might not be on the main thread. This means we need to use 
 dispatch_async()
  to 
 make sure we execute any user interface code on the main thread.
  
 The job of task 1 is done by the 
 canEvaluatePolicy()
  method of the 
 LAContext
  class, 
 requesting the security policy type 
 .DeviceOwnerAuthenticationWithBiometrics
 . The job of 
 task 2 is done by the 
 evaluatePolicy()
  of that same class, using the same policy type, but it 
 accepts a trailing closure telling us the result of the policy evaluation: was it successful, and if 
 not what was the reason?
  
 Like I said, all this is provided by the Local Authentication framework, so the first thing we 
 need to do is import that framework. Add this above 
 import UIKit
 :
  
 import LocalAuthentication 
 And now here's the new code for the 
 authenticateUser()
  method. We already walked 
 through what it does, so this shouldn't be too surprising:
  
 @IBAction func authenticateUser(sender: AnyObject) { 
  let context = LAContext() 
  var error: NSError? 
  if  
 www.hackingwithswift.com 
  
 636",NA
Wrap up ,"This was the last app project in the series, and I hope you didn't find it too challenging – you 
 know a huge amount about iOS 8 and Swift now, so much of what remains is just practice. 
  
 The great thing about Touch ID is that you don't get any access to fingerprints or other 
 secure information. Instead, the system does all the biometric authentication for you, which 
 keeps both your app and users safe.
  
 If you want to take this project further, try using the 
 #if
  compiler directives from project 26 to 
 make the simulator 
 if true
  hack be in the code at the same time as the real Touch ID code. If 
 you're looking for something harder, try creating a password system for your app so that the 
 Touch ID fallback is more useful. You'll need to use the 
  
 addTextFieldWithConfigurationHandler()
  from project 5, and I suggest you save the 
 password in the keychain!
  
 www.hackingwithswift.com 
  
 641",NA
Project 29 ,NA,NA
Exploding ,NA,NA
Monkeys,NA,NA
Remake a classic DOS game and learn about ,NA,NA
destructible terrain and scene transitions.,NA,NA
Setting up ,"This is the last game project in Hacking with Swift Level 1, so I wanted to make it special: 
 you're going to build a clone of a game that's almost 25 years old. This game is hugely 
 recognisable to people over the age of 30 because it was the classic way to waste time 
 during computer classes at school.
  
 The game? It's called Gorillas, and it first shipped with an old text-based operating system 
 called MS-DOS 5.0 way back in 1991. Of course, we're going to re-make it using SpriteKit, but 
 at the same time you're going to learn some new things: how to make colors from hues, 
 texture atlases, scene transitions, mixing UIKit with SpriteKit, and destructible terrain. You'll 
 also get a recap on the Core Graphics techniques from project 27.
  
 ""Destructible terrain"" means ""terrain that can be destroyed,"" which is a key part of Gorillas. If 
 you've never played it before, you won't know that it pits two players against each other, both 
 standing on high-rise buildings and both flinging exploding bananas at each other using 
 physics. Realistic, right? Well, no, but it's certainly fun!
  
 Make a new SpriteKit project named Project29 and targeted at iPad. Please make it use 
 landscape orientation, then delete the existing spaceship image from Images.xcassets and 
 the code from inside the 
 didMoveToView()
  and 
 touchesBegan()
  methods. You should 
 download the files for this project from 
 GitHub
 , but for now please only copy the file 
 Helper.swift into your project.
  
 Warning:
  When working with SpriteKit projects, I strongly recommend you use the iPad 2 
 simulator rather than iPad Air – you'll get much faster frame rates, making it much more 
 suitable for testing.
  
 www.hackingwithswift.com 
  
 643",NA
Building the environment ,"We're going to start by making the game environment, which means building the night-time, 
 high-rise skyscraper scene that forms the backdrop for the game. We're going to do most of 
 this with an 
 SKSpriteNode
  subclass for buildings that sets up physics, draws the building 
 graphic, and ultimately handles the building being hit by stray bananas. Are you ready to flex 
 your Core Graphics muscle a little?
  
 Add a new file, choosing iOS > Source > Cocoa Touch Class, name it ""BuildingNode"" and 
 make it a subclass of 
 SKSpriteNode
 . Open the new file for editing, and add 
 import 
 SpriteKit
  just above the UIKit import.
  
 Initially, this class needs to have three methods:
  
 1. 
 setup()
  will do the basic work required to make this thing a building: setting its name, 
 texture, and physics.
  
 2. 
 configurePhysics()
  will set up per-pixel physics for the sprite's current texture. 3. 
 drawBuilding()
  will do the Core Graphics rendering of a building, and return it as a 
 UIImage
 .
  
 In amongst those three points was one small thing that you may have missed: ""the sprite's 
 current
  texture."" This tells you that the texture will change as bits get blown off by those 
 exploding bananas. To make this work, we're going to keep a copy of the building's texture 
 as a 
 UIImage
  so that we can modify it later.
  
 Add this code to your class – it's a property followed by two methods:
  
 var currentImage: UIImage! 
 func setup() { 
  name = ""building"" 
  currentImage = drawBuilding(size) 
  texture = SKTexture(image: currentImage) 
  configurePhysics() 
 www.hackingwithswift.com 
  
 644",NA
Mixing UIKit and SpriteKit ,"We've been mixing UIKit and SpriteKit ever since our first SpriteKit project, way back in project 
 11. Don't believe me? Look inside 
 GameViewController.swift
  and you'll see a plain old 
 UIViewController
  do all the work of loading and showing our 
 GameScene
  code. There's a 
 Main.storyboard file containing that view controller, and if you go to the identity inspector 
 (Alt+Cmd+3) you'll see it has 
 SKView
  set for its custom class – that's the view holding our 
 scene.
  
 This UIKit setup existed all along, but so far we've been ignoring it. No more: we're going to 
 add some controls to that view so that players can fire bananas. The way the game works, 
 each player gets to enter an angle and a velocity for their throw. We'll be recreating this with a 
 UISlider
  for both of these numbers, along with a 
 UILabel
  so players can see exactly what 
 numbers they chose. We'll also add a ""Launch"" button that makes the magic happen.
  
 Now, think about this for a moment: our game view controller needs to house and manage the 
 user interface, and the game scene needs to manage everything inside the game. But they 
 also need to talk to each other: the view controller needs to tell the game scene to fire a 
 banana when the launch button is clicked, and the game scene needs to tell the view 
 controller when a player's turn has finished so that another banana can be launched again.
  
 This two-way communication could be done using 
 NSNotificationCenter
 , but it's not very 
 pleasant: we know the sender and receiver, and we know exactly what kind of data they will 
 send and receive, so the easiest solution here is to give the view controller a property that 
 holds the game scene, and give the game scene a property that holds the view controller.
  
 In the very first project, I explained that outlet properties should be declared weak ""because the 
 object has been placed inside a view, so the view owns it."" That's true, but using 
 weak
  to 
 declare properties is a bit more generalised: it means ""I want to hold a reference to this, but I 
 don't own it so I don't care if the reference goes away.""
  
 When we discussed closures in project 5, I explained that you needed to make 
 self
  either 
 unowned
  or 
 weak
  so that you avoided strong reference cycles – where a view controller 
 owns a closure and the closure owns the view controller so that neither of them ever get 
 destroyed. Well, with our game scene and game view controller have the same problem: if 
 they both own each other using a property, we have a problem.
  
 The solution is to make one of them have a weak reference to the other: either the game 
 controller owns the game scene strongly, or the game scene owns the game controller 
  
 www.hackingwithswift.com 
  
 652",NA
Unleash the bananas!,"It's time to get down to the nitty-gritty business of writing code: we need to create our 
 players then fill in the 
 launch()
  method so that the fun can begin.
  
 We're going to start with the easy bit, which is creating players. This needs to do two things:
  
 1. Create a player sprite and name it ""player1"".
  
 2. Create a physics body for the player that collides with bananas, and set it to not be 
 dynamic.
  
 3. Position the player at the top of the second building in the array. (This is why we needed to 
 keep an array of the buildings.) 
  
 4. Add the player to the scene.
  
 5. Repeat all the above for player 2, except they should be on the second to last building.
  
 The player physics body can be made using a circle, because the sprite used (which is the 
 same for both players) is more or less round. We used the second building for player 1 and the 
 second to last for player 2 so that they aren't at the very edges of the screen. Positioning them 
 at the top is just a matter of adding the building's height to the player's height and dividing by 
 two, then adding that to the building's Y co-ordinate. SpriteKit measures from the center of 
 nodes, remember!
  
 Before we look at the code, you'll need to create some properties to hold both players, plus 
 the banana and which player is currently in control:
  
 var player1: SKSpriteNode! 
 var player2: SKSpriteNode! 
 var banana: SKSpriteNode! 
 var currentPlayer = 1 
 Now here's the code for 
 createPlayers()
  – please put this in GameScene.swift:
  
 func createPlayers() { 
  player1 = SKSpriteNode(imageNamed: ""player"") 
 www.hackingwithswift.com 
  
 656",NA
Destructible terrain ,"It's time for the most challenging part of our project, but as per usual I've tried to keep things as 
 simple as possible because the fun is in getting results not in learning algorithms. We're going 
 to add collision detection to our code so that players can carve chunks out of the buildings or, 
 better, blow up their opponents.
  
 You will, as always, need to assign 
 self
  to be the delegate of your scene's physics world so 
 that you can get notified of collisions. So, put this in 
 didMoveToView()
 :
  
 physicsWorld.contactDelegate = self 
 Make sure you modify your class definition to say that you conform to the 
 SKPhysicsContactDelegate
  protocol.
  
 When it comes to implementing the 
 didBeginContact()
  method, there are various possible 
 contacts we need to consider: banana hit building, building hit banana (remember the 
 philosophy?), banana hit player1, player1 hit banana, banana hit player2 and player2 hit 
 banana. This is a lot to check, so we're going to eliminate half of them by eliminating whether 
 ""banana hit building"" or ""building hit banana"". Take another look at our category bitmasks:
  
 enum CollisionTypes: UInt32 { 
  case Banana = 1 
  case Building = 2 
  case Player = 4 
 } 
 They are ordered numerically and alphabetically, so what we're going to do is create two new 
 variables of type 
 SKPhysicsBody
  and assign one object from the collision to each: the first 
 physics body will contain the lowest number, and the second the highest. So, if we get banana 
 (collision type 1) and building (collision type 2) we'll put banana in body 1 and building in body 
 2, but if we get building (2) and banana (1) then we'll still put banana in body 1 and building in 
 body 2.
  
 www.hackingwithswift.com 
  
 664",NA
Wrap up ,"This was our final Level 1 game project, and I'd like to think I kept the best for last: lots to 
 learn about mixing UIKit and SpriteKit, texture atlases, scene transitions, and of course 
 destructible terrain. If you've followed the series correctly you've now made seven SpriteKit 
 games of varying complexity, so I hope you have all the knowledge you need to get out there 
 and make your own.
  
 If you want to extend this project, you might want to consider starting with the art for a change: 
 I've made it look relatively similar to the original DOS game, but let's face it that will only 
 appear to fans of retro gaming nowadays! If you're looking to change the code, see if you can 
 make the game track scores across scenes so that players know who is winning.
  
 If you're looking for something harder, make it best of 5: whoever reaches a score of 3 first 
 wins, showing a ""you win!"" screen of your choosing. And for a real challenge, try to modify 
 the collision detection so that exploding bananas damage all buildings the explosion would 
 have touched rather than just the building the banana touched.
  
 One last thing: when you're making amateur games, don't let yourself get bogged down in 
 boring stuff too much – you're doing it for fun, and if it isn't fun to make it's probably not 
 much fun to play.
  
 www.hackingwithswift.com 
  
 672",NA
Project 30 ,NA,NA
Instruments,NA,NA
"Become a bug detective and track down lost memory, ",NA,NA
slow drawing and more.,"www.hackingwithswift.com 
  
 673",NA
Setting up ,"This is the last technique project and indeed the last project in the series, so it's going to be 
 quite different. You see, I've already written all the code for you and I'm giving you a working 
 app. Sure it has a few bugs here and there, but it's not 
 too
  bad. Well, OK: perhaps it's full of 
 bugs, and perhaps this whole project is about showing you how to find and fix those bugs!
  
 We're going to be using a tool called Instruments. It ships as part of Xcode, and is 
  
 responsible for profiling your app. ""Profiling"" is the term used when we monitor performance, 
 memory usage and other information of an app, with the aim of improving efficiency. I'm not 
 going to make you a master of Instruments, but I can at least show you how it helps you find 
 problems with your code. Plus, along the way you'll learn a few extra bits about how iOS works, 
 including shadows, image caching, cell reuse and more.
  
 Please note: it's recommended you use physical devices when profiling your apps because 
 their performance characteristics are very different from those of the iOS simulator. It's not 
 required, just strongly recommended. If you're going to choose a device, I recommend choosing 
 the least powerful device you support. All our apps are written for iOS 8, so that means iPhone 
 4s and onwards and iPad 2 and onwards. If you have one available, I generally find iPad 3 the 
 slowest Pad for testing purposes.
  
 You should download the source code for this project from 
 GitHub
  then modify it as we go. 
 When you open the project, change the the build destination to be your iOS device if you 
 have one handy, otherwise use the iPhone 6 simulator.
  
 www.hackingwithswift.com 
  
 674",NA
What are we working with?,"This is a really simple app, albeit quite a broken on. Obviously the breakages are deliberate, 
 but they are all things I have seen in real, shipping code. The app shows a table view 
 containing images from Greek mythology. When one of the rows is tapped, a detail view 
 controller appears, showing the image at full size.
  
 Every time you tap on the big image, it adds one to a count of how many times that image 
 was tapped, and that count is shown in the original view controller. All the images in the app 
 are deliberately blurry – I use them in my Mythology app, so although I've kept them at their 
 original size I have dramatically lowered the quality. Sorry!
  
 Anyway, that's all the app does. I haven't even used a storyboard, because I want all the 
 problems to be visible (and fixable!) in Swift code.
  
 And how bad are the problems? Well, if you run the app on a device, you'll see that it crashes 
 after viewing just a few pictures. Regardless of whether you're running on a device or a 
 simulator, press Cmd+6 to bring up the debug gauges on the left of the Xcode window if you 
 don't see them already – it will say ""CPU"", ""Memory"", ""Disk"" and ""Network"".
  
 Depending on whether you're using the iOS simulator or a device, you might see memory in 
 the debug gauges start low but then build up as you use the app more and more, never going 
 back down after you load an image. Soon the app will crash because it runs out of memory, 
 which is of course A Very Bad Thing.
  
 You might also notice that in the iOS Simulator (running with the full power of your Mac behind 
 it!) table scrolling is still slow. What gives? This is a really broken app, and with so few lines of 
 code!
  
 www.hackingwithswift.com 
  
 675",NA
What can Instruments tell us?,"Press Cmd+I to run your app using Instruments, and after a few seconds a window will 
 appear offering you a variety of profiling templates. Please select Time Profiler then click 
 Choose. When the new window appears, click the red circle in the top-left corner to start 
 recording of the app.
  
 Your app will launch on your device (or in the simulator) and Instruments will begin 
 monitoring its usage in realtime. You'll see a spike in Instruments' readings to begin with, 
 which reflect the huge amount of work any app does just to start up. We don't care about 
 that for now, we're more interested in the workload of the app once it's running.
  
 So, scroll around a bit, tap an image, go back, scroll around some more, tap another image, 
 and so on. Aim to get about 10 seconds or so of real app usage, then press the Stop button, 
 which is where the record button was earlier.
  
 The top half of your Instruments window is showing readings from your app; the bottom half is 
 showing details on those readings. By default, the detail view shows everything in the app run 
 that was captured, but I want you to click and drag in the top window to select part of the 
 readings when you tapped on an image. All being well (or as well as can be expected in this 
 broken code!) you should see the readings noticeably spike.
  
 When you select an area of the readings like this, the detail view now shows information just 
 on the part you chose. You should see that the vast majority of the time that was selected was 
 spent on the main thread, which means we're not taking much advantage of having multiple 
 CPU cores.
  
 Immediately to the left of ""Main thread"" in the detail view is a disclosure arrow. You can click 
 that to open up all the top-level calls maid on the Main Thread, which will just be ""Start"", which 
 in turn has its own calls under its own arrow. You can if you want hold down Alt and click on 
 these arrows, which causes all the children (and their children's children) to be opened up, but 
 that gets messy!
  
 Instead, there are two options. First, you should have a right-hand detail pane with three 
 options: record settings, display settings and extended detail (accessible through Cmd+1, 
 Cmd+2 and Cmd+3). Select ""Main thread"" in the detail view then press Cmd+3 to choose the 
 extended detail view: this will automatically show you the ""heaviest"" stack trace, which is the 
 code that took the most time to run.
  
 www.hackingwithswift.com 
  
 676",NA
Fixing the bugs ,"It's time for us to use instruments to spot and fix some problems. 
 Important:
  when making 
 performance changes you should change only one thing at a time, then re-test to make sure 
 your change helped. If you changed two or more things and performance got better, which 
 one worked? Or, if performance got worse, perhaps one thing worked and one didn't!
  
 Let's begin with the table view: you should have seen nearly all the table view turn yellow 
 when Color Offscreen-Rendered Yellow was selected. This is because each of the pictures 
 has a shadow effect behind them that's being done on the 
 CALayer
  belonging to the image.
  
 You can find the code for this in SelectionViewController.swift, inside the 
 cellForRowAtIndexPath
  method:
  
 // give the images a nice shadow to make them look a bit more dramatic 
 cell.imageView!.layer.shadowColor = UIColor.blackColor().CGColor 
 cell.imageView!.layer.shadowOpacity = 1 
 cell.imageView!.layer.shadowRadius = 10 
 iOS lets you add a basic shadow to any of its views, and it's a simple way to make 
 something stand out on the screen. But it's not fast: it literally scans the pixels in the image 
 to figure out what's transparent, then uses that information to draw the shadow correctly. 
 When you hit a performance problem, you either drop the code that triggers the problem or 
 you make it run faster.
  
 In our case, we'll assume the designer insists the drop shadow is gorgeous (they are wrong!) 
 so we need to make the code faster. Fortunately, if we give iOS a little more information it can 
 do substantially less work. Calculating the shadow is hard, because iOS needs to see what's 
 transparent. But we know nothing is transparent; our images are solid rectangles!
  
 We can tell iOS not to automatically calculate the shadow path for our images by giving it the 
 exact shadow path to use. The easiest way to do this is to create a new 
 UIBezierPath
  that 
 describes our images (a rectangle with width 320 and height 240), then convert it to a 
 CGPath
  
 because 
 CALayer
  doesn't understand what 
 UIBezierPath
  is.
  
 www.hackingwithswift.com 
  
 679",NA
Wrap up ,"Hold up your right hand and repeat after me: ""I will never ship an app without running it 
 through Instruments first."" It doesn't take long, it's not difficult, and I promise it will pay off – 
 your user interfaces will be smoother, your code will run faster, and you'll avoid wasting 
 memory, all using a tool that's completely free and you already have installed.
  
 I have, predictably, only touched briefly on the many features of Instruments here, but I hope 
 I've inspired you to learn more. Instruments can tell you exactly what each CPU core is doing at 
 any given time, it can tell you when every object was created and when it was destroyed along 
 with what code triggered it, and it can even simulate user interface interactions to help you 
 stress test your apps!
  
 This is the end of the last Level 1 project in the series. I hope you've learned a lot, I hope 
 you've made a lot, and I hope you've had a lot of fun along the way. I've worked hard to 
 delete difficult parts, cut corner cases and take out technicalities, so all being well you've 
 found this series productive.
  
 But – and this is a big but – this is not the end of your Swift learning. There's so much more 
 you can do with Swift and iOS that I haven't come close to so far, and they are every bit as 
 exciting as what you've learned so far. To be blunt, I have given you the first 90% of learning 
 iOS development, so it's time for you to step out into the big world and learn the second 90% 
 by yourself.
  
 What's more, there's a third 90%, and a fourth 90%, and so on – the magic of programming is 
 that it's always evolving, so just as you think you're starting to know everything even more 
 stuff comes along to surprise you all over again. Don't let that feeling of joy escape you: 
 program for fun, and you'll never work a day in your life.
  
 If you'd like to continue your learning on Hacking with Swift – and I hope you do! – then you'll 
 be pleased to know you can continue right onto Level 2 projects. These are different from Level 
 1 because they no longer follow a sequence – now that you've finished all the Level 1 projects, 
 you can tackle the Level 2 projects in any order you want.
  
 Have fun, and happy Swifting!
  
 www.hackingwithswift.com 
  
 686",NA
Project 31 ,NA,NA
Multibrowser,NA,NA
Get started with UIStackView and see just how easy ,NA,NA
iPad multitasking is in iOS 9.,"www.hackingwithswift.com 
  
 687",NA
Setting up ,"This is the first chapter of Hacking with Swift Level 2. Chapters 1 to 30 all formed a 
  
 structured tutorial series teaching you Swift, UIKit, SpriteKit, Auto Layout, MapKit, iBeacons, 
 Core Graphics, Core Image and more all from scratch, using incremental learning and real 
 projects to make the experience fun and productive. That's Level 1, and you should have 
 completed it all. From here on it's Level 2, and projects are designed to be standalone: as 
 long as you have finished projects 1 to 30 already, you can complete any of Level 2 in any 
 order you want.
  
 If you have not already completed projects 1 to 30 of Hacking with Swift, please don't 
 complain if you don't understand a concept!
 Click here to return to the homepage and 
 browse the list of Swift projects
 , then work through them in order.
  
 Now for the important stuff: what are we going to build? Well, I want to use this first Level 2 
 project to show you how to use two great features in iOS 9: 
 UIStackView
  and iPad 
  
 multitasking. Both of these are stand out technologies in iOS 9, and, remarkably, both are so 
 easy to adopt that we can make this entire project in about 20 minutes. We're also going to 
 touch on Size Classes briefly for the first time, so there's a lot to learn.
  
 The project itself is called Multibrowser, and it shows one or more web views that the user 
 can simultaneously browse. So, you could have one pane with live sports results, one pane 
 with the latest news, and another on Reddit – just like Safari tabs, except they are all visible 
 at the same time. I'll be using 
 UIWebView
  for this project rather than 
 WKWebView
 , but it's 
 easy enough to change in your own project if you want to.
  
 Please go ahead and create a new project in Xcode 7, choosing the Single View Application 
 template. Name it Project 31, choose Swift for your language, and iPad for the device. We're 
 using iPad here because multitasking is only available as an iPad feature.
  
 www.hackingwithswift.com 
  
 688",NA
UIStackView by example ,"iOS 9 did not introduce many new user interface components, but it did bring us 
  
 UIStackView
  and that's more than enough – once you understand what it does and how it 
 works, you'll be able to use it in your own apps in just a few minutes, because it's 
 extraordinarily simple.
  
 It's very rare I say this, but Android does have some features that are enviable, and one of them 
 is called 
 LinearLayout
 . When you add views to a 
 LinearLayout
 , they automatically stack up 
 vertically one above the other, or horizontally, side by side. You don't have to worry about sizing 
 them to fit correctly because they automatically fill the space, and you don't have to worry about 
 moving other things around when you remove a view. Well, that's exactly what 
 UIStackView
  
 gives us: a flexible, Auto Layout-powered view container that makes it even easier to build 
 complex user interfaces.
  
 As an example, lets say you want users to fill in a short form: you have a label saying ""Name"" 
 then a 
 UITextField
  to the right of it; beneath that you have another label saying ""Address"" and 
 a 
 UITextView
  beneath it; below that you have a label saying ""Opt-in to marketing"" and to the 
 right of that a switch; and so on. This isn't uncommon, and to be fair it's not exactly hard to 
 make this in Auto Layout, but you do still need to do a lot grunt work for not much benefit.
  
 The problems usually occur if you want to make changes later: what if there's no longer 
 enough space to show your Name label and its 
 UITextField
  side by side? Previously this 
 would happen if your app was running on iPhone, but with the new multitasking system in 
 iPad it can happen if your user activates Slide Over or uses your app in Split View.
  
 If you missed the WWDC15 keynote:
  
  • 
 Slide Over
  is when your app literally sits over the screen on the right edge, with the original 
 application remaining full screen but dimmed. This is supported on iPad Air, Air 2, Mini and Mini 
 2.
  
  • 
 Split View
  is activated if the user drags the Slide Over divider to the left slightly, and it 
 causes your app to be pinned to the screen edge while the original application is resized to 
 take up less space. This is supported only on iPad Air 2.
  
 In both these scenarios, your app now has much less space to work with, so your label and 
 text field won't sit well side by side. Fortunately, 
 UIStackView
  can fix this problem: you can 
 tell it to place items side by side when your app has lots of space, or placed vertically when 
  
 www.hackingwithswift.com 
  
 689",NA
UIStackView in Swift 2 ,"With our storyboard designed, it's time to write the code. As you know, our plan is to produce 
 an app where the user can have multiple web views visible at one time, stacked together and 
 usable in their own right. We have one address bar, so the user will need to tap a web view to 
 select it, then enter a URL to visit.
  
 To make this interface work, we need two buttons in our navigation bar: one to add a new web 
 view, and one to delete whichever one the user doesn't want any more. We're also going to use 
 the title space in the navigation bar to show the page title of whichever web view is currently 
 active.
  
 So, modify your 
 viewDidLoad()
  method to this:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
  setDefaultTitle() 
  let add = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""addWebView"") 
  let delete = UIBarButtonItem(barButtonSystemItem: .Trash, target: self, action: 
 ""deleteWebView"") 
  navigationItem.rightBarButtonItems = [delete, add] 
 } 
 That uses three new methods we haven't created yet, but only one will create a compile 
 error: 
 setDefaultTitle()
 . This is a fairly simple method in this project, but you're welcome to 
 extend it later to add more interesting information for users prompting them to get started. 
  
 Put this method directly beneath 
 viewDidLoad()
 :
  
 func setDefaultTitle() { 
  title = ""Multibrowser"" 
 } 
 www.hackingwithswift.com 
  
 694",NA
Removing views from a UIStackView ,"That was a long chapter, and I hope you learned a lot. But you deserve a break, so I have 
 some good news: it's trivial to remove views from a UIStackView. Heck, at its simplest it's just 
 a matter of telling 
 removeArrangedSubview()
  which view to remove then removing that view 
 from its superview – the others are automatically resized and re-arranged to fill the space.
  
 In this particular project, we need to do a little more:
  
  • We want the delete button to work only if there's a web view selected.
  
  • We want to find the location of the active web view inside the stack view, then remove it. 
 • If there are now no more web views, we want to call 
 setDefaultTitle()
  to reset the user 
 interface.
  
  • We need to find whatever web view immediately follows the one that was removed. • 
 We then make that the new selected web view, highlighting it in blue.
  
 We already pointed the delete button at a method called 
 deleteWebView()
 , so all you need 
 to do is plug this in. I've added comments to make sure it's all clear:
  
 func deleteWebView() { 
  // safely unwrap our webview 
  if let webView = activeWebView { 
   if let index = stackView.arrangedSubviews.indexOf(webView) { 
  
  
  // we 
 found the current webview in the stack view! Remove it from the stack view 
   
  
  stackView.removeArrangedSubview(webView) 
  // now remove it from the view hierarchy – this is important! 
 webView.removeFromSuperview() 
  if stackView.arrangedSubviews.count == 0 {  // go back to 
 our default UI 
  
  setDefaultTitle() 
  } else { 
 www.hackingwithswift.com 
  
 701",NA
iPad multitasking in iOS 9 ,"Multitasking is an all-new feature in iOS 9, and I can guarantee you it's going to be adopted 
 pretty much everywhere. Now is the time to get started upgrading your apps so that you're 
 ready, otherwise you'll have your users complaining that they can't multitask with your app!
  
 You'll be pleased to know that supporting multitasking is easy. In fact, it's so easy that our 
 current app 
 already supports it
 . Don't believe me? Try it out now: launch your app, rotate the 
 simulator to landscape (Cmd + left or right cursor key), then drag from the right edge of the 
 screen.
  
 The first time you do this, you'll see a list of various apps to choose from. Please choose 
 Calendar for now. When you do this, iOS will activate Slide Over, which means your app still 
 owns the full screen, but it's dimmed as the Calendar app has focus in the right part of the 
 screen. On the left edge of Calendar you'll see a thin white line, which is the divider – drag 
 that a little to the left and you'll see the whole interface change as iOS switches from Slide 
 Over to Split View.
  
 Now, the reason I asked you to change the simulator to landscape mode is because Split 
 View actually has two snap points. The first, which you probably triggered this time, has your 
 original app taking up about 2/3rds of the screen on the left and Calendar taking up the 
 remainder on the right. The second, which you can get to by dragging the divider into the 
 center of the screen, has both apps taking up half the screen each. If you're in portrait 
 orientation you have only one mode, which is about 60/40.
  
 So, our app already supports multitasking pretty well, although we'll make it better in a 
 moment. First, though: what if you're upgrading existing apps? Well, you might not have such 
 an easy ride, but if your code is modern you're probably still OK. To make multitasking work, 
 you need to:
  
 1. Have a launch XIB. This is the same thing that enables iPhone 6 support with iOS 8, so you 
 might already have one. If not, add a new file, choose User Interface, then Launch Screen. 
 Then, in your plist, add a key for ""Launch screen interface file base name"" and point it to the 
 name of your launch XIB, without the "".xib"" extension. For example, if your launch screen is 
 called LaunchScreen.xib, give this key the value of ""LaunchScreen"".
  
 2. Make sure your app is configured to support all orientations. This may already be 
 configured this way, but if not make sure you choose all orientations now. As you might 
 imagine, selectively choosing only some orientations would cause havoc with multitasking!
  
 3. Use Auto Layout everywhere. If your app pre-dates Auto Layout or if you found it 
  
 www.hackingwithswift.com 
  
 703",NA
Wrap up ,"With 
 UIStackView
  in place that's another UIKit component under your belt – good job! The 
 addition of multitasking and size classes helps make the app much more polished, and I 
 think you've got the seeds of a great app here.
  
 If you want to try extending this project, the sensible place to start is in the URL entry: if users 
 don't type ""http://"" before their web site addresses the app fails, which isn't very helpful. 
 Another smart place to improve the app is inside the 
 setDefaultTitle()
  method: it just writes 
 Multibrowser in the navigation bar while leaving a large white space in the center – hardly 
 intuitive, and it wouldn't be hard to add a placeholder label in there telling users what to do.
  
 I do intend to do more iOS 9 projects in the future, so please let me know what you'd like to 
 see: I'm 
 @twostraws on Twitter
  and I'd love to hear from you. In the meantime, why not read 
 my 
 guide to the new features in iOS 9
  and my other 
 guide to the new features in Swift 
 2.0
 . Have fun!
  
 www.hackingwithswift.com 
  
 707",NA
Project 32 ,NA,NA
SwiftSearche,NA,NA
r,NA,NA
Add your app's content to iOS Spotlight and take ,NA,NA
advantage of the new Safari integration from iOS ,NA,NA
9.,NA,NA
Setting up ,"I hope you're all set for a massive Level 2 project, because this one is going to cram a lot in. 
 In this project, you're going to make an app for this tutorial series, Hacking with Swift – very 
 meta, I know. The app is going to list all the projects and let users choose which ones they 
 favorite, which by itself sounds like the kind of thing we might have done in project 7 or so.
  
 So home come it's a Level 2 project? Simple: when users favorite a project, we're going to 
 store that in Core Spotlight so they can find it later. And when they view a project, we'll use 
 the new 
 SFSafariViewController
  class for them to read. If those two new features from iOS 9 
 weren't enough for you, I'm going to throw in a little bit of 
 UITableViewCell
  automatic sizing, a 
 little bit of Dynamic Type and even some 
 NSAttributedString
  to handle formatted string 
 drawing.
  
 Are you feeling it now? I hope so. But if all this talk of Level 2 is confusing you, that probably 
 means you haven't completed projects 1 to 30 already, and should 
 click here to browse the 
 projects list
 . Those first 30 projects comprise Hacking with Swift Level 1 and you really need 
 to have completed them before tackling projects 31 onwards.
  
 Still here? Great! Make sure you have Xcode 7 installed, because we'll be using iOS 9 in this 
 tutorial. If you missed my summaries of 
 what's new in Swift 2.0
  and 
 new features in iOS 9 
 for developers
  click one of those two links.
  
 Please go ahead and create a new project in Xcode 7, choosing the Master-Detail 
  
 Application template. Name it Project32, choose Swift for your language, and iPhone for the 
 device.
  
 www.hackingwithswift.com 
  
 709",NA
Automatically resizing UITableViewCells ,NA,NA
with Dynamic Type and ,NA,NA
NSAttributedString ,"We're going to make a UITableView with formatted text that matches a user's preferred size, 
 and where every cell automatically resizes to fit its contents. What's more, it's going to be so 
 easy that you'll barely notice – Apple really has polished this technology, so you get an 
 incredible amount of power for free.
  
 First, we need to make two small changes to the default storyboard, so please open 
 Main.storyboard in Interface Builder. Using the Document Outline, select and delete ""Detail 
 Scene"" and ""Navigation Controller Scene"". Now select and delete DetailViewController.swift 
 into the Project Navigator pane on the left of your Xcode window.
  
 What you just did was delete the built-in segue from master controller to detail controller, so you 
 can expect a few errors. This might seem a strange thing to do given that we want to list 
 Hacking with Swift projects and let users choose one – a perfect example of a master/detail 
 layout – but actually things are a bit more complicated here. You see, we're going to be using 
 the new 
 SFSafariViewController
  class, which is 
 not
  part of UIKit and so not part of Interface 
 Builder. Showing one of these is something that's best done in pure Swift, which is why we 
 removed stuff from the storyboard.
  
 Now get out your shears, choose MasterViewController.swift, and delete the following:
  
  • 
 var detailViewController: DetailViewController? = nil
  • In 
 viewDidLoad()
  everything but 
 the call to 
 super.viewDidLoad()
  • All of 
 viewWillAppear()
  • All of 
 insertNewObject()
  • All of 
 prepareForSegue()
  • From 
 tableView(_:cellForRowAtIndexPath:)
  the two lines 
 let object = 
 objects[indexPath.row] as! NSDate
  and 
 cell.textLabel!.text = object.description
  • All of 
 tableView(_:canEditRowAtIndexPath:)
  • The contents of 
  
 tableView(_:commitEditingStyle:forRowAtIndexPath:)
  but not the method itself
  
 I don't know about you, but I rather like deleting source code – it's cathartic, and gives us a 
 nice, clean foundation to work from!
  
 If you've followed those instructions, your MasterViewController.swift file should look like this:
  
 import UIKit 
 www.hackingwithswift.com 
  
 710",NA
How to use SFSafariViewController to ,NA,NA
browse a web page ,"You just learned about automatic cell resizing, 
 NSAttributedString
  and Dynamic Type, so 
 you deserve a pat on the back. But there's more: I want to introduce you to one of the new 
 view controllers in iOS 9, and you'll be pleased to know that, once again, Apple has made it 
 startlingly simple to use.
  
 When a user taps on one of our table rows, we want to show the Hacking with Swift project 
 that matches their selection. In Ye Olden Days we would do this either with 
 UIWebView
  or 
 WKWebView
 , adding our own user interface to handle navigation. But this had a few 
 problems: everyone's user interface was different, features such as cookies and Auto Fill 
 were unavailable for security reasons, and inevitably users looked for an ""Open in Safari"" 
 button because that was what they trusted.
  
 Apple fixed all these problems in iOS 9 using a new class called 
 SFSafariViewController
 , 
 which effectively embeds all of Safari inside your app using an opaque view controller. That is, 
 you can't style it, you can't interact with it, and you certainly can't pull any private data out of it, 
 and as a result 
 SFSafariViewController
  can take advantage of the user's secure web data in 
 ways that 
 UIWebView
  and 
 WKWebView
  never could.
  
 What's more, Apple builds the new iOS 9 power features right into 
 SFSafariViewController
 , 
 so you get things like content blocking free of charge – and users get consistent features, 
 consistent UI, and consistent security. Everybody wins!
  
 SFSafariViewController
  is not part of UIKit, so you need to import a new framework to use it. 
 Add this to the existing 
 import UIKit
  line at the top of MasterViewController.swift:
  
 import SafariServices 
 We're going to create a method that accepts an integer and shows the matching tutorial. All 
 the Hacking with Swift tutorials are numbered from 1 upwards, so we can match that up to our 
 projects
  array (which is zero-based) just by adding 1. We'll convert that to an 
 NSURL 
 then 
 pass that to a new 
 SFSafariViewController
  to show to the user.
  
 When working with 
 SFSafariViewController
  there are two things you need to know. First, 
  
 www.hackingwithswift.com 
  
 720",NA
How to add Core Spotlight to index your ,NA,NA
app content ,"One of the most important additions in iOS 9 is the ability for apps to communicate 
 bidirectionally with Spotlight, the iOS system-wide search feature. What this means is that iOS 
 9 apps can ask for their content to be shown in the Spotlight search results and, if the user 
 taps one of those search results, the app gets launched and told what was tapped so it can 
 load the right content.
  
 In this project, we're going to have users favorite the Hacking with Swift projects that most 
 interest them. When they do that, we'll store the project title and subtitle in Spotlight so they 
 can search for things like ""wk"" and find the 
 WKWebView
  tutorial that is project 4.
  
 We're going to tackle this problem in three stages: updating the user interface to reflect 
 saved favorites, adding and removing items from Core Spotlight, then responding to deep 
 links when our app is launched from a search result in Spotlight.
  
 First up: creating a user interface that lets user favorite and unfavorite projects, and saving 
 those choices. There are various ways of doing this, but I've chosen the simplest: we're 
 going to set the table to be in editing mode, use the ""Insert"" and ""Delete"" icons to let users 
 select their favorites, and use a checkmark accessory type to show which projects are 
 already favorited.
  
 Behind the scenes we'll also need an array of 
 Ints
  that tracks which project numbers are 
 currently favorited, and that will be saved to 
 NSUserDefaults
  whenever a change is made.
  
 That's all we have to do in theory, but in practise there are two catches:
  
  • When a table is in editing mode, you can't tap the cells any more. Given that this is our way of 
 reading the projects, that's a big problem! Fortunately, we can just set the 
  
 allowsSelectionDuringEditing
  property to true to fix this.
  
  • When a table is in editing mode, you can't just set the 
 accessoryType
  because that isn't 
 shown. Instead, you need to set 
 editingAccessoryType
 , which functions the same but is 
 visible while editing.
  
 Let's do the easy stuff first: add this property to your class:
  
 var favorites = [Int]() 
 www.hackingwithswift.com 
  
 723",NA
Wrap up ,"This project covered a huge amount, including Core Spotlight, 
 SFSafariViewController
 , 
 NSAttributedString
 , automatically sized table view cells, and also Dynamic Type. Plus, you 
 have another project complete, and you're now able to customize it to fit your needs – as nice 
 as a Hacking with Swift browser is, I'm sure you have better ideas!
  
 If you want to work on this project some more, a great place to start is to convert the 
 projects
  
 array to contain objects of a custom subclass rather than just an array. Not only is it safer 
 coding, but it's also more extensible – you might want to add images or other data, and our 
 array stops being so simple when you add more to it! You should follow much the same 
 technique as taught in project 12 to handle loading and saving.
  
 I'd also recommend you investigate some of the many other formatting options you can use 
 with 
 NSAttributedString
 . Right-click on 
 NSFontAttributeName
  and choose Jump to Definition 
 to see a list, and just try things out! You'll see that Apple has put comments next to each key so 
 you can see what kind of data to provide.
  
 There's one more thing, which is the user changing their Dynamic Type size. This won't 
 happen very often, but if it happens while your app is running you'll receive the 
  
 UIContentSizeCategoryDidChangeNotification
  if you subscribe to it using 
  
 NSNotificationCenter
 . This is your chance to refresh your user interface so that fonts are 
 drawn at the new size.
  
 www.hackingwithswift.com 
  
 732",NA
Project 33 ,NA,NA
What's that ,NA,NA
Whistle?,NA,NA
Build a crowd-sourced song recognition app using Apple's ,NA,NA
free platform as a service: CloudKit.,NA,NA
Setting up ,"As I write these initial words, I already know this is going to be one of the most expansive and 
 useful Hacking with Swift tutorials to date. We're going to be using CloudKit to load and save 
 user data, we'll read from the microphone using 
 AVAudioRecorder
 , we'll add 
  
 UIStackView
  and 
 NSAttributedString
  for great layout, and we're going to tie in push 
 messaging for dynamic updates.
  
 This tutorial is going to show you CloudKit to a depth you won't see much elsewhere. Yes, 
 we're going to be loading and saving text data, but we're also going to be loading and saving 
 binary data, registering for updates, and delivering push messages – in short, we're going to be 
 covering the majority of CloudKit in one project, and you'll learn a huge amount along the way. 
 We're even going to be covering the simple and advanced methods of working with CloudKit, 
 because it gives a much better user experience.
  
 As you know, my usual plan is to pick which technologies I want to teach, then strap a real 
 project around it. In this case, the project is called ""What's that Whistle?"" It's an app where 
 users can whistle or hum into their microphone, and upload it to iCloud. Other users can then 
 download whistles and try to identify what song it's from. This is a genuinely useful app: think 
 how often you know how a song goes but just can't remember its name, and boom: this app is 
 for you. Of course, you could also turn it into a game – who can guess the song first? It's down 
 to you.
  
 To make things more exciting, we'll let users choose which music genres they specialize in, and 
 we'll deliver them a push message whenever a new whistle comes in for that genre. They can 
 then swipe to unlock and launch the app, and start posting suggestions for the song name.
  
 CloudKit is something that was announced with iOS 8, but it had some remarkably low limits 
 that made it so unappealing I decided not to write a tutorial about it. Back then, each app got 
 just 25MB per day of data transfer, growing at 0.5MB – yes, half a megabyte – per user per 
 day, which was absurdly low. But with iOS 9 Apple announced they were raising the limits so 
 that every app now gets 2GB per month plus a further 50MB per user per month. Even better, 
 database transfer is now judged on requests per second rather than an arbitrary data cap.
  
 If you're not aware of what CloudKit does, I'll be going into much more detail later. For now, 
 the least you need to know is that CloudKit lets you send and retrieve data for your app, 
 effectively providing a server back-end for your app to talk to. Even better, unless you go 
  
 www.hackingwithswift.com 
  
 734",NA
Recording from the microphone with ,NA,NA
AVAudioRecorder ,"We're going to start off this project easily enough by looking at 
 AVAudioRecorder
 : the iOS 
 way of recording audio from the microphone. You might be tempted to skip past this so you 
 can focus on the CloudKit parts, but please don't – I didn't put audio recording in here just for 
 fun! Instead, it's used to demonstrate how to store binary assets (i.e., data files) inside 
 CloudKit, so it's an integral part of the project.
  
 The built-in Xcode template will have given you one empty view controller inside 
  
 Main.storyboard, plus a ViewController.swift file. We're going to be doing almost all the user 
 interface in code for this project, so you can almost ignore the storyboard entirely – in fact, all 
 you need to do is select the view controller that was created and embed it inside a navigation 
 controller. Now go to ViewController.swift and add these lines to 
 viewDidLoad()
 :
  
 title = ""What's that Whistle?"" 
 navigationItem.rightBarButtonItem =  
 UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""addWhistle"") 
 navigationItem.backBarButtonItem = UIBarButtonItem(title: ""Home"", style: .Plain, target: nil, 
 action: nil) 
 That gives us a button to tap to add a whistle to the app, then customizes the title of the 
 navigation bar's back button to say ""Home"" rather than ""What's that Whistle?"" which is a bit 
 too long. We're going to return to this view controller much later to add a table view and other 
 bits, but for now let's write the very simple 
 addWhistle()
  method:
  
 func addWhistle() { 
  let vc = RecordWhistleViewController() 
  navigationController?.pushViewController(vc, animated: true) 
 } 
 So, that creates a new object of type 
 RecordWhistleViewController
  (not yet written), and 
  
 www.hackingwithswift.com 
  
 736",NA
Animating UIStackView subview layout ,"Before 
 we get onto the CloudKit part of this tutorial, we're going to add a bit more to our user interface. 
 Specifically, we're going to add a ""Tap to Play"" button into the stack view, and have it animate 
 so that it slides out when recording has finished. This is the work of only a few minutes thanks 
 to 
 UIStackView
 , and I'm sure you'll agree the results look marvellous.
  
 While we're finishing up the user interface, we're going to quickly add a couple more simple 
 view controllers to let the user attach some metadata to their whistle: they'll be able to select 
 what genre it is, then enter some free text with any comments – something like ""I definitely 
 remember hearing it in the early 90s"" to help listeners narrow the scope a little.
  
 First, the play button. Add this new property:
  
 var playButton: UIButton! 
 Now create it by placing this just before the end of 
 loadRecordingUI()
 :
  
 playButton = UIButton()  
 playButton.translatesAutoresizingMaskIntoConstraints = false 
 playButton.setTitle(""Tap to Play"", forState: .Normal)  
 playButton.hidden = true  
 playButton.alpha = 0  
 playButton.titleLabel?.font =  
 UIFont.preferredFontForTextStyle(UIFontTextStyleTitle1) 
 playButton.addTarget(self, action: ""playTapped"",  
 forControlEvents: .TouchUpInside)  
 stackView.addArrangedSubview(playButton) 
 That's almost identical to the code for creating the record button, except the play button is set to 
 hidden and alpha 0. Normally you need only one of these, but with stack views it's a little 
 different: a view that is not hidden but has an alpha of 0 appears hidden (i.e., the user can't see 
 it) but still occupies space in the stack view. By setting the button to be hidden and 
  
 www.hackingwithswift.com 
  
 749",NA
Writing to iCloud with CloudKit: ,NA,NA
CKRecord and CKAsset ,"We still have an error in our code, because we haven't created the 
 SubmitViewController 
 class yet. This is where CloudKit comes into play, because this view controller has only one 
 job: to show the user that iCloud submission is happening until it completes, at which point 
 we'll show a ""Done"" button.
  
 To make the view a little more interesting, we're going to use another 
 UIStackView
  to arrange 
 a text label and an activity spinner to keep the user informed. We're also going to hide the 
 back button so the user can't escape until iCloud finishes, successfully or otherwise.
  
 The last two view controllers have been collecting and passing on metadata, specifically a 
 genre and user comments. We'll need to add these as properties for 
 SubmitViewController
 , 
 along with properties for the stack view, the label and the activity spinner. So, create a new 
 class called 
 SubmitViewController
 , make it a subclass of 
 UIViewController
 , then add these 
 properties:
  
 var genre: String! 
 var comments: String! 
 var stackView: UIStackView! 
 var status: UILabel! 
 var spinner: UIActivityIndicatorView! 
 As for the 
 loadView()
  method, this is very similar to what we did with 
  
 RecordWhistleViewController
 : we'll use a stack view that is pinned to the left and right 
 edges then centered vertically. We'll add to this a 
 UILabel
  to show the send status, and a 
 UIActivityIndicatorView
  to show the user that something is happening, but otherwise 
 there's nothing surprising in this code:
  
 override func loadView() { 
  super.loadView() 
 www.hackingwithswift.com 
  
 758",NA
A hands-on guide to the CloudKit ,NA,NA
dashboard ,"If you already finished Hacking with Swift projects 1 to 30 (and you did, right?) you'll know I 
 hate tangents. I'm here to teach you something cool, and I prefer to do that using as little 
 waffle as possible – and tangents are apt to create the Perfect Storm for waffle. But in this 
 case it's important, so please bear with me.
  
 If you haven't already done so, you need to run your app, record a whistle, and tap Submit 
 now. All being well it will work first time (if not you probably missed something!), but how do 
 you know it's worked? I mean really be 
 sure
  that's it worked? And what do you do if you want 
 to change a data type because you made a mistake, or perhaps even delete the whole thing 
 and start again?
  
 Apple has a solution for this, and it's called the CloudKit Dashboard. Now that you have 
 submitted your first record to iCloud, you can launch 
 https://icloud.developer.apple.com/ 
 dashboard
  in your web browser and look behind the iCloud curtain as it were. The CloudKit 
 dashboard shows you exactly what data your app is storing, who can access it, and how 
 much of your free quota you're using.
  
 So, just briefly, it's time for a tangent: I want to explain a few things about CloudKit 
  
 Dashboard, because it's important. Yes, it 
 is
  important – later code won't run unless you read 
 my instructions, so please don't skip ahead.
  
 When you log into CloudKit Dashboard, you may need to select your project in the top-left 
 corner of the window. The default view you'll see is Schema > Record Types, and you'll see 
 two Record Types already there: Users and Whistles. The first of those was created 
 automatically for you by Apple, and tracks anonymised user IDs for your app. The second of 
 these was created by you just a few minutes ago: as soon as you called 
 saveRecord() 
 CloudKit transformed your record into a database in iCloud, and added your test whistle there.
  
 If you select the Whistles record type you'll see that CloudKit has identified that the comments 
 and genre fields are both strings, and the audio field is an asset. You'll also see a line saying 
 ""Metadata Indexes"" with the number 1 and an arrow below it. Please click that now to reveal 
 some fields that CloudKit has created for you: ID, Created By, Date Created, Date Modified 
 and Modified By. These are great for searching, but you can't sort usig these fields by default.
  
 www.hackingwithswift.com 
  
 766",NA
Reading from iCloud with CloudKit: ,NA,NA
CKQueryOperation and NSPredicate ,"So far our app takes a recording from the microphone using 
 AVAudioRecorder
  and sends it 
 off to iCloud for storage. You should have just seen that data in the CloudKit Dashboard, so 
 the next step is to write the code that pulls recordings back down to the device.
  
 This is where things get a little bit more complicated, but only a little. You see, there are two 
 ways of writing to CloudKit: a core API and a convenience API. The core API exposes every 
 possible behavior of the system, offering effectively unlimited functionality to do what you 
 want. The convenience API takes a subset of those features and simplifies them, making it 
 easier to learn and use but less powerful.
  
 When we wrote records two chapters ago we used the convenience API, but when it comes to 
 reading we're going to use the core API. This isn't because I enjoy torturing you, there is a 
 legitimate reason: when you read data using the convenience API it automatically downloads 
 all the data for each record. Often that's helpful, because it means you have everything you 
 need to show a record's data. But in our case that would mean downloading the audio for 
 every record every time we loaded our data – and that's a huge waste of resources.
  
 Remember, CloudKit gives you a basic quota of about 64MB per day of asset transfer, and 
 you need to be careful not to waste it. One of the features offered by the core API that is 
 absent from the convenience API is the ability to selectively download records. In our case, 
 that means we want the genre and user comments, but not the audio – we'll fetch that 
 separately, as needed.
  
 Go ahead and select ViewController.swift for editing. We're going to be using the CloudKit 
 framework, so please add this import:
  
 import CloudKit 
 This view controller is a 
 UIViewController
  subclass as opposed to a 
 UITableViewController 
 subclass, which is intentional as you'll see later. But it does mean we need to create and 
 configure a 
 UITableView
 , then pin it to the edges of our view. Except this time there's a small 
 twist: we're going to use the built-in 
 topLayoutGuide
  property to make the table view pin to the 
 edge of our navigation bar.
  
 www.hackingwithswift.com 
  
 770",NA
Working with CloudKit records: ,NA,NA
"CKReference, fetchRecordWithID, and ",NA,NA
saveRecord ,"I promised this was going to be a thorough CloudKit tutorial, and I'm going to keep that 
 promise over the next two chapters, starting here: we're going to learn about references and 
 records, as well as the 
 fetchRecordWithID()
  convenience API.
  
 So far, our app records whistles using 
 AVAudioRecorder
 , submits it to CloudKit, then shows 
 all whistles into a table view. The next step is to let users tap a whistle that interests them so 
 they can see more information, and in our case that will show the user's comments, any 
 suggestions submitted by other users, and a Listen button that downloads the whistle.
  
 The valuable thing about this screen is that it gives me a chance to show you the 
  
 CKReference
  class, which is used to link records together. Specifically, we're going to build 
 what's called a one-to-many relationship: one whistle can have many suggestions attached to 
 it. Using 
 CKReference
  let us query to find all suggestions for a specific whistle, but it has 
 another brilliant advantage known as 
 cascade deletes
 : if we delete a whistle from our 
 database, iCloud will automatically delete any suggestions that belong to it.
  
 Now, an important warning: as each whistle holds multiple suggestions, and each suggestion is 
 just going to be a string saying something like ""I think this is the theme tune from Star Wars,"" 
 you might be tempted to think ""ah, that means our whistle should have an array of strings 
 attached to its record."" If you try that, it'll work, and it'll work great – in testing. But when it 
 comes to shipping apps, this approach hits a core problem: conflicts.
  
 A conflict occurs when CloudKit receives two sets of different information, and it's something 
 that record arrays are particularly prone to. You see, if I get the record and it has no 
  
 suggestions, I might write ""that's the Star Wars theme tune."" But before I hit Submit, you also 
 download the record, see that it has no suggestions, and write ""That's totally the theme tune to 
 a big movie, but I can't remember which one,"" then hit Submit straight away. In iCloud, that 
 record is now updated to have your (quite useless!) suggestion, so when I submit mine there's 
 a conflict: I'm telling CloudKit the record has one suggestion (mine) and CloudKit thinks it 
 already had one suggestion (yours), so it isn't sure what to do.
  
 Conflict resolution isn't something CloudKit handles for you, because the correct answer 
 depends on your app. In this case, the correct answer is to merge both the arrays, but really 
  
 www.hackingwithswift.com 
  
 780",NA
Delivering notifications with CloudKit push ,NA,NA
messages: CKSubscription and ,NA,NA
saveSubscription ,"You're probably feeling very tired at this point: this has been a long tutorial and you've had to 
 learn a lot. Fortunately, this last chapter is a bonus – you don't need to read this to have a 
 great CloudKit app, but I do add some neat CloudKit technologies here that make the whole 
 experience better.
  
 So far, the app lets users record a whistle using 
 AVAudioRecorder
 , send it off to CloudKit, 
 download whistles others have posted, then write suggestions for what song they think it is. 
  
 What we're going to add now is the ability for users to register themselves as experts for 
 particular genres - they can say ""I know all about jazz and blues music."" When they do that, 
 we'll automatically tell them when a new whistle has been posted in one of those categories, 
 and they can jump right into the app to have a go at identifying it.
  
 We're going to do this with one of the most important technologies in iOS, called push 
 notifications. These are alerts that are delivered straight to the lock screens of users 
 whenever something interesting happens, and the app usually isn't running at the time. Push 
 is so important to iOS that it comes built into CloudKit, and it's done so elegantly that this 
 tutorial will be over in no time. In short: don't worry, the end is in sight!
  
 Create a new 
 UITableViewController
  subclass called 
 MyGenresViewController
 . Add a 
 CloudKit import to it, then add this property:
  
 var myGenres: [String]! 
 We'll use that to track the list of genres the user considers themself an expert on.
  
 Before we starting adding code to this new view controller, we need to make two small 
 changes in ViewController.swift. First, add this in 
 viewDidLoad()
 :
  
 navigationItem.leftBarButtonItem = UIBarButtonItem(title: ""Genres"", style: .Plain, target: self, 
 action: ""selectGenre"") 
 www.hackingwithswift.com
  
 793",NA
Wrap up ,"This was an epic tutorial: epic in length, epic in breadth, and I hope you'll agree epic in what 
 we've accomplished. You've built another real app, you've learned about 
 AVAudioRecorder
 , 
 CKQuery
 , 
 CKRecord
 , 
 CKAsset
 , 
 CKQueryOperation
 , 
 CKSubscription
 , 
 NSPredicate
 , 
 NSSortDescriptor
  and more, while also having some bonus practise working with 
  
 UIStackView
 , 
 UITableView
  and 
 NSAttributedString
 .
  
 So yes, the tutorial was long, but even though you're tired I'd like to think you're pleased with 
 the end result. Take a break, perhaps even a couple of days, then come back and have a think 
 about how you could improve this project. It's so big there are lots of possibilities, not least:
  
  • 
 ViewController
  is a subclass of 
 UIViewController
  rather than 
 UITableViewController
 . 
  
 Make it show something useful while fetching the iCloud records rather than just a blank 
 table.
  
  • If the iCloud fetch fails, we tell the user. How about adding a ""Retry"" button to the user 
 interface?
  
  • We made the 
 Whistle
  class inherit from 
 NSObject
 . Can you make it conform to the 
 NSCoding
  protocol? You might find my guide to NSCoding and NSUserDefaults in Swift 
 useful.
  
  • Fix the 
 AddCommentsViewController
  class so that it correctly adjusts the text view when 
 the keyboard appears. I already showed you how to do this in my tutorial on adjusting the 
 keyboard uising NSNotificationCenter.
  
  • Stop people from posting too many line breaks in their comments, or at least trim the 
 comments when shown in the main table view.
  
 Of course, the other thing you could do is perhaps the most important of all: go back through all 
 your code and make sure you handle CloudKit errors gracefully. Seriously, put your hand in the 
 air and repeat after me: I promise to show meaningful iCloud errors to my users. Now, I know 
 you didn't actually do that, but you really ought to at least mean it. As Apple has said, handling 
 errors is the difference between working apps and non-working apps, and you don't want a 
 non-working app, do you?
  
 www.hackingwithswift.com 
  
 803",NA
Project 34 ,NA,NA
Four in a ,NA,NA
Row,NA,NA
Let iOS take over the AI in your games using new iOS ,NA,NA
9 GameplayKit features.,NA,NA
Setting up ,"One of the most powerful features Apple introduced in iOS 9 is called GameplayKit. It's a 
 library designed to handle non-drawing game functionality such as artificial intelligence, path 
 finding and randomness, and it is pretty dazzling in its scope, so I was really looking forward 
 to write a tutorial about it.
  
 In this project, we're going to create a Four-in-a-Row (4IR) game, and I'm going to be honest 
 with you: I've cheated a bit. You see, Apple already released some sample code for a 4IR 
 game based on GameplayKit, and it works pretty well. Why, then, am I choosing to write a 
 tutorial based on it? Well, for some reason known only to Apple, the source code for the 
 project isn't up to their usual standard. Not only is it in Objective C, but it includes C functions 
 like 
 memcpy()
 , it uses 
 CABasicAnimation
  and 
 CAShapeLayer
  when regular 
 UIView
  
 functionality would do, and includes a 90-line method to detect wins that can be replaced with 
 code a third that size and easier to understand.
  
 Frustrating things further, this sample code is what's used to document GameplayKit, so 
 you're kind of stuck trying to learn about a very large new technology while studying an 
 unfriendly project, or reading the documentation… that's about the same unfriendly project. I 
 wanted to produce a project that was easier to understand and easier to learn, then produce a 
 tutorial that explained how it all worked.
  
 So, I took the Objective C code and rewrote it in Swift. I then simplified the structure to make it 
 more useful for learners, renamed some methods to make more sense, then cleaned up the 
 user interface. Where it wasn't too strange I have tried to keep Apple's original structure, so if 
 you choose to check out their original source code you won't be too lost – look for 
  
 FourInARow in the Apple sample code. I accept any and all blame for bugs introduced in the 
 Swift conversion process: if you spot any problems, 
 let me know on Twitter @twostraws 
 and 
 I'll get them fixed.
  
 You might well say, ""well, if you didn't like the 4IR game, how about Apple's DemoBots sample 
 code? That's really cool, and it uses GameplayKit!"" Yes, it does use GameplayKit. But it's also 
 made up of 84 Swift files, 6,952 images, 14 SKS files for effects and scenes, and a custom 
 shader. Cool: yes. Easy to learn from: not really. By all means download it, but this tutorial is 
 aimed at people just getting started with GameplayKit.
  
 Please note:
  this is a Hacking with Swift Level 2 project, which means I expect you to have 
 finished projects 1-30 first. If you have not done so, please 
 click here now
 , then return here 
 when you've levelled up. They are all free, so there's nothing holding you back.
  
 www.hackingwithswift.com 
  
 805",NA
Creating the interface with UIStackView ,"Once you start using UIStackView it's hard to stop, so naturally I wanted it in this project 
 even though we're making a game. The nature of 4IR games is that you have rows and 
 columns, and we're going to create a 
 UIStackView
  to host the columns. If I didn't want to 
 animate the chips falling into the board we'd be using stack views for the columns too!
  
 Open Main.storyboard in Interface Builder, then embed the existing view controller inside a 
 navigation controller. Now select the navigation controller you just created, find its Navigation 
 Bar in the document outline, then deselect Translucent in the attributes inspector – we don't 
 want our game going behind the navigation bar, after all.
  
 From the object library drag a Horizontal Stack View into your view controller, then resize it to 
 fill the entire view up to the bottom of the navigation bar. When that's done, go to Editor > 
 Resolve Auto Layout Issues > Reset to Suggested Constraints to add in the Auto Layout 
 constraints required to keep it filling the view.
  
 Now drag seven buttons into the stack view. By default, the stack view will show the first one 
 large and all the others as small as possible, but you should select the stack view, go to the 
 attributes inspector, then change Distribution to Fill Equally. While you're there, give Spacing a 
 value of 2.
  
 These seven buttons will be used to store the columns in our game, so to make them stand 
 out I'd like you to select them all and give them all a white background color. Button 
 background color is quite a way down the attributes inspector, so you will need to scroll to 
 find it. Now clear the text for all the buttons, making them just large white spaces that 
 respond to taps.
  
 Now I need you to select each of the buttons in order and give them increasing Tag values. The 
 one on the far left can keep its Tag of 0, but the second one should have a Tag of 1, then 2, 3, 
 4, 5 and 6. This will be used to identify which button was tapped later on.
  
 To make the buttons stand out as columns, select the view itself (you might need to use the 
 document outline view for this) then give it a gray background color. Don't try to give the stack 
 view a background color – it's doesn't actually do any drawing, so your background color will 
 be ignored.
  
 www.hackingwithswift.com 
  
 807",NA
Preparing for basic play ,"We're going to put together the absolute basics required to represent a 4IR game on iOS. 
 Because of the way GameplayKit works, it's especially important to keep a good separation 
 between your model (the state of the game) and your view (how things look). Over the course 
 of this project we're going to produce three different data models: one for the game board 
 (stores the complete game state), one for players (for storing their color and name), and one for 
 a ""move"" – used when it comes to building an AI.
  
 We're going to start with the game board now, so add a new file to the project: choose Cocoa 
 Touch Class and click Next, name it Board and make it subclass from 
 NSObject
 , then click 
 Next and Create.
  
 To begin with, this 
 Board
  class is just going to have two properties: one for tracking the 
 width of the board, and one to track the height. We'll be adding more later, but for now add 
 these two:
  
 static var width = 7 
 static var height = 6 
 Now go back to ViewController.swift. Like I said, there's an important distinction between the 
 model and the view. That 
 Board
  class will hold our model, which means it will store where all 
 the chips are and who is winning. This view controller will store its own array of where the chips 
 are, but it does this so it can draw the view correctly.
  
 A ""chip"" in this case is a 4IR piece, either red or black. We'll be using 
 UIViews
  for this purpose, 
 setting a high corner radius so they look like circles – it's a simple trick, but effective. To store 
 this, we'll need an array of arrays. That is, we'll need an array to store each column, and 
 another array to hold all those column arrays. We're also going to add a property to store a 
 Board
  object, using that class we just created. So, add these two properties to 
 ViewController.swift:
  
 var placedChips = [[UIView]]() 
 var board: Board! 
 www.hackingwithswift.com
  
 810",NA
Adding in players: GKGameModelPlayer ,"It's 
 time to take our first step into GameplayKit, although at first this step will be small. Right now 
 our game is single-player, and all chips that get dropped are red chips. We're going to 
 upgrade this so that there are two players by creating a new 
 Player
  class that stores a 
 player's chip type, their name, their color, and a special GameplayKit value called 
 playerId
  – 
 this is just a number that identifies every player uniquely.
  
 On top of that, we're also going to create a static property for players, which means it's a 
 property that belongs to the class and thus can be called from anywhere. This will be an 
 allPlayers
  array holding both 
 Player
  objects for easy reference
  
 So, please create a new Cocoa Touch Class in your project. Name it Player, then make it 
 inherit from 
 NSObject
 . Let's go ahead and create the properties up front. As a reminder, we 
 need:
  
  • The chip color of the player, either 
 .Red
 , 
 .Black
 , or 
 .None
 .
  
  • The drawing color the player, set to a 
 UIColor
 .
  
  • The name of the player, which will be either ""Red"" or ""Black"".
  
  • A GameplayKit 
 playerId
  property, which we'll just set to the raw value of their chip type. 
  
 (We set this enum up as an integer, 
 remember?)
  
  • A static array of two players, red and black.
  
 Add these properties now:
  
 var chip: ChipColor 
 var color: UIColor 
 var name: String 
 var playerId: Int 
 static var allPlayers = [Player(chip: .Red), Player(chip: .Black)] 
 Now for what is going to be a huge anti-climax: let's bring in GameplayKit by adding this 
 import:
  
 www.hackingwithswift.com 
  
 820",NA
Detecting wins and draws in Four in a Row ,"Now it's time to make our game an actual game – i.e., something a player can win. Four in a 
 Row is what's called a zero-sum game, which means for one player to win the other must lose. 
 This in turn means it's very easy to determine a winner: as soon as either player manages to 
 place four chips in a row in any direcion, they win. As for detecting a draw, that's just a matter of 
 checking to see if no more moves are available.
  
 Of the two, detecting a draw is far easier, so let's write that first. We already put a stub for 
 isFull()
  into the 
 Board
  class, but we can fill that out now: it will return false if any column 
 passes the 
 canMoveInColumn()
  test, otherwise it will return false. Here's the updated 
 method for Board.swift:
  
 func isFull() -> Bool { 
  for column in 0 ..< Board.width { 
  if canMoveInColumn(column) { 
  return false 
  } 
  } 
  return true; 
 } 
 Now for the more challenging method: how to detect when a player has won? In Apple's 
 original code for this, they took a brute force approach with four different methods for 
 detecting wins: left to right, up to down, and two types of diagonal. It's probably very 
 efficient code, but it's unpleasant to read and understand, so I've ditched their code and 
 replaced it with something substantially shorter and easier to understand.
  
 My solution involves two methods: 
 isWinForPlayer()
  and 
 squaresMatchChip()
 , and we'll 
 start with the second one first.
  
 For a player to win, they must have four chips of the same color lined up in a row anywhere 
  
 www.hackingwithswift.com 
  
 827",NA
How GameplayKit AI works: ,NA,NA
"GKGameModel, GKGameModelPlayer ",NA,NA
and GKGameModelUpdate ,"Amongst the many features introduced in GameplayKit, one of the most immediately useful 
 is its ability to provide artificial intelligence that can evaluate a situation and make smart 
 choices. We're going to be using it in our Four in a Row game to provide a meaningful 
 opponent, but first it's essential that you understand how GameplayKit tackles the AI 
 problem because it directly affects the code we'll write.
  
 GameplayKit has three protocols we need to implement in various parts of our model:
  
  • 
 GKGameModel
  is used to represent the state of play, which means it needs to know where 
 all the game pieces are, who the players are, what happens after each move is made, and 
 what the score for a player is given any state.
  
  • 
 GKGameModelPlayer
  is used to represent one player in the game. This protocol is so 
 simple we already implemented it: all you need to do is make sure your player class has a 
 playerId
  integer. It's used to identify a player uniquely inside the AI.
  
  • 
 GKGameModelUpdate
  is used to represent one possible move in the game. For us, that 
 means storing a column number to represent a piece being played there. This protocol 
 requires that you also store a 
 value
  integer, which is used to rank all possible results by 
 quality to help GameplayKit make a good choice.
  
 We have a sensible match for the first two in our 
 Board
  and 
 Player
  classes, but we have 
 nothing suitable for 
 GKGameModelUpdate
  so let's create that now. Like I said, this needs to 
 track only how ""good"" a move is, where each move is represented by a column number to play.
  
 This is easy to do, so please go ahead and create a new Cocoa Touch class in your project. 
 Name it Move, and make it subclass from NSObject. Now replace its source code with this:
  
 import GameplayKit 
 import UIKit 
 class Move: NSObject, GKGameModelUpdate { 
  var value: Int = 0 
 www.hackingwithswift.com 
  
 831",NA
Implementing GKGameModel: ,NA,NA
gameModelUpdatesForPlayer() and ,NA,NA
applyGameModelUpdate() ,"Now you understand how GameplayKit approaches AI, it's time for some action. Open up 
 Board.swift, then add this import:
  
 import GameplayKit 
 You can now make your 
 Board
  class conform to the 
 GKGameModel
  protocol like this:
  
 class Board: NSObject, GKGameModel { 
 As soon as you do that, your beautiful project will stop compiling and you'll see two errors: 
 the 
 Board
  class does not conform to 
 NSCopying
  or 
 GKGameModel
 . We covered 
 NSCoding
  in 
 the original Hacking with Swift
  series, but not 
 NSCopying
 , so let's start 
 there.
  
 As you'll no doubt remember(!), 
 NSCoding
  is used to encoding and decode objects so that they 
 can be archived, such as when you're writing to 
 NSUserDefaults
 . This is great for when you 
 want to save or distribute your data, but it's not very efficient if you just want to copy it, and 
 that's where 
 NSCopying
  comes in: it's a protocol that lets iOS take a copy of your object in 
 memory, with the copy being identical but separate to the original. As you saw in the last 
 chapter, GameplayKit will be taking a lot of copies of our game board, so we definitely need to 
 conform to 
 NSCopying
 .
  
 Implementing 
 NSCopying
  is as simple as adding one new method, called 
 copyWithZone()
 . 
 The ""zone"" part is an optimization hangover from many years ago, and has been ignored for 
 years. In our particular case, we're going to take a little shortcut by merging two things 
 together: taking a copy of the game board and applying a game state.
  
 If you remember, GameplayKit takes multiple copies of our board so that it can evaluate 
 various moves. It then re-uses those copies by setting their game state, which is where 
  
 www.hackingwithswift.com 
  
 834",NA
Creating a GameplayKit AI using ,NA,NA
GKMinmaxStrategist ,"If you've made it this far then you have built a Four in a Row game where two players can 
 place chips in the game slots and either win or draw, and you've also prepared your model 
 data to be run through the new GameplayKit AI routines. But we haven't created the AI just 
 yet: we've just added some methods to our game models to enable an AI to make choices.
  
 In this final step, we're going to use a new class called 
 GKMinmaxStrategist
 , which is a 
 gameplay strategy that tries to MINimize losses while MAXimizing gains – hence the name 
 minmax, or minimax. When you create a 
 GKMinmaxStrategist
  you tell it how many moves it 
 should look ahead, and also what it should do to break ties, i.e. if it has two or more moves 
 that are equally good.
  
 Once you've created the strategist object, you need to provide it a game model to examine 
 (that's our 
 Board
  class), then ask it either to make the best move or make a random good 
 move. If you ask for the best move, you'll get given back a 
 GKGameModelUpdate
  object 
 (that's a 
 Move
  in our game) that represents the best move. If you ask for a random good 
 move you'll need to tell it how many it should consider good (i.e., pick one from the top 5), 
 and you'll get back a random 
 GKGameModelUpdate
  from that list of good moves.
  
 Now, one thing to be aware of up front: running AI takes a long time, particularly if you have a 
 high look ahead depth. As a result, you should run the AI on a background thread so that your 
 user interface doesn't lock up, and only push work back to the main thread when you have a 
 move ready to make.
  
 Let's go ahead and implement 
 GKMinmaxStrategist
  now. Open ViewController.swift in your 
 editor, then import GameplayKit. Now add this property to the 
 ViewController
  class:
  
 var strategist: GKMinmaxStrategist! 
 One strategist is capable of handling more than one game (i.e., if the player restarts the 
 game) just by changing its game model, so we only need to create one 
  
 GKMinmaxStrategist
  object. As it's needed straight away, we might as well put this into 
 viewDidLoad()
  – anywhere before the call to 
 resetBoard()
  is fine:
  
 www.hackingwithswift.com 
  
 840",NA
Wrap up ,"I don't know about you, but I certainly enjoyed this tutorial – not only does it involve cool new 
 iOS 9 stuff, but it's always fun to watch an artificial intelligence ""think"" its way through a problem 
 and come to a solution. Plus, I got the chance to sneak in more 
 UIStackView 
 action, which is 
 always a good thing!
  
 If you're looking to extend this project, the first thing you're likely to target is the heuristic 
 function. As I said at the beginning, this project is based on some less-than-perfect Apple 
 sample code, which I went on to rewrite in Swift, then refactor to make it easier to 
  
 understand. The heuristic code is what makes the AI smart, but it doesn't take into account 
 how many moves it takes for a win to happen, and so it performs fairly poorly.
  
 As for other improvements, you've seen how this game could work in one- or two-player 
 modes, so you could easily add a user interface to let the player select what kind of game 
 they wanted. Then, by adjusting the level of look ahead, you could implement Easy, Medium 
 and Hard computer opponents.
  
 For a much easier improvement to make, you could switch out our 
 UIView
  chips for 
 UIImageViews
 , then draw your own red and black chip graphics. There isn't much coding 
 required to make this happen, but let's face it: you've just written a mountain of code, so you 
 probably deserve a break!
  
 Anyway, that's it for this project. Once again you've made a useful, real-world project that is 
 now your own to extend in whichever direction you want. As a heavy user of iOS apps, I'm 
 particularly looking forward to seeing how apps (not games!) will use AI – can it recommend 
 songs with some real intelligence, for example? Have fun!
  
 www.hackingwithswift.com 
  
 847",NA
Project 35 ,NA,NA
Random ,NA,NA
Numbers,NA,NA
The new iOS 9 GameplayKit lets you generate random ,NA,NA
numbers in ways you soon won't be able to live ,NA,NA
without.,NA,NA
Setting up ,"If you already read project 34 you'll know how much I love GameplayKit in iOS 9. In that 
 project we used a new class called 
 GKMinmaxStrategist
  to produce an AI that can win at 
 Four in a Row games by looking ahead many moves in advance, but the truth is that we only 
 scratched the surface of what GameplayKit can do.
  
 In this project, the first Hacking with Swift Level 2 technique project, we're going to look at 
 another aspect of GameplayKit that is hugely exciting: randomisation. This will, I'm certain, 
 strike you as a strange topic to choose: surely randomisation is a solved problem – what makes 
 it interesting enough to warrant discussion, never mind to dedicate a whole technique project?
  
 It's true that generating random data – or at least the pseudo-random that most of us consider 
 good enough – is old news, but the GameplayKit implementation goes a step further: Apple 
 thought specifically about random needs for games, and has built a 
  
 randomisation system that I promise you're going to love, and going to use even when you're 
 not making games.
  
 Don't believe me? Fire up Xcode, create a new playground, and let's begin!
  
 www.hackingwithswift.com 
  
 849",NA
Generating random numbers in iOS 8 ,NA,NA
and earlier ,"There were lots of ways you can generate random numbers before iOS 9 came along, but 
 none were both easy and good. For example, you could use the 
 rand()
  function like this:
  
 print(rand())  
 print(rand())  
 print(rand())  
 print(rand()) 
 That calls 
 rand()
  four times. Place those four lines of code into your playground, and you'll 
 see four values in the results pane of Xcode. Now, using my incredible psychic powers, I 
 shall predict what those four random numbers are. Ready? Here goes: 16807, 282475249, 
 1622650073 and 984943658.
  
 Was I right? Probably. This is because 
 rand()
  isn't very random by default. Random number 
 generators are called pseudo-random for a reason: given a known starting state, you can 
 usually predict what will come next. This has advantages for things like network games, 
 because you just need to synchronise the starting state between clients and in theory they 
 can both generate the same ""random"" numbers.
  
 If you want to seed the random number generator with an (effectively) random state, you 
 would use the 
 srand()
  function first, like this:
  
 srand(UInt32(time(nil)))  
 print(rand())  
 print(rand())  
 print(rand())  
 print(rand()) 
 That uses the current time of the day to seed the random number generator, and because 
  
 www.hackingwithswift.com 
  
 850",NA
Generating random numbers with ,NA,NA
GameplayKit: GKRandomSource ,"Let's look at the most basic way of generating random numbers using GameplayKit, which is 
 the 
 GKRandomSource
  class and its 
 sharedRandom()
  method.
  
 A random source is a provider of an unfiltered stream of random numbers as you need them. 
 As you'll see soon, GameplayKit has various options for your stream, but for now we're going to 
 look at the simplest one: 
 sharedRandom()
 .
  
 Using 
 sharedRandom()
  for a random number source returns the systems built-in random 
 source that's used for a variety of other tasks, which means you can be pretty sure it's in a 
 truly random state by the time it gets to you. It does, however, mean that it's useless for 
 synchronizing network games, because everyone's device is in a different state.
  
 To produce a truly random number you'd use the 
 nextInt()
  method like this:
  
 print(GKRandomSource.sharedRandom().nextInt()) 
 That produces a number between -2,147,483,648 and 2,147,483,647 – yes, that's a negative 
 number, which means it's not a drop-in replacement for 
 arc4random()
 . Plus, even with 
 GameplayKit's great new logic, Apple includes a warning that it's not guaranteed to be 
 random for very specific situations (harkening back to 
 rand()
 , no less), so for both these 
 reasons it's not likely you'll want to use 
 nextInt()
  much.
  
 As an alternative, try using the 
 nextIntWithUpperBound()
  method, which works identically to 
 arc4random()
 :
  
 print(GKRandomSource.sharedRandom().nextIntWithUpperBound(6)) 
 That will return a random number from 0 to 5 using the system's built-in random number 
 generator.
  
 As well as 
 nextInt()
  and 
 nextIntWithUpperBound()
  are 
 nextBool()
  for generating a random 
  
 www.hackingwithswift.com 
  
 854",NA
Choosing a random number source: ,NA,NA
GKARC4RandomSource and other ,NA,NA
GameplayKit options ,"Using the system's built-in random number source is exactly what you want when you just 
 need something simple. But the system's random number generator is not deterministic, 
 which means you can't predict what numbers it will output because it always starts in a 
 different state – and that makes it useless for synchronizing network games.
  
 Using the system's random number source is also useless to avoid cheating. If someone is 
 playing a brilliant strategy game you made and loses a battle because a dice roll didn't go 
 their way, they could quickly quit the app, relaunch, and try the battle again hoping that the 
 random roll would go differently for them.
  
 GameplayKit offers three custom sources of random numbers, all of which are deterministic, 
 and all of which can be serialized – i.e., written out to disk using something like 
 NSCoding 
 that we looked at in project 12. This means network play can be synchronized and cheaters 
 are unable to force their way around your game – a win all around!
  
 The reason GameplayKit has three sources of random numbers is simple: generating random 
 numbers is hard, so you get to choose whether you want something simple and fast, hard and 
 slow, or somewhere in the middle. That is, if you know the result of your random number 
 doesn't matter that much and you're going to need thousands quickly, you can use the faster-
 but-less-random option. Alternatively, if you need one random number but it's got to be as 
 random as they come, you can use the more intensive algorithm. In short, 
 you pays your 
 money and you takes your choice.
 The three options are:
  
  • 
 GKLinearCongruentialRandomSource
 : has high performance but the lowest randomness 
 • 
 GKMersenneTwisterRandomSource
 : has high randomness but the lowest performance • 
 GKARC4RandomSource
 : has good performance and good randomness – in the words of 
 Apple, ""it's going to be your Goldilocks random source.""
  
 Honestly, the performance difference between the three of these is all but insignificant unless 
 you're generating vast quantities of random numbers.
  
 So, to generate a random number between 0 and 19 using an ARC4 random source that you 
 can save to disk, you'd use this:
  
 www.hackingwithswift.com 
  
 856",NA
Shaping GameplayKit random numbers: ,NA,NA
"GKRandomDistribution, ",NA,NA
GKShuffledDistribution and ,NA,NA
GKGaussianDistribution ,"Random sources are interesting enough, but chances are you're wondering why you've spent 
 the last 20 minutes reading about GameplayKit and have yet to see anything 
  
 interesting. Well, here's where good becomes great: GameplayKit lets you shape the random 
 sources in various interesting ways using 
 random distributions
 .
  
 Let's start off with something simple: rolling a six-sided dice. This is effectively identical to 
 generating a random number between 1 and 6, which before meant having to call our old 
 friend:
  
 func RandomInt(min min: Int, max: Int) -> Int { 
  if max < min { return min } 
  return Int(arc4random_uniform(UInt32((max - min) + 1))) + min } 
 That's all gone in GameplayKit, because they have built six-sided dice right into their API. 
 No, really. Try this:
  
 let d6 = GKRandomDistribution.d6()  
 d6.nextInt() 
 Boom: you'll get a random number between 1 and 6. Want a 20-sided die? Great:
  
 let d20 = GKRandomDistribution.d20()  
 d20.nextInt() 
 www.hackingwithswift.com
  
 858",NA
Shuffling an array with GameplayKit: ,NA,NA
arrayByShufflingObjectsInArray() ,"Many Swift game projects use this Fisher-Yates array shuffle algorithm implemented in Swift 
 by Nate Cook:
  
 extension Array { 
  mutating func shuffle() { 
   for i in 0..<(count - 1) { 
   
  
  let j = Int(arc4random_uniform(UInt32(count - i))) + i 
  
  
  
 swap(&self[i], &self[j]) 
   } 
  }  
 } 
 With GameplayKit there's a specific method you can call that does a similar thing: 
  
 arrayByShufflingObjectsInArray()
 . I say ""similar thing"" rather than ""identical thing"" because 
 the GameplayKit returns a new array rather than modifying the original, whereas Nate's 
 version shuffles in place. We used this method a lot in the original Hacking with Swift projects, 
 so hopefully you're familiar with it by now.
  
 For example, if you wanted to blithely ignore the inevitable legalities and set up a lottery in 
 your neighborhood, you could create an array containing the numbers 1 to 49, randomise its 
 order, then pick the first six balls:
  
 let lotteryBalls = [Int](1...49)  
 let shuffledBalls =  
 GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(lotteryB alls)  
 print(shuffledBalls[0])  
 print(shuffledBalls[1])  
 print(shuffledBalls[2])  
 print(shuffledBalls[3]) 
 www.hackingwithswift.com 
  
 863",NA
Wrap up ,"I realise technique projects can be a little dry, but I hope you can see some real advantages to 
 using GameplayKit randomisation over other solutions. Not only does it offer a wider range of 
 functionality (shuffle and Gaussian distributions are awesome!) but it makes your code much 
 simpler, and also has the guarantee of being provably random.
  
 Of course, if you're stuck supporting prior versions of iOS, you'll need to mix and match 
 GameplayKit randomisation with calls to 
 arc4random_uniform()
  and the like. Make sure you 
 take advantage of the 
 #available
  syntax in Swift 2
  so you can use the new APIs when they 
 are available.
  
 It bears repeating that this is only a small slice of what GameplayKit offers. If you haven't 
 already read tutorial 34, you should check it out now - it's a tutorial for GKMinmaxStrategist 
 from GameplayKit that shows how to create an AI for Four in a Row.
  
 www.hackingwithswift.com 
  
 866",NA
Project 36 ,NA,NA
Crashy Plane,NA,NA
Ever wanted to make a Flappy Bird clone? Now you ,NA,NA
can do it in under an hour thanks to SpriteKit.,"www.hackingwithswift.com 
  
 867",NA
Setting up ,"This is the first game project in Hacking with Swift level 2, and we're going to produce a 
 Flappy Bird clone called Crashy Plane. You might be forgiven for thinking, ""do we really need 
 another tutorial on how to make Flappy Bird?"" And you're right, because there are quite a few 
 tutorials out that already. But this one is different: we'll be using Swift 2, we'll be using iOS 9.0, 
 and you're going to get some gorgeous assets you can use in your own games.
  
 So, it's Yet Another Flappy Bird tutorial, but I'm going to take the opportunity to teach you some 
 Swift 2 and iOS 9 along the way. Before you start, please 
 download the assets for this 
 project
  so you can follow along. If you haven't played Flappy Bird before, the concept is simple: 
 tap the screen to keep your bird flying, and don't touch the floor of any pipes. In our game it'll be 
 a plane with mountains as obstacles, but the idea is the same.
  
 The assets you download are all licensed under CC0 / public domain, which means you can 
 use them however you want without attribution. If you want to attribute the original authors, 
 see the README.txt file in the zip. The game art comes from a designer called Kenney, who 
 offers a huge selection of public domain game assets in return for a donation – if you're 
 serious about making games you should definitely 
 visit his home page
 .
  
 All set? Great! Launch Xcode and create a new project from the game template. Choose 
 Swift for your language, SpriteKit for the game technology, and iPhone for device. Name it 
 Project36 and click Next then Finish. Before we go any further, please lock your game's 
 orientation to be portrait.
  
 www.hackingwithswift.com 
  
 868",NA
Creating a player: ResizeFill vs AspectFill ,"The first thing we're going to do in this game is clear out what's there and get our player on the 
 screen so we can be sure everything is working. This is an iPhone game which means we need 
 to be able to handle various device sizes: iPhone 4s, iPhone 5, iPhone 6 and iPhone 6 Plus all 
 need to be catered for.
  
 In your project, select the Assets.xcassets asset catalog. You'll see AppIcon and Spaceship 
 already in there, and as usual I'd like you to delete Spaceship because it's not used in our 
 game. In the assets you downloaded, look in the GFX folder and drag all the files from there 
 into your asset catalog – you'll see I've provided 1x, 2x and 3x versions of each piece of art, 
 which means you could expand this into an iPad game later on if you wanted.
  
 Now right-click on your project group in the Project Navigator pane – that's not the blue 
 ""Project36"" at the top, but the yellow ""Project36"" directly beneath it. Choose New Group, then 
 name it ""Content"" and hit Enter. Copy into there the remaining assets you downloaded – 
 coin.wav, explosion.wav, music.m4a, PlayerExplosion.sks and spark.png.
  
 That's all the assets configured for this game, so let's look at the code: open up 
  
 GameScene.swift then remove everything from 
 didMoveToView()
 , 
 touchesBegan()
  and 
 update()
 , but leave the methods themselves intact because we'll be using them later. That 
 means your class should look like this:
  
 class GameScene: SKScene { 
  override func didMoveToView(view: SKView) { 
  } 
  override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { 
  } 
  override func update(currentTime: CFTimeInterval) { 
  } 
 www.hackingwithswift.com 
  
 869",NA
"Sky, background and ground: parallax ",NA,NA
scrolling with SpriteKit ,"There are multiple depth levels in Flappy Bird, and when they come together and scroll at 
 various speeds you get a surprisingly nice depth effect. We'll be controlling the depth of our 
 graphics by setting the 
 zPosition
  property of sprites, starting with the sky: this is just two 
 colored blocks that sit right at the very back of the game.
  
 You can create 
 SKSpriteNodes
  with nothing more than a color and a size, and that's what 
 we'll use here. I've sampled the sky colors based on the other graphics that we'll be adding 
 soon – the top and bottom parts of the sky are very, 
 very
  similar, but just different enough to 
 be visible.
  
 To make things easier for my brain, I'm going to be setting the 
 anchorPoint
  property of the 
 sprite nodes. This means they calculate their positions differently from the default, which 
 might not sound easy at all, but trust me: it is! By default, nodes have the anchor point X0.5, 
 Y0.5, which means they calculate their position from their horizontal and vertical center. We'll 
 be modifying that to be X0.5, Y1 so that they measure from their center top instead – it makes 
 it easier to position because one part of the sky will take up 67% of the screen and the other 
 part will take up 33%.
  
 Here's the 
 createSky()
  method; add this just below 
 createPlayer()
 :
  
 func createSky() { 
  let topSky = SKSpriteNode(color: UIColor(hue: 0.55, saturation: 0.14, brightness: 0.97, alpha: 
 1), size: CGSize(width: frame.width, height: frame.height * 0.67)) 
  topSky.anchorPoint = CGPoint(x: 0.5, y: 1) 
  let bottomSky = SKSpriteNode(color: UIColor(hue: 0.55, saturation: 0.16, brightness: 0.96, 
 alpha: 1), size: CGSize(width: frame.width, height: frame.height * 0.33)) 
  topSky.anchorPoint = CGPoint(x: 0.5, y: 1) 
  topSky.position = CGPoint(x: CGRectGetMidX(frame), y: frame.size.height) 
  bottomSky.position = CGPoint(x: CGRectGetMidX(frame), y:  
 www.hackingwithswift.com 
  
 873",NA
Creating collisions and making random ,NA,NA
numbers with GameplayKit ,"Part of the infuriating nature of Flappy Bird was that there were all sorts of collisions that could 
 instantly  kill you. In our game, these are massive rocks that will come out from the top and 
 bottom of the screen – and if a player hits any rock, or the ground, they are history.
  
 The player's job is to fly their plane safely through the rocks that come along. The difficult part 
 is that the gap between rocks varies in position, and can be high, low or in the middle of the 
 screen, so the player needs quick reactions to score anything over a few points.
  
 We're going to make a 
 createRocks()
  method in just a moment, but first here's what it needs to 
 do:
  
 1. Create top and bottom rock sprites. They are both the same graphic, but we're going to 
 rotate the top one and flip it horizontally so that the two rocks form a spiky death for the 
 player.
  
 2. Create a third sprite that is a large red rectangle. This will be positioned just after the rocks 
 and will be used to track when the player has passed through the rocks safely – if they touch 
 that red rectangle, they should score a point. (Don't worry, we'll make it invisible later!) 3. Use 
 the new 
 GKRandomDistribution
  class in iOS 9's GameplayKit to generate a random number 
 in a range. This will be used to determine where the safe gap in the rocks should be.
  
 4. Position the rocks just off the right edge of the screen, then animate them across to the 
 left edge. When they are safely off the left edge, remove them from the game.
  
 Here's the 
 createRocks()
  method, with numbered comments matching the numbers above:
  
 func createRocks() { 
  // 1 
  let rockTexture = SKTexture(imageNamed: ""rock"") 
  let topRock = SKSpriteNode(texture: rockTexture) 
  topRock.zRotation = CGFloat(M_PI) 
  topRock.xScale = -1.0 
  let bottomRock = SKSpriteNode(texture: rockTexture) 
 www.hackingwithswift.com 
  
 879",NA
"Pixel-perfect physics in SpriteKit, plus ",NA,NA
explosions and more ,"Everything in our game is configured to look good, but it's not actually playable yet. 
 Surprisingly, you're now only about 10 minutes away from a fully working game, because as 
 soon as we add in a few physics calls the game is good to go.
  
 As you might imagine, Flappy Bird is a game where physics really matters. The player's plane 
 has physics, the rocks have physics, the ground has physics, and there's also gravity pulling 
 the player inevitably downwards towards their doom. So, we need to make sure we are told 
 when collisions happen, which means we need to conform to the 
  
 SKPhysicsContactDelegate
  protocol. Change your 
 GameScene
  class's definition to this:
  
 class GameScene: SKScene, SKPhysicsContactDelegate { 
 Now in your 
 didMoveToView()
  method you want to make the SpriteKit physics world report 
 collisions to the game scene so they can be acted upon. We're also going to use this 
 opportunity to adjust the gravity of the physics world – you can set this to any value you want, 
 but be warned: the game is hard enough without massive amounts of gravity!
  
 Add these two lines to 
 didMoveToView()
 :
  
 physicsWorld.gravity = CGVectorMake(0.0, -5.0) 
 physicsWorld.contactDelegate = self 
 So: physics. Let's start by adding physics to the player. To make things fair, we're going to 
 use pixel-perfect collision detection to maximize the player's chance of survival, and 
 SpriteKit makes this really easy to do. In your 
 createPlayer()
  method, just after the call to 
 addChild()
 , add this:
  
 player.physicsBody = SKPhysicsBody(texture: playerTexture, size: playerTexture.size()) 
 player.physicsBody!.contactTestBitMask =  
 www.hackingwithswift.com 
  
 885",NA
"Background music with SKAudioNode, an ",NA,NA
"intro, plus game over ","To make this a finished game – or at least as finished as it can be before getting into tiny 
 minutiae – we're going to make four more changes: we're going to add background music, 
 show an intro screen, show a game over screen, and let the player try again when they die. 
 None of these things are difficult, but it's a chance to polish your skills while polishing the 
 game so hopefully you won't skip this out!
  
 First up: background music. New in iOS 9 is a SpriteKit class called 
 SKAudioNode
 , which adds 
 several key new features to audio in SpriteKit, such as the ability to pan your audio left and 
 right. For our purposes, however, 
 SKAudioNode
  is good because it lets us stop the audio 
 whenever we want. Remarkably, annoyingly, this was not part of SpriteKit for iOS 7 and 8, so 
 you had to resort to using something like 
 AVAudioPlayer
  for any sounds you wanted to stop 
 prematurely.
  
 One of the neat features of 
 SKAudioNode
  is that it loops its audio by default. This makes it 
 perfect for background music: we create the music, add it directly to the game scene as a child, 
 and it plays our background music forever. It also has the happy side effect of starting the iOS 
 Simulator's sound system as soon as the game begins, which means you won't have your 
 game freeze the first time the player touches a red scoring rectangle.
  
 Add a property for the background music now:
  
 var backgroundMusic: SKAudioNode! 
 Then add this to 
 didMoveToView()
 :
  
 backgroundMusic = SKAudioNode(fileNamed: ""music.m4a"") 
 addChild(backgroundMusic) 
 Note: if you value your sanity, you'll probably want to run your game now to make sure the 
 music works (yes, that code is all it takes!) then comment out those two lines so you don't 
  
 www.hackingwithswift.com 
  
 893",NA
Wrap up ,"This wasn't a complicated project, but I hope it was a satisfying one. The addition of new 
 techniques like 
 GKRandomDistribution
 , 
 SKAudioNode
  and 
 guard
  should have made it 
 more interesting even for more experienced coders, and it was fun adding the extra bit of 
 polish at the end to make the whole game feel more complete.
  
 If you want to take this project further, you could start by having different kinds of obstacles – 
 the repeating rocks do get a bit tiresome after a while! You could also make the game 
 difficulty ramp up ever so slowly, either by decreasing the gap between the rocks or by 
 increasing the world gravity. To make the game much more challenging, how about 
  
 introducing a secondary scoring mechanism: perhaps the player could get extra points if they 
 fly through hoops in between the rocks? If you fancy a bigger challenge, how about making it 
 a universal game, i.e. support both iPad and iPhone.
  
 www.hackingwithswift.com 
  
 900",NA
Project 37 ,NA,NA
Psychic ,NA,NA
Tester,NA,NA
Are you psychic? Of course not. But what if we could ,NA,NA
use our coding skills to make a game to fool your friends ,NA,NA
into thinking otherwise?,NA,NA
Setting up ,"Are you psychic? Of course not. But what if we could use our coding skills to make a game to 
 fool your friends into thinking otherwise – while also learning some new techniques along the 
 way?
  
 In this project we're going to build a simple game that recreates the classic 
 Zener test
  for 
 extrasensory perception. Our game will show the user eight cards face down, and users need 
 to tap the card that has a star on its flip side. Casual players will get it right 1 in 8 times, but 
 you'll get it right every time. Magic!
  
 Well, no. We'll be cheating, naturally, but even in this cheating I'm going to find new things to 
 teach you. First, we're going to build a tiny watchOS app that silently taps your wrist when 
 your finger moves over the star card. Then we're going to add 3D Touch support so that 
 pressing hard on any card will automaticaly make it the star. Whichever technique you use is 
 going to be enough to baffle your friends, although I hope you use your powers for good!
  
 At the same time we'll also be learning about 
 CAEmitterLayer
 , 
 CAGradientLayer
 , 
  
 @IBDesignable
  and 
 @IBInspectable
 , as well as how to create a 3D card flip effect using the 
 transitionWithView()
  method.
  
 I've left the Apple Watch and 3D Touch code until the end of the project, so at the very least 
 you'll be able to work through the majority of the tutorial without needing special hardware. 
 That being said, we'll be using one of Xcode's built-in iOS/watchOS templates to make the 
 end result easier to reach.
  
 Are you ready to take your first step into the Twilight Zone? Go ahead and launch Xcode, 
 then create a new project. When Xcode asks you which template you want, please select 
 watchOS then iOS App with WatchKit App. Set the target to be iPhone, the language to be 
 Swift, then deselect Include Notification Scene. Finally, name it Project37 and click Next.
  
 Once the project is created, please set it to support landscape left and right only; no portrait this 
 time. You will also need to copy the image assets for this project into your project's asset 
 catalog – you can 
 find them all on GitHub
 . You'll also find a Content directory in that 
 download; please add that to your project too, because it contains some music for later on.
  
 www.hackingwithswift.com 
  
 902",NA
Laying out the cards: ,NA,NA
addChildViewController() ,"The first step in our project will be to lay eight cards out on the screen so that the user can 
 tap on one. We'll be doing most of this in code, but there is a small amount of storyboard 
 work required.
  
 Open up Main.storyboard in Interface Builder, then draw out a large 
 UIView
  inside the view 
 controller that was made by the template. Set its size to be 480x320 using explicit width and 
 height constraits, then make it centered inside its parent view. This explicit sizing makes it 
 easy to support the full range of iPhones: we'll place the cards inside this container at exact 
 positions, and the container will be moved depending on the size of the device.
  
 We'll be placing something behind this view later on, so please set its background color to 
 be Clear Color. Then, using the Assistant Editor, please make an outlet connection between 
 your new view and the ViewController class, naming it 
 cardContainer
 .
  
 That's it: we're done with Interface Builder for now; the rest of this chapter will all be done 
 using code.
  
 In the screenshot below you can see how your interface should look – note that I've 
 temporarily colored my inner view gray so you can see it more clearly!
  
 www.hackingwithswift.com 
  
 903",NA
Animating a 3D flip effect using ,NA,NA
transitionWithView() ,"There's a reason I've made you put the card functionality into a separate view controller, and 
 it's because we're going to be adding some functionality to cards to handle them being flipped 
 over. iOS makes this kind of animation really easy, but it's done in a slightly different way to 
 our previous animations.
  
 To handle tap detection we're going to use a 
 UITapGestureRecognizer
  rather than 
 something like 
 touchesBegan
 . This will make more sense later on, but the TL;DR version is 
 that part of the hoax effect will be you running your finger over the cards using your powers to 
 ""feel"" for the star – something like 
 touchesBegan()
  will just cause problems.
  
 So, please add this gesture recognizer to the end of 
 viewDidLoad()
  in the 
 CardViewController
  class:
  
 let tap = UITapGestureRecognizer(target: self, action: ""cardTapped"") 
 back.userInteractionEnabled = true 
 back.addGestureRecognizer(tap) 
 We haven't written the 
 cardTapped()
  method yet, but it's trivial because all it will do is pass 
 the message on to the 
 ViewController
  class to handle. This is important: we need each card 
 to decide if it was tapped, but we need to pass control onto the 
 ViewController
  class to act 
 upon the tap, otherwise it's possible users might tap two cards at the same time and cause 
 problems.
  
 So, the 
 cardTapped()
  method in the card view controller is simple:
  
 func cardTapped() { 
  delegate.cardTapped(self) 
 } 
 www.hackingwithswift.com
  
 911",NA
Adding a CAGradientLayer with ,NA,NA
IBDesignable and IBInspectable ,"Magic is really the art of misdirection: making people focus their attention on one thing in 
 order to stop them focusing on something else. In our case, we don't want users to suspect 
 that your Apple Watch is helping you find the star, so we're going to overload them with 
 misdirection so that they suspect everything else before they think of your watch.
  
 The first thing we're going to do is add a background to our view. This is going to be a simple 
 gradient, but we're going to make the gradient change color slowly between red and blue. This 
 has no impact on your ability to find the star, but if it makes your friends suspect that the trick is 
 to tap a card when the background is red then it has fulfilled its job of misdirection.
  
 Making gradients in iOS isn't hard thanks to a special 
 CALayer
  subclass called 
  
 CAGradientLayer
 . That being said, working with layers directly isn't pleasant, because they 
 can't take part in things like Auto Layout and they can't be used inside Interface Builder.
  
 So, I'm going to teach you how to wrap a gradient inside a 
 UIView
 , while also adding the 
 benefits of letting you control the gradient right from within Interface Builder. What's more, 
 you'll be amazed at how easy it is.
  
 Add a new Cocoa Touch subclass to your project. Make it a subclass of 
 UIView
  then name it 
 GradientView
 . We need this class to have a top and bottom color for our gradient, but we 
 also want those values to be visible (and editable) inside Interface Builder. This is done using 
 two new keywords: 
 @IBDesignable
  and 
 @IBInspectable
 .
  
 The first of those, 
 @IBDesignable
 , means that Xcode should build the class and make it draw 
 inside Interface Builder whenever changes are made. This means any custom drawing you do 
 will be reflected inside Interface Builder, just like it would when your app runs for real.
  
 The second new keyword, 
 @IBInspectable
 , exposes a property from your class as an 
 editable value inside Interface Builder. Xcode knows how to handle various data types in 
 meaningful ways, so strings will have an editable text box, booleans will have a checkbox, 
 and colors will have a color selection palette.
  
 Other than defining properties for the top and bottom colors of the gradient, the 
  
 GradientView
  class needs to do only two other things to be complete: when iOS asks it 
 what kind of layer to use for drawing it should return 
 CAGradientLayer
 , and when iOS tells 
  
 www.hackingwithswift.com 
  
 915",NA
Creating a particle system using ,NA,NA
CAEmitterLayer ,"Let's take our misdirection up a notch by adding some falling, spinning stars behind the 
 cards. Again, these do nothing other than misdirect your friends while also giving me a 
 chance to squeeze some new learning into you.
  
 We first met particle systems 
 in project 11
  when we covered 
 SKEmitterNode
 . That's a fast 
 and easy way to create particle systems in SpriteKit, but we're not in SpriteKit now so we 
 need an alternative.
  
 Fortunately, iOS has one, and in fact it even predates 
 SKEmitterNode
 : 
 CAEmitterLayer
 . 
 From its name you should already be able to tell that it's a subclass of 
 CALayer
 , which in 
 turn means you need to use 
 CGColor
  rather than 
 UIColor
  and 
 CGImage
  rather than 
 UIImage
 . However, I should add that 
 CAEmitterLayer
  isn't quite a beautifully polished as 
 SKEmitterNode
  – it has no WYSIWYG editor, for example, so you need to do everything in 
 code.
  
 Each 
 CAEmitterLayer
  defines the position, shape, size and rendering mode of a particle 
 system, but it doesn't actually define any particles – that's handled by a separate class, called 
 CAEmitterCell
 . You can create as many emitter cells as you want, then assign them to your 
 emitter layer to have them all fire from the same position.
  
 There are 
 lots
  of properties you can set on emitter cells, and without a WYSIWYG editor 
 you're basically stuck reading the documentation to find them all. To give you a jump start, 
 I'm going to use quite a few to make our particle system:
  
  • 
 birthRate
  sets how many particles to create every second.
  
  • 
 lifetime
  sets how long each particle should live, in seconds.
  
  • 
 velocity
  sets the base movement speed for each particle.
  
  • 
 velocityRange
  sets how much velocity variation there can be.
  
  • 
 emissionLongitude
  sets the direction particles are fired.
  
  • 
 spinRange
  sets how much spin variation there can be between particles. 
 • 
 scale
  sets how large particles should be, where 1.0 is full size.
  
  • 
 scaleRange
  sets how much size variation there can be between particles. • 
 color
  sets the color to be applied to each particle.
  
  • 
 alphaSpeed
  sets how fast particles should be faded out (or in) over their lifetime.
  
  • 
 contents
  assigns a 
 CGImage
  to be used as the 
  
 www.hackingwithswift.com 
  
 919",NA
Wiggling cards and background music with ,NA,NA
AVAudioPlayer ,"The last part of our misdirection is going to be truly evil. That being said, it is entirely optional 
 because I won't be teaching any vital new techniques here – I just enjoy screwing with my 
 friends' heads!
  
 We're going to add two more simple distractions to our app. First, we're going to make 
 random cards move ever so slightly on the screen. The movement has to be small so that 
 people catch it in the corner of their eye, but then aren't 100% sure anything actually 
 happened. Second, we're going to add some background music to make people wonder 
 whether there's something in the sound effects that tells you where the star is.
  
 Making the cards move just a bit is easy thanks to the method 
  
 performSelector(_:withObject:afterDelay:)
  that I introduced earlier. We're going to write a 
 new method that scales a card so that it's a mere 1% larger than normal, before dropping it 
 down again. To make things more interesting, we want this animation to happen only 
 occasionally, so the users aren't sure when it will happen again.
  
 This misdirection is clever because human eyes are extremely sensitive to motion at the 
 edges of vision, so your eye notices a card moves and jumps to it, but of course by then our 
 animation has stopped so your user isn't sure whether anything happened. If you want to 
 create a more pronounced effect, just increase the transform scale that gets applied.
  
 Open CardViewController.swift and add this new method:
  
 func wiggle() { 
  if GKRandomSource.sharedRandom().nextIntWithUpperBound(4) == 1 { 
  UIView.animateWithDuration(0.2, delay: 0, options: 
 .AllowUserInteraction, animations: { 
  self.back.transform = CGAffineTransformMakeScale(1.01, 1.01); 
  }) { _ in 
  self.back.transform = CGAffineTransformIdentity; 
  } 
  performSelector(""wiggle"", withObject: nil, afterDelay: 8) 
 www.hackingwithswift.com 
  
 922",NA
How to measure touch strength using 3D ,NA,NA
Touch ,"3D Touch is a new technology that was first trialled in Apple Watch as Force Touch, but 
 introduced fully inside the iPhone 6s. In iOS it's responsible for multiple interesting 
  
 technologies: peek and pop (to preview and jump into view controllers), application shortcuts 
 (menus on the home screen for common actions) and also pressure-sensitive taps for 
 UITouch
 .
  
 All three of these are surprisingly simple to do, but in this project we're going to use only the 
 last one, and I think you'll be impressed by how easy it is. This project is about producing a 
 hoax, and we're going to make it so that if you press hard on any card it will automatically 
 become a star. This allows you to be able to ""guess"" correctly even without an Apple Watch 
 around, because any card is the right answer as long as you press correctly.
  
 To accomplish this, we're going to use two new properties of 
 UITouch
 : 
 force
  and 
  
 maximumPossibleForce
 . The first tells us how strongly the user is pressing for the current 
 touch, and the second tells us the maximum recognizable strength for the current touch. For 
 our purposes, we just need to make sure the two match: if the user is pressing as hard as the 
 screen can recognize, we'll enable our cheat.
  
 The cheat itself is really simple, because we just need to change the image on the front of the 
 card and set its 
 isCorrect
  property to be true.
  
 There is one small problem here, but it's trivial to fix: devices older than the iPhone 6s 
 devices don't support 3D Touch, and even 3D Touch devices can have the feature disabled 
 on user request. So, we need to add a simple check to ensure 3D Touch is available and 
 enabled on our current device.
  
 That's how it all needs to work in theory, but now for the implementation. To keep things as 
 straightforward as possible, we're going to add all this work to 
 touchesMoved()
  in 
 ViewController.swift, which will get called every time the user's finger moves on the screen. 
 Inside this method, we'll find where the user's touch was, then loop through all the cards to 
 find which one (if any) they are over. Then, if they are over a card and are pressing hard 
 enough, we'll enable the cheat.
  
 Add this method to ViewController.swift now:
  
 www.hackingwithswift.com 
  
 926",NA
Communicating between iOS and ,NA,NA
watchOS: WCSession ,"It's time for something new, and something I've held back from covering in Hacking with 
 Swift because only a small proportion of people have an Apple Watch. So, I'm covering it 
 here only briefly, and only at the very end of the project so that if you don't have an Apple 
 Watch you can just skip on past.
  
 Still here? OK: we're going to upgrade our project so that when your finger moves over the 
 correct card your Apple Watch will gently tap your wrist. The haptic vibration of Apple 
 Watches is so marvellously subtle that no one will have any idea what's happening – the 
 effect is very impressive!
  
 I have good news and bad news. First the good news: for our purposes, communicating 
 between Apple Watch and iOS could not be any easier – it take us maybe five minutes in 
 total to complete the code. Now the bad news: even when the settings are adjusted, your 
 Watch will go to sleep after 70 seconds of inactivity, so it's down you to make sure the app 
 stays awake.
  
 That bad news will make more sense once you're using the finished product, so without 
 further ado let's crack on with development. In ViewController.swift add this new import:
  
 import WatchConnectivity 
 As you might imagine, the WatchConnectivity framework is responsible for connectivity 
 between iOS apps and watchOS apps, and we'll be using it to send messages between our 
 phone and a Watch. The messages are dictionaries of any data you want, so you can send 
 strings, numbers, arrays and more – it's up to you.
  
 In order to work with a session, we need to check whether it's supported on our current 
 phone, then activate it. Put this code into the 
 viewDidLoad()
  method of ViewController.swift:
  
 if (WCSession.isSupported()) { 
  let session = WCSession.defaultSession() 
  session.delegate = self 
 www.hackingwithswift.com 
  
 929",NA
Designing a simple watchOS app to ,NA,NA
receive data ,"So far we have a fully working iOS app that shows cards players can flip over, has a cheat in 
 place for 3D Touch users so you can always guess correctly, and communication happening 
 from iOS to watchOS. The next step is to write a simple watchOS app that is able to receive 
 that data and make the device buzz gently.
  
 We started our project with an Xcode watchOS template, so all this time you will have seen two 
 watchOS folders in your Xcode project: WatchKit App and WatchKit Extension. Yes, cunningly 
 they are two separate things. The 
 extension
  contains all the code that gets run, and the 
 app
  
 contains the user interface. Both run on the Apple Watch as of watchOS 2.0, but in watchOS 
 1.0 the extension used to run on your iPhone.
  
 The first thing we're going to do is design a very simple interface using WatchKit, which is the 
 watchOS equivalent of UIKit. This interface is going to contain only a label and a button, 
 telling users to check their phone for instructions. We haven't written those instructions yet, 
 but all in good time…
  
 Look inside the WatchKit App folder for Interface.storyboard, and open that in Interface 
 Builder. Using the Object Library, just like on iOS, drag a label then a button into the small 
 black space of our app's user interface. You will see that WatchKit automatically stacks its 
 views vertically so the interface doesn't get too cluttered.
  
 Select the label, set its Lines property to be 0 so that it spans as many lines as necessary, 
 then align its text center and give it the following content: ""Please read the instructions on 
 your phone before continuing."" Now select the button and give it the text ""I'm Ready"". 
 Finally, select both the label and button then change their Vertical alignment property to be 
 Center.
  
 All being well, your WatchKit interface should look like the screenshot below. Don't worry that 
 the views go right to the edge – the Watch's bezel blends seamlessly with the edge of the 
 screen in its apps, so it will look fine on devices.
  
 www.hackingwithswift.com 
  
 934",NA
Wrap up ,"The app is finished, but really your work is about to begin: I've given you all the code you 
 need, but it's down to you to provide some meaningful patter to convince your friends! See 
 ""Polishing your patter"" below for some example patter to get you started, but first give the 
 app a quick try to make sure it all works.
  
 To get started, run the app on your phone, then run it on your Watch. Note that installing 
 apps and launching apps are both quite slow on Apple Watch, so make sure you prepare 
 ahead of time. Once the Watch app is running, remember that it will go to sleep in 70 
 seconds unless you stop it, and when the Watch sleeps you won't get any haptic taps. The 
 easiest thing to do is very gently rotate the Digital Crown every 30 seconds or so, just to be 
 sure.
  
 So, the app is complete and you've learned all about 
 CAGradientLayer
 , 
 CAEmitterLayer
 , 
 card flip effects, 
 performSelector()
 , 3D Touch and more - good job! If you want to try taking 
 the app further, try implementing the 
 sessionWatchStateDidChange()
  method in 
  
 ViewController.swift to detect when the Watch goes to sleep – if you make your phone play a 
 brief but innocuous sound, it would alert you to wake your watch.
  
 If you're looking for something more advanced, try adding a hidden button to the Watch user 
 interface that enables ""always win mode"" – i.e., every card that gets tapped will be the star. 
  
 Your patter can then be, ""I promise it's not a trick, in fact I can even transfer my psychic 
 power to you!"" and watch as your friend suddenly finds the star every time.",NA
Polishing your patter ,"Patter is verbal misdirection: what you say to your friends to confuse them while they are trying 
 to figure out the trick. At the very least, you should explain to your friend how the cards work: 
 there are eight cards with different shapes on, but only one has a green star. Let your friend try 
 finding the card by hand, to prove the set up is real. Lucky people will guess the star correctly; 
 very lucky people will guess twice in a row; but it's almost impossible that someone will get the 
 answer right three times in a row - that's where you come in!
  
 The easiest way to get started with the trick is by putting your finger down over one card, then 
 dragging it slowly over the other cards. Note: don't tap the cards, because that will turn one of 
 them over. Instead, slide your finger over them as if you're feeling for – 
 ahem
  – 
  
 www.hackingwithswift.com 
  
 939",NA
Project 38 ,NA,NA
GitHub ,NA,NA
Commits,NA,NA
Get started with Core Data by building an app to fetch ,NA,NA
and store GitHub commits for Swift.,NA,NA
Setting up ,"In this project you'll learn how to use Core Data while building an app that fetches GitHub 
 commit data for the Swift project. Core Data is Apple's object graph and persistence 
 framework, which is a fancy way of saying it reads, writes and queries collections of related 
 objects while also being able to save them to disk.
  
 Core Data is undoubtedly useful, which is why about 500,000 apps in the App Store build on 
 top of it. But it's also rather complicated to learn, which is why I left it so late in this tutorial 
 series – despite my repeated attempts to simplify the topic, this tutorial is still going to be the 
 hardest one in the whole of Hacking with Swift, and indeed I might have missed it out altogether 
 were it not by far the most requested topic from readers!
  
 So, strap in, because you're going to learn a lot: we'll be covering Core Data, which will 
 encompass 
 NSFetchRequest
 , 
 NSManagedObject
 , 
 NSPredicate
 , 
 NSSortDescriptor
 , and 
 NSFetchedResultsController
 . We'll also touch on 
 NSDateFormatter
  for the first time, which 
 is Apple's way of converting 
 NSDate
  objects into human-readable formats.
  
 As always, I like to teach new topics while giving you a real-world project to work with, and in 
 our case we're going to be using the GitHub API to fetch information about Apple's open-source 
 Swift project. The GitHub API is simple, fast, and outputs JSON, but most importantly it's public. 
 Be warned, though: you get to make only 60 requests an hour without an API key, so while 
 you're testing your app make sure you don't refresh too often!
  
 If you weren't sure, a ""Git commit"" is a set of changes a developer made to source code that 
 is stored in a source control repository. For example, if you spot a bug in the Swift compiler 
 and contribute your changes, those changes will form one commit. And before I get emails 
 from random internet pedants, 
 yes I know
  things are more complicated than that, but it's more 
 than enough of an explanation for the purposes of this tutorial.
  
 Before we start, it's important I reiterate that Core Data can be a bit overwhelming at first. It 
 has a lot of unique terminology, and it needs a lot of boilerplate just to get you up and running. 
 If you find yourself struggling to understand it all, that's perfectly normal – it's not you, it's just 
 Core Data.
  
 Over the next four chapters, we will implement the four pieces of Core Data boilerplate. 
 We're going to use Xcode's built-in Master-Detail Application template, but we're not 
 not 
 going to have it generate Core Data code for us – that particular template is confusing 
 enough as it is, and the Core Data variety is practically impenetrable.
  
 www.hackingwithswift.com 
  
 942",NA
Designing a Core Data model ,"A data model is a description of the data you want Core Data to store, and is a bit like creating 
 a class in Swift: you define entities (like classes) and give them attributes (like properties). But 
 Core Data takes it a step further by allowing you to describe how its entities relate to other 
 entities, as well as adding rules for validation and uniqueness.
  
 We're going to create a data model for our app that will store a list of all the GitHub commits 
 for the Swift library. Take a look at the raw GitHub JSON now by loading this URL in a web 
 browser: 
 https://api.github.com/repos/apple/swift/commits?per_page=100
 . You'll see that 
 each commit has a ""sha"" identifier, committer details, a message describing what changed, 
 and a lot more. In our initial data model, we're going to track the ""date"", 
  
 ""message"", ""sha"", and ""url"" fields, but you're welcome to add more if you want to.
  
 To create a data model, choose File > New > File and select iOS > Core Data > Data Model. 
 Name it Project38, then make sure the ""Group"" option near the bottom of the screen has a 
 yellow folder to it rather than a blue project icon.
  
 This will create a new file called Project38.xcdatamodeld, and when you select that you'll see a 
 new editing display: the Data Model Editor. At the bottom you'll see a button with the title ""Add 
 Entity"": please click that now.
  
  
 The Add Entity button should be at the bottom of the data model editor window.
  
 www.hackingwithswift.com 
  
 946",NA
Adding Core Data to our project: ,NA,NA
NSPersistentStoreCoordinator ,"A Core Data model defines what your data should look like, but it doesn't actually store it 
 anywhere. To make our app work, we need to create a persistent store where Core Data can 
 read and write its data, then create what's called a ""managed object context"" where those 
 objects can be manipulated by us in memory.
  
 In this second step we're going to write code to load the model we just defined, load a peristent 
 store where saved objects can be stored, and also create a managed object context where our 
 objects will live while they are active. Any changes we make to objects won't be saved until we 
 explicitly request it, and it's significantly faster to manipulate objects inside your managed object 
 context as much as you need to before saving rather than saving after every change.
  
 When data is saved, it's nearly always written out to an SQLite database. There are other 
 options, but take my word for it: almost everyone uses SQLite. SQLite is a very small, very 
 fast, and very portable database engine, and what Core Data does is provide a wrapper 
 around it: when you read, write and query a managed object context, Core Data translates 
 that into Structured Query Language (SQL) for SQLite to parse.
  
 If you were wondering, SQL is pronounced Ess Cue Ell, but many people pronounce it 
 ""sequel."" The pronunciation of SQLite is more varied, but when I met its author I asked him 
 how 
 he
  pronounces it, so I feel fairly safe that the definitive answer is this: you pronounce 
 SQLite as Ess-Cue-Ell-ite, as if it were a mineral like Kryponite or Carbonite depending on 
 your preferred movie.
  
 To get started, open MasterViewController.swift and add an import for Core Data:
  
 import CoreData 
 To set up the basic Core Data system, we're going to create a new method called 
 startCoreData()
  that will do the following:
  
 1. Load our data model we just created from the application bundle and create a 
 NSManagedObjectModel
  object from it.
  
 www.hackingwithswift.com 
  
 949",NA
Creating an NSManagedObject subclass ,NA,NA
with Xcode ,"In our app, Core Data is responsible for reading data from a persistent store (the SQLite 
 database) and making it available for us to use as objects. After changing those objects, we 
 can save them back to the persistent store, which is when Core Data converts them back from 
 objects to database records.
  
 All this is done using a special data type called 
 NSManagedObject
 . This is a Core Data 
 subclass of 
 NSObject
  that uses a unique keyword, 
 @NSManaged
 , to provide lots of 
 functionality for you. For example, you already saw the 
 hasChanges
  property of a managed 
 object context – that automatically gets set to true when you make changes to your objects, 
 because Core Data tracks when you change properties that are marked 
 @NSManaged
 .
  
 Behind the scenes, 
 @NSManaged
  effectively means ""extra code will automatically be 
 provided when the program runs."" It's a bit like functionality injection: when you say ""this 
 property is 
 @NSManaged
 "" then Core Data will add getters and setters to it when the app 
 runs so that it handles things like change tracking.
  
 If this sounds complicated, relax: Xcode can do quite a bit of work for us. It's not perfect, as 
 you'll see shortly, but it's certainly a head start. So, it's time for step three: creating objects in 
 Core Data so that we can fetch and store data from GitHub.
  
 Select the data model (Project38.xcdatamodeld) and choose Editor > Create 
  
 NSManagedObject Subclass from the menu. Make sure your data model is selected then 
 click Next. Make sure the Commit entity is checked then click Next again.
  
 www.hackingwithswift.com 
  
 953",NA
Loading Core Data objects using ,NA,NA
NSFetchRequest and NSSortDescriptor ,"This 
 is where Core Data starts to become interesting and perhaps – gasp! – even fun. Yes, I 
 know it's taken quite a lot of work to get this far, but I 
 did
  warn you, remember?
  
 Step four is where we finally get to put to use all three previous steps by showing data to 
 users. After the huge amount of work you've put in, particularly in the previous step, I'm sure 
 you'll be grateful to see everything pay off at last!
  
 Xcode's Master-Detail Application template gave us this array to use in the table view:
  
 var objects = [AnyObject]() 
 In our project, we know we're using 
 Commit
  objects rather than 
 AnyObject
 , so please 
 change that line to this:
  
 var objects = [Commit]() 
 As soon as you do that, your code will break in two places because the template expects 
 NSDate
  objects to be in that array. Don't worry, this is easily fixed. Start by going to 
 prepareForSegue()
  and finding this line:
  
 let object = objects[indexPath.row] as! NSDate 
 To fix that line, just remove the 
 as! NSDate
  part, like this:
  
 let object = objects[indexPath.row] 
 www.hackingwithswift.com
  
 962",NA
How to make a Core Data attribute ,NA,NA
unique using constraints ,"After such a huge amount of work getting Core Data up and running, you'll probably run your 
 app a few times to enjoy it all working. But it's not perfect, I'm afraid: first, you'll see GitHub 
 commits get duplicated each time the app runs, and second you'll notice that tapping on a 
 commit shows the Detail screen with not much helpful information.
  
 We'll be fixing that second problem later, but for now let's focus on the first problem: duplicate 
 GitHub commits. In fact, you probably have triplicate or quadruplicate by now, because each 
 time you run the app the same commits are fetched and added to Core Data, so you end up 
 with the same data being repeated time and time again.
  
 No one wants repeated data, so we're going to fix this problem. And for once I'm pleased to 
 say that Core Data makes this very easy thanks to a simple technology called ""unique 
 constraints."" All we need to do is find some data that is guaranteed to uniquely identify a 
 commit, tell Core Data that is a unique identifier, and it will make sure objects with that same 
 value don't get repeated.
  
 Even better, Core Data can intelligently merge updates to objects in situations where this is 
 possible. It's not going to happen with us, but imagine a situation where a commit author could 
 retrospectively change their commit message from ""I fxed a bug with Swift"" to ""I fixed a bug 
 with Swift."" As long as the unique identifier didn't change, Core Data could recognize this was 
 an update on the original commit, and merge the change intelligently.
  
 Inserting data uniquely used to be harder before iOS 9, because you needed to run an 
 NSFetchRequest
  to see if an object matching your identifier existed, then create it or update it 
 as needed. As of iOS 9, this is done automatically: you just need to tell Core Data what your 
 unique attribute is.
  
 In this app, we have the perfect unique attribute just waiting to be used: every commit has a 
 ""sha"" attribute that is a long string of letters and numbers that identify that commit uniquely. 
  
 SHA stands for ""secure hash algorithm"", and it's used in many places to generate unique 
 identifiers from content.
  
 A ""hash"" is a little bit like like one-way, truncated encryption: one piece of input like ""Hello 
 world"" will always generate the same hash, but if you change it to be ""Hello World"" – just 
 capitalising a single letter – you get a completely different hash. It's ""truncated"" because no 
  
 www.hackingwithswift.com 
  
 966",NA
Examples of using NSPredicate to filter ,NA,NA
NSFetchRequest ,"Predicates are one of the most powerful features of Core Data, but they are actually useful in 
 lots of other places too so if you master them here you'll learn a whole new skill that can be 
 used elsewhere. For example, if you already completed project 33 you'll have seen how 
 predicates let us find iCloud objects by reference.
  
 Put simply, a predicate is a filter: you specify the criteria you want to match, and Core Data will 
 ensure that only matching objects get returned. The best way to learn about predicates is by 
 example, so I've created three examples below that demonstrate various different filters. We'll 
 be adding a fourth one in the next chapter once you've learned a bit more.
  
 First, add this new property to the 
 MasterViewController
  class:
  
 var commitPredicate: NSPredicate? 
 I've made that an optional 
 NSPredicate
  because that's exactly what our fetch request takes: 
 either a valid predicate that specifies a filter, or 
 nil
  to mean ""no filter.""
  
 Find your 
 loadSavedData()
  method and add this line just below where the 
 sortDescriptors 
 property is set:
  
 fetch.predicate = commitPredicate 
 With that property in place, all we need to do is set it to whatever predicate we want before 
 calling 
 loadSavedData()
  again to refresh the list of objects. The easiest way to do this is by 
 adding a new method called 
 changeFilter()
 , which we'll use to show an action sheet for the 
 user to choose from. First we need to add a button to the navigation bar that will call this 
 method, so put this code into 
 viewDidLoad()
 :
  
 navigationItem.rightBarButtonItem = UIBarButtonItem(title: ""Filter"", style: .Plain, target: self, 
 action: ""changeFilter"") 
 www.hackingwithswift.com
  
 971",NA
Adding Core Data entity relationships: ,NA,NA
lightweight vs heavyweight migration ,"It's time to take your Core Data skills up a notch: we're going to add a second entity called 
 Author, and link that entity to our existing Commit entity. This will allow us to attach an author to 
 every commit, but also to find all commits that belong to a specific author.
  
 Open the data model (Project38.xcdatamodeld) for editing, then click the Add Entity button. 
 Name the entity Author, then give it two attributes: ""name"" and ""email"". Please make both 
 strings, and make sure both are not marked as optional. This time we're also going to make 
 one further change: select the ""name"" attribute and check the box marked ""Indexed"".
  
  
 You can index as many attributes as you want, but don't go overboard: it takes time to create 
 and update indexes, so you should index only the attributes you really need.
  
 An indexed attribute is one that is optimized for fast searching. There is a cost to creating 
 and maintaining each index, which means you need to choose carefully which attributes 
 should be index. But when you find a particular fetch request is happening slowly, chances 
 are it's because you need to index an attribute.
  
 www.hackingwithswift.com 
  
 976",NA
How to delete a Core Data object ,"The Xcode template we've been using comes with support for deleting objects, but it only 
 removes them from the 
 objects
  array directly – nothing is actually changed in our Core Data 
 set up. So if you ""delete"" a commit, it will be there when you relaunch the app rather than 
 gone for good.
  
 Fortunately, this is really easy to change: our managed object context has a 
 deleteObject() 
 method that will delete any object regardless of its type or location in the object graph. Once 
 an object has been deleted from the context, we can then call 
 saveContext()
  to write that 
 change back to the persistent store so that the change is permanent.
  
 All this is easy to do by adding three new lines of code to the 
 commitEditingStyle
  method. 
 Here's the new method:
  
 override func tableView(tableView: UITableView, commitEditingStyle editingStyle: 
 UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { 
  if editingStyle == .Delete { 
   let commit = objects[indexPath.row] 
   managedObjectContext.deleteObject(commit) 
   objects.removeAtIndex(indexPath.row) 
   tableView.deleteRowsAtIndexPaths([indexPath],  
 withRowAnimation: .Fade) 
   saveContext() 
  } else if editingStyle == .Insert { 
   // Create a new instance of the appropriate class, insert it into the array, and add a new row to 
 the table view. 
  }  
 } 
 So, it 1) pulls out the 
 Commit
  object that the user selected to delete, 2) removes it from the 
 managed object context, 3) removes it from the 
 objects
  array, 4) deletes it from the table 
  
 www.hackingwithswift.com 
  
 983",NA
Optimizing Core Data Performance using ,NA,NA
NSFetchedResultsController ,"You've already seen how Core Data takes a huge amount of work away from you, which is 
 great because it means you can focus on writing the interesting parts of your app rather than 
 data management. But, while our current project certainly works, it's not going to scale well. 
  
 To find out why open the Commit.swift file and modify it to this:
  
 class Commit: NSManagedObject { 
  override init(entity: NSEntityDescription,  
 insertIntoManagedObjectContext context: NSManagedObjectContext?) { 
  super.init(entity: entity, insertIntoManagedObjectContext: context) 
  print(""Init called!"") 
  } 
 } 
 When you run the program now you'll see ""Init called!"" in the Xcode log at least a hundred 
 times - once for every 
 Commit
  object that gets pulled out in our 
 loadSavedData()
  method. 
 So what if there are 1000 objects? Or 10,000? Clearly it's inefficient to create a new object 
 for everything in our object graph just to load the app, particularly when our table view can 
 only show a handful at a time.
  
 Core Data has a brilliant solution to this problem, and it's called 
  
 NSFetchedResultsController
 . It takes over our existing 
 NSFetchRequest
  to load data, 
 replaces our 
 objects
  array with its own storage, and even works to ensure the user interface 
 stays in sync with changes to the data by controlling the way objects are inserted and deleted.
  
 No tutorial on Core Data would be complete without teaching 
 NSFetchedResultsController
 , 
 so that's the last thing we'll be doing in this project. I left it until the end because, although it's 
 very clever and certainly very efficient, 
 NSFetchedResultsController
  is entirely optional: if 
 you're happy with the project as it is, you're welcome to skip over this last chapter.
  
 First, add a new property for the fetched results controller:
  
 www.hackingwithswift.com 
  
 987",NA
Wrap up ,"Core Data is 
 complicated
 . It really is. So if you've made it this far, you deserve a pat on the 
 back because you've learned a huge amount in this one project – good job! You've learned 
 about model design, relationships, predicates, sort descriptors, persistent stores, managed 
 object contexts, fetch requests, fetched results controllers, indexes, hashes and more, and I 
 hope you're pleased with the final project.
  
 But I'm afraid I have some bad news: even with everything you've learned, there's still a lot 
 more to go if you really want to master Core Data. Migrating data models, multiple managed 
 object contexts, delete rules, and thread safety should be top of that list, but at the very least I 
 hope I've managed to give you a firm foundation on the technology – and perhaps even get you 
 a bit excited about what it can do for you!
  
 At this point, you know enough about Core Data that you should be able to start a new 
 project with the Master-Detail Application template, but this time 
 enabling
  the Core Data 
 option for the template. You'll see all the code Apple generates for you, and hopefully you'll 
 see how it's similar to our own code in this project.
  
 Before you're done, I have two small tips for you. First, go to the Product menu and choose 
 Scheme > Edit Scheme. In the window that appears, choose your Run target and select the 
 Arguments tab. Now click + and enter the text 
 -com.apple.CoreData.SQLDebug 1
 . Once 
 that's done, running your app will print debug SQL into the Xcode log pane, allowing you to 
 see what Core Data is up to behind the scenes.
  
 www.hackingwithswift.com 
  
 995",NA
Project 39 ,NA,NA
Unit testing with ,NA,NA
XCTest,NA,NA
Learn how to write unit tests and user interface tests ,NA,NA
using Xcode's built-in testing framework.,NA,NA
Setting up ,"Although this is a technique project, it's a technique project with a difference because you're 
 going to make an app from scratch. It's not a complicated app, don't worry: it will load a large 
 file containing the text of all of Shakespeare's comedies, then have a table view showing how 
 often each word is used.
  
 Easy, right? Right. But here's why it's a technique project: while building this app you'll be 
 learning all about XCTest, which is Xcode's testing framework. Although this isn't a tutorial 
 on test-driven development, I will at least walk you through the concepts and apply them 
 with you. Even better, I'll also be introducing you to some functional programming using 
 filter()
 , so there's a lot to learn.
  
 Please note:
  as I write this, Xcode 7.3 and Swift 2.2 are still in late beta. To avoid problems, 
 there is one piece of code where I've given specific instructions for 2.2 and 2.1 so that 
 everyone can follow along.
  
 All set? Let's do this! Launch Xcode, then create a new Single View Application named 
 Project39. For device please choose Universal, then check both Include Unit Tests and 
 Include UI Tests. Click Create, then save the project somewhere safe.
  
 www.hackingwithswift.com 
  
 999",NA
Creating our first unit test using XCTest ,"At the 
 core of test-driven development lies the concept that you should begin by writing a test that 
 succeeds only when your code works the way you want it to. It might seem strange at first, but 
 it makes a lot of sense: your new test will fail at first because your program doesn't do the right 
 thing, then it's your job to write just enough code (but no more!) to make that test pass.
  
 We're going to follow this approach here, but we need to do a little bit of setup work first so 
 that we're able to write a failing test. So: go to the File menu and choose New > File. From the 
 list of options, choose iOS > Source > Swift File. Click Next, then name it PlayData. We'll be 
 using this to store all the words in the plays.
  
 The goal right now is to write just enough code for us to return to testing, so for now just put 
 this text into the file:
  
 class PlayData { 
  var allWords = [String]() 
 } 
 That's it: there's a class called 
 PlayData
 , and we've given it a property called 
 allWords
  that 
 will hold an array of strings. We're not going to fill that array with data yet, though: first we 
 need to write a test to check that 
 allWords
  has been populated with the words from the 
 plays.txt file. For now, just to make sure you understand how an XCTest works, we're going 
 to write a test that checks 
 allWords
  has exactly 0 strings inside it.
  
 Look in the ""Project39Tests"" for Project39Tests.swift and open it for editing. You'll see it 
 contains four methods: 
 setUp()
 , 
 tearDown()
 , as well as two example test methods, all 
 wrapped up in a class that inherits from 
 XCTestCase
 . Please delete the two test methods, 
 so your file is left like this:
  
 import XCTest 
 @testable import Project39 
 class Project39Tests: XCTestCase { 
 www.hackingwithswift.com 
  
 1002",NA
Loading our data and splitting up words: ,NA,NA
filter() ,"The next step in our project is to get our app working a little bit, which means writing a method 
 that loads the input text and splits it up into words.
  
 Sticking with TDD for now, this means we first need to write a test that fails before updating 
 our code to fix it.
  
 Right now we're checking 
 allWords
  contains 0 items, which needs to change: there are in 
 fact 384,001 words in the input text (based on the character splitting criteria we'll get to 
 shortly), so please update your 
 testAllWordsLoaded()
  method to this:
  
 XCTAssertEqual(playData.allWords.count, 384001, ""allWords was not 384001"") 
 This number, 384,001, is of course entirely arbitrary because it depends on the input data. 
 But that's not the point: we need to tell XCTest what ""correct"" looks like, because it has no 
 way of knowing what constitutes a pass or a fail unless we give it specific criteria.
  
 If you click the green checkmark next to the test now, it will be run again and will fail this time 
 because we haven't written the loading code – XCTest expects 
 allWords
  to contain 384,001 
 strings, but it contains 0. This is good, honest!
  
  
 Our tests are now failing, which is a core part of test-driven development: write tests that fail, 
 then write the code that makes those tests pass.
  
 Let's put testing to one side for now and fill in some of our program – we'll be back with the 
 testing soon enough, don't worry.
  
 Add this to PlayData.swift:
  
 www.hackingwithswift.com 
  
 1006",NA
Counting unique strings in an array ,"Running the 
 allWords
  array through 
 filter()
  solved the problem of empty lines in the array, 
 but there are still two more problems we need to address: duplicate words, and that pesky 
 ""Detail"" text in the detail text label.
  
 Well, we're going to fix two of them right now, at the same time. And, for the first time in this 
 series, I'm going to have you write some bad code. Trust me: this will all become clear shortly, 
 and it will be corrected.
  
 Our app is going to show the number of times each word is used inside Shakespeare's 
 comedies. To do that, we need to calculate how often each word appears, so we're going to 
 add a new property to 
 PlayData
  to store that calculation. Please add this now:
  
 var wordCounts = [String: Int]() 
 That dictionary will hold a string as its key (e.g. ""yonder"") and a number as its value (e.g. 14), 
 so that we can check the frequency of any word whenever we need to.
  
 Our 
 init()
  method already splits all the text up into words, but we need to add some new code 
 to add the counting. This is fairly straightforward to write: loop through every word in the 
 allWords
  array, add one to its 
 wordCounts
  count if we have it, or set its count to 1 if we don't 
 have it.
  
 Modify the 
 init()
  method in PlayData.swift so that this code appears after the call to 
 filter()
 :
  
 for word in allWords { 
  if wordCounts[word] == nil { 
  wordCounts[word] = 1 
  } else { 
  wordCounts[word]! += 1 
  } 
 } 
 www.hackingwithswift.com
  
 1014",NA
measureBlock(): How to optimize our slow ,NA,NA
code and adjust the baseline ,"You might have noticed there's a pre-written method called 
 setup()
  in our unit tests, which 
 contains this comment: ""Put setup code here. This method is called before the invocation of 
 each test method in the class."" Why, then, do we have 
 let playData = PlayData()
  in both our 
 tests – couldn't that go into 
 setup()
  to avoid repetition?
  
 Well, no, and you're about to see why. You will probably have noticed that our new word 
 frequency code has slowed down our app quite a bit. Even when running in the iOS Simulator, 
 using the full power of your Mac, this code now takes about two seconds to run – try to 
 imagine how much slower it would be on a real device!
  
 Of course, this is all a clever ruse to teach you more things, and here I want to teach you how to 
 use XCTest to check performance. Our new word counting code is slow, but the only reliable 
 way to ensure it gets faster when we make changes is to create a new test that times how long 
 it takes for our 
 PlayData
  object to be created. This is why we can't create it inside the 
 setup()
  
 method: we need to create it as part of a measurement in this next test, as you'll see.
  
 XCTest makes performance testing extraordinarily easy: you give it a closure to run, and it 
 will execute that code 10 times in a row. You'll then get a report back of how long the call 
 took on average, what the standard deviation was (how much variance there was between 
 runs), and even how fast each of those 10 runs performed if you want the details.
  
 Let's write a performance test now – please add this to Project39Tests.swift:
  
 func testWordsLoadQuickly() { 
  measureBlock { 
  _ = PlayData() 
  } 
 } 
 Were you expecting something more complicated? I told you it was easy and I meant it! That tiny 
 amount of code is all it takes: assigning a new 
 PlayData
  object to 
 _
  will load the file, split 
  
 www.hackingwithswift.com 
  
 1018",NA
Filtering using functions as parameters ,"We're 
 going to add the ability for users to filter the word list in one of two ways: by showing only 
 words that occur at or greater than a certain frequency, or by showing words that contain a 
 specific string. This will work by giving 
 PlayData
  a new array, 
 filteredWords
 , that will store 
 all words that matches the user's filter. This will also be used for the table view's data source.
  
 As before, we're going to be writing the tests first so we can be sure the code we right is 
 correct, but first we must create some skeleton code in 
 PlayData
  that the test will work. Start by 
 adding this 
 filteredWords
  property to 
 PlayData
 :
  
 var filteredWords = [String]() 
 Now add this empty method, just below the existing 
 init()
  method:
  
 func applyUserFilter(input: String) { 
 } 
 That's just enough functionality for us to start writing tests: an 
 applyUserFilter()
  method that 
 accepts a single string parameter, such as ""home"" or ""100"". What it needs to do is decide 
 whether that parameter contains a number (""100"") or not (""home""), then either show words 
 with that frequency or words that match that substring.
  
 I've done some number crunching for you, and have found that 495 words appear at least 
 100 times, whereas only one word appears more than 10,000 times. I've also found that 
 ""test"" appears 56 times, ""Swift"" appears 7 times, and ""Objective-C"" doesn't appear once – 
 conclusive proof, I think, that Shakespeare prefers Swift.
  
 Using these numbers, as well as some more, we can write the following test in 
 Project39Tests.swift:
  
 func testUserFilterWorks() { 
  let playData = PlayData() 
 www.hackingwithswift.com 
  
 1025",NA
Updating the user interface with filtering ,"We've 
 written the tests to prove that filtering works, but those filters don't do anything in the user 
 interface just yet. We're going to make a few small changes so that our view controller uses 
 filteredWords
  rather than 
 allWords
 , then we'll add an alert controller so that users can enter 
 a filter by hand.
  
 First: using 
 filteredWords
 . This is done in three changes, two of which are trivial: open 
 ViewController.swift, and replace the two instances of 
 allWords
  with 
 filteredWords
 . If you 
 run the app now you'll see no text in the table view, which is where we need to make the 
 third change.
  
 By default, 
 filteredWords
  contains nothing, which is why the table is empty. It's only when a 
 filter is applied that words are added, so our fix is just a matter of adding one line of code 
 immediately before the end of 
 init()
  in 
 PlayData
 :
  
 applyUserFilter(""swift"") 
 That will run an initial filter looking for the word ""swift"". If you want to show all words when 
 the app first runs, use this code instead:
  
 filteredWords = allWords 
 For now, though, please stick with 
 applyUserFilter(""swift"")
  – the reason for this will become 
 clear soon.
  
 Now onto the interesting stuff: letting the user enter a filter value. This needs to show a 
 UIAlertController
  with a text field and two buttons, Filter and Cancel. When the user taps 
 Filter, whatever they entered in the text field needs to be sent to the 
 applyUserFilter() 
 method of 
 PlayData
 , and the table reloaded to reflect their changes.
  
 We've covered how to do all this before, but I'll give you a few reminders once you've read 
 the code. Please add this new method to ViewController.swift:
  
 func searchTapped() { 
 www.hackingwithswift.com 
  
 1032",NA
User interface testing with XCTest ,"There's one more trick XCTest has up its sleeve, and if you're not already impressed then I 
 think this will finally win you over.
  
 We've written tests for our data model: are the words loaded correctly? Are the word counts 
 correct? Did the words get counted in an appropriate time? Does our user filtering work? 
 These are all useful tests, and help make sure our code works now and in the future when 
 further changes are made.
  
 But none of those tests tell us whether our user interface is working as expected, so it's 
 possible that the app could still be broken even though our model is in perfect condition.
  
 XCTest has a solution, and it's a beautiful one: integrated user interface tests that manipulate 
 your app as if there were a real user in control. XCTest is smart enough to understand how 
 the system works, so it will automatically wait for things like animations to complete before 
 trying to check your assertions.
  
 When we created our project we added both unit tests (Project39Tests.swift) and also UI 
 tests (Project39UITests.swift), and we'll be working with the latter now so please open 
 Project39UITests.swift for editing.
  
 You'll see Xcode has written 
 setup()
  and 
 tearDown()
  methods again, although this time the 
 setup()
  method actually has some code in to get things started. You'll also see a 
  
 testExample()
  method, but please just delete that – we'll be writing our own.
  
 We're going to start with a very simple test: when the view controller loads, does it show the 
 correct number of words? If you remember, our app applies an immediate filter for the word 
 ""swift"", which appears 7 times in Shakespeare's comedies. So, to test that our initial app state 
 is correct, we need to write this test:
  
 func testInitialStateIsCorrect() { 
  let table = XCUIApplication().tables 
  XCTAssertEqual(table.cells.count, 7, ""There should be 7 rows initially"") 
 } 
 www.hackingwithswift.com
  
 1036",NA
Wrap up ,"This has been the longest technique project by a long way, but I think you've learned a lot 
 about the importance of good unit testing. We also managed to cover some functional 
 programming techniques, discussed private setters, used functions as parameters, and even 
 tried 
 NSCountedSet
 , so I hope you're happy with the result!
  
 Now that the full suite of tests are complete, you have three options ahead of you. First, you 
 can run all the tests in a file by clicking the diamond (or green checkmark) next to the name of 
 the test class. So, in Project39UITests.swift look in the gutter next to 
 class 
  
 Project39UITests: XCTestCase
  and click that. Second, you can run all the tests in your 
 entire project by pressing Cmd+U. Give it a few moments to run, then you'll get a complete 
 report.
  
 Third, and most impressively, you can run all your tests on Xcode Server, which is the 
 beginning of continuous integration: every time you commit a code change to source control, 
 Xcode Server can pull down those changes, build the app, and run the full suite of tests. If 
 you're working in a team, Xcode can produce a visual display of tests that are passing and 
 failing, which is either motivational or depressing depending on your workplace!
  
 If you'd like to take this app further, you should concentrate on testing. Can you write a test 
 that verifies there are 55 table rows when the user filters by words that appear 1000 or more 
 times? Can you write a test that ensures something sensible happens if the cancel button is 
 pressed? Can you write a performance test to ensure 
 applyUserFilter()
  doesn't get any 
 slower?
  
 There's also a bug in the code that you ought to be able to fix easily: if the user enters nothing 
 into the filter text box, 
 applyUserFilter()
  gets called with an empty string as its parameter and 
 no results will be shown. It's down to you to think up a better solution: is it better to pretend 
 Cancel was tapped instead? Or perhaps consider an empty string to mean ""show all words""? 
 It's your project now, so please choose what you think best.
  
 Keep in mind that testing is only part of a sensible code review process. Yes, Xcode Server 
 can check out your code and automatically validate that tests pass, but it is not a substitute for 
 actual human interaction – looking through each other's code, and providing constructive 
 criticism. Taking the time to read someone else's code, then encouraging and supporting them 
 as they improve it, is a key developer skill – remember, code review is where mistakes get 
 rubbed 
 out
 , not rubbed 
 in
 .
  
 www.hackingwithswift.com 
  
 1042",NA
Appendix ,NA,NA
The Swift Knowledge ,NA,NA
Base,NA,NA
"Quick tips, tricks, and practical examples to help you do ",NA,NA
more with Cocoa Touch.,NA,NA
Arrays,NA,NA
How to count objects in a set using NSCountedSet ,"Availability: iOS 2.0 or later.
  
 One of my favorite little gems in Cocoa Touch is called 
 NSCountedSet
 , and it's the most 
 efficient way to count objects in a set. Here's the code:
  
 let set = NSCountedSet()  
 set.addObject(""Bob"")  
 set.addObject(""Charlotte"")  
 set.addObject(""John"")  
 set.addObject(""Bob"")  
 set.addObject(""James"")  
 set.addObject(""Sophie"")  
 set.addObject(""Bob"") 
 print(set.countForObject(""Bob"")) 
 Now to how it works: a 
 set
  is like an array, except each item can appear only once. If we used 
 an array in the above code, it would contain seven objects: three Bobs, one Charlotte, one 
 John, one James and one Sophie. If we used a Swift set in the above code, it would contain 
 four objects: one Bob, one Charlotte, one John, one James and one Sophie – the set ensures 
 each item appears only once.
  
 Now for the twist: 
 NSCountedSet
  works similar to a set insofar as each object can appear 
 only once, but it keeps track of how many times each item was added and removed. So, our 
 counted set will have four objects in (like it would if it were a regular set), but 
 NSCountedSet 
 has a 
 countForObject()
  method that will report back that Bob was added three times.",NA
How to enumerate items in an array,"www.hackingwithswift.com 
  
 1044",NA
How to find an item in an array using indexOf() ,"Availability: iOS 7.0 or later.
  
 The 
 indexOf()
  method tells you the index of an element in an array if it exists, or returns nil 
 otherwise. Because it's an optional value, you need to unwrap it carefully or at least check 
 the result, like this:
  
 let array = [""Apples"", ""Peaches"", ""Plums""] 
 if let index = array.indexOf(""Peaches"") { 
  print(""Found peaches at index \(index)"") 
 } 
 www.hackingwithswift.com
  
 1045",NA
How to join an array of strings into a single string ,"Availability: iOS 7.0 or later.
  
 If you have an array of strings and want to merge all the elements together into a single 
 string, it's just one line of code in Swift – albeit one you can't guess very easily!
  
 For example, this joins array elements with a comma:
  
 let array = [""Andrew"", ""Ben"", ""John"", ""Paul"", ""Peter"", ""Laura""] let joined = 
 array.joinWithSeparator("", "") 
 The result is that 
 joined
  is set to ""Andrew, Ben, John, Paul, Peter, Laura"".",NA
How to loop through an array in reverse ,"Availability: iOS 7.0 or later.
  
 If you want to read through an array in reverse, you should use the 
 reverse()
  method. You 
 can use this as part of the regular fast enumeration technique if you want, which would give 
 you code like this:
  
 let array = [""Apples"", ""Peaches"", ""Plums""] 
 for item in array.reverse() { 
  print(""Found \(item)"")  
 } 
 You can also reverse an enumerated array just by appending the method call, like this:
  
 let array = [""Apples"", ""Peaches"", ""Plums""] 
 www.hackingwithswift.com 
  
 1046",NA
How to loop through items in an array ,"Availability: iOS 7.0 or later.
  
 Swift offers a selection of ways to loop through an array, but the easiest and fastest is known 
 as fast enumeration and looks like this:
  
 let array = [""Apples"", ""Peaches"", ""Plums""] 
 for item in array { 
  print(""Found \(item)"") 
 } 
 That will print ""Found Apples"", ""Found Peaches"" then ""Found Plums"" to the Xcode console. 
 Each time the loop goes around, one item is read from the array and placed into the constant 
 item
  – and note that 
 is
  a constant, so don't try to change it.",NA
How to shuffle an array in iOS 8 and below ,"Availability: iOS 2.0 or later.
  
 Nate Cook wrote a simple 
 shuffle()
  extension to arrays that implements the Fisher-Yates 
 shuffle algorithm in Swift. I use it a lot, or at least did until GameplayKit came along in iOS 
  
 www.hackingwithswift.com 
  
 1047",NA
How to shuffle an array in iOS 9 using GameplayKit ,"Availability: iOS 9.0 or later.
  
 iOS 9.0 has a built-in way to shuffle arrays thanks to GameplayKit, and it's a simple one-liner. 
 Here's an example of creating an array of lottery balls and picking six random ones:
  
 let lotteryBalls = [Int](1...49)  
 let shuffledBalls =  
 GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(lotteryB alls)  
 print(shuffledBalls[0])  
 print(shuffledBalls[1])  
 print(shuffledBalls[2])  
 print(shuffledBalls[3])  
 print(shuffledBalls[4])  
 print(shuffledBalls[5]) 
 www.hackingwithswift.com 
  
 1048",NA
How to sort an array using sort() ,"Availability: iOS 7.0 or later.
  
 All arrays have a built-in 
 sort()
  method that can be used to sort the array. If the array is 
 simple you can just call it directly, like this:
  
 var names = [""Jemima"", ""Peter"", ""David"", ""Kelly"", ""Isabella""] names.sort() 
 If you have a custom struct or class and want to sort them arbitrarily, you should call 
 sort() 
 using a trailing closure that sorts on a field you specify. Here's an example using an array of 
 custom structs that sorts on a particular property:
  
 struct MyCustomStruct { 
  var someSortableField: String  
 } 
 var customArray = [ 
  MyCustomStruct(someSortableField: ""Jemima""), 
 MyCustomStruct(someSortableField: ""Peter""), 
 MyCustomStruct(someSortableField: ""David""), 
 MyCustomStruct(someSortableField: ""Kelly""), 
 MyCustomStruct(someSortableField: ""Isabella"") ] 
 www.hackingwithswift.com 
  
 1049",NA
How to tell if an array contains an object ,"Availability: iOS 7.0 or later.
  
 It's easy to find out whether an array contains a specific value, because Swift has a 
 contains()
  method that returns true or false depending on whether that item is found. For 
 example:
  
 let array = [""Apples"", ""Peaches"", ""Plums""] 
 if array.contains(""Apples"") { 
  print(""We've got apples!"")  
 } else { 
  print(""No apples here – sorry!"")  
 } 
 www.hackingwithswift.com
  
 1050",NA
CALayer,NA,NA
How to add a border outline color to a UIView ,"Availability: iOS 3.2 or later.
  
 Any 
 UIView
  subclass has a built-in way to draw a border around it using its underlying 
 CALayer
 . For example, to draw a 10-point black border around a view, you'd use this:
  
 yourView.layer.borderWidth = 10 
 yourView.layer.borderColor = UIColor.blackColor().CGColor 
 Note that you need to use the 
 CGColor
  property of your 
 UIColor
  in order for this to work. 
 Adding a border to a view even works if you also round the corners of your view – it's very 
 flexible!",NA
How to create keyframe animations using ,NA,NA
CAKeyframeAnimation ,"Availability: iOS 2.0 or later.
  
 Keyframe animations offer extraordinary power for developers because they let you set 
 multiple values and have iOS animate between them over times you specify. There are three 
 components: a key path (the property to animate), an array of values (the value you want to 
 use for that property), and an array of key times (when that value should be used for the 
 property).
  
 www.hackingwithswift.com 
  
 1051",NA
How to draw color gradients using CAGradientLayer ,"Availability: iOS 3.0 or later.
  
 I love 
 CAGradientLayer
  because it takes just four lines of code to use, and yet looks great 
 because it quickly and accurately draws smooth color gradients use Core Graphics. Here's a 
 basic example:
  
 let layer = CAGradientLayer() 
 layer.frame = CGRect(x: 64, y: 64, width: 160, height: 160) 
 layer.colors = [UIColor.redColor().CGColor, 
 UIColor.blackColor().CGColor] 
 view.layer.addSublayer(layer) 
 Note that you need to fil in an array of 
 colors
  that will be used to draw the gradient. You can 
 provide more than one if you want to, at which point you will also need to fill in the 
 locations 
 array to tell 
 CAGradientLayer
  where each color starts and stops. Note that you need to 
 specify your colors as 
 CGColor
  and not 
 UIColor
 .
  
 If you want to make your gradient work in a different direction, you should set the 
 startPoint 
 and 
 endPoint
  properties. These are both 
 CGPoints
  where the X and Y values are between 0 
 and 1, where 0 is one edge and 1 is the opposite edge. The default start point is X 0.5, Y 0.0 
 and the default end point is X 0.5, Y 1.0, which means both points are in the center of the 
 layer, but it starts at the top and ends at the bottom.
  
 You might be interested to know that 
 CAGradientLayer
  happily works with translucent 
 colors, meaning that you can make a gradient that fades out.",NA
How to draw shapes using CAShapeLayer ,"Availability: iOS 3.0 or later.
  
 www.hackingwithswift.com 
  
 1053",NA
How to emit particles using CAEmitterLayer ,"Availability: iOS 5.0 or later.
  
 Believe it or not, iOS has a built-in particle system that works great in all UIKit apps and is 
 immensely customisable. To get started you need to create a 
 CAEmitterLayer
  object and tell it 
 how to create particles: where it should create them, how big the emitter should be, and what 
 types of particles should exist.
  
 The ""type of particles"" part is handled by 
 CAEmitterCell
 , which covers details like how fast 
 to create, how long they should live, whether they should spin and/or fade out, what texture 
 to use, and more. You can add as many 
 CAEmitterCells
  to a 
 CAEmitterLayer
  as you need.
  
 Here's some example code to get you started. This creates particles of three different colors, 
 all falling and spinning down from the top of the screen. The image ""particle_confetti"" is just a 
 small white triangle that I drew by hand – you should replace that with something more 
 interesting.
  
 func createParticles() { 
  let particleEmitter = CAEmitterLayer() 
 www.hackingwithswift.com 
  
 1054",NA
How to round the corners of a UIView ,"Availability: iOS 3.2 or later.
  
 All 
 UIView
  subclasses have the ability to round their corners thanks to their underlying 
 CALayer
  – that's the bit that handles the actual drawing of your views. To round the corners 
 of a view, use this code:
  
 yourView.layer.cornerRadius = 10 
 The number you specify is how far the rounding should go, measured in points. This means that 
 if you have a view that's 128x128 points wide and give it a 
 cornerRadius
  property of 64, it will 
 look like a circle.
  
 Note that some types of view don't have 
 clipsToBounds
  enabled by default, which means 
 their corners will not round until you enable this property.",NA
Core Graphics,NA,NA
How to calculate the Manhattan distance between two ,NA,NA
CGPoints ,"Availability: iOS 2.0 or later.
  
 Manhattan distance is the distance between two integer points when you are unable to move 
 diagonally. It's named ""Manhattan distance"" because of the grid-like layout of New York: 
  
 www.hackingwithswift.com 
  
 1056",NA
How to calculate the distance between two CGPoints ,"Availability: iOS 2.0 or later.
  
 You can calculate the distance between two 
 CGPoints
  by using Pythagoras's theorem, but 
 be warned: calculating square roots is not fast, so if possible you want to avoid it. More on 
 that in a moment, but first here's the code you need:
  
 func CGPointDistanceSquared(from from: CGPoint, to: CGPoint) -> CGFloat { 
  return (from.x - to.x) * (from.x - to.x) + (from.y - to.y) * (from.y - to.y);  
 } 
 func CGPointDistance(from from: CGPoint, to: CGPoint) -> CGFloat { return 
 sqrt(CGPointDistanceSquared(from: from, to: to));  
 } 
 Note that there are two functions: one for returning the distance between two points, and one 
 for returning the distance squared between two points. The latter one doesn't use a square 
 root, which makes it substantially faster. This means if you want to check ""did the user tap 
 within a 10-point radius of this position?"" it's faster to square that 10 (to make 100) 
  
 www.hackingwithswift.com 
  
 1057",NA
How to compare two CGRects with CGRectEqualToRect() ,"Availability: iOS 2.0 or later.
  
 You could compare two 
 CGRect
  values by evaluating their X, Y, width and height values, but 
 there's a much faster way: 
 CGRectEqualToRect()
 . This takes two rects as its only two 
 parameters and returns true if they are the same, or false otherwise.
  
 Here's an example:
  
 let rect1 = CGRect(x: 64, y: 64, width: 128, height: 128) let rect2 = CGRect(x: 256, y: 
 256, width: 128, height: 128) 
 if CGRectEqualToRect(rect1, rect2) { 
  // rects equal! 
 } else { 
  // rects not equal  
 }",NA
How to draw a circle using Core Graphics: ,NA,NA
CGContextAddEllipseInRect ,"Availability: iOS 4.0 or later.
  
 Core Graphics is able to draw circles and ellipses with just a few lines of code, although there 
 is some set up to do first. The example code below creates a 512x512 circle with a red fill and 
 a black border:
  
 UIGraphicsBeginImageContextWithOptions(CGSize(width: 512, height: 512), false, 0) 
 www.hackingwithswift.com 
  
 1058",NA
How to draw a square using Core Graphics: ,NA,NA
CGContextAddRect() ,"Availability: iOS 4.0 or later.
  
 You can draw a square (or indeed any size of rectangle) using the 
 CGContextAddRect() 
 Core 
 Graphics function. There's a little bit of set up work required, such as creating a context big 
 enough to hold the square and setting up colors, but the code below does everything you need:
  
 UIGraphicsBeginImageContextWithOptions(CGSize(width: 512, height: 512), false, 0) 
 www.hackingwithswift.com 
  
 1059",NA
How to draw a text string using Core Graphics ,"Availability: iOS 4.0 or later.
  
 To draw text in Core Graphics is trivial because every Swift string has a built-in 
  
 drawWithRect()
  method that takes an array of attributes and a position and size. There is, 
 like always, some Core Graphics set up work to do, but this next code snippet is a complete 
 example you can re-use easily:
  
 UIGraphicsBeginImageContextWithOptions(CGSize(width: 512, height: 512), false, 0) 
 www.hackingwithswift.com 
  
 1060",NA
How to draw lines in Core Graphics: CGContextMoveToPoint() ,NA,NA
and CGContextAddLineToPoint() ,"Availability: iOS 4.0 or later.
  
 You can draw lines in Core Graphics using 
 CGContextMoveToPoint()
  and 
  
 CGContextAddLineToPoint()
 . The first function moves the Core Graphics path to a 
 CGPoint 
 of your choosing, and the second function moves the path to a new point while also adding a 
 line. Once you add in the required code to set up a context and choose a color, you can draw a 
 triangle with this code:
  
 UIGraphicsBeginImageContextWithOptions(CGSize(width: 500, height: 500), false, 0)  
 let context = UIGraphicsGetCurrentContext() 
 CGContextMoveToPoint(context, 50, 450) 
 CGContextAddLineToPoint(context, 250, 50) 
 www.hackingwithswift.com 
  
 1061",NA
How to find the rotation from a CGAffineTransform ,"Availability: iOS 2.0 or later.
  
 A 
 CGAffineTransform
  value combines scale, translation and rotation all at once, but if you 
 just want to know its rotation value is then use this code:
  
 func rotationFromTransform(transform: CGAffineTransform) -> Double { return 
 atan2(Double(transform.b), Double(transform.a));  
 }",NA
How to find the scale from a CGAffineTransform ,"Availability: iOS 2.0 or later.
  
 If you have a 
 CGAffineTransform
  and want to know what its scale component is – 
 regardless of whether it has been rotated or translated – use this code:
  
 www.hackingwithswift.com 
  
 1063",NA
How to find the translation from a CGAffineTransform ,"Availability: iOS 2.0 or later.
  
 You can pull out the translation from a 
 CGAffineTransform
  by using the function below. 
 Feed it a transform and it will return you a 
 CGPoint
 :
  
 func translationFromTransform(transform: CGAffineTransform) -> CGPoint { 
  return CGPointMake(transform.tx, transform.ty);  
 }",NA
How to render a PDF to an image ,"Availability: iOS 3.0 or later.
  
 iOS has built-in APIs for drawing PDFs, which means it's relatively straight forward to render a 
 PDF to an image. I say ""relatively"" because there's still some boilerplate you need to worry 
 about: figuring out the document size, filling the background in a solid color to avoid 
 transparency, and flipping the rendering so that the PDF draws the right way up.
  
 To make things easy for you, here's a pre-made method you can use that takes a URL to a 
 PDF and returns either a rendered image or nil if it failed. To call it you should pull out the 
 URL to a resource in your bundle or another local PDF file.
  
 func drawPDFfromURL(url: NSURL) -> UIImage? { 
  guard let document = CGPDFDocumentCreateWithURL(url) else { return  
 www.hackingwithswift.com 
  
 1064",NA
How to use Core Graphics blend modes to draw a UIImage ,NA,NA
differently ,"Availability: iOS 2.0 or later.
  
 If you're rendering images using Core Graphics you should definitely try out some of the 
 alternate blend modes that are available. If you've ever used Photoshop's blend modes 
  
 www.hackingwithswift.com 
  
 1065",NA
Games,NA,NA
How to add physics to an SKSpriteNode ,"Availability: iOS 7.0 or later.
  
 SpriteKit comes with a modified version of the Box2D physics framework, and it's wrapped up 
 a lot of complicated physics mathematics into just one or two lines of code. For example, we 
 can create a square, red sprite and give it rectangular physics like this:
  
 let box = SKSpriteNode(color: UIColor.redColor(), size: CGSize(width: 64, height: 64)) 
 box.physicsBody = SKPhysicsBody(rectangleOfSize: CGSize(width: 64, height: 64)) 
 That rectangle will wrap perfectly around the box's color, so it will bounce and rotate as it 
 collides with other objects in your scene.
  
 If you want to create circular physics to simulate balls, this is done using the 
 circleOfRadius 
 constructor:
  
 let ball = SKSpriteNode(imageNamed: ""ballRed"") 
 ball.physicsBody = SKPhysicsBody(circleOfRadius: ball.size.width / 2.0) 
 For more information see Hacking with Swift tutorial 11.",NA
How to add pixel-perfect physics to an SKSpriteNode ,"Availability: iOS 7.0 or later.
  
 Pixel-perfect physics is just one line of code in SpriteKit. Don't believe me? Here you go:
  
 player = SKSpriteNode(imageNamed: ""player"") 
 www.hackingwithswift.com 
  
 1069",NA
How to color an SKSpriteNode using colorBlendFactor ,"Availability: iOS 7.0 or later.
  
 One powerful and under-used feature of SpriteKit is its ability to recolor 
 SKSpriteNodes 
 dynamically. This has almost zero performance impact, which makes it perfect for having 
 multiple-colored enemies or players. It can also be animated, meaning that you could for 
 example make your player flash white briefly when they've been hit by a bad guy.
  
 To tint a sprite cyan, use this code:
  
 firework.color = UIColor.cyanColor()  
 firework.colorBlendFactor = 1 
 If you want to animate the sprite coloring, you'd use this:
  
 let action = SKAction.colorizeWithColor(UIColor.redColor(), colorBlendFactor: 1, 
 duration: 1) 
 For more information see Hacking with Swift tutorial 20.
  
 www.hackingwithswift.com 
  
 1070",NA
How to create 3D audio sound using SKAudioNode ,"Availability: iOS 9.0 or later.
  
 3D audio is a feature where a sound is dynamically altered so that listeners think it comes 
 from a particular location. Obviously they are looking at a flat 2D screen ahead of them, but 
 using some clever mathematics iOS can make sounds ""feel"" like they are behind you, or at a 
 more basic level adjust the panning so that sounds come from the left or right of the user's 
 audio device.
  
 As of iOS 9.0, you get these features for free: all you need to do is create an 
 SKAudioNode 
 for your sound and set its 
 positional
  property to be 
 true
 . That's it – iOS will automatically use 
 the position of the node to adjust the way its audio sounds, and it even adjusts the audio as 
 you move it around.
  
 To give you a working example, this creates an audio node from a file called music.m4a (you'll 
 need to provide that), then makes the audio move left and right forever. If you listen to this 
 using headphones (which is the only effective way for 3D sound to work on iOS devices) you'll 
 really hear a pronounced panning effect.
  
 override func didMoveToView(view: SKView) { 
  let music = SKAudioNode(fileNamed: ""music.m4a"") 
  addChild(music) 
  music.positional = true 
  music.position = CGPoint(x: -1024, y: 0) 
  let moveForward = SKAction.moveToX(1024, duration: 2) 
  let moveBack = SKAction.moveToX(-1024, duration: 2) 
  let sequence = SKAction.sequence([moveForward, moveBack]) 
  let repeatForever = SKAction.repeatActionForever(sequence) 
  music.runAction(repeatForever) 
 www.hackingwithswift.com 
  
 1071",NA
How to create a SpriteKit texture atlas in Xcode ,"Availability: iOS 7.0 or later.
  
 A SpriteKit texture atlas is actually just a folder with the extension .atlas, but it's more efficient 
 than loading textures individually because multiple images are stored in a single file and thus 
 can be loaded faster. Even better, you don't need to worry about how they are placed or even 
 orientation – you just use them as normal, and SpriteKit does the rest.
  
 In Finder, go into your project directory (where your .swift files are), then create a new folder 
 called assets.atlas. Now go to where you have your SpriteKit assets stored  and drag them 
 from there into your assets.atlas directory. Finally, drag your assets.atlas directory into your 
 Xcode project so that it gets added to the build.
  
 That's it – enjoy your efficiency improvements!
  
 For more information see Hacking with Swift tutorial 29.",NA
How to create shapes using SKShapeNode ,"Availability: iOS 7.0 or later.
  
 SpriteKit's 
 SKShapeNode
  class is a fast and convenient way to draw arbitrary shapes in your 
 games, including circles, lines, rounded rectangles and more. You can assign a fill color, a 
 stroke color and width, plus other drawing options such as whether it should glow – yes, 
 really.
  
 The example code below draws a rounded rectangle smack in the middle of the game scene, 
 giving it a red fill color and a 10-point blue border:
  
 let shape = SKShapeNode() 
 shape.path = UIBezierPath(roundedRect: CGRect(x: -128, y: -128,  
 www.hackingwithswift.com 
  
 1072",NA
How to emit particles using SKEmitterNode ,"Availability: iOS 7.0 or later.
  
 SpriteKit has built-in support for particle systems, which are a realistic and fast way to create 
 effects such as smoke, fire and snow. Even better, Xcode has a built-in visual particle editor 
 so that you can tweak your designs until they look exactly right.
  
 To get started, right-click on your project in Xcode and choose New File. Select iOS > 
 Resource > SpriteKit Particle File, then choose the Smoke template and click Next to name 
 your effect. Once that's done, your particle will be opened immediately in the visual editor so 
 you can adjust its design.
  
 When it comes to using your effect, just create a new 
 SKEmitterNode
  object using the name of 
 your particle effect, like this:
  
 if let particles = SKEmitterNode(fileNamed: ""yourParticleFile.sks"") { particles.position = 
 player.position 
  addChild(particles)  
 } 
 Obviously you will want to set your own position rather than using an example 
 player
  node.
  
 www.hackingwithswift.com 
  
 1073",NA
How to generate a random number with GKRandomSource ,"Availability: iOS 9.0 or later.
  
 GameplayKit is a powerful new framework introduced in iOS 9.0, and one of the (many!) 
 things it does is provide a number of ways to generate random numbers easily. To get 
 started, import the framework into your code like this:
  
 import GameplayKit 
 You can immediately start generating random numbers just by using this code:
  
 print(GKRandomSource.sharedRandom().nextInt()) 
 That code produces a number between -2,147,483,648 and 2,147,483,647, so if you're happy 
 with negative numbers then you're basically done. Alternatively, if you want a random number 
 between and an upper bound (inclusive!), you should use this code instead:
  
 print(GKRandomSource.sharedRandom().nextIntWithUpperBound(10)) 
 That will return a number between 0 and 10, including 0 and 10 themselves.
  
 For more information see Hacking with Swift tutorial 35.",NA
How to roll a dice using GameplayKit and ,NA,NA
GKRandomDistribution ,"Availability: iOS 9.0 or later.
  
 www.hackingwithswift.com 
  
 1074",NA
How to run SKActions in a group,"Availability: iOS 7.0 or later.
  
 SpriteKit action groups let you run multiple SpriteKit actions simultaneously. The grouped 
  
 www.hackingwithswift.com 
  
 1075",NA
How to run SKActions in a sequence ,"Availability: iOS 7.0 or later.
  
 One of the great features of SpriteKit's actions is that they can be chained together using 
 action sequences. SpriteKit automatically ensures each action finishes before the next one 
 begins – all you need to do is create the actions then put them into an array.
  
 The example below makes a spaceship shrink down to 10% of its original size before fading 
 out:
  
 let sprite = SKSpriteNode(imageNamed:""Spaceship"") 
 let scale = SKAction.scaleTo(0.1, duration: 0.5) let fade = 
 SKAction.fadeOutWithDuration(0.5) let sequence = 
 SKAction.sequence([scale, fade]) 
 www.hackingwithswift.com 
  
 1076",NA
How to stop an SKPhysicsBody responding to physics using its ,NA,NA
dynamic property ,"Availability: iOS 7.0 or later.
  
 Enabling physics in SpriteKit is just one line of code, but sometimes you want your physics to 
 be a little more nuanced. For example, your player might have circle physics and should 
 respond to gravity, whereas walls might have rectangle physics and not respond to gravity – 
 they are there to be bounced off, but nothing more.
  
 This problem is solved in SpriteKit by using the 
 dynamic
  property. It's 
 true
  by default, which 
 means that your objects respond to the world's environment as you would expect, but if you 
 set it to be 
 false
  then you get an object that has active physics but doesn't move as a result of 
 those physics.
  
 Here's an example:
  
 let wall = SKSpriteNode(imageNamed: ""wall"") 
 wall.position = CGPoint(x: 512, y: 0) 
 wall.physicsBody = SKPhysicsBody(circleOfRadius: wall.size.width / 2.0) 
 wall.physicsBody!.dynamic = false 
 addChild(wall) 
 For more information see Hacking with Swift tutorial 11.",NA
How to write text using SKLabelNode,"www.hackingwithswift.com 
  
 1077",NA
locationInNode(): How to find a touch's location in a node ,"Availability: iOS 7.0 or later.
  
 It's just one line of code to find where the user touched the screen when you're using 
 SpritKit, and that one line can even be used to calculative relative positions of a touch 
 compared to any node in your game.
  
 To get started, you should implement 
 touchesBegan()
  in your SpriteKit node or scene. This 
 will get called when the user starts touching the node, regardless of where on the node. To 
 locate the exact position, call 
 locationInNode()
  on any 
 UITouch
 , passing in the node you 
 want to check, like this:
  
 override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { 
  if let touch = touches.first { 
  let location = touch.locationInNode(self) 
  print(location) 
  } 
 } 
 For more information see Hacking with Swift tutorial 11.",NA
presentScene(): How to change SKScene with a transition ,"Availability: iOS 7.0 or later.
  
 You can change between SpriteKit scenes by calling the 
 presentScene()
  method on your 
 SKView
 . This can be called either just with a new scene, or with a new scene and a transition 
 animation to use, depending on the effect you want. Here's an example with a transition:
  
 let scene = NewGameScene(fileNamed: ""NewGameScene"")! 
 let transition = SKTransition.moveInWithDirection(.Right, duration:  
 www.hackingwithswift.com 
  
 1079",NA
Language,NA,NA
How to check for valid method input using the guard keyword ,"Availability: iOS 7.0 or later.
  
 The 
 guard
  keyword was introduced in Swift to signal early returns, which is a coding 
 technique that effectively means ""make sure all these things are set up before I start doing 
 the real work in my function, others bail out.""
  
 For example, if you want to ensure a 
 submit()
  is only ever run if an existing 
 name
  property 
 has a value, you would do this:
  
 func submit() { 
  guard name != nil else { return } 
  doImportantWork(name)  
 } 
 This might seem like a job for a regular 
 if
  statement, and to be fair that's correct – the two are 
 very similar. The advantage with 
 guard
 , however, is that it makes your intention clear: these 
  
 www.hackingwithswift.com 
  
 1080",NA
How to convert a float to a CGFloat ,"Availability: iOS 7.0 or later.
  
 The 
 Float
  and 
 CGFloat
  data types sound so similar you might think they were identical, but 
 they aren't: 
 CGFloat
  is flexible in that its precision adapts to the type of device it's running on, 
 whereas 
 Float
  is always a fixed precision. Thus, you never lose precision converting from 
 Float
  to 
 CGFloat
 , whereas you might going the other way.
  
 To convert, just use the 
 CGFloat
  constructor, like this:
  
 let myCGFloat = CGFloat(myFloat)",NA
How to convert a float to an int ,"Availability: iOS 7.0 or later.
  
 You can convert between a 
 Float
  and an 
 Int
  just by using the integer's constructor, like this:
  
 www.hackingwithswift.com 
  
 1081",NA
How to convert a string to a double ,"Availability: iOS 7.0 or later.
  
 Swift strings don't have a built-in way to convert to a 
 Double
 , but their 
 NSString 
 counterparts do. To convert between strings and doubles, just do this:
  
 let myString = ""556""  
 let myFloat = (myString as NSString).doubleValue",NA
How to convert a string to a float ,"Availability: iOS 7.0 or later.
  
 There are several ways to convert between a string and a 
 Float
 , but the easiest way is to use 
 NSString
  as an intermediate because that comes with several helpers built right in:
  
 let myString = ""556""  
 let myFloat = (myString as NSString).floatValue 
 www.hackingwithswift.com
  
 1082",NA
How to convert a string to an NSString ,"Availability: iOS 7.0 or later.
  
 When Swift originally launched, NSString (older iOS strings) and native Swift strings were 
 completely interchangeable, as were NSArray and Swift arrays, plus NSDictionary and Swift 
 dictionaries. This got changed in Swift 1.2 so that you need to explicitly cast between these 
 data types, and this remains the same in Swift 2.0.
  
 So, to cast between Swift strings and NSString, you need to do a simple typecast like this:
  
 let str = ""Hello"" 
 let otherStr = str as NSString 
 Note that you don't need to force the typecast because the two data types are still 
 interoperable.",NA
How to convert a string to an int ,"Availability: iOS 7.0 or later.
  
 If you have an integer hiding inside a string, you can convert between the two just by using 
 the integer's constructor, like this:
  
 let myString = ""556"" 
 let myInt = Int(myString) 
 As with other data types (
 Float
  and 
 Double
 ) you can also convert by using 
 NSString
 :
  
 let myString = ""556"" 
 let myInt = (myString as NSString).integerValue 
 www.hackingwithswift.com
  
 1083",NA
How to convert an int to a float ,"Availability: iOS 7.0 or later.
  
 Swift's 
 Float
  data type has a built-in constructor that can convert from integers with no extra 
 work from you. For example, to convert the integer 556 into its 
 Float
  equivalent, you'd use 
 this:
  
 let myInt = 556 
 let myFloat = Float(myInt)",NA
How to convert an int to a string ,"Availability: iOS 7.0 or later.
  
 Swift's string interpolation means you can convert all sorts of data – including integers – to a 
 string in just one line of code:
  
 let str = ""\(myInt)"" 
 However, the more common way is just to use the string constructor, like this:
  
 let str = String(myInt) 
 www.hackingwithswift.com
  
 1084",NA
How to create an Objective C bridging header to use code in ,NA,NA
Swift ,"Availability: iOS 7.0 or later.
  
 If you want to use Objective-C code in your Swift app – and let's face it, that's going to 
 happen quite a lot! – then you need to create a bridging header that allows your Swift code 
 to work with your Objective-C code.
  
 To create an Objective-C bridging header file, all you need to do is drag some Objective-C 
 code into your Swift project – Xcode should prompt you with the message ""Would you like to 
 configure an Objective-C bridging header?"" Click ""Creating Bridging Header"" and you'll see a 
 file called 
 YourProjectName-Bridging-Header.h
  appear in your project.
  
 But that's only half the problem: Xcode has created the bridging header and modified your 
 build settings so that it gets used, but it hasn't actually put anything into it. If you want to start 
 using your Objective-C code in Swift, you need to add import lines to that bridging header 
 file, like this:
  
 #import ""YourFile.h"" 
 You can add as many of these as you want, and indeed you'll want to import all the 
 Objective-C code you want to use in Swift.",NA
How to delay execution of code using the defer keyword ,"Availability: iOS 7.0 or later.
  
 The 
 defer
  keyword is new in Swift 2 and lets you schedule some code to be run at a later 
 date. That later date is when your code exits its current scope, which might be when a 
 function returns or at the end of a loop, for example.
  
 If you've used other programming languages, 
 defer
  will seem similar to 
 try/finally
 . Any code 
 you defer will run no matter what, even if you throw an exception.
  
 www.hackingwithswift.com 
  
 1085",NA
How to find the maximum of three numbers ,"Availability: iOS 2.0 or later.
  
 The easiest way to find the maximum of three numbers is to use the 
 max()
  function twice: 
 once with your first two numbers, and again with your third number and the result of the first 
 call. Here's an example:
  
 let first = 10  
 let second = 15 
 www.hackingwithswift.com 
  
 1086",NA
How to find the maximum of two numbers ,"Availability: iOS 2.0 or later.
  
 To find the largest of any two integers, use the 
 max()
  function like this:
  
 let first = 10  
 let second = 15 
 let largest = max(first, second) 
 This also works with floating-point numbers, as long as both numbers are floats – you can't 
 mix data types.",NA
How to find the minimum of three numbers ,"Availability: iOS 2.0 or later.
  
 You can find the minimum of three numbers by using the 
 min()
  function twice. This function 
 takes either two integers or two floating-point numbers, but can't accept mixed types. Here's an 
 example:
  
 let first = 10  
 let second = 15  
 let third = 18 
 www.hackingwithswift.com 
  
 1087",NA
How to find the minimum of two numbers ,"Availability: iOS 2.0 or later.
  
 To find the minimum of two numbers, either both integer or both floating point (not mixed!), 
 use the 
 min()
  function. For example:
  
 let first = 10 
 let second = 15 
 let smallest = min(first, second)",NA
How to force your program to crash with assert() ,"Availability: iOS 7.0 or later.
  
 This might seem like a strange topic – after all, why would anyone want their program to 
 crash? Well, the answer is two-fold.
  
 First, if something has gone wrong that leaves your program in an unsafe state, continuing 
 might mean corrupting user data.
  
 Second, if you're debugging your app (i.e., it's still in development), having your app refuse 
 to continue if a serious problem is found is a huge advantage and a very common way to 
 spot problems.
  
 Swift lets you force an app crash using the 
 assert()
  function. This takes two parameters: a 
 condition to check, and a message to print if the assertion fails. Helpfully, any calls to 
  
 www.hackingwithswift.com 
  
 1088",NA
How to print debug text in Swift ,"Availability: iOS 7.0 or later.
  
 You can write text to the Xcode debug console using the 
 print()
  function in Swift. In older 
 versions of Swift this was named 
 println()
 , but this changed in Xcode 7 and Swift 2.",NA
How to unwrap an optional in Swift ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1089",NA
How to use #available to check for API availability ,"Availability: iOS 7.0 or later.
  
 One of my favorite Xcode 7 features is the ability to have Xcode automatically check API 
 availability for you, which means it will refuse to run code that is not available on the 
 minimum iOS version you support.
  
 Of course, there are times when you really do need to use a newer feature, for example if you 
 want to use 
 UIStackView
  where it's available but otherwise show a message to users asking 
  
 www.hackingwithswift.com 
  
 1090",NA
How to use compiler directives to detect the iOS Simulator ,"Availability: iOS 7.0 or later.
  
 Swift makes it easy to write special code that should be executed only in the iOS Simulator. 
 This is helpful to test situations where the simulator and devices don't match, for example 
 testing the accelerometer or camera.
  
 If you want certain code to be run only in the iOS simulator, you should use this:
  
 www.hackingwithswift.com 
  
 1091",NA
How to use try/catch in Swift to handle exceptions ,"Availability: iOS 7.0 or later.
  
 The new try/catch syntax was added in Swift 2.0 to make exception handling clearer and 
 safer. It's made up of three parts: 
 do
  starts a block of code that might fail, 
 catch
  is where 
 execution gets transferred if any errors occur, and any function calls that might fail need to 
 be called using 
 try
 .
  
 Here's a working example that loads an input.txt file from the app bundle into a string:
  
 if let filename = NSBundle.mainBundle().pathForResource(""input"", ofType: ""txt"") { 
  do { 
   let str = try String(contentsOfFile: filename, usedEncoding: nil) 
  print(str) 
  } catch { 
   print(""The file could not be loaded"") 
  }  
 } 
 There are two other ways of using 
 try
 , but neither are really recomended. The first is like this:
  
 let str = try! String(contentsOfFile: filename, usedEncoding: nil) 
 Note the exclamanation mark: 
 try!
 . This means ""I realize this call might throw an exception, 
 but trust me: it never, ever will."" This is useful only if you're 100% sure the call is safe. In our 
 example we're loading a file from the app bundle, and if that file isn't there it means our app is 
 corrupted, so it's OK to use here. You don't need do/catch when you use 
 try!
 .
  
 The second option is 
 try?
  which means ""if this call throws an exception, just return nil 
 instead."" This is closer to the Objective C way of handling errors, which was a bit scruffy. If 
  
 www.hackingwithswift.com 
  
 1093",NA
What are lazy variables? ,"Availability: iOS 7.0 or later.
  
 It's very common in iOS to want to create complex objects only when you need them, largely 
 because with limited computing power at your disposal you need to avoid doing expensive 
 work unless it's really needed.
  
 Swift has a mechanism built right into the language that enables just-in-time calculation of 
 expensive work, and it is called a 
 lazy variable
 . These variables are created using a function 
 you specify only when that variable is first requested. If it's never requested, the function is 
 never run, so it does help save processing time.
  
 I don't want to produce a complicated example because that would rather defy the point, so 
 instead I've built a simple (if silly!) one: imagine you want to calculate a person's age using the 
 Fibonacci sequence. This sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on – each number 
 is calculated by adding the previous two numbers in the sequence. So if someone was aged 
 8, their Fibonacci sequence age would be 21, because that's at position 8 in the sequence.
  
 I chose this because the most common pedagogical way to teach the Fibonacci sequence is 
 using a function like this one:
  
 func fibonacci(num: Int) -> Int { 
  if num < 2 { 
  return num 
  } else { 
  return fibonacci(num - 1) + fibonacci(num - 2) 
  } 
 } 
 www.hackingwithswift.com
  
 1094",NA
What are property observers ,"Availability: iOS 7.0 or later.
  
 Property observers are Swift's way of letting you attach functionality to changes in property 
 values. For example, you might want to say, ""whenever the player's score changes, update 
 this label to show their new score."" Here's a basic example that prints message to the debug 
 console when a variable changes:
  
 var score = 0 { 
  willSet { 
   print(""Score is about to change to \(newValue)"") } 
  didSet { 
   print(""Score just changed from \(oldValue) to \(score)"") }  
 } 
 score = 10 
 For more information see Hacking with Swift tutorial 1.",NA
What are the changes in Swift 1.2? ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1096",NA
What are the changes in Swift 2.0? ,"Availability: iOS 7.0 or later.
  
 Swift 2.0 introduced a lot of major language changes. You can read my full article explaining 
 the changes with code examples 
 by clicking here
 , but here are the highlights:
  
  • Checked exceptions using 
 try/catch
  • Automatically synthesized headers
  
  • The 
 guard
  keyword to check input while unwrapping optionals
  
  • Measuring strings is now done using 
 characters.count
  • Delayed code execution using 
 the 
 defer
  keyword
  
  • You now get mutability warnings if you declare variables that never get changed • API 
 availability checking is now built right in
  
  • The 
 performSelector()
  family of functions is now available
  
 www.hackingwithswift.com 
  
 1097",NA
What does an exclamation mark mean? ,"Availability: iOS 7.0 or later.
  
 Swift uses exclamation marks to signal both force unwrapping of optionals and expicitly 
 unwrapped optionals. The former means ""I know this optional variable definitely has a value, 
 so let me use it directly."" The latter means ""this variable is going to be nil initially then will 
 definitely have a value afterwards, so don't make me keep unwrapping it.""
  
 Broadly speaking, using exclamation marks is frowned upon because ""trust me it's safe"" 
 isn't as good as the compiler absolutely enforcing it. That being said, it's your code: if you 
 know something cannot be nil (usually because if it were nil your program would explode!) 
 then do what works best.
  
 For more information see Hacking with Swift tutorial 1.",NA
What does override mean? ,"Availability: iOS 7.0 or later.
  
 The 
 override
  is used when you want to write your own method to replace an existing one in a 
 parent class. It's used commonly when you're working with 
 UIViewControllers
 , because view 
 controllers already come with lots of methods like 
 viewDidLoad()
  and 
  
 viewWillAppear()
 . When you want to override these default methods, you need to specify this 
 with the 
 override
  keyword.
  
 Now, you might be wondering why the 
 override
  keyword is even needed, but it's really about 
 ensuring your code is safe – if you write a method and accidentally name it the same as 
 something that already exists, Xcode will simply refuse to build your app until you add in the 
 override
  keyword. Similarly, if you use 
 override
  on a method that doesn't override 
  
 something that already exists, Xcode will refuse to build.",NA
What does unowned mean? ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1098",NA
What does weak mean? ,"Availability: iOS 7.0 or later.
  
 Unless you specific otherwise, all Swift properties are strong, which means they will not be 
 removed from RAM until whatever owns them is removed from RAM. So, if you create an 
 array in your view controller and you want it to stick around until the view controller is 
 destroyed, that's what strong does.
  
 Weak
  on the other hand is there when you want to say ""I want to be able to reference this 
 variable, but I don't mind if it goes away, so I don't want to own it."" This might seem strange: 
 after all, where's the point in having a reference to a variable that might not be there?
  
 Well, the answer lies in a thing called reference cycles. If object A has a strong variable 
 pointing at object B, and object B has a strong variable pointing at object A, neither object 
 would ever be deleted because they both keep each other alive.
  
 In this situation, having one of the objects change their property to be weak would solve the 
 problem. For example, object A has a strong variable to object B, but object B has a weak 
 variable pointing at object A. This guarantees that B cannot be destroyed while A still exists, 
 but A can be destroyed because B doesn't have a strong variable owning it.
  
 For more information see Hacking with Swift tutorial 1.",NA
What is AnyObject? ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1099",NA
What is a CGFloat? ,"Availability: iOS 7.0 or later.
  
 A 
 CGFloat
  is a specialised form of 
 Float
  that holds either 32-bits of data or 64-bits of data 
 depending on the platform. The CG tells you it's part of Core Graphics, and it's found 
 throughout UIKit, Core Graphics, Sprite Kit and many other iOS libraries.
  
 If you have a 
 Float
  or 
 Double
  and need a 
 CGFloat
 , you can convert it like this:
  
 let myCGFloat = CGFloat(myDouble)",NA
What is a closure? ,"Availability: iOS 7.0 or later.
  
 If you're here because you find closures hard, that's OK: most people find closures hard. But 
 in truth, closures aren't actually that complicated, so I hope I can explain them to you quickly 
 and easily.
  
 Here's my best, simplest definition: a closure is a kind of anonymous function that gets 
 stored as a variable so it can be called later on, and has the special ability to remember the 
 state of your program when you used it.
  
 Some detail:
  
  • ""Anonymous function"": that is, a closure is a block of code you define, starting with { and 
  
 www.hackingwithswift.com 
  
 1100",NA
What is a delegate in iOS? ,"Availability: iOS 2.0 or later.
  
 Delegates are extremely common in iOS development, but fortunately they are easy to 
 understand: a delegate is any object that should be notified when something interesting has 
 happened. What that ""something interesting"" means depends on the context: for example, a 
 table view's delegate gets notified when the user taps on a row, whereas a navigation 
 controller's delegate gets notified when the user moves between view controllers.
  
 When you agree to be the delegate for an object, you will almost certainly need to conform to a 
 specific protocol, such as 
 UITableViewDelete
 . These protocols will usually have some optional 
 methods that you can implement if you care when something happens, for example, table views 
 can notify you when users 
 deselect
  a row, but most developers don't care. These protocols may 
 also have some required methods that you 
 must
  implement.
  
 For more information see Hacking with Swift tutorial 1.",NA
What is a dictionary?,"www.hackingwithswift.com 
  
 1101",NA
What is a double? ,"Availability: iOS 7.0 or later.
  
 The 
 Double
  data type is the standard Swift way of storing decimal numbers such as 3.1, 
 3.14159 and 16777216.333921. Whenever you create a variable or constant that holds a 
 number like this, Swift automatically assumes it's a 
 Double
  rather than a 
 Float
 , because it 
 has a higher precision and therefore less likely to lose valuable accuracy.
  
 For more information see Hacking with Swift tutorial 0.",NA
What is a float?,"Availability: iOS 7.0 or later.
  
 The 
 Float
  data type stores low-precision decimal numbers such as 3.1, 3.14159 and 556.9. It is 
 not used that often in Swift, partly because 
 Double
  is the default for these kinds of numbers (it 
 has a higher precision), and partly because when you come across libraries that use regular 
 floats they are more likely to want 
 CGFloat
  instead.
  
 For more information see Hacking with Swift tutorial 0.",NA
What is a nib?,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1102",NA
What is a protocol? ,"Availability: iOS 2.0 or later.
  
 A protocol is a collection of methods that describe a specific set of similar actions or 
 behaviors. I realise that probably didn't help much, so I'll try to rephrase in more detail: how 
 many rows should a table view have? How many sections? What should the section titles 
 be? Can the user move rows? If so, what should happen when they do?
  
 All those questions concern a similar thing: data going into a 
 UITableView
 . As a result, they 
 all go into a single protocol, called 
 UITableViewDataSource
 . Some of the behaviors inside 
 that protocol are optional. For example, 
 canEditRowAtIndexPath
  is optional and defaults to 
 true if you don't provide a value yourself.
  
 When you work in Swift you will frequently have to make your class conform to a protocol. 
 This is done by adding the protocol name to your class definition, like this:
  
 class ViewController: UIViewController, UITableViewDataSource { 
 When you do that – when you promise Swift that your class conforms to a protocol – you can 
 be darn sure it checks to make sure you're right. And that means it will refuse to build your code 
 if you haven't added support for all the required methods, which is a helpful security measure.
  
 For more information see Hacking with Swift tutorial 1.
  
 www.hackingwithswift.com 
  
 1103",NA
What is a selector? ,"Availability: iOS 7.0 or later.
  
 Selectors are effectively the names of methods on an object or struct, and they are used to 
 execute some code at runtime. They were common in Objective C, but the earliest versions of 
 Swift didn't include some core selector functionality so their use declined for a while. As of Swift 
 2 that functionality (things like 
 performSelectorInBackground
 ) has been restored.
  
 In Swift, selectors are most commonly found when working with the target/action paradigm 
 that you find in classes such as 
 NSTimer
  and 
 UIBarButtonItem
 . For example, when you 
 create a timer you need to tell it who to notify when the timer fires (the target) and what 
 selector should be called (the action). The same goes for bar button items: when the button 
 is tapped, what selector should be called, and on what object?",NA
What is a storyboard? ,"Availability: iOS 7.0 or later.
  
 Storyboards were introduced way back in iOS 5 as a way to revamp interface design for iOS. 
 At the time they didn't add much in the way of features that weren't available with the older 
 XIBs, but in subsequent releases Apple have added helpful new features such as layout 
 guides that make them much more useful – and arguably indispensible since iOS 7.
  
 All new iOS projects come with at least one storyboard ready to use: Main.storyboard. Inside 
 that you can create as many interfaces as you want, each representing one view controller in 
 your app. You can then design in segues (pronounced ""segway"", like the gyro-bike things) that 
 transition between view controllers – all without a single line of code.
  
 There is one drawback to storyboards, and it's something you'll hit fairly quickly: if you have 
 more than four view controllers in your app, you'll probably find it a little cumbersome to 
 navigate around, particularly if you're working on a laptop. If you're working on something 
 important, move your view controllers around: keep them organised from the beginning, 
 otherwise your storyboard will soon become a nightmare!
  
 For more information see Hacking with Swift tutorial 1.
  
 www.hackingwithswift.com 
  
 1104",NA
What is a struct? ,"Availability: iOS 7.0 or later.
  
 Classes and structures (structs) are so similar in Swift that it's easy to get them confused at 
 first, but actually there are some important underlying differences:
  
  • A struct cannot inherit from another kind of struct, whereas classes can build on other 
 classes.
  
  • You can change the type of an object at runtime using typecasting. Structs cannot have 
 inheritance, so have only one type.
  
  • If you point two variables at the same struct, they have their own independent copy of the 
 data. With objects, they both point at the same variable.
  
 That last point is particularly important: with a struct you know your data is fixed in place, like 
 an integer or other value. This means if you pass your struct into a function, you know it's not 
 going to get modified.",NA
What is a tuple?,"Availability: iOS 7.0 or later.
  
 Tuples in Swift occupy the space between dictionaries and structures: they hold very specific 
 types of data (like a struct) but can be created on the fly (like dictionaries). They are 
  
 commonly used to return multiple values from a function call.
  
 You can create a basic tuple like this:
  
 let person = (name: ""Paul"", age: 35) 
 As you can see, it looks like an anonymous struct: you can read 
 person.name
  and 
  
 person.age
  just like you would with a struct. But, helpfully, we haven't had to define the struct 
 ahead of time – this is something made to be thrown away. It also means you don't get to 
 conform to protocols or write methods inside your tuples, but that's OK.
  
 Tuples can be accessed using element names (""name"" and ""age"" above), or using a position 
  
 www.hackingwithswift.com 
  
 1105",NA
What is an optional value in Swift? ,"Availability: iOS 7.0 or later.
  
 Swift optionals are one of the most confusing parts of the language for beginners, but actually 
 are fairly easy to understand. Put simply, if I declare a variable as an integer, that means it 
 must hold a number. That number might be 0, 1, -1, 159, -758119, or whatever, but it's 
 definitely a number. This works great for telling me, for example, where in an array a certain 
 element can be found.
  
 www.hackingwithswift.com 
  
 1106",NA
What is copy on write? ,"Availability: iOS 7.0 or later.
  
 Copy on write is a common computing technique that helps boost performance when copying 
 structures. To give you an example, imagine an array with 1000 things inside it: if you copied 
 that array into another variable, Swift would have to copy all 1000 elements even if the two 
 arrays ended up being the same.
  
 This problem is solved using copy on write: when you point two variables at the same array 
 they both point to the same underlying data. Swift promises that structs like arrays and 
 dictionaries are copied as values, like numbers, so having two variables point to the same 
 data might seem to contradict that. The solution is simple but clever: if you modify the 
 second variable, Swift takes a full copy at that point so that only the second variable is 
 modified - the first isn't changed.
  
 So, by delaying the copy operation until it's actually needed, Swift can ensure that no wasted 
 work is done.
  
 Warning: copy on write is a feature specifically added to Swift arrays and dictionaries; you 
 don't get it for free in your own data types.
  
 www.hackingwithswift.com 
  
 1107",NA
What is whole module optimization? ,"Availability: iOS 7.0 or later.
  
 Whole module optimization is a compiler pass that can add significant performance gains, 
 and so it's always worth enabling when doing a release build of your app for the App Store. 
  
 How it works is quite simple: when Swift builds the final version of your app it combines all your 
 source files together and can evaluate the whole structure of your program at once. This lets it 
 make extra optimizations that would be impossible before, when every file was optimized 
 individually.",NA
What's the difference between let and var? ,"Availability: iOS 7 or later.
  
 Swift lets you create both variables and constants as ways to reference your data, but there's a 
 strong push (even Xcode warnings!) if you create things as variables then never change them. 
 To make a constant, use 
 let
  like this:
  
 let x = 10 
 To make a variable, use 
 var
  like this:
  
 var x = 10 
 The reason Swift strongly encourages you to use constants wherever possible is because it's 
 safer: if you say ""this value will never change,"" then Swift will refuse to let you change it even by 
 accident. It also opens the possibility of compiler optimizations if the system knows certain data 
 will not change.
  
 For more information see Hacking with Swift tutorial 1.
  
 www.hackingwithswift.com 
  
 1108",NA
Libraries,NA,NA
How to get a Cover Flow effect on iOS ,"Availability: iOS 5.0 or later.
  
 You can get an instant Cover Flow effect on iOS by using the marvellous and free iCarousel 
 library. You can download it from 
 https://github.com/nicklockwood/iCarousel
  and drop it 
 into your Xcode project fairly easily by adding a bridging header (it's written in Objective C).
  
 If you haven't added Objective C code to a Swift project before, follow these steps:
  
  • 
 Download iCarousel
  and unzip it
  
  • Go into the folder you unzipped, open its iCarousel subfolder, then select iCarousel.h and 
 iCarousel.m and drag them into your project navigation – that's the left pane in Xcode. Just 
 beloe Info.plist is fine.
  
  • Check ""Copy items if needed"" then click Finish.
  
  • Xcode will prompt you with the message ""Would you like to configure an Objective-C 
 bridging header?"" Click ""Create Bridging Header""
  
  • You should see a new file in your project, named YourProjectName-Bridging-Header.h.
  
  • Add this line to the file: 
 #import ""iCarousel.h"" 
  
 Once you've added iCarousel to your project you can start using it. Here's a complete, albeit 
 simplified, example:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
  let carousel = iCarousel(frame: CGRect(x: 0, y: 0, width: 300, height: 200)) 
  carousel.dataSource = self 
  carousel.type = .CoverFlow 
  view.addSubview(carousel) 
 } 
 www.hackingwithswift.com 
  
 1109",NA
How to make empty UITableViews look more attractive using ,NA,NA
DZNEmptyDataSet ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 111
 0",NA
How to parse JSON using SwiftyJSON ,"Availability: iOS 7.0 or later.
  
 SwiftyJSON is a super-simplified JSON parsing library that gives you clearer syntax than the 
 built-in iOS libraries, and better yet it's completely free. You can 
 download it from here
  but at 
 the time of writing its Xcode 7 / Swift 2 support was kept in a separate branch – if that's still 
 the case when you click that link, 
 try downloading from here instead
 .
  
 Unzip the file you downloaded, then look in its Source directory and drag SwiftyJSON.swift 
 into your Xcode project. To use SwiftyJSON, you need to convert your JSON string into an 
 NSData
  object, then send it in for parsing. Once that's done, you simply request data in the 
 format you want, and (here's the awesome bit) 
 SwiftyJSON is guaranteed to return 
  
 something.
 That ""something"" is going to be your data, if all things are in good shape. But if you 
 requested the wrong thing (either with a typo, or because you didn't understand your JSON 
 structure correctly) or if the JSON has changed, SwiftyJSON will just return a default value 
 instead.
  
 www.hackingwithswift.com 
  
 111
 3",NA
Location,NA,NA
How to add a button to an MKMapView annotation ,"Availability: iOS 2.0 or later.
  
 The built-in 
 MKPinAnnotationView
  annotation view has a 
 rightCalloutAccessoryView 
 property that can be set to any kind of 
 UIView
 , including buttons. The button doesn't need to 
  
 www.hackingwithswift.com 
  
 111
 5",NA
How to add an MKMapView using MapKit ,"Availability: iOS 2.0 or later.
  
 Map views are pretty easy in iOS, largely because they are baked right into Interface Builder. 
 That's right: open your storyboard, drag a map view into your view, and you're already most of 
 the way there! But there is one further thing to do, which is where people get confused: by 
  
 www.hackingwithswift.com 
  
 111
 7",NA
How to detect iBeacons ,"Availability: iOS 7.0 or later.
  
 Detecting iBeacons requires a number of steps. But first you need to decide whether you 
 want to detect beacons only when your app is running, or whether you want beacons to be 
 detected even if your app isn't in the background.
  
 Have you decided? Good, because you need to set one of two keys in your Info.plist 
 depending on your choice. If you want to detect beacons only when your app is running, add 
 the key 
 NSLocationWhenInUseUsageDescription
  and a short string explaining how you'll 
 use the location, e.g. ""We want to detect where you are in our store.""
  
 If you want the app to detect beacons even when it isn't running (a feat accomplished by 
 handing control of scanning over to the OS), you should use the 
  
 NSLocationAlwaysUsageDescription
  key instead.
  
 With that done, we can start to scan for beacons. Open your class in Xcode (it could be a 
 view controller, but it doesn't have to be), then import the Core Location framework like this:
  
 import CoreLocation 
 Now tell Swift that your class conforms to the 
 CLLocationManagerDelegate
  protocol so that 
 you can start to receive location updates. If you're using a view controller subclass, your code 
 will look something like this:
  
 class ViewController: UIViewController, CLLocationManagerDelegate { 
 www.hackingwithswift.com
  
 1118",NA
How to find directions using MKMapView and ,NA,NA
MKDirectionsRequest ,"Availability: iOS 6.0 or later.
  
 MapKit is great for letting users navigate from place to place, but also makes it easy for you to 
 plot directions from one place to another. You just tell iOS where you're starting from, where 
 you're going, as well as how you're travelling (by car, foot, or mass transit), and it will find 
 routes for you.
  
 First, make sure you have a map view in your app, and have the Maps entitlement enabled. 
 Now add this code:
  
 import MapKit  
 import UIKit 
 class ViewController: UIViewController { @IBOutlet 
 weak var mapView: MKMapView! 
  override func viewDidLoad() { 
  
  super.viewDidLoad() 
  let request = MKDirectionsRequest() 
  request.source = MKMapItem(placemark: MKPlacemark(coordinate: 
 CLLocationCoordinate2D(latitude: 40.7127, longitude: -74.0059), addressDictionary: nil)) 
  request.destination = MKMapItem(placemark:  
 www.hackingwithswift.com 
  
 1122",NA
How to make an iPhone transmit an iBeacon ,"Availability: iOS 7.0 or later.
  
 iOS 7.0 introduced not only the ability to detect iBeacons, but also the ability to create 
 iBeacons – for iPhones and iPads to broadcast their own beacon signal that can then be 
 detected by other devices. To make this work, you add these two imports:
  
 import CoreBluetooth 
 import CoreLocation 
 Now make your view controller (or other class) conform to the 
 CBPeripheralManagerDelegate
  protocol, like this:
  
 class ViewController: UIViewController, CBPeripheralManagerDelegate { 
 To make your beacon work, you need to create three properties: the beacon itself, plus two 
 Bluetooth properties that store configuration and management information. Add these three 
 now:
  
 var localBeacon: CLBeaconRegion! 
 var beaconPeripheralData: NSDictionary! 
 var peripheralManager: CBPeripheralManager! 
 www.hackingwithswift.com
  
 1124",NA
How to request a user's location only once using ,NA,NA
requestLocation ,"Availability: iOS 9.0 or later.
  
 iOS 9.0 introduces a simple way to request a user's location just once, and it's called 
 requestLocation()
 . Calling this method returns immediately (meaning that your code carries on 
 executing) but when iOS has managed (or failed) to get a fix on the user's location you will be 
 told. Below is a complete example:
  
 import CoreLocation  
 import UIKit 
 class ViewController: UIViewController, CLLocationManagerDelegate { let manager = 
 CLLocationManager() 
  override func viewDidLoad() { 
  
  manager.delegate = self 
  
  manager.requestLocation() 
  } 
  func locationManager(manager: CLLocationManager, didUpdateLocations  
 www.hackingwithswift.com 
  
 1126",NA
Media,NA,NA
CIDetectorTypeFace: How to detect faces in a UIImage ,"Availability: iOS 5.0 or later.
  
 Core Image has a number of feature detectors built right in, including the ability to detect faces, 
 eyes, mouths, smiles and even blinking in pictures. When you ask it to look for faces in a 
 picture, it will return you an array of all the faces it found, with each one containing face feature 
 details such as eye position. Here's an example:
  
 if let inputImage = UIImage(named: ""taylor-swift"") { let ciImage = 
 CIImage(CGImage: inputImage.CGImage!) 
  let options = [CIDetectorAccuracy: CIDetectorAccuracyHigh] 
  let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: options) 
 www.hackingwithswift.com 
  
 1127",NA
How to choose a photo from the camera roll using ,NA,NA
UIImagePickerController ,"Availability: iOS 2.0 or later.
  
 The 
 UIImagePickerController
  class is a super-simple way to select and import user photos 
 into your app. As a bonus, it also automatically handles requesting user permission to read 
 the photo library, so all you need to do is be ready to respond when the user selects a photo.
  
 First, make sure your view controller conforms to the 
 UINavigationControllerDelegate
  and 
 UIImagePickerControllerDelegate
  protocols, like this:
  
 www.hackingwithswift.com 
  
 1128",NA
"How to convert text to speech using AVSpeechSynthesizer, ",NA,NA
AVSpeechUtterance and AVSpeechSynthesisVoice ,"Availability: iOS 7.0 or later.
  
 If you're looking for text-to-speech conversion, it's baked right into iOS thanks to the 
 AVSpeechSynthesizer
  class and its friends. As you can tell from the ""AV"" part of its name, 
 you'll need to add AVFoundation to your project, like this:
  
 import AVFoundation 
 With that done, you can speak whatever you want. For example, to say ""Hello world"" in a 
 very slow British accent, use this:
  
 let utterance = AVSpeechUtterance(string: ""Hello world"") utterance.voice = 
 AVSpeechSynthesisVoice(language: ""en-GB"") utterance.rate = 0.1  
 www.hackingwithswift.com 
  
 1130",NA
How to create a PDF417 barcode ,"Availability: iOS 9.0 or later.
  
 PDF417 barcodes - most frequently seen on boarding passes at airports, but also seen in 
 digital postage stamps and other places – are built right into iOS as of iOS 9.0. This function 
 below accepts a string as its only parameter and returns a 
 UIImage
  containing the PDF417 
 barcode representing that string:
  
 func generatePDF417BarcodeFromString(string: String) -> UIImage? { let data = 
 string.dataUsingEncoding(NSISOLatin1StringEncoding) 
  if let filter = CIFilter(name: ""CIPDF417BarcodeGenerator"") { filter.setValue(data, 
 forKey: ""inputMessage"") 
  let transform = CGAffineTransformMakeScale(3, 3) 
   if let output =  
 filter.outputImage?.imageByApplyingTransform(transform) { 
  
   return UIImage(CIImage: output) 
   } 
  } 
  return nil  
 } 
 www.hackingwithswift.com 
  
 1131",NA
How to create a QR code ,"Availability: iOS 7.0 or later.
  
 iOS has a built-in QR code generator, but it's a bit tricksy to use because it's exposed as a 
 Core Image filter that needs various settings to be applied. Also, it generates codes where 
 every bit is just one pixel across, which looks terrible if you try to stretch it inside an image 
 view.
  
 So, here's a simple function that wraps up QR code generation while also scaling up the QR 
 code so it's a respectable size:
  
 func generateQRCodeFromString(string: String) -> UIImage? { let data = 
 string.dataUsingEncoding(NSISOLatin1StringEncoding) 
  if let filter = CIFilter(name: ""CIQRCodeGenerator"") { filter.setValue(data, 
 forKey: ""inputMessage"") 
  filter.setValue(""H"", forKey: ""inputCorrectionLevel"") let transform = 
 CGAffineTransformMakeScale(10, 10) 
   if let output =  
 filter.outputImage?.imageByApplyingTransform(transform) { 
  
   return UIImage(CIImage: output) 
   } 
  } 
  return nil  
 } 
 www.hackingwithswift.com 
  
 1132",NA
How to create a barcode ,"Availability: iOS 8.0 or later.
  
 You can generate a string into a traditional barcode using iOS using Core Image, but you 
 should make sure and convert your input string to an 
 NSData
  using 
  
 NSASCIIStringEncoding
  to ensure compatibility. Here's a function you can use that wraps it 
 all up neatly, including scaling up the barcode so it's a bit bigger:
  
 func generateBarcodeFromString(string: String) -> UIImage? { let data = 
 string.dataUsingEncoding(NSASCIIStringEncoding) 
  if let filter = CIFilter(name: ""CICode128BarcodeGenerator"") { filter.setValue(data, 
 forKey: ""inputMessage"") 
  let transform = CGAffineTransformMakeScale(3, 3) 
   if let output =  
 filter.outputImage?.imageByApplyingTransform(transform) { 
  
   return UIImage(CIImage: output) 
   } 
  } 
  return nil  
 } 
 let image = generateBarcodeFromString(""Hacking with Swift"") 
 www.hackingwithswift.com
  
 1133",NA
How to filter images using Core Image and CIFilter ,"Availability: iOS 5.0 or later.
  
 Core Image is the one of the most powerful frameworks available to iOS developers: it makes 
 hardware-accelerated image manipulation ridiculously easy, which means you get to add 
 powerful graphical effects to your apps and games with very little work.
  
 Most of the work is done by choosing the right 
 CIFilter
 . Apple's official documentation goes 
 into great detail about the various filters you can use, and you can also read Hacking with 
 Swift project 13 for a hands-on tutorial showing off various effects. The code below applies a 
 50% sepia tone effect to an image:
  
 let inputImage = UIImage(named: ""taylor-swift"")! let context = 
 CIContext(options: nil) 
 if let currentFilter = CIFilter(name: ""CISepiaTone"") { 
  let beginImage = CIImage(image: inputImage) 
  currentFilter.setValue(beginImage, forKey: kCIInputImageKey) 
 currentFilter.setValue(0.5, forKey: kCIInputIntensityKey) 
  if let output = currentFilter.outputImage { 
   let cgimg = context.createCGImage(output, fromRect: output.extent) 
   let processedImage = UIImage(CGImage: cgimg) 
   // do something interesting with the processed image }  
 } 
 For more information see Hacking with Swift tutorial 13.
  
 www.hackingwithswift.com 
  
 1134",NA
How to highlight text to speech words being read using ,NA,NA
AVSpeechSynthesizer,"Availability: iOS 7.0 or later.
  
 iOS has text-to-speech synthesis built right into the system, but even better is that it allows 
  
 you to track when individual words are being spoken so that you can highlight the words on 
  
 the screen. This is extremely easy to do thanks to the 
 AVSpeechSynthesizerDelegate
  
 protocol: you get two callbacks in the form of 
 willSpeakRangeOfSpeechString
  and 
  
 didFinishSpeechUtterance
 , where you can do your work.
  
 First, make sure you import AVFoundation into your project. Now make your class conform to 
  
 the 
 AVSpeechSynthesizerDelegate
  protocol. For example, if you're using a regular view 
  
 controller, you would write this:
  
 class ViewController: UIViewController, AVSpeechSynthesizerDelegate { 
 Place a label into your view controller, then hook it up to an outlet called 
 label
 . Now add 
  
 these two methods:
  
 func speechSynthesizer(synthesizer: AVSpeechSynthesizer!,  
 willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance!) 
 { 
  let mutableAttributedString = NSMutableAttributedString(string: utterance.speechString) 
 mutableAttributedString.addAttribute(NSForegroundColorAttributeName, value: 
 UIColor.redColor(), range: characterRange) 
  label.attributedText = mutableAttributedString 
 } 
 func speechSynthesizer(synthesizer: AVSpeechSynthesizer!, 
 didFinishSpeechUtterance utterance: AVSpeechUtterance!) { 
  label.attributedText = NSAttributedString(string:  
 www.hackingwithswift.com 
  
 1135",NA
How to make resizable images using ,NA,NA
resizableImageWithCapInsets() ,"Availability: iOS 2.0 or later.
  
 If you use a small image in a large image view, you can make the image stretch to fit if you 
 want to but it probably won't look great. iOS provides an alternative known as 
 resizable 
 images
 , which is where you define part of an image as being fixed in size and let iOS stretch 
 the remainder.
  
 This technique is common with button graphics: you make the corners fixed in size, then 
 stretch the center part as big as it needs to be. The center part ought to be just one pixel by 
 one pixel in size so that it stretches perfectly, but you can also ask iOS to repeat the center 
 area as a tile if that's what you want.
  
 This example code below creates a resizable image by defining the corners as 8 points each 
  
 www.hackingwithswift.com 
  
 1136",NA
How to play sounds using AVAudioPlayer ,"Availability: iOS 2.2 or later.
  
 The most common way to play a sound on iOS is using 
 AVAudioPlayer
 , and it's popular for a 
 reason: it's easy to use, you can stop it whenever you want, and you can adjust its volume as 
 often as you need. The only real catch is that you must store your player as a property or 
 other variable that won't get destroyed straight away – if you don't, the sound will stop 
 immediately.
  
 AVAudioPlayer
  is part of the AVFoundation framework, so you'll need to import that:
  
 import AVFoundation 
 Like I said, you need to store your audio player as a property somewhere so it is retained 
 while the sound is playing. In our example we're going to play a bomb explosion sound, so I 
 created a property for it like this:
  
 var bombSoundEffect: AVAudioPlayer! 
 With those two lines of code inserted, all you need to do is play your audio file. This is done 
 first by finding where the sound is in your project using 
 pathForResource()
 , then creating a 
 file URL out of it. That can then get passed to 
 AVAudioPlayer
  to create an audio player 
 object, at which point – finally – you can play the sound. Here's the code:
  
 www.hackingwithswift.com 
  
 1137",NA
How to record audio using AVAudioRecorder ,"Availability: iOS 3.0 or later.
  
 While it's not 
 hard
  to record audio with an iPhone, it does take quite a bit of code so give 
 yourself a few minutes to get this implemented. First you need to import the 
 AVFoundation
  
 www.hackingwithswift.com 
  
 1138",NA
How to record user videos using ReplayKit ,"Availability: iOS 9.0 or later.
  
 www.hackingwithswift.com 
  
 1143",NA
How to render a UIView to a UIImage ,"Availability: iOS 7.0 or later.
  
 You can render any 
 UIView
  into a 
 UIImage
  in just four lines of code, and that even handles 
 drawing all the subviews automatically. Here's the code:
  
 UIGraphicsBeginImageContextWithOptions(view.bounds.size, true, 0) 
 view.drawViewHierarchyInRect(view.bounds, afterScreenUpdates: true) let image = 
 UIGraphicsGetImageFromCurrentImageContext()  
 UIGraphicsEndImageContext() 
 Helpfully, that code works equally well no matter what the view contains - if you're using 
 UIKit, SpriteKit, Metal or whatever, it all works.",NA
How to save a UIImage to a file using ,NA,NA
UIImagePNGRepresentation ,"Availability: iOS 2.0 or later.
  
 If you've generated an image using Core Graphics, or perhaps rendered part of your layout, 
 you might want to save that out as either a PNG or a JPEG. Both are easy thanks to two 
 functions: 
 UIImagePNGRepresentation()
  and 
 UIImageJPEGRepresentation()
 , both of 
 which convert a 
 UIImage
  into an 
 NSData
  so you can write it out.
  
 Here's an example:
  
 if let image = UIImage(named: ""example.png"") { 
  if let data = UIImagePNGRepresentation(image) { 
   let filename =  
 getDocumentsDirectory().stringByAppendingPathComponent(""copy.png"")  
 data.writeToFile(filename, atomically: true) 
  } 
 www.hackingwithswift.com 
  
 1146",NA
How to scan a QR code ,"Availability: iOS 8.0 or later.
  
 iOS has built-in support for scanning QR codes using AVFoundation, but the code isn't easy: 
 you need to create a capture session, create a preview layer, handle delegate callbacks, and 
 more. To make it easier for you, I've created a 
 UIViewController
  subclass that does all the 
 hard work for you – you just need to modify the 
 foundCode()
  method to do something more 
 interesting.
  
 Note: rotation when using the camera can be quite ugly, which is why most apps fix the 
 orientation as you see below.
  
 import AVFoundation  
 import UIKit 
 class ScannerViewController: UIViewController, 
 AVCaptureMetadataOutputObjectsDelegate { 
  var captureSession: AVCaptureSession! 
  var previewLayer: AVCaptureVideoPreviewLayer! 
  override func viewDidLoad() { 
  
  super.viewDidLoad() 
  view.backgroundColor = UIColor.blackColor() captureSession 
 = AVCaptureSession() 
  let videoCaptureDevice =  
 AVCaptureDevice.defaultDeviceWithMediaType(AVMediaTypeVideo) let videoInput: 
 AVCaptureDeviceInput 
  do { 
  
  
  videoInput = try AVCaptureDeviceInput(device: 
 videoCaptureDevice) 
  } catch { 
 www.hackingwithswift.com 
  
 1148",NA
How to scan a barcode ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1151",NA
How to turn on the camera flashlight to make a torch ,"Availability: iOS 6.0 or later.
  
 There is one simple property required to enable or disable a device's torch, but you do need to 
 put in some wrapper code to make it work safely. Specifically, you need to use the 
 lockForConfiguration()
  and 
 unlockForConfiguration()
  methods of the 
 AVCaptureDevice 
 class in order to make sure only one app can control the torch at a time.
  
 www.hackingwithswift.com 
  
 1155",NA
UIImageWriteToSavedPhotosAlbum(): how to write to the iOS ,NA,NA
photo album ,"Availability: iOS 2.0 or later.
  
 It's not hard to save an image straight to the user's photo library, but I have to admit the 
 syntax isn't immediately obvious! iOS has a function called 
  
 UIImageWriteToSavedPhotosAlbum()
  that takes four parameters: parameter one is the 
 image to save, parameters two and three set a delegate and selector to send when the 
 image has been written successfully, and parameter four is any additional context 
 information you wan to send.
  
 For example, you might use it like this:
  
 UIImageWriteToSavedPhotosAlbum(yourImage, self, 
 ""image:didFinishSavingWithError:contextInfo:"", nil) 
 That will write the image to the photo library, then call a method when it completes. That 
 method needs to be named very precisely, which is where it's easy to go wrong. Using the 
 call above, you need to write your callback method like this:
  
 func image(image: UIImage, didFinishSavingWithError error: NSError?, 
 contextInfo:UnsafePointer<Void>) { 
  if error == nil { 
  let ac = UIAlertController(title: ""Saved!"", message: ""Your altered image has been 
 saved to your photos."",  
 preferredStyle: .Alert) 
  
  ac.addAction(UIAlertAction(title: ""OK"", style: .Default, handler: nil)) 
  presentViewController(ac, animated: true, completion: nil) 
  } else { 
  
  let ac = UIAlertController(title: ""Save error"", message: 
 error?.localizedDescription, preferredStyle: .Alert) 
 www.hackingwithswift.com 
  
 1157",NA
Strings,NA,NA
How to capitalize words in a string using capitalizedString ,"Availability: iOS 2.0 or later.
  
 Swift offers several ways of adjusting the letter case of a string, but if you're looking for title 
 case – that is, Text Where The First Letter Of Each String Is Capitalized - then you need to 
 use the 
 capitalizedString
  property, like this:
  
 let str = ""sunday, monday, happy days"" 
 print(str.capitalizedString)",NA
How to convert a string to lowercase letters ,"Availability: iOS 2.0 or later.
  
 You can convert any string to lowercase – that is, going from ""HELLO"" to ""hello"" – by 
 accessing its 
 lowercaseString
  property, like this:
  
 let str = ""Sunday, Monday, Happy Days"" 
 www.hackingwithswift.com 
  
 1158",NA
How to convert a string to uppercase letters ,"Availability: iOS 2.0 or later.
  
 If you want to convert a string to uppercase – that is, WHERE EVERY LETTER IS A CAPITAL 
 LETTER – you should use the 
 uppercaseString
  property of your string, like this:
  
 let str = ""Sunday, Monday, Happy Days"" 
 print(str.uppercaseString) 
 That code will print ""SUNDAY, MONDAY, HAPPY DAYS"" into the Xcode console.",NA
How to detect a URL in a String using NSDataDetector ,"Availability: iOS 4.0 or later.
  
 The 
 NSDataDetector
  class makes it easy to detect URLs inside a string using just a few 
 lines of code. This example loops through all URLs in a string, printing each one out:
  
 let input = ""This is a test with the URL https://  
 www.hackingwithswift.com to be detected.""  
 let detector = try! NSDataDetector(types:  
 NSTextCheckingType.Link.rawValue)  
 let matches = detector.matchesInString(input, options: [], range: NSMakeRange(0, 
 input.characters.count)) 
 for match in matches { 
  let url = (input as NSString).substringWithRange(match.range) 
 www.hackingwithswift.com 
  
 1159",NA
How to get the length of a string ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1160",NA
How to load a string from a file in your bundle ,"Availability: iOS 2.0 or later.
  
 Although it's preferable to use Swift strings for most operations, there are some things that 
 are just done better by good old 
 NSString
  – not least reading text in from a file. In fact, 
 NSString
  has a constructor just for this purpose, called 
 contentsOfFile
 , and here it is in 
 action:
  
 if let filepath = NSBundle.mainBundle().pathForResource(""example"", ofType: ""txt"") { 
  do { 
   let contents = try NSString(contentsOfFile: filepath,  
 usedEncoding: nil) as String 
   print(contents) 
  } catch { 
   // contents could not be loaded 
  }  
 } else { 
  // example.txt not found! 
 } 
 That code loads a file called 
 example.txt
  into a string called 
 contents
 . Note that I'm 
 typecasting the 
 NSString
  to a regular Swift string so you can use it normally afterwards.
  
 For more information see Hacking with Swift tutorial 1.
  
 www.hackingwithswift.com 
  
 1161",NA
How to load a string from a website URL ,"Availability: iOS 2.0 or later.
  
 It takes just a few lines of Swift code to load the contents of a website URL, but there are 
 three things you need to be careful with:
  
  • Creating a 
 NSURL
  might fail if you pass a bad site, so you need to unwrap its optional 
 return value.
  
  • Koading a URL's contents might fail because the site might be down (for example), so it 
 might throw an error. This means you need to wrap the call into a 
 do/catch
  block.
  
  • Accessing network data is slow, so you really want to do this on a background thread.
  
 Here's the code:
  
 if let url = NSURL(string: ""https://www.hackingwithswift.com"") { do { 
   let contents = try NSString(contentsOfURL: url, usedEncoding: nil) 
   print(contents) 
  } catch { 
   // contents could not be loaded 
  }  
 } else { 
  // the URL was bad! 
 } 
 If you want to run that on a background thread (and you really ought to!) you should either 
 use GCD's 
 dispatch_async()
  or 
 performSelectorInBackground()
 .",NA
How to loop through letters in a string ,"Availability: iOS 7.0 or later.
  
 www.hackingwithswift.com 
  
 1162",NA
How to measure a string ,"Availability: iOS 7.0 or later.
  
 Cunningly, Apple has changed the way you measure strings in Swift three times now, so 
 you'd be forgiven for not knowing how it's done. As of Swift 2, the correct way to measure 
 strings is like this:
  
 let str = ""Hello, world"" 
 let count = str.characters.count",NA
How to parse a sentence using NSLinguisticTagger ,"Availability: iOS 5.0 or later.
  
 If you're looking to parse natural language entered by a user, you're looking for 
  
 NSLinguisticTagger
 : it automatically recognises English words (and words in other 
 languages too, if you ask) and tells you what kind of word it is. That is, this magic little class 
 distinguishes between verbs, nouns, adjectives and so on, so you can focus on the 
  
 www.hackingwithswift.com 
  
 1163",NA
How to repeat a string ,"Availability: iOS 7.0 or later.
  
 Swift strings have a built-in constructor that lets you create strings by repeating a character a 
 certain number of times. You can use it like this:
  
 let str = String(count: 10, repeatedValue: Character(""~"")) 
 If you want to repeat a string rather than just a single character, you'll want to create a 
 function something like this:
  
 extension String { 
  public init?(byRepeatingString str: String, count: Int) { 
  var newString = """" 
  for _ in 0 ..< count { 
 www.hackingwithswift.com 
  
 1165",NA
How to reverse a string using reverse() ,"Availability: iOS 7.0 or later.
  
 Reversing a string in Swift is done by using the 
 reverse()
  method on its characters, then 
 creating a new string out of the result. Here's the code:
  
 let str = ""Hello, world!""  
 let reversed = String(str.characters.reverse()) print(reversed) 
 That will print ""!dlrow ,olleH"" to the Xcode console.",NA
How to split a string into an array: ,NA,NA
componentsSeparatedByString() ,"Availability: iOS 7.0 or later.
  
 You can convert a string to an array by breaking it up by a substring using the 
  
 www.hackingwithswift.com 
  
 1166",NA
How to test localization by setting a debug locale and double ,NA,NA
length pseudolanguage ,"Availability: iOS 2.0 or later.
  
 If you want to check how your app works when running on devices with other languages, you 
 have two options: you can either instruct the simulator to use a specific language where you 
 have a localization in place, or you can have it use a special ""Double length 
  
 pseudolanguage"" that basically acts as a stress test.
  
 Both of these options live under the the scheme settings for your app, which you can get to by 
 holding down Alt then going to the Product menu and clicking ""Run…"" – holding down Alt 
 makes it say ""Run…"" rather than ""Run"", which is what triggers the scheme settings window.
  
 In the scheme settings window, click the dropdown next to Application Language. You can 
 either choose a language that you have localized to, or choose Double Length 
  
 Pseudolanguage. This option effectively makes all your strings take up twice as much space 
 on the screen, which shows you at a glance if your interface will cope with languages that 
 have longer words than your own.",NA
How to trim whitespace in a string ,"Availability: iOS 2.0 or later.
  
 It's not hard to trim whitespace from a string in Swift, but the syntax is a little wordy – or 
  
 www.hackingwithswift.com 
  
 1167",NA
"How to use string interpolation to combine strings, integers ",NA,NA
and doubles ,"Availability: iOS 7.0 or later.
  
 String interpolation is Swift's way of letting you insert variables and constants into strings. 
  
 But at the same time, you can also perform simple operations as part of your interpolation, 
 such as changing letter case and basic mathematics. Swift is also smart enough to 
  
 understand 
 how
  to bring values into strings, meaning that you can use other strings, integers 
 and floating-point numbers just fine.
  
 Here's an example to get you started:
  
 var name = ""Paul"" 
 var age = 35 
 var longestPi = 3.141592654 
 var combined = ""This person's name is \(name.uppercaseString), their age is \(age) so in \(age) 
 years time they'll be \(age + age), and they know π up to \(longestPi)"" 
 www.hackingwithswift.com
  
 1168",NA
NSRegularExpression: How to match regular expressions in ,NA,NA
strings ,"Availability: iOS 4.0 or later.
  
 The 
 NSRegularExpression
  class lets you find and replace substrings using regular 
 expressions, which are concise and flexible descriptions of text. For example, if we wanted 
 to pull ""Taylor Swift"" out of the string ""My name is Taylor Swift"", we could write a regular 
 expression that matches the text ""My name is "" followed by any text, then pass that to the 
 NSRegularExpression
  class.
  
 The example below does just that. Note that we need to pull out the second match range 
 because the first range is the entire matched string, whereas the second range is just the 
 ""Taylor Swift"" part:
  
 do { 
  let input = ""My name is Taylor Swift"" 
  let regex = try NSRegularExpression(pattern: ""My name is (.*)"", options: 
 NSRegularExpressionOptions.CaseInsensitive) 
  let matches = regex.matchesInString(input, options: [], range: NSMakeRange(0, 
 input.characters.count)) 
  if let match = matches.first { 
   let range = match.rangeAtIndex(1) 
   if let swiftRange = rangeFromNSRange(range, forString: input) {  
  
  let name = 
 input.substringWithRange(swiftRange) 
   } 
  }  
 } catch { 
  // regex was bad! 
 } 
 www.hackingwithswift.com
  
 1169",NA
Replacing text in a string using ,NA,NA
stringByReplacingOccurrencesOfString() ,"Availability: iOS 2.0 or later.
  
 It's easy to replace text inside a string thanks to the (exceedingly long!) method 
  
 stringByReplacingOccurrencesOfString()
 . This is a string method, and you tell it what to 
 look for and what to replace it with, and you're done.
  
 For example:
  
 www.hackingwithswift.com 
  
 1170",NA
writeToFile(): How to save a string to a file on disk ,"Availability: iOS 2.0 or later.
  
 All strings have a 
 writeToFile()
  method that lets you save the contents of the string to disk. 
  
 You need to provide a filename to write to, plus two more parameters: whether the write 
 should be atomic, and what string encoding to use. The second parameter should nearly 
 always be 
 true
  because it avoids concurrency problems. The third parameter should nearly 
 always be 
 NSUTF8StringEncoding
 , which is pretty much the standard for reading and 
 writing text.
  
 Be warned: writing a string to disk can throw an exception, so you need to catch any errors 
 and warn the user.
  
 Here's the code:
  
 let str = ""Super long string here""  
 let filename =  
 getDocumentsDirectory().stringByAppendingPathComponent(""output.txt"") 
 do { 
  try str.writeToFile(filename, atomically: true, encoding:  
 NSUTF8StringEncoding)  
 } catch { 
  // failed to write file – bad permissions, bad filename, missing permissions, or more likely it 
 can't be converted to the encoding } 
 www.hackingwithswift.com 
  
 1171",NA
System,NA,NA
How to cache data using NSCache ,"Availability: iOS 4.0 or later.
  
 Here's an easy win for you that will make your apps immediately much better: 
 NSCache
  is a 
 specialized class that behaves similarly to an 
 NSMutableDictionary
  with one major 
 difference: iOS will automatically remove objects from the cache if the device is running low on 
 memory.
  
 Helpfully, if the system does encounter memory pressure 
 NSCache
  will automatically start to 
 remove items without you knowing about it, which means you won't get a memory warning 
 unless even more RAM needs to be cleared. It will also remove items intelligently, trying to 
 keep as much cached as possible.
  
 Here's how to use it, imagining a fictional class called 
 ExpensiveObjectClass
  that you want 
 to compute as infrequently as you can:
  
 www.hackingwithswift.com 
  
 1172",NA
How to copy objects in Swift using copy() ,"Availability: iOS 7.0 or later.
  
 There are two main complex data types in Swift – objects and structs – and they do so many 
 things similarly that you'd be forgiven for not being sure exactly where they differ. Well, one of 
 the key areas is down to copying: two variables can point at the same object so that changing 
 one changes them both, whereas if you tried that with structs you'd find that Swift creates a full 
 copy so that changing the copy does not affect the original.
  
 Having lots of objects point at the same data can be useful, but frequently you'll want to 
 modify 
 copies
  so that modifying one object doesn't have an effect on anything else. To make 
 this work you need to do three things:
  
  • Make your class conform to 
 NSCopying
 . This isn't strictly required, but it makes your 
 intent clear.
  
  • Implement the method 
 copyWithZone()
 , where the actual copying happens. 
 • Call 
 copy()
  on your object.
  
 www.hackingwithswift.com 
  
 1173",NA
How to copy text to the clipboard using UIPasteboard ,"Availability: iOS 3.0 or later.
  
 You can write to and read from the iOS clipboard by using the 
 UIPasteboard
  class, which 
 has a 
 generalPasteboard()
  method that returns the shared system method of copying and 
 pasting data between apps. Using this you can write text to the clipboard just like this:
  
 let pasteboard = UIPasteboard.generalPasteboard() pasteboard.string 
 = ""\(number)"" 
 To read text back from the clipboard, you should unwrap its optional value like this:
  
 let pasteboard = UIPasteboard.generalPasteboard()  
 if let string = pasteboard.string { 
  // text was found and placed in the ""string"" constant }",NA
How to create a peer-to-peer network using the multipeer ,NA,NA
connectivity framework ,"Availability: iOS 7.0 or later.
  
 The 
 MultipeerConnectivity
  framework is designed to allow ad hoc data transfer between 
  
 www.hackingwithswift.com 
  
 1175",NA
How to create rich formatted text strings using ,NA,NA
NSAttributedString ,"Availability: iOS 6.0 or later.
  
 Attributed strings are strings with formatting attached, which means fonts, colors, alignment, 
 line spacing and more. They are supported in many places around iOS, which means you can 
 assign a fully formatted string to a 
 UILabel
  and have it look great with no further work.
  
 Please keep in mind, when working with fonts it's preferable to use Dynamic Type where 
 possible so that a user's font size settings are honored. The example code below creates an 
 attributed string using the ""Headline"" Dynamic Type size, then colors it purple. That is then 
 placed into a 
 UILabel
  by setting its 
 attributedText
  property:
  
 let titleAttributes = [NSFontAttributeName:  
 UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline), 
 NSForegroundColorAttributeName: UIColor.purpleColor()] 
 let titleString = NSAttributedString(string: ""Read all about it!"", attributes: titleAttributes)  
 myLabel.attributedText = titleString 
 www.hackingwithswift.com
  
 1180",NA
How to detect when your app moves to the background ,"Availability: iOS 4.0 or later.
  
 There are two ways to be notified when your app moves to the background: implement the 
 applicationWillResignActive()
  method in your app delegate, or register for the 
  
 UIApplicationWillResignActiveNotification
  notification anywhere in your app. This 
 particular notification is sent as soon as your app loses focus, meaning that it's triggered 
 when the user taps the home button once (to return to the home screen) or double taps the 
 home button (to enter multi-tasking).
  
 If you want to go down the app delegate route, you'll find a stub for 
  
 applicationWillResignActive()
  already in your AppDelegate.swift file. If you want to look for 
 the notification, use this:
  
 override func viewDidLoad() { 
  let notificationCenter = NSNotificationCenter.defaultCenter() 
 notificationCenter.addObserver(self, selector:  
 ""appMovedToBackground"", name:  
 UIApplicationWillResignActiveNotification, object: nil)  
 } 
 func appMovedToBackground() { 
  print(""App moved to background!"")  
 } 
 For more information see Hacking with Swift tutorial 28.",NA
How to detect which country a user is in,"www.hackingwithswift.com 
  
 1181",NA
How to find the user's documents directory ,"Availability: iOS 2.0 or later.
  
 Every iOS app gets a slice of storage just for itself, meaning that you can read and write your 
  
 www.hackingwithswift.com 
  
 1182",NA
How to format dates with an ordinal suffix using ,NA,NA
NSNumberFormatter's OrdinalStyle ,"Availability: iOS 9 or later.
  
 As of iOS 9.0, Apple introduced a simple way to make ordinal style numbers, which is a 
 fancy way of saying 1st, 2nd, 3rd or 100th – the kind of numbers you normally write for 
 dates, for example. This uses the new 
 NSNumberFormatterStyle.OrdinalStyle
  style of 
 writing numbers with 
 NSNumberFormatter
 , like this:
  
 let formatter = NSNumberFormatter()  
 formatter.numberStyle = .OrdinalStyle  
 let first = formatter.stringFromNumber(1)  
 let second = formatter.stringFromNumber(2)  
 let tenth = formatter.stringFromNumber(10)  
 let oneThousandAndFirst = formatter.stringFromNumber(1001) 
 www.hackingwithswift.com
  
 1183",NA
How to generate a random identifier using NSUUID ,"Availability: iOS 6.0 or later.
  
 A UUID is a 
 universally unique identifier
 , which means if you generate a UUID right now using 
 NSUUID
  it's guaranteed to be unique across all devices in the world. This means it's a great 
 way to generate a unique identifier for users, for files, or anything else you need to reference 
 individually – guaranteed.
  
 Here's how to create a UUID as a string:
  
 let uuid = NSUUID().UUIDString",NA
How to generate random numbers in iOS 8 and below ,"Availability: iOS 2.0 or later.
  
 iOS 9.0 introduces Gameplay and its great new random tools, but if you have to support iOS 
 8.0 and earlier here's the code you're looking for:
  
 let randNum = arc4random_uniform(6) 
 That will generate a number between 0 and 5. If you're looking for a random number 
 between any two numbers, try this helper function:
  
 func RandomInt(min min: Int, max: Int) -> Int { 
  if max < min { return min } 
  return Int(arc4random_uniform(UInt32((max - min) + 1))) + min 
 } 
 www.hackingwithswift.com
  
 1184",NA
How to handle the HTTPS requirements in iOS 9 with App ,NA,NA
Transport Security ,"Availability: iOS 9.0 or later.
  
 As of iOS 9.0, you can't work with HTTP web data by default, because it's blocked by 
 something called App Transport Security that effectively requires data to be transmitted 
 securely. If possible, you should switch to HTTPS and use that instead, but if that's not 
 possible for some reason – e.g. if you're working with a third-party website – then you need 
 to tell iOS to make exceptions for you.
  
 Note: the very fact that iOS calls these ""exceptions"" does imply the exception option 
 may go away in the future.
 Exceptions be defined per-site or globally, although if you're going 
 to make exceptions obviously it's preferable to do it for individual sites. This is all set inside 
 your application's Info.plist file, and this is one of the very few times when editing your plist as 
 source code is faster than trying to use the GUI editor in Xcode. So, right-click on your 
 Info.plist and choose Open As > Source Code.
  
 Your plist should end like this:
  
 </dict> 
 </plist> 
 Just before that, I'd like you to paste this:
  
 <key>NSAppTransportSecurity</key> 
 <dict> 
  <key>NSExceptionDomains</key> 
 www.hackingwithswift.com 
  
 1185",NA
How to identify an iOS device uniquely with ,NA,NA
identifierForVendor ,"Availability: iOS 6.0 or later.
  
 Early iOS releases gave every device a unique identifier, but this was soon abused by 
 developers to identify individual users uniquely – something that Apple really dislikes. So, as 
 of iOS 6.0 Apple removed the truly unique identifier and instead introduced an identifier for 
 each vendor: a UUID that's the same for all apps for a given developer for each user, but 
 varies between developers and between devices.
  
 That is, if a user has five of your apps installed and five of mine, your five will all share the 
 same vendor identifier, and my five will all share the same vendor identifier, but our two 
 identifiers will be different.
  
 Here's how to use it:
  
 if let uuid =  
 UIDevice.currentDevice().identifierForVendor?.UUIDString { 
  print(uuid) 
 }",NA
How to make an action repeat using NSTimer ,"Availability: iOS 2.0 or later.
  
 Timers are a great way to run code on a repeating basis, and iOS has the 
 NSTimer
  class to 
 handle it for you. First, create a property of the type 
 NSTimer!
 . For example:
  
 var gameTimer: NSTimer! 
 You can then create that timer and tell it to execute every five seconds, like this:
  
 www.hackingwithswift.com 
  
 1187",NA
How to make tappable links in NSAttributedString ,"Availability: iOS 6.0 or later.
  
 You can make tappable hyperlinks in any attributed string, which in turn means you can add 
 tappable hyperlinks to any UIKit control. If you're working with 
 UITextView
  (which is likely, 
 let's face it), you get basic tappable hyperlink just by enabling the ""Links"" data detector in 
 Interface Builder, but that doesn't work for arbitrary strings – for example, maybe you want the 
 word ""click here"" to tappable.
  
 www.hackingwithswift.com 
  
 1188",NA
How to open a URL in Safari ,"Availability: iOS 2.0 or later.
  
 www.hackingwithswift.com 
  
 1189",NA
How to parse JSON using NSJSONSerialization ,"Availability: iOS 5.0 or later.
  
 The built-in iOS way of parsing JSON is called 
 NSJSONSerialization
  and it can convert a 
 JSON string into a collection of dictionaries, arrays, strings and numbers in just a few lines of 
 code.
  
 In the example below, I create a dummy piece of JSON that contains three names in an array 
 cunningly called ""names"". This then gets sent to 
 NSJSONSerialization
  (via convert it into an 
 NSData
 , which is how 
 NSJSONSerialization
  likes to receive its content), and I conditionally 
 pull out and print the 
 names
  array:
  
 let str = ""{\""names\"": [\""Bob\"", \""Tim\"", \""Tina\""]}"" let data = 
 str.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: 
 false)! 
 do { 
  let json = try NSJSONSerialization.JSONObjectWithData(data, options: []) as! [String: 
 AnyObject] 
  if let names = json[""names""] as? [String] { 
   print(names) 
  } 
 www.hackingwithswift.com 
  
 1190",NA
How to post messages using NSNotificationCenter ,"Availability: iOS 2.0 or later.
  
 iOS notifications are a simple and powerful way to send data in a loosely coupled way. That is, 
 the sender of a notification doesn't have to care about who (if anyone) receives the 
 notification, it just posts it out there to the rest of the app and it could be picked up by lots of 
 things or nothing depending on your app's state.
  
 As a basic example, you might want various parts of your app to do some work when the 
 user logs in – you might want some views to refresh, you might want a database to update 
 itself, and so on. To do this, just post a notification name like this:
  
 let nc = NSNotificationCenter.defaultCenter() 
 nc.postNotificationName(""UserLoggedIn"", object: nil) 
 Note: it is preferable, for type safety, to define your notification names as static strings that 
 belong to a class or struct or other global form so that you don't make a typo and introduce 
 bugs.
  
 www.hackingwithswift.com 
  
 1191",NA
How to read the contents of a directory using NSFileManager ,"Availability: iOS 2.0 or later.
  
 If you want to work with files 
 NSFileManager
  almost certainly has the answer, and it's no 
 different in this case: it has a method called 
 contentsOfDirectoryAtPath()
  that lists all the 
 files in a specific directory. For example, we could have it list all the files in our app's 
 resource directory like this:
  
 let fm = NSFileManager.defaultManager()  
 let path = NSBundle.mainBundle().resourcePath! 
 do { 
  let items = try fm.contentsOfDirectoryAtPath(path) 
  for item in items { 
   print(""Found \(item)"") 
  }  
 } catch { 
  // failed to read directory – bad permissions, perhaps? 
 } 
 In this particular case the 
 try
  should never fail, but you should still have the 
 catch
  block in 
 there just in case.
  
 www.hackingwithswift.com 
  
 1192",NA
How to run code after a delay using dispatch_after() and ,NA,NA
performSelector ,"Availability: iOS 4.0 or later.
  
 There are two ways to run code after a delay using Swift: GCD and 
  
 performSelector(_:withObject:afterDelay:)
 . The first one has some clumsy syntax because 
 you need to specify a time in nanoseconds – most people just use the constant 
  
 NSEC_PER_SEC
  to let them specify seconds instead.
  
 The easiest way to use GCD to run code after a delay is by using a helper function like this 
 one:
  
 func runAfterDelay(delay: NSTimeInterval, block: dispatch_block_t) { let time = 
 dispatch_time(DISPATCH_TIME_NOW, Int64(delay *  
 Double(NSEC_PER_SEC))) 
  dispatch_after(time, dispatch_get_main_queue(), block)  
 } 
 With that function in place you can now use code like this:
  
 runAfterDelay(0.5) { 
  yourCodeHere()  
 } 
 An alternative option is to use 
 performSelector(_:withObject:afterDelay:)
 , which lets you 
 specify a method to call after a certain time has elapsed – and helpfully that time is specified 
 in seconds, which makes it easier to remember!
  
 www.hackingwithswift.com 
  
 1193",NA
How to run code asynchronously using dispatch_async() ,"Availability: iOS 4.0 or later.
  
 iOS gives you two ways to run code asynchronously: GCD and 
 performSelectorInBackground()
 . The first option looks like this:
  
 dispatch_async(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0)) { 
  runSomeCodeHere() 
 } 
 The 
 QOS_CLASS_USER_INITIATED
  quality of service setting is the highest priority after 
 QOS_CLASS_USER_INTERACTIVE
 . You can also use 
 QOS_CLASS_UTILITY
  (lower 
 priority) or 
 QOS_CLASS_BACKGROUND
  (lowest priority.)
  
 The second option looks like this:
  
 performSelectorInBackground(""runSomeCodeHere"", withObject: nil) 
 You'll need to replace ""runSomeCodeHere"" with the name of an actual method. If you want 
 to pass a parameter, make sure and use ""runSomeCodeHere:"" and provide a value for the 
 withObject
  parameter.
  
 For more information see Hacking with Swift tutorial 9.
  
 www.hackingwithswift.com 
  
 1194",NA
How to run code at a specific time ,"Availability: iOS 2.0 or later.
  
 You can use 
 performSelector(_:withObject:afterDelay:)
  to run a method after a certain 
 number of seconds have passed, but if you want to run code at a specific time – say at 
 exactly 4pm – then you should use 
 NSTimer
  instead. This class is great for executing code 
 repeatly at a specific time interval, but it's also great for running code at an exact time that 
 you specify.
  
 This is accomplished using an 
 NSTimer
  constructor that accepts an 
 NSDate
  for when the 
 timer should fire. You can make this date however you want, which is what makes this 
 approach so flexible.
  
 As a simple example, this will create a timer that calls a 
 runCode()
  method in five seconds:
  
 let date = NSDate().dateByAddingTimeInterval(5) 
 let timer = NSTimer(fireDate: date, interval: 0, target: self, selector: ""runCode"", userInfo: 
 nil, repeats: false) 
 NSRunLoop.mainRunLoop().addTimer(timer, forMode: 
 NSRunLoopCommonModes) 
 Notice how you can specify a 
 interval
  parameter? That's for when you set 
 repeats
  to be 
 true
 . 
 If you have an 
 NSDate
  5 seconds from now and an 
 interval
  of 1 (after setting 
 repeat
  to be 
 true!), it means ""call 
 runCode()
  after five seconds, then every one second after that.""",NA
How to run code on the main thread using dispatch_async() ,"Availability: iOS 4.0 or later.
  
 Swift offers you two ways to run code on the main thread: GCD and 
 performSelectorOnMainThread
 . The first option looks like this:
  
 dispatch_async(dispatch_get_main_queue()) { 
 www.hackingwithswift.com 
  
 1195",NA
How to save and load objects with NSKeyedArchiver and ,NA,NA
NSKeyedUnarchiver ,"Availability: iOS 2.0 or later.
  
 You can write any kind of object to disk as long as it supports the 
 NSCoding
  protocol – 
 which includes strings, arrays, dictionaries, 
 UIView
 , 
 UIColor
  and more right out of the box. 
  
 To write to disk, use this:
  
 let data = NSKeyedArchiver.archivedDataWithRootObject(self) let filename =  
 getDocumentsDirectory().stringByAppendingPathComponent(uuid) 
 data.writeToFile(filename, atomically: true) 
 That call to 
 getDocumentsDirectory()
  is a small helper function I frequently use to write files 
 to disk:
  
 www.hackingwithswift.com 
  
 1196",NA
How to save user settings using NSUserDefaults ,"Availability: iOS 2.0 or later.
  
 All iOS apps have a built in data dictionary that stores small amounts of user settings for as 
 long as the app is installed. This system, called 
 NSUserDefaults
  can save integers, booleans, 
 strings, arrays, dictionaries, dates and more, but you should be careful not to save too much 
 data because it will slow the launch of your app.
  
 Here's an example of setting some values:
  
 let defaults = NSUserDefaults.standardUserDefaults() 
 defaults.setInteger(25, forKey: ""Age"") 
 www.hackingwithswift.com 
  
 1197",NA
How to set local alerts using UILocalNotification ,"Availability: iOS 8.0 or later.
  
 Local notifications are messages that appear on the user's lock screen when your app isn't 
 running. The user can then swipe to unlock their device and go straight to your app, at which 
 point you can act on the notification.
  
 As you might imagine, you need to ask for permission in order to show messages on the lock 
 screen. Here's how that's done:
  
 let notificationSettings =  
 UIUserNotificationSettings(forTypes: .Alert | .Badge | .Sound, categories: nil) 
 UIApplication.sharedApplication().registerUserNotificationSettings(no tificationSettings) 
 www.hackingwithswift.com
  
 1199",NA
How to spell out numbers using NSNumberFormatter's ,NA,NA
SpellOutStyle ,"Availability: iOS 2.0 or later.
  
 iOS makes it easy to convert numbers like 10 or 100 into their written equivalents: ""ten"" and 
 ""one hundred"", and it even handles other languages. For example, to convert the number 556 
 into ""five hundred fifty-six"", you would use this code:
  
 let formatter = NSNumberFormatter()  
 formatter.numberStyle = NSNumberFormatterStyle.SpellOutStyle let english = 
 formatter.stringFromNumber(556) 
 If you wanted to get that in Spanish, you would set a locale like this:
  
 formatter.locale = NSLocale(localeIdentifier: ""es_ES"") let spanish = 
 formatter.stringFromNumber(556) 
 www.hackingwithswift.com
  
 1202",NA
How to stop the screen from going to sleep ,"Availability: iOS 2.0 or later.
  
 You can stop the iOS screen sleeping by using the 
 idleTimerDisabled
  property of your 
 application. When set to true, this means the screen will never dim or go to sleep while your 
 app is running, so be careful – you don't want to waste your user's battery life!
  
 Here's an example:
  
 UIApplication.sharedApplication().idleTimerDisabled = true",NA
How to store NSUserDefaults options in iCloud ,"Availability: iOS 5.0 or later.
  
 iOS has a built-in iCloud sync system called 
 NSUbiquitousKeyValueStore
 , but to be honest 
 it's pretty unpleasant to work with. Fortunately, other developers have written simple wrappers 
 around it so that you can forget about iCloud and focus on the interesting things instead – i.e., 
 the rest of your app.
  
 One such example is called 
 MKiCloudSync
  and it's 
 available from here
 . It's open source 
 and so easy to use you literally don't notice that it's there once you've added it to your app – it 
 just silently syncs your 
 NSUserDefaults
  values to and from iCloud.
  
 To use it, 
 go here
  and click Download Zip. Inside the zip file you'll find 
 MKiCloudSync.h
  and 
 MKiCloudSync.m
 , and you should drag them both into your Xcode project. Xcode will ask 
 you if you want to create an Objective-C bridging header, and you should click ""Create 
 Bridging Header"" - this is required because MKiCloudSync is written in Objective-C rather 
 than Swift.
  
 To actually use the library, open your new bridging header (it'll be called something like 
  
 www.hackingwithswift.com 
  
 1203",NA
How to synchronize code to drawing using CADisplayLink ,"Availability: iOS 3.1 or later.
  
 Lots of beginners think 
 NSTimer
  is a great way to handle running apps or games so that 
 update code is executed every time the screen is redrawn. Their logic is simple: update the 
 app every 60th of a second and you're perfectly placed for smooth redraws. The problem is, 
 they are forgetting that 
 NSTimer
  doesn't offer precise firing and can drift earlier or later than 
 requested updates, and also has no idea about screen redraws and so could happily fire 
 10ms after a screen redraw just happened – and when you're working to 16.666ms frames, 
 10ms is a long time!
  
 A smarter and faster solution is the 
 CADisplayLink
  class, which automatically calls a method 
 you define as soon as a screen redraw happens, so you always have maximum time to execute 
 your update code. It's extremely simple to use – here's an example to get you started:
  
 www.hackingwithswift.com 
  
 1204",NA
How to use Core Motion to read accelerometer data ,"Availability: iOS 4.0 or later.
  
 Core Motion makes it ridiculously easy to read the accelerometer from iPhones and iPads, 
 and it even takes care of managing how the accelerometer and gyroscope work together to 
 report orientation. To get started import the Core Motion framework like this:
  
 import CoreMotion 
 Now create a property that can store a 
 CMMotionManager
 , like this:
  
 var motionManager: CMMotionManager! 
 When you're ready to start reading accelerometer data (this will be inside 
 viewDidLoad()
  for 
 most people), go ahead and create your motion manager then call its 
  
 startAccelerometerUpdates()
  method:
  
 www.hackingwithswift.com 
  
 1205",NA
How to use Core Spotlight to index content in your app ,"Availability: iOS 9.0 or later.
  
 One particularly popular feature in iOS 9.0 is the ability to have your app's content appear 
 inside the iOS Spotlight search so that users can search it alongside their other device 
 content.
  
 First up, add these two imports to your class:
  
 import CoreSpotlight  
 import MobileCoreServices 
 www.hackingwithswift.com
  
 1206",NA
How to use Touch ID to authenticate users by fingerprint ,"Availability: iOS 8.0 or later.
  
 Touch ID is an easy and secure way for users to authenticate themselves, so its no surprise 
 that it's caught on so quickly among apps. Authenticating with Touch ID automatically uses the 
 fingerprints registered by the user when they set up Touch ID, and you never have access to 
 those fingerprints, which means it's both low-friction and extra-secure.
  
 To get started, you need to import the LocalAuthentication framework like this:
  
 import LocalAuthentication 
 The actual act of authenticating users has a number of possible results, and you need to 
 catch them all:
  
  • The user might not have a Touch ID-capable device.
  
  • The user might have a Touch ID-capable device, but might not have configured it. • 
 The user might hit cancel when asked to authenticate.
  
  • The user might ask to enter a passcode rather than use Touch ID.
  
 The first three are easily handled just by showing a message with useful information, but the 
 last one is a quirk of Touch ID: Apple insists that your app provide a passcode method of 
 authentication as a back up. More annoyingly, you need to request and store this passcode 
 yourself – it's not even done by Apple using the system unlock code!
  
 Asking for and setting a passcode is easy enough, so I'll leave that to you. The important bit is 
 asking for Touch ID authentication, which is done using this code:
  
 func authenticateUser() { 
  var context = LAContext() 
 www.hackingwithswift.com 
  
 1209",NA
NSTextEffectLetterpressStyle: How to add a letterpress effect to ,NA,NA
text ,"Availability: iOS 7.0 or later.
  
 You can add a subtle embossing effect to any text in your app using 
 NSAttributedString
  and 
 NSTextEffectLetterpressStyle
 . As an example, this code creates an attributed string using 24-
 point Georga Bold in red, with Apple's letterpress effect applied, then writes it into a label:
  
 let attrs = [NSForegroundColorAttributeName: UIColor.redColor(), NSFontAttributeName: 
 UIFont(name: ""Georgia-Bold"", size: 24)!, NSTextEffectAttributeName: 
 NSTextEffectLetterpressStyle] 
 let string = NSAttributedString(string: ""Hello, world!"", attributes: attrs) 
 www.hackingwithswift.com 
  
 1211",NA
UIColor,NA,NA
How to convert a HTML name string into a UIColor ,"Availability: iOS 2.0 or later.
  
 HTML color names let you use familiar titles like ""steel blue"" and ""mint cream"" rather than 
 hex values, but sadly these standardised names aren't available in iOS – or at least not by 
 default. Fortunately, it's easy to add an extension to 
 UIColor
  that maps these names to 
 hexadecimal color values, then add another extension to convert hex colors to 
 UIColors
 . 
  
 Here's the code:
  
 extension UIColor { 
  public convenience init?(hexString: String) {  let r, g, b, a: CGFloat 
  if hexString.hasPrefix(""#"") { 
  let start = hexString.startIndex.advancedBy(1) let hexColor = 
 hexString.substringFromIndex(start) 
  if hexColor.characters.count == 8 { 
  let scanner = NSScanner(string: hexColor) var hexNumber: 
 UInt64 = 0 
  if scanner.scanHexLongLong(&hexNumber) { 
  r = CGFloat((hexNumber & 0xff000000) >> 24) / 255 g = 
 CGFloat((hexNumber & 0x00ff0000) >> 16) / 255 
 www.hackingwithswift.com 
  
 1212",NA
How to convert a hex color to a UIColor ,"Availability: iOS 2.0 or later.
  
 Here's a simple extension to 
 UIColor
  that lets you create colors from hex strings. The new 
 method is a failable initializer, which means it returns nil if you don't specify a color in the 
 correct format. It should be a # symbol, followed by red, green, blue and alpha in hex format, 
 for a total of nine characters. For example, #ffe700ff is gold.
  
 Here's the code:
  
 extension UIColor { 
  public convenience init?(hexString: String) {  let r, g, b, a: CGFloat 
  if hexString.hasPrefix(""#"") { 
  let start = hexString.startIndex.advancedBy(1) let hexColor = 
 hexString.substringFromIndex(start) 
  if hexColor.characters.count == 8 { 
  let scanner = NSScanner(string: hexColor) var hexNumber: 
 UInt64 = 0 
  if scanner.scanHexLongLong(&hexNumber) { 
  r = CGFloat((hexNumber & 0xff000000) >> 24) / 255 g = 
 CGFloat((hexNumber & 0x00ff0000) >> 16) / 255 b = 
 CGFloat((hexNumber & 0x0000ff00) >> 8) / 255 a = 
 CGFloat(hexNumber & 0x000000ff) / 255 
  self.init(red: r, green: g, blue: b, alpha: a) return 
 www.hackingwithswift.com 
  
 1219",NA
How to create custom colors using UIColor RGB and hues ,"Availability: iOS 2.0 or later.
  
 Although there are quite a few built-in UIColors, you'll want to create your own very 
 frequently. This can be done in a number of ways, but the most common is specifying 
 individual vaues for red, green, blue and alpha, like this:
  
 let col1 = UIColor(red: 1, green: 0, blue: 0, alpha: 1) 
 Each of those numbers need to be between 0 and 1.
  
 An alternative way is to specify color values as hue, saturation and brightness, or HSB. Hue is 
 a value between 0 and 1 on a color wheel, where 0 and 1 are both red. Saturation is how 
 deep the color should be (so 0 is just gray) and brightness is how light the shade should be.
  
 www.hackingwithswift.com 
  
 1220",NA
UIKit,NA,NA
Changing which UITabBarController tabs can be edited ,"Availability: iOS 2.0 or later.
  
 If you have a More tab in your tab bar controller, this will automatically get an Edit button so 
 that users can drag tabs around to customize the user interface. This doesn't actually save 
 the tab ordering for you, which means the tabs will revert on next run unless you persist the 
 user's choices yourself, but it does do everything else for you.
  
 By default, users can move any and all tabs, but if you want to force some tabs to be in place 
 you should set the 
 customizableViewControllers
  property of your tab bar controller. This 
 should be an array of the view controllers you want to give your users access to edit, or an 
 empty array if you want the Edit button to go away entirely.
  
 If your tab bar controller is your window's root view controller (for example, if you started with 
  
 www.hackingwithswift.com 
  
 1221",NA
How set different widths for a UISegmentedControl's ,NA,NA
elements ,"Availability: iOS 5.0 or later.
  
 Segmented controls give each segment equal width by default, which is aesthetically 
 pleasing when you have space to spare but technically irritating when space is tight. Rather 
 than try to squash too much into a small space, you have two options: set custom segment 
 widths, or ask iOS to size them individually for you.
  
 The first option looks like this:
  
 segmentedControl.setWidth(100, forSegmentAtIndex: 0) 
 segmentedControl.setWidth(50, forSegmentAtIndex: 1) 
 www.hackingwithswift.com 
  
 1222",NA
How to add Retina and Retina HD graphics to your project ,"Availability: iOS 8.0 or later.
  
 iOS has a simple, beautiful solution for handling Retina and Retina HD graphics, and in fact it 
 does almost all the work for you – all you have to do is name your assets correctly.
  
 Imagine you have an image called taylor.png, which is 100x100 pixels in size. That will look 
 great on non-Retina devices, which means iPad 2 and the first-generation iPad Mini. If you 
 want it to look great on Retina devices (which means iPad 3, 4, Air, Air 2, Mini 2 and Mini 3, 
 plus iPhone 4s, 5, 5s, and 6) you need to provide a second image called taylor@2x.png that 
 is 200x200 pixels in size – i.e., exactly twice the width and height.
  
 Retina HD devices – at the time of writing that's just the iPhone 6 Plus – have an even higher 
 resolution, so if you want your image to look great there you should provide a third image 
 called taylor@3x.png that is 300x300 pixels in size – i.e., exactly three times the width and 
 height of the original.
  
 If you're not using an asset catalog, you can just drag these images into your project to have 
 iOS use them. If you are using an asset catalog, drag them into your asset catalog and you 
 should see Xcode correctly assign them to 1x, 2x and 3x boxes for the image. 
 It's critical you 
 name the files correctly
  because that's what iOS uses to load the correct resolution.
  
 With that done, you just need to load taylor.png in your app, and iOS will automatically load 
 the correct version of it depending on the user's device.
  
 www.hackingwithswift.com 
  
 1223",NA
How to add a UITextField to a UIAlertController ,"Availability: iOS 8.0 or later.
  
 The 
 UIAlertController
  class from iOS 8.0 lets you add as many text fields as you need, and 
 you can read the value of those text fields when the user taps a button.
  
 The example below creates an alert controller with one button and a text field. When the 
 button is tapped, the text of the text field is pulled out, at which point it's down to you to do 
 something interesting with it:
  
 func promptForAnswer() { 
  let ac = UIAlertController(title: ""Enter answer"", message: nil, preferredStyle: .Alert) 
  ac.addTextFieldWithConfigurationHandler(nil) 
  let submitAction = UIAlertAction(title: ""Submit"",  
 style: .Default) { [unowned self, ac] (action: UIAlertAction!) in 
  
  let answer = 
 ac.textFields![0] as! UITextField 
  
  
  // do something interesting with ""answer"" here 
  } 
  ac.addAction(submitAction) 
  presentViewController(ac, animated: true, completion: nil) } 
 For more information see Hacking with Swift tutorial 5.",NA
How to add a bar button to a navigation bar,"www.hackingwithswift.com 
  
 1224",NA
How to add a button to a UITableViewCell ,"Availability: iOS 2.0 or later.
  
 www.hackingwithswift.com 
  
 1225",NA
How to add a custom view to a UIBarButtonItem ,"Availability: iOS 2.0 or later.
  
 Most 
 UIBarButtonItems
  contain either an icon or some text, but they can do so much more – 
 in fact, you can embed any kind of 
 UIView
  subclass inside a bar button item, then put that 
 button into a navigation bar or toolbar as you normally would.
  
 For example, you can create a 
 UIProgressView
  and place it into a bar button like this:
  
 var progressView = UIProgressView(progressViewStyle: .Default) 
 progressView.sizeToFit() 
 let progressButton = UIBarButtonItem(customView: progressView) 
 www.hackingwithswift.com
  
 1226",NA
How to add a flexible space to a UIBarButtonItem ,"Availability: iOS 2.0 or later.
  
 There's a special kind of 
 UIBarButtonItem
  called 
 FlexibleSpace
 , and this acts like a spring 
 between other buttons, pushing them to one side. A flexible space will always expand to take 
 up as much room as possible, splitting space evenly between other flexible spaces if they exist.
  
 For example, if you add this button to a toolbar, it will sit on the left edge of the toolbar:
  
 let refresh = UIBarButtonItem(barButtonSystemItem: .Refresh, target: self, action: 
 ""refreshTapped"") 
 If you create and add a flexible space first, then that button will be pushed to the right edge 
 as the flexible space expands to take up most of the toolbar. Here's how you create the 
 flexible space:
  
 let spacer = UIBarButtonItem(barButtonSystemItem: .FlexibleSpace, target: nil, action: nil) 
 For more information see Hacking with Swift tutorial 4.",NA
How to add a section header to a table view ,"Availability: iOS 2.0 or later.
  
 You can use the built-in iOS table section headers by returning a value from 
 titleForHeaderInSection
  like this:
  
 override func tableView(tableView: UITableView,  
 www.hackingwithswift.com 
  
 1227",NA
How to add a shadow to a UIView ,"Availability: iOS 3.2 or later.
  
 iOS can dynamically generate shadows for any 
 UIView
 , and these shadows automatically 
 adjust to fit the shape of the item in question – even following the curves of text inside a 
 UILabel
 . This functionality is built right in, so all you need to do is configure its properties, 
 and there are four you need to care about:
  
  • 
 shadowColor
  sets the color of the shadow, and needs to be a 
 CGColor
 .
  
  • 
 shadowOpacity
  sets how transparent the shadow is, where 0 is invisible and 1 is as strong 
 as possible.
  
  • 
 shadowOffset
  sets how far away from the view the shadow should be, to give a 3D offset 
 effect.
  
  • 
 shadowRadius
  sets how wide the shadow should be.
  
 Here's a simple example to get you started:
  
 www.hackingwithswift.com 
  
 1228",NA
How to add blur and vibrancy using UIVisualEffectView ,"Availability: iOS 8.0 or later.
  
 As of iOS 8.0, visual effects such as blur and vibrancy are a cinch because Apple provides a 
 built in 
 UIView
  subclass that does all the hard work: 
 UIVisualEffectView
 . For example, if you 
 want to blur an image, you would use this code:
  
 let imageView = UIImageView(image: UIImage(named: ""example"")) imageView.frame 
 = view.bounds  
 imageView.contentMode = .ScaleToFill  
 view.addSubview(imageView) 
 www.hackingwithswift.com 
  
 1229",NA
How to add iAd to a view controller ,"Availability: iOS 4.0 or later.
  
 There are three ways to add iAd to an app. Helpfully, their use cases are pretty clear because 
 the easiest option give you no control, the hardest option gives you lots of control, and the 
 middle option gives you as much control as you want.
  
 First, the easiest option – put this into your view controller:
  
 canDisplayBannerAds = true 
 You will need to import the iAd framework to make that compile correctly. Yes, that's all it 
 takes to get iAd banners showing in your view. If you don't mind not being able to have 
 control over when adverts show or where they should go, then you're basically done.
  
 The second option is to place an iAd inside Interface Builder. This gives you more control 
 because now you can place it where you want it (within reason – Apple does have rules!), you 
 can attach Auto Layout constraints, you can configure its delegate, and so on.
  
 While that second option is good, you really need to at least know the third option in order to 
 make use of it: making the iAd entirely in code. To make this work you need to create a 
 property to store the banner view, like this:
  
 var bannerView: ADBannerView! 
 Creating a banner view isn't complicated, but you should take care to give it good Auto Layout 
 constraints. This is particularly important when it comes to taking action if there is no banner 
 to show – is hiding the banner view enough, or do you need to change other constraints too?
  
 In the most simple case you can configure an iAd banner in code like this:
  
 www.hackingwithswift.com 
  
 1231",NA
How to adjust a UIScrollView to fit the keyboard ,"Availability: iOS 2.0 or later.
  
 If your user interface brings up the keyboard, you should respond by adjusting your layout so 
 that all parts are still visible. If you're using a 
 UIScrollView
  or any classes that have a scroll 
 view as part of their layout (table views and text views, for example), this means adjusting the 
 contentInset
  property to account for the keyboard.
  
 First you need to register for keyboard change notifications. Put this into your 
 viewDidLoad() 
 method:
  
 let notificationCenter = NSNotificationCenter.defaultCenter() 
 notificationCenter.addObserver(self, selector: ""adjustForKeyboard:"", name: 
 UIKeyboardWillHideNotification, object: nil) 
 notificationCenter.addObserver(self, selector: ""adjustForKeyboard:"", name: 
 UIKeyboardWillChangeFrameNotification, object: nil) 
 Now add this method somewhere else in your class:
  
 func adjustForKeyboard(notification: NSNotification) { 
  let userInfo = notification.userInfo! 
  let keyboardScreenEndFrame =  
 (userInfo[UIKeyboardFrameEndUserInfoKey] as! NSValue).CGRectValue() 
  let keyboardViewEndFrame =  
 view.convertRect(keyboardScreenEndFrame, fromView: view.window) 
  if notification.name == UIKeyboardWillHideNotification { 
 www.hackingwithswift.com 
  
 1233",NA
"How to adjust image content mode using aspect fill, aspect fit and ",NA,NA
scaling ,"Availability: iOS 2.0 or later.
  
 All views (including those that don't hold images) have a content mode that affects the way 
 they draw their content. The default is 
 Scale To Fill
  because it's fastest: the contents of the 
 view just get stretched up (or down) to fit the space available. But there are two others that 
 you'll be using a lot: Aspect Fit and Aspect Fill.
  
 ""Aspect Fit"" means ""stretch this image up as large as it can go, but make sure that all the 
 image is visible while keeping its original aspect ratio."" This is useful when you want an 
 image to be as large as possible without stretching its proportions, and it's probably the 
 most commonly used content mode.
  
 www.hackingwithswift.com 
  
 1234",NA
How to animate views using animateWithDuration() ,"Availability: iOS 4.0 or later.
  
 Animation in iOS is done by starting an animation block, then telling iOS what changes you 
 want to make. Because the animation block is active, those changes won't happen straight 
 away – instead, iOS will execute them smoothly over the time you specified, so you don't 
 have to worry when it will finish or what all the intermediate states are.
  
 Here's a basic example to make a view fade out:
  
 UIView.animateWithDuration(1) { 
  viewToAnimate.alpha = 0 
 } 
 If you want to remove the view from its superview once the fade has finished, you can use a 
 more advanced version of the same method that gives you a completion block – a closure that 
 will be run once the animation finishes. Here's how that looks:
  
 UIView.animateWithDuration(1, animations: { 
  viewToAnimate.alpha = 0 
 }) { _ in 
  viewToAnimate.removeFromSuperview() 
 } 
 www.hackingwithswift.com
  
 1235",NA
How to animate views with spring damping using ,NA,NA
animateWithDuration() ,"Availability: iOS 7.0 or later.
  
 Spring animations work by changing from a start state to an end state, with a slight 
  
 overshoot and bounce at the end. For example, if you want to animate a view moving from X 0 
 to X 100, it might move to X 120 before bouncing back to X 80, then X 110 and finally X 100, 
 as if the animation were attached to a spring.
  
 Spring animations are built into iOS as of iOS 7.0 and require two values: how ""springy"" the 
 spring should be, and how fast it should start. The first value is specified with 
  
 usingSpringWithDamping
 , where higher values make the bouncing finish faster. The second 
 value is specified with 
 initialSpringVelocity
 , where higher values give the spring more initial 
 momentum.
  
 Here's the code to make a view fade out, then fade it the tiniest bit, then fade out again – all 
 done using a spring animation:
  
 UIView.animateWithDuration(1, delay: 1, usingSpringWithDamping: 0.5, initialSpringVelocity: 5, 
 options: .CurveEaseInOut, animations: { 
  viewToAnimate.alpha = 0 
 }) { _ in 
 www.hackingwithswift.com 
  
 1236",NA
How to animate when your size class changes: ,NA,NA
willTransitionToTraitCollection() ,"Availability: iOS 8.0 or later.
  
 A size class change is usually triggered by your user rotating their device, but it can also 
 happen for example when using the new iOS 9.0 multitasking to adjust window splits. Your UI 
 needs to look great in all size classes it supports, which means you either create multiple 
 variations of your layouts inside Interface Builder (this is the preferred route) or you make 
 changes in code.
  
 More often than not, I find myself mixing approaches: I do the vast majority of work inside IB, 
 then make minor changes by hand inside the 
 willTransitionToTraitCollection()
  method. When 
 this is called, you'll be given a 
 UIViewControllerTransitionCoordinator
  object (yes, that's an 
 extremely long name!) to work with, which allows you to animate your changes as needed.
  
 To give you a very visible demonstration of how this works, I've written some example code 
 below that adjusts the background color of the current view. 
 You should run this using the 
 iOS simulator using an iPhone.
  The reason that this requires the iPhone simulator rather 
 than the iPad simulator is that iPads have the same size classes in portrait and landscape, 
 which makes the changes harder to spot.
  
 Anyway, put this code into a view controller, then try it on an iPhone. When you rotate the 
 simulator, the screen will change between red and blue, or green and blue, depending on the 
 rotation. The important thing is that the change is animated because it's placed inside a call to 
 animateAlongsideTransition()
 , which automatically makes your animation match the rotation 
 animation.
  
 Using this method requires two closures: the first is where you make the changes you want to 
 animate, and the second is code to be run when the animation completes. So, when the new 
 vertical size class is compact, the screen will animate from blue to red, then jump back to 
 blue. I realise this isn't directly useful in your own apps, but that's because you'll want to 
  
 www.hackingwithswift.com 
  
 1237",NA
How to bring a subview to the front of a UIView ,"Availability: iOS 2.0 or later.
  
 UIKit draws views back to front, which means that views higher up the stack are drawn on top 
 of those lower down. If you want to bring a subview to the front, there's a method just for you: 
 bringSubviewToFront()
 . Here's an example:
  
 parentView.bringSubviewToFront(childView) 
 This method can also be used to bring any subview to the front, even if you're not sure where it 
 is:
  
 childView.superview.bringSubviewToFront(childView) 
 www.hackingwithswift.com
  
 1238",NA
How to change the scroll indicator inset for a UIScrollView ,"Availability: iOS 2.0 or later.
  
 It's common to adjust content insets of a scroll view or any class that embeds one (table view, 
 text view, etc) so that you control the scrolling mechanism precisely, but whenever you 
 change the content inset it's a good idea also to change the scroll indicator inset: the visual 
 indicator bar on the right that shows users how far they have left to scroll.
  
 Changing this value adds a tiny bit of UI polish and it's easy to do:
  
 scrollView.scrollIndicatorInsets = UIEdgeInsets(top: 30, left: 0, bottom: 0, right: 10)",NA
How to check a string is spelled correctly using ,NA,NA
UITextChecker ,"Availability: iOS 3.2 or later.
  
 You can draw on the iOS dictionary in just a few lines of code thanks to the 
 UITextChecker 
 class. Tell it the range of the string you want to check (this could be the whole string or just 
 part of it), then ask it to tell you where the spelling error is. If it says there are no errors, the 
 word is good. Here's the code:
  
 func wordIsReal(word: String) -> Bool { 
  let checker = UITextChecker() 
  let range = NSMakeRange(0, word.characters.count) 
  let misspelledRange = checker.rangeOfMisspelledWordInString(word, range: range, startingAt: 
 0, wrap: false, language: ""en"") 
  return misspelledRange.location == NSNotFound 
 } 
 www.hackingwithswift.com 
  
 1239",NA
How to convert a CGPoint in one UIView to another view ,NA,NA
using convertPoint() ,"Availability: iOS 2.0 or later.
  
 Each view has its own co-ordinate system, meaning that if I tap a button and ask iOS where I 
 tapped, it will tell me where I tapped 
 relative to the top-left of the button
 . This is usually what 
 you want, but if you want to translate a position in one view into a position it's easy enough to 
 do.
  
 As an example, this code creates two views, creates a virtual ""tap"", then converts it from the 
 first view's co-ordinate space to the second's:
  
 let view1 = UIView(frame: CGRect(x: 50, y: 50, width: 128, height: 128)) 
 let view2 = UIView(frame: CGRect(x: 200, y: 200, width: 128, height: 128)) 
 let tap = CGPoint(x: 10, y: 10) 
 let convertedTap = view1.convertPoint(tap, toView: view2) 
 That will set 
 convertedTap
  to X -140.0, Y -140.0.",NA
How to create Auto Layout constraints in code: ,NA,NA
constraintsWithVisualFormat(),"www.hackingwithswift.com 
  
 1240",NA
How to create a page curl effect using UIPageViewController ,"Availability: iOS 5.0 or later.
  
 When iBooks first launched in iOS 3.2, its page curl effect was almost addictive: it moved so 
 fluently with your finger that it felt you were touching real paper. From iOS 5.0 on this page curl 
 effect is available for every developer as part of the 
 UIPageViewController
  class. Its API isn't 
 immediately obvious to newbies, though, so I'm going to give you a complete example.
  
 In the code below, the page view controller is created in 
 viewDidLoad()
 . I also create five 
 UIViewControllers
  to serve as pages inside the app, then tell the page view controller to start 
 with the first one. I put in a couple of helper methods so that the view controllers could have 
 random background colors so you can see it all working.
  
 Most of the work is done by the 
 viewControllerBeforeViewController
  and 
  
 viewControllerAfterViewController
  methods, which must either return a view controller to 
 show before or after the current one (when the users starts to turn the page) or 
 nil
  to mean 
 the user is at the end and there are no more pages to show in that direction.
  
 To make this work in your own app, you'll obviously want to replace the plain view controller 
  
 www.hackingwithswift.com 
  
 1243",NA
How to create a parallax effect in UIKit ,"Availability: iOS 7.0 or later.
  
 Parallax effects have been standard since iOS 7.0, and the 
 UIInterpolatingMotionEffect 
 class makes this easy by automatically smoothing accelerometer input so your views can 
 adjust to tilt data.
  
 If you want to have a 
 UIView
  respond to tilting, add this function to your code then call it on 
 any view you want:
  
 func addParallaxToView(vw: UIView) { 
  let amount = 100 
  let horizontal = UIInterpolatingMotionEffect(keyPath: ""center.x"",  
 www.hackingwithswift.com 
  
 1246",NA
How to create custom menus using UIMenuController ,"Availability: iOS 3.0 or later.
  
 iOS has a built-in menu system that, while 
 useful
 , doesn't actually get much 
 use
  – because 
 users don't expect to see it, developers don't use it, thus making it even less likely that users 
 expect to see it.
  
 Anyway, if you want to attach multiple actions to elements in your UI – pieces of text in a text 
 view or web view, table view rows, and so on – you might find iOS menus are for you, so you 
 need to turn to 
 UIMenuController
 . This has extremely simple API: you just create a 
  
 UIMenuItem
  object for every action you want, then register them all and wait for the user to 
 do something.
  
 Below is a complete example for a view controller that has a web view inside it – you'll need to 
 create that in your storyboard. The code sets up a new menu item named ""Grok"" that runs the 
 runGrok()
  method when tapped. I've made it do something real: when the user selects some 
 text, they tap Grok to have that printed out to the Xcode console.
  
 www.hackingwithswift.com 
  
 1247",NA
How to create popover menus using ,NA,NA
UIPopoverPresentationController ,"Availability: iOS 8.0 or later.
  
 Show a 
 UIAlertController
  action sheet on iPad isn't as easy as on iPhone. The reason for 
 this is simple: on iPhone the action sheet slides up from the bottom, effectively owning the 
 user's attention until it's dismissed, whereas on iPad it could be shown from anywhere. In 
 fact, if you just try and show one on an iPad like this, your app crashes:
  
 let ac = UIAlertController(title: ""Hello!"", message: ""This is a test."", preferredStyle: 
 .ActionSheet) 
 presentViewController(ac, animated: true, completion: nil) 
 The solution is to use a 
 UIPopoverPresentationController
 , which gets created for you when 
 you try to access the 
 popoverPresentationController
  property of a 
 UIAlertController
 . With 
 this, you can tell it where to show from (and what view those coordinates relate to) before 
 presenting the action sheet, which makes it work correctly on iPad.
  
 To rewrite the previous lines so they work, you'd do this:
  
 let ac = UIAlertController(title: ""Hello!"", message: ""This is a test."", preferredStyle: 
 .ActionSheet) 
 let popover = ac.popoverPresentationController 
 popover?.sourceView = view 
 popover?.sourceRect = CGRect(x: 32, y: 32, width: 64, height: 64) 
 presentViewController(ac, animated: true, completion: nil)",NA
How to customize swipe edit buttons in a UITableView ,"Availability: iOS 8.0 or later.
  
 www.hackingwithswift.com 
  
 1249",NA
How to deselect a UITableViewCell using ,NA,NA
clearsSelectionOnViewWillAppear ,"Availability: iOS 3.2 or later.
  
 When a user taps a table view row, it automatically gets highlighted by iOS, and frequently we 
 use that action to show another view controller with more detailed information. When the user 
 goes back, though, you probably want their selection to go away so that it doesn't remain 
 selected, and if you're using a 
 UITableViewController
  that's easy to do with 
 clearsSelectionOnViewWillAppear
 If you set this property to be 
 true
  the user's selected cell 
 will automatically be deselected when they return to the table view. It does this intelligently, 
 though: the row starts selected, and animates to be deselected, meaning that the user gets a 
 brief reminder of the row they tapped before it gets deselected.",NA
How to detect a double tap gesture ,"Availability: iOS 3.2 or later.
  
 The iOS 
 UITapGestureRecognizer
  class has a built-in way to detect a double tap on any 
 view. All you need to do is create the recognizer, set its 
 numberOfTapsRequired
  property to 
 2, then add it to the view you want to monitor.
  
 Here's an example:
  
 override func viewDidLoad() { 
  super.viewDidLoad() 
  let tap = UITapGestureRecognizer(target: self, action: ""doubleTapped"") 
  tap.numberOfTapsRequired = 2 
  view.addGestureRecognizer(tap) 
 } 
 func doubleTapped() { 
  // do something cool here 
 } 
 www.hackingwithswift.com 
  
 1251",NA
How to detect edge swipes ,"Availability: iOS 7.0 or later.
  
 Detecting pan gestures is easy enough with a regular 
 UIPanGestureRecognizer
 , but there's 
 a special gesture recognizer to use if you want to detect the user swiping from the edge of 
 their screen. The example below demonstrates detecting the user swiping from the left edge 
 of the screen:
  
 override func viewDidLoad() { 
  let edgePan = UIScreenEdgePanGestureRecognizer(target: self, action: 
 ""screenEdgeSwiped:"") 
  edgePan.edges = .Left 
  view.addGestureRecognizer(edgePan)  
 } 
 func screenEdgeSwiped(recognizer: UIScreenEdgePanGestureRecognizer) { if recognizer.state == 
 .Recognized { 
   print(""Screen edge swiped!"") 
  }  
 }",NA
How to detect when the Back button is tapped ,"Availability: iOS 2.0 or later.
  
 www.hackingwithswift.com 
  
 1252",NA
How to dim the screen ,"Availability: iOS 2.0 or later.
  
 There is no built-in way to dim the screen unless you're presenting a view controller, at which 
 point iOS dims the background view controller for you. Instead, if you want to dim stuff you 
 need to do it yourself: create a full-screen 
 UIView
  with a translucent background color (I find 
 66% black works best) then set its alpha to be 0. When you want things to dim, set the alpha to 
 be 1.",NA
How to draw custom views in Interface Builder using ,NA,NA
IBDesignable ,"Availability: iOS 8.0 or later.
  
 You've always been able to have custom views inside your apps, but if you're having a hard 
 time visualizing how they look at design time then you should try 
 @IBDesignable
 : it lets you 
 see exactly how your custom views look inside IB, and if you combine it with 
  
 @IBInspectable
  you can even adjust your view's design there too.
  
 This example view draws an ellipse that fills itself. If you add this to your project, create a 
 view, then set that view to have this custom subclass, you'll see an ellipse appear 
  
 immediately. You can move the view or resize it, and the ellipse will be updated. Plus, 
 because I used 
 @IBInspectable
  you can adjust the colors and stroke width right inside the 
 attributes inspector, helping you make sure your UI looks exactly as you expect.
  
 @IBDesignable class EllipseView: UIView { 
 www.hackingwithswift.com 
  
 1253",NA
How to find a UIView subview using viewWithTag() ,"Availability: iOS 2.0 or later.
  
 If you need a quick way to get hold of a view inside a complicated view hierarchy, you're 
 looking for 
 viewWithTag()
  – give it the tag to find and a view to search from, and this method 
 will search all subviews, and all sub-subviews, and so on, until it finds a view with the 
 matching tag number. The method returns an optional 
 UIView
  because it might not find a view 
 with that tag, so unwrap it carefully.
  
 Here's an example:
  
 www.hackingwithswift.com 
  
 1254",NA
How to flip a UIView with a 3D effect: transitionWithView() ,"Availability: iOS 2.0 or later.
  
 iOS has a built-in way to transition between views, and you can use this to produce 3D flips in 
 just a few lines of code. Here's a basic example that flips between two views:
  
 func flip() { 
  let transitionOptions: UIViewAnimationOptions = 
 [.TransitionFlipFromRight, .ShowHideTransitionViews] 
  UIView.transitionWithView(firstView, duration: 1.0, options: transitionOptions, 
 animations: { 
   self.firstView.hidden = true 
  }, completion: nil) 
  UIView.transitionWithView(secondView, duration: 1.0, options: transitionOptions, 
 animations: { 
   self.secondView.hidden = false 
  }, completion: nil)  
 } 
 www.hackingwithswift.com 
  
 1255",NA
How to give UITableViewCells a selected color other than ,NA,NA
grey ,"Availability: iOS 7.0 or later.
  
 Ever since iOS 7.0, table view cells have been grey when tapped, even when you specifically 
 told Interface Builder you wanted them to be blue. Don't worry, though: it's an easy thing to 
 change, as long as you don't mind writing three lines of code. Specifically, you need to add 
 something like this to your 
 cellForRowAtIndexPath
  method:
  
 let backgroundView = UIView() 
 backgroundView.backgroundColor = UIColor.redColor() 
 cell.selectedBackgroundView = backgroundView 
 You can customize the view as much as you want to, but remember to keep the overall 
 amount of work low to avoid hurting scroll performance.",NA
How to give a UINavigationBar a background image: ,NA,NA
setBackgroundImage() ,"Availability: iOS 5.0 or later.
  
 You can call 
 setBackgroundImage()
  on any navigation bar, providing an image to use and 
 the bar metrics you want it to affect, and you're done. Bar metrics left you specify what sizes 
 of bars you want to change: should this by all bars, just phone-sized bars, or just phone-sized 
 bars on landscape?
  
 Here's an example that changes the navigation bar background image to a file called 
 ""navbar-background.png"" (you'll want to change that!) across all device sizes:
  
 let img = UIImage(named: ""navbar-background"") 
 navigationController?.navigationBar.setBackgroundImage(img, forBarMetrics: 
 .Default) 
 www.hackingwithswift.com
  
 1257",NA
How to give a UIStackView a background color ,"Availability: iOS 9.0 or later.
  
 You can't do this – 
 UIStackView
  is a non-drawing view, meaning that 
 drawRect()
  is never 
 called and its background color is ignored. If you desperately want a background color, 
 consider placing the stack view inside another 
 UIView
  and giving that view a background 
 color.",NA
How to hide passwords in a UITextField ,"Availability: iOS 2.0 or later.
  
 User text in a 
 UITextField
  is visible by default, but you can enable the iOS text-hiding 
 password functionality just by setting your text field's 
 secureTextEntry
  property to be true, 
 like this:
  
 textField.secureTextEntry = true",NA
How to hide the navigation bar using hidesBarsOnSwipe ,"Availability: iOS 8.0 or later.
  
 iOS 8.0 gives 
 UINavigationController
  a simple property that masks some complex behavior. 
  
 If you set 
 hidesBarsOnSwipe
  to be true for any 
 UINavigationController
 , then iOS 
 automatically adds a tap gesture recognizer to your view to handle hiding (and showing) the 
 navigation bar as needed. This means you can mimic Safari's navigation bar behavior in just 
 one line of code, like this:
  
 navigationController?.hidesBarsOnSwipe = true 
 Remember to set this back to 
 false
  when you want to stop the behavior from happening.
  
 www.hackingwithswift.com 
  
 1258",NA
How to hide the navigation bar using hidesBarsOnTap ,"Availability: iOS 8.0 or later.
  
 As of iOS 8.0 it's easy to make a navigation bar automatically hide when the user taps the 
 screen, but only when it's part of a 
 UINavigationController
 . When set to 
 true
 , the 
 hidesBarsOnTap
  property of a navigation controller automatically adds a tap gesture 
 recognizer to your view to handle hiding (and showing) the navigation bar as needed.
  
 Code:
  
 navigationController?.hidesBarsOnTap = true 
 Remember to set this back to 
 false
  when you want to stop the behavior from happening. 
 For more information see Hacking with Swift tutorial 1.",NA
How to hide the status bar ,"Availability: iOS 7.0 or later.
  
 You can hide the status bar in any or all of your view controllers just by adding this code:
  
 override func prefersStatusBarHidden() -> Bool { return true  
 } 
 www.hackingwithswift.com
  
 1259",NA
How to let users tap on a UITableViewCell while editing is ,NA,NA
enabled ,"Availability: iOS 3.0 or later.
  
 As soon as you set the 
 editing
  property of a 
 UITableView
  to be true, its cells stop being 
 tappable. This is often a good idea, because if a user explicitly enabled editing mode they 
 probably want to delete or move stuff, and it's only going to be annoying if they can select 
 rows by accident.
  
 Of course, as always, there are times when you specifically want both actions to be available - 
 for the user to be able to move or delete a cell, and also tap on it to select. If that's the 
 situation you find yourself in right now, here's the line of code you need:
  
 tableView.allowsSelectionDuringEditing = true",NA
How to load a HTML string into a WKWebView or UIWebView: ,NA,NA
loadHTMLString() ,"Availability: iOS 2.0 or later.
  
 If you want to generate HTML locally and show it inside your app, it's easy to do in both 
 UIWebView
  and 
 WKWebView
 . First, here's the code for 
 UIWebView
 :
  
 let webView = UIWebView() 
 webView.loadHTMLString(""<html><body><p>Hello!</p></body></html>"", baseURL: nil) 
 www.hackingwithswift.com
  
 1260",NA
How to make UITableViewCell separators go edge to edge ,"Availability: iOS 8.0 or later.
  
 All table view cells have a separator underneath them by default, and that separator likes to 
 start a little way from the left edge of the screen for stylistic reasons. If this clashes with your 
 own personal aesthetic, you might 
 think
  it's easy to remove but Apple has made the matter 
 quite confused by changing its mind more than once.
  
 If you absolutely, definitely want to remove the separator inset from all cells, you need to do 
 two things. First, add these two lines of code to your table view controller's 
 viewDidLoad() 
 method:
  
 tableView.layoutMargins = UIEdgeInsetsZero 
 tableView.separatorInset = UIEdgeInsetsZero 
 Now look for you 
 cellForRowAtIndexPath
  method and add this:
  
 www.hackingwithswift.com 
  
 1261",NA
How to make UITableViewCells auto resize to their content ,"Availability: iOS 8.0 or later.
  
 If you're using Auto Layout, you can have your table view cells automatically size to fit their 
 content by adding two methods to your table view controller: 
 heightForRowAtIndexPath 
 and 
 estimatedHeightForRowAtIndexPath
 . If both of these are implemented, and both return 
 UITableViewAutomaticDimension
 , then your table view cells will be measured using Auto 
 Layout and automatically fit their content.
  
 If you're using the built-in table cell styles (e.g. Default or Subtitle) then you should make sure 
 you modify the 
 numberOfLines
  properties of your cell's labels so that the text can grow as 
 needed.
  
 In case you're still not sure, here's some example code:
  
 override func tableView(tableView: UITableView,  
 heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { 
  return UITableViewAutomaticDimension 
 } 
 override func tableView(tableView: UITableView,  
 estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { 
  return UITableViewAutomaticDimension 
 } 
 For more information see Hacking with Swift tutorial 32.
  
 www.hackingwithswift.com 
  
 1262",NA
How to make a button glow when tapped with ,NA,NA
showsTouchWhenHighlighted ,"Availability: iOS 2.0 or later.
  
 If you want an easy way to let users know when a 
 UIButton
  was tapped, try setting its 
 showsTouchWhenHighlighted
  property to be true. This will render a circular glow effect 
 behind the button when it's tapped, which is particularly effective on text-only buttons.
  
 Here's the code:
  
 btn.showsTouchWhenHighlighted = true 
 If you're using Interface Builder, look for and check the ""Shows touch when highlighted"" 
 option for your button.",NA
How to make a clear button appear in a textfield ,"Availability: iOS 2.0 or later.
  
 If you want to let users clear their entry on a 
 UITextField
 , the standard approach is to add a 
 clear button to the right edge of the text field. This can be done in two ways, depending on 
 what effect you want:
  
 textField.clearButtonMode = .Always 
 textField.clearButtonMode = .WhileEditing 
 The first will always show the clear button, and the second will only show it while the user is 
 editing the text.",NA
How to make the master pane always visible in a ,"www.hackingwithswift.com 
  
 1263",NA
UISplitViewController ,"Availability: iOS 8.0 or later.
  
 Split view controllers on iPad have an automatic display mode, which means in landscape 
 both the left and right view controllers are visible, but in portrait the left view controller slides 
 over and away as needed.
  
 If this isn't preferable – if, for example, you want to mimic the way the Settings app works in 
 portrait – you can force both view controllers to be visible at all times like this:
  
 splitViewController.preferredDisplayMode = 
 UISplitViewControllerDisplayMode.AllVisible",NA
How to pad a UITextView by setting its text container inset ,"Availability: iOS 7.0 or later.
  
 You can force the text of any 
 UITextView
  to have padding – i.e., to be indented from its edges 
 – by setting its 
 textContainerInset
  property to a value of your choosing. For example, to give 
 a text view insets of 50 points from each edge, you would use this code:
  
 textView.textContainerInset = UIEdgeInsets(top: 50, left: 50, bottom: 50, right: 50)",NA
How to print using UIActivityViewController ,"Availability: iOS 6.0 or later.
  
 Printing in iOS used to be done using 
 UIPrintInteractionController
 , and, while that still works, 
 it has a much better replacement in the form of 
 UIActivityViewController
 . This new class is 
 responsible for taking a wide variety of actions of which printing is just one, but users can also 
 tweet, post to Facebook, send by email, and any other action that has been registered by 
 another app.
  
 www.hackingwithswift.com 
  
 1264",NA
How to put a background picture behind ,NA,NA
UITableViewController ,"Availability: iOS 3.2 or later.
  
 You can put any type of 
 UIView
  behind a table view, and iOS automatically resizes it to fit the 
 table. So, adding a background picture is just a matter of using a 
 UIImageView
  like this:
  
 www.hackingwithswift.com 
  
 1265",NA
How to read a title from a UIPickerView using titleForRow ,"Availability: iOS 2.0 or later.
  
 As soon as you start using 
 UIPickerView
  for the first time, you realise it doesn't have a built-in 
 way to read the title of any of its items. The reason for this is obvious in retrospect, but don't 
 worry if you didn't get it at first: you should read the title straight from the picker's data source.
  
 You should already have conformed to the 
 UIPickerViewDataSource
  and 
  
 UIPickerViewDelegate
  protocols, which means implementing the 
 titleForRow
  picker view 
 method. If you want to read the title of the selected item later, you can do one of the 
 following:
  
  • Read straight from the array you used to populate the picker view. This is the most 
 common method, but of course it only works if the data is simple.
  
  • Write a new method named something like 
 titleForPickerRow()
  that you can use in your 
 data source and to read the title later. This is preferred if it takes some work to calculate row 
 titles, but really it's better to cache this kind of thing if the work is non-trivial.
  
  • Use the same method call as the picker view: 
 pickerView(_:titleForRow:forComponent:)
 . 
 Yes, that just calls the method you implemented, but it's neat and self-describing so as long as 
 your data doesn't take time to calculate this is fine to use.
  
 If you want to try the last option, here's some example code:
  
 let title = pickerView(yourPickerView, titleForRow: 0, forComponent: 0)",NA
How to recolor UIImages using template images and ,"www.hackingwithswift.com 
  
 1266",NA
imageWithRenderingMode ,"Availability: iOS 7.0 or later.
  
 Template images are the iOS 7.0 way of tinting any kind of image when it's inside a 
  
 UIImageView
 . This is usually used to mimic the tinting of button images (as seen in toolbars 
 and tab bars) but it works anywhere you want to dynamically recolor an image.
  
 To get started, load an image then call 
 imageWithRenderingMode()
  on it, like this:
  
 if let myImage = UIImage(named: ""myImage"") { 
  let tintableImage = myImage.imageWithRenderingMode(.AlwaysTemplate) 
  imageView.image = tintableImage 
 } 
 The tint color of a 
 UIImageView
  is the standard iOS 7 blue by default, but you can change it 
 easily enough:
  
 imageView.tintColor = UIColor.redColor()",NA
How to register a cell for UICollectionView reuse ,"Availability: iOS 6.0 or later.
  
 If you're working entirely in code, you can register a 
 UICollectionViewCell
  subclass for use 
 with your collection view, so that new cells are dequeued and re-use automatically by the 
 system.
  
 Here's the most basic form of this technique:
  
 collectionView.registerClass(UICollectionViewCell.self, 
 forCellWithReuseIdentifier: ""Cell"") 
 www.hackingwithswift.com
  
 1267",NA
How to register a cell for UITableViewCell reuse ,"Availability: iOS 6.0 or later.
  
 Reusing table view cells has been one of the most important performance optimizations in 
 iOS ever since iOS 2.0, but it was only with iOS 6.0 that the API got cleaned up a little with 
 the addition of two new methods on 
 UITableView
 : 
 registerClass()
  and 
 registerNib()
 .
  
 Both of these method calls take a parameter 
 forCellReuseIdentifier
 , which is a string that 
 lets you register different kinds of table view cells. For example, you might have a reuse 
 identifier ""DefaultCell"", another one called ""Heading cell"", another one ""CellWithTextField"", 
 and so on. Re-using different cells this way helps save system resources.
  
 If you want to use 
 registerClass()
 , you provide a table view cell class as its first parameter. 
  
 www.hackingwithswift.com 
  
 1268",NA
How to remove a UIView from its superview with ,NA,NA
removeFromSuperview() ,"Availability: iOS 2.0 or later.
  
 If you created a view dynamically and want it gone, it's a one-liner in Swift thanks to the 
 removeFromSuperview()
  method. When you call this, the view gets removed immediately 
 and possibly also destroyed – it will only be kept around if you have a reference to it 
 elsewhere. Here's how it's done:
  
 yourView.removeFromSuperview()",NA
How to remove cells from a UITableViww ,"Availability: iOS 2.0 or later.
  
 It's easy to delete rows from a table view, but there is one catch: you need to remove it from 
 the data source first. If you don't do this, iOS will realize there's a mis-match between what the 
 data source thinks should be showing and what the table view is actually showing, and you'll 
 get a crash.
  
 So, to remove a cell from a table view you first remove it from your data source, then you call 
 deleteRowsAtIndexPaths()
  on your table view, providing it with an array of index paths that 
 should be zapped. You can create index paths yourself, you just need a section and row 
 number.
  
 Here's some example code to get you started:
  
 objects.removeAtIndex(0) 
 let indexPath = NSIndexPath(forItem: 0, inSection: 0) 
 tableView.deleteRowsAtIndexPaths([indexPath], 
 withRowAnimation: .Fade) 
 www.hackingwithswift.com
  
 1270",NA
How to respond to the device being shaken ,"Availability: iOS 3.0 or later.
  
 You can make any 
 UIViewController
  subclass respond to the device being shaken by 
 overriding the 
 motionBegan
  method. This is use to handle motion (shaking) but in theory 
 also remote control actions – although I can't say I've ever seen someone write code to 
 handle that!
  
 This code will print a message every time the device is shaken:
  
 override func motionBegan(motion: UIEventSubtype, withEvent event: UIEvent?) { 
  print(""Device was shaken!"") 
 } 
 For more information see Hacking with Swift tutorial 20.",NA
"How to scale, stretch, move and rotate UIViews using ",NA,NA
CGAffineTransform ,"Availability: iOS 2.0 or later.
  
 Every 
 UIView
  subclass has a 
 transform
  property that lets you manipulate its size, position 
 and rotation using something called an affine transform. This property is animatable, which 
 means yuo can make a view smoothly double in size, or make it spin around, just by 
 changing one value.
  
 Here are some examples to get you started:
  
 imageView.transform = CGAffineTransformMakeScale(2, 2) 
 imageView.transform = CGAffineTransformMakeTranslation(-256, -256) 
 imageView.transform = CGAffineTransformMakeRotation(CGFloat(M_PI)) 
 www.hackingwithswift.com 
  
 1271",NA
How to send an email ,"Availability: iOS 3.0 or later.
  
 In the MessageUI framework lies the 
 MFMailComposeViewController
  class, which handles 
 sending emails from your app. You get to set the recipients, message title and message text, 
 but you don't get to send it – that's for the user to tap themselves.
  
 Here's some example code:
  
 func sendEmail() { 
  if MFMailComposeViewController.canSendMail() { 
   let mail = MFMailComposeViewController() 
   mail.mailComposeDelegate = self 
   mail.setToRecipients([""paul@hackingwithswift.com""]) 
   mail.setMessageBody(""<p>You're so awesome!</p>"", isHTML: true) 
   presentViewController(mail, animated: true, completion: nil) } else { 
   // show failure alert 
  }  
 } 
 www.hackingwithswift.com 
  
 1272",NA
How to set a custom title view in a UINavigationBar ,"Availability: iOS 2.0 or later.
  
 Each view controller has a 
 navigationItem
  property that dictates how it customizes the 
 navigation bar if it is viewed inside a navigation controller. This is where you add left and right 
 bar button items, for example, but also where you can set a title view: any 
 UIView
  subclass that 
 is used in place of the title text in the navigation bar.
  
 For example, if you wanted to show an image of your logo rather than just some text you 
 would use this:
  
 navigationItem.titleView = UIImageView(image: UIImage(named: ""logo""))",NA
How to set prompt text in a navigation bar ,"Availability: iOS 2.0 or later.
  
 You should already know that you can give a title to a navigation controller's bar by setting 
  
 www.hackingwithswift.com 
  
 1273",NA
How to set the tabs in a UITabBarController ,"Availability: iOS 2.0 or later.
  
 If you're creating your tab bar controller from scratch, or if you just want to change the set up of 
 your tabs at runtime, you can do so just by setting the 
 viewControllers
  property of your tab bar 
 controller. This expects to be given an array of view controllers in the order you want them 
 displayed, and you should already have configured each view controller to have its own 
 UITabBarItem
  with a title and icon.
  
 If your tab bar controller is the root view controller of your window, you should be able to 
 write something like this:
  
 if let tabBarController = window?.rootViewController as? UITabBarController { 
  let first = FirstViewController() 
  let second = SecondViewController() 
  tabBarController.viewControllers = [first, second] 
 } 
 www.hackingwithswift.com
  
 1274",NA
How to set the tint color of a UIView ,"Availability: iOS 7.0 or later.
  
 The 
 tintColor
  property of any 
 UIView
  subclass lets you change the coloring effect applied to 
 it. The exact effect depends on what control you're changing: for navigation bars and tab bars 
 this means the text and icons on their buttons, for text views it means the selection cursor and 
 highlighted text, for progress bars it's the track color, and so on.
  
 tintColor
  can be set for any individual view to color just one view, for the whole view in your 
 view controller to color all its subviews, or even for the whole window in your application so 
 that all views and subviews are tinted at once.
  
 To tint just the current view controller, use this code:
  
 override func viewDidLoad() { 
  view.tintColor = UIColor.redColor() 
 } 
 If you want to tint all views in your app, put this in your AppDelegate.swift:
  
 func application(application: UIApplication,  
 didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { 
  // Override point for customization after application launch. 
  window?.tintColor = UIColor.redColor() 
  return true 
 } 
 www.hackingwithswift.com
  
 1275",NA
How to share content with UIActivityViewController ,"Availability: iOS 6 or later.
  
 Before iOS 6.0 was released there were a number of third-party libraries that tried to simplify 
 the sharing of content, but even with those libraries in place it was still far too hard. 
 Fortunately, Apple added 
 UIActivityViewController
 , a class that makes sharing to any 
 service as simple as telling it what kind of content you have.
  
 The nice thing about 
 UIActivityViewController
  is that it automatically takes advantage of the 
 apps the user has installed. If they have configured Twitter, they can post tweets; if they have 
 configured Facebook, they can post to their timline; if they have a printer configured, they can 
 print your images; and more. It takes no extra work from you: you just tell iOS what kind of 
 content you want to share, and it does the rest.
  
 Here's how you share an image:
  
 if let image = UIImage(named: ""myImage"") { 
  let vc = UIActivityViewController(activityItems: [image], applicationActivities: []) 
  presentViewController(vc, animated: true, completion: nil) 
 } 
 And here's an example of sharing a text and an image:
  
 let shareText = ""Hello, world!"" 
 if let image = UIImage(named: ""myImage"") { 
  let vc = UIActivityViewController(activityItems: [shareText, image], 
 applicationActivities: []) 
  presentViewController(vc, animated: true, completion: nil) 
 } 
 www.hackingwithswift.com
  
 1276",NA
How to share content with the Social framework and ,NA,NA
SLComposeViewController ,"Availability: iOS 6.0 or later.
  
 The 
 UIActivityViewController
  class is the iOS way of sharing almost anything to almost 
 anywhere, but what if you don't want to let users choose? Well, iOS has a tool for that too, 
 and it's called the Social framework. Start by importing that now:
  
 import Social 
 You can now create and present a 
 SLComposeViewController
  that allows the user to share 
 to Facebook like this:
  
 let vc = SLComposeViewController(forServiceType: 
 SLServiceTypeFacebook) 
 vc.setInitialText(""Look at this great picture!"") 
 vc.addImage(UIImage(named: ""myImage.jpg"")!) 
 vc.addURL(NSURL(string: ""https://www.hackingwithswift.com"")) 
 presentViewController(vc, animated: true, completion: nil) 
 That attaches initial text, an image and a URL all to that share sheet, although the user can 
 customize the text before posting. If you want to use Twitter instead, try this:
  
 let vc = SLComposeViewController(forServiceType: 
 SLServiceTypeTwitter) 
 www.hackingwithswift.com
  
 1277",NA
How to show and hide a toolbar inside a ,NA,NA
UINavigationController ,"Availability: iOS 3.0 or later.
  
 All navigation controllers have a toolbar built right in, but it's not showing by default. And 
 even if it were showing, it doesn't have any items by default – that's down to you fill in.
  
 To get started, give a view controller some toolbar items by setting its 
 toolbarItems
  property 
 like this:
  
 let add = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: ""addTapped"") 
 let spacer = UIBarButtonItem(barButtonSystemItem: .FlexibleSpace, target: self, action: nil) 
 toolbarItems = [add, spacer] 
 You can now tell the navigation controller to show its toolbar like this:
  
 navigationController?.setToolbarHidden(false, animated: false) 
 If you animate between two view controllers with different toolbar items, iOS automatically 
 animates their change.
  
 For more information see Hacking with Swift tutorial 4.",NA
How to stop Auto Layout and autoresizing masks conflicting: ,NA,NA
translatesAutoresizingMaskIntoConstraints,"www.hackingwithswift.com 
  
 1278",NA
How to stop empty row separators appearing in UITableView ,"Availability: iOS 2.0 or later.
  
 Table views show separators between empty rows by default, which looks quite strange 
 when you have only a handful of visible rows. Fortunately, one simple line of code is all it 
 takes to force iOS not to draw these separators, and it's this:
  
 tableView.tableFooterView = UIView() 
 What's actually happening is that you're creating an empty 
 UIView
  and making it act as the 
 footer of the table – this is the bottom most thing visible in the table. When iOS reaches the 
 bottom of the cells you provide, it draws this view at the end rather than drawing empty rows 
 and their separators, so it totally clears up the problem.",NA
How to stop users selecting text in a UIWebView or ,"www.hackingwithswift.com 
  
 1279",NA
WKWebView ,"Availability: iOS 2.0 or 
 later.
  
 Using a webview to show rich media easily is a common thing to do, but by default users 
 can select the text and that makes it look a little less like native code. To fix this, add the 
 following CSS to the HTML you load, and users won't be able to select anything again:
  
 <style type=""text/css"">  
 * { 
  -webkit-touch-callout: none; 
  -webkit-user-select: none;  
 }  
 </style>",NA
How to stop your view going under the navigation bar using ,NA,NA
edgesForExtendedLayout ,"Availability: iOS 7.0 or later.
  
 As of iOS 7.0, all views automatically go behind navigation bars, toolbars and tab bars to 
 provide what Apple calls ""context"" – having some idea of what's underneath the UI (albeit 
 blurred out with a frosted glass effect) gives users an idea of what else is just off screen. If 
 this is getting in your way (and honestly it does get in the way surprisingly often) you can 
 easily disable it for a given view controller by modifying its 
 edgesForExtendedLayout 
 property.
  
 For example, if you don't want a view controller to go behind any bars, use this:
  
 edgesForExtendedLayout = .None 
 www.hackingwithswift.com
  
 1280",NA
How to style the font in a UINavigationBar's title ,"Availability: iOS 6.0 or later.
  
 If you're setting title's in a navigation bar, you can customise the font, size and color of those 
 titles by adjusting the 
 titleTextAttributes
  attribute for your navigation bar. To do this on a 
 single bar just set it directly whenever you want to; to change all bars, set it inside your app 
 delegate using the appearance proxy for 
 UINavigationBar
  so that it kicks in before the first 
 bar is loaded.
  
 Here's an example that makes title text be 24-point Georgia Bold in red:
  
 let attrs = [ 
  NSForegroundColorAttributeName : UIColor.redColor(), 
  NSFontAttributeName : UIFont(name: ""Georgia-Bold"", size: 24)! 
 ] 
 UINavigationBar.appearance().titleTextAttributes = attrs",NA
How to support pinch to zoom in a UIScrollView ,"Availability: iOS 2.0 or later.
  
 Making a scroll view zoom when you pinch is a multi-step approach, and you need to do all 
 the steps in order for things to work correctly.
  
 First, make sure your scroll view has a maximum zoom scale larger than the default of 1.0. 
 You can change this in Interface Builder if you want, or use the 
 maximumZoomScale 
 property in code.
  
 Second, make your view controller the delegate of your scroll view. Again, you can do this in 
 Interface Builder by Ctrl-dragging from the scroll view to your view controller.
  
 Third, make your view controller conform to the 
 UIScrollViewDelegate
  protocol, then add 
 the 
 viewForZoomingInScrollView()
  method, like this:
  
 www.hackingwithswift.com 
  
 1281",NA
How to swipe to delete UITableViewCells ,"Availability: iOS 2.0 or later.
  
 It takes just one method to enable swipe to delete in table views: 
  
 tableView(_:commitEditingStyle:forRowAtIndexPath:)
 . This method gets called when a user 
 tries to delete one of your table rows using swipe to delete, but its very presence is what 
 enables swipe to delete in the first place – that is, iOS literally checks to see whether the 
 method exists, and, if it does, enables swipe to delete.
  
 When you want to handle deleting, you have to do three things: first, check that it's a delete 
 that's happening and not an insert (this is down to how you use the UI); second, delete the 
 item from the data source you used to build the table; and third, call 
  
 deleteRowsAtIndexPaths()
  on your table view.
  
 It is crucial that you do those things in exactly that order.
  iOS checks the number of rows 
 before and after a delete operation, and expects them to add up correctly following the 
 change.
  
 Here's an example that does everything correctly:
  
 override func tableView(tableView: UITableView, commitEditingStyle editingStyle: 
 UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { 
  if editingStyle == .Delete { 
  objects.removeAtIndex(indexPath.row) 
 www.hackingwithswift.com 
  
 1282",NA
How to use Dynamic Type to resize your app's text ,"Availability: iOS 7.0 or later.
  
 As of iOS 7.0 users can set a system-wide preferred font size for all apps, but many 
 programmers ignore this setting much to user's annoyance. You're not one of 
 those 
 developers, are you? Of course not! So here's how to honor a user's font settings using 
 UIFont
 :
  
 let headlineFont =  
 UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline) 
 let subheadFont =  
 UIFont.preferredFontForTextStyle(UIFontTextStyleSubheadline) 
 And that's it! This technology is called Dynamic Type, and it's powerful because that code 
 will return correctly sized fonts for the user's preference, which means your app's text will 
 shrink or grow as needed.
  
 Note that it is technically possible for users to change their Dynamic Type setting while your 
 app is running. If you want to cover this corner case, use 
 NSNotificationCenter
  to subscribe to 
 the 
 UIContentSizeCategoryDidChangeNotification
  notification then refresh your user 
 interface if you receive it.
  
 For more information see Hacking with Swift tutorial 32.
  
 www.hackingwithswift.com 
  
 1283",NA
How to use IBInspectable to adjust values in Interface Builder ,"Availability: iOS 8.0 or later.
  
 The 
 @IBInspectable
  keyword lets you specify that some parts of a custom 
 UIView
  subclass 
 should be configurable inside Interface Builder. Only some kinds of values are supported 
 (booleans, numbers, strings, points, rects, colors and images) but that ought to be enough for 
 most purposes.
  
 When your app is run, the values that were set in Interface Builder are automatically set, just 
 like any other IB value. Neat, huh?
  
 Here's an example that creates a 
 GradientView
  class. This wraps the 
 CAGradientLayer 
 class up in a 
 UIView
  that you can place anywhere in your app. Even better, thanks to 
 @IBInspectable
  you can customize the colors in your gradient right inside IB. Add this class 
 to your project now:
  
 @IBDesignable class GradientView: UIView { 
  @IBInspectable var startColor: UIColor = UIColor.whiteColor() 
  @IBInspectable var endColor: UIColor = UIColor.whiteColor() 
  override class func layerClass() -> AnyClass { 
  return CAGradientLayer.self 
  } 
  override func layoutSubviews() { 
  (layer as! CAGradientLayer).colors = [startColor.CGColor, endColor.CGColor] 
  } 
 } 
 Now go to IB, drop a 
 UIView
  on to your storyboard, then change its class to be 
  
 GradientView
 . Once that's done, Xcode will compile your project automatically, and then 
 inside the attributes inspector you'll see two color selectors for the start and end color.
  
 www.hackingwithswift.com 
  
 1284",NA
How to use SFSafariViewController to show web pages in ,NA,NA
your app ,"Availability: iOS 9.0 or later.
  
 If a user clicks a web link in your app, you used to have two options before iOS 9.0 came along: 
 exit your app and launch the web page in Safari, or bring up a new web view 
  
 controller that you've designed, along with various user interface controls. Exiting your app is 
 rarely what users want, so unsurprisingly lots of app ended up creating mini-Safari 
  
 experiences to browse inside their app.
  
 As of iOS 9.0, Apple allows you to embed Safari right into your app, which means you get its 
 great user interface, you get its access to stored user data, and you even get Reader Mode 
 right out of the box. To get started, import the SafariServices framework into your view 
 controller, like this:
  
 import SafariServices 
 Now make your view controller conform to the 
 SFSafariViewControllerDelegate
  protocol, 
 like this:
  
 class ViewController: UIViewController, 
 SFSafariViewControllerDelegate { 
 Now for the main piece of code, although I think you'll agree it's easy:
  
 let urlString = ""https://www.hackingwithswift.com"" 
 if let url = NSURL(string: urlString) { 
 www.hackingwithswift.com 
  
 1285",NA
How to use light text color in the status bar ,"Availability: iOS 7.0 or later.
  
 As of iOS 7.0, all view controllers set their own status bar style by default, which means they 
 can have black text or white text depending on what looks best for your view controller. If you 
 want to have light text in the status bar, add this code to your view controller:
  
 override func preferredStatusBarStyle() -> UIStatusBarStyle { return .LightContent  
 } 
 www.hackingwithswift.com
  
 1286",NA
What are size classes? ,"Availability: iOS 8.0 or later.
  
 Size Classes are the iOS method of creating adaptable layouts that look great on all sizes and 
 orientations of iPhone and iPad. For example, you might want to say that your UI looks mostly 
 the same in portrait and landscape, but on landscape some extra information is visible. You 
 could do this in code by checking for a change in the size of your view controller and trying to 
 figure out what it means, but that's a huge waste of time – particularly now that iPad has 
 multiple different sizes thanks to multitasking in iOS 9.
  
 With Size Classes, you don't think about orientation or even device size. You care about 
 whether you are running in a compact size or regular size, and iOS takes care of mapping 
 that to various device sizes and orientations. iOS will also tell you when your size class 
 changes so you can update your UI.
  
 For example, an iPad app running full screen in portrait has regular horizontal and vertical size 
 classes. In landscape, it also has regular horizontal and vertical size classes. If your app is 
 used in iOS 9 multitasking, then its size class can be one of the following:
  
  • If the apps are running with an even split in landscape, both have compact horizontal and 
 regular vertical size classes.
  
  • If the apps are running with an uneven split in landscape, the primary app has a regular 
 horizontal class and the second has a compact horizontal size class. Both apps have regular 
 vertical classes.
  
  • If the apps are running with an uneven split in portrait, both apps have compact horizontal 
 size classes and regular vertical size classes.
  
 Size Classes can be implemented in code if you want, but it's much easier to use Interface 
 Builder. The key is to change only the bits you have to – try to share as much of your user 
 interface as possible!
  
 www.hackingwithswift.com 
  
 1287",NA
What are the different UIStackView distribution types? ,"Availability: iOS 9.0 or later.
  
 One of the most compelling reasons to upgrade to iOS 9.0 is the new 
 UIStackView
  class it 
 introduced, which offers a simplified way of doing layouts in iOS. To give you more control 
 over how it arranges their subviews, stack views offer five different distribution types for you to 
 try, and here's what they do:
  
  • 
 Fill
  makes one subview take up most of the space, while the others remain at their natural 
 size. It decides which view to stretch by examining the content hugging priority for each of the 
 subviews.
  
  • 
 Fill Equally
  adjusts each subview so that it takes up equal amount of space in the stack 
 view. All space will be used up.
  
  • 
 Fill Proportionally
  is the most interesting, because it ensures subviews remain the same 
 size relative to each other, but still stretches them to fit the available space. For example, if 
 one view is 100 across and another is 200, and the stack view decides to stretch them to take 
 up more space, the first view might stretch to 150 and the other to 300 – both going up by 
 50%.
  
  • 
 Equal Spacing
  adjusts the spacing between subviews without resizing the subviews 
 themselves.
  
  • 
 Equal Centering
  attempts to ensure the centers of each subview are equally spaced, 
 irrespective of how far the edge of each subview is positioned.
  
 For more information see Hacking with Swift tutorial 31.",NA
What is content compression resistance? ,"Availability: iOS 9.0 or later.
  
 When Auto Layout has determined there isn't enough space to accomodate all your views at 
 their natural size, it has to make a decision: one or more of those views needs to be squashed 
 to make space for the others, but which one? That's where content compression resistance 
 comes in: it's a value from 1 to 1000 that determines how happy you are for the view to be 
 squashed if needed.
  
 www.hackingwithswift.com 
  
 1288",NA
locationInView(): How to find a touch's location in a view ,"Availability: iOS 2.0 or later.
  
 When the user starts touching an iOS screen, 
 touchesBegan()
  is immediately called with a 
 set of 
 UITouches
 . If you want to find where the user touched, you need to take one of those 
 touches then use 
 locationInView()
  on it, like this:
  
 override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { 
  if let touch = touches.first { 
  let position = touch.locationInView(view) 
  print(position) 
  } 
 } 
 That will make 
 position
  a 
 CGPoint
  representing where the user touched in the current view. 
 You can if you want pass a different view to 
 locationInView()
 , and it will tell you where the 
 touch was relative to that other view instead.",NA
stringByEvaluatingJavaScriptFromString(): How to run ,NA,NA
JavaScript on a UIWebView ,"Availability: iOS 2.0 or later.
  
 You can run custom JavaScript on a 
 UIWebView
  using the method 
  
 stringByEvaluatingJavaScriptFromString()
 . The method returns an optional string, which 
  
 www.hackingwithswift.com 
  
 1289",NA
WKWebView ,NA,NA
How to enable back and forward swiping gestures in ,NA,NA
WKWebView,"Availability: iOS 8.0 or later.
  
 One of the many advantages of 
 WKWebView
  over 
 UIWebView
  is its ability to draw on some 
  
 of the native user interface of Safari. It's a long way from the 
 SFSafariViewController
  that 
  
 was introduced in iOS 9.0, but you can enable the built-in gestures that let users go back 
  
 and forward by swiping left and right.
  
 Here's the code:
  
 webView.allowsBackForwardNavigationGestures = true 
 For more information see Hacking with Swift tutorial 4.",NA
How to monitor WKWebView page load progress using key-,"www.hackingwithswift.com 
  
 1290",NA
value observing ,"Availability: iOS 8.0 or 
 later.
  
 iOS often uses a delegate system to report important changes, such as when a table view cell 
 has been tapped or when a web page has finished loading. But the delegate system only goes 
 so far, and if you want fine-grained detailed information sometimes you need to turn to KVO, 
 or ""key-value observing.""
  
 In the case of seeing how much of a page has loaded in 
 WKWebView
 , KVO is exactly what 
 you need: each web view has a property called 
 estimatedProgress
 , and you can be asked 
 to be notified when that value has changed.
  
 First, create a progress view that will be used to show the loading progress:
  
 progressView = UIProgressView(progressViewStyle: .Default) 
 progressView.sizeToFit() 
 You can place that anywhere you like. Now add the current view controller as an observer of 
 the 
 estimatedProgress
  property of your 
 WKWebView
 , like this:
  
 webView.addObserver(self, forKeyPath: ""estimatedProgress"", options: .New, 
 context: nil) 
 The 
 .New
  in that line of code means ""when the value changes, tell me the new value.""
  
 Finally, implement the 
 observeValueForKeyPath()
  method in your view controller, updating 
 the progress view with the estimated progress from the web view, like this:
  
 override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, 
 change: [NSObject: AnyObject], context: UnsafeMutablePointer<Void>) { 
  if keyPath == ""estimatedProgress"" { 
  progressView.progress = Float(webView.estimatedProgress) 
  } 
 www.hackingwithswift.com 
  
 1291",NA
What's the difference between UIWebView and WKWebView? ,"Availability: iOS 8.0 or later.
  
 The 
 UIWebView
  class has been around since iOS 2.0 as a way to show HTML content inside 
 your app, but iOS 8.0 introduced 
 WKWebView
  as an alternative - what's the difference?
  
 Well, there are several differences, but two are particularly important. First, 
 UIWebView
  is 
 part of UIKit, and thus is available to your apps as standard. You don't need to import 
 anything – it's just there. This also means it's available inside Interface Builder, so you can 
 drag and drop web view into your designs.
  
 Second, 
 WKWebView
  is run in a separate process to your app so that it can draw on native 
 Safari JavaScript optimizations. This means 
 WKWebView
  loads web pages faster and more 
 efficiently than 
 UIWebView
 , and also doesn't have as much memory overhead for you.
  
 In iOS 8.0 
 WKWebView
  was unable to load local files, but this got fixed in iOS 9.0. The main 
 reason to use 
 UIWebView
  nowadays is for access to older features such as ""Scale pages to 
 fit"" - this is not available in 
 WKWebView
 .
  
 For more information see Hacking with Swift tutorial 4.",NA
evaluateJavaScript(): How to run JavaScript on a ,NA,NA
WKWebView ,"Availability: iOS 8.0 or later.
  
 Using 
 evaluateJavaScript()
  you can run any JavaScript in a 
 WKWebView
  and read the 
 result in Swift. This can be any JavaScript you want, which effectively means you can dig 
 right into a page and pull out any kind of information you want.
  
 www.hackingwithswift.com 
  
 1292",NA
Xcode,NA,NA
How to create exception breakpoints in Xcode ,"Availability: iOS 7.0 or later.
  
 Exception breakpoints are a powerful debugging tool that remarkably few people know 
 about, so please read the following carefully and put it into practice!
  
 A regular breakpoint is on a line you specify, and causes the debugger to pause execution at 
 that point so you can evaluate your program's state. An 
 exception
  breakpoint tells the 
 debugger to pause whenever a problem is encountered anywhere in your program, so you 
 can evaluate your program's state before it crashes.
  
 Exception breakpoints are trivial to set up: go to the Breakpoint Navigation (Cmd+7), then 
 click the + button in the bottom left and choose Add Exception Breakpoint. You can leave it 
 there if you want to, but it's preferable to make one further change to reduce unnecessary 
 messages: right-click on your new breakpoint, choose Edit Breakpoint, then change the 
 Exception value from ""All"" to ""Objective-C"".
  
 www.hackingwithswift.com 
  
 1293",NA
How to debug view layouts in Xcode ,"Availability: iOS 8.0 or later.
  
 View debugging lets you visualize exactly how your app is drawing to the screen by 
 exploding your UI into 3D. So, if you're sure you added a button but you just can't see it, 
 view debugging is for you: you can spin your interface around inside Xcode, and you'll 
 probably find your button lurking behind another view because of a bug.
  
 To activate view debugging, first you need to be using iOS 8.0, either on a device or the 
 simulator. Run your app, and browse to the view controller you want to inspect. Now go to 
 Xcode and look just below the main text editor, where the row of debugging buttons live: you 
 want to click the button that has three rectangles in, just to the left of the location arrow.
  
 When you use view debugging your app is paused, so make sure and tell Xcode to continue 
 execution when you're done by pressing Cmd+Ctrl+Y.
  
 For more information see Hacking with Swift tutorial 18.",NA
How to load assets from Xcode asset catalogs ,"Availability: iOS 7 or later.
  
 Xcode asset catalogs are a smart and efficient way to bring together your artwork in a single 
 place. But they are also optimized for performance: when your app is built, your assets 
 converted to an optimized binary format for faster loading, so they are recommended for all 
 kinds of apps unless you have a specific reason to avoid them. (Note: SpriteKit games should 
 texture atlases if possible.
  
 If you don't already have an asset catalog in your project, you can create one by right-click on 
 your project and choosing New File. From ""iOS"" choose ""Resource"" then Asset Catalog, then 
 click Next and name your catalog. You can now select your new asset catalog in Xcode, and 
 drag pictures directly into it.
  
 Images stored inside asset catalog all retain their original filename, minus the path extension 
  
 www.hackingwithswift.com 
  
 1294",NA
