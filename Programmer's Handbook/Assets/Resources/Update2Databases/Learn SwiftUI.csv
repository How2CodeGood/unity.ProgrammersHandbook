Larger Text,Smaller Text,Symbol
Learn SwiftUI,NA,NA
An introductory guide to creating intuitive cross-platform ,NA,NA
user,NA,NA
interfaces using Swift 5,NA,NA
Chris Barker,BIRMINGHAM - MUMBAI,NA
Learn SwiftUI,"Copyright 
 ©
  2020 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form 
 or by any means, without the prior written permission of the publisher, except in the case of brief quotations 
 embedded in critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of the information presented.
  
 However, the information contained in this book is sold without warranty, either express or implied. Neither the 
 author, nor Packt Publishing or its dealers and distributors, will be held liable for any damages caused or alleged to 
 have been caused directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the companies and products 
 mentioned in this book by the appropriate use of capitals. However, Packt Publishing cannot guarantee the accuracy 
 of this information.
  
 Commissioning Editor:
  Pavan Ramchandani 
  
 Acquisition Editor:
  Heramb Bhavsar 
  
 Content Development Editor:
  Akhil Nair 
  
 Senior Editor:
  Hayden Edwards 
  
 Technical Editor:
  Jane DSouza 
  
 Copy Editor:
  Safis Editing 
  
 Project Coordinator:
  Kinjal Bari 
  
 Proofreader:
  Safis Editing 
  
 Indexer:
  Priyanka Dhadke 
  
 Production Designer:
  Nilesh Mohite
  
 First published: April 2020
  
 Production reference: 1020420
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham 
  
 B3 2PB, UK.
  
 ISBN 978-1-83921-542-1
  
 www.packt.com",NA
Why subscribe?,"Spend less time learning and more time coding with practical eBooks and Videos 
  
 from over 4,000 industry professionals
  
 Improve your learning with Skill Plans built especially for you
  
 Get a free eBook or video every month
  
 Fully searchable for easy access to vital information
  
 Copy and paste, print, and bookmark content
  
 Did you know that Packt offers eBook versions of every book published, with PDF and 
 ePub files available? You can upgrade to the eBook version at 
 www.packt.com
  and as a print 
 book customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
 customercare@packtpub.com
  for more details.
  
 At 
 www.packt.com
 , you can also read a collection of free technical articles, sign up for a 
 range of free newsletters, and receive exclusive discounts and offers on Packt books and 
 eBooks.",NA
Contributors,NA,NA
About the author,"Chris Barker
  is a senior iOS developer and tech lead for fashion retailer N Brown (JD 
 Williams, SimplyBe, Jacamo), where he heads the iOS team, building apps for their major 
 brands. Having now worked in the IT industry for over 22 years, Chris started his career 
 developing .NET applications for online retailer dabs.com (now BT Shop).
  
 In 2014, he made his move into mobile app development with digital agency Openshadow 
 based in  MediaCityUK. Here, he worked on mobile apps for clients such as Louis Vuitton 
 and L'Or
 é
 al Paris. Chris often attends and speaks at his local iOS developer meetup, 
 NSManchester.
  
 Most recently, Chris attended Malaga Mobile in Spain, where he spoke about his passion 
 for accessibility in mobile apps. Over the past 2 years, Chris has been a regular speaker at 
 CodeMobile Developer Conference and plans to return in the future.
  
 To everyone who has inspired and supported me during my career not only as a developer 
 but as a first-time author too. From my first mentor, Kerry, who took me under her wing 
 to my current apprentices, who keep me on my toes daily 
 –
  thank you. A shout out to my 
 technical reviewer, Juan, who was a light at the end of the tunnel after many months of 
 self-doubt 
 –
  thank you. To the entire team at Packt for their patience, guidance, and 
 understanding during this whole process 
 –
  thank you.",NA
About the reviewer,"Juan Catalan
  is a software developer with more than 10 years of experience, having started 
 learning iOS almost from the beginning. He has worked as a professional iOS developer in 
 many industries, including industrial automation, transportation, document management, 
 fleet tracking, real estate, and financial services. Juan has contributed to more than 30 
 published apps, some of them with millions of users. He has a passion for software 
 architecture, always looking for ways to write better code and optimize a mobile app.",NA
Packt is searching for authors like you,"If you're interested in becoming an author for Packt, please visit 
 authors.packtpub.com 
 and 
 apply today. We have worked with thousands of developers and tech professionals, just 
 like you, to help them share their insight with the global tech community. You can make 
 a general application, apply for a specific hot topic that we are recruiting an author for, or 
 submit your own idea.",NA
Table of Contents,"Preface
  
 1
  
 Chapter 1: Getting Started with SwiftUI 
  
 Technical requirements 
  
 Introducing Swift as a programming language 
 Learning about existing UI frameworks 
  
  
 Creating the UI programmatically 
  
  
 Creating a UI via Interface Builder 
  
 Introducing SwiftUI 
  
  
 What is SwiftUI? 
  
  
 Syntax in SwiftUI 
  
  
 States and updating the UI 
  
  
 Tools and features 
  
  
 Building for multiple devices 
  
 When to use SwiftUI, and why 
  
 Summary 
  
 Questions 
  
 Further reading
  
 Chapter 2: Understanding Declarative Syntax 
 Technical requirements 
  
 What is declarative syntax?
  
 Visualizing declarative syntax 
  
  
 Getting started with SwiftUI in Xcode 
  
 Making a ""Hello World"" app 
  
  
 Returning multiple views 
  
  
 Modifiers 
  
  
 Nesting syntax 
  
  
 Grouping 
  
 Imperative syntax 
  
 Summary 
  
 Questions 
  
 Further reading
  
 Chapter 3: Building Layout and Structure 
  
 Technical requirements 
  
 Understanding UI logic – the MVVM architecture 
  
 MVVM overview 
  
  
 MVVM in SwiftUI 
  
  
 Other architecture patterns
  
 6 
  
 7 
  
 7 
  
 10 
  
 10 
  
 11 
  
 12 
  
 12 
  
 14 
  
 14 
  
 14 
  
 15 
  
 15 
  
 16 
  
 16 
  
 16
  
 1
 7 
  
 1
 8 
  
 1
 8 
  
 1
 9 
  
 1
 9 
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 6 
  
 2
 7 
  
 2
 8 
  
 2
 9 
  
 2
 9 
  
 2",NA
Preface,"SwiftUI is the brand new UI framework unveiled by Apple at WWDC 2019. For iOS, it 
 comes as a potential successor to UIKit and  AppKit for macOS. 
  
 SwiftUI takes full advantage of declarative syntax, changing the way we think 
 about designing and developing apps. 
  
 We start by taking a look at the Swift programming language before moving onto how 
 declarative syntax works so well for SwiftUI. We
 ’
 ll then begin to program our very own 
 recipe app, learning all about the simplicity of SwiftUI along the way.  We
 ’
 ll also learn 
 about existing UI frameworks and how we can integrate those directly into our project with 
 ease. 
  
 Once our iOS app is up and running, we
 ’
 ll see how making the transition 
 over to iPadOS and watchOS is made even easier.
  
 With brand new features built directly into Xcode 11 and the power of the Swift 5.2 
 programming language - SwiftUI is the start of something very special.",NA
Who this book is for,"This book is aimed at anyone, from a beginner to the world of iOS development, to an 
 experienced Swift developer looking to get their hands on SwiftUI for the first time.
  
 If you've been developing for other platforms, be it mobile, web, or APIs, and want to get 
 stuck into something new, then this book is a great place to start.",NA
What this book covers,"Chapter 1
 , 
 Getting Started with SwiftUI
 , offers an introduction to the Swift programming 
 language and the SwiftUI framework.
  
 Chapter 2
 , 
 Understanding Declarative Syntax
 , provides details on declarative syntax and 
 how this works in SwiftUI.",NA
To get the most out of this book,"In order to follow and code along with this book, you will need to own an Apple Mac that 
 is capable of running macOS Catalina or later.",NA
Download the example code files,"You can download the example code files for this book from your account at 
 www.packt.com
 . If you purchased this book elsewhere, you can visit 
  
 www.packtpub.com/support
  and register to have the files emailed directly to you.
  
 You can download the code files by following these steps:
  
 1. 
  
 Log in or register at 
 www.packt.com
 .
  
 2. 
  
 Select the 
 Support
  tab.
  
 3. 
  
 Click on 
 Code Downloads
 .
  
 4. 
  
 Enter the name of the book in the 
 Search
  box and follow the onscreen 
  
 instructions.
  
 Once the file is downloaded, please make sure that you unzip or extract the folder using the 
 latest version of:
  
 WinRAR/7-Zip for Windows
  
 Zipeg/iZip/UnRarX for Mac
  
 7-Zip/PeaZip for Linux
  
 The code bundle for the book is also hosted on GitHub at 
 https://github.com/ 
  
 PacktPublishing/Learn-SwiftUI
 . In case there's an update to the code, it will be updated on the 
 existing GitHub repository.
  
 We also have other code bundles from our rich catalog of books and videos available 
 at 
 https://github.com/PacktPublishing/
 . Check them out!",NA
Conventions used,"There are a number of text conventions used throughout this book.
  
 CodeInText
 : Indicates code words in text, database table names, folder names, filenames, file 
 extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: 
 ""Let's start by creating an instance of 
 TableView
  in an empty 
 ViewController
 .""
  
 A block of code is set as follows:
  
 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int 
  
 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)-> UITableViewCell
  
 When we wish to draw your attention to a particular part of a code block, the relevant lines 
 or items are set in bold:
  
 class ViewController: UIViewController {
  
 var tableView: UITableView!
  
  override func viewDidLoad() {
  
  tableView = UITableView(frame: view.frame) 
 view.addSubview(tableView)
  
  }
  
 }
  
 Bold
 : Indicates a new term, an important word, or words that you see onscreen. For 
 example, words in menus or dialog boxes appear in the text like this. Here is an example: 
 ""Select 
 SwiftUI View
  from the 
 User Interface
  options and then click 
 Next
 .""
  
  
  
 Warnings or important notes appear like this.
  
 Tips and tricks appear like this.
  
 [ 4 ]",NA
Get in touch,"Feedback from our readers is always welcome.
  
 General feedback
 : If you have questions about any aspect of this book, mention the book 
 title in the subject of your message and email us at 
 customercare@packtpub.com
 .
  
 Errata
 : Although we have taken every care to ensure the accuracy of our content, mistakes 
 do happen. If you have found a mistake in this book, we would be grateful if you would 
 report this to us. Please visit 
 www.packtpub.com/support/errata
 , selecting your book, clicking 
 on the Errata Submission Form link, and entering the details.
  
 Piracy
 : If you come across any illegal copies of our works in any form on the Internet, we 
 would be grateful if you would provide us with the location address or website name. 
 Please contact us at 
 copyright@packt.com
  with a link to the material.
  
 If you are interested in becoming an author
 : If there is a topic that you have expertise in 
 and you are interested in either writing or contributing to a book, please visit 
  
 authors.packtpub.com
 .",NA
Reviews,"Please leave a review. Once you have read and used this book, why not leave a review on 
 the site that you purchased it from? Potential readers can then see and use your unbiased 
 opinion to make purchase decisions, we at Packt can understand what you think about our 
 products, and our authors can see your feedback on their book. Thank you!
  
 For more information about Packt, please visit 
 packt.com
 .",NA
Getting Started with SwiftUI ,NA,NA
,"Here, we'll begin our journey into learning SwiftUI by building our very own SwiftUI app.
  
 We'll start by learning the history of the Swift programming language, which will act as a 
 good foundation for understanding the core concepts of Swift development. Together, we'll 
 build an app with custom animations and everyday elements that work seamlessly for iOS, 
 iPadOS, and watchOS. From this, we'll see the benefits of writing good, clean 
  
 code
 —
 once
 —
 for multiple devices. Once we have our working app, we'll cover testing and 
 debugging, and see how crafting our code in the right way from the start can make this 
 much simpler to implement.
  
 We'll get started with the history of Swift before getting hands-on into Xcode, where we'll 
 learn just how simple, yet powerful, developing in SwiftUI really is. In this chapter, we'll 
 get you primed and ready for your journey into SwiftUI by first of all introducing you to 
 the Swift programming language, along with the existing UIKit framework. We'll then 
 discuss what SwiftUI brings to the table, and how it sits not only within a new project but 
 in your existing projects too.
  
 The following topics will be covered in this chapter:
  
 Introducing Swift as a programming language
  
 Learning about existing UI frameworks
  
 Introducing SwiftUI
  
 When to use SwiftUI, and why",NA
Technical requirements,"No technical requirements are needed for this chapter. We'll simply be going through an 
 overview of Swift and SwiftUI; however, feel free to grab a coffee if you like!",NA
Introducing Swift as a programming ,NA,NA
language,"Whether you're a seasoned Mac/iOS developer or brand new to the scene, one way or 
 another you'll have heard of Swift. The Swift programming language was first announced 
 by Apple at the 
 Apple Worldwide Developers Conference
  (
 WWDC
 ) in 2014 and was 
 intended to bring to the table numerous features from a multitude of other programming 
 languages. Although not labeled as a successor, some feel that Swift was brought in to 
 replace Apple's currently used programming language, Objective-C.
  
  
 Apple had actually been developing Swift since 2010, a project originally 
 started by Chris Lattner, who joined Apple in 2005 to work on the 
 Low-
 Level Virtual Machine
  (
 LLVM
 ) toolchain project.
  
 Since its announcement in 2014, Swift has taken on many iterations, with the current release 
 at the time of writing being version 5.1.
  
 However, the first major milestone for Swift came just after the announcement of version 2 
 at WWDC 2015, when Apple announced that version 2.2 was being open-sourced in 
 December of that year. This decision was met with great enthusiasm by the community, 
 with the ability to build, modify, and contribute to the Swift programming language. This 
 kick-started many projects, including server-side Swift.
  
  
 Open source software
 —
 Software that is created and distributed by 
 developers under specific licenses, such as Apache 2.0 GNU 
 General 
 Public License
  (
 GPL
 ) and 
 Massachusetts Institute of Technology
  (
 MIT
 ).
  
 The different flavors of licenses determine how developers can use and
  
 distribute the software.",NA
Learning about existing UI frameworks,"With all great programming languages come great frameworks
 —
 in particular, UI 
 frameworks. In the case of Apple, UIKit has been the UI framework of choice since 
 Objective-C, offering everything from labels, fonts, and buttons, to animation.
  
 Written in Objective-C, UIKit has been the binding of the iPhone UI for all developers since 
 the beginning. With a multitude of public APIs and documentation available to developers 
 and solid support from the community, there has been little else to offer in terms of 
 alternatives for Apple development.
  
 Without UIKit, everyday interactions such as tap, pinch, and zoom gestures for drawing 
 wouldn
 ’
 t be available. UIKit is even responsible for accessibility, which we'll touch on later 
 on in this book.
  
 The binding between UIKit and Swift can be performed in two ways: programmatically or 
 through the Interface Builder.",NA
Creating the UI programmatically,"Creating the UI programmatically involves writing around five lines of code, such as in the 
 following example:",NA
Creating a UI via Interface Builder,"The second way is via Xcode's 
 Interface Builder
 . Interface Builder is a built-in 
 graphical 
 user interface
  (
 GUI
 ) that allows you to use either 
 XML Interface Builder
  (
 XIB
 ) files, 
 NeXTSTEP Interface Builder
  (
 NIB
 ) files, or Storyboards to design and create your layout 
 with ease. With Interface Builder, you can simply drag and drop components such as Views 
 (
 UIView
 ), labels (
 UILabel
 ), and Image Views (
 UIImageView
 ) straight onto a canvas that can be 
 wired straight into your code. The following is an example of how a button is created in 
 Interface Builder and shows the code to handle the button's tap event:",NA
Introducing SwiftUI,"The Apple headline for WWDC 2019 was 
 We are going to blow your mind
  and, indeed, they 
 weren't wrong. As expected, many rumors floated around WWDC, with heavy 
  
 conversations around Project Marzipan (which came to be announced as Catalyst), but no-
 one could have foreseen the announcement of a new UI framework
 —
 specifically, one built 
 around Swift.",NA
What is SwiftUI? ,"SwiftUI is a brand-new developer toolkit written in Swift for Swift. It presents a 
 declarative syntax, allowing for more fluid and natural development along with more 
 human-readable code.",NA
Syntax in SwiftUI,"SwiftUI makes full use of declarative syntax, which we'll go into further in much more 
 detail in the next chapter, but the burning question on everyone's mind was 
 What's so 
 special about declarative syntax?
  Well, quite a lot, actually. Declarative syntax brings a whole 
 new paradigm to writing and structuring UI-based code: no more dragging and dropping 
 elements into NIBs and Storyboards, or complex constructors and properties to set, but 
 more of an instruction (to the compiler)-based approach to generating and displaying UI 
 elements.
  
 First of all, forget about previous architecture patterns used in mobile apps (or any other 
 object-oriented) development, such as 
 Model-View-Controller
  (
 MVC
 ), 
 Model-View-
 ViewModel
  (
 MVVM
 ), 
 Model-View-Presenter
  (
 MVP
 ), and so on. Delegate patterns 
 commonly used in iOS/macOS development are no longer needed, as declarative syntax 
 now makes use of States.",NA
States and updating the UI,"We'll touch on States in a later chapter but, as a general overview, if you assign 
 @State
  to a 
 property, SwiftUI will monitor this property and, if it is mutated or changed, will invalidate 
 the current layout and reload. 
  
 Think of it in terms of a collection of data in a list. The data changes and the list is 
 automatically updated and refreshed
 —
 no need to invoke a refresh call (or a 
 reloadData()
 , as you might have previously seen in 
 CollectionViews 
 and 
 TableViews
 ).",NA
Tools and features,"Another powerful feature of SwiftUI is hot reloading
 —
 or the preview window, as it's called 
 in Xcode. This allows you to make changes to your UI code in real time, without the need to 
 build and rerun the app.
  
 By creating a 
 Preview
  struct inside your SwiftUI class, you can build and inject mock data, 
 mock navigation, and images straight into your Xcode preview window. So, for example, a 
 SwiftUI project might have a list that is dynamically populated by external data. This would 
 allow you to inject dummy data into the preview window without running your app and 
 calling an API.",NA
Building for multiple devices,"Whether you're building for iOS, macOS, iPadOS, tvOS, or watchOS, SwiftUI has you 
 covered. All the features of SwiftUI can be built once and can support multiple devices, 
 thus eliminating the need to write code multiple times.
  
 In this book, we'll start by building an iOS app, which can be easily turned into an iPadOS 
 app, followed by a watchOS app.
  
 With UIKit, we had many options to build a cross-device UI right within Interface Builder, 
 but this could often lead to complicated AutoLayout constraints, traits, or even size classes 
 (which no-one ever really understood...).
  
  
 SwiftUI's standard library is written in Swift. However, its core 
 foundation is actually written in C++ .
  
 Next, we'll talk about the circumstances in which we may want to use or benefit from 
 SwiftUI.",NA
"When to use SwiftUI, and why","When it comes to using SwiftUI, first off, you need to start by thinking of what type of app 
 you're building. If you're looking to build the next shoot-em-up multiplayer game, then I'm 
 afraid SwiftUI is not for you. However, anything else
 —
 from a banking app to a catalog 
 app
 —
 can benefit immediately from Swift UI.
  
 The afore mentioned declarative syntax allows for States to be used in order to allow 
 effective but
 —
  more importantly
 —
 efficient reloads of data. For those familiar with UIKit's 
 UICollectionViews or UITableViews, you'll know that writing logic to reload the whole 
 table in order to change just one tiny value can be both tiresome and tedious.
  
 Designers taking their first step into development will certainly benefit from SwiftUI, with 
 top graphical design packages already rumored to be incorporating plugins that will allow 
 SwiftUI syntax to be exported directly from the drawing board.
  
 The term full-stack is often used (and overused) in the development industry, particularly 
 with web developers. A frontend web developer would generally look after the design 
 elements and visual construction of a site, such as HTML, 
 Cascading Style Sheets
  (
 CSS
 ),",NA
Summary,"In this chapter, we learned the history of Swift as a programming language, and how its 
 first big milestone kick-started a now-thriving community. We then covered how UIKit was 
 used alongside Swift to design and develop iOS apps and touched on its aging and complex 
 syntax. The introduction of SwifUI came as a perfect companion to Swift, opening up 
 avenues not just for seasoned developers but also for designers and people just starting 
 their journey into the world of Apple app development. 
  
 Next, we are going to delve more deeply into the declarative syntax and talk about the 
 benefits of this particular programming paradigm.",NA
Questions,"1. 
  
 Which paradigms do SwiftUI & UIKit follow?
  
 2. 
  
 What was Swift's first big change?
  
 3. 
  
 What is open source software?
  
 4. 
  
 For which platforms can SwiftUI be developed?
  
 5. 
  
 Which UI GUI tools were used before SwiftUI?",NA
Further reading,"SwiftUI:
 https://developer.apple.com/xcode/swiftui
  
 WWDC:
 https://developer.apple.com/wwdc19/
  
 Declarative Programming:
 https://en.wikipedia.org/wiki/Declarative_ 
  
 programming
  
 Open Source 
  
  
 Software:
  https://en.wikipedia.org/wiki/Open-source_software",NA
Understanding Declarative ,NA,NA
,NA,NA
Syntax,"In this chapter, you'll learn about the core fundamentals of the declarative syntax. You'll be 
 able to identify and understand the theory behind it and the part it plays in SwiftUI 
 development. We'll look specifically at how the syntax is written and how easily it can be 
 intercepted and edited in a live debugging environment, all within Xcode. We'll finish off 
 by going deeper into the structure of the syntax and understand how it all binds together. 
 By the end of this chapter, you'll be able to fully understand what advantages are on offer, 
 along with how to comfortably write a basic UI using declarative syntax.
  
 Without declarative syntax, there would be no SwiftUI, or it would simply be another UIKit 
 forcing users to learn a new framework with the same base language. Due to this, it is 
 important to learn the fundamentals of the syntax as this will help you not only understand 
 the core principles of SwiftUI but how to successfully utilize and build on the foundation 
 that has been laid.
  
 Learning SwiftUI without understanding its declarative syntax would be like trying to 
 drive without really knowing what a car is and, although this does sound like a lot to learn 
 before you've even written your first line of code, with this knowledge at hand, you'll be 
 able to jump right into coding the syntax without any worries.
  
 The following topics will be covered in this chapter:
  
 What is declarative syntax?
  
 Visualizing declarative syntax
  
 Nesting and decoration",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply follow these steps:
  
 1. 
  
 Search for 
 Xcode
  in the App Store and select and download the latest version.
  
 2. 
  
 Launch Xcode and follow any additional installation instructions that your 
  
 system may prompt you for.
  
 3. 
  
 Once Xcode has been fully launched, you're ready to go!",NA
What is declarative syntax?,"In this section, you'll learn what declarative syntax is and what immediate benefit it offers 
 for writing clean code. You'll also learn about its counterpart 
 imperative
  syntax in order to 
 gain understanding from both paradigms.
  
 The declarative syntax is a programming paradigm that allows you to write code in a more 
 formal and procedural way. In essence, the declarative syntax is a way of describing the 
 code you want to write, without having to worry about how it's going to be implemented.
  
 The following is an example of declarative syntax if it was said in spoken language:
  
 “
 I would like a cup of tea, please""
  
 This is more of a statement than written logic as we are asking for something rather than 
 being concerned about how we are going to get it.
  
 Let's take our first look at SwitUI syntax. Here, we have created a Text Label with the value 
 ""Learn SwiftUI""
  and guess what... that's all we need to do:
  
 Text(""Learn SwiftUI"")
  
 As you may recall from 
 Chapter 1
 , 
 Getting Started with SwiftUI
 , and how we created 
 Objects such as an instance of a 
 UIButton
  or a 
 UILabel
 , the example involves a lot less 
 code; we don't need to jump through hoops to tell SwiftUI what we want to create 
 –
  we 
 simply ask for it.
  
 Many languages already make use of declarative programming. A more commonly known 
 language is the SQL syntax that's used in database queries and stored procedures.",NA
Visualizing declarative syntax,"As we mentioned in the previous chapter, declarative syntax is used by many languages. A 
 relatively recent framework, Google's Flutter, took on the declarative syntax approach and 
 the wider developer community was immediately hooked. With this, it was only a matter of 
 time before other frameworks started to follow.
  
  
 At the time of writing this book, Google has just announced Jetpack 
 Compose for Android, which itself adopts the same approach to UI 
 development. 
  
 Now, let's take our first steps into programming with SwiftUI. We'll start by getting to grips 
 with Xcode, learn the basics of how to create a new project, and start to write our very first 
 SwiftUI code!",NA
Getting started with SwiftUI in Xcode,"Let's start by opening Xcode and taking a look at how to set up our first SwiftUI project:
  
 1. 
  
 Start by opening Xcode.
  
 2. 
  
 Select 
 Create a new Xcode project.
  
 3. 
  
 Select 
 Single View App.
  
 4. Finally, select 
 Next.",NA
"Making a ""Hello World"" app","Learning a new programming language always starts with ""Hello World"", no matter how 
 experienced a developer you are (and I won't have anyone tell me any different).
  
 SwiftUI is no different. By default, it will give you some very basic boilerplate code to 
 get you started. If you followed the preceding sections correctly, you'll be presented with 
 the following:
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  Text(""Hello World"")
  
  
  } 
  
 }
  
 This is your first look at SwiftUI's declarative syntax 
 –
  looks great, doesn't it? Well, actually, 
 it doesn't look like a lot, but when we break it down, you'll see how powerful it is and how 
 much is actually being done.
  
 Let's start by taking a look at the first couple of lines:
  
 struct ContentView: View {
  
  
  var body: some View { } 
  
 }
  
 What does this mean? Well, this is your main Content View for the 
 Single View App
  you're 
 about to create. In terms of UIKit, this is your main 
 UIView
 , which may sit inside your 
 existing 
 UIViewController
  or simply be a view on its own. Everything that is going to be 
 displayed on your screen will be returned in this one single view. We can, however, have 
 multiple views being returned inside the body of 
 ContentView
 , which leads us on to the next 
 part 
 –
  a 
 TextView
 :
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  TextView(""Hello World"")
  
  
  } 
  
 }",NA
Returning multiple views,"Even with implicit returns, we can add multiple views to our body without the need for the 
 return
  keyboard. First, let's try adding another TextView and see what happens:
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  Text(""Hello World"")
  
  
  
  Text(""Learn SwiftUI"")
  
  
  } 
  
 }
  
 Looking at the preceding example and trying to add another 
 TextView
  underneath the 
 existing one looks the right thing to do, but, unfortunately, if you duplicate the 
 TextView 
 in 
 the current body, you'll be immediately presented with the following error:
  
 Function declares an opaque return type, but has no return statements in its body from which to infer 
 an underlying type",NA
Nesting and decoration,"Just from the examples in the previous section, you've seen the immediate benefit of not 
 only SwiftUI but how it uses the declarative syntax to create Views and add them to your 
 application.
  
 In this section, we are going to dive a little deeper down the rabbit hole and look at how 
 declarative syntax makes use of modifiers to decorate our Views and how to best handle 
 adding multiple Views inside each other without getting into too much trouble.",NA
Modifiers,"Modifiers in SwiftUI are a simple yet effective way of rendering custom interactions 
 and decoration. Let's take our previous example, add some basic modifiers, and see 
 what we get:
  
 struct ContentView: View {
  
  
  var body: some View {",NA
Nesting syntax,"In this section, we'll cover nesting views within our main body view and learn when they 
 are used. Believe it or not, we touched on nesting in the previous section. Remember when 
 we added a List wrapper around our multiple Text boxes? That was nesting.
  
 Let's have a look at some more examples of nesting in SwiftUI. First, we'll start off with our 
 code from the previous section, which incorporated a List:
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  List {
  
  
  
  Text(""Hello World"")
  
  
  
  
  .bold()
  
  
  
  
  .foregroundColor(.blue)
  
  
  
  
  .blur(radius: 1, opaque: false)
  
  
  }
  
  
  } 
  
 }
  
 Next, we're going to add a Navigation view to our app since we want this to control the 
 whole content of our app. To achieve this, we simply wrap 
 NavigationView { }
  around the 
 existing logic sat within our body:
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  NavigationView {
  
  
  
  List {
  
  
  
  
  Text(""Hello World"")
  
  
  
  
  
  
  .bold()
  
  
  
  
  
  
  .foregroundColor(.blue)
  
  
  
  
  
  
  .blur(radius: 1, opaque: false)
  
  
  }
  
  
  
  }
  
  
  } 
  
 }
  
 As you can see, our new 
 NavigatonView
  sits just inside of the 
 body
  but wraps around our 
 existing content (List and its Children).",NA
Grouping,"Grouping is a way of visually managing views within your code base. This can be 
 performed very easily in SwiftUI by simply wrapping 
 Group {}
 around your content 
 within a 
 List
  view, for example.
  
 Try by adding the following to the code in the previous section and view the results in the 
 Automatic preview window:
  
 I've removed the modifiers for this example as we'll be adding many more Text 
 views shortly.
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  NavigationView {
  
  
  
  List {
  
  
  
  
  Group{
  
  
  
  
  
  
  Text(""Hello World"")
  
  
  
  
  }
  
  
  
  }
  
  
  
  }
  
  
  } 
  
 }
  
 Let your Automatic preview windows update and take a look. What can you see? That's 
 right 
 –
  not much. Groups won't actually affect the way your UI is displayed as these 
 containers are just a way for you (the developer) to order and add some structure, and 
 allow you to visualize your syntax a little easier.
  
  
 As well as syntax aesthetics, you'll need to use Groups when returning 10 
 or more Views in one go as SwiftUI's 
 ViewBuilder
  won't allow it.",NA
Imperative syntax,"Imperative syntax is the more common form of programming that's used as it's much more 
 functional and requires the programmer to write code that will tell the compiler how we are 
 going to achieve the goal, rather than ask politely. The following is an example of 
 imperative syntax:
  
 “
 I would like some boiled water, a teabag, milk, and sugar. Allow the tea to brew for n 
 minutes then add n teaspoons of sugar and n amount of milk
 ……
  oh and remove the 
 teabag.""
  
 Even with the preceding example, we could dig even deeper and say ""
 I need some water, then 
 boil the water
 "" or ""
 type or brand of sugar
 "".
  
 Let's take a look at the following Swift code. This is a typical class you may see when 
 writing a standard Swift app. Take a closer look at the 
 makeBrew()
  function and how each 
 step is coded so that the compiler knows exactly what to do. This approach is imperative 
 programming:
  
 func makeBrew() {
  
  
  let brew = MakeBrew()
  
  brew.addTeabag(type: .earlGrey)
  
  brew.boil()
  
  brew.pourWater()
  
  
  DispatchQueue.main.asyncAfter(deadline: .now() + 120) {
  
  
  
 brew.addMilk(ammount: 11.0)
  
  
  
  brew.addSugar(ammount: 2)
  
  
  
  brew.stir()
  
  
  } 
  
 }
  
 This is an effective class nonetheless, but there will potentially be a lot of code. This is not 
 exactly UI logic, but this hopefully gives you a better idea about the structure of imperative 
 syntax, especially when you compare it to SwiftUI's declarative syntax.",NA
Summary,"In this chapter, we learned how declarative syntax allows the developer to write syntax in a 
 way that describes the actions and functions required and how its counterpart, imperative 
 programming, is more logic-based.
  
 We learned about the structure of declarative syntax and how understanding the view 
 hierarchy is important to us, especially as every component on the screen is of the 
 View
  
 type.
  
 We also got to use SwiftUI for the first time in Xcode and took our first glance at the 
 structure and arrangement that the declarative syntax has to offer, including nesting Views, 
 and the importance of Group containers to arrange our subviews.
  
 In the next chapter, we'll move onto the layout of SwiftUI and understand the structure of 
 not just our code, but the architecture of our code base.",NA
Questions,"1. 
  
 Describe declarative syntax.
  
 2. 
  
 What other syntax paradigms can we use?
  
 3. 
  
 What do modifiers do?
  
 4. 
  
 What visual effects do Groups have on our UI?
  
 5. 
  
 When are we forced to use Groups in SwiftUI?",NA
Further reading,"Declarative Programming
 : 
 https://en.wikipedia.org/wiki/Declarative_ 
  
 programming
  
 SwiftUI View Modifier
 : 
 https://developer.apple.com/documentation/ 
  
 swiftui/
 viewmodifier
  
 SwiftUI Groups
 : 
 https://developer.apple.com/documentation/swiftui/ 
  
 group",NA
Building Layout and Structure ,NA,NA
,"Now that we know a little bit about SwiftUI's syntax, let's look at how best to structure not 
 only our code but also our project. In this chapter, you'll learn the importance of app 
 architecture; we'll cover two of the most commonly used ones, 
 Model-View-View-Model
  
 (
 MVVM
 ) and 
 Model-View-Controller
  (
 MVC
 ), to see not only what they do, but also how 
 we can adopt them in SwiftUI.
  
 Learning about the importance of app architecture will allow us to not only understand but 
 also visualize the separation of UI and application logic. More importantly, we'll learn how 
 this separation will allow us to look closely at how SwiftUI works seamlessly with the new 
 Combine framework in order to achieve a powerful yet efficient pattern.
  
 The following topics will be covered in this chapter:
  
 UI logic 
 –
  the MVVM architecture
  
 Design patterns in SwiftUI",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from Apple's App 
 Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you with. Once Xcode has fully launched, you're ready to go.
  
 Download the sample code from the following GitHub link:
  
 https://github.com/PacktPublishing/Learn-SwiftUI",NA
Understanding UI logic ,NA,NA
–,NA,NA
 the MVVM ,NA,NA
architecture,"In this section, you'll learn about how UI logic is separated from core application logic by 
 taking your first look at the MVVM architecture pattern. MVVM is a widely used design 
 pattern that allows us to separate core application logic from UI logic.
  
 We'll go into the MVVM pattern in detail, which in turn will allow you to identify where 
 SwiftUI should sit within a project.",NA
MVVM overview,"Let's start by looking at what MVVM actually has to offer. MVVM is a very popular and 
 widely used architecture in the development industry alongside many others, 
  
 including 
 Model-View-Presenter
  (
 MVP
 ) and 
 Model-View-Controller
  (
 MVC
 ).
  
 Although SwiftUI doesn't necessarily encourage a specific pattern, it doesn't mean you can't 
 follow one yourself; MVVM particularly lends itself to SwiftUI.
  
 Take a look at the following diagram. This is a standard MVVM pattern for a generic 
 application:
  
  
 As you can see, there are three main components here. Let's take a look at each of them, 
 going from left to right:
  
 Model
 : This is your core model, which will contain all data that you may have 
  
 consumed from a database or via an external API.
  
 ViewModel
 : A stripped-down or UI-tailored representation of your Model that 
  
 contains only the information required for your View.",NA
MVVM in SwiftUI ,"Although SwiftUI is provisionally a UI framework, apps being built in SwiftUI will mostly 
 be written in SwiftUI's syntax, so architecture patterns are just as important.
  
 Looking back at the MVVM diagram in the previous section, how does a SwiftUI project sit 
 within this pattern and do we need to make any changes to the way we work?
  
 The answer is: NO, not really. SwiftUI conforms nicely to this pattern, which you can see in 
 the following diagram:",NA
Other architecture patterns,"MVVM is a great way to get started with SwiftUI, but there are many other patterns, and 
 you might not always have the luxury of starting a project from scratch. So, let's take a look 
 at another very common pattern, MVC, which doesn't necessarily fit into SwiftUI's design 
 patterns. Comparing MVC to SwiftUI will allow us to identify SwiftUI's place in a project:
  
 Model
 : Responsible for housing your user data 
  
 View
 : The UI presentation, displaying data bound from the Model
  
 Controller
 : Your application logic, the link between the View and the Model
  
 So, why doesn't this work for SwiftUI? Well, there are two reasons, really:
  
 In 
 Chapter 2
 , 
 Understanding Declarative Syntax
 , we saw how SwiftUI uses the 
 declarative and not imperative syntax and how unnecessary application logic is 
 no longer needed: by simply 
 asking
  what we want. This logic, would have made 
 up a good portion of Controllers (or helpers or manager classes that were called 
 from our Controller).
  
 SwiftUI uses states and object binding, so there is no longer a need to have logic 
  
 in Controllers that controls and updates our UI; SwiftUI handles all of this for us.
  
  
 We mentioned states and bindings in 
 Chapter 1
 , 
 Getting Started with SwiftUI
  
 and touched on them in the preceding SwiftUI MVVM diagram. We'll go 
 over how the pattern fits into the application architecture later in this 
 chapter, before fully implementing it in our first app later on in the
  
 book.",NA
Design patterns in SwiftUI,"Now that we've compared two of the most common design patterns and we can see where 
 SwiftUI fits within them, we'll take a deeper look at how we can actually write SwiftUI to 
 conform to one of these patterns. In this section, we'll cover what a binding is and how this 
 helps us adhere to the MVVM pattern. We'll also cover states, which show why Controller 
 logic in MVC has no place in SwiftUI.",NA
Observable objects,"Next, we are going to look at observable objects, and by observable we mean models that 
 can change state or be updated due to an external API call. For example, a model that 
 houses weather information from a weather API might get updated periodically. We would 
 want our UI (or SwiftUI, in our case) to monitor this model for any changes and implement 
 updates accordingly.
  
 To dig a little deeper into how MVVM works with SwiftUI, let's write a small application 
 that takes some data from an external API, parses the data, and then displays the data 
 within our app.
  
 ObservableObject
  is a protocol that is part of the new Combine framework, which was 
 announced alongside SwiftUI at WWDC 19. Combine is Swift's own version of Reactive 
 Streams, and it enables objects to be monitored (observed) and data to be passed through 
 streams from core application logic back up to the UI layer. For example, a network request 
 that could take 
 n
  amount of time to retrieve data can be observed and, when ready, pushed 
 back asynchronously to the UI layer, which will be updated accordingly. Before Combine, 
 RxSwift was a very popular open source framework used for Reactive Streams.
  
 You'll find a link to a full working sample project for you to use as a reference at the 
 beginning of this chapter. The project is called 
 MVVM - Chapter 3
 . Simply download or 
 clone the GitHub link and double-click the file called 
 Chapter 3 MVVM.xcodeproj
 . This will 
 launch Xcode.",NA
Publishing objects,"This is where things start to get exciting...
  
 Let's start by taking a look at our SwiftUI View; you'll find this under the 
 View
  group in the 
 file tree:
  
  
 First of all, let's take a look at the code in the body and go through exactly what's going on 
 here:
  
  var body: some View {
  
  
  
  List(model.articles) { article in
  
  
  
  VStack(alignment: .leading) {
  
  
  
  
  Text(article.title)
  
  
  
  
  Text(article.description)
  
  
  
  
  
  
  .foregroundColor(.secondary)
  
  
  }
  
  
  
  }
  
  
  }",NA
Summary,"We've learned a lot in this chapter. First, we looked at the importance of app architecture 
 and the separation of UI logic and application logic. This was a fundamental building block 
 in our understanding of how SwiftUI's framework sits within an app architecture. Next, we 
 covered MVVM and MVC and compared them to see how SwiftUI fits (and doesn't fit) into 
 these structures. We learned that MVC has no place in SwiftUI due to its use of controller 
 logic, which is not really needed in SwiftUI.
  
 Then, we looked at a sample project that made good use of the MVVM architecture. By 
 looking at the code and how the responsibilities of each class were laid out, we were able to 
 easily see the role of SwiftUI with the app. Also, this pattern allowed us to explore and 
 understand object binding, which is part of the Combine framework released alongside 
 SwiftUI.
  
 In the next chapter, we'll start to take everything we've learned from the first three chapters 
 and begin to build our very own recipe app 
 –
  all in SwiftUI.",NA
Questions,"1. 
  
 Name two common architecture patterns.
  
 2. 
  
 What architecture pattern doesn't fit the SwiftUI way of working?
  
 3. 
  
 What is the ViewModel responsible for?
  
 4. 
  
 What does our ViewModel need to conform to in order to become observable?
  
 5. 
  
 Which framework do Publish and Observable belong to?",NA
Further reading,"Combine Framework:
  https://developer.apple.com/documentation/combine
  
 MVVM Architecture
 : 
 https://en.wikipedia.org/wiki/ 
  
 Model%E2%80%93view%E2%80%93viewmodel
  
 RxSwift:
 https://github.com/ReactiveX/RxSwift",NA
Creating Your First Application ,NA,NA
,"In this chapter, we'll begin to code our very first app in SwiftUI 
 –
  exciting, I know, but 
 before we learn to run, we need to walk a little further first. The Xcode IDE will play a 
 fundamental role in our journey, so we'll cover the basics and core components in a little 
 more detail. We'll look at how Xcode allows us to write our SwiftUI code and give us 
 almost immediate feedback. We'll also touch on how and, more importantly, why we may 
 need to use the iOS simulator to run our app in certain scenarios. 
  
 The following topics will be covered in this chapter:
  
 Xcode, as an IDE
  
 Core components of Xcode
  
 Mock data in Automatic Preview",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.0 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search 
 Xcode
  in the App Store and select and download the latest version. Launch 
 Xcode and follow any additional installation instructions that your system may prompt you 
 for. Once Xcode has been fully launched, you'll be ready to go.",NA
"Xcode, as an IDE","In the previous chapters, we covered some of the fundamental basics elements of Swift, 
 SwiftUI, and the application architecture. In those chapters, we touched on Xcode, Apple's 
 integrated development environmen
 t (
 IDE
 ) for creating iOS, iPadOS, watchOS, and 
 macOS applications. Many different frameworks and programming languages use various 
 IDEs 
 –
  Android developers may use the Android Studio IDE, Java developers will most 
 commonly use Eclipse, and .NET Microsoft developers will use Visual Studio.
  
 As you can probably tell by Xcode's latest version (11), it's been around for a while and is 
 exclusive to macOS. While you can use other programming languages such as C and C++, 
 Xcode is predominantly used for core Apple development.
  
 In this chapter, we'll have a closer look at Xcode and get to know the IDE a little better. 
 We'll cover various menu options, shortcuts, and debugging tools, all in preparation for the 
 next chapter, where we'll start writing our very first iOS app in SwiftUI.",NA
Creating our first project,"It's time to create our very first project! We touched on this back in 
 Chapter 3
 , 
 Building Layout 
 and Structure
 , but let's take a closer look at some of the options we're presented with when 
 creating a project and why they are important.
  
 Let's get started by performing the following steps:
  
 1. 
  
 Launch Xcode.
  
 2. 
  
 Go to 
 File | New | Project
 .
  
 3. 
  
 Select 
 Single View App
  and click 
 Next
 .
  
 4. 
  
 For 
 Product Name
 , type 
 My Favourite Recipes
 .
  
 5. Make sure 
 SwiftUI
  is selected for the 
 User Interface.",NA
Core components of Xcode,"Much like many other IDEs, Xcode has a plethora of options and tools to choose from. In 
 this section, we'll cover some of the basics and firm favorites that may seem familiar with 
 other IDEs and have been there from the start, as well as some that are specific to SwiftUI. 
 Unlike many other IDEs, Xcode doesn't rely on (or allow even) third-party extensions or 
 plugins, thus making all its features not only safe but reliable.",NA
Navigator,"The Navigator (or the file tree, in some cases) is a common component in many IDEs and 
 Xcode is no different. The Navigator can be found on the left-hand side of the interface 
 and offers options such as filtering, search and replace, errors and warnings, debugging 
 options, and many more:",NA
Scheme and device list,"Next, let's take a look at the scheme and device list, which can be found at the top of Xcode. 
 In a nutshell, the scheme (on the left-hand side of the picture) is your app. At this stage, 
 that's all you really need to know.
  
 The following is what you should see for your scheme and device list in Xcode:
  
  
 Devices, when clicked, will give you a list of available iOS simulators that you can use to 
 run your app. Also, if connected, your iPhone or iPad will show up in this list too, allowing 
 you to debug and run your application directly on a physical device. For the majority of this 
 book, we'll be running all our applications on a simulator or more excitingly, we'll be using 
 the brand new 
 Automatic Preview
  option that was introduced with Xcode 11 and macOS 
 Catalina.",NA
Automatic Preview ,"Xcode 11 brought us a lot of new features, but one of the most exciting ones was that of the 
 Automatic Previewer, which is built directly into the Xcode 11 IDE.
  
 Automatic Previewer sits to the right of the Xcode IDE and allows us to preview the 
 changes we are making in SwiftUI without the need to run the simulator, as shown here:
  
  
 As shown in the preceding screenshot, this is the Automatic Preview window in its initial 
 state; nothing has been run yet. Let's look at what happens when we press 
 Resume
 :
  
  
 [ 46 ]",NA
Xcode Simulator,"The Automatic Previewer is a fantastic new addition to Xcode 11 and is specifically for 
 building interfaces with SwiftUI, but, when the time comes to test your application with 
 core logic such as networking or switching between screens, you'll need to call on the 
 power of the Code Simulator.
  
 Going back to the device list next to the scheme bar we saw earlier, select a simulator you 
 would like to test against and then press the play button to the left of it.",NA
Mock data in Automatic Preview,"As we mentioned in the previous section, the Automatic Preview window is a brand new 
 feature for Xcode 11 and macOS Catalina. It allows you to view your UI changes without 
 the need to launch the simulator and reload the application. In this section, we'll take a look 
 at how we can mock data that we will inject into our View in order to preview our UI 
 changes with simulated content, but, more importantly, we'll cover why this is important.",NA
Understanding Automatic Preview,"Automatic Preview will no doubt play a big role as you venture into the world of SwiftUI 
 as you'll be able to create your content with the ease and beauty of SwiftUI's declarative 
 syntax and the ability to see your changes hot-reload instantly in front of you. But the 
 ability to inject mock data at the same time will not only save you time but let you 
 effectively make structural designs with ease.
  
 Let's start by taking a look at what we mean by this. In your new project, update your 
 body 
 with the following code:
  
  var body: some View {
  
  Group {
  
  
  
  VStack {
  
  
  
  
  List(recipeNames, id: \.self) { name in
  
  
  
  
  Text(""\(name)"")
  
  
  
  
  }
  
  
  
  
  List(recipeModel.recipes, id: \.self) { name in
  
  
  
  Text(""\(name)"")
  
  
  
  
  }
  
  
  
  }
  
  }
  
  }
  
 Here, we have a Group since we are going to return two 
 Lists
  nested inside a 
 Vertical-Stack
  
 (
 VStack
 ). The first List is going to iterate around a global array called 
 recipeNames 
 within 
 our struct, while the second will iterate around a List that is coming from an external source 
 via a model called 
 recipeModel
  (which we'll simulate for the purpose of this example).",NA
Understanding the Preview Provider,"PreviewProvider
  is brand new to Xcode 11 and specifically new to SwiftUI. By creating a 
 struct that conforms to the 
 PreviewProvider
  protocol (which sits within your SwiftUI class; 
 for example, 
 ContentView.swift
 ), along with a couple of lines of code, Xcode will 
 automatically generate a preview of your SwiftUI View.
  
 As we've seen so far, using the Automatic Preview window is a real treat, but there are a 
 couple of scenarios that we need to be aware of.
  
 So, let's start by stripping back our project a little. While removing the hardcoded values, 
 make the following changes to the struct:
  
 struct ContentView: View {
  
  
  var recipeNames = [String]()
  
  
  var body: some View {
  
  
  
  VStack {
  
  
  
  List(recipeNames, id: \.self) { name in
  
  
  
  
 Text(""\(name)"")
  
  
  
  }
  
  
  
  }
  
  
  } 
  
 }
  
 Here, we're simply amending the app to iterate around a list of 
 String()
  since there is no 
 data. We can't see what or how the View is going to be displayed. This is where 
  
 PreviewProvider
  comes in. Take a moment to familiarize yourself with the following code:
  
 struct ContentView_Previews: PreviewProvider {
  
  static var 
 previews: some View {
  
  
  
  ContentView()
  
  
  } 
  
 }
  
 The preceding struct is responsible for generating the preview we can see in the Automatic 
 Preview window. By creating a struct that conforms to the 
 PreviewProvider
  protocol, we can 
 simply create a static variable that returns our 
 ContentView()
  struct.",NA
Summary,"In this chapter, we started our very first application and took a deeper look around Xcode 
 as an IDE, along with the fundamental changes that were made specifically for SwiftUI. We 
 touched on schemes and device lists, but most importantly, the Automatic Preview 
 window.
  
 We also learned how SwiftUI uses the Automatic Preview window and covered scenarios 
 when it doesn't, in which case we would have to revert back to the iOS simulator.
  
 In the next chapter, we'll look at some of the commonly used UI controls (such as text and 
 images) and how to apply them within our app.",NA
Questions,"1. 
  
 What does IDE stand for?
  
 2. 
  
 Why would the Automatic Preview window not display our data?
  
 3. 
  
 How do we inject mock data to display content in the Automatic Preview 
  
 window?",NA
Further reading,"Xcode
 : 
 https://en.wikipedia.org/wiki/Xcode
  
 Reverse Domain Name Notation:
 https://en.wikipedia.org/wiki/Reverse_ 
  
 domain_name_
 notation
  
 Swift Documentation
 –
  Classes and Structures
 : 
 https://docs.swift.org/ 
  
 swift-book/
 LanguageGuide/ClassesAndStructures.html
  
 [ 55 ]",NA
"Understanding Controls, Views, ",NA,NA
,NA,NA
and Lists,"User interaction plays a big part in all apps; from pressing buttons to gestures, images to 
 switches, Apple takes care of it. While creating interactions programmatically has always 
 been an available option, taking advantage of out-of-the-box system controls has never 
 been easier. Along with the help of Apple's Human Interface Guidelines, SwiftUI makes 
 this even easier.
  
 In this chapter, we'll learn how to add buttons, images, and segmented pickers to our app
 —
 we'll see how easy it is to decorate our controls with the simple use of modifiers. We'll also 
 look at creating custom views that allow us to reuse a specific View in multiple areas of our 
 app, without the need for code duplication. We'll go deeper into the automatic previewer 
 and see how we can reuse mock data that has been previously created to work on our 
 specific custom View.
  
 By the end of this chapter, you'll have a much clearer understanding of how controls work 
 within SwiftUI, and specifically, how they fit into the everyday life of an iOS app and how 
 to continue to adhere to Apple's Human Interface Guidelines.
  
 The following topics will be covered in this chapter:
  
 Exploring and understanding 
 Text
  and decoration
  
 Custom Views in Lists
  
 Adding more controls",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store, and then select and download the latest version.
  
 Launch Xcode, and then follow any additional installation instructions that your system 
 may prompt you for. Once Xcode has fully launched, you're ready to go.",NA
Exploring and understanding Text and ,NA,NA
decoration,"In the last chapter, we started to build the skeleton of our very first SwiftUI app, and in this 
 section we are going to take this a little further and continue to build upon the app. We'll 
 take our basic List and then expand on the various 
 Text
  options that are available to us in 
 SwiftUI, along with how we can add images to our List that are not only stored locally, but 
 also dynamically from an external source.
  
 Finally, we'll dig a little deeper into modifiers in order to help decorate our app. By adding 
 those little bells and whistles, we'll start to see how the little things that we do make our 
 app feel more intuitive.",NA
Text options,"We've covered the 
 Text()
  object in a couple of chapters now, but there is so much more to 
 show, so let's head straight back to the code that we left in 
 Chapter 4
 , 
 Creating Your First 
 Application
 :
  
  var body: some View {
  
  VStack {
  
  
  List(recipeNames, id: \.self) { name in
  
  
  
 Text(""\(name)"")
  
  
  }
  
  }
  
  }",NA
Updating PreviewProvider,"Your Automatic Preview will now show a nice stacked cell with both a headline-styled font 
 and a sub-headline-styled font. But our app isn't going to show duplicate recipe names as 
 we've created so far, so we'll now adjust the model that we created in 
 Chapter 4
 , 
 Creating 
 Your First Application
 , in order to accept a sub-heading.
  
 Make the following change to 
 RecipeModel.swift
 :
  
 struct RecipeModel: Identifiable, Hashable {
  
  var id = 
 UUID()
  
  
  var name = """"
  
  
  var origin = """" 
  
 }
  
 We've really stripped this down so that it is a basic model passing in just a unique ID and 
 name and origin properties. Next, we'll update 
 ContentView.swift
  to reflect this change, as 
 shown here:
  
  var 
 recipes
  = [RecipeModel]()
  
  var body: some View {
  
  VStack(alignment: .leading) {
  
  
  List(
 recipes
 , id: \.id) { 
 recipe
  in
  
  
  
 VStack {
  
  
  
  
  
  Text(""\(
 recipe.name
 )"")
  
  
  
  
  
  
  .font(.headline)
  
  
  
  
  
  Text(""\(
 recipe.origin
 )"")
  
  
  
  
  
  .font(.subheadline)
  
  
  }
  
  
  }
  
  }
  
  }
  
 Noticeable changes have been highlighted in the preceding code, but these are mainly just 
 changes to the model name and to the properties that we'll access while we iterate around a 
 recipe in our array of 
 RecipeModel()
 .
  
 Next, we'll need to update our 
 PreviewProvider
  struct. As you'll probably already have seen, 
 nothing is showing up, so we'll need to make a couple of changes. Make the following 
 amendment to your code and then let's go through it:
  
 struct ContentView_Previews: PreviewProvider {
  
  
  static var previews: some View {
  
  
  
  ContentView(recipes: ContentPreviewHelper.mockRecipes())
  
  } 
  
 }",NA
A little more Text decoration,"Now that we've got some more structure to our app, we can go back and add a little more 
 decoration. Start by adding the highlighted modifiers to our 
 Text
  Views and see what 
 happens, as shown here:
  
 Text(""\(recipe.name)"")
  
  
  .font(.headline) 
  
  
 .foregroundColor(Color.blue) 
  
 Text(""\(recipe.origin)"")
  
  
  .font(.subheadline) 
  
  
 .foregroundColor(Color.purple)",NA
Creating custom Views in Lists,"In this section, we'll take a look at how we can create custom and re-usable views to use in 
 our List View. It's important that we understand the value of doing this early on, as it 
 reduces the need for code duplication; while SwiftUI's declarative syntax is visually 
 appealing, too much code in your struct can be daunting and very unnecessary.",NA
Creating a custom view,"First, let's start by creating another custom view, which, in turn, will house our layout and 
 logic for each row. At the bottom of the 
 ContentView.swift
  file, create the following struct in 
 the format that would create a View struct for SwiftUI:
  
 struct RecipeView: View {
  
  var body: some View {
  
  
  } 
  
 }
  
 We've called this struct 
 RecipeView
 , and as per its name, it will contain all the UI logic that is 
 needed in order to display the recipe information that is required for our List View.
  
 Next, let's populate this with the code that we previously created in the 
 Exploring and 
 understanding Text and decoration
  section. Let's start by highlighting the area in the following 
 code that we are going to extract, and learn a little about which bits we need to leave in, and 
 why:
  
 var body: some View {
  
  
  VStack(alignment: .leading) {
  
  
  
  List(Recipes, id: \.id) { Recipe in
  
  
  
  VStack {
  
  
  
  
  Text(""\(recipe.name)"")
  
  
  
  
  
  
  .font(.headline)
  
  
  
  
  
  
  .foregroundColor(Color.blue)
   
  
  
  
  .bold()
  
  
  
  
  Text(""\(recipe.origin)"")
  
  
  
  
  
  
  .font(.subheadline)
  
  
  
  
  
  
  .foregroundColor(Color.purple)
  
  
  
  
  
  .italic()
  
  
  
  }
  
  
  
  }
  
  
  } 
  
 }",NA
Working independently with our new custom ,NA,NA
view,"Now that we've successfully created our own custom view, let's take this a step further and 
 extract this into its own file, so that we can work on this independently should we ever 
 need to. To do that, follow these steps:
  
 1. 
  
 Create a new file in our Xcode project called 
 RecipeView
 , by highlighting the 
  
 group name in the file tree, then right-click and select 
 New File
 :
  
  
 [ 65 ]",NA
Adding more controls,"Now that we have a solid foundation for getting our app off the ground, let's experiment 
 with some more controls that are available for us to use in SwiftUI. We've already touched 
 on some of the basic controls, such as Text and Button, but from a UI perspective. We can 
 add some really valuable user interaction not only by adding controls into our app for the 
 user, but by changing how controls easily and seamlessly interact with the way we handle 
 data in our app.",NA
Buttons,"Let's start by adding a Button to our app that has an image. The reason that we want 
 Buttons
 —
 rather than just an image
 —
 is that we want the user to be able to interact with this 
 control, which not only performs an action, but can also change the state of our app.
  
 Let's start by heading over to our 
 RecipeView.swift
  file and we'll work from there. To start 
 with, make the following highlighted changes to the code, and we'll go through them one 
 by one:
  
 var body: some View { 
  
 Group {
  
  
  
  VStack(alignment: .leading) {
  
  
  
  Text(""\(recipe.name)"")
  
  
  
  
  .font(.headline)
  
  
  
  
  .foregroundColor(Color.blue)
  
  
  
  
  .bold()
  
  
  
  Text(""\(recipe.origin)"")
  
  
  
  
  .font(.subheadline)
  
  
  
  
  .foregroundColor(Color.purple)
  
  
  
  
  .italic()
  
  
  
  }
  
  
  
  VStack(alignment: .trailing, spacing: 10) {
  
  
  
  Button(action: {
  
  
  
  
  self.recipe.favourite.toggle()
  
  
  
  }) {
  
  
  
  Image(systemName: self.recipe.favourite ? ""star.fill"" : ""star"")
  
  
  }
  
  
  
  }
  
  
  
  .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment:
  
 .trailing) 
  
 } 
  
 }
  
 Let's go through the preceding code in more detail. First, notice that we've wrapped our 
 existing 
 VStack
  inside a 
 Group
 ; we covered this in 
 Chapter 2
 , 
 Understanding Declarative 
 Syntax
 , in that a Group is required when a View is required when returning more than 
 X 
 amount of rows in a List. In this case, it is the same principle as when returning multiple 
 Stacks (whether that is HStacks or VStacks).
  
 Second, we've added the previously mentioned second VStack and created a Button inside 
 it
 —
 let's take a closer look at how we created the Button.",NA
Images,"Adding images to use in an Xcode project has never been easier, whether that's 
  
 downloading them remotely from an API or accessing them locally. In this part, we'll 
 concentrate on adding images locally to the project, which can then be bundled as part of 
 the binary. Follow the steps given here:
  
 1. 
  
 First, head over to the project that was created specifically for this chapter (you 
  
 don't need to open Xcode, just access it via Finder on your Mac).
  
 2. 
  
 Inside the subfolders look for a file called 
 Assets.xcassets
 .
  
 3. 
  
 Copy this file, and head over to your project (again via Finder), locate 
  
 your 
 Assets.xcassets
 , and paste (choosing to replace, when prompted).
  
 4. 
  
 Now, back in Xcode, locate 
 Assets.xcassets
  in the file tree and highlight it.
  
 To the right of the file tree, you should see a List of images, specifically flags. 
 These images are now bundled and ready to use in our app, so let's head over to 
 RecipeModel.swift
 , and add the following property:
  
 var countryCode = """"
  
 We've added in 
 countryCode
 , which we'll pass across in our 
 mockData() 
 function, and from this we'll match up the country code with the name of the 
 images that we have just added in.
  
 5. 
  
 Now, go back over to our 
 RecipeView.swift
  file and make the following 
  
 highlighted amendment:
  
 VStack(alignment: .leading) {
  
  
  Text(""\(recipe.name)"")
  
  
  
  .font(.headline)
  
  
  
  .foregroundColor(Color.blue)
  
  
  
  .bold()
  
  
  Image(recipe.countryCode) 
  
 }
  
 Notice how we've removed the second 
 Text
  View and replaced this with an 
 image view; nice and simple, we simply just reference the 
  
 Assets.xcassets
  name of the image, and SwiftUI does the rest.",NA
Segmented (picker) contols,"Segmented controls (or a picker with the style of 
 SegmentedPickerStyle
 , as they are called 
 now) have been around for a long time in iOS development, often mistakenly referred to as 
 tab selectors (or selectors). The aim of segmented controls is to allow us to shift from one 
 view to another, all within a single screen. We'll create one in our application in order to 
 allow us to switch between two Lists
 —
 one List with all our recipes and another for our 
 favorites.
  
 First, we need to create a 
 Helper
  class along with a couple of functions that will allow us to 
 achieve this. Don't be too concerned about the actual logic in this Helper, although we'll go 
 over it at a higher level in order to understand what exactly is happening. Follow the steps 
 given here:
  
 1. 
  
 Create a new file in our Xcode project called 
 RecipeView
 —
 highlight the group 
  
 name in the file tree, right-click, and select 
 New File
 .
  
 2. 
  
 Select 
 Cocoa Touch Class
  from the 
 Source
  options and click 
 Next
 . Call your new 
  
 file 
 Helper.swift
  and then click 
 Create
 . Next, paste in the content from the 
  
 same 
 source file that was downloaded in the sample project
 —
 we'll go through 
  
 each 
 method one at a time to touch on what they do:
  
 addRemoveFavourite()
 : Adds or removes favorites based on recipe 
 name and whether they are already persisted (saved) or not.",NA
Summary,"In this chapter, we started by changing the style of our Text View by using pre-defined font 
 styles that are available to us through SwiftUI. Using our fonts in this way allows us to 
 easily keep a consistent look throughout the app, with very little effort. Next, we looked at 
 how to add color and how to amend the weight of our Text with the use of modifiers. From 
 this, we added another Text View and saw that by using a VStack, we could obtain our 
 desired look.",NA
Further reading,"SF 
  
 Symbols:
  https://developer.apple.com/design/human-interface-guideline s/sf-
 symbols/overview/
  
 Adding Images to 
  
 Xcode
  https://developer.apple.com/library/archive/documentation/Tools 
 Languages/Conceptual/Xcode_Overview/AddingImages.html
  
 Apple Human Interface 
  
 Guidelines
  https://developer.apple.com/design/human-interface-guidelin es/",NA
Working with Navigation in ,NA,NA
,NA,NA
SwiftUI,"In this chapter, we'll really start to bring our app to life by adding another View that will 
 list our recipe in full, along with ingredients and instructions. From this, we'll learn the 
 importance of navigation in our app, which, in turn, will allow us to tap into our existing 
 recipe lists and populate and view our recipe in full.
  
 This approach will require us to pass data from one View to another, which we'll cover 
 when adding our Views to a navigation stack. From this, we'll introduce the use of 
 EnvironmentObjects
 , which allow our Views to share objects globally, yet only requiring us 
 to initialize and inject data once.
  
 The following topics will be covered in this chapter:
  
 Creating additional Views
  
 App navigation
  
 Accessing with 
 @EnvironmentObject",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.",NA
Creating additional Views,"More often than not, apps have more than one page
 —
 in our previous chapter, we used a 
 cool way of switching between our lists using a segmented style picker, but for pages that 
 visually and logically look different, we require a completely different view.
  
 In this section, we are going to create a dedicated page for our recipe. We'll use Image 
 Views (for a picture of our recipe), Text Views for our recipe details, and we'll revisit 
 PickerView
  and look at the alternative options that this affords us.",NA
Creating the recipe details View,"We'll start by creating a new SwiftUI View. We'll create a new file in our Xcode project 
 called 
 RecipeDetailView
  by highlighting the group name in the 
 File Tree
 , right-clicking and 
 selecting 
 New File
 . Select 
 SwiftUI View
  from the 
 User Interface
  options and then click 
 Next
 . Call your new file 
 RecipeDetailView.swift
  and click 
 Create
 .
  
 Our details view will allow us to view the ingredients and recipe details of a selected dish. 
 There will be a bit more code in here than our previous files, but don't worry; we'll go 
 through the code one change at a time. First, let's start by adding the following two 
 properties to our new struct:
  
 @State var recipe: RecipeModel! 
  
 @State private var viewIndex = 0
  
 The 
 RecipeModel
  single model will contain the details of our recipe that we'll use to 
 populate the data in our view. 
 viewIndex
  will serve the same purpose as it did in the 
 previous chapter as, again, we'll be using a segmented control in this view.
  
 The following code snippets will be inside our 
 var body:
  some View declaration. We'll go 
 through these one at a time and they should be added to your project in this order:
  
 VStack(alignment: .leading, spacing: 15) {
  
  
  // Image (currently using flag)
  
  
  
  Image(recipe.countryCode)
  
  
  
  .resizable()
  
  
  
  .aspectRatio(contentMode: .fit)
  
  
  
  .frame(maxWidth: .infinity, maxHeight: 200)
  
  
  // Remaining code will go here... 
  
 }",NA
Updating our mock data,"With our new view all done and ready to go, you'll notice that we've added a couple of new 
 properties to our view, so our 
 Helper
  and 
 RecipeModel
  struct will need updating so that we 
 can view this in an automatic previewer. Make the following highlighted changes to the 
 RecipeModel.swift
  file:
  
 struct RecipeModel: Identifiable, Codable {
  
  var id = 
 UUID()
  
  
  var name = """"
  
  
  var origin = """"
  
  
  var countryCode = """"
  
  
  var favourite = false
  
  
  var ingredients = [String]()
  
  
  var recipe = """" 
  
 }
  
 As per the logic in our picker, the 
 ingredients
  property will be a list of strings (basically a list 
 of our ingredients) and 
 recipe
  will be our actual recipe instructions.
  
 Now, it's time to update our 
 Helper
  function, so head on over to 
 Helper.swift
 and add the 
 following function:
  
 private static func getMockIngredients() -> [String] {
  
  return [""1 x 
 Ingredient One"",
  
  
  
  ""2tbp Ingredient Two"",
  
  
  
  ""500g Ingredient Three"",",NA
Testing the new view in the simulator,"Sometimes, we'll want to perform a quick test in the actual simulator rather than the 
 automatic preview window. As we've not yet actually hooked up our view to the existing 
 code, we won't be able to run the app in its current state and see our new View. However, 
 we can make a small tweak with a view to performing a quick test (as long as we remember 
 to revert it back).
  
 Head on over to 
 SceneDelegate.swift
 and take a look inside. 
 SceneDelegate
  is generated as part 
 of the project when we first create it. SwiftUI uses this to set up our views and entry points 
 for the app. As you can see, our 
 ContentView
 is referenced here, which is currently our main 
 View. 
  
 To make this quick change, replace the first 
 ContentView
  reference with the following:
  
 let contentView = 
 RecipeDetailView()
  
 Then, make a quick change to the recipe model property in 
 RecipeDetailView.swift
 :
  
 //var recipe: RecipeModel!
  
 var recipe = Helper.mockRecipes().first!
  
 This is a little 
 hacky
 , but should the automatic previewer not give you enough to test with, 
 it's a good way to check your app in the simulator before hooking it up to the rest of your 
 app
 —
 which is exactly what we are going to do in the next section.",NA
App navigation,"As with the majority of apps, navigation plays a massive part in how a user interacts with 
 it
 —
 especially moving from one View to another View and, more importantly, moving back 
 again. Navigation, or 
 UINavigationController
  as you may have heard it referred to as, works 
 with the concept of a navigation stack with a 
 RootViewController
 , from where your 
 navigation starts.",NA
Adding navigation to our ContentView,"Head on over to 
 ContentView.swift
 , identify the following lines of code, and then add the 
 highlighted section:
  
 var body: some View { 
  
 NavigationView {
  
  
  
  VStack {
  
  
  
  //Existing Logic...
  
  
  
  } 
  
  
  
  
 .navigationBarTitle(Text(""My Favourite Recipes""))
  
  } 
  
 }
  
 We'll start by wrapping a 
 NavigationView
  around our VStack and also by adding a 
 navigationBarTitle
  modifier to give our 
 NavigationView
  a title.
  
 Resume the automatic preview window to see how this looks, and you should now see 
 your title sitting nicely above the segmented picker.
  
 This is all well and good, but we still need to hook up each row to our new 
  
 RecipeDetailView()
 . Surprisingly enough, this is done by adding one simple wrapper 
 around our 
 RecipeDetailView()
 iteration within our List view. Refer to the change 
 highlighted here and make the change to your code:
  
 if viewIndex == 0 {
  
  
  List(recipes, id: \.id) { recipe in
  
  
  
  NavigationLink(destination: RecipeDetailView(recipe: recipe)) {",NA
Accessing with @EnvironmentObject,"Previously passing objects between views (or more specifically 
 ViewControllers
 ) could get a 
 bit tricky, whilst the delegate pattern was a solid tried and tested method, passing data 
 backup through multiple layers could get a little repetitive and in some cases complicated.",NA
Adding and injecting the @EnvironmentObject ,NA,NA
class,"To begin with, we'll need to create a class that can conform to 
  
 the 
 ObservableObject
 protocol, as it's only going to contain one property. For now, we'll just 
 create this at the bottom of our 
 ContentView.swift
  file.
  
 Go ahead and add the following code:
  
 class AppData: ObservableObject {
  
  
  @Published var fontColor = Color.black }
  
 We've created a class called 
 AppData
 . During the course of this book, we'll add various 
 other properties that we'll want our SwiftUI Views to access on a more global scale. We'll 
 start by adding a 
 fontColor
  variable, which will allow us to set the color of our fonts in 
 one place, but be accessible in another.
  
 We create our variable called 
 fontColor
  and prefix this with 
 @Published
 .
  
 Now that we've got that set up, let's head on over to the 
 SceneDelegate.swift
 file and add 
 the following highlighted code:
  
 let appData = AppData()
  
 let contentView = ContentView()
  
 // Use a UIHostingController as window root view controller. if let windowScene = 
 scene as? UIWindowScene { 
  
 ...
  
 Here, we are creating an instance of our new 
 AppData()
 class, which we'll now use to 
 inject into our 
 ContentView
  (as our 
 ContentView
  is the root view of our entire app's view 
 hierarchy).",NA
Using @EnvironmentObject,"Once we've set up our environment object, we can now declare and use our 
 UserData
  class 
 from any View we like. Let's try it out. Head on over to 
 RecipeDetailView.swift
  and add the 
 following:
  
 @EnvironmentObject var appData: AppData
  
 Notice that we are not initializing any data here or being forced to set this as forced or 
 as optional. That is because we've already injected the data into our View hierarchy 
 back in 
 SceneDelegate.swift
 .
  
  
 Regardless of whether you've injected the data or not, you can still declare 
 an 
 @EnvironmentObject
  in your project. However, if there is no data 
 injected and your app references it, it will crash.
  
 Let's try this out now. Still in 
 RecipeDetailView.swift
 , make the following highlighted 
 change in order to reference your 
 setting.fontColor
  value:
  
 Text(""\(recipe.name)"")
  
  
  .font(.title)
  
  
  .padding(.leading, 10)
  
  
  .foregroundColor(self.settings.fontColor) 
  
 // Favourites Button 
  
 Button(action: {
  
  
  Helper.addRemoveFavourite(recipe: self.recipe)
  
  
  self.settings.fontColor = self.isFavourite ? .orange : .black
  
  
 self.recipe.favourite.toggle() 
  
 }) {
  
  
  Image(systemName: isFavourite ? ""star.fill"" : ""star"") 
  
 }",NA
Using EnvironmentObject as a single source of ,NA,NA
truth,"The beauty of using 
 @EnvironmentObject
  is that in certain cases, we can use properties or 
 objects within its class as a single source of truth. By this, I mean that we don't have to 
 worry about passing around different copies of objects and data or worry about constantly 
 reading or writing data from our persistence store (as we're currently doing for favorites in 
 UserDefaults
 ).
  
 Let's start by extending our 
 AppData()
 class to include an array of our 
 RecipeModel()
 . 
 Make the following highlighted changes:
  
 class AppData: ObservableObject {
  
  
  @Published var fontColor = Color.black",NA
EnvironmentObject best practices,"So far, we've learned what 
 @EnvironmentObject
  has to offer and we have to admit that it's 
 pretty powerful, but as with most things in software development, we need to be careful 
 not to over-engineer our solution just because something is easy to do.
  
 It's very tempting to simply use 
 @EnvironmentObject
  to store all data passed between 
 views; we could even store a dictionary in there with a key to match our view name and a 
 value to hold some values.
  
 However, those of you who are familiar with the singleton pattern will know all too well 
 that this approach can soon become messy and far too complicated than it needs to be.
  
 When choosing to use 
 @EnvironmentObject
 , don't think about why you want to use it, but 
 more why you need to use it.",NA
Mock EnvironmentObject,"With the above in place, we're really starting to build a good solid architecture for our app, 
 but now that we have made use of 
 @EnvironmentObject
 , we need to make some minor 
 adjustments to our 
 PreviewProvider
  in order to inject in our own mock environment.
  
 We'll first need to create an instance of our 
 @EnvironmentObjectAppData()
  class within our 
 preview struct:
  
 struct ContentView_Previews: PreviewProvider {
  
  static let 
 appData = AppData()
  
  
  static var previews: some View {
  
  
  
  ContentView().environmentObject(appData)
  
  } 
  
 }
  
 Next, we'll need to add some mock data to the new instance:
  
 struct ContentView_Previews: PreviewProvider {
  
  
  static let appData = AppData()
  
  
  static var previews: some View {
  
  
  
  appData.recipes = Helper.mockRecipes() 
  
  
  
  
 return
  ContentView().environmentObject(appData)
  
  } 
  
 }",NA
Summary,"In this chapter, we took the basic structure of our app to the next level. We started by 
 creating another View, which took data that we selected from a list in our previous view. 
 We looked at how we can reuse our mock data to make working on the preview provider a 
 much easier (and more beneficial experience).
  
 Next, we introduced ourselves to navigation and how the navigation stack works within 
 mobile apps. We hooked up our new and existing Views, which allowed us to interact 
 between the two.
  
 Finally, we learned how to use 
 EnvironmentObject
  to inject and give us a global object that 
 can be used anywhere in our app. We then modified our logic to make use of our new 
 environment, reducing the need for us to use our previously written logic.
  
 In our next chapter, we'll create another View that we'll use to create and add our own 
 recipe. We'll integrate this directly into our app's navigation stack and make further use of 
 our recently created 
 EnvironmentObject
  logic.",NA
Questions,"1. 
  
 What View do we add in order to push content to the top of our current View?
  
 2. 
  
 In a navigation hierarchy, what is the first View known as?
  
 3. 
  
 What modifier do we use to add a title to our 
 NavigationView
 ?
  
 4. 
  
 What do we need to wrap our list content in, in order to push to a destination
  
 View?
  
 5. 
  
 What must we make sure that we do in order to prevent a crash when we use an
  
 @EnvironmentObject
  property?",NA
Further reading,"Lorum Ipsum:
  https://en.wikipedia.org/wiki/Lorem_ipsum
  
 SwiftUI Navigation
  
 View:
  https://developer.apple.com/documentation/swiftui/navigationvie
  
 w
  
 SwiftUI Environment
  
 Object
 :
  https://developer.apple.com/documentation/swiftui/environmento
  
 bject
  
 [ 95 ]",NA
Creating a Form with States ,NA,NA
,NA,NA
and Data Binding,"In this chapter, we're going to create a brand-new View that allows us to add our own 
 recipe to our app. We'll create multiple input forms along with a dynamic list as we add 
 ingredients to our recipe. In the header, we'll add a placeholder image that we can 
  
 overwrite by choosing a photo from our library. Included in our form will be a picker much 
 like the segmented picker we created earlier but using the more default look and feel that 
 we are used to from a picker in iOS.
  
 Once we've created our form, we'll save all the data so it can be referenced and favorited in 
 our app, just like our mock data.
  
 The following topics will be covered in this chapter:
  
 Creating our recipe form View
  
 Adding images from our library
  
 Adding a multiline text input and country picker
  
 Persisting our recipe",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.",NA
Creating our recipe form View,"In this section, we'll start the beginning of our form. There are multiple ways we could 
 tackle this, either by creating a VStack and a list of Views or by creating our own custom 
 View and iterating through a 
 ListView
  of options.
  
 But in the case of our app, I'll introduce you to forms and sections. Other than the obvious 
 naming of the controls, forms do a great job of making our desired layout really simple and 
 with very little effort.
  
 Let's start by adding a couple of text fields to visualize how this all looks.",NA
Implementing text and text fields,"We'll start by creating a new SwiftUI View. We'll create a new file in our Xcode project 
 called 
 RecipeDetailView
  by highlighting the group name in the File Tree, then right-clicking 
 and selecting 
 New File
 . Select 
 SwiftUI View
  from the 
 User Interface 
 options and click 
 Next
 . Call your new file 
 AddRecipeView.swift
  and click 
 Create
 .
  
 Next, we're going to add some text fields to our main View that will allow us to input text 
 for our recipe name and ingredients. There are a couple of ways we could approach this, 
 but the simplest way would be to make use of the form View in SwiftUI. Let's add a couple 
 of forms and see how this looks:
  
 Form {
  
  
  Section(header: Text(""Add Recipe Name:"")) {
  
  
  
  TextField(""enter recipe name"", text: $recipeName)
  
  }
  
  
  Section(header: Text(""Add Ingredient:"")) {
  
  
  
  TextField(""enter ingredient name"", text: $ingredient)
  
  } 
  
 }
  
 We start by adding a 
 Form
  wrapper in the body of our app; from here we've added two 
 Section
  wrappers each taking a parameter of 
 header
 —
 the header allows us to add a Text 
 View where we can set a name for each section we create.",NA
Creating our first custom modifier,"For this, we'll need to define another struct. We can do this in the same file as 
 AddRecipeView.swift
 , but just directly below our main struct. Start by adding the 
 following snippet, and we'll go through it line by line:
  
 struct AddButton: ViewModifier {
  
  
  @Binding var text: String
  
  
  @Binding var ingredients: [String]
  
  
  public func body(content: Content) -> some View {
  
  
  
  ZStack(alignment: .trailing) {
  
  
  
  content
  
  
  
  Button(action: {
  
  
  
  
  if self.text != """" {
  
  
  
  
  
  
  self.ingredients.append(self.text)
  
  
  
  
  
  
  self.text = """"
  
  
  
  
  }
  
  
  
  }) {
  
  
  
  
  Image(systemName: ""plus"")
  
  
  
  
  
  
  .foregroundColor(Color(UIColor.opaqueSeparator))
   
  }
  
  
  
  .padding(.trailing, 8)
  
  
  
  }
  
  
  } 
  
 }
  
 We'll start with the declaration; we create a new struct called 
 AddButton
  that extends from 
 the 
 ViewModifier
  protocol. As all objects in SwifUI are Views, we don't need to specify what 
 type of View this is going to be used for (that is, 
 Button
 , 
 TextField
 , 
 Picker
 , and so on):
  
 struct AddButton: ViewModifier",NA
Adding a button to the navigation bar,"Now that we've got our navigation bar all set up, let's look at how we add a button to it.
  
 First of all, let's head back over to 
 ContentView.swift
 . We're going to add a modifier called 
 navigationBarButtonItems
 —
 for those who have worked with 
 UINavigation 
 controls 
 previously, this will suddenly feel like familiar territory. Adding a navigation bar button 
 item to your Navigation View allows you to add Views (anything from images, to text, to 
 buttons) to the top navigation bar in your app.
  
 [ 103 ]",NA
Adding in a bit of a hack,"Now, you'll see me mention a couple of times during this book that SwiftUI is still in its 
 infancy. At the time of writing this book, there was a known issue that when you tap on a 
 NavigationBarItem
  in order to present a sheet (just like we are doing with our 
 AddRecipeView
 ), should you try to tap on the same button again (once said sheet is 
 dismissed) without performing any other interaction, the button would simply be 
 unclickable. 
  
 A temporary workaround discovered by the Apple community is to add the following 
 highlighted code just before we create our 
 NavigationBarItem
 :
  
 .navigationBarTitle(Text(""""), displayMode: .inline) // Hack due to bug in Xcode!
  
 .navigationBarItems(trailing:
  
  
  Button(action: {
  
  
  
  self.showAddRecipe.toggle()
  
  
  }) { ...
  
 This does have a slight knock-on effect with our 
 .navigationBarTitle 
 , so, going 
 forward, we'll need to remove these from 
 ContentView()
 :
  
 .navigationBarTitle(Text(""Favourites"")) 
  
 .navigationBarTitle(Text(""Recipes""))
  
 With that done, everything should work as expected and, hopefully, by the time you're 
 reading this book, Apple will be well on their way to fixing it!
  
 In the next section, we'll create a View where we can capture an image directly from our 
 photo library and add it to our recipe.",NA
Adding images from our library,"For this section, we're going to use some boilerplate code in order to get our app to select 
 images directly from our camera library (or camera roll as some may refer to it) and insert 
 them into our app. While this is a useful way to integrate image lookup from within 
 SwiftUI, it is a little advanced and out of scope for this book.",NA
Creating our Image View,"Back over in our 
 AddReciepeView.swift
  file, add the following highlighted 
 @State 
 variables underneath our existing ones:
  
 @State internal var ingredients = [String]() 
 @State internal var 
 showingImagePicker = false @State private var 
 libraryImage: UIImage?
  
 Now, add the following highlighted code just inside the start of your form (above the 
 Add 
 Recipe Name Text View
 ):
  
 Form {
  
  
  Image(uiImage: self.libraryImage ?? (UIImage(named: ""placeholder-add-image"") ?? 
 UIImage()))
  
  
  
  .resizable()
  
  
  
  .aspectRatio(contentMode: .fit)
  
  
  
  .clipShape(Circle())
  
  
  
  .overlay(Circle().stroke(Color.purple, lineWidth: 3).shadow(radius: 10))
  
  
  
  .frame(maxWidth: .infinity, maxHeight: 230)
  
  
  
  .padding(6)",NA
Implementing our ImageHelper,"Now, let's hook up a button that we'll use to call and select our images from our library. For 
 simplicity, we'll amend our previously created Image View to be a 
 Button
  (with our image 
 inside). Amend the following 
 Image
  code to wrap this within a button control:
  
 Button(action: {
  
  
  self.showingImagePicker.toggle() 
  
 }) {
  
  
  Image(uiImage: self.libraryImage ?? (UIImage(named: ""placeholder-add-image"") ?? UIImage()))
  
  
  
  .resizable()
  
  
  
  .aspectRatio(contentMode: .fit)
  
  
  
  .clipShape(Circle())
  
  
  
  .overlay(Circle().stroke(Color.purple, lineWidth: 3).shadow(radius: 10))
  
  
  
  .frame(maxWidth: .infinity, maxHeight: 230)
  
  
  
  .padding(6) 
  
 } 
  
 .sheet(isPresented: $showingImagePicker) {
  
  
  ImagePicker(image: self.$libraryImage) 
  
 }.buttonStyle(PlainButtonStyle())
  
 Let's go through the code one step at a time:
  
 1. 
  
 First, we add a 
 Button
  View that, when used, toggles the Boolean value of 
  
 showingImagePicker
 , which we set previously. As 
 showingImagePicker
  is a 
  
 @State
  
 variable, SwiftUI will reload the layout once this value has been changed 
  
 (which 
 you'll see the effect of shortly).
  
 2. 
  
 Next, we'll copy in the Image View content that we previously created.
  
 3. 
  
 Now, we'll add a 
 sheet
  modifier similar to the one we created when initially 
  
 calling the 
 AddReciepeView.swift
  file. We'll pass in the 
  
  
 showingImagePicker
  variable to determine if this sheet is to be presented or 
  
 not 
 when the view is loaded (which is why we 
 toggle()
  the value in the action).
  
 When our AddRecipeView sheet is shown, we'll invoke the 
 ImagePicker() 
 function (which lives inside our 
 ImageHelper
 ) passing in the 
  
 libraryImage
  state variable we declared earlier.
  
 Again, using the power of states in SwiftUI, once we've selected an image, our 
 libraryImage
 variable will be updated by the 
 ImagePicker
  and again our View will 
 be reloaded
 —
 this time showing the image selected.",NA
Adding a multiline text input and country ,NA,NA
picker,"At the time of writing this book, there is no native way of creating a multiline Text View 
 using only SwiftUI components. In order to achieve this, we'll have to tap into our old 
 friend UIKit. Much like the helper we created in the previous section, we'll basically create 
 a wrapper around 
 UITextView
  (which in turn allows multiline support) and bring it back 
 as a SwiftUI View.
  
 As previously mentioned, this is a little out of scope for this book, but in a later chapter, 
 we'll cover this in a little more detail for those of you who are familiar with UIKit's exciting 
 components and are interested in using them.",NA
Implementing a UITextView wrapper,"First of all, we need to start by creating a wrapper for our UITextView.
  
 Head on over to the source code you downloaded earlier and grab a file called 
 TextHelper.swift
 . Drag it into your current project via the File Tree (again, add this 
 under your existing Helpers).
  
 Once you've added this in, do a quick 
 command
  + 
 B
  to make sure everything is happy.",NA
Adding a country picker,"Within our mock data, we've been using a predefined country to look up our flag images. 
 We'll also use this later on in the project too, making it a mandatory field that we'll need to 
 add to our 
 AddRecipeView
 .
  
 First, we'll start by creating some mock data. Head on over to 
 Helper.swift
  and create the 
 following helper function:
  
 static func getCountries() -> [String] {
  
  
  return [""Italy"", ""Greece"", ""UK"", ""China"", ""France"", ""USA"", ""Mexico"", ""Spain""] 
  
 }
  
 For the purpose of this book, I've only added a few random countries, but you can add as 
 many as you want. Next, head over to 
 AddRecipeView.swift
  and create another 
 Section()
 . 
 This time called it 
 ""Country of Origin:""
 :
  
 Section(header: Text(""Country of Origin:"")) { }
  
 Next, we'll add a picker. This time, we'll use a default picker that, when tapped from our 
 form, will push us to a list of countries to select. Make the following highlighted changes to 
 your new 
 Section()
 :
  
 Section(header: Text(""Country of Origin:"")) {
  
  
  Picker(selection: $selectedCountry, label: Text(""Country"")) {
   
  ForEach(0 
 ..< countries.count) {
  
  
  
  Text(self.countries[$0]).tag($0)
  
  
  
  }
  
  
  } 
  
 }",NA
Persisting our recipe,"In this section, we'll bundle up all the data we've received from our form and persist it 
 down to our app so we can save the recipe and later view it via our main list or favorites.
  
 First, we'll look at how to convert the image we've taken into data so that we can 
  
 successfully persist it to our 
 UserDefaults
  and retrieve it again when necessary. We'll also 
 cover how to use a fallback image if there is a problem accessing the image we've saved.
  
 Once we've covered that, we'll use a helper function similar to the one we used for our 
 favorites to both retrieve and save our recipe.",NA
Persisting our image,"First off, we'll need to make some tweaks to our 
 RecipeModel()
 . Head on over to 
 the 
 RecipeModel.swift
  file and make the following highlighted changes:
  
 var ingredients = [String]() 
  
 var recipe = """" 
  
 var imageData: Data?
  
 var image: UIImage {
  
  
  if let dataImage = UIImage(data: imageData ?? Data()) {
  
  
  return 
 dataImage
  
  
  } else if let countryImage = UIImage(named: countryCode) {
   
  return 
 countryImage
  
  
  }
  
  
  return UIImage() 
  
 }",NA
Persisting our data,"In order to tie all this together, we'll now look at how we can persist the data; we start by 
 making a call to 
 Helper.saveRecipes()
 , which currently doesn't exist. Head on over to 
 Helper.swift
  and add the following functions there:
  
 // Add Recipe 
  
 static func saveRecipes(recipes: [RecipeModel]) {
  
  
  let data = try! JSONEncoder().encode(recipes)
  
  
  UserDefaults.standard.set(data, forKey: ""recipes"") 
  
 } 
  
 // Gets List of Saved Recipes 
  
 static func getRecipes() -> [RecipeModel] {
  
  
  if let data = UserDefaults.standard.data(forKey: ""recipes"") {
  
  
  let array = try! 
 JSONDecoder().decode([RecipeModel].self, from: data)
  
  
  
  return array
  
  
  }
  
  
  return [RecipeModel]() 
  
 }
  
 We've added two helper functions similar to those we created earlier for persisting our 
 favorites. 
 saveRecipe()
  accepts an array of 
 RecipeModel()
  and 
 getRecipes()
  returns an array 
 of 
 RecipeModel()
  .
  
 Let's make another quick change to our mock data helper too in order to add in any recipes 
 we've created manually through our app; this will allow our app to have some dummy and 
 real data during development and testing. Make the following highlighted change inside 
 mockRecipes()
 :
  
  
 recipies.append(contentsOf: getRecipes())
  
  return 
 recipies 
  
 }
  
 When creating an array of mock recipes, we simply append any recipes that we've created 
 in our app to this array in order to include them in our list.
  
 However, we'll need to make one minor change to the way we read in our recipes over in 
 our 
 SceneDelegate.swift
  file. Head on over there now and make the following highlighted 
 change:
  
 let appData = AppData() 
  
 appData.recipes = Helper.getRecipes()
  
 let contentView = ContentView()",NA
Making the save,"This has been a lot to take in so far, but you're doing great. Just one more piece of the 
 puzzle to solve now... yep, you guessed it! Let's add the 
 Save
  button to tie it all together!
  
 We'll start by adding another 
 Button()
  to our form. Add the following highlighted code at 
 the end of the 
 Form()
  just after the picker view and underneath the 
  
 navigationBarTitle()
 :
  
 } // Closing Form Brace 
  
 .navigationBarTitle(""Add Recipe"") 
  
 .navigationBarItems(trailing:
  
  
  Button(action: {
  
  
  
  self.saveRecipe()
  
  
  
  self.presentationMode.wrappedValue.dismiss()
  
  }) {
  
  
  
  Text(""Save"")
  
  
  } 
  
 )
  
 Here, we've created a new button that will sit just outside of our form and give it a Text 
 View labeled 
 Save
 . As part of the button's action, we've added a call to two functions:
  
 self.saveRecipe() 
  
 self.presentationMode.wrappedValue.dismiss()
  
 saveRecipe()
  is the save function we just created, allowing us to persist our recipe. Next is 
 the dismissal of our sheet.
  
 In order to understand this a little better, let's first add a new variable to our 
 AddRecipeView
  struct:
  
 @Environment(\.presentationMode) var presentationMode
  
 This 
 @Environment
  variable allows us to keep track of the current state of our presented 
 view, and in turn, should we wish to dismiss it, we can simply call the following:
  
 self.presentationMode.wrappedValue.dismiss()",NA
Summary,"We've covered a lot in this chapter. We've built a brand-new view that makes use of a 
 Form 
 View and 
 sections
  to allow us to easily create an input form for our recipes. We covered 
 various types of images and how our old friend 
 UIImage
  comes into play with SwiftUI, 
 allowing us to take a photo from our library and not only insert it into our View but persist 
 and retrieve it when we need to.
  
 We also covered how SwiftUI can integrate into UIKit's existing framework using 
 components that may not necessarily be available yet from SwiftUI, or simply custom 
 components that were created previously and may still add some value.
  
 In the next chapter, we'll be going through this in a little more detail and showing more of 
 the behind the scenes of what we can achieve with SwiftUI in existing applications, 
 including network connectivity.",NA
Questions,"1. 
  
 In our 
 TextField
 , why do we pass in a 
 @State
  variable for our text?
  
 2. 
  
 What is the obvious difference between creating a View and a custom modifier?
  
 3. 
  
 What modifier do we use to add items to the navigation bar?
  
 4. 
  
 What is required for our default picker to push to a page of options?
  
 5. Why do we care about the size of our Image Views?",NA
Networking and Linking to Your ,NA,NA
,NA,NA
Existing App Logic,"Whether you're creating a brand new app or building on an existing one, with the best will 
 in the world, at some point, you'll always need to tap into some form of existing framework 
 or legacy code. Regardless of what people may say... that's actually okay.
  
 In this chapter, we'll touch on the basics of networking in SwiftUI and how you might link 
 into an existing networking approach that's commonly used by most iOS apps. Then, we'll 
 deep dive into how we can use and harness existing UIKit Controls and gracefully yet 
 powerfully implement these directly into our SwiftUI app.
  
 The following topics will be covered in this chapter:
  
 Basic networking in SwiftUI
  
 Integrating UIViews with UIViewRepresentable
  
 Integrating ViewControllers with UIViewControllerRepresentable
  
 Other representable protocols",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.",NA
Basic networking in SwiftUI,"In this section, we'll start by covering networking with SwiftUI. We touched on the basics of 
 how we could implement this using the MVVN pattern back in 
 Chapter 3
 , 
 Building Layout and 
 Structure
 , but now that we're building our app, let's look at making an actual 
  
 networking call to retrieve some data that we can use in our recipe app.",NA
Creating our network helper,"Let's start by taking a look at what data we are going to get back from our call. We'll use a 
 publicly open API called 
 https://source.unsplash.com/
 that will generate a placeholder 
 image for our recipe on the off chance we've not got a photo at hand.
  
 This is a very simple API that is generated based on the structure of the URL. For example, 
 if you wanted a placeholder image that's 300 x 200 in size and categorized as 
 food
 , you 
 would simply access the following 
  
 URL: 
 https://source.unsplash.com/300x200/?food
 .
  
 If you refresh the URL, you'll see a different image 
 –
  nice!
  
 Now, let's see how and where we are going to add this to our app. First, we'll create a new 
 Helper class called 
 NetworkHelper
  by highlighting the group name in the File Tree, right-
 clicking it, and selecting 
 New File
 . Select 
 SwiftUI View
  from the 
 User Interface
  options 
 and click 
 Next
 . Call your new file 
 NetworkHelper.swift
  and click 
 Create
 .
  
 Copy the following function into the class. We'll go through this line by line:
  
 static func loadData(url: URL, completion: @escaping (UIImage?) -> ()) {
  
  
 URLSession.shared.dataTask(with: url) { data, response, error in
  
  
  guard let data = data, 
 error == nil else {
  
  
  
  completion(nil)
  
  
  
  return
  
  
  
  }
  
  
  
  completion(UIImage(data: data))
  
  
  }.resume() 
  
 }
  
 The preceding function is very basic, yet very powerful in what it does: it accepts a type of 
 URL (which we'll create shortly from a URL string), makes the call asynchronously, and, if 
 successful, returns a type of 
 UIImage
 . This type of function is known as a closure and, 
 when called, will allow any subsequent calls and logic to continue prior to receiving a 
 response (or finishing its current operation, depending on what you are using it for).",NA
Invoking our network request,"With this set up, let's head on over to 
 AddRecipeDetailView.swift
  and plug it in.
  
 Create the following private function. This calls our new 
 NetworkHelper
  closure, which 
 will assign a 
 UIImage
  to our 
 @State libraryImage
  property:
  
 private func getRandomImage() {
  
  
  guard let url = URL(string: 
  
 ""https://source.unsplash.com/300x200/?food"") else {
  
  
  
 return
  
  
  }
  
  
  NetworkHelper.loadData(url: url) { (image) in
   
  
 self.libraryImage = image
  
  
  } 
  
 }
  
 Should our closure successfully return a 
 UIImage
 , our 
 libraryImage
  will update and 
 SwiftUI will reload the current state. With our existing logic in place, we should see the 
 randomly generated image courtesy of 
 source.unsplash.com
  show up in our app!
  
 But before we try this out, we'll need to hook up the preceding function to actually run 
 anything. Let's make this simple and add another bar button item to our Navigation View.
  
 Make the following highlighted amendments in the current file:
  
 .navigationBarTitle(""Add Recipe"") 
  
 .navigationBarItems(
 leading:
  
  
  Button(action: {
  
  
  
  self.getRandomImage()
  
  
  }) {
  
  
  
  Text(""Random Image"")
  
  
  },
  trailing:
  
  
  Button(action: {
  
  
  
  self.saveRecipe()
  
  
  
  self.presentationMode.wrappedValue.dismiss()
  
  }) {
  
  
  
  Text(""Save"")
  
  
  } 
  
 )",NA
Integrating UIViews with ,NA,NA
UIViewRepresentable,"With most existing or legacy apps, you'll have specific UI features that you'll not only want 
 to use but need to use to maintain parity with when introducing SwiftUI.
  
 In this section, we'll take a look at 
 TextHelper()
 , which we brought in from 
 Chapter 7
 , 
 Creating 
 a Form with States and Data Binding
 ,and how we made use of 
 UITextField
 , which gave us the 
 option to use 
 MultiLine TextFields
  within our app. This section will cover the basics of the 
 UIViewRepresentable
 protocol and the coordinatorin order to 
  
 successfully bind UIKit controls with SwiftUI.",NA
Implementing UIViewRepresentable,"We'll start by covering how we set up and use the 
 UIViewRepresentable
  protocol. Head on 
 over to 
 TextHelper.swift
 ,where we can use the 
 TextView
  we imported for reference.
  
 First of all, you'll need to create a struct that you intend to use to represent the UIKit View 
 you want to house. This will need to extend the 
 UIViewRepresentable
  protocol with the 
 following functions. Add the following code just outside of the 
 TextView
  struct in 
 TextHelper.swift
 :
  
 struct TestRepresentableView: UIViewRepresentable {
  
  @Binding 
 var text: String
  
  
  func makeUIView(context: Context) -> UITextView {
  
  
  
  return UITextView()
  
  
  }
  
  
  func updateUIView(_ uiView: UITextView, context: Context) {
  
  
  
 uiView.text = text
  
  
  } 
  
 }
  
 We'll go through them one at a time:
  
 func makeUIView(context: Context) -> 
 UITextView",NA
Customizing our UIViewRepresentable and ,NA,NA
coordinators,"Now that we've got the basics up and running, we'll take a closer look at our 
 TextView
  in 
 TextHelper.swift
 . You'll see a very similar pattern to what we had previously but with some 
 added extras 
 –
  don't worry about these; we'll go through them very shortly. For now, let's 
 start by taking a closer look at our 
 makeUIView()
  function. Notice that we've got a lot more 
 going on in there than our previous example:
  
 func makeUIView(context: Context) -> UITextView {
  
  let textView = UITextView()
  
  textView.delegate = context.coordinator
  
  textView.font = UIFont.preferredFont(forTextStyle: .body) 
 textView.isScrollEnabled = true",NA
Integrating ViewControllers with ,NA,NA
UIViewControllerRepresentable,"In this section, we'll take a look at the 
 ImageHelper()
  we brought in from 
 Chapter 7
 , 
 Creating a 
 Form with States and Data Binding
  and how we made use of 
  
 UIImagePickerController
 , which gave us the option to choose a photo from our library to use 
 within our app. This section will cover the basics of 
  
 UIViewControllerRepresentable
  and the coordinator, in order to successfully bind a 
 UIViewController
  to our app.",NA
Implementing UIViewControllerRepresentable,"Let's start by heading on over and taking a look at our implementation 
  
 of 
 ImageHelper.swift
 . Much like 
 UIViewRepresentable
 , the layout and required functions 
 are pretty much the same. So, for this reason, we won't go through and create another 
 UIViewControllerRepresentable
  struct; instead, we'll just cover how we created 
 ImagePickerViewController
  function by function.
  
 First of all, let's take a look at our 
 makeUIViewController()
  function. Much like the 
 makeUIView()
  function, here, we create an instance of 
 UIViewController
  we want to use and 
 return this to SwiftUI so that it can use it:
  
 func makeUIViewController(context: 
  
 UIViewControllerRepresentableContext<ImagePickerViewController>) -> 
 UIImagePickerController {
  
  
  let imagePicker = UIImagePickerController()
  
  
 imagePicker.sourceType = 
  
 UIImagePickerController.SourceType.photoLibrary
  
  
 imagePicker.allowsEditing = false",NA
Other representable protocols,"So far in this chapter, we've covered the two main representable 
  
 protocols, 
 UIViewRepresentable
  and 
 UIViewControllerRepresentable
 , but we can also conform 
 to other variations of the representable protocol to allow for even more versatility within 
 SwiftUI. 
  
 In this section, we'll briefly touch on other options available to us and how they can also be 
 used in a similar way to 
 UIViewRepresentable 
  
 and 
 UIViewControllerRepresentable
 .",NA
Options for macOS,"With catalyst being announced alongside SwiftUI and the option for developers to build 
 native macOS apps straight off the back of their iPadOS apps, it only makes sense to allow 
 the same behavior to be able to create SwiftUI apps in macOS just like you can on iOS and 
 iPadOS.",NA
Options for watchOS,"Apple's watchOS can also get in on the action, with an almost identical pattern being used 
 to implement the representable protocol throughout the watch development process. It's 
 important to bear this in mind as we'll be covering this later in 
 Chapter 11
 , 
 SwiftUI on 
 WatchOS
 ,where this will play a slightly bigger part:
  
 struct TestRepresentableViewController: 
 WKInterfaceObjectRepresentable
  {
  
  func 
 makeWKInterfaceObject
 (context: 
  
 WKInterfaceObjectRepresentableContext<TestRepresentableViewController>) -> WKInterfaceTextField 
 {
  
  
  
  // ...
  
  
  }
  
  
  func 
 updateWKInterfaceObject
 (_ wkInterfaceObject: WKInterfaceTextField, context: 
  
 WKInterfaceObjectRepresentableContext<TestRepresentableViewController>) {
  
  
  // ...
  
  
  }
  
  
  static func 
 dismantleWKInterfaceObject
 (_ wkInterfaceObject: 
 WKInterfaceTextField, coordinator: ()) {
  
  
  
  // ...
  
  
  } 
  
 }
  
 As familiar as this pattern seems, the consistency within each device is key to the success of 
 multi-platform apps for iOS, iPadOS, watchOS, and macOS.
  
 In this section, we covered alternative options regarding how we can use the representable 
 protocol in SwiftUI across the various Apple platforms and learned how the patterns we 
 created in the previous sections can be used in the same way.
  
 In the next chapter, we'll take what we have learned here about representable protocols and 
 adopt them in order to use Apple Maps within our recipe app to pinpoint the origin of our 
 recipes.",NA
Summary,"In this chapter, we covered how linking SwiftUI to existing logic and UIKit frameworks can 
 be achieved. First, we looked at how we integrate into a very common approach for 
 networking by using 
 NetworkHelper
  along with 
 URLSession
  to perform our network request. 
 From this, we were successfully able to update our SwiftUI View with ease.
  
 Next, we took a deep dive into two of the main representable 
  
 protocols, 
 UIViewRepresentable
  and 
 UIViewControllerRepresentable
 , and stepped through how 
 we previously used these in 
 Chapter 7
 , 
 Creating a Form with States and Data Binding
 , in order 
 to implement existing UIKit controls. We covered the differences between using both and 
 understood why we need to take a slightly different approach 
  
 for 
 UIViewControllerRepresentable
  in order to dismiss the ViewController, should we need to.
  
 Finally, we briefly covered the remaining available representable protocols that are 
 available for watchOS and macOS.
  
 In the next section, we'll take a look at adding Apple Maps to our SwiftUI project by 
 utilizing 
 UIViewRepresentable
  and 
 UIViewControllerRepresentable
 .",NA
Questions,"1. 
  
 Why is it important that we use two-way binding when loading remote images?
  
 2. 
  
 Why should we use 
 UIViewRepresentable
 ?
  
 3. 
  
 Why should we use 
 UIViewControllerRepresentable
 ?
  
 4. 
  
 When would we use the coordinator pattern?
  
 5. 
  
 What did we do differently when creating 
 UIViewControllerRepresentable 
  
 and 
 why?",NA
Further reading,"Delegate Design 
  
 Patterns:
  https://developer.apple.com/documentation/swift/cocoa_design_ 
 patterns/using_delegates_to_customize_object_behavior
  
 UITextView:
  https://developer.apple.com/documentation/uikit/uitextvie 
  
 wdelegate/1618630-textview
  
 UITextView 
  
 Delegate:
  https://developer.apple.com/documentation/uikit/uitextviewde legate/1618599-
 textviewdidchange
  
 UIPickerView 
  
 Delegate:
  https://developer.apple.com/documentation/uikit/uipickerview delegate
  
 UIViewRepresentable:
 https://developer.apple.com/documentation/ 
  
 swiftui/
 uiviewrepresentable
  
 UIViewControllerRepresentable:
 https://developer.apple.com/ 
  
 documentation/swiftui/uiviewcontrollerrepresentable
  
 [ 137 ]",NA
Maps and Location Services ,NA,NA
,"In this chapter, we'll be covering Maps and Location Services within iOS and how we can 
 integrate this into our SwiftUI app. We'll learn how to use Apple's built-in MapKit 
 framework to display maps directly in our app and add annotations (or pins as they are 
 sometimes known as) to specific locations throughout.
  
 We'll also cover Core Location and see how Xcode's cool feature of location spoofing allows 
 us to simulate various locations from around the world and update our SwiftUI app 
 dynamically.
  
 Finally, we'll tie all this together and use what we've learned to display recipe locations on 
 our map with the ability to select them and filter our recipes.
  
 The following topics will be covered in this chapter:
  
 Adding a Map with MapKit control
  
 Creating our first pin
  
 Identifying our location
  
 Piecing it all together",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.",NA
Adding a Map with MapKit control,"As we learned in the previous chapter, 
 Chapter 8
 , 
 Networking and Linking to Your Existing 
 App Logic
 , working with existing app logic will require you from time to time to make use 
 of 0f 
 UIViewRepresentable
  and/or 
 UIViewControllerRepresentable
  when implementing 
 existing UIKit features. MapKit is currently no exception to this, and in this section, we'll 
 start to build our 
 MapView
  using this methodology. We'll create 
  
 a 
 UIViewRepresentable
  struct around the current MapKit control and add this directly into 
 our SwiftUI recipe app.",NA
Implementing MapKit,"We'll start by creating a new SwiftUI View; we'll create a new file in our Xcode project 
 called 
 RecipeMapView
  by highlighting the group name in the file tree, then right-clicking 
 and selecting 
 New File
 . Select 
 SwiftUI View
  from the 
 User Interface
  options and click 
 Next
 . Call your new file 
 RecipeMapView.swift
  and click 
 Create
 .
  
 Now we'll create another helper file called 
 MapKitHelper
  by highlighting the group name in 
 the file tree, then right-clicking and selecting 
 New File
 . Select 
 Cocoa Touch Class
  from the 
 User Interface
  options and click 
 Next
 . Call your new file  
 MapKitHelper.swift
  and click 
 Create
 .
  
 Inside our helper, make the following changes. Note the 
 import
  statement at the top of the 
 file; this is needed to tell our project that we intend to use MapKit inside our class or struct:
  
 import UIKit 
  
 import SwiftUI 
  
 import MapKit
  
 struct MapView: UIViewRepresentable {
  
  @State var lat = 0.0
  
  @State var long = 0.0
  
  func makeUIView(context: Context) -> MKMapView {
  
  
  MKMapView(frame: .zero)
  
  }
  
  func updateUIView(_ view: MKMapView, context: Context){
  
  
  let coordinate = CLLocationCoordinate2D(
  
   
  latitude: lat, longitude: long)
  
  
  let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)
  
  let region = 
 MKCoordinateRegion(center: coordinate, span: span)
  
  view.setRegion(region, animated: true)",NA
Adding a MapKit View to SwiftUI,"Head on back over to 
 RecipeMapView.swift
  and you should see the automatically 
 generated template complete with a body and a text view.",NA
Creating our first pin,"Now that we've successfully implemented MapKit directly into our SwiftUI View, let's get a 
 bit creative by adding some pins (or annotations, as they are officially known) to our 
 RecipeMapView
 . We'll start by adding basic annotations to our map using some mock data 
 that we'll generate for our automatic preview canvas and then we'll look at how we can 
 customize each annotation to show details of the recipes we have for that specific area.",NA
Adding your first annotation (pin),"We'll start by heading on over to 
 MapHelper.swift
 , where we'll create a new class called 
 AnnotationPin
 .
  This class will be a custom subclass of 
 MKAnnotation.
  We're creating a 
 subclass as we'd like to customize the annotation later on.
  
 Add the following at the footer of our 
 MapHelper.swift
  for now:
  
 class AnnotationPin: NSObject, MKAnnotation { let title: String?
  
  let subtitle: String?
  
  let coordinate: CLLocationCoordinate2D
  
  init(title: String?, subtitle: String?, coordinate: CLLocationCoordinate2D) {
  
   
  self.title = title
  
   
  self.subtitle = subtitle
  
   
  self.coordinate = coordinate
  
  } 
  
 }
  
 The preceding is a basic subclass of 
 MKAnnotation
 . We've even overwritten the base 
 properties of 
 title
 , 
 subtitle
 , and 
 coordinate
  so we can initialize these ourselves along with 
 anything additional we want later.
  
 Still within our 
 MapHelper.swift
  file, but back up to our 
 UIViewRepresentable 
 implementation, we'll make the following highlighted change within the 
 updateUIView 
 function:
  
 func updateUIView(_ view: MKMapView, context: Context){
  
  let coordinate = CLLocationCoordinate2D(latitude: lat, longitude: long) let span = 
 MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)",NA
Creating custom annotations,"For this next part, we're going to create a custom annotation where we can display some 
 details about our recipe. You'll notice that we passed a title and subtitle to 
  
 our 
 AnnotationPin
  class
 –
 this can now be displayed as a custom annotation, along with a 
 custom image of our choosing.
  
 In order to achieve this, we'll need to make use of a MapKit delegate function called 
 viewFor
  annotation. Let's start by hooking up the 
 MKMapViewDelegate
  to our 
 UIViewRepresentable
 class, as shown in the following:
  
 class MapViewCoordinator: NSObject, MKMapViewDelegate {
  
  var parent: MapView
  
  init(_ control: MapView) {
  
    
  self.parent = control
  
  } 
  
  
 func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> 
 MKAnnotationView? {
  
    
  let annotationView = MKAnnotationView(annotation: annotation, 
  
 reuseIdentifier: ""customView"")
  
    
  annotationView.canShowCallout = true 
  
    
 annotationView.image = UIImage(systemName: ""book.fill"")
  
    
  return annotationView
  
  } 
  
 }
  
 I've highlighted some areas of interest in the preceding code block, but again we create 
 a reference to the 
 parentMapView
  and initializer and then the required delegate function 
 from 
 MKMapViewDelegate
 .
  
 The code inside of 
 viewFor annotation
  is standard code for implementing a custom 
 annotation view. The only bit we want to concentrate on is the image we're assigning. 
 Again we make use of the widely available SF Symbols in order to choose a font for our pin.
  
 Now head on back up to our 
 UIViewRepresentable
  implementation
 –
 can you remember 
 what we need to add next? That's right, we need to add in our 
 makeCoordinator() 
 function:
  
 func makeCoordinator() -> MapViewCoordinator{ 
 MapViewCoordinator(self) 
  
 }
  
 Next, we assign this to the delegate property in 
 updateUIView()
 :",NA
Identifying our location,"In this section, we'll dive into 
 CoreLocation
  and see how we can update our SwiftUI 
 RecipeMapView
  to reflect a certain location when set. We'll again touch on the basics of the 
 Combine framework in order to help us achieve this. As we are primarily working with the 
 iOS simulator, we'll also explore the tools available to us in Xcode that allow us to simulate 
 a specific location and see that reflected in our SwiftUI app immediately.",NA
Creating our MapLocationManager,"Our first job is to create a 
 MapLocationManager
  class. This will house all the logic required to 
 obtain our current (or simulated) location and pass the relevant details back up to our main 
 view in order for them to be displayed in SwiftUI.
  
 Let's start by creating a new class; we'll create a new file in our Xcode project called 
 RecipeMapView
  by highlighting the group name in the file tree, then right-clicking and 
 selecting 
 New File
 . Select 
 Cocoa Touch Class
  from the 
 User Interface
  options and 
  
 click 
 Next
 . Call your new file 
 MapLocationManager.swift
  (making sure this is a subclass of 
 NSObject
 ) and click 
 Create
 .",NA
Hooking up our MapLocationManager to SwiftUI ,"Now let's head on back over to 
 RecipeMapView.swift
  to make just a couple of small 
 changes to our SwiftUI View in order to work with our 
 MapLocationManager
 .",NA
Location permissions,"When trying to get a user's location in iOS, we are required to ask the user's permission 
 first
 –
 in order to do this, we need to tell the user why we are requesting the permissions.
  
 iOS will handle the asking of the questions, but we need to provide the question. We 
 achieve this by adding an entry into our 
 info.plist
  file.
  
 To access the 
 info.plist
 , head over to the file tree and select your project at the very top of the 
 tree hierarchy, then in the main window select the 
 Info
  tab
 –
 you should now see a list of 
 keys already pre-populated by Xcode for our app:
  
  
 [ 152 ]",NA
Piecing it all together,"Now that we've created our 
 MapView
 , learned how to add pins (annotations), and learned 
 how to customize our annotations too, we can integrate this straight into our recipe app.
  
 In this section, we'll hook up our actual recipes to our 
 MapView
 , placing an annotation on 
 each country with a recipe. Then we'll use a custom annotation to list the country name and 
 the number of recipes we have for that country. 
  
 We'll then take a look at the 
 call out accessory view
  and how we can add a button that we'll 
 be able to use to filter our 
 ContentView
  list based on the country selected.
  
 Finally, we'll add another navigation bar button item in order to clear our filter.",NA
Updating our Helper classes,"The first thing we need to do is create a couple of additional functions in our 
 Helper() 
 class 
 in order to perform a latitude and longitude lookup for our 
 RecipeModel().origin 
 property.
  
 Now, there's quite a bit here to type out, so you might just want to grab this from the 
 sample project and copy it into yours.
  
 We'll start by adding in a private function called 
 getCoordinates
 . This function accepts a 
 String
  parameter, which will be the country name:
  
 private static func getCoordinates(country: String) -> 
 CLLocationCoordinate2D {
  
  switch country {
  
  case ""Italy"":
  
   
  return CLLocationCoordinate2D(latitude: 43.112221, longitude: 12.388889)
  
  case ""Greece"":",NA
Hooking up our MapView,"Okay, so we are going to add our 
 MapView
  to the 
 ContentView()
  of our app; we'll take the 
 same approach as we did with the 
 AddRecipeView()
  by adding this to our navigation bar 
 button item. Head on over to 
 ContentView.Swift
  now and make the following highlighted 
 change:
  
 .navigationBarItems(
 leading: HStack {
  
  Button(action: {
  
   
  self.showMap.toggle()
  
  }) {
  
  Image(systemName: ""map"")
  
   
  .renderingMode(.original)
  
  }.sheet(isPresented: $showMap) {
  
   
  RecipeMapView()
  
  }}
 , trailing:
  
  Button(action: {
  
   
  self.showAddRecipe.toggle()
  
  }) {
  
   
  Image(systemName: ""plus"")
  
   
  .renderingMode(.original)
  
  }.sheet(isPresented: $showAddRecipe) {
  
   
  AddRecipeView().environmentObject(self.appData) })
  
 As you can see from the preceding code block, the noticeable difference is that we've now 
 separated out a leading and trailing bar button item (note that also I've added our leading 
 button into an 
 HStack
 –
 spoiler alert
 : we'll be adding another button here shortly).
  
 Now head on over to 
 RecipeMapView()
  and let's add in our new 
 Helper
  function and other 
 highlighted changes as follows:
  
 var body: some View {
  
  NavigationView {
  
   
  MapView(lat: latitude,
  
    
  lon: longitude,
  
    
  annotations: 
 Helper.getRecipeLocations()
 )",NA
Adding an annotation callout accessory and ,NA,NA
filtering,"In the previous part, we implemented our custom annotations to our 
 MapView
  based on our 
 own actual recipe data. Next, we're going to go a step further and add a button to our 
 annotation (called an 
 annotation callout accessory
 ) so that when we click the button, our 
 MapView
  will dismiss and our 
 ContentView()
  will filter recipes by that particular country!
  
 First, however, we need to make a little change to how we get recipes from our 
  
 @EnvironmentObject
 . Head on over to 
 ContentView.swift
  and add in the following function 
 to our 
 AppData()
  class:
  
 func getRecipes(filter: String) -> [RecipeModel] .{ if filter != """" {
  
   
  return recipes.filter ({ $0.origin == filter }) } else {
  
   
  return recipes
  
  } 
  
 }
  
 As you can see from the preceding code, we've created a computed property much like our 
 getFavourites
  function, which passes in a parameter of 
 String
 .
  
 [ 161 ]",NA
Adding a reset filter button,"Still in 
 ContentView.swift
 , locate the navigation bar button items we created earlier. 
 Remember how we added an 
 HStack
  on the leading button for later? Well, this is 
 later
 , so 
 add in the following highlighted changes to add another button to our leading items:
  
 .navigationBarItems(leading: HStack {
  
  Button(action: {
  
   
  self.showMap.toggle()
  
  }) {
  
  Image(systemName: ""map"")
  
   
  .renderingMode(.original)
  
  }.sheet(isPresented: $showMap) {
  
   
  RecipeMapView(filter: self.$filter)
  
  }
  
  Button(action: {
  
   
  self.filter = """"
  
  }) {
  
   
  Image(systemName: ""line.horizontal.3.decrease.circle"")
  
  
  
  .renderingMode(.original)
  
  }
  
  }
 , trailing:
  
  Button(action: {
  
   
  self.showAddRecipe.toggle()
  
  }) {
  
   
  Image(systemName: ""plus"")
  
   
  .renderingMode(.original)
  
  }.sheet(isPresented: $showAddRecipe) {
  
   
  AddRecipeView().environmentObject(self.appData)
  
  })
  
 Here we've added another 
 Button
  view, which when clicked sets our 
 filter
  variable to an 
 empty string, thereby causing a reload of our SwiftUI View (because it's a 
 @State 
 variable).
  
 Go on and give it a try 
 –
  launch the simulator and filter by country as you did before. Once 
 you've done that, hit the button we've just created and all recipes should return as normal.",NA
Summary,"In this chapter, we started by integrating a basic MapKit View into SwiftUI, making use of 
 the 
 UIViewRepresentable
  protocol we picked up in 
 Chapter 7
 , 
 Creating a Form with States and 
 Data Binding
 . 
  
 From there, we learned how to add annotations to our map using mock data we created in 
 our 
 Helper
  class. Starting with the basic annotations offered to us by the Apple MapKit 
 framework, we customized our annotations by adding data that was made visible to users 
 when they selected a specific location.
  
 Next, we touched on Apple's Core Location framework by implementing our own 
 MapLocationManager
  and using Xcode to simulate multiple locations from within our 
 app. We saw how SwiftUI updated our 
 MapView
  instantly once our location changed.
  
 Finally, we tied everything together by adding another bar button item to our 
  
 ContentView()
  that presented our 
 RecipeMapView()
  as a sheet. We then updated and 
 customized our annotations further by displaying how many recipes the selected country 
 had.
  
 We then wrapped it all up by adding a button to our annotations that dismissed our 
 RecipeMapView()
  and filtered our current 
 ContentView()
  list of recipes based on the 
 country selected.
  
 In the next chapter, we'll extend our code base to support the iPad, learning how we can 
 use specific controls in SwiftUI to work seamlessly between iOS and iPadOS.",NA
Questions,"1. 
  
 Which representable protocol will we need to implement MapKit?
  
 2. 
  
 How do we view our Live map in the Automatic Preview Canvas?
  
 3. 
  
 Which three properties are required for our 
 MKAnnotation
  subclass?
  
 4. 
  
 Which framework helped us implement our 
 MapLocationManager
  for notifying 
  
 changes to our location?
  
 5. What plist key do we need to set when requesting a user's location?",NA
Further reading,"MapKit:
  https://developer.apple.com/documentation/mapkit/mkmapview
  
 CoreLocation:
 https://developer.apple.com/documentation/corelocation/
  
 [ 167 ]",NA
Updating for iPad with ,NA,NA
,NA,NA
NavigationViewStyle,"The iPad has changed the way we use portable computers; with more versatile options 
 becoming available, there is an iPad out there for everyone. This makes it much more 
 important than ever to make sure your app supports the iPad to the best of its (or your) 
 ability.
  
 In this chapter, we'll cover various corners, starting by understanding how an iPad fits into 
 our current project. We'll then move on to the 
 little things
  we can do in preparation for 
 supporting the iPad from the start.
  
 We'll then get to run our app in the iPad simulator and learn about the various layouts that 
 are available to us not only in terms of orientation but the architecture within our code base.
  
 The following topics will be covered in this chapter:
  
 Updating our project for iPad
  
 Running our app on iPad for the first time
  
 Making better use of 
 NavigationViewStyle",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from Apple's App 
 Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search 
 Xcode
  in the App Store and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you with. Once Xcode has fully launched, you're ready to go.",NA
Updating our project for iPad,"Unless you're specifically developing an iPad app, the chances are that you'll always start 
 working on the iPhone version first. Don't worry
 —
 we all do it. But working on the iPad 
 version isn't as daunting as you might think, especially as Apple allows you to submit one 
 binary for both platforms.
  
 In this section, we're going to touch on some changes we can make to prep our project to 
 support iPadOS
 —
 whether you choose to do this at the start of your project or halfway 
 through, it's worth bearing some of these in mind.",NA
Project settings,"Probably one of the easiest things you can do in order to get your app up and running 
 ready for iPadOS is done with a simple checkbox.
  
 If you highlight your project name in the file tree on the left-hand side, then select 
 General 
 from the tabs available, you should see the following checkboxes:
  
  
 If it isn't already, just check 
 iPad
  and your app is ready for launch as an iPad 
 application
 —
 it really is that simple.
  
 If you toggle the 
 iPad
  setting off and on, you'll notice that the following two checkboxes 
 appear when 
 iPad
  is selected:
  
  
 Requires full screen
 :This is generally for iPad apps that only support one 
 orientation (such as games). Setting this and supporting both orientations is 
 allowed but will most likely fail validation or face rejection from Apple when 
 submitted to the App Store.",NA
Portrait and landscape support,"With the introduction of the Apple Smart Keyboard, it's more important than ever to 
 support multiple orientations on your iPadOS app.
  
 Unless your app specifically requires you to support a set orientation (again, like a game), 
 then there's no excuse really
 —
 if you're ever in doubt, just ask yourself whether your app 
 requires a user to input using the keyboard. If so, then support landscape, and if you're 
 supporting landscape for this reason, you should already be supporting portrait.
  
 Regardless making the change to lock orientation for your app is simple.
  
 Again, if you highlight your project name in the file tree on the left-hand side, then select 
 General
  from the tabs available, you should see the following checkboxes:
  
  
 These options are ticked by default and can be amended as easily as ticking/unticking the 
 ones you require, but there is one slight catch
 —
 these aren't device-specific; making these 
 changes will apply to both iOS and iPadOS.
  
 Now, with regard to our recipe app, ideally, we'd be happy with just portrait for iOS, yet 
 would want to support both orientations for iPadOS. For now, make the following changes 
 so we can apply these to all devices:",NA
Understanding assets,"With iPad support, you'll need to think a little about your assets (images). Choose an image 
 that's big and that looks good on the iPad and you risk the compression of your image on 
 smaller devices and also bloating your app unnecessarily.
  
 Choose images that are too small
 —
 that might look great on the phone
 —
 and they could be 
 susceptible to stretching and start to look grainy and gain artifacts on your iPad.
  
 Around 90% of the time, you can try to find a happy-medium file in size and in resolution. 
 But for the other 10% of the time, you'll need to work around this.
  
 The common approach is to have iPad-specific images in your 
 Assets.xcassets
  catalog, as 
 I've done here with the 
 placeholder-add-image
  screenshot:
  
  
 We can then programmatically choose the image we require based on what device our code 
 is being executed on. For example, the following snippet would allow us to choose the iPad 
 version of our image when running on an iPad:
  
 var placeHolderImageName: String {
  
  
  return UIDevice.current.userInterfaceIdiom == .pad ? ""placeholder-add-image_iPad"" : ""placeholder-
 add-image"" 
  
 }
  
 This computed property will work really well, however, replace every image in your app 
 with two variations and it's going to bloat
 —
 fast!
  
 In order to stop this from happening, highlight one of the images from within the 
  
 Assets.xcassets
  catalog (either the iPad or the iPhone version), then expand the Inspector 
 window by clicking on the highlighted icon here (situated in the top-right corner of 
 Xcode):",NA
iPadOS simulators,"When the time comes, testing your iPad app is as simple as it is for iOS. If you've set the app 
 to support iPad, you'll be presented with multiple options based on the current version of 
 Xcode you have installed. For example, in Xcode 11.3, you should see the following options:
  
  
 As you can see, we've got five available iPads in our simulator. By default, these will be 
 running iOS 13. This is due to us working with SwiftUI, which requires us to target devices 
 running iOS.
  
 [ 174 ]",NA
Running our app on iPad for the first time,"From what we learned in the previous section, actually getting our app ready for iPad isn't 
 such a daunting task as you may have initially thought it was.
  
 With our project set up, and our orientation ready, and armed with some knowledge 
 about how to fire it up, we'll now start by seeing what exactly is presented to us when we 
 run the simulator.",NA
Running on the simulator,"First, let's start by choosing a device from our device list. Any iOS 13 supported device will 
 do, but for the remainder of this book, I'll choose 
 iPad Pro (11-inch)
 :
  
  
 Now you're all set. Just press the 
 play
  button or use the 
 command
  + 
 R
  keyboard shortcut. The 
 first run of the simulator always takes a little longer than usual (no more than a minute or 
 so, though).
  
  
 One thing you might notice, especially if you are working on a MacBook, 
 is that the iPad simulator can be a little on the 
 large
  side
 —
 as with the iOS
  
 simulator, you can resize this manually by moving your cursor to one of
  
 the corners and dragging the size down.",NA
Initial support for list views ,"Start by returning the simulator to portrait mode and then head on over to 
  
 ContentView.swift
 . We want to add the following modifier to our 
 NavigationView
 : 
  
 .navigationViewStyle(StackNavigationViewStyle()) 
  
 Setting 
 navigationViewStyle
  to 
 StackNavigationViewStyle()
  will tell our app to support 
 ContentView
  by a view stack that only shows a single 
 top
  view at a time, according to 
 Apple's official SDK documentation. 
  
 Go ahead and rerun the simulator. You should see things start to look a little more as we 
 would expect now:
  
  
 [ 179 ]",NA
Making better use of NavigationViewStyle,"As we saw earlier in this chapter, supporting iPadOS is now a default option when creating 
 your app project, and most developers (unless specifically told otherwise) will quite happily 
 leave this option ticked.
  
 Sometimes developers get lucky and the iPad version of their app just works
 —
 others take 
 the time to completely redesign an iPad-specific version of the app and submit this 
 separately to the App Store. But more often than not, there will be an iPadOS version of 
 your app that is not so much broken but a little 
 unloved
 . 
  
 In this section, we'll show you how with SwiftUI and a little bit of upfront thought, you can 
 support iPadOS almost out of the box.",NA
Other NavigationViewStyle options,"In the previous section, we saw how adding a 
 NavigationViewStyle
  modifier allowed us to 
 use our iPad app as we first expected.",NA
Making use ,NA,NA
of DoubleColumnNavigationViewStyle,"As mentioned in the previous section, 
 DoubleColumnNavigationViewStyle
  for our particular 
 style of app will serve as the best option and make the best use of what SwiftUI has to 
 offer for iPadOS.
  
 Let's start by taking a look at exactly what this will do for us. Head on over to 
 ContentView.swift
  and change our previously added 
  
 .navigationViewStyle
  modifier to the following:
  
 .navigationViewStyle(DoubleColumnNavigationViewStyle())
  
 Now, if not already done, press resume and check out the automatic preview 
  
 canvas
 —
 notice something different? That's right
 —
 because we've selected an iPad device in 
 our device list, our canvas has automatically changed to an iPad layout and, with any luck, 
 you should now see the following:",NA
Improving our architecture ,NA,NA
with DoubleColumnNavigationViewStyle,"With the preceding in mind, let's see how we can improve the architecture of our app. First, 
 we are going to start by renaming our 
 ContentView.swift
  struct. To do this, go to the 
 declaration of the struct, hover over it and secondary-click with your cursor; you should be 
 presented with the following menu:
  
  
 Click on 
 Rename
  and the renaming tool should automatically launch within Xcode. This 
 will generate a list of references that currently use 
 ContentView
  ready for renaming.
  
 Simply start typing 
 ListView
  and press the 
 Enter
  key once you're done. Xcode will not 
 only rename all references but also rename the file. If you look in the file tree, you should 
 now see 
 ListView.swift
 :
  
  
 [ 188 ]",NA
Cleaner navigation architecture,"Another benefit to this approach that is that we can house most of our navigation logic 
 inside our 
 ContentView()
 , away from our other views. In fact, we can actually remove a lot 
 of the NavigationViews we used previously and tidy up our code a little.
  
 First, we'll start by bringing 
 NavigationBarButtonItems
  into 
 ContentView()
 . Make the 
 following highlighted changes:
  
 ListView(
 filter: $filter, showAddRecipe: $showAddRecipe
 )
  
  
  .navigationBarTitle(Text(""""), displayMode: .inline) // Hack!
  
  .navigationBarItems(leading: HStack {
  
  Button(action: {
  
  self.showMap.toggle()
  
  }) {
  
  Image(systemName: ""map"")
  
  .renderingMode(.original)
  
  }.sheet(isPresented: $showMap) {
  
  RecipeMapView(filter: self.$filter)
  
  }
  
  Button(action: {
  
  self.filter = """"
  
  }) {
  
  Image(systemName: ""line.horizontal.3.decrease.circle"") 
 .renderingMode(.original)
  
  }
  
  }, trailing:
  
  Button(action: {
  
  self.showAddRecipe.toggle()",NA
Final check on our iPhone and iPad app,"Well, we're almost done
 —
 just one last thing to do now, and that's to run over our 
 functionality for both iPhone and iPad.
  
 Start by launching the simulator for iOS and navigate around. Note that, since the last time 
 we launched in iPhone mode, nothing has really changed. The only thing you should see 
 is that iPhones don't actually make use of our new 
 WelcomeView()
 .
  
 This is mainly due to the fact that our iPhone view doesn't really need one; the smaller 
 screen size houses the 
 ListView()
  well and it doesn't look out of place.
  
 Now go ahead and launch the app on the iPad in portrait mode. Imagine our 
 ListView() 
 as 
 we saw earlier
 —
 looking all lost in that big space. Now we can design a welcome screen that 
 could potentially have details on how to use the app or some additional recipe tips and 
 tricks (basically, anything you want).",NA
Summary,"In this chapter, we learned everything we needed to know about iPad and iPadOS. We 
 learned that if we make some good decisions early on, supporting the iPad isn't going to be 
 such a big chore as we might think. 
  
 We looked at handling assets and best practices to stop our binaries from being bloated. We 
 saw how to support different orientations based on our users' needs and the changes we 
 need to make to our 
 info.plist
  to support these.
  
 Next, we looked at what our iPad app would look like straight out of the box
 —
 we launched 
 the app in the iPad simulator to see how our iPhone design looked so far. We then made 
 use of 
 NavigationView
  in order to support the split view designed specifically for iPad yet 
 without compromising our iPhone app.
  
 In the next chapter, we'll move away from our main devices and take to our wrists as we 
 develop an Apple Watch companion app for our Recipe app.",NA
Questions,"1. 
  
 Where would we overwrite specific orientation support for just an iPad?
  
 2. 
  
 Which window would we find the checkbox to support an image just for iPad in?
  
 3. 
  
 How do we test our iPad app through Xcode (two answers here)?
  
 4. 
  
 How many types of NavigationViewStyle are there? Can you name them all?
  
 5. Which NavigationViewStyle do we use for iPad split-screen support?",NA
Further reading,"App Thinning:
 https://developer.apple.com/videos/play/wwdc2015/404/
  
 [ 194 ]",NA
SwiftUI on watchOS ,NA,NA
,"Welcome to Chapter 11! In this chapter, we are going to create our very own Apple Watch 
 Companion app. For our iOS recipe app, we'll start by covering how we actually develop 
 for watchOS and how Xcode interprets our Watch App within our current project.
  
 We'll then create our Watch project and see how we can integrate it with our current 
 project, reusing some of our existing code.
  
 After that comes the good stuff. We'll look at how we can use the power of SwiftUI to easily 
 create multiple watch interfaces with just a couple of lines of code and by dropping in with 
 ease familiar syntax we've used earlier.
  
 Finally, we'll hook up our iOS app and Watch App, and send newly created recipes straight 
 over to our watch so that we can check our ingredients on the go.
  
 The following topics will be covered in this chapter:
  
 Developing for watchOS
  
 Creating a watchOS project
  
 Using SwiftUI to create a list of recipes
  
 Passing data between our App and watchOS",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store, and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you for. Once Xcode has fully launched, you're ready to go.",NA
Developing for watchOS,"Announced back in 2015, watchOS and Apple Watch was the most anticipated wearable to 
 be released by Apple. With a Developer SDK straight from the word go, App Store apps 
 could now allow users to have a companion in the form of an extension right on their 
 wrists.
  
 In this section, we'll delve a little into the understanding of how we start to develop for 
 watchOS within our current Xcode project with the use of extensions. We'll learn a little 
 about the history of watchOS and where it all started for developers.
  
 Let's get started by understanding a little more about the watchOS framework, 
 WatchKit
 .",NA
What is WatchKit?,"WatchKit is the framework developed by Apple that is used by developers to create 
 watchOS apps. Unveiled at WWDC 2015 alongside Xcode 7 beta, developers were given the 
 power to create companion apps that would run alongside their parent apps. 
  
 Initially, watchOS apps needed a parent app to work (or exist even), and they were built as 
 an 
 extension
  to the parent iOS project from within Xcode. Recently, watchOS branched off 
 from this approach and with the birth of the App Store for Apple Watch, an independent 
 watchOS app could be built.
  
 For this book, we'll concentrate on building a companion app using iOS extensions as our 
 method to implement this. We'll take a closer look now at what 
 extensions
  are and how 
 they sit within our project.",NA
Understanding extensions ,"Extensions, particularly in iOS, aren't just for watchOS, they are used for many other 
 components such as Today (widgets), photo sharing, custom keyboard, and audio.
  
 Extensions are designed to allow interaction between the app and another UI element. Take 
 the Today extension, for example 
 —
 this is an external UI component that sits on your home 
 screen in iOS, yet interacts directly with your app (and from within your app's project in 
 Xcode).
  
 You need to remember that extensions are not a permanent feature of your app, as a user 
 can choose whether or not to interact with the extension or even enable it. Apple's 
 guidelines suggest that when building an extension, think carefully about its design and 
 make sure it looks like it belongs and functions how the user would expect it to.
  
 The same applies to watchOS too, given how a user expects to interact with watchOS (for 
 example, scrolling with the digital crown). User expectations should play a big part in how 
 you think about and design your extension.
  
 Next, let's look specifically at how watchOS works with extensions.",NA
Extensions in watchOS,"Although we're going to create a companion watchOS app within our current iOS project, 
 watchOS is still an app in its own right. Apple initially took this approach as a view to 
 eventually creating standalone apps, hence setting a base foundation for developers to 
 build standalone watchOS apps going forward.
  
 The 
 app
  element of our companion (the WatchKit App) is just like we would expect. It has 
 its own 
 Assets.xcassets
  catalog; its own settings file, 
 info.plist
 ; and even its own Target so 
 that we can run it as an app. But as we'll see in the next section, no code as such lives 
 there.",NA
Creating a watchOS project,"In this section, we'll start by taking our existing recipe project and through Xcode, we'll go 
 through and, learn how to create a 
 Watch App for iOS App
 .
  
 Once we've done that, we'll take a look at the updated project structure, and, as per the 
 previous section, we'll be able to see in more detail the separation between the 
 WatchKit 
 App
  and the 
 extension
 .",NA
Updating our project,"Let's start by heading on over to Xcode and highlighting the project name at the top of the 
 File Tree. With the project tree highlighted, take a look at the column to the right, which 
 contains a list of projects and targets.
  
 At the bottom of the column, you should see a 
 +
  button. Click on this and you will be 
 presented with an action sheet that says 
 Choose a template for your new target
 .
  
 Here, select 
 watchOS 
 from the top list and then select 
 Watch App for iOS App
 :
  
  
 [ 199 ]",NA
Changes to our project ,"Now that's all done, let's take a look at the changes that have been made in Xcode. First, 
 you'll see that there have been two additions to our targets:
  
 My Favourite Recipes Watch
  
  
 My Favourite Recipes Watch Extension 
  
 Also, the same two named groups have appeared in our File Tree too:
  
  
 [ 201 ]",NA
Using SwiftUI to create a list of recipes,"We'll start with something simple as more of a proof of concept of how watchOS can 
 harness SwiftUI. We'll also learn how we can reuse some of our classes and models from 
 our parent application.",NA
Creating a List() view in watchOS,"Let's start by heading on over to our 
 ContentView.swift
 . Now, remember, 
  
 that's 
 ContentView.swift
  in our 
 My Favourite Recipes Watch Extension 
 group (not our 
 parent app). Make the following highlighted changes:
  
 struct ContentView: View { 
  
  
 var recipes = [RecipeModel]()
  
  
  var body: some View {
  
  
   
  VStack {
  
  
   
  Text(""Recipes"")
  
  
   
  
  .font(.headline)
  
  
   
  List(recipes, id: \.id) { recipe in
  
  
  
  
  Text(""\(recipe.name)"")
  
  
   
  }
  
  
   
  }
  
  
  } 
  
 }
  
 Here, we've started by creating a variable for our recipes. This is an array of 
 RecipeModel()
  from our parent class.
  
 Next, into the body of our struct, we've added some familiar controls: 
 VStack
 , which 
 wraps around 
 Text()
 , and a 
 List()
  view.",NA
Using our mock data,"With that done, let's inject some mock data into our app. The good news is that we can 
 reuse our 
 Helper.mockData()
  class from our main app; head on over to 
  
 Helper.swift
  and highlight the file.
  
 We're going to want to include this as part of our 
 My Favourite Recipes Watch Extension 
 project, so similar to what we did with 
 RecipeDetail()
 ,select the 
 File Inspector
  in the right-
 hand column of Xcode, take note of the 
 Target Membership
  section, and check 
 My 
 Favourite Recipes Watch Extension.",NA
Multiple screens in watchOS,"Back before the days of SwiftUI, to achieve multiple screens, we would need to add 
 additional 
 HostingController
  to our storyboard
 .
  But with SwiftUI, we can eliminate this by 
 having just one default 
 HostingController
 , which acts as a harness or entry point for our 
 watchOS app. 
  
 To create a new screen, we'll first need to create a new file. Highlight the 
 My Favourite 
 Recipes Watch Extension
  group and create a new Swift UI View file and call it 
 IngredientsView.swift
 .
  
 Once created, add the highlighted code as follows:
  
 var ingredients = [String]() 
  
 var recipeName = """" 
  
 var body: some View {
  
  
  VStack {
  
  
  
  Text(recipeName)
  
  
  
  .font(.headline)
  
  
  
  List(ingredients, id: \.self) { ingredient in
  
  
  
 Text(ingredient)
  
  
  
  }
  
  
  } 
  
 }
  
 There's nothing too fancy here; we've created another 
 List()
  view with a 
 Text()
  header of 
 ingredients, and again we have an array of 
 String()
  to hold our list of ingredients for our 
 specific recipe. Have a look in the automatic preview window and you should see a 
 similar result to the previous one we created.
  
 Now, it's time to inject some data. First, head on over to 
 Helper.swift
  and find 
  
 the 
 getMockIngredients()
  function. A simple change here
 —
 just remove 
 private
  from the 
 start of the function to make this a publicly available function.
  
 Now, go back on over to 
 IngredientsView.swift
  and make the following highlighted 
 changes to the preview provider:
  
 struct IngredientsView_Previews: PreviewProvider {
  
  
  static var previews: some View {
  
  
  
  IngredientsView(ingredients: Helper.getMockIngredients(), recipeName: 
 ""Ingredients"")
  
  
  } 
  
 }",NA
Adding multiple screens,"With SwiftUI, this is one of the easiest things to implement in watchOS, especially 
 compared to the original way of doing it.
  
 Previously, you would set up a custom segue in your storyboard, then implement a 
 delegate method to detect a tap on a row, and then wrap up the data you wanted to pass 
 over into a dictionary, followed by unwrapping at the other end. It's nothing too 
 difficult
 —
 just tedious.
  
 Now, with SwiftUI, we can fix this with one simple little wrapper that you've already seen 
 before. Take a look, and make the following highlighted changes in your 
 ContentView() 
 struct:
  
 VStack {
  
  
  Text(""Recipes"")
  
  
  
  .font(.headline)
  
  
  List(recipes, id: \.id) { recipe in
  
  
  
  NavigationLink(destination: IngredientsView(ingredients: 
 recipe.ingredients, recipeName: recipe.name)) {
  
  
  
  Text(""\(recipe.name)"")
  
  
  
  }",NA
Passing data between our app and watchOS,"In this section, we are going to learn how to pass data from the parent app straight into the 
 watchOS app. We will do this by updating our recipe list on our watch with a recently 
 added recipe from 
 AddRecipeView()
 . 
  
 When watchOS first came on the scene, passing data was a little tricky, to say the least. We 
 first had to create an 
 App Group
  that was shared by both the iOS app and the watchOS app. 
 Here, we could persist 
 shared
 UserDefaults
 , which could be accessed by both the parent app 
 and the watch.
  
  
 UserDefaults is a lightweight way of storing data in your projects, using a 
 key-value approach. You can easily persist anything from 
 String
 , 
 Bool
 , 
 Int
 , 
 Array
 , or 
 Data
  in your app.
  
 With watchOS 2.0 came 
 WatchConnectivity
 —
 a new and more effective way of sending data 
 from our iOS app straight to our wrist.
  
 The initial API gave us a function called 
 WCSession.transferUserInfo
 , which allowed us to 
 pass a dictionary to the app while the watchOS wasn't running but, in turn, could not 
 receive data back from the request.
  
 Another function made available was 
 WCSession.sendMessage
 ; initially, this call would 
 allow you to receive a message back from the watchOS companion app once the initial 
 message had been received, although early versions of this API would only work if the 
 watchOS was running.
  
 Recent changes to 
 WCSession.sendMessage
  now allow messages to be sent that will wake the 
 watchOS app should it need to. As of February 
  
 2020, 
 WCSession.transferUserInfo
  was not marked as deprecated; however, it seems to be 
 unsupported in Xcode 11.3 for its original intended use.",NA
Initializing WatchConnectivity in iOS,"Let's start by creating a new class in our parent app called 
 WatchManager.swift
 . Inside the 
 class, we are going to make the following changes. I'll break these down a section at a time 
 so we can go through them:
  
 import WatchConnectivity
  
 class WatchManager: NSObject, WCSessionDelegate {
  
  
  // MARK: - Watch Delegates
  
  
  func session(_ session: WCSession, activationDidCompleteWith activationState: 
 WCSessionActivationState, error: Error?) { }
  
  func sessionDidBecomeInactive(_ 
 session: WCSession) { }
  
  func sessionDidDeactivate(_ session: WCSession) { }
  
  // Remaining code here...
  
 }
  
 First, we'll start by telling our class that we want to use the 
 WatchConnectivity 
 framework; we do this by adding 
 importWatchConnectivity
  to the top of our class.
  
 Next, we want to make sure we conform to two protocols, 
 NSObject
  and 
  
 WCSessionDelegate
 . The first is required because we are going to create a shared instance of 
 our class. The next is the delegate method used by our 
 WatchConnectivty
  session (
 WCSession
 ).
  
 By design, Xcode will now prompt us that we currently don't conform to 
  
 the 
 WCSessionDelegate
  protocol, so we'll add in the preceding three delegate functions to 
 satisfy this. Although required, we won't be making use of these functions for this chapter. 
 But as you can probably tell by the name, they are used to monitor the states of 
 WCSession
 .
  
 Next, let's add in our initializers as highlighted here:
  
 class WatchManager: NSObject, WCSessionDelegate {
  
  // 
 Previous code here...
  
  static let sharedInstance = WatchManager() override 
 init() {
  
  super.init()
  
  if WCSession.isSupported() {",NA
Sending data to watchOS,"First, we need to add a couple of small functions to our 
 RecipeModel()
 struct. Head on over 
 to 
 RecipeModel.swift
  and add in the following functions. I suggest you grab them from the 
 example code rather than type them out in full as we only really need to know 
 what
  they 
 do rather than 
 how
  they do it:
  
 func toJson() -> String {
  
  
  // Get function from Code Sample 
  
 }
  
 static func createFrom(json: String) -> RecipeModel {
  
  // Get 
 function from Code Sample 
  
 }
  
 The 
 toJson
  function will simply convert 
 RecipeModel()
  into a JSON string that we can add 
 to our 
 WCSession.sendMessage()
  call.
  
 The 
 createFrom
  static function will convert our JSON string back into 
 RecipeModel()
  on the 
 watchOS side.",NA
Receiving data on watchOS,"First, let's start by heading on over to 
 HostingController.swift
  and conforming our class to 
 WCSessionDelegate
 .
  
 Before we do anything, we'll need to import the 
 WatchConnectivity
  framework:
  
 import WatchConnectivity
  
 Now, we can add the 
 WCSessionDelegate
  protocol to our class:
  
 class HostingController: WKHostingController<HomeView>, 
 WCSessionDelegate
  {
  
  
  // Remaining code here... 
  
 }
  
 This will force us to add the following delegate methods into our class:
  
 func session(_ session: WCSession, activationDidCompleteWith activationState: 
 WCSessionActivationState, error: Error?) { }
  
 We can leave 
 activationDidCompleteWith activationState
  empty as we won't be needing this 
 for our app. Although, if you wanted to add any error handling, you would do so here.",NA
Testing sendMessage() end to end,"First of all, select the 
 My Favourite Recipes Watch 
 target and press command + 
 R
 .
  Wait for 
 your simulator to launch as normal until you get 
 HomeView()
 :",NA
Summary,"We started by looking at how Xcode interprets a Watch App within an existing project. 
 From this, we learned about extensions and their file structure when created in Xcode.
  
 Next, we created our Apple Watch project and familiarized ourselves with the 
  
 autogenerated code; we looked at how the newly created 
 My Favourite Recipes 
  
 Watch
  target now offers us Apple Watch simulators that we can use in the same way as iOS 
 or iPadOS simulators.
  
 When we finally got stuck into developing our Watch App, we saw how 
  
 HostingController
  acts as an entry point for our watchOS app, harnessing our initial 
 SwiftUI View, hence allowing us to create simple 
 List()
  views and 
 Text()
  views, just like 
 we had done previously.
  
 We were then introduced to the 
 WatchConnectivity
  framework. We learned about the APIs 
 available to us for communicating and sending direct messages from our parent app to 
 our Watch App. With this, we hooked them up together and successfully sent a recipe 
 from our app to our watch.
  
 Finally, we looked at how we can make use of the watchOS and iOS simulators not only to 
 test our newly created watchOS app but to send data to and from both iOS and watchOS 
 simulators.
  
 In the next chapter, we'll go back over our app and take a look at what we've learned with 
 SwiftUI and compare this to how it might have been done using UIKit, reiterating the 
 benefits of everything we've done so far.",NA
Questions,"1. 
  
 What does an existing Xcode project see a watchOS project as?
  
 2. 
  
 What is the entry point for a watchOS app?
  
 3. 
  
 How can we test our SwiftUI views in watchOS?
  
 4. 
  
 What framework do we use for sending messages to and from our watchOS app?
  
 5. Why would we use 
 sendMessage()
  over 
 transferUserInfo()
 ?",NA
Further reading,"WatchKit:
 https://developer.apple.com/documentation/watchkit
  
 App Extensions:
 https://developer.apple.com/app-extensions/
  
 WatchConnectivity Framework:
 https://developer.apple.com/ 
  
 documentation/watchconnectivity 
  
 UserDefaults:
 https://developer.apple.com/documentation/foundation/ 
  
 userdefaults
  
 [ 223 ]",NA
SwiftUI versus UIKit ,NA,NA
,"So far, we've covered many of the benefits of using SwiftUI and also seen how we can 
 utilize UIKit within our SwiftUI projects, but what impact does SwiftUI really have when it 
 comes to developing our apps?
  
 This chapter is intended as a reference and is aimed at those who are new to SwiftUI but 
 have an understanding of UIKit and are looking to make comparisons. It is also intended 
 for those who are brand new to development with SwiftUI and want to learn a little more 
 about the benefits compared to UIKit.
  
 The following topics will be covered in this chapter:
  
 List view versus UITableView
  
 Data Binding versus Data Source
  
 Comparing decoration techniques 
  
 Migrating UIKit so that it's ready for SwiftUI",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.0 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you for. Once Xcode has fully launched, you'll be ready to go!",NA
List view versus UITableView,"Now that we've got a comprehensive understanding of SwiftUI, let's take some time to 
 compare the benefits of SwiftUI against Apple's original UI Framework UIKit. In this 
 section, we'll take a look at the simplicity of a 
 List()
  View in SwiftUI and compare this to 
 how we'd construct a 
 UITableView()
  in UIKit.",NA
Basic UITableView implementation,"Let's start by checking out exactly how we'd create a list, similar to the one found in our 
 ListView.swift
  file.
  
 Although we can make use of Storyboards to create 
 TableViews
 , for this comparison, we'll 
 give all our examples programmatically so that we can provide a more direct comparison 
 with the declarative syntax we've just been practicing.
  
 Let's start by creating an instance of a 
 TableView
  in an empty 
 ViewController
 :
  
 class ViewController: UIViewController {
  
 var tableView: UITableView!
  
  override func viewDidLoad() {
  
  tableView = UITableView(frame: view.frame) 
 view.addSubview(tableView)
  
  }
  
 }
  
 As shown in the highlighted code, we've created the 
 tableView
  variable, which we'll use 
 throughout our class. Next, inside 
 viewDidLoad()
 , we've instantiated our variable and set the 
 size to that of our current view controller. Finally, we've told our view (which sits inside 
 our view controller) that we want to add our 
 tableView
  to it.
  
 Notice how we've had to set up three important things here before we can even get started. 
 The following code shows how we would do this in SwiftUI:
  
 struct SwiftUIView: View {
  
  
  var body: some View {
  
  
  
  List() { _ in
  
  
  
  }
  
  
  } 
  
 }",NA
Basic SwiftUI List implementation,"Now, let's compare how we'd do the exact same thing in SwiftUI:
  
 struct SwiftUIView: View {
  
  
  let mockData = [""Recipe 1"", ""Recipe 2"", ""Recipe 3""]
  
  var body: some 
 View {
  
  
  
  List(mockData, id: \.self) { recipe in
  
  
  
  Text(recipe)
  
  
  
  }
  
  
  } 
  
 }
  
 That's it, really 
 –
  excluding the 
 mockData
  variable, we have a total of three lines of code to 
 do the work of everything we covered previously 
 –
  amazing.
  
 Let's dig a little deeper and have a look at some other comparisons. Remember how, in 
 Chapter 6
 , 
 Working with Navigation in SwiftUI
 , we looked at how to push to another 
 SwiftUI view by wrapping a simple 
 NavigationLink
  around our List View's iteration?
  
 var body: some View {
  
  
  List(mockData, id: \.self) { recipe in
  
  
  
  NavigationLink(destination: SecondSwiftUIView()) {
  
  
  
 Text(recipe)
  
  
  } 
  
 }
  
 Again, this is nice and simple. Let's take a look at a comparison in UIKit:
  
 func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  
  
  present(SecondViewController(), animated: true, completion: nil) }
  
 First, we have to add a new delegate method called 
 didSelectRowAt
 . Again, this delegate is 
 called for each row, which we can identify by referencing the 
 IndexPath
  variable being 
 passed in.
  
 In this section, we made a direct comparison between SwiftUI and UIKit in terms of Lists 
 and UITableViews. Using a similar approach to how we built a List View previously, we 
 saw the clear benefits of how SwiftUI can be used in what should be a very quick and easy 
 implementation.",NA
Data Binding versus Data Source,"Data Sources can play a massive part in building and even (programmatically) designing a 
 UITableView
 . In this section, we'll look at how to best perceive a 
  
 UITableViewDataSource
  in a way that makes understanding why it works the way it does 
 much clearer.
  
 Then, we'll take a look at a comparison of how we achieve the same thing in SwiftUI.",NA
UIKit ,NA,NA
–,NA,NA
 multiple Data Sources,"First of all, we must ask the question, why would we want 
  
 multiple 
 UITableViewDataSource
 ? One of the many reasons is simply its reusability.
  
 As we saw in the previous section, we have to conform to the 
 UITableViewDataSource 
 delegate and override multiple functions, just in order to get our table to load some data. 
 However, one of the positive sides to all this is the ability to separate out specific code of 
 specific instances. 
  
 Referring back to the 
 IndexPath
  we saw being passed into each delegate method, we can 
 easily identify and alter the style or even the type of the 
 UITableViewCell
  being used.
  
 We may, however, decide to reload a whole other set of data and 
 UITableViewCell 
 without the need to reload the whole 
 ViewController
 . This is where setting a specific 
 Data Source has its advantages.
  
 The best way to achieve this is by separating the two delegate methods we were forced to 
 conform to earlier into their own classes:
  
 class DataSourceA: NSObject, UITableViewDataSource {
  
  
  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  
  
  
  return mockData.count
  
  
  }
  
  
  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  
  
  
  let cell = UITableViewCell()
  
  
  
  cell.textLabel?.text = mockData[indexPath.row]",NA
SwiftUI ,NA,NA
–,NA,NA
 handling Data Sources,"Following on from where we've just left off with UIKit and UITableViews in SwiftUI, we'll 
 use 
 @State
  in order to invalidate our current layout and force a reload. As a basic 
 implementation, this will work really well and almost do our job for us.
  
 Looking back at our previous example, if we have a mutable variable with our 
 mockData
 , 
 we could simply reassign some data and this would invalidate our layout and reload it 
 with our new data:
  
 @State
  var mockData = [""Recipe 1"", ""Recipe 2"", ""Recipe 3""]
  
 This would be followed by something like this:
  
 mockData = [""Recipe 4"", ""Recipe 5"", ""Recipe 6""]
  
 This works a treat! Here, we're assigning basic types such as 
 String
 , 
 Int
 , 
 Bool
 , 
 Array
 , and so 
 on. However, our data could be far more complex and won't necessarily be updated from 
 within our View either. That's where 
 @ObservedObject
  comes into play.",NA
Comparing decoration techniques ,"As many iOS developers will agree, mastering the art of decorating UIViews and 
  
 manipulating a UIImage can be an art form in itself, to say the least. However, with SwiftUI 
 and the use of modifiers, this pain can be eased quite considerably.
  
 In this section, we'll take a look at and compare modifiers in SwiftUI to see how they hold 
 up against their UIKit counterparts.",NA
Simple decoration made easy,"It goes without saying that modifiers in SwiftUI have been a blessing in disguise. Where 
 previously we would have had to make a series of changes in order to make a simple 
 amendment such as a 
 border with a corner radius
 , the use of a one-line modifier does all the 
 hard work for us.
  
 In some cases with UIKit, we could ease the pain a little by creating extensions that we 
 could reuse again and in our current project and across other projects too.
  
 By comparison, you can think of a modifier as an extension of some sort, wrapping up little 
 bundles of complex logic and adding them to one line of code.
  
 Let's start by taking a look at how we can create a border in a 
 UIButton
  with a corner 
 radius:",NA
Complex decoration made easy,"Let's take a look at something a little more complex. Here, we have a gradient effect on a 
 UIKit view 
 –
  it looks cool and adds a little 
 something extra
  to our control:",NA
Migrating UIKit ready for SwiftUI,"So far, we've looked at a direct comparison between UIKit's 
 TableView()
  against SwiftUI's 
 ListView
 , but as common as TableViews are, there are far more options to explore when it 
 comes to migrating to SwiftUI.
  
 Now, due to SwiftUI being new to the scene, not every UIKit control has a SwiftUI 
 equivalent. However, if you ever need to jump back to a particular UIKit control, please 
 refer to the 
 Using the Representable Protocol
  section in 
 Chapter 8
 , 
 Networking and Linking to 
 Your Existing App Logic.
  We'll cover everything else in this section.",NA
UIStackView,"First introduced in iOS 8, 
 UIStackView
  was welcomed with open arms as it allowed for a 
 more flexible layout hierarchy than what was on offer before. UIStackViews allow us to 
 implement vertical and horizontal stacking of independent views without getting bogged 
 down in the complexity of a 
 UITableView
  or a 
 UICollectionView
 :
  
 let viewOne = UIView() 
  
 let viewTwo = UIView()
  
 let stackView = UIStackView(arrangedSubviews: [viewOne, viewTwo]) stackView.axis = 
 .vertical 
  
 stackView.distribution = .fillEqually",NA
UITextField ,"Covered in 
 Chapter 7
 , 
 Creating a Form with States and Data Binding
 ,
 UITextField
 , when 
 conforming to the 
 UITextFieldDelegate
  protocol, is a powerful and widely used control in iOS 
 apps.
  
 SwiftUI Equivalent:
  TextField and SecureField",NA
UISwitch ,"The commonly known 
 toggle
  has been transitioned to the SwiftUI world. Utilizing all the 
 same features, the use of SwiftUI's 
 @State
  binding makes updating logic based on the 
 value of the UISwitches a piece of cake.
  
 SwiftUI Equivalent:
  Toggle",NA
Summary ,"In this chapter, we looked at the benefits that SwiftUI has to offer over UIKit. Taking 
 UITableView
  as an example, we learned how SwiftUI simplifies the existing delegate 
 pattern given to us by default in UIKit. 
  
 Although SwiftUI is beneficial due to its simplicity, UIKit is just as powerful, which is clear 
 from its place in iOS development.
  
 Then, we looked at how using modifiers to decorate our SwiftUI Views compares against 
 UIKit's implementation. With this, we covered border-radius, gradients, and attributed 
 Strings.
  
 In the next chapter, we'll look at how to create basic Animations in SwiftUI and how we can 
 incorporate them into our Recipe app for a bit of added spice (
 see what I did there...
 )!",NA
Questions,"1. 
  
 What pattern does UIKit use for UITableViews?
  
 2. 
  
 What protocol does UITableView need to conform to? 
 3. 
  
 How does a SwiftUI List look for changes?
  
 4. What modifier do we use in SwiftUI to add a border?
  
 [ 237 ]",NA
Basic Animation in Views ,NA,NA
,"Animations have always played a massive part in any form of development 
 –
  no matter 
 what language you are coding in. This is no different when developing for iOS applications 
 either. In this chapter, we'll take a look at how we can simply drop animations into our 
 existing app 
 –
  in some cases, this can be done with just a single line of code.
  
 We'll cover all the various types of animation options available to us, from pulsing buttons 
 to spinning 3D images, and you'll be able to see how the little things we do make such a big 
 difference.
  
 The following topics will be covered in this chapter:
  
 The fundamental use of Animations
  
 Exploring animation options
  
 Rotation and scaling
  
 Adding Animation to our app",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you for. Once Xcode has been fully launched, you'll be ready to go!",NA
The fundamental use of animations,"In this section, we are going to learn the basic fundamentals of animation in SwiftUI and 
 start by looking at simple yet effective animations.
  
 We'll start by taking a look at 
 implicit
  animations. With SwiftUI, these don't come much 
 easier. Then, we'll take a look at its counterpart, 
 explicit
  animations, and understand what 
 they have to offer us, both programmatically and over 
 implicit
  animations.",NA
Implicit animations,"Let's start by creating a new playground project. Do this by clicking 
 File
  | 
 New
  | 
  
 Playground
 . Call the project anything you like and add the following code to prepare your 
 playground for SwiftUI:
  
 import SwiftUI 
  
 import PlaygroundSupport
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  } 
  
 }
  
 PlaygroundPage.current.setLiveView(ContentView())
  
 Now that we've got our playground set up, let's add some content to do. We'll start by 
 adding a basic button and a 
 Text
  view just beneath it:
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  VStack {
  
  
  
  Button(""Tap to Animate"") {
  
  
  
  }
  
  
  
  Text(""Learn SwiftUI"")
  
  
  
  }
  
  
  } 
  
 }
  
 Great! Now, let's make the button disappear and reappear when we click it. We'll achieve 
 this by changing the opacity of the 
 Text
  view (the alpha channel) using 
 @State
  to an 
 opacity
  
 variable.",NA
Explicit animations,"Our setup is going to be pretty much the same here. Let's create another button with a Text 
 view that we'll use to animate a change:
  
 @State var opacity = 0.0 
  
 struct ContentView: View {
  
  
  var body: some View {
  
  
  
  Button(""Tap to Animate"") { 
  
  
  
  
 self.opacity = (self.opacity == 1.0) ? 0 : 1.0
  
  
  }
  
  
  
  Text(""Learn SwiftUI"") 
  
  
  
  
 .opacity(opacity)
  
  
  } 
  
 }
  
 This time, we want to 
 explicitly
  tell SwiftUI that the animation is to only occur on an 
 opacity
  change. We do this by adding the following 
 withAnimation
  wrapper to our button 
 action:
  
 Button(""Tap to Animate"") {
  
  
  withAnimation { 
  
  
  
 self.opacity = (self.opacity == 1.0) ? 0 : 1.0
  
  } 
  
 }",NA
Exploring animation options,"In the previous section, we learned how to use implicit and explicit animations. By default, 
 we were given a basic animation by SwiftUI, but as we saw with the 
 easeIn
  option, there are 
 many more variants to choose from.
  
 In this section, we'll be covering all the options that are available and how to use them in 
 our implicit and explicit animations.",NA
Easings,"The first options we are going to take a look at are easings. Probably one of the most 
 commonly used effects of animation, easings can make even the most basic of animations 
 look polished and finished.
  
 Easings have been around for a while, specifically in web development within 
 cascading 
 style sheets
  (
 CSS
 ).",NA
.easeIn ,"We touched on 
 easeIn
  in the previous section, but for reference, here is how we would use 
 it:
  
 Animation.easeIn(duration: 1)",NA
.easeOut ,"You guessed it 
 –
  the opposite of 
 easeIn
  is 
 easeOut
 : 
  
  
 Animation.easeOut(duration: 1) 
  
 The following is a line diagram of ease-out time against value:
  
  
 [ 243 ]",NA
.easeInOut,"This is the best of both worlds. It's often used as the default easing option to satisfy both 
 needs and give us the best possible effect:
  
 Animation.easeInOut(duration: 1)
  
 The following is a line diagram of ease-in-out time against value:
  
  
 Due to the nature of how 
 easeInOut
  performs, it's advised that you do not perform this 
 animation over a prolonged period of time.",NA
Springs,"No matter what anyone says, Spring animations are just plain fun!
  
 Yes, they have their place and in most enterprise apps, and you'd be hard done to find 
 random images and text labels springing around your device screen 
 –
  but nonetheless, they 
 are still widely used in app development.
  
 Spring and Spring with Damping Fraction were first introduced in iOS 7 as part of the UI 
 overhaul. Although the API has been around since iOS 6, it was only available as a private 
 function that wasn't available to developers.",NA
.spring ,"First, we have the basic 
 spring
  animation, which can be used in its default state or with 
 damping options:
  
 Animation.spring() 
  
 Animation.spring(response: 1.0, dampingFraction: 4, blendDuration: 3.0)
  
  
 Damping Fraction is the amount of drag that's applied to the value being 
 animated as a fraction of an estimate of the amount needed to produce 
 critical damping.
  
 Next, we have 
 interactiveSpring
 , an option that's convenient for 
 spring
  to use with 
 interactive elements (such as a button press):
  
 Animation.interactiveSpring() 
  
 Animation.interactiveSpring(response: 1.0, dampingFraction: 4, blendDuration: 3.0)
  
  
 A convenience is a 
 spring()
  animation with a lower 
 response
  value, 
 intended for driving interactive animations.
  
 Our final Spring option is 
 interpolatingSpring
 :
  
 Animation.interpolatingSpring(stiffness: 2, damping: 4) 
  
 Animation.interpolatingSpring(mass: 2.0, stiffness: 4.0, damping: 3.0, initialVelocity: 2.0)
  
 An interpolating spring animation is one that uses a damped spring
  
  
 model to produce values in the range [0, 1] that are then used to 
  
 interpolate within the [from, to] range of the animated property. It 
 preserves velocity across overlapping animations by adding the effects of 
 each animation.
  
 All of the preceding quotes have been taken from Apple's internal API 
 documentation.
  
 [ 245 ]",NA
.linear,"This is a transition effect that's similar to easings (based on a period of time) but without the 
 initial or final change of inertia:
  
 Animation.linear() 
  
 Animation.linear(duration: 1)
  
 In this section, we looked at the available options we can use when performing an 
 animation in SwiftUI. The majority of the options were around easings and spring 
 animations, although it's not so much about what animation you choose but how you use 
 them. In the next section, we are going to take a look at the rotation and scaling we can 
 perform when using animations. We will learn how to use them in order to manipulate 
 views in SwiftUI.",NA
Rotation and scaling,"For those seasoned programmers among us, you'll know that in the past, with a variety of 
 programming languages, manipulating views or screens in terms of rotation, scale, or even 
 geometry required a small understanding of some form of mathematics.
  
 Luckily, with SwifuUI, operations such as rotating and scaling UI elements are a piece of 
 cake. In this section, we're going to look at an API that adds a 3D feel to an element being 
 rotated.",NA
Rotation,"Let's start by looking at rotation. We'll begin by creating another button. This time, we'll 
 decorate it a little (you'll see why later):
  
 struct ContentView: View {
  
  
  var body: some View {
  
  Button(""Rotate"") {
  
  }
  
  .padding(10)
  
  .background(Color.green)
  
  .foregroundColor(.white)
  
  .clipShape(Circle())
  
  }",NA
3D rotation,"Working almost identically to 
 .rotationEffect
 , the 3D rotation effect is another modifier that 
 will attempt to add a 3D mask to the view you are trying to rotate, thus giving it an almost 
 embossed
  effect when it spins:
  
 .rotation3DEffect(.degrees(360), axis: (x: 0, y: 1, z: 0))
  
 One noticeable difference with 
 rotation3DEffect
  is that it requires an axis to base the 
 rotation off.
  
 From the preceding code snippet, setting the 
 y
  axis allows our view to spin from left to 
 right or vice versa on a vertical point (like a signpost would do in a cartoon!).
  
 The 
 x
  axis will rotate from top to bottom and the 
 z
  axis will spin the view 
 around
 , much like 
 rotationEffect
  did.",NA
Scaling,"Scaling is another type of element manipulation that previously would have required some 
 calculations that may have eluded some of us. 
  
 However, using the same methods as we did with the opacity animation, along with the 
 use of a simple modifier, we can quickly and efficiently scale elements however we want.
  
 Let's have a go by creating another button, just like we did earlier:
  
 Button(""Scale"") {
  
  
  withAnimation {
  
  
  
  // Add scale logic here...
  
  } 
  
 } 
  
 .padding(10) 
  
 .background(Color.green) 
  
 .foregroundColor(.white) 
  
 .clipShape(Circle())
  
 Now, let's take a look at our scale modifier:
  
 .scaleEffect(1)
  
 Yep, it's really that easy! Actually, the only real difference here is the logic that's used to 
 calculate the increase and decrease of the scale effect. Let's add that now.",NA
Adding animation to our app,"In the previous sections, we learned a lot about animations in SwiftUI and with the helping 
 hand of Swift Playground, we've been able to demonstrate and see these in action. But 
 there's nothing like practicing them in the real world! In this section, we'll add some of the 
 tricks we've learned throughout this chapter directly into our app. Even with the smallest of 
 changes, you'll instantly be able to see the impact animations have.",NA
Spinning star,"Now, let's head on over to our Recipe app and make some changes ourselves. We'll start by 
 heading on over to 
 RecipeDetailView.swift
  and finding our favorite button. Add the following 
 highlighted code to add a little 
 spin
  to our selection:
  
 Button(action: {
  
  
  Helper.addRemoveFavourite(recipe: self.recipe)
  
  
  self.recipe.favourite.toggle()
  
  
  withAnimation(.spring()) {
  
  
  
  self.angle = self.angle == 1080 ? 0 : 1080
  
  
  } 
  
 }) {
  
  
  Image(systemName: isFavourite ? ""star.fill"" : ""star"")
  
  
  
 .resizable()
  
  
  
  .aspectRatio(contentMode: .fit) 
  
 } 
  
 .rotationEffect(.degrees(angle)) 
  
 .frame(height: 45)
  
 Here, we've added an explicit animation to our star view. Looking at the 
 action
  in our 
 button, it's clear we're performing a 
 .spring()
  animation when we set the angle of our 
 rotation effect.
  
 Then, we added the 
 rotationEffect
  modifier and set the degrees to the value of our angle 
 variable, which we'll need to set as follows:
  
 @State private var angle: Double = 0
  
 Go ahead 
 –
  compile and run the project and check it out. You'll see the immediate impact of 
 such a small animation.
  
 Find all the other places in the app that have the favorites star and apply this animation 
 there too.",NA
Fading image,"Still in 
 RecipeDetailView.swift
 , let's make a change to our main image. By design, the image 
 should just appear on the screen when the view is loaded, but with a small and very subtle 
 animation, we can give it a much more grand entrance.
  
 Add the following highlighted changes to the Image view, at the top of our view:
  
 Image(uiImage: recipe.image)
  
  
  .resizable()
  
  
  .aspectRatio(contentMode: .fill)
  
  
  .frame(maxWidth: 400, maxHeight: 200)
  
  
  .clipShape(RoundedRectangle(cornerRadius: 10))
  
  
  .opacity(imageOpacity)
  
  
  .onAppear {
  
  
  
  withAnimation(Animation.easeIn(duration: 2.6).delay(0.4)) {
  
  
  
 self.imageOpacity = 1
  
  
  
  }
  
  
  }
  
 We'll start by adding the 
 .opacity
  modifier to our Image view and setting this with the 
 value from the 
 imageOpacity
  variable:
  
 @State private var imageOpacity = 0.0
  
 Next, we'll need to do something we've not yet covered. Since we are not invoking the 
 animation via a button click and are looking to do this when our view firsts loads, we'll set 
 our explicit animation to occur within a 
 .onAppear
  modifier.
  
 Also, notice how we've tweaked some of the animation values in order to get the desired 
 effect. We've set 
 .easeIn
  to 
 2.4
  and also added a 
 .delay
  of 
 0.4
  to our animation in order to 
 allow time for our view to load before performing the actual animation.",NA
Rotating the 3D action button,"Finally, let's take a look at how well the 
 rotation3DEffect
  works. Head on over to 
 AddRecipeView.swift
  and find the 
 Button
  and Image view that we use to choose an image 
 from our library.
  
 Make the following highlighted changes:
  
 Button(action: {
  
  
  DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
  
  
  
 self.showingImagePicker.toggle()",NA
Summary,"In this chapter, we've touched on the core basics of animation in SwiftUI. We've learned 
 about the differences between explicit and implicit animations and when best to use one or 
 the other. We've referenced all the various animation options available to use, from the 
 various types of 
 easings
  to all the options that 
 springs
  have to offer.
  
 Next, we looked at scaling and rotation and put both into practice with the animation types 
 that we just covered, thereby allowing us to experiment with various settings to get our 
 desired effect.
  
 Finally, we took everything we learned from the previous sections and added this to our 
 existing Recipe app. We finished this off by showing you how well the 
  
 .rotation3DEffect
  animation works.
  
 In the next chapter, we're going to be continuing with the theme of animations and take a 
 look at how transitions work in SwiftUI, as well as how we can incorporate these into our 
 Recipe app.",NA
Questions,"1. 
  
 Name the two ways of performing animations in SwiftUI.
  
 2. 
  
 Name three of the animation types we have available.
  
 3. 
  
 What rotation options are available to us?
  
 4. 
  
 What modifier would we use if we needed to animate without user invocation?
  
 5. How would we achieve postponing an animation for a set period of time?",NA
Further reading,"Dispatch:
 https://developer.apple.com/documentation/DISPATCH
  
 Floating Points:
 https://floating-point-gui.de/
  
 [ 254 ]",NA
Animations in Transitions ,NA,NA
,"As we saw in 
 Chapter 13
 , 
 Basic Animation in Views
 , animations can play a part in making a 
 big difference to any app, no matter how small the change is. But if there is one thing that 
 can complement an animation, it's a transition effect.
  
 In this chapter, we are going to start by covering the basic transitions available to us from 
 SwiftUI. We'll look at how and when we can use these with animations and what effect 
 they'll have on our views.
  
 We'll also cover some slightly more advanced syntax in order to not only optimize our code 
 but improve how the animation takes place.
  
 Once we've done that, we'll go back to our Recipe app for the last time and add some 
 finishing touches.
  
 The following topics will be covered in this chapter:
  
 Basic transitions
  
 Advanced transitions
  
 Adding transitions to our app",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the AppStore and select and download the latest version.",NA
Basic transitions,"Let's start by taking a look at how the simplest of transitions can make a big difference in 
 SwiftUI. In this section, we'll cover when and how to use the transition modifier along with 
 the various options available to us.",NA
Invoking a basic transition,"We'll again create a SwiftUI playground in order to test some of these examples out (see 
 Chapter 13
 , 
 Basic Animation in Views
 , on how we created a playground for use in SwiftUI).
  
 We'll start by creating a simple button with a text view that will sit just beneath it:
  
 VStack {
  
  
  Button(""Basic Transitions"") {
  
  
  
  // Add logic here...
  
  
  }
  
  
  Text(""Learn SwiftUI"") 
  
 }
  
 Nice and simple to start with, but our main intention here is to use transitions to bring in 
 our text view when the button is clicked. Let's start by adding a 
 @State
  variable and some 
 conditional logic to make this happen:
  
 @State var transition = false
  
 Then we'll add the following highlighted changes:
  
 Button(""Basic Transitions"") { 
  
  
 self.transition.toggle() 
  
 } 
  
 if transition {
  
  
  Text(""Learn SwiftUI"") 
  
 }
  
 Go ahead and run the code in the playground's canvas. Just as we expected, you should see 
 the text view appear when you click the button.
  
 Now for the... not so complex part: we'll add a simple modifier to our text view and wrap 
 our 
 self.transitions.toggle()
  in an animation block:
  
 Button(""Basic Transitions"") {
  
  
  withAnimation {",NA
Transition modifier options,"There are various options available to us within the basic transition modifier. Let's start by 
 taking a look at them one at a time. I've included direct quotes from the Apple API 
 documentation too (where available):
  
 .opacity
 :
  
 A transition from transparent to opaque on insertion and opaque to transparent 
 on removal
  
 .transition(.opacity)
  
 .scale
 :
  
 No overview available (but basically transitions the view into another view by 
 scaling to size)
  
 .transition(.scale)
  
 .identity
 :
  
 A transition that returns the input view, unmodified, as the output view
  
 .transition(.identity)",NA
Moving views with transitions,"Another transition option we have is 
 .move
 :
  
 .transition(.move(edge: .top))
  
 With this option and its accompanying animation, we can transition the view to the 
 chosen 
 edge
  of a view (
 .top
 , 
 .leading
 , 
 .bottom
 , 
 .trailing
 ).
  
 Add this into your previous playground code and have a go; change the enum values to see 
 all the options.
  
 As we mentioned, the transition will only work as long as it is accompanied by an 
 animation (in our case, an explicit animation). As we're not specifying an animation type, 
 SwiftUI will automatically use the 
 .default
  animation provided by the framework.
  
 Let's take what we've learned from 
 Chapter 13
 , 
 Basic Animation in Views
 ,and spruce up 
 both our animation and transition in one go:
  
 Button(""Basic Transitions"") {
  
  
  withAnimation
 (.interpolatingSpring(stiffness: 40.0, damping: 1.0))
  {
   
  
 self.transition.toggle()
  
  
  } 
  
 } 
  
 .padding(.top, 15) 
  
 if transition {
  
  
  Text(""Learn SwiftUI"")
  
  
  
  .transition(.move(edge: .bottom)) 
  
 }
  
 With this change, you'll see the Text view bounce into life from the bottom of its frame, 
 springing up and down until it finally finds its place.",NA
Advanced transitions,"As we saw in the previous section, combining both animations and transitions needn't be a 
 headache. Yet, in addition to the basic approach, SwiftUI also gives us some alternative 
 options to work with, allowing for more creativity in how we handle not only transitions on 
 their own, but also alongside our existing animation options.",NA
Asymmetric transitions,"Asymmetric transitions are a way of adding and removing views based on their current 
 state without the need for additional or duplicated logic.
  
 Let's take a look at our previous example and see how we would achieve this:
  
 Button(""Basic Transitions"") {
  
  
  withAnimation {
  
  
  
  self.transition.toggle()
  
  
  } 
  
 } 
  
 if transition {
  
  
  Text(""Learn SwiftUI (click me again)"")
  
  
  
  .transition(.asymmetric(insertion: .opacity, removal: .scale)) 
 }
  
 The highlighted code in the preceding snippet is all we need to do. Our 
 .transition 
 modifier accepts a type of 
 .asymmetric
 , which in turn asks for both 
 insertion
  and 
 removal
  parameters:
  
 insertion
  will be the initial transition performed when our 
 if
  statement is 
  
 satisfied.
  
 removal
  will occur when the state is reversed; in our example, this causes the 
  
 view to transition away using a 
 .scale
 .
  
 As previously mentioned, these transitions are only possible with their accompanying 
 animation, which leaves the window wide open for further animation types to be added 
 into the mix.",NA
Combined transitions,"This is where it starts to get interesting. Using a combined transition allows you to perform 
 two transitions simultaneously. Let's take a look at how we would construct this modifier:
  
 .transition(
 AnyTransition.opacity.combined(with: .slide)
 )
  
 Here, we start by selecting the first transition in question, 
 AnyTransition.opacity
 . Then, we 
 use the combined function to add a 
 .slide
  effect to the mix.
  
 Try it out
 —
 see how seamlessly it works? Remember that you'll still need an accompanying 
 animation to go with it, but more on how we can help tackle that in a moment.",NA
"Using asymmetric, combined, and inline ",NA,NA
animations together,"Now that we've covered a couple of the more advanced options with transitions, let's take a 
 look at how we can make them all work seamlessly together.
  
 We'll start by merging both 
 asymmetric
  and 
 combined
  transitions together:
  
 .transition(.asymmetric(insertion: AnyTransition.opacity.combined(with: .slide), removal: .scale))
  
 As you can see from the preceding code, we've added the combined function within our 
 insertion
  parameter
 —
 go ahead and try it for yourself!
  
 Another thing that you've heard me mention quite a few times in this chapter is the 
 following:
  
 Remember that you'll still need an accompanying animation.
  
 Well, that's not always the case. Let's take a look at how we can adjust our code to include 
 the explicit animation so that we don't have to worry about it:
  
 Button(""Basic Transitions"") {
  
  
  self.transition.toggle() 
  
 } 
  
 .padding(.top, 15) 
  
 if transition {
  
  
  Text(""Learn SwiftUI (click me again)"")
  
  
  
  .transition(AnyTransition.opacity.combined(with: 
 .slide).animation(.easeInOut(duration: 1.0))) 
  
 }",NA
Adding transitions to our app,"Now that we've mastered the art of basic transitions, let's continue to work these into our 
 app so we can really fine-tune our UI.
  
 In this section, we'll add some basic transitions to our app, looking specifically at moving 
 text with transitions. Then we'll take what we have learned with advanced transitions by 
 incorporating asymmetric and combined transitions alongside the existing animations that 
 we added in 
 Chapter 13
 , 
 Basic Animation in Views
 .",NA
Transition validation,"We'll start off with something simple. Head on over to 
 AddRecipeView.swift
  and add the 
 following 
 @State
  variable:
  
 @State private var validated = false
  
 Now add the following just below your 
 Save 
 button:
  
 if validated {
  
  
  Text(""* Please give your recipe a name"")
  
  
  
 .foregroundColor(.red)
  
  
  
  .bold()
  
  
  
  .transition(.move(edge: .top)) 
  
 }",NA
Asymmetric transition ,NA,NA
–,NA,NA
 loading state,"In this section, we are going to transition a text view, which lets the user know when they 
 are requesting a remote image from our external API. Once the loading is complete and our 
 image is displayed, we'll then transition out the text view.
  
 Staying within 
 AddRecipeView.swift
 , add the following 
 @State
  variable into our struct:
  
 @State var loadingImage = false",NA
Summary,"In this chapter, we started by taking a look at basic transitions and how we can invoke them 
 using animations we learned about in 
 Chapter 13
 , 
 Basic Animations in Views
 . We then covered 
 the range of modifiers available to us, including scaling, opacity, and sliding.
  
 From this, we took a deep dive into the more advanced options and saw how asymmetric 
 transitions work by giving us entry and exit points for a specific transition. We then looked 
 at how to combine transitions, which allowed us to use the power of two different 
 transitions in one go.
  
 Finally, we took everything we learned from our advanced transitions and brought them 
 together harmoniously to really show off the power of animations and transitions in 
 SwiftUI.
  
 In the next chapter, we'll take a look at how to tackle testing and debugging, and how we as 
 the developer can make Xcode work for us.",NA
Questions,"1. 
  
 What type of animation is required for a transition to work?
  
 2. 
  
 Name three of the transition options available to us.
  
 3. 
  
 How would we adjust a view with a transition?
  
 4. What is the difference between asymmetric and combined transitions?",NA
Testing in SwiftUI ,NA,NA
,"In this chapter, we'll explore the fundamentals of testing and debugging and see how we 
 can use the excellent tools already built into Xcode to achieve this.
  
 We'll learn how to incorporate XCTest into our Recipe app for both UI and Unit Test and 
 then go on to write our very own test that we can run against our project.
  
 Finally, we'll cover debugging and how we can stop the process of our app in real-time and 
 use certain tools and commands to inspect elements right within Xcode.
  
 The following topics will be covered in this chapter:
  
 Creating our first UI test project and tests
  
 Creating our first Unit Test project and tests
  
 Debugging in SwiftUI",NA
Technical requirements,"For this chapter, you'll need to download Xcode version 11.3 or above from the Apple Mac 
 App Store. You'll also need to be running the latest version of macOS (Catalina or above).
  
 Simply search for 
 Xcode
  in the App Store and select and download the latest version.
  
 Launch Xcode and follow any additional installation instructions that your system may 
 prompt you for. Once Xcode has been fully launched, you'll be ready to go!",NA
Creating a UI/Unit Test project,"Testing plays a massive part in any form of software development, from a human being 
 sitting at a desk and running through a script of what to test and what results are expected, 
 to automated tests running hourly or every time a change is made to a particular code base. 
  
 Regardless of how small or big your app is, one way or another, testing should always play 
 a fundamental part in your app's development process.
  
 In this section, we are going to take a look at two ways we can integrate tests in our app 
 from a developer's perspective: by using tools that are built into Xcode and a process that 
 can seamlessly be added into our project.",NA
Creating a UI test project,"We'll start by taking a look at UI Tests 
 –
  or automation tests, as they are sometimes known 
 (although most variations of developer tests are automated).
  
 UI tests allow us to validate certain aspects of our apps from a visual perspective of the 
 user's 
 happy path
  of what is expected from the app. Let's start by adding a UITest project to 
 our existing Recipe app.
  
 In our existing project, click 
 File
  | 
 New
  | 
 Target
 . Once the menu is open, make sure the iOS 
 tab is selected and search for 
 Test
  in the search box. Then, highlight UI Testing Bundle and 
 click Next:",NA
Writing our very first UI Test,"Let's start by looking at naming conventions for UI Tests. The key (and best practice) to UI 
 Tests 
 –
  or any test functions, for that matter 
 –
  is a good name. Try and write the function 
 name as if you were describing the action you are taking, along with the expected result.
  
 Rename the 
 testExample()
  function to 
 testCanTapMapButton()
 . The key here is to always 
 start your function names with the word 
 test
 . This is how Xcode and XCTest are able to 
 identify your tests. 
  
 As you've probably gathered by the description, our first UI Test is going to check that not 
 only is the map button visible, but if it is tappable too, since this is what we expect from the 
 app when it's launched.
  
 Make the following highlighted amendment to the function:
  
 func 
 testCanTapMapButton
 () {
  
  
  let app = XCUIApplication()
  
  
  app.launch()
  
  
  app.buttons[""accessibility.map.button""].tap() 
 }
  
 Let's go through this one line at a time. First, we create an instance of 
  
 XCUIApplication()
 . This instance is a reference to the app in our main project and it's from 
 here where we will invoke all our UI Test requests.",NA
Writing multiple UI Tests,"Now, let's add some more UI Tests regarding the navigation buttons. Here are some more 
 I've created. Copy these into your project and see if you can add the relevant accessibility 
 modifiers to get them to pass. Go on 
 –
  I know you can do it!
  
 func testCanTapFilterButton() {
  
  
  let app = XCUIApplication()
  
  
  app.launch()
  
  
  app.buttons[""accessibility.filter.button""].tap() } 
  
 func testCanTapAddButton() {
  
  
  let app = XCUIApplication()
  
  
  app.launch()
  
  
  app.buttons[""accessibility.add.button""].tap() }
  
 Did they pass? I'm sure they did, but if you are struggling, just take a look at the sample 
 project for this chapter and it will point you in the right direction.
  
 Now, let's take a closer look at all three UI Tests we have. Notice anything? There's a lot of 
 duplication, especially in terms of creating our 
 XCUIApplication()
  instance and launching it. 
 This is where our 
 setUp()
  method comes in handy.
  
 Make the following highlighted changes to your test class:
  
 let app = XCUIApplication()
  
  
  override func setUp() { 
  
  
  
 app.launch()
  
  
  }",NA
Nesting UI Tests,"Another trick we can perform is making use of existing tests we've already written in order 
 to help aid new tests, such as if we want to check something on our 
 AddRecipeDetail 
 view. 
 But first, we need to get there.
  
  
 In the world of Unit Tests (covered in the next section), tests like these are 
 commonly referred to as integration tests. This is because they are testing 
 the integration between pieces of logic by testing one function's 
  
 dependency on another.
  
 Add the following new test to your test class:
  
 func testCanAddRecipeImage() {
  
  
  testCanTapAddButton()
  
  
  app.buttons[""accessibility.add.image.button""].tap() }
  
 As you can see, we are simply calling an existing test, 
 testCanTapAddButton()
 , to get to the 
 AddRecipeView
  view. From there, we can continue with our desired test, which in this case 
 checks whether we can tap on the 
 Add Image
  button.
  
 [ 271 ]",NA
Testing with assertions,"We're well on our way now with writing our UI Tests, so let's take a look at assertions.
  
 Assertions allow us to test the outcome of a particular scenario; for example, if a value (such 
 as a String) should equal (or not equal) another value or whether an Integer should be equal 
 to, greater than, or less than a particular value.
  
 Let's make a new UI Test based around our 
 AddRecipeView
 :
  
 func testAddIngredientsAddsToList() {
  
  
  testCanTapAddButton()
  
  
  let textField = app.textFields[""accessibility.ingredient.textfield""]
  
  textField.tap()
  
  
  textField.typeText(""Milk"")
  
  
  app.buttons[""accessibility.ingredient.add.button""].tap()
  
  
  XCTAssertTrue(app.staticTexts[""accessibility.ingredient.list""].exists) }
  
 Again, we've called upon another existing function to get where we want to be. Here, we've 
 identified a specific 
 TextField
  and tapped on this to bring it into focus (just like a user would 
 to bring up the keyboard). Then, we've used 
 .typeText("""")
  to enter a test so that we can 
 .tap()
  
 the 
 Add
  button.
  
 Finally, we can now perform our assertion. Looking at our logic in 
  
 AddRecipeView.swift
 , we only create the list if something has been added to it, so for our 
 assertion, we're looking for the 
 staticTexts
  identifier in question and checking if it 
 .exists
 . 
  
 With our 
 XCTestAssertTrue
  wrapped around this logic, 
 XCTest
  will either pass or fail the 
 test based on the outcome. Try it for yourself 
 –
  don't forget to add the 
  
 accessibilityIdentifier
  modifiers in the required places.
  
 In this section, we learned all about UI Tests and how to set up a specific target just for the 
 tests within our existing Xcode project. Then, we looked at the structure of running each 
 test and created multiple UI Tests, some of which can be integrated with each other, in 
 order to test the required user journey. 
  
 In the next section, we'll create our first Unit Test and learn about the differences between 
 them and UI Tests.
  
 [ 272 ]",NA
Creating our first Unit Test project and tests,"In this section, we are going to take a look at the other side of the testing pond and discover 
 what Unit Tests are and why they are just as important as UI Tests. We'll start by creating a 
 Unit Test project within our current Xcode project and create our first test.",NA
Creating a Unit Test project,"As opposed to UI Tests, Unit Tests are designed to test specific pieces of logic within your 
 app. For example, you may have a function that calculates a complex algorithm, which 
 would then be used in multiple places within your app.
  
 Writing a Unit Test for this function will give you the confidence of being able to update 
 your logic without having to worry about any breaking changes.
  
 In our existing project, click 
 File
  | 
 New
  | 
 Target
 . Once the menu is open, make sure the 
 iOS
  tab is selected and search for 
 Test
  in the search box. Then, highlight 
 Unit Testing 
 Bundle
  and click 
 Next
 :",NA
Writing our very first Unit Test,"Now that we're set up, let's get straight into it and start writing our first Unit Test. Copy the 
 following into your test class (you can remove 
 testExample()
 ):
  
 func testIfGetCountriesHasItems() {
  
  
  XCTAssertTrue(Helper.getCountries().count > 0) }",NA
Unit Testing conclusion,"The main focus of this book is UI and we've not had to write a great deal of hard logic or 
 algorithms, so I just wanted to touch on Unit Testing so that you can consider it when you 
 write your first app.
  
 The key to successful Unit Testing is finding a way to implement it that suits you. There are 
 many different approaches, such as 
 test-driven development
  (
 TDD
 ), which is where a 
 developer would write the Unit Test first (which, in turn, would fail) and then write the 
 function accordingly in order to make the test pass. Once the test passes, you could then 
 refactor your code with the safe knowledge that any breaking changes would be picked up 
 by your Unit Test.",NA
Debugging in SwiftUI,"In the olden days, the thought of your IDE being able to debug your application was 
 unheard of 
 –
  you could spend hours looking for that bug only to find it was a missing 
 semicolon. 
  
 In this section, we'll cover the options available to us in Xcode that will help make our daily 
 lives just a little easier. We'll start by taking a look at how to add breakpoints to our app, 
 followed by good old-fashioned 
 print
  statements.",NA
Understanding breakpoints,"Breakpoints have been around for a while now, and not just in Xcode 
 –
  other IDEs such as 
 Visual Studio make great use of breakpoints to debug applications on the fly.
  
 In a nutshell, by adding a breakpoint at a specific line in your code, when running the app 
 from the IDE, should the line of code where you have placed the breakpoint be hit, the code 
 will pause at this point and allow you inspect any variable that might be available at that 
 time.
  
 The following is an example of a breakpoint in Xcode. A currently active breakpoint will 
 appear in light blue, as shown here:",NA
Inspecting variables,"If you hover over 
 recipes
  and expand the current collection, you'll be able to see the array of 
 RecipeModel()
  currently being passed in:",NA
Understanding the console window,"To the right of the Watch Window is the console. When your app is running, Xcode will 
 automatically output any data that's been pushed to the console here. However, when you 
 hit a breakpoint, you can input commands to check the value of a variable, condition, or 
 even a function for yourself. Let's take a look at how we would do this:
  
 [ 278 ]",NA
Other tools to consider,"Xcode really is bursting with features to be proud of and a lot of them are out of the scope 
 of this book. However, I couldn't leave this chapter without mentioning a couple of 
 things to take note of, should you fancy dipping your toes further into the water.",NA
Instruments,NA,NA
Analyze,"Analyze is a static analyzer built directly into Xcode. These days, static analysis plays a big 
 part in many types of development projects. Analyze, as a tool, can offer the following in 
 terms of features for your current project:
  
 Logic flaws and uninitialized variables
  
 Memory leaks and bad management
  
 Suggestions on API usages that don't conform to Apple's Framework guidelines
  
 Analyze can be found from Xcode's menu bar by clicking on 
 Product
  | 
 Analyze
 .",NA
Summary,"In this chapter, we've covered how to start testing with UI Testing and Unit Testing. We do 
 this by creating new targets in our current project and learning the fundamental basics of 
 how to write the tests. We also looked at the differences between them and why they coexist 
 in Xcode.
  
 Then, we looked at debugging and explored the most common tools used for debugging, 
 such as breakpoints, the Watch Window, and the output console.
  
 We wrapped up the section by looking at some of the other tools that are available that you 
 may wish to explore.
  
 The only thing left to do is grab that second coffee and give yourself a big pat on the back -
 with everything we've covered during the course of this book - you'll have no trouble 
 getting up and running building your first SwiftUI project - good luck and thank you for 
 coming along for the ride!",NA
Questions,"1. 
  
 What are the two fundamental differences between UI and Unit Tests?
  
 2. 
  
 How do we add a UI or Unit Test to our current project?
  
 3. 
  
 How should we word the name of the function for a test?
  
 4. 
  
 What is the name of Xcode's test suite?
  
 5. 
  
 How would we output a class hierarchy to the console window?",NA
Further reading,"MobileA11y Blog:
  https://mobilea11y.com/
  
 Static Analyzer:
 https://developer.apple.com/library/archive/ 
  
 documentation/DeveloperTools/Conceptual/debugging_with_xcode/chapters/ static_analyzer.
 html",NA
Other Books You May Enjoy,"If you enjoyed this book, you may be interested in these other books by Packt:
  
  
 iOS 13 Programming for Beginners - Fourth Edition 
 Ahmad Sahar, Craig Clayton
  
 ISBN: 978-1-83882-190-6
  
 Get to grips with the fundamentals of Xcode 11 and Swift 5, the building blocks 
  
 of iOS development
  
 Understand how to prototype an app using storyboards
  
 Discover the Model-View-Controller design pattern, and how to implement the 
  
 desired functionality within the app
  
 Implement the latest iOS features such as Dark Mode and Sign In with Apple
  
 Understand how to convert an existing iPad app into a Mac app
  
 Design, deploy, and test your iOS applications with industry patterns and 
  
 practices",NA
Leave a review - let other readers know what ,NA,NA
you think,"Please share your thoughts on this book with others by leaving a review on the site that you 
 bought it from. If you purchased the book from Amazon, please leave us an honest review 
 on this book's Amazon page. This is vital so that other potential readers can see and use 
 your unbiased opinion to make purchasing decisions, we can understand what our 
 customers think about our products, and our authors can see your feedback on the title that 
 they have worked with Packt to create. It will only take a few minutes of your time, but is 
 valuable to other potential customers, our authors, and Packt. Thank you!
  
 [ 285 ]",NA
Index,NA,NA
3 ,"3D rotation effect  
 248
  
 AnnotationPin
  
  about  
 143
  
  adding  
 143
 , 
 144
 , 
 145",NA
@ ,"@EnvironmentObject class 
 adding  
 88
 , 
 89
  
  creating  
 143
  
  custom annotation, creating  
 146
 , 
 148 
 app navigation
  
  about  
 83
 , 
 84
  
  
  injecting  
 88
 , 
 89 
  
 @EnvironmentObject
  
  adding, to ContentView  
 84
 , 
 85
 , 
 86
 , 
 87 
 Apple Developer memberships
  
  best practices  
 92
 , 
 93
  
  reference link  
 21
  
  mocking  
 93
 , 
 94
  
  using  
 89
 , 
 90
  
  using, as single source of truth  
 90
 , 
 91
 , 
 92
  
 using, for access  
 87",NA
A ,"advanced transitions
  
  about  
 259
  
  asymmetric transitions  
 259
  
 combined transitions  
 260
  
 using, together  
 260
 , 
 261 
 analyze
  
  about  
 281
  
 Apple Worldwide Developers Conference (WWDC) 
   
 7 
  
 asymmetric transitions
  
  about  
 259
  
  state, loading  
 262
 , 
 263 
  
 Automatic Preview
  
  about  
 46
 , 
 47
 , 
 49
 , 
 50
 , 
 52
 , 
 53
  
  mock data  
 49",NA
B ,"basic transitions
  
  invoking  
 256
 , 
 257
  
  modifier options  
 257
  
  features  
 281 
  
 animation option
  
  easings  
 242
  
  Springs  
 244 
  
 animations
  
  3D action button, rotating  
 251
 , 
 253",NA
C ,"Cascading Style Sheets (CSS)  
 15
 , 
 242 
 closure function  
 123 
  
 Codeable, in Swift
  
  reference link  
 37
  
  
  adding, to app  
 250
  
  explicit animations  
 241
  
 combined transitions  
 260 
  
 computed property  
 80
  
  fading image  
 251 
  
 ContentView
  
  implicit animations  
 239
  
  
  app navigation, adding  
 84
 , 
 85
 , 
 86
 , 
 87
  
 options, exploring  
 242 
  
 controls
  
  spinning star  
 250
  
  
  adding  
 68
  
  usage  
 239
  
  
  buttons, adding  
 69
 , 
 70
 , 
 71
  
 annotation callout accessory  
 161
  
  images, adding  
 72
 , 
 73",NA
F ,"form View
  
  button, adding to navigation bar  
 103
 , 
 104
  
 creating  
 97
  
  custom modifier, creating  
 99
 , 
 100
 , 
 102
 , 
 103
  
 data, persisting  
 119
  
  data, persisting to app  
 116
  
  image, persisting  
 116
 , 
 118",NA
D ,"Data Binding
  
  save button, adding  
 120
 , 
 121
  
  temporary workaround  
 105
  
  text and text fields, implementing  
 97
 , 
 99
  
  
  versus Data Source  
 230 
  
 data
  
  passing, between iOS app and watchOS  
 214 
 declarative syntax
  
  about  
 18
 , 
 19
  
  Hello World app, creating  
 21
 , 
 22
  
  modifiers, used for decoration  
 23
  
  multiple views, returning  
 22
 , 
 23
  
  SwiftUI, setting up in Xcode  
 19
  
  Views, adding  
 23
  
  visualizing  
 19 
  
 decoration techniques
  
  comparing  
 232 
  
 decoration
  
  exploring  
 57 
  
 design patterns
  
  in SwiftUI  
 34 
  
 developer tools
  
  analyze  
 281
  
  instruments  
 280 
  
 devices  
 45 
  
 DoubleColumnNavigationViewStyle
  
  used, for improving architecture  
 188
 , 
 190
  
 using  
 183
 , 
 185
 , 
 187",NA
G ,"General Public License (GPL)  
 7 
 Grand Central Dispatch (GCD)  
 253 
 graphical user interface (GUI)  
 11",NA
I ,"Image View
  
  creating  
 106
 , 
 107 
  
 ImageHelper
  
  implementing  
 108
 , 
 110 
  
 images
  
  adding, from library  
 105 
  
 imperative syntax  
 28 
  
 implicit animations  
 239
 , 
 241 
  
 instruments  
 280 
  
 integrated development environment (IDE)  
 12
 , 
 42 
 integration tests  
 276 
  
 Interface Builder
  
  about  
 11
  
  UI, creating via  
 11
 , 
 12 
  
 iOS app
  
  data, passing to watchOS  
 214
  
  data, receiving on watchOS  
 218
 , 
 219
 , 
 220",NA
E ,"easings option
  
  .easeIn  
 242
  
  data, sending to watchOS  
 217
  
  sendMessage() end to end, testing  
 220
 , 
 221
  
 WatchConnectivity, initializing  
 215
 , 
 216
 , 
 217 
 iPad app
  
 [ 287 ]",NA
L ,"List View
  
  custom views, creating  
 63
  
  versus UITableView  
 225 
  
 Low-Level Virtual Machine (LLVM)  
 7
  
 multiline text input
  
  adding  
 110 
  
 MVVM architecture  
 31 
  
 MVVM pattern
  
  Model  
 31
  
  View  
 31
  
  ViewModel  
 31",NA
N,NA,NA
M ,"macOS
  
  options  
 133 
  
 map
  
  adding, with MapKit control  
 139 
 MapKit control
  
  implementing  
 139
 , 
 140
  
  used, for adding map  
 139 
  
 MapKit View
  
  adding, to SwiftUI  
 140
 , 
 141
 , 
 142 
 MapKitHelper file  
 139
  
 NavigationViewStyle
  
  benefit  
 190
 , 
 192
  
  options  
 182
  
  using  
 182 
  
 Navigator  
 44
 , 
 45 
  
 nesting
  
  syntax  
 26
 , 
 27 
  
 networking, in SwiftUI
  
  about  
 123
  
  network helper, creating  
 123
  
  network request, invoking  
 124
 , 
 125 
 NeXTSTEP Interface Builder (NIB)  
 11
  
 MapLocationManager class
  
  creating  
 148
 , 
 149
 , 
 150
  
  linking, to SwiftUI  
 151 
  
 MapView
  
  annotation callout accessory, adding  
 161
 , 
 162
 ,",NA
P ,"PreviewProvider
  
  about  
 53
 , 
 54
  
  updating  
 60
 , 
 61
  
  
   
 163
 , 
 164
  
  ContentView(), filtering  
 161
 , 
 162
 , 
 163
 , 
 164
  
 Helper() class, updating  
 157
 , 
 158
  
  implementing  
 157
  
  linking  
 159
 , 
 160
 , 
 161
  
  reset filter button, adding  
 165 
  
 Massachusetts Institute of Technology (MIT)  
 7 
 mock data
  
  in Automatic Preview  
 49",NA
R ,"recipe details View
  
  creating  
 78
 , 
 79
 , 
 80
 , 
 81 
  
 RecipeMapView file  
 139 
  
 recipeModel  
 49 
  
 representable protocols
  
  about  
 133
  
  macOS, options  
 133
  
 [ 288 ]",NA
S ,"scheme  
 45 
  
 SF Symbols  
 70 
  
 Spring animations
  
  .linear  
 246
  
  .spring  
 245
  
  about  
 244 
  
 Swift
  
  as programming language  
 7
 , 
 8
 , 
 9 
 SwiftUI application
  
  building  
 42
 , 
 43
 , 
 44 
  
 SwiftUI List
  
  basic implementation  
 229
  
  watchOS, multiple screens  
 209
 , 
 210 
 Syntax
  
  in SwiftUI  
 14",NA
T ,"test-driven development (TDD)  
 275 
 Text decoration  
 61
 , 
 62 
  
 Text
  
  exploring  
 57
  
  options  
 57
 , 
 58
 , 
 59 
  
 toggle  
 236 
  
 transition validation  
 261
 , 
 262 
  
 transitions
  
  adding, to app  
 261
  
  views, moving  
 258
  
  
 SwiftUI, in Xcode
  
  setting up  
 19
 , 
 21
  
  starting with  
 20 
  
 SwiftUI
  
  about  
 12
 , 
 13
  
  breakpoints  
 276
 , 
 277
  
  console window  
 278
 , 
 279
 , 
 280
  
  Data Sources, handling  
 231
 , 
 232
  
  debugging  
 276
  
  design patterns  
 34
  
  developer tools  
 280
  
  features  
 14
  
  grouping  
 27
  
  List() view, creating in watchOS  
 204
 , 
 205
  MapKit 
 View, adding  
 140
 , 
 141
 , 
 143
  
  mock data, using  
 205
 , 
 207
  
  modifiers  
 23
 , 
 25
 , 
 26
  
  multiple devices, building  
 15
  
  multiple screens, adding  
 210
 , 
 211
 , 
 212
 , 
 213
 , 
   
 214
  
  need for  
 15
 , 
 16
  
  networking  
 123
  
  observable objects  
 34
 , 
 35
 , 
 36
 , 
 37
  
  publishing objects  
 38
 , 
 39
  
  States  
 14
  
  syntax  
 14
  
  tools  
 14
  
  updating  
 14
  
  used, for creating list of recipes  
 204
  
  variables, inspecting  
 277
 , 
 278",NA
U ,"UI elements
  
  rotating  
 246
 , 
 247
  
  scaling  
 246
 , 
 248
 , 
 249 
  
 UI frameworks  
 10 
  
 UI logic  
 31 
  
 UI programmatically
  
  creating  
 10
 , 
 11 
  
 UI Test project
  
  creating  
 266
 , 
 267
 , 
 268
  
  nesting  
 271
  
  testing, with assertions  
 272
  
  writing  
 268
 , 
 269
 , 
 270
 , 
 271 
  
 UI
  
  creating, via Interface Builder  
 11
 , 
 12 
 UIKit
  
  migrating  
 235
  
  multiple Data Sources  
 230
 , 
 231 
  
 UIStackView  
 235 
  
 UISwitch  
 236 
  
 UITableView
  
  basic implementation  
 225
 , 
 226
 , 
 227
  
 versus List view  
 225 
  
 UITextField  
 236 
  
 UITextView wrapper
  
  implementing  
 110
 , 
 112 
  
 UIViewControllerRepresentable
  
  implementing  
 130
 , 
 133 
  
 UIViewRepresentable
  
 [ 289 ]",NA
V ,"Vertical-Stack (VStack)  
 49 
  
 ViewControllers
  
  integrating, with UIViewControllerRepresentable 
   
 130 
  
 Views
  
  creating  
 78
  
  mock data, updating  
 81
 , 
 82
 , 
 83
  
  moving, with transitions  
 258
  
  recipe details View, creating  
 78
 , 
 79
 , 
 80
 , 
 81
  
 testing, in simulator  
 83",NA
W,"watchOS
  
  data, passing from iOS app  
 214
  
 developing  
 196
  
  extensions  
 197
  
  extensions, working with  
 197
  
 options  
 135
  
  WatchKi framework  
 196",NA
X ,"Xcode Simulator  
 47
 , 
 48 
  
 Xcode, components
  
  about  
 44
  
  Automatic Preview  
 46
 , 
 47
  
 device list  
 45
  
  Navigator  
 44
 , 
 45
  
  scheme  
 45
  
  Xcode Simulator  
 47
 , 
 48 
 Xcode
  
  about  
 42
  
  
 WatchKi framework  
 196
  
  SwiftUI, setting up  
 19
 , 
 21 
  
 XML Interface Builder (XIB)  
 11",NA
