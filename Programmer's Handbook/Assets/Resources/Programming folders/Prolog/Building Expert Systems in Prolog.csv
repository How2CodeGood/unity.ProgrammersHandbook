Larger Text,Smaller Text,Symbol
Building Expert Systems in Prolog ,by,NA
Dennis Merritt ,NA,NA
Preface ,"When I compare the books on expert systems in my library with the production expert systems I know of, I note that 
 there are few good books on building expert systems in Prolog. Of course, the set of actual production systems is a little 
 small for a valid statistical sample, at least at the time and place of this writing – here in Germany, and in the first days 
 of 1989. But there are at least some systems I have seen running in real life commercial and industrial environments, and 
 not only at trade shows. 
  
 I can observe the most impressive one in my immediate neighborhood. It is installed in the Telephone Shop of the 
 German Federal PTT near the Munich National Theater, and helps configure telephone systems and small PBXs for 
 mostly private customers. It has a neat, graphical interface, and constructs and prices an individual telephone 
 installation interactively before the very eyes of the customer. 
  
 The hidden features of the system are even more impressive. It is part of an expert system network with a distributed 
 knowledge base that will grow to about 150 installations in every Telephone Shop throughout Germany. Each of them 
 can be updated individually overnight via Teletex to present special offers or to adapt the selection process to the 
 hardware supplies currently available at the local warehouses. 
  
 Another of these industrial systems supervises and controls in ""soft"" real time the excavators currently used in Tokyo 
 for subway construction. It was developed on a Unix workstation and downloaded to a single board computer using a 
 real time operating system. The production computer runs exactly the same Prolog implementation that was used for 
 programming, too. 
  
 And there are two or three other systems that are perhaps not as showy, but do useful work for real applications, such as 
 oil drilling in the North Sea, or estimating the risks of life insurance for one of the largest insurance companies in the 
 world. What all these systems have in common is their implementation language: Prolog, and they run on ""real life"" 
 computers like Unix workstations or minis like VAXs. Certainly this is one reason for the preference of Prolog in 
 commercial applications. 
  
 But there is one other, probably even more important advantage: Prolog is a programmer's and software engineer's 
 dream. It is compact, highly readable, and arguably the ""most structured"" language of them all. Not only has it done 
 away with virtually all control flow statements, but even explicit variable assignment too! 
  
 These virtues are certainly reason enough to base not only systems but textbooks on this language. Dennis Merritt has 
 done this in an admirable manner. He explains the basic principles, as well as the specialized knowledge representation 
 and processing techniques that are indispensable for the implementation of industrial software such as those mentioned 
 above. This is important because the foremost reason for the relative neglect of Prolog in expert system literature is 
 probably the prejudice that ""it can be used only for backward chaining rules."" Nothing is farther from the truth. Its 
 relational data base model and its underlying unification mechanism adapt easily and naturally to virtually any 
 programming paradigm one cares to use. Merritt shows how this works using a copious variety of examples. His book 
 will certainly be of particular value for the professional developer of industrial knowledge-based applications, as well as 
 for the student or programmer interested in learning about or building expert systems. I am, therefore, happy to have 
 served as his editor. 
  
 Peter H. Schnupp 
  
 Munich, January 1989 
  
 Building Expert Systems in Prolog 
  
 iii",NA
Acknowledgements ,"A number of people have helped make this book possible. They include Dave Litwack and Bill Linn of Cullinet who 
 provided the opportunity and encouragement to explore these ideas. Further thanks goes to Park Gerald and the Boston 
 Computer Society, sounding boards for many of the programs in the book. Without the excellent Prolog products from 
 Cogent (now Amzi!), AAIS, Arity, and Logic Programming Associates none of the code would have been developed. A 
 special thanks goes to Peter Gable and Paul Weiss of Arity for their early help and Allan Littleford, provider of both 
 Cogent Prolog and feedback on the book. Jim Humphreys of Suffolk University gave the most careful reading of the 
 book, and advice based on years of experience. As have many other Mac converts, I feel compelled to mention my 
 Macintosh SE, Microsoft Word and Cricket Draw for creating an enjoyable environment for writing books. And finally 
 without both the technical and emotional support of Mary Kroening the book would not have been started or finished.
  
 iv",NA
Table of Contents ,"Preface........................................................................................................iii
  
 Acknowledgements ...................................................................................iv
  
 1Introduction............................................................................................1
  
 1.1 Expert Systems ............................................................................................ 1
  
 1.2 Expert System Features............................................................................... 3
  
 Goal-Driven 
 Reasoning 
 .............................................................................................3 
 Uncertainty.................................................................................................................
 4 
 Data 
 Driven 
 Reasoning 
 .............................................................................................4 
 Data 
 Representation..................................................................................................5 
 User 
 Interface 
 ............................................................................................................6 Explanations 
 ..............................................................................................................7
  
 1.3 Sample Applications..................................................................................... 7
  
 1.4 Prolog........................................................................................................... 8
  
 1.5 Assumptions................................................................................................. 8
  
 2Using Prolog's Inference Engine..........................................................9
  
 2.1 The Bird Identification System...................................................................... 9
  
 Rule 
 formats 
 ..............................................................................................................9 Rules about 
 birds.....................................................................................................10 Rules for 
 hierarchical relationships..........................................................................10 Rules 
 for other relationships....................................................................................11
  
 2.2 User Interface............................................................................................. 13
  
 Attribute 
 Value 
 pairs 
 ................................................................................................13 
 Asking 
 the 
 user........................................................................................................13 
 Remembering 
 the 
 answer 
 .......................................................................................14 
 Multi-valued 
 answers...............................................................................................14 Menus for 
 the 
 user...................................................................................................15 
 Other 
 enhancements...............................................................................................16
  
 2.3 A Simple Shell............................................................................................ 16
  
 Command loop 
 ........................................................................................................17 A tool for non-
 programmers.....................................................................................19
  
 2.4 Summary.................................................................................................... 19
  
 Exercises.......................................................................................................... 19
  
 3Backward Chaining with Uncertainty.................................................21
  
 3.1 Certainty Factors........................................................................................ 21
  
 An 
 Example 
 .............................................................................................................21 
 Rule 
 Uncertainty 
 ......................................................................................................22 
 User Uncertainty......................................................................................................22 
 Combining 
 Certainties 
 .............................................................................................23 
 Properties 
 of 
 Certainty Factors................................................................................23
  
 3.2 MYCINs Certainty Factors.......................................................................... 24
  
 Determining Premise CF .........................................................................................24",NA
1 Introduction ,"Over the past several years there have been many implementations of expert systems using 
 various tools and various hardware platforms, from powerful LISP machine workstations to 
 smaller personal computers. 
  
 The technology has left the confines of the academic world and has spread through many 
 commercial institutions. People wanting to explore the technology and experiment with it 
 have a bewildering selection of tools from which to choose. There continues to be a debate 
 as to whether or not it is best to write expert systems using a high-level shell, an AI 
 language such as LISP or Prolog, or a conventional language such as C. 
  
 This book is designed to teach you how to build expert systems from the inside out. It 
 presents the various features used in expert systems, shows how to implement them in 
 Prolog, and how to use them to solve problems. 
  
 The code presented in this book is a foundation from which many types of expert systems 
 can be built. It can be modified and tuned for particular applications. It can be used for 
 rapid prototyping. It can be used as an educational laboratory for experimenting with expert 
 system concepts.",NA
 1.1 Expert Systems ,"Expert systems are computer applications which embody some non-algorithmic expertise 
 for solving certain types of problems. For example, expert systems are used in diagnostic 
 applications servicing both people and machinery. They also play chess, make financial 
 planning decisions, configure computers, monitor real time systems, underwrite insurance 
 policies, and perform many other services which previously required human expertise. 
  
 Domain
  
 User
  
 User
  
 Expert
  
 expertise
  
 Interface
  
 Knowledge
  
 Inference
  
 System
  
 Engineer
  
 Engine
  
 Engineer
  
 encoded
  
 Knowledge
  
 Working
  
 expertise
  
 Base
  
 Storage
  
 Figure 1.1  Expert system components and human interfaces 
  
 Expert systems have a number of major system components and interface with individuals 
 in various roles. These are illustrated in figure 1.1. The major components are: 
  
 Building Expert Systems in Prolog 
  
 1",NA
1.2 Expert System Features ,"There are a number of features which are commonly used in expert systems. Some shells 
 provide most of these features, and others just a few. Customized shells provide the 
 features which are best suited for the particular problem. The major features covered in 
 this book are: 
  
 • 
 Goal driven reasoning or backward chaining – an inference technique which uses IF 
 THEN rules to repetitively break a goal into smaller sub-goals, which are easier to prove; 
  
 • 
 Coping with uncertainty – the ability of the system to reason with rules and data that are 
 not precisely known; 
  
 • 
 Data driven reasoning or forward chaining – an inference technique that uses IF 
 THEN rules to deduce a problem solution from initial data; 
  
 • 
 Data representation – the way in which the problem specific data in the system is 
 stored and accessed; 
  
 • 
 User interface – that portion of the code that creates an easy-to-use system; 
  
 • 
 Explanations – the ability of the system to explain the reasoning process that it used to 
 reach a recommendation.",NA
Goal-Driven Reasoning ,"Goal-driven reasoning, or backward chaining, is an efficient way to solve problems that 
 can be modelled as ""structured selection"" problems. That is, the aim of the system is to 
 pick the best choice from many enumerated possibilities. For example, an identification 
 problem falls in this category. Diagnostic systems also fit this model, since the aim of the 
 system is to pick the correct diagnosis. 
  
 The knowledge is structured in rules, which describe how each of the possibilities might 
 be selected. The rule breaks the problem into sub-problems. For example, the following 
 top level rules are in a system which identifies birds. 
  
 IF 
  
  
  family is albatross and 
  
  
  color is white 
  
 THEN 
  
  
  bird is laysan albatross. 
  
 IF 
  
  
  family is albatross and 
  
  
  color is dark 
  
 THEN 
  
  
  bird is black footed albatross. 
  
 The system would try all of the rules which gave information satisfying the goal of 
 identifying the bird. Each would trigger sub-goals. In the case of these two rules, the sub-
 goals of determining the family and the color would be pursued. The following rule is one 
 that satisfies the family sub-goal: 
  
 IF 
  
  order is tubenose and 
  
  size large and 
  
  wings long narrow 
  
 Building Expert Systems in Prolog
  
 3",NA
Uncertainty ,"Often in structured selection problems the final answer is not known with complete 
 certainty. The expert's rules might be vague, and the user might be unsure of answers to 
 questions. This can be easily seen in medical diagnostic systems where the expert is not 
 able to be definite about the relationship between symptoms and diseases. In fact, the 
 doctor might offer multiple possible diagnoses. 
  
 For expert systems to work in the real world they must also be able to deal with 
  
 uncertainty. One of the simplest schemes is to associate a numeric value with each piece of 
 information in the system. The numeric value represents the certainty with which the 
 information is known. There are numerous ways in which these numbers can be defined, 
 and how they are combined during the inference process.",NA
Data Driven Reasoning ,"For many problems it is not possible to enumerate all of the possible answers beforehand 
 and have the system select the correct one. For example, system configuration problems 
 fall in this category. These systems might put components in a computer, design circuit 
 boards, or lay out office space. Since the inputs vary and can be combined in an almost 
 infinite number of ways, the goal driven approach will not work. 
  
 The data driven approach, or forward chaining, uses rules similar to those used for 
 backward chaining. However, the inference process is different. The system keeps track 
 of the current state of problem solution and looks for rules, which will move that state 
 closer to a final solution. 
  
 A system to layout living room furniture would begin with a problem state consisting of a 
 number of unplaced pieces of furniture. Various rules would be responsible for placing the 
 furniture in the room, thus changing the problem state. When all of the furniture was 
 placed, the system would be finished, and the output would be the final state. Here is a rule 
 from such a system which places the television opposite the couch. 
  
 IF 
  
  
  unplaced tv and 
  
  
  couch on wall(X) and 
  
  
  wall(Y) opposite wall(X) 
  
 THEN 
  
  
  place tv on wall(Y). 
  
 This rule would take a problem state with an unplaced television and transform it to a state 
 that had the television placed on the opposite wall from the couch. Since the television is 
 now placed, this rule will not fire again. Other rules for other furniture will fire until the 
 furniture arrangement task is finished. 
  
 Note that for a data driven system, the system must be initially populated with data, in 
 contrast to the goal driven system which gathers data as it needs it. Figure 1.2 illustrates 
 the difference between forward and backward chaining systems for two simplified rules. 
  
 The forward chaining system starts with the data of 
 a=1
  and 
 b=2
  and uses the rules to 
  
 4 
  
 Chapter 1 - Introduction",NA
Data Representation ,"For all rule based systems, the rules refer to data. The data representation can be simple or complex, depending on the 
 problem. The four levels described in this section are illustrated in figure 1.3. 
  
 Attribute-Value Pairs 
  
  
  
 color – white 
  
 Object Attribute-Value Triples 
  
  
  
 arm_chair – width – 3 
  
  
 straight_chair – width – 2 
 Records 
  
  
 chairs 
  
 object 
  
 width 
  
 color 
  
 type 
  
  
 chair #1 
  
 3 
  
 orange 
  
 easy 
  
 chair #2 
  
 2 
  
 brown 
  
 straight 
  
 Frames 
  
  
 mammal 
  
 skin 
  
 legs 
  
  
 fur 
  
 default 4 
  
  
 size 
  
 elephant 
  
  
  
 monkey 
  
 legs 
  
 tusks 
  
 type 
  
 tail 
  
 size 
  
    
 large 
  
 default 2 
  
 constraint: 
 indian or 
  
 african 
  
  
 curly 
  
 medium 
  
 2 
  
  
 Figure 1.3  Four levels of data representation 
  
 Building Expert Systems in Prolog
  
 5",NA
User Interface ,"The acceptability of an expert system depends to a great extent on the quality of the user 
 interface. The easiest to implement interfaces communicate with the user through a 
 scrolling dialog as illustrated in figure 1.4. The user can enter commands, and respond to 
 questions. The system responds to commands, and asks questions during the inferencing 
 process. 
  
  
 ...",NA
Explanations ,"One of the more interesting features of expert systems is their ability to explain 
 themselves. Given that the system knows which rules were used during the inference 
 process, it is possible for the system to provide those rules to the user as a means for 
 explaining the results. 
  
 This type of explanation can be very dramatic for some systems such as the bird 
  
 identification system. It could report that it knew the bird was a black footed albatross 
 because it knew it was dark colored and an albatross. It could similarly justify how it knew 
 it was an albatross. 
  
 At other times, however, the explanations are relatively useless to the user. This is because 
 the rules of an expert system typically represent empirical knowledge, and not a deep 
 understanding of the problem domain. For example a car diagnostic system has rules which 
 relate symptoms to problems, but no rules which describe why those symptoms are related 
 to those problems. 
  
 Explanations are always of extreme value to the knowledge engineer. They are the 
 program traces for knowledge bases. By looking at explanations the knowledge engineer 
 can see how the system is behaving, and how the rules and data are interacting. This is an 
 invaluable diagnostic tool during development.",NA
1.3 Sample Applications ,"In chapters 2 through 9, some simple expert systems are used as examples to illustrate the 
 features and how they apply to different problems. These include a bird identification 
 system, a car diagnostic system, and a system which places furniture in a living room. 
  
 Chapters 10 and 11 focus on some actual systems used in commercial environments. 
 These were based on the principles in the book, and use some of the code from the book. 
  
 The final chapter describes a specialized expert system which solves Rubik's cube and 
 does not use any of the formalized techniques presented earlier in the book. It illustrates 
 how to customize a system for a highly specialized problem domain. 
  
 Building Expert Systems in Prolog
  
 7",NA
1.4 Prolog ,"The details of building expert systems are illustrated in this book through the use of Prolog 
 code. There is a small semantic gap between Prolog code and the logical specification of a 
 program. This means the description of a section of code, and the code are relatively 
 similar. Because of the small semantic gap, the code examples are shorter and more concise 
 than they might be with another language. 
  
 The expressiveness of Prolog is due to three major features of the language: rule-based 
 programming, built-in pattern matching, and backtracking execution. The rule-based 
 programming allows the program code to be written in a form which is more declarative 
 than procedural. This is made possible by the built-in pattern matching and backtracking 
 which automatically provide for the flow of control in the program. Together these 
 features make it possible to elegantly implement many types of expert systems. 
  
 There are also arguments in favor of using conventional languages, such as C, for building 
 expert system shells. Usually these arguments center around issues of portability, 
  
 performance, and developer experience. As newer versions of commercial Prologs have 
 increased sophistication, portability, and performance, the advantages of C over Prolog 
 decrease. However, there will always be a need for expert system tools in other languages. 
  
 (One mainframe expert system shell is written entirely in COBOL.) 
  
 For those seeking to build systems in other languages, this book is still of value. Since the 
 Prolog code is close to the logical specification of a program, it can be used as the basis for 
 implementation in another language.",NA
1.5 Assumptions ,"This book is written with the assumption that the reader understands Prolog programming. 
  
 If not, 
 Programming in Prolog
  by Clocksin and Mellish from Springer-Verlag is the classic 
 Prolog text. 
 APT - The Active Prolog Tutor
  by the author and published by Solution 
 Systems in South Weymouth, Massachusetts is an interactive PC based tutorial that 
 includes a practice Prolog interpreter. 
  
 An in depth understanding of expert systems is not required, but the reader will probably 
 find it useful to explore other texts. In particular since this book focuses on system 
 engineering, readings in knowledge engineering would provide complementary 
  
 information. Some good books in this area are: 
 Building Expert Systems
  by Hayes-Roth, 
 Waterman, and Lenat; 
 Rule-Based Expert Systems
  by Buchanan and Shortliffe; and 
 Programming Expert Systemsin OPS5
  by Brownston, Kant, Farrell, and Martin. 
  
 8 
  
 Chapter 1 - Introduction",NA
2 Using Prolog's Inference Engine ,"Prolog has a built-in backward chaining inference engine that can be used to partially 
 implement some expert systems. Prolog rules are used for the knowledge representation, 
 and the Prolog inference engine is used to derive conclusions. Other portions of the 
 system, such as the user interface, must be coded using Prolog as a programming 
 language. 
  
 The Prolog inference engine does simple backward chaining. Each rule has a goal and a 
 number of sub-goals. The Prolog inference engine either proves or disproves each goal. 
 There is no uncertainty associated with the results. 
  
 This rule structure and inference strategy is adequate for many expert system applications. 
 Only the dialog with the user needs to be improved to create a simple expert system. These 
 features are used in this chapter to build a sample application called ""Birds"", which 
 identifies birds. 
  
 In the later portion of this chapter the Birds system is split into two modules. One contains 
 the knowledge for bird identification, and the other becomes ""Native"" – the first expert 
 system shell developed in the book. Native can then be used to implement other similar 
 expert systems.",NA
 2.1 The Bird Identification System ,"A system which identifies birds will be used to illustrate a native Prolog expert system. 
  
 The expertise in the system is a small subset of that contained in 
 Birds of North America 
 by 
 Robbins, Bruum, Zim, and Singer. The rules of the system were designed to illustrate how 
 to represent various types of knowledge, rather than to provide accurate identification.",NA
Rule formats ,"The rules for expert systems are usually written in the form: 
  
 IF 
  
  first premise, and 
  
  second premise, and 
  
  ... 
  
 THEN 
  
  
  conclusion 
  
 The IF side of the rule is referred to as the left hand side (LHS), and the THEN side is 
 referred to as the right hand side (RHS). This is semantically the same as a Prolog rule: 
  
 conclusion :- 
  
  first_premise,  
  
  second_premise,  
  
  ... 
  
 Note that this is a bit confusing since the syntax of Prolog is really THEN IF, and the 
 normal RHS and LHS appear on opposite sides. 
  
 Building Expert Systems in Prolog
  
 9",NA
Rules about birds ,"The most fundamental rules in the system identify the various species of birds. We can 
 begin to build the system immediately by writing some rules. Using the normal IF THEN 
 format, a rule for identifying a particular albatross is: 
  
 IF 
  
  
  family is albatross and 
  
  
  color is white 
  
 THEN 
  
  
  bird is laysan_albatross 
  
 In Prolog the same rule is: 
  
 bird(laysan_albatross) :- 
  
  family(albatross),  
  
  color(white). 
  
 The following rules distinguish between two types of albatross and swan. They are clauses 
 of the predicate 
 bird/1
 : 
  
 bird(laysan_albatross):- 
  
  family(albatross),  
  
  color(white). 
  
 bird(black_footed_albatross):- 
  
  family(albatross),  
  
  color(dark). 
  
 bird(whistling_swan) :- 
  
  family(swan),  
  
  voice(muffled_musical_whistle). 
  
 bird(trumpeter_swan) :- 
  
  family(swan),  
  
  voice(loud_trumpeting). 
  
 In order for these rules to succeed in distinguishing the two birds, we would have to store 
 facts about a particular bird that needed identification in the program. For example if we 
 added the following facts to the program: 
  
 family(albatross). 
  
 color(dark). 
  
 then the following query could be used to identify the bird: 
  
 ?- bird(X). 
  
 X = black_footed_albatross 
  
 Note that at this very early stage there is a complete working Prolog program, which 
 functions as an expert system to distinguish between these four birds. The user interface is 
 the Prolog interpreter's interface, and the input data is stored directly in the program.",NA
Rules for hierarchical relationships ,"The next step in building the system would be to represent the natural hierarchy of a bird 
 classification system. These would include rules for identifying the family and the order of 
 a bird. Continuing with the albatross and swan lines, the predicates for 
 order
  and 
 family 
 are: 
  
 order(tubenose) :- 
  
  
  nostrils(external_tubular),  
  
 10 
  
 Chapter 2 - Using Prolog's Inference Engine",NA
Rules for other relationships ,"The Canada goose can be used to add some complexity to the system. Since it spends its 
 summers in Canada, and its winters in the United States, its identification includes where it 
 was seen and in what season. Two different rules would be needed to cover these two 
 situations: 
  
 bird(canada_goose):- 
  
  family(goose),  
  
  season(winter),  
  
  country(united_states),  
  
  head(black),  
  
  cheek(white). 
  
 bird(canada_goose):- 
  
  family(goose),  
  
  season(summer),  
  
  country(canada),  
  
  head(black),  
  
  cheek(white). 
  
 Building Expert Systems in Prolog
  
 11",NA
2.2 User Interface ,"The system can be dramatically improved by providing a user interface which prompts for 
 information when it is needed, rather than forcing the user to enter it beforehand. The 
 predicate 
 ask
  will provide this functionality.",NA
Attribute Value pairs ,"Before looking at 
 ask
 , it is necessary to understand the structure of the data which will be 
 asked about. All of the data has been of the form: ""attribute-value"". For example, a bird is 
 a mallard if it has the following values for these selected bird attributes: 
  
 Attribute
  
 Value
  
 family
  
 duck
  
 voice 
  
 quack 
  
 head 
  
 green 
  
 This is one of the simplest forms of representing data in an expert system, but is sufficient 
 for many applications. More complex representations can have ""object-attribute-value"" 
 triples, where the attribute-values are tied to various objects in the system. Still more 
 complex information can be associated with an object and this will be covered in the 
 chapter on frames. For now the simple attribute-value data model will suffice. 
  
 This data structure has been represented in Prolog by predicates which use the predicate 
 name to represent the attribute, and a single argument to represent the value. The rules 
 refer to attribute-value pairs as conditions to be tested in the normal Prolog fashion. For 
 example, the rule for mallard had the condition 
 head(green) 
 in the rule. 
  
 Of course since we are using Prolog, the full richness of Prolog's data structures could be 
 used, as in fact list membership was used in the rules for 
 region
 . The final chapter 
 discusses a system which makes full use of Prolog throughout the system. However, the 
 basic attribute-value concept goes a long way for many expert systems, and using it 
 consistantly makes the implementation of features such as the user interface easier.",NA
Asking the user ,"The 
 ask
  predicate will have to determine from the user whether or not a given attribute-
 value pair is true. The program needs to be modified to specify which attributes are 
 askable. This is easily done by making rules for those attributes that call 
 ask
 . 
  
 eats(X):- ask(eats, X). 
  
 feet(X):- ask(feet, X). 
  
 wings(X):- ask(wings, X). 
  
 neck(X):- ask(neck, X). 
  
 color(X):- ask(color, X). 
  
 Now if the system has the goal of finding 
 color(white)
  it will call 
 ask
 , rather than look in 
 the program. If 
 ask(color, white)
  succeeds, 
 color(white)
  succeeds. 
  
 The simplest version of 
 ask
  prompts the user with the requested attribute and value and 
 seeks confirmation or denial of the proposed information. The code is: 
  
 Building Expert Systems in Prolog
  
 13",NA
Remembering the answer ,"A new predicate, 
 known/3
  is used to remember the user's answers to questions. It is not 
 specified directly in the program, but rather is dynamically 
 assert
 ed whenever 
 ask
  gets 
 new information from the user. 
  
 Every time 
 ask
  is called it first checks to see if the answer is already 
 known
  to be yes or 
 no. If it is not already 
 known
 , then 
 ask
  will 
 assert
  it after it gets a response from the user. 
  
 The three arguments to 
 known
  are: yes/no, attribute, and value. The new version of 
 ask 
 looks like: 
  
 ask(A, V):- 
  
  
  known(yes, A, V), % succeed if true 
  
  
  !. % stop looking  
  
 ask(A, V):- 
  
  
  known(_, A, V),  % fail if false 
  
  
  !, 
  
  
  fail. 
  
 ask(A, V):- 
  
  write(A:V),  % ask user 
  
  write('? : '),  
  
  read(Y),  % get the answer 
  
  asserta(known(Y, A, V)),  % remember it 
  
  Y == yes.  % succeed or fail 
  
 The cuts in the first two rules prevent 
 ask
  from backtracking after it has already 
 determined the answer.",NA
Multi-valued answers ,"There is another level of subtlety in the approach to 
 known
 . The 
 ask
  predicate now 
 assumes that each particular attribute value pair is either true or false. This means that the 
 user could respond with a ""yes"" to both color:white and color:black. In effect, we are 
  
 14 
  
 Chapter 2 - Using Prolog's Inference Engine",NA
Menus for the user ,"The user interface can further be improved by adding a menu capability that gives the user 
 a list of possible values for an attribute. It can further enforce that the user enter a value on 
 the menu. 
  
 This can be implemented with a new predicate, 
 menuask
 . It is similar to 
 ask
 , but has an 
 additional argument which contains a list of possible values for the attribute. It would be 
 used in the program in an analogous fashion to 
 ask
 : 
  
 size(X):- 
  
  
  menuask(size, X, [large, plump, medium, small]). 
  
 flight(X):- 
  
  
  menuask(flight, X, [ponderous, agile, flap_glide]). 
  
 The
  menuask
  predicate can be implemented using either a sophisticated windowing 
 interface, or by simply listing the menu choices on the screen for the user. When the user 
 returns a value it can be verified, and the user reprompted if it is not a legal value. 
  
 A simple implementation would have initial clauses as in 
 ask
 , and have a slightly different 
 clause for actually asking the user. That last clause of 
 menuask
  might look like: 
  
 menuask(A, V, MenuList) :- 
  
  write('What is the value for'), write(A), write('?'), nl,   
 write(MenuList), nl,  
  
  read(X),  
  
  check_val(X, A, V, MenuList),  
  
  asserta( known(yes, A, X) ),  
  
  X == V. 
  
 check_val(X, A, V, MenuList) :- 
  
  member(X, MenuList), 
  
  !. 
  
 check_val(X, A, V, MenuList) :- 
  
  write(X), write(' is not a legal value, try again.'), nl,   
 menuask(A, V, MenuList). 
  
 Building Expert Systems in Prolog
  
 15",NA
Other enhancements ,"Other enhancements can also be made to allow for more detailed prompts to the user, and 
 other types of input validation. These can be included as other arguments to 
 ask
 , or 
 embodied in other versions of the 
 ask
  predicate. Chapter 10 gives other examples along 
 these lines.",NA
2.3 A Simple Shell ,"The bird identification program has two distinct parts: the knowledge base, which contains 
 the specific information about bird identification; and the predicates that control the user 
 interface. 
  
 By separating the two parts, a shell can be created, which can be used with any other 
 knowledge base. For example, a new expert system could be written that identifies fish. It 
 could be used with the same user interface code developed for the bird identification 
 system. 
  
 The minimal change needed to break the two parts into two modules is a high level 
 predicate that starts the identification process. Since in general it is not known what is 
 being identified, the shell will seek to solve a generic predicate called 
 top_goal
 . Each 
 knowledge base will have to have a 
 top_goal
 , which calls the goal to be satisfied. For 
 example: 
  
 top_goal(X) :- bird(X). 
  
 This is now the first predicate in the knowledge base about birds. 
  
 The shell has a predicate called 
 solve
 , which does some housekeeping and then solves for 
 the 
 top_goal
 . It looks like: 
  
 solve :- 
  
  abolish(known, 3),  
  
  define(known, 3),  
  
  top_goal(X),  
  
  write('The answer is '), write(X), nl. 
  
 solve :- 
  
  
  write('No answer found.'), nl. 
  
 The built-in 
 abolish
  predicate is used to remove any previous 
 known
 s from the system 
 when a new consultation is started. This allows the user to call 
 solve
  multiple times in a 
 single session. 
  
 The 
 abolish
  and 
 define
  predicates are built-in predicates that respectively remove previous 
 known
 s for a new consultation, and ensure that 
 known
  is defined to the system so no error 
 condition is raised the first time it is referenced. Different dialects of Prolog might require 
 different built-in predicate calls. 
  
 In summary, the predicates of the bird identification system have been divided into two 
 modules. The predicates in the shell, called 
 Native
 , are: 
  
  
 • 
  
 solve
  – starts the consultation; 
  
 • 
  
 ask
  – poses simple questions to the users and remembers the answers; 
  
 16 
  
  
 Chapter 2 - Using Prolog's Inference Engine",NA
Command loop ,"The shell can be further enhanced to have a top level command loop called 
 go
 . To begin 
 with, 
 go
  should recognize three commands: 
  
 • 
 load
  – Load a knowledge base. 
  
 • 
 consult
  – Consult the knowledge base by satisfying the top goal of the knowledge 
 base. 
  
 • 
 quit
  – Exit from the shell. 
  
 The 
 go
  predicate will also display a greeting and give the user a prompt for a command. 
 After reading a command, 
 do
  is called to execute the command. This allows the command 
 names to be different from the actual Prolog predicates that execute the command. For 
 example, the common command for starting an inference is 
 consult
 ; however, 
 consult
  is 
 the name of a built-in predicate in Prolog. This is the code: 
  
 go :- 
  
  
  greeting,  
  
  
  repeat,  
  
   
  write('> '),  
  
   
  read(X),  
  
   
  do(X),  
  
  
  X == quit. 
  
 greeting :- 
  
  write('This is the Native Prolog shell.'), nl,  
  
  write('Enter load, consult, or quit at the prompt.'), nl. 
  
 do(load) :- 
  
  load_kb, 
  
  !. 
  
 do(consult) :- 
  
  solve, 
  
  !. 
  
 Building Expert Systems in Prolog
  
 17",NA
A tool for non-programmers ,"There are really two levels of Prolog, one which is very easy to work with, and one which 
 is a little more complex. 
  
 The first level is Prolog as a purely declarative rule based language. This level of Prolog is 
 easy to learn and use. The rules for bird identification are all formulated with this simple 
 level of understanding of Prolog. 
  
 The second level of Prolog requires a deeper understanding of backtracking, unification, 
 and built-in predicates. This level of understanding is needed for the shell. 
  
 By breaking the shell apart from the knowledge base, the code has also been divided along 
 these two levels. Even though the knowledge base is in Prolog, it only requires the high 
 level understanding of Prolog. The more difficult parts are hidden in the shell. 
  
 This means the knowledge base can be understood with only a little training by an 
 individual who is not a Prolog programmer. In other words, once the shell is hidden from 
 the user, this becomes an expert system tool that can be used with very little training.",NA
2.4 Summary ,"The example shows that Prolog's native syntax can be used as a declarative language for 
 the knowledge representation of an expert system. The rules lend themselves to solving 
 identification and other types of selection problems that do not require dealing with 
 uncertainty. 
  
 The example has also shown that Prolog can be used as a development language for 
 building the user interface of an expert system shell. In this case Prolog is being used as a 
 full programming language.",NA
Exercises ,"2.1 In 
 Native
 , implement commands to provide help and to list the current ""known""s. 
  
 2.2 Have 
 menuask
  print a numbered list of items and let the user just enter the number 
  
 of the chosen item. 
  
 2.3 Modify both 
 ask
  and 
 menuask
  to recognize input from the user which is a 
  
 command, execute the command, and then re-ask the question. 
  
 2.4 Add a prompt field to 
 ask
  which allows for a longer question for an attribute. 
  
 2.5 Modify the system to handle attribute-object-value triples as well as attribute-value 
  
 pairs. For example, rules might have goals such as 
 color(head, green)
 , 
 color(body, 
  
 green)
 , 
 length(wings, long)
 , and 
 length(tail, short)
 . Now 
 ask
  will prompt with 
  
 both the object and the attribute as in ""head color?"". This change will lead to a more 
  
 natural representation of some of the knowledge in a system as well as reducing the 
  
 number of attributes. 
  
 2.6 Use the 
 Native
  shell to build a different expert system. Note any difficulties in 
  
 implementing the system and features that would have made it easier. 
  
 Building Expert Systems in Prolog
  
 19",NA
3 Backward Chaining with Uncertainty ,"As we have seen in the previous chapter, backward chaining systems are good for solving 
 structured selection types of problems. The Birds system was a good example; however, it 
 made the assumption that all information was either absolutely true, or absolutely false. In 
 the real world, there is often uncertainty associated with the rules of thumb an expert uses, 
 as well as the data supplied by the user. 
  
 For example, in the Birds system the user might have spotted an albatross at dusk and not 
 been able to clearly tell if it was white or dark colored. An expert system should be able to 
 handle this situation and report that the bird might have been either a laysan or black footed 
 albatross. 
  
 The rules too might have uncertainty associated with them. For example, a mottled brown 
 duck might only identify a mallard with 80% certainty. 
  
 This chapter will describe an expert system shell, called 
 Clam
 , which supports backward 
 chaining with uncertainty. The use of uncertainty changes the inference process from that 
 provided by pure Prolog, so 
 Clam
  has its own rule format and inference engine.",NA
3.1 Certainty Factors ,"The most common scheme for dealing with uncertainty is to assign a certainty factor to 
 each piece of information in the system. The inference engine automatically updates and 
 maintains the certainty factors as the inference proceeds.",NA
An Example ,"Let's first look at an example using 
 Clam
 . The certainty factors (preceded by cf) are 
 integers from –100 (for definitely false) to +100 (for definitely true). 
  
 The following is a small knowledge base in 
 Clam
  that is designed to diagnose a car which 
 will not start. It illustrates some of the behavior of one scheme for handling uncertainty. 
  
 goal problem. 
  
 rule 1 
  
 if not turn_over and 
  
 battery_bad 
  
 then problem is battery. 
  
 rule 2 
  
 if lights_weak 
  
 then battery_bad cf 50. 
  
 rule 3 
  
 if radio_weak 
  
 then battery_bad cf 50. 
  
 rule 4 
  
 if turn_over and 
  
 smell_gas 
  
 then problem is flooded cf 80. 
  
 rule 5 
  
 if turn_over and 
  
 gas_gauge is empty 
  
 then problem is out_of_gas cf 90. 
  
 Building Expert Systems in Prolog
  
 21",NA
Rule Uncertainty ,"What follows is a sample dialog of a consultation with the Car expert system. 
  
 consult, restart, load, list, trace, how, exit 
 :
 consult 
  
 Does the engine turn over? 
  
 : 
 yes 
  
 Do you smell gas? 
  
 : 
 yes 
  
 What does the gas gauge say? 
  
 empty 
  
 low 
  
 full 
  
 : 
 empty 
  
 problem-out_of_gas-cf-90 
  
 problem-flooded-cf-80 
  
 done with problem 
  
 Notice that, unlike Prolog, the inference does not stop after having found one possible value 
 for problem. It finds all of the reasonable problems and reports the certainty to which they 
 are known. As can be seen, these certainty factors are not probability values, but simply 
 give some degree of weight to each answer.",NA
User Uncertainty ,"The following dialog shows how the user's uncertainty might be entered into the system. 
 The differences from the previous dialog are shown in bold. 
  
 22 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
Combining Certainties ,"Finally consider the following consultation, which shows how the system combines 
 evidence for a bad battery. Remember that there were two rules that concluded the battery 
 was weak with a certainty factor of 50. 
  
 :consult 
  
 Does the engine turn over? 
  
 :
  no 
  
 Are the lights weak? 
  
 : 
 yes 
  
 Is the radio weak? 
  
 : 
 yes 
  
 problem-battery-cf-75 
  
 done with problem 
  
 In this case the system combined the two rules to determine that the battery was weak with 
 certainty factor 75. This propagated straight through rule 1 and became the certainty factor 
 for 
 problembattery
 .",NA
Properties of Certainty Factors ,"There are various ways in which the certainty factors can be implemented, and how they 
 are propagated through the system, but they all have to deal with the same basic situations: 
  
 • 
 rules whose conclusions are uncertain; 
  
 • 
 rules whose premises are uncertain; 
  
 • 
 user entered data which is uncertain; 
  
 • 
 combining uncertain premises with uncertain conclusions; 
  
 • 
 updating uncertain working storage data with new, also uncertain information; 
  
 • 
 establishing a threshold of uncertainty for when a premise is considered known. 
  
 Clam
  uses the certainty factor scheme that was developed for MYCIN, one of the earliest 
 expert systems used to diagnose bacterial infections. Many commercial expert system 
 shells today use this same scheme. 
  
 Building Expert Systems in Prolog
  
 23",NA
3.2 MYCINs Certainty Factors ,"The basic MYCIN certainty factors (CFs) were designed to produce results that seemed 
 intuitively correct to the experts. Others have argued for factors that are based more on 
 probability theory and still others have experimented with more complex schemes designed 
 to better model the real world. The MYCIN factors, however, do a reasonable job of 
 modeling for many applications with uncertain information. 
  
 We have seen from the example how certainty information is added to the rules in the 
 then 
 clause. We have also seen how the user can specify CFs with input data. These are the only 
 two ways uncertainty gets into the system. 
  
 Uncertainty associated with a particular run of the system is kept in working storage. Every 
 time a value for an attribute is determined by a rule or a user interaction, the system saves 
 that attribute value pair and associated CF in working storage. 
  
 The CFs in the conclusion of the rule are based on the assumption that the premise is 
 known with a CF of 100. That is, if the conclusion has a CF of 80 and the premise is 
 known to CF 100, then the fact which is stored in working storage has a CF of 80. For 
 example, if working storage contained: 
  
 turn_over cf 100 
  
 smell_gas cf 100 
  
 then a firing of rule 4: 
  
 rule 4 
  
 if turn_over and 
  
 smell_gas 
  
 then problem is flooded cf 80 
  
 would result in the following fact being added to working storage: 
  
 problem flooded cf 80",NA
Determining Premise CF ,"However, it is unlikely that a premise is perfectly known. The system needs a means for 
 determining the CF of the premise. The algorithm used is a simple one. The CF for the 
 premise is equal to the minimum CF of the individual sub goals in the premise. If working 
 storage contained: 
  
 turn_over cf 80 
  
 smell_gas cf 50 
  
 then the premise of rule 4 would be known with CF 50, the minimum of the two.",NA
Combining Premise CF and Conclusion CF ,"When the premise of a rule is uncertain due to uncertain facts, and the conclusion is 
 uncertain due to the specification in the rule, then the following formula is used to 
 compute the adjusted certainty factor of the conclusion: 
  
 CF = RuleCF * PremiseCF / 100. 
  
 Given the above working storage and this formula, the result of a firing of rule 4 would be: 
  
 24 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
Premise Threshold CF ,"A threshold value for a premise is needed to prevent all of the rules from firing. The 
 number 20 is used as a minimum CF necessary to consider a rule for firing. This means 
 that if working storage had: 
  
 turn_over cf 80 
  
 smell_gas cf 15 
  
 then rule 4 would not fire due to the low CF associated with the premise.",NA
Combining CFs ,"Next, consider the case where there is more than one rule that supports a given conclusion. 
 In this case, each of the rules might fire and contribute to the CF of the resulting fact. If a 
 rule fires supporting a conclusion, and that conclusion is already represented in working 
 memory by a fact, then the following formulae are used to compute the new CF associated 
 with the fact. X and Y are the CFs of the existing fact and rule conclusion. 
  
 CF(X, Y) = X + Y(100 - X)/100.  X, Y both > 0 
  
 CF(X, Y) = X + Y/1 - min(|X|, |Y|).  one of X, Y < 0 
 CF(X, Y) = -CF(-X, -Y).  X, Y both < 0 
  
 For example, both rules 2 and 3 provide evidence for 
 battery_bad
 : 
  
 rule 2 
  
 if lights_weak 
  
 then battery_bad cf 50. 
  
 rule 3 
  
 if radio_weak 
  
 then battery_bad cf 50. 
  
 Assume the following facts are in working storage: 
  
 lights_weak cf 100 
  
 radio_weak cf 100 
  
 A firing of rule 2 would then add the following fact: 
  
 battery_bad cf 50 
  
 Next, rule 3 would fire – also concluding 
 battery_bad
  cf 50. However, there already is a 
 battery_bad
  fact in working storage, so rule 3 updates the existing fact with the new 
 conclusion using the formulae above. This results in working storage being changed to: 
  
 battery_bad cf 75 
  
 This case most clearly shows why a new inference engine was needed for 
 Clam
 . When 
 trying to prove a conclusion for which the CF is less than 100, we want to gather all of the 
  
 Building Expert Systems in Prolog
  
 25",NA
3.3 Rule Format ,"Since we are writing our own inference engine, we can design our own internal rule format 
 as well. (We will use something easier to read for the user.) It has at least two arguments: 
 one for the IF or left hand side (LHS), which contains the premises, and one for the THEN 
 or right hand side (RHS), which contains the conclusion. It is also useful to keep a third 
 argument for a rule number or name. The overall structure looks like: 
  
 rule(Name, LHS, RHS). 
  
 The name will be a simple atom identifying the rule. The 
 LHS
  and 
 RHS
  must hold the rest 
 of the rule. Typically in expert systems, a rule is read: LHS implies RHS. This is 
  
 backwards from a Prolog rule, which can be thought of as being written RHS :- LHS, or 
 RHS is implied by LHS. That is, the RHS (conclusion) is written on the left of the rule, and 
 the LHS (premises) is written on the right. 
  
 Since we will be backward chaining, and each rule will be used to prove or disprove some 
 bit of information, the 
 RHS
  contains one goal pattern, and its associated CF. This is: 
  
 rhs(Goal, CF) 
  
 The 
 LHS
  can have many sub-goals, which are used to prove or disprove the 
 RHS
 : 
  
 lhs(GoalList) 
  
 where 
 GoalList
  is a list of goals. 
  
 The next bit of design has to do with the actual format of the goals themselves. Various 
 levels of sophistication can be added to these goals, but for now we will use the simplest 
 form, which is attribute-value pairs. For example, 
 gas_gauge
  is an attribute, and 
 low
  is a 
 value. Other attributes have simple yes-no values, such as 
 smell_gas
 . An attribute-value 
 pair will look like: 
  
 av(Attribute, Value) 
  
 where Attribute and Value are simple atoms. The entire rule structure looks like: 
  
 rule(Name, 
  
  lhs( [av(A1, V1), av(A2, V2), ....] ),   
 rhs( av(Attr, Val), CF) ). 
  
 Internally, rule 5 looks like: 
  
 rule(5, 
  
  lhs( [av(turns_over, yes), av(gas_gauge, empty)] ),   
 rhs( av(problem, flooded), 80) ). 
  
 This rule format is certainly not easy to read, but it makes the structure clear for 
  
 programming the inference engine. There are two ways to generate more readable rules for 
 the user. One is to use operator definitions. The other is to use Prolog's language handling 
 ability to parse our own rule format. The built-in definite clause grammar (DCG) of most 
 Prologs is excellent for this purpose. Later in this chapter we will use DCG to create a clean 
 user interface to the rules. The forward chaining system in a later chapter uses the operator 
 definition approach. 
  
 26 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
3.4 The Inference Engine ,"Now that we have a format for rules, we can write our own inference engine to deal with 
  
 those rules. Let's summarize the desired behavior: 
  
 • 
 combine certainty factors as indicated previously; 
  
 • 
 maintain working storage information that is updated as new evidence is acquired; 
  
 • 
 find all information about a particular attribute when it is asked for, and put that 
  
 information in working storage. 
  
 The major predicates of the inference engine are shown in figure 3.1. They are described 
  
 in detail in the rest of this section. 
  
 findgoal
  
  
 % already known 
  
 % ask  user 
  
 % derive from rules
  
 fact askable query_user 
  
 fg
  
 rule 
  
 prove 
  
 adjust 
  
 update
  
 findgoal 
  
 fact 
  
 combine
  
 Figure 3.1 Major predicates of Clam inference engine",NA
Working Storage ,"Let's first decide on the working storage format. It will simply contain the known facts 
  
 about attribute-value pairs. We will use the Prolog database for them and store them as: 
  
 fact( av(A, V), CF).",NA
Find a Value for an Attribute ,"We want to start the inference by asking for the value of a goal. In the case of the Car 
  
 expert system we want to find the value of the attribute 
 problem
 . The main predicate that 
  
 does inferencing will be 
 findgoal/2
 . In the Car expert system, it could be called from an 
  
 interpreter with the following query: 
  
 ?- findgoal( av(problem, X), CF). 
  
 The 
 findgoal/2
  predicate has to deal with three distinct cases: 
  
 • 
  
 the attribute-value is already known; 
  
  
 • 
  
 there are rules to deduce the attribute-value; 
  
 • 
  
 we must ask the user. 
  
 Building Expert Systems in Prolog
  
 27",NA
Attribute Value Already Known ,"The first rule covers the case where the information is in working storage. It was asserted 
 so we know all known values of the attribute have been found. Therefore we cut, so no 
 other clauses are tried. 
  
 findgoal( av(Attr, Val), CF) :- 
  
  fact( av(Attr, Val), CF),  
  
  !.",NA
Ask User for Attribute Value ,"The next rule covers the case where there is no known information, and the attribute is 
 askable. In this case we simply ask. 
  
 findgoal(av(Attr, Val), CF) :- 
  
  not fact(av(Attr, _), _),  
  
  askable(Attr, Prompt),  
  
  query_user(Attr, Prompt),  
  
  !,  
  
  findgoal(av(Attr, Val), CF). 
  
 The 
 query_user
  predicate prompts the user for a value and CF and then asserts it as a 
 fact
 . 
 The recursive call to 
 findgoal
  will now pick up this 
 fact
 . 
  
 query_user(Attr, Prompt) :- 
  
  write(Prompt),  
  
  read(Val),  
  
  read(CF),  
  
  asserta( fact(av(Attr, Val), CF)).",NA
Deduce Attribute Value from Rules ,"The final rule of 
 findgoal
  covers the interesting case of using other rules. Remember that 
 the inferencing is going to require looking for all rules that provide support for values for 
 the sought attribute, and combining the CFs from them. This is done by calling 
 fg
 , which 
 uses a repeat fail loop to continue to find rules whose RHS conclude a value for the 
 attribute. The process stops when the attribute is known with a CF of 100, or all the rules 
 have been tried. 
  
 findgoal(Goal, CurCF) :- 
  
  
  fg(Goal, CurCF). 
  
 28 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
Negation ,"One last point is to deal with negation. The premises might also be of the form 
 not goal
 . In 
 this case we call 
 findgoal
  for the 
 goal
 , and complement the CF to find the degree of 
 certainty of its negation. For example, if a fact has a CF of 70, then 
 not
  fact has a certainty 
 of -70. 
  
 findgoal(not Goal, NCF) :- 
  
  findgoal(Goal, CF),  
  
  NCF is - CF, 
  
  !. 
  
 This rule should become the first clause for 
 findgoal
 .",NA
3.5 Making the Shell ,"Now that the inference engine is built, it can become part of a shell. The code to build this 
 first version of the 
 Clam
  shell is the same as that used to build the 
 Native
  shell. It consists 
 of a command loop with the commands 
 load
 , 
 consult
 , and 
 exit
 . Figure 3.2 shows the 
 architecture of 
 Clam
 . 
  
 super :- 
  
  repeat,  
  
  write('consult, load, exit'), nl,  
  
  write(':'),  
  
  read_line(X),  
  
  doit(X),  
  
  X == exit. 
  
 30 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
Starting the Inference ,"The 
 consult
  command does a little more than just call 
 findgoal
 . It calls 
 top_goals
  which 
 uses the 
 top_goal
  facts to start the inference. The system might have more than one 
 top_goal
  to allow sequencing of the consultation. For example a diagnostic system might 
 have two goals, the first diagnoses the problem, and the second recommends a solution. 
  
 After 
 top_goals
  satisfies a goal, it prints the values for the goal as seen in the early 
 examples of Car. 
  
 top_goals :- 
  
  top_goal(Attr),  
  
  top(Attr),  
  
  print_goal(Attr),  
  
  fail. 
  
 top_goals. 
  
 top(Attr) :- 
  
  findgoal(av(Attr, Val), CF), 
  
  !. 
  
 top(_) :- 
  
  
  true. 
  
 print_goal(Attr) :- 
  
  nl,  
  
  fact(av(Attr, X), CF),  
  
  CF >= 20,  
  
  outp(av(Attr, X), CF), nl,  
  
  fail. 
  
 print_goal(Attr) :- 
  
  
  write('done with '), write(Attr), nl, nl. 
  
 Building Expert Systems in Prolog
  
 31",NA
3.6 English-like Rules ,"The 
 load
  command for 
 Clam
  does not simply read in Prolog terms as in 
 Native
 , but instead 
 uses DCG to read in a knowledge base in the format shown earlier in the chapter for the Car 
 system. You might notice that the askable items have the additional syntax to allow menu 
 choices, which was not included in the implementation details above. It is coded similarly 
 to the menu feature in 
 Native
 . 
  
 The 
 load_kb
  predicate in the shell gets a file name as in 
 Native
 , and then calls 
 load_rules 
 with the file name. 
  
 load_rules(F) :- 
  
  clear_db,  
  
  see(F),  
  
  lod_ruls,  
  
  write('rules loaded'), nl,  
  
  seen, 
  
  !. 
  
 lod_ruls :- 
  
  
  repeat,  
  
   
  read_sentence(L),  
  
   
  process(L),  
  
  
  L == eof. 
  
 process(eof) :- !. 
  
 process(L) :- 
  
  trans(R, L, []),  
  
  assertz(R), 
  
  !. 
  
 process(L) :- 
  
  write('translate error on:'), nl,  
  
  write(L), nl. 
  
 clear_db :- 
  
  abolish(top_goal, 1),  
  
  abolish(askable, 4),  
  
  abolish(rule, 3). 
  
 This section of code basically calls 
 read_sentence
  to tokenize a sentence (up to a ""."") into a 
 list. The token list is then processed by the DCG predicate 
 trans
 , and the resulting Prolog 
 term, 
 R
 , is asserted in the knowledge base. For a good description of DCG, see Clocksin & 
 Mellish chapter 9, 
 Using Grammar Rules
 . The 
 clear_db
  predicate removes all earlier 
 top_goal
 , 
 askable
 , and 
 rule
  predicates so that a new knowledge base can be loaded over an 
 existing one. 
  
 The tokenizing predicate, 
 read_sentence
 , varies from Prolog to Prolog based on the 
 implementation. If the implementation has built-in predicates that can read tokens, then 
 read_sentence
  is trivial. If not, it has to read the input character by character and build the 
  
 32 
  
 Chapter 3 - Backward Chaining with Uncertainty",NA
Exercises ,"3.1 
  
 Add attribute object value triples to the knowledge representation of 
 Clam
 . 
   
 Building Expert Systems in Prolog
  
 33",NA
4 Explanation ,"It is often claimed that an important aspect of expert systems is the ability to explain their 
 behavior. This means the user can ask the system for justification of conclusions or 
 questions at any point in a consultation with an expert system. The system usually responds 
 with the rules that were used for the conclusion, or the rules being considered that led to a 
 question to the user.",NA
Value of Explanations to the User ,"The importance of this feature is probably overestimated for the user. Typically the user 
 just wants the answer. Furthermore, when the user does want an explanation, the 
  
 explanation is not always useful. This is due to the nature of the ""intelligence"" in an expert 
 system. 
  
 The rules typically reflect empirical, or ""compiled"" knowledge. They are codifications of 
 an expert's rules of thumb, not the expert's deeper understanding that led to the rules of 
 thumb. For example, consider the following dialog with an expert system designed to give 
 advice on car problems: 
  
 Does the car start?
  no.
  
 Does the engine turn over?
  yes.
  
 Do you smell gas?
  yes.
  
 Recommendation - Wait 5 minutes and try again. 
 why? 
  
 I used the rule: 
  
 If not start, and 
  
 engine_turn_over, and 
  
 smell_gas 
  
 Then recommend is 'Wait 5 minutes and try again.'. 
  
 The rule gives the correct advice for a flooded car, and knows the questions to ask to 
 determine if the car is flooded, but it does not contain the knowledge of what a flooded car 
 is and why waiting will help. If the user really wanted to understand what was happening, 
 he/she would need a short dissertation on carburetors, how they behave, and their 
  
 relationship to the gas pedal. 
  
 For a system such as this to have useful explanations, it would need to do more than parrot 
 the rules used. One approach is to annotate the rules with deeper explanations. This is 
 illustrated in chapter 10. Another approach being actively researched is to encode the 
 deeper knowledge into the system and use it to drive both the inference and the 
  
 explanations. 
  
 On the other hand, there are some systems in which the expert's knowledge is just 
 empirical knowledge. In this case, the system's explanation is useful to the user. 
  
 Classification systems such as the bird identification system fall in this category. The Bird 
 system would explain an identification of a laysan albatross with the rule used to identify it. 
 There is no underlying theory as to why a white albatross is a laysan albatross and a dark 
 one is a black footed albatross. That is simply the rule used to classify them.",NA
Value of Explanations to the Developer ,"While an explanation feature might be of questionable value to the user of the system, it is 
 invaluable to the developer of the system. It serves the same diagnostic purpose as program 
 tracing for conventional programs. When the system is not behaving correctly, the expert 
 can use the explanations to find the rules that are in error. The knowledge 
  
 Building Expert Systems in Prolog
  
 35",NA
Types of Explanation ,"There are four types of explanations commonly used in expert systems. We will 
 implement most of these in both the 
 Clam
  shell and the 
 Native
  shell: 
  
 • 
 a rule trace, which reports on the progress of a consultation; 
  
 • 
 explanation of 
 how
  the system reached a given conclusion; 
  
 • 
 explanation of 
 why
  the system is asking a question; 
  
 • 
 explanation of 
 why not
  a given conclusion. 
  
 Since we wrote the inference engine for 
 Clam
  it will not be difficult to modify it to include 
 these features. The 
 Native
  system currently uses Prolog's inference engine. In order to add 
 explanation it will be necessary to write our own Prolog inference engine. Fortunately it is 
 not difficult to write Prolog in Prolog.",NA
4.1 Explanation in Clam ,"First, let's look at some examples of the explanation features of 
 Clam
  using the Car system. 
 Here is how the user turns on tracing for the consultation, and the results. The new trace 
 information is in bold. It shows the sequence of rule firings as they are expected. 
  
 Notice in particular that it reports correctly on the nesting of rules 2 and 3 within rule 1. 
  
 consult, restart, load, list, trace, how, exit 
 :trace on 
  
 consult, restart, load, list, trace, how, exit 
 :consult 
  
 call rule 1 
  
 Does the engine turn over? 
  
 : no 
  
 call rule 2 
  
 Are the lights weak? 
  
 : yes 
  
 exit rule 2 
  
 call rule 3 
  
 Is the radio weak? 
  
 : yes 
  
 exit rule 3 
  
 exit rule 1 
  
 call rule 4 
  
 fail rule 4 
  
 call rule 5 
  
 fail rule 5 
  
 call rule 6 
  
 fail rule 6 
  
 problem-battery-cf-75 
  
 done with problem 
  
 Next we can look at the use of 
 why
  explanations. The user would ask why and get the 
 inference chain that led to the question. For example: 
  
 ... 
  
 Is the radio weak? 
  
 : why 
  
 rule 3 
  
 If 
  
 36 
  
 Chapter 4 - Explanation",NA
Tracing ,"The first explanation addition to 
 Clam
  will be the rule tracing facility. It will behave 
 similarly to the Prolog box model traces, and inform the user when a rule is ""call""ed, 
 ""exit""ed, or ""fail""ed. It will use a special predicate 
 bugdisp
  to communicate trace 
 information with the user. It will take as an argument a list of terms to be written on a line.
  
 To make it a user option, bugdisp will only write if ruletrace is true. The user will have a 
 new high level command to turn tracing on or off which will assert or retract ruletrace. We 
 can then use bugdisp to add any diagnostics printout we like to the program. 
  
 bugdisp(L) :- 
  
  ruletrace,  
  
  write_line(L), 
  
  !. 
  
 bugdisp(_). 
  
 write_line([]) :- 
  
  
  nl. 
  
 write_line([H|T]) :- 
  
  write(H),  
  
  tab(1),  
  
  write_line(T). 
  
 Here is the new command added to the 
 do
  predicate called by the command loop 
  
 predicate, 
 go
 . It allows the user to turn tracing on or off by issuing the command 
 trace(on) 
 or 
 trace(off)
 . 
  
 do( trace(X) ) :- 
  
  set_trace(X), 
  
  !. 
  
 set_trace(off) :- 
  
  ruletrace,  
  
  retract( ruletrace ). 
  
 set_trace(on) :- 
  
  
  not ruletrace,  
  
  
  asserta( ruletrace ). 
  
 set_trace(_). 
  
 38 
  
 Chapter 4 - Explanation",NA
How Explanations ,"The next explanation feature to implement is 
 how
 . The how question is asked by the user to 
 see the proof of some conclusion the system has reached. The proof can be generated by 
 either rederiving the result with extra tracing, or by having the original derivation stored in 
 working storage. 
 Clam
  uses the second option and stores derivation information with the 
 fact
  in working storage. Each fact might have been derived from multiple rules, all 
 concluding the same attribute value pair and combining certainty factors. For this reason, a 
 list of rule numbers is stored as the third argument to 
 fact
 . This is not the entire proof tree, 
 but just those rules which conclude the fact directly. 
  
 fact(AV, CF, RuleList) 
  
 A 
 fact
  is updated by 
 update
 , so this is where the derivation is captured. A new argument 
 is added to 
 update
  which is the rule number that caused the update. Note that the first 
 clause of 
 update
  adds the new rule number to the list of existing derivation rule numbers 
 for the 
 fact
 . The second clause merely creates a new list with a single element. 
  
 update(Goal, NewCF, CF
 , RuleN
 ) :- 
  
  fact(Goal, OldCF
 , _
 ),  
  
  combine(NewCF, OldCF, CF),  
  
  retract( fact(Goal, OldCF
 , OldRules
 ) ),  
  
  asserta( fact(Goal, CF
 , [RuleN | OldRules]
 ) ),  
 !. 
  
 update(Goal, CF, CF
 , RuleN
 ) :- 
  
  
  asserta( fact(Goal, CF
 , [RuleN]
 ) ). 
  
 The call to update from fg is modified to fill in the new argument with a rule number: 
  
 fg(Goal, CurCF) :- 
  
  rule(N, lhs(IfList), rhs(Goal, CF)),  
  
  ... 
  
 Building Expert Systems in Prolog
  
 39",NA
Why Questions ,"The 
 how
  question is asked from the top level of an inference, after the inference has been 
 completed. The 
 why
  question is asked at the bottom of a chain of rules — when there are 
 no more rules and it is time to ask the user. The user wants to know 
 why
  the question is 
 being asked. 
  
 Building Expert Systems in Prolog
  
 41",NA
4.2 Native Prolog Systems ,"Since we wrote the inference engine for 
 Clam
 , it was easy to modify it to add the code for 
 explanations. However, when we use pure Prolog, we don't have access to the inference 
 engine. 
  
 This problem is easily solved. We simply write a Prolog inference engine in Prolog. Then, 
 having written the inference engine, we can modify it to handle explanations. 
  
 An inference engine has to have access to the rules. In Prolog, the clauses are themselves 
 just Prolog terms. The built-in predicate 
 clause
  gives us access to the rules. It has two 
 arguments, which unify with the head of a clause and its body. A fact has a body with just 
 the goal true. 
  
 Predicates that manipulate Prolog clauses are confusing to read due to the ambiguous use 
 of the comma in Prolog. It can be either: 
  
 • 
 an operator used to separate the subgoals in a clause; or 
  
 • 
 a syntactic separator of functor arguments. 
  
 Prolog clauses are just Prolog terms with functors of "":-"" and "","". Just for now, pretend 
 Prolog used an ""&"" operator to separate goals rather than a "","" operator. Then a clause 
 would look like: 
  
 a :- b & c & d. 
  
 Without the operator definitions it would look like: 
  
 :-(a, &(b, &(c, d))). 
  
 The 
 clause
  built-in predicate picks up the first and second arguments of the "":-"" functor. It 
 will find the entire Prolog database on backtracking. If patterns are specified in either 
 argument, then only clauses that unify with the patterns are found. For the above clause: 
  
 ?- clause(Head, Body). 
  
 Head = a 
  
 Body = b & c & d 
  
 A recursive predicate working through the goals in 
 Body
  would look like: 
  
 Building Expert Systems in Prolog
  
 43",NA
Exercises ,"4.1 Implement 
 whynot
  for 
 Clam
 . 
  
 4.2 Have 
 whynot
  give a full failure history. 
  
 4.3 Make sure the explanation facility can handle attribute object value triples in both 
 Clam
  and 
 Native
 . 
  
 4.4 Decide whether you like the full rules presented in answer to 
 why
  questions as in 
 Clam
 , or just the goals as in 
 Native
 . Make both systems behave the same way. 
  
 4.5 Enhance the trace function so it displays the goals currently being sought by the 
 system. Have various levels of trace information that can be controlled by the trace 
 command. 
  
 4.6 Using 
 prove
 , implement a Prolog trace function. 
  
 4.7 Add a pretty printing predicate for 
 Native
  to use when displaying Prolog rules. 
  
 46 
  
 Chapter 4 - Explanation",NA
5 Forward Chaining ,"This chapter discusses a forward chaining rule based system and its expert system 
 applications. It shows how the forward chaining system works, how to use it, and how to 
 implement it quickly and easily using Prolog. 
  
 A large number of expert systems require the use of forward chaining, or data driven 
 inference. The most famous of these is Digital Equipment Corporation's XCON system. It 
 configures computers. It starts with the data about the customer order and works forward 
 toward a configuration based on that data. The XCON system was written in the OPS5 
 (forward chaining rule based) language. 
  
 Data driven expert systems are different from the goal driven, or backward chaining 
 systems seen in the previous chapters. 
  
 The goal driven approach is practical when there are a reasonable number of possible final 
 answers, as in the case of a diagnostic or identification system. The system methodically 
 tries to prove or disprove each possible answer, gathering the needed information as it 
 goes. 
  
 The data driven approach is practical when combinatorial explosion creates a seemingly 
 infinite number of possible right answers, such as possible configurations of a machine.",NA
5.1 Production Systems ,"Forward chaining systems are often called “production” systems. Each of the rules is 
 actually a miniature procedure called a production. When the patterns in the left hand side 
 match working storage elements, then the actions on the right hand side are taken. This 
 chapter concentrates on building a production system called 
 Oops
 . 
  
 Production systems are composed of three components. These are: 
  
 • 
 the rule set; 
  
 • 
 a working storage area which contains the current state of the system; 
  
 • 
 an inference engine which knows how to apply the rules. 
  
 The rules are of the form: 
  
 left hand side (LHS) ==> right hand side (RHS). 
  
 The LHS is a collection of conditions which must be matched in working storage for the 
 rule to be executed. The RHS contains the actions to be taken if the LHS conditions are 
 met. 
  
 The execution cycle is: 
  
 1. Select a rule whose left hand side conditions match the current state as stored in the 
  
 working storage. 
  
 2. Execute the right hand side of that rule, thus somehow changing the current state. 
  
 3. Repeat until there are no rules which apply. 
  
 Building Expert Systems in Prolog
  
 47",NA
5.2 Using Oops ,"In the Winston & Horn LISP book there is an example of a forward chaining animal 
 identification system. Some of those rules would be expressed in 
 Oops
  like this: 
  
 rule id6: 
  
 [1: has(X, pointed_teeth), 
  
  2: has(X, claws), 
  
  3: has(X, forward_eyes)] 
  
 ==> 
  
 48 
  
 Chapter 5 - Forward Chaining",NA
5.3 Implementation ,"The implementation of 
 Oops
  is both compact and readable due to the following features of 
 Prolog: 
  
 • 
 Each rule is represented as a single Prolog term (a relatively complex structure). 
  
 • 
 The functors of the rule structure are defined as operators to allow the easy-to-read 
 syntax of the rule. 
  
 • 
 Prolog's built-in backtracking search makes rule selection easy. 
  
 • 
 Prolog's built-in pattern matching (unification) makes comparison with working 
 storage easy. 
  
 • 
 Since each rule is a single term, unification causes variables to be automatically bound 
 between LHS conditions and RHS actions. 
  
 • 
 The Prolog database provides an easy representation of working storage. 
  
 Each rule is a single Prolog term, composed primarily of two lists: the right hand side 
 (RHS), and the left hand side (LHS). These are stored using Prolog's normal data 
 structures, with 
 rule
  being the predicate and the various arguments being lists. 
  
 In 
 Clam
 , DCG was used to allow a friendly, flexible rule format. In 
 Oops
 , Prolog operators 
 are used. The operators allow for a syntax that is formal, but readable. The operator syntax 
 can also be used directly in the code. 
  
 Without operator definitions, the rules would look like normal hierarchical Prolog data 
 structures: 
  
 rule(==>(:(id4, [:(1, flies(X)), :(2, lays_eggs(X))], 
 [retract(all), assert(isa(X, bird))])). 
  
 The following operator definitions allow for the more readable format of the rules: 
  
 op(230, xfx, ==>). 
  
 op(32, xfy, :). 
  
 52 
  
 Chapter 5 - Forward Chaining",NA
5.4 Explanations for Oops ,"Explanations for forward chaining systems are more difficult to implement. This is because 
 each rule modifies working storage, thus covering its tracks. The most useful information 
 in debugging a forward chaining system is a trace facility. That is, you want to know each 
 rule that is fired and the effects it has on working storage. 
  
 Each fact can have associated with it the rule which posted it, and this would give the 
 immediate explanation of a fact. However, the facts that supported the rules which led up to 
 that fact might have been erased from working memory. To give a full explanation, the 
 system would have to keep time stamped copies of old versions of facts. 
  
 The trace option is added in 
 Oops
  in a similar fashion to which it was added in 
 Clam
 . The 
 inference engine informs the user of the rules that are firing as they fire.",NA
5.5 Enhancements ,"Oops
  in its current state is a simple forward chaining system. More advanced forward 
 chaining systems differ in two main aspects. 
  
 • 
 more sophisticated rule selection when many rules match the current working storage; 
  
 • 
 performance. 
  
 The current rule selection strategy of 
 Oops
  is simply to pick the first rule that matches. If 
 many rules match, there might be other optimal choosing strategies. For example, we 
 could pick the rule that matched the most recently asserted facts, or the rule that had the 
 most specific match. Either of these would change the inference pattern of the system to 
 give effects that might be more natural. 
  
 Oops
  is also inefficient in its pattern matching, since at each cycle of the system it tries all 
 of the rules against working memory. There are various indexing schemes that can be used 
 to allow for much faster picking of rules which match working memory. These will be 
 discussed in chapter 8. 
  
 56 
  
 Chapter 5 - Forward Chaining",NA
5.6 Rule Selection ,"OPS5, which is probably the most well known example of a forward chaining, or 
 production, system offers two different means of selecting rules. One is called LEX and 
 the other is MEA. Both make use of time stamped data to determine the best rule to fire 
 next. They differ slightly in the way in which they use the data. Both of these strategies 
 can be added to 
 Oops
  as options.",NA
Generating the conflict set ,"For both, the first step is to collect all of the rules whose LHS match working memory at a 
 given cycle. This set of rules is called the conflict set. It is not actually the rules, but rather 
 instantiations of the rules. This means that the same rule might have multiple instantiations 
 if there are multiple facts which match a LHS premise. This will often happen when there 
 are variables in the rules that are bound differently for different instantiations. 
  
 For example, an expert system to identify animals might have the following condition on 
 the LHS: 
  
 rule 12: 
  
 [... 
  
  eats(X, meat), 
  
  ...] 
  
 ==> ... 
  
 In working memory there might be the following two facts: 
  
 ... 
  
 eats(robie, meat). 
  
 eats(suzie, meat). 
  
 ... 
  
 Assuming the other conditions on the LHS matched, this would lead to two different 
 instantiations of the same rule. One for 
 robie
  and one for 
 suzie
 . 
  
 The simplest way to get the conflict set is to use 
 findall
  or its equivalent. (If your system 
 does not have a findall, a description of how to write your own can be found in Clocksin 
 and Mellish section 7.8, 
 Assert and Retract: Random, Gensym, Findall
 .) It collects all of 
 the instantiations of a term in a list. The three arguments to 
 findall
  are: 
  
 • 
 a term that is used as a pattern to collect instantiations of variables; 
  
 • 
 a list of goals used as a query; 
  
 • 
 an output list whose elements match the pattern of the first argument, and for which 
 there is one element for each successful execution of the query in the second argument. 
  
 The instantiations of the conflict set will be stored in a structure, 
 r/4
 . The last three 
 arguments of 
 r/4
  will be the 
 ID
 , 
 LHS
 , and 
 RHS
  of the rule, which will be used later. 
  
 The first argument of 
 r/4 
 is the 
 LHS
  with the variables instantiated with the working 
 storage elements that were matched. Each match of a LHS premise and working storage 
 element is also accompanied by a time stamp indicating when the working storage element 
 was last updated. 
  
 The query to be executed repeatedly by 
 findall
  will be similar to the one currently used to 
 find just the first matching rule: 
  
 Building Expert Systems in Prolog
  
 57",NA
Time stamps ,"The timestamp is just a chronological counter that numbers the 
 fact
 s in working memory 
 as they are added. All assertions of facts are now handled by the 
 assert_ws
  predicate as 
 follows: 
  
 assert_ws(fact(X, T)) :- 
  
  getchron(T),  
  
  asserta(fact(X, T)). 
  
 The 
 getchron
  predicate simply keeps adding to a counter: 
  
 getchron(N) :- 
  
  retract( chron(N) ),  
  
  NN is N + 1,  
  
  asserta( chron(NN) ), 
  
  !.",NA
5.7 LEX ,"Now that we have a list of possible rules and instantiations in the conflict set, it is 
 necessary to select one. First we will look at the OPS5 LEX method of rule selection. It 
 uses three criteria to select a rule. 
  
 The first is refraction. This discards any instantiations that have already been fired. Two 
 instantiations are the same if the variable bindings and the time stamps are the same. This 
 prevents the same rule from firing over and over — unless the programmer has caused 
 working memory to be repeatedly updated with the same fact. 
  
 58 
  
 Chapter 5 - Forward Chaining",NA
Changes in the Rules ,"The LEX strategy changes the way in which 
 Oops
  rules are programmed. In the first 
 version of 
 Oops
 , the knowledge engineer had to make sure that the working storage 
 elements that caused the rule to fire are changed. It was the knowledge engineer's 
 responsibility to ensure that a rule did not repeatedly fire. 
  
 The opposite is also true. Where looping is required, the facts matching the LHS must be 
 continually reasserted. 
  
 In the original version of 
 Oops
  the knowledge engineer knew the order in which rules 
 would fire, and could use that information to control the inference. Using LEX he/she can 
 still control the inference, but it requires more work. For example, if it is desirable to have 
 the couch placed first by the system, then that rule must be structured to fire first. This can 
 be done by adding a goal to place the couch first and asserting it after the data is gathered. 
  
 For example: 
  
 rule gather_data 
  
 ... 
  
 ==> 
  
 [... 
  
  assert( goal(couch_first) ) ]. 
  
 rule couch 
  
 [ goal(couch_first), 
  
 ... 
  
 The 
 gather_data
  rule will assert the 
 couch_first
  goal after all other assertions. This means 
 it is the most recent addition to working storage. The Lex recency criteria will then ensure 
 that the couch rule is fired next. 
  
 The rule which is supposed to fire last in the system also needs to be handled specially. 
 The easiest way to ensure a rule will fire last is to give it an empty list for the LHS. The 
 specificity check will keep it from firing until all others have fired.",NA
Implementing LEX ,"To implement the LEX strategy, we modify the 
 go
  predicate to first get the conflict set and 
 then pass it to the predicate 
 select_rule
 , which picks the rule to execute. After processing 
 the rule, the instantiation associated with the rule is saved to be used as a check that it is not 
 re-executed. 
  
 go :- 
  
  conflict_set(CS),  
  
  select_rule(CS, r(Inst, ID, LHS, RHS)),  
  
  process(RHS, LHS),  
  
  asserta( instantiation(Inst) ),  
  
 Building Expert Systems in Prolog
  
 59",NA
5.8 MEA ,"The other strategy offered with OPS5 is MEA. This is identical to LEX with one 
  
 additional filter added. After refraction, it finds the time stamp associated with the first 
 condition of the rule and picks the rule with the highest time stamp on the first condition. If 
 there is more than one, then the normal LEX algorithm is used to pick which of them to 
 use. 
  
 At first this might seem like an arbitrary decision; however, it was designed to make goal 
 directed programming easier in OPS5. The flow of control of a forward chaining system is 
 often controlled by setting goal facts in working storage. Rules might have goals in the 
 conditions thus ensuring the rule will only fire when that goal is being pursued. 
  
 Building Expert Systems in Prolog
  
 61",NA
Exercises ,"5.1 Add full rule tracing to OOPS. 
  
 5.2 Add a command loop that turns on and off tracing, MEA/LEX strategies, loads rule 
  
 files, consults the rules, lists working storage, etc. 
  
 5.3 Add a feature that allows for the saving of test case data, which can then be run 
  
  
 against the system. The test data and the results are used to debug the system as it 
  
 undergoes change. 
  
 5.4 Allow each rule to optionally have a priority associated with it. Use the user-defined 
  
 rule priorities as the first criteria for selecting rule instantiations from the conflict 
  
 set. 
  
 62 
  
 Chapter 5 - Forward Chaining",NA
6 Frames ,"Up until this point in the book, we have worked with data structures that are simply that — 
 data structures. It is often desirable to add some ""intelligence"" to the data structures, such 
 as default values, calculated values, and relationships between data. 
  
 Of the various schemes which evolved over the years, the 
 frame
  based approach has been 
 one of the more popular. Information about an object in the system is stored in a 
 frame
 . 
  
 The frame has multiple 
 slots
  used to define the various attributes of the object. The slots 
 can have multiple 
 facets
  for holding the value for the attributes, defaults or procedures that 
 are called to calculate the value. 
  
 The various frames are linked together in a hierarchy with a-kind-of (ako) links that allow 
 for inheritance. For example, rabbits and hamsters might be stored in frames that have 
 ako(mammal). In the frame for mammal are all of the standard attribute-values for 
 mammals, such as skin-fur and birth-live. These are inherited by rabbits and hamsters and 
 do not have to be specified in their frames. There can also be defaults for attributes which 
 might be overwritten by specific species. Legs-4 applies to most mammals, but monkeys 
 would have legs-2 specified. 
  
 Another feature of a frame based system is 
 demons
 . These are procedures that are 
  
 activated by various updating procedures. For example, a financial application might have 
 demons on various account balances that are triggered when the value is too low. These 
 could also have editing capabilities that made sure the data being entered is consistent with 
 existing data. Figure 6.1 shows some samples of frames for animals. 
  
 facets 
  
 mammal 
  
  
 value 
  
 default
  
 when 
  
 updated 
  
 skin 
  
 fur 
  
  
  
 birth 
  
 live 
   
  
 legs 
   
 4 
  
 leg-check 
  
 slots 
  
 leg-check: value =< 4 
  
  
 facets 
  
 rabbit 
  
  
 value 
  
 default 
  
 when 
  
 updated 
  
 ako 
  
 mammal 
   
  
 ears 
   
 long 
   
 move 
  
 hops 
  
  
  
 slots slots 
  
 facets 
  
 monkey 
  
  
 value 
  
 default 
  
 when 
  
 updated 
  
 ako 
  
 mammal 
   
  
 legs 
  
 2 
  
  
  
 tail 
   
 curly 
   
  
 Figure 6.1  Examples of animal frames 
  
 Building Expert Systems in Prolog
  
 65",NA
6.1 The Code ,"In order to implement a frame system in Prolog, there are two initial decisions to be made. 
 The first is the design of the user interface, and the second is the design of the internal data 
 structure used to hold the frame information. 
  
 The access to data in the frame system will be through three predicates: 
  
 • 
 get_frame
  — retrieves attribute values for a frame; 
  
 • 
 add_frame
  — adds or updates attribute values for a frame; 
  
 • 
 del_frame
  — deletes attribute values from a frame. 
  
 From the user's perspective, these operations will appear to be acting on structures that are 
 very similar to database records. Each frame is like a record, and the slots in the frame 
 correspond to the fields in the record. The intelligence in the frame system, such as 
 inheritance, defaults, and demons, happens automatically for the user. 
  
 The first argument of each of these predicates is the name of the frame. The second 
 argument has a list of the slots requested. Each slot is represented by a term of the form 
 attribute-value
 . For example, to retrieve values for the 
 height
  and 
 weight
  slots in the 
 frame 
 dennis,
  the following query would be used: 
  
 ?- get_frame(dennis, [weight-W, height-H]). 
  
 W = 155 
  
 H = 5-10 
  
 To add a new sport for 
 mary
 : 
  
 ?- add_frame(mary, [sport-rugby]). 
  
 To delete a slot's value for 
 mynorca
 's computer: 
  
 ?- del_frame(mynorca, [computer-'PC AT']). 
  
 These three primitive frame access predicates can be used to build more complex frame 
 applications. For example, the following query would find all of the women in the frame 
 database who are rugby players: 
  
 ?- get_frame(X, [ako-woman, sport-rugby]). 
  
 X = mary ; 
  
 X = kelly; 
  
 A match-making system might have a predicate that looks for men and women who have a 
 hobby in common: 
  
 in_common(M, W, H) :- 
  
  get_frame(M, [ako-man, hobby-H]),  
  
  get_frame(W, [ako-woman, hobby-H]).",NA
6.2 Data Structure ,"The next decision is to chose a type of data structure for the frames. The frame is a 
 relatively complex structure. It has a name and multiple slots. Each slot, which 
  
 corresponds to an attribute of the frame, can have a value. This is the same as in a normal 
 database. However in a frame system, the value is just one possible facet for the slot. 
  
 66 
  
 Chapter 6 - Frames",NA
6.3 The Manipulation Predicates ,"get_frame
  
  
 frame
  
 find_slot
  
 slot_vals
  
 prep_req
  
 slot_vals
  
  
 % get value from a facet
  
 facet_val
  
 % inherit a value
  
 facet_val
  
 % ako-X
  
 find_slot
  
  
 % value
  
 % default value
  
 % calculate value
  
 Figure 6.2  Major predicates of get_frame 
  
 The first predicate to look at is 
 get_frame
 . It takes as input a query pattern, which is a list 
 of slots and requested values. This request list (
 ReqList
 ) is then compared against the 
 SlotList
  associated with the frame. As each request is compared against the slot list, 
 Prolog's unification instantiates the variables in the list. Figure 6.2 shows the major 
 predicates used with 
 get_frame
 . 
  
 get_frame(Thing, ReqList) :- 
  
  frame(Thing, SlotList),  
  
  slot_vals(Thing, ReqList, SlotList). 
  
 The 
 slot_vals
  predicate takes care of matching the request list against the slot list. It is a 
 standard recursive list predicate, dealing with one item from the request list at a time. That 
 item is first converted from the more free-form style allowed in the input list to a more 
 formal structure describing the request. That structure is 
 req/4
  where the arguments are: 
  
 • 
 name of the frame; 
  
 • 
 the requested slot; 
  
 • 
 the requested facet; 
  
 • 
 the requested value. 
  
 The code for 
 slot_vals
  recognizes request lists, and also single slot requests not in list 
 form. This means both of the following frame queries are legal: 
  
 ?- get_frame( dennis, hair-X ). 
  
 ... 
  
 ?- get_frame( dennis, [hair-X, height-Y] ). 
  
 ... 
  
 68 
  
 Chapter 6 - Frames",NA
6.4 Using Frames ,"The use of inheritance makes the frame based system an intelligent way of storing data. For 
 many expert systems, a large portion of the intelligence can be stored in frames instead of 
 in rules. Let's consider, for example, the bird identification expert system. 
  
 In the bird system there is a hierarchy of information about birds. The rules about the order 
 tubenose, family albatross, and particular albatrosses can all be expressed in frames as 
 follows: 
  
 frame(tubenose, 
  
  
  [ 
  
  
  
  level-[val order],  
  
  
  
  nostrils-[val external_tubular],  
  
  
  
  live-[val at_sea],  
  
  
  
  bill-[val hooked] 
  
  
  ]). 
  
 frame(albatross, 
  
  
  [ 
  
  
  
  ako-[val tubenose],  
  
  
  
  level-[val family],  
  
  
  
  size-[val large],  
  
  
  
  wings-[val long-narrow] 
  
  
  ]). 
  
 frame(laysan_albatross, 
  
  
  [ 
  
  
  
  ako-[val albatross],  
  
  
  
  level-[val species],  
  
  
  
  color-[val white] 
  
  
  ]). 
  
 frame(black_footed_albatross, 
  
  
  [ 
  
  
  
  ako-[val albatross],  
  
  
  
  level-[val species],  
  
  
  
  color-[val dark] 
  
  
  ]). 
  
 In a forward chaining system, we would feed some facts to the system and the system 
 would identify the bird based on those facts. We can get the same behavior with the frame 
 system and the predicate 
 get_frame
 . 
  
 For example, if we know a bird has a dark color, and long narrow wings, we can ask the 
 query: 
  
 ?- get_frame(X, [color-dark, wings-long_narrow]). 
 X = black_footed_albatross ; 
  
 no 
  
 Notice that this will find all of the birds that have the requested property. The 
 ako
  slots 
 and inheritance will automatically apply the various slots from wherever in the hierarchy 
 they appear. In the above example, the color attribute was filled from the black footed 
 albatross frame and the wings attribute was filled from the albatross frame. This feature 
 can be used to find all birds with long narrow wings: 
  
 74 
  
 Chapter 6 - Frames",NA
6.5 Summary ,"For the expert systems we have seen already, we have used the Prolog database to store 
 information. That database has been relatively simple. By writing special access predicates 
 it is possible to create a much more sophisticated database using frame technology. These 
 frames can then be used to store knowledge about the particular environment.",NA
Exercises ,"6.1 Add other facets to the slots to allow for specification of things like explanation of the 
 slot, certainty factors, and constraints. 
  
 6.2 Add an automatic query-the-user facility that is called whenever a slot value is sought 
 and there is no other frame to provide the answer. This will allow the frame system to 
 be used as a backward chaining expert system. 
  
 Building Expert Systems in Prolog
  
 75",NA
7 Integration ,"Many real problems cannot be solved by the simple application of a single expert system 
 technique. Problems often require multiple knowledge representation techniques as well as 
 conventional programming techniques. 
  
 Often it is necessary to either have the expert system embedded in a conventional 
 application, or to have other applications callable from the expert system. For example, a 
 financial expert system might need a tight integration with a spread sheet, or an 
  
 engineering expert system might need access to programs that perform engineering 
 calculations. 
  
 The degree to which the systems in this book can be integrated with other environments 
 depends on the flexibility of the Prolog used and the application that needs to be accessed. 
 The systems can be designed with the hooks in place for this integration. In the examples 
 presented in this chapter, the knowledge base tools will have hooks to Prolog. 
  
 Often the Prolog code can be used to implement features of the system that do not fit neatly 
 in the knowledge tools. This is often the case in the area of user interface, but applies to 
 other portions as well. In the example in this chapter, we will see Prolog used to smooth 
 over a number of the rough edges of the application. 
  
 The degree of integration needed between knowledge tools also depends somewhat on the 
 application. In this chapter, the forward chaining system and frame based knowledge 
 representation will be tightly integrated. By having control over the tools, the degree of 
 integration can be implemented to suit the individual application. 
  
 The example used in this chapter is the same room furniture placement used in the chapter 
 on forward chaining. While the application was developed with the pure 
 Oops
  system, a 
 much more elegant solution can be implemented by integrating frames, Oops, and Prolog. 
 In particular, there is a lot of knowledge about the types of furniture that could be better 
 stored in a frame system. Also the awkward input and output sections of the system could 
 be better written in Prolog.",NA
7.1 Foops (Frames and Oops) ,"The first step is to integrate the frame based knowledge representation with the Oops 
 forward chaining inference engine. The integration occurs in two places: 
  
 • 
 The concept of a frame instance needs to be implemented. 
  
 • 
 The rules must be able to reference the frame instances. 
  
 The instances are needed for an integrated system to distinguish between the frame data 
 definition in the knowledge base, and the instances of frames in working storage. The rules 
 will be matching and manipulating instances of frames, rather than the frame definitions 
 themselves. For example, there will be a frame describing the attributes of chairs, but there 
 might be multiple instances of chairs in working storage.",NA
Instances ,"In the frame system as it is currently written, the frames are the data. Particular instances 
 of a frame, such as person, are just additional frames. For use in the expert system it is 
 cleaner to distinguish between frame definitions and instances of frames. 
  
 Building Expert Systems in Prolog
  
 77",NA
Rules for frinsts ,"Now that there is a mechanism for handling instances of frames, the next step is to revise 
 the 
 Oops
  rule structure to use those instances. In 
 Oops
 , each of the 
 LHS
  conditions was a 
 Prolog term held in a 
 fact
  relation. For 
 Foops
 , the 
 LHS
  conditions will be 
 frinst
 s. 
  
 In keeping with the 
 Oops
  design of using operators to make the rules more readable, the 
 frinst
 s will be presented differently in the rules. The form will be: 
  
 Class - Name with [Attr - Val, ...] 
  
 For example, the rule in the furniture configuration that puts table lamps on end tables is: 
  
 rule f11: 
  
 [table_lamp - TL with [position-none], 
  
  end_table - ET with [position-wall/W]] 
  
 ==> 
  
 [update( table_lamp - TL with [position-end_table/ET] )]. 
  
 Note that the RHS actions also use the same syntax for the instance. 
  
 The change is easy to implement due to the interchangeability of facts and rules in Prolog. 
 Oops
  refers to 
 fact
 s, expecting to find data. 
 Foops
  uses the same code, but implements the 
 relation 
 fact
  as a rule, which calls 
 getf
 . 
  
 Following is the code that matches the premises from the 
 LHS
 . It is the the same as in the 
 previous version except that the definition of 
 fact
  has been changed to reflect the new 
 nature of each individual premise. 
  
 match([], []). 
  
 Building Expert Systems in Prolog
  
 79",NA
Adding Prolog to Foops ,"Now that frames and 
 Oops
  have been integrated into a new system, 
 Foops
 , the next step is 
 to integrate Prolog as well. This has already been done for the frame based system with the 
 various demons that can be associated with frame slots. The Prolog predicates referred to in 
 the demon slots can simply be added directly to the knowledge base. 
  
 Adding Prolog to the rules is done by simply adding support for a call statement in both 
 the 
 test
  (for the LHS) and 
 take
  (for the RHS) predicates. 
  
 ... 
  
 test(call(X)) :- call(X). 
  
 ... 
  
 ... 
  
 take(call(X)) :- call(X). 
  
 ... 
  
 80 
  
 Chapter 7 - Integration",NA
7.2 Room Configuration ,"Now that 
 Foops
  is built, let's use it to attack the room configuration problem again. Many 
 of the aspects of the original system were handled clumsily in the original version. In 
 particular: 
  
 • 
 The initial data gathering was awkward using rules that triggered other data gathering 
 rules. 
  
 • 
 The wall space calculations were done in the rules. 
  
 • 
 Each rule was responsible for maintaining the consistency of the wall space and the 
 furniture against the wall. 
  
 The new system will allow for a much cleaner expression of most of the system, and use 
 Prolog to keep the rough edges out of the rule and frame knowledge structures. 
  
 Much of the knowledge about the furniture in the room is better stored in frames. This 
 knowledge is then automatically applied by the rules accessing instances of furniture. The 
 rules then become simpler, and just deal with the IF THEN situations and not data 
 relationships. 
  
 Building Expert Systems in Prolog
  
 81",NA
Furniture frames ,"The knowledge base contains the basic frame definitions, which will be used by the 
 instances of furniture. The frames act as sophisticated data definition statements for the 
 system. 
  
 The highest frame defines the class furniture. It establishes defaults and demons that apply 
 to all furniture. 
  
 frame(furniture, 
  
  
  [legal_types - [val [couch, 
  
  
   
  chair, 
  
  
   
  coffee_table, 
  
  
   
  end_table, 
  
  
   
  standing_lamp, 
  
  
   
  table_lamp, 
  
  
   
  tv, 
  
  
   
  knickknack]],  
  
  
  
  position - [def none, add pos_add],  
  
  
  
  length - [def 3],  
  
  
  
  place_on - [def floor]]). 
  
 The most interesting slot is 
 position
 . Each piece of furniture has the default of having the 
 positionnone
 , meaning it has not been placed in the room. This means the programmer 
 need not add this value for each piece of furniture initially. As it is positioned, the instance 
 acquires a value that is used instead of the inherited default. 
  
 Also note that there is a demon, which is called when a 
 position
  is added for a piece of 
 furniture. This demon will automatically maintain the relation between wall space and 
 furniture position. It will be described in detail a little later. 
  
 Next in the knowledge base are some classes of furniture. Note that the default length for a 
 couch will override the general default length of 3 for any piece of furniture without a 
 length specified. 
  
 frame(couch, [ako - [val furniture], 
  
  
  length - [def 6]]). 
  
 frame(chair, [ako - [val furniture]]). 
  
 A table is another class of furniture, which is a bit different from other furniture in that 
 things can be placed on a table. It has additional slots for available space, the list of items 
 it is holding (things placed on the table), and the slot indicating that it can support other 
 items. 
  
 frame(table, [ako - [val furniture], 
  
  space - [def 4],  
  
  length - [def 4],  
  
  can_support - [def yes],  
  
  holding - [def []]]). 
  
 There are two types of tables which are recognized in the system: 
  
 frame(end_table, [ako - [val table], 
  
  
  length - [def 2]]). 
  
 frame(coffee_table, [ako - [val table], 
  
  
  length - [def 4]]). 
  
 Remember that frames can have multiple inheritance paths. This feature can be used to 
 establish other classes, which define attributes shared by certain types of furniture. For 
  
 82 
  
 Chapter 7 - Integration",NA
Frame Demons ,"Next in the knowledge base are the Prolog predicates used in the various frame demons. 
  
 Here is the predicate that is called to calculate a value for the 
 place_on
  slot for a 
 television. It asks the user, and uses the answer to update the television 
 frinst
  so that the 
 user will not be asked again. 
  
 tv_support(tv, N, place_on-table) :- 
  
  
  nl,  
  
 Building Expert Systems in Prolog
  
 83",NA
Initial Data ,"Now let's look at the data initialization for the system. It establishes other slots for the wall 
 frames giving spatial relationships between them, and establishes the 
 goalgather_data
 . 
  
 initial_data([goal - gather_data, 
  
  
  wall - north with [opposite-south, 
  
  
  right-west, 
  
 84 
  
 Chapter 7 - Integration",NA
Input Data ,"The first rule uses the call feature to call a Prolog predicate to perform the data gathering 
 operations, which used to be done with rules in 
 Oops
 . 
 Foops
  uses the 
 Lex
  rule selection, 
 but this rule will fire first because no other rules have any furniture to work with. It then 
 asserts the 
 goalcouch_first
  after gathering the other data. Because 
 Lex
  gives priority to 
 rules accessing recently updated elements in working storage, the rules that have as a 
 goal 
 couch_first
  will fire next. 
  
 rule 1: 
  
 [goal - gather_data] 
  
 ==> 
  
 [call(gather_data), 
  
  assert( goal - couch_first )]. 
  
 The Prolog predicate proceeds with prompts to the user and calls to frame predicates to 
 populate working storage. 
  
 gather_data :- 
  
  read_furniture,  
  
  read_walls. 
  
 read_furniture :- 
  
  
  get_frame(furniture, [legal_types-LT]),  
  
  
  write('Enter name of furniture at the prompt. '), nl, 
  
  
  write(' It must be one of:'), nl,  
  
  
  write(LT), nl,  
  
  
  write('Enter end to stop input.'), nl,  
  
  
  write('At the length prompt enter y or a new number.'), nl,  
  
  repeat,  
  
   
  write('>'), 
  
   
  read(X),  
  
   
  process_furn(X), 
  
  
  !. 
  
 Note that this predicate has the additional intelligence of finding the default value for the 
 length of a piece of furniture and allowing the user to accept the default, or choose a new 
 value. 
  
 process_furn(end). 
  
 process_furn(X) :- 
  
  get_frame(X, [length-DL]),  
  
  write(length-DL), write('>'),  
  
  read(NL),  
  
  get_length(NL, DL, L),  
  
  addf(X, _, [length-L]), 
  
  fail. 
  
 get_length(y, L, L) :- !. 
  
 get_length(L, _, L). 
  
 Building Expert Systems in Prolog
  
 85",NA
The Rules ,"With the data definition, initial data, and input taken care of, we can proceed to the body of 
 rules. They are much simpler than the original versions. 
  
 The first rules place the couch either opposite the door or to its right, depending on which 
 wall has more space. Note that the update of the couch position is done with a single 
 action. The frame demons take care of the rest of the update. 
  
 rule f1: 
  
 [goal - couch_first, 
  
  couch - C with [position-none, length-LenC],  
 door - D with [position-wall/W], 
  
  wall - W with [opposite-OW, right-RW], 
  
  wall - OW with [space-SpOW], 
  
  wall - RW with [space-SpRW], 
  
  SpOW >= SpRW, 
  
  LenC =< SpOW] 
  
 ==> 
  
 [update(couch - C with [position-wall/OW])]. 
  
 rule f2: 
  
 [goal - couch_first, 
  
  couch - C with [position-none, length-LenC],  
 door - D with [position-wall/W], 
  
  wall - W with [opposite-OW, right-RW], 
  
  wall - OW with [space-SpOW], 
  
  wall - RW with [space-SpRW], 
  
  SpRW >= SpOW, 
  
  LenC =< SpRW] 
  
 ==> 
  
 [update(couch - C with [position-wall/RW])]. 
  
 86 
  
 Chapter 7 - Integration",NA
Output Data ,"The 
 output_data
  predicate is again straight forward Prolog, which gets the relevant 
 information and displays it. 
  
 output_data :- 
  
  write('The final results are:'), nl,  
  
  output_walls,  
  
  output_tables,  
  
  output_recommends,  
  
  output_unplaced. 
  
 output_walls :- 
  
  getf(wall, W, [holding-HL]),  
  
  write_line([W, wall, holding|HL]),  
  
  fail. 
  
 output_walls. 
  
 output_tables :- 
  
  getf(C, N, [holding-HL]),  
  
  not C = wall,  
  
  write_line([C, N, holding|HL]),  
  
  fail. 
  
 output_tables. 
  
 output_recommends :- 
  
  getf(recommend, _, [buy-BL]),  
  
  write_line([purchase|BL]),  
  
  fail. 
  
 output_recommends. 
  
 output_unplaced :- 
  
  write('Unplaced furniture:'), nl,  
  
  getf(T, N, [position-none]),  
  
  write(T-N), nl,  
  
  fail. 
  
 output_unplaced. 
  
 Figure 7.2 summarizes how the tools in 
 Foops
  are applied to the furniture layout program. 
 Frames are used for objects and relationships, rules are used to define situations and 
 responses, and Prolog is used for odds and ends like I/O and calculations. 
  
 Frames
  
  
 information about objects - ex. furniture
  
 relationships between objects - ex. length of
  
  furniture and wall space
  
 Rules
  
 situations and responses - when to place
  
  what and when
  
 Prolog
  
 I/O - gather data
  
 calculations - wall space updates
  
 Figure 7.2  Summary of knowledge representation tools used in Foops 
  
 Building Expert Systems in Prolog
  
 89",NA
7.3 A Sample Run ,"Here is a portion of a sample run of the furniture placement system. 
  
 The system starts in the 
 Foops
  command loop, and then begins the initial data gathering. 
  
 =>go. 
  
 Enter name of furniture at the prompt. It must be one of: 
  
 [couch, chair, coffee_table, end_table, standing_lamp, table_lamp, 
 tv, knickknack] 
  
 Enter end to stop input. 
  
 At the length prompt enter y or a new number. 
 >couch. 
  
 length-6>y. 
  
 >chair. 
  
 length-3>5. 
  
 ... 
  
 >end. 
  
 Enter data for the walls. 
  
 What is the length of the north & south walls? 12. 
  
 What is the length of the east & west walls? 9. 
 Which wall has the door? east. 
  
 What is its length? 3. 
  
 Which walls have outlets? (a list)[east]. 
  
 adding-(goal-couch_first) 
  
 Rule fired 1 
  
 One of the rules accessing the television causes this prompt to appear. 
  
 Should the TV go on a table? yes. 
  
 The system has informational messages regarding which rules are firing and what data is 
 being updated. 
  
 updating-(couch-110 with [position-wall/north]) Rule 
 fired f2 
  
 updating-(end_table-116 with [position-wall/south]) 
 updating-(tv-117 with [position-end_table/116]) Rule 
 fired f4 
  
 ... 
  
 Here is a message that appeared when a knickknack was unsuccessfully placed on an end 
 table. A different knickknack was then found to fit on the same table. 
  
 Not enough room on end_table 116 for knickknack 121 Rule 
 fired f11a 
  
 updating-(knickknack-120 with [position-end_table/116]) 
 Rule fired f11a 
  
 Here is one of the extension cord recommendations: 
  
 adding-(recommend-_3888 with [buy-[extension cord- 
  
  
 table_lamp/north]]) Rule fired f13 
  
 The last rule to fire provides the final results. 
  
 90 
  
 Chapter 7 - Integration",NA
7.4 Summary ,"A combination of techniques can lead to a much cleaner representation of knowledge for a 
 particular problem. The Prolog code for each of the techniques can be integrated relatively 
 easily to provide a more complex system.",NA
Exercises ,"7.1 Integrate 
 Clam
  with frames. 
  
 7.2 Implement multiple rule sets as described in the chapter five exercises. Let each rule 
 set be either forward or backward chaining, and use the appropriate inference engine 
 for both. 
  
 7.3 Build another expert system using 
 Foops
 . 
  
 Building Expert Systems in Prolog
  
 91",NA
8 Performance ,"As the size of a knowledge base grows, performance becomes more problematic. The 
 inference engines we have looked at so far use a simple pattern matching algorithm to find 
 the rules to fire. Various indexing schemes can be used to speed up that pattern matching 
 process. 
  
 The indexing problem is different for forward and backward chaining systems. Backward 
 chaining systems need to be accessed by the goal pattern in the right hand side of the rule. 
  
 Forward chaining systems need to be indexed by the more complex patterns on the left 
 hand side. Backward chaining issues will be discussed briefly in this chapter, followed by 
 more in-depth treatment of a simplified Rete match algorithm for the 
 Foops
  forward 
 chaining system.",NA
8.1 Backward Chaining Indexes ,"For performance in backward chaining systems, the rules are indexed by goal patterns on 
 the right hand side. In particular, if the goal is to find a value for a given attribute, then the 
 rules should be indexed by the attribute set in the RHS of the rule. This happens 
  
 automatically for the pure Prolog rules in the bird identification program since the 
 attributes are Prolog predicate names, which are generally accessed through hashing 
 algorithms. The indices, if desired, must be built into the backward chaining engine used in 
 Clam
 . Some Prologs provide automatic indexing on the first argument of a predicate. This 
 feature could be used to provide the required performance. 
  
 Given indexing by the first argument, the rules in 
 Clam
  would be represented by: 
  
 rule(Attribute, Val, CF, Name, LHS). 
  
 This way, a search for rules providing values for a given attribute would quickly find the 
 appropriate rules. 
  
 Without this, each rule could be represented with a functor based on the goal pattern and 
 accessed using the univ (=..) predicate rather than the pattern matching currently used in 
 Clam
 . The predicates that initially read the rules can store them using this scheme. For 
 example, the internal format of the 
 Clam
  rules would be: 
  
 attribute(Val, CF, Name, LHS). 
  
 In particular, some rules from the car diagnostic system would be: 
  
 problem(battery, 100, 'rule 1', 
  
  
  [av(turn_over, no), av(battery_bad, yes)]). 
  
 problem(flooded, 80, 'rule 4', 
  
  
  [av(turn_over, yes), av(smell_gas, yes)]). 
  
 battery_bad(yes, 50, 'rule 3', [av(radio_weak, yes)]). 
  
 When the inference is looking for rules to establish values for an attribute-value pattern, 
 av(A, V)
 , the following code would be used: 
  
 Rule =.. [A, V, CF, ID, LHS], 
  
 call(Rule), 
  
 ... 
  
 Building Expert Systems in Prolog
  
 93",NA
8.2 Rete Match Algorithm ,"OPS5 and some high-end expert system shells use the Rete match algorithm to optimize 
 performance. It is an indexing scheme, which allows for rapid matching of changes in 
 working memory with the rules. Previous match information is saved on each cycle, so the 
 system avoids redundant calculations. We will implement a simplified version of the Rete 
 algorithm for 
 Foops
 . 
  
 The Rete algorithm is designed for matching left hand side rule patterns against working 
 storage elements. Let's look at two similar rules from the room placement expert system. 
  
 rule f3# 
  
 [couch - C with [position-wall/W], 
  
  wall - W with [opposite-OW], 
  
  tv - TV with [position-none, place_on-floor]] 
 ==> 
  
 [update(tv - TV with [position-wall/OW])]. 
  
 rule f4# 
  
 [couch - C with [position-wall/W], 
  
  wall - W with [opposite-OW], 
  
  tv - TV with [position-none, place_on-table],  
 end_table - T with [position-none]] 
  
 ==> 
  
 [update(end_table - T with [position-wall/OW]),  
 update(tv - TV with [position-end_table/T])]. 
  
 First let's define some terms. Each LHS is composed of one or more frame patterns. An 
 example of a frame pattern is: 
  
 tv-TV with [position-none, place_on-table] 
  
 The frame pattern will be the basic unit of indexing in the simplified Rete match 
 algorithm. In a full implementation, indexing is carried down to the individual attribute-
 value pairs within the frame pattern, such as 
 place_on-table
 . 
  
 The match algorithm used in the first implementation of 
 Foops
  takes every rule and 
 compares it to all the frame instances on each cycle. In particular, both of the example rules 
 above would be compared against working storage on each cycle. Not only is redundant 
 matching being done on each cycle, within each cycle the same frame patterns are being 
 matched twice, once for each rule. Since working memory generally has few changes on 
 each cycle, and since many of the rules have redundant patterns, this approach is very 
 inefficient. 
  
 With the Rete algorithm, the status of the match information from one cycle is 
 remembered for the next. The indexing allows the algorithm to update only that match 
 information which is changed due to working memory changes. 
  
 The rules are compiled into a network structure where the nodes correspond to the frame 
 patterns in the LHS of the rules. There are three basic types of node, which serve as: the 
 entry to the network; the internals of the network; and the exit from the network. These are 
 called root nodes, two-input nodes, and rule nodes respectively. 
  
 The network has links which run from single frame patterns in the root nodes, through the 
 two-input nodes, to full LHS patterns in the rule nodes. Figure 8.1 shows the nodes and 
 links generated from the two sample rules. 
  
 94 
  
 Chapter 8 - Performance",NA
Network Nodes ,"The root nodes serve as entry points to the Rete network. They are the simplest patterns 
 recognized by the network, in this case the frame patterns that appear in the various rules. 
 A frame pattern only appears once in a root node even if it is referenced in multiple rules. 
 Each root node has pointers to two-input nodes, which are used to combine the patterns 
 into full LHS patterns. 
  
 Two-input nodes represent partially completed LHS patterns. The left input has a pattern 
 that has one or more frame patterns as they appear in one or more rules. The right input 
 has a single frame pattern, which when appended to the left input pattern completes more 
  
 Building Expert Systems in Prolog
  
 95",NA
Network Propagation ,"Associated with each two-input node are copies of working storage elements that have 
  
 already matched either side of the node. These are called the left and right memories of the 
  
 node. In effect, this means working memory is stored in the network itself. 
  
 Whenever a frame instance is added, deleted, or updated it is converted to a ""token"". A 
  
 token is formed by comparing the frame instance to the root patterns. A root pattern which 
  
 is unified with the frame instance is a token. The token has an additional element which 
  
 indicates whether it is to be added to or deleted from the network. 
  
 Frame Pattern 
  
 Frame Instance
  
 Rule f3 
  
 wall-north with
  
 ...
  
  [opposite-south,
  
 wall-W with [opposite-OW],
  
  left-west, right-east]
  
 ...
  
 Root 
  
 wall-W with [opposite-OW]
  
 Node
  
 Add
  
 + wall-north with [opposite-south]
  
 Token
  
 Two-
  
 couch-C with 
  
 wall-W with
  
 input
  [position-wall/W] [opposite-OW]
  
 Node
  
 couch-1 with wall-north with
  
  [position-wall/north]
  
  [opposite-south]
  
 Left Memory 
  
 Right Memory
  
 Add 
  
 + couch-1 with [position-wall/north],
  
 Token
  
  wall-north with [opposite-south]
  
 couch-C with tvTV with
  
  [position-wall/W],
  
  [position-none,
  
 wall-W with place_on-floor]
  
  [opposite-OW]
  
 couch-1 with [position-wall/north],
  
 wall-north with [opposite-south]
  
 Left Memory
  
 Figure 8.2  The relationship between frame patterns, instances, tokens, and nodes 
  
 96 
  
 Chapter 8 - Performance",NA
Example of Network Propagation ,"Lets trace what happens in the network during selected phases of a run of the room 
 configuration system. 
  
 First the walls are placed during initialization. There are four wall frame instances asserted, 
 which define opposites and are therefore recognized by the portion of the system we are 
 looking at. They are used to build add-tokens that are sent to the network. 
  
 wall-north with [opposite-south]. 
  
 wall-south with [opposite-north]. 
  
 wall-east with [opposite-west]. 
  
 wall-west with [opposite-east]. 
  
 Each of these tokens matches the following root pattern, binding 
 OW
  to the various 
 directions: 
  
 wall-W with [opposite-OW]. 
  
 Therefore, each token is passed on to the right side of two-input node #1 as indicated by 
 the list of links associated with that root pattern. Each of these terms is stored in the right 
 memory of node #1. Since there is nothing in the left memory of node #1, network 
 processing stops until the next input is received. 
  
 Next, the furniture is initialized, with the couch, tv, and end_table placed with 
 position-
 none
 . They will be internally numbered 1, 2, and 3. Since the root pattern for couch in the 
 segment we are looking at has a 
 position-wall/W
 , the couch does not show up in it at this 
 time. However, node #2 and node #4 have their right memories updated respectively with 
 the tokens: 
  
 tv-2 with [position-none, place_on-floor]. 
  
 end_table-3 with [position-none]. 
  
 At this point the system looks like figure 8.3. The shaded boxes correspond to the two-
 input nodes of figure 8.1. 
  
 Building Expert Systems in Prolog
  
 97",NA
Performance Improvements ,"The Rete network provides a number of performance improvements over a simple 
 matching of rules to working memory: 
  
 Building Expert Systems in Prolog
  
 99",NA
8.3 The Rete Graph Data Structures ,"The roots of the network are based on the frame patterns from the rules. The root nodes are 
 represented as: 
  
 root(NID, Pattern, NextList). 
  
 NID
  is a generated identification for the node, 
 Pattern
  is the frame pattern, and 
 NextList 
 is the list of succesor nodes that use the 
 Pattern
 . 
 NextList
  serves as the pointers 
 connecting the network together. For example: 
  
 root(2, wall-W with [opposite-OW], [1-r]). 
  
 The two-input nodes of the network have terms representing the patterns that are matched 
 from the left and right inputs to the node. Together they form the template, which 
 determines if particular tokens will be successfully combined into rule instantiations. The 
 format of this structure is: 
  
 bi(NID, LeftPattern, RightPattern, NextList). 
  
 NID
  again is an identification. 
 LeftPattern
  is the list of frame patterns that have been 
 matched in nodes previous to this one. 
 RightPattern
  is the new frame pattern that will be 
 appended to the 
 LeftPattern
 . 
 NextList
  contains a list of successor nodes. For example: 
  
 bi(1, [couch-C with [position-wall/W]], 
  
  [wall-W with [opposite-OW],  
  
  [2-l, 3-l]). 
  
 bi(2, [couch-C with [position-wall/W], 
  
  
  
  wall-W with [opposite-OW]],  
  
  
  [tv-TV with [position-none, place_on-floor]],  
  
  [rule(f3)]). 
  
 The end of the network is rules. The rules are stored as: 
  
 rul(N, LHS, RHS). 
  
 N
  is the identification of the rule. 
 LHS
  is the list of frame patterns which represent the full 
 left hand side of the rule. 
 RHS
  is the actions to be taken when the rule is instantiated. 
  
 100 
  
 Chapter 8 - Performance",NA
8.4 Propagating Tokens ,"Tokens are generated from the updates to frame instances. There are only two update 
 predicates for the network: 
 addrete
 , which adds tokens, and 
 delrete
 , which deletes them. 
  
 Both take as input the 
 Class
 , 
 Name
 , and 
 TimeStamp
  of the frame instance. Both are called 
 from the 
 Foops
  predicates that update working memory: 
 assert_ws
 , 
 retract_ws
  and 
 update_ws
 . The major predicates of 
 addrete
  are shown in figure 8.5. 
  
 addrete
  
  
 root
  
 getf
  
 ffsend
  
 send
  
  
 sen 
  
 send
  
  
 rul
  
 conflict_set
  
 bi
  
 matchRight/Left
  
 % update
  
 memory send 
  
 % right/left
  
 Figure 8.5  Major predicates which propagate a token through the network 
  
 The 
 addrete
  predicate uses a simple repeat-fail loop to match the frame instance against 
 each of the root nodes. It looks like: 
  
 addrete(Class, Name, TimeStamp) :- 
  
  root(ID, Class-Name with ReqList, NextList),  
  
  ffsend(Class, Name, ReqList, TimeStamp, NextList),   
 fail. 
  
 addrete(_, _, _). 
  
 The 
 ffsend
  predicate fullfills the request pattern in the 
 root
  by a call to the frame system 
 predicate, 
 getf
 . This fills in the values for the pattern thus creating a token. Next, 
 send
  is 
 called with an add token. 
  
 ffsend(Class, Name, ReqList, TimeStamp, NextList) :- 
  
  getf(Class, Name, ReqList),  
  
  send(tok(add, [(Class-Name with ReqList)/TimeStamp]), NextList),   
 !. 
  
 The 
 delrete
  predicate is analagous, the only difference being it 
 send
 s a delete token 
 through the network. 
  
 delrete(Class, Name, TimeStamp) :- 
  
  root(ID, Class-Name with ReqList, NextList),   
 delr(Class, Name, ReqList, TimeStamp),  
  
  fail. 
  
 delrete(_, _, _). 
  
 delr(Class, Name, ReqList, TimeStamp) :- 
  
  
  getf(Class, Name, ReqList),  
  
  
  !, 
  
  
  send(tok(del, [(Class-Name with ReqList)/TimeStamp]), NextList). 
 delr(Class, Name, ReqList, TimeStamp). 
  
 Building Expert Systems in Prolog
  
 101",NA
8.5 The Rule Compiler ,"The rule compiler builds the Rete network from the rules. The compiler predicates are not 
 as straight forward as the predicates that propagate tokens through the network. This is one 
 of the rare cases where the power of Prolog's pattern matching actually gets in the way, and 
 code needs to be written to overcome it. 
  
 The very unification which makes the pattern matching propagation predicates easy to code 
 gets in the way of the rule compiler. We allow variables in the rules, which behave as 
 normal Prolog variables, but when the network is built, we need to know which rules are 
 matching variables and which are matching atoms. For example, one rule might have the 
 pattern 
 wall/W
  and another might have 
 wall/east
 . These should generate two different 
 indices when building the network, but Prolog would not distinguish between them since 
 they unify with each other. 
  
 In order to distinguish between the variables and atoms in the frame patterns, we must pick 
 the pattern apart first, binding the variables to special atoms as we go. Once all of the 
 variables have been instantiated in this fashion, the patterns can be compared. 
  
 But first, let's look at the bigger picture. Each rule is compared, frame pattern by frame 
 pattern, against the network which has been developed from the rules previously 
  
 processed. The frame patterns of the rule are sent through the network in a similar fashion 
 to the propagation of tokens. If the frame patterns in the rule are accounted for in the 
 network, nothing is done. If a pattern is not in the network, then the network is updated to 
 include it. 
  
 The top level predicate for compiling rules into a Rete net, reads each rule and compiles it. 
  
 rete_compil :- 
  
  rule N# LHS ==> RHS,  
  
  rete_comp(N, LHS, RHS),  
  
  fail. 
  
 rete_compil. 
  
 The major predicates involved in compiling rules into a Rete network are shown in figure 
 8.6. 
  
 Building Expert Systems in Prolog
  
 103",NA
8.6 Integration with Foops ,"Only a few changes have to be to 
 Foops
  to incorporate the Rete network developed here. 
  
 A compile command is added to the main menu that builds the Rete network. It is called 
 after the load command. 
  
 The commands to update working memory are modified to propagate tokens through the 
 Rete network. This means calls to 
 addrete
  and 
 delrete
  as appropriate. 
  
 108 
  
 Chapter 8 - Performance",NA
8.7 Design Tradeoffs ,"There are a number of design tradeoffs made in this version. The first is the classic space 
 versus speed tradeoff. At each Rete memory, a full copy of each token is saved. This 
 allows it to be retrieved and matched quickly during execution. Much space could be 
 saved by only storing pointers to the working memory elements. These would have to be 
 retrieved and the token reconstructed when needed. 
  
 The other tradeoff is with the flexibility of the frame system. With the frames in the 
 original 
 Foops
 , the frame patterns in the rules could take advantage of inheritance and 
 general classes, as in the rules which determined a need for electrical plugs in a room. 
 Since 
 Rete-Foops
  instantiates the patterns before propagating tokens through the network, 
 this does not work. This feature could be incorporated but would add to the burden and 
 complexity of maintaining the network.",NA
Exercises ,"8.1 Implement nodes which support rules which have tests such as X > Y, and negated 
 frame patterns. 
  
 8.2 The implementation described in this chapter makes heavy use of memory by storing 
 the full tokens in left and right memories. Build a new system in which space is saved 
 by storing a single copy of the token and having pointers to it in left and right memory. 
 The stored tokens just match single frame patterns. The complex tokens in the middle 
 of the network contain lists of pointers to the simple tokens. 
  
 8.3 Experiment with various size systems to see the performance gains of the Rete version 
 of Foops. 
  
 8.4 Figure out a way to allow Rete-Foops to use inheritance in frame patterns. That is, fix it 
 so the rule which finds electric plugs works. 
  
 8.5 Build an indexed version of Clam and make performance experiments with it. 
  
 Building Expert Systems in Prolog
  
 109",NA
9 User Interface ,"The user interface issues for expert system shells can be divided between two classes of 
 users and two different levels. The two users are the developer and the end-user of the 
 application. The levels are the external interface and the internal function. 
  
 For the developer, the internal function must be adequate before the external interface 
 becomes a factor. To build a configuration application, an easy-to-use backward chaining 
 system is not as good as a hard-to-use forward chaining system. To build a large 
  
 configuration system, an easy-to-use, low performance forward chaining system is not as 
 good as a hard-to-use, high performance forward chaining system. 
  
 The same is true for the end-user. While there is increasing awareness of the need for good 
 external interfaces, it should not be forgotten that the internal function is still the heart of an 
 application. If a doctor wants a diagnostic system to act as an intelligent assistant and 
 instead it acts as an all knowing guru, then it doesn't matter how well the external interface 
 is designed. The system will be a failure. If a system can save a company millions of 
 dollars by more accurately configuring computers, then the system will be used no matter 
 how poor the external interface is. 
  
 Given that a system meets the needs of both the developer and the end-user, then the 
 external interface becomes an essential ingredient in the satisfaction with the system. The 
 systems developed so far have used a command driven, dialog type user interface. 
  
 Increasingly windows, menus, and forms are being used to make interfaces easier to 
 understand and work with. This chapter describes how to build the tools necessary for 
 developing good user interfaces.",NA
9.1 Object Oriented Window Interface ,"One of the major difficulties with computer languages in general, and Prolog in particular, 
 is the lack of standards for user interface features. There are emerging standards, but there 
 is still a long way to go. The windowing system described here includes a high-level, 
 object oriented interface for performing common window, menu and form operations, 
 which can be used with any Prolog or computer. The low level implementation will vary 
 from Prolog to Prolog, and computer to computer. 
  
 The interface is object-oriented in that each window, menu and form in the system is 
 considered to be a ""window-object"" that responds to messages requesting various 
 behaviors. For example, a display window would respond to ""write"" messages, and both a 
 menu and prompt window would respond to a ""read"" message. 
  
 The developer using the system defines window-objects to be used in an application and 
 then uses a single predicate, 
 window
 , to send messages to them. The system can be easily 
 extended to include new messages and window-objects. For example, graphics can be 
 included for systems that support it.",NA
9.2 Developer's Interface to Windows ,"The windows module provides for overlapping windows of four basic flavors. 
  
 display
  — an output only window. The user may scroll the window up and down 
 using the cursor keys. 
  
 menu
  — a pop-up vertical menu. 
  
 form
  — a fill-in-the-blanks form. 
  
 Building Expert Systems in Prolog
  
 111",NA
9.3 High-Level ,NA,NA
W ,"The 
 The 
 l
  
 114 
  
 Figure 9.2  Window interface for dialog with Birds system",NA
indow Implementation ,"window module is constructed in layers. The top layer can be used with any Prolog. 
 ower layers have the actual implementations of the windows and vary from system to 
  
 Chapter 9 - User Interface",NA
Message Passing ,"At the top level, the interface is object oriented. This means messages are sent to the 
 individual windows. One feature of object oriented systems is that messages are 
  
 dispatched at run time based on the class of object. For example, the read message applies 
 to both the prompt windows and the menu windows, but the implementation is different in 
 each case. The implementations are called methods. The window predicate must determine 
 what type of window is receiving the message, and what the correct method to call is: 
  
 window(W, Op, Args):- 
  
  get_type(W, T),  
  
  find_proc(T, Op, Proc),  
  
  P =.. [Proc, W, Args],  
  
  call(P), 
  
  !. 
  
 The 
 get_type
  predicate finds the type of the window, 
 find_proc
  gets the correct method to 
 call, and univ (
 =..
 ) is used to call it. 
  
 When 
 window
  is called with a window description as the first argument, it creates a 
 temporary window, sends the message to it, and then deletes it. A two argument version of 
 window is used to capture calls with no arguments. 
  
 window([H|T], Op, Args):- 
  
  window(temp_w, create, [H|T]),  
  
  window(temp_w, Op, Args),  
  
  window(temp_w, delete), 
  
  !. 
  
 window(W, Op) :- 
  
  
  window(W, Op, []). 
  
 The 
 get_type
  predicate uses 
 select_parm
  to find the value for the type attribute of the 
 window. It uses the stored window definition. 
  
 get_type(W, X):- 
  
  select_parm(W, [type(X)]), 
  
  !. 
  
 Window definitions are stored in structures of the form: 
  
 wd(W, AttributeList).",NA
Inheritance ,"Another feature of object oriented systems is inheritance of methods. The objects are 
 arranged in a class hierarchy, and lower level objects only have methods defined for them 
 that are different from the higher level methods. In the window program, 
 type(window)
  is 
 the highest class, and the other types are subclasses of it. A predicate such as 
 close
  is only 
 defined for the window superclass and not redefined for the subclasses. 
  
 This makes it easy to add new window types to the system. The new types can inherit 
 many of the methods of the existing types. 
  
 The classes are represented in Prolog using a subclass predicate: 
  
 Building Expert Systems in Prolog
  
 115",NA
9.4 Low-Level Window Implementation ,"In addition to being a powerful language for artificial intelligence applications, Prolog is 
 good at implementing more standard types of programs as well. Since most programs can 
 be specified logically, Prolog is a very efficient tool. While we will not look at all the 
 details in this chapter, a few samples from the low-level implementation should 
  
 demonstrate this point. An entire overlapping window system with reasonable response 
 time was implemented 100% in Prolog using just low-level screen manipulation 
  
 predicates. 
  
 The first example shows predicates that give the user control over a menu. They follow 
 very closely the logical specification of a menu driver. A main loop, 
 menu_select
 , 
 captures keystrokes, and then there are a number of rules, 
 m_cur
 , governing what to do 
 when various keys are hit. Here is the main loop for the Arity Prolog PC implementation: 
  
 menu_select(W, X):- 
  
  
  select_parm(W, [coord(R1, C1, R2, _), width(L), attr(A)]),  
  
  tmove(R1, C1),  % move the cursor to first item 
  
  
  revideo(L, A),  % reverse video first item 
  
  
  repeat,  
  
   
  keyb(_, S),  % read the keyboard 
  
   
  m_cur(S, Z, w(W, R1, R2, C1, L, A)),  % usually fails 
  
  
 !, 
  
  
  Z = X. 
  
 Here are four of the menu rules covering the cases where: the down arrow (scan code of 
 80) is hit (highlight the next selection); the down arrow is hit at the bottom of the menu 
 (scroll the menu); the home key (scan code of 71) is hit (go to the top); and the enter key 
 (scan code of 28) is hit (finally succeed and select the item). 
  
 m_cur(80, _, w(W, R1, R2, C1, L, A)):-  % down arrow  
 tget(R, _),  
  
  R < R2,  
  
  normvideo(L, A),  
  
  RR is R + 1,  
  
  tmove(RR, C1),  
  
  revideo(L, A),  
  
  !, 
  
  fail. 
  
 Building Expert Systems in Prolog
  
 117",NA
Exercises ,"9.1 Implement object oriented windows on the Prolog system you use. 
  
 9.2 Add windowing interfaces to all of the expert system shells developed so far. 
  
 9.3 Add controls as a window type. These are display windows that use a graphical image 
 to represent a number. The easiest graphical control to implement is a thermometer in a 
 text based system (such as the IBM PC in text mode). The controls can also contain 
 digital readouts, which is of course even easier to implement. 
  
 9.4 Active images are controls which automatically display the contents of some variable in 
 a system. For example, in the furniture placement system it would be interesting to 
 have four controls that indicate the available space on each of the four walls. They can 
 be elegantly implemented using the attached procedure in the 
 add
  slot of the frames. 
 Whenever a new value is added, the procedure sends it to the control window. (Note 
 that add is called during update of the slot in this implementation.) 
  
 9.5 In the windowing interface for the various shells, have trace information appear in a 
  
 separate window. 
  
 9.6 Add graphics windows to the system if your version of Prolog can support it. 
  
 9.7 In the main control loop, recognize certain user actions as a desire to manipulate the 
 windows. For example, function keys might allow the user to pop various windows to 
 the top. This would enable the system to keep trace information in one window, which 
 is overlapped by the main window. The user could access the other windows by taking 
 the appropriate actions. 
  
 120 
  
 Chapter 9 - User Interface",NA
10 Two Hybrids ,"This chapter describes two similar expert systems, which were developed at Cullinet 
 Software, a large software vendor for IBM mainframes, VAXes, and PCs. The systems 
 illustrate some of the difficulties in knowledge base design and show the different features 
 needed in two seemingly very similar systems. 
  
 Both expert systems were designed to set parameters for the mainframe database, IDMS/R, 
 at a new user site. The parameters varied from installation to installation, and it was 
 necessary to have an experienced field support person set them at the site. Since field 
 support people are expensive, the expert systems were written to allow the customer to set 
 the parameters, thus freeing the support person for more demanding tasks. 
  
 The first, CVGEN, set the system generation (sysgen) parameters for the run time behavior 
 of the system. This included such parameters as storage pool sizes, logging behavior, and 
 restart procedures. These parameters had a serious effect on the performance of the system, 
 and needed to be set correctly based on each site's machine configuration and application 
 mix. 
  
 The second, AIJMP, set all of the parameters that ran an automated installation procedure. 
  
 This included parameters that determined which modules to include and how to build 
 installation libraries. These parameters determined how the software would reside at the 
 customer's site. 
  
 The systems were built using a variation of the pure Prolog approach described earlier in 
 the book. The inferencing parts of the system were separated from the knowledge base. It 
 was surprising to find that even with two systems as similar as these — they both set 
 parameters, the shell for one was not completely adequate for the other.",NA
10.1 CVGEN ,"Various shells available on the PC were examined when CVGEN was built, yet none 
 seemed particularly well suited for this application. The main difficulty centered around 
 the nature of the dialog with the user. To a large degree, the expertise a field support 
 person brought to a site was the ability to ask the right questions to get information from 
 the systems programmers at the site, and the ability to judge whether the answers were 
 realistic. 
  
 To capture this expertise, the knowledge base had to be rich in its ability to represent the 
 dialog with the user. In particular: 
  
 • 
 The system was designed to be used by systems programmers who were technically 
 sophisticated, but not necessarily familiar with the parameters for IDMS/R. This meant 
 fairly lengthy prompts were needed in the dialog with the user. 
  
 • 
 The input data had to be subjected to fairly complex validation criteria, which was 
 often best expressed in additional sets of rules. A large portion of the field person's 
 expertise was knowing what values made sense in a particular situation. 
  
 • 
 The output of the system had to be statements, which were syntactically correct for 
 IDMS/R. This meant the rules not only found values for parameters but built the 
 statements as well. 
  
 Building Expert Systems in Prolog
  
 121",NA
10.2 The Knowledge Base ,"The knowledge base is divided into six parts, designed to make it easy for the expert to 
 examine and maintain it. These are: 
  
 • 
 main rules for the parameters; 
  
 • 
 rules for derived information; 
  
 • 
 questions for the user; 
  
 • 
 rules for complex validation; 
  
 • 
 rules for complex default calculations; 
  
 • 
 static information.",NA
Rule for parameters ,"The rules for each parameter are stored in the knowledge base with the parameter name as 
 the functor. Thus each parameter is represented by a predicate. The argument to the 
 predicate is a list with the actual IDMS/R syntax used to set the parameter. Variables in the 
  
 122 
  
 Chapter 10 - Two Hybrids",NA
Rules for derived information ,"The next part of the knowledge base contains the level of rules below the 
  
 parameter/subparameter level. These rules represent derived information. They read as 
 standard Prolog. Here are a few examples: 
  
 heavily_loaded:- 
  
  ask(heavy_cpu_utilization, yes), 
  
  !. 
  
 heavily_loaded:- 
  
  ask(heavy_channel_utilization, yes), 
  
  !. 
  
 Building Expert Systems in Prolog
  
 123",NA
Questions for the user ,"The next portion of the knowledge base describes the user interaction. Standard Prolog 
 rules do not cover this case, so special structures are used to hold the information. 
 Operator definitions are used to make it easy to work with the structure. 
  
 The first two examples show some of the default and edit rules, which are simple enough 
 to keep directly in the question definition. 
  
 quest abend_storage_size 
  
 default 200 
  
 edit between( 0, 32767) 
  
 prompt 
  
  
  ['Enter the amount of storage, in fullwords, available',  
   
  'to the system for processing abends in the event',  
  
  
  'of a task control element (TCE) stack overflow.',  
  
  
  'Note that this resource is single threaded.']. 
  
 quest abru_value 
  
 default no 
  
 edit member( [yes, no]) 
  
 prompt 
  
  
  ['Do you want the system to write a snap dump to the',  
  
  
  'log file when an external run unit terminates',  
  
  
  'abnormally?']. 
  
 The next two rules require more complex edit and default rule sets to be called. The square 
 brackets in the default field indicate there is a rule set to be consulted. In these examples, 
 ed_batch_user
  will be called to check the answer to 
 allowed_batch_users
 , and 
  
 def_storage_cushion
  is used to calculate a default value for 
 storage_cushion_size
 . 
  
 quest allowed_batch_users 
  
 default 0 
  
 edit ed_batch_user 
  
 prompt 
  
  
  ['How many concurrent batch jobs may access',  
   
  'the CV at one time?']. 
  
 quest storage_cushion_size 
  
 default [def_storage_cushion] 
  
 edit between( 0, 16384) 
  
 prompt 
  
  
  ['How many bytes of storage cushion would',  
  
   
  'you like? When available storage is less than the',  
   
  'cushion no new tasks are started. A recommended',  
   
  'value has been calculated for you.'].",NA
Default rules ,"The next two sections contain the rules that are used for edit and default calculations. For 
 example, the following rules are used to calculate a default value for the storage cushion 
  
 124 
  
 Chapter 10 - Two Hybrids",NA
Rules for edits ,"Here are the rules that are used to edit the response to the number of batch users. The 
 user's response is passed as the argument, and rules succeed or fail in standard Prolog 
 fashion depending on the user's response. 
  
 ed_batch_user(V1):- 
  
  V1 =< 2, 
  
  !. 
  
 ed_batch_user(V1):- 
  
  machine_size(large),  
  
  V1 =< 10, 
  
  !. 
  
 ed_batch_user(V1):- 
  
  machine_size(medium),  
  
  V1 =< 5, 
  
  !. 
  
 ed_batch_user(V1):- 
  
  machine_size(small),  
  
  V1 =< 3, 
  
  !.",NA
Static information ,"The final section contains factual information. For example, here is a table of the MIPS 
 ratings for various machines, and the rules used to broadly classify machines into sizes. 
  
 mac_mips('4381-1', 1.7). 
  
 mac_mips('4381-2', 2.3). 
  
 mac_mips('3083EX', 3.7). 
  
 mac_mips('3083BX', 6.0). 
  
 mac_mips('3081GX', 12.2). 
  
 mac_mips('3081KX', 15.5). 
  
 mac_mips('3084QX', 28.5). 
  
 mips_size(M, tiny):- 
  
  M < 0.5, 
  
  !. 
  
 mips_size(M, small):- 
  
  M >= 0.5,  
  
  M < 1.5, 
  
  !. 
  
 mips_size(M, medium):- 
  
  M >= 1.5,  
  
  M < 10, 
  
  !. 
  
 Building Expert Systems in Prolog
  
 125",NA
10.3 Inference Engine ,"The inference is organized around the specialized knowledge base. The highest level 
 predicates are set up to look for values for all of the parameters. The basic predicate 
 set_parms
  accomplishes this. It uses the 
 parm
  predicate to get parameter names and then 
 uses the 
 univ
  (
 =..
 ) built-in function to build a call to a parameter setting predicate. 
  
 set_parms:- 
  
  parm(Parm),  
  
  set_parm(Parm),  
  
  fail. 
  
 set_parms:- 
  
  
  write('no more parms'), nl. 
  
 set_parm(Parm):- 
  
  get_parm(Parm, Syntax),  
  
  write(Parm), write(': '),  
  
  print_line(Syntax), nl,  
  
  subs(Parm). 
  
 get_parm(Parm, Syntax):- 
  
  PS =.. [Parm, Syntax],  
  
  call(PS), 
  
  !.  
  
 subs(Parm):- 
  
  subprm(Parm, Sub, Syntax),  
  
  write(Parm), write('/'), write(Sub), write(':'),   
 print_line(Syntax), nl,  
  
  subs(Sub),  
  
  fail. 
  
 subs(Parm):- 
  
  
  true. 
  
 The next portion of the inference engine deals with the questions to the user. The 
 following operator definitions are used to define the data structure for questions. 
  
 :-op(250, fx, quest). 
  
 :-op(240, yfx, default). 
  
 :-op(240, yfx, edit). 
  
 126 
  
 Chapter 10 - Two Hybrids",NA
10.4 Explanations ,"Explanations become a bit more difficult with the 
 ask
  predicate. The how questions are 
 handled pretty much as in the 
 Clam
  and 
 Native
  systems described earlier in the book. Since 
 why traces require overhead during the inference process, and performance is a key issue 
 for a system with a long dialog such as this one, the why trace implementation is different 
 from that in 
 Native
 . The basic strategy is to use pure Prolog as indicated for most of the 
 inferencing, but to redo the inference using a Prolog in Prolog inference engine to answer 
 why questions. 
  
 In order to do this the system must in fact restart the inference, but since the parameters are 
 all basically independent, the why trace need only restart from the last call to set a 
 parameter. For this reason, the 
 set_parm
  predicate writes a record to the database 
  
 indicating which parameter is currently being set. 
  
 Once the why trace gets into 
 ask
 , the Prolog in Prolog must stop. In fact, the question 
 might have arisen from setting a parameter, calculating a default value or specifying an 
 edit criteria. Again, for these cases a flag is kept in the database so that trace knows the 
 current situation. 
  
 Building Expert Systems in Prolog
  
 127",NA
10.5 Environment ,"CVGEN is also designed to handle many of the details necessary in a commercially 
 deployed system. These details include the ability to change an answer to a question, save a 
 consultation session and restore it, build and save test runs of the system, and the ability to 
 list and examine the cache and the knowledge base from within a consultation. The system 
 also includes a tutorial, which teaches how to use the system. 
  
 Most of these features are straight-forward to implement, however changing a response is a 
 bit tricky. When the user changes an answer to a question, it is almost impossible to predict 
 what effects that will have on the results. Whole new chains of inferencing might be 
 triggered. The safest way to incorporate the change is to rerun the inference. By saving the 
 user's responses to questions, the system avoids asking any questions previously asked. 
  
 New questions might be asked due to the new sequence of rules fired after the change. 
  
 The facts which are stored are not necessarily the same as the user's response. In particular, 
 the user response of ""take the default"" is different from the actual answer, which is the 
 default value itself. For this reason, both the facts and the user responses to questions are 
 cached. Thus, when the user asks to change a response, the response can be edited and the 
 inference rerun without reprompting for all of the answers. 
  
 This list of responses can also be used for building test cases, which are rerun as the 
 knowledge base is modified. 
  
 128 
  
 Chapter 10 - Two Hybrids",NA
10.6 AIJMP ,"The AIJMP system seemed on the surface to be identical to the CVGEN system. Both set 
 parameters. It was initially assumed that the shell used for CVGEN could be applied to 
 AIJMP as well. While this was in general true, there were still key areas that needed to be 
 changed. 
  
 The differences have much to do with the nature of the user interaction. The CVGEN 
 system fits very nicely into the classic expert system dialog as first defined in the MYCIN 
 system. The system tries to reach goals and asks questions as it goes. However, for AIJMP 
 there is often the need for large amounts of tabular data on various pieces of hardware and 
 software. For these cases a question and answer format becomes very tedious for the user; a 
 form-based front end to gather information is much more appropriate. 
  
 AIJMP uses forms to capture some data, and dialogs to ask for other data as needed. This 
 led to the need to expand the basic inferencing to handle these cases. 
  
 Another difficulty became evident in the nature of the expertise. Much of what was needed 
 was purely algorithmic expertise. For example, part of the system uses formulas to compute 
 library sizes based on different storage media. Many of the parameters required both rules 
 of thumb and algorithmic calculations. 
  
 The best solution to the problem, for the knowledge engineer, was to build into the 
 inference engine the various predicates which performed calculations. This way they could 
 be referred to easily from within the rules. 
  
 Some of the declarative knowledge required for AIJMP could not be easily represented in 
 rules. For example, many products depend on the existence of co-requisite products. When 
 the user enters a list of products to be installed, it must be checked to make sure all product 
 dependencies are satisfied. The clearest way to represent this knowledge was with 
 specialized data structures. Operators are used to make the structures easy to work with. 
  
 product 'ads batch 10.1' 
  
 psw [adsb] 
  
 coreqs ['idms db', 'i data dict']. 
  
 product 'ads batch 10.2' 
  
 psw [adsb] 
  
 coreqs ['idms db', 'i data dict']. 
  
 product 'ads online' 
  
 psw [adso, nlin] 
  
 coreqs ['idms db', 'idms cv', 'i data dict', 
  
  
  'idms dc' / 'idms ucf']. 
  
 product auditor 
  
 psw [audi, culp] 
  
 coreqs []. 
  
 product autofile 
  
 psw [auto] 
  
 coreqs []. 
  
 The inference engine was enhanced to use this structure for co-requisite checking. The 
 design goal is to make the knowledge base look as familiar as possible to the experts. With 
 Prolog, it is not difficult to define specialized structures that minimize semantic gap and to 
 modify the inference engine to use them. 
  
 One simple example of how the custom approach makes life easier for the expert and 
 knowledge engineer is in the syntax for default specifications in the questions for the user. 
 The manual on setting these parameters used the ""@"" symbol to indicate that a parameter 
 had as its default the value of another parameter. This was a shorthand syntax well 
 understood by the experts. In many cases the same value (for example a volume id on a 
  
 Building Expert Systems in Prolog
  
 129",NA
10.7 Summary ,"These two systems show how some of the techniques in this book can be used to build real 
 systems. The examples also show some of the difficulties with shells, and the advantages of 
 customized systems in reducing semantic gap.",NA
Exercises ,"10.1 Incorporate data structures for user queries with edits and defaults for the 
 Clam 
  
 shell. 
  
 10.2 The CVGEN user query behavior can be built into 
 Foops
  when a value is sought 
 from the frame instances. If there is no other way to get the value, the user should 
 be queried. Additional facets can be used for prompt, default, and edit criteria, 
 which the inference engine uses just like in CVGEN. 
  
 10.3 Add features of CVGEN to the shells that are needed for real world applications. 
 These include the ability to save user responses, allow editting of responses, saving a 
 consultation, and rerunning a consultation. The last feature is essential for testing 
 and debugging systems. Old test runs can be saved and rerun as the knowledge base 
 changes. Hopefully the changes will not adversely affect the old runs. 
  
 130 
  
 Chapter 10 - Two Hybrids",NA
11 Prototyping ,"Regardless of whether one is going to use Prolog to build a finished application, Prolog is 
 still a powerful tool for prototyping the application. The problem might fit nicely into 
 Clam
  
 or 
 Foops
 , in which case those systems should be used for the prototype. Otherwise, pure 
 Prolog can be used to model the application. 
  
 In an expert system prototype it is important to model all of the different types of 
 knowledge that will be used in the application. Initial knowledge engineering should be 
 focused on what types of information the expert uses and how it is used. The full range of 
 expertise should be modelled, but not to the depth required for a real system. 
  
 The Prolog rules used in a prototype can be quickly molded to get the desired effects in the 
 application. The clean break between the inference engine and the knowledge base can be 
 somewhat ignored to allow more rapid development of the prototype. Explanations, traces 
 and many of the other features of an expert system are left out of the prototype. The I/O is 
 implemented simply to just give a feeling for the user interaction with the system. The full 
 system can be more elegantly designed once the prototype has been reviewed by the 
 potential users.",NA
11.1 The Problem ,"This section describes the building of a prototype system, which acts as an advisor for a 
 mainframe software salesperson. A good sales person must not only be congenial and buy 
 lunches, but must also have good product knowledge and know how to map that 
  
 knowledge onto a potential customer's needs. The type of knowledge needed by the sales 
 person is different from that typically held by a technical person. 
  
 The technical person thinks of a product in terms of its features, and implementation 
 details. The sales person must think of the prospect's real and perceived needs and be able 
 to map those to benefits provided by the features in the product. That is, the sales person 
 must understand the prospect's objectives and be able to present the benefits and features of 
 the product that help meet those objectives. 
  
 The salesperson must also have similar product knowledge about the competitor's products 
 and know which benefits to stress that will show up the weaknesses in the competitor's 
 product for the particular prospect. 
  
 In addition to this product knowledge, the sales person also has rules for deciding whether 
 or not the prospect is likely to buy, and recognizing various typical sales situations. 
  
 With a large workload, it is often difficult for a sales person to keep up on product 
 knowledge. An expert system, which helps the sales person position the products for the 
 prospect, would be a big asset for a high tech sales person. The 
 Sales Advisor
  system is a 
 prototype of such a system, designed to help in the early stages of the sales cycle.",NA
11.2 The Sales Advisor Knowledge Base ,"The ways in which sales people mentally organize product knowledge are fairly consistent. 
 The knowledge base for the sales advisor should be organized in a format which is as close 
 to the sales person's organization of the knowledge as possible. This way the semantic gap 
 will be reduced and the knowledge base will be more easily maintained by a domain expert. 
  
 Building Expert Systems in Prolog
  
 131",NA
Qualifying ,"First we implement the knowledge for qualifying the prospect. This type of knowledge 
 falls easily into a rule format. The final version will probably need some uncertainty 
 handling as in 
 Clam
 , but it is also important for this system to provide more text output 
 than 
 Clam
  provides. The quickest way to build the prototype is to use pure Prolog syntax 
 rules with I/O statements included directly in the body of the rule. 
 Clam
  can be used later 
 with modifications for better text display. 
  
 Two examples of qualifying rules are: the prospect must have an IBM mainframe, and the 
 prospect's revenues must be at least $30 million. They are written as 
 unqualified
  since if 
 the prospect fails a test then it is unqualified. 
  
 unqualified:- 
  
  not computer('IBM'), 
  
  advise('Prospect must have an IBM computer'),  
 nl. 
  
 unqualified:- 
  
  
  revenues(X), 
  
  
  X < 30, 
  
  
  advise('Prospect is unlikely to buy IDMS with revenues under $30 
 million'), 
  
  
  nl.",NA
Objectives - Benefits - Features ,"Sales people typically store product knowledge in a tabular form called an objective-
 benefit-feature chart, or OBF chart. It categorizes product knowledge so that for each 
 objective of the customer, the benefits of the product for meeting that objective and the 
 features of the product are detailed. 
  
 For the prototype we can simplify the prospect objectives by considering three main ones: 
 development of applications, building an information center and building efficient 
 production systems. Each prospect might have a different one of these objectives. The 
 benefits of each product in the product line varies for each of these objectives. This 
 information is stored in Prolog structures of three arguments called 
 obf
 . The first argument 
 is the feature (or product), the second is the customer objective and the third is the benefit 
 that is stressed to the prospect. 
  
 132 
  
 Chapter 11 - Prototyping",NA
Situation Analysis ,"The next key area is making sure that the products are compatible with the customer's 
 configuration. We wouldn't want to sell something that doesn't work. For example, OLE 
 would not run at the time on a small machine or under a DOS operating system. 
  
 unsuitable('OLE'):- 
  
  
  operating_system(dos). 
  
 unsuitable('OLE'):- 
  
  
  machine_size(small).",NA
Competitive Analysis ,"A good sales person will not directly attack the competition, but will use the competition's 
 weakness to advantage. This is done by stressing those aspects of a product which highlight 
 the competitor's weakness. That is, how can our product be differentiated from the 
 competitor's. For example, two of Cullinet's main competitors were IBM and ADR. 
  
 Building Expert Systems in Prolog
  
 133",NA
Miscellaneous Advice ,"Besides this tabular data, there are also collections of miscellaneous rules for different 
 situations. For example, there were two TP monitors, UCF, and DC. One allowed the user 
 to use CICS for terminal networks, and the other provided direct control of terminals. The 
 recommendation would depend on the situation. Another example is dealing with federal 
 government prospects, which required help with the Washington office as well. Another 
 rule recommends a technical sales approach, rather than the business oriented sell, for small 
 shops that are not responding well. 
  
 advice:- 
  
  not objective(production), 
  
  tp_monitor('CICS'), 
  
  online_applications(many), 
  
  nl, 
  
  advise('Since there are many existing online applications and'),  
 nl, 
  
  advise('performance isn''t an issue suggest UCF instead of DC'),   
 nl. 
  
 advice:- 
  
  industry(government), 
  
  government(federal), 
  
  nl, 
  
  advise('If it's the federal government, make sure you work'),  
 nl, 
  
  advise(' with our federal government office on the account'),  
 nl. 
  
 advice:- 
  
  competition('ADR'), 
  
  revenues(X), 
  
  X < 100, 
  
  friendly_account(no), 
  
  nl, 
  
  advise(' Market database technical issues'), 
  
  nl, 
  
  advise(' Show simple solutions in shirt sleeve sessions' ),  
 nl.",NA
User Queries ,"Finally, the knowledge base contains a list of those items which will be obtained from the 
 user. 
  
 134 
  
 Chapter 11 - Prototyping",NA
11.3 The Inference Engine ,"Now that a knowledge base has been designed, which has a reasonably small semantic gap 
 with the expert's knowledge, the inference engine can be written. For the prototype, some 
 of the knowledge is more easily stored in the inference engine. The high level order of 
 goals to seek is stored in the main predicate, 
 recommend
 . 
  
 recommend:- 
  
  qualify, 
  
  objective_products, 
  
  product_differentiation, 
  
  other_advice, 
  
  !. 
  
 recommend. 
  
 First, the prospect is qualified. The 
 qualify
  predicate checks to make sure there are no 
 unqualified rules which fire. 
  
 qualify:- 
  
  unqualified,  
  
  !, 
  
 Building Expert Systems in Prolog
  
 135",NA
11.4 User Interface ,"For a prototype, the user interface is still a key point. The system will be looking for 
 supporters inside an organization, and it must be easy for people to understand the system. 
  
 The windowing environment makes it relatively easy to put together a reasonable 
 interface. 
  
 For this example, one display window is used for advice near the top of the screen, and a 
 smaller window near the bottom is used for questions to the user. Pop-up menus and 
 prompter windows are used to gather information from the user. Figure 11.1 shows the 
 user interface. 
  
 136 
  
 Chapter 11 - Prototyping",NA
11.5 Summary ,"One can model a fairly complex domain relatively quickly in Prolog, using the tools 
 available. A small semantic gap on the knowledge base and good user interface are two 
 very important points in the prototype.",NA
Exercises ,"11.1 Prototype an expert system that plays poker or some similar game. It will need to be 
 specialized to understand the particular knowledge of the game. Experiment with the 
 prototype to find the best type of user interface and dialog with the system. 
  
 138 
  
 Chapter 11 - Prototyping",NA
12 Rubik's Cube ,"This chapter describes a Prolog program that solves Rubik's cube. The program illustrates 
 many of the knowledge engineering problems in building expert systems. Performance is a 
 key issue and affects most of the design decisions in the program. 
  
 This program differs from the others in the book in that the knowledge and the reasoning 
 are all intertwined in one system. The system uses Prolog's powerful data structures to map 
 the expertise for solving a cube into working code. It illustrates how to build a system in a 
 problem domain that does not fit easily into the attribute-value types on data representation 
 used for the rest of the book. 
  
 Like most expert systems, the program can perform at a level comparable to a human 
 expert, but does not have an ""understanding"" of the problem domain. It is simply a 
 collection of the rules, based on
  Unscrambling the Cube
  by Black & Taylor, that an expert 
 uses to solve the cube . Depending on the machine, it unscrambles cubes as fast or faster 
 than a human expert. It does not, however, have the intelligence to discover the rules for 
 solving Rubik's cube from a description of the problem. 
  
 A Rubik's cube program illustrates many of the trade-offs in AI programs. The design is 
 influenced heavily by the language in which the program is written. The representation of 
 the problem is the key, but each language provides different capabilities for knowledge 
 representation and tools for manipulating the knowledge. 
  
 Performance has always been the issue with expert systems. A blind search strategy for the 
 cube simply would not work. Heuristics programming was invented to solve problems such 
 as this. Using various rules (intelligence), the search space can be drastically reduced so 
 that the problem can be solved in a reasonable amount of time. This is exactly what 
 happens in the Rubik's cube program. As with the basic knowledge representation, the 
 representation of the rules and how they are applied also figure heavily in the program 
 design. 
  
 Through this example we will see both the tremendous power and expressiveness of 
 Prolog as well as the obfuscation it sometimes brings as well.",NA
12.1 The Problem ,"Rubik's cube is a simple looking puzzle. It is a cube with nine tiles on each face. In its 
 solved state each of the sides is made up of tiles of the same color, with a different color 
 for each side. Each of the tiles is actually part of a small cube, or cubie. Each face of the 
 cube (made up of nine cubies) can be rotated. The mechanical genius of the puzzle is that 
 the same cubie can be rotated from multiple sides. A corner cubie can move with three 
 sides, an edge cubie with two sides. Figure 12.1 shows a cube in the initial solved state, 
 and after the right side was rotated 90 degrees clockwise.",NA
12.2 The Cube ,"The core of the program has to be the knowledge representation of the cube and its 
 fundamental rotations. 
  
 The cube lends itself to two obvious representation strategies. It can either be viewed 
 simply as 54 tiles, or as 20 cubies (or pieces) each with either two or three tiles. Since 
 much of the intelligence in the program is based on locating pieces and their positions on 
 the cube, a representation that preserves the piece identity is preferred. However, there are 
  
 140 
  
 Chapter 12 - Rubik's Cube",NA
12.3 Rotation ,"Unification also gives us the most efficient way to rotate a cube. Each rotation is 
 represented by a predicate, which maps one arrangement of tiles to another. The first 
 argument is the name of the rotation, while the second and third arguments represent a 
 clockwise turn of the side. For example, the rotation of the upper side is represented by: 
  
 mov(u, cube(X1, ...X6, X7, X8, X9, ...), 
  
 cube(X1, ...X6, X20, X19, X21, ...)) 
  
 We can apply this rotation to the top of the goal cube: 
  
 ?- goalstate(State), mov(u, State, NewState). 
  
 The variable 
 NewState
  would now have a solved cube with the upper side rotated 
 clockwise. 
  
 Since these can be used in either direction, we can write a higher level predicate that will 
 make either type of move based on a sign attached to the move. 
  
 move(+M, OldState, NewState):- 
  
  mov(M, OldState, NewState). 
  
 move(-M, OldState, NewState):- 
  
  mov(M, NewState, OldState). 
  
 Having now built the basic rotations, it is necessary to represent the complex sequences of 
 moves necessary to unscramble the cube. In this case the list notation is the best way to go. 
  
 For example, a sequence that rotates three corner pieces is represented by: 
  
 seq(tc3, [+r, -u, -l, +u, -r, -u, +l, +u]). 
  
 The sequence can be applied to a cube using a recursive list predicate, 
 move_list/3
 : 
  
 move_list([], X, X). 
  
 move_list( [Move|T], X, Z):- 
  
  move(Move, X, Y),  
  
  move_list(T, Y, Z). 
  
 At this point we have a very efficient representation of the cube and a means of rotating it. 
 We next need to apply some expertise to the search for a solution.",NA
12.4 High Level Rules ,"The most obvious rule for solving Rubik's cube is to attack it one piece at a time. The 
 placing of pieces in the solved cube is done in stages. In Black & Taylor's book they 
 recognize six different stages, which build the cube up from the left side to the right. Some 
 examples of stages are: put the left side edge pieces in place, and put the right side corner 
 pieces in place. 
  
 142 
  
 Chapter 12 - Rubik's Cube",NA
12.5 Improving the State ,"The
  stage/1
  predicate calls the main working predicates, which search for the rotations to 
 put a given piece in place and update all of the appropriate data structures. The 
  
 representation of the partially solved cube is a key design issue for this portion of the 
 program. 
  
 There are predicates in the program that search through a cube in list-piece notation (rather 
 than tile notation) and determine where a piece is or, conversely, which piece is in a given 
 position. These predicates are useful for many portions of the program but are too slow to 
 be used for testing whether a given search has been successful or not. This is true since they 
 not only have to check for the new piece being placed but also have to insure that none of 
 the previously placed pieces have moved. 
  
 Unification is again the answer. So far, there are two 
 cube/54
  terms used in the program. 
 One represents the final solved state of the cube, the other represents the current state of 
 the cube. We introduce a third 
 cube/54
 , referred to as the criteria, which is used to denote 
 those tiles which are currently in place and the tiles of the cubie that are currently being 
 positioned. 
  
 Initially all of the arguments of this third cube are variables. This structure will unify with 
 any cube. As pieces are put in place, the variables representing tiles of the criteria cube are 
 unified with the corresponding tiles of the solved cube. In this case, the criteria cube will 
 only unify with a cube that has those corresponding tiles in place. 
  
 Building Expert Systems in Prolog
  
 143",NA
12.6 The Search ,"Now that we have a plan of attack on the cube, and a means of representing the current 
 state, and the criteria for testing if a given piece is in place, we can institute a very fast 
 search routine. The core routine to the Rubik's cube program is a predicate 
 rotate/3
 . It is 
 called: 
  
 rotate(Moves, State, Crit). 
  
 The variable 
 Moves
  is unbound at calling, and contains the list of moves necessary to 
 position the piece after the search has succeeded. 
 State
  is the current state of the cube, and 
 Crit
  is the criteria for this stage of the solution. 
 Crit
  has all of the pieces found so far 
 bound, as well as the one additional piece for this search. 
 rotate/3
  searches for a sequence 
 of moves which will put the new piece in place without disturbing the existing pieces. 
  
 The
  rotate/3
  predicate illustrates the tremendous power and compactness of Prolog code. 
 At the same time it illustrates the difficulty of understanding some Prolog code. Prolog's 
 power derives from the built in backtracking execution and unification. Both of these 
 features help to eliminate many of the standard programming structures normally used. 
 Thus, a predicate like 
 rotate/3
  has a fraction of the code it would take in another language 
 (and executes fast as well), but it requires a good understanding of the underlying execution 
 behavior of Prolog to understand it. 
  
 rotate([], State, State). 
  
 rotate(Moves, State, Crit):- 
  
  rotate(PriorMoves, State, NextState),  
  
  get_move(ThisMove, NextState, Crit),  
  
  append(PriorMoves, [ThisMove], Moves). 
  
 The 
 rotate/3
  predicate does a breadth first search as can be seen by the fact that it calls 
 itself recursively before it calls the move generation predicate 
 get_move/3
 . Since the 
 application of moves and testing is so fast, and the depth of search is never great, 
 intermediate results are not saved as in a normal breadth first search. Instead, they are just 
 recalculated each time. 
  
 The
  append/3
  predicate can be used to build lists. In this case it takes 
 ThisMove
  and 
 appends it to the end of the list 
 PriorMoves
 , generating a new list, 
 Moves
 . 
  
 The candidate moves for a given stage are stored in a predicate 
 cand/1
  (the actual program 
 is a little more complex) which is maintained by the 
 stage/1
  predicate. For stage one, it 
 would look like: 
  
 cand(r). 
  
 cand(u). 
  
 cand(f). 
  
 The
  get_move/3
  predicate is called with 
 Move
  unbound, and the second and third 
 arguments bound to the current state and criteria respectively. If the call to 
 move/3
  fails 
 (because it does not rotate the cube into a position which unifies with the criteria), then 
 cand/1
  backtracks generating another possible move. When all of the positive moves fail, 
 then 
 get_move/3
  tries again with negative moves. 
  
 144 
  
 Chapter 12 - Rubik's Cube",NA
12.7 More Heuristics ,"The program, as described so far, almost works. However, it turns out there are a few 
 situations that will cause the search routines to dig too deep for a solution. These situations 
 drastically affect the performance. 
  
 It was necessary to add more intelligence to the program to recognize situations that will 
 not be easily unscrambled by the search routine, and to correct them before calling 
 rotate/3
 . 
  
 One of the problems occurs when positioning pieces on the left side. If the piece to be 
 positioned is currently on the right side, then a few simple moves will put it in place on the 
 left side. However, if the piece is already on the left side, but in the wrong position, then it 
 will have to be moved to the right and back to the left. This longer sequence of moves takes 
 longer to search for, so one of the extra heuristics looks for this situation. 
  
 The heuristics analyze the cube, test for this condition, and blindly move the piece to the 
 right if it occurs. Then the normal search routine gets it back into its proper place. There 
 are a couple of situations like this that are covered by the heuristics. 
  
 It is tempting to think of adding more and more of these heuristics to straighten out the 
 cube with less searching. There is a trade-off, however, and that is it takes time to apply 
 the heuristics, and the search routine is relatively fast. So a heuristic is only worthwhile 
 when the search is slow. The program may be improved by additional heuristics, but the 
 search will still be the core of the program.",NA
12.8 User Interface ,"A graphical representation of the cube is used to display the progress of the program. A 
 window is kept for recording all of the moves used so far. 
  
 Building Expert Systems in Prolog
  
 145",NA
12.9 On the Limits of Machines ,"I don't mind saying that I was pretty proud of myself for writing this program. It was one 
 of my better hacks. At the time, I had a neighbor who was 12 years old and who had just 
 gotten a computer. He loved it and used to come over to my house to hang out with 
 someone who actually got paid for playing with these things. 
  
 I had finished an early version of the cube program and decided to knock his socks off. I 
 said, look at this, and ran the program. On my PC-XT it solved a randomly scrambled cube 
 in about three minutes. I looked at him and waited for his awed response — there was 
 nothing. I asked him what he thought. He said he wasn't impressed, his best time was 45 
 seconds!",NA
Exercises ,"12.1 Improve the speed of the program by experimenting with more heuristics and more 
 canned move sequences. Try to find the optimal balance between the powerful 
 heuristics and sequences and the time it takes to search for them. 
  
 12.2 Experiment with a version of the cube program, which when given the goal of 
 replacing two pieces without disturbing the others, can ""discover"" a sequence and 
 remember it for future use. 
  
 146 
  
 Chapter 12 - Rubik's Cube",NA
Appendices - Full Source Code ,"Building Expert Systems in Prolog
  
 147",NA
A Native ,NA,NA
Birds Knowledgebase (birds.nkb) ,"% BIRDS.NKB - a sample bird identification system for use with the 
 % Native shell. 
  
 % top_goal where Native starts the inference. 
  
 top_goal(X) :- 
  
  
  bird(X). 
  
 order(tubenose) :- 
  
  nostrils(external_tubular), 
  
  live(at_sea), 
  
  bill(hooked). 
  
 order(waterfowl) :- 
  
  feet(webbed), 
  
  bill(flat). 
  
 order(falconiforms) :- 
  
  eats(meat), 
  
  feet(curved_talons), 
  
  bill(sharp_hooked). 
  
 order(passerformes) :- 
  
  
  feet(one_long_backward_toe). 
  
 family(albatross) :- 
  
  order(tubenose), 
  
  size(large), 
  
  wings(long_narrow). 
  
 family(swan) :- 
  
  order(waterfowl), 
  
  neck(long), 
  
  color(white), 
  
  flight(ponderous). 
  
 family(goose) :- 
  
  order(waterfowl), 
  
  size(plump), 
  
  flight(powerful). 
  
 family(duck) :- 
  
  order(waterfowl), 
  
  feed(on_water_surface), 
  
  flight(agile). 
  
 family(vulture) :- 
  
  order(falconiforms), 
  
  feed(scavange), 
  
  wings(broad). 
  
 family(falcon) :- 
  
  order(falconiforms), 
  
  wings(long_pointed), 
  
  head(large), 
  
  tail(narrow_at_tip). 
  
 family(flycatcher) :- 
  
  order(passerformes), 
  
  bill(flat), 
  
  eats(flying_insects). 
  
 family(swallow) :- 
  
  order(passerformes), 
  
  wings(long_pointed), 
  
  tail(forked), 
  
  bill(short). 
  
 Building Expert Systems in Prolog
  
 149",NA
Native Shell (native.pro) ,"% Native - a simple shell for use with Prolog 
 % knowledge bases. It includes explanations. 
  
 :-op(900,xfy, :). 
  
 main :- 
  
  greeting, 
  
  repeat, 
  
  write('> '), 
  
  read(X), 
  
  do(X), 
  
  X == quit. 
  
 greeting :- 
  
  write('This is the native Prolog shell.'), nl,  
 native_help. 
  
 do(help) :- 
  
  native_help, 
  
  !. 
  
 do(load) :- 
  
  load_kb, 
  
  !. 
  
 do(solve) :- 
  
  solve, 
  
  !. 
  
 do(how(Goal)) :- 
  
  how(Goal), 
  
  !. 
  
 do(whynot(Goal)) :- 
  
  whynot(Goal), 
  
  !. 
  
 do(quit). 
  
 do(X) :- 
  
  write(X), 
  
  write(' is not a legal command.'), nl, 
  
  fail. 
  
 native_help :- 
  
  write('Type help. load. solve. how(Goal). whynot(Goal). or quit.'), nl,  
 write('at the prompt.'), nl. 
  
 load_kb :- 
  
  write('Enter file name in single quotes (ex. ''birds.nkb''.): '),  
 read(F), 
  
  reconsult(F). 
  
 solve :- 
  
  abolish(known,3), 
  
  prove(top_goal(X),[]), 
  
  write('The answer is '), write(X), nl. 
  
 solve :- 
  
  
  write('No answer found.'), nl. 
  
 ask(Attribute,Value,_) :- 
  
  
  known(yes,Attribute,Value),  % succeed if we know its true 
  
  !.                           % and dont look any further 
 ask(Attribute,Value,_) :- 
  
 Building Expert Systems in Prolog 
  
 153",NA
B Clam ,NA,NA
Car Knowledgebase (car.ckb) ,"goal problem. 
  
 rule 1 
  
  
  if not turn_over and 
  
   
  battery_bad 
  
  
  then problem is battery cf 100. 
  
 rule 2 
  
  if lights_weak 
  
  then battery_bad cf 50. 
  
 rule 3 
  
  if radio_weak 
  
  then battery_bad cf 50. 
  
 rule 4 
  
  if turn_over and 
  
   
  smell_gas 
  
  
  then problem is flooded cf 80. 
  
 rule 5 
  
  
  if turn_over and 
  
   
  gas_gauge is empty 
  
  
  then problem is out_of_gas cf 90. 
  
 rule 6 
  
  
  if turn_over and 
  
   
  gas_gauge is low 
  
  
  then problem is out_of_gas cf 30. 
  
 output problem is battery get the battery recharged. 
  
 output problem is out_of_gas start walking or hitching to a gas station. 
 output problem is flooded wait 5 minutes and try again. 
  
 ask turn_over 
  
  menu (yes no) 
  
  prompt 'Does the engine turn over?'. 
  
 ask 
 lights_weak 
  
  menu 
 (yes 
 no) 
  
  prompt 'Are the lights weak?'. 
  
 ask radio_weak 
  
  menu (yes no) 
  
  prompt 'Is the radio weak?'. 
  
 ask smell_gas 
  
  menu (yes no) 
  
  prompt 'Do you smell gas?'. 
  
 ask gas_gauge 
  
  menu (empty low full) 
  
  prompt 'What does the gas gauge say?'. 
  
 Building Expert Systems in Prolog
  
 157",NA
Birds Knowledgebase (birds.ckb) ,"goal bird. 
  
 rule 1 
  
  
  if   nostrils is external_tubular and 
  
   
  live is at_sea and 
  
   
  bill is hooked 
  
  
  then order is tubenose cf 80. 
  
 rule 2 
  
  
  if   feet is webbed and 
  
   
  bill is flat 
  
  
  then order is waterfowl cf 80. 
  
 rule 3 
  
  
  if   eats is meat and 
  
   
  feet is curved_talons and 
  
   
  bill is sharp_hooked 
  
  
  then order is falconiforms cf 80. 
  
 rule 4 
  
  if   feet is one_long_backward_toe 
  
  then order is passerformes cf 80. 
  
 rule 5 
  
  
  if   order is tubenose and 
  
   
  size is large and 
  
   
  wings is long_narrow 
  
  
  then family is albatross cf 80. 
  
 rule 6 
  
  
  if   order is waterfowl and 
  
   
  neck is long and 
  
   
  color is white and 
  
   
  flight is ponderous 
  
  
  then family is swan cf 80. 
  
 rule 7 
  
  
  if   order is waterfowl and 
  
   
  size is plump and 
  
   
  flight is powerful 
  
  
  then family is goose cf 80. 
  
 rule 8 
  
  
  if   order is waterfowl and 
  
   
  feed is on_water_surface and 
  
   
  flight is agile 
  
  
  then family is duck cf 80. 
  
 rule 9 
  
  
  if   order is falconiforms and 
  
   
  feed is scavange and 
  
   
  wings is broad 
  
  
  then family is vulture cf 80. 
  
 rule 10 
  
  
  if   order is falconiforms and 
  
   
  wings is long_pointed and 
  
   
  head is large and 
  
   
  tail is narrow_at_tip 
  
  
  then family is falcon cf 80. 
  
 rule 11 
  
  
  if   order is passerformes and 
  
   
  bill is flat and 
  
   
  eats is flying_insects 
  
 158
  
 Appendices - Full Source Code",NA
Clam Shell (clam.pro) ,"% Clam - expert system shell with EMYCIN type certainty factors 
  
 % This system is an imitation of the EMYCIN imitators. It does backward % 
 chaininging (goal directed) inference with uncertainty. The uncertainty % 
 is modelled using the MYCIN certainty factors. 
  
 % The only data structure is an attribute:value pair. 
  
 % NOTE - CF calculation in update only good for positive CF 
  
 main :- 
  
  do_over, 
  
  super. 
  
 % The main command loop 
  
 super :- 
  
  
  repeat, 
  
   
  write('consult  restart  load  list  trace on/off  how  exit'), nl, 
   
  write('> '), 
  
   
  read_line([X|Y]), 
  
   
  doit([X|Y]), 
  
  
  X == exit. 
  
 doit([consult]) :- 
  
  top_goals, 
  
  !. 
  
 doit([restart]) :- 
  
  do_over, 
  
  !. 
  
 doit([load]) :- 
  
  load_rules, 
  
  !. 
  
 doit([list]) :- 
  
  list_facts, 
  
  !. 
  
 doit([trace,X]) :- 
  
  set_trace(X), 
  
  !. 
  
 doit([how|Y]) :- 
  
  how(Y), 
  
  !. 
  
 doit([exit]). 
  
 doit([X|Y]) :- 
  
  write('invalid command : '), 
  
  write([X|Y]), nl. 
  
 % top_goals works through each of the goals in sequence 
  
 top_goals :- 
  
  ghoul(Attr), 
  
  top(Attr), 
  
  print_goal(Attr), 
  
  fail. 
  
 top_goals. 
  
 % top starts the backward chaining by looking for rules that reference % the 
 attribute in the RHS.  If it is known with certainty 100, then % no other 
 rules are tried, and other candidates are eliminated.  Otherwise % other 
 rules which might yield different values for the attribute 
  
 Building Expert Systems in Prolog
  
 163",NA
Build Rules (bldrules.pro) ,"% build rules use dcg in reverse to make clam rules from Prolog rules 
 % You can use bldrules.pro to convert, for example, the native Prolog 
 % rules of the birds.pro into clam syntax. 
  
 main :- 
  
  write($From file: $), read(From), 
  
  write($To file: $), read(To), 
  
  doit(From,To). 
  
 doit(From,To) :- 
  
  see(From), 
  
  tell(To), 
  
  test. 
  
 test :- 
  
  
  cntr_set(1,1), 
  
  
  repeat, 
  
   
  read(X), 
  
   
  tran(X,Ans,[]), 
  
   
  write_nice(Ans), nl, 
  
  
  X == '!EOF'. 
  
 test 
 :- 
  
  told, 
  
  seen, 
  
  write(done). 
  
 xxif(Body) --> 
  
  [if], 
  
  xxbody(Body). 
  
 xxthen(Head) --> 
  
  {Head =.. [F,A]}, 
  
  [then,F,is,A]. 
  
 xxbody((H,T)) --> 
  
  {!,H =.. [F,A]}, 
  
  [F,is,A,and], 
  
  xxbody(T). 
  
 xxbody(H) --> 
  
  {H =.. [F,A]}, 
  
  [F,is,A]. 
  
 tran(A,B,C) :- 
  
  trans(A,B,C), 
  
  !. 
  
 tran(X,X,_). 
  
 trans('!EOF','!EOF',_). 
  
 trans((Head :- true)) --> 
  
  {Head =.. [F,A]}, 
  
  [F,is,A], 
  
  !. 
  
 trans((Head :- Body)) --> 
  
  {cntr_get(1,ID)}, 
  
  [rule, ID], 
  
  xxif(Body), 
  
 Building Expert Systems in Prolog
  
 176",NA
C Oops ,NA,NA
Room Knowledgebase (room.okb) ,"% ROOM is an expert system for placing furniture in a living room. 
  
 % It is written using the OOPS production system rules language. 
  
 % It is only designed to illustrate the use of a forward chaining % 
 rules based language for solving configuration problems. As such % 
 it makes many simplifying assumptions (such as furniture has no % 
 width). It just decides which wall each item goes on, and does % 
 not decide the relative placement on the wall. 
  
 % Furniture to be placed in the room is stored in terms of the form % 
 ""furniture(item,length)"". The rules look for unplaced furniture, % and 
 if found attempt to place it according to the rules of thumb. % Once 
 placed, the available space on a wall is updated, the furniture % is ed 
 on a wall with a term of the form ""position(item,wall)"", % and the 
 original ""furniture"" term is removed. 
  
 % These are the terms which are initially stored in working storage. 
 % They set a goal used to force firing of certain preliminary rules, 
 % and various facts about the problem domain used by the actual % 
 configuration rules. 
  
 initial_data([goal(place_furniture), 
  
  
  not_end_yet, 
  
  
  legal_furniture([couch, chair, table_lamp, end_table, 
  
  
  coffee_table, tv, standing_lamp, end]), 
  
  
 opposite(north,south), 
  
  
  opposite(south,north), 
  
  
  opposite(east,west), 
  
  
  opposite(west,east), 
  
  
  right(north,west), 
  
  
  right(west,south), 
  
  
  right(south,east), 
  
  
  right(east,north), 
  
  
  left(north,east), 
  
  
  left(east,south), 
  
  
  left(south,west), 
  
  
  left(west,north)]). 
  
 % Rules 1-8 are an example of how to generate procedural behavior % 
 from a non-procedural rule language. These rules force a series % of 
 prompts and gather data from the user on the room and furniture % to 
 be configured. They are included to illustrate the kludgy % nature of 
 production systems in a conventional setting. 
  
 % This is in contrast to rules f1-f14 which elegantly configure the room. 
  
 rule 1: 
  
  
  [1: goal(place_furniture),     % The initial goal causes a rule to 
  
  
  2: legal_furniture(LF)]       % to fire with introductory information.  
 ==>                             % It will set a new goal. 
  
  [retract(1), 
  
  nl, 
  
  write('Enter a single item of furniture at each prompt.'),nl,  
 write('Include the width (in feet) of each item.'),nl, 
  
  write('The format is Item:Length.'),nl,nl, 
  
  write('The legal values are:'),nl, 
  
  write(LF),nl,nl, 
  
 Building Expert Systems in Prolog
  
 179",NA
Animal Knowledgebase (animal.okb) ,"% from Winston & Horn's LISP 
  
 % Rules for animal identification. The first three rules are an % 
 input loop. Enter attributes that match the patterns in the rules. 
  
 % For example: has(robie,hair), or lays_eggs(suzie). These facts will % 
 help identify robie and suzie. Enter ""end"" to end the input loop. 
  
 % 
  
 % The attributes can also be put in the list of initial_data. 
  
 % Example: 
  
 % 
  
 %   initial_data([has(dennis,hair), 
  
 %                 has(dennis,hoofs), 
  
 %                 has(dennis,black_stripes), 
  
 %                 parent(dennis,diana) 
  
 %                ] 
  
 %               ). 
  
 % 
  
 % This should lead to the identification of dennis and diana as zebras. 
  
 initial_data([goal(animal_id)]). 
  
 rule 1: 
  
  
  [1: goal(animal_id)] 
  
  
  ==> 
  
  
  [assert(read_facts), 
  
   
  retract(1)]. 
  
 rule 2: 
  
  
  [1: end, 
  
   
  2: read_facts] 
  
  
  ==> 
  
  
  [retract(all)]. 
  
 rule 3: 
  
  
  [1: read_facts] 
  
  
  ==> 
  
  
  [prompt('Attribute ? ',X), 
  
   
  assert(X)]. 
  
 rule id1: 
  
  
  [1: has(X,hair)] 
  
  
  ==> 
  
  
  [assert(isa(X,mammal)), 
  
   
  retract(all)]. 
  
 rule id2: 
  
  
  [1: gives(X,milk)] 
  
  
  ==> 
  
  
  [assert(isa(X,mammal)), 
  
   
  retract(all)]. 
  
 rule id3: 
  
  
  [1: has(X,feathers)] 
  
  
  ==> 
  
  
  [assert(isa(X,bird)), 
  
   
  retract(all)]. 
  
 184 
  
 Appendices - Full Source Code",NA
Oops Interpreter (oops.pro) ,"% OOPS2 - A toy production system interpreter. It uses a forward chaining, 
 %         data driven, rule based approach for expert system development. 
  
 % 
  
 % Version 2, the simplest version without LEX, MEA, or conflict sets 
 % 
  
 % author Dennis Merritt 
  
 % Copyright (c) Dennis Merritt, 1986 
  
 % operator definitions 
  
 :-op(800,xfx,==>).          % used to separate LHS and RHS of rule :-
 op(500,xfy,:).            % used to separate attributes and values :-
 op(810,fx,rule).          % used to define rule 
  
 :-op(700,xfy,#).            % used for unification instead of = 
  
 main :- 
  
  welcome, 
  
  supervisor. 
  
 welcome  :- 
  
  nl, nl, 
  
  write($         OOPS - A Toy Production System$), nl, nl, 
  
  write($This is an interpreter for files containing rules coded in the$), nl,  
 write($OOPS format.$), nl, nl, 
  
  write($The => prompt accepts three commands:$), nl, nl, 
  
  write($   load. -  prompts for name of rules file$), nl, 
  
  write($            enclose in single quotes$), nl, 
  
  write($   list. -  lists working memory$), nl, 
  
  write($   go.   -  starts the inference$), nl, 
  
  write($   exit. -  does what you'd expect$), nl, nl. 
  
 % the supervisor, uses a repeat fail loop to read and process commands 
 % from the user 
  
 supervisor :- 
  
  
  repeat, 
  
   
  write('=>'), 
  
   
  read(X), 
  
 %    write(echo1-X), 
  
   
  doit(X), 
  
 %    write(echo2-X), 
  
  
  X = exit. 
  
 doit(X) :- 
  
  
  do(X). 
  
 % actions to take based on commands 
  
 do(exit) :- 
  
  
  !. 
  
 do(go) :- 
  
  initialize, 
  
  go, 
  
  !. 
  
 do(load) :- 
  
  load, 
  
  !. 
  
 do(list) :- 
  
  
  lst,       % lists all of working storage 
  
 Building Expert Systems in Prolog
  
 187",NA
D Foops ,NA,NA
Room Knowledgebase (room.fkb) ,"% ROOM.FKB - a version of the room knowledge base for FOOPS.  Much of the % 
 knowledge about furniture is stored in frames, thus simplifying 
  
 % the rule portion of the knowledge base. 
  
 frame(furniture, [ 
  
 legal_types - [val [couch,chair,coffee_table,end_table,standing_lamp, 
  
 table_lamp,tv,knickknack]], 
  
 position - [def none, add pos_add], 
  
 length - [def 3], 
  
 place_on - [def floor], 
  
 can_hold - [def 0]]). 
  
 frame(couch, [ 
  
 ako - [val furniture], 
  
 length - [def 6]]). 
  
 frame(chair, [ 
  
 ako - [val furniture], 
  
 length - [def 3]]). 
  
 % A table is different from most furniture in that it can hold things % 
 on it. 
  
 frame(table, [ 
  
 ako - [val furniture], 
  
 space - [def 4], 
  
 length - [def 4], 
  
 can_support - [def yes], 
  
 holding - [def []]]). 
  
 frame(end_table, [ 
  
 ako - [val table], 
  
 length - [def 2]]). 
  
 frame(coffee_table, [ 
  
 ako - [val table], 
  
 length - [def 4]]). 
  
 % electric is used as a super class for anything electrical.  It contains % 
 the defaults for those attributes unique to electrical things. 
  
 frame(electric, [ 
  
 needs_outlet - [def yes]]). 
  
 frame(lamp, [ 
  
 ako - [val [furniture, electric]]]). 
  
 frame(standing_lamp, [ 
  
 ako - [val lamp]]). 
  
 frame(table_lamp, [ 
  
 ako - [val lamp], 
  
 place_on - [def table]]). 
  
 frame(tv, [ 
  
 ako - [val [furniture, electric]], 
  
 place_on - [calc tv_support]]). 
  
 Building Expert Systems in Prolog
  
 193",NA
Foops (foops.pro) ,"% FOOPS.PRO - an integration of frames, forward chaining with LEX and MEA, 
 % and Prolog. 
  
 % Copyright (c) Dennis Merritt, 1986 - Permission granted for % 
 non-commercial use 
  
 % The first section of the code contains the basic OOPS code, the % 
 second section contains the FRAMES code. 
  
 % OPERATOR DEFINITIONS 
  
 :-op(800,xfx,==>).          % used to separate LHS and RHS of rule :-
 op(500,xfy,:).            % used to separate attributes and values :-
 op(810,fx,rule).          % used to define rule 
  
 :-op(700,xfy,#).            % used for unification instead of = :-
 op(700,xfy,\=).           % not equal 
  
 :-op(600,xfy,with).         % used for frame instances in rules 
  
 main :- 
  
  welcome, 
  
  supervisor. 
  
 welcome  :- 
  
  write($FOOPS - A Toy Production System$),nl,nl, 
  
  write($This is an interpreter for files containing rules coded in the$),nl,  
 write($FOOPS format.$), nl, nl, 
  
  write($The => prompt accepts four commands:$), nl, nl, 
  
  write($   load. -  prompts for name of rules file$), nl, 
  
  write($            enclose in single quotes$), nl, 
  
  write($   go.   -  starts the inference$), nl, 
  
  write($   list. -  list working memory$), nl, 
  
  write($   exit. -  does what you'd expect$), nl, nl. 
  
 % THE SUPERVISOR, USES A REPEAT FAIL LOOP TO READ AND PROCESS COMMANDS 
 % FROM THE USER 
  
 supervisor :- 
  
  repeat, 
  
  write('=>'), 
  
  read(X), 
  
  doit(X), 
  
  X = exit. 
  
 doit(X) :- do(X). 
  
 % ACTIONS TO TAKE BASED ON COMMANDS 
  
 do(exit) :- !. 
  
 do(go) :- 
  
  initialize, 
  
  timer(T1), 
  
  go, 
  
  timer(T2), 
  
  T is 10 * (T2 - T1), 
  
  write(time-T), nl, !. 
  
 do(load) :- load, !. 
  
 do(list) :- lst, !.       % lists all of working storage 
 do(list(X)) :- lst(X), !. % lists all which match the pattern 
 do(_) :- write('invalid command'), nl. 
  
 200 
  
 Appendices - Full Source Code",NA
E Rete-Foops ,NA,NA
Room Knowledgebase (room.rkb) ,"% ROOM.RKB - a version of ROOM for use with RETE-FOOPS. 
  
 frame(furniture, [legal_types - [val [couch,chair,coffee_table,end_table, 
  
  
  
   
  standing_lamp,table_lamp,tv,knickknack] 
  
  
  
  
  ], 
  
  
  
  
  position - [def none, add pos_add], 
  
  
  
  
  length - [def 3], 
  
  
  
  
  place_on - [def floor], 
  
  
  
  
  can_hold - [def 0] 
  
  
  
  ] 
  
  ). 
  
 frame(couch, [ako - [val furniture], 
  
  
  
  
  length - [def 6] 
  
  
  
  ] 
  
  ). 
  
 frame(chair, [ako - [val furniture], 
  
  
  
  
  length - [def 3] 
  
  
  
  ] 
  
  ). 
  
 % A table is different from most furniture in that it can hold things % 
 on it. 
  
 frame(table, [ako - [val furniture], 
  
  
  
  
  space - [def 4], 
  
  
  
  
  length - [def 4], 
  
  
  
  
  can_support - [def yes], 
  
  
  
  
  holding - [def []] 
  
  
  
  ] 
  
  ). 
  
 frame(end_table, [ako - [val table], 
  
  
  
  
  length - [def 2] 
  
  
  
  ] 
  
  ). 
  
 frame(coffee_table, [ako - [val table], 
  
  
  
  
  length - [def 4] 
  
  
  
  ] 
  
  ). 
  
 % electric is used as a super class for anything electrical.  It contains % 
 the defaults for those attributes unique to electrical things. 
  
 frame(electric, [needs_outlet - [def yes]]). 
  
 frame(lamp, [ako - [val [furniture, electric]]]). 
  
 frame(standing_lamp, [ako - [val lamp]]). 
  
 Building Expert Systems in Prolog
  
 211",NA
Rete Compiler (retepred.pro) ,"% RETEPRED.PRO - the predicates that implement the Rete pattern 
 %                matching algorithm. 
  
 % It should be modified some day to use pointers to working memory in 
 % the memory predicates rather than the full tokens - this would save 
 % a lot of space. 
  
 % retecomp - compile rules into a rete network 
  
 :-op(800,xfx,==>).         % used to separate LHS and RHS of rule :-
 op(500,xfy,#).           % used to separate attributes and values :-
 op(810,fx,rule).         % used to define rule 
  
 :-op(700,xfy,#).           % used for unification instead of = :-
 op(700,xfy,\=).          % not equal 
  
 :-op(600,xfy,with).        % used for frame instances in rules 
  
 rete_compile :- 
  
  abolish(root,3), 
  
  abolish(bi,4), 
  
  abolish(tes,4), 
  
  abolish(rul,3), 
  
  abolish(varg,1), 
  
  abolish(nid,1), 
  
  asserta(nid(0)), 
  
  rete_compil. 
  
 %  display_net. 
  
 display_net :- 
  
  display_roots,nl, 
  
  display_bis,nl, 
  
  display_teses,nl, 
  
  display_ruls. 
  
 display_roots :- 
  
  root(N,A,B), 
  
  write( root(N,A,B) ), nl, 
  
  fail. 
  
 display_roots. 
  
 display_bis :- 
  
  bi(A,B,C,D), 
  
  write(bi(A)), nl, 
  
  write_list([left|B]), 
  
  write_list([right|C]), 
  
  write(D), nl, nl, 
  
  fail. 
  
 display_bis. 
  
 display_teses :- 
  
  tes(A,B,C,D), 
  
  write(tes(A)), nl, 
  
  write_list([left|B]), 
  
  write_list([right|C]), nl, 
  
  write(D), nl, nl, 
  
  fail. 
  
 display_teses. 
  
 display_ruls :- 
  
  
  rul(A,B,C), 
  
 Building Expert Systems in Prolog
  
 218",NA
Rete Runtime (retefoop.pro) ,"% RETEFOOP.PRO - forward chaining, frames, and Rete algorithm, also using %               
 LEX and MEA to sort the conflict set. 
  
 % 
  
 % Copyright (c) Dennis Merritt, 1988 
  
 % operator definitions 
  
 :-op(800,xfx,==>).          % used to separate LHS and RHS of rule :-
 op(500,xfy,#).            % used to separate attributes and values :-
 op(810,fx,rule).          % used to define rule 
  
 :-op(700,xfy,#).            % used for unification instead of = :-
 op(700,xfy,\=).           % not equal 
  
 :-op(600,xfy,with).         % used for frame instances in rules 
  
 main :- welcome, supervisor. 
  
 welcome  :- 
  
  write($         RETEFOOP - A Toy Production System$), nl, nl, 
  
  write($This is an interpreter for files containing rules coded in the$), nl,  
 write($FOOPS format.$), nl, nl, 
  
  write($The => prompt accepts three commands:$), nl, nl, 
  
  write($   load.       - prompts for name of rules file$), nl, 
  
  write($                 enclose in single quotes$), nl, 
  
  write($   compile.    - compiles rules into a rete net$), nl, 
  
  write($   displaynet. - displays the rete net$), nl, 
  
  write($   list.       - lists stuff$), nl, 
  
  write($   list(X).    - lists things which match X$), nl, 
  
  write($   options.    - allows setting of message levels$), nl, 
  
  write($   go.         -  starts the inference$), nl, 
  
  write($   exit.       - does what you'd expect$), nl, nl. 
  
 % the supervisor, uses a repeat fail loop to read and process commands 
 % from the user 
  
 supervisor :- 
  
  repeat, 
  
  write('=>'), 
  
  read(X), 
  
  doit(X), 
  
  X = exit. 
  
 doit(X) :- 
  
  timer(T1), 
  
  do(X), 
  
  timer(T2), 
  
  T is (T2 - T1) / 600, 
  
  message(101,T), 
  
  !. 
  
 % actions to take based on commands 
  
 do(exit) :- !. 
  
 do(go) :- 
  
  initialize, 
  
  go, 
  
  !. 
  
 do(load) :- 
  
  load, 
  
  !. 
  
 Building Expert Systems in Prolog
  
 225",NA
F Windows ,NA,NA
Windows Demonstration (windemo.pro) ,"% WINDEMO.PRO - demonstrates how to use windows 
  
 :- module windemo. 
  
 :- public main/0, restart/0. 
  
 :- extrn window/2:far, window/3:far. 
  
 main:- 
  
  cls, 
  
  go. 
  
 restart:- 
  
  
  halt. 
  
 go:- 
  
  
  create_windows, 
  
  
  ctr_set(1,1),            % used by list2 
  
  
  ctr_set(3,1),            % used by dummy 
  
  
  repeat, 
  
   
  window(wmain,read,X), 
  
   
  do(X), 
  
  
  fail. 
  
 create_windows:- 
  
  
  window(wform, create, 
  
   
  
  [type(form), 
  
   
  
  coord(8,20,16,53), 
  
   
  
  title(' Form not Function '), 
  
   
  
  border(white:magenta),contents(white:magenta), 
  
   
  form([lit(2:5,'First'), 
  
   
    
   
  var(one,2:20,8,''), 
  
   
    
   
  lit(4:5,'Second'), 
  
   
    
   
  var(two,4:20,8,'two'), 
  
   
    
   
  lit(6:5,'Third'), 
  
   
    
   
  var(three,6:20,8,'') 
  
   
    
  
  ] 
  
   
    
  ) 
  
   
  
  ] 
  
   
  ), 
  
  
  window(wform2, create, 
  
   
  
  [type(form), 
  
   
  
  coord(12,24,14,49), 
  
   
  
  title(' Form two '), 
  
   
  
  border(white:green),contents(white:green), 
  
   
  form([lit(2:3,'First and Last'), 
  
   
    
   
  var(three,2:20,8,'') 
  
   
    
  
  ] 
  
   
    
  ) 
  
   
  
  ] 
  
   
  ), 
  
  
  window(wprompt, create, 
  
   
  
  [type(prompt), 
  
   
  
  coord(18,10,18,70), 
  
   
  
  border(black:green), 
  
 Building Expert Systems in Prolog
  
 239",NA
Windows (windows.pro) ,"% WINDOWS.PRO - Windowing predicates, written for an old version 
 % of Arity Prolog.  While not operational at this time, they do % 
 illustrate the power of Prolog for systems type work. 
  
 :- module windows. 
  
 :- segment(ijseg2). 
  
 :- public window/2, window/3. 
  
 :- public showcurse/0, hidecurse/0. 
  
 :- default(invisible). 
  
 :- extrn curtype/2:asm.    % sets the cursor, can be replaced with: 
  
 showcurse:- 
  
  
  curtype(7,8). 
  
 hidecurse:- 
  
  
  curtype(39,40).  
  
 %*********************************************************** 
  
 % 
  
 % window/3 is the main predicate.  The windowing system is organized % 
 at the top in an object oriented fashon.  The window/3 arguments are: %    
 arg1 - operation (message) 
  
 %    arg2 - window (the object) 
  
 %    arg3 - parameters (input or output - either a singleton or a list 
  
 % The objects can be one of four types of window - 
  
 %    display, menu, form, prompt 
  
 % 
  
 %*********************************************************** 
  
 :- mode window(+,+). 
  
 window(W, Op):- 
  
  
  window(W, Op, []). 
  
 :- mode window(+,+,?). 
  
 window([H|T], Op, Args):- 
  
  window(temp_w, create, [H|T]), 
  
  window(temp_w, Op, Args), 
  
  window(temp_w, delete), 
  
  !. 
  
 window(W, Op, Args):- 
  
  get_type(W, T), 
  
  find_proc(T, Op, Proc), 
  
  doproc(Proc, W, Args), 
  
  !. 
  
 % get_type/2 figures out what type of window we have 
  
 :- mode get_type(+,-). 
  
 get_type(W, X):- 
  
  select_parm(W, [type(X)]), 
  
  !. 
  
 get_type(W, window).  % W is currently undefined 
  
 Building Expert Systems in Prolog
  
 243",NA
G Rubik ,NA,NA
Cube Solver (rubik.pro) ,"% RUBIK.PRO 
  
 % CUBE SOLVER II 
  
 %   A Rubik's Cube Solver 
  
 %   written by Dennis Merritt 
  
 %   as described in Building Expert Systems in Prolog (Springer-Verlag) 
 %   available from: 
  
 %     Amzi! inc. 
  
 %     40 Samuel Prescott Dr. 
  
 %     Stow, MA 01775 USA 
  
 %     Tel 508/897-7332, FAX 508/897-2784 
  
 %     e-mail amzi@world.std.com 
  
 % 
  
 %  This program may be copied, modified and redistributed although proper %  
 acknowledgement is appreciated. 
  
 % 
  
 %  This implementation was done with Cogent Prolog, also available 
 %  from Amzi! inc. 
  
 % 
  
 %  This is the main module which contains the predicates for 
 %         the main control loop, 
  
 %         manual mode, 
  
 %         solve mode, and 
  
 %         utility functions. 
  
 % 
  
 % Note - The Cogent/Prolog compiler supports modules.  The export declarations 
 %        are for predicates defined in the current module which may be used %        
 by other modules.  The import declarations are for predicates 
  
 %        defined in other modules. 
  
 :-export main/0. 
  
 :-export append/3. 
  
 :-export get_flag/2. 
  
 :-export set_flag/2. 
  
 :-export error/1. 
  
 :-export reverse/2. 
  
 :-import add_history/1.     % rubhist 
  
 :-import cnd/2.             % rubdata 
  
 :-import cube_print/1.      % rubdisp 
  
 :-import get_color/1.       % rubedit 
  
 :-import pristine/1.        % rubdata 
  
 :-import rub_help/0.        % rubhelp 
  
 :-import m_disp/1.          % rubdisp 
  
 :-import m_choose/2.        % rubdisp 
  
 :-import move/3.            % rubmov 
  
 :-import orientation/2.     % rubdata 
  
 :-import pln/2.             % rubdata 
  
 :-import rdfield/2.         % rubdisp 
  
 :-import rdchar/2.          % rubdisp 
  
 :-import redit/1.           % rubedit 
  
 :-import rewrite/2.         % rubedit 
  
 :-import rot/3.             % rubmov 
  
 :-import seq/2.             % rubdata 
  
 :-import side_color/1.      % rubdata 
  
 :-import s_r/2.             % rubdata 
  
 :-import vw/2.              % rubdata 
  
 :-import wrfield/2.         % rubdisp 
  
 :-import writec/2.          % rubdisp 
  
 Building Expert Systems in Prolog
  
 273",NA
Cube Display (rubdisp.pro) ,"% RUBDISP.PRO - Copyright (C) 1993, Amziod 
  
 % This file contains the display predicates. 
  
 :-export cube_print/1. 
  
 :-export wrfield/2, rdfield/2, rdchar/2. 
  
 :-export writec/2. 
  
 :-export color/1,color/2,color/3. 
  
 :-export m_disp/1,m_erase/1,m_choose/2. 
  
 :-import 
 error/1. 
  
  
  
  
  
 % 
 rubik 
  
 :-import 
 get_flag/2. 
  
  
 % 
 rubik 
  
 :-import sidecolor/1.  % dynamic database 
  
 :- op(500,xfy,:). 
  
 % cube_print - displays the full color cube. Both variables and %              
 blanks appear as spaces.  unification is again used %              
 to map the input cube to the individual displays 
  
 cube_print(cube(F, R, U, B, L, D, 
  
   
  
  
  V7, V8, V9, V10, V11, V12, V13, V14, V15, V16, V17,  
  
   
  
  V18, V19, V20, V21, V22, V23, V24, V25, V26, V27, 
  
   
  
  V28, V29, V30, V31, V32, V33, V34, V35, V36, V37, 
  
   
  
  V38, V39, V40, V41, V42, V43, V44, V45, V46, V47, 
  
   
  
  V48, V49, V50, V51, V52, V53, V54 
  
   
  
  ) 
  
  
  ) :- 
  
  
  nl, 
  
  
  tab(6),  pc([V28, V45, V22]), 
  
  
  tab(6),  pc([V53, B, V51]), 
  
  
  tab(6),  pc([V25, V43, V19]), 
  
  
  pc([V29, V54, V26, V27, V44, V21, V20, V52, V23]), 
  
  
  pc([V37, L, V35, V36, U, V32, V31, R, V33]), 
  
  
  pc([V17, V50, V14, V15, V40, V9, V8, V48, V11]), 
  
  
  tab(6),  pc([V13, V39, V7]), 
  
  
  tab(6),  pc([V49, F, V47]), 
  
  
  tab(6),  pc([V16, V41, V10]), 
  
  
  tab(6),  pc([V18, V42, V12]), 
  
  
  tab(6),  pc([V38, D, V34]), 
  
  
  tab(6),  pc([V30, V46, V24]), 
  
  
  check_step, 
  
  
  !. 
  
 check_step :- 
  
  get_flag(stepmode, on), 
  
  write($Hit Enter to continue$), 
  
  get0(_). 
  
 check_step. 
  
 pc([]):- 
  
  
  nl. 
  
 pc([V1| V2]):- 
  
  
  sidecolor(V1 - C), 
  
  
  write(C),  tab(1), 
  
 %  write(V1),  tab(1), 
  
  
  pc(V2). 
  
 % wrfield & rdfield - allow input and output to a named field 
  
 286
  
 Appendices - Full Source Code",NA
Cube Entry (rubedit.pro) ,"% RUBEDIT.PRO - Copyright (C) 1994, Amzi! inc. 
  
 % This module allows the user to easily enter a scrambled % 
 cube position.  the cube is displayed in goal form. 
  
 % the cursor keys move from tile to tile, and the f1 key % 
 selects the color for the tile.  repeated hits of f1 
  
 % changes the color.  f1 was chosen since that allows a 
  
 % machine with a pcmouse to do cube editing with the mouse and 
 % and the left button (f1) with no special changes. 
  
 :-export redit/1. 
  
 :-export set_tcolor/1. 
  
 :-export get_color/1. 
  
 :-export rewrite/2. 
  
 :-import cube_print/1.  % rubdisp 
  
 :-import error/1.       % rubik 
  
 :-import ghoul/1.       % rubdata 
  
 :-import wrfield/2.     % rubdisp 
  
 :-import sidecolor/1.   % dynamic database 
  
 redit(Y):- 
  
  ghoul(G), 
  
  cube_print(G), 
  
  write($Enter single letters separated by spaces in the pattern$),  nl,  
 write($of the display.  The letters should represent the colors$),  nl,  
 write($on your cube.  Exact spacing isn't critical.$),  nl, 
  
  read_cube(X),     % read it off the screen 
  
  trans_cube(X,Y),  % change colors to side notation 
  
  cube_print(Y). 
  
 redit(_):- 
  
  error('failing edit'), 
  
  halt. 
  
 % read_cube - reads the edited cube directly from the screen, there was 
 % no need to save information about colors during the cursor movement % 
 stage (""edi"").  it was for this reason that ""change_color"" writes the % 
 letter of the color in the tile. 
  
 % read_cube looks exactly like print_cube, only in reverse 
  
 read_cube(cube(F, R, U, B, L, D, 
  
   
  
  
  V7, V8, V9, V10, V11, V12, V13, V14, V15, V16,  
  
   
  
  V17, V18, V19, V20, V21, V22, V23, V24, V25, V26, 
   
  
  
  V27, V28, V29, V30, V31, V32, V33, V34, V35, V36, 
   
  
  
  V37, V38, V39, V40, V41, V42, V43, V44, V45, V46, 
   
  
  
  V47, V48, V49, V50, V51, V52, V53, V54 
  
   
  
  ) 
  
   
  ):- 
  
  
  rc([V28, V45, V22]), 
  
  
  rc([V53, B, V51]), 
  
  
  rc([V25, V43, V19]), 
  
  
  rc([V29, V54, V26, V27, V44, V21, V20, V52, V23]), 
  
  
  rc([V37, L, V35, V36, U, V32, V31, R, V33]), 
  
  
  rc([V17, V50, V14, V15, V40, V9, V8, V48, V11]), 
  
  
  rc([V13, V39, V7]), 
  
  
  rc([V49, F, V47]), 
  
  
  rc([V16, V41, V10]), 
  
  
  rc([V18, V42, V12]), 
  
  
  rc([V38, D, V34]), 
  
  
  rc([V30, V46, V24]), 
  
  
  !. 
  
 Building Expert Systems in Prolog
  
 289",NA
Move History (rubhist.pro) ,"% RUBHIST.PRO - Copyright (C) 1994, Amzi! inc. 
  
 %  This module records history information so you can unscramble 
 %  a real cube by looking at the log file. 
  
 :-export add_history/1. 
  
 :-import append/3.      % rubik 
  
 :-import attr/2.        % rubdisp 
  
 :-import clr_bottom/0.  % rubik 
  
 :-import error/1.       % rubik 
  
 :-import bug/1.         % rubik 
  
 :-import get_flag/2.    % rubik 
  
 :-import reverse/2.     % rubik 
  
 :-import move/3.        % rubmove 
  
 :-import rot/3.         % rubmove 
  
 :-import seq/2.         % rubdata 
  
 :-import wrfield/2.     % rubdisp 
  
 % add_history takes a list of moves as input.  As output it sends % the 
 expanded version of the moves to the logfile.  That is, sequences % are 
 broken down into primitive moves before being written to the % window 
  
 add_history(V1):- 
  
  expand(V1, V2),       % expand the list 
  
  de_list(V2,V3),       % remove inbedded lists (flatten the list)  
 segment_list(V3,V4),  % break into pieces that fit in window  
 write_hist(V4), 
  
  !. 
  
 add_history(X):- 
  
  
  error([add_history,X]). 
  
 write_hist([]). 
  
 write_hist([FirstLine|Rest]) :- 
  
  write('  Moves: '), 
  
  wr_hist(FirstLine), 
  
  nl, 
  
  write_hist(Rest). 
  
 wr_hist([]). 
  
 wr_hist([H|T]) :- 
  
  tab(2), 
  
  write(H), 
  
  wr_hist(T). 
  
 % expand pushes its way through a list of moves and sequences, making % 
 sequences into other move lists. It takes care to preserve the % meaning 
 of a counterclockwise sequence by reversing the list defining % the 
 sequence. This reverse also changes the sign of each term along % the 
 way. The first argument is the imput list, the second is output 
  
 expand([], []) :- !. 
  
 expand([Term|V3], [Term|V4]):- 
  
  
  moveterm(Term, X),  % strip the sign 
  
  
  (move(X,_,_) 
  
   
  ; 
  
   
  rot(X,_,_)  % its a primitive 
  
  
  ), 
  
  
  !, 
  
 Building Expert Systems in Prolog
  
 291",NA
Moves and Rotations (rubmov.pro) ,"% RUBMOV.PRO - copyright (C) 1994, Amzi! inc. 
  
 % this file contains the definitions of all of the 
 % moves and rotations primitive to Rubik's Cube. 
  
 % Both moves and rotations are done using Prologs unification. 
  
 % The first argument is the name of the move or rotation, and the % 
 second and third arguments define transformations of the structure % 
 which represents the cube. 
  
 % By convention the moves are named by a single character which stands 
 % for the position of the side being turned.  Rotations are used to % 
 reposition the entire cube (leaving the pieces in the same relative % 
 positions).  They are named by the side which defines the axis % of 
 rotation, preceded by the letter r. 
  
 % (Why the funny variable names?  This program was originally written %  
 in micro-Prolog (one of my favorites) with its parenthetical list %  
 notation.  I then acquired Arity Prolog and wrote a translation %  
 program converted the micro-Prolog syntax to Edinburgh syntax. %  It 
 did the dumb thing with variable names, and I've never bothered %  to 
 fix many of them, such as these.) 
  
 % The sides are: u up, d down, l left, r right, f front, b back. 
  
 :- export move/3,rot/3. 
  
 move(u, 
  
  
  cube(X1, X2, X3, X4, X5, X6, V7, V8, V9, V10, V11, V12,  
  
  
  
  V13, V14, V15, V16, V17, V18, V19, V20, V21, V22, V23,  
  
  
  
  V24, V25, V26, V27, V28, V29,  
  
  
   
  V30, V31, V32, V33, V34,  
  
  
   
  V35, V36, V37, V38, V39, V40, V41, V42, V43, V44, V45,  
  
  
  
  V46, V47, V48, V49, V50, V51, V52, V53, V54),  
  
  
  cube(X1, X2, X3, X4, X5, X6, V20, V19, V21, V10, V11,  
  
  
  
  V12, V8, V7, V9, V16, V17, V18, V26, V25, V27, V22,  
  
  
  
  V23, V24, V14, V13, V15, V28, V29, V30, V43, V44,  
  
  
   
  V33, V34, V39, V40, V37, V38, V31, V32, V41, V42,  
  
  
   
  V35, V36, V45, V46, V47, V48, V49, V50, V51, V52,  
  
  
   
  V53, V54) 
  
  
  ). 
  
 move(d, 
  
  
  cube(X1, X2, X3, X4, X5, X6, V7, V8, V9,  
  
  
  
  V10, V11, V12, V13, V14, V15, V16, V17,  
  
  
  
  V18, V19, V20, V21, V22, V23, V24, V25, V26, V27, V28, V29,  
  
  
  
 V30, V31, V32, V33, V34, V35, V36, V37, V38, V39, V40, V41, V42,  
  
  
  
 V43, V44, V45, V46, V47, V48, V49, V50, V51, V52, V53, V54),  
  
  cube(X1, X2, 
 X3, X4, X5, X6, V7, V8, V9, 
  
  
  
  V17, V16, V18, V13, V14, V15, V29, V28,  
  
  
  
  V30, V19, V20, V21, V11,  
  
  
  
  V10, V12, V25, V26, V27, V23, V22, V24, V31, V32,  
  
  
  
  V41, V42, V35, V36, V45, V46, V39, V40, V37, V38, V43, V44, V33,  
  
  
  V34, V47, V48, V49, V50, V51, V52, V53, V54) 
  
  
  ). 
  
 move(r, 
  
  cube(X1, X2, X3, X4, X5, X6, V7, V8, V9,  
  
  
  V10, V11, V12, V13, V14, V15, V16, V17, V18,  
  
  
  V19, V20, V21, V22, V23, V24, V25, V26, V27, V28, V29, V30, V31,  
  
  
 V32, V33, V34, V35, V36, V37, V38, V39, V40, V41, V42, V43, V44,  
  
  V45, 
 V46, V47, V48, V49, V50, V51, V52, V53, V54),  
  
  cube(X1, X2, X3, X4, X5, X6, V12, V11, V10, V24, 
  
  
  V23, V22, V13, V14, V15, V16, V17, V18, V9,  
  
  
  V8, V7, V21, V20, V19, V25, V26, V27, V28, V29, V30, V48, V47, V52,  
  
 Building Expert Systems in Prolog
  
 293",NA
Rubik Help (rubhelp.pro) ,"% RUBHELP.PRO - Copyright (C) 1994, Amzi! inc. 
  
 % This is the help you get when you ask for help. 
  
 :- export rub_help/0. 
  
 rub_help:- 
  
  helpscreen(_), 
  
  nl,  write($[more - hit any key to continue]$),  
 get1(_), 
  
  fail. 
  
 rub_help. 
  
 helpscreen(intro):- 
  
  write($INTRODUCTION$),  nl,  nl, 
  
  write($The cube solver will generate a sequence of moves that will$),  nl,  
 write($solve any given cube (if solvable).  See rubdoc1.txt for$),  nl,  
 write($notes on the method.$),  nl,  nl. 
  
 helpscreen('menu options'):- 
  
  write($MAIN MENU OPTIONS$),  nl,  nl, 
  
  write($Solve - solves three types of cubes (from submenu)$),  nl,  nl,  
 write($      random - generate a random cube to solve$),  nl, 
  
  write($      manual - allows you to scramble your own$),  nl, 
  
  write($      edit   - allows you to describe a real cube$),  nl,  nl,  
 write($        with the option (prompts)$),  nl,  nl, 
  
  write($      stepmode - stops after each sequence (useful if$),  nl,  
 write($                 solving a real cube)$),  nl, 
  
  write($Manual - allows manipulation of cube (useful to see the$),  nl,  
 write($         effects of all the legal moves)$),  nl,  nl, 
  
  write($Help   - this stuff$),  nl,  nl, 
  
  write($Exit   - return to dos$),  nl. 
  
 helpscreen(notation):- 
  
  write($NOTES ON NOTATION$),  nl,  nl, 
  
  write($The cube is unfolded so all six sides are visible.  All moves$),  nl,  
 write($are labeled by the side they affect.  The letters used are:$),  nl,  
 nl, 
  
  write($                 B - back$),  nl, 
  
  write($       L - left  U - up    R - right$),  nl, 
  
  write($                 F - front$),  nl, 
  
  write($                 D - down$),  nl,  nl, 
  
  write($Directions - + clockwise, - counterclockwise$),  nl,  nl, 
  
  write($Pieces are referred to by color.  The colors are:$),  nl,  nl,  
 write($         W - white, G - green, B - blue, Y - yellow,$),  nl, 
  
  write($         R - red (PC magenta), O - orange (PC red) $),  nl,  nl,  
 write($Moves - three types$),  nl,  nl, 
  
  write($     Side moves - represented by single side letter, ex +r$),  nl,  
 write($     Rotations - rotate entire cube, preface side with r$),  nl,  
 write($                 ex. -ru, +rr (used to exploit symmetry)$),  nl,  
 write($     Sequences - sequence of moves by name ex. +ct1$),  nl. 
  
 helpscreen('solve display'):- 
  
  write($SOLVE DISPLAY FIELDS$),  nl,  nl, 
  
  write($Stage - the current stage (see rubdoc1.txt)$),  nl,  nl, 
  
  write($Target - the piece being solved for$),  nl,  nl, 
  
  write($Trying - the n-1 nodes of the breadth first search$),  nl,  nl,  
 write($Rotation - the chosen sequence of moves for the current goal$),  nl,  
 nl, 
  
  write($Hit any key to end$). 
  
 296 
  
 Appendices - Full Source Code",NA
Rubik Data (rubdata.pro) ,"% RUBDATA.PRO - Copyright (C) 1994, Amzi! inc. 
  
 % This file contains all the data needed to drive 
 % the main cube solving predicates. 
  
 :-export seq/2, s_r/2, orientation/2. 
  
 :-export cnd/2, pln/2, vw/2. 
  
 :-export pristine/1. 
  
 :-export side_color/1. 
  
 % the sequences of moves used to perform special transformations 
 % such as twisting the corners without moving anything else 
  
 seq(s, [+rr, -r, +l]). 
  
 seq(tc1, [-l, +u, +r, -u, +l, +u, -r, -u]). 
  
 seq(tc1u2, [+ru, +ru, +tc1, -ru, -ru]). 
  
 seq(tc3, [+r, -u, -l, +u, -r, -u, +l, +u]). 
  
 seq(ct1, [-r, +d, +r, +f, +d, -f, -u, +f, 
  
  -d, -f, -r, -d, +r, +u]). 
  
 seq(ct3, [-r, +d, +r, +f, +d, -f, +u, +u, 
  
  +f, -d, -f, -r, -d, +r, +u, +u]). 
  
 seq(ef1, [-u, +f, -r, +u, -f, -s, +f, -u, 
  
  +r, -f, +u, +s]). 
  
 seq(ef2, [+l, +f, -u, +f, -r, +u, -f, -s, 
  
  +f, -u, +r, -f, +u, +s, -f, -l]). 
  
 seq(et1, [+f, +f, +r, +r, +f, +f, +r, +r, 
  
  +f, +f, +r, +r]). 
  
 seq(h, [+l, +f, +u, -f, -u, -l]). 
  
 seq(g, [-r, -f, -u, +f, +u, +r]). 
  
 seq(pt, [+ru, +ru]). 
  
 seq(mr2a, [+r, +f, -r, -f]). 
  
 seq(mr2b, [-r, -u, +r, +u]). 
  
 seq(mr3a, [-u, +r, +u]). 
  
 seq(mr3b, [+f, -r, -f]). 
  
 % cnd defines the moves which will be used in a given stage for search 
  
 cnd(1, [r, u, f]). 
  
 cnd(2, [r, mr2a, mr2b]). 
  
 cnd(3, [r, mr3a, mr3b]). 
  
 cnd(4, [r, tc1u2, ct1]). 
  
 cnd(5, [u, h, g, ef1, ef2]). 
  
 cnd(6, [u, tc1, tc3, ct1, ct3]). 
  
 % s_r is used by the shift_right heuristics.  it lists the move sequence 
 % needed to move a piece which is not on the right, to the right.  the % 
 first arguement is the position the piece is at 
  
 s_r(p('F','L','U'), [-mr2a]). 
  
 s_r(p('F','L','D'), [+rr, -mr2a, -rr]). 
  
 s_r(p('B','L','U'), [-rr, -mr2a, +rr]). 
  
 s_r(p('B','L','D'), [+rr, +rr, -mr2a, -rr, -rr]). 
 s_r(p('F','U'), [-mr3a]). 
  
 s_r(p('F','D'), [+s, -mr3a, -s]). 
  
 s_r(p('B','U'), [-s, -mr3a, +s]). 
  
 s_r(p('B','D'), [+s, +s, -mr3a, -s, -s]). 
  
 s_r(p('L','U'), [+u, +u]). 
  
 s_r(p('F','L'), [+f, +f]). 
  
 s_r(p('L','D'), [+d, +d]). 
  
 s_r(p('B','L'), [+b, +b]). 
  
 Building Expert Systems in Prolog
  
 297",NA
