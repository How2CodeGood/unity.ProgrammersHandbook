Larger Text,Smaller Text,Symbol
The Rust ,NA,NA
Programming ,NA,NA
Language,NA,NA
The Rust Programming ,NA,NA
Language,NA,NA
"Steve Klabnik and Carol Nichols, with ",NA,NA
Contributions from the Rust Community,NA,NA
Contents,"I
  
 1
  
 2
  
 3
  
 4
  
 5
  
 Getting started
  
 7
  
 Introduction
  
 1.1 
  
 Contributing to the book 
  
 . . . . . . . . . . . . . . . . .
  
 1.2 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.3 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 1
 0 
 1
 0 
 1
 2
  
 Guessing Game
  
 2.1 
  
 Setting Up a New Project
  . . . . . . . . . . . . . . . . .
  
 2.2 
  
 Processing a Guess
  . . . . . . . . . . . . . . . . . . . . .
  
 2.3 
  
 Generating a Secret Number 
  
 . . . . . . . . . . . . . . .
  
 2.4 
  
 Comparing the Guess to the Secret Number
  . . . . . . .
  
 2.5 
  
 Allowing Multiple Guesses with Looping
  . . . . . . . . .
  
 2.6 
  
 Summary 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
 1 
 2
 1 
 2
 2 
 2
 7 
 3
 3 
 3
 8 
 4
 4
  
 Common Programming Concepts
  
 3.1 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.2 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.3 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.4 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.5 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
 5 
 4
 6 
 5
 0 
 5
 8 
 6
 5 
 6
 6
  
 Understanding Ownership
  
 4.1 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.2 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.3 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
 7 
 7
 7 
 9
 0 
 9
 7
  
 Using Structs to Structure Related Data 
  
 10
 5
  
 5.1 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
  
 5.2 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
  
 5.3 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117",NA
Part I ,NA,NA
Getting started,NA,NA
Chapter 1,NA,NA
Introduction,"Welcome to “The Rust Programming Language,” an introductory book 
 about Rust. Rust is a programming language that’s focused on safety, 
 speed, and concurrency. Its design lets you create programs that have 
 the performance and control of a low-level language, but with the pow-
 erful abstractions of a high-level language. These properties make Rust 
 suitable for programmers who have experience in languages like C and 
 are looking for a safer alternative, as well as those from languages like 
 Python who are looking for ways to write code that performs better 
 without sacrificing expressiveness.
  
 Rust performs the majority of its safety checks and memory man-
 agement decisions at compile time, so that your program’s runtime 
 performance isn’t impacted. This makes it useful in a number of use 
 cases that other languages aren’t good at: programs with predictable 
 space and time requirements, embedding in other languages, and writ-
 ing low-level code, like device drivers and operating systems. It’s also 
 great for web applications: it powers the Rust package registry site, 
 crates.io
 ! We’re excited to see what
  you
  create with Rust.
  
 This book is written for a reader who already knows how to 
 program in at least one programming language. After reading this book, 
 you should be comfortable writing Rust programs. We’ll be learning 
 Rust through small, focused examples that build on each other to 
 demon-strate how to use various features of Rust as well as how they 
 work behind the scenes.",NA
1.1,NA,NA
Contributing to the book,"This book is open source. If you find an error, please don’t hesitate to 
 file an issue or send a pull request
  on GitHub
 . Please see
  CON-
 TRIBUTING.md
  for more details.",NA
1.2,"Installation
  
 The first step to using Rust is to install it. You’ll need an internet con-
 nection to run the commands in this chapter, as we’ll be downloading 
 Rust from the internet.
  
 We’ll be showing off a number of commands using a terminal, and 
 those lines all start with $. You don’t need to type in the $ character; 
 they are there to indicate the start of each command. You’ll see many 
 tutorials and examples around the web that follow this convention: $ 
 for commands run as a regular user, and # for commands you should be 
 running as an administrator. Lines that don’t start with $ are typically 
 showing the output of the previous command.
  
 Installing on Linux or Mac
  
 If you’re on Linux or a Mac, all you need to do is open a terminal and 
 type this:
  
 $ curl https://sh.rustup.rs -sSf | sh
  
 This will download a script and start the installation. You may be 
 prompted for your password. If it all goes well, you’ll see this appear:
  
 Rust is installed now. Great!
  
 Of course, if you disapprove of the curl | sh pattern, you can down-load, 
 inspect and run the script however you like.
  
 Installing on Windows
  
 On Windows, go to
  https://rustup.rs
  and follow the instructions to 
 download rustup-init.exe. Run that and follow the rest of the instruc-
 tions it gives you.
  
 The rest of the Windows-specific commands in the book will assume 
 that you are using cmd as your shell. If you use a different shell, you",NA
1.3,"Hello, World!
  
 Now that you have Rust installed, let’s write your first Rust program. 
 It’s traditional when learning a new language to write a little program 
 to print the text “Hello, world!” to the screen, and in this section, we’ll 
 follow that tradition.
  
 Note: This book assumes basic familiarity with the com-
 mand line. Rust itself makes no specific demands about your 
 editing, tooling, or where your code lives, so if you prefer an 
 IDE to the command line, feel free to use your favorite IDE.
  
 Creating a Project Directory
  
 First, make a directory to put your Rust code in. Rust doesn’t care 
 where your code lives, but for this book, we’d suggest making a
  projects 
 directory in your home directory and keeping all your projects there. 
 Open a terminal and enter the following commands to make a directory 
 for this particular project: 
  
  
 Linux and Mac:
  
 $ mkdir ~/projects 
  
 $ cd ~/projects 
  
 $ mkdir hello_world 
  
 $ cd hello_world
  
 Windows:
  
 > mkdir
  %USERPROFILE%\projects 
 > cd
  %USERPROFILE%\projects 
  
 > mkdir
  hello_world",NA
Chapter 2,NA,NA
Guessing Game,"Let’s jump into Rust by working through a hands-on project together! 
 This chapter introduces you to a few common Rust concepts by show-
 ing you how to use them in a real program. You’ll learn about let, match, 
 methods, associated functions, using external crates, and more! The 
 following chapters will explore these ideas in more detail. In this 
 chapter, you’ll practice the fundamentals.
  
 We’ll implement a classic beginner programming problem: a guess-
 ing game. Here’s how it works: the program will generate a random 
 integer between 1 and 100. It will then prompt the player to enter a 
 guess. After entering a guess, it will indicate whether the guess is too 
 low or too high. If the guess is correct, the game will print congratula-
 tions and exit.",NA
2.1 ,NA,NA
Setting Up a New Project,"To set up a new project, go to the
  projects
  directory that you created in 
 Chapter 1, and make a new project using Cargo, like so:
  
 $ cargo new guessing_game --bin $ cd 
 guessing_game
  
 The first command, cargo new, takes the name of the project (guessing_ 
 game) as the first argument. The --bin flag tells Cargo to make a bi-nary 
 project, similar to the one in Chapter 1. The second command changes to 
 the new project’s directory.
  
 Look at the generated
  Cargo.toml
  file: 
 Filename: Cargo.toml",NA
2.2 ,NA,NA
Processing a Guess,"The first part of the program will ask for user input, process that input, 
 and check that the input is in the expected form. To start, we’ll allow 
 the player to input a guess. Enter the code in Listing 2-1 into 
 src/main.rs
 .
  
 Filename: src/main.rs",NA
2.3 ,NA,NA
Generating a Secret Number,"Next, we need to generate a secret number that the user will try to 
 guess. The secret number should be different every time so the game is 
 fun to play more than once. Let’s use a random number between 1 and",NA
2.4,NA,NA
Comparing the Guess to the Secret Num-ber,"Now that we have user input and a random number, we can compare 
 them. That step is shown in Listing 2-4: 
  
  
 Filename: src/main.rs 
  
 extern crate
  rand; 
  
 use
  std::io; 
  
 use
  std::cmp::Ordering; 
  
 use
  rand::Rng; 
  
 fn
  main
 () { 
  
   
 println!(
 ""Guess the number!""
 ); 
  
   
 let
  secret_number
  =
  rand::thread_rng().
 gen_range
 (
 1
 , 
 101
 );
  
 ;
  
 println!(
 ""The secret number is:
  {}
 ""
 , secret_number)
  
 println!(
 ""Please input your guess.""
 ); 
 let mut
  
 guess
  =
  String
 ::new(); 
  
 io::stdin().
 read_line
 (
 &mut
  guess) 
  
  
 .
 expect
 (
 ""Failed to read line""
 ); 
 println!(
 ""You guessed:
  {}
 ""
 , guess);
  
 match
  guess.
 cmp
 (
 &
 secret_number) { 
  
  
 Ordering::Less 
  
 =>
  println!(
 ""Too small!""
 ),",NA
2.5,NA,NA
Allowing Multiple Guesses with Loop-ing,"The loop keyword gives us an infinite loop. Add that now to give users 
 more chances at guessing the number: 
  
  
 Filename: src/main.rs
  
 extern crate
  rand;
  
 use
  std::io; 
  
 use
  std::cmp::Ordering; 
  
 use
  rand::Rng;
  
 fn
  main
 () { 
  
  
 println!(
 ""Guess the number!""
 );
  
  
 let
  secret_number
  =
  rand::thread_rng().
 gen_range
 (
 1
 , 
 101
 );
  
 ;
  
 println!(
 ""The secret number is:
  {}
 ""
 , secret_number)
  
 loop
  { 
  
  
 println!(
 ""Please input your guess.""
 );",NA
2.6 ,NA,NA
Summary,"At this point, you’ve successfully built the guessing game! Congratu-
 lations!
  
 This project was a hands-on way to introduce you to many new Rust 
 concepts: let, match, methods, associated functions, using exter-nal 
 crates, and more. In the next few chapters, you’ll learn about these 
 concepts in more detail. Chapter 3 covers concepts that most program-
 ming languages have, such as variables, data types, and functions, and 
 shows how to use them in Rust. Chapter 4 explores ownership, which is 
 a Rust feature that is most different from other languages. Chapter 5 
 discusses structs and method syntax, and Chapter 6 endeavors to 
 explain enums.",NA
Chapter 3,NA,NA
Common Programming ,NA,NA
Concepts,"This chapter covers concepts that appear in almost every programming 
 language and how they work in Rust. Many programming languages 
 have much in common at their core. None of the concepts presented in 
 this chapter are unique to Rust, but we’ll discuss them in the context of 
 Rust and explain their conventions.
  
 Specifically, you’ll learn about variables, basic types, functions, 
 comments, and control flow. These foundations will be in every Rust 
 program, and learning them early will give you a strong core to start 
 from.
  
 Keywords
  
 The Rust language has a set of keywords that have been 
 reserved for use by the language only, much like other lan-
 guages do. Keep in mind that you cannot use these words as 
 names of variables or functions. Most of the keywords have 
 special meanings, and you’ll be using them to do var-ious 
 tasks in your Rust programs; a few have no current 
 functionality associated with them but have been reserved for 
 functionality that might be added to Rust in the future. You 
 can find a list of the keywords in Appendix A.",NA
3.1,"Variables and Mutability
  
 As mentioned in Chapter 2, by default variables are
  immutable
 . This is 
 one of many nudges in Rust that encourages you to write your code in a 
 way that takes advantage of the safety and easy concurrency that Rust 
 offers. However, you still have the option to make your variables 
 mutable. 
  
 Let’s explore how and why Rust encourages you to favor 
 immutability, and why you might want to opt out.
  
 When a variable is immutable, that means once a value is bound to a 
 name, you can’t change that value. To illustrate, let’s generate a new 
 project called
  variables
  in your
  projects
  directory by using cargo new --
 bin variables.
  
  
 Then, in your new
  variables
  directory, open
  src/main.rs
  and replace 
 its code with the following: 
  
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 let
  x
  =
  5
 ; 
  
  
 println!(
 ""The value of x is:
  {}
 ""
 , x); 
  
 x
  =
  6
 ; 
  
  
 println!(
 ""The value of x is:
  {}
 ""
 , x); }
  
 Save and run the program using cargo run. You should receive an error 
 message, as shown in this output:
  
 error[E0384]: re-assignment of immutable variable `x`
  
 --> 
 src/main.rs:4:5 
  
  
 |
  
 2 |
  
 let x = 5;
  
 | 
  
 3 |
  
 - first assignment to `x` 
  
 println!(""The value of x is: {}"", x);
  
 4 |
  
 x = 6;
  
 |
  
 ^^^^^ re-assignment of immutable variable
  
 This example shows how the compiler helps you find errors in your 
 programs. Even though compiler errors can be frustrating, they only 
 mean your program isn’t safely doing what you want it to do yet; they 
 do
  not
  mean that you’re not a good programmer! Experienced 
 Rustaceans still get compiler errors. The error indicates that the cause",NA
3.2,"Data Types
  
 Every value in Rust is of a certain
  type
 , which tells Rust what kind of 
 data is being specified so it knows how to work with that data. In this 
 section, we’ll look at a number of types that are built into the language. 
 We split the types into two subsets: scalar and compound.",NA
3.3,"How Functions Work
  
 Functions are pervasive in Rust code. You’ve already seen one of the 
 most important functions in the language: the main function, which is 
 the entry point of many programs. You’ve also seen the fn keyword, 
 which allows you to declare new functions.
  
  
 Rust code uses
  snake case
  as the conventional style for function and 
 variable names. In snake case, all letters are lowercase and underscores 
 separate words. Here’s a program that contains an example function 
 definition: 
  
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 println!(
 ""Hello, world!""
 );
  
 }
  
 another_function
 ();
  
 fn
  another_function
 () { 
  
  
 println!(
 ""Another function.""
 ); }
  
 Function definitions in Rust start with fn and have a set of parentheses 
 after the function name. The curly braces tell the compiler where the 
 function body begins and ends.",NA
3.4,"Comments
  
 All programmers strive to make their code easy to understand, but 
 sometimes 
 extra 
 explanation 
 is 
 warranted. 
 In 
 these 
 cases, 
 programmers leave notes, or
  comments
 , in their source code that the 
 compiler will ignore but people reading the source code may find 
 useful.
  
 Here’s a simple comment:
  
 // Hello, world.
  
 In Rust, comments must start with two slashes and continue until the 
 end of the line. For comments that extend beyond a single line, you’ll 
 need to include // on each line, like this:
  
 // So we’re doing something complicated here, long enough that we 
 need 
  
 // multiple lines of comments to do it! Whew! Hopefully, this comment 
 will 
  
 // explain what’s going on.
  
 Comments can also be placed at the end of lines containing code: 
 Filename: src/main.rs
  
 fn
  main
 () { 
  
 let
  lucky_number
  =
  7
 ;
  // I’m feeling lucky today.
  
 }
  
 But you’ll more often see them used in this format, with the comment on 
 a separate line above the code it’s annotating: 
  
 Filename: src/main.rs",NA
3.5,"Control Flow
  
 Deciding whether or not to run some code depending on if a condition 
 is true or deciding to run some code repeatedly while a condition is 
 true are basic building blocks in most programming languages. The 
 most common constructs that let you control the flow of execution of 
 Rust code are if expressions and loops.
  
 if Expressions
  
 An if expression allows us to branch our code depending on conditions. 
 We provide a condition and then state, “If this condition is met, run this 
 block of code. If the condition is not met, do not run this block of code.”
  
  
 Create a new project called
  branches
  in your
  projects
  directory to 
 explore the if expression. In the
  src/main.rs
  file, input the following: 
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 let
  number
  =
  3
 ;
  
 }
  
 if
  number
  <
  5
  { 
  
  
 println!(
 ""condition was true""
 ); }
  else
  {
  
 }
  
 println!(
 ""condition was false""
 );
  
 All if expressions start with the keyword if, which is followed by a 
 condition. In this case, the condition checks whether or not the vari-
 able number has a value less than 5. The block of code we want to 
 execute if the condition is true is placed immediately after the condi-
 tion inside curly braces. Blocks of code associated with the conditions",NA
Chapter 4,NA,NA
Understanding ,NA,NA
Ownership,"Ownership is Rust’s most unique feature, and it enables Rust to make 
 memory safety guarantees without needing a garbage collector. There-
 fore, it’s important to understand how ownership works in Rust. In this 
 chapter we’ll talk about ownership as well as several related features: 
 borrowing, slices, and how Rust lays data out in memory.",NA
4.1,"What Is Ownership?
  
 Rust’s central feature is
  ownership
 . Although the feature is straightfor-
 ward to explain, it has deep implications for the rest of the language.
  
 All programs have to manage the way they use a computer’s 
 memory while running. Some languages have garbage collection that 
 constantly looks for no longer used memory as the program runs; in 
 other lan-guages, the programmer must explicitly allocate and free the 
 memory. Rust uses a third approach: memory is managed through a 
 system of ownership with a set of rules that the compiler checks at 
 compile time.
  
 No run-time costs are incurred for any of the ownership features.
  
 Because ownership is a new concept for many programmers, it does 
 take some time to get used to. The good news is that the more experi-
 enced you become with Rust and the rules of the ownership system, the 
 more you’ll be able to naturally develop code that is safe and efficient. 
 Keep at it!",NA
4.2,"References and Borrowing
  
 The issue with the tuple code at the end of the preceding section is that 
 we have to return the String to the calling function so we can still use 
 the String after the call to calculate_length, because the String was 
 moved into calculate_length.
  
  
 Here is how you would define and use a calculate_length function 
 that has a
  reference
  to an object as a parameter instead of taking 
 ownership of the value: 
  
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 let
  s1
  =
  String
 ::from(
 ""hello""
 );
  
 let
  len
  =
  calculate_length
 (
 &
 s1);
  
 }
  
 println!(
 ""The length of '
 {}
 ' is
  {}
 .""
 , s1, len);
  
 fn
  calculate_length
 (s:
  &
 String) ->
  usize
  {",NA
4.3,"Slices
  
 Another data type that does not have ownership is the
  slice
 . Slices let 
 you reference a contiguous sequence of elements in a collection rather 
 than the whole collection.
  
 Here’s a small programming problem: write a function that takes a 
 string and returns the first word it finds in that string. If the function 
 doesn’t find a space in the string, it means the whole string is one word, 
 so the entire string should be returned.
  
 Let’s think about the signature of this function:
  
 fn
  first_word
 (s:
  &
 String) ->
  ?
  
 This function, first_word, has a &String as a parameter. We don’t want 
 ownership, so this is fine. But what should we return? We don’t really 
 have a way to talk about
  part
  of a string. However, we could return the 
 index of the end of the word. Let’s try that as shown in Listing 4-10: 
  
 Filename: src/main.rs
  
 fn
  first_word
 (s:
  &
 String) ->
  usize
  { 
 let
  
 bytes
  =
  s.
 as_bytes
 ();
  
 for
  (i,
  &
 item)
  in
  bytes.
 iter
 ().
 enumerate
 () { 
  
 if
  item
  == 
 b
 ' '
  { 
  
  
  
 return
  i; 
  
  
 } 
  
 }
  
 }
  
 s.
 len
 ()
  
 Listing 4-10: The first_word function that returns a byte index value 
 into the String parameter 
  
 Let’s break down this code a bit. Because we need to go through the 
 String element by element and check whether a value is a space, we’ll 
 convert our String to an array of bytes using the as_bytes method:
  
 let
  bytes
  =
  s.
 as_bytes
 ();
  
 Next, we create an iterator over the array of bytes using the iter method 
 :",NA
Chapter 5,NA,NA
Using Structs to ,NA,NA
Structure Related Data,"A
  struct
 , or
  structure
 , is a custom data type that lets us name and 
 package together multiple related values that make up a meaningful 
 group. If you’re familiar with an object-oriented language, a
  struct
  is 
 like an object’s data attributes. In this chapter, we’ll compare and con-
 trast tuples with structs, demonstrate how to use structs, and discuss 
 how to define methods and associated functions on structs to specify 
 behavior associated with a struct’s data. The struct and
  enum
  (which is 
 discussed in Chapter 6) concepts are the building blocks for creating 
 new types in your program’s domain to take full advantage of Rust’s 
 compile time type checking.",NA
5.1,"Defining and Instantiating Structs
  
 Structs are similar to tuples, which were discussed in Chapter 3. Like 
 tuples, the pieces of a struct can be different types. Unlike tuples, we 
 name each piece of data so it’s clear what the values mean. As a result 
 of these names, structs are more flexible than tuples: we don’t have to 
 rely on the order of the data to specify or access the values of an 
 instance.
  
 To define a struct, we enter the keyword struct and name the entire 
 struct. A struct’s name should describe the significance of the pieces of 
 data being grouped together. Then, inside curly braces, we define",NA
5.2,"An Example Program Using Structs
  
 To understand when we might want to use structs, let’s write a 
 program that calculates the area of a rectangle. We’ll start with single 
 variables, and then refactor the program until we’re using structs 
 instead.
  
 Let’s make a new binary project with Cargo called
  rectangles
  that 
 will take the length and width of a rectangle specified in pixels and will",NA
5.3,"Method Syntax
  
 Methods
  are similar to functions: they’re declared with the fn keyword 
 and their name, they can have parameters and return values, and they 
 contain some code that is run when they’re called from somewhere 
 else. However, methods are different from functions in that they’re 
 defined within the context of a struct (or an enum or a trait object, 
 which we cover in Chapters 6 and 17, respectively), and their first 
 parameter is always self, which represents the instance of the struct the 
 method is being called on.
  
 Defining Methods
  
 Let’s change the area function that has a Rectangle instance as a 
 parameter and instead make an area method defined on the Rectangle 
 struct, as shown in Listing 5-12: 
  
 Filename: src/main.rs
  
 #[derive(Debug)] 
  
 struct
  Rectangle { 
  
 length:
  u32
 , 
  
 width:
  u32
 , 
  
 }
  
 impl
  Rectangle { 
  
 fn
  area
 (
 &
 self) ->
  u32
  { 
  
  
 self.length
  *
  self.width } 
  
 }",NA
Chapter 6,NA,NA
Enums and Pattern ,NA,NA
Matching,"In this chapter we’ll look at
  enumerations
 , also referred to as
  enums
 . 
 Enums allow you to define a type by enumerating its possible values. 
 First, we’ll define and use an enum to show how an enum can encode 
 meaning along with data. Next, we’ll explore a particularly useful enum, 
 called Option, which expresses that a value can be either some-thing or 
 nothing. Then we’ll look at how pattern matching in the match 
 expression makes it easy to run different code for different values of an 
 enum. Finally, we’ll cover how the if let construct is another con-venient 
 and concise idiom available to you to handle enums in your code.
  
 Enums are a feature in many languages, but their capabilities differ 
 in each language. Rust’s enums are most similar to
  algebraic data types 
 in functional languages like F#, OCaml, and Haskell.",NA
6.1,"Defining an Enum
  
 Let’s look at a situation we might want to express in code and see why 
 enums are useful and more appropriate than structs in this case. Say we 
 need to work with IP addresses. Currently, two major standards are 
 used for IP addresses: version four and version six. These are the only 
 possibilities for an IP address that our program will come across:",NA
6.2,"The match Control Flow Operator
  
 Rust has an extremely powerful control-flow operator called match that 
 allows us to compare a value against a series of patterns and then 
 execute code based on which pattern matches. Patterns can be made up 
 of literal values, variable names, wildcards, and many other things; 
 Chapter 18 will cover all the different kinds of patterns and what they 
 do. The power of match comes from the expressiveness of the patterns 
 and the compiler checks that make sure all possible cases are handled.
  
 Think of a match expression kind of like a coin sorting machine: 
 coins slide down a track with variously sized holes along it, and each 
 coin falls through the first hole it encounters that it fits into. In the same 
 way, values go through each pattern in a match, and at the first pattern 
 the value “fits,” the value will fall into the associated code block to be 
 used during execution.
  
  
 Because we just mentioned coins, let’s use them as an example using 
 match! 
  
 We can write a function that can take an unknown United 
 States coin and, in a similar way as the counting machine, determine 
 which coin it is and return its value in cents, as shown here in Listing 6-
 3:
  
 enum
  Coin { 
  
  
 Penny, 
  
  
 Nickel, 
  
  
 Dime, 
  
  
 Quarter, 
  
 }
  
 fn
  value_in_cents
 (coin: Coin) ->
  i32
  { 
  
 match
  
 coin {",NA
6.3,"Concise Control Flow with if let
  
 The if let syntax lets you combine if and let into a less verbose way to 
 handle values that match one pattern and ignore the rest. Consider the 
 program in Listing 6-6 that matches on an Option<u8> value but only 
 wants to execute code if the value is three:
  
 let
  some_u8_value
  =
  Some
 (
 0
 u8
 ); 
 match
  
 some_u8_value { 
  
  
 Some
 (
 3
 )
  =>
  println!(
 ""three""
 ), 
  
 _ 
 =>
  (),
  
 }
  
 Listing 6-6: A match that only cares about executing code when the 
 value is Some(3)",NA
Part II ,NA,NA
Basic Rust Literacy,NA,NA
Chapter 1,NA,NA
Using Modules to Reuse ,NA,NA
and Organize Code,"When you start writing programs in Rust, your code might live solely in 
 the main function. As your code grows, you’ll eventually move func-
 tionality into other functions for reuse and better organization. By 
 splitting your code into smaller chunks, each chunk is easier to under-
 stand on its own. But what happens if you have too many functions? 
 Rust has a module system that enables the reuse of code in an 
 organized fashion.
  
 In the same way that you extract lines of code into a function, you 
 can extract functions (and other code, like structs and enums) into 
 different modules. A
  module
  is a namespace that contains definitions of 
 functions or types, and you can choose whether those definitions are 
 visible outside their module (public) or not (private). Here’s an 
 overview of how modules work:
  
 • The mod keyword declares a new module. Code within the module 
 appears either immediately following this declaration within 
 curly braces or in another file.
  
 • By default, functions, types, constants, and modules are private. 
 The pub keyword makes an item public and therefore visible out-
 side its namespace.
  
 • The use keyword brings modules, or the definitions inside mod-
 ules, into scope so it’s easier to refer to them.
  
 We’ll look at each of these parts to see how they fit into the whole.",NA
1.1,"mod and the Filesystem
  
 We’ll start our module example by making a new project with Cargo, 
 but instead of creating a binary crate, we’ll make a library crate: a 
 project that other people can pull into their projects as a dependency. 
 For example, the rand crate in Chapter 2 is a library crate that we used 
 as a dependency in the guessing game project.
  
  
 We’ll create a skeleton of a library that provides some general net-
 working functionality; we’ll concentrate on the organization of the mod-
 ules and functions but we won’t worry about what code goes in the 
 function bodies. 
  
 We’ll call our library communicator. By default, 
 Cargo will create a library unless another type of project is specified: if 
 we omit the --bin option that we’ve been using in all of the chapters 
 preceding this one, our project will be a library:
  
 $ cargo new communicator 
  
 $ cd communicator
  
 Notice that Cargo generated
  src/lib.rs
  instead of
  src/main.rs
 . Inside 
 src/lib.rs
  we’ll find the following: 
  
  
 Filename: src/lib.rs
  
 #[cfg(test)] 
  
 mod
  tests { 
  
  
 #[test] 
  
  
 fn
  it_works
 () { 
  
  
 } 
  
 }
  
 Cargo creates an empty test to help us get our library started, rather 
 than the “Hello, world!” binary that we get when we use the --bin 
 option. We’ll look at the #[] and mod tests syntax in the “Using super to 
 Access a Parent Module” section later in this chapter, but for now, leave 
 this code at the bottom of
  src/lib.rs
 .
  
  
 Because we don’t have a
  src/main.rs
  file, there’s nothing for Cargo to 
 execute with the cargo run command. 
  
 Therefore, we’ll use the 
 cargo build command to compile our library crate’s code.
  
 We’ll look at different options for organizing your library’s code that 
 will be suitable in a variety of situations, depending on the intent of the 
 code.",NA
1.3,"Importing Names
  
 We’ve covered how to call functions defined within a module using the 
 module name as part of the call, as in the call to the nested_modules 
 function shown here in Listing 7-6: 
  
  
 Filename: src/main.rs
  
 pub mod
  a { 
  
  
 pub mod
  series { 
  
  
  
 pub mod
  of { 
  
  
  
 pub fn
  nested_modules
 () {} 
  
  
 } 
  
  
 } 
  
 }
  
 fn
  main
 () { 
  
  
 a::series::of::nested_modules(); }
  
 Listing 7-6: Calling a function by fully specifying its enclosing module’s 
 path 
  
  
 As you can see, referring to the fully qualified name can get quite 
 lengthy. 
  
 Fortunately, Rust has a keyword to make these calls more 
 concise.",NA
Chapter 2,NA,NA
Common Collections,"Rust’s standard library includes a number of really useful data struc-
 tures called
  collections
 . Most other data types represent one specific 
 value, but collections can contain multiple values. Unlike the built-in 
 array and tuple types, the data these collections point to is stored on 
 the heap, which means the amount of data does not need to be known 
 at compile time and can grow or shrink as the program runs. Each kind 
 of collection has different capabilities and costs, and choosing an 
 appropriate one for the situation you’re in is a skill you’ll develop over 
 time. In this chapter, we’ll go over three collections which are used very 
 often in Rust programs:
  
 • A
  vector
  allows us to store a variable number of values next to each 
 other.
  
 • A
  string
  is a collection of characters. We’ve seen the String type 
 before, but we’ll talk about it in depth now.
  
 • A
  hash map
  allows us to associate a value with a particular key. It’s 
 a particular implementation of the more general data struc-ture 
 called a
  map
 .
  
 To learn about the other kinds of collections provided by the standard 
 library, see
  the documentation
 .
  
 We’re going to discuss how to create and update vectors, strings, and 
 hash maps, as well as what makes each special.",NA
2.1,"Vectors
  
 The first type we’ll look at is Vec<T>, also known as a
  vector
 . Vectors 
 allow us to store more than one value in a single data structure that 
 puts all the values next to each other in memory. Vectors can only store 
 values of the same type. They are useful in situations where you have a 
 list of items, such as the lines of text in a file or the prices of items in a 
 shopping cart.
  
 Creating a New Vector
  
 To create a new, empty vector, we can call the Vec::new function:
  
 let
  v: Vec<
 i32
 >
  =
  Vec
 ::new();
  
 Note that we added a type annotation here. Since we aren’t inserting 
 any values into this vector, Rust doesn’t know what kind of elements 
 we intend to store. This is an important point. Vectors are 
 homogeneous: they may store many values, but those values must all 
 be the same type. Vectors are implemented using generics, which 
 Chapter 10 will cover how to use in your own types. For now, all you 
 need to know is that the Vec type provided by the standard library can 
 hold any type, and when a specific Vec holds a specific type, the type 
 goes within angle brackets. We’ve told Rust that the Vec in v will hold 
 elements of the i32 type.
  
 In real code, Rust can infer the type of value we want to store once 
 we insert values, so you rarely need to do this type annotation. It’s 
 more common to create a Vec that has initial values, and Rust provides 
 the vec! macro for convenience. The macro will create a new Vec that 
 holds the values we give it. This will create a new Vec<i32> that holds 
 the values 1, 2, and 3:
  
 let
  v
  =
  vec![
 1
 ,
  2
 ,
  3
 ];
  
 Because we’ve given initial i32 values, Rust can infer that the type of v 
 is Vec<i32>, and the type annotation isn’t necessary. Let’s look at how 
 to modify a vector next.
  
 Updating a Vector
  
 To create a vector then add elements to it, we can use the push method:",NA
2.2,"Strings
  
 We’ve already talked about strings a bunch in Chapter 4, but let’s take a 
 more in-depth look at them now. Strings are an area that new Rus-
 taceans commonly get stuck on. This is due to a combination of three 
 things: Rust’s propensity for making sure to expose possible errors, 
 strings being a more complicated data structure than many program-
 mers give them credit for, and UTF-8. These things combine in a way 
 that can seem difficult when coming from other languages.
  
 The reason strings are in the collections chapter is that strings are 
 implemented as a collection of bytes plus some methods to provide 
 useful functionality when those bytes are interpreted as text. In this 
 section, we’ll talk about the operations on String that every collection 
 type has, like creating, updating, and reading. We’ll also discuss the 
 ways in which String is different than the other collections, namely how 
 indexing into a String is complicated by the differences in which people 
 and computers interpret String data.
  
 What is a String?
  
 Before we can dig into those aspects, we need to talk about what 
 exactly we mean by the term
  string
 . Rust actually only has one string 
 type in the core language itself: str, the string slice, which is usually 
 seen in its borrowed form, &str. We talked about
  string slices
  in Chapter 
 4: these are a reference to some UTF-8 encoded string data stored 
 elsewhere. String literals, for example, are stored in the binary output 
 of the program, and are therefore string slices.
  
 The type called String is provided in Rust’s standard library rather than 
 coded into the core language, and is a growable, mutable, owned, UTF-8 
 encoded string type. 
  
 When Rustaceans talk about “strings”in 
 Rust, they usually mean both the String and the string slice &str types, 
 not just one of those. This section is largely about String, but both these 
 types are used heavily in Rust’s standard library. 
  
 Both 
 String and string slices are UTF-8 encoded.
  
 Rust’s standard library also includes a number of other string types, 
 such as OsString, OsStr, CString, and CStr. Library crates may provide 
 even more options for storing string data. 
  
 Similar to the 
 *String/*Str naming, they often provide an owned and borrowed 
 variant, just like String/&str. These string types may store different 
 encodings or be represented in memory in a different way, for example.",NA
2.3,"Hash Maps
  
 The last of our common collections is the
  hash map
 . The type HashMap<K, 
 V> stores a mapping of keys of type K to values of type V. It does this via a
  
 hashing function
 , which determines how it places these keys and values 
 into memory. Many different programming languages support this kind of 
 data structure, but often with a different name: hash, map, object, hash 
 table, or associative array, just to name a few.
  
 Hash maps are useful for when you want to be able to look up data 
 not by an index, as you can with vectors, but by using a key that can be 
 of any type. For example, in a game, you could keep track of each team’s 
 score in a hash map where each key is a team’s name and the values are 
 each team’s score. Given a team name, you can retrieve their score.
  
 We’ll go over the basic API of hash maps in this chapter, but there 
 are many more goodies hiding in the functions defined on HashMap by 
 the standard library. As always, check the standard library documen-
 tation for more information.",NA
Chapter 3,NA,NA
Error Handling,"Rust’s commitment to reliability extends to error handling. Errors are a 
 fact of life in software, so Rust has a number of features for handling 
 situations in which something goes wrong. In many cases, Rust will 
 require you to acknowledge the possibility of an error occurring and 
 take some action before your code will compile. This makes your 
 program more robust by ensuring that you won’t only discover errors 
 after you’ve deployed your code to production.
  
 Rust groups errors into two major categories:
  recoverable
  and
  un-
 recoverable
  errors. Recoverable errors are situations when it’s usually 
 reasonable to report the problem to the user and retry the operation, 
 like a file not being found. Unrecoverable errors are always symptoms 
 of bugs, like trying to access a location beyond the end of an array.
  
 Most languages don’t distinguish between the two kinds of errors, and 
 handle both in the same way using mechanisms like exceptions. Rust 
 doesn’t have exceptions. 
  
 Instead, it has the value Result<T, E> 
 for recoverable errors and the panic! macro that stops execution when 
 it encounters unrecoverable errors. This chapter will cover calling 
 panic! first, then talk about returning Result<T, E> values. Finally, we’ll 
 discuss considerations to take into account when deciding whether to 
 try to recover from an error or to stop execution.",NA
3.1,"Unrecoverable Errors with panic!
  
 Sometimes, bad things happen, and there’s nothing that you can do 
 about it. For these cases, Rust has the panic! macro. When this macro 
 executes, your program will print a failure message, unwind and clean 
 up the stack, and then quit. The most common situation this occurs in is 
 when a bug of some kind has been detected and it’s not clear to the 
 programmer how to handle the error.
  
 Unwinding the Stack Versus Aborting on Panic
  
 By default, when a panic! occurs, the program starts un-
 winding, which means Rust walks back up the stack and 
 cleans up the data from each function it encounters, but this 
 walking and cleanup is a lot of work. The alternative is to 
 immediately abort, which ends the program without cleaning 
 up. Memory that the program was using will then need to be 
 cleaned up by the operating system. If in your project you 
 need to make the resulting binary as small as possible, you 
 can switch from unwinding to aborting on panic by adding 
 panic = ‘abort’ to the appropriate [profile] sections in your 
 Cargo.toml. For example, if you want to abort on panic in 
 release mode:
  
 [profile.release] 
  
 panic = 'abort'
  
 Let’s try calling panic! with a simple program: 
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 panic!(
 ""crash and burn""
 ); 
  
 }
  
 If you run it, you’ll see something like this:
  
 $ cargo run 
  
 Compiling panic v0.1.0 (file:///projects/panic) 
   
 Finished 
 dev [unoptimized + debuginfo] target(s) in 0.25 secs",NA
3.2,"Recoverable Errors with Result
  
 Most errors aren’t serious enough to require the program to stop en-
 tirely. Sometimes, when a function fails, it’s for a reason that we can 
 easily interpret and respond to. For example, if we try to open a file",NA
3.3,"To panic! or Not To panic!
  
 So how do you decide when you should panic! and when you should 
 return Result? When code panics, there’s no way to recover. You could 
 choose to call panic! for any error situation, whether there’s a possible 
 way to recover or not, but then you’re making the decision for your 
 callers that a situation is unrecoverable. When you choose to return a 
 Result value, you give your caller options, rather than making the 
 decision for them. They could choose to attempt to recover in a way 
 that’s appropriate for their situation, or they could decide that actually, 
 an Err value in this case is unrecoverable, so they can call panic! and 
 turn your recoverable error into an unrecoverable one. Therefore, 
 returning Result is a good default choice when you’re defining a 
 function that might fail.
  
 There are a few situations in which it’s more appropriate to write 
 code that panics instead of returning a Result, but they are less com-
 mon. Let’s discuss why it’s appropriate to panic in examples, proto-type 
 code, and tests, then situations where you as a human can know",NA
Chapter 4,NA,NA
"Generic Types, Traits, ",NA,NA
and Lifetimes,"Every programming language has tools to deal effectively with dupli-
 cation of concepts; in Rust, one of those tools is
  generics
 . Generics are 
 abstract stand-ins for concrete types or other properties. When we’re 
 writing and compiling the code we can express properties of generics, 
 such as their behavior or how they relate to other generics, without 
 needing to know what will actually be in their place.
  
 In the same way that a function takes parameters whose value we don’t 
 know in order to write code once that will be run on multiple concrete 
 values, we can write functions that take parameters of some generic 
 type instead of a concrete type like i32 or String. 
  
 We’ve 
 already used generics in Chapter 6 with Option<T>, Chapter 8 with 
 Vec<T> and HashMap<K, V>, and Chapter 9 with Result<T, E>. In this 
 chapter, we’ll explore how to define our own types, functions, and 
 methods with generics!
  
 First, we’re going to review the mechanics of extracting a function 
 that reduces code duplication. Then we’ll use the same mechanics to 
 make a generic function out of two functions that only differ in the 
 types of their parameters. We’ll go over using generic types in struct 
 and enum definitions too.
  
 After that, we’ll discuss
  traits
 , which are a way to define behavior in 
 a generic way. Traits can be combined with generic types in order to 
 constrain a generic type to those types that have a particular behavior, 
 rather than any type at all.
  
 Finally, we’ll discuss
  lifetimes
 , which are a kind of generic that let us",NA
4.1,NA,NA
Removing Duplication by Extracting a ,NA,NA
Function,"Before getting into generics syntax, let’s first review a technique for 
 dealing with duplication that doesn’t use generic types: extracting a 
 function. Once that’s fresh in our minds, we’ll use the same mechanics 
 with generics to extract a generic function! In the same way that you 
 recognize duplicated code to extract into a function, you’ll start to 
 recognize duplicated code that can use generics.
  
  
 Consider a small program that finds the largest number in a list, 
 shown in Listing 10-1: 
  
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 let
  numbers
  =
  vec![
 34
 ,
  50
 ,
  25
 ,
  100
 ,
  65
 ];
  
 let mut
  largest
  =
  numbers[
 0
 ];
  
 for
  number
  in
  numbers { 
  
  
 if
  number
  >
  largest { 
  
  
  
 largest
  =
  number; 
  
  
 } 
  
 }
  
 # 
  
 }
  
  
 println!(
 ""The largest number is
  {}
 ""
 , largest); 
 assert_eq!(largest,
  100
 );
  
 Listing 10-1: Code to find the largest number in a list of numbers 
  
 This 
 code takes a list of integers, stored here in the variable numbers. It puts 
 the first item in the list in a variable named largest. Then it iterates 
 through all the numbers in the list, and if the current value is greater 
 than the number stored in largest, it replaces the value in largest. If the 
 current value is smaller than the largest value seen so far, largest is not 
 changed. When all the items in the list have been",NA
4.2,"Generic Data Types
  
 Using generics where we usually place types, like in function signatures 
 or structs, lets us create definitions that we can use for many different 
 concrete data types. 
  
 Let’s take a look at how to define functions, 
 structs, enums, and methods using generics, and at the end of this 
 section we’ll discuss the performance of code using generics.
  
 Using Generic Data Types in Function Definitions
  
 We can define functions that use generics in the signature of the func-
 tion where the data types of the parameters and return value go. In this 
 way, the code we write can be more flexible and provide more 
 functionality to callers of our function, while not introducing code du-
 plication.
  
 Continuing with our largest function, Listing 10-4 shows two func-tions 
 providing the same functionality to find the largest value in a slice. The 
 first function is the one we extracted in Listing 10-3 that finds the 
 largest i32 in a slice. The second function finds the largest char in a 
 slice: 
  
 Filename: src/main.rs",NA
4.3,"Traits: Defining Shared Behavior
  
 Traits allow us to use another kind of abstraction: they let us abstract 
 over behavior that types can have in common. A
  trait
  tells the Rust 
 compiler about functionality a particular type has and might share with 
 other types. In situations where we use generic type parameters, we 
 can use
  trait bounds
  to specify, at compile time, that the generic type 
 may be any type that implements a trait and therefore has the behavior 
 we want to use in that situation.
  
  
 Note: Traits are similar to a feature often called ‘inter-
 faces’ in other languages, though with some differences.
  
 Defining a Trait
  
 The behavior of a type consists of the methods we can call on that type. 
 Different types share the same behavior if we can call the same 
 methods on all of those types. Trait definitions are a way to group 
 method signatures together in order to define a set of behaviors 
 necessary to accomplish some purpose.
  
 For example, say we have multiple structs that hold various kinds 
 and amounts of text: a NewsArticle struct that holds a news story filed 
 in a particular place in the world, and a Tweet that can have at most 
 140 characters in its content along with metadata like whether it was a 
 retweet or a reply to another tweet.
  
 We want to make a media aggregator library that can display sum-
 maries of data that might be stored in a NewsArticle or Tweet in-stance. 
 The behavior we need each struct to have is that it’s able to be 
 summarized, and that we can ask for that summary by calling a 
 summary method on an instance. Listing 10-11 shows the definition of 
 a Summarizable trait that expresses this concept: 
  
 Filename: lib.rs
  
 pub trait
  Summarizable { 
  
 fn
  summary
 (
 &
 self) -> String; }
  
 Listing 10-11: Definition of a Summarizable trait that consists of the 
 behavior provided by a summary method 
  
 We declare a trait with the trait keyword, then the trait’s name, in this 
 case Summarizable. Inside curly braces we declare the method",NA
4.4,"Validating References with Lifetimes
  
 When we talked about references in Chapter 4, we left out an important 
 detail: every reference in Rust has a
  lifetime
 , which is the scope for 
 which that reference is valid. Most of the time lifetimes are implicit and 
 inferred, just like most of the time types are inferred. Similarly to when 
 we have to annotate types because multiple types are possible, there 
 are cases where the lifetimes of references could be related in a few 
 different ways, so Rust needs us to annotate the relationships using 
 generic lifetime parameters so that it can make sure the actual 
 references used at runtime will definitely be valid.
  
 Yes, it’s a bit unusual, and will be different to tools you’ve used in 
 other programming languages. Lifetimes are, in some ways, Rust’s most 
 distinctive feature.
  
 Lifetimes are a big topic that can’t be covered in entirety in this 
 chapter, so we’ll cover common ways you might encounter lifetime syn-
 tax in this chapter to get you familiar with the concepts. Chapter 19",NA
Chapter 5,NA,NA
Testing,"Program testing can be a very effective way to show the 
 presence of bugs, but it is hopelessly inadequate for showing 
 their absence.
  
 Edsger W. Dijkstra, “The Humble Programmer” (1972)
  
 Correctness in our programs means that our code does what we intend 
 for it to do. Rust is a programming language that cares a lot about 
 correctness, but correctness is a complex topic and isn’t easy to prove. 
 Rust’s type system shoulders a huge part of this burden, but the type 
 system cannot catch every kind of incorrectness. As such, Rust includes 
 support for writing software tests within the language itself.
  
 As an example, say we write a function called add_two that adds 
  
  
 This function’s signature accepts an two to a number passed to it.
  
 integer as a parameter and returns an integer as a result. When we 
 implement and compile that function, Rust will do all the type checking 
 and borrow checking that we’ve seen so far. Those checks will make 
 sure that, for instance, we aren’t passing a String value or an invalid 
 reference to this function. What Rust
  can’t
  check is that this function 
 will do precisely what we intend: return the parameter plus two, rather 
 than, say, the parameter plus 10 or the parameter minus 50! That’s 
 where tests come in.
  
 We can write tests that assert, for example, that when we pass 3 to 
 the add_two function, we get 5 back. We can run these tests whenever 
 we make changes to our code to make sure any existing correct 
 behavior has not changed.
  
 Testing is a complex skill, and we cannot hope to cover everything 
 about how to write good tests in one chapter of a book, so here we’ll",NA
5.1,"How to Write Tests
  
 Tests are Rust functions that verify non-test code is functioning in the 
 program in the expected manner. The bodies of test functions typically 
 contain some setup, running the code we want to test, then asserting 
 that the results are what we expect. Let’s look at the features Rust 
 provides specifically for writing tests: the test attribute, a few macros, 
 and the should_panic attribute.
  
 The Anatomy of a Test Function
  
 At its simplest, a test in Rust is a function that’s annotated with the test 
 attribute. Attributes are metadata about pieces of Rust code: the derive 
 attribute that we used with structs in Chapter 5 is one example. To 
 make a function into a test function, we add #[test] on the line before 
 fn. When we run our tests with the cargo test command, Rust will build 
 a test runner binary that runs the functions annotated with the test 
 attribute and reports on whether each test function passes or fails.
  
  
 We saw in Chapter 7 that when you make a new library project with 
 Cargo, a test module with a test function in it is automatically generated 
 for us. This is to help us get started writing our tests, since we don’t 
 have to go look up the exact structure and syntax of test functions every 
 time we start a new project. 
  
 We can add as many 
 additional test functions and as many test modules as we want, though!
  
 We’re going to explore some aspects of how tests work by experi-
 menting with the template test generated for us, without actually test-
 ing any code. Then we’ll write some real-world tests that call some code 
 that we’ve written and assert that its behavior is correct.
  
 Let’s create a new library project called adder:
  
 $ cargo new adder 
  
  
 Created library `adder` project $ cd 
 adder",NA
5.2,"Controlling How Tests are Run
  
 Just as cargo run compiles your code and then runs the resulting binary, 
 cargo test compiles your code in test mode and runs the resulting test 
 binary. There are options you can use to change the de-fault behavior of 
 cargo test. For example, the default behavior of the binary produced by 
 cargo test is to run all the tests in parallel and capture output generated 
 during test runs, preventing it from be-ing displayed to make it easier 
 to read the output related to the test results. You can change this 
 default behavior by specifying command line options.
  
 Some command line options can be passed to cargo test, and some 
 need to be passed instead to the resulting test binary. To separate these 
 two types of arguments, you list the arguments that go to cargo test, 
 then the separator --, and then the arguments that go to the test binary. 
 Running cargo test --help will tell you about the options that go with 
 cargo test, and running cargo test -- --help will tell you about the 
 options that go after the separator --.
  
 Running Tests in Parallel or Consecutively
  
 When multiple tests are run, by default they run in parallel using 
 threads. This means the tests will finish running faster, so that we can 
 get faster feedback on whether or not our code is working. Since the 
 tests are running at the same time, you should take care that your tests 
 do not depend on each other or on any shared state, including a shared 
 environment such as the current working directory or environ-ment 
 variables.
  
 For example, say each of your tests runs some code that creates a 
 file on disk named test-output.txt and writes some data to that file. 
 Then each test reads the data in that file and asserts that the file 
 contains a particular value, which is different in each test. Because the 
 tests are all run at the same time, one test might overwrite the file 
 between when another test writes and reads the file. The second test 
 will then fail, not because the code is incorrect, but because the tests",NA
5.3,"Test Organization
  
 As mentioned at the start of the chapter, testing is a large discipline, 
 and different people use different terminology and organization. The 
 Rust community tends to think about tests in terms of two main cate-
 gories:
  unit tests
  and
  integration tests
 . Unit tests are smaller and more 
 focused, testing one module in isolation at a time, and can test private 
 interfaces. Integration tests are entirely external to your library, and 
 use your code in the same way any other external code would, using 
 only the public interface and exercising multiple modules per test.
  
  
 Both kinds of tests are important to ensure that the pieces of your 
 library are doing what you expect them to separately and together.
  
 Unit Tests
  
 The purpose of unit tests is to test each unit of code in isolation from 
 the rest of the code, in order to be able to quickly pinpoint where code 
 is and is not working as expected. We put unit tests in the
  src
  directory, 
 in each file with the code that they’re testing. The convention is that we 
 create a module named tests in each file to contain the test functions, 
 and we annotate the module with cfg(test).
  
 The Tests Module and #[cfg(test)] 
  
 The #[cfg(test)] anno-
 tation on the tests module tells Rust to compile and run the test code 
 only when we run cargo test, and not when we run cargo build. This 
 saves compile time when we only want to build the library, and saves 
 space in the resulting compiled artifact since the tests are not in-cluded. 
 We’ll see that since integration tests go in a different directory, they 
 don’t need the #[cfg(test)] annotation. Because unit tests go in the same 
 files as the code, though, we use #[cfg(test)]to specify that they should 
 not be included in the compiled result.
  
  
 Remember that when we generated the new adder project in the 
 first section of this chapter, Cargo generated this code for us: 
  
  
 Filename: src/lib.rs
  
 #[cfg(test)] 
  
 mod
  tests { 
  
  
 #[test] 
  
  
 fn
  it_works
 () {",NA
Chapter 6,NA,NA
An I/O Project Building a ,NA,NA
Small Grep,"This chapter is both a recap of the many skills you’ve learned so far and 
 an exploration of a few more standard library features. We’re going to 
 build a command-line tool that interacts with file and command line 
 input/output to practice some of the Rust you now have under your 
 belt.
  
 Rust’s speed, safety, ‘single binary’ output, and cross-platform sup-
 port make it a good language for creating command line tools, so for 
 our project we’ll make our own version of the classic command line tool 
 grep. Grep is an acronym for “Globally search a Regular Expression and 
 Print.” In the simplest use case, grep searches a specified file for a 
 specified string using the following steps:
  
 • Take as arguments a filename and a string.
  
 • Read the file.
  
 • Find lines in the file that contain the string argument.
  
 • Print out those lines.
  
 We’ll also show how to use environment variables and print to 
 standard error instead of standard out; these techniques are commonly 
 used in command line tools.
  
 One Rust community member, Andrew Gallant, has already cre-ated 
 a fully-featured, very fast version of grep, called ripgrep. By 
 comparison, our version of grep will be fairly simple, this chapter will",NA
6.1,"Accepting Command Line Arguments
  
 Our first task is to make greprs able to accept its two command line 
 arguments: the filename and a string to search for. That is, we want to 
 be able to run our program with cargo run, a string to search for, and a 
 path to a file to search in, like so:
  
 $ cargo run searchstring example-filename.txt
  
 Right now, the program generated by cargo new ignores any argu-
 ments we give it. There are some existing libraries on crates.io that can 
 help us accept command line arguments, but since we’re learning, let’s 
 implement this ourselves.",NA
6.2,"Reading a File
  
 Next, we’re going to read the file that we specify in the filename com-
 mand line argument. First, we need a sample file to test it with---the 
 best kind of file to use to make sure that greprs is working is one with a 
 small amount of text over multiple lines with some repeated words. 
 Listing 12-3 has an Emily Dickinson poem that will work well! Create a 
 file called poem.txt at the root level of your project, and enter the poem 
 “I’m nobody! Who are you?”: 
  
 Filename: poem.txt",NA
6.3,"Refactoring to Improve Modularity and Error Han-dling
  
 There are four problems that we’d like to fix to improve our program, 
 and they have to do with the way the program is structured and how 
 it’s handling potential errors.
  
 First, our main function now performs two tasks: it parses argu-
 ments and opens up files. For such a small function, this isn’t a huge 
 problem. However, if we keep growing our program inside of main, the 
 number of separate tasks the main function handles will grow. As a 
 function gains responsibilities, it gets harder to reason about, harder to 
 test, and harder to change without breaking one of its parts. It’s better 
 to separate out functionality so that each function is responsible for one 
 task.
  
 This also ties into our second problem: while query and filename are 
 configuration variables to our program, variables like f and contents are 
 used to perform our program’s logic. The longer main gets, the more 
 variables we’re going to need to bring into scope; the more variables we 
 have in scope, the harder it is to keep track of the purpose of each. It’s 
 better to group the configuration variables into one structure to make 
 their purpose clear.
  
 The third problem is that we’ve used expect to print out an error 
 message if opening the file fails, but the error message only says file not 
 found. There are a number of ways that opening a file can fail besides a 
 missing file: for example, the file might exist, but we might not have 
 permission to open it. Right now, if we’re in that situation, we’d print 
 the file not found error message that would give the user the wrong 
 advice!
  
  
 Fourth, we use expect repeatedly to deal with different errors, and if 
 the user runs our programs without specifying enough arguments, 
 they’ll get an “index out of bounds” error from Rust that doesn’t clearly 
 explain the problem. It would be better if all our error handling code was 
 in one place so that future maintainers only have one place to consult in 
 the code if the error handling logic needs to change. Having all the error 
 handling code in one place will also help us to ensure that we’re printing 
 messages that will be meaningful to our end users. 
  
 Let’s address 
 these problems by refactoring our project.",NA
6.4,"Testing the Library’s Functionality
  
 Now that we’ve extracted the logic into
  src/lib.rs
  and left all the ar-
 gument parsing and error handling in
  src/main.rs
 , it’s much easier for 
 us to write tests for the core functionality of our code. We can call our 
 functions directly with various arguments and check return values 
 without having to call our binary from the command line.
  
 In this section, we’re going to follow the Test Driven Development 
 (TDD) process. This is a software development technique that follows 
 this set of steps:
  
 1. Write a test that fails, and run it to make sure it fails for the reason 
 you expected.
  
 2. Write or modify just enough code to make the new test pass.",NA
6.5,"Working with Environment Variables
  
 We’re going to improve our tool with an extra feature: an option for 
 case insensitive searching turned on via an environment variable. We 
 could make this a command line option and require that users enter it 
 each time they want it to apply, but instead we’re going to use an 
 environment variable. 
  
 This allows our users to set the environment 
 variable once and have all their searches be case insensitive in that 
 terminal session.
  
 Writing a Failing Test for the Case-Insensitive search Function
  
 First, let’s add a new function that we will call when the environment 
 variable is on.
  
 We’re going to continue following the TDD process that we started 
 doing in the last section, and the first step is again to write a failing test. 
 We’ll add a new test for the new case insensitive search function, and 
 rename our old test from one_result to case_sensitive to be clearer 
 about the differences between the two tests, as shown in Listing 12-20: 
  
 Filename: src/lib.rs
  
 #[cfg(test)] 
  
 mod
  test { 
  
 use super
 ::
 *
 ;
  
 #[test] 
  
 fn
  case_sensitive
 () { 
  
  
 let
  query
  =
  ""duct""
 ; 
  
  
 let
  contents
  =
  ""\ 
  
 Rust: 
  
 safe, fast, productive. 
  
 Pick three.
  
 Duct tape.""
 ;
  
 assert_eq!( 
  
  
 vec![
 ""safe, fast, productive.""
 ], 
  
 search
 (query, contents) 
  
 );",NA
6.6,"Write to stderr Instead of stdout
  
 Right now, we’re writing all of our output to the terminal with println!. 
 Most terminals provide two kinds of output: “standard out” for general 
 information, and “standard error” for error messages. This distinction is 
 the behavior that’s expected of command line programs: it enables users 
 to choose to direct a program’s successful output to a file but still print 
 error messages to the screen, for example. println! is only ca-pable of 
 printing to standard out, though, so we have to use something else in 
 order to print to standard error.
  
 We can verify that, the way we’ve written greprs so far, everything 
 is being written to standard out, including error messages that should 
 be written to standard error instead. We’ll do that by intentionally 
 causing an error, the one that happens when we run the program with-
 out any arguments. We’re going to redirect standard output to a file, but 
 not standard error. The way command line programs are expected to 
 work is that, because the output is an error message, it should be 
 shown on the screen rather than being redirected to the file. Let’s see 
 that our program is not currently meeting this expectation by using > 
 and specifying a filename,
  output.txt
 , that we want to redirect standard 
 out to:
  
 $ cargo run > output.txt
  
 The > syntax tells the shell to write the contents of standard out to 
 output.txt
  instead of the screen. We didn’t see the error message we 
 were expecting printed on the screen, so that means it must have ended 
 up in the file. Let’s see what
  output.txt
  contains:",NA
Part III ,NA,NA
Thinking in Rust,NA,NA
Chapter 1,NA,NA
Functional Language ,NA,NA
features in Rust: ,NA,NA
Iterators and Closures,"Rust’s design has taken inspiration from a lot of existing languages and 
 techniques, and one significant influence is
  functional program-ming
 . 
 Programming in a functional style often includes using functions as 
 values in arguments or return values of other functions, assigning 
 functions to variables for later execution, and so forth. We won’t de-
 bate here the issue of what, exactly, functional programming is or is not, 
 but will instead show off some features of Rust that are similar to 
 features in many languages often referred to as functional.
  
 More specifically, we’re going to cover:
  
 •
  Closures
 : a function-like construct you can store in a variable.
  
 •
  Iterators
 : a way of processing a series of elements.
  
 • How to use these features to improve on the I/O project from 
 Chapter 12.
  
 • The performance of these features. Spoiler alert: they’re faster than 
 you might think!
  
 There are other Rust features influenced by the functional style, like 
 pattern matching and enums, that we’ve covered in other chapters as 
 well. Mastering closures and iterators is an important part of writing",NA
1.1,"Closures: Anonymous Functions that can Capture their 
 Environment
  
 Rust’s
  closures
  are anonymous functions that you can save in a variable 
 or pass as arguments to other functions. You can create the closure in 
 one place, and then call the closure to evaluate it in a different context. 
 Unlike functions, closures are allowed to capture values from the scope 
 in which they are called. We’re going to demonstrate how these 
 features of closures allow for code reuse and customization of behavior.
  
 Creating an Abstraction of Behavior Using a Closure
  
 Let’s work on an example that will show a situation where storing a 
 closure to be executed at a later time is useful. We’ll talk about the 
 syntax of closures, type inference, and traits along the way.
  
  
 The hypothetical situation is this: we’re working at a startup that’s 
 making an app to generate custom exercise workout plans. The back-
 end is written in Rust, and the algorithm that generates the workout 
 plan takes into account many different factors like the app user’s age, 
 their Body Mass Index, their preferences, their recent workouts, and an 
 intensity number they specify. The actual algorithm used isn’t impor-
 tant in this example; what’s important is that this calculation takes a few 
 seconds. We only want to call this algorithm if we need to, and we only 
 want to call it once, so that we aren’t making the user wait more than 
 they need to. We’re going to simulate calling this hypothetical algorithm 
 by calling the simulated_expensive_calculation function shown in Listing 
 13-1 instead, which will print calculating slowly. .., wait for two seconds, 
 and then return whatever number we passed in: 
  
  
 Filename: src/main.rs
  
 use
  std::thread; 
  
 use
  std::time::Duration;
  
 fn
  simulated_expensive_calculation
 (intensity:
  i32
 ) ->
  i32 
 {",NA
1.2,"Processing a Series of Items with Iterators
  
 The iterator pattern allows you to perform some task on a sequence of 
 items in turn. An
  iterator
  is responsible for the logic around iterating 
 over each item in the sequence and determining when the sequence has 
 finished. When we use iterators, we don’t have to reimplement that 
 logic ourselves.
  
 In Rust, iterators are
  lazy
 , which means they have no effect until we 
 call methods on them that consume the iterator to use it up. For 
 example, the code in Listing 13-13 creates an iterator over the items in 
 the vector v1 by calling the iter method defined on Vec. This code by 
 itself doesn’t do anything useful:
  
 let
  v1
  =
  vec![
 1
 ,
  2
 ,
  3
 ];
  
 let
  v1_iter
  =
  v1.
 iter
 ();
  
 Listing 13-13: Creating an iterator; this by itself isn’t useful 
  
  
 After creating an iterator, we can choose to use it in a variety of 
 ways. 
  
 In Listing 3-6, we actually used iterators with for loops to 
 execute some code on each item, though we glossed over what the call 
 to iter did until now. 
  
 The example in Listing 13-14 separates the 
 creation of the iterator from the use of the iterator in the for loop. The 
 iterator is stored in the v1_iter variable, and no iteration takes place at 
 that time. Once the for loop is called using the iterator in v1_iter, then 
 each element in the iterator is used in one iteration of the loop, which 
 prints out each value:
  
 let
  v1
  =
  vec![
 1
 ,
  2
 ,
  3
 ];
  
 let
  v1_iter
  =
  v1.
 iter
 ();
  
 for
  val
  in
  v1_iter { 
  
  
 println!(
 ""Got:
  {}
 ""
 , val); 
  
 }
  
 Listing 13-13: Making use of an iterator in a for loop 
  
  
 In languages that don’t have iterators provided by their standard 
 libraries, we would likely write this same functionality by starting a 
 variable at index 0, using that variable to index into the vector to get a 
 value, and incrementing the variable value in a loop until its value gets",NA
1.3,"Improving our I/O Project
  
 We can improve our implementation of the I/O project in Chapter 12 by 
 using iterators to make places in the code clearer and more concise. 
 Let’s take a look at how iterators can improve our implementation of 
 both the Config::new function and the search function.
  
 Removing a clone Using an Iterator
  
 In Listing 12-13, we had code that took a slice of String values and 
 created an instance of the Config struct by checking for the right num-
 ber of arguments, indexing into the slice, and cloning the values so that 
 the Config struct could own those values. We’ve reproduced the code 
 here in Listing 13-23: 
  
  
 Filename: src/main.rs
  
 impl
  Config { 
  
  
 fn
  new
 (args:
  &
 [String]) -> Result<Config,
  &'static str
 > { 
  
  
  
 if
  args.
 len
 ()
  <
  3
  { 
  
  
  
 return
  Err
 (
 ""not enough arguments""
 );
  
 }
  
 let
  query
  =
  args[
 1
 ].
 clone
 (); 
 let
  
 filename
  =
  args[
 2
 ].
 clone
 ();",NA
1.4,"Comparing Performance: Loops versus Iterators
  
 To determine which to use, we need to know which version of our 
 search functions is faster: the version with an explicit for loop or the 
 version with iterators.
  
 We ran a benchmark by loading the entire contents of “The Adven-
 tures of Sherlock Holmes” by Sir Arthur Conan Doyle into a String and 
 looking for the word “the” in the contents. Here were the results of the 
 benchmark on the version of search using the for loop and the version 
 using iterators:",NA
Chapter 2,NA,NA
More about Cargo and ,NA,NA
Crates.io,"We’ve used some features of Cargo in this book so far, but only the most 
 basic ones. We’ve used Cargo to build, run, and test our code, but it can 
 do a lot more. Let’s go over some of its other features now. Cargo can do 
 even more than what we will cover in this chapter; for a full 
 explanation, see its documentation.
  
 We’re going to cover:
  
 • Customizing your build through release profiles
  
 • Publishing libraries on crates.io
  
 • Organizing larger projects with workspaces
  
 • Installing binaries from crates.io
  
 • Extending Cargo with your own custom commands",NA
2.1,"Release profiles
  
 Cargo supports a notion of
  release profiles
 . These profiles control vari-
 ous options for compiling your code and let you configure each profile 
 independently of the others. You’ve seen a hint of this feature in the 
 output of your builds:",NA
2.2,"Publishing a Crate to Crates.io
  
 We’ve added crates from crates.io as dependencies of our project. We 
 can choose to share our code for other people to use as well. Crates.io 
 distributes the source code of your packages, so it is primarily used to 
 distribute code that’s open source.
  
 Rust and Cargo have some features that can make your published 
 package easier for people to find and use. We’ll talk about some of those 
 features, then cover how to publish a package.
  
 Documentation Comments
  
 In Chapter 3, we saw comments in Rust that start with //. Rust also has 
 a second kind of comment: the
  documentation comment
 . While 
 comments can be useful if someone is reading your code, you can 
 gener-ate HTML documentation that displays the contents of 
 documentation comments for public API items meant for someone 
 who’s interested in knowing how to
  use
  your crate, as opposed to how 
 your crate is
  imple-mented
 . Note that documentation is only generated 
 for library crates, since binary crates don’t have a public API that 
 people need to know how to use.
  
 Documentation comments use /// instead of // and support Mark-
 down notation inside. They go just before the item they are document-
 ing. Here’s documentation comments for an add_one function: 
  
 Filename: src/lib.rs
  
 /// Adds one to the number given.
  
 /// 
  
 /// # Examples 
  
 /// 
  
 /// ``` 
  
 /// let five = 5; 
  
 /// 
  
 /// assert_eq!(6, add_one(five)); /// ``` 
  
 pub fn
  add_one
 (x:
  i32
 ) ->
  i32
  { x
  +
  1 
  
 }
  
 Listing 14-1: A documentation comment for a function",NA
2.3,"Cargo Workspaces
  
 In Chapter 12, we built a package that included both a binary crate and a 
 library crate. But what if the library crate continues to get bigger and we 
 want to split our package up further into multiple library crates? As 
 packages grow, separating out major components can be quite useful. In 
 this situation, Cargo has a feature called
  workspaces
  that can help us 
 manage multiple related packages that are developed in tandem. A
  
 workspace
  is a set of packages that will all share the same
  Cargo.lock 
 and 
 output directory. Let’s make a project using a workspace where the code 
 will be trivial so that we can concentrate on the structure of a workspace. 
 We’ll have a binary that uses two libraries: one that will provide an 
 add_one method and a second that will provide an add_two method. Let’s 
 start by creating a new crate for the binary:
  
 $ cargo new --bin adder 
  
  
 Created binary (application) `adder` project $ cd adder
  
 We need to modify the binary package’s
  Cargo.toml
  to tell Cargo the 
 adder package is a workspace. Add this at the bottom of the file:
  
 [workspace]
  
 Like many Cargo features, workspaces support convention over con-
 figuration: we don’t need to say anything more than this as long as we 
 follow the convention. The convention is that any crates that we 
 depend on as sub-directories will be part of the workspace. Let’s add a 
 path dependency to the adder crate by changing the [dependencies] 
 section of
  Cargo.toml
  to look like this:
  
 [dependencies] 
  
 add-one = { path = ""add-one"" }
  
 If we add dependencies that don’t have a path specified, those will be 
 normal dependencies that aren’t in this workspace.
  
 Next, generate the add-one crate within the adder directory:
  
 $ cargo new add-one 
  
  
 Created library `add-one` project
  
 Your adder directory should now have these directories and files:",NA
2.4,"Installing Binaries from Crates.io with cargo install
  
 The cargo install command allows you to install and use binary crates 
 locally. This isn’t intended to replace system packages; it’s meant to be 
 a convenient way for Rust developers to install tools that others have 
 shared on crates.io. Only packages which have binary targets can be 
 installed, and all binaries are installed into the installation root’s
  bin 
 folder. If you installed Rust using
  rustup.rs
  and don’t have any custom 
 configurations, this will be $HOME/.cargo/bin. Add that directory to 
 your $PATH to be able to run programs you’ve gotten through cargo 
 install.
  
 For example, we mentioned in Chapter 12 that there’s a Rust im-
 plementation of the grep tool for searching files called ripgrep. If we 
 want to install ripgrep, we can run:
  
 $ cargo install ripgrep 
  
 Updating registry `https://github.com/rust-lang/crates.
  
 io-index` 
  
 Downloading ripgrep v0.3.2 
  
 ...snip...
  
   
 Compiling ripgrep v0.3.2 
  
   
 Finished release [optimized + debuginfo] target(s) in 97.91 
 secs 
  
  
 Installing ~/.cargo/bin/rg
  
 The last line of the output shows the location and the name of the 
 installed binary, which in the case of ripgrep is named rg. As long as the 
 installation directory is in our $PATH as mentioned above, we can then 
 run rg --help and start using a faster, rustier tool for searching files!",NA
2.5,"Extending Cargo with Custom Commands
  
 Cargo is designed to be extensible with new subcommands without 
 having to modify Cargo itself. 
  
 If a binary in your $PATH is named 
 cargo-something, you can run it as if it were a Cargo subcommand by 
 running cargo something. Custom commands like this are also listed 
 when you run cargo --list. It’s convenient to cargo install extensions to 
 Cargo then be able to run them just like the built-in Cargo tools!
  
 Summary
  
 Sharing code with Cargo and crates.io is part of what makes the Rust 
 ecosystem useful for many different tasks. Rust’s standard library is 
 small and stable, but crates are easy to share, use, and improve on a 
 different timeline than the language itself. Don’t be shy about sharing 
 code that’s useful to you on crates.io; it’s likely that it will be useful to 
 someone else as well!",NA
Chapter 3,NA,NA
Smart Pointers,"Pointer
  is a generic programming term for something that refers to a lo-
 cation that stores some other data. We learned about Rust’s references 
 in Chapter 4; they’re a plain sort of pointer indicated by the & sym-bol 
 and borrow the value that they point to.
  Smart pointers
  are data 
 structures that act like a pointer, but also have additional metadata and 
 capabilities, such as reference counting. The smart pointer pattern 
 originated in C++. In Rust, an additional difference between plain 
 references and smart pointers is that references are a kind of pointer 
 that only borrow data; by contrast, in many cases, smart pointers
  own 
 the data that they point to.
  
 We’ve actually already encountered a few smart pointers in this 
 book, even though we didn’t call them that by name at the time. For 
 example, in a certain sense, String and Vec<T> from Chapter 8 are both 
 smart pointers. They own some memory and allow you to manip-ulate 
 it, and have metadata (like their capacity) and extra capabilities or 
 guarantees (String data will always be valid UTF-8). The charac-
 teristics that distinguish a smart pointer from an ordinary struct are 
 that smart pointers implement the Deref and Drop traits, and in this 
 chapter we’ll be discussing both of those traits and why they’re impor-
 tant to smart pointers.
  
 Given that the smart pointer pattern is a general design pattern 
 used frequently in Rust, this chapter won’t cover every smart pointer 
 that exists. Many libraries have their own and you may write some 
 yourself. The ones we cover here are the most common ones from the 
 standard library:
  
 • Box<T>, for allocating values on the heap",NA
3.1,"Box<T> Points to Data on the Heap and Has a Known 
 Size
  
 The most straightforward smart pointer is a
  box
 , whose type is written 
 Box<T>. Boxes allow you to put a single value on the heap (we talked 
 about the stack vs. the heap in Chapter 4). Listing 15-1 shows how to 
 use a box to store an i32 on the heap: 
  
  
 Filename: src/main.rs
  
 fn
  main
 () { 
  
  
 let
  b
  =
  Box
 ::new(
 5
 );
  
 println!(
 ""b =
  {}
 ""
 , b);
  
 }
  
 Listing 15-1: Storing an i32 value on the heap using a box 
  
  
 This will print b = 5. In this case, we can access the data in the box in 
 a similar way as we would if this data was on the stack. Just like any 
 value that has ownership of data, when a box goes out of scope like b 
 does at the end of main, it will be deallocated. The deallocation happens 
 for both the box (stored on the stack) and the data it points to (stored 
 on the heap).
  
 Putting a single value on the heap isn’t very useful, so you won’t use 
 boxes by themselves in the way that Listing 15-1 does very often. A 
 time when boxes are useful is when you want to ensure that your type",NA
3.2,"The Deref Trait Allows Access to the Data Through a 
 Reference
  
 The first important smart pointer-related trait is Deref, which allows us 
 to override *, the dereference operator (as opposed to the 
 multiplication operator or the glob operator). Overriding * for smart 
 pointers makes accessing the data behind the smart pointer convenient, 
 and we’ll talk about what we mean by convenient when we get to deref 
 coercions later in this section.
  
 We briefly mentioned the dereference operator in Chapter 8, in the 
 hash map section titled “Update a Value Based on the Old Value”. We 
 had a mutable reference, and we wanted to change the value that",NA
3.3,"The Drop Trait Runs Code on Cleanup
  
 The other trait that’s important to the smart pointer pattern is the Drop 
 trait. Drop lets us run some code when a value is about to go out of 
 scope. Smart pointers perform important cleanup when being dropped, 
 like deallocating memory or decrementing a reference count.
  
 More generally, data types can manage resources beyond memory, like 
 files or network connections, and use Drop to release those resources 
 when our code is done with them. We’re discussing Drop in the context 
 of smart pointers, though, because the functionality of the Drop trait is 
 almost always used when implementing smart pointers.
  
 In some other languages, we have to remember to call code to free the 
 memory or resource every time we finish using an instance of a smart 
 pointer. If we forget, the system our code is running on might get 
 overloaded and crash. In Rust, we can specify that some code should be 
 run when a value goes out of scope, and the compiler will insert this code 
 automatically. That means we don’t need to remember to put this code 
 everywhere we’re done with an instance of these types, but we still won’t 
 leak resources!
  
 The way we specify code should be run when a value goes out of 
 scope is by implementing the Drop trait. The Drop trait requires us to 
 implement one method named drop that takes a mutable reference to 
 self.
  
 Listing 15-8 shows a CustomSmartPointer struct that doesn’t actu-ally do 
 anything, but we’re printing out CustomSmartPointer created.
  
 right after we create an instance of the struct and Dropping CustomSmartPointer 
 when the instance goes out of scope so that we can see when each piece 
  
 of code gets run. Instead of a println! statement, you’d fill in drop 
  
 with whatever cleanup code your smart pointer needs to run: 
  
 Filename: src/main.rs
  
 struct
  CustomSmartPointer { 
  
 data: String, 
  
 }",NA
3.4,"Rc<T>, the Reference Counted Smart Pointer
  
 In the majority of cases, ownership is very clear: you know exactly 
 which variable owns a given value. However, this isn’t always the case; 
 sometimes, you may actually need multiple owners. For this, Rust has a 
 type called Rc<T>. Its name is an abbreviation for
  reference counting
 . 
 Reference counting means keeping track of the number of references to 
 a value in order to know if a value is still in use or not. If there are zero 
 references to a value, we know we can clean up the value without any 
 references becoming invalid.
  
 To think about this in terms of a real-world scenario, it’s like a TV in 
 a family room. When one person comes in the room to watch TV, they 
 turn it on. Others can also come in the room and watch the TV. When 
 the last person leaves the room, they’ll turn the TV off since it’s no 
 longer being used. If someone turns off the TV while others are still 
 watching it, though, the people watching the TV would get mad!
  
 Rc<T> is for use when we want to allocate some data on the heap 
 for multiple parts of our program to read, and we can’t determine at 
 compile time which part of our program using this data will finish using 
 it last. If we knew which part would finish last, we could make that part 
 the owner of the data and the normal ownership rules enforced at 
 compile time would kick in.
  
 Note that Rc<T> is only for use in single-threaded scenarios; the 
 next chapter on concurrency will cover how to do reference counting in 
 multithreaded programs. If you try to use Rc<T> with multiple threads, 
 you’ll get a compile-time error.
  
 Using Rc<T> to Share Data
  
 Let’s return to our cons list example from Listing 15-5. In Listing 15-11, 
 we’re going to try to use List as we defined it using Box<T>. First we’ll 
 create one list instance that contains 5 and then 10. Next, we want to 
 create two more lists: one that starts with 3 and continues on to our 
 first list containing 5 and 10, then another list that starts with 4 and
  
 also
  continues on to our first list containing 5 and 10. In other",NA
3.5,"RefCell<T> and the Interior Mutability Pattern
  
 Interior mutability
  is a design pattern in Rust for allowing you to mu-
 tate data even though there are immutable references to that data, 
 which would normally be disallowed by the borrowing rules. The inte-
 rior mutability pattern involves using unsafe code inside a data struc-
 ture to bend Rust’s usual rules around mutation and borrowing. We 
 haven’t yet covered unsafe code; we will in Chapter 19. The interior 
 mutability pattern is used when you can ensure that the borrowing 
 rules will be followed at runtime, even though the compiler can’t en-
 sure that. The unsafe code involved is then wrapped in a safe API, and 
 the outer type is still immutable.
  
  
 Let’s explore this by looking at the RefCell<T> type that follows the 
 interior mutability pattern.
  
 RefCell<T> has Interior Mutability
  
 Unlike Rc<T>, the RefCell<T> type represents single ownership over 
 the data that it holds. So, what makes RefCell<T> different than a type 
 like Box<T>? Let’s recall the borrowing rules we learned in Chapter 4:
  
 1. At any given time, you can have
  either
  but not both of:
  
 • One mutable reference.
  
 • Any number of immutable references.
  
 1. References must always be valid.
  
 With references and Box<T>, the borrowing rules’ invariants are en-
 forced at compile time. 
  
 With RefCell<T>, these invariants are en-
 forced
  at runtime
 . With references, if you break these rules, you’ll get",NA
3.6,"Creating Reference Cycles and Leaking Memory is Safe
  
 Rust makes a number of guarantees that we’ve talked about, for exam-
 ple that we’ll never have a null value, and data races will be disallowed 
 at compile time. Rust’s memory safety guarantees make it more dif-
 ficult to create memory that never gets cleaned up, which is known as a
  
 memory leak
 . Rust does not make memory leaks
  impossible
 , how-ever, 
 preventing memory leaks is
  not
  one of Rust’s guarantees. In other 
 words, memory leaks are memory safe.
  
  
 By using Rc<T> and RefCell<T>, it is possible to create cycles of 
 references where items refer to each other in a cycle. This is bad 
 because the reference count of each item in the cycle will never reach 0, 
 and the values will never be dropped. 
  
 Let’s take a look at how that 
 might happen and how to prevent it.
  
 In Listing 15-16, we’re going to use another variation of the List 
 definition from Listing 15-5. We’re going back to storing an i32 value as 
 the first element in the Cons variant. The second element in the Cons 
 variant is now RefCell<Rc<List>>: instead of being able to modify the 
 i32 value this time, we want to be able to modify which List a Cons 
 variant is pointing to. We’ve also added a tail method to make it 
 convenient for us to access the second item, if we have a Cons variant: 
 Filename: src/main.rs
  
 #[derive(Debug)] 
  
 enum
  List { 
  
  
 Cons(
 i32
 , RefCell<Rc<List>>), 
  
 Nil, 
  
 }
  
 impl
  List { 
  
  
 fn
  tail
 (
 &
 self) -> Option<
 &
 RefCell<Rc<List>>> { 
  
  
 match *
 self { 
  
  
  
 Cons(
 _
 ,
  ref
  item)
  =>
  Some
 (item), 
  
  
  
 Nil
  =>
  None
 ,",NA
Chapter 4,NA,NA
Fearless Concurrency,"Ensuring memory safety isn’t Rust’s only goal: being a language that is 
 better equipped to handle concurrent and parallel programming has 
 always been another major goal of Rust. 
  
 Concurrent programming
 , 
 where different parts of a program execute independently, and
  paral-lel 
 programming
 , where different parts of a program are executing at the 
 same time, are becoming more important as more computers have 
 multiple processors for our programs to take advantage of. Historically, 
 programming in these contexts has been difficult and error prone: Rust 
 hopes to change that.
  
 Originally, we thought that memory safety and preventing concur-rency 
 problems were two separate challenges to be solved with different 
 methods. However, over time, we discovered that ownership and the 
 type system are a powerful set of tools that help in dealing with both 
 memory safety
  and
  concurrency problems! 
  
 By leveraging ownership 
 and type checking, many concurrency errors are
  compile time
  errors in 
 Rust, rather than runtime errors. We’ve nicknamed this aspect of Rust
  
 fearless concurrency
 . Fearless concurrency means Rust not only allows 
 you to have confidence that your code is free of subtle bugs, but also 
 lets you refactor this kind of code easily without worrying about 
 introducing new bugs.
  
 Note: given that Rust’s slogan is fearless concurrency, 
 we’ll be referring to many of the problems here as concurrent 
 rather than being more precise by saying concurrent and/or 
 parallel, for simplicity’s sake. If this were a book specifically 
 about concurrency and/or parallelism, we’d be sure to be 
 more specific. For this chapter, please mentally substitute",NA
4.1,"Using Threads to Run Code Simultaneously
  
 In most operating systems in use today, when your program executes, 
 the context in which the operating system runs your code is called a 
 process
 . The operating system runs many processes, and the operating 
 system managing these processes is what lets multiple programs 
 execute at the same time on your computer.
  
 We can take the idea of processes each running a program down 
 one level of abstraction: your program can also have independent parts 
 that run simultaneously within the context of your program. The 
 feature that enables this functionality is called
  threads
 .
  
 Splitting up the computation your program needs to do into multi-
 ple threads can improve performance, since the program will be doing 
 multiple things at the same time. Programming with threads can add",NA
4.2,"Message Passing to Transfer Data Between Threads
  
 One approach to concurrency that’s seen a rise in popularity as of late is
  
 message passing
 , where threads or actors communicate by sending each 
 other messages containing data. Here’s the idea in slogan form:",NA
4.3,"Shared State Concurrency
  
 While message passing is a fine way of dealing with concurrency, it’s 
 not the only one. Consider this slogan again:
  
  
 Do not communicate by sharing memory; instead, share 
 memory by communicating.
  
 What would “communicate by sharing memory” look like? And more-
 over, why would message passing enthusiasts dislike it, and dislike it 
 enough to invert it entirely?
  
 Remember how channels are sort of like single ownership? Shared 
 memory concurrency is sort of like multiple ownership: multiple 
 threads can access the same memory location at the same time. As we 
 saw with multiple ownership made possible by smart pointers in 
 Chapter 15, multiple ownership can add additional complexity, since 
 we need to manage these different owners somehow.
  
 Rust’s type system and ownership can help a lot here in getting this 
 management correct, though. For an example, let’s look at one of the 
 more common concurrency primitives for shared memory: mutexes.
  
 Mutexes Allow Access to Data from One Thread at a Time
  
 A
  mutex
  is a concurrency primitive for sharing memory. It’s short 
 for“mutual exclusion”, that is, it only allows one thread to access some 
 data at any given time. Mutexes have a reputation for being hard to use, 
 since there’s a lot you have to remember:
  
 1. You have to remember to attempt to acquire the lock before using 
  
 the data.
  
 2. Once you’re done with the data that’s being guarded by the mutex, 
 you have to remember to unlock the data so that other threads 
 can acquire the lock.
  
 For a real-world example of a mutex, imagine a panel discussion at a 
 conference where there is only one microphone. Before a panelist may 
 speak, they have to ask or signal that they would like to use the 
 microphone. Once they get the microphone, they may talk for as long as 
 they would like, then hand the microphone to the next panelist who 
 would like to speak. 
  
 It would be rude for a panelist to start",NA
4.4,"Extensible Concurrency with the Sync and Send Traits
  
 One interesting aspect of Rust’s concurrency model is that the lan-
 guage knows
  very
  little about concurrency. Almost everything we’ve 
 been talking about so far has been part of the standard library, not the 
 language itself. Because we don’t need the language to provide every-
 thing we need to program in a concurrent context, we’re not limited to 
 the concurrency options that the standard library or language provide: 
 we can write our own or use ones others have written.
  
  
 We said
  almost
  everything wasn’t in the language, so what is? There 
 are two traits, both in std::marker: Sync and Send.
  
 Send for Indicating Ownership May Be Transferred to Another 
 Thread
  
 The Send marker trait indicates that ownership of that type may be 
 transferred between threads. Almost every Rust type is Send, but there 
 are some exceptions. One type provided by the standard library that is 
 not Send is Rc<T>: if we clone an Rc<T> value and try to transfer own-
 ership of the clone to another thread, both threads might update the 
 reference count at the same time. As we mentioned in the previous sec-
 tion, Rc<T> is implemented for use in single-threaded situations where 
 you don’t want to pay the performance penalty of having a threadsafe 
 reference count.
  
 Because Rc<T> is not marked Send, Rust’s type system and trait 
 bounds ensure that we can never forget and accidentally send an Rc<T> 
 value across threads unsafely. We tried to do this in Listing 16-14, and",NA
Chapter 5,NA,NA
Is Rust an ,NA,NA
Object-Oriented ,NA,NA
Programming Language?,"Object-Oriented Programming is a way of modeling programs that orig-
 inated with Simula in the 1960s and became popular with C++ in the 
 1990s. There are many competing definitions for what OOP is: under 
 some definitions, Rust is object-oriented; under other definitions, Rust 
 is not. In this chapter, we’ll explore some characteristics that are com-
 monly considered to be object-oriented and how those characteristics 
 translate to idiomatic Rust.",NA
5.1,"What Does Object-Oriented Mean?
  
 There isn’t consensus in the programming community about the fea-
 tures a language needs to have in order to be called object-oriented. 
 Rust is influenced by many different programming paradigms; we ex-
 plored the features it has that come from functional programming in 
 Chapter 13. Some of the characteristics that object-oriented program-
 ming languages tend to share are objects, encapsulation, and inheri-
 tance. Let’s take a look at what each of those mean and whether Rust 
 supports them.",NA
5.2,"Trait Objects for Using Values of Different Types
  
 In Chapter 8, we said that a limitation of vectors is that vectors can only 
 store elements of one type. We had an example in Listing 8-1 where we 
 defined a SpreadsheetCell enum that had variants to hold integers, 
 floats, and text so that we could store different types of data in each cell 
 and still have a vector represent a row of cells. This works for cases in 
 which the kinds of things we want to be able to treat interchangeably 
 are a fixed set of types that we know when our code gets compiled.
  
 Sometimes we want the set of types that we use to be extensible by 
 the programmers who use our library. For example, many Graphical 
 User Interface tools have a concept of a list of items that get drawn on 
 the screen by iterating through the list and calling a draw method on 
 each of the items. We’re going to create a library crate containing the 
 structure of a GUI library called rust_gui. Our GUI library could include 
 some types for people to use, such as Button or TextField. Programmers 
 that use rust_gui will want to create more types that can be drawn on 
 the screen: one programmer might add an Image, while another might 
 add a SelectBox. We’re not going to implement a fully-fledged GUI 
 library in this chapter, but we will show how the pieces would fit 
 together.
  
  
 When we’re writing the rust_gui library, we don’t know all the types 
 that other programmers will want to create, so we can’t define an enum 
 containing all the types. 
  
 What we do know is that rust_ gui 
 needs to be able to keep track of a bunch of values of all these different 
 types, and it needs to be able to call a draw method on each of these 
 values. Our GUI library doesn’t need to know what will happen exactly 
 when we call the draw method, just that the value will have that method 
 available for us to call.
  
 In a language with inheritance, we might define a class named 
 Component that has a method named draw on it. The other classes like 
 Button, Image, and SelectBox would inherit from Component and thus",NA
5.3,"Object-Oriented Design Pattern Implementation
  
 Let’s look at an example of the state design pattern and how to use it in 
 Rust. The
  state pattern
  is when a value has some internal state, and the 
 value’s behavior changes based on the internal state. The internal state 
 is represented by a set of objects that inherit shared functionality (we’ll 
 use structs and traits since Rust doesn’t have objects and inheritance). 
 Each state object is responsible for its own behavior and the rules for 
 when it should change into another state. The value that holds one of 
 these state objects doesn’t know anything about the different behavior 
 of the states or when to transition between states. In the future when 
 requirements change, we won’t need to change the code of the value 
 holding the state or the code that uses the value. We’ll only need to 
 update the code inside one of the state objects to change its rules, or 
 perhaps add more state objects.
  
 In order to explore this idea, we’re going to implement a blog post 
 workflow in an incremental way. The workflow that we want our blog 
 posts to follow, once we’re done with the implementation, is:
  
 1. A blog post starts as an empty draft.
  
 2. Once the draft is done, we request a review of the post.
  
 3. Once the post is approved, it gets published.
  
 4. Only published blog posts return content to print so that we can’t 
  
 accidentally print the text of a post that hasn’t been approved.",NA
Part IV ,NA,NA
Advanced Topics,NA,NA
Chapter 1,NA,NA
Patterns Match the ,NA,NA
Structure of Values,"Patterns are a special syntax within Rust for matching against the 
 structure of our types, complex or simple. A pattern is made up of some 
 combination of literals; destructured arrays, enums, structs, or tuples; 
 variables, wildcards, and placeholders. These pieces describe the 
 “shape” of the data we’re working with.
  
 We use a pattern by taking some value and comparing it against the 
 pattern. If the pattern matches our value, we do something with Recall 
 in Chapter 6 when we discussed the match the value parts.
  
 expression that uses patterns like a coin sorting machine. We can name 
 pieces within the shape, like we named the state that appeared on 
 quarters in Chapter 6, and if the data fits the shape, we can use the 
 named pieces.
  
 This chapter is a reference on all things related to patterns. We’ll 
 cover the valid places to use patterns, the difference between
  refutable 
 and
  irrefutable
  patterns, and the different kinds of pattern syntax that 
 you might see.",NA
1.1,"All the Places Patterns May be Used
  
 Patterns pop up in a number of places in Rust. You’ve been using them 
 a lot without realizing it! This section is a reference to all the places 
 where patterns are valid.",NA
1.2,"Refutability: Whether a Pattern Might Fail to Match
  
 Patterns come in two forms: refutable and irrefutable. Patterns which 
 cannot fail to match for any possible value are said to be
  irrefutable
 , and 
 patterns which can fail to match for some possible value are said to be
  
 refutable
 . let statements, function parameters, and for loops are 
 restricted to only accept irrefutable patterns, since there’s nothing 
 correct the program could do if the pattern fails to match. if let, and 
 while let expressions are restricted to only accept refutable patterns, 
 since they’re made to handle possible failure and we wouldn’t need 
 their functionality if the pattern could never fail.
  
 In general, you shouldn’t have to worry about the distinction be-
 tween refutable and irrefutable patterns; just be familiar with the con-
 cept of refutability when you see it mentioned in an error message. 
 When you get an error message involving refutability, you’ll need to 
 change either the pattern or the construct you’re using the pattern 
 with, depending on your intentions for the behavior of the code.
  
 Let’s look at some examples. Earlier in this chapter, we had let x = 
 5;. x is indeed an irrefutable pattern we’re allowed to use: since it 
 matches anything, it can’t fail to match. In contrast, consider trying to 
 match one variant of an enum with let, such as matching only a 
 Some<T> value from the Option<T> enum as shown in Listing 18-7:
  
 let
  Some
 (x)
  =
  some_option_value;
  
 Listing 18-7: Attempting to use a refutable pattern with let 
  
 If some_option_value was a None value, some_option_value would not 
 match the pattern Some(x). The pattern Some(x) is refutable since there 
 exists a case in which it would fail to match a value. There’s nothing 
 valid that our code could do with this let statement if some_ 
 option_value was the None value. Therefore, Rust will complain at 
 compile time that we’ve tried to use a refutable pattern where an ir-
 refutable pattern is required:",NA
1.3,"All the Pattern Syntax
  
 We’ve seen some examples of different kinds of patterns throughout 
 the book. This section lists all the syntax valid in patterns and why you 
 might want to use each of them.
  
 Literals
  
 As we saw in Chapter 6, you can match against literals directly:
  
 let
  x
  =
  1
 ;
  
 match
  x { 
  
 1
  =>
  println!(
 ""one""
 ), 
  
 2
  =>
  println!(
 ""two""
 ), 
  
 3
  =>
  println!(
 ""three""
 ), 
  
 _ =>
  println!(
 ""anything""
 ),
  
 }
  
 This prints one since the value in x is 1.
  
 Named Variables
  
 Named variables are irrefutable patterns that match any value.
  
 As with all variables, variables declared as part of a pattern will shadow 
 variables with the same name outside of the match construct since a 
 match starts a new scope. In Listing 18-10, we declare a variable named 
 x with the value Some(5) and a variable y with the value 10. Then we 
 have a match expression on the value x. Take a look at the patterns in 
 the match arms and the println! at the end, and make a guess about 
 what will be printed before running this code or reading further: 
  
 Filename: src/main.rs",NA
Chapter 2,NA,NA
Advanced Features,"We’ve come a long way! 
  
 By now, we’ve learned 99% of the things 
 you’ll need to know when writing Rust. Before we do one more project 
 in Chapter 20, let’s talk about a few things that you may run into that 
 last 1% of the time. Feel free to skip this chapter and come back to it 
 once you run into these things in the wild; the features we’ll learn to use 
 here are useful in very specific situations. We don’t want to leave these 
 features out, but you won’t find yourself reaching for them often.
  
 In this chapter, we’re going to cover:
  
 • Unsafe Rust: for when you need to opt out of some of Rust’s 
 guarantees and tell the compiler that you will be responsible for 
 upholding the guarantees instead
  
 • Advanced Lifetimes: Additional lifetime syntax for complex sit-
 uations
  
 • Advanced Traits: 
  
 Associated Types, default type parameters, 
 fully qualified syntax, supertraits, and the newtype pattern in 
 relation to traits
  
 • Advanced Types: some more about the newtype pattern, type 
 aliases, the “never” type, and dynamically sized types
  
 • Advanced Functions and Closures: function pointers and return-ing 
 closures
  
 It’s a panoply of Rust features with something for everyone! Let’s dive 
 in!",NA
2.1,"Unsafe Rust
  
 In all of the previous chapters in this book, we’ve been discussing code 
 written in Rust that has memory safety guarantees enforced at compile 
 time. 
  
 However, Rust has a second language hiding out inside of it, 
 unsafe Rust, which does not enforce these memory safety guarantees. 
 Unsafe Rust works just like regular Rust does, but it gives you extra 
 superpowers not available in safe Rust code.
  
 Unsafe Rust exists because, by nature, static analysis is conserva-
 tive. When trying to determine if code upholds some guarantees or not, 
 it’s better to reject some programs that are valid than it is to accept 
 some programs that are invalid. There are some times when your code 
 might be okay, but Rust thinks it’s not! In these cases, you can use 
 unsafe code to tell the compiler, “trust me, I know what I’m doing.”The 
 downside is that you’re on your own; if you get unsafe code wrong, 
 problems due to memory unsafety like null pointer dereferencing can 
 occur.
  
 There’s another reason that Rust needs to have unsafe code: the 
 underlying hardware of computers is inherently not safe. If Rust didn’t 
 let you do unsafe operations, there would be some tasks that you 
 simply could not do. But Rust needs to be able to let you do low-level 
 systems programming like directly interacting with your operating 
 system, or even writing your own operating system! That’s part of the 
 goals of the language. We need some way to do these kinds of things.
  
 Unsafe Superpowers
  
 We switch into unsafe Rust by using the unsafe keyword and starting a 
 new block that holds the unsafe code. There are four actions that you 
 can take in unsafe Rust that you can’t in safe Rust. We call these the 
 “unsafe superpowers.” We haven’t seen most of these features yet since 
 they’re only usable with unsafe!
  
 1. Dereferencing a raw pointer
  
 2. Calling an unsafe function or method
  
 3. Accessing or modifying a mutable static variable
  
 4. Implementing an unsafe trait",NA
2.2,"Advanced Lifetimes
  
 Back in Chapter 10, we learned how to annotate references with life-
 time parameters to help Rust understand how the lifetimes of different 
 references relate. We saw how most of the time, Rust will let you elide 
 lifetimes, but every reference has a lifetime. There are three advanced 
 features of lifetimes that we haven’t covered though:
  lifetime subtyping
 , 
 lifetime bounds
 , and
  trait object lifetimes
 .
  
 Lifetime Subtyping
  
 Imagine that we want to write a parser. To do this, we’ll have a struc-
 ture that holds a reference to the string that we’re parsing, and we’ll 
 call that struct Context. We’ll write a parser that will parse this string",NA
2.3,"Advanced Traits
  
 We covered traits in Chapter 10, but like lifetimes, we didn’t get to all 
 the details. 
  
 Now that we know more Rust, we can get into the 
 nitty-gritty.",NA
2.4,"Advanced Types
  
 The Rust type system has some features that we’ve mentioned or used 
 without discussing. We started talking about the newtype pattern in 
 regards to traits; we’ll start with a more general discussion about why 
 newtypes are useful as types. We’ll then move to type aliases, a feature 
 that is similar to newtypes but has slightly different semantics. We’ll 
 also discuss the ! type and dynamically sized types.
  
 Using the Newtype Pattern for Type Safety and Abstraction
  
 The newtype pattern that we started discussing at the end of the “Ad-
 vanced Traits” section, where we create a new type as a tuple struct",NA
2.5,"Advanced Functions & Closures
  
 Finally, let’s discuss some advanced features having to do with func-
 tions and closures: function pointers, diverging functions, and 
 returning closures.
  
 Function pointers
  
 We’ve talked about how to pass closures to functions, but you can pass 
 regular functions to functions too! Functions have the type fn, with",NA
Chapter 3,NA,NA
Final Project: Building a ,NA,NA
Multithreaded Web ,NA,NA
Server,"It’s been a long journey, but here we are! It’s the end of the book.
  
 Parting is such sweet sorrow. But before we go, let’s build one more
  
 project together, to show off some of the things we learned in these
  
 final chapters, as well as re-cap some of the earlier ones.
  
 Here’s what we’re going to make: a web server that says hello:",NA
3.1,"A Single Threaded Web Server
  
 First, let’s get a single threaded web server working. We’re going to 
 work with the raw bytes of TCP and HTTP requests and responses to 
 send HTML from our server to a web browser. Let’s start with a quick 
 overview of the protocols involved.
  
 The
  Hypertext Transfer Protocol
  (
 HTTP
 ) that powers the web is built 
 on top of the
  Transmission Control Protocol
  (
 TCP
 ). We won’t get into the 
 details too much, but here’s a short overview: TCP is a low-level 
 protocol, and HTTP builds a higher-level protocol on top of TCP. Both 
 protocols are what’s called a
  request-response protocol
 , that is, there is a
  
 client
  that initiates requests, and a
  server
  that listens to requests and 
 provides a response to the client. The contents of those requests and 
 responses are defined by the protocols themselves.
  
 TCP describes the low-level details of how information gets from 
 one server to another, but doesn’t specify what that information is; it’s 
 just a bunch of ones and zeroes. HTTP builds on top of TCP by defining 
 what the content of the requests and responses should be. As such, it’s 
 technically possible to use HTTP with other protocols, but in the vast 
 majority of cases, HTTP sends its data over TCP.
  
 So the first thing we need to build for our web server is to be able to 
 listen to a TCP connection. The standard library has a std::net module 
 that lets us do this. Let’s make a new project:
  
 $ cargo new hello --bin 
  
  
 Created binary (application) `hello` project $ cd hello
  
 And put the code in Listing 20-1 in src/main.rs to start. This code will 
 listen at the address 127.0.0.1:8080 for incoming TCP streams. When it 
 gets an incoming stream, it will print Connection established!: Filename: 
 src/main.rs
  
 use
  std::net::TcpListener;
  
 fn
  main
 () { 
  
 let
  listener
  =
  TcpListener::bind(
 ""127.0.0.1:8080""
 ).
  
 unwrap
 ();
  
 for
  stream
  in
  listener.
 incoming
 () {",NA
3.2,"How Slow Requests Affect Throughput
  
 Right now, the server will process each request in turn. That works for 
 services like ours that aren’t expected to get very many requests, but as 
 applications get more complex, this sort of serial execution isn’t 
 optimal.
  
 Because our current program processes connections sequentially, it 
 won’t process a second connection until it’s completed processing the 
 first. If we get one request that takes a long time to process, requests 
 coming in during that time will have to wait until the long request is 
 finished, even if the new requests can be processed quickly. Let’s see 
 this in action.
  
 Simulating a Slow Request in the Current Server Implemen-tation
  
 Let’s see the effect of a request that takes a long time to process on 
 requests made to our current server implementation. 
  
 Listing 20-10",NA
3.3,"Designing the Thread Pool Interface
  
 Let’s talk about what using the pool should look like. The authors often 
 find that when trying to design some code, writing the client interface 
 first can really help guide your design. Write the API of the code to be 
 structured in the way you’d want to call it, then implement the 
 functionality within that structure rather than implementing the 
 functionality then designing the public API.
  
 Similar to how we used Test Driven Development in the project in 
 Chapter 12, we’re going to use Compiler Driven Development here. 
 We’re going to write the code that calls the functions we wish we had, 
 then we’ll lean on the compiler to tell us what we should change next. 
 The compiler error messages will guide our implementation.
  
 Code Structure if We Could Use thread::spawn
  
 First, let’s explore what the code to create a new thread for every 
 connection could look like. This isn’t our final plan due to the prob-lems 
 with potentially spawning an unlimited number of threads that we 
 talked about earlier, but it’s a start. Listing 20-11 shows the changes to 
 main to spawn a new thread to handle each stream within the for loop: 
  
  
 Filename: src/main.rs
  
 # use
  std::thread; 
  
 # use
  std::io::prelude::
 *
 ; 
  
 # use
  std::net::TcpListener; 
  
 # use
  std::net::TcpStream; 
  
 # 
  
 fn
  main
 () { 
  
  
 let
  listener
  =
  TcpListener::bind(
 ""127.0.0.1:8080""
 ).",NA
3.4,"Creating the Thread Pool and Storing Threads
  
 The warnings are because we aren’t doing anything with the 
 parameters to new and execute. Let’s implement the bodies of both of 
 these with the actual behavior we want.
  
 Validating the Number of Threads in the Pool
  
 To start, let’s think about new. We mentioned before that we picked an 
 unsigned type for the size parameter since a pool with a negative 
 number of threads makes no sense. However, a pool with zero threads 
 also makes no sense, yet zero is a perfectly valid u32. Let’s check that 
 size is greater than zero before we return a ThreadPool instance and 
 panic if we get zero by using the assert! macro as shown in Listing 20-
 13: 
  
  
 Filename: src/lib.rs",NA
3.5,"Sending Requests to Threads Via Channels
  
 The next problem to tackle is that our closures do absolutely nothing. 
 We’ve been working around the problem that we get the actual closure 
 we want to execute in the execute method, but it feels like we need to 
 know the actual closures when we create the ThreadPool.
  
 Let’s think about what we really want to do though: we want the 
 Worker structs that we just created to fetch jobs from a queue that the 
 ThreadPool holds, and run those jobs in a thread.
  
 In Chapter 16, we learned about channels. Channels are a great way 
 to communicate between two threads, and they’re perfect for this use-
 case. The channel will function as the queue of jobs, and execute will 
 send a job from the ThreadPool to the Worker instances that are 
 checking for jobs in the thread they’ve spawned. Here’s the plan:
  
 1. ThreadPool will create a channel and hold on to the sending side.
  
 2. Each Worker will hold on to the receiving side of the channel.
  
 3. A new Job struct will hold the closures we want to send down 
  
 the 
 channel.
  
 4. The execute method of ThreadPool will send the job it wants 
  
 to 
 execute down the sending side of the channel.
  
 5. In a thread, the Worker will loop over its receiving side of the 
  
 channel and execute the closures of any jobs it receives.
  
 Let’s start by creating a channel in ThreadPool::new and holding the 
 sending side in the ThreadPool instance, as shown in Listing 20-16. Job 
 is the type of item we’re going to be sending down the channel; it’s a 
 struct that doesn’t hold anything for now: 
  
  
 Filename: src/lib.rs",NA
3.6,"Graceful Shutdown and Cleanup
  
 The code in Listing 20-21 is responding to requests asynchronously 
 through the use of a thread pool, as we intended. We get some warnings 
 about fields that we’re not using in a direct way, which are a reminder 
 that we’re not cleaning anything up. When we use CTRL-C to halt the 
 main thread, all the other threads are stopped immediately as well, 
 even if they’re in the middle of serving a request.
  
 We’re now going to implement the Drop trait for ThreadPool to call 
 join on each of the threads in the pool so that the threads will finish the 
 requests they’re working on. Then we’ll implement a way for the 
 ThreadPool to tell the threads they should stop accepting new requests 
 and shut down. To see this code in action, we’ll modify our server to 
 only accept two requests before gracefully shutting down its thread 
 pool.
  
  
 Let’s start with implementing Drop for our thread pool. When the 
 pool is dropped, we should join on all of our threads to make sure they 
 finish their work. Listing 20-22 shows a first attempt at a Drop 
 implementation; this code won’t quite work yet: 
  
  
 Filename: src/lib.rs
  
 impl
  Drop
  for
  ThreadPool { 
  
  
 fn
  drop
 (
 &mut
  self) { 
  
  
  
 for
  worker
  in &mut
  self.workers { 
  
  
  
 println!(
 ""Shutting down worker
  {}
 ""
 , worker.
  
 id);
  
 }
  
 }
  
 }
  
 worker.thread.
 join
 ().
 unwrap
 ();
  
 Listing 20-22: Joining each thread when the thread pool goes out of 
 scope 
  
  
 We loop through each of the thread pool workers, using &mut be-
 cause self is itself a mutable reference and we also need to be able to 
 mutate worker. We print out a message saying that this particular",NA
Appendix,"The following sections contain reference material you may find useful 
 in your Rust journey.
  
 Appendix A: Keywords 
  
 The following keywords are reserved by the Rust language and may not 
 be used as identifiers such as names of functions, variables, param-
 eters, struct fields, modules, crates, constants, macros, static values, 
 attributes, types, traits, or lifetimes.
  
 Keywords Currently in Use
  
 • as - primitive casting, disambiguating the specific trait containing 
  
 an 
 item, or renaming items in use and extern crate statements• break - exit 
 a loop immediately
  
 • const - constant items and constant raw pointers
  
 • continue - continue to the next loop iteration
  
 • crate - external crate linkage or a macro variable representing 
  
 the 
 crate in which the macro is defined
  
 • else - fallback for if and if let control flow constructs
  
 • enum - defining an enumeration
  
 • extern - external crate, function, and variable linkage
  
 • false - boolean false literal",NA
