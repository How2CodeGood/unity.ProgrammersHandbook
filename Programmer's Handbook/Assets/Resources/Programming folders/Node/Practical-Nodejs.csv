Larger Text,Smaller Text,Symbol
Contents at a Glance,"About the Author 
 xv 
 About the Technical Reviewer 
 xvii 
 Acknowledgments 
 xix 
 Introduction 
 xxi
  
 ■
 ■
 ■
 ■
 ■
 ■
  
 ■
 ■
 ■
 ■
 ■
 ■
  
 Chapter 1: Setting up Nodejs and Other Essentials
  
 1
  
 Chapter 2: Using Expressjs 4 to Create Nodejs Web Apps
  
 33
  
 Chapter 3: TDD and BDD for Nodejs with Mocha
  
 57
  
 Chapter 4: Template Engines: Jade and Handlebars
  
 71
  
 Chapter 5: Persistence with MongoDB and Mongoskin
  
 103
  
  Chapter 6: Using Sessions and OAuth to Authorize and Authenticate 
  
 Users in Nodejs Apps 
 129
  
 Chapter 7: Boosting Your Nodejs Data with the Mongoose ORM Library
  
 149
  
 Chapter 8: Building Nodejs REST API Servers with Expressjs and Hapi
  
 173
  
 Chapter 9: Real-Time Apps with WebSocket, SocketIO, and DerbyJS
  
 195
  
 Chapter 10: Getting Nodejs Apps Production Ready
  
 215
  
 Chapter 11: Deploying Nodejs Apps
  
 243
  
 Chapter 12: Publishing Nodejs Modules and Contributing to Open Source
  
 261
  
 Index 
 269
  
  
 v 
 www.allitebooks.com",NA
Introduction,"There are more and more books and online resources being published that cover Node.js basics (e.g., how-to’s of 
 Hello World and simple apps). For the most part, these tutorials rely on core modules only or maybe one or two Node 
 Package Manager (NPM) packages. This “sandbox” approach of tutorials is easy and doesn’t require many 
 dependencies, but it can’t be further from the actual Node.js stack. This is especially true with Node.js, the core of 
 which—by design—is kept lean and minimal. At the same time, the vast “userland” (i.e., NPM) provides an ecosystem 
 of packages/modules to serve specific granular purposes. Therefore, there is a need to show effectively how Node.js 
 is used in the industry and to have it all in one place—the all-encompassing 
 practical
  resource that can be used as a 
 learning tool, a code cookbook, and a reference.",NA
What This Book Is,"Practical Node.js: Building Real-World Scalable Web Apps
  is a hands-on manual for developing production-ready web 
 applications and services by leveraging the rich ecosystem of Node.js packages. This is important because real 
 applications require many components, such as security, deployment, code organization, database drivers, template 
 engines, and more. This is why we include extensive 12-chapter coverage of third-party services, command-line tools, 
 NPM modules, frameworks, and libraries. 
  
 Just to give you some idea, 
 Practical Node.js
  is a one-stop place for getting started with Express.js 4, Hapi.js, 
 DerbyJS, Mongoskin, Mongoose, Everyauth, Mocha, Jade, Socket.IO, TravisCI, Heroku, Amazon Web Services (AWS), 
 and many others. Most of these items are vital for any serious project. 
  
 In addition, we create a few projects by building, step by step, from a straightforward concept to a more 
 complicated application. These projects can also serve as a boilerplate for jump-starting your own development 
 efforts. Also, the examples show industry best practices to help you avoid costly mistakes.
  
  
 Last but not least, many topics and chapters serve as a reference to which you can always return later 
 when you’re faced with a challenging problem. 
  
 Practical Node.js
  aims to save you time and make you a more productive Node.js programmer!",NA
What You’ll Learn,"Practical Node.js
  takes you from an overview of JavaScript and Node.js basics, installing all the necessary modules 
 to writing and deploying web applications, and everything in between. We cover libraries including, but not limited 
 to, Express.js 4 and Hapi.js frameworks, Mongoskin and the Mongoose object-relational mapping (ORM) library for 
 the MongoDB database, Jade and Handlebars template engines, OAuth and Everyauth libraries for OAuth 
 integrations, the Mocha testing framework and Expect test-driven development/behavior-driven development 
 language, and the Socket.IO and DerbyJS libraries for WebSocket real-time communication. 
  
 xxi
  
 www.allitebooks.com",NA
What This Book Is Not,"Although the entire first chapter is dedicated to installations and a few important differences between Node.js and 
 browser JavaScript, we didn’t want to dilute the core message of making production-ready apps, or make 
 Practical 
 Node.js
  even larger and more convoluted. Therefore, the 
 book is not a beginner’s guide
  and there is no extensive 
 immersion into the inner workings of the Node.js platform and its core modules. 
  
 We also can’t guarantee that each component and topic are explained to the extent you need, because the nature 
 of your project might be very specific. Most chapters in the book help you to get started with the stack. There is 
 simply no realistic way to fit so many topics in one book and cover them comprehensively. 
  
 Another caveat of this book (or virtually any other programming book) is that the versions of the packages we 
 use will eventually become obsolete. Often, this isn’t an issue because, in this book, versions are stated and locked 
 explicitly. So no matter what, the 
 examples will continue to work with our versions
 . 
  
 Even if you decide to use the latest versions, in many cases this still might not be an issue, because essentials 
 remain the same. However, if you go this off-path route, once in a while you might be faced with a breaking change 
 introduced by the latest versions. 
  
 xxii
  
 www.allitebooks.com",NA
Who Can Benefit from This Book,"Practical Node.js
  is an intermediate- to advanced-level book on programming with Node.js. Consequently, to get the 
 most out of it, you need to have prior programming experience and some exposure to Node.js. We assume readers’ 
 prior knowledge of computer science, programming concepts, web development, Node.js core modules, and the 
 inner workings of HTTP and the Internet. 
  
 However, depending on your programming level and ability to learn, you can fill in any knowledge gaps very 
 quickly by visiting links to official online documentations and reading external resources referenced in this book. 
 Also, if you have a strong programming background in some other programming language, it would be relatively easy 
 for you to start Node.js development with 
 Practical Node.js
 . 
  
  
 As mentioned earlier, 
 Practical Node.js
  is written for 
 intermediate and advanced software engineers
 . For 
 this reason, there are three categories of programmers who can benefit from it the most:
  
 1. 
  
 Generalist or full-stack developers including development operation (DevOps) and quality 
  
 assurance (QA) automation engineers
  
 2. 
  
 Experienced front-end web developers with a strong background and understanding 
 of 
  
 browser JavaScript
  
 3. 
  
 Skilled back-end software engineers coming from other languages such as Java, PHP, and 
  
 Ruby, who don’t mind doing some extra work get up to speed with the JavaScript language",NA
Source Code,"Learning is more effective when we apply our knowledge right away. For this reason, virtually every chapter in 
 Practical Node.js
  ends with a hands-on exercise. For your convenience, and because we believe in open source and 
 transparency, all the book’s examples are available publicly (i.e., free of charge) for exploration and execution on 
 GitHub at 
 https://github.com/azat-co/practicalnode
 .",NA
Errata and Contacts,"If you spot any mistakes or typos (and I’m sure you will), please open an issue or, even better, fix it and make a 
 pull request to the GitHub repository of the book’s examples at 
 https://github.com/azat-co/practicalnode
 . For all 
 other updates and contact information, the canonical home of 
 Practical Node.js
  on the Internet is 
  
 http://practicalnodebook.com
 .",NA
Notation ,"This book follows a few formatting conventions. Code is in monospace font—for example, var book = {name: 
 'Practical Node.js'}; . If the code begins with $, this code is meant to be executed in the terminal/command line. 
  
 However, if the code line starts with >, the code is meant for the virtual environment (a.k.a., console—either for 
 Node.js or MongoDB). If the Node.js module name is in code font, this is the NPM name and you can use it with NPM 
 and the require() method, such as superagent.
  
 xxiii
  
 www.allitebooks.com",NA
Why You Should Read This Book,"Practical Node.js
  was designed to be one stop for going from Hello World examples to building apps in a professional 
 manner. You get a taste of the most widely used Node.js libraries in one place, along with best practices and 
 recommendations based on years of building and running Node.js apps in production. The libraries covered in 
 Practical Node.js
  greatly enhance the quality of code and make you more productive. Also, although the material in 
 this book is not groundbreaking, the convenience of the format saves hours of frustration researching the Internet. 
 Therefore, 
 Practical Node.js
  is here to help you to jump-start your Node.js development!.
  
 xxiv
  
 www.allitebooks.com",NA
Chapter 1,NA,NA
Setting up Node.js and ,NA,NA
Other Essentials,"As with many technologies, it’s vital to have the proper foundation set up first, before moving on to solving 
 more complex problems. In this chapter, we cover the following:
  
 
  
 Node.js and (NPM) Node Package Manager installation
  
 
  
 Node.js script launches
  
 
  
 Node.js syntax and basics
  
 
  
 Node.js integrated development environments (IDEs) and code editors
  
 
  
 Awareness of file changes
  
 
  
 Node.js program debugging",NA
Installing Node.js and NPM ,"Although your operating system (OS) might have Node.js installed on it already, you should update to at least 
 0.10.x. 
  
 In the following subsection, we examine a few different approaches to installing Node.js:
  
 
  
 One-click installers
 : probably the easiest and fastest way to get started with the platform
 
  
 Installing with HomeBrew or MacPorts
 : straightforward installation for Max OS X users 
  
  
 Installing from a tar file
 : an alternative installation from an archive file
 
  
 
  
  
 Installing without sudo
 : the best way to avoid needing sudo (admin rights) when using the 
  
  
 node and npm commands
  
 
  
 Installing from a Git repo
 : an option for advanced developers who need the latest version 
  
  
 and/or contribute to the project 
  
  
  
 Multiversion setup with Nave
 : a must-have for developers contributing to projects that use 
 
  
  
  
 different Node.js versions
  
 
  
 Multiversion setup with Node Version Manager
  (
 NVM
 ): alternative to Nave (see previous entry)",NA
One-Click Installers,"First, let’s go to 
 http://nodejs.org
  and download a one-click installer for your OS (Figure 
 1-1
 ) by clicking on the 
 Install button. Don’t choose binaries or source code unless you know what to do with them or your OS is not present 
 there (i.e., not Windows or Mac).
  
  
 Figure 1-1.
  One-click installers for Node.js
  
 The installers come with NPM (Node Package Manager)— an important tool for managing dependencies. If 
 there’s no installer for your OS (page 
 http://nodejs.org/download/
 ), you can get the source code and compile 
 it yourself (Figure 
 1-2
 ).
  
 2
  
 www.allitebooks.com",NA
Installing with HomeBrew or MacPorts ,"If you already have HomeBrew (brew) installed, run the following in a straightforward 
 manner: $ brew install node 
  
 $ brew install npm 
  
  
 Similarly, for MacPorts, run 
  
 $ sudo port install nodejs
  
  
 3 
 www.allitebooks.com",NA
Installing from a Tar File,"To install from a tar file (which is type of archive), set up a folder for the latest Node.js as follows:
  
 $ echo 'export PATH=$HOME/local/bin:$PATH' >> ~/.bashrc $ . 
 ~/.bashrc 
  
 $ mkdir ~/local 
  
 $ mkdir ~/node-latest-install 
  
 $ cd ~/node-latest-install 
  
 ■
 Note
  advanced users who choose to make their own node.js builds need to have certain compilers 
 installed first. For 
  
 more information, refer to the official documentation 
 (
 https://github.com/joyent/node/wiki/Installation
 )
 .
  
 Download the tar file with CURL and unpack it:
  
 $ curl 
 http://nodejs.org/dist/node-latest.tar.gz
  | tar xz --strip-components=1 $ ./configure 
 --prefix=~/local
  
 Build Node.js and install it:
  
 $ make install 
  
 $ curl 
 https://npmjs.org/install.sh
  | sh 
  
 ■
 Tip
  if you find yourself getting errors when trying to install the module globally via npM (
 $ npm install -
 g 
  
 <packagename>
 ), reinstall node.js and npM with the “installing Without sudo” solution below to eliminate 
 the need 
  
 to use 
 sudo
  with the installation command. For more solutions for advanced users, there’s a gist from 
 isaac Z. Schlueter: 
  
 https://gist.github.com/isaacs/579814
 .",NA
Installing Without sudo,"Sometimes, depending on your configuration, NPM asks users for sudo— root user permissions. To avoid using sudo, 
 advanced developers can use the following::
  
 $ sudo mkdir -p /usr/local/{share/man,bin,lib/node,include/node} $ sudo chown -
 R $USER /usr/local/{share/man,bin,lib/node,include/node} 
  
 ■
 Note
  please be sure you are comfortable with the functionality of the 
 chown
  command before you 
 run it.",NA
Installing from a Git Repo,"If you want to use the latest core Node.js code, and maybe even contribute to the Node.js and NPM projects, it’s 
 possible to build the installation from the cloned Git repo. (This step requires Git. To install it, go to 
 http://git-
 scm.com/ 
 and click Download.) For basic Git commands, refer to Chapter 11, where we explore deployment; 
 otherwise, do the following:
  
 1. 
  
 Make the folders and add the path:
  
 $ mkdir ~/local 
  
 $ echo 'export PATH=$HOME/local/bin:$PATH' >> ~/.bashrc $ . 
 ~/.bashrc
  
  
 To clone the original Node.js repo from Joyent (alternatively, you can fork it and clone your own repository), 
 do the following:
  
 $ git clone git://github.com/joyent/node.git 
  
 $ cd node 
  
 $ ./configure --prefix=~/local
  
 2. 
  
 Make the build:
  
 $ make install 
  
 $ cd ..
  
 3. 
  
 Repeat for NPM:
  
 $ git clone git://github.com/isaacs/npm.git 
  
 $ cd npm 
  
 $ make install
  
 For a more cutting-edge NPM version, use
  
 $ make link",NA
Multiversion Setup with Nave,"If you plan to run multiple versions of Node.js, use Nave (
 https://github.com/isaacs/nave
 ), which is a virtual 
 environment for Node.js. First, make a folder:
  
 mkdir ~/.nave 
  
 cd ~/.nave
  
 5",NA
Multiversion Setup with NVM ,"Another option to Nave is NVM—Node Version Manager (GitHub, 
 https://github.com/creationix/nvm
 ). Install 
 NVM as follows: 
  
 $ curl 
 https://raw.github.com/creationix/nvm/master/install.sh
  | sh 
  
 or 
  
 $ wget -qO- 
 https://raw.github.com/creationix/nvm/master/install.sh
  | sh 
  
  
 Then, harness NVM’s install: 
  
 $ nvm install 0.10 
  
  
 To switch to the 0.10 version, apply the use command. For example: 
  
 $ nvm use 0.10",NA
Alternative Multiversion Systems ,"Alternatives to Nave and NVM include the following:
  
 
  
 neco (
 https://github.com/kuno/neco
 )
  
 
  
 n (
 https://github.com/visionmedia/n
 )
  
 6",NA
Checking the Installation,"To test your installation, run the following commands in your Terminal app (command line cmd.exe in Windows):
  
 $ node -v 
  
 $ npm -v
  
  
 You should see the latest versions of Node.js and NPM that you just downloaded and installed, as shown in 
 Figure 
 1-3
 .
  
  
 Figure 1-3.
  Checking Node.js and NPM installations
  
  
 That’s it! You now have Node.js and NPM installed, and you should be ready to dig deeper into using the 
 platform. The simplest way to run Node.js is through its virtual environment, which is often called 
 read–eval–print–
 loop,
  or REPL.",NA
Node.js Console (REPL),"Like most platforms/languages (e.g., Java, Python, Ruby, and PHP), Node.js comes with a virtual environment: REPL. 
 Using this shell program, we can execute pretty much any Node.js/JavaScript code. It’s even possible to include 
 modules and work with the file system! Other REPL use cases involve controlling nodecopters 
 (
 http://nodecopter.com/
 ) and debugging remote servers (more about this in Chapter 10). To start the console, run 
 the following command in your terminal:
  
 $ node
  
 7",NA
Launching Node.js Scripts,"To start a Node.js script from a file, simply run $ node filename—for example, $ node program.js. If all we need is a 
 quick set of statements, there’s a -e option that allows us to run inline JavaScript/Node.js—for example, $ node -e 
 ""console.log(new Date());"".
  
 8",NA
Node.js Basics and Syntax ,"Node.js was built on top of the Google Chrome V8 engine and its ECMAScript, which means most of the Node.js 
 syntax is similar to front-end JavaScript (another implementation of ECMAScript), including objects, functions, 
 and methods. In this section, we look at some of the most important aspects; let’s call them 
 Node.js/JavaScript 
 fundamentals
 :
  
 
  
 Loose typing
  
 
  
  
 Buffer—Node.js super data type
 
  
 Object literal notation
  
 
  
 Functions
  
 
  
 Arrays
  
 
  
  
 Prototypal nature
 
  
 Conventions",NA
Loose Typing ,"Automatic typecasting works well most of the time. It’s a great feature that saves a lot of time and mental 
 energy! 
  
 There are only a few types of primitives:
  
 
  
 String
  
 
  
 Number (both integer and real) 
  
  
  
 Boolean
 
  
 
  
  
 Undefined
 
  
 Null
  
 
  
 RegExp
  
  
 Everything else is an object (i.e., mutable keyed collections, read Stackoverflow on “What does immutable 
 mean?”,
 1
  if in doubt).
  
  
 Also, in JavaScript, there are String, Number, and Boolean objects that contain helpers for the primitives, 
 as follows:
  
 'a' === new String('a') 
 //false
  
 but
  
 1
 http://stackoverflow.com/questions/3200211/what-does-immutable-mean",NA
Buffer—Node.js Super Data Type,"Buffer is a Node.js addition to four primitives (boolean, string, number, and RegExp) and all-encompassing objects 
 (array and functions are also objects) in front-end JavaScript. Think of buffers as extremely efficient data stores. In 
 fact, Node.js tries to use buffers any time it can, such as when reading from file systems and when receiving packets 
 over the network.",NA
Object Literal Notation,"Object notation is super readable and compact:
  
 var obj = {
  
  
  color: ""green"",
  
  
  type: ""suv"",
  
  
  owner: {
  
   
  ...
  
  
  } 
  
 }
  
 Remember, functions are objects:
  
 var obj = function () {
  
  
  this.color: ""green"",
  
  
  this.type: ""suv"",
  
  
  this.owner: {
  
   
  ...
  
  
  } 
  
 }",NA
Functions,"In Node.js (as well as in JavaScript), functions are 
 first-class citizens
 , and we treat them as variables, because they 
 are objects! Yes, functions can even have properties/attributes. First, let’s learn how to define a function.",NA
Define/Create a Function,"The three most common ways to define/create a function are to use a named expression, an anonymous expression 
 assigned to a variable, or both. The following is an example of a named expression:
  
 function f () {
  
  console.log('Hi');
  
  return true; 
  
 }
  
 10",NA
Pass Functions as Parameters,"JavaScript treats functions like any other objects, so we can pass them to other functions as parameters (usually, 
 callbacks in Node.js): 
  
 var convertNum = function (num) {
  
  return num + 10; 
  
 }
  
 var processNum = function (num, fn) {
  
  
  return fn(num); 
  
 }
  
 processNum(10, convertNum);",NA
Function Invocation vs. Expression,"The function definition is as follows:
  
 function f () {};
  
 11",NA
Arrays,"Arrays are also objects that have some special methods inherited from the Array.prototype
 2
  global object. 
 Nevertheless, JavaScript arrays are 
 not
  real arrays; instead, they are objects with unique integer (usually 0 based) 
 keys.
  
 var arr = []; 
  
 var arr2 = [1, ""Hi"", {a:2}, function () {console.log('boo');}]; 
  
 var arr3 = new Array(); 
  
 var arr4 = new Array(1,""Hi"", {a:2}, function () {console.log('boo');});",NA
Prototypal Nature,"There are 
 no classes
  in JavaScript because objects inherit directly from other objects, which is called 
 prototypal 
 inheritance
 . There are a few types of inheritance patterns in JavaScript:
  
 
  
 Classical
  
 
  
 Pseudoclassical
  
 
  
 Functional
  
 This is an example of the functional inheritance pattern:
  
 var user = function (ops) {
  
  return { firstName: ops.name || 'John'
  
   
  , lastName: ops.name || 'Doe'
  
   
  , email: ops.email || 'test@test.com'
  
   
  , name: function() { return this.firstName + this.lastName}
  
  
  } 
  
 }
  
 var agency = function(ops) {
  
  ops = ops || {}
  
  var agency = user(ops)
  
  agency.customers = ops.customers || 0
  
  agency.isAgency = true
  
  return agency 
  
 }
  
 2
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype
  
 12",NA
Conventions ,"It’s important to follow the most common language conventions. Some of them are listed 
 here:
 
  
 Semicolons
  
 
  
 camelCase
  
 
  
 Naming
  
 
  
 Commas
  
 
  
 Indentations
  
 
  
 Whitespace
  
 These JavaScript/Node.js conventions (with semicolons being an exception) are stylistic and highly preferential. 
 They don’t impact the execution; however, it’s strongly suggested that you follow one style consistently, especially if 
 you are a developer working in teams and/or on open-source projects. Some open-source projects might not accept 
 pull requests if they contain semicolons (e.g., NPM) or if they don’t use comma-first style (e.g., request).",NA
Semicolons ,"The use of semicolons is optional, except for two cases: 
  
 1. 
  
 In for loop construction: for (var i=0; i++; i<n) 
  
 2. 
  
 When a new line starts with parentheses, such as when using an immediately invoked 
  
  
 function expression (IIFE): ;(function(){...}())",NA
camelCase ,"camelCase is the main naming pattern in JavaScript, except for class names, which are CapitalCamelCase. An example 
 follows:
  
 var MainView = Backbone.View.extend({...}) 
  
 var mainView = new MainView()",NA
Naming ,"_ and $ are perfectly legitimate characters for literals (jQuery and Underscore libraries use them a lot). Private 
 methods and attributes start with _ (and it does nothing by itself!).",NA
Commas ,"An example of a comma-first approach is as follows:
  
 var obj = { firstName: ""John""
  
  , lastName: ""Smith""
  
  , email: ""johnsmith@gmail.com""
  
  }
  
 13
  
 www.allitebooks.com",NA
Indentation,"Indentation is usually done using either a tab, or four- or two-space indentation, with supporting camps split almost 
 religiously between the two options.",NA
Whitespace,"Usually, there is a space before and after the =, +, {, and } symbols. There is no space on invocation (e.g., 
 arr.push(1);), but there’s a space when we define an anonymous function: function () {}.",NA
Node.js Globals and Reserved Keywords,"Despite being modeled after one standard, Node.js and browser JavaScript differ when it comes to globals. This 
 was done intentionally because when var is omitted, browser JavaScript leaks variables infamously to the global 
 space, thus polluting it. This has been dubbed as one of the bad parts of JavaScript in the canonical book 
 JavaScript: 
 The Good Parts
  by Douglas Crockford (2008 O’Reilly).
  
 As you might know, in browser JavaScript we have a window object. However, in Node.js, it is absent (obviously 
 we don’t deal with a browser window), but developers are provided with new objects/keywords:
  
 
  
 process
  
 
  
 global
  
 
  
 module.exports and exports
  
 So, let’s take a look at the main differences between Node.js and JavaScript.",NA
Node.js Process Information,"Each Node.js script that runs is, in essence, a process. For example, ps aux | grep 'node' outputs all Node.js 
 programs running on a machine. Conveniently, developers can access useful process information in code with the 
 process object (e.g., node -e ""console.log(process.pid)""), as shown in Figure 
 1-5
 .
  
 14",NA
Accessing Global Scope in Node.js,"As you know, browser JavaScript, by default, puts everything into its global scope. On the other hand, Node.js 
 was designed to behave differently, with everything being local by default. In case we need to access globals, 
 there is a global object. And, when we need to export something, we should do so explicitly.
  
 In a sense, the window object from front-end/browser JavaScript metamorphosed into a combination of global 
 and process objects. Needless to say, the document object, which represents the DOM (Document Object Model) of 
 the web page, is nonexistent in Node.js.",NA
Exporting and Importing Modules,"Another 
 bad part
  in browser JavaScript is that there is no way to include modules. Scripts are supposed to be 
 linked together using a different language (HTML), but dependency management is lacking. CommonJS 
 (
 http://www.commonjs.org/
 ) and RequireJS (
 http://requirejs.org/
 ) solve this problem with the AJAX-y 
 approach. Node.js borrowed many things from the CommonJS concept.
  
 To export an object in Node.js, use exports.name = object;. An example follows:
  
 var messages = {
  
  find: function(req, res, next) {
  
  ...
  
  },
  
  add: function(req, res, next) {
  
  ...
  
  },
  
  format: 'title | date | author' 
  
 } 
  
 exports.messages = messages;
  
 15",NA
__dirname vs. process.cwd,"__dirname is an absolute path to the file in which the global variable is called, whereas process.cwd is an absolute 
 path to the process that runs the script. The latter might not be the same as the former if we started the program 
 from a different folder, such as $ node ./code/program.js.
  
 16",NA
Browser Application Programming Interface Helpers ,"There are myriad helper functions in Node.js from the browser JavaScript application programming interface (API). 
 The most useful come from String, Array, and Math objects. To make you aware of their existence, or to remind you, 
 here is a list of the most common functions and their meanings:
  
 
  
 Array
  
  
  
  
 
  
 some() and every(): assertions for array items
  
  
  
  
 
  
 join() and concat(): convertion to a string
  
  
  
  
 
  
 pop(), push(), shift(), and unshift(): working with stacks and queues
  
  
  
  
 
  
 map(): model mapping for array items
  
  
  
  
 
  
 filter(): querying array items
  
  
  
  
 
  
 sort(): ordering items
  
  
  
  
 
  
 reduce(), reduceRight(): computing
  
  
  
  
 
  
 slice(): copying
  
  
  
  
 
  
 splice(): removing
  
  
  
  
 
  
 indexOf(): lookups of finding the value in the array
  
  
  
  
 
  
 reverse(): reversing the order
  
  
  
  
 
  
 The in operator: iteration over array items
  
 
  
  
 Math
  
  
  
 
  
 random(): random real number less than one
  
 
  
 String
  
  
  
  
 
  
 substr() and substring(): extracting substrings
  
  
  
  
 
  
  
 length: length of the string
  
  
  
 
  
 indexOf(): index of finding the value in the string
  
  
  
  
 
  
 split(): converting the string to an array
  
  
 In addition, we have setInterval(), setTimeout(), forEach(), and console methods in Node.js. For the 
 complete list of methods and examples, visit the following sites:
  
 
  
 String
  (
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/ 
  
 Global_Objects/String
 )
  
 
  
 Array
  (
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/ 
  
 Global_Objects/Array
 )
  
 
  
 Math
  (
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/ 
  
 Global_Objects/Math
 )
  
 17",NA
Node.js Core Modules,"Unlike other programming technologies, Node.js doesn’t come with a heavy standard library. The core modules of 
  
 node.js are a bare minimum, and the rest can be cherry-picked via the NPM registry. The main core modules, classes, 
  
 methods, and events include the following:
  
 
  
 http (
 http://nodejs.org/api/http.html#http_http
 )
  
 
  
 util (
 http://nodejs.org/api/util.html
 )
  
 
  
 querystring (
 http://nodejs.org/api/querystring.html
 )
  
 
  
 url (
 http://nodejs.org/api/url.html
 )
  
 
  
 fs (
 http://nodejs.org/api/fs.html
 )",NA
http ,NA,NA
(,NA,NA
http://nodejs.org/api/http.html,NA,NA
),"http is the main module responsible for the Node.js HTTP server. The main methods are as follows:
  
 
  
 http.createServer(): returns a new web server object
  
 
  
 http.listen(): begins accepting connections on the specified port and hostname
  
 
  
 http.createClient(): is a client and makes requests to other servers
  
 
  
 http.ServerRequest(): passes incoming requests to request handlers
  
 
  
 data
 : emitted when a part of the message body is received
  
 
  
 end
 : emitted exactly once for each request
  
 
  
 request.method(): the request method as a string
  
 
  
 request.url(): request URL string
  
 
  
 http.ServerResponse(): creates this object internally by an HTTP server — not by 
  
 the user— and is used as an output of request handlers
  
 
  
 response.writeHead(): sends a response header to the request
  
 
  
 response.write(): sends a response body
  
 
  
 response.end(): sends and ends a response body",NA
util ,NA,NA
(,NA,NA
http://nodejs.org/api/util.html,NA,NA
),"The util module provides utilities for debugging. One method is as follows:
  
 
  
 util.inspect(): returns a string representation of an object, which is useful for debugging",NA
querystring ,NA,NA
(,NA,NA
http://nodejs.org/api/querystring.html,NA,NA
),"The querystring module provides utilities for dealing with query strings. Some of the methods include the following:
  
 
  
 querystring.stringify(): serializes an object to a query string
  
 
  
 querystring.parse(): deserializes a query string to an object
  
 18",NA
url ,NA,NA
(,NA,NA
http://nodejs.org/api/url.html,NA,NA
) ,"The url module has utilities for URL resolution and parsing. One method is as 
 follows:
 
  
 parse(): takes a URL string and returns an object",NA
fs ,NA,NA
(,NA,NA
http://nodejs.org/api/fs.html,NA,NA
) ,"fs handles file system operations such as reading to and writing from files. There are synchronous and asynchronous 
 methods in the library. Some of the methods include the following:
  
 
  
 fs.readFile(): reads files asynchronously
  
 
  
 fs.writeFile(): writes data to files asynchronously
  
  
 There is no need to install or download core modules. To include them in your application, all you need is to use 
 the following syntax:
  
 var http = require('http');
  
 A list of noncore modules is found at the following locations:
  
 
 npmjs.org (
 https://npmjs.org
 ): for the NPM registry
  
 
 GitHub hosted list (
 https://github.com/joyent/node/wiki/Modules
 ): for Node.js modules 
  
 maintained by Joyent
  
 
 nodetoolbox.com (
 http://nodetoolbox.com/
 ): for a registry based on stats
  
 
 Nipster (
 http://eirikb.github.com/nipster/
 ): for NPM search tools for Node.js
  
 
 Node tracking ( 
 http://nodejsmodules.org
 ): for a registry based on GitHub stats
  
 If you want to know how to code your own modules, take a look at the article “Your First Node.js Module
 3
 .”",NA
Handy Node.js Utilities ,"Although the core of the Node.js platform was, intentionally, kept small, it has some essential utilities, including 
 the following:
  
 
  
 Crypto
 (
 http://nodejs.org/api/crypto.html
 ): has randomizer, MD5, HMAC-SHA1, and 
   
 other 
 algorithms
  
 
  
 Path
 (
 http://nodejs.org/api/path.html
 ): handles system paths
  
 
  
 String decoder
 (
 http://nodejs.org/api/string_decoder.html
 ): decodes to and from buffer 
  
  
 and string types
  
  
 The method we use throughout is path.join and it concatenates the path using an appropriate folder 
 separator (/ or \\).
  
 3
 http://cnnr.me/blog/2012/05/27/your-first-node-dot-js-module/
  
 19",NA
Reading to and Writing from the File System in Node.js,"Reading from files is done via the core fs module (
 http://nodejs.org/api/fs.html
 ). There are two sets of reading 
 methods: async and sync. In most cases, developers should use async methods, such as fs.readFile:
  
 var fs = require('fs'); 
  
 var path = require('path'); 
  
 fs.readFile(path.join(__dirname, '/data/customers.csv'), {encoding: 'utf-8'}, function (err, data) { if (err) throw err;
  
  console.log(data); 
  
 });
  
 To write to the file, execute the following:
  
 var fs = require('fs'); 
  
 fs.writeFile('message.txt', 'Hello World!', function (err) { if (err) throw 
 err;
  
  console.log('Writing is done.'); 
  
 });",NA
Streaming Data in Node.js,"Streaming data
  is a phrase that means an application processes the data while it’s still receiving it. This feature 
 is useful for extra large datasets such as video or database migrations.
  
 Here’s a basic example of using streams that output the binary file content back:
  
 var fs = require('fs'); 
  
 fs.createReadStream('./data/customers.csv').pipe(process.stdout);
  
  
 By default, Node.js uses buffers for streams. For more immersive instruction, take a look at stream-adventure 
 (
 http://npmjs.org/stream-adventure
 ) and Stream Handbook (
 https://github.com/substack/stream-handbook
 ).",NA
Installing Node.js Modules with NPM,"NPM comes with the Node.js platform and allows for seamless Node.js package management. The way npm install 
 works is similar to Git in the  way it traverses the working tree to find a current project (
 https://npmjs.org/doc/ 
 files/npm-folders.html
 ). For starters, keep in mind that we need either the package.json file or the node_modules 
 folder to install modules locally with $ npm install name. For example, $ npm install superagent; in the program. js 
 write: var superagent = require('superagent');.
  
 The best thing about NPM is that it keeps all the dependencies local, so if module A uses module B v1.3, and 
 module C uses module B v2.0 (with breaking changes compared with v1.3), both A and C will have their own localized 
 copies of different versions of B. This proves to be a more superior strategy than that of Ruby and other platforms 
 that use global installations by default.
  
 The best practice is 
 not to include
  a node_modules folder in the Git repository when the project is a module that 
 is supposed to be used in other applications. However, it’s recommended 
 to include
 node_modules for deployable 
 applications to prevent breakage caused by unfortunate dependency updates.
  
 ■
 Note
  the npM creator likes to call it 
 npm
  (lowercase, 
 http://npmjs.org/doc/misc/npm-faq.html
 ).
  
 20",NA
Taming Callbacks in Node.js,"Callbacks (
 https://github.com/maxogden/art-of-node
 ) are able to make Node.js code asynchronous, yet 
 programmers unfamiliar with JavaScript, who work with Java or PHP, might be surprised when they see Node.js code 
 described on Callback Hell (
 http://callbackhell.com/
 ):
  
 fs.readdir(source, function(err, files) {
  
  if (err) {
  
   
  console.log('Error finding files: ' + err)
  
  } else {
  
   
  files.forEach(function(filename, fileIndex) {
  
    
  console.log(filename)
  
    
  gm(source + filename).size(function(err, values) {
  
     
  if (err) {
  
      
  console.log('Error identifying file size: ' + err)
  
     
  } else {
  
      
  console.log(filename + ' : ' + values)
  
      
  aspect = (values.width / values.height)
  
      
  widths.forEach(function(width, widthIndex) {
  
       
  height = Math.round(width / aspect)
  
       
  console.log('resizing ' + filename + 'to ' + height + 'x' + height)
  
       
  this.resize(width, height).write(destination + 'w' + width + '_' + filename, function(err) {
   
      
  if (err) console.log('Error writing file: ' + err)
  
       
  })
  
      
  }.bind(this))
  
     
  }
  
    
  })
  
   
  })
  
  } 
  
 })
  
  
 There’s nothing to be afraid of here as long as two-space indentation is used. ;-) However, callback code can be 
 rewritten with the use of event emitters or promises, or by using the async library.",NA
Hello World Server with HTTP Node.js Module,"Although, Node.js can be used for a wide variety of tasks, it’s used primarily for building web applications. Node.js 
 thrives in the network as a result of its asynchronous nature and built-in modules such as net and http.
  
  
 Here’s a quintessential Hello World example in which we create a server object, define the request handler 
 (function with req and res arguments), pass some data back to the recipient, and start up the whole thing (hello.js):
  
 var http = require('http'); 
  
 http.createServer(function (req, res) {
  
  res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello 
 World\n'); 
  
 }).listen(1337, '127.0.0.1'); 
  
 console.log('Server running at 
 http://127.0.0.1:1337/
 ');
  
  
 Let’s break it down a bit (if you know this already, skip to the next section). The following loads the core http 
 module for the server (more on the modules later):
  
 var http = require('http');
  
 21",NA
Debugging Node.js Programs,"Modern-day software developers, especially those who use compiled languages such as Java, get accustomed to rich 
 tool sets for debugging purposes. Back in the day, before JavaScript and AJAX apps were starting to gain momentum 
 (~2005–2007), the only way to debug was to put a bunch of alert() statements everywhere. Now, there are amazing 
 environments such as Chrome Developer Tools and Firefox Firebug! Also, because Node.js has a lot of things in 
 common with the browser JavaScript environment, we have plenty of options for debugging in Node.js, including the 
 following:
  
 
  
 Core Node.js Debugger
 : a nongraphic user interface (non-GUI) minimalistic tool that works 
  
 everywhere
  
 
  
 Node Inspector
 : port of Google Chrome Developer Tools
  
 
  
 WebStorm and other IDEs (covered in the next section)",NA
Core Node.js Debugger,"The best debugger is console.log(), because it doesn’t break/interrupt the flow, and it is fast and informative. 
 However, to use it, we first need to know where to put it. Sometimes, we just don’t know where to put the logs! Other 
 times, we need to see the call stack and orient ourselves in the async code a bit more. To do this, put debugger",NA
Debugging with Node Inspector,"The built-in Node.js debugger client is extensive, but it’s not intuitive because of the lack of a GUI. Therefore, for a 
 more developer-friendly interface than the core Node.js debugger provides, node-inspector (
 https://github.com/ 
 node-inspector/node-inspector
 ) comes to the rescue!
  
 To download and install Node Inspector, we use our beloved NPM in the global mode (-g or --global):
  
 $ npm install -g node-inspector
  
 Then, we start Node Inspector with the following (Figure 
 1-6
 ):
  
 $ node-inspector
  
 23
  
 www.allitebooks.com",NA
Node.js IDEs and Code Editors,"One of the best things about Node.js is that you don’t need to compile the code, because it’s loaded into memory 
 and interpreted by the platform! Therefore, a lightweight text editor is highly recommended, such as Sublime Text 
 (Figure 
 1-11
 ), vs. a full-blown IDE. However, if you are already familiar and comfortable with the IDE of your 
 choice, such as Eclipse (
 http://www.eclipse.org/
 ), NetBeans (
 http://netbeans.org/
 ), or Aptana 
 (
 http://aptana.com/
 ), feel free to stick with it.
  
  
 Figure 1-11.
  Sublime Text code editor home page
  
 28",NA
Watching for File Changes,"If you are familiar with watching for file changes or it’s not an issue for you, feel free to skip this section.
  
 Node.js applications are stored in memory, and if we make changes to the source code, we need to restart the 
 process (i.e., node). We do this manually by killing the process and starting a new one (Control + c on Macs and Ctrl 
 + c on Windows). However, it’s faster for development if this constant sequence of restarts is automated. There are 
 brilliant tools that leverage the watch method from the core Node.js fs module and restart servers when we save 
 changes from an editor:
  
 
  
 forever ( 
 http://npmjs.org/forever
 ) (GitHub, 
 http://github.com/nodejitsu/forever
 ) 
  
 usually used in production (we examine this topic in Chapter 11)
  
 
  
 node-dev ( 
 https://npmjs.org/package/node-dev
 ) (GitHub,  
 https://github.com/fgnass/node-dev
 )
  
 30",NA
Summary,"In this chapter, we explored Installing Node.js and NPM, and launching Node.js scripts from the command line. We 
 also looked at the essential concepts of Node.js syntax and the platform. Last, lists of Node.js IDEs and libraries for 
 development were provided.
  
 In the next chapter, we dive deep into using the most popular Node.js framework for creating web apps.",NA
Chapter 2,NA,NA
Using Express.js 4 to Create ,NA,NA
Node.js Web Apps,"It’s only logical that, by using frameworks, software engineers become more productive and can achieve results 
 faster. Often, the results are of a better quality because the frameworks are used and maintained by many other 
 developers and contributors. Even if developers build everything from scratch, they end up with 
 their own framework
  
 in the end. It’s just a very customized one!
  
  
 Node.js is a relatively young platform when it comes to frameworks (unlike Ruby or Java), but there’s already a 
 leader that has become a de facto standard used in the majority of Node.js projects: Express.js.
  
  
 Express.js is an amazing framework for Node.js projects, and it’s used in the majority of web apps, which is 
 why this second chapter is dedicated to getting started with this framework.
  
 In this chapter we cover the following topics, which serve as an introduction to Express.js:
  
 
  
 What Express.js is
  
 
  
 How Express.js works
  
 
  
 Express.js Installation
  
 
  
 Express.js scaffolding (command-line tool)
  
 
  
 The Blog Project overview
  
 
  
 Express.js 4 Hello World example",NA
What Is Express.js?,"Express.js is a web framework based on the core Node.js http module and Connect (
 http://www.senchalabs.org/ 
 connect/
 ) components. The components are called 
 middleware
  and they are the cornerstones of the framework 
 philosophy 
 configuration over convention
 . In other words, Express.js systems are highly configurable, which allows 
 developers to pick freely whatever libraries they need for a particular project. For these reasons, the Express.js 
 framework leads to flexibility and high customization in the development of web applications.
  
  
 If you write serious apps using only core Node.js modules (refer to the following snippet for an example), you 
 most likely find yourself reinventing the wheel by writing the same code continually for similar tasks, such as the 
 following:
  
 
  
 Parsing of HTTP request bodies
  
 
  
 Parsing of cookies
  
 
  
 Managing sessions
  
 33",NA
How Express.js Works ,"Express.js usually has an entry point—aka, a main file. Most of the time, this is the file that we start with the node 
 command; or export as a module, in some cases. And in this file, we do the following: 
  
  
 1. 
  
 Include third-party dependencies as well as our own modules, such as controllers, utilities, 
  
  
   
 helpers, and models 
  
  
 2. 
  
 Configure Express.js app settings such as template engine and its file extensions 
  
  
 3. 
  
 Connect to databases such as MongoDB, Redis, or MySQL (optional) 
  
  
 4. 
  
 Define middleware such as error handlers, static files folder, cookies, and other parsers 
  
  
 5. 
  
 Define routes 
  
  
 6. 
  
 Start the app 
  
  
 7. 
  
 Export the app as a module (optional) 
  
  
 When the Express.js app is running, it’s listening to requests. Each incoming request is processed according to a 
 defined chain of middleware and routes, starting from top to bottom. This aspect is important in controlling the 
 execution flow. For example, routes/middleware that are higher in the file have precedence over the lower 
 definitions.
  
  
 Because we can have multiple middleware functions processing each HTTP request, some of the functions are in 
 the middle (hence the name 
 middleware
 ). Here are some examples of middleware purposes: 
  
  
  
 Parse cookie information and put it in req object for following middleware/routes 
 1. 
  
 2. 
  
 Parse parameters from the URL and put it in req object for following 
 middleware/routes 
 3. 
  
 Get the information from the database based on the value of 
 the parameter if the user is 
  
 authorized (cookie/session) and put it in req object for 
 following middleware/routes 
 4. 
  
 Authorize users/requests, or not.
  
 5. 
  
 Display the data and end the response",NA
Express.js Installation ,"The Express.js package comes in two flavors: 
  
 1. 
  
 express-generator: a global NPM package that provides the command-line tool for rapid 
  
  
 app creation (scaffolding) 
  
 2. 
  
 express: a local package module in your Node.js app’s node_modules folder",NA
Express.js Version ,"Before we proceed with installations, let’s check the Express.js versions. We’ll use an exact version 4.1.2 to 
 avoid confusion resulting from potential future changes to the Express.js skeleton-generating mechanism and 
 the module API.
  
 For the Express.js Generator, which is a separate module, we’ll use version 4.0.0, which is compatible with 
 Express.js 4.x. If you have a version other than 4.0.0 ($ express -V to check), you can uninstall it using $ sudo npm 
 uninstall -g express-generator. Or $ sudo npm uninstall -g express for Express.js 2.x and 3.x. Before, version 4.x, 
 Express.js Generator was a part of the Express.js module itself. After you’ve uninstalled the older versions, install the 
 proper version with the next section’s commands.",NA
Express.js Generator,"To install the Express.js Generator as global package, run $ npm install -g express-generator@4.0.0 from anywhere 
 on your computer. This downloads and links the $ express terminal command to the proper path, so that later we 
 can access its command-line interface (CLI) for the creation of new apps.
  
 ■
 Note
  For Max os x and Linux users, if there is an error installing globally, most likely your system 
 requires root/
  
 administrator rights to write to the folder. in this case, 
 $ sudo npm install -g express-generator@4.0.0
  might 
 be 
  
 needed. refer to Chapter 1 for more information on changing npM ownership.
  
  
 Of course, we can be more vague and tell NPM to install the latest version of express-generator: $ npm install –g 
 express-generator. But in this case your results might be inconsistent with the book’s examples.
  
 The Figure 
 2-1
  shows us results of running the aforementioned command. Please notice the path in Figure 
 2-
 1
 : /usr/local/lib/node_modules/express-generator. This is where, on Max OS X / Linux systems, NPM puts global 
 modules by default. We verify the availability of Express.js CLI by running $ express –V.
  
  
 Figure 2-1.
  The result of running NPM with -g and $ express -V",NA
Local Express.js,"For the local Express.js 4.1.2 module installation, let’s create a new folder express-cli somewhere on your computer: $ 
 mkdir express-cli. This will be our project folder for the chapter. Now we can open it with $ cd express-cli. When we 
 are inside the project folder, we can create package.json manually in a text editor or with the $ npm init terminal 
 command (Figure 
 2-2
 ).",NA
Express.js Scaffolding,"So far, we’ve covered Expres.js installation. When it comes to prototyping, it’s vital to be able to get started quickly 
 with the solid app skeleton, which is why many modern frameworks provide some type of scaffolding. Now is the time 
 to explore its rapid app creation mechanism— Express.js Generator!
  
  
 Comparable with Ruby on Rails and many other web frameworks, Express.js comes with a CLI for jump-
 starting your development process. The CLI generates a basic foundation for the most common cases.
  
 If you followed the global installation instructions in the installation section, you should be able to see the 
 version number 4.0.0 if you run $ express -V from anywhere on your machine. If we type $ express -h or $ express --
 help, we should get the list of available options and their usage. The list of options is broken down below to serve 
 readers as a reference.
  
  
 To generate a skeleton Express.js app, we need to run a terminal command— express 
 [options] [dir|appname]—the options for which are the following:
  
 
  
 -e, --ejs: add EJS (
 http://embeddedjs.com/
 ) engine support (by default, Jade 
  
 (
 http://jade-lang.com/tutorial/
 ) is used)
  
 
  
 -H, --hogan: add Hogan.js engine support
  
 
  
 -c <engine>, --css <engine>: add stylesheet <engine> support, such as LESS 
  
 (
 http://lesscss.org/
 ), Stylus (
 http://learnboost.github.io/stylus/
 ) or Compass 
  
 (
 http://compass-style.org/
 ) (by default, plain CSS is used)
  
 
  
 -f, --force: force app generation on a nonempty directory
  
  
 If the dir/appname option is omitted, Express.js creates files using the current folder as the base for the project. 
 Otherwise, the application is in the folder with the name provided.
  
 Now that we’re clear with the command and its options, let’s go step by step to create an app with the scaffolding:
  
 1. 
  
 Check the Express.js version, because the app-generating code is prone to changes.
  
 2. 
  
 Execute the scaffolding command with options.
  
 3. 
  
 Run the application locally.
  
 40",NA
Express.js Command-Line Interface,"Now we can use the CLI to spawn new Express.js apps. For example, to create an app with Stylus support, type the 
 following:
  
 $ express -c styl express-styl
  
 Then, as the instructions in the terminal tell us (Figure 
 2-5
 ), type:
  
 $ cd express-styl && npm install 
  
 $ DEBUG=my-application ./bin/www 
  
  
 Figure 2-5.
  The result of using Express.js Generator
  
 Open the browser of your choice at 
 http://localhost:3000
 .
  
 If you don’t have computer in front of your right now, here’s the full code of express-styl/app.js using Express.
  
 js Generator v4.0.0:
  
 var express = require('express'); 
  
 var path = require('path'); 
  
 var favicon = require('static-favicon'); 
  
 var logger = require('morgan'); 
  
 var cookieParser = require('cookie-parser'); 
  
 var bodyParser = require('body-parser');
  
 var routes = require('./routes/index'); 
  
 var users = require('./routes/users');
  
 41",NA
Routes in Express.js,"When you open express-styl/app.js, you see two routes in the middle:
  
 app.use('/', routes); 
  
 app.use('/users', users);
  
 The first one basically takes care of all the requests to the home page, such as http://localhost:3000/. The 
 second takes care of requests to /users, such as http://localhost:3000/users. Both of the routes process URLs in a 
 case-insensitive manner and in a same way as with trailing slashes.
  
 By default, Express.js doesn’t allow developers to route by query string arguments, such as the following:
  
 GET: www.webapplog.com/?id=10233 
  
 GET: www.webapplog.com/about/?author=10239 
  
 GET: www.webapplog.com/books/?id=10&ref=201
  
 However, it’s trivial to write your own middleware. It might look like this:
  
 app.use(function (req, res, next) {
  
  if (req.query.id) {
  
   
  // process the id, then call next() when done
  
  else if (req.query.author) {
  
   
  // same approach as with id
  
  else if (req.query.id && req.query.ref) {
  
   
  // process when id and ref present
  
  } else {
  
   
  next();
  
  } 
  
 });
  
 app.get('/about', function (req, res, next) {
  
  
  // this code is executed after the query string middleware });
  
  
 The request handler itself (index.js, in this case) is straightforward. Everything from the HTTP request is in req 
 and it writes results to the response in res:
  
 exports.list = function(req, res){
  
  res.send('respond with a resource'); 
  
 };",NA
Middleware as the Backbone of Express.js,"Each line/statement above the routes in app.js is middleware:
  
 var favicon = require('static-favicon'); 
  
 var logger = require('morgan'); 
  
 var cookieParser = require('cookie-parser'); 
  
 var bodyParser = require('body-parser'); 
  
 //...
  
 app.use(favicon());
  
 43",NA
Configuration of an Express.js App,"Here is how we define configuration statements in a typical Express.js app (the app.js file):
  
 app.set('views', path.join(__dirname, 'views')); 
  
 app.set('view engine', 'jade');
  
 And in bin/www:
  
 app.set('port', process.env.PORT || 3000);
  
  
 An ordinary setting involves a name, such as views, and a value, such as path.join(__dirname, 'views'), a path 
 to the folder where the templates/views live.
  
 Sometimes there is more than one way to define a certain setting. For example, app.enable('trust proxy') for 
 Boolean flags is identical (aka, sugar-coating) to app.set('trust proxy', true). The Chapter 11 explains why we might 
 need to trust proxy.",NA
Jade Is Haml for Express.js/Node.js,"The Jade template engine is akin to the Ruby on Rails’ Haml in the way it uses whitespace and indentation, such as 
 layout.jade:
  
 doctype html 
  
 html
  
  head
  
   
  title= title
  
   
  link(rel='stylesheet', href='/stylesheets/style.css') body
  
   
  block content
  
  
 Other than that, it’s possible to use a full-blown JavaScript code inside of Jade templates with the - prefix. More 
 information on Jade and Handlebars template engines is in Chapter 4.
  
 44
  
 www.allitebooks.com",NA
Conclusion About Scaffolding ,"As you’ve seen, it’s effortless to create web apps with Express.js. The framework is splendid for REST APIs as well. If 
 you feel like the settings and other methods mentioned in this chapter just flew over your head, don’t despair! Pro 
 Express.js 4 [2014 Apress] is dedicated solely to Express.js and its interface which can serve as a good reference. 
 For now, the next step is to create a foundation for our project: the Blog app.",NA
The Blog Project Overview ,"Our Blog app consists of five main parts from the user 
 perspective:
 
  
 A home page 
 with a list of articles (Figure 
 2-6
 )
  
  
 Figure 2-6.
  The home page of the Blog app
  
 
  
 An individual article page with the full-text article
  
 
  
 An admin page for publishing and removing content
  
 
  
 A login page for accessing the aforementioned admin page
  
 
  
 A post article page for adding new content",NA
Submitting the Data,"The first approach is traditional and is considered more search engine optimization friendly, but it takes longer 
 for 
  
 users (especially on mobile) and is not as smooth as the second approach (Figure 
 2-7
 ).
  
 Traditional server-side approach
  
 User
  
 Browser
  
 Server
  
 Url
  
 Url
  
 Find data
  
 Generate HTML
  
 Full HTML page
  
 Full DOM
  
 User
  
 Browser
  
 Server
  
 Figure 2-7.
  Traditional server-side approach
  
 46",NA
Express.js 4 Hello World Example ,"This is the first and the last hello world example in this book! :-) The goal is to show readers how easy is it to 
 create Express.js apps from scratch without generators, fancy modules and middleware. We’ll go through these 
 sections:
 
  
 Setting up folders
  
 
  
 NPM init and package.json
  
 
  
  
 Dependency declaration
 
  
 The app.js file
  
 
  
 Meet Jade
  
 
  
 Running the app 
  
 48",NA
Setting up Folders,"Express.js is very configurable and almost all folders can be renamed. However, there are certain conventions that 
 might help beginners to find their way through many files. Here is a list of the main folders that we use in this 
 chapter, and their meaning:
  
 
  
 node_modules: dependencies (third-party modules) live here as well as Express.js and 
  
 Connect libraries
  
 
  
 views: Jade (or any other template engine) files
  
  
 That’s it for now, but if you want to create a few more folders for other examples (that we’ll cover in the 
 later chapters), be my guest:
  
 
  
 routes: Node.js modules that contain request handlers
  
 
  
 db: seed data and scripts for MongoDB
  
 
  
 public: all the static (front-end) files, including HTML, CSS, JavaScript (browser), and Stylus 
  
 (or any other CSS-language framework files)
  
  
 Let’s choose a project folder hello-world, and create these directories with Finder or the following terminal 
 command (Figure 
 2-10
 ):
  
 mkdir {public,public/css,public/img,public/js,db,views,views/includes,routes} 
  
  
 Figure 2-10.
  Setting up folders
  
 Now we’re all set to add project metadata with NPM.",NA
NPM Init and package.json,"For this example we will be creating the Express.js app from scratch, i.e., without Express.js Generator. We’ll start 
 with defining dependencies with package.json and NPM. 
  
 49",NA
Dependency Declaration: npm install,"Another way to create a package.json file (without using $ npm init) is to type or copy and paste package.json and run 
 $ npm install:
  
 {
  
  ""name"": ""hello-world"",
  
  ""version"": ""0.0.1"",",NA
The App.js File,"The app.js file is the main file for this example. A typical structure of the main Express.js file consists of the following 
 areas (this may be a partial repeat from an earlier section, but this is important, so bear with me):
  
 1. 
  
 Require dependencies
  
 2. 
  
 Configure settings
  
 3. 
  
 Connect to database (
 optional
 )
  
 4. 
  
 Define middleware
  
 5. 
  
 Define routes
  
 6. 
  
 Start the server
  
 7. 
  
 Start workers with clusters (a term spawn workers is also used for this) (
 optional
 )
  
 The order here is important, because requests travel from top to bottom in the chain of middleware.
  
 Let’s perform a quintessential programming exercise: writing the Hello World application. This app transitions 
 smoothly into the Blog example project, so no effort is wasted!
  
 Open app.js in a code editor of your choice and start writing or just copy the code from GitHub at 
 http://github.com/azat-co/blog-express
 . 
  
 First, all the dependencies need to be included with require():
  
 var express = require('express'); 
  
 var http = require('http'); 
  
 var path = require('path');
  
 Then, the Express.js object is instantiated (Express.js uses a functional pattern):
  
 var app = express();
  
 51",NA
Meet Jade: One Template to Rule Them All,"Jade is an absolutely amazing template engine that allows developers to type less code and to execute powerfully 
 almost all JavaScript functions. It also supports top-to-bottom and bottom-to-top inclusion and other useful things. 
 Like its brother from the Ruby world, Haml, Jade uses whitespace/indentation as a part of its language. It’s a 
 convention to use two-space indentation.
  
 The Jade syntax and its features are covered more extensively in Chapter 4. For now, just keep in mind that 
 the way Jade works is that the first word is used as an HTML tag (HTML element) and the text that follows (a.k.a., 
 inner text), is put inside this element. For example,
  
 h1 hello 
  
 p Welcome to the Practical Node.js!
  
 Produces the following HTML code:
  
 hello</h1> 
  
 <p>Welcome to the Practical Node.js!</p>
  
 If we want to output a value of a variable (called locals), we use =. For example:
  
 p= msg
  
  
 For this example, create index.jade in the views folder that outputs a header and a paragraph with the value of 
 msg variable inside that paragraph (i.e., inner text):
  
 h1 hello 
  
 p= msg
  
  
 There are more advanced examples of Jade included later in this book; but for now, everything is set for the 
 first demo!",NA
Running the Hello World App,"When we run the $ node app command and open browsers at http://localhost:3000, we see what appears in 
 Figure 
 2-12
 .
  
 55",NA
Summary,"In this chapter we learned what Express.js is and how it works. We also explored different ways to install it and use 
 its scaffolding (command-line tool) to generate apps. We went through the Blog example with a high-level overview 
 (traditional vs. REST API approaches), and proceeded with creating the project file, folders, and the simple Hello 
 World example, which serves as a foundation for the book’s main project: the Blog app. And then lastly, we touched 
 on a few topics such as settings, a typical request process, routes, AJAX versus server side, Jade, templates, and 
 middleware.
  
 56",NA
Chapter 3,NA,NA
TDD and BDD for Node.js with ,NA,NA
Mocha,"Test-driven development (TDD), as many of you might know, is one of the main, agile development techniques. 
  
 The genius of TDD lies in increased quality of code, faster development resulting from greater programmer 
 confidence, and improved bug detection (duh!).
  
 Historically, web apps have been hard to autotest, and developers relied heavily on manual testing. But, certain 
 parts such as standalone services and REST API can be 
 and should be
  tested thoroughly by the TDD. At the same time, 
 rich user interface (UI) / user experience (UX) can be tested with headless browsers such as PhantomJS.
  
  
 The behavior-driven development (BDD) concept is based on TDD. It differs from TDD in language, which 
 encourages collaboration between product owners and programmers.
  
  
 Similar to building apps themselves, most of the time software engineers should use a testing framework. To 
 get you started with the Node.js testing framework, Mocha, in this chapter, we cover the following:
  
 
  
 Installing and understanding Mocha
  
 
  
 TDD with the assert
  
 
  
 BDD with Expect.js
  
 
  
 Project: writing the first BDD test for Blog
  
  
 The source code for this chapter is in the ch3 folder of the practicalnode GitHub repository 
 (
 https://github.com/azat-co/practicalnode
 ).",NA
Installing and Understanding Mocha,"Mocha is a mature and powerful testing framework for Node.js. To install it, simply run:
  
 $ npm install –g mocha@1.16.2 
  
 ■
 Note
  We use a specific version (the latest as of this writing is 1.16.2) to prevent inconsistency in this 
 book’s 
  
 examples caused by potential breaking changes in future versions of Mocha.
  
 If you encounter the lack-of-permissions issue, discussed in Chapters 1 and 2, run:
  
 $ sudo npm install –g mocha@1.16.2
  
 To avoid using sudo, follow the instructions in Chapter 1 on how to install Node.js correctly.",NA
Understanding Mocha Hooks,"A hook is some logic, typically a function or a few statements, which is executed when the associated event happens; 
  
 for example, in Chapter 7 we'll use hooks to explore the Mongoose library pre hooks. Mocha has hooks that are 
  
 executed in different parts of suites—before the whole suite, before each test, and so on.
  
 In addition to before and beforeEach hooks, there are after(), and afterEach() hooks. They can be used to 
  
 clean up the testing setup, such as database data?
  
 59",NA
TDD with the Assert,"Let’s write our first tests with the assert library. This library is part of the Node.js core, which makes it easy to access. 
  
 It has minimal functionality, but it might be enough for some cases, such as unit tests. 
  
  
 After global Mocha installation is finished, a test file can be created in a test-example folder:
  
 $ mkdir test-example 
  
 $ subl test-example/test.js",NA
Chai Assert,"In the previous example with test.js and assert, we used the Node.js core module assert. Chai is a subset of that 
 library. We can modify our previous example to use chai assert with following code:
  
 $ npm install chai@1.8.1
  
 And in test-example/test.js:
  
 var assert = require('chai').assert;
  
 The following are some of the methods from the chai assert library:
  
 
  
 assert(expressions, message): throws an error if the expression is false
  
 
  
 assert.fail(actual, expected, [message], [operator]): throws an error with values of 
  
 actual, expected, and operator
  
 
  
 assert.ok(object, [message]): throws an error when the object is not double equal (==) to 
  
 true—aka, truthy (0, and an empty string is false in JavaScript/Node.js)
  
 62",NA
BDD with Expect.js,"Expect.js is one of the BDD languages. Its syntax allows for chaining and is richer in features than core module assert. 
 There are two options to use expect.js:
  
 1. 
  
 Install as a local module
  
 2. 
  
 Install as a part of the chai library
  
 For the former, simply execute the following:
  
 $ mkdir node_modules 
  
 $ npm install expect.js@0.2.0
  
  
 And, use var expect = require('expect.js'); inside a Node.js test file. For example, the previous test can be 
 rewritten in expect.js BDD style:
  
 var expect = require('expect.js'); 
  
 var expected, current; 
  
 before(function(){
  
  expected = ['a', 'b', 'c']; 
  
 }) 
  
 describe('String#split', function(){
  
  beforeEach(function(){
  
   
  current = 'a,b,c'.split(',');
  
  })
  
  it('should return an array', function(){
  
   
  expect(Array.isArray(current)).to.be.true;
  
  });
  
 63",NA
Expect.js Syntax,"The Expect.js library is very extensive. It has nice methods that mimic natural language. Often there are a few 
 ways to write the same assertion, such as expect(response).to.be(true) and expect(response).equal(true). The 
 following lists some of the main Expect.js methods/properties:
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 ok: checks for truthyness 
  
 true: checks whether the object is truthy 
  
 to.be, to: chains methods as in linking two methods 
  
 not: chains with a not connotation, such as expect(false).not.to.be(true) a/an: 
 checks type (works with array as well) 
  
 include/contain: checks whether an array or string contains an element 
 below/above: checks for the upper and lower limits
  
 ■
 Note
  again, there is a slight deviation between the standalone 
 expect.js
  module and its Chai 
 counterpart.
  
  
 For the full documentation on chai expect.js, refer to 
 http://chaijs.com/api/bdd/
 , and for the standalone, refer to 
 https://github.com/LearnBoost/expect.js/
 .
  
 64",NA
Project: Writing the First BDD Test for Blog,"The goal of this mini-project is to add a few tests for Blog (this book’s primary project). We won’t get into 
 headless browsers and UI testing, but we can send a few HTTP requests and parse their responses from the app’s 
 REST end points (see Chapter 2 for a description of the Blog app).
  
  
 The source code for this chapter is in the ch3/blog-express folder of the practicalnode GitHub repository 
 (
 https://github.com/azat-co/practicalnode
 ).
  
  
 First, let’s copy the Hello World project. It will serve as a foundation for Blog. Then, install Mocha in the Blog 
 project folder, and add it to the package.json file at the same time with $ npm install mocha@1.16.2 --save-dev. 
  
 The --save-dev flag will categorize this module as a development dependency (devDependencies). Modify this 
 command by replacing package name and version number for expect.js (0.2.0) and superagent (0.15.7) (
 https:// 
 npmjs.org/package/superagent
 ). The latter is a library to streamline the making of HTTP requests. Alternatives to 
 superagent include the following:
  
 
  
 request(
 https://npmjs.org/package/request
 ): the third most-starred NPM module (as of 
  
 this writing)
  
 
  
 core
 http
 module
 : clunky and very low level
  
 
  
 supertest: a superagent-based assertions library
  
 Here’s the updated package.json:
  
 {
  
  ""name"": ""blog-express"",
  
  ""version"": ""0.0.1"",
  
  ""private"": true,
  
  ""scripts"": {
  
   
  ""start"": ""node app.js"",
  
   
  ""test"": ""mocha test""
  
  },
  
  ""dependencies"": {
  
   
  ""express"": ""4.1.2"",
  
   
  ""jade"": ""1.3.1"",
  
   
  ""stylus"": ""0.44.0""
  
  },
  
  ""devDependencies"": {
  
   
  ""mocha"": ""1.16.2"",
  
   
  ""superagent"": ""0.15.7"",
  
   
  ""expect.js"": ""0.2.0""
  
  } 
  
 }
  
  
 Now, create a test folder with $ mkdir tests and open tests/index.js in your editor. The test needs to start the 
 server:
  
 var boot = require('../app').boot,
  
  shutdown = require('../app').shutdown,
  
  port = require('../app').port,
  
  superagent = require('superagent'),
  
  expect = require('expect.js'); 
  
 describe('server', function () {
  
  before(function () {
  
   
  boot();
  
  });
  
 65",NA
Putting Configs into a Makefile,"The mocha accepts many options. It’s often a good idea to have these options gathered in one place, which could be a 
 Makefile. For example, we can have test, test-w test all files in the test folder, and have modes for just the module-a.js 
 and module-b.js files to test them separately, this way:
  
 REPORTER = list 
  
 MOCHA_OPTS = --ui tdd --ignore-leaks
  
 test:
  
  clear
  
  echo Starting test ********************************************************* 
 ./node_modules/mocha/bin/mocha \
  
  --reporter $(REPORTER) \
  
  $(MOCHA_OPTS) \
  
  tests/*.js
  
  echo Ending test
  
 test-w:
  
  ./node_modules/mocha/bin/mocha \
  
  --reporter $(REPORTER) \
  
  --growl \
  
  --watch \
  
  $(MOCHA_OPTS) \
  
  tests/*.js
  
 test-module-a:
  
  
  mocha tests/module-a.js --ui tdd --reporter list --ignore-leaks
  
 67",NA
Summary,"In this chapter, we installed Mocha as a command-line tool and learned its options, we wrote simple tests with assert 
 and the expect.js libraries, and we created the first test for the Blog app by modifying app.js to work as a module. In 
 Chapter 10, we harness TravisCI SaaS by writing a yml config file and using GitHub to trigger continuous multiple 
 tests in the cloud virtual environments. In the next chapter, proceeds the essence of any web app that outputs 
  
 HTML—template engine. We'll dive deep into Jade and Handlebars, and add pages to Blog.
  
 69",NA
Chapter 4,NA,NA
Template Engines: ,NA,NA
Jade and ,NA,NA
Handlebars,"A template engine is a library or a framework that uses some rules/languages to interpret data and render views. In 
 the case of web applications, views are HTML pages (or parts of them), but they can be JSON or XML files, or, in 
 desktop programs, GUIs. For those of you familiar with the model–view–controller concept, templates belong to the 
 view.
  
  
 In web apps, it’s beneficial to use templates because we can generate an infinite number of pages dynamically 
 with a single template! Another side benefit is when we need to change something; we can do it in one place only.
  
 If we go back to the diagrams in the previous chapter (traditional vs. REST API approaches), we can deduce that 
 templates can be compiled into HTML either server-side (traditional approach) or client-side (REST API approach). 
 No matter which approach we take, the syntax of the libraries themselves remains intact.
  
 In this chapter we cover the following:
  
 
  
 Jade syntax and features
  
 
  
 Jade standalone usage
  
 
  
 Handlebars syntax
  
 
  
 Handlebars standalone usage
  
 
  
 Jade and Handlebars usage in Express.js 4
  
 
  
 Project: adding Jade templates to Blog",NA
Jade Syntax and Features,"Jade is a Node.js brother of Haml, in the sense that it uses whitespace and indentation as part of its language. 
 Therefore, we need to be careful to follow the proper syntax.
  
 You can follow the Jade syntax examples in this section, online, at the official web site’s demo page 
  
 (
 http://jade-lang.com/demo
 ) or at the @naltatis resource (
 http://naltatis.github.io/jade-syntax-docs/
 ), or by writing 
 standalone Node.js scripts (examples are presented in “Jade Standalone Usage,” which appears later in this chapter).",NA
Tags,"Any text at the beginning of a line—by default—is interpreted as an HTML tag. The main advantage of Jade is that this 
 text renders both closing and opening tags for the HTML element, as well as the <></>symbols. Therefore, we save 
 many keystrokes as developers writing in Jade!",NA
Variables/Locals,"Data that are passed to the Jade template are called 
 locals
 . To output the value of a variable, use =. See the 
 following examples: 
  
  
 Jade code:
  
 h1= title 
  
 p= body
  
 Locals:
  
 {
  
  title: ""Express.js Guide"",
  
  body: ""The Comprehensive Book on Express.js"" 
  
 }
  
 HTML output:
  
 <h1>Express.js Guide</h1> 
  
 <p>The Comprehensive Book on Express.js</p>
  
 72",NA
Attributes,"Attributes are added by putting them into parentheses right after the tag name. They follow name=value format. 
 In addition, multiple attributes need to be separated by a comma. For example,
  
 div(id=""content"", class=""main"")
  
  a(href=""
 http://expressjsguide.com
 "", title=""Express.js Guide"", target=""_blank"") Express.js Guide 
 form(action=""/login"")
  
   
  button(type=""submit, value=""save"")
  
  div(class=""hero-unit"") Lean Node.js!
  
 turns into
  
 <div id=""content"" class=""main""><a href=""
 http://expressjsguide.com
 "" title=""Express.js Guide"" 
 target=""_blank"">Express.js Guide</a>
  
  <form action=""/login"">
  
   
  <button type=""submit"" value=""save""></button>
  
  </form>
  
  <div class=""hero-unit"">Learn Node.js</div> 
  
 </div>
  
 Sometimes, the value of an attribute needs to be dynamic. In this case, just use the variable name! The pipe, or |, 
 allows us to write the content of the HTML node on the new line—in other words, the line with the pipe becomes 
 inner text an example is as follows:
  
 a(href=url, data-active=isActive) 
  
 label
  
  input(type=""checkbox"", checked=isChecked)
  
  |  yes / no
  
 The template above is provided with locals:
  
 {
  
  url: ""/logout"",
  
  isActive: true,
  
  isChecked: false 
  
 }
  
 And they both, i.e., template and locals data, produce output:
  
 <a href=""/logout"" data-active=""data-active""></a> 
  
 <label>
  
  <input type=""checkbox""/>yes / no 
  
 </label>
  
  
 Note that the attribute with the value false is omitted from the HTML output. However, when no value is passed, 
 true is assumed—for example,
  
 input(type='radio', checked) 
  
 input(type='radio', checked=true) 
  
 input(type='radio', checked=false) 
  
 <input type=""radio"" checked=""checked""/> 
  
 <input type=""radio"" checked=""checked""/> 
  
 <input type=""radio""/> 
  
 73",NA
Literals,"For convenience, we can write classes and IDs right after tag names. For example, we can then apply lead and center 
 classes to a paragraph, and create a div element with the side-bar ID and pull-right class (again, the pipe signifies an 
 inner text):
  
 div#content
  
  p.lead.center
  
   
  | webapplog: where code lives
  
   
  #side-bar.pull-right
  
   
  span.contact.span4
  
    
  a(href=""/contact"") contact us 
  
 <div id=""content"">
  
  <p class=""lead center"">
  
   
  webapplog: where code lives
  
   
  <div id=""side-bar"" class=""pull-right""></div>
  
   
  <span class=""contact span4"">
  
    
  <a href=""/contact"">contact us</a>
  
   
  </span>
  
  </p> 
  
 </div>
  
 Note that if the tag name is omitted, div is used instead.",NA
Text,"Outputting raw text is done via |—for example,
  
 div
  
  | Jade is a template engine.
  
  | It can be used in Node.js and in the browser JavaScript.",NA
Script and Style Blocks,"Sometimes, developers want to write chunks of content for script or style tags in the HTML! This is possible with a 
 dot. For example, we can write inline front-end JavaScript like this:
  
 script.
  
   
  console.log('Hello Jade!')
  
   
  setTimeout(function(){
  
    
  window.location.href='
 http://rpjs.co
 '
  
   
  },200))
  
   
  console.log('Good bye!') 
  
 <script>
  
  console.log('Hello Jade!')
  
  setTimeout(function(){
  
   
  window.location.href='
 http://rpjs.co
 '
  
  },200))
  
  console.log('Good bye!') 
  
 </script>
  
 74",NA
JavaScript Code,"Contrary to the previous example, if we want to use 
 any
  JavaScript at template compilation time—in other words, to 
 write executable JavaScript code that manipulates the output of the Jade (i.e., HTML)—we can use the -, =, or != 
 symbols. This might come in handy when we output HTML elements and inject JavaScript. Obviously, these types of 
 things should be done carefully to avoid cross-site scripting (XSS) attacks. For example, if we want to define an array 
 and output <> symbols, we can use !=.
  
 - var arr = ['<a>','<b>','<c>'] 
  
 ul
  
  - for (var i = 0; i< arr.length; i++)
  
   
  li
  
    
  span= i
  
    
  span!=""unescaped: "" + arr[i] + "" vs. ""
  
    
  span= ""escaped: "" + arr[i]
  
 produces this:
  
 <ul>
  
  <li><span>0</span><span>unescaped: <a> vs. </span><span>escaped: &lt;a&gt;</span></li> 
 <li><span>1</span><span>unescaped: <b> vs. </span><span>escaped: &lt;b&gt;</span></li> 
 <li><span>2</span><span>unescaped: <c> vs. </span><span>escaped: &lt;c&gt;</span></li> </ul> 
  
 ■
 Tip
  One of the main differences between Jade and handlebars is that the former allows pretty much 
 any Javascript 
  
 in its code whereas the latter restricts programmers to only a handful of built-in and custom-registered 
 helpers.",NA
Comments,"When it comes to comments, we have a choice to output them or not. For the former, use JavaScript style //; for the 
 latter, use //-. For example,
  
 // content goes here 
  
 p Node.js is a non-blocking I/O for scalable apps.
  
 //- @todo change this to a class 
  
 p(id=""footer"") Copyright 2014 Azat
  
 outputs
  
 <!-- content goes here--> 
  
 <p>Node.js is a non-blocking I/O for scalable apps.</p> <p 
 id=""footer"">Copyright 2014 Azat</p>",NA
Conditions (if),"Interestingly enough, in addition to the standard JavaScript code where the if statement can be used by prefixing it 
 with -, we can use a minimalistic Jade alternative with no prefix and no parentheses—for example,
  
 - var user = {}
  
 - user.admin = Math.random()>0.5 
  
 if user.admin
  
   
  button(class=""launch"") Launch Spacecraft 
  
 else
  
  
  button(class=""login"") Log in
  
 There’s also unless, which is equivalent to not or !.",NA
Iterations (each loops),"Similar to conditions, iterators in Jade can be written simply with each—for example,
  
 - var languages = ['php', 'node', 'ruby'] 
  
 div
  
  each value, index in languages
  
   
  p= index + "". "" + value
  
 The HTML output is as follows:
  
 <div>
  
  <p>0. php</p>
  
  <p>1. node</p>
  
  <p>2. ruby</p> 
  
 </div>
  
 The same construction works with objects as well:
  
 - var languages = {'php': -1, 'node': 2, 'ruby':1} div
  
  each value, key in languages
  
   
  p= key + "": "" + value
  
 The Jade above is compiled into the HTML output:
  
 <div>
  
  <p>php: -1</p>
  
  <p>node: 2</p>
  
  <p>ruby: 1</p> 
  
 </div>
  
 76",NA
Filters,"Filters are used when there are blocks of texts written in a different language. For example, the filter for 
 Markdown looks like this:
  
 p
  
  :markdown
  
   
  # Practical Node.js
  
  
  [This book](
 http://expressjsguide.com
 ) really helps to grasp many components needed for  modern-day 
 web development. 
  
 ■
 Note
  the markdown modules still need to be installed. the 
 marked
  and markdown npm packages are 
 often used for 
  
 this. there’s no need for an additional configuration, just install them in the project's local 
 node_modules
  
 folder.",NA
Interpolation,"Interpolation in Jade is achieved via #{name}. For example, to output title in a paragraph, do the following:
  
 - var title = ""Express.js Guide"" 
  
 p Read the #{title} in PDF, MOBI and EPUB
  
 The interpolation is processed at template compilation; therefore, don’t use it in executable JavaScript (-).:",NA
Case,"Here’s an example of the case statement in Jade:
  
 - var coins = Math.round(Math.random()*10) 
  
 case coins
  
  when 0
  
   
  p You have no money
  
  when 1
  
   
  p You have a coin
  
  default
  
   
  p You have #{coins} coins!",NA
Mixins,"Mixins are functions that take parameters and produce some HTML. The declaration syntax is mixin name(param, 
 param2,...), and the usage is +name(data). For example,
  
 mixin row(items)
  
  tr
  
   
  each item, index in items
  
    
  td= item",NA
Include,"include is a way to split logic into a separate file for the purpose of reusing it across multiple files. It’s a top-to-
 bottom approach; we dictate what to use in the file that includes another file. The file that includes is processed first 
 (we can define locals there), then the included file is processed (we can use earlier defined locals).
  
 To include a Jade template, use include /path/filename. For example, in file A:
  
 include ./includes/header
  
 Notice there’s no need for double or single quotes for the template name and its path. 
 It’s possible to traverse up the tree:
  
 include ../includes/footer
  
  
 But, there’s no way to use a dynamic value for the file and path (use a variable), because includes/partials 
 are handled at compilation (not at runtime).
  
 78",NA
Extend,"extend is a bottom-to-top approach (as oppose to include), in the sense that the included file commands which parts 
 of the main file it wants to replace. The way it works is with extend filename and block blockname statements: 
  
 In 
 file_a:
  
 block header
  
  p some default text 
  
 block content
  
  p Loading ...
  
 block footer
  
  p copyright
  
 In file_b:
  
 extend file_a 
  
 block header
  
  p very specific text 
  
 block content
  
  .main-content",NA
Standalone Jade Usage,"Template engines are not always used with Node.js (and frameworks like Express.js). Sometimes, we might just 
 want to use Jade in a standalone manner. The use cases include generating an e-mail template, precompiling Jade 
 before deployment, and debugging. In this section, we do the following:
  
 
  
 Install a Jade module
  
 
  
 Create our first Jade file
  
 
  
 Create a Node.js program that uses the Jade file
  
 
  
 Compare jade.compile, jade.render, and jade.renderFile
  
  
 To add a jade dependency to your project, or if you’re starting from scratch from an empty project folder, do 
 the following:
  
 
  
 Create an empty node_modules folder with $ mkdir node_modules
  
 
  
 Install and add jade to package.json with $ npm install jade –save. See the results 
  
 in 
 Figure 
 4-1
 . 
  
 79",NA
Handlebars Syntax,"The Handlebars library is another template engine. It inherits from Mustache and, for the most part, is compatible 
 with Mustache’s syntax. However, Handlebars adds more features (i.e., a superset).
  
  
 Unlike Jade, by design, Handlebars was made so that developers 
 can’t write
  a lot of JavaScript logic inside the 
 templates. This helps to keep templates lean and related strictly to the representation of the data (no business 
 logic).
  
  
 Another drastic difference between Jade and Handlebars is that the latter requires full HTML code (<, >, and so 
 on), and for this reason it could care less about whitespace and indentation.",NA
Variables,"A Handlebars expression is {{, some content, followed by  }}, hence the name of the library (see the resemblance to 
 handlebars on a bicycle?). For example, the Handlebars code:
  
 <h1>{{title}}</h1> 
  
 <p>{{body}}</p>
  
 with data:
  
 {
  
  title: ""Express.js Guide"",
  
  body: ""The Comprehensive Book on Express.js"" 
  
 }
  
 renders:
  
 <h1>Express.js Guide</h1> 
  
 <p>The Comprehensive Book on Express.js</p>",NA
Iteration (each),"In Handlebars, each is one of the built-in helpers; it allows you to iterate through objects and arrays. Inside the block, 
 we can use @key for the former (objects), and @index for the later (arrays). In addition, each item is referred to as 
 this. 
  
 When an item is an object itself, this can be omitted and just the property name is used to reference the value of 
 that property.
  
 The following are examples of the each helper block in Handlebars:
  
 <div> 
  
 {{#each languages}}
  
  <p>{{@index}}. {{this}}</p> 
  
 {{/each}} 
  
 </div>
  
 The template above is supplied with this data:
  
 {languages: ['php', 'node', 'ruby']}
  
 And output this HTML upon compilation:
  
 <div>
  
  <p>0. php</p>
  
  <p>1. node</p>
  
  <p>2. ruby</p> 
  
 </div>",NA
Unescaped Output,"By default, Handlebars escapes values. If you don’t want Handlebars to escape a value, use triple curly braces: 
 {{{ and }}}.
  
 As data, let’s use this object that has an array with some HTML tags (angle braces):
  
 {
  
  arr: [
  
   
  '<a>a</a>',
  
   
  '<i>italic</i>',
  
   
  '<strong>bold</strong>'
  
  ] 
  
 }
  
 To apply this Handlebars template to our data above (i.e., hydration):
  
 <ul>
  
   
  {{#each arr}}
  
    
  <li>
  
     
  <span>{{@index}}</span>
  
     
  <span>unescaped: {{{this}}} vs. </span>
  
     
  <span>escaped: {{this}}</span>
  
    
  </li>
  
  {{/each}} 
  
 </ul>
  
 84",NA
Conditions (if),"if is another built-in helper invoked via #. For example, this Handlebars code:
  
 {{#if user.admin}}
  
  <button class=""launch"">Launch Spacecraft</button> 
 {{else}}
  
   
  <button class=""login""> Log in</button> 
  
 {{/if}}
  
 populated with data:
  
 {
  
  user: {
  
   
  admin: true
  
  } 
  
 }
  
 turns into this HTML output:
  
 <button class=""launch"">Launch Spacecraft</button>",NA
Unless,"To inverse an if not ... (if ! ...) statement (convert negative to positive), we can harness the unless built-in helper 
 block. For example, the previous code snippet can be rewritten with unless.
  
 85",NA
With,"In case there’s an object with nested properties, and there are a lot of them, it’s possible to use with to pass the 
 context. 
  
 We have this Handlebars code that is handling a user’s contact and address information:
  
 {{#with user}}
  
  <p>{{name}}</p>
  
  {{#with contact}}
  
   
  <span>Twitter: @{{twitter}}</span>
  
  {{/with}}
  
  <span>Address: {{address.city}}, 
  
 {{/with}} 
  
 {{user.address.state}}</span>
  
  
 Then we merge the template with this data. Notice the properties’ names are the same as in the Handlebar 
 template, there’s only one reference to the user object:
  
 {user: {
  
  contact: {
  
   
  email: 'hi@azat.co',
  
   
  twitter: 'azat_co'
  
  },
  
  address: {
  
   
  city: 'San Francisco',
  
   
  state: 'California'
  
  },
  
  name: 'Azat' 
  
 }}
  
 86",NA
Comments,"To output comments, use regular HTML <!-- and -->. To hide comments in the final output, use {{! and }} or {{!-
 - and --}}. For example,
  
 <!-- content goes here --> 
  
 <p>Node.js is a non-blocking I/O for scalable apps.</p> {{! 
 @todo change this to a class}} 
  
 {{!-- add the example on {{#if}} --}} 
  
 <p id=""footer"">Copyright 2014 Azat</p>
  
 outputs
  
 <!-- content goes here --> 
  
 <p>Node.js is a non-blocking I/O for scalable apps.</p> <p 
 id=""footer"">Copyright 2014 Azat</p>",NA
Custom Helpers,"Custom Handlebars helpers are similar to built-in helper blocks and Jade mixins. To use custom helpers, we need to 
 create them as a JavaScript function and register them with the Handlebars instance.
  
  
 This Handlebars template uses our custom helper table which we’ll register (i.e., define) later in the 
 JavaScript/Node.js code:
  
 {{table node}}
  
  
 Here goes the JavaScript/Node.js that tells the Handlebars compiler what to do when it encounters the custom 
 table function (i.e., print an HTML table out of the provided array):
  
 Handlebars.registerHelper('table', function(data) { var str = 
 '<table>';
  
  for (var i = 0; i < data.length; i++ ) {
  
   
  str += '<tr>';
  
   
  for (var key in data[i]) {
  
    
  str += '<td>' + data[i][key] + '</td>';
  
   
  };
  
   
  str += '</tr>';
  
  };
  
  str += '</table>';
  
  return new Handlebars.SafeString (str); 
  
 });
  
 87",NA
Includes (Partials),"Includes or partials templates in Handlebars are interpreted by the {{>partial_name}} expression. Partials are akin to 
 helpers and are registered with Handlebars.registerPartial(name, source), where name is a string and source is a 
 Handlebars template code for the partial.",NA
Standalone Handlebars Usage,"Developers can install Handlebars via NPM with $ npm install handlebars or $ npm install handlebars --save, 
 assuming there’s either node_modules or package.json in the current working directory (see the results of a sample 
 installation in Figure 
 4-3
 ).
  
 88",NA
Jade and Handlebars Usage in Express.js 4,"By default, Express.js 4.x (and 3.x) uses either a template extension provided to the res.render method or the default 
 extension set by the view engine setting, to invoke the require and __express methods on the template library. In 
 other words, for Express.js to utilize a template engine library out of the box, that library needs to have the 
 __express method.
  
 When the template engine library doesn’t provide the __express method, or a similar one with 
 (path, options, callback) parameters, it’s recommended that you use Consolidate.js 
  
 (
 https://github.com/visionmedia/consolidate.js/
 ).
  
 Here is a quick example of Consolidate.js for Express.js 4 (version 4.2.0 and Consolidate version is 0.10.0):
  
 var express = require('express'),
  
  cons = require('consolidate'),
  
  app = express()
  
 app.engine('html', cons.swig)
  
 app.set('view engine', 'html') 
  
 app.set('views', __dirname + '/views')
  
 var platforms = [
  
  { name: 'node' },
  
  { name: 'ruby' },
  
  { name: 'python' } 
  
 ]
  
 app.get('/', function(req, res){
  
  res.render('index', {
  
   
  title: 'Consolidate This'
  
  }) 
  
 })
  
 app.get('/platforms', function(req, res){
  
  res.render('platforms', {
  
   
  title: 'Platforms',
  
   
  platforms: platforms
  
  }) 
  
 })
  
 app.listen(3000) 
  
 console.log('Express server listening on port 3000')
  
 Usually, the source code is in the GitHub repository and the snippet is in the ch4/consolidate folder.
  
  
 For more information on how to configure Express.js settings and use Consolidate.js, refer to the Pro Express.js 4 
 book (Apress, 2014).",NA
Jade and Express.js,"Jade is compatible with Express.js out of the box (in fact, it’s the default choice), so to use Jade with Express.js, you just 
 need to install a template engine module jade (
 https://www.npmjs.org/package/jade
 ) and provide an extension to 
 Express.js via the view engine setting.).
  
 91",NA
Handlebars and Express.js,"Contrary to Jade, the Handlebars library from 
 http://handlebarsjs.com/
  doesn’t come with the __express method, but 
 there are a few options to make Handlebars work with Express.js:).
  
 
  
 consolidate: a Swiss-army knife of Express.js template engine libraries (shown above)
  
 
  
 hbs (
 https://github.com/donpark/hbs
 ): wrapper library for Handlebars
  
 
  
 express-Handlebars (
 file://pchns-f01/TECHNOLOGY/BPR/Techutilities/Apress/ 
  
 Apress%20Outline/express3-handlebars
 ): despite the name, this module should work just 
  
 fine with Express.js 4 as well as version 3.x
  
  
 Here’s how we can use hbs approach (extension hbs). Inside of the typical Express.js app code (i.e., configuration 
 section of the main file that we launch with the $ node command) write the following statements:
  
 ...
  
 app.set('view engine', 'hbs'); 
  
 ...
  
 Or, if another extension is preferable, such as html, we see the following:
  
 ...
  
 app.set('view engine', 'html'); 
  
 pp.engine('html', require('hbs').__express); 
  
 ...",NA
Project: Adding Jade Templates to Blog,"Last, we can continue with Blog. In this section we add main pages using Jade, plus add a layout and some partials:
  
 
  
 layout.jade: global app-wide template
  
 
  
 index.jade: home page with the list of posts
  
 
  
 article.jade: individual article page
  
 
  
 login.jade: page with a login form
  
 
  
 post.jade: page for adding a new article
  
 
  
 admin.jade: page to administer articles after logging in
  
 Because the templates in this mini-project require data, we’ll skip the demo until the chapter 5 where we’ll plug 
 in the MongoDB database. So the source code for the Jade templates is exactly the same as in the ch5 folder of the 
 GitHub repository practicalnode: 
 https://github.com/azat-co/practicalnode
 . Feel free to copy it from there or 
 follow the instructions below.",NA
layout.jade,"Let’s open the project where we left off in the previous chapter and add layout.jade with the document type 
 statement:
  
 doctype html 
  
 ■
 Note
  
 doctype 5
  was deprecated around v1.0.
  
 Now we can add the main tags of the page:
  
 html
  
  head
  
 The title of the each page is provided from the appTitle variable (aka, local):
  
  title= appTitle
  
 Then, in the head tag, we list all the front-end assets that we need app-wide (on each page):
  
  script(type=""text/javascript"", src=""js/jquery-2.0.3.min.js"")
  
  link(rel='stylesheet', href='/css/bootstrap-3.0.2/css/bootstrap.min.css') 
 link(rel=""stylesheet"", href=""/css/bootstrap-3.0.2/css/bootstrap-theme.min.css"") 
 link(rel=""stylesheet"", href=""/css/style.css"")
  
 93",NA
index.jade,"Now we can look at the home page template index.jade that extends layout:
  
 extends layout
  
  
 We set the menu variable to index, so the menu include (i.e., menu.jade) can determine which tab to show 
 as active:
  
 block page
  
  - var menu = 'index'
  
 95",NA
article.jade,"The individual article page (Figure 
 4-5
 ) is relatively unsophisticated because most of the elements are abstracted into 
 layout.jade:
  
 extends layout
  
 block content
  
  p
  
   
  h1= title
  
   
  p= text 
  
 97",NA
login.jade,"Similarly, the login page contains only a form and a button (with the Twitter Bootstrap classes/markup):
  
 extends layout
  
 block page
  
  - var menu = 'login'
  
 block content
  
  .col-md-4.col-md-offset-4
  
   
  h2 Log in
  
   
  div= error
  
   
  div
  
    
  form(action=""/login"", method=""POST"")
  
     
  p
  
      
  input.form-control(name=""email"", type=""text"", placeholder=""hi@azat.co"")
  
 98",NA
post.jade,"The post page (Figure 
 4-7
 ) has another form. This time, the form contains a text area element:
  
 extends layout 
  
 block page
  
  - var menu = 'post' 
  
 block content
  
 99",NA
admin.jade,"The admin page (Figure 
 4-8
 ) has a loop of articles just like the home page. In addition, we can include a front-end 
 script (js/admin.js) specific to this page:
  
 extends layout
  
 block page
  
  - var menu = 'admin'
  
 block content
  
  div.admin
  
   
  if (articles.length === 0 )
  
    
  p
  
     
  | Nothing to display. Add a new
  
     
  a(href=""/post"") article
  
     
  |.
  
  else
  
  
  table.table.table-stripped
  
  
  
  thead
  
  
   
  tr
  
  
    
  th(colspan=""2"") Actions
  
  
    
  th Post Title
  
  
  
  tbody
  
  
   
  each article, index in articles
  
  
    
  tr(data-id=""#{article._id}"", class=(!article.published)?'unpublished':'')
  
  
     
  td.action
  
  
      
  button.btn.btn-danger.btn-sm.remove(type=""button"")
  
  
       
  span.glyphicon.glyphicon-remove(title=""Remove"")
  
  
     
  td.action
  
  
      
  button.btn.btn-default.btn-sm.publish(type=""button"")
  
  
       
  span.glyphicon(class=(article.published)?""glyphicon-pause"":""glyphicon-play"", 
 title=(article.published)?""Unpublish"":""Publish"")
  
  
     
  td= article.title
  
  
  script(type=""text/javascript"", src=""js/admin.js"")
  
 101",NA
Summary,"You learned about Jade and Handlebars templates (variables, iterations, condition, partials, unescaping, and so forth), 
 and how to use them in a standalone Node.js script or within Express.js. In addition, the main pages for Blog were 
 created using Jade.
  
 In the next chapter we examine an important aspect of modern web development and software engineering: test-
 driven development. We look at the Mocha module and write some tests for Blog in true TDD/BDD style. In addition, 
 the next chapter deals with adding a database to Blog routes to populate these templates, and shows you how to turn 
 them into working HTML pages!
  
 102",NA
Chapter 5,NA,NA
Persistence with ,NA,NA
MongoDB and ,NA,NA
Mongoskin,"NoSQL databases, also called 
 non-relational databases
 , are more horizontally scalable, usually open source, and 
 better suited for distributed systems. NoSQL databases deal routinely with larger data sizes than traditional ones. 
  
 The key distinction in implementation comes from the fact that relationships between database entities are not 
 stored in the database itself (no more join queries); they are moved to the application or object-relational mapping 
 (ORM) levels—in our case, to Node.js code. Another good reason to use NoSQL databases is that, because they are 
 schemaless, they are perfect for prototyping and Agile iterations (more pushes!).
  
  
 MongoDB is a document store NoSQL database (as opposed to key value and wide-column store NoSQL 
 databases, 
 http://nosql-database.org/
 ). It’s the most mature and dependable NoSQL database available thus far. 
  
 In addition to efficiency, scalability, and lightning speed, MongoDB uses JavaScript–like language for its interface! This 
 alone is magical, because now there’s no need to switch context between the front end (browser JavaScript), back end 
 (Node.js), and database (MongoDB).
  
  
 The company behind MongoDB (formerly 10gen, 
 http://en.wikipedia.org/wiki/10gen
 ) is an industry leader and 
 provides education and certification through its online MongoDB University (
 https://university.mongodb.com/
 ).
  
 To get you started with MongoDB and Node.js, we examine the following in this chapter:
  
 
  
 Easy and proper installation of MongoDB
  
 
  
 How to run the Mongo server
  
 
  
 Data manipulation from the Mongo console
  
 
  
 MongoDB shell in detail
  
 
  
 Minimalistic native MongoDB driver for Node.js example
  
 
  
 Main Mongoskin methods
  
 
  
 Project: storing Blog data in MongoDB with Mongoskin",NA
Easy and Proper Installation of MongoDB,"The following steps are better suited for Mac OS X/Linux–based systems, but with some modifications, they can be 
 used for Windows systems as well (i.e., $PATH variable, or the slashes). Next, we look at MongoDB installation from 
 the official package, as well as using HomeBrew for Mac OS X users (recommended) . For non-Mac users, there are 
 many other ways to install (
 http://docs.mongodb.org/manual/installation/
 ).",NA
How to Run the Mongo Server ,"To run the Mongo server, go to the folder where you unpacked MongoDB. That location should have a bin folder in it. 
  
 From that folder, type the following command: 
  
 $ ./bin/mongod 
  
  
 Or, if you added $PATH for the MongoDB location, type the 
 following: $ mongod 
  
 ■
 Note
  Don’t forget to restart the terminal window after adding a new path to the 
 $PATH
  variable 
 (Figure 
 5-2
 ).
  
  
 Figure 5-2.
  Starting up the MongoDB server
  
  
 If you see something like 
  
 MongoDB starting: pid =7218 port=27017...
  
 this means the MongoDB database server is running. By default, it’s listening to http://localhost:27017. This is the 
 host and port for the scripts and applications to access MongoDB. However, there’s a web GUI for humans. If you go to 
 your browser and type http://localhost:28017, you should be able to see the version number, logs, and other useful 
  
 105",NA
Data Manipulation from the Mongo Console,"Akin to the Node.js REPL, MongoDB has a console/shell that acts as a client to the database server instance. This 
 means that we have to keep the terminal window with the server open and running while using the console in a 
 different window/tab.
  
 From the folder where you unpacked the archive, launch the mongod service with
  
 $ ./bin/mongod
  
 Or, if you installed MongoDB globally (recommended), launch the mongod service with
  
 $ mongod
  
 You should be able to see information in your terminal and in the browser at localhost:28017.
  
  
 For the MongoDB shell, or mongo, launch in a new terminal window (
 important!
 ) and, in the same folder, type 
 the following commands:
  
 $ ./bin/mongo
  
 Open another terminal window in the same folder and execute
  
 $ ./bin/mongo
  
 Or, if you installed mongo globally (recommended), type
  
 $ mongo
  
 You should see something like this, depending on your version of the MongoDB shell:
  
 MongoDB shell version: 2.0.6 
  
 connecting to: test
  
 Then, type and execute
  
 > db.test.save( { a: 1 } ) 
  
 > db.test.find()
  
 Figure 
 5-3
  shows this. If you see that your record is being saved, then everything went well.
  
 106",NA
MongoDB Shell in Detail,"The most useful MongoDB shell commands are listed here:
  
 
  
 > help: prints a list of available commands
  
 
  
 > show dbs: prints the names of the databases on the database server to which the console is 
  
 connected (by default, localhost:27017; but, if we pass params to mongo, we can connect to any 
  
 remote instance)
  
 
  
 > use db_name: switches to db_name
  
 
  
 > show collections: prints a list of collections in the selected database
  
 
  
 > db.collection_name.find(query);: finds all items matching query
  
 
  
 > db.collection_name.findOne(query);: finds one item that matches query
  
 
  
 > db.collection_name.insert(document): adds a document to the collection_name
  
 collection
  
 
  
 > db.collection_name.save(document);: saves a document in the collection_name
  
 collection—a shorthand of upsert (no _id) or insert (with _id)
  
 
  
 > db.collection_name.update(query,{$set: data});: updates items that match query in 
  
 the collection_name collection with data object values",NA
Minimalistic Native MongoDB Driver for Node.js ,NA,NA
Example,"To illustrate the advantages of Mongoskin, let’s use Node.js native driver for MongoDB (
 https://github.com/ 
 christkv/node-mongodb-native
 ) first. We need to write a basic script that accesses the database.
  
 First, however, let’s install the MongoDB native driver for Node.js with:
  
 $ npm install mongodb@1.3.23
  
 Don’t forget to include the dependency in the package.json file as well:
  
 {
  
  ""name"": ""node-example"",
  
  ""version"": ""0.0.1"",
  
  ""dependencies"": {
  
  ""mongodb"":""1.3.23"",
  
  ...
  
  },
  
  ""engines"": {
  
   
  ""node"": "">=0.6.x""
  
  } 
  
 }
  
  
 This small example tests whether we can connect to a local MongoDB instance from a Node.js script and run a 
 sequence of statements analogous to the previous section:
  
 1. 
  
 Declare dependencies
  
 2. 
  
 Define the database host and port
  
 3. 
  
 Establish a database connection
  
 4. 
  
 Create a database document
  
 5. 
  
 Output a newly created document/object",NA
Main Mongoskin Methods,"Mongoskin provides a better API than the native MongoDB driver. To illustrate this, compare this code with the 
 example written using native MongoDB driver for Node.js. As always, to install a module, run NPM with install—for 
 example, $ npm install mongoskin@0.6.1.
  
 The connection to the database is a bit easier:
  
 var mongoskin = require('mongoskin'),
  
  dbHost = '127.0.0.1',
  
  dbPort = 27017;
  
 var db = mongoskin.db(dbHost + ':' + dbPort + '/local', {safe:true});
  
 111",NA
Project: Storing Blog Data in MongoDB with Mongoskin,"Let’s now return to our Blog project. I’ve split this feature of storing Blog data in MongoDB with Mongoskin into the 
 following three subprojects:
  
 1. 
  
 Adding MongoDB seed data
  
 2. 
  
 Writing Mocha tests
  
 3. 
  
 Adding persistence",NA
Project: Adding MongoDB Seed Data,"First of all, it’s not much fun to enter data manually each time we test or run an app. So, in accordance with the Agile 
 principles, we can automate this step by creating a Bash seed data script db/seed.sh:
  
 mongoimport --db blog --collection users --file ./db/users.json –jsonArray mongoimport --db 
 blog --collection articles --file ./db/articles.json --jsonArray
  
  
 This script uses MongoDB’s mongoimport feature, which inserts data conveniently into the database straight 
 from JSON files.
  
 The users.json file contains information about authorized users:
  
 [{
  
  ""email"": ""hi@azat.co"",
  
  ""admin"": true,
  
  ""password"": ""1"" 
  
 }]
  
 The articles.json file has the content of the blog posts:
  
 [{
  
  ""title"": ""Node is a movement"",
  
  ""slug"": ""node-movement"",
  
  ""published"": true,
  
  ""text"": ""In one random deployment, it is often assumed that the number of scattered sensors are more than that 
 required by the critical sensor density. Otherwise, complete area coverage may not be guaranteed in this 
 deployment, and some coverage holes may exist. Besides using more sensors to improve coverage, mobile sensor 
 nodes can be used to improve network coverage..."" 
  
 }, {
  
  ""title"": ""Express.js Experience"",
  
  ""slug"": ""express-experience"",
  
  ""text"": ""Work in progress"",
  
  ""published"": false 
  
 },{
  
  ""title"": ""Node.js FUNdamentals: A Concise Overview of The Main Concepts"",
  
 113",NA
Project: Writing Mocha Tests,"We can import test data from seed files via require because it’s a JSON format:
  
 var seedArticles = require('../db/articles.json');
  
 Let’s add this test to the home page suite to check whether our app shows posts from seed data on the front page:
  
 it('should contain posts', function(done) {
  
  superagent
  
   
  .get('http://localhost:'+port)
  
   
  .end(function(res){
  
    
  seedArticles.forEach(function(item, index, list){
  
     
  if (item.published) {
  
      
  expect(res.text).to.contain('<h2><a href=""/articles/' + item.slug + '"">' +  item.title);
  
     
  } else {
  
      
  expect(res.text).not.to.contain('<h2><a href=""/articles/' + item.slug + '"">' +  item.title);
  
     
  }
  
     
  // console.log(item.title, res.text)
  
    
  })
  
    
  done()
  
  }) 
  
 });
  
 In a new-article page suite, let’s test for presentation of the text with contains:
  
 describe('article page', function(){
  
  it('should display text', function(done){
  
   
  var n = seedArticles.length;
  
   
  seedArticles.forEach(function(item, index, list){
  
    
  superagent
  
     
  .get('http://localhost:'+port + '/articles/' + seedArticles[index].slug)
  
  
   
  .end(function(res){
  
      
  if (item.published) {
  
       
  expect(res.text).to.contain(seedArticles[index].text);
  
      
  } else {
  
       
  expect(res.status).to.be(401);
  
      
  }
  
 114",NA
Project: Adding Persistence,"This example builds on the previous chapter, with the chapter 3 having the latest code (chapter 4 code is in ch5). 
 Let’s go back to our ch3 folder, and add the tests, duplicate them, and then start adding statements to the app.js file. 
  
  
 The full source code of this example is available under ch5 folder. First, the dependencies inclusions need to be 
 reformatted to utilize Mongoskin:
  
 var express = require('express'),
  
  routes = require('./routes'),
  
  http = require('http'),
  
  path = require('path'),
  
  mongoskin = require('mongoskin'),
  
  dbUrl = process.env.MONGOHQ_URL || 'mongodb://@localhost:27017/blog', db = 
 mongoskin.db(dbUrl, {safe: true}),
  
  collections = {
  
   
  articles: db.collection('articles'),
  
   
  users: db.collection('users')
  
  };
  
 These statements are needed for the Express.js 4 middleware modules:
  
 var session = require('express-session'),
  
  logger = require('morgan'),
  
  errorHandler = require('errorhandler'),
  
  cookieParser = require('cookie-parser'),
  
  bodyParser = require('body-parser'),
  
  methodOverride = require('method-override');
  
 Then, our usual statements follow, i.e., creating of Express.js instance and assigning the title:
  
 var app = express(); 
  
 app.locals.appTitle = 'blog-express';
  
 115",NA
Running the App,"To run the app, simply execute $ node app, but if you want to seed and test it, execute $ make db and $ make test, 
 respectively (Figure 
 5-5
 ). Don't forget that $ mongod service must be running on the localhost and port 27017. The 
 expected result is that all tests now pass (hurray!), and if users visit http://localhost:3000, they can see posts and 
 even create new ones on the admin page (http://localhost:3000/admin) as shown in Figure 
 5-6
 .
  
  
 Figure 5-5.
  The results of running Mocha tests
  
 126",NA
Summary,"In this chapter we learned how to install MongoDB, and use its console and native Node.js driver, for which we wrote 
 a small script and refactored it to see Mongoskin in action. Last, we wrote tests, seeded scripts, and implemented the 
 persistence layer for Blog. In the next chapter, we'll implement authorization and authentication.
  
 127",NA
Chapter 6,NA,NA
Using Sessions and OAuth ,NA,NA
to Authorize and Authenticate ,NA,NA
Users in Node.js Apps,"Security is an important aspect of any real-world web application. This is especially true nowadays, because our apps 
 don’t function in silos anymore. We, as developers, can and should leverage numerous third-party services (e.g., 
 Twitter, GitHub) or become service providers ourselves (e.g., provide a public API).
  
 We can makes our apps and communications secure with the usage of various approaches, such as token-
 based authentication and/or OAuth (
 http://oauth.net
 ). Therefore, in this practical guide, I dedicate the whole 
 chapter to matters of authorization, authentication, OAuth, and best practices. We’ll look at the following topics:
  
 
  
 Authorization with Express.js middleware
  
 
  
 Token-based authentication
  
 
  
 Session-based authentication
  
 
  
 Project: adding e-mail and password login to Blog
  
 
  
 Node.js OAuth
  
 
  
 Project: Adding Twitter OAuth 1.0 sign-in to Blog with Everyauth ( 
 https://github.com/ 
  
 bnoguchi/everyauth
 )",NA
Authorization with Express.js Middleware,"Authorization in web apps usually means restricting certain functions to privileged clients. These functions can either 
 be methods, pages, or REST API end points.
  
  
 Express.js middleware allows us to apply certain rules seamlessly to all routes, groups of routes 
 (namespacing), or individual routes.
  
 
  
 All routes
 : app.get('*', auth)
  
 
  
 Groups of routes
 : app.get('/api/*', auth)
  
 
  
 Individual routes
 : app.get('/admin/users', auth)
  
 129",NA
Token-Based Authentication,"For applications to know which privileges a specific client has (e.g., admin), we must add an authentication step. 
 In the previous example, this step goes inside the auth() function.
  
 The most common authentication is a cookie & session–based authentication, and the next section deals with this 
 topic. However, in some cases, more REST-fulness is required, or cookies/sessions are not supported well (e.g., 
 mobile). In this case, it’s beneficial to authenticate each request with a token (probably using the OAuth2.0 
 (
 http://tools.ietf.org/html/rfc6749
 ) scheme). The token can be passed in a query string or in HTTP request headers. 
 Alternatively, we can send some other authentication combination of information, such as e-mail/username and 
 password, or API key, or API password instead of a token.
  
 So, in our example of token-based authentication, each request can submit a token in a query string (accessed via 
 req.query.token). And, if we have the correct value stored somewhere in our app (database, or in this example just a 
 constant SECRET_TOKEN), we can check the incoming token against it. If the token matches our records, we call 
 next() to proceed with the request executions, if not then we call next(error) which triggers Express.js error handlers 
 execution (see the note below):
  
 var auth = function(req, res, next) {
  
  if (req.query.token && token === SECRET_TOKEN) {
  
  // Client is fine, proceed to the next route
  
   
  return next();
  
  } else {
  
   
  return  next(new Error('Not authorized'));
  
    
  // or res.send(401);
  
  } 
  
 };
  
 130",NA
Session-Based Authentication,"Session-based authentication is done via the session object in the request object req. A web session in general is a 
 secure way to store information about a client so that subsequent requests from that same client can be identified. 
  
 In the Express.js 4.x (versions 4.1.2 and 4.2.0 as of this writing), we’ll need to import (require()) these modules 
 manually, because Express.js 4.x separated these and some other middleware out of its package. For example, to 
 include and use cookie-parser and express-session:
  
 var cookieParser = require('cookie-parser'); 
  
 var session = require('express-session'); 
  
 ...
  
 app.use(cookieParser()); 
  
 app.use(session());
  
  
 Needless to say, cookie-parser and express-session must be installed via NPM into the project’s 
 node_modules folder.
  
 To use the session in a typical Express.js 3.x app, two pieces of middleware need to be added to the configuration:
  
 1. 
  
 express.cookieParser(): allows for parsing of the client/request cookies.
  
 2. 
  
 express.session(): exposes the res.session object in each request handler, and stores 
  
 data in the app memory or some other persistent store like MongoDB or Redis.
  
 In later examples don’t mention Express.js version, assume that it works for both 3.x and 4.x.
  
 The rest is trivial; we can store any data in req.session and it appears automagically on each request from the 
 same client (assuming their browser supports cookies). Hence, the authentication consists of a route that stores some 
 flag (true/false) in the session and of an authorization function in which we check for that flag (if true, then proceed; 
 otherwise, exit). For example,
  
 app.post('/login', function(req, res, next) {
  
  // This function checks for credentials
  
  // passed in the request's payload
  
  if (checkForCredentials(req)) {
  
   
  req.session.auth = true;
  
   
  res.redirect('/dashboard');  // Private resource } else {
  
 131",NA
Project: Adding E-mail and Password Login to Blog,"To enable session-based authentication in Blog, we need to do the following:
  
 1. 
  
 Import and add the session middleware to the configuration part of app.js.
  
 2. 
  
 Implement the authorization middleware authorize with a session-based authorization 
  
 so we can re-use the same code for many routes.
  
 3. 
  
 Add the middleware from #2 (step above) to protected pages and routes in app.js routes, 
  
 e.g., app.get('/api/, authorize, api.index).
  
 4. 
  
 Implement an authentication route POST /login, and a logout route, GET /logout in 
  
 user.js.",NA
Session Middleware,"Let’s add the automatic cookie parsing and support for session middleware in these two lines by putting them in the 
 middle of configurations in app.js:
  
 // Other middleware 
  
 app.use(cookieParser('3CCC4ACD-6ED1-4844-9217-82131BDCB239')); 
 app.use(session({secret: '2C44774A-D649-4D44-9535-46E296EF984F'})); // 
 Routes
  
 For Express.js 3.x:
  
 // Other middleware 
  
 app.use(express.cookieParser('3CCC4ACD-6ED1-4844-9217-82131BDCB239')); 
 app.use(express.session({secret: '2C44774A-D649-4D44-9535-46E296EF984F'})); // 
 Routes
  
 ■
 Warning
  You should replace randomly generated values with your own ones.",NA
Authorization in Blog,"Authorization is also done via middleware, but we won’t set it up right away with app.use like we did in the snippet 
 for res.locals. Instead, we define a function that checks for req.session.admin to be true, and proceeds if it is. 
 Otherwise, the 401 Not Authorized error is thrown and the response is ended.
  
 // Authorization 
  
 var authorize = function(req, res, next) {
  
  if (req.session && req.session.admin)
  
   
  return next();
  
  else
  
   
  return res.send(401); 
  
 };
  
 Now we can add this middleware to certain protected end points:
  
 ...
  
 app.get('/admin', authorize, routes.article.admin); 
  
 app.get('/post', authorize, routes.article.post); 
  
 app.post('/post', authorize, routes.article.postArticle);
  
 We add the authorize middleware to API routes as well:
  
 app.all('/api', authorize); 
  
 app.get('/api/articles', routes.article.list) 
  
 app.post('/api/articles', routes.article.add); 
  
 app.put('/api/articles/:id', routes.article.edit); 
  
 app.del('/api/articles/:id', routes.article.del);
  
 The app.all('/api', authorize); is a more compact alternative to adding authorize to all /api/... routes.
  
 133",NA
Authentication in Blog,"The last step in session-based authorization is to allow users and clients to turn the req.session.admin switch on and 
 off. We do this by having a login form and processing the POST request from that form.
  
 For authenticating users as admins we set the appropriate flag (admin=true), in the routes.user.authenticate in 
 the user.js file. This is done in the POST /login route which we defined in the app.js— a line that has this statement: 
 app.post('/login', routes.user.authenticate);.
  
 In user.js, expose the method to the importer, i.e., the file that imports this user.js module:
  
 exports.authenticate = function(req, res, next) {
  
 The form on the login page submits data to this route. In general, a sanity check for the input values is always a 
 good idea. If values are falsy (including empty values), we’ll render the login page again with the message error. The 
 return keyword ensures the rest of the code in this method isn’t executed. If the values are non-empty (or otherwise 
 truthy), then the request handler will not terminate yet and proceed to the next statements:
  
 if (!req.body.email || !req.body.password)
  
  
  return res.render('login',{
  
    
  error: 'Please enter your email and password.'
  
  
  });
  
 Thanks to the database middleware in app.js, we can access database collections in req.collections. In our 
 app’s architecture, e-mail is a unique identifier (there are no two accounts with the same e-mail), so we use the 
 findOne function to find a match of the e-mail and password combination (logical AND):
  
 req.collections.users.findOne({
  
  email: req.body.email,
  
  password: req.body.password 
  
 }, function(error, user){
  
  ... 
  
 ■
 Warning
  in virtually all cases, we don’t want to store passwords as a plain text; we should store 
 salts and password 
  
 hashes instead. in this way, if the database gets compromised, passwords are not seen. For salting, 
 use the core node.js 
  
 module crypto.
  
 findOne returns an error object and the user result object. However, we should still do error processing 
 manually:
  
  if (error) return next(error);
  
  if (!user) return res.render('login', {error: 'Incorrect email&password combination.'});",NA
Running the App,"Now everything should be set up properly to run Blog. Contrary to the example in Chapter 5, we see protected pages 
 only when we’re logged in. These protected pages enable us to create new posts, and to publish and unpublish them. 
 But as soon as we click “Logout” in the menu, we no longer can access the administrator page. 
  
 137",NA
Node.js OAuth,"OAuth—which can be located on NPM (
 https://www.npmjs.org/package/oauth
 ) and GitHub (
 https://github.com/ 
 ciaranj/node-oauth
 )—is the powerhouse of OAuth 1.0/2.0 schemes for Node.js. It’s a module that generates 
 signatures, encryptions, and HTTP headers, and makes requests. We still need to initiate the OAuth dances 
  
 (i.e., requests back and forth between consumer, provider and our system), write the callback routes, and store 
 information in sessions or databases. Refer to the service provider’s (e.g., Facebook, Twitter, Google) documentation 
 for end points, methods, and parameter names.
  
 It is recommended that node-auth be used when complex integration is needed or when only certain pieces of 
 OAuth are needed (e.g., header signatures are generated by node-auth, but the request is made by the superagent 
 library).
  
 To add OAuth version 0.9.11 (the latest as of this writing) to your project, simply run:
  
 $ npm install oauth@0.9.11",NA
Twitter OAuth 2.0 Example with Node.js OAuth,"OAuth 2.0 is less complicated and, some might argue, less secure than OAuth 1.0. The reasons for this are numerous 
 and better understood when written by Eran Hammer, the person who participated in OAuth2.0 creation: OAuth 
 2.0 and the Road to Hell.
  
 In essence, OAuth 2.0 is similar to the token-based authorization we examined earlier, for which we have a single 
 token, called a 
 bearer
 , that we pass along with each request. To get that token, all we need to do is exchange our app’s 
 token and secret for the bearer.
  
 Usually, this bearer can be stored for a longer time than OAuth 1.x tokens (depends on the rules set by a 
 specific service-provider), and can be used as a single key/password to open protected resources. This bearer acts 
 as our token in the token-based auth.
  
 Here’s an ordinary example from Node.js OAuth docs (
 https://github.com/ciaranj/node-oauth#oauth20
 ). 
  
 First, we create an oauth2 object that has a Twitter consumer key and secret (replace the values with yours):
  
 var OAuth = require('OAuth'); 
  
 var OAuth2 = OAuth.OAuth2; 
  
 var twitterConsumerKey = 'your key'; 
  
 var twitterConsumerSecret = 'your secret'; 
  
 var oauth2 = new OAuth2(server.config.keys.twitter.consumerKey, 
 twitterConsumerSecret,
  
  '
 https://api.twitter.com/
 ',
  
  null,
  
  'oauth2/token',
  
  null 
  
 );
  
 Then, we request access to the token/bearer from the service provider:
  
 oauth2.getOAuthAccessToken(
  
  '',
  
  {'grant_type': 'client_credentials'},
  
  function (e, access_token, refresh_token, results){
  
 138",NA
Everyauth ,"The Everyauth module allows for multiple OAuth strategies to be implemented and added to any Express.js app in just 
 a few lines of code. Everyauth comes with strategies for most of the service providers, so there’s no need to search 
 and implement service provider-specific end points, parameters names, and so forth. Also, Everyauth stores user 
 objects in a session, and database storage can be enabled in a findOrCreate callback using a promise pattern.
  
 ■
 Tip
  everyauth has an e-mail and password strategy that can be used instead of the custom-built 
 auth. More information about it can be found in everyauth documentation at the github repository 
 (
 https://github.com/bnoguchi/ everyauth#password-authentication
 )
 .
  
  
 Everyauth submodules that enable service provider-specific authorization strategies (as of this writing, take 
 from its GitHub repo (
 https://github.com/bnoguchi/everyauth/blob/master/README.md
 )) are as follows:
  
  
 
  
 Password
  
  
 
  
 Facebook
  
  
 
  
 Twitter
  
  
 
  
 Google
  
  
 
  
 Google Hybrid
  
  
 
  
 LinkedIn
  
  
 
  
 Dropbox
  
  
 
  
 Tumblr
  
  
 
  
 Evernote
  
  
 
  
 GitHub
  
  
 
  
 Instagram
  
  
 
  
 Foursquare
  
  
 
  
 Yahoo!
  
 139",NA
Project: Adding Twitter OAuth 1.0 Sign-in to Blog with ,NA,NA
Everyauth,"A typical OAuth 1.0 flow consists of these three steps (simplified):
  
 1. 
  
 Users go to a page/route to initiate the OAuth dance. There, our app requests a token via 
  
 GET/POST requests using the signed app’s consumer key and secret. For example, /auth/
  
 twitter is added automatically by Everyauth.
  
 2. 
  
 The app uses the token extracted in step 1 and redirects users to the service-provider 
  
 (Twitter) and waits for the callback.
  
 3. 
  
 The service provider redirects users back to the app which catches the redirect in the 
  
 callback route (e.g., /auth/twitter/callback). Then, the app extracts the access token, 
  
 the access token secret, and the user information from the Twitter incoming request body 
  
 / payload.",NA
Adding a Sign-in with a Twitter Link,"By default, Everyauth uses the /auth/:service_provider_name pattern to initiate the three-legged OAuth 1.0 strategy. 
 This, of course, can be customized, but to keep it short and simple (KISS), we can just add this link to menu.jade:
  
 li(class=(menu === 'login') ? 'active' : '')
  
  a(href='/auth/twitter') Sign in with Twitter
  
 The whole menu.jade looks like this:
  
 .menu
  
  ul.nav.nav-pills
  
   
  li(class=(menu === 'index') ? 'active' : '')
   
  
  a(href='/') Home
  
   
  if (admin)
  
    
  li(class=(menu === 'post') ? 'active' : '')
   
   
  a(href=""/post"") Post
  
    
  li(class=(menu === 'admin') ? 'active' : '')
  
    
  a(href=""/admin"") Admin
  
    
  li
  
     
  a(href=""/logout"") Log out
  
   
  else
  
    
  li(class=(menu === 'login')? 'active' : '')
   
   
  a(href='/login') Log in
  
    
  li
  
     
  a(href='/auth/twitter') Sign in with Twitter",NA
Configuring the Everyauth Twitter Strategy,"To add the Everyauth module (everyauth) to Blog, type the following in the terminal:
  
 $ npm install everyauth@0.4.5 --save
  
 The configuration of the Everyauth Twitter strategy is implemented in app.js, but in larger apps it’s a good idea 
 to abstract these types of strategies into separate files. The most important thing to remember is that Everyauth 
 middleware needs to precede the app.route call.
  
 To procure the Twitter app consumer key and secret, we harness environmental variables via process.env:
  
 var TWITTER_CONSUMER_KEY = process.env.TWITTER_CONSUMER_KEY 
 var TWITTER_CONSUMER_SECRET = 
 process.env.TWITTER_CONSUMER_SECRET
  
 141",NA
Summary,"In this chapter, we learned how to implement a standard e-mail and password authentication, and used Express.
  
 js middleware to protect sensitive pages and end points in Blog. Then, we covered OAuth 1.0 and OAuth 2.0 with 
 Everyauth and OAuth modules, respectively.
  
 Now we have a few security options for Blog. In the next chapter we’ll explore Mongoose 
 (
 http://mongoosejs.com
 ) object-relational mapping (ORM (
 http://en.wikipedia.org/wiki/Object-
 relational_mapping
 )) Node.js library for MongoDB. This library is a good choice for complex systems with a lot of 
 interdependent business logic between entities, because it completely abstracts the database and provides developers 
 with tools to operate with data only via Mongoose objects. The chapter will touch on the main Mongoose classes and 
 methods, explain some of the more advanced concepts, and re-factor persistence in Blog.
  
 147",NA
Chapter 7,NA,NA
Boosting Your Node.js ,NA,NA
Data with the Mongoose ,NA,NA
ORM Library,"Mongoose is a fully developed object relational mapping (ORM) library for Node.js and MongoDB. The advantages of 
 using ORM are many and go far beyond code organization or the ease of development. Typical ORM is a crucial piece 
 of modern software engineering.
  
 Mongoose abstracts everything from the database, and the application code interacts only with objects and their 
 methods. ORM also allows specifying relationships between different types of objects and putting business logic 
 (related to those objects) in the classes.
  
  
 In addition, Mongoose has built-in validation and type casting that can be extended and customized according to 
 needs. When used together with Express.js, Mongoose makes the stack truly adherent to the MVC concept.
  
 Mongoose uses a similar interface to those of Mongo shell, native MongoDB driver, and Mongoskin. For this 
 reason, main functions such as find, update, insert, save, remove, and so on, look and act the same, which helps us to 
 get started with Mongoose faster. In this chapter we look at the following:
  
 
  
 Mongoose installation
  
 
  
 Connection establishment in a standalone Mongoose script
  
 
  
 Mongoose schemas
  
 
  
 Hooks for keeping code organized
  
 
  
 Custom static and instance methods
  
 
  
 Mongoose models
  
 
  
 Relationships and joins with population
  
 
  
 Nested documents
  
 
  
 Virtual fields
  
 
  
 Schema type behavior amendment
  
 
  
 Express.js + Mongoose = true MVC
  
  
 The source code for this chapter is in the ch7/blog-express directory of the practical node GitHub repository 
 (
 https://github.com/azat-co/practicalnode
 ).",NA
Mongoose Installation,"First, we should install Mongoose with NPM. Among many variations, this is one of the ways we can install 
 Mongoose 3.8.4 into an empty folder:
  
 $ mkdir node_modules 
  
 $ npm install mongoose@3.8.4",NA
Connection Establishment in a Standalone Mongoose ,NA,NA
Script,"Mongoose can be used as a standalone MongoDB library. To illustrate this, here’s a banal script that establishes a 
 connection, creates a Mongoose model definition, instantiates the practicalNodeBook object, and then saves it to the 
 database.
  
 To have access to the library, we need to include the mongoose module in our program:
  
 var mongoose = require('mongoose');
  
 Unlike the Node.js native MongoDB driver, which requires us to write a few lines of code, Mongoose can connect 
 to the database server in one line. Mongoose requests are buffered, so we don’t have to wait for the established 
 connection (vs. native driver, which usually requires a callback). To do this, just call mongoose.connect(uri(s), 
 [options], [callback]). The uniform resource identifier (URI) or connection string is the only required parameter, and 
 it follows a standard format of type://username:password@host:port/database_name. In our simple example, the 
 host is localhost, the port is 27017 (default), and the database name is test:
  
 mongoose.connect('mongodb://localhost/test');
  
 For situations that are more advanced, options and callbacks can be passed to connect. The options object 
 supports all properties of the native MongoDB driver (
 http://mongodb.github.io/node-mongodb-native/driver-
 articles/mongoclient.html#mongoclient-connect-options
 ).
  
 ■
 Note
  it’s a common practice in node.js apps (and Mongoose) to open a database connection once, 
 when the 
  
 program starts, and then to keep it open until termination. this applies to web apps and servers as 
 well.
  
 This is easy so far, right? The next step is an important distinction that Mongoose introduces compared with 
 Mongoskin and other lightweight MongoDB libraries. The step creates a model with the model() function by passing a 
 string and a schema (more on schemas later). The model is usually stored in a capitalized literal:
  
 var Book = mongoose.model('Book', { name: String });
  
  
 Now the configuration phase is over and we can create a document that represents a particular instance of the 
 model Book:
  
 var practicalNodeBook = new Book({ name: 'Practical Node.js' });
  
 Mongoose documents come with very convenient built-in methods (
 http://mongoosejs.com/docs/api. 
 html#document-js
 ) such as validate, isNew, update, and so on. Just keep in mind that these methods apply to this 
 particular document, not the entire collection or model. The difference between documents and models is that a 
 document is an instance of a model; a model is something abstract. It’s like your real MongoDB collection, but it is",NA
Mongoose Schemas,"Schema is a JSON-ish class that has information about properties/field types of a document. It also can store 
 information about validation and default values, and whether a particular property is required. Schemas can contain 
 business logic and other important information. In other words, schemas serve as blueprints for documents. They are 
 needed for model creation (i.e., schemas are compiled into models). So, before we can use models properly, we need 
 to define their schemas, e.g., the book schema with the name property of string type:
  
 var bookSchema = mongoose.Schema({
  
  
  name: String 
  
 }) 
  
 ■
 Warning
  Mongoose ignores those properties that aren’t defined in the model’s schema.
  
 Mongoose Schema supports these data types:
  
 
  
 String: a standard JavaScript/Node.js string (a sequence of characters) type
  
 
  
 Number: a standard JavaScript/Node number type up to 253 (64-bit); larger numbers with 
  
 mongoose-long (
 https://www.npmjs.org/package/mongoose-long
 ) (Git (
 https://github.com/ 
  
 aheckmann/mongoose-long
 ))
  
 
  
 Boolean: a standard JavaScript/Node Boolean type—true or false
  
 
  
 Buffer: a Node.js binary type (images, PDFs, archives, and so on)
  
 
  
 Date: an ISODate formatted date type, such as 2014-12-31T12:56:26.009Z
  
 
  
 Array: a standard JavaScript/Node array type
  
 152",NA
Hooks for Keeping Code Organized,"In a complex application with a lot of interrelated objects, we might want to execute certain logic before saving an 
 object. Hooks are a good place to store such logic. For example, we might want to upload a PDF to the web site before 
 saving a book document:
  
 bookSchema.pre('save', function(next) {
  
  
  //prepare for saving
  
  
  //upload PDF
  
  
  return next(); 
  
 });
  
 On the other hand, before removing, we need to make sure there are no pending purchase orders for this book:
  
 bookSchema.pre('remove', function(next) {
  
  //prepare for removing
  
  return next(e); 
  
 });",NA
Custom Static and Instance Methods,"In addition to dozens of built-in Mongoose model methods, we can add custom ones. For example, to initiate a 
 purchase, we can call the buy method on the document practicalNodeBook after we implement the custom instance 
 method buy():
  
 bookSchema.method({
  
  buy: function(quantity, customer, callback) {
   
  
 var bookToPurchase = this;
  
   
  //create a purchase order and invoice customer
  
  
  return callback(results);
  
  },
  
  refund: function(customer, callback) {
  
   
  //process the refund
  
   
  return callback(results);
  
  } 
  
 });
  
 Static methods are useful when we either don’t have a particular document object or we don’t need it:
  
 bookSchema.static({
  
  getZeroInventoryReport: function(callback) {
  
   
  //run a query on all books and get the ones with zero inventory
  
  
  return callback(books);
  
  },
  
  getCountOfBooksById: function(bookId, callback){
  
   
  //run a query and get the number of books left for a given book
  
  
  return callback(count);
  
  } 
  
 })
  
 154",NA
Mongoose Models,"As in many other ORMs, in Mongoose, the cornerstone object is a model. To compile a schema into a model, use 
 mongoose.model(name, schema)—for example,
  
 var Book = mongoose.model('Book', bookSchema)
  
  
 The first parameter is just a string, which we can use later to pull the instance of this model. Usually, this string is 
 the same as the object literal for the model (e.g., Book).
  
 Models are used to create documents (actual data). To do so, call new ModelName(data)—for example,
  
 var practicalNodeBook = new Book({ name: 'Practical Node.js' }); 
  
 var javascriptTheGoodPartsBook = new Book({ name: ""JavaScript The Good Parts""});
  
 It’s better to assign the initial value through the constructor versus using the document.set() method, because 
 Mongoose has to process less function calls and our code remains more compact and better organized. Of course, this 
 is possible only if we know the values when we create the instances.
  
  
 Don’t confuse static with instance model methods. If we call a method on practicalNodeBook, it’s an instance 
 method; if we call it on the Book object, it’s a static class method.
  
  
 Models have static built-in methods that are very similar to Mongoskin and native MongoDB methods, such as 
 find(), create(), and update().
  
  
 A list of the static Mongoose model methods (invoked on a capitalized object, e.g., Book) along with their 
 meaning follows:
  
 
  
 Model.create(data, [callback (error, doc)]): creates a new Mongoose document and 
  
 saves it to the database
  
 
  
 Model.remove(query, [callback(error)]): removes documents from the collection that 
  
 match the query; when finished, calls callback with error
  
 
  
 Model.find(query, [fields], [options], [callback(error, docs)]): finds documents 
  
 that match 
 the query (as a JSON object); possible to select fields (
 http://mongoosejs.com/ 
  
 docs/api.html#query_Query-select
 ) and use options (
 http://mongodb.github.io/node-
  
 mongodb-native/api-generated/collection.html#find
 )
  
 
  
 Model.update(query, update, [options], [callback(error, affectedCount, raw)]): 
  
 updates 
 documents, similar to native update
  
 
  
 Model.populate(docs, options, [callback(error, doc)]): populates documents using 
  
 references to other collections; an alternative to another approach described in the next 
 section
  
 
  
 Model.findOne(query, [fields], [options], [callback(error, doc)]): finds the first 
  
 document that matches the query
  
 
  
 Model.findById(id, [fields], [options], [callback(error, doc)]): finds the first 
  
 element for which _id equals the id argument (cast based on the schema)
  
 
  
 Model.findOneAndUpdate([query], [update], [options], [callback(error, doc)]): 
  
 finds the 
 first document that matches the query (if present) and updates it, returning the 
  
 document; uses findAndModify (
 http://mongodb.github.io/node-mongodb-native/api-
  
 generated/collection.html#findandmodify
 )",NA
Relationships and Joins with Population,"Although, there are no relationships stored in a NoSQL database such as MongoDB, we can do so in the application 
 layer. Mongoose provides a feature called 
 population
 . It allows us to fill certain parts of the document from a different 
 collection. Let’s say we have posts and users collections. We can reference posts in the user schema:
  
 var mongoose = require('mongoose'),
  
  Schema = mongoose.Schema
  
 var userSchema = Schema({
  
  _id     : Number,
  
  name: String,
  
  posts: [{ type: Schema.Types.ObjectId, ref: 'Post' }] });
  
 var postSchema = Schema({
  
  _creator: { type: Number, ref: 'User' },
  
  title: String,
  
  text: String 
  
 });
  
 var Post  = mongoose.model('Post', postSchema); 
  
 var User = mongoose.model('User', userSchema); 
  
 User.findOne({ name: /azat/i })
  
  .populate('posts')
  
  .exec(function (err, user) {
  
   
  if (err) return handleError(err);
  
   
  console.log('The user has % post(s)', user.posts.length); }) 
  
 ■
 Note
  
 ObjectId
 , 
 Number
 , 
 String
 , and 
 Buffer
  are valid data types to use as references.
  
 In the previous query, we used a regular expression (RegExp), this feature is not exclusive to Mongoose. In fact, 
 the native driver and its other wrappers, along with the mongo console all support RegExps. The syntax is the same 
 as in normal JavaScript/Node.js RegExp patterns. Therefore, in a way, we perform a join query on our Post and User 
 models.
  
  
 It’s possible to return only a portion of populated results. For example, we can limit the number of posts to 
 the first 10 only:
  
 .populate({
  
  path: 'posts',
  
  options: { limit: 10, sort: 'title' } 
  
 })
  
 157",NA
Nested Documents,"The document storage model in NoSQL databases is well-suited to use nested documents. For example, instead of 
 having two collections—posts and users—we can have a single collection (users), with each item of that collection 
 having posts.
  
 The decision of whether to use separate collections or nested documents is more of an architectural question, 
 and its answer depends on usage. For example, if posts are used only in the context of users (their authors)—say, on 
 the users’ profile pages—then it’s best to use nested documents. However, if the blog features multiple users’ posts 
 that need to be queried independently of their user context, then separate collections fit better.
  
 158",NA
Virtual Fields,"Virtuals are fields that don’t exist in the database but act just like normal fields in a Mongoose document. To 
 oversimplify, virtual fields are mock or fake fields that pretend to act and be normal ones.
  
 Virtual fields are awesome for creating aggregate fields. For example, if our system requires to have first name, 
 last name and the full name (which is just a concatenation of the first two names)—there’s no need to store the full 
 name values in addition to the first and last name values! All we need to do is concatenate the first and last name in 
 a full name virtual.
  
 Another use case is to make the database backward compatible. For example, we might have thousands of user 
 items in a MongoDB collection and we want to start collecting their locations. We have two options: run a migration 
 script to add the default location (“none”) to the thousands of old user documents or use a virtual field and apply 
 defaults at runtime!
  
 159",NA
Schema Type Behavior Amendment,"Mongoose allows us to define/write getters (get), setters (set), and defaults (default) right in the Schema! Same goes 
 for validate and some other useful methods.
  
 160",NA
Express.js + Mongoose = True MVC,"To avoid rebuilding all other components unrelated to ORM, such as templates, routes, and so forth, we can factor 
 the existing Blog from the previous chapter by making it use Mongoose instead of Mongoskin. This requires minimal 
 effort but produces an abstraction layer between MongoDB and the request handlers. As  always, the fully 
 functional code is available on GitHub, in the ch7 folder (
 https://github.com/azat-
 co/practicalnode/tree/master/ch7
 ). 
  
 The process of refactoring starts with the creation of a new branch: mongoose. You can use the final solution 
 in the GitHub repository (
 https://github.com/azat-co/blog-express/tree/mongoose
 ). First, we need to remove 
 Mongoskin and install Mongoose:
  
 $ npm uninstall mongoskin –save 
  
 $ npm install mongoose@3.8.4 --save
  
 package.json is amended to something like this:
  
 {
  
  ""name"": ""blog-express"",
  
  ""version"": ""0.0.1"",
  
  ""private"": true,
  
  ""scripts"": {
  
   
  ""start"": ""node app.js"",
  
   
  ""test"": ""mocha test""
  
  },
  
  ""dependencies"": {
  
   
  ""express"": ""4.1.2"",
  
   
  ""jade"": ""1.3.1"",
  
   
  ""stylus"": ""0.44.0"",
  
   
  ""everyauth"": ""0.4.5"",
  
   
  ""mongoose"": ""3.8.4"",
  
   
  ""cookie-parser"": ""1.0.1"",
  
   
  ""body-parser"": ""1.0.2"",
  
   
  ""method-override"": ""1.0.0"",
  
   
  ""serve-favicon"": ""2.0.0"",
  
   
  ""express-session"": ""1.0.4"",
  
   
  ""morgan"": ""1.0.1"",
  
   
  ""errorhandler"": ""1.0.1""
  
  },
  
  ""devDependencies"": {
  
   
  ""mocha"": ""1.16.2"",
  
 162",NA
Summary,"In this chapter, we learned what Mongoose is, how to install it, how to establish a connection to the database, and how 
 to create Mongoose schemas while keeping the code organized with hooks and methods. We also compiled schemas 
 into models and populated references automatically, and used virtual fields and custom schema type properties. Last, 
 we refactored Blog to use Mongoose and made our app gain a true MVC architecture.
  
 Next, we’ll cover how to build REST APIs with the two Node.js frameworks: Express.js and Hapi. This is an 
 important topic, because more and more web developments shift towards heavy front-end logic and thin back-end. 
 Some systems even go as far as building/using free-JSON APIs or back-as-a-service services. This tendency allows 
 teams to focus on what is the most important for end-users: user interface, features, as well as what is vital for 
 businesses: reduced iteration cycles, lower costs of maintenance and development.
  
  
 Another essential piece in this puzzle is test-driven practice. To explore it, we’ll cover Mocha, which is a widely 
 used Node.js testing framework. To REST APIs and TDD onward.
  
 172",NA
Chapter 8,NA,NA
Building Node.js REST API ,NA,NA
Servers with Express.js and ,NA,NA
Hapi,"Modern-day web development is moving increasingly toward a structure for which there’s a thick client, usually built 
 with frameworks such as Backbone.js, (
 http://backbonejs.org/
 ) Anglers JS, (
 https://angularjs.org/
 ) Ember.js, 
 (
 http://emberjs.com/
 ) and the like, and a thin back-end layer typically represented by a representational state 
 transfer (REST) web application programing interface (API) service. This model has become more and more popular, 
 and we’ve seen services such as Parse.com and many others pioneer the back end as a service niche. The advantages 
 of this approach are as follows:
  
 
  
 The same back-end REST API can serve multiple client apps/consumers, with web 
  
 applications being just one of them (mobile and public third-party apps are examples of 
  
 others).
  
 
  
 There is a separation of concerns, i.e., the clients can be replaced without compromising the 
  
 integrity of the core business logic, and vice versa.
  
 
  
 User interface / user experience (UI/UX) are inherently hard to test, especially with event-
 driven, 
  
 single-page apps, and then there’s an added complexity of cross-browser testing; but, 
 with 
  
 separation of business logic into the back-end REST API, that logic becomes easy to test 
 in 
  
 both unit and functional testing.
  
 Therefore, the majority of new projects take the REST API and clients approach. Development teams may take 
 this approach even if they have just one client for the time being which is typically a web app, because they realize 
 that otherwise, when they eventually add more apps, they’ll have to redo their work. 
  
 To get started with Node.js REST servers, in this chapter we cover the following:
  
 
  
 RESTful API basics
  
 
  
 Project dependencies
  
 
  
 Test coverage with Mocha ( 
 http://visionmedia.github.io/mocha/
 ) and superagent 
  
 (
 http://visionmedia.github.io/superagent/
 )
  
 
  
 REST API server implementation with Express and Mongoskin 
  
 (
 https://github.com/kissjs/node-mongoskin
 )
  
 
  
 Refactoring: Hapi.js ( 
 http://hapijs.com/
 ) REST API Server
  
 The REST API server is able to process the creation of objects, retrieval of objects and collections, make 
 changes to objects and remove objects. For your convenience, all the source code is in the ch8 folder in 
 github.com/azat-co/practicalnode (
 https://github.com/azat-co/practicalnode
 ).",NA
RESTful API Basics,"RESTful API
 1
  became popular because of the demand in distributed systems in which each transaction needs to 
 include enough information about the state of the client. In a sense, this standard is stateless, because no information 
 about the clients’ states is stored on the server, making it possible for each request to be served by a different system.
  
 Distinct characteristics of RESTful API (i.e., if API is RESTful, it usually follows these principles) are as follows:
  
 
  
 RESTful API has better scalability support because different components can be deployed 
  
 independently to different servers.
  
 
  
 It replaced the Simple Object Access Protocol (SOAP 
 2
 ) because of the simpler verb and noun 
  
 structure.
  
 
  
 It uses HTTP methods such as GET, POST, DELETE, PUT, OPTIONS, and so forth.
  
 
  
 JSON is not the only option (although it is the most popular). Unlike SOAP, which is a protocol, 
  
 the REST methodology is flexible in choosing formats. For example alternative formats might 
  
 be Extensible Markup Language (XML) or comma-separated values formats (CSV).
  
 In Table 
 8-1
  is an example of a simple create, read, update and delete (CRUD
 3
 ) REST API for message collection.
  
 Table 8-1.
  Example of the CRUD REST API Structure
  
 Method
  
 URL
  
 Meaning
  
 GET
  
 /messages.json
  
 Return list of messages in JSON format
  
 PUT
  
 /messages.json
  
 Update/replace all messages and return status/error in JSON
  
 POST
  
 /messages.json
  
 Create a new message and return its ID in JSON format
  
 GET
  
 /messages/{id}.json
  
 Return message with ID {id} in JSON format
  
 PUT
  
 /messages/{id}.json
  
 Update/replace message with id {id}; if {id} message doesn’t exist, create it
  
 DELETE
  
 /messages/{id}.json
  
 Delete message with ID {id}, return status/error in JSON format",NA
Project Dependencies,"To get started with our project, we need to install packages. In this chapter, we use Mongoskin 
  
 (
 https://github.com/kissjs/node-mongoskin
 ), a MongoDB library, which is a better alternative to the plain, good-
 ol’ native MongoDB driver for Node.js (
 https://github.com/mongodb/node-mongodb-native
 ). In addition, 
 Mongoskin is more lightweight than Mongoose and it is schemaless. For more insights on the library, please check 
 out this Mongoskin comparison blurb, 
 https://github.com/kissjs/node-mongoskin#comparation
 .
  
 Express.js (
 http://expressjs.com/
 ) is a wrapper for core Node.js http module (
 http://nodejs.org/api/http.html
 ) 
 objects. The Express.js framework is built on top of the Connect (
 https://github.com/senchalabs/connect
 ) 
 middleware library and it provides myriads of convenience. Some people compare the Express.js framework with 
 Ruby’s Sinatra because it’s non-opinionated and configurable.
  
 First, we need to create a ch8/rest-express folder (or download the source code):
  
 $ mkdir rest-express 
  
 $ cd rest-express
  
  
 As mentioned in the previous chapter, Node.js/NPM provides multiple ways to install dependencies, including 
 the following:
  
 
  
 
  
 
  
 Manually, one by one 
  
 As a part of package.json 
  
 By downloading and copying modules
  
 4
 http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Idempotent_methods_and_web_application
 . 
 5
 http://en.wikipedia.org/wiki/Representational_state_transfer
 .
  
 175",NA
Test Coverage with Mocha and Superagent,"Before the app implementation, let’s write functional tests that make HTTP requests to our soon-to-be-created 
 REST API server. In a TDD manner, let’s use these tests to build a Node.js free JSON REST API server using the 
 Express.js framework and Mongoskin library for MongoDB.
  
  
 In this section we walk through the writing of functional tests using the Mocha (
 http://visionmedia.github.io/ 
 mocha/
 ) and superagent
 6
  libraries. The tests need to perform basic CRUD by posting HTTP requests to our server. 
  
  
 If you know how to use Mocha or just want to jump straight to the Express.js app implementation, feel free to 
 do so. You can use CURL terminal commands for testing, too.
  
 6
 http://visionmedia.github.io/superagent/
 .
  
 176",NA
REST API Server Implementation with Express and ,NA,NA
Mongoskin,"Create and open ch8/rest-express/index.js, which will be the main application file. 
  
 First things first. Let’s import our dependencies into the application:
  
 var express = require('express'),
  
  mongoskin = require('mongoskin'),
  
  bodyParser = require('body-parser'),
  
  logger = require('morgan')
  
  
 After version 3.x, Express.js streamlined the instantiation of its app instance so that the following line gives us 
 a server object:
  
 var app = express()
  
  
 To extract parameters and data from the requests, let’s use bodyParser.urlencoded() and bodyParser.json() 
 middleware. We apply them with app.use(), and the code looks more like configuration statements:
  
 app.use(bodyParser.urlencoded()) 
  
 app.use(bodyParser.json()) 
  
 app.use(logger())
  
 express.logger() is optional middleware that allows us to monitor requests. Middleware (in this 
  
 (
 http://expressjs.com/api.html#app.use
 ) and other forms (
 http://expressjs.com/api.html#middleware
 )) is a 
 powerful and convenient pattern in Express.js and Connect to organize and reuse code.
  
 As with the express.urlencoded() and express.json() methods, which save us from the hurdles of parsing a 
 body object of an HTTP request, Mongoskin makes it possible to connect to the MongoDB database in one effortless 
 line of code:
  
 var db = mongoskin.db('mongodb://@localhost:27017/test', {safe:true})
  
 ■
 Note
  if you wish to connect to a remote database (e.g., MongohQ (
 https://www.mongohq.com/home
 )), 
 substitute 
  
 the string with your username, password, host, and port values. here is the format of the uniform 
 resource identifier (uri) 
  
 string (no spaces): 
 mongodb://[username:password@] host1[:port1][,host2[:port2],... [,hostN[:portN]]] 
  
 [/[database][?options]]
  
 The next statement is a helper function that converts hex strings into MongoDB ObjectID data types:
  
 var id = mongoskin.helper.toObjectID
  
 The app.param() method is another form of Express.js middleware. It basically says: Do something every time 
 there is this value in the URL pattern of the request handler
 .
  In our case, we select a particular collection when a 
 request pattern contains a string collectionName prefixed with a colon (we see this when we examine routes):
  
 app.param('collectionName', function(req, res, next, collectionName){ 
 req.collection = db.collection(collectionName)",NA
Refactoring: Hapi RESP API Server,"Hapi (
 http://spumko.github.io/
 ) (NPM (
 https://www.npmjs.org/package/hapi
 ) and GitHub 
  
 (
 https://github.com/spumko/hapi
 )) is an enterprise-grade framework. It’s more complex and feature rich than 
 Express.js, and it’s easier to develop in large teams (
 http://hueniverse.com/2012/12/hapi-a-prologue/
 ). Hapi is 
 maintained by Eran Hammer (
 http://hueniverse.com/
 ) of Walmart Labs.
  
 187",NA
Summary,"The loosely coupled architecture of REST API servers and clients (mobile, web app, or front end) allows for better 
 maintenance and works perfectly with TDD/BDD. In addition, NoSQL databases such as MongoDB are good at 
 handling free REST APIs. We don’t have to define schemas, and we can throw any data at it and it is saved!
  
  
 The Express.js and Mongoskin libraries are great when you need to build a simple REST API server using a few 
 lines of code. Later, if you need to expand the libraries, they also provide a way to configure and organize your code. 
  
 If you want to learn more about Express.js, take a look at 
 Pro Express.js [2014, Apress]
 . Also, it’s good to know that, 
 for more complex systems, the Hapi server framework is there for you!
  
 In this chapter, in addition to Express.js, we used MongoDB via Mongoskin. We also used Mocha and SuperAgent 
 to write functional tests that, potentially, save us hours in testing and debugging when we refactor code in the future. 
 Then, we easily flipped Express.js for Hapi and, thanks to the tests, are confident that our code works as expected! 
 The differences between the Express and Hapi frameworks that we observed are in the way we defined routes and 
 URL parameters, and output the response.
  
 194",NA
Chapter 9,NA,NA
Real-Time Apps with ,NA,NA
"WebSocket, Socket.IO, and ",NA,NA
DerbyJS,"Real-time apps are becoming more and more widespread in gaming, social media, various tools, services, and news. 
  
 The main factor contributing to this trend is that technologies have become much better. They allow for a greater 
 bandwidth to transmit data, and for more calculations to process and retrieve the data.
  
 HTML5 pioneered the new standard of real-time connections called 
 WebSocket
 . At the same time, on the server 
 side, Node.js has a highly efficient, nonblocking input/output platform that is very well suited for the task of being a 
 back-end pair to the browser JavaScript and WebSocket.
  
 To get you started with WebSocket and Node.js, we’ll keep things simple stupid (KISS (
 http://en.wikipedia.
  
 org/wiki/KISS_principle
 )) and cover the following:
  
 
  
 What is WebSocket?
  
 
  
 Native WebSocket and Node.js with the ws module example
  
 
  
 Socket.IO and Express.js example
  
 
  
 Collaborative online editor example with DerbyJS, Express.js, and MongoDB",NA
What Is WebSocket?,"WebSocket is a special communication “channel” between browsers (clients) and servers. It’s an HTML5 protocol. 
 WebSocket’s connection is constant, in contrast to traditional HTTP requests, with the latter usually initiated by the 
 client. Therefore, there’s no way for a server to notify the client if there are updates. By maintaining a duplex open 
 connection between the client and the server, updates can be pushed in a timely fashion without clients needing to 
 poll at certain intervals. This main factor makes WebSocket ideal for real-time apps for which data need to be 
 available on the client immediately. For more information on WebSocket, take a look at the extensive resource 
 “About HTML5 WebSocket” (
 http://www.websocket.org/aboutwebsocket.html
 ).
  
 There’s no need to use any special libraries to use WebSocket in modern browsers. The following StackOverflow 
 has a list of such browsers: What browsers support HTML5 WebSockets API? (
 http://stackoverflow.com/ 
 questions/1253683/what-browsers-support-html5-websocket-api
 ) For older browser support, the workaround 
 includes falling back on polling.
  
 As a side note, polling (both short and long), can also be used to emulate the real-time responsiveness of web 
 apps. In fact, some advanced libraries (Socket.IO) fall back to polling when WebSocket becomes unavailable as a 
 result of connection issues or users not having the latest versions of browsers. Polling is relatively easy and we 
 don’t cover it here. It can be implemented with just a setInterval() callback and an end point on the server. 
 However, there’s not real-time communication with polling; each request is separate.",NA
Native WebSocket and Node.js with the ws Module ,NA,NA
Example,"Sometimes it’s easier to start from the simplest thing and build things on top of it. With this in mind, our mini project 
 includes building a native WebSocket implementation that talks with the Node.js server with the help of the ws 
 module:
  
 
  
 Browser WebSocket implementation
  
 
  
 Node.js server with ws module implementation
  
 Let’s examine this with a quick example.",NA
Browser WebSocket Implementation,"This is our front-end code (file ch9/basic/index.html) for Chrome version 32.0.1700.77. We start with typical 
 HTML tags:
  
 <html>
  
  <head>
  
  </head>
  
  <body>
  
 The main code lives in the script tag, where we instantiate an object from global WebSocket:
  
 <script type=""text/javascript"">
  
  var ws = new WebSocket('ws://localhost:3000');
  
 As soon as the connection is established, we send a message to the server:
  
 ws.onopen = function(event) {
  
  ws.send('front-end message: ABC'); 
  
 };
  
  
 Usually, messages are sent in response to user actions, such as mouse clicks. When we get any message from the 
 WebSocket location, the following handler is executed:
  
 ws.onmessage = function(event) {
  
  console.log('server message: ', event.data); 
  
 };
  
 A good practice is to have an onerror event handler:
  
 ws.onerror = function(event) {
  
  console.log('server error message: ', event.data); };
  
 We then close the tags and save the file:
  
   
  </script>
  
  </body> 
  
 </html>
  
 196",NA
Node.js Server with ws Module Implementation,"WebSocket.org provides an echo service for testing the browser WebSocket, but we can build our own small 
 Node.js server with the help of the ws (
 http://npmjs.org/ws
 , GitHub: 
 https://github.com/einaros/ws
 ) library:
  
 $ mkdir node_modules 
  
 $ npm install ws@0.4.31
  
 In the ch9/basic/server.js file, we import ws and initialize the server:
  
 var WebSocketServer = require('ws').Server,
  
  wss = new WebSocketServer({port: 3000});
  
  
 Akin to the front-end code, we use an event pattern to wait for a connection. When the connection is ready, in the 
 callback we send the string XYZ and attach an event listener on ('message') to listen to incoming messages from the 
 page:
  
 wss.on('connection', function(ws) {
  
  
  ws.send('XYZ');
  
  
  ws.on('message', function(message) {
  
  
  
  console.log('received: %s', message);
  
  
  }); 
  
 });
  
 Again, for reference, here’s the full code of ch9/basic/server.js:
  
 var WebSocketServer = require('ws').Server,
  
  wss = new WebSocketServer({port: 3000});
  
 wss.on('connection', function(ws) {
  
  
  ws.send('XYZ');
  
  
  ws.on('message', function(message) {
  
  
  
  console.log('received: %s', message);
  
  
  }); 
  
 });
  
 197",NA
Socket.IO and Express.js Example,"Full coverage of the Socket.IO (
 http://socket.io/
 ) library absolutely deserves its own book. Nevertheless, because it’s 
 such a popular library, and getting started with it is very easy with Express.js, we include in this chapter an example 
 that covers the basics. This mini project illustrates duplex-channel communication between browser and server.
  
 As in most real-time web apps, the communication between a server and a client happens in response either to 
 some user actions or as a result of updates from the server. So, in our example, the web page renders a form field in 
 which each character echoes (browser to server and back) in reverse in real time. The example harnesses Express.
  
 js command-line tool scaffolding, Socket.IO, and Jade (see screenshots of the working app in Figures 
 9-3
  and 
 9-4
 ). 
  
 Of course, you can just download the app from github.com/azat-co/practicalnode (
 http://github.com/azat-co/ 
 practicalnode
 ).
  
 199",NA
Collaborative Online Code Editor Example with ,NA,NA
"DerbyJS, Express.js, and MongoDB","Derby (
 http://derbyjs.com/
 ) is a new, sophisticated MVC
 1
  framework designed to be used with Express 
  
 (
 http://expressjs.com/
 ) as its middleware, whereas Express.js (
 http://expressjs.com/
 ) is a popular node framework 
 that uses the middleware concept to enhance the functionality of applications. Derby also comes with the support of 
 Racer (
 https://github.com/codeparty/racer
 ), a data synchronization engine, and Handlebars (
 https://github.com/ 
 wycats/handlebars.js/
 ) -like template engine, among many other features (
 http://derbyjs.com/#features
 ).
  
 1
 http://en.wikipedia.org/wiki/Model–view–controller
 .
  
 204",NA
Project Dependencies and package.json,"If you haven’t installed Node.js, NPM, MongoDB, or Redis, you can do it now by following instructions in these 
 resources:
  
 
  
 Installing Node.js via package manager ( 
 https://github.com/joyent/node/wiki/ 
  
 Installing-Node.js-via-package-manager
 )
  
 
  
 Installing npm ( 
 http://howtonode.org/introduction-to-npm
 )
  
 
  
 Install MongoDB ( 
 http://docs.mongodb.org/manual/installation/#install-mongodb
 )
  
 
  
 Redis Quick Start ( 
 http://redis.io/topics/quickstart
 )
  
 Create a project folder, editor, and a file package.json with the following content:
  
 {
  
  ""name"": ""editor"",
  
  ""version"": ""0.0.1"",
  
  ""description"": ""Online collaborative code editor"", ""main"": 
 ""index.js"",
  
  ""scripts"": {
  
   
  ""test"": ""mocha test""
  
  },
  
  ""git repository"": ""
 http://github.com/azat-co/editor
 "", 
 ""keywords"": ""editor node derby real-time"",
  
  ""author"": ""Azat Mardan"",
  
  ""license"": ""BSD"",
  
  ""dependencies"": {
  
   
  ""derby"": ""~0.5.12"",
  
   
  ""express"": ""~3.4.8"",
  
   
  ""livedb-mongo"": ""~0.3.0"",
  
   
  ""racer-browserchannel"": ""~0.1.1"",
  
   
  ""redis"": ""~0.10.0""
  
  } 
  
 }
  
 205",NA
Server-side Code,"As an entry point for our application, create editor/server.js with a single line of code that starts a Derby server we 
 have yet to write:
  
 require('derby').run(__dirname + '/server.js');
  
 Create and start adding the following lines to editor/server.js. First, import the dependencies:
  
 var path = require('path'),
  
  express = require('express'),
  
  derby = require('derby'),
  
  racerBrowserChannel = require('racer-browserchannel'), 
 liveDbMongo = require('livedb-mongo'),
  
 Then, define the Derby app file:
  
 app = require(path.join(__dirname, 'app.js')),
  
 Instantiate the Express.js app:
  
 expressApp = module.exports = express(),
  
 the Redis client:
  
 redis = require('redis').createClient(),
  
 and the local MongoDB connection URI:
  
 mongoUrl = 'mongodb://localhost:27017/editor';
  
 Now we create a liveDbMongo object with the connection URI and redis client object:
  
 var store = derby.createStore({
  
  db: liveDbMongo(mongoUrl + '?auto_reconnect', {
  
   
  safe: true
  
  }),
  
  redis: redis 
  
 });
  
 Define a public folder with static content:
  
 var publicDir = path.join(__dirname, 'public');
  
 206",NA
DerbyJS App,"The DerbyJS app (app.js) shares code smartly between the browser and the server, so you can write functions and 
 methods in one place (a Node.js file). However, parts of app.js code become browser JavaScript code (not just Node.
  
 js) depending on the DerbyJS rules. This behavior allows for better code reuse and organization, because you don’t 
 have to duplicate routes, the helper function, and utility methods. One of the places where the code from the DerbyJS 
 app file becomes browser code only is inside app.ready(), which we will see later.
  
 Declare the variable and create an app (editor/app.js):
  
 var app; 
  
 app = require('derby').createApp(module);
  
  
 Declare the root route so that when a user visits it, the new snippet is created and the user is redirected 
 to the /:snippetId route:
  
 app.get('/', function(page, model, _arg, next) {
  
  snippetId = model.add('snippets', {
  
   
  snippetName: _arg.snippetName,
  
   
  code: 'var'
  
  });
  
  return page.redirect('/' + snippetId); 
  
 });
  
  
 DerbyJS uses a route pattern similar to Express.js, but instead of response (res), we use page, and we get 
 data from the model argument.
  
  
 The /:snippetId route is where the editor is displayed. To support real-time updates to the Document Object 
 Model (DOM), all we need to do is to call subscribe:
  
 app.get('/:snippetId', function(page, model, param, next) { var snippet 
 = model.at('snippets.'+param.snippetId); 
 snippet.subscribe(function(err){
  
   
  if (err) return next(err);
  
   
  console.log (snippet.get());
  
   
  model.ref('_page.snippet', snippet);
  
   
  page.render();
  
  }); 
  
 });
  
  
 The model.at method with a parameter in a collection_name.ID pattern is akin to calling findById()—in other 
 words, we get the object from the store/database.
  
 208",NA
DerbyJS View,"The DerbyJS view (views/app.html) is quite straightforward. It contains built-in tags such as <Title:>, but most of 
 the things are generated dynamically by the Ace editor after the page is loaded.
  
 Let’s start by defining the title and head:
  
 <Title:>
  
  Online Collaborative Code Editor 
  
 <Head:>
  
  <meta charset=""UTF-8"">
  
  <meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""> 
 <title>Editor</title>
  
  <style type=""text/css"" media=""screen"">
  
   
  body {
  
    
  overflow: hidden;
  
   
  }
  
  #editor {
  
  margin: 0;
  
  position: absolute;
  
  top: 0px;
  
  bottom: 0;
  
 210",NA
Editor Tryout,"If you followed all the previous steps, there should be app.js, index.js, server.js, views/app.html, and 
 package.json files.
  
  
 Let’s install the modules with $ npm install. Start the databases with $ mongod and $ redis-server, and leave 
 them running. Then, launch the app with $ node . or $ node index.
  
 Open the first browser window at http://localhost:3000/ and it should redirect you to a new snippet (with ID in 
 the URL). Open a second browser window at the same location and start typing (Figure 
 9-5
 ). You should see the code 
 updating in the first window! Congratulations! In just a few minutes, we built an app that might have taken 
 programmers a few months to build back in the 2000s, when front-end JavaScript and AJAX-y web sites were first 
 gaining popularity.
  
  
 Figure 9-5.
  Collaborative online code editor
  
 The working project is available on GitHub at 
 https://github.com/azat-co/editor
 .
  
 212",NA
Summary,"In this chapter, we saw that there’s native support for WebSocket in modern HTML5 browsers, and we learned how 
 to get started with Socket.IO and Express.js to harness the power of WebSocket in Node.js. In addition, we explored 
 the mighty full-stack framework of DerbyJS in the editor example. 
  
  
 In the next chapter we’ll move to the essential part of any real-world project which is getting Node.js apps to 
 a production level readiness by adding extra configuration, monitoring, logging and other things.
  
 213",NA
Chapter 10,NA,NA
Getting Node.js Apps ,NA,NA
Production Ready,"Getting Node.js apps to a production-ready state is probably the most under covered and skipped topic in the Node.js 
 literature, but it’s one of the most important in my humble opinion.
  
  
 Yes, the apps differ in structures, frameworks they use, and goals they try to achieve; however, there are a 
 few commonalities worth knowing about, for example, environmental variables, multithreading, logging and 
 error handling. So, in this chapter we cover the following topics:
  
  
 
  
 Environment variables 
  
  
   
 Express.js in production
 
  
  
 
  
  
 Socket.IO in production
  
 
  
 Error handling
  
  
 
  
 Node.js domains for error handling 
  
  
   
 Multithreading with Cluster
 
  
  
 
  
  
 Multithreading with Cluster2
  
 
  
 Event logging and monitoring
  
  
 
  
 Building tasks with Grunt 
  
  
   
 Git for version control and deployments
 
  
  
 
  
 Running tests in Cloud with TravisCI",NA
Environment Variables ,"Before deployment to the production environment, it’s good to prepare our app’s code. Let’s start with information 
 that needs to be private and can’t be shared in a version control system. Sensitive information such as API keys, 
 passwords, and database URIs are best stored in environment variables (
 http://en.wikipedia.org/wiki/ 
 environment_variable
 ), not in the source code itself. Node.js makes it fairly easy to access these variables:
  
 console.log (process.env.NODE_ENV,
  
  process.env.API_KEY,
  
  process.env.DB_PASSWORD)
  
 215",NA
Express.js in Production,"In Express.js 4.x, use if/else statements to check for NODE_ENV values:
  
 var errorHandler = require('errorhandler'); 
  
 if (process.env.NODE_ENV === 'development') {
  
  app.use(errorHandler({ 
  
   
  dumpExceptions: true, 
  
   
  showStack: true 
  
  })); 
  
 } else if (process.env.NODE_ENV === 'production') { 
 app.use(errorHandler()); 
  
 }
  
  
 Express.js 3.x provides app.configure(), the so-called sugarcoating methods for different modes: development, 
 test, stage, production, and so on.
  
 app.configure('development', function(){
  
  app.use(express.errorHandler({ 
  
   
  dumpExceptions: true, 
  
   
  showStack: true   
  
  })); 
  
 });
  
 app.configure('production', function(){
  
  app.use(express.errorHandler()); 
  
 });
  
 Each app.configure pattern is equivalent to a series of if/else statements:
  
 if (process.env.NODE_ENV === 'development') {
  
  app.use(express.errorHandler({ 
  
   
  dumpExceptions: true, 
  
   
  showStack: true 
  
  })); 
  
 } else if (process.env.NODE_ENV === 'production') { 
 app.use(express.errorHandler()); 
  
 }
  
 216",NA
Socket.IO in Production,"Akin to Express.js 3.x, the Socket.IO library has configure() method that can be used to define different rules for 
 different environments:
  
 var io = require('socket.io').listen(80);
  
 io.configure('production', function(){
  
  io.enable('browser client etag');
  
  io.set('log level', 1);
  
  io.set('transports', [ 
  
   
  'websocket', 
  
   
  'flashsocket', 
  
   
  'htmlfile', 
  
   
  'xhr-polling', 
  
   
  'jsonp-polling' 
  
  ]); 
  
 });
  
 io.configure('development', function(){
  
  io.set('transports', ['websocket']); 
  
 });
  
  
 Often, WebSockets data are stored in a high-performance database such as Redis. In this example, you can use 
 environment variables for values of port and hostname:
  
 var sio = require('socket.io'), 
  
  RedisStore = sio.RedisStore,
  
  io = sio.listen();
  
 io.configure(function () {
  
  io.set('store', new RedisStore({ host: '
 http://webapplog.com
 ' })); });
  
 var redis = require('redis'),
  
  redisClient = redis.createClient(port, hostname), redisSub 
 = redis.createClient(port, hostname);
  
 218",NA
Error Handling,"As a rule of thumb, listen to all error events from http.Server and https.Server (i.e., always have onerror event 
 listeners doing something):
  
 server.on('error', function (err) {
  
  console.error(err);
  
  ...
  
 })
  
  
 Then, have a catchall event listener (uncaughtException) for unforeseen cases. These cases won’t make it to the 
 onerror handlers:
  
 process.on('uncaughtException', function (err) { 
 console.error('uncaughtException: ', err.message); 
 console.error(err.stack);
  
  process.exit(1); 
  
 });
  
 Alternatively, you can use the addListener method:
  
 process.addListener('uncaughtException', function (err) { 
 console.error('uncaughtException: ', err.message); 
 console.error(err.stack);
  
  process.exit(1); 
  
 });
  
  
 The following snippet is devised to catch uncaught exceptions, log them, notify development and operations 
 (DevOps) via e-mail/text messages, and then exit:
  
 process.addListener('uncaughtException', function (e) { 
 server.statsd.increment('errors.uncaughtexception');
  
  log.sub('uncaughtException').error(e.stack || e.message); 
 if(server.sendgrid && server.set('env') === 'production') {
  
 219",NA
Node.js Domains for Error Handling,"Because Node.js allows developers to write asynchronous code, and that’s what we usually do, and because state 
 changes during different async parts of code, sometimes it’s harder to trace errors and have a meaningful state and 
 context in which the application was during that exception. To mitigate this, we have domains in Node.js.
  
 Contrary to its more popular homonym (domain as in webapplog.com or google.com), domain is a core Node. js 
 module (
 http://nodejs.org/api/domain.html
 ). It aids developers in tracking and isolating errors that could be a 
 juggernaut task. Think of domains as a smarter version of try/catch statements (
 https://developer.mozilla.org/ en-
 US/docs/web/javaScript/reference/statements/try...catch
 ).
  
 When it comes to Express.js (and other frameworks), we can apply domains in error-prone routes. A route can 
 become error prone if it has pretty much any nontrivial code (i.e., any route can be prone to error), but usually 
 developers can just analyze logs and determine which URL and path are causing the crashes. Typically, these routes 
 rely on third-party modules, some communication, or file system/database input/output.
  
  
 Before defining the routes, we need to define custom handlers to catch errors from domains. In Express.js 4.x we 
 do the following:
  
 var express = require('express'); 
  
 var domain = require('domain'); 
  
 var defaultHandler = require('errorhandler');
  
 In Express.js 3.x, we execute:
  
 var express = require('express'); 
  
 var domain = require('domain'); 
  
 var defaultHandler = express.errorHandler();
  
 Then, for Express.js 4.x and 3.x, we add middleware:
  
 app.use(function (error, req, res, next) {
  
  if (domain.active) {
  
   
  console.info('caught with domain');
  
   
  domain.active.emit(""error"", error);
  
  } else {
  
   
  console.info('no domain');
  
   
  defaultHandler(error, req, res, next);
  
  } 
  
 });
  
 Here is a “crashy route” in which the error-prone code goes inside the d.run callback:
  
 app.get('/e', function (req, res, next) {
  
  var d = domain.create();
  
  d.on('error', function (error) {
  
   
  console.error(error.stack);
  
 221",NA
Multithreading with Cluster,"There are a lot of opinions out there against Node.js that are rooted in the myth that Node.js-based systems 
 have
  to 
 be single threaded. Although a single Node.js process 
 is
  single threaded, nothing can be further from the truth about 
 the systems. And with the core cluster module (
 http://nodejs.org/api/cluster.html
 ), we can spawn many Node.js 
 processes effortlessly to handle the system’s load. These individual processes use the same source code and they 
 can listen to the same port. Typically, each process uses one machine’s CPU. There’s a master process that spawns 
 all other processes and, in a way, controls them (can kill, restart, and so on).
  
  
 Here is a working example of an Express.js (version 4.x or 3.x) app that runs on four processes. At the beginning 
 of the file, we import dependencies:
  
 var cluster = require('cluster'); 
  
 var http = require('http'); 
  
 var numCPUs = require('os').cpus().length; 
  
 var express = require('express');
  
 The cluster module has a property that tells us whether the process is master or child (master controls children). 
 We use it to spawn four workers (the default workers use the same file, but this can be overwritten with setupMaster 
 (
 http://nodejs.org/docs/v0.9.0/api/cluster.html#cluster_cluster_setupmaster_settings
 )). In addition, we can attach 
 event listeners and receive messages from workers (e.g., kill).
  
 if (cluster.isMaster) {
  
  console.log (' Fork %s worker(s) from master', numCPUs)
  
  for (var i = 0; i < numCPUs; i++) {
  
   
  cluster.fork();
  
  };
  
  cluster.on('online', function(worker) {
  
   
  console.log ('worker is running on %s pid', worker.process.pid) });
  
  cluster.on('exit', function(worker, code, signal) {
  
   
  console.log('worker with %s is closed', worker.process.pid); }); 
  
 }
  
 The worker code is just an Express.js app with a twist. Let’s get the process ID:
  
 } else if (cluster.isWorker) {
  
  var port = 3000;
  
  console.log('worker (%s) is now listening to http://localhost:%s',
  
  
  cluster.worker.process.pid, port);
  
  var app = express();
  
  app.get('*', function(req, res) {
  
 224",NA
Multithreading with Cluster2,"If you prefer ready solutions to low-level libraries (such as cluster), check out the real-world production library 
 created and used by eBay: cluster2 (GitHub (
 https://github.com/cubejs/cluster2
 ) ,NPM 
  
 (
 https://www.npmjs.org/package/cluster2
 )) which is a wrapper for the core cluster module. Cluster2 provides 
 handy utility functions and is battle-tested on a large-scale production deployment.
  
 To install Cluster2, run:
  
 $ npm install cluster2
  
 226",NA
Event Logging and Monitoring,"When things go south (e.g., overloads, crashes), there are two things software engineers can do:
  
 1. 
  
 Monitor via dashboard and health statuses (monitoring and REPL).
  
 2. 
  
 Analyze postmortems after the events have happened (Winston and Papertrail).",NA
Monitoring,"When going to production, software and development operations engineers need a way to get current status quickly. 
 Having a dashboard or just an end point that spits out JSON-formatted properties is a good idea, including properties 
 such as the following:
  
 
  
 memoryUsage: memory usage information
  
 
  
 uptime: number of seconds the Node.js process is running
  
 
  
 pid: process ID
  
 
  
 connections: number of connections
  
 
  
 loadavg: load average
  
 
  
 sha: Secure Hash Algorithm (SHA) of the Git commit deploy and /or version tag of the deploy
  
 Here’s an example of the Express.js route /status:
  
 app.get('/status', function(req, res){
  
  res.send({
  
   
  pid: process.pid,
  
   
  memory: process.memoryUsage(),
  
   
  uptime: process.uptime()
  
  }) 
  
 })
  
 227",NA
REPL in Production,"What can be better than poking around a live process and its context using the REPL tool? We can do this easily 
 with production apps if we set up REPL as a server:
  
 var net = require('net'),
  
  options = {name: 'azat'};
  
 net.createServer(function(socket) {
  
  repl.start(options.name + ""> "", socket).context.app = app; 
 }).listen(""/tmp/repl-app-"" + options.name);
  
 Then, connect to the remote machine by using Secure Shell (SSH). Once on the remote machine, run:
  
 $ telnet /tmp/repl-app-azat
  
 You should be prompted with a standard >, which means you’re in the REPL.
  
  
 Or, if you want to connect to the remote server right away, i.e., by-passing the SSH step, you can modify the 
 code to this:
  
 var repl = require('repl'); 
  
 var net = require('net'),
  
  options = { name: 'azat' };
  
 app = {a: 1}; 
  
 net.createServer(function(socket) {
  
  repl.start(options.name + ""> "", socket).context.app = app; 
 }).listen(3000);
  
  
 Please use iptable to restrict the Internet protocol addresses (IPs) when using this approach. Then, straight from 
 your local machine (where the hostname is the IP of the remote box), execute:
  
 $ telnet hostname 3000
  
 229",NA
Winston ,"Winston provides a way to have one interface for logging events while defining multiple transports, e.g., e-mail, 
 database, file, console, Software as a Service (SaaS), and so on. The list of transports supported by Winston include the 
 following:
 
  
 Console
  
 
  
 File
  
 
  
  
 Loggly ( 
 http://www.loggly.com/
 )
 
  
 Riak
  
 
  
 MongoDB
  
 
  
 SimpleDB
  
 
  
 Mail
  
 
  
 Amazon SNS
  
 
  
 Graylog2
  
 
  
 Papertrail
  
 
  
 Cassandra
  
 It’s easy to get started with Winston:
  
 $ npm install winston
  
 In the code, execute the following:
  
 var winston = require('winston'); 
  
 winston.log('info', 'Hello distributed log files!'); 
 winston.info('Hello again distributed logs');
  
 To add and remove transporters, use the winston.add() and winston.remove() functions. To add, use:
  
 winston.add(winston.transports.File, {filename: 'webapp.log'});
  
 To remove, use:
  
 winston.remove(winston.transports.Console);
  
  
 For more information, go to the official documentation (
 https://github.com/flatiron/ 
 winston#working-with-transports
 ).",NA
Papertrail App for Logging ,"Papertrail (
 https://papertrailapp.com
 ) is a SaaS that provides centralized storage and a web GUI to search and 
 analyze logs. To use Papertrail with the Node.js app, do the following: 
  
 1. 
  
 Write logs to a file and remote_sync (
 https://github.com/papertrail/remote_syslog
 ) 
  
  
  
 them to Papertrail.
  
 2. 
  
 Send logs with winston (
 https://github.com/flatiron/winston#working-with-
  
 transports
 ), which is described earlier, and winston-papertrail (
 https://github.com/ 
  
 kenperkins/winston-papertrail
 ) directly to the service.
  
 230",NA
Building Tasks with Grunt,"Grunt is a Node.js-based task runner. It performs compilations, minifications, linting, unit testing, and other 
 important tasks for automation.
  
 Install Grunt globally with NPM:
  
 $ npm install -g grunt-cli
  
 Grunt uses Gruntfile.js to store its tasks. For example,
  
 module.exports = function(grunt) {
  
  // Project configuration
  
  grunt.initConfig({
  
  
  pkg: grunt.file.readJSON('package.json'),
  
  
  uglify: {
  
   
  options: {
  
    
  banner: '/*! <%= pkg.name %> <%= grunt.template.today(""yyyy-mm-dd"") %> */\n'
  
  
  },
  
   
  build: {
  
    
  src: 'src/<%= pkg.name %>.js',
  
    
  dest: 'build/<%= pkg.name %>.min.js'
  
   
  }
  
  
  }
  
  });
  
  // Load the plugin that provides the ""uglify"" task 
 grunt.loadNpmTasks('grunt-contrib-uglify');
  
  // Default task
  
  grunt.registerTask('default', ['uglify']);
  
 }; 
  
  
 package.json should have plugins required by the grunt.loadNpmTasks() method. For example,
  
 {
  
  ""name"": ""grunt-example"",
  
  ""version"": ""0.0.1"",
  
  ""devDependencies"": {
  
   
  ""grunt"": ""~0.4.2"",
  
   
  ""grunt-contrib-jshint"": ""~0.6.3"",
  
   
  ""grunt-contrib-uglify"": ""~0.2.2"",
  
   
  ""grunt-contrib-coffee"": ""~0.10.1"",
  
   
  ""grunt-contrib-concat"": ""~0.3.0""
  
  } 
  
 }
  
  
 Let’s move to the more complex example in which we use jshint, uglify, coffee, and concat plugins in the 
 default task in Gruntfile.js.
  
 231",NA
Git for Version Control and Deployments,"Git has become not only a standard version control system, but also—because of its distributed nature—Git has 
 become the default transport mechanism of deployment (i.e., enables you to send source code). 
  
 Platform as a service (PaaS) solutions often leverage Git for deploys, because it’s already a part of many 
 development flows. Instead of “pushing” your code to GitHub or BitBucket, the destination becomes a PaaS-like 
 Heroku, Azure, or Nodejitsu. Git is also used for continuous deployment and continuous integration 
  
 (e.g., TravisCI, CircleCI).
  
 Even when IaaS solutions are used, systems such as Chef (
 http://docs.opscode.com
 ) can be used.",NA
Installing Git,"To install Git for your OS, download a package from the official website (
 http://git-scm.com/downloads
 ). Then, 
 follow these steps:
  
 1. 
 In your terminal, type these commands, 
 substituting
 ""John Doe"" and johndoe@example.com 
 with your name and e-mail address:
  
 $ git config --global user.name ""John Doe"" 
  
 $ git config --global user.email johndoe@example.com
  
 2. 
  
 To check the installation, run:
  
 $ git version
  
 235",NA
Generating SSH Keys,"SSH keys provide a secure connection without the need to enter username and password every time. For GitHub 
 repositories, the latter approach is used with HTTPS URLs (e.g., 
 https://github.com/azat-co/rpjs.git
 ) and the 
 former with SSH URLs (e.g., 
 git@github.com:azat-co/rpjs.git
 ).
  
 To generate SSH keys for GitHub on Mac OS X/Unix machines, do the following:
  
 1. 
  
 Check for existing SSH keys:
  
 $ cd ~/.ssh 
  
 $ ls -lah
  
 2. 
  
 If you see some files like id_rsa (please refer to Figure 
 10-5
  for an example), you can 
  
 delete them or back them up into a separate folder by using the following 
 commands:
  
 $ mkdir key_backup 
  
 $ cp id_rsa* key_backup 
  
 $ rm id_rsa*
  
 236",NA
Creating a Local Git Repository ,"To create a GitHub repository, go to github.com (
 http://github.com/
 ), log in, and create a new repository. There will 
 be an SSH address; copy it. In your terminal window, navigate to the project folder to which you would like to push 
 GitHub. Then, do the following: 
  
 1. 
  
 Create a local Git and .git folder in the root of the project folder: 
  
  
  
 $ git init 
  
  
  
 Add all the files to the repository and start tracking them: 
 2. 
  
 $ git add
  
 3. 
  
 Make the first commit: 
  
  
 $ git commit -m ""initial commit""",NA
Pushing the Local Repository to GitHub ,"You can create a new repository in github.com via a web interface. Then, copy your newly created repo’s to the 
 Git SSH URI, which looks something like git@github.com:username/reponame.
  
 1. 
  
 Add the GitHub remote destination: 
  
  
 $ git remote add your-github-repo-ssh-url 
  
  
 It might look something like this: 
  
  
 $ git remote add origin git@github.com:azat-co/simple-message-board.git 
 2. 
  
 Now 
 everything should be set to push your local Git repository to the remote destination 
  
 on 
 GitHub with the following command: 
  
  
 $ git push origin master 
  
 3. 
  
 You should be able to see your files at github.com (
 http://github.com/
 ) under your 
  
 account and repository.
  
 Later, when you make changes to the file, there is no need to repeat all these steps. Just execute: 
 $ git add 
  
 $ git commit -am ""some message"" 
  
 $ git push origin master 
  
 If there are no new untracked files that you want to start tracking, type the following: 
  
 $ git commit -am ""some message"" 
  
 $ git push origin master
  
 239",NA
Running Tests in Cloud with TravisCI,"TravisCI is an SaaS continuous integration system that allows you to automate testing on each GitHub push (e.g., 
 $ git push origin master). Alternative services include Codeship (
 https://www.codeship.io
 ), CircleCI 
 (
 https://circleci.com
 ), and many others 
 www.quora.com
  (
 http://bit.ly/1ipdxxt
 ).
  
  
 TravisCI is more common among open-source projects and has a similar configuration to other systems, 
 i.e., a YAML file. In case of Node.js programs, it can look like this:
  
 language: node_js 
  
 node_js:
  
  - ""0.11""
  
  - ""0.10""
  
 In this configuration, 0.11 and 0.10 are versions of Node.js to use for testing. These multiple Node.js versions 
 are tested on a separate set of virtual machines (VMs). The following configuration file can be copied and used (it’s 
 recommended by TravisCI):
  
 language: node_js 
  
 node_js:
  
  - ""0.11""
  
  - ""0.10""
  
  - ""0.8""
  
  - ""0.6""
  
  
 NPM’s package.json has a property scripts.test that is a string to execute scripts, so we can put the mocha 
 command in it:
  
 echo '{""scripts"": {""test"": ""mocha test-expect.js""}}' > package.json",NA
TravisCI Configuration,"There’s no database in our application yet, but it’s good to prepare the TravisCI configuration right now. To add 
 a database to the TravisCI testing instance, use:
  
 services:
  
  - mongodb
  
 By default, TravisCI starts the MongoDB instance for us on the local host, port 27017:
  
 language: node_js 
  
 node_js:
  
  - ""0.11""
  
  - ""0.10""
  
  - ""0.8""
  
  - ""0.6"" 
  
 services:
  
  - mongodb
  
 That’s it! The test build will be synched on each push to GitHub.
  
  
 If your tests fail even locally right now, don’t despair, because that’s the whole point of TDD. In the next chapter, 
 we hook up the database and write more tests for fun.
  
  
 Because of the GitHub hooks to TravisCI, the test build should start automatically. On their completion, 
 contributors can get e-mail / Internet Relay Chat (IRC) notifications.",NA
Summary,"In this chapter, we briefly touched on environment variables, went through the basics of Git, and generated SSH keys. 
 We used Grunt for predeploy tasks such as concatenation, minification, and compilation; implemented clusters, 
 monitoring, error handling, and logging; and configured TravisCI to run tests.
  
  
 In the next chapter, we’ll proceed to cover the deployment of the app to PaaS (Heroku) and IaaS (Amazon Web 
 Services). We’ll also show basic examples of Nginx, Varnish Cache and Upstart configurations.
  
 241",NA
Chapter 11,NA,NA
Deploying Node.js Apps,"As we approach the end of the book, there’s a vital step we have to explore: the deployment itself. To help you 
 navigate between PaaS and IaaS options, and have some scripts you can use on your servers, we cover the following 
 topics:
  
 
  
 Deploying to Heroku (PaaS)
  
 
  
 Deploying to Amazon Web Services (AWS)
  
 
  
 Keeping Node.js apps alive with forever, Upstart, and init.d
  
 
  
 Serving static resources properly with Nginx
  
 
  
 Caching with Varnish",NA
Deploying to Heroku,"Heroku (
 http://www.heroku.com
 ) is a polyglot Agile application deployment Platform as a Service (PaaS). The 
 benefits of using PaaS over other cloud solutions include the following:
  
 1. 
  
 It’s easy to deploy, i.e., just one Git command to deploy $ git push heroku master.
  
 2. 
  
 It’s easy to scale, e.g., log in to Heroku.com and click a few options.
  
 3. 
  
 It’s easy to secure and maintain, e.g., no need to set up startup scripts manually.
  
 Heroku works similarly to Windows Azure (
 http://azure.microsoft.com/en-us
 ), Nodejitsu 
  
 (
 https://www.nodejitsu.com
 ), and many others in the sense that you can use Git to deploy applications. In other 
 words, Heroku uses ubiquitous Git as its deployment mechanism. This means that after becoming familiar with 
 Heroku and comfortable with Git, and after creating accounts with Windows Azure, Nodejitsu, and other PaaSs, 
 it’s fairly easy to deploy Node.js apps to them as well.
  
 To get started with the process, we need to follow these steps:
  
 1. 
  
 Install Heroku Toolbelt (
 https://toolbelt.heroku.com
 )—a bundle that includes Git and 
  
 other tools.
  
 2. 
  
 Log in to Heroku, which should upload a public SSH key file (e.g., id_rsa.pub) to the cloud 
  
 (i.e., heroku.com).
  
 243",NA
Deploying to Amazon Web Services,"Cloud is eating the world of computing. There are private and public clouds. AWS, probably the most popular choice 
 among the public cloud offerings, falls under the IaaS category. The advantages of using an IaaS such as AWS over 
 PaaS-like Heroku are as follows:
  
 1. 
  
 It’s more configurable (any services, packages, or operation systems).
  
 2. 
  
 It’s more controllable. There are no restrictions or limitations.
  
 3. 
  
 It’s cheaper to maintain. PaaS can quickly cost a fortune for high-performance resources.
  
 In this tutorial, we use 64-bit Amazon Linux AMI (
 http://aws.amazon.com/amazon-linux-ami
 ) with CentOS. It 
 might be easier to use the Extra Packages for Enterprise Linux (EPEL) package manager to install Node.js and NPM. If 
 you don’t have EPEL, skip to the manual C++ build instructions. 
  
 Assuming you have your Elastic Compute Cloud (EC2) instance up and running, make an SSH connection into it 
 and see if you have yum with EPEL (
 https://fedoraproject.org/wiki/EPEL
 ). To do so, just see if this command says 
 epel:
  
 yum repolist
  
 248",NA
"Keeping Node.js Apps Alive with forever, Upstart, and ",NA,NA
init.d,"This section relates only to IaaS deployment—another advantage to PaaS deployments. The reason why we need this 
 step is to bring the application back to life in case it crashes. Even if we have a master–child system, something needs 
 to keep an eye on the master itself. You also need a way to stop and start processes for maintenance, upgrades, and so 
 forth.
  
 Luckily, there’s no shortage of solutions to monitor and restart our Node.js apps:
  
 
  
 forever
  (
 https://github.com/nodejitsu/forever
 ): probably the easiest method. The forever 
  
 module is installed via NPM and works on almost any Unix OS. Unfortunately, if the server 
  
 itself fails (not our Node.js server, but the big Unix server), then nothing resumes forever.
  
 
  
 Upstart
  (
 http://upstart.ubuntu.com
 ): the most recommended option. It solves the problem 
  
 of starting daemons on startups, but it requires writing an Upstart script and having the latest 
  
 Unix OS version support for it. We’ll show you an Upstart script example for CentOS.
  
 
  
 init.d
  (
 http://www.unix.com/man-page/opensolaris/4/init.d
 ): an outdated analog of 
  
 Upstart. init.d contains the last startup script options for systems that don’t have Upstart 
  
 capabilities.",NA
forever,"forever is a module that allows us to start Node.js apps/servers as daemons and keeps them running 
 forever
 . Yes, 
 that’s right. If the node process dies for some reason, it brings it right back up! 
  
  
 forever  is a very neat utility because it’s an NPM module (very easy to install almost anywhere) and it’s very 
 easy to use without any extra language. A simple use case is as follows:
  
 $ sudo npm install forever –g 
  
 $ forever server.js",NA
Upstart Scripts,"“Upstart is an event-based replacement for the /sbin/init daemon that handles starting of tasks and services during 
 boot...”—the Upstart web site (
 http://upstart.ubuntu.com
 ). The latest CentOS (6.2+), as well as Ubuntu and Debian 
 OSs, come with Upstart. If Upstart is missing, try typing sudo yum install upstart to install it on CentOS, and try sudo 
 app-get install upstart for Ubuntu.
  
  
 A very basic Upstart script—to illustrate its structure—starts with 
 metadata: author      ""Azat"" 
  
 description ""practicalnode"" 
  
 setuid      ""nodeuser"" 
  
  
 We then start the application on startup after the file system and network: 
 start on (local-filesystems and net-device-up IFACE=eth0) 
  
  
 We stop the app on server shutdown: 
  
 stop on shutdown 
  
  
 We instruct Upstart to restart the program when it crashes: 
  
 respawn 
  
  
 We log events to /var/log/upstart/webapp.log: 
  
 console log
  
 253",NA
init.d,"If Upstart is unavailable, you can create an init.d script. init.d, which is a technology available on most Linux OSs. 
 Usually, development operations engineers resort to init.d when Upstart is not available and when they need 
 something more robust than forever. Without going into too much detail, Upstart is a newer alternative to init.d 
 scripts. We put init.d scripts into the /etc/ folder. 
  
  
 For example, the following init.d script for CentOS starts, stops, and restarts the node process / file 
 home/ nodejs/sample/app.js:
  
 #!/bin/sh
  
 # 
  
 # chkconfig: 35 99 99 
  
 # description: Node.js /home/nodejs/sample/app.js 
  
 #
  
 . /etc/rc.d/init.d/functions
  
 USER=""nodejs""
  
 DAEMON=""/home/nodejs/.nvm/v0.4.10/bin/node
 "" 
  
 ROOT_DIR=""/home/nodejs/sample""
  
 SERVER=""$ROOT_DIR/app.js"" 
  
 LOG_FILE=""$ROOT_DIR/app.js.log""
  
 255",NA
Serving Static Resources Properly with Nginx,"Although, it’s fairly easy to serve static files from Node.js applications, and we can use sendFile or Express.js static 
 middleware, it’s a big no-no for systems that require high performance. In other words, this step is optional but 
 recommended.
  
 The best option is to use Nginx (
 http://nginx.org
 ), Amazon S3 (
 http://aws.amazon.com/s3
 ) or CDNs, e.g., 
 Akamai (
 http://www.akamai.com
 ) or CloudFlare (
 https://www.cloudflare.com
 ), for the purpose for which they were 
 specifically designed, i.e., serving static content, and let Node.js apps handle interactive and networking tasks only. 
 This tactic decreases the load on Node.js processes and improves the efficiency of your system. 
  
 Nginx is a popular choice among development operations engineers. It’s an HTTP and reverse-proxy server. 
  
 To install Nginx on a CentOS system (v6.4+), type:
  
 sudo yum install nginx 
  
  
 As a side note, for Ubuntu, you can use the apt packaging tool: sudo apt-get install nginx. For more 
 information about apt, refer to the docs (
 https://help.ubuntu.com/12.04/serverguide/apt-get.html
 ). 
  
 But, let’s 
 continue with our CentOS example. We need to open the /etc/nginx/conf.d/virtual.conf file for editing, e.g., using 
 a VIM (Vi Improved) editor:
  
 sudo vim /etc/nginx/conf.d/virtual.conf 
  
 Then, we must add this configuration:
  
 server {
  
  
  location / {
  
  
  
  proxy_pass http://localhost:3000;
  
  
  }
  
  
  location /static/ {
  
  
  
  root /var/www/webapplog/public;
  
  
  } 
  
 }
  
  
 The first location block acts as a proxy server and redirects all requests that are not /static/* to the Node.js 
 app, which listens on port 3000. Static files are served from the /var/www/webapplog/public folder.
  
  
 If your project uses Express.js or a framework that’s built on top of it, don’t forget to set the trust proxy to true 
 by adding the following line to your server configuration:
  
 app.set('trust proxy', true);
  
  
 This little configuration enables Express.js to display true client IPs provided by proxy instead of proxy IPs. The 
 IP address is taken from the X-Forwarded-For HTTP header of requests (see next code snippet).
  
  
 A more complex example with HTTP headers in the proxy-server directive, and file extensions for static 
 resources, follows:
  
 server { 
  
  listen 0.0.0.0:80;
  
  server_name webapplog.com;
  
  access_log /var/log/nginx/webapp.log;
  
 257",NA
Caching with Varnish,"The last piece of the production deployment puzzle is setting up caching using Varnish Cache 
  
 (
 https://www.varnish-cache.org
 ). This step is optional for Node.js deploys, but, like a Nginx setup, it’s also 
 recommended, especially for systems that expect to handle large loads with the minimum resources consumed. 
  
 The idea is that Varnish allows us to cache requests and serve them later from the cache without hitting Nginx 
 and/or Node.js servers. This avoids the overhead of processing the same requests over and over again. In other 
 words, the more identical requests the server has coming, the better Varnish’s optimization. 
  
  
 Here’s a nice Varnish Cache video (
 http://youtu.be/x7t2Sp174eI
 ). It does a good job at summarizing the tool in 
 just less than three minutes. 
  
 Let’s use yum again, this time to install Varnish dependencies on CentOS:
  
 $ yum install -y gcc make automake autoconf libtool ncurses-devel libxslt groff pcre-devel pckgconfig libedit 
 libedit-devel
  
 Download the latest stable release (as of May 2014):
  
 $ wget http://repo.varnish-cache.org/source/varnish-3.0.5.tar.gz
  
 and build Varnish Cache with the following:
  
 $ tar -xvpzf varnish-3.0.5.tar.gz 
  
 $ cd varnish-3.0.5 
  
 $ ./autogen.sh 
  
 $ ./configure 
  
 $ make 
  
 $ make check 
  
 $ make install
  
 259",NA
Summary,"In this chapter, we covered deployment using the Git and Heroku command-line interfaces to deploy to PaaS. Then, 
 we worked through examples of installing and building a Node.js environment on AWS EC2, running Node.js apps 
 on AWS with CentOS. After that, we explored examples of forever, Upstart, and init.d to keep our apps running. 
  
 Last, we installed and configured Nginx to serve static content, including error pages, and split traffic between 
 multiple Node.js processes. Then, we added Varnish Cache to lighten the Node.js apps’ loads even more.
  
 260",NA
Chapter 12,NA,NA
Publishing Node.js Modules ,NA,NA
and Contributing to Open ,NA,NA
Source,"One of the key factors that contributed to the rapid growth of the Node.js module ecosystem is its open-source 
  
 nature and robust packaging systems (with registry). As of April 2013, JavaScript and Node.js had already surpassed 
  
 any other language/platform in the number of packages contributed per year (source) 
  
 (
 http://caines.ca/blog/programming/the-node-js-community-is-quietly-changing-the-face-of-open-source/
 ):
  
 
  
 Python: 1351 packages per year (29,720 packages in 22 years)
  
 
  
 Ruby: 3022 packages per year (54,385 packages in 18 years)
  
 
  
 Node.js: 
 6742 packages per year
  (26,966 packages in 4 years)
  
 This year’s (2014) numbers are even higher, and expectations are that, by mid 2014, Node.js will surpass other 
  
 platforms, in absolute numbers, with Maven and Rubygems being the top dogs (source) (
 http://modulecounts.com/
 ).
  
 Other factors that attribute to the Node.js popularity include:
  
 
  
 Ability to share code between front-end/browser and server-side (with projects such as 
  
 browserify (
 http://browserify.org/
 ) and ender.js) (
 https://github.com/ender-js/Ender
 )
  
 
  
 Philosophy of small (in terms of lines of code and functionality) functional modules vs. large, 
  
 standard/core packages (i.e., granularity)
  
 
  
 Evolving ECMAScript standard and expressive nature, and ease of adoption of the JavaScript 
  
 language
  
 With this in mind, many Node.js enthusiasts find it rewarding to contribute to the ever-growing open-source 
  
 community. When doing so, there are a few conventions to follow as well as concepts to understand:
  
 
  
 Recommended folder structure
  
 
  
 Required patterns
  
 
  
 package.json
  
 
  
 Publishing to NPM
  
 
  
 Locking versions",NA
Recommended Folder Structure,"Here is an example of a good, structured NPM module:
  
 Webapp
  
  /lib
  
   
  webapp.js
  
  index.js
  
  package.json
  
  README.md
  
 The index.js file does the initialization whereas lib/webapp.js has all the principal logic. If 
 you’re building a command-line tool, add the bin folder:
  
 Webapp
  
  /bin
  
   
  webapp-cli.js
  
  /lib
  
   
  webapp.js
  
  index.js
  
  package.json
  
  README.md
  
 Also, for the CLI module, add the following to package.json:
  
 ...
  
 ""bin"": {
  
  
  ""webapp"": ""./bin/webapp-cli.js"" 
  
 }, 
  
 ...
  
 The webapp-cli.js file starts with the line #! /usr/bin/env node, but then has normal Node.js code.
  
 It’s a good idea to add unit tests to your external module, which increases confidence and the likelihood of other 
 people using it. Some programmers go as far as not using a module that doesn’t have any tests! The added benefit is 
 that tests serve as a poor man’s examples and documentation.
  
 TravisCI, which we covered in previous chapters, allows free testing for open-source projects. Its badges, which 
 turn from red to green, depending on the status of tests (failing or passing), became the de facto standard of quality 
 and are often seen on the README pages of the most popular Node.js projects.",NA
Required Patterns,"There are a few common patterns for writing external (meant for use by other users, not just within your 
 app) modules:
  
 
  
 module.exports as a function pattern (recommended)
  
 
  
 module.exports as a class pattern (not recommended)
  
 
  
 module.exports as an object pattern
  
 
  
 exports.NAME pattern; which could be an object or a function
  
 262",NA
package.json,"Another mandatory part of an NPM module is its package.json file. The easiest way to create a new package.json file, if 
 you don’t have one yet (most likely you do), is to use $ npm init. The following is an example produced by this 
 command:
  
  ""name"": ""webapp"",
  
  ""version"": ""0.0.1"",
  
  ""description"": ""An example Node.js app"",
  
  ""main"": ""index.js"",
  
  ""devDependencies"": {},
  
  ""scripts"": {
  
  ""test"": ""test""
  
  },
  
  ""repository"": """",
  
  ""keywords"": [
  
  ""math"",
  
  ""mathematics"",
  
  ""simple""
  
  ],
  
  ""author"": ""Azat <hi@azat.co>"",
  
  ""license"": ""BSD"" 
  
 }
  
  
 The most important fields are name and version. The others are optional and self-explanatory, by name. The full 
 list of supported keys is located at the NPM web site. (
 https://www.npmjs.org/doc/json.html
 )
  
 ■
 Warnin
 g
  
 package.json
  must have double quotes around values and property names, unlike native 
 javascript 
  
 object literals.
  
  
 It’s worth noting that package.json and NPM do not limit their use. In other words, you are encouraged to add 
 custom fields and devise new conventions for their cases.",NA
Publishing to NPM,"To publish to NPM, we must have an account there. We do this by executing the following:
  
 $ npm adduser
  
 Then, simply execute from the project folder:
  
 $ npm publish
  
 Some useful NPM commands are as follows:
  
 
  
 $ npm tag NAME@VERSION TAG: tag a version
  
 
  
 $ npm version SEMVERSION: increment a version to the value of SEMVERSION 
 (semver) 
  
 (
 http://semver.org/
 ) and update package.json
  
 265",NA
Locking Versions,"The rule of thumb is that when we publish external modules, we don’t lock dependencies’ versions. However, when 
 we deploy apps, we lock versions in package.json. This is a common convention that many projects on NPM follow 
 (i.e., they don’t lock the versions). So, as you might guess, this may lead to trouble.
  
 Consider this scenario: We use Express.js that depends on, say, Jade of the latest version (*). Everything 
 works until, unknown to us, Jade is updated with breaking changes. Express.js now uses Jade that breaks our 
 code. No bueno.
  
 The solution: Commit node_modules! The following article describes nicely why committing your application’s 
 node_modules folder (not the one for the external module!) to Git repo is a good idea: 
 node_modules in git 
 (
 http://www.futurealoof.com/posts/nodemodules-in-git.html
 ).
  
 Why do this? Because, even if we lock dependency A in our package.json, most likely this module A has a wild 
 card * or version range in its package.json. Therefore, our app might be exposed to unpleasant surprises when an 
 update to the A module dependency breaks our system.
  
 One significant drawback is that binaries often need to be rebuilt on different targets (e.g., Mac OS X vs. Linux). 
  
 So, by skipping $ npm install and not checking binaries, development operations engineers have to use $ npm 
 rebuild on targets.
  
 On the other hand, the same problem might be mitigated by using $ npm shrinkwrap (official docs) 
  
 (
 https://www.npmjs.org/doc/cli/npm-shrinkwrap.html
 ). This command creates npm-shrinkwrap.json, which has 
 every
  subdependency listed/locked at the current version. Now, magically, $ npm install skips package.json and uses 
 npm-shrinkwrap.json instead!
  
 When running Shrinkwrap, be careful to have all the project dependencies installed and to have only them 
 installed (run $ npm install and $ npm prune to be sure). For more information about Shrinkwrap and locking 
 versions with node_modules, see the article by core Node.js contributors: “Managing Node.js Dependencies with 
 Shrinkwrap”. (
 http://blog.nodejs.org/2012/02/27/managing-node-js-dependencies-with-shrinkwrap/
 )",NA
Summary,"Open-source factors have contributed to the success and widespread use of the Node.js platform. It’s relatively easy 
 to publish a module and make a name for yourself (unlike other mature platforms with solid cores). We looked at 
 the recommended patterns and structures, and explored a few commands to get started with publishing modules to 
 NPM.
  
 266",NA
Practical Node.js,NA,NA
 Conclusion ,"Lo and behold, this is the end of the book. There was a study that showed that the majority of programmers read zero 
 books per year (source) (
 http://blog.codinghorror.com/programmers-dont-read-books-but-you-should/
 ). So, pat 
 yourself on the back, because you’re on the road to awesomeness when it comes to building Node.js web apps. 
 ☺ 
  
 Regarding the material covered in 
 Practical Node.js
 , we explored real-world aspects of the Node.js stack. To do 
 this, many things were essential, and by now you should have an awareness of how pieces fit together. For some 
 technologies such as Jade and REST API, our coverage was quite extensive. However, most of the packages are very 
 specific and tailored to our apps’ goals, so those topics were given a brief introduction, with references for further 
 learning. Here’s a list of topics we covered:
  
  
 
  
 Node.js and NPM setup and development tools
  
  
 
  
 Web apps with Express.js
  
  
 
  
 TDD with Mocha
  
  
 
  
  
 Jade and Handlebars
  
 
  
 MongoDB and Mongoskin
  
  
 
  
 Mongoose MongoDB ORM
  
  
 
  
 Session, token authentication, and OAuth with Everyauth
  
  
 
  
  
 REST APIs with Express and Hapi
  
 
  
 WebSockets with ws, Socket.IO, and DerbyJS
  
  
 
  
 Best practices for getting apps production ready
  
  
 
  
 Deployment to Heroku and AWS
  
  
 
  
 Structuring and publishing NPM modules",NA
Further Reading ,"If you enjoyed this book, you might like the programming blog about software engineering, startups, Agile 
 development, and Node.js: webapplog.com (
 http://webapplog.com
 ). You can also follow the author of this book on 
 Twitter at @azat_co (
 http://twitter.com/azat_co
 ) for tips and news about Node.js. 
  
 Here’s the list of other books by the author Azat Mardan:
  
 
 Pro Express.js
  (Apress, coming 2014) 
  
  
 Rapid Prototyping with JS
 : (
 http://rpjs.co/
 ) 
 Agile JavaScript Development
 
  
 
 Express.js Guide
 :(
 http://expressjsguide.com/
 )
  The Comprehensive Book on Express.js
 
  
 JavaScript and Node.js FUNdamentails
 : (
 http://leanpub.com/jsfun
 ) 
  A Collection of Essential 
 Basics
 
 ProgWriter
 : (
 http://progwriter.com/
 )
  Complete Guide to Publishing Programming Books",NA
Errata and Contacts ,"If you spotted any mistakes (I’m sure you did), please open an issue or even better fix it and make a pull request to the 
 GitHub repository of the book’s examples: 
 https://github.com/azat-co/practicalnode
 . For all other updates and 
 contact information, the canonical home of the Practical Node.js book on the Internet is 
 http://practicalnodebook.com
 .
  
 267",NA
Index,NA,NA
A ,NA,NA
C,"addListener method, 
 219 
  
 Content delivery networks (CDNs), 
 211 
 Amazon Web Services (AWS) 
  
  
 advantages, 
 248 
  
 Domain Name System, 
 251",NA
D,"EC2 instance, 
 250 
  
  
 EPEL, 
 248 
  
  
 HTTP traffic, 
 251 
  
  
 Node.js build, 
 250 
  
  
 NPM, 
 249–250 
  
  
 server.js, 
 250 
  
  
 yum command, 
 249 
  
 Application programming interface 
  
  
  
 (API), 
 17 
  
  
 array objects, 
 17 
  
  
 Math objects, 
 17 
  
  
 string objects, 
 17 
  
 Authentication, Blog, 
 132 
  
  
  
 destroy( ), 
 137 
  
  
  
 findOne function, 
 136 
  
  
  
 return keyword, 
 136 
  
 Authorization, 
 129,133
  
 DELETE method, 
 175,183 
  
 DerbyJS, 
 195 
  
  
 app 
  
  
  
 app.js code, 
 209 
  
  
  
 declaration, 
 208 
  
  
  
 DOM, 
 208 
  
  
  
 model.ref( ), 
 209 
  
  
  
 process.nextTick function, 
 209 
  
  
 snippetId route, 
 208 
  
  
 editor tryout, 
 212 
  
  
 package.json, 
 205 
  
  
 server-side code, 
 206 
  
  
 structure, 
 205 
  
  
 usage, 
 204 
  
  
 views, 
 210 
  
 Document Object Model (DOM), 
 208 
 Domain Name System (DNS), 
 251",NA
B ,NA,NA
E,"Behavior-driven development (BDD), 
 57 
 Blog, 
 132 
  
  
 authentication 
  
  
  
 destroy( ), 
 137 
  
  
  
 findOne function, 
 136 
  
  
  
 return keyword, 
 136 
  
  
 authorization, 
 133 
  
  
 running the app, 
 137 
  
  
 session middleware, 
 132
  
 Editor tryout, 
 212 
  
 Environment variables, 
 215 
  
 Error handling 
  
  
 addListener method, 
 219 
  
  
 Node.js domains, 
 221 
  
  
 onerror event listeners, 
 219 
  
  
 REST API, 
 220 
  
 Event logging, 
 230 
  
 Everyauth, 
 139",NA
F ,"Forever, 
 252
  
   
 Blog app, 
 45 
  
  
  
 admin page, 
 48 
  
  
  
 $.ajax( ) method, 
 47 
  
  
  
 elements, 
 46 
  
  
  
 REST API approach, 
 47 
  
  
  
 traditional server-side approach, 
 46 
  
 hello world creation, 
 48 
  
  
  
 app.js file, 
 51,54–55 
  
  
  
 app.set( ), 
 52 
  
  
  
 folder settup, 
 49 
  
  
  
 framework, 
 52 
  
  
  
 Jade syntax, 
 55 
  
  
  
 $ node app command, 
 56 
  
  
  
 node_modules folder, 
 51 
  
  
  
 NPM Init and package.json, 
 50 
  
  
  
 $ npm install, 
 50 
  
  
  
 require( ) method, 
 51 
  
  
  
 res.render( ), 
 54 
  
  
  
 VERB values, 
 53 
  
  
 HTTP methods and URLs, 
 35 
  
  
 if/else statements, 
 216 
  
  
 installation 
  
  
  
 Express.js Generator, 
 37 
  
  
  
 Express.js Version, 
 36 
  
  
  
 node_modules folder, 
 39 
  
  
  
 $ npm init terminal command, 
 38 
  
  
 $ npm ls command, 
 39–40 
  
  
  
 package.json file, 
 38–39 
  
  
 middleware, 
 33,36,217 
  
  
 mongoose, 
 162 
  
  
 MVC-like, 
 35 
  
  
 Node.js framework, 
 35 
  
  
 scaffolding 
  
  
  
 app.js middleware, 
 43 
  
  
  
 command-line interface, 
 40–41 
  
  
 creation, 
 40 
  
  
  
 Express.js App, configuration of, 
 44 
  
  
 Jade template engine, 
 44 
  
  
  
 routes, 
 43 
  
  
  
 terminal command, 
 40 
  
  
 session options, 
 217 
  
  
 tasks, 
 33 
  
  
 working principles, 
 36 
  
 Express.js usage, 
 4,91 
  
  
 __express method, 
 91 
  
  
 Handlebars, 
 92 
  
  
 Jade, 
 91 
  
  
 res.render method, 
 91 
  
 Express.js middleware, 
 129 
  
 Extra Packages for Enterprise 
  
  
  
  
 Linux (EPEL), 
 248
  
 270",NA
G,"GET method, 
 175,186 
  
 Git, 
 235 
  
  
 GitHub, 
 239 
  
  
 installation, 
 236 
  
  
 local repository creation, 
 239 
  
 PaaS, 
 235 
  
  
 SSH Keys, 
 236 
  
 Grunt 
  
  
 default task, 
 235 
  
  
 grunt.loadNpmTasks( ) 
  
  
  
 method, 
 231 
  
  
 HTTP requests, 
 232 
  
  
 jshint, 
 232–234 
  
  
 NPM installation, 
 231 
  
  
 uglify method, 
 232",NA
H,"Handlebars 
  
  
 comments, 
 87 
  
  
 custom helpers, 
 87 
  
  
 each iteration, 
 84 
  
  
 if condition, 
 85 
  
  
 includes/partials templates, 
 88 
  
 unescaped output, 
 84 
  
  
 unless statement, 
 85 
  
  
 usages, 
 89 
  
  
 With statement, 
 86 
  
 Handlebars expressions, 
 83 
  
 Handlebars syntax, 
 83 
  
 Hapi framework 
  
  
 database collection, 
 188 
  
  
 findOne method, 
 190 
  
  
 goals, 
 188 
  
  
 hapi-app.js coding, 
 191 
  
  
 hapi-app.js file creation, 
 188 
  
 loadCollection method, 
 189 
  
 server.route( ), 
 189 
  
  
 server.start( ) method, 
 191 
  
  
 URL parameter, 
 190 
  
 Heroku 
  
  
 configuration, 
 246 
  
  
 creation, 
 244 
  
  
 env file, 
 246–247 
  
  
 environment variables, 
 246 
  
  
 Git, 
 245,248 
  
  
 $ heroku login command, 
 244 
  
 MongoHQ URI, 
 248",NA
I ,"init.d script, 
 255",NA
"J, K","hooks, 
 59 
  
 installation, 
 57 
  
  
 BDD, 
 58 
  
  
 node_modules, 
 58 
  
  
 nyan reporter, 
 59 
  
  
 optional parameters, 
 58
  
  
 Jade, 
 71 
  
  
 add templates, 
 93 
  
  
  
 admin.jade, 
 101 
  
  
  
 article.jade, 
 97 
  
  
  
 index.jade, 
 95 
  
  
  
 layout.jade, 
 93 
  
  
  
 login.jade, 
 98 
  
  
  
 post.jade, 
 99 
  
  
 attributes, 
 73 
  
  
 block blockname, 
 79 
  
  
 case statement, 
 77 
  
  
 comments, 
 75 
  
  
 extend filename, 
 79 
  
  
 filters, 
 77 
  
  
 if statement, 
 76 
  
  
 include, 
 78 
  
  
 interpolation, 
 77 
  
  
 iterations, 
 76 
  
  
 JavaScript code, 
 75 
  
  
 literals, 
 74 
  
  
 mixins functions, 
 77 
  
  
 script/style tags, 
 74 
  
  
 tags, 
 71 
  
  
 text, 
 74 
  
  
 usages, 
 79 
  
  
 variables/locals, 
 72 
  
 JavaScript fundamentals. 
 See
  Node. js 
 JSON, 
 174
  
  
  
 TDD, 
 58 
  
  
 TDD assert, 
 57,60 
  
  
  
 array-type test, 
 61 
  
  
  
 chai assert, 
 62 
  
 Mocha hooks, 
 59 
  
 Mocha tool, 
 57 
  
 MongoDB, 
 103,113 
  
  
 bin folder, 
 105 
  
  
 installation, 
 103 
  
  
  
 data directory, 
 104 
  
  
  
 HomeBrew, 
 103 
  
  
 mongod service, 
 106 
  
  
 Node.js native driver, 
 108 
  
  
  
 library documentation, 
 111 
  
  
  
 mongo-native-insert.js file, 
 109 
  
  
  
 package.json file, 
 108 
  
  
  
 running sequence, 
 108 
  
  
 NoSQL database/non-relational databases, 
 103 
  
 shell commands, 
 107 
  
  
 storing blog, mongoskin, 
 113 
  
  
  
 add persistance (
 see
  Persistence) 
  
  
  
 add seed data, 
 113 
  
  
  
 admin page, 
 127 
  
  
  
 $ make db /$ make test, 
 126 
  
  
  
 mocha tests, 
 114 
  
  
  
 $ mongod service, 
 126 
  
  
  
 $ node app, 
 126 
  
 Mongoose, 
 149 
  
  
 custom instance method, 
 154",NA
L,"hooks, 
 154 
  
 installation, 
 150
  
  
 Locking versions, 
 266
  
 instance methods, 
 156 
  
 mongoose.model(name, schema), 
 155",NA
M,"nested documents, 
 158 
  
 population
  
  
 map( ) function, 
 178 
  
 Mocha, 
 57 
  
  
 BDD test, 
 65 
  
  
  
 boot method, 
 66 
  
  
  
 $ make test command, 
 68 
  
  
 $ mkdir tests, 
 65 
  
  
  
 $ mocha tests, 
 66 
  
  
  
 package.json file, 
 65 
  
  
  
 shutdown method, 
 66 
  
  
  
 test folder, 
 67
  
  
  
 populate method, 
 158 
  
  
  
 posts and user models, 
 157 
  
 Schema behavior, 
 161 
  
  
 standalone Mongoose script, 
 150 
  
 static methods, 
 154 
  
  
 static model methods, 
 155 
  
  
 True MVC, 
 162 
  
  
 virtual fields, 
 159 
  
 Mongoskin methods, 
 111 
  
  
 data validation, 
 113",NA
N ,"loose typing, 
 9 
  
  
 whitespaces, 
 14
  
 Native WebSocket, 
 196 
  
 Nginx, 
 257 
  
  
 HTTP header, 
 257 
  
  
 installation, CentOS system, 
 257 
  
  
 proxy-server configurations, 
 258 
  
  
 URL path, 
 258 
  
  
 VIM editor, 
 257 
  
 Node.js, 
 1,9 
  
  
 application programming interface, 
 17 
  
  
 array objects, 
 17 
  
  
  
 Math objects, 
 17 
  
  
  
 string objects, 
 17 
  
  
 arrays, 
 12 
  
  
 Buffer—Node.js, 
 10 
  
  
 callbacks, 
 21 
  
  
 code editor, 
 28 
  
  
 core modules, 
 18 
  
  
  
 fs module, 
 19 
  
  
  
 http module, 
 18 
  
  
  
 querystring module, 
 18 
  
  
  
 url module, 
 19 
  
  
  
 util module, 
 18 
  
  
 debugging, 
 22 
  
  
  
 alert( ) statements, 
 22 
  
  
  
 console.log( ), 
 22 
  
  
  
 debug commands, 
 23 
  
  
  
 Node inspector, 
 23 
  
  
 __dirname 
 vs
 . process.cwd, 
 16 
  
  
 file changes, 
 30 
  
  
 functions, 
 10 
  
  
  
 creation, 
 10 
  
  
  
 definition, 
 11 
  
  
  
 invocation 
 vs
 . expression, 
 12 
  
  
  
 parameters, 
 11 
  
  
 global space, 
 14 
  
  
  
 global scope, 
 15 
  
  
  
 modules, 
 15 
  
  
  
 process.pid, 
 14
  
  
 NPM installation, 
 20 
  
  
 object notation, 
 10 
  
  
 prototypal inheritance, 
 12 
  
 read and write, 
 20 
  
  
 streaming data, 
 20 
  
  
 utilities, 
 19 
  
  
 web development, IDES and 
  
  
 text editor, 
 29 
  
  
 webstorm IDE, 
 29–30 
  
 Node.js apps 
  
  
 forever, 
 252 
  
  
 init.d script, 
 255 
  
  
 upstart scripts, 
 253 
  
 Node.js OAuth, 
 138 
  
  
 Everyauth, 
 139 
  
  
 Twitter, 
 138 
  
 NPM commands, 
 265",NA
O,"OAuth 1.0, 
 140 
  
  
 Everyauth Twitter strategy 
  
  
  
 configuration, 
 141 
  
  
  
 with debug mode, 
 147 
  
  
  
 run the app, 
 146 
  
  
 sign-in with Twitter link, 
 141 
  
 Object relational mapping (ORM), 
 103,149 
 Open-source factors, 
 261 
  
  
 locking versions, 
 266 
  
  
 NPM commands, 
 265–266 
  
  
 package.json file, 
 265 
  
  
 patterns 
  
  
  
 class, 
 263 
  
  
  
 exports.NAME pattern, 
 264 
  
  
  
 function, 
 263 
  
  
  
 object, 
 264 
  
  
 recommended folder structure, 
 262
  
 Hello World server, 
 21 
  
 installation, 
 1 
  
  
 cloned Git repo, 
 5 
  
  
 HomeBrew/Macports, 
 3",NA
"P, Q ","Papertrail App, 
 230 
  
 Patterns
  
  
 Nave setup, 
 5 
  
 Node Version Manager (NVM), 
 6
  
 class, 
 263 
  
 exports.NAME pattern, 
 264
  
 one-click installer, 
 2 
  
 function, 
 263
  
 read–eval–print–loop (REPL), 
 7 
  
 object, 
 264
  
 272",NA
S,"Scaffolding 
  
  
 app.js middleware, 
 43 
  
  
 command-line interface, 
 40–41 
  
 creation, 
 40 
  
  
 Express.js App, configuration of, 
 44 
  
 Jade template engine, 
 44 
  
  
 routes, 
 43 
  
  
 terminal command, 
 40 
  
 Session-based authentication, 
 131 
  
  
 express.cookieParser( ), 
 131 
  
  
 express.session( ), 
 131 
  
 setMode( ) method, 
 211",NA
R,"setTheme( ) method, 
 211 
  
 Simple Object Access Protocol (SOAP), 
 174
  
  
 Read–eval–print–loop (REPL), 
 7,229 
  
 Recommended folder structure, 
 262 
  
 REST API servers, 
 173 
  
  
 approach, 
 173 
  
  
 characteristics of, 
 174 
  
  
 CRUD structure, 
 174 
  
  
 Hapi framework 
  
  
  
 database collection, 
 188 
  
  
  
 findOne method, 
 190 
  
  
  
 goals, 
 188 
  
  
  
 hapi-app.js coding, 
 191 
  
  
  
 hapi-app.js file creation, 
 188 
  
  
  
 loadCollection method, 
 189 
  
  
  
 server.route( ), 
 189 
  
  
  
 server.start( ) method, 
 191 
  
  
  
 URL parameter, 
 190 
  
  
 HTTP methods, 
 175 
  
  
 implementation 
  
  
  
 app.param( ) method, 
 181 
  
  
  
 coding, 
 183 
  
  
  
 DELETE method, 
 183 
  
  
  
 express.logger( ), 
 181 
  
  
  
 find( ), 
 182 
  
  
  
 GET method, 
 186 
  
  
  
 POST method, 
 187 
  
  
  
 PUT request handler, 
 182 
  
  
  
 TDD, 
 187 
  
  
  
 terminal window, 
 185 
  
  
 Mocha and Superagent, test coverage with 
  
  
 coding, 
 179 
  
  
  
 done( ), 
 178 
  
  
  
 error checking, 
 178 
  
  
  
 get( ), 
 178 
  
  
  
 HTTP request, 
 177 
  
  
  
 map( ) function, 
 178 
  
  
  
 test/index.js file, 
 177 
  
  
  
 usage, 
 176 
  
  
 NPM, 
 175 
  
  
 $ npm install command, 
 176
  
 Socket.IO, 
 195,218 
  
  
 and Express.js 
  
  
  
 catching and processing, 
 201 
  
  
  
 HTTP requests, 
 202 
  
  
  
 Jade template, 
 204 
  
  
  
 messageChange event listener, 
 203 
  
  
 package.json and $ npm install, 
 202 
  
  
 server logs, 
 200 
  
  
 in production, 
 218–219",NA
T,"Template engines, 
 71 
  
  
 Handlebars 
  
  
  
 comments, 
 87 
  
  
  
 custom helpers, 
 87 
  
  
  
 each iteration, 
 84 
  
  
  
 expressions, 
 83 
  
  
  
 Express.js 
 4,92 
  
  
  
 if condition, 
 85 
  
  
  
 includes/partials templates, 
 88 
  
  
 syntax, 
 83 
  
  
  
 unescaped output, 
 84 
  
  
  
 unless statement, 
 86 
  
  
  
 usages, 
 88 
  
  
  
 With statement, 
 86 
  
  
 Jade, 
 71 
  
  
  
 admin.jade, 
 101 
  
  
  
 aticle.jade, 
 97 
  
  
  
 attributes, 
 73 
  
  
  
 block blockname, 
 79 
  
  
  
 case statement, 
 77 
  
  
  
 comments, 
 75 
  
  
  
 Express.js 
 4,91 
  
  
  
 extend filename, 
 79 
  
  
  
 filters, 
 77 
  
  
  
 if statement, 
 76 
  
  
  
 include, 
 78 
  
  
  
 index.jade, 
 95",NA
U ,"Upstart scripts, 
 253",NA
V ,"Varnish cache, 
 259 
  
 Views, 
 210 
  
 Virtual fields, 
 159
  
   
  
 script/style tags, 
 74 
  
  
  
 syntax and features, 
 71 
  
  
  
 tags, 
 71 
  
  
  
 text, 
 74 
  
  
  
 usages, 
 79 
  
  
  
 variables/locals, 
 72 
  
 Test-driven development (TDD), 
 57 
 Token-based authentication, 
 130 
 TravisCI 
  
  
 configuration file, 
 240–241 
  
  
 definition, 
 240 
  
  
 $ make test command, 
 241
  
 274",NA
"W, X, Y, Z","WebSocket, 
 195 
  
  
 browser implementation 
  
  
  
 HTML tags, 
 196–197 
  
  
  
 script tag, 
 196 
  
  
 definition, 
 195 
  
  
 Node.js Server, 
 197 
  
  
 polling, 
 195 
  
 Winston, 
 230",NA
Practical Node.js ,NA,NA
Building Real-World Scalable Web Apps,NA,NA
Azat Mardan,NA,NA
Contents,"About the Author 
 xv
  
 About the Technical Reviewer 
 xvii
  
 Acknowledgments 
 xix
  
 Introduction 
 xxi
  
 ■
  
 Chapter 1: Setting up Nodejs and Other Essentials
  
 1
  
 Installing Node.js and NPM 
 ...........................................................................................................
 1 
 One-Click 
 Installers 
 ...............................................................................................................................................
 2 
 Installing with HomeBrew or MacPorts 
 .................................................................................................................
 3 
 Installing from a Tar File 
 ........................................................................................................................................
 4 
 Installing 
 Without sudo 
 ..........................................................................................................................................
 4 
 Installing 
 from a Git Repo 
 ......................................................................................................................................
 5 
 Multiversion 
 Setup with Nave ................................................................................................................................
 5 
 Multiversion Setup with NVM 
 ................................................................................................................................
 6 
 Alternative 
 Multiversion Systems ..........................................................................................................................
 6 
 Checking the Installation 
 .......................................................................................................................................
 7 
 Node.js 
 Console (REPL) 
 ..........................................................................................................................................
 7 
 Launching Node.js Scripts",NA
About the Author,"Azat Mardan
  has more than a dozen years of experience in web, mobile, and 
 software engineering. With a Bachelor’s degree in informatics and a Master of 
 Science degree in information systems technology, Azat possesses deep academic 
 knowledge as well as extensive practical experience.
  
 Currently, Azat works as a team lead/senior software engineer at DocuSign, 
 where his team rebuilds 50 million user products (DocuSign web app) using the 
 technical cutting-edge stack of Node.js, Express.js, Backbone.js, CoffeeScript, Jade, 
 Stylus, and Redis. 
  
 Previously Azat worked as a senior software engineer at Storify.com (acquired 
 in 2013), National Center for Biotechnology Information, Federal Deposit 
 Insurance Corporation, Lockheed Martin, and others. He taught programming 
 classes at 
  
  
 Marakana (acquired in 2013), pariSOMA, General Assembly San Francisco, and 
  
 Hack Reactor to much acclaim. In his spare time, Azat writes about technology on 
 his blog 
 webapplog.com
 . He is also the author of four other books on JavaScript and Node.js, including Amazon’s #1 
 Best Seller in the Client Server category: 
 Rapid Prototyping with JS: Agile JavaScript Development
 . 
  
  
 Azat is the creator of open-source Node.js projects: ExpressWorks, mongoui, HackHall, and 
 NodeFramework.com
 , as well as a contributor to Express, OAuth, jade-browser, and other Node Package Manager 
 modules.
  
 xv",NA
About the Technical Reviewer,"Peter Elst
  is a web standards enthusiast with a multimedia and application 
 development background. He works as a web solutions engineer in creative 
 innovation at Google. 
  
 With well more than a decade of experience, Elst is a regular technical 
 reviewer; has co-authored a number of books, including 
 HTML5 Solutions: Essential 
 Techniques for HTML5 Developers
 ; and is a well-respected speaker at many 
 industry events. You can find out more about his latest interests and ongoing 
 projects on his personal blog 
 peterelst.com
 . 
  
 xvii",NA
Acknowledgments,"I convey my gratitude to all the wonderful people I have encountered during my software engineering career. These 
 people supported, mentored, and trusted me with new challenges, helped me to find mistakes, and pushed my limits.
  
  
 Of course, this book wouldn’t be possible without the assistance, research, and championing done by my Apress 
 editors. I especially thank Ben Renow-Clarke, Christine Ricketts, James Markham, Cat Ohala, and Peter Elst.
  
 Also, many thanks and appreciation go to the readers who kindly provided feedback to the alpha version of 
 Practical Node.js
 , my webapplog.com (
 http://webapplog.com
 ) blog posts, and my prior books 
  
 (
 http://webapplog.com/books
 ).
  
 xix",NA
