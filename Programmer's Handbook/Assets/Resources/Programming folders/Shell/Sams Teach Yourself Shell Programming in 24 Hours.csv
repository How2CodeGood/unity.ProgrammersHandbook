Larger Text,Smaller Text,Symbol
Sams Teach Yourself Shell Programming in 24 Hours,"Copyright
  
 Introduction
  
 G
 How This Book Is Organized 
  
 G
 Conventions Used in This Book 
  
 G
 About the Author 
  
 G
 Dedication 
  
 G
 Acknowledgments
  
 Part I   Introduction to UNIX and Shell Tools
  
 Hour 1: Shell Basics
  
 G
 What Is a Command? 
  
 G
 What Is the Shell?
  
 G
 Summary 
  
 G
 Questions 
  
 G
 Terms
  
 Hour 2: Script Basics
  
 G
 The UNIX System 
  
 G
 Shell Initialization 
  
 G
 Getting Help 
  
 G
 Summary 
  
 G
 Questions 
  
 G
 Terms
  
 Hour 3: Working with Files
  
 G
 Listing Files 
  
 G
 Viewing the Content of a File 
  
 G
 Manipulating Files 
  
 G
 Summary 
  
 G
 Questions 
  
 G
 Terms
  
 Hour 4: Working With Directories",NA
Copyright,NA,NA
Sams Teach Yourself Shell Programming in 24 Hours ,"Copyright © 1999 by Sams Publishing 
  
 All rights reserved. No part of this book shall be reproduced, stored in a retrieval system, or transmitted by 
 any means, electronic, mechanical, photocopying, recording, or otherwise, without written permission from 
 the publisher. No patent liability is assumed with respect to the use of the information contained herein. 
 Although every precaution has been taken in the preparation of this book, the publisher and author assume 
 no responsibility for errors or omissions. Neither is any liability assumed for damages resulting from the use 
 of the information contained herein. 
  
 International Standard Book Number: 0-672-31481-9 
  
 Library of Congress Catalog Card Number: 98-89272 
  
 Printed in the United States of America 
  
 First Printing: March 1999 
  
 01 00 99 
  
 4 3 2 1 
  
 Trademarks
  
 All terms mentioned in this book that are known to be trademarks or service marks have been appropriately 
 capitalized. Sams cannot attest to the accuracy of this information. Use of a term in this book should not be 
 regarded as affecting the validity of any trademark or service mark. 
  
 Warning and Disclaimer 
  
 Every effort has been made to make this book as complete and as accurate as possible, but no warranty or 
 fitness is implied. The information provided is on an ""as is"" basis. The authors and the publisher shall have 
 neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the 
 information contained in this book or from the use of the programs accompanying it. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Copyright
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Introduction ,"In recent years, the UNIX operating system has seen a huge boost in its popularity, especially with the 
 emergence of Linux. For programmers and users of UNIX, this comes as no surprise: UNIX was designed to 
 provide an environment that's powerful yet easy to use. 
  
 One of the main strengths of UNIX is that it comes with a large collection of standard programs. These 
 programs perform a wide variety of tasks from listing your files to reading email. Unlike other operating 
 systems, one of the key features of UNIX is that these programs can be combined to perform complicated 
 tasks and solve your problems. 
  
 One of the most powerful standard programs available in UNIX is the shell. The 
 shell
  is a program that 
 provides you with a consistent and easy-to-use environment for executing programs in UNIX. If you have 
 ever used a UNIX system, you have interacted with the shell. 
  
 The main responsibility of the shell is to read the commands you type and then ask the UNIX kernel to 
 perform these commands. In addition to this, the shell provides sophisticated programming constructs that 
 enable you to make decisions, repeatedly execute commands, create functions, and store values in 
 variables. 
  
 This book concentrates on the standard UNIX shell called the Bourne shell. When Dennis Ritche and Ken 
 Thompson were developing much of UNIX in the early 1970s, they used a very simple shell. The first real 
 shell, written by Stephen Bourne, appeared in the mid 1970s. The original Bourne shell has changed slightly 
 over the years; some features were added and others were removed, but its syntax and its resulting power 
 have remained the same. 
  
 The most attractive feature of the shell is that it enables you to create scripts. 
 Scripts
  are files that contain a 
 list of commands you want to run. Because every script is contained in a file and every file has a name, 
 scripts enable you to combine existing programs to create completely new programs that solve your 
 problems. This book teaches you how to create, execute, modify, and debug shell scripts quickly and easily. 
  
 After you get used to writing scripts, you will find yourself solving more and more problems with them.",NA
How This Book Is Organized ,"About the Examples
  
 I assume that you have some familiarity with UNIX and know how to log in, create and edit files, and work 
 with files and directories to a limited extent. If you haven't used UNIX in a while or you aren't familiar with 
 one of these topics, don't worry. The first part of this book reviews this material thoroughly. 
  
 This book is divided into three parts:",NA
About the Examples ,"As you work through the chapters, try typing in the examples to get a better feeling of how the computer 
 responds and how each command works. After you get an example working, try experimenting with the 
 example by changing commands. Don't be afraid to experiment. Experiments (both successes and failures) 
 teach you important things about UNIX and the shell.",NA
Conventions Used in This Book ,"Features in this book include the following: 
  
  
 Note -
  Notes give you comments and asides about the topic at hand, as well as full explanations of certain 
  
 concepts. 
  
  
 Tip -
  Tips provide great shortcuts and hints on how to program in shell more effectively. 
  
  
 Caution -
  Cautions warn you against making your life miserable and avoiding the pitfalls in programming. 
  
 Paragraphs containing new terms feature the New Term icon. The new term appears in 
 italic
 .
  
 At the end of each chapter, you'll find a handy Summary and a Quiz section (with answers found in 
 Appendix C
 ). Many times, you'll also find a Terms section. 
  
 In addition, you'll find various typographic conventions throughout this book: 
  
 G
 Commands, variables, directories, and files appear in text in a special 
 monospaced font 
 .
  
 G
 Commands and such that you type appear in 
 boldface type 
 .
  
 G
 Placeholders in syntax descriptions appear in a 
 monospaced italic 
 typeface. This indicates that 
 you will replace the placeholder with the actual filename, parameter, or other element that it 
 represents. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Introduction 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How This Book Is Organized
  
 Dedication
  
 Conventions Used in This Book
  
 Acknowledgments
  
 About the Author
  
 © Copyright Macmillan USA. All rights reserved.",NA
About the Author ,"Sriranga Veeraraghavan 
 works in the Enterprise Network Management group at Cisco Systems, Inc. He 
 has several years of experience developing software in C, Java, Perl, and Bourne Shell and has contributed 
 to several books, including UNIX Unleashed and Special Edition Using UNIX. Sriranga graduated from the 
 University of California at Berkeley in 1997 with a degree in engineering and is currently pursuing further 
 studies at Stanford University. Among other interests, Sriranga enjoys mountain biking, classical music, and 
 playing Marathon with his brother Srivathsa. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Introduction 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How This Book Is Organized
  
 Dedication
  
 Conventions Used in This Book
  
 Acknowledgments
  
 About the Author
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Dedication,"For my grandmother, who taught me to love the English language. 
  
 For my mother, who taught me to love programming languages. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Introduction 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How This Book Is Organized
  
 Dedication
  
 Conventions Used in This Book
  
 Acknowledgments
  
 About the Author
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Acknowledgments,"Writing a book on shell programming is a daunting task, due to the myriad of UNIX versions and shell 
 versions that are available. Thanks to the work of my development editor Hugh Vandivier and my technical 
 editor Aron Hsiao, I was able to make sure the book covered all the material completely and correctly. Their 
 suggestions and comments have helped me enormously. 
  
 In addition to the technical side of the book, many things about the publishing process were new to me. 
 Thanks to my acquisitions editor Gretchen Ganser and my executive editor Jeff Koch for handling all of the 
 editorial issues and patiently working with me to keep this book on schedule. I would also like to thank Jane 
 Brownlow who got me started on this project. 
  
 Working on a book takes a lot of time from work, as I found out. Thanks to the cooperation and 
 understanding of my managers Pat Shriver and Larry Coryell, I was able to balance work and authoring. I 
 know there is a thing called regular work, Pat. I'll get to it soon. I promise. 
  
 I need to thank my parents; my brother, Srivathsa; and my aunt and uncle, Srinivasa and Suma; who put off 
 family activities so that I could finish this book. I promise we'll go to Lake Tahoe next year. Also thanks to my 
 cousin's wife, Katherine, who wanted to see her name in my book. 
  
 Thanks to everyone else on the excellent team at Sams who worked on this book. Without their support, this 
 book would not exist. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Introduction 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How This Book Is Organized
  
 Dedication
  
 Conventions Used in This Book
  
 Acknowledgments
  
 About the Author
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 1 ,NA,NA
Shell Basics ,"My father has a tool chest that holds all his woodworking tools, from screwdrivers and chisels to power 
 sanders and power drills. He has used these tools to build several desks, a shed, a bridge, and many toys. 
  
 By applying the same tools, he has been able to build all the different elements required for his projects. 
  
  Shell scripting is similar to a woodworking project. To build something out of wood, you need to 
 use the right tools. In UNIX, the tools you use are called 
 utilities
  or 
 commands
 . There are simple commands 
 like 
 ls
  and 
 cd
 , and there are power tools like 
 awk
 , 
 sed
 , and the shell. 
  
 One of the biggest problems in woodworking is using the wrong tool or technique while building a project. 
 Knowing which tool to use comes from experience. In this book, you will learn how to use the UNIX tools via 
 examples and exercises. 
  
 The simple tools are easy to learn. You probably already know how to use many of them. The power tools 
 take longer to learn, but when you get the hang of them, you'll be able to tackle any problem. This book 
 teaches you how to use both the simple tools and the power tools. The main focus is on the most powerful 
 tool in UNIX, the shell. 
  
 Before you can build things using the shell, you need to learn some basics. This chapter looks at the 
 following topics: 
  
 G
 Commands 
  
 G
 The shell 
  
 It's time to get started.",NA
What Is a Command? ,"Simple Commands 
  
 Compound Commands
  
 Complex Commands 
  
 Command Separators
  
  In UNIX, a 
 command
  is a program that you can run. In other operating systems, such as Mac OS 
 or Windows, you point to the program you want to run and click it. To run a command in UNIX, you type its 
 name and press Enter.
  
 For example:",NA
Simple Commands ,"The 
 who
  and 
 date
  commands are examples of 
 simple
  commands. A simple command is one 
 that you can execute by just giving its name at the prompt: 
  
 $ 
 command
  
 Here, 
 command
  is the name of the command you want to execute. Simple commands in UNIX can be small 
 commands like 
 who
  and 
 date
 , or they can be large commands like a Web browser or a spreadsheet 
 program.You can execute most commands in UNIX as simple commands.",NA
Complex Commands ,"You can use the 
 who
  command to gather information about yourself when you execute it as follows: 
  
 $ who am i 
  
 ranga      pts/0        Dec  9 08:49 
  
 $ 
  
 This tells me the following information: 
  
 G
 My username is 
 ranga
 .
  
 G
 I am logged in to the terminal 
 pts/0
 . 
  
 G
 I logged in at 8:49 on Dec 9. 
  
  This command also introduces the concept of a 
 complex
  command, which is a command that 
 consists of a command name and a list of arguments. 
  
  Arguments
  are command modifiers that change the behavior of a command. In this case, the 
 command name is 
 who
 , and the arguments are 
 am
  and 
 i
 .
  
  When the 
 who
  command runs as a simple command, it displays information about everyone who 
 is logged in to a UNIX system. The output that is generated when a command runs as a simple command is 
 called the 
 default
  behavior of that command. 
  
 The arguments 
 am
  and 
 i
  change the behavior of the 
 who
  command to list information about you only. In 
 UNIX, most commands accept arguments that modify their behavior. 
  
 The formal syntax for a complex command is: 
  
 $ 
 commandargument1argument2argument3
  ... 
 argumentN
  
 Here, 
 command
  is the name of the command you want to execute, and 
 argument1
  through 
 argumentN 
 are the arguments you want to give 
 command
 .",NA
Compound Commands ,"One of the most powerful features of UNIX is the capability to combine simple and complex commands 
 together to obtain 
 compound
  commands. 
  
 A compound command consists of a list of simple and complex commands separated by the 
 semicolon character ( 
 ;)
 . An example of a complex command is 
  
 $ date ; who am i ; 
  
 Wed Dec  9 10:10:10 PST 1998",NA
Command Separators ,"The semicolon character ( 
 ;
 ) is treated as a command 
 separator
 , which indicates where one 
 command ends and another begins. 
  
 If you don't use it to separate each of the individual commands in a complex command, the computer will 
 not be able to tell where one command ends and the next command starts. If you execute the previous 
 example without the first semicolon 
  
 $ date who am i
  
 an error message similar to the following will be produced: 
  
 date: bad conversion
  
 Here, the 
 date
  command thinks that it is being run as a complex command with the arguments 
 who
 , 
 am, 
 and 
 i
 . The date command is confused by these arguments and displays an error message. When using 
 complex commands, remember to use the semicolon character. 
  
 You can also terminate individual simple and complex commands using the semicolon character. For 
 example, the commands",NA
What Is the Shell? ,"The Shell Prompt
  
 Different Types of Shells
  
 In the preceding section, I explained that when you type the command 
  
 $ date
  
 the computer executes the 
 date
  command and displays the result. 
  
 But how does the computer know that you wanted to run the command 
 date
 ?
  
 The computer uses a special program called the 
 shell
  to figure this out. The shell provides you 
 with an interface to the UNIX system. It gathers input from you and executes programs based on that input. 
 When a program finishes executing, it displays that program's output. 
  
 For this reason, the shell is often referred to as the UNIX system's 
 command interpreter
 . For users familiar 
 with Windows, the UNIX shell is similar to the DOS shell, 
 COMMAND.COM
 .
  
 The real power of the UNIX shell lies in the fact that it is much more than a command interpreter. It is also a 
 powerful programming language, complete with conditional statements, loops, and functions. 
  
 If you are familiar with these types of statements from other programming languages, great. You'll pick up 
 shell programming quickly. If you haven't seen these before, don't fret. By the time you finish this book, you'll 
 know how to use each of these statements.",NA
The Shell Prompt ,"The prompt, 
 $
 , which was discussed in the beginning of this chapter, is issued by the shell. 
  
 While the prompt is displayed, you can type a command. The shell reads your input after you press Enter. It 
 determines the command you want executed by looking at the first 
 word
  of your input. A word is an unbroken 
 set of characters. Spaces and tabs separate words. 
  
 To the shell, your input looks like the following: 
  
 $ 
 word1word2word3
  ... 
 wordN
  
 The shell always picks 
 word1
  as the name of the command you want executed. If there is only one word",NA
Different Types of Shells ,"You might notice that your prompt looks slightly different than the 
 $
  prompt I am using. The actual prompt 
 that is displayed depends on the type of shell you are using. 
  
 In UNIX there are two major types of shells: 
  
 G
 The Bourne shell (includes 
 sh
 , 
 ksh
 , and 
 bash
 ) 
  
 G
 The C shell (includes 
 csh
  and 
 tcsh
 )
  
 If you are using a Bourne-type shell, the default prompt is the 
 $
  character. If you are using a C-type shell, 
 the default prompt is the 
 %
  character. This book covers only Bourne-type shells because the C-type shells 
 are not powerful enough for shell programming. 
  
 Note -
  In UNIX there are two types of accounts, regular user accounts and the root account. Normal users are given 
 regular user accounts. The root account is an account with special privileges the administrator of a UNIX system 
 (called the 
 sysadmin
 ) uses to perform maintenance and upgrades. 
  
  
 If you are using the root account, both the Bourne and C shells display the 
 #
  character as a prompt. Be 
  
 extremely careful when executing commands as the root user because your commands effect the whole 
  
 system. 
  
  
 None of the examples in this book require that you have access to the root account to execute them. 
  
 The different Bourne-type shells follow:
  
 G
 Bourne shell ( 
 sh
 ) 
  
 G
 Korn shell ( 
 ksh
 ) 
  
 G
 Bourne Again shell ( 
 bash
 ) 
  
 G
 POSIX shell ( 
 sh
 )
  
 The different C-type shells follow:
  
 G
 C shell ( 
 csh
 ) 
  
 G
 TENEX/TOPS C shell ( 
 tcsh
 )
  
 Unless explicitly noted, the examples and exercise answers in this book will work with any Bourne-type shell. 
  
 The Original Bourne Shell",NA
Summary,"In this chapter, you looked at the shell basics. You saw how to execute simple commands, complex 
 commands, and compound commands. You also covered the concept of a shell along with descriptions of 
 the different shells that you are likely to encounter. 
  
 In the next chapter, 
 ""Script Basics,""
  you explore the function of the shell in greater detail, starting with its 
  
 use, interactively. I then show you how to use the shell for shell scripts. 
  
 One chapter down, only 23 more to go until you are a shell programming expert. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 1: Shell Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 What Is a Command?
  
 Questions
  
 What Is the Shell?
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Classify each of the following as simple, complex, or compound commands: 
  
  $ ls
  
  $ date ; uptime
  
  $ ls -l 
  
  $ echo ""hello world""
  
 If you haven't seen some of these commands before, try them out on your system. As you progress 
 through the book, each will be formally introduced. 
  
 2. 
 What is the effect of putting a semicolon at the end of a single simple command or a complex 
 command? 
  
 For example, will the output of the following commands be different? 
  
 $ who am i 
  
 $ who am i ;
  
 3. 
 What are the two major types of shells? Give an example of a shell that falls into each type. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 1: Shell Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 What Is a Command?
  
 Questions
  
 What Is the Shell?
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Commands
   A command is a program you can run. To run a command, type its name and press Enter. 
  
 Prompts
   When you see a prompt, type the name of a command and press Enter. In this book, the 
 $ 
 character is used to indicate the prompt. 
  
 Simple Commands 
   A simple command is a command that you can execute by giving its name at the 
 prompt. 
  
 Default Behavior 
   The output that is generated when a command runs as a simple command is called the 
 default behavior of that command. 
  
 Complex Commands 
   A complex command is a command that consists of a command name and a list of 
 arguments. 
  
 Arguments
   Arguments are command modifiers that change the behavior of a command. 
  
 Compound Commands 
   A compound command consists of a list of simple and complex commands 
 separated by the semicolon character ( 
 ;
 ).
  
 Command Separators 
   A command separator indicates where one command ends and another begins. 
 The most common command separator is the semicolon character ( 
 ;
 ).
  
 Shell
   The shell provides you with an interface to the UNIX system. It gathers input from you and executes 
 programs based on that input. When a program has finished executing, it displays that program's output. 
 The shell is sometimes called a command interpreter. 
  
 Words
   A word is an unbroken set of characters. The shell uses spaces and tabs to separate words. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 1: Shell Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 What Is a Command?
  
 Questions
  
 What Is the Shell?
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 2 ,NA,NA
Script Basics,"In 
 Chapter 1, ""Shell Basics,""
  I introduced the concept of a shell and commands. I showed you how the shell 
  
 reads your input and executes the command you requested. 
  
 In this chapter I will explain in detail what the shell is and how it works. You will learn how the shell is started 
 during the login process and what happens when you log out. 
  
 After I explain this behavior, I will show you how to group commands that are normally executed interactively 
 into a file to create a script. Scripts are the power behind the shell because they enable you to group 
 commands together to create new commands.",NA
The UNIX System ,"Logging In
  
 The UNIX system consists of two components: 
  
 G
 Utilities 
  
 G
 The kernel 
  
  Utilities
  are programs you can run or execute. The programs 
 who
  and 
 date
  that you saw in the 
 previous chapter are examples of utilities. Almost every program that you know is considered a utility. 
  
  Commands
  are slightly different than utilities. The term 
 utility
  refers to the name of a program, 
 whereas the term 
 command
  refers to the program and any arguments you specify to that program to change 
 its behavior. You might see the term 
 command
  used instead of the term 
 utility
  for simple commands, where 
 only the program name to execute is given. 
  
 The kernel is the heart of the UNIX system. It provides utilities with a means of accessing a machine's 
 hardware. It also handles the scheduling and execution of commands. 
  
 When a machine is turned off, both the kernel and the utilities are stored on the machine's hard disks. But 
 when the computer is booted, the kernel is loaded from disk into memory. The kernel remains in memory 
 until the machine is turned off. 
  
 Utilities, on the other hand, are stored on disk and loaded into memory only when they are executed. For",NA
Logging In ,"When you first connect to a UNIX system, you usually see a prompt such as the following: 
  
 login:
  
 You need to enter your username at this prompt. After you enter your username, another prompt is 
 presented: 
  
 login: ranga 
  
 Password: 
  
 You need to enter your password at this prompt. 
  
 These two prompts are presented by a program called 
 getty
 . These are its tasks: 
  
 1. 
 Display the prompt 
 login
 .
  
 2. 
 Wait for a user to type a username. 
  
 3. 
 After a username has been entered, display the password prompt. 
  
 4. 
 Wait for a user to enter a password. 
  
 5. 
 Give the username and password entered by the user to the 
 login
  command and exit.",NA
Shell Initialization ,"Interactive Versus Noninteractive Shells 
  
 Making a Shell Script Executable
  
 Initialization File Contents
  
 When the login program executes a shell, that shell is 
 uninitialized
 . When a shell is uninitialized, important 
 parameters required by the shell to function correctly are not defined. 
  
 The shell undergoes a phase called 
 initialization
  to set up these parameters. This is usually a two step 
 process that involves the shell reading the following files:
  
 G
 /etc/profile 
  
 G
 profile
  
 The process is as follows: 
  
 1. 
 The shell checks to see whether the file 
 /etc/profile
  exists. 
  
 2. 
 If it exists, the shell reads it. Otherwise, this file is skipped. No error message is displayed. 
  
 3. 
 The shell checks to see whether the file 
 .profile
  exists in your home directory. Your 
 home 
 directory 
 is the directory that you start out in after you log in. 
  
 4. 
 If it exists, the shell reads it; otherwise, the shell skips it. No error message is displayed. 
  
 As soon as both of these files have been read, the shell displays a prompt: 
  
 $
  
 This is the prompt where you can enter commands in order to have them execute. 
  
  
 Note -
  The shell initialization process detailed here applies to all Bourne type shells, but some additional 
  
 files are used by 
 bash
  and 
 ksh
 . 
  
  
 You can obtain more information about this process for a particular shell using the 
 man
  command 
 explained later in this chapter.",NA
Interactive Versus Noninteractive Shells ,"When the shell displays a prompt for you, it is running in interactive mode.",NA
Initialization File Contents ,"Usually the shell initialization files are quite short. They are designed to provide a complete working 
 environment with as little overhead as possible for both interactive and noninteractive shells. 
  
 The file 
 /etc/profile
  is maintained by the system administrator of your UNIX machine and contains shell 
 initialization information required by all users on a system. 
  
 The file 
 .profile
  is under your control. You can add as much shell customization information as you want 
 to this file. The minimum set of information that you need to configure includes 
  
  
 G
 The type of terminal you are using 
  
  
 G
 A list of directories in which to locate commands 
  
  
 G
 A list of directories in which to locate manual pages for commands 
  
 Setting the Terminal Type 
  
 Usually the type of terminal you are using is automatically configured by either the 
 login
  or 
 getty 
 programs. Sometimes, the autoconfiguration process guesses your terminal incorrectly. This can occur when 
 you are using a dial-up or modem connection. 
  
 If your terminal is set incorrectly, the output of commands might look strange, or you might not be able to 
 interact with the shell properly. To make sure that this is not the case, most users set their terminal to the 
 lowest common denominator as follows: 
  
 TERM=vt100 
  
 When I introduce the 
 case
  statement in 
 Chapter 10, ""Flow Control,""
  you will see a more advanced method 
 of setting the terminal type that enables access to advanced terminal features. 
  
 Setting the 
 PATH 
  
 When you type the command 
  
 $ date 
  
 the shell has to locate the command 
 date
  before it can be executed. The 
 PATH
  specifies the locations in 
 which the shell should look for commands. Usually it is set as follows:",NA
Making a Shell Script Executable ,"One of the most important tasks in writing shell scripts is making the shell script executable and making sure 
 that the correct shell is invoked on the script. 
  
 In a previous example, you created the 
 logins
  script that executes the following compound command: 
 date ; who ; 
  
 If you wanted to run the script by typing its name, you need to do two things: 
  
  
 G
 Make it executable. 
  
 G
 Make sure that the right shell is used when the script is run. 
  
 To make this script executable, do the following:",NA
Getting Help ,"Using the man Command
  
 Manual Sections
  
 As you read through this book, you will want to get more information about the commands and features I 
 discuss. This information is available by using the online help feature of UNIX. 
  
 Every version of UNIX comes with an extensive collection of online help pages called manual pages. These 
 are often referred to as 
 man pages 
 . The man pages are the authoritative source about your UNIX system. 
 They contain complete information about both the kernel and all the utilities.",NA
Using the ,NA,NA
man,NA,NA
 Command ,"To access a man page you need to use the 
 man
  (
 man
  as in 
 manual
 ) command as follows:
  
 man 
 command
  
 Here, 
 command
  is the name of a command that you want more information about. As an example, 
  
 $ man uptime
  
 displays the following on a Solaris machine: 
  
 User Commands                                           uptime(1) 
  
 NAME 
  
  uptime - show how long the system has been up 
  
 SYNOPSIS 
  
  uptime 
  
 DESCRIPTION 
  
  The uptime command prints the current time,  the  length  of  
 time  the system has been up, and the average number of jobs  
 in the run queue over the last 1, 5 and 15 minutes.  It  is,  
 essentially,  the first line of a w(1) command. 
  
 EXAMPLE 
  
  Below is an example of the output uptime provides: 
  
  
  
  example% uptime 
  
  
  
  10:47am  up 27 day(s), 50 mins,  1 user,  load average: 0.18, 0.26, 
 0.20",NA
Manual Sections ,"The term 
 manual page 
 comes from the original versions of UNIX, when the online pages were available as 
 large bound manuals. In all, there were eight different manuals covering the main topics of the UNIX system. 
 These manuals are described in Table 2.3. 
  
 Table 2.3  The UNIX System Manuals 
  
  
  
 Manual Section Description
  
  
  
  
 1
  
  
  
 Covers commands. 
  
  
  
 2
  
  
  
 Covers UNIX system calls. 
 System calls 
 are used inside a program, such as 
 date
 , to 
 ask the kernel for a service. 
  
  
  
 3
  
  
  
 Covers libraries. Libraries are used to store non-kernel-related functions used by C 
 programmers. 
  
  
  
 4
  
  
  
 Covers file formats. This manual specifies the format of files such as 
 /etc/passwd
 .
  
  
  
 5
  
  
  
 Also covers file formats. 
  
  
  
 6
  
  
  
 Includes the instructions for playing the games that came with UNIX. 
  
  
  
 7
  
  
  
 Covers device drivers. 
  
  
  
 8
  
  
  
 Covers system maintenance. 
  
  
  
 Unlike the printed version, where you had to know the section where you needed to look for a particular 
 manual page, the 
 man
  command looks in all the sections for the information you requested. This makes it 
 much easier to get help using the man pages. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 2: Script Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The UNIX System
  
 Summary
  
 Shell Initialization
  
 Questions
  
 Getting Help
  
 Terms",NA
Summary,"In this chapter, I explained in greater detail what the shell is and how it works. You saw how the login 
 process works and what the 
 login
  command does to start a shell. From this you were able to look at the 
 two modes in which the shell can be run: 
  
 G
 Interactively
  
 G
 Noninteractively
  
 In shell programming, the noninteractive use of the shell should interest you the most. This mode enables 
 you to specify commands inside a file and then have the shell execute the commands within that file. You 
 also saw how to make a file containing commands executable. This enables you to treat shell scripts as new 
 commands. 
  
 You also looked at some details of shell initialization and getting help using the 
 man
  command. 
  
 The next chapter formally introduces the concept of files by showing you how to list files, view the contents 
 of files, and manipulate files. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 2: Script Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The UNIX System
  
 Summary
  
 Shell Initialization
  
 Questions
  
 Getting Help
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What are the two files used by the shell to initialize itself? 
  
 2. 
 Why do you need to set 
 PATH
  and 
 MANPATH
 ?
  
 3. 
 What purpose does the following line 
  
 #!/bin/sh
  
 serve in a script? 
  
 4. 
 What command should you use to access the online help? 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 2: Script Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The UNIX System
  
 Summary
  
 Shell Initialization
  
 Questions
  
 Getting Help
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Utilities
   Utilities are programs, such as 
 who
  and 
 date
 , that you can run or execute. 
  
 Commands
   A command is the name of a program and any arguments you specify to that program to 
 cause its behavior to change. You might see the term 
 command
  used instead of the term 
 utility
  for simple 
 commands, where only the program name to execute is given. 
  
 Kernel
   The kernel is the heart of the UNIX system. It provides utilities with a means of accessing a 
 machine's hardware. It also handles the scheduling and execution of commands. 
  
 Uninitialized Shell 
   When a shell is started it is uninitialized. This means that important parameters 
 required by the shell to function correctly are not defined. 
  
 Shell Initialization 
   After a shell is started it undergoes a phase called initialization to set up some 
 important parameters. This is usually a two step process that involves the shell reading the files 
 /etc/profile
  and 
 .profile
 .
  
 Interactive Mode 
   In interactive mode the shell reads input from you and executes the commands that you 
 specify. This mode is called interactive because the shell is interacting with a user. 
  
 NoninteractiveMode
   In noninteractive mode, the shell does not interact with you; instead it reads 
 commands stored in a file and executes them. When it reaches the end of the file, the shell exits. 
  
 Shell Script 
   A shell script is a list of commands stored in a file that the shell executes noninteractively. 
  
 Home Directory 
   Your home directory is the directory in which you start out after you log in. 
  
 Comments
   A comment is a statement that is embedded in a shell script but should not be executed by the 
 shell. 
  
 Man Pages 
   Every version of UNIX comes with an extensive collection of online help pages called 
 man 
 pages 
 (short for 
 manual pages 
 ). The man pages are the authoritative source about your UNIX system. 
 They contain complete information about both the kernel and all the utilities. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 2: Script Basics 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The UNIX System
  
 Summary
  
 Shell Initialization
  
 Questions
  
 Getting Help
  
 Terms",NA
Hour 3 ,NA,NA
Working with Files ,"In UNIX there are three basic types of files: 
  
 G
 Ordinary Files 
  
 G
 Directories 
  
 G
 Special Files 
  
 An 
 ordinary file 
 is a file on the system that contains data, text, or program instructions. In this chapter, you 
 look at working with ordinary files. 
  
  Directories
 , covered in 
 Chapter 4, ""Working with Directories,""
  store both special and ordinary files. 
  
 For users familiar with Windows or Mac OS, UNIX directories are equivalent to folders. 
  
 Special files are covered in 
 Chapter 5, ""Manipulating File Attributes.""
  Some special files provide access to 
  
 hardware such as hard drives, CD-ROM drives, modems, and Ethernet adapters. Other special files 
 are similar to aliases or shortcuts and enable you to access a single file using different names.",NA
Listing Files ,"Hidden Files
  
 Option Grouping
  
 First, list the files and directories stored in the current directory. Use the following command: 
  
 $ ls
  
 Here's a sample directory listing: 
  
 bin           hosts         lib           res.03 
  
 ch07          hw1           pub           test_results 
 ch07.bak      hw2           res.01        users 
  
 docs          hw3           res.02        work 
  
 This output indicates that several items are in the current directory, but this output does not tell us whether 
 these items are files or directories. To find out which of the items are files and which are directories, specify 
 the 
 -F
  option to 
 ls
 :",NA
Hidden Files ,"So far you have used 
 ls
  to list 
 visible
  files and directories, but 
 ls
  can also list 
 invisible
  or 
 hidden 
 files and directories. An invisible file is one whose first character is the dot or period character ( 
 .
 ). UNIX 
 programs (including the shell) use most of these files to store configuration information. Some common 
 examples of hidden files include the files 
  
 G
 .profile
 , the Bourne shell ( 
 sh
 ) initialization script 
 G
 .kshrc
 , the Korn shell ( 
 ksh
 ) initialization script 
 G
 .cshrc
 , the C shell ( 
 csh
 ) initialization script 
  
 G
 .rhosts
 , the remote shell configuration file 
  
 All files that do not start with the 
 .
  character are considered visible. 
  
 To list invisible files, specify the 
 -a
  option to 
 ls
 :
  
 $ ls -a
  
 The directory listing now looks like this: 
  
 .             .profile      docs          lib           test_results 
 ..            .rhosts       hosts         pub           users 
  
 .emacs        bin           hw1           res.01        work 
  
 .exrc         ch07          hw2           res.02 
  
 .kshrc        ch07.bak      hw3           res.03 
  
 As you can see, this directory contains many invisible files. 
  
 Notice that in this output, the file type information is missing. To get the file type information, specify the 
 -F 
 and the 
 -a
  options as follows: 
  
 $ ls -a -F
  
 The output changes to the following: 
  
 ./             .profile       docs/          lib/           test_results 
 ../            .rhosts        hosts          pub/           users .emacs         
 bin/           hw1            res.01         work/ .exrc          ch07           
 hw2            res.02 
  
 .kshrc         ch07.bak       hw3            res.03 
  
 With the file type information you see that there are two hidden directories (
 .
  and 
 ..
 ). These two directories 
 are special entries that are present in all directories. The first one, 
 .
 , represents the current directory. The 
 second one, 
 ..
 , represents the parent directory. We discuss these concepts in greater detail in section 
 ""The 
  
 Directory Tree""
  of 
 Chapter 4
 .",NA
Option Grouping ,NA,NA
Viewing the Content of a File ,"cat
  
 Counting Words (wc)
  
 The ability to list files is very important, but shell scripts also need to be able to view the contents of a file.",NA
cat,"follows: 
  
 To view the content of a file, use the 
 cat
  (short for 
 concatenate
 ) command. Its syntax is as 
  
 cat 
 files
  
 Here 
 files
  are the names of the files that you want to view. For example, 
  
 $ cat hosts
  
 prints out the contents of a file called 
 hosts
 :
  
 127.0.0.1       localhost          loopback 
 10.8.11.2       kanchi.bosland.us  kanchi 
 10.8.11.9       kashi.bosland.us   kashi 
 128.32.43.52    soda.berkeley.edu  soda 
  
 You can specify more than one file as follows: 
  
 $ cat hosts users
  
 If the 
 users
  file contains a list of users, this produces the following output: 
  
 127.0.0.1       localhost          loopback 
 10.8.11.2       kanchi.bosland.us  kanchi 
 10.8.11.9       kashi.bosland.us   kashi 
 128.32.43.52    soda.berkeley.edu  soda 
  
 ranga 
  
 sveerara 
  
 vathsa 
  
 amma",NA
Counting Words ( ,NA,NA
wc,NA,NA
),"Now that you know how to view the contents of a file, look at how to get some information about the 
 contents. 
  
 You can use the 
 wc
  command to get a count of the total number of lines, words, and characters 
 contained in a file. The basic syntax of this command is 
  
 wc [
 options
 ] 
 files
  
 Here 
 options
  are one or more of the options given in Table 3.1 and 
 files
  are the files you want 
 examined. 
  
 If no options are specified, the output contains a summary of the number of lines, words, and characters. For 
 example, the command 
  
 $ wc .rhosts",NA
Manipulating Files ,"Copying Files (cp) 
  
 Removing Files (rm)
  
 Renaming Files (mv)
  
 In the preceding sections, you looked at listing files and viewing their content. In this section you look at the 
 following methods of manipulating files: 
  
 G
 Copying files 
  
 G
 Renaming files 
  
 G
 Removing files",NA
Copying Files ( ,NA,NA
cp,NA,NA
),"To make a copy of a file use the 
 cp
  command. The basic syntax of the command is 
  
 cp 
 sourcedestination
  
 Here 
 source
  is the name of the file that is copied and 
 destination
  is the name of the copy. For example, 
 the following command makes a copy of the file 
 test_results
  and places the copy in a file named 
 test_results.orig
 :
  
 $ cp test_results test_results.orig
  
 Common Errors 
  
 There is no output from the 
 cp
  command, unless it encounters an error. Two common errors occur when 
  
 G
 The source is a directory 
  
 G
 The source does not exists 
  
 An example of the first case is the command 
  
 $ cp work docs
  
 This causes an error message similar to the following: 
  
 cp: work: is a directory
  
 An example of the second case is the command",NA
Renaming Files ( ,NA,NA
mv,NA,NA
),"To change the name of a file use the 
 mv
  command. Its basic syntax is 
  
 mv 
 sourcedestination 
  
 Here 
 source
  is the original name of the file and 
 destination
  is the new name of the file. As an example, 
 $ mv test_result test_result.orig 
  
 changes the name of the file 
 test_result
  to 
 test_result.orig
 . A new file called 
  
 test_result.orig
  is not produced like in 
 cp
 ; only the name of the file is changed. There is no output 
 from 
 mv
  if the name change is successful. 
  
 If the source does not exist, as in the following example, 
  
 $ mv test_reslut test_result.orig 
  
 an error similar to the following is reported: 
  
 mv: test_reslut: cannot access: No such file or directory 
 Interactive Mode 
  
 Like 
 cp
 , 
 mv
  does not report an error if the 
 destination
  already exists: it simply overwrites the file. to avoid 
 this problem you can specify the 
 -i
  option.",NA
Removing Files ( ,NA,NA
rm,NA,NA
),"To remove files use the 
 rm
  command. The syntax is 
  
 rm 
 files 
  
 Here 
 files
  is a list of one or more files to remove. For example, the command 
 $ rm res.01 res.02 
  
 removes the files 
 res.01
  and 
 res.02
 .
  
 Common Errors 
  
 The two most common errors using 
 rm
  are 
  
 G
 One of the specified files does not exist 
  
 G
 One of the specified files is a directory 
  
 As an example of the first case, the command 
  
 $ rm res.01 res.02 res.03 
  
 produces an error message if the file 
 res.02
  does not exist: 
 rm: res.02 non-existent 
  
 The other two files are removed. 
  
 An example of the second case is the command 
  
 $ rm res.01 res.03 work/ 
  
 This command produces another error message:",NA
Summary,"In this chapter, you covered the following topics: 
  
 G
 Listing files using 
 ls 
  
 G
 Viewing the content of a file using 
 cat 
  
 G
 Counting the words, lines, and characters in a file using 
 wc 
 G
 Copying files using 
 cp 
  
 G
 Renaming files using 
 mv 
  
 G
 Removing files using 
 rm
  
 Knowing how to perform each of these tasks is essential to becoming a good shell programmer. In the 
  
 chapters ahead you use these basics to create scripts for solving real world problems. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 3: Working with Files 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Listing Files
  
 Summary
  
 Viewing the Content of a File
  
 Questions
  
 Manipulating Files
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What are invisible files? How do you use 
 ls
  to list them? 
  
 2. 
 Will there be any difference in the output of the following commands? 
  
  
 a. 
 $ ls -a1 
  
  
 b. 
 $ ls -1 -a 
  
  
 c. 
 $ ls -1a 
  
 3. 
 Which options should be specified to 
 wc
  in order to count the number of lines and characters in a 
 file? 
  
 4. 
 Given that 
 hw1
 , 
 hw2
 , 
 ch1
 , and 
 ch2
  are files and 
 book
  and 
 homework
  are directories, which of 
 the following commands generates an error message? 
  
 a. 
 $ cp hw1 ch2 homework 
  
 b. 
 $ cp hw1 homework hw2 book 
  
 c. 
 $ rm hw1 homework ch1 
  
 d. 
 $ rm hw2 ch2 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 3: Working with Files 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Listing Files
  
 Summary
  
 Viewing the Content of a File
  
 Questions
  
 Manipulating Files
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms ,"ls
   The command that lists the files in a directory. 
  
 cat
   The command that views the contents of a file. 
  
 wc
   The command that counts the words, lines, and characters in a file. 
  
 cp
   The command that copies files. 
  
 mv
   The command that renames files. 
  
 rm
   The command that removes files. 
  
 Ordinary File 
   A file on the system that contains data, text, or program instructions. 
  
 Directories
   A type of file that stores other files. For users familiar with Windows or Mac OS, UNIX 
 directories are equivalent to folders. 
  
 Invisible Files 
 or 
 Hidden Files 
   Files whose names start with the 
 .
  character. By default the 
 ls
  command 
 does not list these files. You can list them by specifying the 
 -a
  option to 
 ls
 .
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 3: Working with Files 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Listing Files
  
 Summary
  
 Viewing the Content of a File
  
 Questions
  
 Manipulating Files
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 4 ,NA,NA
Working With Directories,"UNIX uses a hierarchical structure for organizing files and directories. This structure is often 
 referred to as a 
 directory tree 
 . The tree has a single root node, the slash character ( 
 /
 ), and all other 
 directories are contained below it. 
  
 You can use every directory, including 
 /
 , to store both files and other directories. Every file is stored in a 
 directory, and every directory except 
 /
  is stored in another directory. 
  
 This is slightly different from the multiroot hierarchical structure used by Windows and Mac OS. In those 
 operating systems, all devices (floppy disk drives, CD-ROMs, hard drives, and so on) are mounted at the 
 highest directory level. The UNIX model is slightly different, but after a short time most users find it 
 extremely convenient. 
  
 This chapter introduces the directory tree and shows you how to manipulate its building blocks: directories.",NA
The Directory Tree ,"Filenames
  
 Pathnames
  
 To explain the origin and advantages of the directory tree, consider a project that requires organization, 
 such as writing a book. 
  
 When you start out, it is easiest to put all the documents related to the book in one location. As you work on 
 the book, you might find it hard to locate the material related to a particular chapter. 
  
 If you are writing the book with pen and paper, the easiest solution to this problem is to take all the pages 
 related to the first chapter and put them into a folder labeled ""Chapter 1."" As you write more chapters, you 
 can put the material related to these chapters into separate folders. 
  
 In this method, when you finish the book, you will have many separate folders. You might put all the folders 
 into a box and label that box with the name of the book. (Then you can stack the boxes in your closet.) 
  
 By grouping the material for the different chapters into folders and grouping the folders into boxes, the 
 multitude of pages required to write a book becomes organized and easily accessible. When you want to 
 see Chapter 5 from a particular book, you can grab that box from your closet and look only at the folder 
 pertaining to Chapter 5.",NA
Filenames,"In UNIX, every file and directory has a name associated with it. This name is referred to as the file or 
 directory's 
 filename
 .
  
 In addition to their filenames, every file and directory is associated with the name of its parent directory. 
 When a filename is combined with the parent directory's name, the result is called a 
 pathname
 . Two 
 examples of pathnames are 
  
 /home/ranga/docs/book/ch5.doc 
  
 /usr/local/bin/ 
  
 As you can see, each of these pathnames consists of several ""words"" separated by the slash ( 
 /
 ) character. 
 In UNIX, the slash separates directories, whereas the individual words are the names of files or directories. 
 The sum of all the words and the 
 /
  characters makes up the pathname. 
  
 The last set of characters in a pathname is the actual name of the file or directory being referred to: The rest 
 of the characters represent its parent directories. In the first example, the filename is 
 ch5.doc
 .
  
 The name of a file can be up to 255 characters long and can contain any ASCII character except 
 /
 . 
 Generally, the characters used in pathnames are the alphanumeric characters ( 
 a
  to 
 z
 , 
 A
  to 
 Z
 , and 
 0
  to 
 9
 ) 
 along with periods ( 
 .
 ), hyphens ( 
 -
 ), and underscores ( 
 _
 ).
  
 Other characters, especially the space, are usually avoided because many programs cannot deal with them 
 properly. For example, consider a file with the following name: 
  
 A Farewell To Arms
  
 Most programs treat this a four separate files named 
 A
 , 
 Farewell
 , 
 To
 , and 
 Arms
 , instead of one file. You 
 look at a workaround to this problem in 
 Chapter 9, ""Quoting.""
  
 One thing to keep in mind about filenames is that two files in the same directory cannot have the same",NA
Pathnames,"In order to access a file or directory, its pathname must be specified. As you have seen, a pathname 
 consists of two parts: the name of the directory and the names of its parents. UNIX offers two ways to 
 specify the names of the parent directory. This leads to two types of pathnames: 
  
 G
 Absolute 
  
 G
 Relative
  
 An Analogy for Pathnames 
  
  
  
 The following statements illustrate a good analogy for the difference between absolute and relative 
  
 pathnames: 
  
  
 ""I live in San Jose."" 
  
  
 ""I live in San Jose, California, USA."" 
  
  
 The first statement gives only the city in which I live. It does not give any more information, thus the 
  
 location of my house is relative. It could be located in any state or country containing a city called San 
  
 Jose. The second statement fully qualifies the location of my house, thus it is an absolute location.
  
 Absolute Pathnames 
  
 An 
 absolute
  pathname represents the location of a file or directory starting from the root directory 
 and listing all the directories between the root and the file or directory of interest. 
  
 Because absolute pathnames list the path from the root directory, they always start with the slash ( 
 /
 )",NA
Switching Directories ,"Home Directories
  
 Changing Directories
  
 Now that you have covered the basics of the directory tree, look at moving around the tree using 
  
 the 
 cd
  (change directory) command.",NA
Home Directories ,"First print the working directory: 
  
 $ pwd 
  
 /home/ranga 
  
 This indicates that I am in my home directory. Your home directory is the initial directory where you start 
  
 when you log in to a UNIX machine. Most systems use either 
 /home
  or 
 /users
  as directories under which 
  
 home directories are stored. On my system I use 
 /home
 .
  
 The easiest way to determine the location of your home directory is to do the following: 
  
 $ cd 
  
 $ pwd 
  
 /home/ranga 
  
 When you issue the 
 cd
  command without arguments, it changes the current directory to your home 
  
 directory. Therefore, after the 
 cd
  command completes, the 
 pwd
  command prints the working directory that is 
  
 your home directory.",NA
Changing Directories ,"You can use the 
 cd
  command to do more than change to a home directory: You can use it to change to any 
  
 directory by specifying a valid absolute or relative path. The syntax is as follows: 
  
 cd 
 directory
  
 Here, 
 directory
  is the name of the directory that you want to change to. For example, the command 
  
 $ cd /usr/local/bin",NA
Listing Files and Directories ,"Listing Directories
  
 Listing Files
  
 In 
 Chapter 3, ""Working with Files,""
  you looked at using the 
 ls
  command to list the files in the current 
  
 directory. Now look at using the 
 ls
  command to list the files in any directory.",NA
Listing Directories ,"To list the files in a directory you can use the following syntax: 
  
 ls 
 directory
  
 Here, 
 directory
  is the absolute or relative pathname of the directory whose contents you want listed. 
  
 For example, both of the following commands list the contents of the directory 
 /usr/local
  (assuming the 
 working directory is 
 /home/ranga
 ):
  
 $ ls /usr/local 
  
 $ ls ../../usr/local 
  
 On my system the listing looks like 
  
 X11           bin           gimp          jikes         sbin 
  
 ace           doc           include       lib           share 
  
 atalk         etc           info          man           turboj-1.1.0 
  
 The listing on your system might look quite different. 
  
 You can use any of the options you covered in 
 Chapter 3
  to change the output. For example, the command
  
 $ ls -aF /usr/local
  
 produces the following output 
  
 ./             atalk/         gimp/          lib/           turboj-1.1.0/ 
 ../            bin/           include/       man/ 
  
 X11/           doc/           info/          sbin/ 
  
 ace/           etc/           jikes/         share/",NA
Listing Files ,"If you specify the name of a file instead of a directory, 
 ls
  lists only that one file. For example 
  
 $ ls .profile 
  
 .profile 
  
 You can intermix files and directories as arguments to 
 ls
 :
  
 $ ls .profile docs/ /usr/local /bin/sh
  
 This produces a listing of the specified files and the contents of the directories. 
  
 If you don't want the contents of the directory listed, specify the 
 -d
  option to 
 ls
 . This forces 
 ls
  to display 
 only the name of the directory, not its contents: 
  
 $ ls -d /home/ranga 
  
 /home/ranga 
  
 You can combine the 
 -d
  option with any of the other 
 ls
  options you have covered. An example of this is 
  
 $ ls -aFd /usr/local /home/ranga /bin/sh 
 /bin/sh*      /home/ranga/  /usr/local/ 
  
 Common Errors 
  
 If the file or directory you specify does not exist, 
 ls
  reports an error. For example 
  
 $ ls tomorrows_stock_prices.txt 
  
 tomorrows_stock_prices.txt: No such file or directory",NA
Manipulating Directories ,"Creating Directories 
  
 Moving Files and Directories
  
 Copying Files and Directories 
  
 Removing Directories
  
 Now that you have covered using directories, look at manipulating them. The most common manipulations 
 are 
  
 G
 Creating directories 
  
 G
 Copying directories 
  
 G
 Moving directories 
  
 G
 Removing directories",NA
Creating Directories ,"You can create directories with the 
 mkdir
  command. Its syntax is 
  
 mkdir 
 directory
  
 Here, 
 directory
  is the absolute or relative pathname of the directory you want to create. For example, the 
 command 
  
 $ mkdir hw1
  
 creates the directory 
 hw1
  in the current directory. Here is another example: 
  
 $ mkdir /tmp/test-dir
  
 This command creates the directory 
 test-dir
  in the 
 /tmp
  directory. The 
 mkdir
  command produces no 
 output if it successfully creates the requested directory. 
  
 If you give more than one directory on the command line, 
 mkdir
  creates each of the directories. For 
 example 
  
 $ mkdir docs pub
  
 creates the directories 
 docs
  and 
 pub
  under the current directory. 
  
 Creating Parent Directories",NA
Copying Files and Directories ,"In 
 Chapter 3
 , you looked at using the 
 cp
  command to copy files. Now look at using it to copy directories. 
  
 To copy a directory, you specify the 
 -r
  option to 
 cp
 . The syntax is as follows: 
  
 cp -r 
 sourcedestination
  
 Here, 
 source
  is the pathname of the directory you want to copy, and 
 destination
  is where you want to 
  
 place the copy. For example 
  
 $ cp -r docs/book /mnt/zip
  
 copies the directory 
 book
  located in the 
 docs
  directory to the directory 
 /mnt/zip
 . It creates a new 
  
 directory called 
 book
  under 
 /mnt/zip
 .
  
 Copying Multiple Directories 
  
 In the same way that you can copy multiple files with 
 cp
 , you can also copy multiple directories. If 
 cp
  
 encounters more than one source, all the source directories are copied to the destination. The destination is 
  
 assumed to be the last argument. 
  
 For example, the command 
  
 $ cp -r docs/book docs/school work/src /mnt/zip
  
 copies the directories 
 school
  and 
 book
 , located in the directory 
 docs
 , to 
 /mnt/zip
 . It also copies the 
  
 directory 
 src
 , located in the directory 
 work
 , to 
 /mnt/zip
 . After the copies finish, 
 /mnt/zip
  looks like the 
  
 following: 
  
 $ ls -aF /mnt/zip 
  
 ./   ../   book/   school/   src/ 
  
 You can also mix files and directories in the argument list. For example 
  
 $ cp -r .profile docs/book .kshrc doc/names work/src /mnt/jaz
  
 copies all the requested files and directories to the directory 
 /mnt/jaz
 .
  
 If your argument list consists only of files, the 
 -r
  option has no effect. 
  
 Common Errors 
  
 The most common error in copying files and directories is in the requested destination. The most common 
  
 problems in copying directories involve using a destination that is not a directory. 
  
 An example of this is",NA
Moving Files and Directories ,"You have looked at the 
 mv
  command to rename files, but its real purpose is to move files and directories 
 between different locations in the directory tree. The basic syntax is this: 
  
 mv 
 sourcedestination 
  
 Here 
 source
  is the name of the file or directory you want to move, and 
 destination
  is the directory 
 where you want the file or directory to end up. For example 
  
 $ mv /home/ranga/names /tmp 
  
 moves the file 
 names
  located in the directory 
 /home/ranga
  to the directory 
 /tmp
 .
  
 Moving a directory is exactly the same: 
  
 $ mv docs/ work/ 
  
 moves the directory 
 docs
  into the directory 
 work
 . To move the directory 
 docs
  back to the current directory 
 you can use the command: 
  
 $ mv work/docs .
  
 One nice feature of 
 mv
  is that you can move and rename a file or directory all in one command. For example 
 $ mv docs/names /tmp/names.txt 
  
 moves the file 
 names
  in the directory 
 docs
  to the directory 
 /tmp
  and renames it 
 names.txt
 .
  
 Moving Multiple Items 
  
 As you can with 
 cp
 , you can specify more than one file or directory as the source. For example 
 $ mv work/ docs/ .profile pub/ 
  
 moves the directories 
 work
  and 
 docs
  along with the file 
 .profile
  into the directory 
 pub
 .
  
 When you are moving multiple items, you cannot rename them. If you want to rename an item and move it, 
 you must use a separate 
 mv
  command for each item.",NA
Removing Directories ,"You can use two commands to remove directories: 
  
  
 G
 rmdir 
  
  
 G
 rm -r 
  
 Use the first command to remove empty directories. It is considered ""safe"" because in the worst case, you 
 can accidentally lose an empty directory, which you can quickly re-create with 
 mkdir
 .
  
 The second command removes directories along with their contents. It is considered ""unsafe"" because in 
 the worst case of 
 rm -r, 
 you could lose your entire system. 
  
  
 Caution -
  When using 
 rm
  to remove either files or directories, make sure that you remove only those files 
  
 that you don't want. 
  
  
 There is no way to restore files deleted with 
 rm
 , so mistakes can be very hard to recover from. 
  
 rmdir 
  
 To remove an empty directory, you can use the 
 rmdir
  command. Its syntax is 
  
 rmdir 
 directories 
  
 Here, 
 directories
  includes the names of the directories you want removed. For example, the command 
 $ 
 rmdir ch01 ch02 ch03 
  
 removes the directories 
 ch01
 , 
 ch02
 , and 
 ch03
  if they are empty. The 
 rmdir
  command produces no output 
 if it is successful. 
  
 Common Errors 
  
 You might encounter two common error messages from 
 rmdir
 . These occur when you 
  
  
 G
 Try to remove a directory that is not empty 
  
  
 G
 Try to remove files with 
 rmdir 
  
 For the first case, you need to know how to determine whether a directory is empty. You can do this by using 
 the 
 -A
  option of the 
 ls
  command. An empty directory produces no output. If there is some output, the 
 directory you specified is not empty. 
  
 For example, if the directory 
 bar
  is empty, the following command 
 $ ls -A bar",NA
Summary,"In this chapter, you have looked at working with directories. Specifically, you covered the following topics: 
  
 G
 Working with filenames and pathnames 
  
 G
 Switching directories 
  
 G
 Listing files and directories 
  
 G
 Creating directories 
  
 G
 Copying and moving directories 
  
 G
 Removing directories 
  
 You reviewed each of these topics because it is important to know how to perform these functions when 
 writing shell scripts. As you progress further into this book, you see how common directory manipulations 
 occur in shell scripts. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 4: Working With Directories 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The Directory Tree
  
 Manipulating Directories
  
 Switching Directories
  
 Summary
  
 Listing Files and Directories
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Which of the following are absolute pathnames? Which are relative? 
  
  
 a. 
 /usr/local/bin 
  
  
 b. 
 ../../home/ranga 
  
  
 c. 
 docs/book/ch01 
  
  
 d. 
 / 
  
 2. 
 What is the output of the 
 pwd
  command after the following sequence of 
 cd
  commands have been 
 issued? 
  
 $ cd /usr/local 
  
 $ cd bin 
  
 $ cd ../../tmp 
  
 $ cd 
  
 3. 
 What command should be used to copy the directory 
 /usr/local
  to 
 /opt/pgms
 ?
  
 4. 
 What command(s) should be used to move the directory 
 /usr/local
  to 
 /opt/pgms
 ?
  
 5. 
 Given the following listing for the directory 
 backup
 , can you use the 
 rmdir
  command to remove 
 this directory? If not, please give a command that can be used. 
  
 $ ls -a backup 
  
 ./    ../   sysbak-980322 sysbak-980112
  
  
 Sams Teach Yourself Shell 
  
 Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Next Chapter
  
 Hour 4: Working With Directories
  
 Sections in this 
  
 Chapter:
  
 The Directory 
  
 Manipulating 
  
 Tree
  
 Directories
  
 Switching 
  
 Summary
  
  
 Directories
  
 Questions
  
 Previous Section
  
 Next Section
 Previous Section
  
 Next Section<img 
 src=""
  
 Listing Files and 
  
 Directories",NA
Hour 5 ,NA,NA
Manipulating File Attributes ,"In addition to working with files and directories, shell scripts are often called on to manipulate the attributes 
 of a file. In this chapter, you learn how to manipulate the following file attributes: 
  
  
 G
 Permissions 
  
  
 G
 Owners 
  
  
 G
 Groups 
  
 You will examine the different types of files available on UNIX systems and how to identify them.",NA
File Types ,"Determining a File's Type 
  
 Device Files
  
 Regular Files 
  
 Named Pipes
  
 Symbolic Links
  
 UNIX supports several different types of files. Files can contain your important data, such as files from a 
 word processor or graphics package, or they can represent devices, directories, or symbolic links. In this 
 section, you will look at the different types of files available under UNIX.",NA
Determining a File's Type ,"To determine a file's type, specify the 
 -l
  option to the 
 ls
 . When this option is specified, 
 ls
  lists the file type 
 for the specified files. For example, the command 
  
 $ ls -l /home/ranga/.profile 
  
 produces the following output: 
  
 -rwxr-xr-x   1 ranga    users        2368 Jul 11 15:57 .profile* 
  
 Here, you see that the very first character is a hyphen (-). This indicates that the file is a regular file. For 
 special files, the first character will be one of the letters given in Table 5.1. 
  
 To obtain file type information about a directory, you must specify the 
 -d
  option along with the 
 -l
  option:",NA
Regular Files ,"Regular files 
 are the most common type of files you will encounter. These files store any kind of 
 data. This data can be stored as plain text, an application- specific format, or a special binary format that the 
 system can execute. 
  
 UNIX does not have to understand the data contained in a regular file. A regular file can store any form of 
 raw data because UNIX does not interpret the data that is in the file. 
  
 Note -
  Often simply determining that a file is a regular file tells you very little about the file itself. Usually you need 
 to know whether a particular file is a binary program, a shell script, or a library. In these instances, the 
 file
  program 
 is very useful. 
  
  
 It is invoked as follows: 
  
  
 file 
 filename
  
  
 Here, 
 filename
  is the name of the file you want to examine. As an example, on my system, the command 
  
  
 $ file /sbin/sh
  
  
 produces the following output: 
  
  
  
 /sbin/sh: ELF 32-bit MSB executable SPARC Version 1, statically linked, 
  
 stripped",NA
Symbolic Links ,"A 
 symbolic link 
 is a special file that points to another file on the system. When you access one of 
 these files, it has a pathname stored inside it. Use this pathname to advance to the file or directory on the 
 system represented by the pathname stored in the symbolic link. 
  
 For readers who are familiar with Windows or Mac OS, a symbolic link is similar to a shortcut or an alias. 
  
 You can use symbolic links to make a file appear as though it is located in many different places or has 
 many different names in the file system. Symbolic links can point to any type of file or directory. 
  
 The 
 ls -l 
 output for a symbolic link looks like this: 
  
 lrwxrwxrwx   1 root     root           9 Oct 23 13:58 /bin/ -> 
 ./usr/bin/ 
 The output indicates that the directory 
 /bin
  is really a link to the directory 
 ./usr/bin
 .
  
 The relative path in the output is not relative to your current working directory: it is relative to the directory 
 where the link resides. In this case, the link 
 /bin
  resides in the 
 /
  directory, thus 
 ./usr/bin
  indicates that 
 /bin
  is a link to the directory 
 /usr/bin
 .
  
 Creating Symbolic Links 
  
 Create symbolic links using the 
 ln
  command with the 
 -s
  option. The syntax is as follows: 
  
 ln -s 
 sourcedestination 
  
 Here, 
 source
  is either the absolute or relative path to the original version of the file, and 
 destination
  is 
 the name you want the link to have. 
  
 For example, the following command 
  
 $ ln -s /home/httpd/html/users/ranga /home/ranga/public_html 
  
 creates a link in my home directory to my Web files. If you encounter an error while creating a link, 
 ln
  will 
 display an error message. Otherwise, it displays no output. 
  
 In this example, you used absolute paths. In practice, relative paths are preferred for the source and the 
 destination. For example, the actual commands I used to create a link to my Web files are the following:",NA
Device Files ,"You can access UNIX devices through reading and writing to device files. These device files are access 
 points to the device within the file systems. 
  
 Usually, device files are located under the 
 /dev
  directory. The two main types of device files are 
  
 G
 Character special files 
  
  
 G
 Block special files 
  
 Character Special Files 
  
  Character special 
 files provide a mechanism for communicating with a device one character at a 
 time. Usually character devices represent a ""raw"" device. The output of 
 ls
  on a character special file looks",NA
Named Pipes ,"One of the greatest features of UNIX is that you can redirect the output of one program to the 
 input of another program with very little work. For example, the command 
 who | grep ranga 
 takes the 
 output of the 
 who
  command and makes it the input to the 
 grep
  command. This is called 
 piping
  the output of 
 one command into another. You will examine input and output redirection in great detail in 
 Chapter 13, 
  
 ""Input/Output.""
  
 On the command line, temporary anonymous pipes are used, but sometimes more control is needed than 
 the command line provides. For such instances, UNIX provides a way to create a 
 named pipe
 , so that two or 
 more process can communicate with each other via a file that acts like a pipe. Because these files allow 
 process to communicate with one another, they are one of the most popular forms of 
 interprocess 
 communication 
 (
 IPC
  for short) available under UNIX. 
  
 Sockets
  
  Socket files 
 are another form of interprocess communication, but sockets can pass data and 
 information between two processes that are not running on the same machine. Socket files are created 
 when communication to a process on another machine located on a network is required. Internet tools in 
 use today, such as Web browsers, use sockets to make a connection to the Web server. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Hour 5: Manipulating File Attributes
  
 Next Chapter",NA
"Owners, Groups, and Permissions ","Viewing Permissions 
  
 Changing Owners and Groups
  
 Changing File and Directory Permissions
  
 File ownership is an important component of UNIX that provides a secure method for storing files. Every file 
 in UNIX has the following attributes: 
  
 G
 Owner permissions 
  
 G
 Group permissions 
  
 G
 Other (world) permissions 
  
 The owner's permissions determine what actions the owner of the file can perform on the file. The group's 
 permissions determine what actions a user, who is a member of the group that a file belongs to, can perform 
 on the file. The permissions for others indicate what action all other users can perform on the file. 
  
 You can perform the following actions on a file: 
  
 G
 Read 
  
 G
 Write 
  
 G
 Execute
  
 If a user has 
 read
  permissions, that person can view the contents of a file. A user with 
 write 
 permissions can change the contents of a file, whereas a user with 
 execute
  permissions can run a file as a 
 program.",NA
Viewing Permissions ,"You can display the permissions of a file using the 
 ls -l 
 command. For example, the following command 
  
 $ ls -l /home/ranga/.profile
  
 produces the following output: 
  
 -rwxr-xr-x   1 ranga    users        2368 Jul 11 15:57 .profile*
  
 Because the first character is a hyphen (-), you know that this is a regular file. Several characters appear 
 after this hyphen. The first three characters indicate the permissions for the 
 owner
  of the file, the next three 
 characters indicate the permissions for the 
 group
  the file is associated with, and the last three characters 
 indicate the permissions for all 
 other
  users.",NA
Changing File and Directory Permissions ,"You can change file and directory permissions with the 
 chmod
  command. The basic syntax is as follows: 
  
 chmod 
 expression
   files",NA
Changing Owners and Groups ,"Two commands are available to change the owner and the group of files: 
  
 G
 chown 
  
 G
 chgrp
  
 The 
 chown
  command stands for ""change owner"" and is used to change the owner of a file. 
 The 
 chgrp
  command stands for ""change group"" and is used to change the group of a file. 
  
 On some older systems, the 
 chgrp
  command might not be available, and the 
 chown
  command must be 
 used instead. You will learn how to use both 
 chown
  and 
 chgrp
  to change the group of a file. For maximum 
 portability, you should stick to using 
 chown
  to change both the owner and the group of a file. 
  
 Changing Ownership 
  
 The 
 chown
  command changes the ownership of a file. The basic syntax is as follows: 
  
 chown 
 optionsuser
 :
 group
  files 
  
 Here, 
 options
  can be one or more of the options listed in the 
 man
  page for 
 chown
 . Because considerable 
 variation exists in the available options, please consult the 
 man
  page on your system for a complete list. 
  
 The value of 
 user
  can be either the name of a user on the system or the user id (uid) of a user on the 
 system. The value of 
 group
  can be the name of a group on the system or the group ID (GID) of a group on 
 the system. To just change the owner, you can omit the group value. 
  
 As an example 
  
 chown ranga: /home/httpd/html/users/ranga 
 changes the owner of the given directory to the user 
 ranga
 .",NA
Summary,"In this chapter, I covered several important topics relating to files and file permissions. Specifically, I covered 
 the following tasks: 
  
 G
 Determining a file's type 
  
 G
 Changing file and directory permissions using symbolic and octal notation 
 G
 Enabling SUID and SGID permissions for files and directories 
  
 G
 Changing the owner of a file or directory 
  
 G
 Changing the group of a file or directory 
  
 As you will see in subsequent chapters, each of these tasks is important in shell scripts. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 5: Manipulating File Attributes 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 File Types
  
 Summary
  
 Owners, Groups, and Permissions
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"For the three questions, refer to the following 
 ls -l 
 output: 
  
 crw-r-----   1 bin        sys        188 0x001000 Oct 13 00:31 
  
 /dev/rdsk/c0t1d0 
  
 -r--r--r--   1 root       sys            418 Oct 13 16:25 /etc/passwd 
 drwxrwxrwx  10 bin        bin           1024 Oct 15 20:27 /usr/local/ -r-
 sr-xr-x   1 root       bin          28672 Nov  6  1997 /usr/sbin/ping 
  
 1. 
 Identify the file type of each of the files given above. 
  
 2. 
 Identify the owner and group of each of the files given above. 
  
 3. 
 Describe the permissions for the owner, group, and all ""other"" users for each of the files given 
 above. 
  
  
 Sams Teach Yourself Shell 
 Programming in 24 Hours 
  
  
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
 Hour 5: Manipulating File Attributes
  
 Sections in this Chapter:
  
 Previous Section
  
 Next Section
 Previous Section
  
 Next Section<img 
 src=""
  
 File Types
  
 Summary
  
 Owners, Groups, and 
  
 Questions
  
 Permissions",NA
Hour 6 ,NA,NA
Processes ,"By David B. Horvath, CCP 
  
 In this chapter you learn the concepts of processes and jobs. In UNIX every program runs as a process. I 
 explain background and foreground processes and how to start a process. You are introduced to the 
 commands that list and kill processes. Finally, the concept of parent and child processes are explained. 
  
 In this chapter you look at the four major topics involving processes provided with the shell: 
  
 G
 Starting processes 
  
 G
 Listing running processes 
  
 G
 Killing processes 
  
 G
 Parent and child processes",NA
Starting a Process ,"Foreground Processes
  
 Background Processes
  
 Whenever you issue a command in UNIX, it creates, or 
 starts
 , a new process. When you tried out the 
 ls 
 command to list directory contents in 
 Chapter 4, ""Working with Directories,""
  you started a process (the 
 ls 
 command). 
  
 The operating system tracks processes through a five digit ID number known as the 
 pid
  or 
 process ID 
 . Each 
 process in the system has a unique pid. Pids eventually repeat because all the possible numbers are used 
 up and the next pid rolls or starts over. At any one time, no two processes with the same pid exist in the 
 system because it is the pid that UNIX uses to track each process. You might be interested in the fact that 
 the pid usually rolls over at the 16-bit signed boundary. The highest it gets before rolling over is 32,767. 
  
 You can use the 
 ps
  command to see what processes you are running and all processes on the system. The 
 ps
  command is described in the 
 ""Listing Running Processes""
  section of this chapter. 
  
 When you start a process (run a command), there are two ways you can run it--in the 
 foreground 
 or 
 background
 . The difference is how the process interacts with you at the terminal.",NA
Foreground Processes ,"By default, every process that you start runs in the foreground. It gets its input from the keyboard and sends 
 its output to the screen. You can redirect process input and output (see 
 Chapter 13, ""Input/Output""
 ), but by 
  
 default, input and output are connected to your terminal. 
  
 You can see this happen with the 
 ls
  command. If I want to list all the files in my current directory (various 
 chapters that start with a zero), I can use the following command: 
  
 $ ls ch0*.doc
  
 On my screen, I see the following output: 
  
 ch01-1.doc  ch010.doc   ch02.doc    ch03-2.doc  ch04-1.doc   ch040.doc 
 ch05.doc    ch06-2.doc 
  
 ch01-2.doc  ch02-1.doc  ch020.doc   ch03.doc    ch04-2.doc   ch05-1.doc 
 ch050.doc   ch06.doc 
  
 ch01.doc    ch02-2.doc  ch03-1.doc  ch030.doc   ch04.doc     ch05-2.doc  ch06-
 1.doc  ch060.doc 
  
 The process runs in the foreground, the output is directed to my screen, and if the 
 ls
  command wants any 
 input (which it does not), it waits for it from the keyboard. 
  
 While this command is running, I cannot run any other commands (start any other processes). I can enter 
 commands, but no prompt appears and nothing happens until this one completes because UNIX buffers 
 keystrokes. For the 
 ls
  command, which usually runs very quickly, this is not a problem. But if I have 
 something that runs for a long time--such as a large compile, database query, program that calculated pi, or 
 a server--my terminal will be tied up. 
  
 Fortunately, I do not have to wait for one process to complete before I can start another. UNIX provides 
 facilities for starting processes in the background, suspending foreground processes, and moving processes 
 between the foreground and background. 
  
  
 Caution -
  When you log off or are disconnected from the system by a communication problem, your 
  
  
 processes are terminated. If you have a long running process that you do not want terminated, you need to 
  
 use the 
 nohup
  command. 
 nohup
  stands for no HUP (Hang UP). The 
 nohup
  command is described later, 
 in the section 
 ""Keeping Background Processes Around ( 
 nohup
  Command).""",NA
Background Processes ,"A background process runs without being connected to your keyboard. If the background process requires 
 any keyboard input, it waits. 
  
 The advantage of running a process in the background is that you can run other commands; you do not 
 have to wait until it completes to start another! 
  
 The simplest way to start a background process is to add an ampersand ( 
 &
 ) at the end of the command.",NA
Listing Running Processes ,"jobs Command
  
 ps Command
  
 You can start processes in the foreground and background, suspend them, and move them between the 
 foreground and background, but how do you know what is running? There are two commands to help you 
 find out--
 jobs
  and 
 ps
 .",NA
jobs,NA,NA
 Command ,"The 
 jobs
  command shows you the processes you have suspended and the ones running in the 
 background. Because the 
 jobs
  command is a foreground process, it cannot show you your active 
 foreground processes. 
  
 In the following example, I have three jobs. The first one (job 3) is running, the second (job 2) is suspended 
 (a foreground process after I used Ctrl+Z), and the third one (job 1) is stopped in the background to wait for 
 keyboard input: 
  
 $ jobs 
  
 [3] +  Running                 first_one & 
 [2] - Stopped (SIGTSTP)        second_one 
 [1]   Stopped (SIGTTIN)        third_one & 
  
 I can manipulate these jobs with the 
 fg
  and 
 bg
  commands. The most recent job is job number 3 (shown 
 with a plus sign); this is the one that 
 bg
  or 
 fg
  act on if no job number is supplied. The most recent job 
 before that is job number two (shown with a minus sign). 
  
 Note -
  The reason for the plus and minus symbols on the 
 jobs
  listing is that job numbers are reassigned when one 
 completes and another starts. In the previous example, if job number 2 finishes and you start another job, it is assigned 
 job number 2 and a plus sign because it is the most recent job.",NA
ps,NA,NA
 Command ,"Another command that shows all processes running is the 
 ps
  (Process Status) command. By default, it 
 shows those processes that you are running. It also accepts many different options, a few of which are 
 shown here. 
  
 There are different flavors, or versions, of UNIX. 
 ps
  is one command where the differences are very",NA
Killing a Process ( ,NA,NA
kill,NA,NA
 Command) ,"Another handy command to use with jobs and processes is the 
 kill
  command. As the name implies, the 
 kill
  command 
 kills
 , or ends, a process. 
  
 Just like the 
 fg
  and 
 bg
  commands, the job number is prefixed with a percent sign. To kill job number 1 in 
 the earlier example regarding waiting for keyboard input, I use the following: 
  
 $ kill %1 
  
 [1] - Terminated               third_one & 
 $ 
  
 You can also kill a specific process by specifying the process ID on the command line without the percent 
 sign used with job numbers. To kill job number 2 (process 
 6738
 ) in the earlier example using process ID, I 
 use the following: 
  
 $ kill 6739 
  
 $ 
  
 In reality, 
 kill
  does not physically kill a process; it sends the process a signal. By default, it sends the 
 TERM
  (value 
 15
 ) signal. A process can choose to ignore the 
 TERM
  signal or use it to begin an orderly shut 
 down (flushing buffers, closing files, and so on). If a process ignores a regular 
 kill
  command, you can use 
 kill -9 
 or 
 kill -KILL 
 followed by the process ID or job number (prefixed with a percent sign). This 
 forces the process to end. 
  
 Caution -
  Be very careful when specifying which process to kill, especially if you are using 
 kill -9
 , 
 because you can end a job by accident or even log yourself off. My command interpreter has the process 
  
 ID of 
 3662
 , and I can try to kill it as follows: 
  
  
 $ ps -f 
  
  UID   PID  PPID  C    STIME TTY      TIME CMD  
 billing  3662  3657  0 08:10:53 pts/6    0:01 -ksh $ 
 kill 3662 
  
 $ ps -f 
  
  UID   PID  PPID  C    STIME TTY      TIME CMD 
  
  billing  3662  3657  0 08:10:53 pts/6    0:01 -ksh 
  
  
 ksh ignores a regular 
 kill
  but not a 
 kill -9
 , as follows: 
  
  
    
 $ kill -9 3662.",NA
Parent and Child Processes ,"Job ID Versus Process ID 
  
 Process Permissions
  
 Subshells 
  
 Overlaying the Current Process (exec Command)
  
 In the 
 ps -f 
 example in the 
 ps
  command section, each process has two ID numbers assigned to it: 
 process ID (pid) and parent process ID (ppid). Each user process in the system has a parent process. Most 
 commands that you run have the shell as their parent. The parent of your shell is usually the operating 
 system or the terminal communications process ( 
 in.telnetd
  for telnet connections). 
  
 I have recreated this earlier example to demonstrate the ppid of all my commands is 
 3662
 , the pid of 
 ksh
 , 
 as follows: 
  
 $ ps -f 
  
  UID   PID  PPID  C    STIME TTY      TIME CMD  
  
  dhorvath 6738  3662  0 10:23:03 pts/6    0:00 first_one  
 dhorvath 6739  3662  0 10:22:54 pts/6    0:00 second_one  
 dhorvath 3662  3657  0 08:10:53 pts/6    0:00 -ksh 
  
  dhorvath 6892  3662  4 10:51:50 pts/6    0:00 ps -f  
 dhorvath 6770  3662  2 10:35:45 pts/6    0:03 third_one 
  
 The ppid of 
 ksh
  is 
 3657
 . Using 
 ps -ef 
 (or 
 ps -aux 
 on some systems) and 
 grep
  to find that number, I 
 see the following: 
  
 $ ps -ef | grep 3657 
  
  dhorvath 9778  3662  4 10:52:50 pts/6    0:00 ps -f 
  
  dhorvath 9779  3662  0 10:52:51 pts/6    0:00 grep 3657  
 root 3657   711  0 08:10:53 ?        0:00 in.telnetd   
 dhorvath 3657  3662  0 08:10:53 pts/6    0:00 -ksh 
  
 This tells me that my terminal session is being handled by 
 in.telnetd
  (the telnet daemon) that owns, or is 
 the parent of, my Korn shell command interpreter. 
  
 There is a parent-child relationship between processes. 
 in.telnetd
  is the parent of 
 ksh
 , which is the child 
 of 
 in.telnetd
  but the parent of 
 ps
  and 
 grep
 .
  
 When a child is 
 forked
 , or created, from its parent, it receives a copy of the parent's environment, including 
 environment variables. The child can change its own environment, but those changes do not reflect in the 
 parent and go away when the child exits.",NA
Job ID Versus Process ID ,NA,NA
Subshells,"Whenever you run a shell script, in addition to any commands in the script, another copy of the shell 
 interpreter is created. This new shell is known as a 
 subshell,
  just as a directory contained in or under 
 another is known as a subdirectory. 
  
 The best way to show this is with an example. I created a script known as 
 psit
  and gave it execute 
 permissions. This script runs 
 ps
  and exits in the following example: 
  
 #! /bin/ksh 
  
 ps -ef | grep dhorvath 
  
 exit 0 
  
 When run, 
 psit
  produces the following: 
  
 $ psit 
  
  dhorvath 9830  3662  0 13:58:42 pts/6    0:00 ksh psit  
 dhorvath 9831  9830 19 14:05:24 pts/6    0:00 ps -ef 
  
  dhorvath 3662  3657  0 08:10:53 pts/6    0:00 -ksh 
  
  dhorvath 9832  9830  0 13:58:42 pts/6    0:00 grep dhorvath 
 $ 
  
 The subshell running as process 
 9830
  is a child of process 
 3662
 , the original 
 ksh
  shell. 
 ps
  and 
 grep
  are 
 the children of process 
 9830
  ( 
 ksh psit
 ). When the 
 psit
  script is done and exits, the subshell exits, and 
 control is returned to the original shell. 
  
 You can also start a subshell by entering the shell name ( 
 ksh
  for Korn, 
 sh
  for Bourne, and 
 csh
  for C Shell). 
 This feature is handy if you have one login (default) shell and want to use another. Starting out in Korn shell 
 and starting C Shell would look like the following: 
  
 $ csh 
  
 % ps -f 
  
  UID   PID  PPID  C    STIME TTY      TIME CMD   
 dhorvath 3662  3657  0 08:10:53 pts/6    0:00 -ksh  
 dhorvath 3266  8848 11 10:50:40 pts/6    0:00 ps -f  
 dhorvath 8848  3662  1 10:50:38 pts/6    0:00 csh % 
  
 The C shell uses the percent sign as a prompt. After the 
 csh
  command starts the shell, the prompt becomes 
 the percent sign. The 
 ps
  command shows 
 csh
  as a child process and subshell of 
 ksh
 . To exit 
 csh
  and 
 return to the parent shell, you enter 
 exit
 .",NA
Process Permissions ,NA,NA
Overlaying the Current Process ( ,NA,NA
exec,NA,NA
 Command) ,"In addition to creating (forking) child processes, you can overlay the current process with another. The 
 exec 
 command replaces the current process with the new one. Use this command only with great caution. If you 
 use 
 exec
  in your primary (login) shell interpreter, that shell interpreter ( 
 ksh
  with pid 
 3662
  in the previous 
 examples) is replaced with the new process. 
  
 Using the command 
 exec ls 
 at your login shell prompt gives you a directory listing and then disconnects 
 you from the system, logging you out. Because 
 exec
  overlays your shell ( 
 ksh
 , for example), there are no 
 programs to handle commands for you when 
 ls
  finishes and exits. 
  
 You can use 
 exec
  to change your shell interpreter completely without creating a subshell. To convert from 
 ksh
  to 
 csh
 , you can use the following: 
  
 $ exec csh 
  
 % ps -f 
  
  
  UID   PID  PPID  C    STIME TTY      TIME CMD   
 dhorvath  3662  3657  0 08:10:53 pts/6    0:00 csh  
 dhorvath  3266  3662 11 14:50:40 pts/6    0:00 ps -f % 
  
 The prompt changes and 
 ps
  shows 
 csh
  instead of 
 ksh
  but with the original pid and start time. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 6: Processes 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Starting a Process
  
 Summary
  
 Listing Running Processes
  
 Questions
  
 Killing a Process (kill Command)
  
 Terms
  
 Parent and Child Processes
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Summary,"In this chapter, you looked at the four major topics involving processes provided with the shell: 
  
 G
 Starting a process 
  
 G
 Listing running processes 
  
 G
 Killing a process ( 
 kill
  command) 
  
 G
 Parent and child processes 
  
 As you write scripts and use the shell, knowing how to work with processes improves your productivity. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 6: Processes 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Starting a Process
  
 Summary
  
 Listing Running Processes
  
 Questions
  
 Killing a Process (kill Command)
  
 Terms
  
 Parent and Child Processes
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 How do you run a command in the background? 
  
 2. 
 How do you determine what processes you are running? 
  
 3. 
 How do you change a foreground process into a background process? 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 6: Processes 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Starting a Process
  
 Summary
  
 Listing Running Processes
  
 Questions
  
 Killing a Process (kill Command)
  
 Terms
  
 Parent and Child Processes
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Background
 --Background describes processes usually running at a lower priority and with their input 
 disconnected from the interactive session. Input and output are usually directed to a file or other process. 
  
 Background Processes 
 --Background processes are autonomous processes that run under UNIX without 
 requiring user interaction. 
  
 bash
 --
 bash
  stands for the GNU Bourne Again Shell and is based on the Bourne shell, 
 sh
 , the original 
 command interpreter. 
  
 Bourne Shell 
 --This shell is the original standard user interface to UNIX that supported limited programming 
 capability. 
  
 BSD
 --BSD is an acronym for Berkeley Software Distribution. 
  
 BSD UNIX 
 --This version of UNIX was developed by Berkeley Software Distribution and written at University 
 of California, Berkeley. 
  
 C Shell 
 --This user interface for UNIX, written by Bill Joy at Berkeley, features C programming-like syntax. 
  
 Child Processes 
 --See 
 subprocesses
 .
  
 Child Shells 
 --See 
 subshells
 .
  
 Daemons
 --Daemons are system-related background processes that often run with the permissions of root 
 and services requests from other processes. 
  
 Korn Shell 
 --This shell is a user interface for UNIX with extensive scripting (programming) support. It was 
 written by David G. Korn. The shell features command-line editing and also accepts scripts written for the 
 Bourne shell. 
  
 Parent Process Identifier 
 --The parent process identifier is shown in the heading of the 
 ps
  command as 
 PPID
 . This is the process identifier of the parent process. See also 
 parent processes 
 .
  
 Parent Processes 
 --These processes control other processes that are often referred to as child processes 
 or subprocesses. See 
 processes
 .
  
 Parent Shell 
 --This shell controls other shells, which are often referred to as child shells or subshells. The 
 login shell is typically the parent shell. See 
 shells
 .",NA
Hour 7 ,NA,NA
Variables ,"Variables
  are ""words"" that hold a 
 value
 . The shell enables you to create, assign, and delete 
 variables. Although the shell manages some variables, it is mostly up to the programmer to manage 
 variables in shell scripts. 
  
 This chapter shows you how to 
  
  
 G
 Create variables 
  
  
 G
 Delete variables 
  
 This chapter also explains what environment variables are and how to use them properly. By using 
 variables, you are able to make your scripts flexible and maintainable.",NA
Defining Variables ,"Variable Names 
  
 Accessing Array Values
  
 Accessing Values 
  
 Read-only Variables
  
 Array Variables
  
 Variables are defined as follows: 
  
 name
 =
 value 
  
 In this example, 
 name
  is the name of the variable, and 
 value
  is the value it should hold. For example, 
 FRUIT=peach 
  
 defines the variable 
 FRUIT
  and assigns it the value 
 peach
 .
  
 Variables of this type are called 
 scalar
  variables. A scalar variable can hold only one value at a time. Later in 
 this chapter, you look at a different type of variable called an 
 array
  variable that can hold multiple values. 
  
 Scalar variables are also referred to as 
 name value pairs
 , because a variable's name and its value can be 
 thought of as a pair.",NA
Variable Names ,"The name of a variable can contain only letters ( 
 a
  to 
 z
  or 
 A
  to 
 Z
 ), numbers ( 
 0
  to 
 9
 ) or the underscore 
 character ( 
 _
 ). In addition, a variable's name can start only with a letter or an underscore. 
  
 The following examples are valid variable names: 
  
 _FRUIT 
  
 FRUIT_BASKET 
  
 TRUST_NO_1 
  
 TWO_TIMES_2 
  
 but
  
 2_TIMES_2_EQUALS_4
  
 is not a valid variable name. To make this a valid name, add an underscore at the beginning of its name: 
  
 _2_TIMES_2
  
 Variable names, such as 
 1
 , 
 2
  or 
 11
 , that start with numbers are reserved for use by the shell. You can use 
 the value stored in these variables, but you cannot set the value yourself. 
  
 The reason you cannot use other characters such as 
 !
 ,
 *
 , or 
 -
  is that these characters have a special 
 meaning for the shell. If you try to make a variable name with one of these special characters it confuses the 
 shell. For example, the variable names 
  
 FRUIT-BASKET 
  
 _2*2 
  
 TRUST_NO_1! 
  
 are invalid names. The error message generated by one of these variable name looks something like the 
 following:
  
 $ FRUIT-BASKET=apple 
  
 /bin/sh: FRUIT-BASKET=apple:  not found. 
  
 Variable Values 
  
 The shell enables you to store any value you want in a variable. For example, 
  
 FRUIT=peach 
  
 FRUIT=2apples 
  
 FRUIT=apple+pear+kiwi 
  
 The one thing to be careful about is using values that have spaces. For example, 
  
 $ FRUIT=apple orange plum",NA
Accessing Values ,"To access the value stored in a variable, prefix its name with the dollar sign ( 
 $
 ). For example, the command 
 $ echo $FRUIT 
  
 peach 
  
 prints out the value stored in the variable 
 FRUIT
 , in this case 
 peach
 .
  
 If you do not use the dollar sign ( 
 $
 ) to access the value of a variable, the name of the variable is printed 
 instead of its value. For example, 
  
 $ echo FRUIT 
  
 FRUIT 
  
 simply prints out 
 FRUIT
 , not the value of the variable 
 FRUIT
 .
  
 The dollar sign ( 
 $
 ) is used only to access a variable's value, not to define it. For example, the assignment 
 $ $FRUIT=apple 
  
 generates the following warning message 
  
 sh: peach=apple: not found 
  
 if 
 FRUIT
  is defined as given previously. 
  
 If the variable 
 FRUIT
  is undefined the error would be 
  
 sh: =apple: not found 
  
 Remember that when the dollar sign ( 
 $
 ) character precedes a variable name, the value of the variable is 
 substituted. For more information on the types of variable substitution available in 
 sh
 , please consult the 
 section, 
 ""Variable Substitution,""
  in 
 Chapter 8, ""Substitution.""",NA
Array Variables ,"The Bourne shell, 
 sh
 , supports only 
 scalar
  variables, which are the type of variables you have seen so far. 
 The Korn shell, 
 ksh
 , extends this to include array variables. Version 2.0 and later of the Bourne Again shell, 
 bash
 , also support array variables. The examples in the following section assume that you are using either 
 ksh
  or 
 bash
  2. 
 x
  or later. 
  
 Arrays
  provide a method of grouping a set of variables. Instead of creating a new name for each variable 
 that is required, you can use a single array variable that stores all the other variables. 
  
 The difference between an array variable and a scalar variable can be explained as follows. Say that you 
 are trying to represent the chapters in this book as a set of variables. Each of the individual variables is a 
 scalar variable. 
  
 Some of these variables might be 
  
 CH01 
  
 CH02 
  
 CH15 
  
 CH07 
  
 Here is a format for each of the variable names: the letters 
 CH
  followed by the chapter number. This format 
 serves as a way of grouping these variables together. An array variable formalizes this grouping by using an 
 array name in conjunction with a number that is called an 
 index
 .
  
 The simplest method of creating an array variable is to assign a value to one of its indices. This is expressed 
 as follows: 
  
 name
 [
 index
 ]=
 value
  
 Here 
 name
  is the name of the array, 
 index
  is the index of the item in the array that you want to set, and 
 value
  is the value you want to set for that item. 
  
 As an example, the following commands 
  
 $ FRUIT[0]=apple 
  
 $ FRUIT[1]=banana 
  
 $ FRUIT[2]=orange 
  
 set the values of the first three items in the array named 
 FRUIT
 . You could do the same thing with scalar 
 variables as follows: 
  
 $ FRUIT_0=apple 
  
 $ FRUIT_1=banana 
  
 $ FRUIT_2=orange 
  
 Although this works fine for small numbers of items, the array notation is much more efficient for large 
 numbers of items. If you have to write a script using only 
 sh
 , you can use this method for simulating arrays.",NA
Accessing Array Values ,"After you have set any array variable, you access it as follows: 
  
 ${
 name
 [
 index
 ]}
  
 Here 
 name
  is the name of the array, and 
 index
  is the index that interests us. For example, if the array 
  
 FRUIT
  was initialized as given previously, the command 
  
 $ echo ${FRUIT[2]}
  
 produces the following output: 
  
 orange
  
 You can access all the items in an array in one of the following ways: 
  
 ${
 name
 [*]} 
  
 ${name[@]} 
  
 Here 
 name
  is the name of the array you are interested in. If the 
 FRUIT
  array is initialized as given 
  
 previously, the command 
  
 $ echo ${FRUIT[*]}
  
 produces the following output: 
  
 apple banana orange
  
 If any of the array items hold values with spaces, this form of array access will not work and will need to use 
  
 the second form. The second form quotes all the array entries so that embedded spaces are preserved. 
  
 For example, define the following array item: 
  
 FRUIT[3]=""passion fruit""",NA
Read-only Variables ,"The shell provides a way to mark variables as read-only by using the 
 readonly
  command. After a variable 
 is marked read-only, its value cannot be changed. 
  
 Consider the following commands: 
  
 $ FRUIT=kiwi 
  
 $ readonly FRUIT 
  
 $ echo $FRUIT 
  
 kiwi 
  
 $ FRUIT=cantaloupe 
  
 The last command results in an error message: 
  
 /bin/sh: FRUIT: This variable is read only.
  
 As you can see, the 
 echo
  command can read the value of the variable 
 FRUIT
 , but the shell did not enable 
 us to overwrite the value stored in the variable 
 FRUIT
 .
  
 This feature is often used in scripts to make sure that critical variables are not overwritten accidentally. In 
 ksh
  and 
 bash
 , the 
 readonly
  command can be used to mark array and scalar variables as read-only. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Contents
  
 Inde
 x",NA
Unsetting Variables ,"Unsetting
  a variable tells the shell to remove the variable from the list of variables that it tracks. 
 This is like asking the shell to forget a piece of information because it is no longer required. 
  
 Both scalar and array variables are unset using the 
 unset
  command:
  
 unset 
 name 
  
 Here 
 name
  is the name of the variable to unset. For example, 
 unset FRUIT 
  
 unsets the variable 
 FRUIT
 .
  
 You cannot use the 
 unset
  command to unset variables that are marked 
 readonly
 .
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 7: Variables 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Defining Variables
  
 Summary
  
 Unsetting Variables
  
 Questions
  
 Environment Variables
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Environment Variables ,"When a shell is running, three main types of variables are present: 
  
 G
 Local Variables 
  
 G
 Environment Variables 
  
 G
 Shell Variables 
  
 A 
 local variable 
 is a variable that is present within the current instance of the shell. It is not 
 available to programs that are started by the shell. The variables that you looked at previously have all been 
 local variables. 
  
 An 
 environment variable 
 is a variable that is available to any child process of the shell. Some 
 programs need environment variables in order to function correctly. Usually a shell script defines only those 
 environment variables that are needed by the programs that it runs. 
  
 A 
 shell variable 
 is a special variable that is set by the shell and is required by the shell in order to 
 function correctly. Some of these variables are environment variables whereas others are local variables. 
  
 Table 7.1 gives a summary of the different types of variables discussed in this section. This table compares 
 local variables set by the user, environment variables set by the user, and shell variables set by the shell. 
  
 Table 7.1  A Comparison of Local, Environment, and Shell Variables 
  
   
 Attribute
  
  
  
  
 Local Environment Shell
  
  
  
  
   
  
 Accessible by 
  
  
  
 No
  
  
  
 Yes
  
  
  
 Yes child processes 
  
  
  
 Set by users 
  
  
  
 Yes
  
  
  
 Yes
  
  
  
 No
  
  
  
  
 Set by the shell No
  
  
  
  
 No
  
  
  
 Yes
  
  
  
  
 User modifiable Yes
  
  
  
  
 Yes
  
  
  
 No
  
  
  
  
 Required by the No
  
  
  
  
 No
  
  
  
 Yes shell",NA
Exporting Environment Variables ,"You place variables in the environment by 
 exporting
  them. Exporting can be done as follows: 
  
 export 
 name",NA
Shell Variables ,"The variables that you have examined so far have all been 
 user variables 
 . A user variable is one 
 that the user can manually set and reset. 
  
 In this section, you look at 
 shell variables
 , which are variables that the shell sets during initialization and",NA
Summary,"In this chapter, you looked at using variables for shell script programming. You learned how to define, 
 access, and unset scalar and array variables. You also looked at special classes of variables known as 
 environment variables and shell variables. 
  
 In the following chapters, you look at how variables are used to achieve a greater degree of flexibility and 
 clarity in shell scripts. As you read, continue learning about shell programming until using variables becomes 
 second nature to you.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 7: Variables 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Defining Variables
  
 Summary
  
 Unsetting Variables
  
 Questions
  
 Environment Variables
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Which of the following are valid variable names? 
  
  
 a. 
 _FRUIT_BASKET 
  
  
 b. 
 1_APPLE_A_DAY 
  
  
 c. 
 FOUR-SCORE&7YEARS_AGO 
  
  
 d. 
 Variable 
  
 2. 
 Is the following sequence of array assignments valid in 
 sh
 , 
 ksh
 , and 
 bash
 ?
  
 $ adams[0]=hitchhikers_guide 
  
 $ adams[1]=restaurant 
  
 $ adams[3]=thanks_for_all_the_fish 
  
 $ adams[42]=life_universe_everything 
  
 $ adams[5]=mostly_harmless 
  
 3. 
 Given the preceding array assignments, how would you access the array item at index 5 in the 
 array 
 adams
 ? How about every item in the array?
  
 4. 
 What is the difference between an environment variable and a local variable? 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 7: Variables 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Defining Variables
  
 Summary
  
 Unsetting Variables
  
 Questions
  
 Environment Variables
  
 Terms",NA
Terms,"Scalar Variable 
   A 
 scalar variable 
 can hold only one value at a time. 
  
 Array Variable 
   An 
 array variable 
 is a mechanism available in 
 bash
  and 
 ksh
  for grouping scalar variables 
 together. The scalar variables stored in an array are accessed using a single name in conjunction with a 
 number. This number is referred to as an index. 
  
 Local Variable 
   A 
 local variable 
 is a variable that is present within the current instance of the shell. It is not 
 available to programs that are started by the shell. 
  
 Environment Variable 
   An 
 environment variable 
 is a variable that is available to any program that is 
 started by the shell. 
  
 Shell Variable 
   A 
 shell variable 
 is a special variable that is set by the shell and is required by the shell in 
 order to function correctly. 
  
 Exporting
   A variable is placed in the environment by 
 exporting
  it using the 
 export
  command.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 7: Variables 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Defining Variables
  
 Summary
  
 Unsetting Variables
  
 Questions
  
 Environment Variables
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 8 ,NA,NA
Substitution ,"The shell performs substitution when it encounters an expression that contains one or more special 
 characters. 
  
 In the last chapter, you learned how to access a variable's value using the special 
 $
  character. 
 The process of retrieving the value of a variable is called 
 variable substitution
 . In addition to this type of 
 substitution, the shell can perform several other types of substitutions: 
  
 G
 Filename substitution (called 
 globbing
 ) 
  
 G
 Value-based variable substitution 
  
 G
 Command substitution 
  
 G
 Arithmetic substitution 
  
 In this chapter, you look at each of these types of substitution in detail.",NA
Filename Substitution (Globbing) ,"The most common type of substitution is filename substitution. It is sometimes referred to as 
 globbing
 .
  
 Filename substitution is the process by which the shell expands a string containing wildcards into a list of 
 filenames. Table 8.1 provides the wildcards that the shell understands. 
  
 Tip -
  Any command or script that operates on files can take advantage of filename substitution. The examples in this 
 section use the 
 ls
  command so that the results of the filename substitution are clear. You can use any command in 
 place of the 
 ls
  command. 
  
 Table 8.1  Wildcards Used in Filename Substitution 
  
   
 Wildcard
  
  
  
 Description
  
  
  
 *
  
  
  
 Matches zero or more occurrences of any character 
  
  
  
 ?
  
  
  
 Matches one occurrence of any character 
  
  
  
  
 [
 characters
 ]
  Matches one occurrence of any of the given 
 characters",NA
Using the ,NA,NA
*,NA,NA
 Wildcard ,"The simplest form of filename substitution is the 
 *
  character. The 
 *
  tells the shell to match zero or more 
  
 occurrences of any character. If given by itself, it matches all filenames. For example, the command 
  
 $ ls *
  
 lists every file and the contents of every directory in the current directory. If there are any invisible files or 
  
 directories, they are not listed. You need to specify the 
 -a
  option to 
 ls
 , as described in 
 Chapter 3, ""Working 
  
 with Files."" 
  
 Using the 
 *
  character by itself is required in many cases, but its strength lies in the fact that you can use it to 
  
 match file suffixes, prefixes, or both. 
  
 Matching a File Prefix 
  
 To match a file prefix, use the 
 *
  character as follows: 
  
 commandprefix
 *
  
 Here, 
 command
  is the name of a command, such as 
 ls
 , and 
 prefix
  is the filename prefix you want to 
  
 match. For example, the command 
  
 $ ls ch1*
  
 matches all the files and directories in the current directory that start with the letters 
 ch1
 . The output is 
  
 similar to the following: 
  
 ch10-01  ch10-02  ch10-03  ch11-01  ch11-02  ch11-03
  
 By varying the prefix slightly, you can change lists of files that are matched. For example, the command 
  
 $ ls ch10*
  
 generates the following list of files on your system: 
  
 ch10-01  ch10-02  ch10-03
  
 You can vary the suffix until it matches the list of files that you want to manipulate.
  
 Matching a File Suffix 
  
 To match a file suffix, you use the 
 *
  character as follows: 
  
 command
  *
 suffix",NA
Using the ,NA,NA
?,NA,NA
 Wildcard ,"One limitation of the 
 *
  wildcard is that it matches one or more characters each time. 
  
 As an example, consider a situation where you need to list all files that have names of the form 
 ch0
 X
 .doc
 , 
 where 
 X
  is a single number or letter. It seems like the command 
  
 $ ls ch0*.doc
  
 would produce the appropriate match, but the actual output might look like: 
  
 ch01-1.doc  ch010.doc   ch02.doc    ch03-2.doc  ch04-1.doc  ch040.doc 
  
 ch05.doc    ch06-2.doc 
  
 ch01-2.doc  ch02-1.doc  ch020.doc   ch03.doc    ch04-2.doc  ch05-1.doc 
 ch050.doc   ch06.doc 
  
 ch01.doc    ch02-2.doc  ch03-1.doc  ch030.doc   ch04.doc    ch05-2.doc   ch06-
 1.doc  ch060.doc 
  
 In order to match only one character, the shell provides you with the 
 ?
  wildcard. You can rewrite the 
 command using this wildcard: 
  
 $ ls ch0?.doc
  
 Now you see that the output matches only those files you are interested in: 
  
 ch01.doc  ch02.doc  ch03.doc  ch04.doc  ch05.doc  ch06.doc
  
 Say that you now want to look for all files that have names of the form 
 ch
 XY
 , where 
 X
  and 
 Y
  are any number 
 or character. You can use the command",NA
Matching Sets of Characters ,"Two potential problems with the 
 ?
  and 
 *
  wildcards are 
  
 G
 They match any character, including special characters such as hyphens ( 
 -
 ) or underlines ( 
 _
 ).
  
 G
 You have no way to indicate that you want to match only letters or only numbers to these operators. 
  
 Sometimes you need more control over the exact characters that you match. Consider the situation where 
  
 you want to match filenames of the form 
 ch0
 X
 , where 
 X
  is a number between 0 and 9. Neither the 
 *
  or the 
 ?
  
 operator is cut out for this job. 
  
 Fortunately, the shell provides you with the capability to match sets of characters using the 
 [
  wildcard. The 
  
 syntax for using this wildcard is 
  
 command
  [
 characters
 ]
  
 Here 
 command
  is the name of a command, such as 
 ls
 , and 
 characters
  represents the characters you 
  
 want to match. For example, the following command fulfills the previous requirements: 
  
 $ ls ch0[0123456789].doc 
  
 ch01.doc  ch02.doc  ch03.doc  ch04.doc  ch05.doc  ch06.doc 
  
 One thing that you might have noticed is that you had to list all the characters that you wanted matched. The 
  
 shell provides a mechanism to shorten the list. For example, the command
  
 $ ls ch0[0-9].doc
  
 produces the same list of files. As you can probably guess, this is most useful when you're trying to match 
  
 sets of letters. For example, 
  
 $ ls [a-z]*
  
 lists all the files starting with a lowercase letter. To match all the files starting with uppercase letters use the 
  
 following: 
  
 $ ls [A-Z]*
  
 The 
 [
  wildcard also enables you to combine sets by putting the sets together. For example, 
  
 $ ls [a-zA-Z]*
  
 matches all files that start with a letter, whereas the command",NA
Variable Substitution ,"Variable substitution enables the shell programmer to manipulate the value of a variable based on its state. 
 Variable substitution falls into two categories: 
  
 G
 Actions taken when a variable has a value 
  
 G
 Actions taken when a variable does not have a value 
  
 The actions range from one time value substitution to aborting the script. 
  
 These categories are broken down into four forms of variable substitution. You can use variable 
  
 substitutions as shorthand forms of expressions that would have to be written as explicit 
 if-then-else 
 statements, covered in 
 Chapter 10, ""Flow Control.""
  Table 8.2 provides a summary of all variable substitution 
  
 methods. 
  
 Table 8.2  Variable Substitution 
  
   
 Form
  
  
  
 Description
  
  
  
 ${
 parameter
 :-
 word
 }
  
  
  
 If 
 parameter
  is null or unset, 
 word
  is substituted for 
 parameter
 . The 
 value of 
 parameter
  does not change. 
  
  
  
 ${
 parameter
 :=
 word
 }
  
  
  
 If 
 parameter
  is null or unset, 
 parameter
  is set to the value of 
 word
 .
  
  
  
  
  
 checks that variables are set correctly. 
  
 ${
 parameter
 :?
 message
 }
  If 
 parameter
  is null or unset, 
 message
  is printed to standard error. This 
  
  
 ${
 parameter
 :+
 word
 }
  
  
  
 If 
 parameter
  is set, 
 word
  is substituted for 
 parameter
 . The value of 
 parameter
  does not change.",NA
Substituting a Default Value ,"The first form enables a default value to be substituted when a variable is unset or null. This is formally 
 described as 
  
 ${
 parameter
 :-
 word
 }
  
 Here 
 parameter
  is the name of the variable, and 
 word
 is the default value. A simple example of its use is 
  
 PS1=${HOST:-localhost}""$ "" ; export PS1 ;
  
 You could use this in a user's 
 .profile
  to make sure that the prompt is always set correctly. This form of 
 variable substitution does not affect the value of the variable. It performs substitution only when the variable",NA
Assigning a Default Value ,"To set the value of a variable, the second form of variable substitution must be used. This form is formally 
 described as: 
  
 ${
 parameter
 :=
 word
 }
  
 Here, 
 parameter
  is the name of the variable, and 
 word
  is the default value to set the variable to if it is 
 unset. Appending the previous example, you have 
  
 PS1=${HOST:=´uname -n´}""$ "" ; export PS1 HOST ;
  
 After the execution of this statement, both 
 HOST
  and 
 PS1
  are set. This example also demonstrates the fact 
 that the default string to use does not have to be a fixed string but can be the output of a command. If this 
 substitution did not exist in the shell, the same line would have to be written as 
  
 if [ -z ""$HOST"" ] ; then HOST=´uname -n´ ; fi ; PS1=""$HOST$ "";  export PS1 
 HOST ; 
  
 As you can see, the variable substitution form is shorter and clearer than the explicit form.",NA
Aborting Due to Variable Errors ,"Sometimes substituting default values can hide problems, thus 
 sh
  supports a third form of variable 
 substitution that enables a message to be written to standard error when a variable is unset. This form is 
 formally described as 
  
 ${
 parameter
 :?
 message
 }
  
 A common use of this is in shell scripts and shell functions requiring certain variables to be set for proper 
 execution. For example, the following command exits if the variable 
 $HOME
  is unset: 
  
 : ${HOME:?""Your home directory is undefined.""}
  
 In addition to using the variable substitution form described previously, you are also making use of the no-op 
 ( 
 no-op
  as in 
 no operation 
 ) command, 
 :
 , which simply evaluates the arguments passed to it. Here you are 
 checking to see whether the variable 
 HOME
  is defined. If it is not defined, an error message prints. 
  
 The final form of variable substitution is used to substitute when a variable is set. Formally this is described 
 as 
  
 ${
 parameter
 :+
 word
 }
  
 Here 
 parameter
  is the name of the variable, and 
 word
  is the value to substitute if the variable is set. This 
 form does not alter the value of the variable; it alters only what is substituted. A frequent use is to indicate 
 when a script is running in debug mode:",NA
Command and Arithmetic Substitution ,"Command Substitution
  
 Arithmetic Substitution
  
 Two additional forms of substitution provided by the shell are 
  
 G
 Command substitution 
  
 G
 Arithmetic substitution 
  
  Command substitution 
 enables you to capture the output of a command and substitute it in 
 another command, whereas arithmetic substitution enables you to perform simple integer mathematics 
 using the shell.",NA
Command Substitution ,"Command substitution is the mechanism by which the shell performs a given set of commands and then 
 substitutes their output in the place of the commands. Command substitution is performed when a command 
 is given as 
  
 ´command´
  
 Here 
 command
 , can be a simple command, a pipeline, or a list. 
  
 Caution -
  Make sure that you are using the backquote, not the single quote character, when performing command 
 substitution. Command substitution is performed by the shell only when the backquote, or backtick, character, 
 ´
 , is 
 given. Using the single quote instead of the back quote is a common error in shell scripts leading to many hard to find 
 bugs. 
  
 Command substitution is generally used to assign the output of a command to a variable. Each of the 
 following examples demonstrate command substitution: 
  
 DATE=´date´ 
  
 USERS=´who | wc -l´ 
  
 UP=´date ; uptime´ 
  
 In the first example, the output of the 
 date
  command becomes the value for the variable 
 DATE
 . In the 
 second example, the output of the pipeline becomes the value of the variable 
 USERS
 . In the last example, 
 the output of the list becomes the value of the variable 
 UP
 .",NA
Arithmetic Substitution ,"In 
 ksh
  and 
 bash
 , the shell enables integer arithmetic to be performed. This avoids having to run an extra 
 program such as 
 expr
  or 
 bc
  to do math in a shell script. This feature is not available in 
 sh
 .
  
 Arithmetic substitution is performed when the following form of command is given: 
  
 $((
 expression
 )) 
  
 Expressions are evaluated according to standard mathematical conventions. Table 8.3 provides the 
 available operators. The operators are listed in order of precedence. 
  
 Table 8.3  Arithmetic Substitution Operators 
  
  
  
 Operator Description
  
  
  
  
 /
  
  
  
 The division operator. Divides two numbers and returns the result. 
  
  
  
 *
  
  
  
 The multiplication operator. Multiples two numbers and returns the result. 
  
  
  
 -
  
  
  
 The subtraction operator. Subtracts two numbers and returns the result. 
  
  
  
 +
  
  
  
 The addition operator. Adds two numbers and returns the result. 
  
  
  
 ()
  
  
  
 The parentheses clarify which expressions should be evaluated before others. 
  
  
  
 You use the following command as an illustration of the operators and their precedence: 
  
 foo=$(( ((5 + 3*2) - 4) / 2 )) 
  
 After this command executes the value of 
 foo
  to 3. Because this is integer arithmetic, the value is not 3.5, 
 and because of operator precedence the value is not 6.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 8: Substitution 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Filename Substitution (Globbing)
  
 Summary
  
 Variable Substitution
  
 Questions
  
 Command and Arithmetic Substitution",NA
Summary,"In this chapter, you have looked at the four main forms of substitution available in the shell: 
  
 G
 Filename substitution 
  
 G
 Variable substitution 
  
 G
 Command substitution 
  
 G
 Arithmetic substitution 
  
 As you write scripts and use the shell to solve problems, you find that these types of substitution help you 
 extensively.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 8: Substitution 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Filename Substitution (Globbing)
  
 Summary
  
 Variable Substitution
  
 Questions
  
 Command and Arithmetic Substitution
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What combination of wildcards should you use to list all the files in the current directory that end in 
 the form 
 hw
 XYZ
 .
 ABC
 ?
  
 Here 
 X
  and 
 Y
  can be any number; 
 Z
 is a number between 2 and 6; and 
 A
 , 
 B
 , and 
 C
  are any 
 character. 
  
 2. 
 What action is performed by the following line, if the variable 
 MYPATH
  is unset: 
  
 : ${MYPATH:=/usr/bin:/usr/sbin:/usr/ucb} 
  
 3. 
 What is the difference between the actions performed by the command given in the previous 
 problem and the action performed by the following command: 
  
 : ${MYPATH:-/usr/bin:/usr/sbin:/usr/ucb} 
 4. 
 What is the result of the following arithmetic substitution: 
  
 $(( 3 * 2 + ( 4 - 3 / 4) ))
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 8: Substitution 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Filename Substitution (Globbing)
  
 Summary
  
 Variable Substitution
  
 Questions
  
 Command and Arithmetic Substitution
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 9 ,NA,NA
Quoting ,"By Frank Watson 
  
 In the preceding chapter, you looked at shell substitution, which occurs automatically whenever you enter a 
 command containing a wildcard character or a 
 $
  parameter. The way the shell interprets these and other 
 special characters is generally useful, but sometimes it is necessary to turn off shell substitution and let each 
 character stand for itself. Turning off the special meaning of a character is called 
 quoting
 , and it can be done 
 three ways: 
  
 G
 Using the backslash ( 
 \
 ) 
  
 G
 Using the single quote ( 
 '
 ) 
  
 G
 Using the double quote ( 
 ""
 )
  
 Quoting can be a very complex issue, even for experienced UNIX programmers. In this chapter you look at 
 each of these forms of quoting and how to use them. You learn a series of simple rules to help you 
 understand when quoting is needed and how to do it correctly.",NA
Quoting with Backslashes ,"First, use the 
 echo
  command to see what a special character is. The 
 echo
  command is covered in more 
 detail in 
 Chapter 13, ""Input/Output,""
  but it is a simple command that just displays the arguments it has been 
  
 given on the command line. For example, 
  
 echo Hello world
  
 displays the following message on your screen: 
  
 Hello world
  
 Here is a list of most of the shell special characters (also called 
 metacharacters
 ):
  
 * ? [ ] ' "" \ $ ; & ( ) | ^ < > new-line space tab
  
 Watch what happens if you add one of them to the 
 echo
  command: 
  
 echo Hello; world",NA
Using Single Quotes ,"Here is an 
 echo
  command that must be modified because it contains many special shell characters: 
 echo <-$1250.**>; (update?) [y|n] 
  
 Putting a backslash in front of each special character is tedious and makes the line difficult to read: 
  
 echo \<-\$1250.\*\*\>\; \(update\?\) \[y\|n\] 
  
 There is an easy way to quote a large group of characters. Put a single quote ( 
 '
 ) at the beginning and at 
 the end of the string: 
  
 echo '<-$1250.**>; (update?) [y|n]' 
  
 Any characters within single quotes are quoted just as if a backslash is in front of each character. So now 
 this 
 echo
  command displays properly. 
  
 Note -
  Quoting regular characters is harmless. In the previous example, you put single quotes around a whole string, 
 quoting both the special characters and the regular letters and digits that need no quoting. It does not hurt to quote 
 regular characters because quoting takes away any special meaning from a character and does not mind if that 
 character had no special meaning to begin with. This is true for the backslash, single quotes, and double 
  
 If a single quote appears within a string to be output, you should not put the whole string within single 
 quotes: 
  
 echo 'It's Friday' 
  
 This fails and only outputs the following character, while the cursor waits for more input: 
  
 > _ 
  
 The 
 >
 sign is the secondary shell prompt (as stored in the PS2 shell variable), and it indicates that you have 
 entered a multiple-line command--what you have typed so far is incomplete. Single quotes must be entered 
 in pairs, and their effect is to quote all characters that occur between them. In case you are wondering, you 
 cannot get around this by putting a backslash before an embedded single quote. 
  
 You can correct the previous example by not using single quotes as the method of quoting. Use one of the",NA
Using Double Quotes ,"Single quotes can sometimes take away too much of the shell's special conveniences. The following 
 echo 
 statement contains many special characters that must be quoted in order to use them literally: 
  
 echo '$USER owes <-$1250.**>; [ as of (´date +%m/%d´) ]'
  
 The output using single quotes is easy to predict--what you see is what you get: 
  
 $USER owes <-$1250.**>; [ as of (´date +%m/%d´) ]
  
 However, this is not exactly what you want in this case. Single quotes prevent variable substitution (covered 
  
 in 
 Chapter 8, ""Substitution""
 ), so 
 $USER
  is not replaced by the specific user name stored in that variable. 
  
 Single quotes also prevent command substitution (covered in 
 Chapter 8
 ), so the attempt to insert the current 
  
 month and day using the date command within backquotes fails. 
  
 Double quotes are the answer to this situation. 
  
 Double quotes take away the special meaning of all characters except the following: 
  
 G
 $
  for parameter substitution. 
  
 G
 Backquotes for command substitution. 
  
 G
 \$
  to enable literal dollar signs. 
  
 G
 \´
  to enable literal backquotes. 
  
 G
 \""
  to enable embedded double quotes. 
  
 G
 \\
  to enable embedded backslashes. 
  
 G
 All other 
 \
  characters are literal (not special). 
  
 Watch what happens if you use double quotes like this: 
  
 echo ""$USER owes <-$1250.**>; [ as of (´date +%m/%d´) ]""
  
 Notice in the following output that the double quotes enable variable substitution to replace 
 $USER
  and 
 command substitution to replace 
 ´date +%m/%d´ 
 :
  
 Fred owes <-250.**>; [ as of (12/21) ]
  
 As you can see in this example, double quotes permit you to display many special characters literally while 
  
 still enabling 
 $
  and backquote substitutions. However, notice the amount of money owed is incorrect 
 because 
 $1
  is substituted. To correct this, always use a leading backslash to escape any 
 $
  within double",NA
Quoting Rules and Situations ,"Quoting Ignores Word Boundaries 
  
 Quoting to Access Filenames Containing Special Characters
  
 Combining Quoting in Commands 
  
 Quoting Regular Expression Wildcards
  
 Embedding Spaces in a Single Argument 
  
 Quoting Newlines to Continue on the Next Line
  
 Quoting the Backslash to Enable echo Escape Sequences 
 Quote Wildcards for cpio and find
  
 Now that you know the basics, you can learn some additional rules to help you use quoting. You can also 
 look at various UNIX commands and apply quoting to other situations.",NA
Quoting Ignores Word Boundaries ,"In English, you are used to quoting whole words or sentences. In shell programming, the special characters 
 must be quoted, but it does not matter whether the regular characters are quoted in the same word, as 
 follows: 
  
 echo ""Hello; world""
  
 You can move the quotes off word boundaries as long as any special characters remain quoted. This 
 command produces the same output as the preceding one: 
  
 echo Hel""lo; w""orld
  
 Of course, it is easier to read the line if the quotes are on word boundaries. I present this point here to help 
 you understand quoting and because you need this knowledge for more complex quoting situations.",NA
Combining Quoting in Commands ,"You can freely switch from one type of quoting to another within the same command. This example contains 
 single quotes, a backslash, and then double quotes: 
  
 echo The '$USER' variable contains this value \> ""|$USER|""
  
 Here is the output of this command if 
 fred
  is the current content of 
 $USER
 :
  
 The $USER variable contains this value > |fred|",NA
Embedding Spaces in a Single Argument ,NA,NA
Quoting Newlines to Continue on the Next Line ,"The newline character is found at the end of each line of a UNIX shell script; it is a special character that 
  
 tells the shell that it has encountered the end of the command line. You insert the newline character by 
  
 pressing Enter to go to the next line when inserting text in your shell script. Normally you can't see the 
  
 newline character, but if you are in the 
 vi
  editor, 
 :set list 
 will mark each newline character with a dollar 
  
 sign. You can quote the newline character to enable a long command to extend to the next line: 
  
 $ cp file1 file2 file3 file4 file5 file6 file7 \ 
  
 > file8 file9 /tmp 
  
 Notice the last character in the first line is a backslash, which is quoting the newline character implied at the 
  
 end of the line. The shell recognizes this and displays 
 >
  (the 
 PS2
  prompt) as confirmation that you are 
  
 entering a continuation line or multiple-line command.",NA
Quoting to Access Filenames Containing Special Characters ,"In the previous chapter, you learned that any word that contains the characters 
  
 * ? [ ]
  
 is expanded to a list of files that match the wildcard pattern given. For example, the command 
  
 rm ch1*
  
 removes all files whose names have the prefix of 
 ch1
 . In this case, the 
 *
  character is a special character. 
  
 Most of the time, this is exactly what you want, but there is a case where you need to use quoting to remove 
  
 the character's special meaning. Assume you have these files in a directory: 
  
 ch1     ch1*     ch1a     ch15
  
 Notice that the filename 
 ch1*
  contains the 
 *
  character. Although this is certainly not recommended, 
  
 sometimes you encounter files whose names contain strange characters (usually through some accident or 
  
 mistake). If you only want to delete the file 
 ch1*
 , don't do so like this: 
  
 rm ch1*
  
 This deletes all your 
 ch1
  files. Instead, quote the special character using single quotes, double quotes, or 
  
 the backslash: 
  
 rm 'ch1*'
  
 Quoting the special character takes away its wildcard meaning and enables you to delete the desired file. 
  
 Tip -
  Avoid using special characters in filenames because you have to quote the special character each time you 
 access that file. 
  
  
 Here again is the list of special characters: 
  
  
    
 * ? [ ] ' "" \ $ ; & ( ) | ^ < > new-line space tab",NA
Quoting Regular Expression Wildcards ,"In 
 Chapter 16, ""Filtering Text Using Regular Expressions,""
  you learn about another type of wildcard called 
  
 regular expression. Regular expressions use some of the same wildcard characters as filename substitution, 
 as you can see in this 
 grep
  command (which is covered in 
 Chapter 15, ""Text Filters""
 ): 
  
 grep '[0-9][0-9]*$' report2 report7
  
 The quoted string 
 [0-9][0-9]*$
  is a regular expression (wildcard) pattern that 
 grep
  searches for within 
 the contents of files 
 report2
  and 
 report7
 . Wildcards in the 
 grep
  pattern must be quoted to prevent the 
 shell from erroneously replacing that pattern with a list of filenames that match the pattern. 
  
 Tip -
  You should always quote your regular expressions to protect them from shell filename expansion, but 
 sometimes they work even if you don't quote them. The shell only expands the pattern if it finds existing files whose 
 names match the pattern. If you happen to be in a directory where no matching files are found, the pattern is left 
 alone, and 
 grep
  works fine. Move to another directory, though, and the exact same command might fail.",NA
Quoting the Backslash to Enable ,NA,NA
echo,NA,NA
 Escape Sequences ,"In 
 Chapter 13, ""Input/Ouput,""
  you see that 
 echo
  enables some special characters like 
 \n
 :
  
 echo -e ""Line 1\nLine 2""
  
 This displays the following: 
  
 Line 1 
  
 Line 2 
  
 The 
 -e
  option of 
 echo
  enables it to interpret 
 echo
  escape sequences as special, not literal, characters. 
 Some versions of UNIX object to 
 -e
  as an illegal option to 
 echo
 . In that case, simply omit 
 -e
  from your 
 echo
  command, as it is not required on that system to enable these escape sequences. 
  
 The 
 \n
  option is called an escape sequence because the preceding backslash causes the following 
 n
  to be 
 treated as a special character. How do the quoting rules apply here? If the backslash takes away the special 
 meaning of its following character, shouldn't you just see 
 n
  in the output? 
  
 Review Table 9.1. It shows that a backslash within double quotes is only special if it precedes these four 
 characters: 
  
 G
 $ 
  
 G
 ´
  
 G
 "" 
  
 G
 \
  
 \n
  within double quotes is treated as two normal characters that are passed to the 
 echo
  command as 
 arguments. The 
 echo
  command enables its own set of special characters, which are indicated by a",NA
Quote Wildcards for ,NA,NA
cpio,NA,NA
 and ,NA,NA
find,"There are other commands like 
 echo
  that have their own special characters that must be quoted for the 
 shell to pass them unaltered. 
 cpio
  is a command that saves and restores files. It enables shell filename 
 wildcards to select the files to restore. These wildcards must be quoted to prevent shell expansion. This 
  
 enables them to be passed to 
 cpio
  for interpretation, as in the following example: 
  
 cpio -icvdum 'usr2/*' < /dev/rmt0
  
 -icvdum
  includes options to 
 cpio
  to specify how it should restore files from the tape device 
 /dev/rmt0
 . 
  
 usr2/*
  says to restore all files from directory 
 usr2
  on tape. Again, this command sometimes works 
 correctly even if the wildcards aren't quoted because shell expansion doesn't occur if matching files aren't 
  
 found in the current path (in this case, if there is no 
 usr2
  subdirectory in the current directory). It is best to 
 quote these 
 cpio
  wildcards so you can be sure the command works properly every time. 
  
 The 
 find
  command is covered in 
 Chapter 18, ""Miscellaneous Tools.""
  It supports its own wildcards to look 
  
 for partial filenames: 
  
 find / -name 'ch*.doc' -print
  
 ch*.doc
  is a wildcard pattern that tells 
 find
  to display all filenames that start with 
 ch
  and end with a 
 .doc 
 suffix. Unlike shell filename expansion, this 
 find
  command checks all directories on the system for a match. 
 However, the wildcard must be quoted using single quotes, double quotes, or a backslash, so the 
  
 wildcard is passed to 
 find
  and not expanded by the shell.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 9: Quoting 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Quoting with Backslashes
  
 Summary
  
 Using Single Quotes
  
 Questions
  
 Using Double Quotes
  
 Terms
  
 Quoting Rules and Situations
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Summary,"In this chapter, you looked at three types of quoting and when to use them: 
  
 G
 Backslash 
  
 G
 Single quote 
  
 G
 Double quote 
  
 Here is a summary of the quoting rules you learned in this chapter in the order of presentation: 
  
 G
 A backslash takes away the special meaning of the character that follows it. 
 G
 The character doing the quoting is removed before command execution. 
  
 G
 Single quotes remove the special meaning of all enclosed characters. 
 G
 Quoting regular characters is harmless. 
  
 G
 A single quote can not be inserted within single quotes. 
  
 G
 Double quotes remove the special meaning of most enclosed characters. 
 G
 Quoting can ignore word boundaries. 
  
 G
 Different types of quoting can be combined in one command. 
  
 G
 Quote spaces to embed them in a single argument. 
  
 G
 Quote the newline to continue a command on the next line. 
  
 G
 Use quoting to access filenames that contain special characters. 
  
 G
 Quote regular expression wildcards. 
  
 G
 Quote the backslash to enable 
 echo
  escape sequences. 
  
 G
 Quote wildcards for 
 cpio
  and 
 find
 .
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 9: Quoting 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Quoting with Backslashes
  
 Summary
  
 Using Single Quotes
  
 Questions
  
 Using Double Quotes
  
 Terms
  
 Quoting Rules and Situations
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Give an 
 echo
  command to display this message: 
  
  It's <party> time!
  
 2. 
 Give an 
 echo
  command to display one line containing the following fields: 
  
 H
 The contents of variable 
 $USER 
  
  
 H
 A single space 
  
  
 H
 The word ""owes"" 
  
  
 H
 Five spaces 
  
  
 H
 A dollar sign ($) 
  
  
 H
 The contents of the variable 
 $DEBT
  (this variable contains only digits) 
 Sample output: 
  
 fred owes     $25
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 9: Quoting 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Quoting with Backslashes
  
 Summary
  
 Using Single Quotes
  
 Questions
  
 Using Double Quotes
  
 Terms
  
 Quoting Rules and Situations
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Quoting
   Quoting literally encloses selected text within some type of quotation marks. When applied to shell 
 commands, quoting means to disable shell interpretation of special characters by enclosing the characters 
 within single or double quotes or by escaping the characters. 
  
 Escaping
   Escaping a character means to put a backslash (\) just before that character. Escaping can either 
 remove the special meaning of a character in a shell command, or it can add special meaning as we saw 
 with 
 \n
  in the 
 echo
  command. The character following the backslash is called an escaped character. 
  
 Special characters, metacharacters, wildcards 
   All these terms indicate characters that are not taken at 
 face value. These characters have an extra meaning or cause some action to be taken by the shell or other 
 UNIX commands. 
  
 Literal characters 
   These characters have no special meaning and cause no extra action to be taken. 
 Quoting causes the shell to treat a wildcard as a literal character. 
  
 Newline character 
   This is literally the linefeed character whose ASCII value is 10. In general, the newline 
 character is a special shell character that indicates a complete command line has been entered and can 
 now be executed. 
  
 PS2 variable 
   This shell variable's content is usually the > character. The content of the PS2 variable is 
 displayed by the shell as a secondary prompt that indicates the previous command was not complete and 
 the current command line is a continuation of that command line. 
  
 Shell preprocessing 
   This describes actions taken by the shell to manipulate the command line before 
 executing it. This is when filename, variable, command, and arithmetic substitution occur (as covered in 
 Chapter 8
 ). 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 9: Quoting 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Quoting with Backslashes
  
 Summary
  
 Using Single Quotes
  
 Questions
  
 Using Double Quotes
  
 Terms
  
 Quoting Rules and Situations
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 10 ,NA,NA
Flow Control ,"The order in which commands execute in a shell script is called the 
 flow
  of the script. In the scripts that you 
 have looked at so far, the flow is always the same because the same set of commands executes every time. 
  
 In most scripts, you need to change the commands that execute depending on some condition provided by 
 the user or detected by the script itself. When you change the commands that execute based on a condition, 
 you change the flow of the script. For this reason, the commands discussed in this chapter are called 
 flow 
 control commands 
 . You might also see them referred to as 
 conditional flow control commands 
 because they 
 change the flow of a script based on some condition. 
  
 Two powerful flow control mechanics are available in the shell: 
  
 G
 The 
 if
  statement 
  
 G
 The 
 case
  statement 
  
 The 
 if
  statement is normally used for the conditional execution of commands, whereas the 
 case
  statement 
 enables any number of command sequences to be executed depending on which one of several patterns 
 matches a variable first. 
  
 In this chapter, I explain how to use flow control in your shell scripts.",NA
The ,NA,NA
if,NA,NA
 Statement ,"An if Statement Example
  
 Using test
  
 The 
 if
  statement performs actions depending on whether a given condition is true or false. Because the 
 return code of a command indicates true (return code is zero) or false (return code is nonzero), one of the 
 most common uses of the 
 if
  statement is in error checking. An example of this is covered shortly.
  
 The basic 
 if
  statement syntax follows: 
  
 if 
 list1 
  
 then 
  
  
 list2 
  
 elif 
 list3 
  
 then 
  
  
 list4 
  
 else",NA
An ,NA,NA
if,NA,NA
 Statement Example ,"A simple use of the 
 if
  statement is 
  
 if uuencode koala.gif koala.gif > koala.uu ; then  
 echo ""Encoded koala.gif to koala.uu"" 
  
 else 
  
  echo ""Error encoding koala.gif"" 
  
 fi 
  
 Look at the flow of control through this statement: 
  
 1. 
 First, the command 
  
 uuencode koala.gif koala.gif > koala.uu
  
 executes. This command is 
 list1
  in the general statement. 
  
 2. 
 If this command is successful, the command 
  
 echo ""Encoded koala.gif to koala.uu""",NA
Using ,NA,NA
test ,"Most often, the list given to an 
 if
  statement is one or more 
 test
  commands, which are invoked by calling 
 the 
 test
  command as follows: 
  
 test 
 expression 
  
 Here 
 expression
  is constructed using one of the special options to the 
 test
  command. The 
 test 
 command returns either a 
 0
  (true) or a 
 1
  (false) after evaluating an expression. 
  
 A shorthand for the 
 test
  command is the 
 [
  command: 
  
 [ 
 expression
  ] 
  
 Here 
 expression
  is any valid expression that the 
 test
  command understands. This shorthand form is the 
 most common form of test that you can encounter. 
  
 The types of expressions understood by test can be broken into three types: 
  
  
 G
 File tests 
  
  
 G
 String comparisons 
  
  
 G
 Numerical comparisons 
  
 You look at each of these types in turn. You also look at compound expressions, formed by combining two 
 or more test expressions.
  
  
 Note -
  When using the 
 [
  shorthand for test, the space after the open bracket ( 
 [
 ) and the space before the 
  
 close bracket ( 
 ]
 ) are required. 
  
  
 Without these spaces, the shell cannot tell where the expression begins and ends. 
  
 File Tests 
  
 File test expressions test whether a file fits some particular criteria. The general syntax for a file test is 
  
 test 
 optionfile 
  
 or
  
 [ 
 optionfile
  ] 
  
 Here 
 option
  is one of the options given in Table 10.1 and 
 file
  is the name of a file or directory. 
  
 Look at a few examples of 
 if
  statements that use the 
 test
  command to perform file tests.",NA
The ,NA,NA
case,NA,NA
 Statement ,"A case Statement Example
  
 Using Patterns
  
 The 
 case
  statement is the other major form of flow control available in the shell. In this section I explain its 
 usage. 
  
 The basic syntax is 
  
 case 
 word
  in 
  
  
 pattern1
 ) 
  
  
  
  
 list1 
  
  
  
  ;; 
  
  
 pattern2
 ) 
  
  
  
  
 list2 
  
  
  
  ;; 
  
 esac 
  
 Here the string 
 word
  is compared against every 
 pattern
  until a match is found. The 
 list
  following the 
 matching 
 pattern
  executes. If no matches are found, the 
 case
  statement exits without performing any 
 action. There is no maximum number of patterns, but the minimum is one. 
  
 When a list executes, the command 
 ;;
  indicates that program flow should jump to the end of the entire 
 case
  statement. This is similar to 
 break
  in the C programming language. 
  
 Some programmers prefer to use the form 
  
 case 
 word
  in 
  
 pattern1
 ) 
 list1 ;; 
  
 pattern2
 ) 
 list2 
 ;; 
  
 esac 
  
 This form should be used only if the 
 list
  of commands to be executed is short.",NA
A ,NA,NA
case,NA,NA
 Statement Example ,"Consider the following variable declaration and 
 case
  statement: 
  
 FRUIT=kiwi 
  
 case ""$FRUIT"" in 
  
  
  apple) echo ""Apple pie is quite tasty."" ;;",NA
Using Patterns ,"In the previous example, you used fixed strings as the pattern. If used in this fashion the 
 case
  statement 
 degenerates into an 
 if
  statement. For example, the 
 if
  statement 
  
 if [ ""$FRUIT"" = apple ] ; then 
  
  
  echo ""Apple pie is quite tasty."" 
  
 elif [ ""$FRUIT"" = banana ] ; then 
  
  
  echo ""I like banana nut bread."" 
  
 elif [ ""$FRUIT"" = kiwi ] ; then 
  
  
  echo ""New Zealand is famous for kiwi."" 
 fi 
  
 is more verbose, but the real power of the 
 case
  statement does not lie in simplifying 
 if
  statements. The 
 power lies in the fact that it uses 
 pattern
 s to perform matching. 
  
 A pattern is a string that consists of regular characters and special wildcard characters. The pattern 
 determines whether a match is present. 
  
 The patterns can use the same special characters as patterns for pathname expansion covered in 
 Chapter 
  
 8, ""Substitution,""
  along with the or operator, 
 |
 . Some default actions can be performed by giving the 
 *
  
 pattern, which matches anything. 
  
 An example of a simple 
 case
  statement that uses patterns is 
  
 case ""$TERM"" in 
  
  
  *term) 
  
  
  
  TERM=xterm ;; 
  
  
  network|dialup|unknown|vt[0-9][0-9][0-9]) 
  
  
  TERM=vt100 ;;",NA
Summary,"In this chapter, you covered the two main flow control mechanisms available in the shell. You looked at the 
 following topics related to the 
 if
  statement: 
  
 G
 Performing file tests 
  
 G
 Performing string comparisons 
  
 G
 Performing numerical comparisons 
  
 G
 Using compound expressions 
  
 You also looked at the basic 
 case
  statement and using 
 pattern
  in conjunction with it. 
  
 Starting with the next chapter, you begin to see how you can use flow control while programming. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 10: Flow Control 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The if Statement
  
 Summary
  
 The case Statement
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What is the difference between the following commands? 
  
 if [ -e /usr/local/bin/bash ] ; then /usr/local/bin/bash ; fi 
 if [ -x /usr/local/bin/bash ] ; then /usr/local/bin/bash ; fi
  
 2. 
 Given the following variable declarations, 
  
 HOME=/home/ranga 
  
 BINDIR=/home/ranga/bin
  
 what is the output of the following 
 if
  statement? 
  
 if [ $HOME/bin = $BINDIR ] ; then
  
  
  echo ""Your binaries are stored in your home directory."" 
 fi
  
 3. 
 What 
 test
  command should be used in order to test whether 
 /usr/bin
  is a directory or a symbolic 
 link? 
  
 4. 
 Given the following 
 if
  statement, write an equivalent 
 case
  statement: 
  
 if [ ""$ANS"" = ""Yes"" -o ""$ANS"" = ""yes"" -o ""$ANS"" = ""y"" -o ""$ANS"" = ""Y"" ] ; then
  
  ANS=""y"" 
  
 else 
  
  
  ANS=""n"" 
  
 fi
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 10: Flow Control 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The if Statement
  
 Summary
  
 The case Statement
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 11,NA,NA
Loops ,"In this chapter, you'll learn how to set up and use loops in your shell scripts. Loops enable you to execute a 
 series of commands multiple times. Two main types of loops are 
  
 G
 The 
 while
  loop 
  
 G
 The 
 for
  loop 
  
 The 
 while
  loop enables you to execute a set of commands repeatedly until some condition occurs. It is 
 usually used when you need to manipulate the value of a variable repeatedly. 
  
 The 
 for
  loop enables you to execute a set of commands repeatedly for each item in a list. One of its most 
 common uses is in performing the same set of commands for a large number of files. 
  
 In addition to these two types of loops, 
 ksh
  and 
 bash
  support an additional type of loop called the 
 select 
 loop. It frequently presents a menu of choices to a shell scripts user. 
  
 The first section of this chapter explains the 
 while
  loop and its uses. The second section of this chapter 
 shows you how to use the 
 for
  and 
 select
  loops.",NA
The ,NA,NA
while,NA,NA
 Loop ,"Validating User Input
  
 The until Loop
  
 The basic syntax of the 
 while
  loop is 
  
 while 
 command 
  
 do 
  
 list 
  
 done 
  
 Here 
 command
  is a single command to execute, whereas 
 list
  is a set of one or more commands to 
 execute. Although 
 command
  can be any valid UNIX command, it is usually a 
 test
  expression of the type 
 covered in the last chapter. 
  
 list
  is commonly referred to as the 
 body
  of the 
 while
  loop because it contains the heart or guts of the 
 loop. The 
 do
  and 
 done
  keywords are not considered part of the body of the loop because the shell uses 
 them only for determining where the 
 while
  loop begins and ends.",NA
Validating User Input ,"Say that you need to write a script that needs to ask the user for the name of a directory. You can use the 
 following steps to get information from the users: 
  
  
 1. 
 Ask the user a question. 
  
 2. 
 Read the user's response. 
  
 3. 
 Check to see whether the user responded with the name of a directory. 
  
 What should you do when the user gives you a response that is not a directory? 
  
 The simplest choice would be to do nothing, but this is not very user friendly. Your script can be much more 
 user friendly by informing the user of the error and asking for the name of a directory again. 
  
 The 
 while
  loop is perfect for doing this. In fact, one of the most common uses for the 
 while
  loop is to 
 check whether user input has been gathered correctly. Usually a strategy similar to the following is 
 employed: 
  
  
 1. 
 Set a variable's value to null. 
  
 2. 
 Start a 
 while
  loop that exits when the variable's value is not null. 
  
 3. 
 In the 
 while
  loop, ask the user a question and read in the users response. 
  
 4. 
 Validate the response. 
  
 5. 
 If the response is invalid the variable's value is set to null. This enables the 
 while
  loop to repeat. 
  
 6. 
 If the response is valid, the variable's value is not changed. It continues to hold the user's 
 response. Because the variable's value is not null, the 
 while
  loop exits. 
  
 In the following example, use the commands 
  
  
 G
 echo
  to display a string 
  
  
 G
 read
  to read in the user's response 
  
 I have not formally introduced these commands, but you might be familiar with them. For readers who are 
 not familiar with these commands, I'll cover them in 
 Chapter 13, ""Input/Output.""",NA
The ,NA,NA
until,NA,NA
 Loop ,"The 
 while
  loop is perfect for a situation where you need to execute a set of commands while some 
 condition is true. Sometimes you need to execute a set of commands until a condition is true. 
  
 A variation on the 
 while
  loop available only in 
 ksh
  and 
 bash
 , the 
 until
  loop provides this functionality. Its 
 basic syntax is: 
  
 until 
 command 
  
 do 
  
 list 
  
 done 
  
 Here 
 command
  is a single command to execute, whereas 
 list
  is a set of one or more commands to 
 execute. Although 
 command
  can be any valid UNIX command, it is usually a 
 test
  expression of the type 
 covered in the last chapter. 
  
 The execution of an 
 until
  loop is identical to that of the 
 while
  loop and proceeds according to the 
 following steps: 
  
 1. 
 Execute 
 command
 .",NA
The ,NA,NA
for,NA,NA
 and ,NA,NA
select,NA,NA
 Loops ,"The for Loop
  
 The select Loop
  
 Unlike the 
 while
  loop, which exits when a certain condition is false, both the 
 for
  and 
 select
  loops 
 operate on lists of items. The 
 for
  loop repeats a set of commands for every item in a list, whereas the 
 select
  loop enables the user to select an item from a list.",NA
The ,NA,NA
for,NA,NA
 Loop ,"The basic syntax is 
  
 for 
 name
  in 
 word1 word2 ... wordN 
  
 do 
  
 list 
  
 done 
  
 Here 
 name
  is the name of a variable and 
 word1
  to 
 wordN
  are sequences of characters separated by 
 spaces (words). Each time the 
 for
  loop executes, the value of the variable 
 name
  is set to the next word in 
 the list of words, 
 word1
  to 
 wordN
 . The first time, 
 name
  is set to 
 word1
 ; the second time, it's set to 
 word2
 ; 
 and so on. 
  
 This means that the number of times a 
 for
  loop executes depends on the number of words that are 
 specified. For example, if the following words were specified to a 
 for
  loop 
  
 there comes a time
  
 the loop would execute four times. 
  
 In each iteration of the 
 for
  loop, the commands specified in 
 list
  are executed. 
  
 You can also write the entire loop on a single line as follows: 
  
 for 
 name
  in 
 word1 word2 ... wordN
  ; do 
 list
  ; done
  
 If 
 list
  and the number of words are short, the single line form is often chosen; otherwise, the multiple-line 
 form is preferred. 
  
 A simple 
 for
  loop example is",NA
The ,NA,NA
select,NA,NA
 Loop ,"The 
 select
  loop provides an easy way to create a numbered menu from which users can select options. It 
 is useful when you need to ask the user to choose one or more items from a list of choices. 
  
 This loop was introduced in 
 ksh
  and has been adapted into 
 bash
 . It is not available in 
 sh
 .
  
 The basic syntax of the 
 select
  loop is 
  
 select 
 name
  in 
 word1 word2 ... wordN 
  
 do 
  
 list 
  
 done 
  
 Here 
 name
  is the name of a variable and 
 word1
  to 
 wordN
  are sequences of characters separated by 
 spaces (words). The set of commands to execute after the user has made a selection is specified by 
 list
 .
  
 The execution process for a 
 select
  loop is as follows: 
  
 1. 
 Each item in 
 list1
  is displayed along with a number. 
  
 2. 
 A prompt, usually 
 #?
 , is displayed.",NA
Loop Control ,"Infinite Loops and the break Command
  
 The continue Command
  
 So far you have looked at creating loops and working with loops to accomplish different tasks. Sometimes 
 you need to stop a loop or skip iterations of the loop. In this section you'll look at the commands used to 
 control loops: 
  
 G
 break 
  
 G
 continue",NA
Infinite Loops and the ,NA,NA
break,NA,NA
 Command ,"When you looked at the 
 while
  loop earlier in this chapter, it terminated when a particular condition was 
 met. This happened when the task of the 
 while
  loop completed. 
  
 If you make a mistake in specifying the termination condition of a 
 while
  loop, it can continue forever. For 
 example, say you forgot to specify the 
 $
  before the 
 x
  in the test expression: 
  
 x=0 
  
 while [ x -lt 10 ] 
  
 do 
  
  
  echo $x 
  
  
  x=´echo ""$x + 1"" | bc´ 
  
 done 
  
 This loop would continue to display numbers forever. A loop that executes forever without 
 terminating executes an infinite number of times. For this reason, such loops are called 
 infinite
  loops. 
  
 In most cases infinite looping is not desired and stems from programming errors, but in certain instances 
 they can be useful. For example, say that you need to wait for a particular event, such as someone logging 
 on to a system, to occur. 
  
 You can use an infinite loop to check every few seconds whether the event has occurred. Because you don't 
 know how many times you need to execute the loop, when the event occurs, you can exit the infinite loop 
 using the 
 break
  command. 
  
 In 
 sh
 , you can create infinite loops using the 
 while
  loop. Because a 
 while
  loop executes 
 list
  while 
 command
  is true, specifying 
 command
  as either 
 :
  or 
 /bin/true
  causes the loop to execute forever.",NA
The ,NA,NA
continue,NA,NA
 Command ,"The 
 continue
  command is similar to the 
 break
  command, except that it causes the current iteration of the 
 loop to exit, rather than the entire loop. This command is useful when an error has occurred but you want to 
 try to execute the next iteration of the loop. 
  
 As an example, the following loop doesn't exit if one of the input files is bad: 
  
 for FILE in $FILES ; 
  
 do 
  
  
  if [ ! -f ""$FILE"" ] ; then 
  
  
  
  echo ""ERROR: $FILE is not a file."" 
  
  
  continue 
  
  
  fi 
  
  
  # process the file 
  
 done 
  
 If one of the filenames in 
 $FILES
  is not a file, this loop skips it, rather than exiting.
  
  
 Sams Teach Yourself Shell 
 Programming in 24 Hours 
  
  
  
  
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
 Hour 11: Loops
  
 Sections in this Chapter:
  
 Previous Section
  
 Next Section
  
  
 Previous Section
  
 Next Section<img 
 src=""
  
 The while Loop
  
 Summary
  
 The for and select Loops
  
 Questions
  
 Loop Control
  
 Terms",NA
Summary,"Loops are a powerful programming tool that enable you to execute a set of commands repeatedly. In this 
 chapter, you have examined the following types of loops available to shell programmers: 
  
 G
 while 
  
 G
 until 
  
 G
 for 
  
 G
 select
  
 You have also examined the concept of nested loops, infinite loops, and loop control. In the next chapter, I'll 
 introduce the concept of parameters. Here you'll see one of the most common applications of loops. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 11: Loops 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The while Loop
  
 Summary
  
 The for and select Loops
  
 Questions
  
 Loop Control
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What changes are required to the following 
 while
  loop 
  
 x=0 
  
 while [ $x -lt 10 ] 
  
 do
  
  echo ""$x \c""
  
  y=$(($x-1))
  
  x=$(($x+1))
  
  while [ $y -ge 0 ] ; do
  
  
  
  
  y=$(($y-1))
  
  
  
  echo ""$y \c""
  
  done
  
  echo 
  
 done
  
 so that the output looks like the following: 
  
 0 
  
 0 1 
  
 0 1 2 
  
 0 1 2 3 
  
 0 1 2 3 4 
  
 0 1 2 3 4 5 
  
 0 1 2 3 4 5 6 
  
 0 1 2 3 4 5 6 7 
  
 0 1 2 3 4 5 6 7 8 
  
 0 1 2 3 4 5 6 7 8 9
  
 2. 
 Write a 
 select
  loop that lists each file in the current directory and enables the user to view the 
 file by selecting its number. In addition to listing each file, use the string 
 Exit Program 
 as the key 
 to exit the loop. If the user selects an item that is not a regular file, the program should identify the 
 problem. If no input is given, the menu should be redisplayed. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 11: Loops 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The while Loop
  
 Summary
  
 The for and select Loops
  
 Questions
  
 Loop Control
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Loops
   Loops enable you to execute a series of commands multiple times. Two main types of loops are the 
 while
  and 
 for
  loops. 
  
 Body
   The set of commands executed by a loop. 
  
 Iteration
   A single execution of the body of a loop. 
  
 Nested Loops 
   When a loop is located inside the body of another loop it is said to be nested within another 
 loop. 
  
 Infinite Loops 
   Loops that execute forever without terminating. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 11: Loops 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The while Loop
  
 Summary
  
 The for and select Loops
  
 Questions
  
 Loop Control
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 12 ,NA,NA
Parameters ,"As you saw in previous chapters, the general format for the invocation of programs in UNIX is 
  
 commandoptionsfiles
  
 Here 
 command
  is the command name, 
 options
  is any option that you need to specify, and 
 files
  is an 
 optional list of files on which the command should operate. Consider the following example: 
  
 $ ls -l *.doc
  
 Here 
 ls
  is the command, 
 -l
  is the only option, and 
 *.doc
  is the list of files for 
 ls
  to operate on. 
  
 Because most UNIX users are familiar with this interface, you should adhere to this format in shell scripts. 
 This means that scripts that can have options specified must be able to read and interpret them correctly. 
  
 You have two common methods for the handling options passed to a shell script: 
  
 G
 Handle options manually using a 
 case
  statement 
  
 G
 Handle options using the 
 getopts
  command 
  
 For scripts that support only one or two options, the first method is easy to implement and works quite well, 
 but many scripts allow any combination of several options to be given. For such scripts, the 
 getopts 
 command is very useful because it affords the maximum flexibility in parsing options. 
  
 This chapter looks at both methods but it first covers the topic of special shell variables.",NA
Special Variables ,"The shell defines several special variables that are relevant to option parsing. In addition to these, a few 
 variables give the status of commands that the script executes. Table 12.1 describes all of the special 
 variables defined by the shell. 
  
 In this section you construct a simple yet useful shell script that illustrates the use of these variables. 
  
 Table 12.1  Special Shell Variables 
  
  
  
 Variable Description",NA
Using ,NA,NA
$0,"Start by looking at 
 $0
 . This variable is commonly used to determine the behavior of scripts that can be 
 invoked with more than one name. Consider the following script: 
  
 #!/bin/sh 
  
 case $0 in
  
  
  *listtar) TARGS=""-tvf $1"" ;;
  
  
  *maketar) TARGS=""-cvf $1.tar $1"" 
 ;; 
  
 esac 
  
 tar $TARGS
  
 You can use this script to list the contents of a tar file (
 t
  as in 
 tape
  and 
 ar
  as in 
 archive
 , a common format for 
 distributing files in UNIX) or to create a tar file based on the name with which the script is invoked. The 
 tar 
 file to read or create is specified as the first argument, 
 $1
 .
  
 I called this script 
 mytar
  and made two symbolic links to it called 
 listtar
  and 
 maketar
  as follows: 
  
 $ ln -s mytar 
 listtar 
  
 $ ln -s mytar 
 maketar
  
 If the script is invoked with the name 
 maketar
  and is given a directory or filename, a 
 tar
  file is created. If 
 you had a directory called 
 fruits
  with the following contents 
  
 $ ls fruits 
  
 apple   banana  mango   peach   
 pear",NA
Options and Arguments ,"Dealing with Arguments, an Example 
  
 Common Argument Handling Problems
  
 Using basename
  
 Options are given on the command line to change the behavior of a script or program. For example, the 
 -a 
 option of the 
 ls
  command changes the behavior of the 
 ls
  command from listing all visible files to listing all 
 files. This section shows you how to use options to change the behavior of scripts. 
  
 Often you will see or hear options called 
 arguments
 . The difference between the two is subtle. A 
 command's arguments are all of the separate strings or words that appear on the command line after the 
 command name, whereas 
 options
  are only those arguments that change the behavior of the command. 
  
 For example, in the following 
  
 $ ls -aF fruit
  
 the command is 
 ls
 , and its arguments are 
 -aF
  and 
 fruit
 . The options to the 
 ls
  command are 
 -aF
 .",NA
"Dealing with Arguments, an Example ","To illustrate the use of options, change the 
 mytar
  script to use its first argument, 
 $1
 , as the mode argument 
 and 
 $2
  as the tar file to read or create. 
  
 To implement this, change the case statement as follows: 
  
 USAGE=""Usage: $0 [-c|-t] [file|directory]"" 
 case ""$1"" in
  
  
  -t) TARGS=""-tvf $2"" ;;
  
  
  -c) TARGS=""-cvf $2.tar $2"" ;;
  
  
  *) echo ""$USAGE"" 
  
  
  
  exit 0
  
  
  
  ;; 
  
 esac
  
 The three major changes are 
  
 G
 All references to 
 $1
  have been changed to 
 $2
  because the second argument is now the filename. 
 G
 listtar
  has been replaced by 
 -t
 . 
  
 G
 maketar
  has been replaced by 
 -c
 .",NA
Using ,NA,NA
basename ,"Currently, the message displays the entire path with which the shell script was invoked, but what is really 
 required is the name of the shell script. You can correct this by using the 
 basename
  command.
  
 The 
 basename
  command takes an absolute or relative path and returns the file or directory name. Its basic 
 syntax is 
  
 basename 
 file 
  
 For example, 
  
 $ basename /usr/bin/sh 
  
 prints the following: 
  
 sh 
  
 Using 
 basename,
  you can change the variable 
 $USAGE
  in the 
 mytar
  script as follows: 
 USAGE=""Usage: ´basename $0´ [-c|-t] [file|directory]"" 
  
 This produces the following output: 
  
 Usage: mytar [-c|-t] [file|directory] 
  
 You could also have used the 
 basename
  command in the first version of the 
 mytar
  script to avoid using the 
 *
  wildcard character in the case statement as follows: 
  
 #!/bin/sh 
  
 case ´basename $0´ in
  
  
  listtar) TARGS=""-tvf $1"" ;;
  
  
  maketar) TARGS=""-cvf $1.tar $1"" ;; 
  
 esac 
  
 tar $TARGS",NA
Common Argument Handling Problems ,"Now that the 
 mytar
  script uses options to set the mode in which the script runs, you have another problem 
 to solve. Namely, what should it do if the second argument, 
 $2
 , is not provided? 
  
 You don't have to worry about what happens if the first argument, 
 $1
 , is not provided because the case 
 statement deals with this situation via the default case, 
 *
 .
  
 The simplest method for checking the necessary number of arguments is to see whether the number of 
 given arguments, 
 $#
 , matches the number of required arguments. Add this check to the script: 
  
 #!/bin/sh
  
 USAGE=""Usage: ´basename $0´ [-c|-t] [file|directory]""
  
 if [ $# -lt 2 ] ; then 
  
  
  echo ""$USAGE""
  
  
  exit 1 
  
 fi
  
 case ""$1"" in
  
  
  -t) TARGS=""-tvf $2"" ;;
  
  
  -c) TARGS=""-cvf $2.tar $2"" ;;
  
  
  *) echo ""$USAGE"" 
  
  
   
  exit 0 
  
  
   
  ;; 
  
 esac
  
 tar $TARGS
  
 Handling Additional Files 
  
 This 
 mytar
  script is mostly finished, but you can still make a few improvements. For example, it only deals 
 with the first file that is given as an argument, and it does not check to see whether the file argument is 
 really a file. 
  
 You can add the processing of all file arguments by using the special shell variable 
 $@
 . Start with the 
 -t
  (list 
 contents) option. The case statement now becomes",NA
Option Parsing in Shell Scripts ,"Using getopts
  
 You have two common ways to handle the parsing of options passed to a shell script. In the first method, 
 you can manually deal with the options using a 
 case
  statement. This method was used in the 
 mytar
  script 
 presented earlier in the chapter. The second method, discussed in this section, is to use the 
 getopts 
 command. 
  
 The syntax of the 
 getopts
  command is
  
 getopts 
 option-stringvariable
  
 Here 
 option-string
  is a string consisting of all the single character options 
 getopts
  should consider, 
 and 
 variable
  is the name of the variable that the option should be set to. Usually the 
 variable
  used is 
 named 
 OPTION
 .
  
 The process by which 
 getopts
  parses the options given on the command line is 
  
 1. 
 The 
 getopts
  option examines all the command line arguments, looking for arguments 
 starting with the 
 -
  character.
  
 2. 
 When an argument starting with the 
 -
  character is found, it compares the characters following the 
 -
 to the characters given in the 
 option-string
 .
  
 3. 
 If a match is found, the specified 
 variable
  is set to the option: otherwise, 
 variable
  is set to the 
 ?
  character. 
  
 4. 
 Steps 1 through 3 are repeated until all the options have been considered. 
  
 5. 
 When parsing has finished, 
 getopts
  returns a nonzero exit code. This allows it to be easily used 
 in loops. Also, when 
 getopts
  has finished, it sets the variable 
 OPTIND
  to the index of the last 
 argument. 
  
 Another feature of 
 getopts
  is the capability to indicate options requiring an additional parameter. You can 
 accomplish this by following the option with a 
 :
  character in the 
 option-string
 . In this case, after an 
 option is parsed, the additional parameter is set to the value of the variable named 
 OPTARG
 .",NA
Using ,NA,NA
getopts,NA,NA
Conclusion,"In this chapter you examined how to deal with arguments and options in shell script. Specifically you looked 
 at the following methods: 
  
 G
 Manually handling arguments and options using a 
 case
  statement 
 G
 Handling options using 
 getopts
  
 You worked through two examples that illustrate the implementation and rationale behind each method. In 
 addition, you saw several special variables that pertain to arguments and command execution. 
  
 As you will see in later chapters, using options greatly increases the flexibility and the reusability of your 
 shell scripts. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 12: Parameters 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Special Variables
  
 Conclusion
  
 Options and Arguments
  
 Questions
  
 Option Parsing in Shell Scripts
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Add 
 tar
  file extraction to the 
 mytar
  script. 
  
 Assume that the 
 -x
  option indicates that the user wants to extract 
 tar
  files and that the correct 
 value of 
 TARGS
  for extracting 
 tar
  files is 
 -xvf
 .
  
 2. 
 Add the extract option to the 
 uu
  script. Assume that the 
 -x
  option indicates that the file should be 
 extracted, and that the command 
  
 uudecode $INFILE 
  
 is used to extract a uuencoded file. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 12: Parameters 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Special Variables
  
 Conclusion
  
 Options and Arguments
  
 Questions
  
 Option Parsing in Shell Scripts
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 13 ,NA,NA
Input/Output,"Until now you have been looking at commands that print out messages. When a command prints a 
 message, the message is called 
 output
 . In this chapter, you will look at the different types of output available 
 to shell scripts. This chapter also introduces the mechanisms used to obtain 
 input
  from users. 
  
 Specifically, the areas that you will cover are 
  
  
 G
 Output to the screen 
  
  
 G
 Output to a file 
  
  
 G
 Input from a file 
  
  
 G
 Input from users",NA
Output,"Output to the Terminal
  
 Output Redirection
  
 As you have seen in previous chapters, most commands produce output. For example, the command 
 $ date 
  
 produces the current date in the terminal window: 
  
 Thu Nov 12 16:32:35 PST 1998
  
 When a command produces output that is written to the terminal, we say that the program has 
 printed its output to the 
 Standard Output 
 , or STDOUT. When you run the 
 date
  command, it prints the date 
 to STDOUT. 
  
 You might have also seen commands produce error messages, such as: 
 $ ln -s ch01.doc ch01-01.doc 
  
 ln: cannot create ch01-1.doc: File Exists",NA
Output to the Terminal ,"Two common commands print messages to the terminal (STDOUT):
  
 G
 echo 
  
 G
 printf
  
 The 
 echo
  command is mostly used for printing strings that require simple formatting. The 
 printf 
 command is the shell version of the C language function 
 printf
 . It provides a high degree of flexibility in 
 formatting output. 
  
 You first look at 
 echo
  and then 
 printf
 .
  
 echo
  
 The most common command used to output messages to the terminal is the 
 echo
  command. Its syntax is
  
 echo 
 string
  
 Here 
 string
  is the string you want printed. For example, the command 
  
 $ echo Hi
  
 produces the following output: 
  
 Hi
  
 You can also embed spaces in the output as follows: 
  
 $ echo Safeway has fresh fruit 
  
 Safeway has fresh fruit 
  
 In addition to spaces, you can embed each of the following in the 
 string
 :
  
 G
 Punctuation marks 
  
 G
 Variable substitutions",NA
Output Redirection ,"In the process of developing a shell script, you often need to capture the output of a command and store it in 
 a file. When the output is in a file, you can edit and modify it easily. 
  
 In UNIX, the process of capturing the output of a command and storing it in a file is called 
 output 
 redirection 
 because it redirects the output of a command into a file instead of the screen. To redirect the 
 output of a command or a script to a file, instead of 
 STDOUT
 , use the output redirection operator, 
 >
 , as 
 follows: 
  
 command
  > 
 file 
  
 list
  > 
 file
  
 The first form redirects the output of the specified 
 command
  to a specified 
 file
 , whereas the second 
 redirects the output of a specified 
 list
  to a specified 
 file
 . If 
 file
  exists, its contents are overwritten; if 
 file
  does not exist, it is created. 
  
 For example, the command",NA
Input,"Input Redirection 
  
 Pipelines
  
 Reading User Input
  
 Many UNIX programs are interactive and read input from the user. To use such programs in shell scripts, 
 you need to provide them with input in a noninteractive manner. Also, scripts often need to ask the user for 
 input in order to execute commands correctly. 
  
 To provide input to interactive programs or to read input from the user, you need to use input redirection. In 
 this section, you will look at the following two methods in detail: 
  
 G
 Input 
 redirection 
 from 
 files 
  
 G
 Reading 
 input 
 from 
 a 
 user 
  
 G
 Redirecting the output of one command to the input of another",NA
Input Redirection ,"When you need to use an interactive command such as 
 mail
  in a script, you need to provide the command 
 with input. One method for doing this is to store the input of the command in a file and then tell the command 
 to read input from that file. You accomplish this using input redirection. 
  
 The input can be redirected in a manner similar to output redirection. In general, input redirection is 
  
 command
  < 
 file
  
 Here the contents of 
 file
  become the input for 
 command
 . For example, the following would be an excellent 
 use of redirection: 
  
 Mail ranga@soda.berkeley.edu < Final_Exam_Answers
  
 Here the input to the 
 Mail
  command, which becomes the body of the mail message, is the file 
 Final_Exam_Answers
 . In this particular example, a professor might perform this function, and the file 
 might contain the answers to a current final exam.
  
 Here Documents 
  
 An additional use of input redirection is in the creation of 
 here documents 
 . A common use of 
 here documents is in the generation of email messages within scripts and in the generation of files 
 containing the values of all the variables in the script. Also, here documents store temporary information.",NA
Reading User Input ,NA,NA
Pipelines,"Most commands in UNIX that are designed to work with files can also read input from STDIN. This enables 
 you to use one program to filter the output of another. This is one of the most common tasks in shell 
 scripting: having one program manipulate the output of another program. 
  
 You can redirect the output of one command to the input of another command using a 
 pipeline
 , which 
 connects several commands together with 
 pipes
  as follows: 
  
 command1
  | 
 command2
  | ...
  
 The pipe character, 
 |
 , connects the standard output of 
 command1
  to the standard input of 
 command2
 , and 
 so on. The commands can be as simple or complex as are required. 
  
 Here are some examples of pipeline commands: 
  
 tail -f /var/adm/messages | more
  
 ps -ael | grep ""$UID"" | more
  
 In the first example, the standard output of the 
 tail
  command is piped into the standard input of the 
 more 
 command, which enables the output to be viewed one screen at a time. 
  
 In the second example, the standard output of 
 ps
  is connected to the standard input of 
 grep
 , and the 
 standard output of 
 grep
  is connected to the standard input of 
 more
 , so that the output of 
 grep
  can be 
 viewed one screen at a time. For now, simply be aware of this technique of redirection. I show you how to 
 use it to filter text in 
 Chapters 16
 , 
 17
 , and 
 18
 .
  
 Caution -
  One important thing about pipelines is that each command is executed as a separate process, and the exit 
 status of a pipeline is the exit status of the last command. 
  
  
 It is vital to remember this fact when writing scripts that must do error handling. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Contents
  
 Inde
 x
  
 Hour 13: Input/Output
  
  
 Previous Chapter
  
 Next Chapter
  
 Sections in this Chapter:
  
 Output
  
 Summary
  
 Input
  
 Questions
  
 Previous Section
  
 Next Section
  
 File Descriptors
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
File Descriptors ,"Associating Files with a File Descriptor
  
 General Input/Output Redirection
  
 When you issue any command, three files are opened and associated with that command. In the 
 shell, each of these files is represented by a small integer called a file descriptor. A 
 file descriptor 
 is a 
 mechanism by which you can associate a number with a filename and then use that number to read and 
 write from the file. Sometimes file descriptors are called 
 file handles 
 .
  
 The three files opened for each command along with their corresponding file descriptors are 
  
 G
 Standard Input (STDIN), 0 
  
 G
 Standard Output (STDOUT), 1 
  
 G
 Standard Error (STDERR), 2
  
 The integer following each of these files is its file descriptor. Usually, these files are associated with the 
 user's terminal, but they can be redirected into other files. 
  
 In the previous examples in this chapter, you have used input and output redirection using the default file 
 descriptors. This section introduces the general form of input and output redirection. 
  
 First you examine associating files with a file descriptor.",NA
Associating Files with a File Descriptor ,"By default, the shell provides you with three standard file descriptors for every command. With it, you can 
 also associate any file with file descriptors using the 
 exec
  command. 
  
 Associating a file with a file description is useful when you need to redirect output or input to a file many 
 times but you don't want to repeat the filename several times. 
  
 To open a file for writing, use one of the following forms: 
  
 exec 
 n
 >
 file 
  
 exec 
 n
 >>
 file
  
 Here 
 n
  is an integer, and 
 file
  is the name of the file you want to open for writing. The first form overwrites 
 the specified 
 file
  if it exists. The second form appends to the specified 
 file
 . For example, the following 
 command",NA
General Input/Output Redirection ,"You can perform general output redirection by combining a file descriptor and an output redirection operator. 
  
 The general forms are 
  
 command 
 n
 > 
 file
  
 command 
 n
 >> 
 file
  
 Here 
 command
  is the name of a command, such as 
 ls
 , 
 n
  is a file descriptor (integer), and 
 file
  is the name 
  
 of the file. The first form redirects the output of 
 command
  to the specified 
 file
 , whereas the second form 
  
 appends the output of 
 command
  to the specified 
 file
 .
  
 For example, you can write the standard output redirection forms in the general form as 
  
 command
  1> 
 file
  
 command
  1>> 
 file
  
 Here the 
 1
  explicitly states that STDOUT is being redirected into the given file. 
  
 General input redirection is similar to general output redirection. It is performed as follows: 
  
 commandn
 <
 file
  
 Here 
 command
  is the name of a command, such as 
 ls
 , 
 n
  is a file descriptor (integer), and 
 file
  is the name 
  
 of the file. For example, the standard input redirection forms can be written in the general form as
  
 command
  0<
 file
  
 Redirecting STDOUT and STDERR to Separate Files 
  
 One of the most common uses of file descriptors is to redirect STDOUT and STDERR to separate files. The 
  
 basic syntax is 
  
 command
  1> 
 file1
  2> 
 file2
  
 Here the STDOUT of the specified 
 command
  is redirected to 
 file1
 ,
  and the STDERR (error messages) is",NA
Summary,"In this chapter, I formally introduced the concept of input and output. I covered the 
 echo
  and 
 printf 
 commands that are used to produce messages from within shell scripts. 
  
 I also introduced output redirection, covering the methods of redirecting and appending the output of a 
 command to a file. In addition, I discussed reading input for the first time. I also covered reading in files and 
 reading input from users. 
  
 Finally, I introduced the concept of a file descriptor and showed several aspects of its use, including opening 
 files for reading and writing, closing files, and redirecting the output of two file descriptors to one source. 
  
 In the subsequent chapters, I will expand on the material covered here, and you will see many more 
 applications of both input and output redirection along with the use of file descriptors. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 13: Input/Output 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Output
  
 Summary
  
 Input
  
 Questions
  
 File Descriptors
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Complete the script using the appropriate 
 printf
  commands to perform the specified numeric 
 conversions. Assume that the input is always a number: 
  
 #!/bin/sh 
  
 if [ $# -lt 2 ] ; then 
  
  echo ""ERROR: Insufficient arguments."" ; 
  
  exit 1 ; 
  
 fi 
  
 case ""$1"" in
  
  -o) : # convert the number stored in ""$2"" into octal 
  
  
  
  ;;
  
  -x) : # convert the number stored in ""$2"" into hexadecimal
  
  
  
  ;;
  
  -e) : # convert the number stored in ""$2"" into scientific notation
  
  
  ;;
  
  *) echo ""ERROR: Unknown conversion, $1!"" ;; 
  
 esac
  
 2. 
 Rewrite the error messages in the previous script to redirect their output to STDERR instead of 
 STDOUT. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 13: Input/Output 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Output
  
 Summary
  
 Input
  
 Questions
  
 File Descriptors
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"File Descriptor 
   An integer that is associated with a file. Enables you to read and write from a file using the 
 integer instead of the file's name. 
  
 STDIN
   Standard Input. User input is read from STDIN. The file descriptor for STDIN is 0. 
  
 STDOUT
   Standard Output. The output of scripts is usually to STDOUT. The file descriptor for STDOUT is 
 1. 
  
 STDERR
   Standard Error. A special type of output used for error messages. The file descriptor for STDERR 
 is 2. 
  
 Escape Sequence 
   An escape sequence is special sequence of characters that represents another 
 character. 
  
 Output Redirection 
   In UNIX, the process of capturing the output of a command and storing it in a file is 
 called 
 output redirection 
 because it redirects the output of a command into a file instead of the screen. 
  
 Input Redirection 
   In UNIX the process of sending input to a command from a file is called input 
 redirection. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 13: Input/Output 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Output
  
 Summary
  
 Input
  
 Questions
  
 File Descriptors
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 14 ,NA,NA
Functions,"Shell functions provide a way of mapping a name to a list of commands. Shell functions are similar to 
 subroutines, procedures, and functions in other programming languages. 
  
 Think of them as miniature shell scripts that enable a name to be associated with a set of commands. The 
 main difference is that a new instance of the shell begins in order to run a shell script, whereas functions run 
 in the current shell.",NA
Creating and Using Functions ,"Invoking a Function
  
 Function Examples
  
 The formal definition of a shell function is as follows: 
  
 name
  () { 
 list
  ; }
  
 A function binds a 
 name
  to the 
 list
  of commands that composes the body of the function. The 
 (
  and 
 ) 
 characters are required at the function definition. 
  
 The following examples illustrate valid and invalid function definitions: 
  
 lsl() { ls -l ; }    # valid 
  
 lsl { ls -l ; }         # invalid 
  
 In this example, the first definition is valid but the second one is not because it omits the parentheses after 
 the string 
 lsl
 .
  
 This example also demonstrates a common use of functions. Because the original shell, 
 sh
 , did not have 
 the 
 alias
  keyword common to more recent shells, all aliases were defined in terms of shell functions. A 
 frequently encountered example of this is the 
 source
  command. The 
 sh
  equivalent is the 
 .
  command. 
  
 Many converts from 
 csh
  use the following function to simulate the 
 source
  command: 
  
 source() { . ""$@"" ; }
  
 As this example shows, shell functions have a separate set of arguments than the shell script to which they 
 belong. You explore this feature later in the chapter.",NA
Invoking a Function ,"To invoke a function, only its name is required, thus typing
  
 $ lsl
  
 on the command line executes the 
 lsl()
  function, but typing 
  
 $ lsl()
  
 does not work because 
 sh
  interprets this as a redefinition of the function by the name 
 lsl
 . In most versions 
 of the shell, typing 
 lsl()
  results in a prompt similar to the following: 
  
 >
  
 This is a prompt produced by the shell when it expects you to provide more input. Here the input it expects 
 is the body of the function 
 lsl
 .",NA
Function Examples ,"In this section you will look at two examples of how functions are used to gain a better understanding of their 
 role in shell scripting. 
  
 Listing Your Path 
  
 A simple task that is well-suited to a function is listing the current value of your 
 PATH
 , with each directory 
 listed on a single line. The basic shell code is 
  
 OLDIFS=""$IFS"" 
  
 IFS=: 
  
 for DIR in $PATH ; do echo $DIR ; done 
  
 IFS=""$OLDIFS"" 
  
 Here you save the value of 
 IFS
  in the variable 
 OLDIFS
  and then set 
 IFS
  to 
 :
 . Because 
 IFS
  is the Internal 
 Field Separator for the shell, you can use the 
 for
  loop to cycle through the individual entries in 
 PATH
 . When 
 you are finished, restore the value of 
 IFS
 .",NA
"Sharing Data Between Functions, an Example ","Moving Around the File System 
  
 Implementing pushd
  
 Implementing dirs 
  
 Implementing popd
  
 The functions seen thus far operate independently of one another, but in most shell scripts functions either 
 depend on or share data with other functions. 
  
 In this section you will look at an example where three functions work together and share data.",NA
Moving Around the File System ,"The C shell, 
 csh
 , provides three commands for quickly moving around in the UNIX file system: 
  
 G
 popd 
  
 G
 pushd 
  
 G
 dirs
  
 These commands maintain a stack of directories internally and enable the user to add and remove 
 directories from the stack and list the contents of the stack. 
  
 For those readers who are not familiar with the programming concept of a 
 stack
 , you can think of it as a 
 stack of plates: you can add or remove a plate only at the top of the stack. You can access only the top 
 plate, not any of the middle plates in the stack. A stack in programming terms is similar. You can add or 
 remove an item only at the top of the stack. 
  
 In 
 csh
 , the stack is maintained within the shell, but in your shell function-based implementation you have to 
 maintain the stack as an exported environment variable so that all three functions have access to it. 
  
 Use the variable 
 _DIR_STACK
  to store the directory stack. Each entry in the stack is separated by the 
 : 
 character similar to the PATH variable. By using this character rather than a space or tab, you increase the 
 flexibility of the directory names that you can handle.",NA
Implementing ,NA,NA
dirs,"Now you'll look at the simplest of the three functions, the 
 dirs()
  function, which lists the directory stack: 
  
 dirs() { 
  
  # save IFS, then set it to : to access the  
 # the items in _DIR_STACK individually.",NA
Implementing ,NA,NA
pushd,"The 
 pushd
  function is slightly more complicated than the 
 dirs
  function. It needs to change to a requested 
 directory and then add that directory to the top of the stack. 
  
 Your implementation is as follows: 
  
 pushd() { 
  
  # set the requested directory, $REQ, to the first argument  
 # If no argument is given, set REQ to . 
  
  REQ=""$1"";  
  
  if [ -z ""$REQ"" ] ; then REQ=. ; fi 
  
  # if $REQ is a directory, cd to the directory  # 
 if the cd is successful update $_DIR_STACK  # 
 otherwise issue the appropriate error messages 
  
  if [ -d ""$REQ"" ] ; then 
  
  cd ""$REQ"" > /dev/null 2>&1 
  
  if [ $? -eq 0 ] ; then 
  
  
  
  _DIR_STACK=""´pwd´:$_DIR_STACK"" ; export _DIR_STACK ; 
  
  
  dirs 
  
  else 
  
  
  
  echo ""ERROR: Cannot change to directory $REQ."" >&2  
 fi 
  
  else 
  
  echo ""ERROR: $REQ is not a directory."" >&2 
  
  fi",NA
Implementing ,NA,NA
popd,"The 
 popd()
  function is far more complicated than the other two. First look at the operations that it performs: 
  
 1. 
 Removes the first entry from the directory stack variable 
  
 2. 
 Updates the directory stack to reflect the removal 
  
 3. 
 Changes to the directory indicated by the entry that was removed from the stack 
  
 4. 
 Displays the full path of the current directory 
  
 In order to make the first and second operations easy, implement a helper function for 
 popd()
  called 
 _popd_helper()
 . This function performs all the work; 
 popd()
  is simply a wrapper around it. Frequently, 
 you need to write functions in this manner: one function that simplifies the interface and one that performs 
 the work. 
  
 The Helper Function 
  
 Look at 
 _popd_helper
  first to see how the directory stack is manipulated: 
  
 _popd_helper() {",NA
Conclusion,"In this chapter you looked at creating and calling functions. Some of the major topics that you covered are 
  
 G
 Creating a function 
  
 G
 Using functions to replace built-in commands 
  
 G
 Using IFS to simplify parsing 
  
 G
 Using arguments with functions 
  
 G
 Sharing data between functions 
  
 G
 Calling a function from within another function 
  
 Part III introduces the concept of function libraries and presents a set of functions that you can use in your 
 scripts. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 14: Functions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Creating and Using Functions
  
 Conclusion
  
 Sharing Data Between Functions, an Example
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Write a function to make a directory (and all its parents) change to that directory and then print the 
 full path of that directory. Please include error checking at all levels. Make sure that all error 
 messages are generated by your script, not the commands that you execute. 
  
 2. 
 Chapter 13, ""Input/Output,""
  introduced the concept of prompting the user from a shell script. Write 
 a function that can be used to prompt the user for a response. This function should take a single 
 argument that is the prompt, and it should place the user's response in the variable 
 RESPONSE
 . 
 Please include error checking at all levels. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 14: Functions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Creating and Using Functions
  
 Conclusion
  
 Sharing Data Between Functions, an Example
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 15 ,NA,NA
Text Filters,"Shell scripts are often called on to manipulate and reformat the output from commands that they execute. 
 Sometimes this task is as simple as displaying only part of the output by filtering out certain lines. In most 
 instances, the processing required is much more sophisticated. 
  
 In this chapter, you will look at several commands that are used heavily as text filters in shell scripts. These 
 commands include 
  
  
 G
 head 
  
  
 G
 tail 
  
  
 G
 grep 
  
  
 G
 sort 
  
  
 G
 uniq 
  
  
 G
 tr 
  
 I will also show you how to combine these commands to filter text in extremely powerful ways.",NA
The ,NA,NA
head,NA,NA
 and ,NA,NA
tail,NA,NA
 Commands ,"The head Command
  
 The tail Command
  
 In 
 Chapter 3, ""Working with Files,""
  you looked at viewing the contents of a file using the 
 cat
  command. This 
 command enables you to view an entire file, but often you need more control over lines that are displayed. 
 The 
 head
  and 
 tail
  commands provide some of this control.",NA
The ,NA,NA
head,NA,NA
 Command ,"The basic syntax for the 
 head
  command is 
  
 head [-n 
 lines
 ] 
 files",NA
The ,NA,NA
tail,NA,NA
 Command ,"The basic syntax for the 
 tail
  command is similar to that of the 
 head
  command: 
  
 tail [-n 
 lines
 ] 
 files
  
 Here 
 files
  is the list of the files the 
 tail
  command should process. Without the 
 -n 
 lines
  option, the 
 tail 
 command shows the last 10 lines of its standard input. With this option it shows the specified number of 
 lines
  instead. 
  
 To illustrate the use of the 
 tail
  command, consider the problem of generating a list of the five oldest mail 
 spools on my system. 
  
 I can start with 
 ls -1 
 command again, but this time I'll use the 
 -t
  (sort by last modified time) option 
 instead: 
  
 $ ls -1t /var/spool/mail
  
 To get the bottom five, I'll use 
 tail
  instead of 
 head
 :
  
 $ ls -1t /var/spool/mail | tail -5
  
 On my system the following list is generated: 
  
 anna 
  
 root 
  
 amma 
  
 vathsa 
  
 ranga
  
 In this list, the files are listed from newest to oldest. To reverse the order, I can also specify the 
 -r
  option to 
 the 
 ls
  command: 
  
 ls -1rt /var/spool/mail | tail -5
  
 On my system, I get this list: 
  
 ranga 
  
 vathsa 
  
 amma 
  
 root 
  
 anna",NA
Using ,NA,NA
grep,"Looking for Words 
  
 Line Numbers
  
 Reading From STDIN 
  
 Listing Filenames Only
  
 The 
 grep
  command lets you locate the lines in a file that contain a particular word or a phrase. The word 
 grep
  stands for 
 globally regular expression print
 . The command is derived from a feature of the original 
 UNIX text editor, 
 ed
 . To find a word in 
 ed
 , the following command was used: 
  
 g/
 word
 /p
  
 Here 
 word
  is a regular expression. For those readers who are not familiar with regular expressions, 
 Chapter 
  
 16, ""Filtering Text Using Regular Expressions,""
  discusses them in detail. 
  
 This particular 
 ed
  command was used widely in shell scripts, thus it was factored into its own command 
 called 
 grep
 . In this section, you will look at the 
 grep
  command and some of its most commonly used 
 options.",NA
Looking for Words ,"The basic syntax of the 
 grep
  command is 
  
 grep 
 wordfile
  
 Here 
 file
  is the name of a file in which you want to search for 
 word
 . The 
 grep
  command displays every line 
 in 
 file
  that contains 
 word
 . When you specify more than one file, 
 grep
  precedes each of the output lines with 
 the name of the file that contains that line. 
  
 As an example, the following command locates all the occurrences of the word 
 pipe
  in file 
 ch15.doc
  (this 
 chapter): 
  
 $ grep pipe ch15.doc 
  
 I've broken the command into two lines, with the pipe character as the 
 the right thing and use the next line as the command to pipe to. It's 
 The first few lines look like (ten actually, I piped the output to
  
 If I specify more than one file the output changes as follows: 
  
 $ grep pipe ch15.doc ch15-01.doc 
  
 ch15.doc:I've broken the command into two lines, with the pipe character as 
 the",NA
Reading From STDIN ,"When no files are specified, 
 grep
  looks for matches on the lines that are entered on STDIN. This makes it 
 perfect for attaching to pipes. 
  
 For example, the following command looks for all users named 
 ranga
  in the output of the 
 who
  command: 
  
 $ who | grep ranga 
  
 ranga    tty1     Aug 26 14:12 
  
 ranga    ttyp2    Nov 23 14:15 (rishi.bosland.u)
  
 The 
 -v
  Option 
  
 Most of the time you use 
 grep
  to search through a file looking for a particular 
 word
 , but sometimes you 
 want to acquire a list of all the lines that do not match a particular 
 word
 .
  
 Using 
 grep,
  this is simple --specify the 
 -v
  option. For example, the following command produces a list of 
 all the lines in 
 /etc/passwd
  that do not contain the word 
 home
 :
  
 $ grep -v home /etc/passwd
  
 On my system, the output looks like the following: 
  
 root:*:0:3::/:/sbin/sh 
  
 daemon:*:1:5::/:/sbin/sh 
  
 bin:*:2:2::/usr/bin:/sbin/sh 
  
 sys:*:3:3::/: 
  
 adm:*:4:4::/var/adm:/sbin/sh 
  
 uucp:*:5:3::/var/spool/uucppublic:/usr/lbin/uucp/uucico 
 lp:*:9:7::/var/spool/lp:/sbin/sh 
  
 nobody:*:-2:-2::/:
  
 One common use of the 
 -v
  option is to parse the output of the 
 ps
  command. For example, if I were looking 
 for all instances of 
 bash
  that were running on a system, I could use the following command: 
  
 $ /bin/ps -ef | grep bash
  
 Sometimes the output looks like the following: 
  
 ranga  3277  3276  2 13:41:45 pts/t0    0:02 -bash 
 ranga  3463  3277  4 18:38:26 pts/t0    0:00 grep bash
  
 The second process in this list is the 
 grep
  that I just ran. Because it is not really an instance of 
 bash
 , I can 
 get rid of it as follows:",NA
Line Numbers ,"As 
 grep
  looks through a file for a given 
 word
 , it keeps track of the line numbers that it has examined. You 
 can have 
 grep
  list the line numbers along with the matching lines by specifying the 
 -n
  option. With this 
 option the output format is 
  
 file
 :
 line number
 :
 line
  
 Here 
 file
  is the name of the file in which the match occurs, 
 line number 
 is the line number in the file on which 
 the matching line occurs, and 
 line
  is the complete line that contains the specified word. For example, the 
 command 
  
 $ grep -n pipe ch15.doc ch15-01.doc
  
 produces the following output: 
  
 ch15.doc:969:I've broken the command into two lines, with the pipe character 
 as the 
  
 ch15.doc:971:the right thing and use the next line as the command to pipe to. 
  
 It's 
  
 ch15.doc:1014:The first few lines look like (ten actually, I piped the output 
 to 
  
 ch15-01.doc:964:I've broken the command into two lines, with the pipe 
  
 character as the 
  
 ch15-01.doc:966:the right thing and use the next line as the command to pipe 
 to.  It's 
  
 ch15-01.doc:1009:The first few lines look like (ten actually, I piped the 
 output to
  
 As you can see, the lines might be the same in both files, but the line numbers are different.",NA
Listing Filenames Only ,"Sometimes you don't really care about the actual lines in a file that match a particular word. You want a list 
 of all the files that contain that word. 
  
 For example, the following command looks for the word 
 delete
  in all the files in my 
 projects
  directory: 
  
 $ grep delete /home/ranga/docs/projects
  
 In my case, it produces the following output:",NA
Counting Words ,"The tr Command 
  
 Sorting Numbers
  
 The sort Command 
  
 Using Character Classes with tr
  
 The uniq Command
  
 Counting words is an essential capability in shell scripts. There are many ways to do it, with the easiest 
 being the 
 wc
  command. Unfortunately, it displays only the number of characters, words, or lines. 
  
 What about when you need to count the number of occurrences of 
 word
  in a file? The 
 wc
  command falls 
 short. In this section, you will solve this problem using the following commands: 
  
  
 G
 tr 
  
  
 G
 sort 
  
  
 G
 uniq 
  
 The 
 tr
  command ( 
 tr
  for 
 transliterate
 ) changes all the characters in one set into characters in a second set. 
 Sometimes it deletes sets of characters. 
  
 The 
 sort
  command sorts the lines in an input file. If you don't specify an input file, it sorts the lines given on 
 STDIN. 
  
 The 
 uniq
  command ( 
 uniq
  for 
 unique
 ) prints all the unique lines in a file. If a line occurs multiple times, only 
 one copy of the line is printed out. It can also list the number of times a particular line was duplicated. I will 
 use the text of this chapter, 
 ch15.doc
 , as the input file for this example.",NA
The ,NA,NA
tr,NA,NA
 Command ,"First, you need to eliminate all the punctuation and delimiters in the input file because the word 
 end.
  and 
 the word 
 end
  are the same. You accomplish this task using the 
 tr
  command. Its basic syntax is 
 tr 
 '
 set1
 ' '
 set2
 ' 
  
 Here 
 tr
  takes all the characters in 
 set1
  and transliterates them to the characters in 
 set2
 . Usually, the 
 characters themselves are used, but the standard C language escape sequences also work. 
  
 To accomplish my first task, I used the following command: 
  
 $ tr '!?"":;\[\]{}(),.' ' ' < /home/ranga/docs/ch15.doc",NA
The ,NA,NA
sort,NA,NA
 Command ,"To get a count of how many times each word is used, you need to sort the file using the 
 sort
  command. In 
  
 its simplest form, the 
 sort
  command sorts each of its input lines. Thus you need to have only one word per 
  
 line. You can do this changing all the spaces into new lines as follows: 
  
 $ tr '!?"":;\[\]{}(),.\t\n' ' ' < /home/ranga/docs/ch15.doc |
  
 tr 'A-Z' 'a-z' | tr -s ' '  | tr ' ' '\n'
  
 Now you can sort the output, by adding the 
 sort
  command:",NA
The ,NA,NA
uniq,NA,NA
 Command ,"At this point, you can eliminate all the repeated words by using the 
 -u
  ( 
 u
  as in 
 unique
 ) option of the 
 sort 
 command. Because you need a count of the number of times a word is repeated, you should use the 
 uniq 
 command. 
  
 By default, the 
 uniq
  command discards all but one of the repeated lines. For example, the commands 
  
 $ echo ' 
  
 peach 
  
 peach 
  
 peach 
  
 apple 
  
 apple 
  
 orange 
  
 ' > ./fruits.txt 
  
 $ uniq fruits.txt
  
 produce the output 
  
 peach 
  
 apple 
  
 orang
 e
  
 As you can see, 
 uniq
  discarded all but one of the repeated lines. 
  
 The 
 uniq
  command produces a list of the 
 uniq
  items in a file by comparing consecutive lines. To function 
 properly, its input needs to be a sorted file. For example, if you change 
 fruits.txt
  as follows 
  
 $ echo ' 
  
 peach 
  
 peach 
  
 orange 
  
 apple 
  
 apple 
  
 peach 
  
 ' > ./fruits.txt 
  
 $ uniq fruits.txt
  
 the output is incorrect for your purposes: 
  
 peach 
  
 orang
 e 
  
 apple 
  
 peach",NA
Sorting Numbers ,"At this point the output is sorted alphabetically. Although this output is useful, it is much easier to determine 
 the most frequently used words if the list is sorted by the number of times a word occurs. 
  
 To obtain such a list, you need 
 sort
  to sort by numeric value instead of string comparison. It would also be 
 nice if the largest number was printed first. By default, 
 sort
  prints the largest number last. To satisfy both of 
 these requirements, you specify the 
 -n
  ( 
 n
  as in 
 numeric
 ) and 
 -r
  ( 
 r
  as in 
 reverse
 ) options to the 
 sort 
 command: 
  
 $ tr '!?"":;\[\]{}(),.\t\n' ' ' < /home/ranga/docs/ch15.doc 
 | tr 'A-Z' 'a-z' | tr -s ' '  | tr ' ' '\n' | sort | uniq -
 c | sort -rn
  
 By piping the output to 
 head
 , you can get an idea of what the ten most repeated words are: 
  
 $ tr '!?"":;\[\]{}(),.\t\n' ' ' < /home/ranga/docs/ch15.doc | 
 tr 'A-Z' 'a-z' | tr -s ' '  | tr ' ' '\n' | sort | uniq -c | 
 sort -rn | head 
  
 389 the 
  
 164 to 
  
 127 of 
  
 115 is 
  
 115 and 
  
 111 a
  
  80 files
  
  70 file
  
  69 in
  
  65 '
  
 Sorting Numbers in a Different Column 
  
 In the preceding output, you used the 
 sort -rn 
 command to sort the output by numbers because the 
 numbers occurred in the first column instead of the second column. If the numbers occurred in any other 
 column, this would not be possible. 
  
 Suppose the output looked like the following: 
  
 $ cat switched.txt 
  
 files 80 
  
 file 70 
  
 is 115 
  
 and 115 
  
 a 111",NA
Using Character Classes with ,NA,NA
tr,"Take a look at the output of the command: 
  
 $ tr '!?"":;\[\]{}(),.\t\n' ' ' < /home/ranga/docs/ch15.doc |",NA
Summary,"In this chapter you looked at some of the commands that are heavily used for filtering text in scripts. These 
 commands include: 
  
 G
 head 
  
 G
 tail 
  
 G
 grep 
  
 G
 sort 
  
 G
 uniq
  
 G
 tr
  
 I also covered how to combine these commands together to solve problems such as counting the number of 
 times a word was repeated in a text file. In 
 Chapter 16
  I will introduce two more text filtering commands, 
 awk
  
 and 
 sed
 , that give you much more control over editing lines and printing specific columns of your output. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 15: Text Filters 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The head and tail Commands
  
 Summary
  
 Using grep
  
 Questions
  
 Counting Words
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1.
  Given the following shell function 
  
 lspids() { /bin/ps -ef | grep ""$1""| grep -v grep ; } 
  
 make the necessary changes so that when the function is executed as follows 
  
 $ lspid -h ssh 
  
 the output looks like this: 
  
 UID   PID  PPID  C    STIME TTY       TIME COMMAND 
  
 root  2121     1  0  Nov 16  ?         0:14 /opt/bin/sshd 
 Also, when the function executes as 
  
 $ lspid ssh 
  
 the output looks like this: 
  
 root  2121     1  0  Nov 16  ?         0:14 /opt/bin/sshd 
  
 Here you are using 
 ssh
  as the 
 word
  specified to 
 grep
 , but your function should be able to use any 
 word
  as an argument. 
  
 Also, validate that you have enough arguments before executing the 
 ps
  command. 
  
 If you are using a Linux or FreeBSD-based system, please use the following version of the function 
 lspids
  as a starting point instead of the version given previously: 
  
 lspids() { /bin/ps -auwx 2> /dev/null | grep ""$1""| grep -v grep ; } 
 (HINT: 
 The header that you are using is the first line in the output from the 
 /bin/ps -ef 
 command.) 
  
 2.
  Take the function you wrote in question 1 and add a 
 -s
  option that sorts the output of the 
 ps 
 command by process ID. The process IDs, or pids, do not have to be arranged from largest to 
 smallest.",NA
Hour 16 ,NA,NA
Filtering Text Using Regular Expressions ,"The most powerful text filtering tools in the UNIX environment are a pair of oddly named 
 programs, 
 awk
  and 
 sed
 . They let shell programmers easily edit text files and filter the output of other 
 commands using regular expressions. A 
 regular expression 
 is a string that can be used to describe several 
 sequences of characters. 
  
 sed
  (which stands for 
 stream editor
 ) was created as an editor exclusively for executing scripts. As its name 
 implies, 
 sed
  is stream oriented, thus all the input you feed into it passes through and goes to STDOUT. It 
 does not change the input file. In this chapter I will show you how to use 
 sed
  in shell scripts. 
  
 I will cover 
 awk
  programming in 
 Chapter 17, ""Filtering Text with 
 awk
 ,""
  but I'll discuss some of the many 
 similarities between 
 awk
  and 
 sed
  at the beginning of this chapter.",NA
The Basics of ,NA,NA
awk,NA,NA
 and ,NA,NA
sed ,"Invocation Syntax 
  
 Regular Expressions
  
 Basic Operation
  
 There are many similarities between 
 awk
  and 
 sed
 : 
  
  
 G
 They have similar invocation syntax. 
  
 G
 They enable you to specify instructions that execute for every line in an input file. 
  
 G
 They use regular expressions for matching patterns 
 .
  
 For those readers who are not familiar with patterns and regular expressions, I will explain them shortly.",NA
Invocation Syntax ,"The invocation syntax for 
 awk
  and 
 sed
  is as follows: 
  
 command
  '
 script
 ' 
 filenames 
  
 Here 
 command
  is either 
 awk
  or 
 sed
 , 
 script
  is a list of commands understood by 
 awk
  or 
 sed
 , and 
 filenames
  is a list of files that the command acts on.",NA
Basic Operation ,"When an 
 awk
  or 
 sed
  command runs, it performs the following operations: 
  
 1. 
 Reads a line from an input file 
  
 2. 
 Makes a copy of this line 
  
 3. 
 Executes the given 
 script
  on this line 
  
 4. 
 Repeats step 1 for the next line 
  
 These operations illustrate the main feature of 
 awk
  and 
 sed
 --they provide a method of acting on every 
 record or line in a file using a single script. When every record has been read, the input file is closed. If the 
 input file is the last file specified in 
 filenames
 , the command exits. 
  
 Script Structure and Execution 
  
 The 
 script
  specified to 
 awk
  or 
 sed
  consists of one or more lines of the following form: 
  
 /pattern/action
  
 Here 
 pattern
  is a regular expression, and 
 action
  is the action that either 
 awk
  or 
 sed
  should take when 
 the 
 pattern
  is encountered. Regular expressions will be covered shortly. The slash characters ( 
 /
 ) that 
 surround the 
 pattern
  are required because they are used as delimiters. 
  
 When 
 awk
  or 
 sed
  is executing a script, it uses the following procedure on each record: 
  
 1. 
 Sequentially searches each 
 pattern
  until a match is found. 
  
 2. 
 When a match is found, the corresponding 
 action
  is performed on the input line. 
  
 3. 
 When the 
 action
  is completed, it goes to the next 
 pattern
  and repeats step 1. 
  
 4. 
 When all patterns have been exhausted, it reads in the next line. 
  
 Just before step 4 is performed, 
 sed
  displays the modified record. In 
 awk
  you must manually display the 
 record. 
  
 The actions taken in 
 awk
  and 
 sed
  are quite different. In 
 sed
 , the actions consist of commands that edit",NA
Regular Expressions ,"The basic building blocks of a regular expression are 
  
 G
 Ordinary characters 
  
  
 G
 Metacharacters 
  
 Ordinary characters are 
  
  
 G
 Uppercase and lowercase letters such as 
 A
  or 
 b 
  
 G
 Numerals such as 
 1
  or 
 2 
  
  
 G
 Characters such as a space or an underscore 
  
  Metacharacters
  are characters that have a special meaning inside a regular expression: They are 
 expanded to match ordinary characters. By using metacharacters, you need not explicitly specify all the 
 different combinations of ordinary characters that you want to match. The basic set of metacharacters 
 understood by both 
 sed
  and 
 awk
  is given in Table 16.1. 
  
 Frequently regular expressions are referred to as 
 patterns
 . In 
 Chapter 8, ""Substitution,""
  I 
 described the shell feature know as filename substitution, which uses a subset of regular expressions to 
 produce lists of files. 
  
 Note -
  In the context of filename substitution, I referred to metacharacters as 
 wildcards
 . You might see these two 
 terms used interchangeably in books and reference materials. 
  
 Table 16.1  Metacharacters Used in Regular Expressions 
  
   
  
 Character Description
  
  
  
  
 .
  
  
  
 Matches any single character except a newline. 
  
  
  
 *
  
  
  
 Matches zero or more occurrences of the character immediately preceding it. 
  
  
  
 [chars]
  
  
  
 Matches any one of the characters given in 
 chars
 , where 
 chars
  is a sequence of characters. 
 You can use the 
 -
  character to indicate a range of characters. If the 
 ^
  character is the first 
 character in 
 chars
 , one occurrence of any character that is not specified by 
 chars
  is 
 matched. 
  
  
  
 ^
  
  
  
 Matches the beginning of a line. 
  
  
  
 $
  
  
  
 Matches the end of a line. 
  
  
  
 \
  
  
  
 Treats the character that immediately follows the 
 \
  literally. This is used to specify patterns 
 that contain one of the preceding wildcards.",NA
Using ,NA,NA
sed,"Printing Lines 
 Deleting Lines
  
 Using Multiple sed Commands 
  
 Using sed in a Pipeline
  
  
  
 Performing Substitutions
  
 sed
  is a stream editor that you can use as a filter. It reads each line of input and then performs a set of 
 requested actions. The basic syntax of a 
 sed
  command is 
  
 sed '
 script
 ' 
 files
  
 Here 
 files
  is a list of one or more files, and 
 script
  is one or more commands of the form: 
  
 /
 pattern
 / 
 action
  
 Here, 
 pattern
  is a regular expression, and 
 action
  is one of the commands given in Table 16.4. If 
 pattern
  is omitted, 
 action
  is performed for every line. 
  
 Table 16.4  Some of the Actions Available in 
 sed
  
   
 Action
  
  
  
 Description
  
  
  
 p
  
  
  
 Prints the line 
  
  
  
 d
  
  
  
 Deletes the line 
  
  
  
  
 s/pattern1/pattern2/
  Substitutes the first occurrence of 
 pattern1
  with 
 pattern2
 .",NA
Printing Lines ,"Start with the simplest feature available in 
 sed
 --printing a line that matches a pattern. 
  
 Consider the price list for a small fruit market. The list is stored in the file 
 fruit_prices.txt
 :
  
 $ cat fruit_prices.txt 
  
 Fruit           Price/lbs 
  
 Banana          0.89 
  
 Paech           0.79 
  
 Kiwi            1.50 
  
 Pineapple       1.29 
  
 Apple           0.99 
  
 Mango           2.20",NA
Deleting Lines ,NA,NA
Performing Substitutions ,"By now you might have noticed that 
 Peach
  is misspelled as 
 Paech
  in the file 
 fruit_prices.txt
 . You can 
 fix this misspelling by substituting 
 Paech
  with the correct spelling 
 Peach
 . To do this, use the 
 sed
  command 
 s
  
 ( 
 s
  as in 
 substitute
 ):
  
 /
 pattern
 /s/
 pattern1
 /
 pattern2
 /
  
 Here 
 pattern
 , 
 pattern1
 ,
  and 
 pattern2
  are regular expressions. In the 
 s
  command 
 pattern1
  is 
 replaced with 
 pattern2
  on any line that matches 
 pattern
 .
  
 Frequently 
 pattern
  is omitted, so you see the 
 s
  command used as follows: 
  
 s/
 pattern1
 /
 pattern2
 /
  
 Here the 
 s
  command executes for every input line. 
  
 To fix the spelling of 
 Paech
 , you can use the following 
 sed
  command: 
  
 $ sed 's/Paech/Peach/' fruit_prices.txt
  
 The output looks like the following: 
  
 Fruit           Price/lbs 
  
 Banana          0.89 
  
 Peach           0.79 
  
 Kiwi            1.50 
  
 Pineapple       1.29 
  
 Apple           0.99 
  
 Notice that in this case you did not have to specify the 
 -n
  option to 
 sed
  to get the correct output. The 
 s 
 command is similar to the 
 d
  command in that it tells 
 sed
  to modify the regular output. 
  
 Common Errors 
  
 A common error with the 
 s
  command is forgetting one or more of the 
 /
  characters. For example, say you 
 were to issue the command 
  
 $ sed 's/Paech/Peach' fruit_prices.txt
  
 An error message similar to the following is produced: 
  
 sed: command garbled: s/Paech/Peach
  
 This is the standard style of 
 sed
  error messages:",NA
Using Multiple ,NA,NA
sed,NA,NA
 Commands ,"As you can see from the last example, you were able to update the prices, but 
 Paech
  is still misspelled. Say 
 that you need to update 
 fruit_prices.txt
  with both changes. This means that you have to perform more 
 than one 
 sed
  command on the file. You can do this in two ways: 
  
 G
 Perform the first change and then update the file. Perform the second change command and then 
  
 update the file. 
  
 G
 Perform both changes using a single 
 sed
  command and then update the file once. 
  
 As you can guess, the second method is much more efficient and less prone to error because the file is 
 updated only once. You can perform both changes using a single 
 sed
  command as follows: 
  
 sed -e '
 command1
 ' -e '
 command2
 ' ... -e '
 commandN
 ' files
  
 Here 
 command1
  through 
 commandN
  are 
 sed
  commands of the type discussed previously. These commands 
 are applied to each of the lines in the list of files given by 
 files
 .
  
 In this case you can perform both updates using either of the following commands: 
  
 $ sed -e 's/Paech/Peach/' -e 's/ *[0-9][0-9]*\.[0-9][0-9]$/\$&/' 
 fruit_prices.txt 
  
 Fruit           Price/lbs 
  
 Banana          $0.89 
  
 Peach           $0.79 
  
 Kiwi            $1.50 
  
 Pineapple       $1.29 
  
 Apple           $0.99 
  
 To update the file you use the same procedure as before: 
  
 $ mv fruit_pieces.txt fruit_pieces.txt.$$ 
  
 $ sed -e 's/Paech/Peach/' -e 's/ *[0-9][0-9]*\.[0-9][0-9]$/\$&/' 
 fruit_prices.txt.$$ > fruit_pieces.txt 
  
 $ cat fruit_pieces.txt 
  
 Fruit           Price/lbs 
  
 Banana          $0.89",NA
Using ,NA,NA
sed,NA,NA
 in a Pipeline ,"As I have mentioned before, if 
 sed
  does not receive a list of files, it acts on its STDIN. This enables us to 
 use it in pipelines. 
  
 I will demonstrate 
 sed
 's usage in this manner by using it to solve the problem of determining the user's 
 numeric user ID (uid). 
  
 On all UNIX systems the 
 /usr/bin/id
  command prints the current users uid and gid information. In my 
 case, the output of 
 id
  looks like the following: 
  
 $ /usr/bin/id 
  
 uid=500(ranga) gid=100(users) 
  
 As you can tell from the output, my numeric uid is 500. You need to modify this output so that only this 
 number is printed. Using 
 sed
  makes this task quite easy. 
  
 First you need to eliminate everything following the first parenthesis. You can do that as follows: 
  
 $ /usr/bin/id | sed 's/(.*$//' 
  
 Now the output looks like the following: 
  
 uid=500 
  
 If you eliminate the 
 uid=
  portion at the beginning of the line, you are finished. You can do this as follows: 
 $ /usr/bin/id | sed -e 's/(.*$//' -e 's/^uid=//' 
  
 Now the output is 
  
 500 
  
 This is what you want. Notice that when you added the second 
 s
  command, you changed from the single 
 command form for 
 sed
  to the multiple command form that uses the 
 -e
  option. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 16: Filtering Text Using Regular Expressions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The Basics of awk and sed
  
 Summary
  
 Using sed
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Summary,"In this chapter you looked at filtering text using regular expressions. Some of the major topics that you 
 covered are 
  
  
 G
 Matching characters 
  
  
 G
 Specifying sets of characters 
  
  
 G
 Anchoring patterns 
  
  
 G
 Escaping metacharacters 
  
 You also covered the similarities between the two most powerful text filtering programs available on UNIX 
 systems, 
 awk
  and 
 sed
 . Finally, you looked at using the 
 sed
  command. Some of the uses that you covered 
 are 
  
  
 G
 Printing lines 
  
  
 G
 Deleting lines 
  
  
 G
 Performing substitution 
  
 In the next chapter I will introduce the 
 awk
  command and its programming language. Using the material 
 covered in this chapter, you will be able to use 
 awk
  to easily perform difficult text manipulations. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 16: Filtering Text Using Regular Expressions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The Basics of awk and sed
  
 Summary
  
 Using sed
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Using 
 sed
 , write a shell function that searches for a word or simple expression in a list of files, 
 printing out a list of matches. This is similar to the 
 grep
  program. 
  
 You do not have to support all possible 
 sed
  expressions. Your function should take the word to look 
 for as its first argument. It should treat its other arguments as a list of files. 
  
 HINT: Use double quotes ( 
 ""
 ) instead of single quotes ( 
 '
 ) to surround your 
 sed
  script. 
  
 2. 
 Write a 
 sed
  command that takes as its input the output of the 
 uptime
  command and prints only 
 the last three load averages. The 
 uptime
  command's output looks like the following: 
  
 $ uptime 
  
 6:34pm  up 2 day(s), 49 min(s),  1 user,  load average: 
 0.00, 0.00, 0.02
  
 Your output should look like the following: 
  
 load average: 0.05, 0.01, 0.03
  
 3. 
 Write a 
 sed
  command that takes as its input the output of the command 
 df -k 
 and prints only 
 those lines that start with a /. The output of the 
 df -k 
 command looks like the following: 
  
 Filesystem          kbytes   used  avail capacity  Mounted on 
 /dev/dsk/c0t3d0s0   739262 455143 224979    67%    / 
  
 /proc                    0      0      0     0%    /proc fd                 
 0      0      0     0%    /dev/fd /dev/dsk/c0t3d0s1   123455   
 4813 106297     5%    /var /dev/dsk/c0t3d0s5   842150 133819 
 649381    18%    /opt swap                366052  15708 
 350344     5%    /tmp kanchi:/home       1190014 660165 
 468363    59%    /users
  
 On HP-UX use the command 
 df -b 
 instead of 
 df -k 
 .
  
 4. 
 Write a 
 sed
  command that takes as its input the output of the 
 ls -l 
 command and prints the 
 permissions and the filename for regular files. Directories, links, and special files should not appear 
 in the output. The output of 
 ls -l 
 should look similar to the following: 
  
 -rw-r--r--  1 ranga users  85 Nov 27 15:34 fruit_prices.txt-rw-
 r--r--  1 ranga users  80 Nov 27 13:53 fruit_prices.txt.7880 
 lrwxrwxrwx  1 ranga users   8 Nov 27 19:01 nash -> nash.txt-rw-
 r--r--  1 ranga users  62 Nov 27 16:06 nash.txt",NA
Hour 17 ,NA,NA
Filtering Text with ,NA,NA
awk ,"In 
 Chapter 16, ""Filtering Text Using Regular Expressions,""
  you looked at the 
 sed
  command and used 
 regular expressions to filter text. In this chapter you will look at another powerful text filtering command 
 called 
 awk
 .
  
 The 
 awk
  command is a complete programming language that enables you to search many files for patterns 
 and conditionally modify files without having to worry about opening files, reading lines, or closing files. It's 
 found on all UNIX systems and is quite fast, easy to learn, and extremely flexible. 
  
 This chapter concentrates on the 
 awk
  elements that are most commonly used in shell scripts. Specifically 
 these features are 
  
  
 G
 Field editing 
  
  
 G
 Variables 
  
  
 G
 Flow control statements",NA
What is ,NA,NA
awk,NA,NA
?,"Basic Syntax 
  
 Comparison Operators
  
 Field Editing 
  
 Using STDIN as Input
  
 Taking Pattern-Specific Actions
  
 The 
 awk
  command is a programming language that enables you to search through files and modify records 
 with these files based on patterns. The name 
 awk
  comes from the last names of its creators Alfred 
 A
 ho, 
 Peter 
 W
 einberger, and Brian 
 K
 ernighan. It has been a part of UNIX since 1978, when it was added to UNIX 
 Version 7. 
  
 Currently three main versions are available: 
  
 G
 The original 
 awk 
  
 G
 A newer version 
 nawk 
  
 G
 The POSIX/GNU version 
 gawk",NA
Basic Syntax ,"The basic syntax of an 
 awk
  command is 
  
 awk '
 script
 ' 
 files
  
 Here 
 files
  is a list of one or more files, and 
 script
  is one or more commands of the form: 
  
 /
 pattern
 / { 
 actions
  }
  
 Here 
 pattern
  is a regular expression, and 
 actions
  is one or more of the commands that are covered 
 later in this chapter. If 
 pattern
  is omitted, 
 awk
  performs the specified 
 actions
 for each input line. 
  
 Look at the simplest task in 
 awk
 , displaying all the input lines from a file. In this case you use a modified 
 version of the file 
 fruit_prices.txt
  from the previous chapter: 
  
 $ awk '{ print ; }' fruit_prices.txt 
 Fruit           Price/lbs       Quantity 
 Banana          $0.89           100 
  
 Peach           $0.79           65 
  
 Kiwi            $1.50           22 
  
 Pineapple       $1.29           35 
  
 Apple           $0.99           78 
  
 Here you use the 
 awk
  command 
 print
  to print each line of the input. When the 
 print
  command is given 
 without arguments, it prints the input line exactly as it was read. 
  
 Notice that there is a semicolon ( 
 ;
 ) after the 
 print
  command. This semicolon is required to let 
 awk
  know 
 that the command has concluded. Strictly speaking, some older versions of 
 awk
  do not require this, but it is 
 good practice to include it anyway.",NA
Field Editing ,NA,NA
Taking Pattern-Specific Actions ,"Say that you want to highlight those fruits that cost more than a dollar by putting a 
 *
  at the end of the line for 
 those fruits. This means that you need to perform different actions depending on the pattern that was 
 matched for the price. 
  
 Start with the following script: 
  
 #!/bin/sh 
  
 awk ' 
  
  
  / *\$[1-9][0-9]*\.[0-9][0-9] */ { print $1,$2,$3,""*""; } 
  
  / *\$0\.[0-9][0-9] */ { print ; } 
  
 ' fruit_prices.txt 
  
 Here you have two patterns: The first one looks for fruit priced higher than a dollar, and the second one 
 looks for fruit priced lower than a dollar. When a fruit priced higher than a dollar is encountered, the three 
 fields are output with a 
 *
  at the end of the line. For all other fruit, the line is printed exactly as it was read. 
  
 The output looks like the following: 
  
 Banana          $0.89           100 
  
 Peach           $0.79           65 
  
 Kiwi $1.50 22 * 
  
 Pineapple $1.29 35 * 
  
 Apple           $0.99           78 
  
 The main problem here is that the lines you wanted to flag with the 
 *
  in are no longer formatted in the same 
 manner as the other lines. You could solve this using 
 printf
 , but a much nicer and simpler solution is to 
 use the 
 $0
  field. The variable 
 0
  is used by 
 awk
  to store the entire input line as it was read. Change the script 
 as follows: 
  
 #!/bin/sh 
  
 awk ' 
  
  
  / *\$[1-9][0-9]*\.[0-9][0-9] */ { print $0,""*""; } 
  
  / *\$0\.[0-9][0-9] */ { print ; } 
  
 ' fruit_prices.txt 
  
 This changes the output so that all the lines are formatted identically: 
  
 Banana          $0.89           100 
  
 Peach           $0.79           65 
  
 Kiwi            $1.50           22 * 
  
 Pineapple       $1.29           35 * 
  
 Apple           $0.99           78",NA
Comparison Operators ,"Say that you have to flag all the fruit whose quantity is less than 75 for reorder by appending the string 
 REORDER
  to the end of their line. In this case you have to check whether the third field, which holds the 
 quantity, is less than or equal to 75. 
  
 To solve this problem, you need to use a comparison operator. In 
 awk
 , comparison operators compare the 
 values of numbers and strings. Their behavior is similar to operators found in the C language or the shell. 
  
 When you use a comparison operator, the syntax of an 
 awk
  command changes to the following: 
  
 expression
  { 
 actions
 ; }
  
 Here 
 expression
  is constructed using one of the comparison operators given in Table 17.1 
  
 Table 17.1  Comparison Operators in 
 awk
  
   
 Operator
  
  
  
 Description
  
  
  
 <
  
  
  
 Less than 
  
  
  
 >
  
  
  
 Greater than 
  
  
  
 <=
  
  
  
 Less than or equal to 
  
  
  
 >=
  
  
  
 Greater than or equal to 
  
  
  
 ==
  
  
  
 Equal to 
  
  
  
 !=
  
  
  
 Not equal to 
  
  
  
 value
  ~ / 
 pattern
 /
  
  
  
 True if 
 value
  matches 
 pattern
  
  
  
  
 value
  !~ / 
 pattern
 /
  True if 
 value
  does not match 
 pattern
  
  
  
  
 You can solve your problem using the following script: 
  
 #!/bin/sh 
  
 awk ' 
  
  
  $3 <= 75 { printf ""%s\t%s\n"",$0,""REORDER"" ; } 
  
  $3 > 75 { print $0 ; } 
  
 ' fruit_prices.txt 
  
 Here you check to see whether the third field contains a value less than or equal to 75. If it does, you print 
 out the input line followed by the string 
 REORDER
 . Next you check to see whether the third field contains a 
 value greater than 75 and, if it does, you print the input line unchanged. 
  
 The output from this scripts looks like the following: 
  
 Fruit           Price/lbs       Quantity 
  
 Banana          $0.89           100 
  
 Peach           $0.79           65      REORDER 
 Kiwi            $1.50           22      REORDER",NA
Using STDIN as Input ,"Recall that the basic form of an 
 awk
  command is 
  
 awk '
 script
 ' 
 files 
  
 If 
 files
 , the list of files, is omitted, 
 awk
  reads its input from STDIN. This enables us to use it to filter the 
 output of other commands. For example, the command",NA
Using ,NA,NA
awk,NA,NA
 Features ,"Variables
  
 Flow Control
  
 You have seen some of the basics of using 
 awk
 , and you'll now look at some of the more powerful features 
 that it provides. The main topics are 
  
  
 G
 Variables 
  
  
 G
 Flow control 
  
  
 G
 Loops 
  
 These features let you fully exploit the power of 
 awk
 .",NA
Variables ,"Variables in 
 awk
  are similar to variables in the shell: They are words that refer to a value. The basic syntax 
 of defining a variable is 
  
 name
 =
 value 
  
 Here 
 name
  is the name of the variable, and 
 value
  is the value of that variable. For example, the following 
 awk
  command 
  
 fruit=""peach"" 
  
 creates the variable 
 fruit
  and assigns it the value 
 peach
 . There is no need to initialize a variable: the first 
 time you use it, it is initialized. 
  
 Like the shell, the name of a variable can contain only letters, numbers, and underscores. A variable's name 
 cannot start with a number. 
  
 You can assign both numeric and string values to a variable in the same script. For example, consider the 
 following 
 awk
  commands: 
  
 fruit=""peach"" 
  
 fruit=100 
  
 The first command assigns the value 
 peach
  to the variable 
 fruit
 . The second command assigns the value 
 100
  to the variable 
 fruit
 .",NA
Flow Control ,"There are three main forms for flow control in 
 awk
 :
  
 G
 The 
 if
  statement 
  
 G
 The 
 while
  statement 
  
 G
 The 
 for
  statement 
  
 The 
 if
  and 
 while
  statements are similar to the versions in the shell, whereas the 
 for
  statement is much 
 closer to the version found in the C language version. 
  
 You will look at each of these statements in turn. 
  
 The 
 if
  Statement 
  
 The 
 if
  statement enables you to make tests before executing some 
 awk
  command. 
  
 The pattern matching and expressions that you have used in the previous examples are essentially 
 if 
 statements that affect the overall execution of the 
 awk
  program. The 
 if
  statement should be used within an 
 action rather than in the main input processing loop. 
  
 The basic syntax of the if statement is 
  
 if (
 expression1
 ) { 
  
 action1 
  
 } else if (
 expression2
 ) { 
  
 action2 
  
 } else { 
  
 action3 
  
 } 
  
 Here 
 expression1
  and 
 expression2
  are expressions created using the conditional operators. They are",NA
Summary,"In this chapter I have introduced programming in 
 awk
 . It is one of the most powerful text filtering tools 
 available in UNIX. By using 
 awk
 , you can often modify and transform text in ways that are difficult or 
 impossible using only the shell. 
  
 Some of the important topics that I have covered are 
  
  
 G
 Field editing 
  
  
 G
 Pattern specific actions 
  
  
 G
 Using STDIN as input 
  
  
 G
 Variables 
  
  
 G
 Numeric and assignment expressions 
  
  
 G
 Using flow control 
  
 In addition to these topics, 
 awk
  offers features such as multiple line editing, arrays, and functions. If you are 
 interested in learning more about these topics, consult one of the following sources: 
  
 The UNIX Programming Environment 
 by Brian Kernighan and Rob Pike (Prentice-Hall, 1984) 
  
 The AWK Programming Language 
 by Alfred Aho, Peter Weinberger, and Brian Kernighan (Addison-Wesley, 
 1984) 
  
 The GNU Awk User's Guide 
 by Arnold Robbins (SCC, 1996) 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 17: Filtering Text with awk 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 What is awk?
  
 Questions
  
 Using awk Features
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Write an 
 awk
  script that prints each of the fields in a record in reverse order. The output for the file 
 fruit_prices.txt
  should look like the following: 
  
 Quantity Price/lbs Fruit 
  
 100 $0.89 Banana 
  
 65 $0.79 Peach 
  
 22 $1.50 Kiwi 
  
 35 $1.29 Pineapple 
  
 78 $0.99 Apple
  
 (HINT: Use the 
 for
  statement and 
 NF
 )
  
 2. 
 Write an 
 awk
  script that balances a checking account. Your program needs to print the balance in 
 the account every time the user makes a transaction. 
  
 The transactions are stored in a file. Each line or record in the file has the following format: 
  
 command
 :
 date
 :
 comment
 :
 amount
  
 Here 
 date
  is the date on which the transaction was made, 
 comment
  is a string (including embedded 
 spaces) describing the transaction, and 
 amount
  is the amount of the transaction. The 
 command 
 determines what should be done to the balance with 
 amount
 . The valid 
 commands
  are 
  
 H
 B
 , indicates balance. When this command is encountered, the balance in the account should be 
 set to the transaction 
 amount
 .
  
 H
 D
 , indicates a deposit. When this command is encountered, the transaction 
 amount
  should be 
 added to the balance. 
  
 H
 C
 , indicates a check. When this command is encountered, the transaction 
 amount
  should be 
 subtracted from the balance. 
  
 H
 W
 , indicates a withdrawal. When this command is encountered, the transaction 
 amount 
 should be subtracted from the balance. 
  
 The main difference between the 
 C
  (check) and the 
 W
  (withdrawal) commands is that the 
 C
  (check) 
 command adds an extra field to its records: 
  
 command
 :
 date
 :
 comment
 :
 check number
 :
 amount
  
 In addition, the 
 B
  (balance) command uses only two fields:",NA
Terms,"Field
   A set of characters that are separated by one or more field separator characters. The default field 
 separator characters are tab and space. 
  
 Numeric expressions 
   Commands used to add, subtract, multiply, and divide two numbers. Numeric 
 expressions are constructed using the numeric operators 
 +
  (add), 
 -
  (subtract), 
 *
  (multiply), and 
 /
  (divide). 
  
 Field separator 
   The field separator controls the manner in which an input line is broken into fields. In the 
 shell, the field separator is stored in the variable 
 IFS
 . In 
 awk
 , the field separator is stored in the 
 awk 
 variable 
 FS
 . Both the shell and 
 awk
  use the default value of space and tab for the field separator. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 17: Filtering Text with awk 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 What is awk?
  
 Questions
  
 Using awk Features
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 18,NA,NA
Miscellaneous Tools ,"by Frank Watson 
  
 In this chapter, you will look at several miscellaneous UNIX commands that you often encounter 
  
 in shell scripts and can use in your own programs. The first of these tools includes 
 built-in
  shell commands, 
  
 which means that the shell can execute them without reading a separate utility from disk: 
  
 G
 eval 
  
 G
 : 
  
 G
 type
  
 Then you will cover several external commands that exist as binary programs on disk: 
  
 G
 sleep 
  
 G
 find
  and 
 xargs 
  
 G
 bc
  and 
 expr 
  
 G
 remsh
  (sometimes called 
 rsh
 , 
 rcmd
 , or 
 remote
 )
  
 Built-in tools run slightly more efficiently than external programs because they do not need to be read from 
  
 the disk. Unless you are looping thousands of times, you usually do not need to be concerned if the tool you 
  
 use is built in or external.",NA
The ,NA,NA
eval,NA,NA
 Command ,"The 
 eval
  command can be used when you want the shell to reprocess the command line a second time. 
 The basic syntax is 
  
 eval 
 any-UNIX-command
  
 Insert the 
 eval
  command at the start of any UNIX shell command. This is needed when shell special 
 characters are inserted via variable substitution or command substitution (refer to 
 Chapter 8, ""Substitution""
 ). 
  
 For example, 
  
 OUTPUT=""> out.file"" 
  
 echo hello $OUTPUT",NA
The ,NA,NA
:,NA,NA
 Command ,"The 
 :
  character is actually a complete shell command that does nothing but return a zero 
 completion code, which indicates the command has completed successfully. It can be used as a 
 no-op
 , 
  
 which is a command that does nothing and thus can be safely inserted anywhere a command is needed for 
  
 purely syntactical reasons: 
  
 if [ -x $CMD ] 
  
 then : 
  
 else 
  
  echo Error: $CMD is not executable >&2 fi 
  
 In this example, assume you are not quite ready to write the code to follow the 
 then
  statement. The shell 
 flags a syntax error if you leave that code out completely, so you insert the 
 :
  command as a temporary no-
 op command that can be replaced by the desired code later. 
  
 Because the 
 :
  always returns a successful result, it is sometimes used to create an infinite loop:
  
 while : 
  
 do 
  
  echo ""Enter some input: \c"" 
  
  read INPUT 
  
  [ ""$INPUT"" = stop ] && break 
  
 done 
  
 Because the 
 :
  always returns a successful or true result, the 
 while
  loop will continue forever or until a 
 break
  is executed within the loop. Sometimes you might find that 
 while true 
 used in place of 
 while : 
 but using the 
 :
  is more efficient because it is a shell built-in command, whereas 
 true
  is a command that 
 must be read from a disk file, if you are in the Bourne shell.
  
 You might sometimes find the 
 :
  used as the first line of a shell script. You sometimes find this in older 
 scripts written when programmers used the C shell but wrote scripts for the Bourne shell. If you start a script 
  
 from the C shell and the first character of the script is a 
 #
  sign, it assumes that this script uses C shell 
 syntax, not Bourne shell syntax. Thus it was important to start Bourne shell scripts with something other 
  
 than a 
 #
  sign, and the 
 :
  no-op was often used. 
  
 Another use of the 
 :
  command takes advantage of the fact that the shell evaluates arguments to it. This is a 
 useful way to invoke variable substitution as covered in 
 Chapter 8
 :",NA
The ,NA,NA
type,NA,NA
 Command ,"The 
 type
  command tells you the full pathname of a given UNIX command. 
  
 The basic syntax is 
  
 type 
 command1 command2
  ...
  
 If the command given is not a utility that exists as a separate disk file, 
 type
  tells you whether it is one of the 
 following: 
  
 G
 A shell built-in command 
  
 G
 A shell keyword or reserved word 
  
 G
 An alias 
  
 If the given command is an alias for another command, 
 type
  also gives the command that is actually 
 invoked when you run the alias. 
  
 For example, 
  
 $ type true vi case ulimit history 
  
 true is /bin/true 
  
 vi is /usr/bin/vi 
  
 case is a keyword 
  
 ulimit is a shell builtin 
  
 history is an exported alias for fc -l 
  
 $ 
  
 Different types of UNIX systems can implement the same command in different ways. For example, 
 true
  is 
 a shell included on some UNIX systems and in some UNIX shells and therefore is as efficient to use as the 
 :
  
 command. You can check whether 
 true
  is built into your system by using the 
 type
  command. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Hour 18: Miscellaneous Tools
  
 Next Chapter",NA
The ,NA,NA
sleep,NA,NA
 Command ,"The 
 sleep
  command pauses for a given number of seconds. The basic syntax is 
  
 sleep 
 n
  
 where 
 n
  is the number of seconds to sleep or pause. Some types of UNIX enable other time units to be 
 specified. It is usually recommended that 
 n
  not exceed 65,534. 
  
 sleep
  can be used to give a user time to read an output message before clearing the screen. It can also be 
 used when you want to give a series of beeps:
  
 echo -e ""A value must be input!\a"" 
  
 sleep 1 
  
 echo -ne ""\a"" 
  
 sleep 1 
  
 echo -ne ""\a"" 
  
 \a causes 
 echo
  to output an audible beep. 
 -e
  is required on some UNIX systems for 
 \a
  to sound a beep. 
 -
 n
  suppresses the newline that 
 echo
  normally prints. The 
 sleep
  command is used in the previous example 
 to give a sequence of beeps, spaced one second apart. 
  
 sleep
  can be used in a loop to repeat a job periodically: 
  
 while : 
  
 do 
  
  date 
  
  who 
  
  sleep 300 
  
 done >> logfile 
  
 This code enables a list of who is logged into the system to be appended to 
 logfile
  every 5 minutes (300 
 seconds). 
  
 Note -
  If you want to leave this code running all the time, you must clear 
 logfile
  periodically so that it does not 
 eat up all your disk space.",NA
The ,NA,NA
find,NA,NA
 Command ,"find: Starting Directory 
 find: -name Option 
  
 find: -type Option
  
 find: Combining Options 
  
 find: Negating Options
  
 find: -print Action
  
 find: -mtime, -atime, -ctimefind: -exec Action
  
 find: -size Option
  
 The 
 find
  command is a very powerful, very flexible way to create a list of files that match given criteria. The 
 basic syntax is 
  
 find start-dir options actions
  
 Here is a simple 
 find
  example: 
  
 find / -name alpha -print
  
 This example looks for all files named 
 alpha
  and displays the full pathname to the screen (standard output). 
 It is a useful command to know about when you are sure you have a file named 
 alpha
  but can't remember 
 what directory it is in or want to know whether it exists in more than one directory. Here is some possible 
 output from that command: 
  
 /reports/1998/alpha 
  
 /reports/1998/region2/alpha 
  
 /tmp/alpha 
  
 I will shortly cover the elements of the 
 find
  command in detail. Files can be selected not only by name but 
 also by size, last modification date, last access date, and so on. First let me give you a more complex 
 example with a brief explanation of each part of the example, so you get a sense of what options and actions 
 look like: 
  
 find /reports/1998 -name alpha -type f -print -exec lp {} \;
  
 Table 18.1 provides a breakdown of these elements. 
  
 Table 18.1  A Sample 
 find
  Command 
  
  
  
 Command Element Description",NA
find,NA,NA
: Starting Directory ,"A UNIX system can contain a huge number of files, often so many that 
 find
  can take several minutes or 
 more to complete. For this reason, 
 find
  enables specifying a starting directory to narrow down the number 
 of files it has to search. Only files in this directory and all its subdirectories are checked. 
 find
  enables either 
 an absolute or relative pathname for the starting directory. If you specify an absolute pathname such as 
 /reports
 , 
  
 find /reports -name alpha -print 
  
 then all the files found are specified as absolute pathnames, as in this sample output: 
  
 /reports/1998/alpha 
  
 /reports/1998/region2/alpha 
  
 If you specify a relative pathname to 
 find
 , 
  
 cd /reports 
  
 find ./1998 -name alpha -print 
  
 all the files are displayed relative to the starting directory. For example, 
  
 ./1998/alpha 
  
 ./1998/region2/alpha 
  
 To search the whole system, specify 
 /
  as the starting directory. This indicates the system root directory that 
 includes all other files and directories: 
  
 find / -name alpha -print 
  
 To search the entire system and still display all found files as relative pathnames, use the following:",NA
find,NA,NA
: ,NA,NA
-name,NA,NA
 Option ,"The 
 -name
  option enables us to specify either an exact or partial filename for 
 find
  to match. 
 find
  checks 
 for a match only in the filename and not in the directory portion of the pathname. 
  
 find / -name alpha -print 
  
 /tmp/alpha has a matching filename and would be displayed by this command. 
 /reports/alpha/file2 
 would not be displayed because 
 find
  ignores the directory portion of the 
 pathname. 
  
 To specify a partial pathname, use filename substitution wildcards (refer to 
 Chapter 8
 ). For instance, 
  
 find / -name '*alpha*' -print 
  
 This displays all files that contain 
 alpha
  anywhere within the filename. Here is some sample output: 
  
 /reports/1998/alpha 
  
 /reports/1998/alpha2 
  
 /reports/1998/old-alpha 
  
 /reports/1998/region2/alpha 
  
 /tmp/alpha 
  
 /usr/fredp/ralphadams 
  
 All the wildcards covered in 
 Chapter 8
  can be used: 
  
 * ? [
 characters
 ] [!
 characters
 ] 
  
 You must enclose the filename containing these wildcards within single quotes (see 
 Chapter 9
 ); otherwise, 
  
 your 
 find
  command does not always give you the desired results.",NA
find,NA,NA
: ,NA,NA
-type,NA,NA
 Option ,"The 
 -type
  option enables us to specify the type of file to search for, as in this example: 
  
 find / -type d -print
  
 -type d indicates directories, so only files that are directories are displayed. In this example, all directories in 
 the whole system are displayed. Notice that no 
 -name
  option has been given, so you display all directories 
 regardless of their names. Table 18.2 lists other types that are available. 
  
 Table 18.2  Types Available for the 
 find
  Command 
  
   
  
 Type Description
  
  
  
  
 f
  
  
  
 Regular or normal file 
  
  
  
 d
  
  
  
 Directory
  
  
  
 b
  
  
  
 Block special device file 
  
  
  
 c
  
  
  
 Character special device file (raw) 
  
  
  
 l
  
  
  
 Symbolic link 
  
  
  
 p
  
  
  
 Named pipe",NA
find,NA,NA
: ,NA,NA
-mtime,NA,NA
", ",NA,NA
-atime,NA,NA
", ",NA,NA
-ctime ,"The 
 find -mtime
  option enables us to locate files that were last modified recently or have not been 
 modified in a long time: 
  
 find / -mtime -5 -print
  
 -mtime
  takes an integer argument that is measured in days. This 
 find
  command locates files that were last 
 modified fewer than five days ago. This is a useful option when you are sure you modified a file recently but 
 can't remember its name or directory. 
  
 Following 
 -mtime
  you must specify an integer value: 
  
 +n 
  
 Find only files last modified more than n days ago 
 n 
  
 Find only files last modified exactly n days ago 
 -n 
  
 Find only files last modified fewer than n days ago 
  
 To find files that have not been modified in the last 
 n
  days, look for files that were last modified more than 
 n 
 days ago: 
  
 find / -mtime +90 -print 
  
 This shows all files that were last modified more than 90 days ago: that is, files that have not been modified",NA
find,NA,NA
: ,NA,NA
-size,NA,NA
 Option ,"The 
 find -size
  option enables us to locate files based on the number of blocks in the file: 
  
 find / -size +2000 -print
  
 This 
 find
  command prints the names of all files that contain more than 2,000 blocks. It is useful when you 
  
 want to find the largest files that are consuming disk space. 
  
 Following 
 -size
 , you must specify an integer number: 
  
 +
 n 
  
 n
  
 -n
  
 Finds only files that contain more than 
 n
  blocks 
 Finds only files that contain exactly 
 n
  blocks 
 Finds only files that contain fewer than 
 n
  blocks 
  
  
  
 Tip -
  It is a very rare occasion when you need to search for files that contain an exact number of blocks. 
  
  
 Usually you look for files that contain more than 
 n
  blocks or fewer than 
 n
  blocks. UNIX neophytes often 
  
 forget the plus or minus sign for these types of 
 find
  options and then wonder why 
 find
  did not locate the 
 expected files.",NA
find,NA,NA
: Combining Options ,"If you specify more than one option, the file must match all options to be displayed:",NA
find,NA,NA
: Negating Options ,"You can use the 
 !
  sign to select files that do not match the given option: 
  
 find /dev ! \( -type b -o -type c -o type d \) -print
  
 This locates all files in the 
 /dev
  directory and its subdirectories that are not block special device files, 
 character special device files, or directories. This is a useful command to locate device names that users 
 have misspelled, which leaves a regular file in 
 /dev
  that can waste a large amount of disk space.",NA
find,NA,NA
: ,NA,NA
-print,NA,NA
 Action ,"-print
  is an action that tells 
 find
  to display the pathnames of all files that match the options given before 
 -print
 . If you put the 
 -print
  action before other options in the command line, those options are not used 
 in the selection process: 
  
 find / -size -20 -print -mtime +30
  
 This command prints all files that contain fewer than 20 blocks. The 
 -mtime
  option is ignored because it 
 comes after the 
 -print
  action on the command line. 
  
 If no action is specified on the command line, 
 -print
  is usually done by default. On older versions of UNIX, 
 however, you must remember to include - 
 print
  specifically, or no output is generated.",NA
find,NA,NA
: ,NA,NA
-exec,NA,NA
 Action ,"-exec
  is an action that lets you specify a UNIX command to run on each of the files that match the options 
 given:",NA
xargs,"xargs
  is a command that accepts a list of words from standard input and provides those words as 
 arguments to a given command: 
  
 cat filelist | xargs rm
  
 You cannot pipe the output of 
 cat
  directly to 
 rm
  because 
 rm
  does not look for filenames on standard input. 
  
 xargs
  reads the files being passed by 
 cat
  and builds up a command line beginning with 
 rm
  and ending 
 with the filenames. If there are a large number of files, 
 xargs
  runs the 
 rm
  command multiple times, deleting 
 some of the files each time. You can specify how many arguments from standard input to build up on the 
 command line with the 
 -n
  option: 
  
 cat filelist | xargs -n 20 rm 
  
 -n 20
  says to put only 20 arguments on each command line, so you delete only 20 files at a time. Here is a 
 different example to give you more insight into how 
 xargs
  works: 
  
 $ ls 
  
 acme 
  
 report16 
  
 report3 
  
 report34 
  
 report527 
  
 $ ls | xargs -n 2 echo === 
  
 === acme report16 
  
 === report3 report34 
  
 === report527 
  
 $ 
  
 The first 
 ls
  command shows us that there are only five files in the current directory. (These five can be 
 regular files or directories; it does not matter for this example.) Next you pipe the output of 
 ls
  to 
 xargs
 , 
 which composes and executes this command (the first of several): 
  
 echo === acme report16
  
 The command begins with 
 echo === 
 because these are the arguments given to the 
 xargs
  command. 
 The command then contains two filenames read from standard input. 
 -n 2 
 tells 
 xargs
  to add only two 
 words from standard input to each 
 echo
  command. I added 
 ===
  as the first 
 echo
  argument so you can 
 visually find the output from each separate 
 echo
  command. You can see that 
 xargs
  called 
 echo
  three",NA
The ,NA,NA
expr,NA,NA
 Command ,"The 
 expr
  command performs simple integer arithmetic:
  
 $ expr 8 / 3 
  
 2 
  
 $ 
  
 Notice that any fractional result is ignored. The general syntax is 
  
 expr 
 integer1 operand integer2
  
 Possible operands are given in Table 18.3. 
  
 Table 18.3   
 expr
  Operands 
  
   
  
 Operand Description
  
  
  
  
 +
  
  
  
 Addition
  
  
  
 -
  
  
  
 Subtraction
  
  
  
 \*
  
  
  
 Multiplication
  
  
  
 /
  
  
  
 Integer division (any fraction in the result is dropped) 
  
  
  
 % Remainder from a division operation (also called the modulus function) 
  
 Notice that the 
 *
  sign must be quoted to prevent shell expansion (see 
 Chapter 9
 ), but the spaces around the 
  
 *
  sign must not be quoted: 
  
 $ expr 3 \* 5 
  
 15 
  
 $ 
  
  The 
 remainder
  or 
 modulus
  function is what remains after a division operation:
  
 $ expr 19 % 7 
  
 5",NA
The ,NA,NA
bc,NA,NA
 Command ,"bc
  is an arithmetic utility not limited to integers: 
  
 $ bc 
  
 scale=4 
  
 8/3 
  
 2.6666 
  
 2.5 * 4.1/6.9 
  
 1.4855 
  
 quit 
  
 $ 
  
 In this example, you invoke 
 bc
  and set scale to 4, meaning that you want it to calculate any fraction to four 
 decimal places. You ask it to calculate 8/3, which gives 2.6666 and then a more complex calculation. Note 
 that spaces are optional. Finally you enter 
 quit
  to return to the shell prompt. 
 bc
  can handle addition (+), 
 subtraction (-), multiplication (*), division (/), remainder or modulo (%), and integer exponentiation (^). 
 bc 
 can accurately compute numbers of any size: 
  
 9238472938742937 * 29384729347298472 
  
 271470026887302339647844620892264 
  
 bc can be used in shell variable assignment to assign calculated values to variables: 
  
 AVERAGE=´echo ""scale=4; $PRICE/$UNITS"" | bc´
  
 The 
 echo
  command is used here to print directives that are piped to 
 bc
 . The first directive sets the scale to 
 4; the second directive is a division operation. These directives are piped to 
 bc
 , which does the calculations 
 and returns the result. The backquotes allow the result from 
 bc
  to be stored in the variable 
 AVERAGE
 .
  
 bc
  allows conversion between different number bases: 
  
 $ bc 
  
 obase=16 
  
 ibase=8 
  
 400 
  
 100 
  
 77 
  
 3f 
  
 10*3",NA
remsh/rsh/rcmd/remote,NA,NA
 (Remote Shell) ,"If you have several UNIX systems connected over a network, it is possible to invoke a remote shell to run a 
 command on the remote system and return the output of that command to your screen: 
  
 remsh acron who
  
 This shows us who is logged into the remote system called 
 acron
 . The basic syntax is: 
  
 remsh 
 remote-sys unix-command
  
 remote-sys
  is the name of the remote system where the given 
 unix-command
  runs. You can pipe text to 
 remsh
 , which is passed to the 
 unix-command
  being run on the remote system. Any standard output from 
 unix-command
  on the remote system is passed to standard output on your system where it can be 
 redirected if desired. 
  
 Different types of UNIX systems have different names for this command including: 
 remsh
 , 
 rsh
 , 
 rcmd
 , or 
 remote
 .
  
 Check the man pages on your system to see which command is correct. Be careful to avoid confusion with 
 the restricted shell command 
 rsh
 , which is sometimes invoked as 
 /usr/lib/rsh
  if 
 rsh
  invokes the 
 remote shell. 
  
 Using the remote shell requires setting up 
 /etc/hosts.equiv
 , which indicates a trust relationship 
 between the two systems. The simplest most trusting setup is to put each system name in the other 
 system's 
 host.equiv
  file. Usually the same user account is added to both systems. Then a remote 
 command run by that user on one system runs with the same access permissions for that user on the other 
 system. To use this facility for root, 
 /.rhosts
  must be set up to contain the other system name. 
  
 Here is a more complex example that enables us to copy a whole directory tree to the remote system: 
  
 cd /
 sourcedir 
  
 find . -print | cpio -ocva | 
  
  
  remsh 
 remote_sys
  \( cd /
 destdir
  \; cpio -icdum \) 
  
 The 
 find
  command passes a list of files to 
 cpio
 , which copies them to standard output. This is passed by 
 the remote shell command to the remote system where the files are restored to the desired destination 
 directory. Notice that many of the special characters must be escaped--that is, preceded by a backslash--so 
 they are interpreted on the remote system and not on the local system.",NA
Summary,"In this chapter you have looked at several miscellaneous tools: 
  
 G
 eval 
  
 G
 :
  
  
 G
 type 
  
  
 G
 sleep 
  
  
 G
 find 
  
  
 G
 xargs 
  
  
 G
 expr 
  
  
 G
 bc 
  
  
 G
 remsh
 /
 rsh
 /
 rcmd
 /
 remote 
  
 A large part of this chapter was spent on the basics of the 
 find
  command. Peruse the man page on 
 find
 , 
 and you can see other useful 
 find
  options for your scripts that I did not cover. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 18: Miscellaneous Tools 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The eval Command
  
 The expr Command
  
 The : Command
  
 The bc Command
  
 The type Command
  
 remsh/rsh/rcmd/remote (Remote Shell)
  
 The sleep Command
  
 Summary
  
 The find Command
  
 Questions
  
 xargs
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 You are about to run a custom command called 
 process2
 , but you would first like to determine 
 where that command resides. Give a UNIX command to do this. 
  
 2. 
 How can you determine all directories under 
 /data
  that contain a file called 
 process2
 , allowing 
 any possible prefix or suffix to also be displayed (for example, you want to find names such as 
 process2-doc
 ).
  
 3. 
 How can you increase the numeric value in variable 
 PRICE
  to be 3.5 times its current amount? 
 Allow two digits to the right of the decimal point. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 18: Miscellaneous Tools 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The eval Command
  
 The expr Command
  
 The : Command
  
 The bc Command
  
 The type Command
  
 remsh/rsh/rcmd/remote (Remote Shell)
  
 The sleep Command
  
 Summary
  
 The find Command
  
 Questions
  
 xargs
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"no-op
   A command that does nothing and thus can be used as a dummy command or placeholder where 
 syntax requires a command. 
  
 built-in
   A command whose code is part of the shell as opposed to a utility which exists in a separate disk 
 file which must be read into memory before it is executed. 
  
 reserved word 
   A nonquoted word that is used in grouping commands or selectively executing them, such 
 as: 
 if
 , 
 then
 , 
 else
 , 
 elif
 , 
 fi
 , 
 case
 , 
 esac
 , 
 for
 , 
 while
 , 
 until
 , 
 do
 , or 
 done
 .
  
 modulus function 
   See remainder function. 
  
 remainder function 
   The remainder of a division operation, which is the amount that is left over when the 
 amounts are not evenly divisible. 
  
 inode
   A table entry within a file system that contains file information such as the owner, group, permissions, 
 last modification date or time, last access date or time, and the block list of the actual file data. There is one 
 inode for each file. The inodes are numbered sequentially. The inode does not contain the filename. A 
 directory is a table that maps filenames to inode numbers. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 18: Miscellaneous Tools 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 The eval Command
  
 The expr Command
  
 The : Command
  
 The bc Command
  
 The type Command
  
 remsh/rsh/rcmd/remote (Remote Shell)
  
 The sleep Command
  
 Summary
  
 The find Command
  
 Questions
  
 xargs
  
 Terms
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 19 ,NA,NA
Dealing with Signals ,"Signals
  are software interrupts sent to a program to indicate that an important event has 
 occurred. The events can vary from user requests to illegal memory access errors. Some signals, such as 
 the interrupt signal, indicate that a user has asked the program to do something that is not in the usual flow 
 of control. 
  
 Because signals can arrive at any time during the execution of a script, they add an extra level of complexity 
 to shell scripts. Scripts must account for this fact and include extra code that can determine how to respond 
 appropriately to a signal regardless of what the script was doing when the signal was received. 
  
 In this chapter you will look at the following topics: 
  
 G
 The different types of signals encountered in shell programming 
 G
 How to deliver signals using the 
 kill
  command 
  
 G
 Handling signals 
  
 G
 How to use signals within your script",NA
How Are Signal Represented? ,"Getting a List of Signals 
  
 Delivering Signals
  
 Default Actions
  
 Each type of event is represented by a separate signal. Each signal is only a small positive integer. The 
 signals most commonly encountered in shell script programming are given in Table 19.1. All the listed 
 signals are available on all versions of UNIX.
  
 Table 19.1  Important Signals for Shell Scripts 
  
   
 Name
  
  
  
  
 Value Description
  
  
  
  
 SIGHUP
  
  
  
 1
  
  
  
 Hang up detected on controlling terminal or death of controlling process 
  
  
  
 SIGINT
  
  
  
 2
  
  
  
 Interrupt from keyboard 
  
  
  
  
 SIGQUIT
  3
  
  
  
  
 Quit from keyboard 
  
  
  
  
 SIGKILL
  9
  
  
  
  
 Kill signal 
  
  
  
  
 SIGALRM
  14
  
  
  
  
 Alarm Clock signal (used for timers) 
  
  
  
  
 SIGTERM
  15
  
  
  
  
 Termination signal",NA
Getting a List of Signals ,"All the signals understood by your system are listed in the C language header file 
 signal.h
 . The location 
 of this file varies between UNIX flavors. Some common locations are 
  
 G
 Solaris and HPUX: 
 /usr/include/sys/signal.h 
 G
 Linux: 
 /usr/include/asm/signal.h
  
 Some vendors provide a 
 man
  page for this file which you can view with one of the following commands:
  
 G
 In Linux: 
 man 7 signal 
  
 G
 In Solaris: 
 man -s 5 signal 
  
 G
 In HP-UX: 
 man 5 signal 
  
 Another way that your system can understand a list of signals is to use the 
 -l
  option of the 
 kill
  command. 
 For example on a Solaris system the output is: 
  
 $ kill -l 
  
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL  5) 
 SIGTRAP      6) SIGABRT      7) SIGEMT       8) SIGFPE  9) 
 SIGKILL     10) SIGBUS      11) SIGSEGV     12) SIGSYS 13) 
 SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGUSR1 17) 
 SIGUSR2     18) SIGCHLD     19) SIGPWR      20) SIGWINCH 21) 
 SIGURG      22) SIGIO       23) SIGSTOP     24) SIGTSTP 25) 
 SIGCONT     26) SIGTTIN     27) SIGTTOU     28) SIGVTALRM 29) 
 SIGPROF     30) SIGXCPU     31) SIGXFSZ     32) SIGWAITING 33) 
 SIGLWP      34) SIGFREEZE   35) SIGTHAW     36) SIGCANCEL 37) 
 SIGLOST 
  
 The actual list of signals varies between Solaris, HP-UX, and Linux.",NA
Default Actions ,"Every signal, including those listed in Table 19.1, has a 
 default action 
 associated with it. The default action 
 for a signal is the action that a script or program performs when it receives a signal. 
  
 Some of the possible default actions are 
  
 G
 Terminate the process. 
  
 G
 Ignore the signal. 
  
 G
 Dump core. This creates a file called 
 core
  containing the memory image of the process when it 
  
 received the signal. 
  
 G
 Stop the process. 
  
 G
 Continue a stopped process.",NA
Delivering Signals ,"There are several methods of delivering signals to a program or script. One of the most common is for a 
 user to type 
 CONTROL-C
  or the 
 INTERRUPT
  key while a script is executing. In this case a 
 SIGINT
  is sent to 
 the script and it terminates. 
  
 The other common method for delivering signals is to use the 
 kill
  command as follows: 
  
 kill -
 signalpid
  
 Here 
 signal
  is either the number or name of the signal to deliver and 
 pid
  is the process ID that the signal 
 should be sent to. 
  
 TERM
  
 In previous chapters you looked at the 
 kill
  command without the signal argument. By default the 
 kill 
 command sends a 
 TERM
  or terminates a signal to the program running with the specified pid. Recall from 
 Chapter 6, ""Processes,""
  that a PID is the process ID given by UNIX to a program while it is executing. Thus 
  
 the commands 
  
 kill 
 pid 
  
 kill -s SIGTERM 
 pid
  
 are equivalent. 
  
 Now look at a few examples of using the 
 kill
  command to deliver other signals. 
  
 HUP
  
 The following command
  
 $ kill -s SIGHUP 1001
  
 sends the 
 HUP
  or hang-up signal to the program that is running with process ID 1001. You can also use the 
 numeric value of the signal as follows: 
  
 $ kill -1 1001
  
 This command also sends the hang-up signal to the program that is running with process ID 1001. Although 
 the default action for this signal calls for the process to terminate, many UNIX programs use the 
 HUP
  signal 
 as an indication that they should reinitialize themselves. For this reason, you should use a different signal if 
 you are trying to terminate or kill a process.",NA
Dealing with Signals ,"The trap Command 
  
 Ignoring Signals
  
 Cleaning Up Temporary Files 
  
 Setting Up a Timer
  
 A program or script can handle a signal in three different ways: 
  
 G
 Do nothing and let the default action occur. This is the simplest method for a script to deal with a 
  
 signal. 
  
 G
 Ignore the signal and continue executing. This method is not the same as doing nothing, because 
  
 ignoring a signal requires the script to have some code that explicitly ignores signals. 
  
 G
 Catch the signal and perform some signal-specific commands. In this method the script has a special 
 routine that executes when a signal is received. This is the most complex and powerful method of 
 dealing with signals. 
  
 The first method for dealing with a signal requires no additional code in your shell script. This is the default 
 behavior for all shell scripts that do not explicitly handle signals. All the scripts that you have looked at so far 
 handle signals using this method. 
  
 In this section you will look at the second and third methods of dealing with signals.",NA
The ,NA,NA
trap,NA,NA
 Command ,"The 
 trap
  command sets and unsets the actions taken when a signal is received. Its syntax is 
  
 trap 
 namesignals
  
 Here 
 name
  is a list of commands or the name of a shell function to execute when a signal in the list of 
 specified 
 signals
  is received. If 
 name
  is not given, 
 trap
  resets the action for the given signals to be the 
 default action. 
  
 There are three common uses for 
 trap
  in shell scripts: 
  
 G
 Clean up temporary files 
  
 G
 Always ignore signals 
  
 G
 Ignore signals only during critical operations 
  
 You will look at a fourth use, setting up a timer, later in this chapter.",NA
Cleaning Up Temporary Files ,NA,NA
Ignoring Signals ,"Sometimes there is no intelligent or easy way to clean up if a signal is received. In these cases, it is better to 
 ignore signals than to deal with them. There are two methods of ignoring signals: 
  
 trap '' 
 signals",NA
Setting Up a Timer ,"In many scripts, there are critical sections where commands that require a large amount of time to complete 
 are executed. On rare occasions, these commands might not finish processing. In order to deal with this 
 situation, you need to set up a timer within the script. When the timer expires, you should terminate the 
 program and inform the user about the abnormal exit. 
  
 In this section you will walk through a simple script that demonstrates the major aspects of setting up a timer 
 using the 
 ALARM
  signal and a signal handler. 
  
 The main body of this script needs to perform the following actions: 
  
 1. 
 Set a handler for the 
 ALARM
  signal. 
  
 2. 
 Set the timer. 
  
 3. 
 Execute the program.",NA
Conclusion,"In this chapter, I introduced the concept of signals. Signals inform a program or script that an important 
 event has occurred. 
  
 You learned about the most common signals encountered in shell programming. I also listed several 
 methods of obtaining a complete list of all the signals understood by your system. In this section you also 
 covered the concept of delivering signals and the default actions associated with a signal. 
  
 In the second section of this chapter I introduced the three main methods of handling a signal in a script. 
 Now you know how to catch signals and handle them using signal handlers. You also know how to ignore 
 signals. Finally I showed you how to use signals to set up a timer inside your scripts. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 19: Dealing with Signals 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How Are Signal Represented?
  
 Conclusion
  
 Dealing with Signals
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 The following is the main body of the ""alive"" script presented earlier in this chapter. Please change 
 it so that receiving a 
 SIGQUIT
  causes it to exit when the 
 wait
  command returns. 
  
 # main() 
  
 trap CleanUp 2 3 15 
  
 trap Init 1 
  
 PROG=$1 
  
 Init 
  
 while : ; 
  
 do 
  
  wait $!
  
  $PROG & 
  
 done
  
 2. 
 Add a signal handler to the timer script to handle the 
 INT
  signal. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 19: Dealing with Signals 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 How Are Signal Represented?
  
 Conclusion
  
 Dealing with Signals
  
 Questions
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 20 ,NA,NA
Debugging ,"In this book you have looked at scripts that are quite short. Thus, the issue of debugging them has boiled 
 down to looking at their output and making sure it is correct. 
  
 For larger shell scripts, especially the kind that change system configurations, trying to deduce the source of 
 a problem from a script's output is insufficient. Often, by the time you get the output, it is too late--the script 
 will have made incorrect modifications or changes. Another common scenario is adding features to a large 
 script that someone else developed. In such cases you need to make sure your changes don't affect the rest 
 of the script. Fortunately, the shell provides several built-in commands for enabling different modes of 
 debugging support. 
  
 In this chapter you learn how to enable debugging, and then you will look at how to use the following 
 debugging modes: 
  
 G
 Syntax checking 
  
 G
 Shell tracing",NA
Enabling Debugging ,"By now, you are quite familiar with the basic syntax for executing a shell script: 
  
 $ 
 scriptarg1arg2
  ... 
 argN
  
 Here 
 script
  is the name of the script, and 
 arg1
  through 
 argN
  are the arguments to the script. A 
 frequently used alternative method to execute a shell script is 
  
 $ /bin/sh 
 scriptarg1arg2
  ... 
 argN
  
 Here you explicitly specify the shell, in this case 
 /bin/sh
 , that you used to execute the script. The 
 advantage of this method is that you can enable a debugging mode by supplying arguments to the shell. 
  
 Using this method of script invocation, the basic syntax for enabling a debugging mode is 
  
 $ /bin/sh 
 optionscriptarg1arg2
  ... 
 argN
  
 Here 
 option
  is one of the debugging options covered in Table 20.1.",NA
Using the ,NA,NA
set,NA,NA
 command ,"In one of the invocation activated debugging modes, the default behavior is for that debugging mode to take 
 effect at the first line of your script and remain in effect until the last line. Sometimes you just need to debug a 
 particular function or section of your script. In these cases, enabling debugging for the entire script is overkill. 
  
 As you see later in this chapter, the debugging output is quite extensive, and it is often hard to sort out the 
 real errors from the noise. Address this problem with the 
 set
  command to enable the debugging modes. 
  
 By using the 
 set
  command, you can enable and disable debugging at any point in your shell script. 
  
 Enabling Debugging Using 
 set
  
 The basic syntax follows: 
  
 set 
 option
  
 Here 
 option
  is one of the options given in Table 20.1. 
  
 You can use the 
 set
  command anywhere in your shell script, and many scripts use it to change the 
 debugging flags as part of the normal execution of the script. Because these debugging modes are activated 
 only when the shell script programmer uses the 
 set
  command, they are sometimes referred to as 
 ""programmer activated"" modes.",NA
Syntax Checking ,"Why You Should Use Syntax Checking
  
 Using Verbose Mode
  
 When dealing with any shell script, check the syntax of the script before trying to execute it. This enables 
 you to fix most problems. 
  
 To enable syntax checking, use the 
 -n
  option as follows: 
  
 /bin/sh -n 
 scriptarg1arg2
  ... 
 argN
  
 Here 
 script
  is the name of a script and 
 arg1
  through 
 argN
  are the arguments for that script. This 
 command generates output only if errors occur in the specified 
 script
 .
  
 Check the syntax of the following script (the line numbers are included for your reference): 
  
  1  #!/bin/sh 
  
  2   
  
  3  YN=y 
  
  4  if [ $YN = ""yes"" ]  
  
  5      echo ""yes"" 
  
  6  fi 
  
 Can you spot the error? 
  
 If this script is stored in the file 
 buggy1.sh
 , check its syntax as follows: 
  
 $ /bin/sh -n ./buggy1.sh
  
 The output looks like the following: 
  
 ./buggy1.sh: syntax error at line 7: 'fi' unexpected
  
 This tells you that when the shell tried to read line 7, it found that the 
 fi
  statement on line 6 was 
  
 unexpected. By now you have probably figured out that the reason the shell was trying read line 7 is that the 
 if
  statement on line 4 
  
 if [ $YN = ""y"" ]
  
 is not terminated with a 
 then
  statement. This line should read as follows:",NA
Why You Should Use Syntax Checking ,"After looking at the shell script in the previous example, you might be wondering why you couldn't simply 
 execute the shell script to determine the problem. After all, the command 
  
 $ /bin/sh ./buggy1.sh
  
 produces the output 
  
 buggy1.sh: syntax error at line 7: 'fi' unexpected
  
 This output is identical to the output of the following command: 
  
 $ /bin/sh -n ./buggy1.sh
  
 For this script, it does not matter whether you use the syntax checking mode, but this is not always the case. 
 As an example, consider the following script (the line numbers are included for your reference): 
  
  1  #!/bin/sh 
  
  2   
  
  3  Failed() { 
  
  4      if [ $1 -ne 0 ] ; then 
  
  5          echo ""Failed. Exiting."" ; exit 1 ;  6      
 fi 
  
  7      echo ""Done."" 
  
  8  } 
  
  9   
  
  10  echo ""Deleting old backups, please wait... \c""  
 11  rm -r backup > /dev/null 2>&1 
  
  12  Failed $? 
  
  13   
  
  14  echo ""Make backup (y/n)? \c"" 
  
  15  read RESPONSE 
  
  16  case $RESPONSE in 
  
  17      [yY]|[Yy][Ee][Ss]|*)  
  
  18          echo ""Making backup, please wait... \c""  
 19          cp -r docs backup 
  
  20          Failed 
  
  21      [nN]|[Nn][Oo]) 
  
  22          echo ""Backup Skipped."" ;;",NA
Using Verbose Mode ,"Now that you know why syntax checking should be employed, you can track down the source of the 
 problem. 
  
 Looking at line 21 of 
 buggy2.sh 
  
 21      [nN]|[Nn][Oo]) 
  
 it is hard to see why the shell thinks the parenthesis 
 )
  is unexpected. Sometimes knowing where a syntax 
 error occurs is not enough--you have to know the context in which the error occurs. 
  
 The shell provides you with the 
 -v
  ( 
 v
  as in 
 verbose
 ) debugging mode in order to check the context in which 
 a syntax error occurs. When this option is specified, the shell prints each line of a script as it is read. 
  
 If you issue the 
 -v
  option by itself, every line in the script will execute. Because you want to check the 
 syntax, you combine the 
 -n
  and 
 -v
  options as follows: 
  
 $ /bin/sh -nv 
 scriptarg1arg2
  ... 
 argN 
  
 If you execute 
 buggy2.sh
  with the debugging options",NA
Shell Tracing ,"Finding Syntax Bugs Using Shell Tracing 
  
 Using Debugging Hooks
  
 Finding Logical Bugs Using Shell Tracing
  
 There are many instances when syntax checking gives your script a clean bill of health, but bugs are still 
 lurking in your script. Running syntax checking on a shell script is similar to running a spelling checker on a 
 text document--it might find most of the misspellings, but it can't fix problems like spelling 
 read
  as 
 red
 .
  
 For text documents, you need to proofread them in order to find and fix all misspellings. To find and fix these 
 types of problems in shell scripts, you need to use shell tracing. 
  
 In shell tracing mode the shell prints each command in the exact form in which it executes. For this reason, 
 you sometimes see the shell tracing mode referred to as the 
 execution tracing mode
 .
  
 The shell tracing or execution tracing mode is enabled by using the 
 -x
  option ( 
 x
  as in 
 execution
 ). For a 
 complete script, it is enabled as follows: 
  
 $ /bin/sh -x 
 scriptarg1arg2
  ... 
 argN
  
 As was mentioned before, it can also be enabled using the 
 set
  command:
  
 set -x
  
 To get an idea of what the output of shell tracing looks like, try the following command: 
  
 $ set -x ; ls *.sh ; set +x
  
 The output is similar to the following: 
  
 + ls buggy.sh buggy1.sh buggy2.sh buggy3.sh buggy4.sh 
 buggy.sh   buggy1.sh  buggy2.sh  buggy3.sh  buggy4.sh 
 + set +x 
  
 In the output, the lines preceded by the plus ( 
 +
 ) character are the commands that the shell executes. The 
 other lines are the output from those commands. As you can see from the output, the shell prints the exact 
 ls
  command it executes. This is extremely useful in debugging because it enables you to determine 
 whether all the substitutions were performed correctly.",NA
Finding Syntax Bugs Using Shell Tracing ,NA,NA
Finding Logical Bugs Using Shell Tracing ,"As mentioned before, there is at least one logical bug in this script. With the help of shell tracing, you can 
 locate and fix this bug. 
  
 Consider the prompt produced by this script: 
  
 Make backup (y/n)?",NA
Using Debugging Hooks ,"In the previous examples, you were able to deduce the location of a bug by using shell tracing for either the 
 entire script or for part of the script. In the case of enabling tracing for a part of a script, you had to edit the 
 script to insert the debug command: 
  
 set -x
  
  In larger scripts, a more common practice is to embed 
 debugging hooks 
 . Debugging hooks are 
 functions that enable shell tracing during functions or critical code sections. They are activated in one of two 
 ways: 
  
 G
 The script is run with a particular command line option (commonly 
 -d
  or 
 -x
 ).
  
 G
 The script is run with an environment variable set to true (commonly 
 DEBUG=true
  or 
 TRACE=true
 ).
  
 Here is a function that enables you to activate and deactivate debugging at will if the variable 
 DEBUG
  is set 
 to 
 true
 :
  
 Debug() { 
  
  
  if [ ""$DEBUG"" = ""true"" ] ; then 
  
  
  
  if [ ""$1"" = ""on""  -o ""$1"" = ""ON"" ] ; then 
  
  
  
  set -x 
  
  
  
  else 
  
  
  
  
  set +x 
  
  
  
  fi 
  
  
  fi 
  
 } 
  
 To activate debugging, use the following: 
  
 Debug on",NA
Summary,"In the process of developing or maintaining large shell scripts, you need to find and fix bugs that occur in 
 them. In this chapter you looked at the tools provided by the shell to ease the task of debugging shell 
 scripts. Some of the topics you covered are 
  
 G
 Enabling debugging 
  
 G
 Syntax checking using 
 sh -n 
 and 
 sh -nv 
  
 G
 Using shell tracing to find syntax and logic bugs 
  
 G
 Embedding debugging hooks in your shell scripts 
  
 By learning the techniques used in debugging shell scripts, you can fix your own scripts as well as maintain 
 scripts written by other programmers. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 20: Debugging 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Enabling Debugging
  
 Summary
  
 Syntax Checking
  
 Questions
  
 Shell Tracing
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What are the three main forms of enabling debugging in a shell script? 
  
 2. 
 Enhance the 
 Debug()
  function given in this chapter so that the programmer has to press Enter 
 after deactivating the debugging mode. 
  
 When you debug scripts that have several dozen functions, this feature enables you to study the 
 debugging output of a particular function in detail before the script proceeds to the next function. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 20: Debugging 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Enabling Debugging
  
 Summary
  
 Syntax Checking
  
 Questions
  
 Shell Tracing
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 21 ,NA,NA
Problem Solving with Functions ,"In previous chapters you looked at writing short shell scripts that perform a specific task. In each shell script, 
 you needed to perform a set of common tasks. Some examples of the required tasks are 
  
 G
 Displaying , 
 ERROR
 , 
 WARNING
 , and 
 USAGE
  messages 
  
 G
 Prompting the user for input 
  
 In some cases you needed to repeat these tasks, so you used shell functions. You were able to tailor the 
 output of these functions to suit your needs by using arguments. Many of your scripts reused functions 
 developed for other shell scripts. 
  
 In this chapter, I will present a library of shell functions that you can use in your shell scripts to perform some 
 common UNIX task. By using and improving on these implementations, you can avoid having to reinvent the 
 wheel when faced with a particular problem.",NA
Creating a Library of Functions ,"Creating the Library 
  
 Naming Conventions
  
 Including Functions from a Library
  
 In previous chapters, when you wrote shell scripts that required the use of a function, you added that 
 function to the shell scripts file. In that model, whenever you wanted to use a function in a script, you had to 
 copy it from a different file. 
  
 When you have two or three scripts, this is fine, but as the number of scripts you write increases, so do the 
 number of copies of the functions. Say you locate a bug in one of your functions. Imagine how hard it would 
 be to fix every copy of that function if the function is used in ten or more shell scripts. 
  
  o reduce the complexity involved in maintaining shell functions, it would be ideal to create a 
 central repository of functions that you could access from your shell script. In other programming languages, 
 a central repository of functions is called a 
 library
 .",NA
Creating the Library ,"Creating a library of shell functions is exactly like creating a shell script. The main difference between the 
 two is that a library contains only functions, whereas a script contains both functions and main code.",NA
Including Functions from a Library ,"To use a set of functions defined in a library, you need to be able to include or require these functions in 
 shell scripts. You can do this by using the 
 .
  command. Its syntax is as follows: 
  
 . 
 file
  
 Here 
 file
  is the name of a file that contains shell commands. If the shell functions given in the previous 
 example were stored in a file called 
 messages.sh
 , the command 
  
 . messages.sh
  
 can be used to include the functions 
 echo_error
  and 
 echo_warning
  into a shell script. As an example, 
 you can rewrite the script 
  
  1  #!/bin/sh 
  
  2  MSG=""hello"" 
  
  3  echo_error() { echo ""ERROR:"" $@ >&2 ; }  
 4  echo_error $MSG 
  
 to use 
 messages.sh
  as follows: 
  
  1  #!/bin/sh 
  
  2 . $HOME/lib/sh/messages.sh",NA
Naming Conventions ,"Unlike other languages, there are no widespread naming conventions for shell libraries or shell functions. 
 Many programmers feel that descriptive names are best for both functions and libraries, whereas others feel 
 that some structure such as that found in the C programming language should be used. In reality, both are 
 good ideas. 
  
 Library Naming 
  
 For the purposes of this chapter, I assume that the shell functions that are covered are stored in the file 
  
 $HOME/lib/sh/libTYSP.sh 
  
 This naming scheme provides double redundancy and can be explained as follows: 
  
 G
 The 
 lib
  in 
 libTYSP.sh
  indicates that this file is a library. This is similar to the convention used in 
  
 the C language. 
  
 G
 The 
 .sh
  in 
 libTYSP.sh
  indicates that this file contains Bourne shell code. 
  
 G
 The directory 
 $HOME/lib
  indicates that this file is a library because it resides in the 
 lib
  ( 
 lib
  as in 
  
 library
 ) directory. 
  
 G
 The directory 
 $HOME/lib/sh
  indicates that this file is a Bourne Shell library because it resides in 
  
 the 
 sh
  directory under the 
 lib
  directory. 
  
 To use this library in your scripts, you need to include it as follows: 
  
 . $HOME/lib/sh/libTYSP.sh 
  
 If you put the library in a different directory, say 
 /usr/local/lib/sh/libTYSP.sh
 , your scripts need to 
 access it as follows: 
  
 . /usr/local/lib/sh/libTYSP.sh 
  
 Function Naming",NA
Useful Functions ,"Displaying Messages 
  
 Obtaining the Process ID by Name
  
 Asking a Question 
  
 Getting a User's Numeric User ID
  
 Checking Disk Space 
  
 The Complete Library
  
 Now that I have covered the background knowledge needed to create and use a library of shell functions, 
 look at a shell library that provides you with the capability to perform common scripting tasks easily. A 
 complete listing of the library is available at the end of this chapter. 
  
 Some of the functions you will look at are 
  
 G
 printERROR 
  
 G
 printWARNING 
  
 G
 printUSAGE 
  
 G
 promptYESNO 
  
 G
 promptRESPONSE 
  
 G
 getSpaceFree 
  
 G
 getSpaceUsed 
  
 G
 getPID 
  
 G
 getUID
  
 In addition, you will be asked to develop four additional functions as part of the 
 ""Questions""
  section in this 
  
 chapter: 
  
 G
 toUpper 
  
 G
 toLower 
  
 G
 isSpaceAvailable 
  
 G
 isUserRoot
  
 By developing these functions, you can gain experience in working with a library of shell functions. 
  
 In the following sections, I will first present a brief description of each function or group of functions, followed 
 by the implementation of the functions. At the end of each section is a discussion of the function's 
 implementation along with caveats regarding its use. 
  
 Some of these functions need to be modified to work properly on all versions of UNIX. In this chapter, I will 
 note the differences. In 
 Chapter 23, ""Scripting for Portability,""
  I will show you how to modify these functions 
  
 to account for the differences between different versions of UNIX.",NA
Displaying Messages ,NA,NA
Asking a Question ,"In interactive shell scripts, you need to obtain input from the user. Sometimes this involves asking simple 
 yes
  or 
 no
  questions. In other instances, you need to ask the user a question that requires a more 
 complicated response. For example, many scripts need to retrieve the name of a file on which to operate. 
  
 In this section, I present two functions that help you to prompt the user and get a response: 
  
 G
 promptYESNO 
  
 G
 promptRESPONSE
  
 Asking a 
 Yes
  or 
 No
  Question 
  
 One of the most common types of questions asked by shell scripts is a 
 yes
  or 
 no
  question. For example, this 
 shell script 
  
 Make backup (y/n)?
  
 asks whether you want to make a backup. 
  
 The function, 
 promptYESNO
 , provides you with a reusable method of asking a 
 yes
  or 
 no
  question and 
 getting a response. The user's response, 
 y
  indicating 
 yes
  or 
 n
  indicating 
 no
 , is stored in the variable 
 YESNO 
 after the function completes. 
  
 ################################################ 
 # Name: promptYESNO 
  
 # Desc: ask a yes/no question 
  
 # Args: $1 -> The prompt 
  
 #       $2 -> The default answer (optional) 
  
 # Vars: YESNO -> set to the users response 
  
 #                y for yes, n for no 
  
 ################################################ 
  
 promptYESNO() { 
  
  if [ $# -lt 1 ] ; then",NA
Checking Disk Space ,"Shell scripts are commonly used to keep system administrators up to date about the amount of free space 
 available in certain directories. For example, you don't want the incoming mail directory to fill up. An auxiliary 
 task is to determine how much space a directory uses. For example, you don't want a single user to hog up 
 all the disk space for extended periods. 
  
 The information about disk usage is also important to installation scripts because they need to warn a user 
 when an installation is attempted in a directory that does not contain enough space. 
  
 In this section, I will present two functions that can help you determine disk space usage: 
  
 G
 getSpaceFree 
  
 G
 getSpaceUsed
  
 Determining Free Space 
  
 To determine the free space in a directory, you use the 
 df -k 
 ( 
 k
  as in 
 KB
 ) command. Its output looks like 
 the following: 
  
 $ df -k 
  
 Filesystem         1024-blocks  Used Available Capacity Mounted on 
 /dev/hda1            1190014  664661   463867     59%   / 
  
 /dev/hdd1            4128240 1578837  2335788     40%   /internal 
 /dev/hdb1            1521567  682186   760759     47%   /store 
 /dev/hda3             320086   72521   231034     24%   /tmp 
  
 When run on a single directory or file, the output looks like the following: 
  
 $ df -k /home/ranga 
  
 Filesystem         1024-blocks  Used Available Capacity Mounted on",NA
Obtaining the Process ID by Name ,"One of the difficulties with the 
 ps
  command is that it is hard to obtain the process ID of a command by 
 specifying only its name. In shell scripts that have to start and stop processes, the capability to look through 
 the output of 
 ps
  and retrieve a list of process IDs based on a command's name is essential. 
  
 In this section, I will present a function that displays a list of process IDs (pids) based on a string supplied by 
 the user. 
  
 ################################################ 
 # Name: getPID 
  
 # Desc: outputs a list of process id matching $1 
 # Args: $1 -> the command name to look for 
  
 ################################################ 
  
 getPID() { 
  
  if [ $# -lt 1 ] ; then 
  
  printERROR ""Insufficient Arguments.""  
 return 1 
  
  fi 
  
  PSOPTS=""-ef"" 
  
  
  /bin/ps $PSOPTS | grep ""$1"" | grep -v grep | awk '{ print $2; }' 
 } 
  
 As you can see, this function is a set of filters on top of the command 
 /bin/ps -ef
 . The first 
 grep 
 command looks for all lines that match the first argument. As an example, executing this on the command 
 line produces output similar to the following: 
  
 $ /bin/ps -ef | grep sshd
  
 Here you are looking for all the lines that contain the word 
 sshd
 . The output should look similar to the 
 following: 
  
 root  1449     1  8 12:23:06 ?         0:02 /opt/bin/sshd 
 ranga  1451   944  5 12:23:08 pts/t0    0:00 grep sshd 
  
 As you can see, the output contains two lines. The first one contains the process ID of the commands that 
 you are looking for, but the second contains the process ID of the 
 grep
  command that just executed. In 
 order to get rid of such lines, add the 
 grep -v grep 
 to the pipeline.",NA
Getting a User's Numeric User ID ,"Some shell scripts need to determine whether a user has sufficient permissions to execute commands. For 
 example, an install script might need to run as root (UID 0) to modify system files correctly. In other 
 instances, a script might need to detect whether a user has too many privileges. 
  
 To check the user's ID, you can use the 
 id
  command, which can be run in two forms. The first form 
 specifies a username whose ID should be returned. For example, the command 
  
 $ id vathsa 
  
 uid=501(vathsa) gid=100(users) groups=100(users) 
  
 returns the UID for the user 
 vathsa
 . The second form omits the user ID. In this form, the current user's 
 information is returned. 
  
 $ id 
  
 uid=500(ranga) gid=100(users) groups=100(users),101(ftpadmin) 
  
 Your function supports both. 
  
 ################################################ 
 # Name: getUID 
  
 # Desc: outputs a numeric user id 
  
 # Args: $1 -> a user name (optional) 
  
 ################################################",NA
The Complete Library ,"Listing 21.1 contains a complete listing of the shell library, 
 libTYSP.sh
 , discussed in this chapter. The line 
 numbers are present for your reference and should not be entered into a script library file that you plan to 
 use. 
  
 Listing 21.1--Complete Listing of the Shell Library 
 libTYSP.sh
  
 1     #!/bin/sh 
  
  2      
  
  3     ################################################  
 4     # Name: printERROR 
  
  5     # Desc: prints an message to STDERR 
  
  6     # Args: $@ -> message to print 
  
  7     ################################################  
 8",NA
Summary,"In this chapter, I presented a library of shell functions that can be used in your shell scripts to handle many 
 common tasks. By using and improving these implementations, you can avoid having to reinvent the wheel 
 when faced with a particular problem. 
  
 Some of the problems that I addressed are 
  
 G
 Displaying standardized error, warning, and usage messages 
 G
 Prompting for a 
 yes
  or 
 no
  response 
  
 G
 Prompting for a general response 
  
 G
 Checking disk space 
  
 G
 Getting the process ID of a command using its name 
  
 G
 Getting the numeric user ID of a user 
  
 In addition to these tasks, I have covered many other useful functions throughout this book. By using these 
 functions, you can concentrate on developing scripts to solve complicated problems without worrying about 
 the basics. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 21: Problem Solving with Functions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Creating a Library of Functions
  
 Questions
  
 Useful Functions
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Write a function called 
 toLower
  that converts its arguments to all lowercase and displays the 
 converted string to 
 STDOUT
 . You don't have to worry about checking the number of arguments. 
  
 (HINT: Use the 
 tr
  command.) 
  
 2. 
 Write a function called 
 toUpper
  that converts its arguments to all uppercase and displays the 
 converted string to 
 STDOUT
 . You don't have to worry about checking the number of arguments. 
  
 (HINT: Use the 
 tr
  command.) 
  
 3. 
 Write a function called 
 isSpaceAvailable
  to check whether a directory contains a certain 
 amount of disk space. 
  
 Your function should accept two arguments. The first one indicates the directory to check, and the 
 second one indicates the amount of space to check. An error should be reported if both arguments 
 are not given. Your function should validate that the first argument is a directory. 
  
 If sufficient space is present, your function should return 0; otherwise, it should return 1. This 
 enables us to use it as follows: 
  
 if isSpaceAvailable /usr/local 20000 ; then
  
  : # perform some action 
  
 fi 
  
 (HINT: Use the function 
 getSpaceFree
 .) 
  
 4. 
 Modify your 
 isSpaceAvailable
  function to accept an optional third argument that specifies the 
 units of the amount space to check. 
  
 The default should remain in kilobytes, but you should support 
 m
  or 
 mb
  indicating megabytes and 
 g 
 or 
 gb
  indicating gigabytes. If some other units are given, assume that the user meant kilobytes. 
 The following conversion factors apply to this problem: 1MB equals 1024KB, and 1GB equals to 
 1024MB. 
  
 (HINT: Use the 
 bc
  command.) 
  
 5. 
 Write a function called 
 isUserRoot
  that checks to see whether the ID of a user is equal to 0. If 
 no user is given, it should check to see whether the ID of the current user is root.",NA
Terms,"Library
 --A file that contains only functions is called a library. Usually libraries contain no main code. 
  
 Main Code 
 --Main code consists of all the commands in a shell script that are not contained within 
 functions. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 21: Problem Solving with Functions 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Creating a Library of Functions
  
 Questions
  
 Useful Functions
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 22 ,NA,NA
Problem Solving with Shell Scripts ,"In 
 Chapter 21, ""Problem Solving with Functions,""
  I showed you several useful functions that you can use in 
 your shell scripts. In this chapter, I will present two shell scripts that demonstrate how you can use shell 
 scripts to solve everyday problems. 
  
 These scripts illustrate using the tools I covered in previous chapters to create new tools that you can reuse. 
  
 For each script I will first describe the motivations for its development, followed by some design issues. 
  
 Then I will present the script in full. I will conclude the discussion of scripts by highlighting the script's flow 
 and error checking. 
  
 The two tasks that I will look at are 
  
  
 G
 Moving directories 
  
  
 G
 Maintaining an Address Book",NA
Moving Directories ,"Using tar 
  
 A Walkthrough of mvdir.sh
  
 mvdir.sh 
  
 Examples
  
  In 
 Chapter 4, ""Working with Directories,""
  I noted that the 
 mv
  command could not be used to move 
 directories across file systems. A 
 file system 
 can be thought of as a hard drive or hard drive partition. The 
 mv
  
 command works fine when you want to move a directory between different locations on the same file system 
 (hard drive), but it doesn't work well when you want to move a file across file systems. Depending on your 
 version of 
 mv
 , an error message could be generated when you try to do this. 
  
 For example, consider this directory: 
  
 $ ls -F /tmp/ch22 
  
 ch22-01.doc ch22.doc@ 
  
 If you use the 
 mv
  command to move this directory in the directory 
 /home/ranga
  on a different file system, 
 an error message similar to the following is generated: 
  
 mv: cannot move 'ch22' across filesystems: Not a regular file",NA
Using ,NA,NA
tar,"The workaround for these problems is to use the 
 tar
  ( 
 tar
  as in 
 tape archive 
 ) command to copy 
 directories. This command creates an archive or tar file that contains files and directories. A 
 tar file 
 is similar 
 to a zip file, except that its contents are not compressed. In addition, a tar file stores the file permission along 
 with group and owner information for the files it contains. Thus by using 
 tar
 , your copies 
  
 automatically end up with the correct file attributes.
  
 By using 
 tar
  you can move directories using the following procedure: 
  
 1. 
 Make a tar file of the source directory. 
  
 2. 
 Change to the destination directory. 
  
 3. 
 Extract the source directory in the destination directory. 
  
 4. 
 Remove the source directory. Notice that your procedure does not include deleting the tar file of 
 the source directory. Normally when you use the 
 tar
  command, a tar file is created on your hard 
 drive. If you use this behavior in your script, you need to worry about cleaning up the tar file 
 whenever an error occurs. This adds a large amount of complexity to your script. To avoid all that 
 unnecessary complexity, you can use a special feature of the 
 tar
  command to avoid creating a tar 
 file. 
  
 The 
 tar
  command can create archives and write them to 
 STDOUT
  instead of a file. It can also read archives 
 from 
 STDIN
  instead of from a file. By using a pipe character ( 
 |
 ), you can connect a 
 tar
  command that 
 creates a tar file with one that extracts a tar file, thus avoiding the creation of an intermediate tar file. 
  
 To create a tar file, use the following command:",NA
mvdir.sh,"The script 
 mvdir.sh
  is given in Listing 22.1 (the line numbers are provided for your reference). 
  
 Listing 22.1  Complete Listing of the 
 mvdir.sh
  Script
  
  1  #!/bin/sh 
  
  2  # Name: mvdir 
  
  3  # Desc: Move directories across file systems 
  
  4  # Args: $1 -> src dir 
  
  5  #       $2 -> dest dir 
  
  6   
  
  7  PATH=/bin:/usr/bin ; export PATH 
  
  8   
  
  9  # function to print errors and exit 
  
  10   
  
  11  printERROR() { echo ""ERROR: $@."" >&2 ; exit 1; } 
  
  12   
  
  13  # function to print usage message and exit 
  
  14   
  
  15  printUSAGE() { echo ""USAGE: ´/bin/basename $0´ $@."" >&2 ;  exit 1; }  
 16   
  
  17  # check whether sufficient args are given 
  
  18   
  
  19  if [ $# -lt 2 ] ; then printUSAGE ""[src] [dest]"" ; fi 
  
  20   
  
  21  # check whether the source directory exists 
  
  22   
  
  23  if [ ! -d ""$1"" ] ; then",NA
A Walkthrough of ,NA,NA
mvdir.sh,"I'll walk through the script and highlight some of the important points. 
  
 The first thing this script does is set the 
 PATH
  variable (line 7). You do this to ensure that all the commands 
 you use come from one of the two directories that you specified. When you write a script that can be run by 
 many users, you have to take into account that some users might have modified their 
 PATH
  such that the 
 commands you are using are inaccessible or replaced by other versions. By setting the 
 PATH
  variable 
 explicitly, you avoid this problem. 
  
 Next the script defines a few utility functions (lines 11 and 15) used to print error usage messages. You can",NA
Examples,"Now look at two examples of using this script to move a directory between file systems. 
  
 In the first example, you want to move a source directory into a destination directory on a different file 
 system: 
  
 $ ls /tmp 
  
 ch22           ps_data        sdtdbcache_:0 $ 
 ./mvdir.sh /tmp/ch22 /home/ranga/docs/book $ 
 ls /tmp /home/ranga/docs/book 
  
 /tmp: 
  
 ps_data        sdtdbcache_:0 
  
 /home/ranga/docs/book 
  
 ch20     ch21     ch22     ch23 
  
 As you can see, the directory 
 ch22
  was moved from 
 /tmp
  to the directory 
 /home/ranga/docs/book
 .
  
 In the second example, you move the same directory, but you also rename it: 
  
 $ ls /home/ranga/docs/book 
  
 ch20     ch21     ch22     ch23 
  
 $ ./mvdir /home/ranga/docs/book/ch22 /tmp/ch22-work 
 $ ls /home/ranga/docs/book /tmp 
  
 /home/ranga/docs/book: 
  
 ch20     ch21     ch23 
  
 /tmp: 
  
 ch22-work     ps_data     sdtdbcache_:0 
  
 Here the directory was moved and renamed.
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Contents
  
 Inde
 x",NA
Maintaining an Address Book ,"Showing People 
  
 Deleting a Person
  
 Adding a Person
  
 I often get business cards or email messages from people I need to keep in touch with. Sometimes I lose 
 these email messages or business cards, leading to problems when I need to contact someone important. 
  
 A nice solution to this problem would be to store all the contact information on my computer so that I could 
 access and manipulate it easily. In this section, I will look at developing a set of scripts that work together to 
 maintain a simple address book. 
  
 The address book will store the following information: 
  
 G
 Name 
  
 G
 Email address 
  
 G
 Postal address 
  
 G
 Phone number 
  
 Each of these pieces of information can contain almost any character including spaces or other special 
 characters such as the dash ( 
 -
 ), period, ( 
 .
 ), or single quote ( 
 '
 ). Thus you need to hold the information in 
 a format that allows for these characters. A commonly used format is to separate each piece of information 
 using the colon ( 
 :
 ) character. For example, the following information: 
  
 Sriranga Veeraraghavan 
  
 ranga@soda.berkeley.edu 
  
 1136 Wunderlich Dr. San Jose CA 95129 
  
 408-444-4444 
  
 can be stored as: 
  
 Sriranga Veeraraghavan:ranga@soda.berkeley.edu:1136 Wunderlich Dr. San Jose CA 
 95129:408-444-4444 
  
 Here any special character, except the colon, can be used. Also this format enables you to make any field 
 optional. For example, 
  
 :vathsa@kanchi.bosland.us::408-444-4444
  
 could indicate that only the email address and phone number were known for a particular person.",NA
Showing People ,"One of the main tasks any address book must perform is looking up a person. You will develop a script 
 called 
 showperson
  to accomplish this. 
  
 To find information about a person, you can use 
 grep
  command. For example, 
  
 $ grep vathsa addressbook
  
 lists all the lines that contain the word 
 vathsa
  in the file 
 addressbook
 . For your address book, the output 
 might look like the following: 
  
 :vathsa@kanchi.bosland.us::408-444-4444
  
 As you imagine, your 
 showperson
  script should format the results of the 
 grep
  command. A nice format 
 would be to list the name, email address, postal address, and phone number on separate lines. You can do 
 this using an 
 awk
  command:
  
 awk -F: '{ printf ""Name: %s\nEmail: %s\nAddress: %s\nPhone: 
 %s\n\n"",$1,$2,$3,$4 ; }'
  
 By putting these commands together, you construct the 
 showperson
  script given in Listing 22.2 (the line 
 numbers are provided for your reference). 
  
 Listing 22.2  Listing of the 
 showperson
  Script
  
  1  #!/bin/sh 
  
  2  # Name: showperson 
  
  3  # Desc: show matching records in addressbook  4  
 # Args: $1 -> string to look for in addressbook  5   
  
  6  PATH=/bin:/usr/bin 
  
  7   
  
  8  # check that a string is given 
  
  9   
  
  10  if [ $# -lt 1 ] ; then 
  
  11      echo ""USAGE: ´basename $0´ name"" 
  
  12      exit 1 
  
  13  fi 
  
  14   
  
  15  # check that the address book exists",NA
Adding a Person ,"One of the most important things about any address book is the capability to add information to it easily. If 
 you need to edit the address book manually to add information, you're bound to make errors such as 
 forgetting to add a colon to separate fields. By using a script, you can avoid such errors. 
  
 In this section I will look at a script, 
 addperson
 , that enables you to add entries into the address book in 
 two ways: 
  
 G
 Interactively 
  
 G
 Using command line options 
  
 The script enters interactive mode when no options are given. If the noninteractive mode is being used, it 
 tries to obtain information from the command line options. 
  
 In both modes you put the user-provided information into the following variables:
  
 G
 NAME
 , stores the name given by the user 
  
 G
 EMAIL
 , stores the email address given by the user 
 G
 ADDR
 , stores the postal address given by the user 
 G
 PHONE
 , stores the phone number given by the user 
  
 In interactive mode, you can prompt for the information in each record as follows: 
  
 printf ""%-10s "" ""Name:""    ; read NAME 
 printf ""%-10s "" ""Email:""   ; read EMAIL 
 printf ""%-10s "" ""Address:"" ; read ADDR 
 printf ""%-10s "" ""Phone:""   ; read PHONE 
  
 After each prompt, you read and store the user's input, including spaces and special characters inside the 
 appropriate variable. 
  
 In noninteractive mode, you can use 
 getopts
  to scan the options: 
  
 while getopts n:e:a:p: OPTION 
  
 do 
  
  
  case $OPTION in",NA
Deleting a Person ,"Occasionally, you need to delete a person from the address book. In this section, I will look at a script called 
 delperson
  that deletes people from the address book. 
  
 Deleting a person from the address book is a harder task because you have to make sure that those people 
 you really want to delete are deleted. The two main tasks you need to perform are 
  
 1. 
 Make a list of the lines in the address book that match the specified name.",NA
Summary,"In this chapter I covered using shell scripts to solve two problems: 
  
  
 G
 Moving directories 
  
  
 G
 Maintaining an address book 
  
 In the first example, I showed you how to move a directory between file systems using the 
 tar
  command. 
  
 This example also showed you how to use the 
 basename
  and 
 dirname
  commands to extract parts of a 
 path for your use. 
  
 In the second example, you developed three scripts that you used to modify and view the contents of an 
 address book. Some of the highlights of these scripts are: 
  
  
 G
 The 
 showperson
  script showed you how the 
 grep
  and 
 awk
  commands can be used to format 
  
  
 input. 
  
 G
 The 
 addperson
  script showed you how a single script can be used in both interactive and 
  
 noninteractive modes. 
  
 G
 The 
 delperson
  script showed you how to use the 
 grep
  command and file descriptors to update a 
  
 file accurately. 
  
 The examples in this chapter demonstrate how you can apply the tools that you have covered in previous 
 chapters to solve real problems. Using these scripts as examples, you can see some of the techniques used 
 to solve everyday problems. 
  
 In the next chapter I will show you how to make sure the scripts you write are portable between different 
 versions of UNIX. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 22: Problem Solving with Shell Scripts 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Moving Directories
  
 Questions
  
 Maintaining an Address Book
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 How might you simplify the following portion of the 
 mvdir
  script? Specifically, how could you rewrite 
 the main 
 if
  statement, such that the 
 else
  clause was unnecessary? 
  
  40  if [ -d ""$2"" ] ; then
  
  41  
  
  42      DESTDIR=´( cd ""$2"" ; pwd ; )´
  
  43  
  
  44  else
  
  45  
  
  46      # if the destination doesn't exist then 47      
 # assume the destination is the new name 48      # 
 for the directory
  
  49      DESTDIR=""´/usr/bin/dirname $2´""
  
  50      NEWNAME=""´/bin/basename $2´""
  
  51  
  
  52      # if dirname returns a relative dir we will 
 53      # be confused after cd'ing later on. So 54      
 # reset it to the full path.
  
  55      DESTDIR=´(cd $DESTDIR ; pwd ; )´
  
  56  
  
  57      # if the parent of the destination doesn't 
 58      # exist, we're in trouble. Tell the user 59      
 # and exit.
  
  
  60      if [ ! -d ""$DESTDIR"" ] ; then
  
  
  61          printERROR ""A parent of the destination directory $2 does not 
 exist""
  
  
  62      fi
  
  
  63  
  
  
  64  fi
  
  
  65  
  
 2. 
 The 
 showperson
  script lists all matching entries in the address book based on a name provided by 
 the user. The matches produced are case sensitive. How can you change the matches so they aren't 
 case sensitive? 
  
 3. 
 Both the 
 showperson
  and 
 delperson
  scripts reproduce exactly the following pieces of code 
  
 PATH=/bin:/usr/bin 
  
 # check that a name is given 
  
 if [ $# -lt 1 ] ; then
  
  
  printUSAGE ""´basename $0´ name""
  
  
  exit 1 
  
 fi 
  
 # check that the address book exists",NA
Terms,"File System 
   A file system is used by UNIX to store files and directories. Usually a file system corresponds 
 to a hard drive or hard drive partition. 
  
 Tar File 
   A tape archive file created by the 
 tar
  command. A tar file can contain both files and directories, 
 making it similar to a zip file. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 22: Problem Solving with Shell Scripts 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Moving Directories
  
 Questions
  
 Maintaining an Address Book
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 23 ,NA,NA
Scripting for Portability ,"Shell programming is an important part of UNIX because shell scripts are portable between different 
 versions of UNIX. In many cases, no changes are required for a shell script to function correctly on multiple 
 systems. 
  
 The easiest way to ensure that your shell scripts are completely portable is to restrict yourself to using only 
 those commands and features that are available on all versions of UNIX. Sometimes, you have to 
 implement workarounds to deal with the limitations of a particular version of UNIX. 
  
 In this chapter, you will first learn how to determine which version of UNIX is running. Then you will learn 
 how to adapt your shell scripts to different versions of UNIX by examining some of the problems 
 encountered when porting scripts between the versions.",NA
Determining UNIX Versions ,"BSD Versus System V 
  
 Determining the UNIX Version Using a Function
  
 Using uname
  
 Before you can begin adjusting shell scripts to be portable, you need to know what the different types of 
 UNIX are and how to tell them apart. 
  
 The two major types of UNIX are 
  
 G
 BSD (Berkeley Software Distribution) 
  
 G
 System V 
  
 The locations of commands and the options supported by certain commands are different between these 
 two types of UNIX. This chapter highlights the major differences and commands in particular.",NA
BSD Versus System V ,"BSD UNIX was developed by the Computer Systems Research Group at the University of California at 
 Berkeley. In the early 1980s, the University of California acquired the source code to UNIX from AT&T Bell 
 Labs and significantly modified it to produce BSD UNIX. 
  
 Although the University of California has stopped distributing BSD UNIX, current versions of it are available 
 from many sources. The most common versions of BSD are OpenBSD, NetBSD, and FreeBSD. Some older 
 machines from Sun Microsystems run a modified version of BSD called SunOS.",NA
Using ,NA,NA
uname,"The first step in writing portable shell scripts is to determine which version of UNIX is executing your shell 
 script. You can determine this using the 
 uname
  command:
  
 uname 
 options",NA
Determining the UNIX Version Using a Function ,NA,NA
Techniques for Increasing Portability ,"Conditional Execution
  
 Abstraction
  
 Shell scripts that run on multiple versions of UNIX often include code that is version-specific. For example, 
 you might need to use a different command on Linux than Solaris to obtain some system information. There 
 are two common techniques to increase the portability of a shell script between different versions of UNIX: 
  
  
 G
 Conditional execution 
  
  
 G
 Abstraction 
  
 Conditional execution alters the execution of a script based on the system type, whereas abstraction retains 
 the same basic flow of the script by placing the conditional statements within functions.",NA
Conditional Execution ,"A script that uses conditional execution for portability contains an 
 if
  statement at the beginning. The 
 if 
 statement sets several variables indicating the set of commands to use on a particular platform. 
  
 In this section, you look at two common cases of conditional execution: 
  
  
 G
 Determining the remote shell command 
  
  
 G
 Determining the proper method of using the 
 echo
  command in prompts 
  
 The first case illustrates setting a variable based on the operating system type. The second case illustrates 
 setting variables based on the behavior of a command ( 
 echo
 ) on a particular system. 
  
 Executing Remote Commands 
  
 A common use of conditional execution is in scripts that need to execute commands on remote systems. On 
 most versions of UNIX, you can use the 
 rsh
  (remote shell) command to execute commands on a remote 
 system. Unfortunately, you cannot use this command on all versions of UNIX. 
  
 On HP-UX, 
 rsh
  is available, but it is not the remote shell program--it is the restricted shell program. On HP-
 UX, you need to use the command 
 remsh
  to execute commands on a remote system.",NA
Abstraction,NA,NA
Summary,"In this chapter, you learned how to determine which version of UNIX you are running by using the 
 uname 
 command. In addition, you developed the 
 getOSName
  and 
 isOS
  functions to help you adapt your shell 
 scripts to multiple versions of UNIX. 
  
 You also looked at the following techniques for improving the portability of shell scripts: 
  
  
 G
 Conditional execution 
  
  
 G
 Abstraction 
  
 In conditional execution, you modify the flow of your script depending on the version of UNIX being used. In 
 abstraction, you change the implementation of your functions to account for the differences between the 
 versions of UNIX. Here, the flow of your script remains the same. 
  
 Using the techniques and tips in this chapter, you can port your shell script across different versions of 
 UNIX. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 23: Scripting for Portability 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Determining UNIX Versions
  
 Questions
  
 Techniques for Increasing Portability
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 Write a function called 
 getCharCount
  that prints the number of characters in a file. Use 
 wc
  to 
 obtain the character count. 
  
 On Linux, FreeBSD, and SunOS (not Solaris), use the 
 -c
  option for 
 wc
 ,. On other versions of UNIX, 
 use the 
 -m
  option instead. You can use the function 
 getOSName
  to get the name of the operating 
 system. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 23: Scripting for Portability 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Determining UNIX Versions
  
 Questions
  
 Techniques for Increasing Portability
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Terms,"Conditional Execution 
   Conditional execution alters the execution of a script based on the system type. A 
 script that uses conditional execution usually contains an 
 if
  statement at the beginning that sets variables 
 to indicate the commands to use on a particular platform. 
  
 Abstraction
   Scripts that use abstraction retain the same basic flow by placing the conditional execution 
 statements within functions. When a function is called, it makes a decision as to what commands execute 
 for a given platform. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 23: Scripting for Portability 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Determining UNIX Versions
  
 Questions
  
 Techniques for Increasing Portability
  
 Terms
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Hour 24 ,NA,NA
Shell Programming FAQs ,"Each of the previous chapters has focused on an individual topic in shell programming, such as variables, 
 loops, or debugging. As you progressed through the book, you worked on problems that required knowledge 
 from previous chapters. In this chapter, I'm taking a slightly different approach. I will try to answer some 
 common shell programming questions that frequently arise. Specifically I will cover questions from three 
 main areas of shell programming: 
  
 G
 The shell and commands 
  
 G
 Variables and arguments 
  
 G
 Files and directories 
  
 Each section includes several common questions (along with answers) that occur in shell programming. 
 These questions are designed to help you solve or avoid problems while programming using the shell. 
  
 Some of the questions provide deeper background information about UNIX, whereas others illustrate 
 concepts covered in previous chapters.",NA
Shell and Command Questions ,"In this section I will cover some of the common questions that arise in regard to the shell itself. Also included 
 are a few questions regarding the execution of commands. 
  
 Why does 
 #!/bin/sh
  have to be the first line of my scripts? 
  
 In 
 Chapter 2, ""Script Basics,""
  I stated that 
 #!/bin/sh
  must be the first line in your script to ensure that the 
 correct shell is used to execute your script. This line must be the first line in your shell script because of the 
 underlying mechanism used by a shell to execute commands. 
  
  When you ask a shell to execute the command 
 $ date
 ,the shell uses the system call 
 exec
  to 
 ask the UNIX kernel to execute the command you requested. For those readers who are not familiar with the 
 term 
 system call
 , a system call is a C language function built in to the UNIX kernel that enables you to 
 access features of the kernel.
  
 The shell passes the name of the command that should be executed to the 
 exec
  system call. This system 
 call reads the first two characters in a file to determine how to execute the command. In the case of shell 
 scripts, the first two characters are 
 #!
 , indicating that the script needs to be interpreted by another program",NA
Variable and Argument Questions ,"In this section I will examine some questions related to variables and their use in shell scripts. I will also 
  
 cover some questions related to command line arguments. 
  
 How can I include functions and variable definitions from one file into another file? 
  
 To include functions and variable definitions defined in one file into another file you need to use the 
 .
  
 command as follows: 
  
 . 
 file 
  
 Here 
 file
  is the name of the file you want to include. I covered this topic in 
 Chapter 22, ""Problem Solving 
  
 with Shell Scripts."" 
  
 Is it possible to consider each argument to a shell script one at a time? 
  
 You can do this using a 
 for
  loop: 
  
 for arg in ""$@"" 
  
 do 
  
 list 
  
 done 
  
 Here the variable 
 arg
  will be set to each argument in turn. The specified list of commands, 
 list
 , will be 
  
 executed for each argument. 
  
 You use 
 $@
  in this example for the arguments instead of 
 $*
 , because 
 $@
  preserves the quoting used when 
  
 the command was issued. The difference between 
 $@
  and 
 $*
  was discussed in 
 Chapter 12, ""Parameters."" 
  
 How can I forward all the arguments given to my script to another command? 
  
 A common task for shell programmers is writing a wrapper script for command. A wrapper script might need 
  
 to define a set of variables or change the environment in some way before a particular command starts 
  
 executing. 
  
 When writing wrapper scripts, you will need to forward all the arguments given to your script to a command. 
  
 Usually the following is sufficient: 
  
 command
  ""$@""",NA
File and Directory Questions ,"In this section, I will look at some questions about files and directories. These questions include issues with 
 specific commands and examples that illustrate the usage of commands to solve particular problems. 
  
 How do I determine the full pathname of a directory? 
  
 Shell scripts that work with directories often need to determine the full pathname of a directory to perform 
 the correct operations on these directories. 
  
 You can determine the full pathname of a directory by using the 
 cd
  and 
 pwd
  commands: 
  
 FULLPATH=´(cd 
 dir
  ; pwd)´
  
 Here 
 dir
  is the name of a directory. This command changes directories to the specified directory, 
 dir
 , and 
 then displays the full pathname of the directory using the 
 pwd
  command. Because command substitution is 
 used, the full pathname is assigned to the variable 
 FULLPATH
 .
  
 Because the 
 cd
  command changes the working directory of the current shell, you execute it in a subshell. 
 Thus the working directory of the shell script is unchanged. 
  
 How do I determine the full pathname of a file? 
  
 Determining the full pathname of a file is slightly harder than determining the full pathname of a directory. 
 You need to use the 
 dirname
  and 
 basename
  commands in conjunction with the 
 cd
  and 
 pwd
  commands to 
 determine the full pathname of a file: 
  
 CURDIR=´pwd´ 
  
 cd ´dirname file´ 
  
 FULLPATH=""´pwd´/´basename file´"" 
  
 cd $CURDIR 
  
 Here 
 file
  is the name of a file whose full pathname you want to determine. First you save the current path 
 of the current directory in the variable 
 CURDIR
 . Next you change to the directory containing the specified file, 
 file
 .
  
 Then you join the output of the 
 pwd
  command and the name of the 
 file
  determined using the 
 basename 
 command to get the full pathname. This value gets stored in the variable 
 FULLPATH
 . Finally you change 
 back to the original directory. 
  
 How can locate a particular file?",NA
Summary,"In this chapter I have looked at some common questions encountered in shell programming. These 
 questions and their answers will help you write bigger and better scripts. 
  
 Now that you have finished all 24 chapters, you have learned about using both the basics of the shell and its 
 advanced features. As you continue to program, use this book as a reference to help you remember the 
 intricacies of shell programming. 
  
 I hope that you learned not only to program efficiently using the shell but also to enjoy shell programming. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Hour 24: Shell Programming FAQs 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Shell and Command Questions
  
 File and Directory Questions
  
 Variable and Argument Questions
  
 Summary
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Appendix A ,NA,NA
Command Quick Reference ,"by Frank Watson 
  
 This appendix summarizes and reviews the script elements you have covered: 
  
 G
 Reserved words and built-in shell commands 
  
 G
 Conditional expressions 
  
 G
 Arithmetic expressions (available Korn/Bash only) 
  
 G
 Parameters and variables 
  
 G
 Parameter substitution 
  
 G
 Pattern matching 
  
 G
 I/O 
  
 G
 Miscellaneous command summaries 
  
 G
 Regular expression wildcards 
  
 You can also find details not discussed earlier that are included here for completeness.",NA
Reserved Words and Built-in Shell Commands ,". (period) 
 executes the following command in the current shell instead of as a child process. 
  
 : (colon) 
 no-op command. Its arguments are processed for variable substitution. 
  
 !!
  (Bash) re-executes the previous command. 
  
 alias
  (only Korn/Bash) creates a short name for the command. 
  
 bg
  (Korn/Bash) starts a suspended job running in background. 
  
 break
  exits from current 
 for
 , 
 while
 , or 
 until
  loop. 
  
 case
  executes commands given for first pattern that match 
 expr
 . Patterns can contain filename expansion 
 wildcards. 
  
 case 
 expr
  in",NA
Conditional Expressions ,"File Tests 
  
 Integer Comparisons
  
 String Tests
  
 These can be used with
  
 if [ 
 test-expression
  ] 
  
 while [ 
 test-expression
  ] 
  
 until [ 
 test-expression
  ]",NA
File Tests ,"-a 
 file 
  
 true if the file exists (Korn/Bash) 
  
 -b 
 file 
  
 true if the file is a block special device 
  
 -c 
 file 
  
 true if the file is a character special device 
  
 -d 
 file 
  
 true if the file is a directory 
  
 -f 
 file 
  
 true if the file is a regular file 
  
 -g 
 file 
  
 true if the file has the SGID permission bit set 
  
 -G 
 file 
  
 true if the file's group matches the user's group 
  
 -k 
 file 
  
 true if the file has the sticky bit set 
  
 -L 
 file 
  
 true if the file is a symbolic link 
  
 -O 
 file 
  
 true if the user running this command owns this file (Korn/Bash) 
  
 -p 
 file 
  
 true if the file is a named pipe or fifo 
  
 -r 
 file 
  
 true if the file is readable 
  
 -s 
 file 
  
 true if the file has a size greater than zero 
  
 -S 
 file 
  
 true if the file is a socket 
  
 -t 
 filedes 
  
 true if file descriptor is associated with a terminal device",NA
String Tests ,"-z 
 string 
  
 true if the string is empty 
  
 -n 
 string 
  
 true if the string has nonzero size 
  
 s1 = 
 s2 
  
 true if string 
 s1
  equals 
 s2
  
 s1
  != 
 s2 
  
 true if the strings are not equal 
  
 s1 
  
 true if string 
 s1
  is not empty 
  
 s1
  < 
 s2 
  
 true if 
 s1
  comes before 
 s2
  in ASCII order (Korn [[ ]]) 
  
 s1
  > 
 s2 
  
 true if 
 s1
  comes after 
 s2
  in ASCII order (Korn [[ ]])",NA
Integer Comparisons ,"Comparisons stop on first non-digit. 
  
 n1
  -eq 
 n2
  
 true if 
 n1
  is equal in value to 
 n2
 . 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 n1
  -ne 
 n2
  
 true if 
 n1
  is not equal to 
 n2
  
 n1
  -gt 
 n2
  
 true if 
 n1
  is greater than 
 n2
  
 n1
  -ge 
 n2
  
 true if 
 n1
  is greater than or equal to 
 n2
  
 n1
  -lt 
 n2
  
 true if 
 n1
  is less than 
 n2
  
 n1
  -le 
 n2
  
 true if 
 n1
  is less than or equal to 
 n2
  
 ! expr 
  
 true if 
 expr
  is false (logical NOT) 
  
 -a
  
 logical AND (Bourne) 
  
 &&
  
 logical AND (Bash/Korn [[ ]]) 
  
 -o
  
 logical OR (Bourne) 
  
 ||
  
 logical OR (Bash/Korn [[ ]]) 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Appendix A: Command Quick Reference
  
 Next Chapter",NA
Arithmetic Expressions (Korn/Bash Only) ,"Operators Allowed in Korn/Bash Integer Expressions
  
 Follow the general format for variable assignment: 
  
 let ""
 VARIABLE
 =
 integer_expresson
 ""
  
 To embed integer calculations within a command 
  
 $((
 integer_expression
 ))",NA
Operators Allowed in Korn/Bash Integer Expressions ,"G
 Logical operators return 1 for true and 0 for false 
  
 G
 This list is from highest to lowest operator precedence 
  
 -
  
 unary minus (negates the following value) 
  
 ! ~ 
  
 logical NOT, binary one's complement 
  
 * / % 
  
 multiply, divide, modulus (remainder operation) 
  
 + -
  
 add, subtract 
  
 >> << 
  
 right, left shift, for example: 
  
 $((32 >> 2)) 
  
 gives 8 (right shift 32 by 2 bits is the same as division by 4)
  
 <= >= 
  
 less than or equal to, greater than or equal to 
  
 > < 
  
 greater than, less than 
  
 == != 
  
 equal to, not equal to 
  
 & 
  
 bitwise AND operation, for example:
  
 $((5 & 3)) 
  
 converts 5 to binary 101 and 3 to binary 011 and ANDs the bits to 
  
 give 1 as the result",NA
Parameters and Variables ,"User-Defined Variables 
  
 Two Types of Variables
  
 Built-in Shell Variables 
  
 Shell Variables
  
 Built-in Commands that Directly Affect Variables",NA
User-Defined Variables ,"USERVAR
 =
 value 
 $
 USERVAR 
  
 ${
 USERVAR
 }
  
 sets the contents of 
 USERVAR
  to 
 value 
  
 substitutes the contents of 
 USERVAR 
  
 also substitutes the contents of USERVAR. The braces are optional 
 if there is no ambiguity. 
  
 User-defined variable names
  
 G
 Must start with letter or _ 
  
 G
 Can contain only letters, digits, or _ 
  
 G
 Are often in capital letters to differentiate from UNIX commands 
  
 Korn/Bash 2.x Support Arrays 
  
 USERVAR
 [
 index
 ]=
 value 
 ${
 USERVAR
 [
 index
 ]} 
  
 ${
 USERVAR
 [*]} 
  
 ${
 USERVAR
 [@]}
  
 sets a value for array element denoted by 
 index 
 substitutes a value into the command line 
  
 substitutes all array elements 
  
 substitutes all array elements as if individually double 
 quoted 
  
 Note 
 index
  must be an integer. 
  
 Korn array initialization 
  
  set -A 
 USERVAR value1 value2 value3
  ...",NA
Built-in Shell Variables ,"$0 
  
 $
 n
  
 $# 
  
 $* 
  
 $@ 
  
 $?
  
 $$ 
  
 $!
  
 name of the command or script being executed 
  
 positional parameters, that is, arguments given on the command line 
 numbered 1 through 9 
  
 number of positional parameters given on command line 
  
 a list of all the command line arguments 
  
 a list of all command line arguments individually double quoted 
  
 The numeric exit status (that is, return code) of last command executed 
 PID (process ID) number of current shell 
  
 PID (process ID) number of last background command",NA
Built-in Commands that Directly Affect Variables ,"getopts
 , 
 export
 , 
 read
 , 
 readonly
 , 
 unset",NA
Two Types of Variables ,"G
 Environment variables are passed to any child processes. 
 G
 Local variables are not passed to any child processes.",NA
Shell Variables ,"CDPATH
  contains colon-separated list of directories to facilitate 
 cd
  command 
  
 HOME
  Your home directory 
  
 IFS
  Internal field separator characters 
  
 OPTARG
  The last 
 cmd
  line 
 arg
  processed by 
 getopts
  (Korn/Bash) 
  
 OPTIND
  The index of the last 
 cmd
  line 
 arg
  processed by 
 getopts
  (Korn/Bash) 
  
 PATH
  Contains a colon-separated list of directories to search for commands that are given without any slash 
 PS1
  The primary shell prompt string",NA
Parameter Substitution ,"Parameter Substitution in Bourne/Korn/Bash
  
 Parameter Substitution Only in Korn/Bash",NA
Parameter Substitution in Bourne/Korn/Bash ,"${
 parameter
 }
  substitutes the contents of the 
 parameter
 , which can be a variable name or digit 
 indicating a positional parameter. 
  
 ${
 parameter
 :-
 word
 }
  substitutes the contents of the 
 parameter
  but if it is empty or undefined, it 
 substitutes the 
 word
 , which might contain unquoted spaces. 
  
 ${
 parameter
 :=
 word
 }
  substitutes the contents of the 
 parameter
  but if it is empty or undefined, it sets 
 parameter
  equal to the 
 word
  and substitutes 
 word.
  
 ${
 parameter
 :?
 message
 }
  substitutes the contents of the 
 parameter
 , but if it is empty or undefined, 
 aborts the script and gives the 
 message
  as a final error. Message might contain unquoted spaces. 
  
 ${
 parameter:+word
 }
  if 
 parameter
  is not empty, it substitutes the 
 word
 ; otherwise it substitutes nothing.",NA
Parameter Substitution Only in Korn/Bash ,"${#
 parameter
 }
  substitutes the number of characters in the contents of 
 parameter.
  
 ${#
 array
 [*]}
  substitutes the number of elements in 
 array.
  
 ${
 parameter#pattern
 }
  if the regular expression pattern given is found at start of the contents of 
 parameter
 , it deletes the matching characters and substitutes the remainder. The smallest possible match 
 is deleted. 
  
 ${
 parameter##pattern
 }
  same as above but deletes the largest possible match at the start of 
 parameter.
  
 ${
 parameter%pattern
 }
  same as above but deletes the smallest match at the end of 
 parameter.
  
 ${
 parameter%%pattern
 }
  same as above but deletes the largest match at the end of 
 parameter.",NA
Pattern Matching ,"Pattern Wildcards Available in Bourne/Korn/Bash
  
 Pattern Wildcards Available Only in Korn
  
 Rules for filename expansion: 
  
 G
 Any word on the command line containing a wildcard is expanded to a list of files which match the 
  
 pattern word. 
  
 G
 If no filename matches are found, the pattern word is not substituted. 
 G
 Wildcards cannot match a leading period or a slash.",NA
Pattern Wildcards Available in Bourne/Korn/Bash ,"* 
 matches 0 or more of any character 
  
 ? 
 matches exactly 1 of any character 
  
 [
 list
 ] 
 matches exactly 1 of any character in list 
  
 [!
 list
 ] 
 matches exactly 1 of any character not in list",NA
Pattern Wildcards Available Only in Korn ,"?(
 pattern1|pattern2
 ...)
  matches any of the patterns 
  
 *(
 pattern1|pattern2
 ...)
  matches zero or more occurrences of the patterns 
  
 +(
 pattern1|pattern2
 ...)
  matches one or more occurrences of the patterns 
  
 @(
 pattern1|pattern2
 ...)
  matches only one of the patterns 
  
 !(
 pattern1|pattern2
 ...)
  matches anything except one of the patterns 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Appendix A: Command Quick Reference
  
 Next Chapter",NA
I/O ,"Table A.1  Summary of Standard UNIX I/O 
  
   
  
 Abbreviation
  I/O description 
 File Descriptor 
  
  
  
  
   
  
 STDIN
  
  
  
 Standard input 
  
  
  
 0
  
  
  
 STDOUT
  
  
  
  
 Standard output 1
  
  
  
  
 STDERR
  
  
  
 Standard error 
  
  
  
 2
  
  
  
  
 cmd > file 
 cmd 1> file 
 cmd >> file 
  
 save STDOUT from UNIX command in 
 file 
 same as above 
  
 append STDOUT from UNIX command to 
 file
  
 cmd 1>> file 
 same as above 
  
 cmd 2> file 
  
 save STDERR from UNIX command in 
 file
  
 cmd 2>> file 
 append STDERR from UNIX command in 
 file
  
 cmd < file 
  
 provide STDIN to UNIX command from 
 file
  instead of keyboard 
  
 cmd 0< file 
  
 same as above",NA
here,NA,NA
 Document ,"Provides STDIN to UNIX command from lines that follow until delimiter is found at start of line: 
  
 cmd
  << 
 delimiter
  
 one or more text lines 
  
 delimiter
  
 cmd1 | cmd2 
  
 pipe STDOUT of 
 cmd1
  as STDIN to 
 cmd2",NA
Miscellaneous Command Summaries ,"Here is some helpful information about several commands often used in shell programming. 
  
 echo
 --display arguments to standard output 
  
 \b 
  
 Backspace
  
 \c 
  
 Suppress trailing newline 
  
 \f 
  
 Formfeed
  
 \n 
  
 Newline
  
 \r 
  
 Carriage return 
  
 \t 
  
 Tab
  
 \\ 
  
 Backslash
  
 \0nn 
  
 Character whose ASCII value is octal nn 
  
 grep
 --display lines that contain the given pattern 
  
 -i ignore upper versus lower case 
  
 -l list only filenames that contain a match, not the matching lines 
  
 -n include the file line number with each matching line displayed 
  
 -v reverse the test, which means ignore lines that contain the pattern 
  
 printf
 --display formatted text output, for example: 
  
 printf ""
 text
  %[-]m.nx"" 
 arguments
  
 -
  
 Left justify (optional) 
  
 m 
  
 Minimum field length",NA
Regular Expression Wildcards ,"Limited Regular Expression Wildcards
  
 Extended Regular Expression Wildcards
  
 grep
 , 
 fgrep
 , 
 egrep
 , 
 sed
 , 
 vi
 , 
 perl
 , and 
 awk
  allow regular expression wildcards in search patterns.",NA
Limited Regular Expression Wildcards ,"All regular expression patterns can include these wildcards: 
  
 ^pattern 
 only matches if 
 pattern
  is at start of line 
  
 pattern$ 
 only matches if 
 pattern
  is at end of line 
  
 . 
 matches exactly 1 of any character 
  
 [list] 
 matches exactly 1 of any character in 
 list
  
 [^list] 
 matches exactly 1 of any character not in 
 list
  
 * 
 matches 0 or more repetitions of previous element (char or expression) 
  
 .* 
 matches 0 or more of any characters",NA
Extended Regular Expression Wildcards ,"These are additional regular expression wildcards that are only supported in some commands: 
  
 \{n\} 
  
 matches 
 n
  repetitions of previous element 
  
 \{n,\} 
  
 matches 
 n
  or more repetitions of previous element 
  
 \{n,m\} 
  
 matches at least 
 n
  but not more than 
 m
  reps of previous element 
  
 ? 
  
 matches 0 or 1 occurrences of previous element 
  
 + 
  
 matches 1 or more occurrences of previous element",NA
Summary,"This appendix provides a quick reference for shell commands and features: 
  
  
 G
 Reserved words and built-in shell commands 
  
  
 G
 Conditional expressions 
  
  
 G
 Arithmetic expressions (Korn/Bash only) 
  
  
 G
 Parameters and variables 
  
  
 G
 Parameter substitution 
  
  
 G
 Pattern matching 
  
  
 G
 I/O 
  
  
 G
 Miscellaneous command summaries 
  
  
 G
 Regular expression wildcards 
  
 As you write scripts and become familiar with the concepts, you might find this summary helps you to locate 
 a symbol, a command name, or the correct syntax. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix A: Command Quick Reference 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Reserved Words and Built-in Shell Commands
  
 I/O
  
 Conditional Expressions
  
 Miscellaneous Command Summaries
  
 Arithmetic Expressions (Korn/Bash Only)
  
 Regular Expression Wildcards
  
 Parameters and Variables
  
 Summary
  
 Parameter Substitution
  
 Questions
  
 Pattern Matching
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Questions,"1. 
 What section of this summary describes how to append output to a file? 
  
 2. 
 What section of this summary describes how to end a 
 case
  statement? 
  
 3. 
 What section of this summary enables you to determine whether the 
 jobs
  command is supported 
 in the Bourne shell? 
  
 4. 
 What section of this summary enables you to determine whether the 
 +
  sign is a generally 
 supported regular expression wildcard? 
  
 5. 
 What section of this summary enables you to determine which shell variable gives the numeric 
  
 result code of the last command executed? 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix A: Command Quick Reference 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Reserved Words and Built-in Shell Commands
  
 I/O
  
 Conditional Expressions
  
 Miscellaneous Command Summaries
  
 Arithmetic Expressions (Korn/Bash Only)
  
 Regular Expression Wildcards
  
 Parameters and Variables
  
 Summary
  
 Parameter Substitution
  
 Questions
  
 Pattern Matching
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Appendix B ,NA,NA
Glossary ,"absolute path 
   The complete pathname to a file starting at the root directory /. 
  
 abstraction
   Scripts that use abstraction retain the same basic flow by placing the conditional execution 
 statements within functions. When a function is called, it makes a decision as to what commands execute 
 for a given platform. 
  
 anchoring expression 
   Normally any part of a line will be matched by a regular expression. To match 
 expressions that either begin or end a line, you need to anchor the regular expression. The 
 ^
  character 
 anchors regular expressions to the beginning of a line, whereas the 
 $
  character anchors regular expressions 
 to the end of a line. 
  
 argument
   Command modifiers that change the behavior of a command. In the shell, they are specified 
 after a command's name. 
  
 array variable 
   A mechanism available in 
 bash
  and 
 ksh
  for grouping scalar variables together. The scalar 
 variables stored in an array are accessed using a single name in conjunction with a number. This number is 
 referred to as an index. 
  
 awk
   The 
 awk
  command is a power pattern matching language that allows you to modify input lines by 
 manipulating the fields they contain. 
  
 background
   Processes usually running at a lower priority and with their input disconnected from the 
 interactive session. Any input and output are usually directed to a file or other process. 
  
 background process 
   An autonomous process that runs under UNIX without requiring user interaction. 
  
 bash
   Stands for GNU Bourne Again shell and is based on the Bourne shell, 
 sh
 , the original command 
 interpreter. 
  
 block special file 
   Provides a mechanism for communicating with device drivers via the file system. These 
 files are called 
 block devices 
 because they transfer large blocks of data at a time. This type of file typically 
 represents hard drives and removable media. 
  
 body
   The set of commands executed by a loop is called the body of the loop. 
  
 Bourne shell 
   The original standard user interface to UNIX that supported limited programming capability. 
 BSD
   Berkeley Software Distribution. 
  
 BSD UNIX 
   Version of UNIX developed by Berkeley Software Distribution and written at the University of 
 California, Berkeley.",NA
Appendix C ,NA,NA
Quiz Answers ,NA,NA
Chapter 1 ,"1. 
 The first is a simple command. The second is a compound command constructed from two simple 
 commands. The last two are complex commands. 
  
 2. 
 There is no effect. The output will be the same for both commands. 
  
 3. 
 The two types are Bourne ( 
 sh
 , 
 ksh
 , or 
 bash
 ) and C ( 
 csh
 , 
 tcsh
 ).
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 2 ,"1. 
 The files are 
 /etc/profile
  and 
 .profile
 .
  
 2. 
 If 
 PATH
  is not set, the shell cannot find the commands you want to execute. If 
 MANPATH
  is not set, 
 the shell cannot locate the online help. 
  
 3. 
 It specifies that the shell 
 /bin/sh
  should be used to execute the script. 
  
 4. 
 The 
 man
  command. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 3 ,"1. 
 Invisible files are files whose names start with the 
 .
  character. You can list them by specifying the 
 -
 a
  option to 
 ls
 .
  
 2. 
 No. Each of these commands will produce the same results. 
  
 3. 
 On Solaris and HPUX use the command 
  
 $ wc -lm 
  
 On Linux use the command 
  
 $ wc -lc 
  
 4. 
 (b) and (c) will generate error messages indicating that 
 homework
  is a directory. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Index
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 4 ,"1. 
 (a) and (d) are absolute pathnames. (b) and (c) are relative pathnames. 
  
 2. 
 The 
 pwd
  command will output the full path to your home directory. In my case the path is 
  
 /home/ranga 
  
 3. 
 The following command will work: 
  
 cp -r /usr/local /opt/pgms 
  
 4. 
 The following commands will work: 
  
 cp -r /usr/local /opt/pgms ; rm -r /usr/local 
  
 5. 
 No, you cannot use the 
 rmdir
  command, because the directory is not empty. You can use the 
 following command: 
  
 $ rm -r backup
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 5 ,"1. 
 The file types of these files are 
  
 /dev/rdsk/c0t1d0 
  
 character special file 
  
 /etc/passwd 
  
 regular file 
  
 /usr/local 
  
 directory
  
 /usr/sbin/ping 
  
 regular file 
  
 2. 
 The owner and groups of these files are 
  
 /dev/rdsk/c0t1d0
  
 owner 
 bin
  
 group 
 sys
  
 /etc/passwd
  
 owner 
 root
  
 group 
 sys
  
 /usr/local
  
 owner 
 bin
  
 group 
 bin
  
 /usr/sbin/ping
  
 owner 
 root
  
 group 
 bin
  
 3. 
 The permissions of these files are 
  
 /dev/rdsk/c0t1d0
  
 owner 
 read
  and 
 write 
  
 group 
 read 
  
 other 
 none
  
 /etc/passwd 
  
 owner 
 read
  
 group 
 read
  
 other 
 read",NA
Chapter 6 ,"1. 
 By putting an ampersand at the end of the command line. 
  
 2. 
 With the 
 ps
  command. 
  
 3. 
 Use the suspend key (usually Ctrl-Z) to stop the foreground process and then use the 
 bg 
 command to resume it in the background. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 7 ,"1. 
 (a) and (d) are valid variable names. (b) starts with a number thus it is invalid. (c) contains the 
 & 
 character, which is not a valid character for variable names. 
  
 2. 
 These assignments are valid in 
 ksh
  and 
 bash
 , but not in 
 sh
 . The shell, 
 sh
 , only supports scalar 
 variables. 
  
 3. 
 To access the array item at index 5 use the following: 
  
 ${adams[5]}
  
 To access every item in the array use the following: 
  
 ${adams[@]}
  
 4. 
 An environment variable's value can be accessed by child processes of a shell. A local variable is 
  
 restricted to a particular shell; it cannot be used by child processes of a shell. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 8 ,"1. 
 The following command will accomplish this task: 
  
 $ ls *hw[0-9][0-9][2-6].???
  
 2. 
 If 
 MYPATH
  is unset, it is set to the given value, which is then substituted. 
  
 3. 
 If MYPATH is unset, the given value is substituted for it. MYPATH remains unset. 
  
 4. 
 10
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 9 ,"1. 
 Double quotes accomplish this easily but not single quotes: 
  
 $ echo ""It's <party> time!""
  
 2. 
 The following command will accomplish this task: 
  
 $ echo ""$USER owes     \$$DEBT""
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 10 ,"1. 
 The difference is that the first command will try to run the command without checking if it is 
 executable. Thus if the file exists but is not executable, the command will fail. The second command 
 takes this into account and attempts to run the command only if it is executable. 
  
 2. 
 The output is ""Your binaries are stored in your home directory."" 
  
 3. 
 Any of the following commands are valid: 
  
 $ test -d /usr/bin || test -h /usr/bin 
  
 $ [ -d /usr/bin ] || [ -h /usr/bin ] 
  
 $ test -d /usr/bin -o -h /usr/bin 
  
 $ [ -d /usr/bin  -o -h /usr/bin ]
  
 4. 
 The following 
 case
  statement covers the given combinations and several more: 
  
 case ""$ANS"" in
  
  [Yy]|[Yy][Ee][Ss]) ANS=""y"" ;;
  
  *) ANS=""n"" ;; 
  
 esac
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 11 ,"1. 
 Here is one possible implementation: 
  
 x=0 
  
 while [ $x -lt 10 ] 
  
 do
  
  x=$(($x+1))
  
  y=0
  
  while [ $y -lt $x ] ; do
  
  echo ""$y \c""
  
  
  
  y=$(($y+1))
  
  done
  
  echo 
  
 done
  
 2. 
 Here is one possible implementation: 
  
 #!/bin/bash 
  
 select FILE in * ""Exit Program"" 
  
 do
  
  if [ -z ""$FILE"" ] ; then continue ; fi
  
  if [ ""$FILE"" = ""Exit Program"" ] ; then break ; fi 
 if [ ! -f ""$FILE"" ] ; then
  
  
  echo ""$FILE is not a regular file.""
  
  
  continue
  
  fi
  
  echo $FILE
  
  cat $FILE 
  
 done
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Appendix C: Quiz Answers
  
 Next Chapter",NA
Chapter 12 ,"1. 
 One correct implementation is as follows: 
  
 #!/bin/sh
  
 USAGE=""Usage: ´basename $0´ [-c|-t] [files|directories]""
  
 if [ $# -lt 2 ] ; then
  
  echo ""$USAGE"" ;
  
  exit 1 ; 
  
 fi
  
 case ""$1"" in
  
  -t|-x) TARGS=${1}vf ; shift
  
  
   
  for i in ""$@"" ; do
  
  
   
  if [ -f ""$i"" ] ; then
  
  
   
  
  
  FILES=´tar $TARGS ""$i"" 2>/dev/null´
  
   
  
  
  if [ $? -eq 0 ] ; then
  
  
   
  
  
  
  echo ; echo ""$i"" ; echo ""$FILES""
  
   
  
  
  else
  
  
   
  
  
  
  echo ""ERROR: $i not a tar file.""
  
   
  
  
  fi
  
  
   
  else
  
  
   
  
  
  echo ""ERROR: $i not a file.""
  
  
   
  fi
  
  
   
  done
  
  
   
  ;;
  
  -c) shift ; TARGS=""-cvf"" ;
  
  
   
  tar $TARGS archive.tar ""$@""
  
  
   
  ;;
  
  
  *) echo ""$USAGE""
  
  
   
  exit 0
  
  
   
  ;; 
  
 esac 
  
 exit $?
  
 2. 
 One possible implementation is as follows: 
  
 #!/bin/sh",NA
Chapter 13 ,"1. 
 The simplest possible answer is as follows: 
  
 #!/bin/sh
  
 if [ $# -lt 2 ] ; then 
  
  echo ""ERROR: Insufficient arguments."" ;  exit 
 1 ; 
  
 fi 
  
 case ""$1"" in
  
  -o) printf ""%o\n"" ""$2"" ;;
  
  -x) printf ""%x\n"" ""$2"" ;;
  
  -e) printf ""%e\n"" ""$2"" ;;
  
  *) echo ""ERROR: Unknown conversion, $1!"" ;; 
 esac
  
 2. 
 The rewritten script is as follows: 
  
 #!/bin/sh
  
 if [ $# -lt 2 ] ; then
  
  echo ""ERROR: Insufficient arguments."" >&2 
 exit 1 ; 
  
 fi
  
 case ""$1"" in
  
  -o) printf ""%o\n"" ""$2"" ;;
  
  -x) printf ""%x\n"" ""$2"" ;;
  
  -e) printf ""%e\n"" ""$2"" ;;
  
  *) echo ""ERROR: Unknown conversion, $1!"" >&2 ;; 
 esac
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Appendix C: Quiz Answers
  
 Next Chapter",NA
Chapter 14 ,"1. 
 A possible implementation is 
  
 mymkdir() {
  
  if [ $# -lt 1 ] ; then
  
  
  echo ""ERROR: Insufficient arguments."" >&2
  
  
 return 1
  
  fi
  
  mkdir -p ""$1"" > /dev/null 2>&1
  
  if [ $? -eq 0 ] ; then
  
  
  
  cd ""$1"" > /dev/null 2>&1
  
  
  
  if [ $? -eq 0 ] ; then
  
  
  
  pwd ;
  
  
  
  else
  
  
  
  echo ""ERROR: Could not cd to $1."" >&2
  
  
  fi
  
  else
  
  
  
  echo ""ERROR: Could not mkdir $1."" >&2 fi 
  
 }
  
 2. 
 A possible implementation is 
  
 Prompt_RESPONSE() {
  
  if [ $# -lt 1 ] ; then
  
  
  echo ""ERROR: Insufficient arguments."" >&2
  
  
 return 1
  
  fi
  
  RESPONSE=
  
  while [ -z ""$RESPONSE"" ]
  
  do
  
  
  echo ""$1 \c ""
  
  
  read RESPONSE
  
  done",NA
Chapter 15 ,"1. 
 A sample implementation is 
  
 lspids() {
  
  USAGE=""Usage: lspids [-h] process""
  
  HEADER=false
  
  PSCMD=""/bin/ps -ef""
  
  case ""$1"" in
  
  
  -h) HEADER=true ; shift ;;
  
  esac
  
  if [ -z ""$1"" ] ; then
  
  
  echo $USAGE ;
  
  
  return 1 ;
  
  fi
  
  if [ ""$HEADER"" = ""true"" ] ; then
  
  
  $PSCMD 2> /dev/null | head -n 1 ;
  
  fi
  
  $PSCMD 2> /dev/null | grep ""$1""| grep -v grep }
  
 For Linux or FreeBSD, change the variable 
 PSCMD
  from 
  
 PSCMD=""/bin/ps -ef""
  
 to
  
 PSCMD=""/bin/ps -auwx""
  
 2. 
 The following is one possible implementation: 
  
 lspids () 
  
 { 
  
  USAGE=""Usage: lspids [-h|-s] process"";",NA
Chapter 16 ,"1. 
 One possible implementation is 
  
 sgrep() {
  
  if [ $# -lt 2 ] ; then 
  
  
  
  echo ""USAGE: sgrep pattern files"" >&2
  
  
  exit 1
  
  fi
  
  PAT=""$1"" ; shift ;    
  
  for i in $@ ; 
  
  do
  
  
  if [ -f ""$i"" ] ; then
  
  
  sed -n ""/$PAT/p"" $i
  
  
  else
  
  
  echo ""ERROR: $i not a file."" >&2
  
  
 fi
  
  done
  
  return 0 
  
 }
  
 2. 
 The following command does the job: 
  
 $ uptime | sed 's/.* load/load/'
  
 3. 
 There are two possible solutions: 
  
 $ df -k | sed -n '/^\//p' 
  
 $ df -k | sed '/^[^\/]/d'
  
 4. 
 The following command will solve this problem: 
  
 /bin/ls -al | sed -e '/^[^\-]/d' -e 's/ *[0-9].* / /'
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Contents
  
 Inde
 x",NA
Chapter 17 ,"1. 
 A possible implementation is as follows: 
  
 #!/bin/sh
  
 if [ $# -lt 1 ] ; then
  
  echo ""USAGE: ´basename $0´ files""
  
  exit 1 
  
 fi
  
 awk '{
  
  for (i=NF;i>=1;i--) {
  
  
  
  printf(""%s "",$i) ;
  
  }
  
  printf(""\n"") ; 
  
 }' $@
  
 2. 
 A possible solution is 
  
 #!/bin/sh 
  
 awk 'BEGIN { FS="":"" ; }
  
  $1 == ""B"" {
  
  
  
  BAL=$NF ; next ;
  
  }
  
  $1 == ""D"" {
  
  
  
  BAL += $NF ;
  
  }
  
  ($1 == ""C"") || ($1 == ""W"") {
  
  
  
  BAL-=$NF ;
  
  }
  
  ($1 == ""C"") || ($1 == ""W"") || ($1 == ""D"") {
  
  
  printf ""%10-s %8.2f\n"",$2,BAL ;
  
  } 
  
 ' account.txt ;
  
 Alternatively, you can use the 
 -F
  option: 
  
 #!/bin/sh",NA
Chapter 18 ,"1. 
 The following command will accomplish this task: 
  
 $ type process2
  
 2. 
 The following command will accomplish this task: 
  
 $ find /data -name '*process2*' -print
  
 3. 
 The following command will accomplish this task: 
  
 PRICE=´echo ""scale=2; 3.5 \* $PRICE"" | bc´
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Chapter 19 ,"1. 
 Here is a possible implementation: 
  
 trap CleanUp 2 15 
  
 trap Init 1 
  
 trap ""quit=true"" 3 
  
 PROG=""$1"" 
  
 Init
  
 while : ; 
  
 do
  
  wait $!
  
  if [ ""$quit"" = true ] ; then exit 0 ; fi 
 $PROG & 
  
 done
  
 2. 
 Here is a possible implementation: 
  
 #! /bin/sh
  
 AlarmHandler() {
  
  echo ""Got SIGALARM, cmd took too long."" 
 KillSubProcs
  
  exit 14 
  
 }
  
 IntHandler() {
  
  echo ""Got SIGINT, user interrupt.""
  
  KillSubProcs
  
  exit 2 
  
 }
  
 KillSubProcs() {
  
  kill ${CHPROCIDS:-$!}
  
  if [ $? -eq 0 ] ; then echo ""Sub-processes killed."" ; fi }
  
 SetTimer() {
  
  DEF_TOUT=${1:-10};",NA
Chapter 20 ,"1. 
 The three main methods are 
  
 H
 Issue the script in the following fashion: 
  
  $ /bin/sh 
 optionscriptarg1arg2arg3
  
 H
 Change the first line of the script to 
  
  #!/bin/sh 
 option
  
 H
 Use the 
 set
  command as follows:
  
  set 
 option
  
 Here 
 option
  is the debugging option you want to enable. 
  
 2. 
 Here is one possible implementation: 
  
 Debug() {
  
  if [ ""$DEBUG"" = ""true"" ] ; then
  
  
  
  if [ ""$1"" = ""on""  -o ""$1"" = ""ON"" ] ; then
  
  
  set -x
  
  
  
  else
  
  
  
  set +x
  
  
  
  echo "" >Press Enter To Continue< \c""
   
  
 read press_enter_to_continue
  
  
  
  fi
  
  fi 
  
 }
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Previous Chapter
  
 Contents
  
 Inde
 x
  
 Appendix C: Quiz Answers
  
 Next Chapter",NA
Chapter 21 ,"1. 
 One possible implementation is 
  
 ################################################ 
 # Name: toLower 
  
 # Desc: changes an input string to lower case # 
 Args: $@ -> string to change 
  
 ################################################
  
 toLower() {
  
  echo $@ | tr '[A-Z]' '[a-z]' ; 
  
 }
  
 2. 
 One possible implementation is 
  
 ################################################ 
 # Name: toUpper 
  
 # Desc: changes an input string to upper case # 
 Args: $@ -> string to change 
  
 ################################################
  
 toUpper() {
  
  echo $@ | tr '[a-z]' '[A-Z]' 
  
 }
  
 3. 
 One possible solution is 
  
 ################################################ 
 # Name: isSpaceAvailable 
  
 # Desc: returns true (0) if space available 
  
 # Args: $1 -> The directory to check 
  
 #       $2 -> The amount of space to check for 
 ################################################
  
 isSpaceAvailable() {
  
  if [ $# -lt 2 ] ; then
  
  
  
  printERROR ""Insufficient Arguments.""
  
  
  return 1",NA
Chapter 22 ,"1. 
 One possible simplification is 
  
 # initalize the destination directory 
  
 DESTDIR=""$2""; 
  
 # check if the destination exits 
  
 if [ ! -d ""$DESTDIR"" ] ; then
  
  # if the destination doesn't exist then assume the destination is # 
 the new name for the directory
  
  DESTDIR=""´/usr/bin/dirname $2´""
  
  NEWNAME=""´/bin/basename $2´"" 
  
 fi 
  
 # if dirname returns a relative dir we will be confused after cd'ing 
 # latter on. So reset it to the full path.
  
 DESTDIR=´(cd $DESTDIR ; pwd ; )´
  
 # if the parent of the destination doesn't exist, 
 # were in trouble. Tell the user and exit.
  
 if [ ! -d ""$DESTDIR"" ] ; then
  
  printERROR ""A parent of the destination directory $2 does not exist"" fi
  
 2. 
 Use 
 grep -i 
 instead of 
 grep
 .
  
 3. 
 They can be rewritten as functions and stored in a shell library that both scripts can access. 
  
 4. 
 We can change the lines 
  
  55  grep ""$1"" ""$TMPF1"" > ""$TMPF2"" 2> /dev/null 
 56  Failed $? ""No matches found.""",NA
Chapter 23 ,"1. 
 A possible implementation is 
  
 getCharCount() {
  
  case ´getOSName´ in
  
  
  
  bsd|sunos|linux)
  
  
  
  WCOPT=""-c"" ;;
  
  
  
  *)
  
  
  
  WCOPT=""-m"" ;;
  
  esac
  
  wc $WCOPT $@ 
  
 }
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Appendix A ,"1. 
 The ""
 I/O
 "" section; use 
 >>
  to append. 
  
 2. 
 In the section ""
 Reserved Words and Built-in Shell Commands
 ,"" find the 
 case
  statement, which 
 shows the word 
 esac
  must come at the end. 
  
 3. 
 In the section ""
 Reserved Words and Built-in Shell Commands
 ,"" find the 
 jobs
  command. Note that 
 (Korn/Bash) is indicated. This command is available in the Korn shell and Bash shell but not the 
 Bourne shell. 
  
 4. 
 In the section ""
 Regular Expression Wildcards
 ,"" note the 
 +
  sign is not listed under ""
 Limited Regular 
 Expression Wildcards
 ,"" which are always supported. It is in the next section, ""
 Extended Regular 
  
 Expression Wildcards
 ,"" which are supported only on some commands. Check the 
 man
  pages to see 
 if a particular command supports this wildcard. 
  
 5. 
 In the section ""
 Parameters and Variables
 ,"" subsection ""
 Built-in Shell Variables
 ,"" 
 $?
  is what you 
 are looking for. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Appendix C: Quiz Answers 
  
 Sections in this Chapter:
  
 Contents
  
 Inde
 x
  
 Previous Chapter
  
 Next Chapter
  
  
  
 Previous Section
  
 Next Section
  
 Chapter 1
  
 Chapter 9
  
 Chapter 17
  
 Chapter 2
  
 Chapter 10
  
 Chapter 18
  
 Chapter 3
  
 Chapter 11
  
 Chapter 19
  
 Chapter 4
  
 Chapter 12
  
 Chapter 20
  
 Chapter 5
  
 Chapter 13
  
 Chapter 21
  
 Chapter 6
  
 Chapter 14
  
 Chapter 22
  
 Chapter 7
  
 Chapter 15
  
 Chapter 23
  
 Chapter 8
  
 Chapter 16
  
 Appendix A
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Index ,NA,NA
A ,"absolute pathnames 
  
 find command, 
 1st 
  
 absolute paths, 
 1st 
  
 abstraction 
  
 portability, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 accounts 
  
 root, 
 1st 
  
 user, 
 1st 
  
 actions
  
 -exec 
  
 find command, 
 1st
  
 -print 
  
 find command, 
 1st 
  
 addperson script, 
 1st 
  
 address book, 
 1st
 , 
 2nd 
  
 adding people, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 deleting people, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 interactive mode, 
 1st 
  
 listing people in, 
 1st
 , 
 2nd
 , 
 3rd 
  
 noninteractive mode, 
 1st 
  
 ALARM signals, 
 1st
 , 
 2nd 
  
 example timer script, 
 1st
 , 
 2nd 
  
 handler function, 
 1st
 , 
 2nd 
  
 setting timer, 
 1st
 , 
 2nd 
  
 unsetting timer, 
 1st 
  
 AlarmHandler function, 
 1st
 , 
 2nd 
  
 aliases, 
 1st 
  
 displaying pathnames for, 
 1st 
  
 ampersand (&) 
  
 background processes, 
 1st 
  
 global substitutions, 
 1st 
  
 anchoring 
  
 patterns, 
 1st
 , 
 2nd
 , 
 3rd 
  
 and-and operator (&&), 
 1st 
  
 appending output to files, 
 1st
 , 
 2nd 
  
 arguments, 
 1st 
  
 basename command, 
 1st 
  
 commands, 
 1st 
  
 considering one at a time, 
 1st",NA
B ,"background processes, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 fg command, 
 1st
 , 
 2nd 
  
 input, requiring, 
 1st 
  
 moving foreground processes to, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 output, writing, 
 1st 
  
 preventing termination, 
 1st 
  
 waiting for, 
 1st 
  
 backquote (´) 
  
 command substitution, 
 1st 
  
 backslash, 
 1st
 , 
 2nd
 , 
 3rd 
  
 backslash ( 
  
 echo command escape sequences, 
 1st
 , 
 2nd 
  
 newline character, 
 1st 
  
 backslash character ( 
  
 tr command, 
 1st 
  
 backslash escaping, 
 1st 
  
 basename command, 
 1st
 , 
 2nd 
  
 bash, 
 1st
 , 
 2nd 
  
 exporting variables, 
 1st 
  
 Bash shell 
  
 integer expressions, 
 1st
 , 
 2nd
 , 
 3rd 
  
 support arrays, 
 1st 
  
 until loop, 
 1st 
  
 wildcards, 
 1st 
  
 bc command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 beeps 
  
 sounding a series with sleep command, 
 1st 
  
 BEGIN pattern 
  
 numeric expressions, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 bg, 
 1st 
  
 bg command, 
 1st 
  
 binaries 
  
 replacing 
  
 with functions, 
 1st 
  
 bit bucket, 
 1st 
  
 block special files, 
 1st 
  
 Bourne shell 
  
 character, 
 1st 
  
 initialization process, 
 1st 
  
 job control availibility, 
 1st 
  
 parameter substitution, 
 1st
 , 
 2nd 
  
 variables, 
 1st",NA
C ,"C shell 
  
 character, 
 1st 
  
 starting from Korn Shell, 
 1st 
  
 C shells. See csh 
  
 tcsh, 
 1st 
  
 C-type shells, 
 1st 
  
 caret (^), 
 1st 
  
 carriage returns 
  
 removing from files, 
 1st 
  
 case statement, 
 1st
 , 
 2nd
 , 
 3rd 
  
 patterns, 
 1st
 , 
 2nd 
  
 case-sensitive, 
 1st 
  
 cat command, 
 1st
 , 
 2nd
  
 -b option, 
 1st
  
 -n option, 
 1st 
  
 cd command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 common errors, 
 1st 
  
 CDPATH variable, 
 1st 
  
 character special files, 
 1st 
  
 characters 
  
 quoting, 
 1st 
  
 chgrp command, 
 1st 
  
 child processes, 
 1st
 , 
 2nd 
  
 IDs, 
 1st 
  
 permissions, 
 1st 
  
 subshells, 
 1st
 , 
 2nd
 , 
 3rd 
  
 chmod command, 
 1st 
  
 common errors, 
 1st 
  
 octal method, 
 1st 
  
 symbolic expression, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 chown command, 
 1st
 , 
 2nd 
  
 groups, 
 1st 
  
 restrictions, 
 1st 
  
 command interpreters. See shells, 
 1st 
  
 command line 
  
 options, 
 1st 
  
 reprocessing with eval command, 
 1st 
  
 command substitution, 
 1st
 , 
 2nd 
  
 single quotes, 
 1st 
  
 commands, 
 1st
 , 
 2nd 
  
 commands",NA
D ,"date command, 
 1st 
  
 debug mode 
  
 variable substitution, 
 1st 
  
 debugging 
  
 debugging mode, 
 1st
 , 
 2nd 
  
 invocation activated, 
 1st 
  
 enabling, 
 1st
 , 
 2nd 
  
 execution tracing mode, 
 1st 
  
 function libraries, 
 1st 
  
 set command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 shell tracing, 
 1st
 , 
 2nd
 , 
 3rd 
  
 debugging hooks, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 logical bugs, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 syntax bugs, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 syntax, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 verbose mode, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 debugging hooks 
  
 shell tracing, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 default actions (signals), 
 1st
 , 
 2nd 
  
 default behavior 
  
 commands, 
 1st 
  
 defining 
  
 variables, 
 1st 
  
 deleting 
  
 lines with sed command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 persons from address book, 
 1st 
  
 delimiters 
  
 deleting from input file, 
 1st 
  
 delivering signals, 
 1st 
  
 delperson script, 
 1st 
  
 descriptors. See file descriptors, 
 1st 
  
 dev directory 
  
 device files, 
 1st 
  
 device drivers 
  
 block special files, 
 1st 
  
 device files, 
 1st 
  
 DIR STACK variable, 
 1st 
  
 directories 
  
 BSD and System V equivalents, 
 1st 
  
 cd command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 common errors, 
 1st 
  
 changing, 
 1st
 , 
 2nd
 , 
 3rd",NA
E ,"echo command, 
 1st
 , 
 2nd
  
 -e option, 
 1st 
  
 conditional execution, 
 1st 
  
 function libraries, 
 1st 
  
 modifying with backslash, 
 1st 
  
 modifying with double quotes, 
 1st 
  
 modifying with single quote, 
 1st 
  
 option, 
 1st 
  
 output, 
 1st
 , 
 2nd 
  
 formatting, 
 1st
 , 
 2nd
 , 
 3rd 
  
 punctuation marks, 
 1st
 , 
 2nd 
  
 variable substitution, 
 1st 
  
 passing arguments to, 
 1st 
  
 echo_prompt function, 
 1st 
  
 elif statement 
  
 with else statements, 
 1st 
  
 else if statements, 
 1st 
  
 else statement 
  
 with ielif statement, 
 1st 
  
 embedding in output 
  
 formatting, 
 1st
 , 
 2nd
 , 
 3rd 
  
 printf command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 punctuation marks, 
 1st
 , 
 2nd 
  
 variable substitution, 
 1st 
  
 END pattern 
  
 numeric expressions, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 environment variables, 
 1st 
  
 exporting, 
 1st 
  
 error messages, 
 1st 
  
 background processes, 
 1st 
  
 output, 
 1st 
  
 redirecting, 
 1st
 , 
 2nd
 , 
 3rd 
  
 errors 
  
 cd command, 
 1st 
  
 cp command, 
 1st 
  
 copying directories, 
 1st 
  
 if statement, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 ln command 
  
 symbolic links, 
 1st
 , 
 2nd 
  
 ls command, 
 1st 
  
 mkdir command, 
 1st
 , 
 2nd",NA
F ,"false command, 
 1st 
  
 fc command, 
 1st 
  
 fg command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 fi statement, 
 1st 
  
 field editing 
  
 awk command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 fields, 
 1st 
  
 file attributes 
  
 tar command, 
 1st 
  
 file command, 
 1st 
  
 file descriptors, 
 1st
 , 
 2nd 
  
 redirecting, 
 1st 
  
 STDERR, 
 1st 
  
 STDIN, 
 1st 
  
 STDOUT, 
 1st 
  
 file descriptrs 
  
 associating files with, 
 1st
 , 
 2nd 
  
 file handles. See file descriptors, 
 1st 
  
 file systems, 
 1st 
  
 file types 
  
 determining, 
 1st
 , 
 2nd 
  
 filename substitution. See globbing, 
 1st 
  
 FILENAME variable, 
 1st 
  
 filenames, 
 1st
 , 
 2nd
 , 
 3rd 
  
 case-sensitive, 
 1st 
  
 length of, 
 1st 
  
 rules for expansion, 
 1st 
  
 setting to lowercase, 
 1st 
  
 spaces, 
 1st 
  
 special characters, 
 1st 
  
 files 
  
 appending output to, 
 1st
 , 
 2nd 
  
 as leaves, 
 1st 
  
 associating with descriptors, 
 1st
 , 
 2nd 
  
 block special, 
 1st 
  
 changing groups, 
 1st 
  
 changing owners, 
 1st
 , 
 2nd 
  
 restrictions, 
 1st 
  
 character special, 
 1st 
  
 copying, 
 1st
 , 
 2nd 
  
 common errors, 
 1st",NA
G ,"general input/output redirection, 
 1st
 , 
 2nd 
  
 getFreeSpace function 
  
 abstraction, 
 1st
 , 
 2nd
 , 
 3rd 
  
 getopts command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th
 , 
 8th
 , 
 9th
 , 
 10th 
 syntax, 
 1st 
  
 getopts function, 
 1st 
  
 getOSName function, 
 1st 
  
 getPID function, 
 1st 
  
 abstraction, 
 1st
 , 
 2nd
 , 
 3rd 
  
 getUID function, 
 1st 
  
 globally regular expression print. See grep, 
 1st 
  
 globbing, 
 1st
 , 
 2nd 
  
 * wildcard, 
 1st
 , 
 2nd
 , 
 3rd 
  
 ? wildcard, 
 1st 
  
 matching sets of characters, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 matching suffixes and prefixes, 
 1st 
  
 [] wildcard, 
 1st 
  
 GNU 
  
 gawk command, 
 1st 
  
 grep command, 
 1st
 , 
 2nd
  
 -i option, 
 1st
  
 -l option, 
 1st
  
 -n option, 
 1st
  
 -v option, 
 1st 
  
 address book 
  
 extracting names, 
 1st 
  
 greping a string in every file, 
 1st 
  
 line numbers, 
 1st 
  
 listing filenames, 
 1st 
  
 regular expressions 
  
 quoting, 
 1st 
  
 searching for words, 
 1st
 , 
 2nd 
  
 case independent, 
 1st 
  
 STDIN, 
 1st 
  
 groups 
  
 changing owners, 
 1st 
  
 restrictions, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
 Index 
  
 Contents",NA
H ,"hardware 
  
 determining, 
 1st
 , 
 2nd 
  
 head command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 help. See online help, 
 1st 
  
 here documents, 
 1st
 , 
 2nd
 , 
 3rd 
  
 (double less than signs) operator, 
 1st 
  
 hidden directories, 
 1st 
  
 hidden files, 
 1st
 , 
 2nd 
  
 history command, 
 1st 
  
 home directories, 
 1st 
  
 HOME variable, 
 1st
 , 
 2nd 
  
 hostname command, 
 1st 
  
 HP-UX 
  
 /bin, /sbin directories, 
 1st 
  
 abstraction 
  
 getFreeSpace function, 
 1st
 , 
 2nd
 , 
 3rd 
  
 remote system command, 
 1st 
  
 wc command 
  
 counting file characters, 
 1st 
  
 HUP signals, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G
  H
  I J K L M N O P Q R S T U V W X Y Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
I ,"IEEE 
  
 awk standard, 
 1st 
  
 if statement, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
  
 -f option, 
 1st
  
 -n option, 
 1st
  
 -s option, 
 1st
  
 -z option, 
 1st 
  
 awk command, flow control, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 common errors, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 compound expressions, 
 1st 
  
 script portability, 
 1st 
  
 syntax checking, 
 1st 
  
 if-then-else statements 
  
 abbreviating with variable substitution, 
 1st 
  
 IFS variable, 
 1st
 , 
 2nd 
  
 ignoring signals, 
 1st
 , 
 2nd 
  
 during critical operations, 
 1st
 , 
 2nd 
  
 index numbers, 
 1st 
  
 arrays variables, accessing, 
 1st 
  
 infinite loops 
  
 character, 
 1st 
  
 break command, 
 1st
 , 
 2nd 
  
 nested loops, 
 1st 
  
 continue command, 
 1st 
  
 initialization scripts 
  
 accessing current shell name, 
 1st 
  
 cross-platform 
  
 PATH variable, 
 1st 
  
 initializing shell 
  
 file contents, 
 1st
 , 
 2nd
 , 
 3rd 
  
 inner loops, 
 1st 
  
 input, 
 1st 
  
 background processes, 
 1st 
  
 pipelines, 
 1st
 , 
 2nd 
  
 printing lines with awk, 
 1st 
  
 reading, 
 1st
 , 
 2nd 
  
 redirecting, 
 1st
 , 
 2nd 
  
 general redirection, 
 1st
 , 
 2nd 
  
 here documents, 
 1st
 , 
 2nd 
  
 while loops, 
 1st 
  
 xargs command, 
 1st",NA
J ,"job controls 
  
 determining if available to shell, 
 1st 
  
 jobs 
  
 kill command, 
 1st 
  
 jobs command, 
 1st
 , 
 2nd 
  
 Joy, Bill, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I
  J
  K L M N O P Q R S T U V W X Y Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
K ,"kernel, 
 1st 
  
 accessing features with system calls, 
 1st 
  
 kill command, 
 1st
 , 
 2nd
  
 -l option, 
 1st 
  
 signals, 
 1st 
  
 kill signals, 
 1st
 , 
 2nd 
  
 Korn shell 
  
 array variables, 
 1st 
  
 integer expressions, 
 1st
 , 
 2nd
 , 
 3rd 
  
 parameter substitution, 
 1st
 , 
 2nd 
  
 starting C Shell from, 
 1st 
  
 support arrays, 
 1st 
  
 wildcards, 
 1st 
  
 Korn shell. See ksh, 
 1st 
  
 Korn, David, 
 1st 
  
 ksh, 
 1st
 , 
 2nd 
  
 exporting variables, 
 1st 
  
 ksh shell 
  
 until loop, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I J
  K
  L M N O P Q R S T U V W X Y Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
L ,"leaves, 
 1st 
  
 let command, 
 1st 
  
 libraries, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 checking disk space, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 displaying messages, 
 1st
 , 
 2nd
 , 
 3rd 
  
 libTYSP.sh, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 naming conventions, 
 1st
 , 
 2nd 
  
 retrieving process ID name, 
 1st
 , 
 2nd
 , 
 3rd 
  
 retrieving user numeric user ID, 
 1st
 , 
 2nd 
  
 user input, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 prompting for response, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 libTYSP.sh shell library, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 line numbers 
  
 grep command, 
 1st 
  
 Linux 
  
 compared to BSD and System V, 
 1st 
  
 gawk command, 
 1st 
  
 shell tracing, 
 1st 
  
 wc command 
  
 counting file characters, 
 1st 
  
 listing paths 
  
 with functions, 
 1st
 , 
 2nd 
  
 listing signals, 
 1st 
  
 listings 
  
 addperson script, 
 1st 
  
 delperson script, 
 1st 
  
 mvdir.sh script, 
 1st 
  
 showperson script, 
 1st 
  
 literal characters, 
 1st 
  
 ln command
  
 -s option, 
 1st 
  
 local variables, 
 1st 
  
 logging in, 
 1st
 , 
 2nd
 , 
 3rd 
  
 logic 
  
 checking with shell tracing, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 login 
  
 starting shell interactively, 
 1st 
  
 starting shell noninteractively, 
 1st 
  
 logins 
  
 logging, 
 1st 
  
 looping 
  
 controlling",NA
M ,"mail command 
  
 quoting with embedding spaces, 
 1st 
  
 mail spools 
  
 listing oldest, 
 1st 
  
 main code, 
 1st 
  
 main loops, 
 1st 
  
 man command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 man pages 
  
 signals, 
 1st 
  
 MANPATH variable, 
 1st 
  
 manuals, 
 1st 
  
 matching 
  
 find command -name option, 
 1st 
  
 sets of characters, 
 1st 
  
 strings, 
 1st 
  
 memory 
  
 commands, 
 1st 
  
 kernel, 
 1st 
  
 utilities, 
 1st 
  
 messages 
  
 . See also output, 
 1st 
  
 displaying 
  
 function libraries, 
 1st
 , 
 2nd
 , 
 3rd 
  
 displaying on STDERR, 
 1st 
  
 printing 
  
 to STDOUT, 
 1st 
  
 metacharacters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 double quotes, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 escaping, 
 1st
 , 
 2nd
 , 
 3rd 
  
 quoting with backslash, 
 1st
 , 
 2nd
 , 
 3rd 
  
 single quotes, 
 1st
 , 
 2nd 
  
 misspellings 
  
 correcting with sed command, 
 1st 
  
 mkdir command, 
 1st
 , 
 2nd 
  
 common errors, 
 1st
 , 
 2nd 
  
 parent directories, 
 1st 
  
 modified dates 
  
 finding files with find command, 
 1st 
  
 modulus function, 
 1st 
  
 moving 
  
 directories, 
 1st
 , 
 2nd 
  
 examples, 
 1st
 , 
 2nd",NA
N ,"name value pairs, 
 1st 
  
 named pipes, 
 1st 
  
 naming 
  
 variables, 
 1st
 , 
 2nd
 , 
 3rd 
  
 naming conventions 
  
 function libraries, 
 1st
 , 
 2nd 
  
 nawk command, 
 1st 
  
 negating a set, 
 1st 
  
 nesting, 
 1st 
  
 loops 
  
 breaking infinite loops, 
 1st 
  
 while loops, 
 1st
 , 
 2nd
 , 
 3rd 
  
 networking 
  
 System V UNIX, 
 1st 
  
 newgrp command, 
 1st 
  
 newline character, 
 1st 
  
 newlines 
  
 converting to spaces, 
 1st 
  
 next command 
  
 comparison operators, 
 1st
 , 
 2nd
 , 
 3rd 
  
 no-op, 
 1st 
  
 no-op command ( 
  
 ), 
 1st 
  
 nohup command, 
 1st 
  
 nohup.out file, 
 1st 
  
 noninteractive mode, 
 1st 
  
 address book, 
 1st 
  
 login, 
 1st 
  
 noninteractive shells 
  
 determining, 
 1st 
  
 numbers 
  
 sorting, 
 1st 
  
 different columns, 
 1st
 , 
 2nd 
  
 numeric expressions, 
 1st 
  
 awk command 
  
 assignment operators, 
 1st
 , 
 2nd 
  
 built-in variables, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 shell variables, 
 1st
 , 
 2nd 
  
 special patterns, BEGIN, END, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 numeric tests, 
 1st",NA
O ,"octal method 
  
 chmod command, 
 1st 
  
 online help 
  
 man command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 MANPATH variable, 
 1st 
  
 operands 
  
 expr command, 
 1st 
  
 operators 
  
 !, 
 1st 
  
 != 
  
 test command, 
 1st 
  
 &&, 
 1st 
  
 (double less than signs) 
  
 here documents, 
 1st 
  
 comparison, 
 1st 
  
 Korn/Bash integer expressions, 
 1st
 , 
 2nd
 , 
 3rd 
  
 ||, 
 1st 
  
 OPTARG variable, 
 1st 
  
 OPTIND variable, 
 1st 
  
 option 
  
 echo command, 
 1st 
  
 option grouping, files, 
 1st 
  
 option parsing, 
 1st
 , 
 2nd 
  
 getopts command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 options, 
 1st 
  
 combining 
  
 find command, 
 1st 
  
 compared to arguments, 
 1st 
  
 debugging options, 
 1st 
  
 negating 
  
 find command, 
 1st 
  
 ps command, 
 1st 
  
 uname command, 
 1st 
  
 or-or operator (||), 
 1st 
  
 outer loops, 
 1st 
  
 output, 
 1st 
  
 background processes, 
 1st 
  
 redirecting 
  
 general redirection, 
 1st
 , 
 2nd 
  
 pipelines, 
 1st
 , 
 2nd 
  
 reading files, 
 1st
 , 
 2nd 
  
 redirecting to /dev/null, 
 1st",NA
P ,"parameters 
  
 substitution, 
 1st
 , 
 2nd 
  
 parent directories, 
 1st 
  
 creating, 
 1st 
  
 parent processes, 
 1st
 , 
 2nd 
  
 IDs, 
 1st 
  
 permissions, 
 1st 
  
 subshells, 
 1st
 , 
 2nd
 , 
 3rd 
  
 passwd command 
  
 SUID bit, 
 1st 
  
 passwd file 
  
 login, 
 1st 
  
 password files 
  
 process permissions, 
 1st 
  
 passwords 
  
 file stored in, 
 1st 
  
 logging in, 
 1st 
  
 PATH variable, 
 1st
 , 
 2nd 
  
 cross-platform initialization scripts, 
 1st 
  
 setting, 
 1st 
  
 pathnames, 
 1st
 , 
 2nd
 , 
 3rd 
  
 .. leader, 
 1st 
  
 absolute, 
 1st 
  
 determining directory full pathnames, 
 1st 
  
 determining file full pathnames, 
 1st 
  
 displaying for a command, 
 1st 
  
 displaying for files, 
 1st 
  
 find command, 
 1st 
  
 relative, 
 1st
 , 
 2nd
 , 
 3rd 
  
 paths 
  
 absolute, 
 1st 
  
 customizing 
  
 with functions, 
 1st
 , 
 2nd
 , 
 3rd 
  
 listing 
  
 with functions, 
 1st
 , 
 2nd 
  
 pattern matching, 
 1st 
  
 awk command, 
 1st 
  
 if statement, 
 1st 
  
 patterns, 
 1st 
  
 .*, 
 1st 
  
 anchoring, 
 1st
 , 
 2nd
 , 
 3rd",NA
Q ,"QUIT signals, 
 1st 
  
 quoting 
  
 combining quoting, 
 1st 
  
 echo escape sequences, 
 1st
 , 
 2nd 
  
 embedding spaces, 
 1st
 , 
 2nd 
  
 filenames with special characters, 
 1st
 , 
 2nd 
  
 newline character, 
 1st
 , 
 2nd 
  
 wildcards, 
 1st 
  
 cpio and find commands, 
 1st 
  
 with backslash, 
 1st
 , 
 2nd
 , 
 3rd 
  
 with double quotes, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 with single quotes, 
 1st
 , 
 2nd 
  
 word boundaries, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I J K L M N O P
  Q
  R S T U V W X Y Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
R ,"r command, 
 1st 
  
 RANDOM variable, 
 1st
 , 
 2nd 
  
 read command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 read permission, 
 1st 
  
 read permissions, 
 1st 
  
 read-only variables, 
 1st 
  
 reading 
  
 files 
  
 redirection, 
 1st
 , 
 2nd 
  
 input, 
 1st
 , 
 2nd 
  
 readonly command, 
 1st
 , 
 2nd 
  
 redirecting 
  
 file descriptors, 
 1st 
  
 input, 
 1st
 , 
 2nd 
  
 general redirection, 
 1st
 , 
 2nd 
  
 here documents, 
 1st
 , 
 2nd 
  
 while loops, 
 1st 
  
 output, 
 1st
 , 
 2nd 
  
 appending to files, 
 1st
 , 
 2nd 
  
 general redirection, 
 1st
 , 
 2nd 
  
 pipelines, 
 1st
 , 
 2nd 
  
 reading files, 
 1st
 , 
 2nd 
  
 STDOUT, 
 1st
 , 
 2nd
 , 
 3rd 
  
 to files and screens, 
 1st
 , 
 2nd 
  
 redirection signs 
  
 eval command, 
 1st 
  
 regular expression wildcards, 
 1st
 , 
 2nd 
  
 regular expressions, 
 1st 
  
 .*, 
 1st 
  
 awk command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 anchoring patterns, 
 1st
 , 
 2nd
 , 
 3rd 
  
 escaping metacharacters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 matching characters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 matching sets of characters, 
 1st 
  
 metacharacters, 
 1st
 , 
 2nd 
  
 sets of characters, 
 1st
 , 
 2nd 
  
 quoting, 
 1st 
  
 sed command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 anchoring patterns, 
 1st
 , 
 2nd
 , 
 3rd 
  
 escaping metacharacters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 matching characters, 
 1st
 , 
 2nd
 , 
 3rd",NA
S ,"scalar variables, 
 1st 
  
 scale (bc command), 
 1st 
  
 scripts 
  
 $0 shell variable, 
 1st 
  
 comments, 
 1st 
  
 globbing, 
 1st 
  
 including functions, 
 1st 
  
 maintenance, 
 1st 
  
 operation failures, 
 1st 
  
 option parsing, 
 1st
 , 
 2nd 
  
 getopts command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 variable substitution, 
 1st 
  
 while loop, 
 1st
 , 
 2nd
 , 
 3rd 
  
 nesting, 
 1st
 , 
 2nd
 , 
 3rd 
  
 until loop, 
 1st
 , 
 2nd
 , 
 3rd 
  
 validating user input, 
 1st
 , 
 2nd
 , 
 3rd 
  
 searching 
  
 files with wildcards, 
 1st 
  
 SECONDS variable, 
 1st
 , 
 2nd 
  
 sed command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 anchoring patterns, 
 1st
 , 
 2nd
 , 
 3rd 
  
 deleting lines, 
 1st
 , 
 2nd
 , 
 3rd 
  
 escaping metacharacters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 matching characters, 
 1st
 , 
 2nd
 , 
 3rd 
  
 matching sets of characters, 
 1st 
  
 metacharacters, 
 1st
 , 
 2nd 
  
 multiple sed commands, 
 1st 
  
 pipelines, 
 1st
 , 
 2nd 
  
 printing lines, 
 1st
 , 
 2nd
 , 
 3rd 
  
 sets of characters, 
 1st
 , 
 2nd 
  
 substitutions, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 using shell variables in, 
 1st 
  
 select command, 
 1st 
  
 select loops, 
 1st
 , 
 2nd
 , 
 3rd 
  
 changing prompt, 
 1st 
  
 semicolon ( 
  
 ), 
 1st 
  
 if then statement, 
 1st 
  
 semicolon (), 
 1st
 , 
 2nd 
  
 semicolon ([sc]) 
  
 awk command, 
 1st",NA
T ,"tabs 
  
 converting to spaces, 
 1st 
  
 tail command, 
 1st
 , 
 2nd
  
 -f optio, 
 1st 
  
 follow option, 
 1st 
  
 tar command, 
 1st 
  
 tar files, 
 1st 
  
 arguments, 
 1st 
  
 listing contents with $0 variable, 
 1st 
  
 tcsh, 
 1st 
  
 temporary files 
  
 appending process IDs, 
 1st 
  
 cleaning up, 
 1st 
  
 trap command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 TENEX/TOPS C shell. See tcsh, 
 1st 
  
 TERM (value 15) signal, 
 1st 
  
 TERM signals, 
 1st 
  
 terminal 
  
 output to, 
 1st 
  
 echo command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th
 , 
 8th 
  
 printf command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 terminals 
  
 setting type, 
 1st 
  
 test -t command, 
 1st 
  
 test command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 compound expressions, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 file test options, 
 1st 
  
 file tests, 
 1st
 , 
 2nd 
  
 numerical comparisons, 
 1st
 , 
 2nd
 , 
 3rd 
  
 string comparisons, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 text 
  
 filtering 
  
 awk command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th
 , 
 8th
 , 
 9th
 , 
 10th
 , 
 11th
 , 
 12th
 , 
 13th
 , 
 14th
 , 
 15th
 , 
 16th
 , 
 17th
 , 
 18th
 , 
 19th
 , 
 20th
 , 
 21st
 , 
 22nd
 , 
 23rd
 , 
 24th
 , 
 25th
 , 
 26th
 , 
 27th
 , 
 28th
 , 
 29th
 , 
 30th
 , 
 31st
 , 
 32nd
 , 
 33rd
 , 
 34th
 , 
 35th
 , 
 36th
 , 
 37th
 , 
 38th
 , 
 39th
 , 
 40th
 , 
 41st
 , 
 42nd
 , 
 43rd 
  
 text files 
  
 filtering 
  
 grep command, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th 
  
 head command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 tail command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 then statement 
  
 troubleshooting, 
 1st",NA
U ,"UID variable, 
 1st
 , 
 2nd 
  
 ulimit command, 
 1st 
  
 umask command, 
 1st 
  
 unalias command, 
 1st 
  
 uname command, 
 1st
 , 
 2nd
  
 -m option, 
 1st
  
 -r option, 
 1st 
  
 determining versions with a function, 
 1st
 , 
 2nd
 , 
 3rd 
  
 hardware type, 
 1st
 , 
 2nd 
  
 SunOS, 
 1st 
  
 uniq command, 
 1st
 , 
 2nd 
  
 UNIX 
  
 kernel, 
 1st 
  
 system manuals, 
 1st 
  
 unset command, 
 1st
 , 
 2nd 
  
 UnsetTimer function, 
 1st 
  
 unsetting variables, 
 1st 
  
 until command, 
 1st 
  
 until loop, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 usage statements 
  
 $0 variable, 
 1st
 , 
 2nd 
  
 user accounts, 
 1st 
  
 user IDs 
  
 retrieving, 
 1st 
  
 user input 
  
 function libraries, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 prompting for response, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 validating with while loop, 
 1st 
  
 user-defined variables, 
 1st 
  
 users 
  
 . See also input, 
 1st 
  
 logging in, 
 1st
 , 
 2nd
 , 
 3rd 
  
 logging logins with sleep command, 
 1st 
  
 process ID, 
 1st 
  
 profiles 
  
 shell specific startup with $0 variable, 
 1st 
  
 shell 
  
 interactive mode, 
 1st 
  
 utilities, 
 1st 
  
 uuencode, 
 1st 
  
 uuencode command",NA
V ,"validating 
  
 user input 
  
 while loops, 
 1st
 , 
 2nd
 , 
 3rd 
  
 variable substitution, 
 1st
 , 
 2nd 
  
 default values 
  
 assigning, 
 1st 
  
 substituting, 
 1st 
  
 option parsing, 
 1st 
  
 single quotes, 
 1st 
  
 variable errors, 
 1st 
  
 variables 
  
 $0, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 usage statements, 
 1st
 , 
 2nd 
  
 $?, 
 1st 
  
 arguments 
  
 troubleshooting, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th 
  
 array, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th 
  
 arrays 
  
 accessing values, 
 1st
 , 
 2nd
 , 
 3rd 
  
 awk command, 
 1st
 , 
 2nd 
  
 numeric expressions, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th
 , 
 6th
 , 
 7th
 , 
 8th
 , 
 9th
 , 
 10th
 , 
 11th
 , 
 12th
 , 
 13th
 , 
 14th
 , 
 15th 
 built-in shell, 
 1st 
  
 checking for values, 
 1st 
  
 considering arguments one at a time, 
 1st 
  
 defining, 
 1st 
  
 DIR STACK, 
 1st 
  
 environment, 
 1st 
  
 exporting, 
 1st 
  
 FILENAME, 
 1st 
  
 including functions and definitions in other files, 
 1st 
  
 local, 
 1st 
  
 naming, 
 1st
 , 
 2nd
 , 
 3rd 
  
 PATH 
  
 cross-platform initialization scripts, 
 1st 
  
 read-only, 
 1st 
  
 scalar, 
 1st 
  
 sed command 
  
 using shell variable values in, 
 1st 
  
 shell, 
 1st
 , 
 2nd 
  
 listed, 
 1st 
  
 special, 
 1st 
  
 substitution",NA
W ,"wait command, 
 1st
 , 
 2nd 
  
 wc command, 
 1st
 , 
 2nd
 , 
 3rd
  
 -c option, 
 1st
  
 -l option, 
 1st
  
 -w option, 
 1st 
  
 grouping options, 
 1st 
  
 Web browsers 
  
 sockets, 
 1st 
  
 whence command, 
 1st 
  
 while command, 
 1st 
  
 while loop, 
 1st
 , 
 2nd
 , 
 3rd 
  
 nesting, 
 1st
 , 
 2nd
 , 
 3rd 
  
 until loop, 
 1st
 , 
 2nd
 , 
 3rd 
  
 validating user input, 
 1st
 , 
 2nd
 , 
 3rd 
  
 while loops 
  
 input redirection, 
 1st 
  
 while statement 
  
 awk command, flow control, 
 1st 
  
 who command, 
 1st 
  
 wildcards, 
 1st 
  
 . See also metacharacters, 
 1st 
  
 expr command, 
 1st 
  
 find command, 
 1st 
  
 globbing, 
 1st 
  
 * wildcard, 
 1st
 , 
 2nd
 , 
 3rd 
  
 ? wildcard, 
 1st 
  
 matching sets of characters, 
 1st
 , 
 2nd
 , 
 3rd
 , 
 4th
 , 
 5th 
  
 [] wildcard, 
 1st 
  
 quoting, 
 1st 
  
 with cpio and find, 
 1st 
  
 regular expression, 
 1st
 , 
 2nd 
  
 words 
  
 count occurances, 
 1st
 , 
 2nd 
  
 counting, 
 1st 
  
 transliterating, 
 1st
 , 
 2nd 
  
 world read permission, 
 1st 
  
 world write permission, 
 1st 
  
 wrapper scripts 
  
 forwarding arguments onto other commands, 
 1st 
  
 write permission, 
 1st",NA
X ,"xargs command, 
 1st
 , 
 2nd
 , 
 3rd
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I J K L M N O P Q R S T U V W
  X
  Y Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Y ,"No entry available. 
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X
  Y
  Z Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Z ,"zero completion code, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours 
  
 Index 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y
  Z
  Symbols
  
 Contents
  
 © Copyright Macmillan Computer Publishing. All rights reserved.",NA
Symbols,NA,NA
:,": (colon), 
 1st 
  
 : character 
  
 getopts command, 
 1st 
  
 shell command, 
 1st
 , 
 2nd
 , 
 3rd 
  
 : command (no-op), 
 1st",NA
;,";(semicolon), 
 1st",NA
!,"! operator, 
 1st 
  
 until loop, 
 1st 
  
 ! sign 
  
 find command 
  
 negating options, 
 1st 
  
 !!, 
 1st 
  
 != operator 
  
 test command, 
 1st",NA
#,"# character 
  
 comments, 
 1st 
  
 #!, 
 1st 
  
 #!/bin/sh, 
 1st",NA
$,"$ 
  
 parameter substitution, 
 1st
 , 
 2nd 
  
 $ (dollar sign) 
  
 field operator, 
 1st 
  
 newline character, 
 1st",NA
%,"% (percent sign) 
  
 job number prefixes, 
 1st 
  
 prompt, 
 1st",NA
',"' (single quote) 
  
 awk and sed commands, 
 1st 
  
 filtering, 
 1st 
  
 quoting, 
 1st
 , 
 2nd",NA
´,"´ (backquote) 
  
 command substitution, 
 1st",NA
&,"& (ampersand) 
  
 background processes, 
 1st 
  
 & operator 
  
 global substitutions, 
 1st 
  
 && (and) compound operator, 
 1st 
  
 && operator, 
 1st",NA
(,NA,NA
*,"* metacharacter, 
 1st 
  
 * sign 
  
 expr command, 
 1st 
  
 * wildcard 
  
 basename command, 
 1st 
  
 globbing, 
 1st
 , 
 2nd
 , 
 3rd",NA
+,"+ character 
  
 shell tracing, 
 1st",NA
-,"- character 
  
 getopts command, 
 1st
  
 -a option 
  
 cpio command, 
 1st
  
 -atime option 
  
 find command, 
 1st
 , 
 2nd
  
 -c option 
  
 uniq command, 
 1st
  
 -ctime option 
  
 find command, 
 1st
 , 
 2nd
  
 -e option 
  
 echo command, 
 1st 
  
 ps command, 
 1st
  
 -exec action 
  
 find command, 
 1st
  
 -f option 
  
 tail command, 
 1st
  
 -i option 
  
 grep command, 
 1st",NA
.,". (period), 
 1st 
  
 . character 
  
 hidden files, 
 1st 
  
 . command 
  
 calling functions, 
 1st 
  
 including functions and variable definitions in other files, 
 1st 
 . metacharacter, 
 1st 
  
 .. (pathname leaders), 
 1st",NA
/,"/ (forward slash), 
 1st 
  
 regular expressions, 
 1st 
  
 sed command, 
 1st",NA
?,"? wildcard 
  
 globbing, 
 1st",NA
[,"[0-9]* expression, 
 1st 
  
 [gt] (redirection sign) 
  
 eval command, 
 1st 
  
 [less than] sign 
  
 quoting, 
 1st 
  
 [sc] (semicolon) 
  
 awk command, 
 1st 
  
 [sc][sc] command 
  
 case statement, 
 1st 
  
 [] 
  
 test command shorthand, 
 1st 
  
 [] (brackets) metacharacter, 
 1st 
  
 [] wildcard 
  
 globbing, 
 1st",NA
^,"^ character, 
 1st 
  
 ^ metacharacter, 
 1st 
  
 ^M (carriage return) 
  
 removing from files, 
 1st",NA
{,"{} (braces) 
  
 while statement, 
 1st",NA
|,"| (pip) 
  
 tr command, 
 1st 
  
 | (pipe character) 
  
 tar files, 
 1st 
  
 || (or) compound operator, 
 1st 
  
 || operator, 
 1st
  
 Sams Teach Yourself Shell Programming in 24 Hours
  
 Contents",NA
