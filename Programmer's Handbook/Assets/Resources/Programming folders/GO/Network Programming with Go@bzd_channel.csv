Larger Text,Smaller Text,Symbol
Network ,NA,NA
Programmi,NA,NA
ng ,NA,NA
with Go,NA,NA
Essential Skills for Using and ,NA,NA
Securing Networks,NA,NA
—,NA,NA
Jan Newmarch,NA,NA
Network Programming ,NA,NA
with Go,NA,NA
Essential Skills for Using and ,NA,NA
Securing Networks,NA,NA
Jan Newmarch,www.allitebooks.com,NA
Contents at a Glance,"About the Author xvii About the Technical Reviewer xix Preface xxi
  
 ■
 Chapter 1: Architecture  1
 ■
 Chapter 2: Overview of the Go Language  
 21
 ■
 Chapter 3: Socket-Level Programming  29
 ■
 Chapter 4: Data Serialization  
 57
 ■
 Chapter 5: Application-Level Protocols  87
 ■
 Chapter 6: Managing Character 
 Sets and Encodings  107
 ■
 Chapter 7: Security  121
 ■
 Chapter 8: HTTP  
 137
 ■
 Chapter 9: Templates  161
 ■
 Chapter 10: A Complete Web Server  
 175
 ■
 Chapter 11: HTML  193
 ■
 Chapter 12: XML  199
 ■
 Chapter 13: Remote 
 Procedure Call 209
 ■
 Chapter 14: REST  221
 ■
 Chapter 15: WebSockets  247 
 Afterword  267
  
 Index  269
  
 iii
  
 www.allitebooks.com",NA
Contents,"About the Author xvii
  
 About the Technical Reviewer xix
  
 Preface xxi
  
 ■
 Chapter 1: Architecture  1 Protocol Layers  1 
 ISO OSI Protocol 2 OSI Layers 2 TCP/IP 
 Protocol 3 Some Alternative Protocols 3 
 Networking  3 Gateways  4 Packet 
 Encapsulation  4 Connection Models  5 
 Connection Oriented 5 Connectionless 5 
 Communications Models  5 
 Message Passing 5 Remote Procedure Call 6 
 Distributed 
 Computing Models  7 Client-Server System  8 Client-Server Application 8 Server 
 Distribution  9
  
 v
  
 www.allitebooks.com",NA
About the Author,"Jan Newmarch
  is head of ICT (higher education) at Box Hill Institute, 
 adjunct professor at Canberra University, and adjunct lecturer in the 
 School of Information Technology, Computing and Mathematics at Charles 
 Sturt University. He is interested in more aspects of computing than he 
 has time to pursue, but the major thrust over the last few years has 
 developed from user interfaces under UNIX into Java, the Web, and then 
 into general distributed systems. Jan developed a number of publicly 
 available software systems in these areas. For the last few years, he has 
 been looking at sound for Linux systems and programming the Raspberry 
 Pi’s GPU. He is now exploring aspects of the IoT. He lives in Melbourne, 
 Australia and enjoys the food and culture there, but is not so impressed by 
 the weather.
  
 xvii",NA
About the Technical Reviewer,"Ronald Petty
 ,M.B.A., M.S. is the founder of Minimum Distance LLC, a 
 management consulting firm based in San Francisco. He spends his time 
 helping technology-based startups do the right thing. He is also an 
 instructor at UC Berkeley Extension. 
  
 xix",NA
Preface,"It’s always fun to learn a new programming language, especially when it turns out to be a major one. Prior to 
 the release of Go in 2009, I was teaching a Master’s level subject in network programming at Monash 
 University. It’s good to have a goal when learning a new language, but this time, instead of building yet 
 another wine cellar program, I decided to orient my lecture notes around Go instead of my (then) standard 
 delivery vehicle of Java.
  
 The experiment worked well: apart from the richness of the Java libraries that Go was yet to match, 
 all the programming examples transferred remarkably well, and in many cases were more elegant than 
 the original Java programs.
  
 This book is the result. I have updated it as Go has evolved and as new technologies such as HTTP/2 
 have arisen. But if it reads like a textbook, well, that is because it is one. There is a large body of theoretical 
 and practical concepts involved in network programming and this book covers some of these as well as 
 the practicalities of building systems in Go.
  
 In terms of language popularity, Go is clearly rising. It has climbed to 16th in the TIOBE index, is 18th 
 in the PYPL (Popularity of Programming Language), and is 15th in the RedMonk Programming Language 
 rankings. It is generally rated as one of the fastest growing languages.
  
 There is a growing community of developers both of the core language and libraries and of the 
 independent projects. I have tried to limit the scope of this book to the standard libraries only and to the 
 “sub-repositories” of the Go tree. While this eliminates many excellent projects that no doubt make many 
 programming tasks easier, restricting the book to the official Go libraries provides a clear bound.
  
 This book assumes a basic knowledge of Go. The focus is on using Go to build network applications, not 
 on the basics of the language. Network applications are different than command-line applications, are 
 different than applications with a graphical user interface, and so on. So the first chapter discusses 
 architectural aspects of network programs. The second chapter is an overview of the features of Go that we 
 use in this book. The third chapter on sockets covers the Go version of the basics underlying all 
  
 TCP/IP systems. Chapters 
 4
 , 
 5
 , and 
 6
  are more unusual in network programming books. They cover the 
 topics of what representations of data will be used, how a network interaction will proceed, and for text, 
 which language formats are used. Then in Chapter 
 7
 , we look at the increasingly important topic of security. 
  
 In Chapter 
 8
 , we look at one of the most common application layer protocols in use, HTTP. The next four 
 chapters are about topics related to HTTP and common data formats carried above HTTP—HTML and 
 XML. In Chapter 
 13
 , we look at an alternative approach to network programming, remote procedure calls. 
 Chapters 
 14
  and 
 15
  consider further aspects of network programming using HTTP.
  
 xxi",NA
CHAPTER 1,NA,NA
Architecture,"This chapter covers the major architectural features of distributed systems. You can’t build a system without 
 some idea of what you want to build. And you can’t build it if you don't know the environment in which it 
 will work. GUI programs are different than batch processing programs; games programs are different than 
 business programs; and distributed programs are different than standalone programs. They each have their 
 approaches, their common patterns, the problems that typically arise, and the solutions that are often used.
  
  
 This chapter covers the high-level architectural aspects of distributed systems. There are many ways of 
 looking at such systems, and many of these are dealt with.",NA
Protocol Layers,"Distributed systems are 
 hard
 . There are multiple computers involved, which have to be connected in some 
 way. Programs have to be written to run on each computer in the system and they all have to cooperate to 
 get a distributed task done.
  
 The common way to deal with complexity is to break it down into smaller and simpler parts. These parts 
 have their own structure, but they also have defined means of communicating with other related parts. 
  
 In distributed systems, the parts are called 
 protocol layers
  and they have clearly defined functions. They 
 form a stack, with each layer communicating with the layer above and the layer below. The communication 
 between layers is defined by protocols.
  
  
 Network communications requires protocols to cover high-level application communication all the way 
 down to wire communication and the complexity handled by encapsulation in protocol layers.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_1
  
 1",NA
ISO OSI Protocol,"Although it was never properly implemented, the OSI (Open Systems Interconnect) protocol has been a 
 major influence in ways of talking about and influencing distributed systems design. It is commonly given as 
 shown in Figure 
 1-1
 .
  
 Application
  
  
 Application
  
  
 Presentation
  
 Presentation
  
 Session
  
 Session
  
 Transport
  
 Transport
  
 Network
  
 Network
  
 Data Link
  
 Data Link
  
 Physical
  
 Physical",NA
TCP/IP Protocol,"While the OSI model was being argued, debated, partly implemented, and fought over, the DARPA Internet 
 research project was busy building the TCP/IP protocols. These have been immensely successful and have 
 led to 
 The Internet
  (with capitals). This is a much simpler stack, as shown in Figure 
 1-2
 .
  
 application 
  
 application 
  
 OSI 5−7 
  
 TCP UDP 
  
 OSI 4
  
 IP OSI 3
  
 h/w interface 
  
 OSI 1−2
  
 Figure 1-2.
  The TCP/IP protocols",NA
Some Alternative Protocols,"Although it almost seems like it, the TCP/IP protocols are not the only ones in existence and in the long run 
 may not even be the most successful. Wikipedia’s list of network protocols (see 
 https://en.wikipedia.
  
 org/wiki/List_of_network_protocols_(OSI_model)
 ) has a huge number more, at each of the ISO layers. Many 
 of these are obsolete or of little use, but due to advances in technology in all sorts of areas—such as the 
 Internet in Space and the Internet of Things—there will always be room for new protocols.
  
  
 The focus in this book is on the TCP/IP (including UDP) layer, but you should be aware that there are 
 other ones.",NA
Networking,"A 
 network
  is a communications system for connecting end systems called hosts. The mechanisms of 
 connection might be copper wire, Ethernet, fiber optic, or wireless, but that won’t concern us here. A local 
 area network (LAN) connects computers that are close together, typically belonging to a home, small 
 organization, or part of a larger organization.
  
 A Wide Area Network (WAN) connects computers across a larger physical area, such as between 
 cities. There are other types as well, such as MANs (Metropolitan Area Network), PANs (Personal Area 
 Networks), and even BANs (Body Area Network).
  
  
 An internet is a connection of two or more distinct networks, typically LANs or WANs. An intranet is an 
 internet with all networks belonging to a single organization.
  
 There are significant differences between an internet and an intranet. Typically, an intranet will be 
 under a single administrative control, which will impose a single set of coherent policies. An internet, on the 
 other hand, will not be under the control of a single body, and the controls exercised over different parts 
 may not even be compatible.
  
 3",NA
Gateways,"A 
 gateway
  is a generic term for an entity used to connect two or more networks. A repeater operates at 
 the physical level and copies information from one subnet to another. A bridge operates at the data link 
 layer level and copies frames between networks. A router operates at the network level and not only 
 moves information between networks but also decides on the route.",NA
Packet Encapsulation,"The communication between layers in either the OSI or the TCP/IP stacks is done by sending packets of data 
 from one layer to the next, and then eventually across the network. Each layer has administrative 
 information that it has to keep about its own layer. It does this by adding header information to the packet it 
 receives from the layer above, as the packet passes down. On the receiving side, these headers are removed 
 as the packet moves up.
  
 For example, the TFTP (Trivial File Transfer Protocol) moves files from one computer to another. It 
 uses the UDP protocol on top of the IP protocol, which may be sent over Ethernet. This looks like the 
 diagram shown in Figure 
 1-3
 .",NA
data,NA,NA
ethernet ,NA,NA
header,NA,NA
IP ,NA,NA
heade,NA,NA
r,NA,NA
UDP ,NA,NA
heade,NA,NA
r,NA,NA
TFTP ,NA,NA
heade,NA,NA
r,NA,NA
data,NA,NA
TFTP ,NA,NA
heade,NA,NA
r,NA,NA
data,NA,NA
UDP ,NA,NA
heade,NA,NA
r,NA,NA
TFTP ,NA,NA
heade,NA,NA
r,NA,NA
TFTP ,NA,NA
heade,NA,NA
r,NA,NA
data,NA,NA
data,NA,NA
IP ,NA,NA
heade,NA,NA
r,NA,NA
UDP ,NA,NA
heade,NA,NA
r,"Figure 1-3.
  The TFTP (Trivial File Transfer Protocol)
  
 4",NA
Connection Models,"In order for two computers to communicate, they must set up a path whereby they can send at least one 
 message in a session. There are two major models for this:
  
 • 
  
 Connection oriented
  
 • 
  
 Connectionless",NA
Connection Oriented,"A single connection is established for the session. Two-way communications flow along the connection. 
 When the session is over, the connection is broken. The analogy is to a phone conversation. An example is 
 TCP.",NA
Connectionless,"In a connectionless system, messages are sent independent of each other. Ordinary mail is the analogy. 
 Connectionless messages may arrive out of order. An example is the IP protocol. UDP is a connectionless 
 protocol above IP and is often used as an alternative to TCP, as it is much lighter weight.
  
 Connection-oriented transports may be established on top of connectionless ones—TCP over IP. 
  
 Connectionless transports may be established on top of connection-oriented ones—HTTP over TCP. 
  
 There can be variations on these. For example, a session might enforce messages arriving, but might not 
 guarantee that they arrive in the order sent. However, these two are the most common.",NA
Communications Models,"In a distributed system there will be many components running that have to communicate with each 
 other. There are two primary models for this, message passing and remote procedure calls.",NA
Message Passing,"Some non-procedural languages are built on the principle of 
 message passing
 . Concurrent languages often 
 use such a mechanism, and the most well known example is probably the UNIX pipeline. The UNIX pipeline 
 is a pipeline of bytes, but this is not an inherent limitation: Microsoft’s PowerShell can send objects along its 
 pipelines, and concurrent languages such as Parlog can send arbitrary logic data structures in messages 
 between concurrent processes.
  
 Message passing is a primitive mechanism for distributed systems. Set up a connection and pump some 
 data down it. At the other end, figure out what the message was and respond to it, possibly sending 
 messages back. This is illustrated in Figure 
 1-4
 .
  
 5",NA
Remote Procedure Call,"In any system, there is a transfer of information and flow control from one part of the system to another. In 
 procedural languages, this may consist of the procedure call, where information is placed on a call stack and 
 then control flow is transferred to another part of the program.
  
 Even with procedure calls, there are variations. The code may be statically linked so that control 
 transfers from one part of the program’s executable code to another part. Due to the increasing use of 
 library routines, it has become commonplace to have such code in dynamic link libraries (DLLs), where 
 control transfers to an independent piece of code.
  
 DLLs run in the same machine as the calling code. it is a simple (conceptual) step to transfer control to 
 a procedure running in a different machine. The mechanics of this are not so simple! However, this model of 
 control has given rise to the remote procedure call (RPC), which is discussed in much detail in a later 
 chapter. This is illustrated by Figure 
 1-5
 .
  
 6",NA
Distributed Computing Models,"At the highest level, we could consider the equivalence or the non-equivalence of components of a 
 distributed system. The most common occurrence is an asymmetric one: a client sends requests to a server, 
 and the server responds. This is a 
 client-server
  system.
  
 If both components are equivalent, both able to initiate and to respond to messages, then we have a 
 peer-to-peer
  system. Note that this is a logical classification: one peer may be a 16,000 core 
 supercomputer, the other might be a mobile phone. But if both can act similarly, then they are peers.
  
 These are illustrated as shown in Figure 
 1-6
 .
  
 client-server 
 A 
 B 
 peer-to-peer 
 A 
 A’ 
 Figure 1-6.
  Client-sever versus peer-to-peer systems
  
 7",NA
Client-Server System,"Another view of a client-server system is shown in Figure 
 1-7
 .
  
 User
  
 Client
  
 request
  
 Server
  
  
 Client
  
 Server
  
 process
  
 response
  
 process
  
 System
  
 System
  
 hardware
  
 hardware
  
 Figure 1-7.
  The client-server system
  
 This view may be held by a developer who needs to know the components of a system. It is also the 
 view that may be held by a user: a user of a browser knows it is running on her system but is communicating 
 with servers elsewhere.",NA
Client-Server Application,"Some applications may be seamlessly distributed, with the user unaware that it is distributed. Users will see 
 their view of the system, as shown in Figure 
 1-8
 .
  
 Client  
 Client  
 process 
 System  
 hardwar
 e 
 Server 
 Application 
 Process 
 System 
 hardware 
 Figure 1-8.
  The user’s view of the system
  
 8",NA
Server Distribution,"A client-server system need not be simple. The basic model is a single client, single server system, as shown 
 in Figure 
 1-9
 .
  
 Client
  
  
 Server
  
  
 Figure 1-9.
  The single client, single server system
  
 However, you can also have multiple clients, single server, as illustrated in Figure 
 1-10
 .
  
 Client
  
 Slave
  
 Master
  
 Slave
  
 Client
  
 Figure 1-10.
  The multiple clients, single server system
  
  
 In this system, the master receives requests and instead of handling them one at a time itself, it 
 passes them to other servers to handle. This is a common model when concurrent clients are possible. 
  
  
 There are also single client, multiple servers, as shown in Figure 
 1-11
 .
  
 Client
  
 Server
  
 Server
  
 Figure 1-11.
  The single client, multiple servers system
  
 This type of system occurs frequently when a server needs to act as a client to other servers, such as a 
 business logic server getting information from a database server. And of course, there could be multiple 
 clients with multiple servers.",NA
Communication Flows,"The previous diagrams have shown the connection views between high-level components of a system. Data 
 will flow between these components and it can do so in multiple ways, discussed in the following sections.
  
 9",NA
Synchronous Communication,"In a synchronous communication, one party will send a message and block, waiting for a reply. This is often 
 the simplest model to implement and is just relies on blocking I/O. However, there may need to be a timeout 
 mechanism in case some error means that no reply will ever be sent.",NA
Asynchronous Communication,"In asynchronous communication, one party sends a message and instead of waiting for a reply carries 
 on with other work. When a reply eventually comes, it is handled. This may be in another thread or by 
 interrupting the current thread. Such applications are harder to build but are much more flexible to 
 use.",NA
Streaming Communication,"In streaming communication, one party sends a continuous stream of messages. Online video is a good 
 example. The streaming may need to be handled in real time, may or may not tolerate losses, and can be 
 one-way or allow reverse communication as in control messages.",NA
Publish/Subscribe,"In pub/sub systems, parties subscribe to topics and others post to them. This can be on a small or massive 
 scale, as demonstrated by Twitter.",NA
Component Distribution,"A simple but effective way of decomposing many applications is to consider them as made up of three parts:
  
 • 
  
 Presentation component
  
 • 
  
 Application logic
  
 • 
  
 Data access
  
 The 
 presentation component
  is responsible for interactions with the user, both displaying data and 
 gathering input. It may be a modern GUI interface with buttons, lists, menus, etc., or an older command-line 
 style interface, asking questions and getting answers. It could also encompass wider interaction styles, such 
 as the interaction with physical devices such as a cash register, ATM, etc. It could also cover the interaction 
 with a non-human user, as in a machine-to-machine system. The details are not important at this level.
  
  
 The 
 application logic
  is responsible for interpreting the users’ responses, for applying business rules, 
 for preparing queries, and for managing responses from the third component.
  
  
 The 
 data access
  component is responsible for storing and retrieving data. This will often be through a 
 database, but not necessarily.
  
 10",NA
Gartner Classification,"Based on this threefold decomposition of applications, Gartner considered how the components might be 
 distributed in a client-server system. They came up with five models, shown in Figure 
 1-12
 .
  
  
 presentation
  
 logic
  
 data
  
  
  
 presentation
  
 logic
  
  
  
 presentation
  
 logic
  
  
  
 presentation
  
  
  
 presentation
  
  
  
 logic
  
 data
  
  
  
 presentation
  
 logic
  
 data
  
  
  
 data
  
  
  
 logic
  
 data
  
  
  
 data
  
  
 distributed
  
 remote
  
 distributed
  
 remote
  
 distributed
  
 data
  
 data
  
 transaction
  
 presentation
  
 presentation
  
 Figure 1-12.
  Gartner’s five models",NA
Example: Distributed Database,"• 
  
 Gartner classification: 1 (see Figure 
 1-13
 )
  
  
 presentatio
 n
  
 logic
  
 data
  
  
 data
  
 Figure 1-13.
  Gartner example 1
  
 Modern mobile phones make good examples of this. Due to limited memory, they may store a small 
 part of a database locally so that they can usually respond quickly. However, if data is required that is 
 not held locally, then a request may be made to a remote database for that additional data.
  
 Google maps is another good example. All of the maps reside on Google’s servers. When one is 
 requested by a user, the “nearby” maps are also downloaded into a small database in the browser. When the 
 user moves the map a little bit, the extra bits required are already in the local store for quick response.
  
 11",NA
Example: Network File Service ,"Gartner classification 2 allows remote clients access to a shared file system, as shown in Figure 
 1-
 14
 .
  
 presentation
  
 logic
  
  
 data
  
 Figure 1-14.
  Gartner example 2
  
 There are many examples of such systems: NFS, Microsoft shares, DCE, etc.",NA
Example: Web ,"An example of Gartner classification 3 is the Web with Java applets or JavaScript, and CGI scripts or similar 
 (Ruby on Rails, etc.) on the server side. This is a distributed hypertext system, with many additional 
 mechanisms, as illustrated in Figure 
 1-15
 .
  
 presentation
  
 logic
  
  
 logic
  
 data
  
 Figure 1-15.
  Gartner example 3",NA
Example: Terminal Emulation ,"An example of Gartner classification 4 is terminal emulation. This allows a remote system to act as a normal 
 terminal on a local system, as shown in Figure 
 1-16
 .
  
 presentation
  
  
 logic
  
 data
  
 Figure 1-16.
  Gartner example 4
  
 Telnet is the most common example of this.
  
 12
  
 www.allitebooks.com",NA
Example: Secure Shell,"The secure shell on UNIX allows you to connect to a remote system, run a command there, and display the 
 presentation locally. The presentation is prepared on the remote machine and displayed locally. Under 
 Windows, remote desktop behaves similarly. See Figure 
 1-17
 .
  
 presentation
  
  
 presentation
  
 logic
  
 data
  
 Figure 1-17.
  Gartner example 4",NA
Three-Tier Models,"Of course, if you have two tiers, then you can have three, four, or more. Some of the three-tier possibilities 
 are shown in Figure 
 1-18
 .
  
  
 data
  
  
  
 data
  
 logic
  
  
  
 data
  
  
  
 data
  
 logic
  
  
  
 logic
  
  
  
 logic
  
  
  
 logic
  
  
  
 data
  
 logic
  
  
  
 presentation
  
  
  
 presentation
  
  
  
 logic
  
 presentation
  
  
  
 data
  
 logic
  
 presentation
  
  
 Figure 1-18.
  Three-tier models
  
 The modern Web is a good example of the rightmost of these. The backend is made up of a database, 
 often running stored procedures to hold some of the database logic. The middle tier is an HTTP server such 
 as Apache running PHP scripts (or Ruby on Rails, or JSP pages, etc.). This will manage some of the logic and 
 will have data such as HTML pages stored locally. The frontend is a browser to display the pages, under the 
 control of some JavaScript. In HTML 5, the frontend may also have a local database.
  
 13",NA
Fat versus Thin,"A common labeling of components is “fat” or “thin”. Fat components take up lots of memory and do complex 
  
 processing. Thin components on the other hand, do little of either. There don't seem to be any “normal” size 
  
 components, only fat or thin!
  
 Fatness or thinness is a relative concept. Browsers are often labeled as thin because all they do is 
 display 
  
 web pages. However, Firefox on my Linux box takes nearly half a gigabyte of memory, which I don't regard 
 as 
  
 small at all!",NA
Middleware Model,"Middleware is the “glue” connecting components of a distributed system. The middleware model is shown 
  
 in Figure 
 1-19
 .
  
 Client processes
  
  
 Server processes
  
 Client 
  
 middleware
  
 Server 
  
 middleware
  
 Exchange 
  
 protocol
  
 network protocol
  
 Local 
  
 services
  
 Network 
 services
  
 Local 
  
 services
  
 Network 
 services
  
 O/S and h/w
  
 O/S and h/w",NA
Middleware Functions,"The functions of middleware can include these:
  
 • 
  
 Initiation of processes at different computers
  
 • 
  
 Session management
  
 • 
  
 Directory services to allow clients to locate servers
  
 • 
  
 Remote data access
  
 • 
  
 Concurrency control to allow servers to handle multiple clients
  
 • 
  
 Security and integrity
  
 • 
  
 Monitoring
  
 • 
  
 Termination of processes, both local and remote",NA
Continuum of Processing,"The Gartner model is based on a breakdown of an application into the components of presentation, 
  
 application logic, and data handling. A finer grained breakdown is illustrated in Figure 
 1-20
 .
  
 TYPE
  
 ACTIVITY
  
 DIVISION
  
 keyboard/mouse input
  
 (Client)
  
 Interactive
  
 Host
  
 screen handling
  
 application
  
 processing
  
 graphics/sound/video control
  
 Intelligent
  
 Application
  
 command/menu/dialog 
 interpretation
  
 terminal
  
 help processing
  
 GUI front ene
  
 data input validation
  
 application
  
 processing
  
 application logic
  
 Client/server
  
 error recovery
  
 Database
  
 transaction construction
  
 transaction
  
 processing
  
 transaction validation
  
 Networked SQL
  
 database access
  
 data base
  
 processing
  
 data management and storage
  
 Filesharing
  
 application
  
 (Server)
  
 Figure 1-20.
  Breakdown of an application into its components of presentation
  
 15",NA
Points of Failure ,"Distributed applications run in a complex environment. This makes them much more prone to failure than 
 standalone applications on a single computer. The points of failure include:
  
 • 
  
 Client-side errors
  
  
  
  
 • 
  
 The client side of the application could crash
  
  
  
  
 • 
  
  
 The client system may have hardware problems
   
  
 • 
  
 The client’s network 
 card could fail
  
 • 
  
 Network errors
  
  
  
 • 
  
 Network contention could cause timeouts
  
  
  
 • 
  
 There may be network address conflicts
  
  
  
 • 
  
 Network elements such as routers could fail
  
  
  
 • 
  
 Transmission errors may lose messages
  
 • 
  
 Client-server errors
  
  
  
 • 
  
 The client and server versions may be 
 incompatible• 
  
 Server errors
  
  
  
 • 
  
 The server’s network card could fail
  
  
  
 • 
  
 The server system may have hardware problems
  
  
 • 
  
 The server software may crash
  
  
  
 • 
  
 The server’s database may become corrupted
  
 Applications have to be designed with these possible failures in mind. Any action performed by one 
 component must be recoverable if failure occurs in some other part of the system. Techniques such as 
 transactions and continuous error checking need to be employed to avoid errors. It should be noted that 
 while a standalone application may have a lot of control over the errors that can occur, that is not the case 
 with distributed systems. For example, the server has no control over network or client errors and can only 
 be prepared to handle them. In many cases, the cause of an error may not be available: did the client crash or 
 did the network go down?",NA
Acceptance Factors ,"The acceptance factors of a distributed system are similar to those of a standalone system. They include the 
 following:
  
 • 
  
 Reliability
  
 • 
  
 Performance
  
 • 
  
  
 Responsiveness• 
  
 Scalability
  
 • 
  
 Capacity
  
 • 
  
 Security
  
 16",NA
Transparency ,"The “holy grails” of distributed systems are to provide the 
 following:• 
  
 Access transparency
  
 • 
  
 Location transparency
  
 • 
  
 Migration transparency
  
 • 
  
 Replication transparency
  
 • 
  
 Concurrency transparency
  
 • 
  
 Scalability transparency
  
 • 
  
 Performance transparency
  
 • 
  
 Failure transparency",NA
Access Transparency ,"The user should not know (or need to know) if access to all or parts of the system are local or 
 remote.",NA
Location Transparency ,The location of a service should not matter.,NA
Migration Transparency ,"If part of the system moves to another location, it should make no difference to a 
 user.",NA
Replication Transparency ,It should not matter if one or multiple copies of the system are running.,NA
Concurrency Transparency ,"There should be no interference between parts of the system running concurrently. For example, if I am 
 accessing the database, then you should not know about it.",NA
Scalability Transparency ,"It shouldn’t matter if one or a million users are on the 
 system.
  
 17",NA
Performance Transparency,Performance should not be affected by any of the system or network characteristics.,NA
Failure Transparency,"The system should not fail. If parts of it fail, the system should recover without the user knowing the 
 failure occurred.
  
 Most of these transparency factors are observed more in the breach than in the observance. There are 
 notable cases where they are almost met. For example, when you connect to Google, you don’t know (or 
 care) where the servers are. Systems using Amazon Web Services are able to scale up or down in response to 
 demand. Netflix has what almost seems cruel testing strategies, regularly and deliberately breaking large 
 sections of its system to ensure that the whole still works.",NA
Eight Fallacies of Distributed Computing,"Sun Microsystems was a company that performed much of the early work in distributed systems, and 
 even had a mantra” “The network is the computer.” Based on their experience over many years, a number 
 of the scientists at Sun came up with the following list of fallacies commonly assumed:
  
 1. 
  
 The network is reliable.
  
 2. 
  
 Latency is zero.
  
 3. 
  
 Bandwidth is infinite.
  
 4. 
  
 The network is secure.
  
 5. 
  
 Topology doesn't change.
  
 6. 
  
 There is one administrator.
  
 7. 
  
 Transport cost is zero.
  
 8. 
  
 The network is homogeneous.",NA
Fallacy:,NA,NA
 The Network Is Reliable,"A paper by Bailis and Kingsbury entitled “The Network is Reliable” (see 
 http://queue.acm.org/detail.
  
 cfm?id=2655736
 ) examines this fallacy. It finds many instances, such as Microsoft reporting on their 
 datacenters giving 5.2 device failures per day and 40.8 link failures per day.
  
 The Chinese government uses “DNS poisoning” as one of its techniques to censor what it considers to be 
 undesirable web sites. China also runs one of the DNS root servers. In 2010, this server was misconfigured 
 and poisoned the DNS servers of many other countries. This made many non-Chinese web sites inaccessible 
 outside of China as well as inside (see 
 http://www.pcworld.com/article/192658/article.html
 ).
  
 There are many other possible cases, such as DDS (distributed denial of service) attacks making web 
 sites unavailable. At Box Hill Institute, a contractor once put a back hoe through the fiber cable connecting 
 our DHCP server to the rest of the network, and so we went home for the rest of the day.
  
 The network is 
 not
  reliable. The implications are that any networked program must be prepared to deal 
 with failure. This led to the design choices of Java's RMI and most later frameworks, with application design 
 allowing for each network call possibly failing.
  
 18",NA
Fallacy:,NA,NA
 Latency Is Zero,"Latency is the delay between sending a signal and getting a reply. In a single-process system, latency can 
 depend on the amount of computation performed in a function call before it can return, but on the network, 
 it is usually caused by simply having to traverse transports and be processed by all sorts of nodes such as 
 routers on the way.
  
  
 The ping command is a good way of showing latency. A ping to Google’s Australia server takes about 
 20 milliseconds from Melbourne. A ping to Baidu's Chinese servers takes about 200 msecs
 1
 .
  
 By contrast, Williams (see 
 http://www.eetimes.com/document.asp?doc_id=1200916
 ) discusses the 
 latency of the Linux scheduler and comes up with a mean latency of 88 
 micro
 seconds. The latency of 
 network calls is thousands of times greater.",NA
Fallacy:,NA,NA
 Bandwidth Is Infinite,"Everyone who goes to make a cup of tea or coffee while a download takes place knows this is a fallacy. I run 
 my own web server, and on ADSL2 get an upload speed of 800 Kbps. I am unfortunate enough to have HFC 
 to my home, and the disastrous Australian National Broadband Network will upgrade this to 1000 Kbps 
 perhaps. In three years time, by 2020.
  
  
 In the meantime, I use a local wireless connection to give me 75 Mbps up and down and it still isn’t fast 
 enough!",NA
Fallacy:,NA,NA
 The Network Is Secure,"There is a strong push by technology companies for strong crypto to be used for all network 
  
 communications, and an equally strong push by governments all over the world for weaker systems or for 
 backdoors “only for particular governments”. This seems to apply equally well to 
 demoncratic
  (my 
 accidental misspelling may be accurate!) as well as totalitarian governments.
  
  
 In addition, of course, there are the general “baddies,” stealing and selling credit card numbers and 
 passwords by the millions.",NA
Fallacy:,NA,NA
 Topology Doesn’t Change,"Well it does. Generally this may affect latency and bandwidth. But the more hard-coding of routes, or of IP 
 addresses, the more prone to failure network applications will become.",NA
Fallacy:,NA,NA
 There Is One Administrator,"So what? No problem when everything is working fine. It’s when it goes wrong that problems start—who 
 to blame, who to fix it?
  
 1
 From my Melbourne, Australia location I see the ping time 
 by ping 
 www.google.com.au 
  
 PING google.com.au (216.58.203.99) 56(84) bytes of data.
  
 64 bytes from syd09s15-in-f3.1e100.net (216.58.203.99): icmp_seq=1 ttl=50 time=27.1 ms 64 
 bytes from syd09s15-in-f3.1e100.net (216.58.203.99): icmp_seq=2 ttl=50 time=19.7 ms
  
 19",NA
Fallacy:,NA,NA
 Transport Cost Is Zero,"Once I've bought my PC, the transport cost from CPU to monitor is zero (well, minor electricity!). But we all 
 pay our IP providers money each month because they have to build server rooms, lay cables, and so on. It's 
 just a cost that has to be factored in.",NA
Fallacy:,NA,NA
 The Network Is Homogeneous,"The network isn't homogenous and neither are the endpoints—your and my PCs, iPads, Android devices, 
 and mobile phones for example. Let alone with the IoT bringing a myriad of connected devices into the 
 picture. There are continual attempts by vendors for product lockin, and continually restrictive work 
 environments trying to simplify their control systems, which succeed to some extent. But when they fail, 
 systems dependent on homogeneity fail too.",NA
Conclusion,"This chapter has tried to emphasize that distributed computing has its own unique features compared to 
 other styles of computing. Ignoring these features can only lead to failure of the resultant systems. There are 
 continual attempts to simplify the architectural model, with the latest being “microservices” and “serverless” 
 computing, but in the end the complexities still remain.
  
  
 These have to be addressed using any programming language, and subsequent chapters consider how 
 Go manages them.
  
 20",NA
CHAPTER 2,NA,NA
Overview of the Go Language,"There is a continual stream of programming languages being invented. Some are highly specialized, others 
 are quite generic, while a third group is designed to fill broad but to some extent niche areas. Go was created 
 in 2007 and released publically in 2009. It was intended to be a systems programming language, augmenting 
 (or replacing) C++ and other statically compiled languages for production network and multiprocessing 
 systems.
  
 Go joins a group of modern languages including Rust, Swift, Julia, and several others. Go’s particular features 
 are a simple syntax, fast compilation of multiple program units, a form of O/O programming based on 
 “structural” typing, and of course the benefit of lessons learned from large-scale programs in C, C++, and 
 Java.
  
 The language popularity listings in early 2017 such as TIOBE (see 
 http://www.tiobe.com/tiobe-index/
 ) 
 rank Go as currently the 14th most popular language. PYPL (see 
 http://pypl.github.io/PYPL.html
 ) places it 
 at number 19. This is alongside the 20+ year old languages of Java, Python, C, C++, JavaScript, and more.
  
 This book assumes you are an experienced programmer with some or extensive knowledge of Go at 
 some level. This could be by an introductory text such as 
 Introducing Go
  by Caleb Doxsey (O’Reilly) or 
 The 
 Little Go Book
  by Karl Seguin, or by reading the more formal documentation such as The Go Programming 
 Language Specification at 
 https://golang.org/ref/spec
 .
  
 If you are an experienced programmer, you can skip this chapter. If not, this chapter points out the 
 bits of Go that are used in this book, but you should go elsewhere to get the necessary background. There 
 are several tutorials on the Go web site at 
 http://golang.org
 :
  
 • 
  
 Getting started
  
 • 
  
 A tutorial for the Go programming language
  
 • 
  
 Effective Go
  
 • 
  
 GoLang tutorials
  
 Installing Go is best done from the Go programing language web site. At the time of writing, Go 1.8 has 
 just been released. Most of the examples in this book will run using Go 1.6, with a few pointers to Go 1.8. You 
 don’t actually need to install Go to test the programs: Go has a “playground” accessible from the main page 
 which can be used to run code. There are also several REPL (Read–Eval–Print Loop) environments, but these 
 are third party.
  
 The book predominantly uses libraries and packages from the Go Standard Library (
 https://golang.
  
 org/pkg/
 ). The Go team also built a further set of packages as “sub-repositories,” which often do not have 
 the same support as the Standard Library. These are occasionally used. They will need to be installed using 
 the go get command. These have package names including an “x,” such as golang.org/x/net/ipv4.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_2
  
 21",NA
Types,"There are pre-defined types of Boolean, numeric, and string types. The numeric types include uint32, 
 int32, float32, and other sized numbers, as well as bytes (uint8) and runes. Runes and strings are dealt 
 with extensively in Chapter 
 7
 , as issues of internationalization can be significant in distributed 
 programs. 
  
 There are more complex types, discussed next.",NA
Slices and Arrays,"Arrays are sequences of elements of a single type. Slices are segments of an underlying array. Slices are 
 often more convenient to deal with in Go. An array can be created statically:
  
 var x [128]int
  
 Or dynamically as a pointer:
  
 xp := new([128]int)
  
 A slice may be created along with its underlying array:
  
 x := make([]int, 50, 100)
  
 or
  
 x := new([100]int)[0:50]
  
 These last two are both of type []int (as shown by reflect.TypeOf(x)). 
 Elements of an array or slice are accessed by their index:
  
 x[1]
  
 The indices are from 0 to len(x)-1.
  
  
 A slice may be taken of an array or slice by using the lower (inclusive) and upper (exclusive) indices 
 of the array or slice:
  
 a := [5]int{-1, -2, -3, -4, -5} 
  
 s := a[1:4]  // s is now [-2, -3, -4]",NA
Structures,"Structures are similar to those in other languages. In Chapter 
 4
 , we consider serialization of data and use 
 the example of the following structs:
  
 type Person struct {
  
  
  Name  Name
  
  
  Email []Email 
  
 }
  
 22",NA
Pointers,"Pointers behave similarly to pointers in other languages. The * operator dereferences a pointer, while the 
 & operator takes the address of a variable. Go simplifies the use of pointers so that most of the time you 
 don’t have to worry about them. The most we do in this book is check if a pointer value is nil, which will 
 usually signify an error, or conversely, if a possible error value is not nil, as described in the next section.",NA
Functions,"Functions are defined using a notation unique to Go. Why the familiar C syntax (or any other for that 
 matter) is not used is explained in the Go’s Declaration Syntax blog (see 
 https://blog.golang.org/ gos-
 declaration-syntax
 ). We leave it to the textbooks to explain the details of the syntax.
  
 Every Go program must have a main function declared as follows:
  
 func main() { ... }
  
 We will frequently use a function checkError defined as follows:
  
 func checkError(err error) {
  
  
  if err != nil {
  
  
  
  fmt.Fprintf(os.Stderr, ""Fatal error: %s"", err.Error())
  
  
  os.Exit(1)
  
  
  } 
  
 }
  
  
 It takes one parameter and has no return value. It starts with a lowercase letter, so it is local to 
 the package in which it is declared.
  
 23",NA
Maps,"A 
 map
  is an unordered group of elements of one type, indexed by a key of another type. We do not use maps 
 much in this book, although one place is in Chapter 
 10
 , where the values of fields of an HTTP request may be 
 accessed through a map using the field name as key.",NA
Methods,"Go does not have classes in the sense that languages like Java do. However, 
 types
  can have 
 methods 
 associated with them, and these act similar to methods of more standard O/O languages.
  
  
 We will make heavy use of the methods defined for the various networking types. This will happen from 
 the very first programs of the next chapter. For example, the type IPMask is defined as an array of bytes:
  
 type IPMask []byte
  
 A number of functions are defined on this type, such as:
  
 func (m IPMask) Size() (ones, bits int)
  
 A variable of type IPMask can have the method Size() applied, as follows:
  
 var m IPMask 
  
 ...
  
 ones, bits := m.Size()
  
 Learning how to use methods of the network-related types is a principal aim of this book.
  
 We won’t be defining our own methods much in this book. That’s because to illustrate the Go libraries 
 we don’t need many of our own complex types. A typical use will be pretty-printing a type like the Person 
 type defined previously:
  
 func (p Person) String() string {
  
  
  s := p.Name.Personal + "" "" + p.Name.Family
  
  for _, v 
 := range p.Email {
  
  
  
  s += ""\n"" + v.Kind + "": "" + v.Address
  
  }
  
  
  return s 
  
 }
  
  
 There is more extensive use in Chapter 
 10
 , where a number of types and methods on these types, 
 are used. This is because we 
 do
  need our own types when we are building more realistic systems.
  
 24",NA
Multi-Threading,"Go has a simple mechanism for starting additional threads using the go command. In this book, that is all we 
 will need. Complex tasks such as synchronizing multiple threads are not needed here.",NA
Packages,"Go programs are built from linked packages. The packages used by any block of code have to be imported, 
 by an import statement at the head of the code file. Our own programs are declared to be in package main. 
  
 Apart from Chapter 
 10
  again, nearly all of the programs in this book are in the main package.
  
  
 Most packages are imported from the Standard Library. Some are imported from the sub-repositories 
 such as golang.org/x/net/ipv4.",NA
Type Conversion,"The only one we need to worry about in this book is conversion of strings to byte arrays and vice 
 versa. To convert a string to a byte array, you do:
  
 var b []byte 
  
 b = []byte(""string"")
  
 To convert the whole of an array/slice to a string, use this:
  
 var s string 
  
 s = string(b[:])",NA
Statements,"A function or method will be composed of a set of statements. These include assignments, if and switch 
 statements, for and while loops, and several others.
  
  
 Apart from syntax, these have essentially the same meaning as in other programming languages. Nearly 
 all of the statements types will be used in later chapters.",NA
GOPATH,"There are two ways of organizing workspaces for projects: put every project in a shared workspace or 
 have a separate workspace for each project. My preference is for the second, whereas apparently the 
 preference by most Go programmers is for the first.
  
 Either way is supported by the go tool by the environment variable GOPATH. This can be set to a list of 
 directories (a : separated list in Linux/UNIX a ; separated list on Windows, and a list on Plan9). It defaults to 
 the directory go in the user’s home directory if it’s unset.
  
 For each directory in GOPATH, there will be three sub-directories—src, pkg, and bin. The directory 
 src will typically contain one directory per package name, and under that will be the source files for that 
 package. For example, in Chapter 
 10
  we have a complete web server that uses packages we define of 
 dictionary and flashcards. The src/flashcards directory contains the file FlashCards.go.
  
 25",NA
Running Go Programs,"A Go program must have a file defining the package main. Most of the programs in this book are defined 
 in a single file, such as the program IP.go in Chapter 
 3
 . The simplest way to run it is from the directory 
 containing the file:
  
 go run IP.go <IP address>
  
 Alternatively, you can build an executable and then run it:
  
 go build IP.go 
  
 ./IP <IP address>
  
  
 Programs that require packages other than the standard ones will require GOPATH to be set. For 
 example, the programs in Chapter 
 10
  require (under Linux):
  
 export GOPATH=$PWD 
  
 go run Server.go <port>",NA
Standard Libraries,"Go has an extensive set of Standard Libraries. Not as large as C, Java, or C++, for example, but those 
 languages have been around for a 
 long
  time. The Go packages are documented at 
 https://golang.org/pkg/ 
 We will use these extensively in this book, particularly the net, crypto, and encoding packages.
  
  
 In addition, there is a sub-repositories group of packages available from the same page. These are less 
 stable, but sometimes have useful packages, which we will use occasionally.
  
 As well as these, there is a large set of user-contributed packages. They will not be used in the body of 
 this book which deals with principles, but in practice you may find many of them very useful. Some are 
 discussed in the concluding chapter.",NA
Error Values,"We discussed in the last chapter that a major difference between distributed and local programming is the 
 greatly increased likelihood of errors occurring during execution. A local function call may fail because of 
 simple programming errors such as divide by zero; more subtle errors may occur such as out-of-memory 
 errors, but their possible occurrences are generally predictable.
  
 On the other hand, almost any function that utilizes the network can fail for reasons beyond the 
 application’s control. Networking programs are consequently riddled with error checks. This is tedious, but 
 necessary. Just like operating system kernel code is always error checking—errors need to be managed.
  
  
 In this book, we generally exit a program with errors with appropriate messages on the client side, and 
 for servers, attempt to recover by dropping the offending connection and carrying on.
  
 26",NA
Conclusion,"This book assumes a knowledge of the Go programming language. This chapter just highlighted those parts 
 that will be needed for later chapters.
  
 27",NA
CHAPTER 3,NA,NA
Socket-Level Programming,"There are many kinds of networks in the world. These range from the very old networks, such as serial 
 links, through to wide area networks made from copper and fiber, to wireless networks of various kinds, 
 both for computers and for telecommunications devices such as phones. These networks obviously differ at 
 the physical link layer, but in many cases they also differ at higher layers of the OSI stack.
  
 Over the years there has been a convergence to the “Internet stack” of IP and TCP/UDP. For example, 
 Bluetooth defines physical layers and protocol layers, but on top of that is an IP stack so that the same 
 Internet programming techniques can be employed on many Bluetooth devices. Similarly, developing 
 Internet of Things (IoT) wireless technologies such as LoRaWAN and 6LoWPAN include an IP stack.
  
  
 While IP provides the networking layer 3 of the OSI stack, TCP and UDP deal with layer 4. These are 
 not the final word, even in the Internet world: SCTP (Stream Control Transmission Protocol) has come 
 from the telecommunications world to challenge both TCP and UDP, while to provide Internet services in 
 interplanetary space requires new, under development protocols such as DTN (Delay Tolerant 
 Networking). Nevertheless, IP, TCP, and UDP hold sway as principal networking technologies now and at 
 least for a considerable time into the future. Go has full support for this style of programming 
  
  
 This chapter shows how to do TCP and UDP programming using Go, and how to use a raw socket for 
 other protocols.",NA
The TCP/IP Stack,"The OSI model was devised using a committee process wherein the standard was set up and then 
 implemented. Some parts of the OSI standard are obscure, some parts cannot easily be implemented, and 
 some parts have not been implemented.
  
 The TCP/IP protocol was devised through a long-running DARPA project. This worked by 
 implementation followed by RFCs (Request for Comments). TCP/IP is the principal UNIX networking 
 protocol. TCP/IP stands for Transmission Control Protocol/Internet Protocol.
  
 The TCP/IP stack is shorter than the OSI one, as shown in Figure 
 3-1
 .
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_3
  
 29",NA
IP Datagrams,"The IP layer provides a connectionless and unreliable delivery system. It considers each datagram 
 independently of the others. Any association between datagrams must be supplied by the higher layers.
  
  
 The IP layer supplies a checksum that includes its own header. The header includes the source and 
 destination addresses.
  
  
 The IP layer handles routing through an internet. It is also responsible for breaking up large datagrams 
 into smaller ones for transmission and reassembling them at the other end.",NA
UDP,"UDP is also connectionless and unreliable. What it adds to IP is a checksum for the contents of the datagram 
 and 
 port numbers.
  These are used to give a client-server model, which you’ll see later.",NA
TCP,"TCP supplies logic to give a reliable connection-oriented protocol above IP. It provides a 
 virtual circuit
  
 that two processes can use to communicate. It also uses port numbers to identify services on a host.",NA
Internet Addresses,"In order to use a service, you must be able to find it. The Internet uses an address scheme for devices such 
 as computers so that they can be located. This addressing scheme was originally devised when there were 
 only a handful of connected computers, and very generously allowed up to 2^32 addresses, using a 32-bit 
 unsigned integer. These are the so-called IPv4 addresses. In recent years, the number of connected 
  
 30",NA
IPv4 Addresses,"The address is a 32-bit integer that gives the IP address. This addresses down to a network interface card 
 on a single device. The address is usually written as four bytes in decimal with a dot . between them, as in 
 127.0.0.1 or 66.102.11.104.
  
 The IP address of any device is generally composed of two parts: the address of the network in which 
 the device resides, and the address of the device within that network. Once upon a time, the split between 
 network address and internal address was simple and was based on the bytes used in the IP address.
  
 • 
  
 In a class A network, the first byte identifies the network, while the last three identify 
  
 the device. There are only 128 class A networks, owned by the very early players in 
  
 the Internet space such as IBM, the General Electric Company, and MIT
 1
 .
  
 • 
  
 Class B networks use the first two bytes to identify the network and the last two to 
  
 identify devices within the subnet. This allows up to 2^16 (65,536) devices on a 
 subnet.
  
 • 
  
 Class C networks use the first three bytes to identify the network and the last one 
 to 
  
 identify devices within that network. This allows up to 2^8 (actually 254, not 256, 
 as 
  
 the bottom and top addresses are reserved) devices.
  
 This scheme doesn’t work well if you want, say, 400 computers on a network. 254 is too small, while 
 65,536 (-2) is too large. In binary arithmetic terms, you want about 512 (-2). This can be achieved by using a 
 23-bit network address and 9 bits for the device addresses. Similarly, if you want up to 1024 (-2) devices, 
 you use a 22-bit network address and a 10-bit device address.
  
 Given an IP address of a device and knowing how many bits N are used for the network address gives 
 a relatively straightforward process for extracting the network address and the device address within that 
 network. Form a “network mask” which is a 32-bit binary number with all ones in the first N places and all 
 zeroes in the remaining ones. For example, if 16 bits are used for the network address, the mask is 
 1111111 1111111110000000000000000. It’s a little inconvenient using binary, so decimal bytes are 
 usually used. The netmask for 16-bit network addresses is 255.255.0.0, for 24-bit network addresses it is 
 255.255.255.0, while for 23-bit addresses it would be 255.255.254.0 and for 22-bit addresses it would be 
 255.255.252.0.
  
 Then to find the network of a device, bit-wise AND its IP address with the network mask, while 
 the device address within the subnet is found with bit-wise AND of the one’s complement of the 
 mask with the IP address. For example, the binary value of the IP address 192.168.1.3 is 
 1100000010101 0000000000100000011 (using the 
 IP Address Subnet Mask Calculator
 ). If a 16-bit 
 netmask is used, the network is 1100000010101000 0000000000000000 (or 192.168.0.0), while 
 the device address is 0000000000000000  0000000100000011 (or 0.0.1.3).",NA
IPv6 Addresses,"The Internet has grown vastly beyond original expectations. The initially generous 32-bit addressing scheme 
 is on the verge of running out. There are unpleasant workarounds such as NAT (Network Address 
 Translation) addressing, but eventually we will have to switch to a wider address space. IPv6 uses 128-bit 
 addresses. Even bytes becomes cumbersome to express such addresses, so hexadecimal digits are used, 
 grouped into four digits and separated by a colon :. A typical address might be 
 FE80:CD00:0000:0CDE:1257:0000:211E:729C.
  
 1
 Recently MIT have returned their class A network to the pool. 
 http://www.iana.org/assignments/ipv4-address-
 space/ipv4-address-space.xml
 .",NA
IP Address Type,"Finally we can start using some of the Go language network packages. The package net defines many types, 
 functions, and methods of use in Go network programming. The type IP is defined as an array of bytes:
  
 type IP []byte
  
 There are several functions to manipulate a variable of type IP, but you are likely to use only some of 
 them in practice. For example, the function ParseIP(String) will take a dotted IPv4 address or a colon IPv6 
 address, while the IP method String() will return a string. Note that you may not get back what you started 
 with: the string form of 0:0:0:0:0:0:0:1 is ::1.
  
 A program that illustrates this process is IP.go:
  
 /* IP
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Fprintf(os.Stderr, ""Usage: %s ip-addr\n"", os.Args[0])
   
  
 os.Exit(1)
  
  
  }
  
  
  name := os.Args[1]
  
  
  addr := net.ParseIP(name)
  
  
  if addr == nil {
  
  
  
  fmt.Println(""Invalid address"")
  
  
  } else {
  
  
  
  fmt.Println(""The address is "", addr.String())
  
  }
  
  
  os.Exit(0) 
  
 }
  
 32",NA
The IPMask Type ,"An IP address is typically divided into the components of a network address, a subnet, and a device portion. 
 The network address and subnet form a 
 prefix
  to the device portion. The mask is an IP address of all binary 
 ones to match the prefix length, followed by all zeroes.
  
  
 In order to handle masking operations, you use this type: 
  
 type IPMask []byte 
  
  
 The simplest function to create a netmask uses the CIDR notation of ones followed by zeroes up to the 
 number of bits: 
  
 func CIDRMask(ones, bits int) IPMask 
  
  
 A mask can then be used by a method of an IP address to find the network for that IP address: func (ip 
 IP) Mask(mask IPMask) IP 
  
  
 An example of the use of this is the following program called Mask.go: 
  
 /* Mask
  
  */ 
  
 package main 
  
 import (
  
  
  
  ""fmt""
  
  
  
  ""net""
  
  
  
  ""os""
  
  
  
  ""strconv"" 
  
 )
  
 33
  
 www.allitebooks.com",NA
The IPAddr Type,"Many of the other functions and methods in the net package return a pointer to an IPAddr. This is simply a 
 structure containing an IP (and a zone which may be needed for IPv6 addresses).
  
 type IPAddr {
  
  
  IP IP
  
  
  Zone string 
  
 }
  
  
 A primary use of this type is to perform DNS lookups on IP hostnames. The zone may be needed for 
 ambiguous IPv6 addresses with multiple network interfaces.
  
 func ResolveIPAddr(net, addr string) (*IPAddr, error)
  
 Where net is one of ip, ip4, or ip6. This is shown in the program called ResolveIP.go:
  
 /* ResolveIP
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Fprintf(os.Stderr, ""Usage: %s hostname\n"", os.Args[0])
  
  
  fmt.Println(""Usage: "", os.Args[0], ""hostname"")
  
  
  
  os.Exit(1)
  
  
  }
  
  
  name := os.Args[1]
  
  addr, err := net.ResolveIPAddr(""ip"", name)
  
  if err != nil {
  
  
  fmt.Println(""Resolution error"", err.Error())
  
  
 os.Exit(1)
  
  }
  
 36",NA
Host Lookup ,"The ResolveIPAddr function will perform a DNS lookup on a hostname and return a single IP address. How 
 it does this depends on the operating system and its configuration. For example, a Linux/UNIX system may 
 use /etc/resolv.conf or /etc/hosts with the order of the search set in /etc/nsswitch.conf.
  
  
 Some hosts may have multiple IP addresses, usually from multiple network interface cards. They may 
 also have multiple hostnames, acting as aliases. The LookupHost function will return a slice of addresses.
  
 func LookupHost(name string) (cname string, addrs []string, err error) 
  
  
 One of these addresses will be labeled as the “canonical” hostname. If you want to find the canonical 
 name, use this: 
  
 func LookupCNAME(name string) (cname string, err error).
  
  
 For 
 www.google.com
 , it prints both the IPv4 and IPv6 addresses: 
  
 172.217.25.164 
  
 2404:6800:4006:806::2004 
  
  
 This is shown in the following program called LookupHost.go: 
  
 /* LookupHost
  
  */ 
  
 package main 
  
 import (
  
  
  
  ""fmt""
  
  
  
  ""net""
  
  
  
  ""os"" 
  
 ) 
  
  
  
  
 37",NA
Services,"Services run on host machines. They are typically long lived and are designed to wait for requests and 
 respond to them. There are many types of services, and there are many ways in which they can offer their 
 services to clients. The Internet world bases many of these services on two methods of communication—
 TCP and UDP—although there are other communication protocols such as SCTP waiting in the wings to take 
 over. Many other types of service, such as peer-to-peer, remote procedure calls, communicating agents, and 
 many others, are built on top of TCP and UDP.",NA
Ports,"Services live on host machines. We can locate a host using a IP address. But on each computer may be many 
 services, and a simple way is needed to distinguish between them. The method used by TCP, UDP, SCTP, and 
 others is to use a 
 port number
 . This is an unsigned integer between 1 and 65,535 and each service will 
 associate itself with one or more of these port numbers.
  
 There are many “standard” ports. Telnet typically uses port 23 with the TCP protocol. DNS uses port 53, 
 either with TCP or with UDP. FTP uses ports 21 and 20, one for commands, the other for data transfer. HTTP 
 usually uses port 80, but it often uses ports 8000, 8080, and 8088, all with TCP. The X Window System often 
 takes ports 6000-6007, both on TCP and UDP.
  
  
 On a UNIX system, the commonly used ports are listed in the file /etc/services. Go has a function to 
 look up ports on all systems:
  
 func LookupPort(network, service string) (port int, err error)
  
 38",NA
The TCPAddr Type,"The TCPAddr type is a structure containing an IP, a port, and a zone. The zone is required to distinguish 
 between possible ambiguous IPv6 link-local and site-local addresses, as different network interface cards 
 (NICs) may have the same IPv6 address.
  
 type TCPAddr struct {
  
  
  IP   IP
  
  
  Port int
  
  
  Zone string 
  
 }
  
 39",NA
TCP Sockets,"When you know how to reach a service via its network and port IDs, what then? If you are a client, you 
 need an API that will allow you to connect to a service and then to send messages to that service and read 
 replies back from the service.
  
  
 If you are a server, you need to be able to bind to a port and listen at it. When a message comes in, 
 you need to be able to read it and write back to the client.
  
  
 The net.TCPConn is the Go type that allows full duplex communication between the client and the 
 server. Two major methods of interest are as follows:
  
 func (c *TCPConn) Write(b []byte) (n int, err error) func (c 
 *TCPConn) Read(b []byte) (n int, err error) 
  
 A TCPConn is used by both a client and a server to read and write messages.
  
  
 Note that a TCPConn implements the io.Reader and io.Writer interfaces so that any method using a 
 reader or writer can be applied to a TCPConn.",NA
TCP Client,"Once a client has established a TCP address for a service, it “dials” the service. If successful, the dial 
 returns a TCPConn for communication. The client and the server exchange messages on this. Typically a 
 client writes a request to the server using the TCPConn and reads a response from the TCPConn. This 
 continues until either (or both) side closes the connection. A TCP connection is established by the client 
 using this function:
  
 func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error)
  
 Where laddr is the local address, which is usually set to nil, and raddr is the remote address of the 
 service. The net string is one of ""tcp4"", ""tcp6"", or ""tcp"", depending on whether you want a TCPv4 
 connection, a TCPv6 connection, or don’t care.
  
  
 A simple example can be provided by a client to a web (HTTP) server. We will deal in substantially 
 more detail with HTTP clients and servers in a later chapter, so for now we will keep it simple.
  
 One of the possible messages that a client can send is the HEAD message. This queries a server for 
 information about the server and a document on that server. The server returns information, but does not 
 return the document itself. The request sent to query an HTTP server could be as follows:
  
 ""HEAD / HTTP/1.0\r\n\r\n""
  
 40",NA
A Daytime Server,"About the simplest service that we can build is the daytime service. This is a standard Internet service, 
 defined by RFC 867, with a default port of 13, on both TCP and UDP. Unfortunately, with the (justified) 
 increase in paranoia over security, hardly any sites run a daytime server any more. Never mind; we can 
 build our own. (For those interested, if you install inetd on your system, you usually get a daytime server 
 thrown in.) 
  
  
 A server registers itself on a port and listens on that port. Then it blocks on an “accept” operation, 
 waiting for clients to connect. When a client connects, the accept call returns, with a connection object. The 
 daytime service is very simple and just writes the current time to the client, closes the connection, and 
 resumes waiting for the next client.
  
 The relevant calls are as follows:
  
 func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err error) func (l 
 *TCPListener) Accept() (c Conn, err error)
  
 42",NA
Multi-Threaded Server,"echo is another simple IETF service. The SimpleEchoServer.go program just reads what the client types and 
 sends it back:
  
 /* SimpleEchoServer
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  service := "":1201""
  
  tcpAddr, err := net.ResolveTCPAddr(""tcp4"", service) 
 checkError(err)
  
  listener, err := net.ListenTCP(""tcp"", tcpAddr) 
 checkError(err)
  
  
  for {
  
  
  
  conn, err := listener.Accept()
  
  
  
  if err != nil {
  
  
  
  
  continue
  
  
  
  }
  
  
  
  handleClient(conn)
  
  
  
  conn.Close() // we're finished
  
  
  } 
  
 }
  
 44",NA
Controlling TCP Connections,NA,NA
Timeout,"The server may want to time out a client if it does not respond quickly enough, i.e., does not write a request 
 to the server in time. This should be a long period (several minutes), because the users may be taking their 
 time. 
  
 Conversely, the client may want to time out the server (after a much shorter time). Both do this as follows:
  
 func (c *IPConn) SetDeadline(t time.Time) error
  
 This is done before any reads or writes on the socket.",NA
Staying Alive,"A client may want to stay connected to a server even if it has nothing to send. It can use this:
  
 func (c *TCPConn) SetKeepAlive(keepalive bool) error
  
 There are several other connection control methods, which are documented in the net package.
  
 46",NA
UDP Datagrams,"In a connectionless protocol, each message contains information about its origin and destination. There is 
 no “session” established using a long-lived socket. UDP clients and servers make use of datagrams, which 
 are individual messages containing source and destination information. There is no state maintained by 
 these messages, unless the client or server does so. The messages are not guaranteed to arrive, or may 
 arrive out of order.
  
 The most common situation for a client is to send a message and hope that a reply arrives. The most 
 common situation for a server is to receive a message and then send one or more replies back to that client. 
 In a peer-to-peer situation, though, the server may just forward messages to other peers.
  
  
 The major difference between TCP and UDP handling for Go is how to deal with packets arriving from 
 multiple clients, without the cushion of a TCP session to manage things. The major calls needed are as 
 follows:
  
 func ResolveUDPAddr(net, addr string) (*UDPAddr, error) 
  
 func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error) func 
 ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err error) func (c *UDPConn) 
 ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error func (c *UDPConn) 
 WriteToUDP(b []byte, addr *UDPAddr) (n int, err error)
  
  
 The client for a UDP time service doesn’t need to make many changes; just change the ...TCP... calls to 
 ...UDP... calls in the program UDPDaytimeClient.go:
  
 /* UDPDaytimeClient
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Fprintf(os.Stderr, ""Usage: %s host:port"", os.Args[0])
   
  
 os.Exit(1)
  
  
  }
  
  
  service := os.Args[1]
  
  udpAddr, err := net.ResolveUDPAddr(""udp"", service) 
 checkError(err)
  
  conn, err := net.DialUDP(""udp"", nil, udpAddr)
  
  checkError(err)
  
  _, err = conn.Write([]byte(""anything""))
  
  checkError(err)
  
 47",NA
Server Listening on Multiple Sockets,"A server may be attempting to listen to multiple clients not just on one port, but on many. In this case, it has 
 to use some sort of polling mechanism between the ports.
  
  
 In C, the select() call lets the kernel do this work. The call takes a number of file descriptors. The 
 process is suspended. When I/O is ready on one of these, a wakeup is done, and the process can continue. 
  
 This is cheaper than busy polling. In Go, you can accomplish the same by using a different go routine for 
 each port. A thread will become runnable when the lower-level select() discovers that I/O is ready for this 
 thread.",NA
"The Conn, PacketConn, and Listener Types","So far we have differentiated between the API for TCP and the API for UDP, using for example DialTCP and 
 DialUDP returning a TCPConn and UDPConn, respectively. The Conn type is an interface and both TCPConn 
 and UDPConn implement this interface. To a large extent, you can deal with this interface rather than the 
 two types.
  
 Instead of separate dial functions for TCP and UDP, you can use a single function:
  
 func Dial(net, laddr, raddr string) (c Conn, err error)
  
 The net can be any of tcp, tcp4 (IPv4-only), tcp6 (IPv6-only), udp, udp4 (IPv4-only), udp6 (IPv6-only), 
 ip, ip4 (IPv4-only), and ip6 IPv6-only) and several UNIX-specific ones such as unix for UNIX sockets. It will 
 return an appropriate implementation of the Conn interface. Note that this function takes a string rather 
 than address as the raddr argument, so that programs using this can avoid working out the address type 
 first.
  
 49",NA
Raw Sockets and the IPConn Type,"This section covers advanced material that most programmers are unlikely to need. it deals with 
 raw 
 sockets
 , which allow programmers to build their own IP protocols, or use protocols other than TCP or UDP.
  
 52",NA
Conclusion,"This chapter considered programming at the IP, TCP, and UDP levels. This is often necessary if you want to 
 implement your own protocol or build a client or server for an existing protocol.
  
 55",NA
CHAPTER 4,NA,NA
Data Serialization,"A client and server need to exchange information via messages. TCP and UDP provide the transport 
 mechanisms to do this. The two processes also need to have a protocol in place so that message exchange 
 can take place meaningfully.
  
 Messages are sent across the network as a sequence of bytes, which has no structure except as a 
 linear stream of bytes. We address the various possibilities for messages and the protocols that define 
 them in the next chapter. In this chapter, we concentrate on a component of messages—the data that is 
 transferred.
  
 A program will typically build complex data structures to hold the current program state. In conversing 
 with a remote client or service, the program will be attempting to transfer such data structures across the 
 network—that is, outside of the application’s own address space.",NA
Structured Data,"Programming languages use structured data such as the following:
  
 • 
  
 Records/structures
  
 • 
  
 Variant records
  
 • 
  
 Array: Fixed size or varying
  
 • 
  
 String: Fixed size or varying
  
 • 
  
 Tables: Arrays of records
  
 • 
  
 Non-linear structures such as
  
 • 
  
 Circular linked lists
  
 • 
  
 Binary trees
  
 • 
  
 Objects with references to other objects
  
 None of the IP, TCP, or UDP packets know the meaning of any of these data types. All that they can 
 contain is a sequence of bytes. Thus an application has to 
 serialize
  any data into a stream of bytes in order 
 to write it, and deserialize the stream of bytes back into suitable data structures on reading it. These two 
 operations are known as 
 marshalling
  and 
 unmarshalling,
  respectively
 1
 .
  
 1
 I’m treating serialization and marshalling as synonomous. There are a variety of opinions on this, some 
 more language-specific than others. See, for example, “
 What is the difference between Serialization and 
 Marshaling?
 ”
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_4
  
 57",NA
Mutual Agreement,"The previous section gave an overview of the issue of data serialization. In practice, the details can be 
 considerably more complex. For example, consider the first possibility, marshalling a table into the 
 stream:
  
 3 
  
 4 fred 
  
 10 programmer 
  
 6 liping 
  
 7 analyst 
  
 8 sureerat 
  
 7 manager
  
 Many questions arise. For example, how many rows are possible for the table—that is, how big an 
 integer do we need to describe the row size? If it is 255 or less, then a single byte will do, but if it is more, 
 then a short, integer, or long may be needed. A similar problem occurs for the length of each string. With the 
 characters themselves, to which character set do they belong? 7-bit ASCII? 16-bit Unicode? The question of 
 character sets is discussed at length in a later chapter.
  
 This serialization is 
 opaque
  or 
 implicit
 . If data is marshalled using this format, then there is nothing in 
 the serialized data to say how it should be unmarshalled. The unmarshalling side has to know exactly how 
 the data is serialized in order to unmarshal it correctly. For example, if the number of rows is marshalled as 
 an 8-bit integer, but unmarshalled as a 16-bit integer, then an incorrect result will occur as the receiver tries 
 to unmarshal 3 and 4 as a 16-bit integer, and the receiving program will almost certainly fail later.
  
 An early well-known serialization method is XDR (external data representation) used by Sun’s RPC, 
 later known as ONC (Open Network Computing). XDR is defined by RFC 1832 and it is instructive to see 
 how precise this specification is. Even so, XDR is inherently type-unsafe as serialized data contains no type 
 information. The correctness of its use in ONC is ensured primarily by compilers generating code for both 
 marshalling and unmarshalling.
  
  
 Go contains no explicit support for marshalling or unmarshalling opaque serialized data. The RPC 
 package in Go does not use XDR, but instead uses 
 Gob
  serialization, described later in this chapter.",NA
Self-Describing Data,"Self-describing data carries type information along with the data. For example, the previous data might 
 get encoded as follows:
  
 table
  
  
  uint8 3
  
  
  uint 2 
  
 string
  
  
  uint8 4
  
  
  []byte fred 
  
 string
  
  
  uint8 10
  
  
  []byte programmer 
  
 string
  
  
  uint8 6
  
  
  []byte liping
  
 59",NA
ASN.1,"Abstract Syntax Notation One (ASN.1) was originally designed in 1984 for the telecommunications industry. 
  
 ASN.1 is a complex standard, and a subset of it is supported by Go in the package asn1. It builds self-
 describing serialized data from complex data structures. Its primary use in current networking systems is as 
 the encoding for X.509 certificates, which are heavily used in authentication systems. The support in Go is 
 based on what is needed to read and write X.509 certificates.
  
 Two functions allow us to marshal and unmarshal data:
  
 func Marshal(val interface{}) ([]byte, error) 
  
 func Unmarshal(val interface{}, b []byte) (rest []byte, err error)
  
 The first marshals a data value into a serialized byte array, and the second unmarshals it. However, the 
 first argument of type interface deserves further examination. Given a variable of a type, we can marshal it 
 by just passing its value. To unmarshal it, we need a variable of a named type that will match the serialized 
 data. The precise details of this are discussed later. But we also need to make sure that the variable is 
 allocated to memory for that type, so that there is actually existing memory for the unmarshalling to write 
 values into.
  
 We illustrate with an almost trivial example in ASN1.go of marshalling and unmarshalling an integer. 
 We can pass an integer value to marshal to return a byte array, and unmarshal the array into an integer 
 variable, as in this program:
  
 /* ASN1
  
  */
  
 package main
  
 import (
  
  
  ""encoding/asn1""
  
  
  ""fmt""
  
  
  ""os"" 
  
 )
  
 60",NA
ASN.1 Daytime Client and Server,"Now (finally) let’s turn to using ASN.1 to transport data across the network.
  
  
 We can write a TCP server that delivers the current time as an ASN.1 Time type, using the techniques 
 of the last chapter. A server is ASNDaytimeServer.go:
  
 /* ASN1 DaytimeServer
  
  */ 
  
 package main
  
 import (
  
  
  ""encoding/asn1""
  
  
  ""fmt""
  
  
  ""net""Calibri
  
  
  ""os""
  
  
  ""time"" 
  
 )
  
 func main() {
  
  service := "":1200""
  
  tcpAddr, err := net.ResolveTCPAddr(""tcp"", service) 
 checkError(err)
  
  listener, err := net.ListenTCP(""tcp"", tcpAddr) 
 checkError(err)
  
  for {
  
  
  conn, err := listener.Accept()
  
  
  if err != nil {
  
  
  
  continue
  
  
  }
  
  daytime := time.Now()
  
  // Ignore return network errors.
  
  mdata, _ := asn1.Marshal(daytime)
  
 66",NA
JSON,"JSON stands for JavaScript Object Notation. It was designed to be a lightweight means of passing data 
 between JavaScript systems. It uses a text-based format and is sufficiently general that it has become used 
 as a general-purpose serialization method for many programming languages.
  
 JSON serializes objects, arrays, and basic values. The basic values include string, number, Boolean 
 values, and the null value. Arrays are a comma-separated list of values that can represent arrays, 
 vectors, lists, or sequences of various programming languages. They are delimited by square brackets [ 
 ... ]. Objects are represented by a list of “field: value” pairs enclosed in curly braces { ... }.
  
 For example, the table of employees given earlier could be written as an array of employee objects:
  
 [
  
  
  {""Name"": ""fred"", ""Occupation"": ""programmer""},
  
  
 {""Name"": ""liping"", ""Occupation"": ""analyst""},
  
  {""Name"": 
 ""sureerat"", ""Occupation"": ""manager""} ]
  
 There is no special support for complex data types such as dates, no distinction between number types, 
 no recursive types, etc. JSON is a very simple language, but nevertheless can be quite useful. Its text-based 
 format makes it easy to use and debug, even though it has the overheads of string handling.
  
 68",NA
A Client and Server,"A client to send a person’s data and read it back 10 times is JSONEchoClient.go:
  
 /* JSON EchoClient
  
  */ 
  
 package main
  
 import (
  
  
  ""bytes""
  
  
  ""encoding/json""
  
  
  ""fmt""
  
  
  ""io""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 type Person struct {
  
  
  Name  Name
  
  
  Email []Email 
  
 }
  
 type Name struct {
  
  
  Family   string
  
  
  Personal string 
  
 }
  
 type Email struct {
  
  
  Kind    string
  
  
  Address string 
  
 }
  
 func (p Person) String() string {
  
  
  s := p.Name.Personal + "" "" + p.Name.Family
  
  for _, v 
 := range p.Email {
  
  
  
  s += ""\n"" + v.Kind + "": "" + v.Address
  
  }
  
  
  return s 
  
 }
  
 func main() {
  
  
  person := Person{
  
  
  
  Name: Name{Family: ""Newmarch"", Personal: ""Jan""},
  
  
  
  Email: []Email{Email{Kind: ""home"", Address: ""jan@newmarch.name""},
  
  
  
  Email{Kind: ""work"", Address: ""j.newmarch@boxhill.edu.au""}}}
  
  if len(os.Args) != 2 {
  
  
  fmt.Println(""Usage: "", os.Args[0], ""host:port"")
  
  
 os.Exit(1)
  
  }
  
  service := os.Args[1]
  
 72",NA
The Gob Package,"Gob is a serialization technique specific to Go. It is designed to encode Go data types specifically and does 
 not at present have substantial support for or by any other languages. It supports all Go data types except 
 for channels, functions, and interfaces. It supports integers of all types and sizes, strings and Booleans, 
 structs, arrays, and slices. At present, it has some problems with circular structures such as rings, but that 
 will improve over time.
  
 Gob encodes type information into its serialized forms. This is far more extensive than the type 
 information in say an X.509 serialization, but far more efficient than the type information contained in an 
 XML document. Type information is only included once for each piece of data, but includes, for example, 
 the names of struct fields.
  
  
 This inclusion of type information makes Gob marshalling and unmarshalling fairly robust to changes 
 or differences between the marshaller and unmarshaller. For example, this struct:
  
  struct T {
  
  
  a int
  
  
  b int 
  
 }
  
 Can be marshalled and then unmarshalled into a different struct, where the order of fields has changed:
  
  struct T {
  
  
  b int
  
  
  a int 
  
 }
  
  
 It can also cope with missing fields (the values are ignored) or extra fields (the fields are left 
  
 unchanged). It can cope with pointer types, so that the previous struct could be unmarshalled into this one:
  
  struct T {
  
  
  *a int
  
  
  **b int 
  
 }
  
 75",NA
A Client and Server,"A client to send a person’s data and read it back 10 times is GobEchoClient.go:
  
 /* Gob EchoClient
  
  */ 
  
 package main
  
 import (
  
  
  ""bytes""
  
  
  ""encoding/gob""
  
  
  ""fmt""
  
  
  ""io""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 type Person struct {
  
  
  Name  Name
  
  
  Email []Email 
  
 }
  
 type Name struct {
  
  
  Family   string
  
  
  Personal string 
  
 }
  
 78",NA
Encoding Binary Data as Strings,"Once upon a time, transmitting 8-bit data was problematic. It was often transmitted over noisy serial lines 
 and could easily become corrupted. 7-bit data, on the other hand, could be transmitted more reliably 
 because the 8th bit could be used as check digit. For example, in an “even parity” scheme, the check digit 
 would be set to one or zero to make an even number of 1s in a byte. This allows detection of errors of a 
 single bit in each byte.
  
 81",NA
Protocol Buffers,"The serialization methods considered so far fall into various types:
  
 • 
  
 ASN.1 encodes the different types using binary tags in the data. In that sense, an 
  
 ASN.1 encoded data structure is a self-describing structure.
  
 • 
  
 JSON similarly is a self-describing format, using the rules of JavaScript data 
  
 structures: lists, dictionaries, etc.
  
 • 
  
 Gob similarly encodes type information into its encoded form. This is far more 
  
 detailed than the JSON format.
  
  
 A separate class of serialization techniques rely on an external specification of the data type to be 
 encoded. There are several major ones, such as the encoding used by ONC RPC.
  
 ONC RPC is an old encoding, targeted toward the C language. A recent one is from Google, known as 
 protocol buffers
 . This is not supported in the Go Standard Libraries, but is supported by the Google Protocol 
 Buffers developer group (
 https://developers.google.com/protocol-buffers/
 ) and is apparently very popular 
 within Google. For that reason, we include a section on protocol buffers, although in the rest of the book we 
 typically deal with the Go Standard Libraries.
  
 Protocol buffers are a binary encoding of data intended to support the data types of a large variety of 
 languages. They rely on an external specification of a data structure, which is used to encode data (in a 
 source language) and also to decode the encoded data back into a target language. (Note: Protocol buffers 
 transitioned to version 3 in July 2016. It is not compatible with version 2. Version 2 will be supported for a 
 long time, but will eventually be obsoleted. See Protocol Buffers v3.0.0 at 
 https://github.com/google/ 
 protobuf/releases/tag/v3.0.0
 ).
  
  
 The data structure to be serialized is known as a 
 message.
  The data types supported in each message 
 include:
  
 • 
  
 Numbers (integers or floats)
  
 • 
  
 Booleans
  
 • 
  
 Strings (in UTF-8)
  
 • 
  
 Raw bytes
  
 • 
  
 Maps
  
 • 
  
 Other messages, allowing complex data structures to be built
  
 The fields of a message are all optional (this is a change from proto2 where fields were required or 
 optional). A field can stand for a list or array by the keyword repeated or a map using the keyword map. 
 Each field has a type, followed by a name, followed by a tag index value. The full language guide is at called 
 the “Protocol Buffers Language Guide” (see 
 https://developers.google.com/protocol-buffers/docs/proto
 ).
  
 Messages are defined independent of the possible target language. A version of the Person type in the 
 syntax of Protocol Buffers version 3 is personv3.proto. Note that the file includes specific tags (1, 2) on 
 each type.
  
 syntax = ""proto3""; 
  
 package person;
  
 message Person {
  
  
  message Name {
  
  
  
  string family = 1;
  
  
  
  string personal = 2;
  
  
  }
  
 83",NA
Installing and Compiling Protocol Buffers,"Protocol buffers are compiled using a program called protoc. This is unlikely to be installed on your system. 
 Version 3 was only released in July 2016, so copies in repositories are likely to be version 2.
  
 Install the latest version from the Protocol Buffers v3.0.0 page. For 64-bit Linux for example, download 
 protoc-3.0.0-linux-x86_64.zip from GitHub and unzip it to a suitable place (it includes the binary 
 bin/protoc, which should be placed somewhere in your PATH).
  
  
 That installs the general binary. You also need the “backend” to generate Go files. To do this, fetch it 
 from GitHub:
  
 go get -u github.com/golang/protobuf/protoc-gen-go 
  
 You are nearly ready to compile a .proto file. The previous example of personv3.proto declares the 
 package person. In your GOPATH, you should have a directory called src. Create a subdirectory called 
 src/person. Then compile the personv3.proto as follows:
  
 protoc --go_out=src/person personv3.proto
  
 This should create the src/person/personv3.pb.go file.",NA
The Compiled personv3.pb.go File,"The compiled file will declare a number of types and methods on these types. The types are as follows:
  
 type Person struct {
  
  
  Name  *Person_Name    `protobuf:""bytes,1,opt,name=name"" json:""name,omitempty""`
  
  Email 
 []*Person_Email `protobuf:""bytes,2,rep,name=email"" json:""email,omitempty""` }
  
 type Person_Name struct {
  
  
  Family   string `protobuf:""bytes,1,opt,name=family"" json:""family,omitempty""`
  
  Personal 
 string `protobuf:""bytes,2,opt,name=personal"" json:""personal,omitempty""` }
  
 type Person_Email struct {
  
  
  Kind    string `protobuf:""bytes,1,opt,name=kind"" json:""kind,omitempty""`
  
  Address string 
 `protobuf:""bytes,2,opt,name=address"" json:""address,omitempty""` }
  
  
 They are in the package called person. (Note: Simple types such as strings are encoded directly. In 
 Protocol Buffers v2, a pointer was used. For compound types, a pointer is required, as in v2.)
  
 84
  
 www.allitebooks.com",NA
Using the Compiled Code,"There is essentially no difference between the coding used in the JSON example and this one, apart from 
 having to watch pointers for the structs used. A simple program just to marshal and unmarshal a Person is 
 ProtocolBuffer.go: 
  
  
 The output should be a Person before and after marshalling and should be the same:
  
 /* ProtocolBuffer
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""github.com/golang/protobuf/proto""
  
  
  ""os""
  
  
  ""person"" 
  
 )
  
 func main() {
  
  
  name := person.Person_Name{
  
  
  
  Family:   ""newmarch"",
  
  
  
  Personal: ""jan""}
  
  email1 := person.Person_Email{
  
  
  Kind:    ""home"",
  
  
  Address: ""jan@newmarch.name""}
  
  email2 := person.Person_Email{
  
  
  Kind:    ""work"",
  
  
  Address: ""j.newmarch@boxhill.edu.au""}
  
  emails := []*person.Person_Email{&email1, &email2} p := 
 person.Person{
  
  
  Name:  &name,
  
  
  Email: emails,
  
  }
  
  fmt.Println(p)
  
  
  data, err := proto.Marshal(&p)
  
  
  checkError(err)
  
  
  newP := person.Person{}
  
  
  err = proto.Unmarshal(data, &newP)
  
  
  checkError(err)
  
  
  fmt.Println(newP) 
  
 }
  
 func checkError(err error) {
  
  
  if err != nil {
  
  
  
  fmt.Println(""Fatal error "", err.Error())
   
  
 os.Exit(1)
  
  
  } 
  
 }
  
 85",NA
Conclusion,"This chapter discussed the general properties of serializing data types and showed a number of common 
 encodings. There are many more, including XML (included in the Go libraries), CBOR (a binary form of 
 JSON), and YAML (similar to XML), as well as many language-specific ones such as Java Object Serialization 
 and Python’s Pickle. Those not in the Go standard packages may often be found on GitHub.
  
 86",NA
CHAPTER 5,NA,NA
Application-Level Protocols,"A client and server need to exchange information via messages. TCP and UDP provide the transport 
 mechanisms to do this. The two processes also need to have a protocol in place so that message exchange 
 can take place meaningfully. A protocol defines what type of conversation can take place between two 
 components of a distributed application, by specifying messages, data types, encoding formats, and so on. 
 This chapter looks at some of the issues involved in this process and gives a complete example of a simple 
 client-server application.",NA
Protocol Design,"There are many possibilities and issues to be decided on when designing a protocol. Some of the issues 
 include:
  
 Is it to be broadcast or point-to-point? Broadcast can be UDP, local multicast, or 
 the more experimental MBONE. Point-to-point could be either TCP or UDP.
  
 Is it to be stateful or stateless? Is it reasonable for one side to maintain state about 
 the other side? It is often simpler for one side to maintain state about the other, 
 but what happens if something crashes?
  
 Is the transport protocol reliable or unreliable? Reliable is often slower, but then 
 you don’t have to worry so much about lost messages.
  
 Are replies needed? If a reply is needed, how do you handle a lost reply? 
 Timeouts may be used.
  
 What data format do you want? Several possibilities were discussed in the last 
 chapter.
  
 Is your communication bursty or steady stream? Ethernet and the Internet are 
 best at bursty traffic. Steady stream is needed for video streams and particularly 
 for voice. If required, how do you manage Quality of Service (QoS)?
  
 Are there multiple streams with synchronization required? Does the data need 
 to be synchronized with anything, such as video and voice?
  
 Are you building a standalone application or a library to be used by others? The 
 standards of documentation required might vary.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_5
  
 87",NA
Why Should You Worry?,"Jeff Bezos, the CEO of Amazon, reportedly made the following statements in 2002:
  
 • 
  
 All teams will henceforth expose their data and functionality through service 
  
 interfaces.
  
 • 
  
 Teams must communicate with each other through these interfaces.
  
 • 
  
 There will be no other form of interprocess communication allowed: no direct 
  
 linking, no direct reads of another team’s data store, no shared-memory model, no 
  
 backdoors whatsoever. The only communication allowed is via service interface calls 
  
 over the network.
  
 • 
  
 It doesn’t matter what technology they use. HTTP, Corba, Pubsub, custom 
  
 protocols—it doesn’t matter. Bezos doesn’t care.
  
 • 
  
 All service interfaces, without exception, must be designed from the ground up to be 
  
 externalizable. That is to say, the team must plan and design to be able to expose the 
  
 interface to developers on the outside world. No exceptions.
  
 • 
  
 Anyone who doesn’t do this will be fired.
  
 (Source: Rip Rowan’s blog about Steve Yegge’s posting at 
 https://plus.google.com/+RipRowan/ 
 posts/eVeouesvaVX
 .) What Bezos was doing was orienting one of the world’s most successful Internet 
 companies around service architectures, and interfaces must be clear enough that 
 all
  communication must 
 be through those interfaces alone—without confusion or errors.",NA
Version Control,"A protocol used in a client-server system will evolve over time, changing as the system expands. This raises 
 compatibility problems: a version 2 client will make requests that a version 1 server doesn’t understand, 
 whereas a version 2 server will send replies that a version 1 client won’t understand.
  
  
 Each side should ideally be able to understand messages from its own version and all earlier ones. It 
 should be able to write replies to old-style queries in old-style response formats. See Figure 
 5-1
 .
  
 88",NA
The Web,"The Web is a good example of a system that has been through multiple different versions. The underlying 
 HTTP protocol manages version control in an excellent manner, even though it has been through four 
 versions. Most servers/browsers support the latest version but also support the earlier versions. The 
 latest version HTTP/2 appears to account for just over 11% of web traffic by January 2017, while 
 HTTP/1.1 accounts for almost all of the rest. The version is given in each request as in the following GET 
 requests:
  
 Request
  
 Version
  
 GET / 
  
 GET / HTTP/1.0 
 GET / HTTP/1.1
  
 GET / HTTP/1.1
  
 Pre 1.0 
  
 HTTP 1.0 
  
 HTTP 1.1
  
 HTTP 2
  
 Connection: Upgrade, 
  
 HTTP2-Settings Upgrade: h2c
  
 89",NA
Message Format ,"In the last chapter we discussed some possibilities for representing data to be sent across the wire. Now 
 we look one level up, to the messages that may contain such data.
  
 • 
  
 The client and server will exchange messages with different meanings:
  
  
 • 
  
 Login request 
  
  
   
 Login reply• 
  
  
  
 • 
  
 Get record request
  
  
  
 • 
  
 Record data reply
  
 • 
  
 The client will prepare a request, which must be understood by the 
 server.
  
 The server will prepare a reply, which must be understood by the client.• 
  
 90",NA
Data Format,There are two main format choices for messages: byte encoded or character encoded.,NA
Byte Format,"In the byte format:
  
 • 
  
 The first part of the message is typically a byte to distinguish between message types.
  
 • 
  
 The message handler examines this first byte to distinguish the message type and 
  
 then performs a switch to select the appropriate handler for that type.
  
 • 
  
 Further bytes in the message contain message content according to a predefined 
  
 format (as discussed in the previous chapter).
  
 The advantages are compactness and hence speed. The disadvantages are caused by the opaqueness of 
 the data: it may be harder to spot errors, harder to debug, and require special purpose decoding functions. 
 There are many examples of byte-encoded formats, including major protocols such as DNS and NFS, up to 
 recent ones such as Skype. Of course, if your protocol is not publicly specified, then a byte format can also 
 make it harder for others to reverse-engineer it!
  
 Pseudocode for a byte-format server is as follows:
  
 handleClient(conn) {
  
  
  while (true) {
  
  
  
  byte b = conn.readByte()
  
  
  
  switch (b) {
  
  
  
  
  case MSG_1: ...
  
  case MSG_2: ...
  
  ...
  
  
  
  }
  
  
  } 
  
 }
  
 91",NA
Character Format,"In this mode, everything is sent as characters if possible. For example, an integer 234 would be sent as, 
 say, the three characters 2, 3, and 4 instead of as the one byte 234. Data that is inherently binary may be 
 Base64 encoded to change it into a 7-bit format and then sent as ASCII characters, as discussed in the 
 previous chapter.
  
 In character format:
  
 • 
  
 A message is a sequence of one or more lines. The start of the first line of the 
 message 
  
 is typically a word that represents the message type.
  
 • 
  
 String-handling functions may be used to decode the message type and data.
  
 • 
  
 The rest of the first line and successive lines contain the data.
  
 • 
  
 Line-oriented functions and line-oriented conventions are used to manage this.
  
 The pseudocode is as follows:
  
 handleClient() {
  
  
  line = conn.readLine()
  
  
  if (line.startsWith(...) {
  
  
  
  ...
  
  } else if (line.startsWith(...) {
  
  
  ...
  
  
  } 
  
 }
  
 Character formats are easier to set up and easier to debug. For example, you can use telnet to connect to 
 a server on any port and send client requests to that server. There isn’t a simple tool like telnet to send 
 server responses to a client, but you can use tools like tcpdump or wireshark to snoop on TCP traffic and see 
 immediately what clients are sending to, and receiving from, the servers.
  
  
 There is not the same level of support in Go for managing character streams. There are significant 
 issues with character sets and character encodings, and we will explore these issues in a later chapter.
  
 If we just pretend everything is ASCII, like it was once upon a time, then character formats are quite 
 straightforward to deal with. The principal complication at this level is the varying status of “newline” across 
 different operating systems. UNIX uses the single character \n. Windows and others (more correctly) use 
 the pair \r\n. On the Internet, the pair \r\n is most common. UNIX systems just need to take care that they 
 don’t assume \n.",NA
A Simple Example,"This example deals with a directory browsing protocol, which is basically a stripped down version of FTP, 
 but without even the file transfer part. We only consider listing a directory name, listing the contents of a 
 directory, and changing the current directory—all on the server side, of course. This is a complete worked 
 example of creating all components of a client-server application. It is a simple program that includes 
 messages in both directions, as well as a design of messaging protocol.
  
 92",NA
A Standalone Application,"Look at a simple non-client-server program that allows you to list files in a directory and change and print 
 the name of the directory on the server. We omit copying files, as that adds to the length of the program 
 without introducing important concepts. For simplicity, all filenames will be assumed to be in 7-bit ASCII. If 
 we just looked at a standalone application first, it would look like Figure 
 5-2
 .
  
 File
  
 UI
  
 system 
  
 access
  
 Figure 5-2.
  The standalone application
  
 The pseudocode would be as follows:
  
 read line from user 
  
 while not eof do
  
  if line == dir
  
   
  list directory // local function call
  
  else
  
  if line == cd <directory>
  
  
  change directory // local function call
  
  else
  
  if line == pwd
  
  
  print directory // local function call
  
  else
  
  if line == quit
  
  
  quit
  
  else
  
  
  complain
  
  read line from user
  
 A non-distributed application would simply link the UI and file access code by local function calls.
  
 93",NA
The Client-Server Application,"In a client-server situation, the client would be at the user end, talking to a server somewhere else. Aspects 
 of this program belong solely at the presentation end, such as getting the commands from the user. Some are 
 messages from the client to the server; some are solely at the server end. See Figure 
 5-3
 .",NA
UI,NA,NA
Client,NA,NA
network,NA,NA
server,NA,NA
Server,NA,NA
client,NA,NA
File,NA,NA
system,NA,NA
I/O,NA,NA
I/O,NA,NA
access,"Figure 5-3.
  The client-server situation",NA
The Client Side,"For a simple directory browser, assume that all directories and files are at the server end, and we are 
 transferring file information only from the server to the client. The client side (including 
 presentation aspects) will become:
  
 read line from user 
  
 while not eof do
  
  if line == dir 
  
   
 list directory // network call to server
  
  else
  
  if line == cd <directory> 
  
  
 change directory // network call to server
  
  else
  
  if line == pwd 
  
  
 print directory // network call to server
  
  else
  
  if line == quit
  
  
  quit
  
  else
  
  
  complain
  
  read line from user
  
  
 Where the calls listdirectory, change directory, and print directory now all involve network calls to 
 the server. The details are not shown yet and will be discussed later.
  
 94",NA
Alternative Presentation Aspects,"A GUI program would allow directory contents to be displayed as lists, for files to be selected and 
 actions such as change directory to be performed on them. The client would be controlled by actions 
 associated with various events that take place on graphical objects. The pseudocode might look like this:
  
 change dir button:
  
  if there is a selected file 
  
    
 change directory // remote call to server
  
  if successful
  
   
  update directory label 
  
    
 list directory // remote call to server
  
   
  update directory list
  
  
 The functions called from the different UIs should be the same—changing the presentation should not 
 change the networking code.",NA
The Server Side,"The server side is independent of whatever presentation is used by the client. It is the same for all clients:
  
 while read command from client
  
  if command == dir 
  
   
 send list directory // local call on server
  else
  
  if command == cd <directory> 
  
  
 change directory // local call on server
  
  else
  
  if command == pwd 
  
  
 send print directory // local call on server
  else",NA
Protocol: Informal,"Client Request
  
 Server Response
  
 dir 
  
 cd <directory>
  
 Send list of files 
  
 Change dir
  
  Send an error if failed  
  
  Send ok if succeed
  
 pwd 
  
 quit
  
 Send current directory 
  
 Quit
  
 95",NA
Text Protocol,"This is a simple protocol. The most complicated data structure that we need to send is an array of strings 
 for a directory listing. In this case, we don’t need the heavy-duty serialization techniques of the last chapter. 
 In this case, we can use a simple text format.
  
  
 But even if we make the protocol simple, we still have to specify it in detail. We choose the following 
 message format:
  
 • 
  
 All messages are in 7-bit US-ASCII.
  
 • 
  
 The messages are case-sensitive.
  
 • 
  
 Each message consists of a sequence of lines.
  
 • 
  
 The first word on the first line of each message describes the message type. All 
 other 
  
 words are message data.
  
 • 
  
 All words are separated by exactly one space character.
  
 • 
  
 Each line is terminated by CR-LF.
  
 Some of the choices made above are weaker in real-life protocols. For example:
  
 • 
  
 Message types could be case-insensitive. This just requires mapping message type 
  
 strings down to lowercase before decoding.
  
 • 
  
 An arbitrary amount of whitespace could be left between words. This just adds a little 
  
 more complication, compressing whitespace.
  
 • 
  
 Continuation characters such as \ can be used to break long lines over several lines. 
  
 This starts to make processing more complex.
  
 • 
  
 Just a \n could be used as line terminator, \r\n can too. This makes recognizing the 
  
 end of line a bit harder.
  
  
 All of these variations exist in real protocols. Cumulatively, they make string processing more complex 
 than in this case.
  
 Client Request
  
 Server Response
  
 send ""DIR"" 
  
 send ""CD <directory>""
  
 Send list of files, one per line, terminated by a blank line 
 Change dir
  
  Send ""ERROR"" if failed  
  
  Send ""OK"" if succeeded
  
 send ""PWD""
  
 Send current working directory
  
 We should also specify the transport:
  
 • 
  
 All messages are sent over a TCP connection established from the client to the server.
  
 96",NA
Server Code,"The server is FTPServer.go:
  
 /* FTP Server
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 const (
  
  
  DIR = ""DIR""
  
  
  CD  = ""CD""
  
  
  PWD = ""PWD"" 
  
 )
  
 func main() {
  
  service := ""0.0.0.0:1202""
  
  tcpAddr, err := net.ResolveTCPAddr(""tcp"", service) 
 checkError(err)
  
  listener, err := net.ListenTCP(""tcp"", tcpAddr) 
 checkError(err)
  
  
  for {
  
  
  
  conn, err := listener.Accept()
  
  
  
  if err != nil {
  
  
  
  
  continue
  
  
  
  }
  
  
  
  go handleClient(conn)
  
  
  } 
  
 }
  
 func handleClient(conn net.Conn) {
  
  
  defer conn.Close()
  
  var buf [512]byte
  
  for {
  
  
  n, err := conn.Read(buf[0:])
  
  
  if err != nil {
  
  
  
  conn.Close()
  
  
  
  return
  
  
  }
  
 97",NA
Client Code,"A command-line client is FTPClient.go:
  
 /* FTPClient
  
  */ 
  
 package main
  
 import (
  
  
  ""bufio""
  
  
  ""bytes""
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os""
  
  
  ""strings"" 
  
 )
  
 // strings used by the user interface 
  
 const (
  
  
  uiDir  = ""dir""
  
  
  uiCd   = ""cd""
  
  
  uiPwd  = ""pwd""
  
  
  uiQuit = ""quit"" 
  
 )
  
 // strings used across the network 
  
 const (
  
  
  DIR = ""DIR""
  
  
  CD  = ""CD""
  
  
  PWD = ""PWD"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""host"")
  
  
  os.Exit(1)
  
  
  }
  
  host := os.Args[1]
  
  conn, err := net.Dial(""tcp"", host+"":1202"")
  
  checkError(err)
  
  reader := bufio.NewReader(os.Stdin)
  
  for {
  
  
  line, err := reader.ReadString('\n')
  
  // lose 
 trailing whitespace
  
  
  line = strings.TrimRight(line, "" \t\r\n"")
  
  
 if err != nil {
  
  
  
  break
  
  
  }
  
 99",NA
Textproto Package,"The textproto package contains functions designed to simplify management of text protocols similar to 
 HTTP and SNMP.
  
 These formats have some little-known rules with regard to a single logical line continued over multiple 
 lines such as: “HTTP/1.1 header field values can be folded onto multiple lines if the continuation line begins 
 with a space or horizontal tab” (HTTP1.1 specification). Formats allowing lines like these can be read using 
 the ReadContinuedLine() function, in addition to simpler functions like ReadLine().
  
 These protocols also signal status values with lines beginning with three-digit codes such as 404. These 
 can be read using ReadCodeLine(). They also have key: value lines such as Content-Type: image/gif. Such 
 lines can be read into a map by ReadMIMEHeader().",NA
State Information,"Applications often use state information to simplify what is going on. For example:
  
 • 
  
 Keeping file pointers to a current file location.
  
 • 
  
 Keeping the current mouse position.
  
 • 
  
 Keeping the current customer value.
  
 In a distributed system, such state information may be kept in the client, in the server, or in both.
  
 The important point is to whether one process is keeping state information about 
 itself
  or about the 
 other
  process. One process may keep as much state information about itself as it wants, without causing any 
 problems. If it needs to keep information about the state of the other process, then problems arise. The 
 process’ actual knowledge of the state of the other may become incorrect. This can be caused by loss of 
 messages (in UDP), by failure to update, or by software errors.
  
 An example is reading a file. In single process applications, the file-handling code runs as part of the 
 application. It maintains a table of open files and the location in each of them. Each time a read or write is 
 done, this file location is updated. In distributed systems, this simple model does not hold. See Figure 
 5-4
 .
  
 101",NA
DCE File System,"client
  
 read n bytes
  
 file
  
 File table
  
 reading
  
 n bytes
  
 server
  
 name
  
 file ptr
  
 file
  
 name
  
 file ptr",NA
update ,NA,NA
file ptr,"Figure 5-4.
  The DCE file system
  
 In the DCE file system shown in Figure 
 5-4
 , the file server keeps track of a client’s open files and where 
 the client’s file pointer is. If a message could get lost (but DCE uses TCP), these could get out of synch. If the 
 client crashes, the server must eventually time out on the client’s file tables and remove them.",NA
NFS File System,NA,NA
update,NA,NA
file ptr,NA,NA
read n bytes from,NA,NA
file,NA,NA
client,NA,NA
file at ptr,NA,NA
reading,NA,NA
n bytes,NA,NA
server,NA,NA
file,NA,NA
File table,NA,NA
name ,NA,NA
file ptr ,NA,NA
name ,NA,NA
file ptr,"Figure 5-5.
  The NFS file system
  
 102",NA
Application State Transition Diagram,"A state transition diagram keeps track of the current state of an application and the changes that move it 
 to new states.
  
 The previous example basically only had one state: file transfer. If we add a login mechanism, that 
 would add an extra state called 
 login
 , and the application would need to change states between login and file 
 transfer, as shown in Figure 
 5-6
 .",NA
LOGIN,NA,NA
START,NA,NA
failed,NA,NA
LOGIN,NA,NA
GET,NA,NA
QUIT,NA,NA
Login,NA,NA
File,NA,NA
Transfer,NA,NA
succeeded,NA,NA
LOGOUT,NA,NA
DIR,"Figure 5-6.
  The state-transition diagram
  
 103",NA
Client State Transition Diagrams ,"The client state diagram must follow the application diagram. It has more detail though: it 
 writes
  and then 
  
 reads
 :
  
 Current State
  
 Write
  
 Read
  
 Next State
  
 login
  
 LOGIN name password
  
 FAILED
  
 login
  
 file transfer
  
 CD dir
  
 OK
  
 file transfer
  
 OK
  
 file transfer
  
 GET filename
  
 FAILED
  
 file transfer
  
 #lines + contents
  
 file transfer
  
 DIR
  
 FAILED
  
 file transfer
  
 File names + blank line
  
 file transfer
  
 quit
  
 blank line (Error)
  
 file transfer
  
 none
  
 quit
  
 104",NA
Server State Transition Diagrams,"The server state diagram must also follow the application diagram. It also has more detail: it 
 reads
  and then 
 writes
 :
  
 Current State
  
 Read
  
 Write
  
 Next State
  
 login
  
 LOGIN name password
  
 FAILED
  
 login
  
 file transfer
  
 CD dir
  
 OK
  
 file transfer
  
 SUCCEEDED
  
 file transfer
  
 GET filename
  
 FAILED
  
 file transfer
  
 #lines + contents
  
 file transfer
  
 DIR
  
 FAILED
  
 file transfer
  
 filenames + blank line
  
 file transfer
  
 quit
  
 blank line (failed)
  
 file transfer
  
 none
  
 login",NA
Server Pseudocode,"Here is the server pseudocode:
  
 state = login 
  
 while true
  
  
  read line
  
  
  switch (state)
  
  
  
  case login:
  
  
  
  
  get NAME from line
  
  
  
  
  get PASSWORD from line
  
  
  
  
  if NAME and PASSWORD verified
  
  
  
  
  
  write SUCCEEDED
  
  
  
  
  
  state = file_transfer
  
  
  
  
  else
  
  
  
  
  
  write FAILED
  
  
  
  
  
  state = login
  
  
  
  case file_transfer:
  
  
  
  
  if line.startsWith CD
  
  
  
  
  
  get DIR from line
  
  
  
  
  
  if chdir DIR okay
  
  
  
  
  
  
  write SUCCEEDED
  
  
  
  
  
  
  state = file_transfer
  
  
  
  
  
  else
  
  
  
  
  
  
  write FAILED
  
  
  
  
  
  
  state = file_transfer
  
  
  
  
  ...
  
 We don’t give the actual code for this server or client since it is pretty straightforward.
  
 105",NA
Conclusion,"Building any application requires design decisions before you start writing code. With distributed 
  
 applications, you have a wider range of decisions to make compared to standalone systems. This chapter 
 considered some of those aspects and demonstrated what the resultant code might look like. We only 
 touched on the elements of protocol design. There are many formal and informal models. The IETF (Internet 
 Engineering Task Force) created a standard format for its protocol specifications in its RFCs (Requests for 
 Comments), and sooner or later, every network engineer will need to work with RFCs.
  
 106",NA
CHAPTER 6,NA,NA
Managing Character Sets ,NA,NA
and Encodings,"Once upon a time, there was EBCDIC and ASCII. Actually, it was never that simple and has just become more 
 complex over time. There is light on the horizon, but some estimates are that it may be 50 years before we 
 all live in the daylight on this!
  
 Early computers were developed in the English-speaking countries of the United States, the UK, and 
 Australia. As a result of this, assumptions were made about the language and character sets in use. Basically, 
 the Latin alphabet was used, plus numerals, punctuation characters, and a few others. These were then 
 encoded into bytes using ASCII or EBCDIC.
  
 The character-handling mechanisms were based on this: text files and I/O consisted of a sequence of 
 bytes, with each byte representing a single character. String comparison could be done by matching 
 corresponding bytes; conversions from upper- to lowercase could be done by mapping individual bytes, and 
 so on.
  
 There are about 6,500 spoken languages in the world (850 of them in Papua New Guinea!). A few 
 languages use the “English” characters, but most do not. The Romanic languages such as French have 
 adornments on various characters, so that you can write “j’ai arrêté” with two differently accented vowels. 
 Similarly, the Germanic languages have extra characters such as “ß”. Even UK English has characters not in 
 the standard ASCII set: the pound symbol “£” and recently the euro “€”.
  
 But the world is not restricted to variations on the Latin alphabet. Thailand has its own alphabet, with 
 words looking like this: “
 ภาษาไทย
 ”. There are many other alphabets, and Japan even has two, Hiragana and 
 Katagana.
  
 There are also the hierographic languages such as Chinese where you can write “
 百度一下
 ,  
 你
 就知道
 ”.
  
 It would be nice from a technical viewpoint if the world just used ASCII. However, the trend is in the 
 opposite direction, with more and more users demanding that software use the language that they are 
 familiar with. If you build an application that can be run in different countries then users will demand that it 
 uses their own language. In a distributed system, different components of the system may be used by users 
 expecting different languages and characters.
  
 Internationalization
  (i18n) is how you write your applications so that they can handle the variety of 
 languages and cultures. 
 Localization
  (l10n) is the process of customizing your internationalized application 
 to a particular cultural group.
  
 i18n and l10n are big topics in themselves. For example, they cover issues such as colors: while white 
 means “purity” in Western cultures, it means “death” to the Chinese, and “joy” to Egyptians. In this chapter, 
 we just look at issues of character handling.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_6
  
 107",NA
Definitions,"It is important to be careful about exactly what part of a text-handling system you are talking about. Here is 
 a set of definitions that have proven useful.",NA
Character,"A 
 character
  is a “unit of information that roughly corresponds to a grapheme (written symbol) of a natural 
 language, such as a letter, numeral, or punctuation mark” (Wikipedia). A character is “the smallest 
 component of written language that has a semantic value” (Unicode). This includes letters such as ‘a’ and ‘À’ 
 (or letters in any other language), digits such as “2”, punctuation characters such as “, ” and various symbols 
 such as the English pound currency symbol “£”.
  
 A character is some sort of abstraction of any actual symbol: the character “a” is to any written “a” as a 
 Platonic circle is to any actual circle. The concept of character also includes control characters, which do 
 not correspond to natural language symbols but to other bits of information used to process texts of the 
 language.
  
 A character does not have any particular appearance, although we use the appearance to help recognize 
 the character. However, even the appearance may have to be understood in a context: in mathematics, if you 
 see the symbol π (pi) it is the character for the ratio of circumference to radius of a circle, while if you are 
 reading Greek text, it is the sixteenth letter of the alphabet: “πρoσ” is the Greek word for “with” and has 
 nothing to do with 3.14159.",NA
Character Repertoire/Character Set,"A character repertoire is a set of distinct characters, such as the Latin alphabet. No particular ordering is 
 assumed. In English, although we say that “a” is earlier in the alphabet than “z,” we wouldn’t say that “a” is 
 less than “z”. The “phone book"" ordering which puts “McPhee” before “MacRea” shows that “alphabetic 
 ordering” isn’t critical to the characters.
  
 A repertoire specifies the names of the characters and often a sample of how the characters might look. 
  
 For example, the letter “a” might look like “a”, “
 a
 ” or “
 a
 ”. But it doesn’t force them to look like that—they are 
 just samples. The repertoire may make distinctions such as upper- and lowercase, so that “a” and “A” are 
 different. But it may regard them as the same, just with different sample appearances. (Just like some 
 programming languages treat upper- and lowercase as different—Go—but some don’t—Basic.). On the 
 other hand, a repertoire might contain different characters with the same sample appearance: the repertoire 
 for a Greek mathematician would have two different characters with appearance π. This is also called a 
 noncoded character set.",NA
Character Code,"A character code is a mapping from characters to integers. The mapping for a character set is also called a 
 coded character set or code set. The value of each character in this mapping is often called a code point. 
 ASCII is a code set. The code point for “a” is 97 and for “A” is 65 (decimal).
  
  
 The character code is still an abstraction. It isn’t yet what we will see in text files, or in TCP packets. 
 However, it is getting close, as it supplies the mapping from human-oriented concepts into numerical ones.",NA
Character Encoding,"To communicate or store a character, you need to encode it in some way. To transmit a string, you need to 
 encode all characters in the string. There are many possible encodings for any code set.
  
 108",NA
Transport Encoding,"A character encoding will suffice for handling characters within a single application. However, once you start 
 sending text 
 between
  applications, then there is the further issue of how the bytes, shorts, or words are put 
 on the wire. An encoding can be based on space- and hence bandwidth-saving techniques such as zipping the 
 text. Or it could be reduced to a 7-bit format to allow a parity checking bit, such as base64.
  
 If we do know the character and transport encoding, then it is a matter of programming to manage 
 characters and strings. If we don’t know the character or transport encoding then it is a matter of guesswork 
 as to what to do with any particular string. There is no convention for files to signal the character encoding.
  
 There 
 is
  however a convention for signaling encoding in text transmitted across the Internet. It is 
 simple: the header of a text message contains information about the encoding. For example, an HTTP 
 header can contain lines such as the following:
  
 Content-Type: text/html; charset=ISO-8859-4 
  
 Content-Encoding: gzip
  
 This says that the character set is ISO 8859-4 (corresponding to certain countries in Europe) with the 
 default encoding, but then gziped. The second part—the content encoding—is what we are referring to as 
 “transfer encoding” (IETF RFC 2130).
  
 But how do you read this information? Isn’t it encoded? Don’t we have a chicken and egg situation? 
  
 Well, no. The convention is that such information is given in ASCII (to be precise, US ASCII) so that a 
 program can read the headers and then adjust its encoding for the rest of the document.",NA
ASCII,"ASCII has the repertoire of the English characters plus digits, punctuation, and some control characters. The 
 code points for ASCII are given by this familiar table:
  
 Oct   Dec   Hex   Char           Oct   Dec   Hex   Char-------------------------------
 -----------------------------000   0     00    NUL '¥0'       100   64    40    @ 
  
 001   1     01    SOH            101   65    41    A 
  
 002   2     02    STX            102   66    42    B 
  
 003   3     03    ETX            103   67    43    C 
  
 004   4     04    EOT            104   68    44    D 
  
 005   5     05    ENQ            105   69    45    E 
  
 006   6     06    ACK            106   70    46    F 
  
 007   7     07    BEL '\a'       107   71    47    G
  
 109",NA
ISO 8859,"Octets are now the standard size for bytes. This allows 128 extra code points for extensions to ASCII. A 
 number of different code sets to capture the repertoires of various subsets of European languages are the 
 ISO 8859 series. ISO 8859-1 is also known as Latin-1 and covers many languages in western Europe, while 
 others in this series cover the rest of Europe and even Hebrew, Arabic, and Thai. For example, ISO 8859-5 
 includes the Cyrillic characters of countries such as Russia, while ISO 8859-8 includes the Hebrew alphabet.
  
 The standard encoding for these character sets is to use their code point as an 8-bit value. For example, 
 the character “Á” in ISO 8859-1 has the code point 193 and is encoded as 193. All of the ISO 8859 series have 
 the bottom 128 values identical to ASCII, so that the ASCII characters are the same in all of these sets.
  
 The HTML specifications used to recommend the ISO 8859-1 character set. HTML 3.2 was the last one 
 to do so, and after that HTML 4.0 recommended Unicode. In 2008 Google made an estimate that of the 
 pages it sees, about 20% were still in ISO 8859 format while 20% were still in ASCII (See “Unicode nearing 
 50% of the web” at 
 http://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html
 ). See also 
 http://pinyin.info/news/2015/utf-8-unicode-vs-other-encodings-over-time/
  and 
 https:// 
 w3techs.com/technologies/history_overview/character_encoding
  for more background information.",NA
Unicode,"Neither ASCII nor ISO 8859 cover the languages based on hieroglyphs. Chinese is estimated to have about 
 20,000 separate characters, with about 5,000 in common use. These need more than a byte, and typically 
 two bytes has been used. There have been many of these two-byte character sets: Big5, EUC-TW, GB2312, 
 and GBK/GBX for Chinese, JIS X 0208 for Japanese, and so on. These encodings are generally not mutually 
 compatible.
  
 Unicode is an embracing standard character set intended to cover all major character sets in use. It 
 includes European, Asian, Indian, and many more. It is now up to version 9.0 and has 128,172 characters. 
 The number of code points now exceeds 65,536. That is more than 2^16. This has implications for character 
 encodings.
  
 The first 256 code points correspond to ISO 8859-1, with US ASCII as the first 128. There is thus a 
 backward compatibility with these major character sets, as the code points for ISO 8859-1 and ASCII are 
 exactly the same in Unicode. The same is not true for other character sets: for example, while most of the 
 Big5 characters are also in Unicode, the code points are not the same. The web site 
 http://moztw.org/ 
 docs/big5/table/unicode1.1-obsolete.txt
  contains one example of a (large) table mapping from Big5 to 
 Unicode.
  
 111",NA
"UTF-8, Go, and Runes","UTF-8 is the most commonly used encoding. Google estimated that in 2008 that 50% of the pages that it sees 
 are encoded in UTF-8 and that proportion is increasing. The ASCII set has the same encoding values in UTF-
 8, so a UTF-8 reader can read text consisting of just ASCII characters as well as text from the full Unicode set.
  
 Go uses UTF-8 encoded characters in its strings. Each character is of type rune. This is an alias for int32. 
 A Unicode character can be up to 4 bytes in UTF-8 encoding so that 4 bytes are needed to represent all 
 characters. In terms of characters, a string is an array of runes using 1, 2, or 4 bytes per rune.
  
 A string is also an array of bytes, but you have to be careful: only for the ASCII subset is a byte equal to a 
 character. All other characters occupy 2, 3, or 4 bytes. This means that the length of a string in characters 
 (runes) is generally not the same as the length of its byte array. They are equal only when the string consists 
 of ASCII characters only.
  
 The following program fragment illustrates this. If you take a UTF-8 string and test its length, you get 
 the length of the underlying byte array. But if you cast the string to an array of runes []rune then you get an 
 array of the Unicode code points, which is generally the number of characters:
  
 str := ""
 百度一下
 , 
 你
 就知道
 ""
  
 println(""String length"", len([]rune(str))) 
  
 println(""Byte length"", len(str))
  
 prints 
  
 String length 9 
  
 Byte length 27
  
  
 A more detailed explanation of strings and runes is given by The Go Blog (see 
 https://blog.golang. 
 org/strings
 ).",NA
UTF-8 Client and Server,"Possibly surprisingly, you need do nothing special to handle UTF-8 text in either the client or the server. The 
 underlying data type for a UTF-8 string in Go is a byte array, and as we just saw, Go looks after encoding the 
 string into 1, 2, 3, or 4 bytes as needed. The length of the string is the length of the byte array, so you write 
 any UTF-8 string by writing the byte array.
  
 112",NA
ASCII Client and Server,"The ASCII characters have the same encoding in ASCII and in UTF-8. So ordinary UTF-8 character handling 
 works fine for ASCII characters. No special handling needs to be done.",NA
UTF-16 and Go,"UTF-16 deals with arrays of short 16-bit unsigned integers. The package utf16 is designed to manage such 
 arrays. To convert a normal Go string, that is a UTF-8 string, into UTF-16, you first extract the code points by 
 coercing it into a []rune and then use utf16.Encode to produce an array of type uint16.
  
  
 Similarly, to decode an array of unsigned short UTF-16 values into a Go string, you use utf16.Decode to 
 convert it into code points as type []rune and then to a string. The following code fragment illustrates this:
  
 str := ""
 百度一下
 , 
 你
 就知道
 ""
  
 runes := utf16.Encode([]rune(str)) 
  
 ints := utf16.Decode(runes)
  
 str = string(ints)
  
  
 These type conversions need to be applied by clients or servers as appropriate, to read and write 16-bit 
 short integers, as shown next.",NA
Little-Endian and Big-Endian,"Unfortunately, there is a little devil lurking behind UTF-16. It is basically an encoding of characters into 
 16-bit short integers. The big question is: for each short, how is it written as two bytes? The top one first, 
 or the top one second? Either way is fine, as long as the receiver uses the same convention as the sender.
  
 Unicode has addressed this with a special character known as the 
 BOM
  (byte order marker). This is a 
 zero-width non-printing character, so you never see it in text. But its value 0xfffe is chosen so that you can 
 tell the byte order:
  
 • 
  
 In a big-endian system, it is FF FE
  
 • 
  
 In a little-endian system, it is FE FF
  
  
 Text will sometimes place the BOM as the first character in the text. The reader can then examine these 
 two bytes to determine what endian-ness has been used.
  
 113",NA
UTF-16 Client and Server,"Using the BOM convention, you can write a server that prepends a BOM and writes a string in UTF-16 as 
 UTF16Server.go:
  
 /* UTF16 Server
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net""
  
  
  ""os""
  
  
  ""unicode/utf16"" 
  
 )
  
 const BOM = '￾'
  
 func main() {
  
  service := ""0.0.0.0:1210""
  
  tcpAddr, err := net.ResolveTCPAddr(""tcp"", service) 
 checkError(err)
  
  listener, err := net.ListenTCP(""tcp"", tcpAddr) 
 checkError(err)
  
  for {
  
  
  conn, err := listener.Accept()
  
  
  if err != nil {
  
  
  
  continue
  
  
  }
  
  str := ""j'ai arrÃªtÃ©""
  
  shorts := utf16.Encode([]rune(str))
  
  writeShorts(conn, shorts)
  
  
  
  conn.Close() // we're finished
  
  } 
  
 }
  
 func writeShorts(conn net.Conn, shorts []uint16) {
  
  
 var bytes [2]byte
  
  // send the BOM as first two bytes
  
  bytes[0] = BOM >> 8
  
  bytes[1] = BOM & 255
  
  _, err := conn.Write(bytes[0:])
  
  if err != nil {
  
  
  return
  
  }
  
 114",NA
Unicode Gotchas,"This book is not about i18n issues. In particular, we don’t want to delve into the arcane areas of Unicode. 
 But you should know that Unicode is not a simple encoding and there are many complexities. For example, 
 some earlier character sets used 
 non-spacing
  characters, particularly for accents. This was brought into 
 Unicode, so you can produce accented characters in two ways: as a single Unicode character, or as a pair of 
  
 116",NA
ISO 8859 and Go,"The ISO 8859 series are 8-bit character sets for different parts of Europe and some other areas. They all 
 have the ASCII set common in the low part, but differ in the top part. According to Google, ISO 8859 codes 
 accounted for about 20% of the web pages it saw, but that has now dropped.
  
 The first code, ISO 8859-1 or Latin-1, has the first 256 characters in common with Unicode. The 
 encoded value of the Latin-1 characters is the same in UTF-16 and in the default ISO 8859-1 encoding. But 
 this doesn’t really help much, as UTF-16 is a 16-bit encoding and ISO 8859-1 is an 8-bit encoding. UTF-8 is 
  
 117",NA
Other Character Sets and Go,"There are very, very many character set encodings. According to Google, these generally only have a small 
 use in Web documents, which will hopefully decrease even further with time. But if your software wants 
 to capture all markets, then you may need to handle them.
  
 In the simplest cases, a lookup table will suffice. But that doesn’t always work. The character coding ISO 
 2022 minimized character set sizes by using a finite state machine to swap code pages in and out. This was 
 borrowed by some of the Japanese encodings and makes things very complex.
  
 Go presently only gives package support for any of these other character sets in the “sub-
 repositories” package tree. For example, the package golang.org/x/text/encoding/japanese handles EUC-
 JP and Shift JIS.",NA
Conclusion,"There hasn’t been much code in this chapter. Instead, there have been some of the concepts of a very 
 complex area. It’s up to you: if you want to assume everyone speaks U.S. English then the world is 
 simple. But if you want your applications to be usable by the rest of the world, you need to pay attention 
 to these complexities.
  
 119",NA
CHAPTER 7,NA,NA
Security,"Although the Internet was originally designed as a system to withstand attacks by hostile agents, it 
 developed into a cooperative environment of relatively trusted entities. Alas, those days are long gone. Spam 
 mail, denial of service (DoS) attacks, phishing attempts, and so on are indicative that anyone using the 
 Internet does so at their own risk.
  
 Applications have to be built to work correctly in hostile situations. “Correctly” no longer means just 
 getting the functional aspects of the program correct, but also means ensuring privacy and integrity of data 
 transferred, access only to legitimate users, and other security issues.
  
 This of course makes your programs much more complex. There are 
 difficult
  and 
 subtle
  computing 
 problems involved in making applications secure. Attempts to do it yourself (such as making up your own 
 encryption libraries) are usually doomed to failure. Instead, you need to use the libraries designed by 
 security professionals.
  
 Why should you bother, if it makes things harder? Almost every day there are reports of leaked credit 
 card details, of private servers being run by government officials and being hacked, and reports of systems 
 being brought down by denial of service attacks. Many of these attacks are possible by coding errors in 
 network-facing applications, such as buffer overflows, cross-site scripting, and SQL injection. But a large 
 number of errors can be traced to poor network handling: passwords passed in plain text, security 
 credentials requested and then not checked, and just trusting the environment you are in. For example, a 
 colleague recently purchased a home IoT (Internet of Things) device. He used wireshark to see what it was 
 doing on his network and discovered it was sending RTMP messages with authentication token admin.
  
 admin. An easy attack vector, without even having to crack passwords! Drones made by one well-known 
 company use encryption with known flaws and can be “stolen” by other drones. An increasingly common 
 method of stealing data is to act as a “rogue” wireless access point, pretending to be a legitimate access point 
 in a local coffee shop, but monitoring everything that passes through, including your bank account details. 
  
 These are “low hanging fruit”. The scope of data breaches is shown by “World's Biggest Data Breaches” 
 at 
 http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/
 .
  
 This chapter addresses the basic cryptographic tools given by Go that you can build into your 
 applications. If you don’t and your company loses a million dollars—or worse, your customers lose a million 
 dollars—then the blame comes back to you.",NA
ISO Security Architecture,"The ISO OSI (open systems interconnect) seven-layer model of distributed systems is well known and is 
 repeated in Figure 
 7-1
 .
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_7
  
 121",NA
Mechanisms,"The mechanisms to achieve this level of security are as follows:
  
 • 
  
 Peer entity authentication
  
 • 
  
 Encryption
  
 • 
  
 Digital signature
  
 • 
  
 Authentication exchange
  
 • 
  
 Data origin authentication
  
 • 
  
 Encryption
  
 • 
  
 Digital signature
  
 • 
  
 Access control service
  
 • 
  
 Access control lists
  
 • 
  
 Passwords
  
 • 
  
 Capabilities lists
  
 • 
  
 Labels
  
 • 
  
 Connection confidentiality
  
 • 
  
 Encryption
  
 • 
  
 Routing control
  
 • 
  
 Connectionless confidentiality
  
 • 
  
 Encryption
  
 • 
  
 Routing control
  
 • 
  
 Selective field confidentiality
  
 • 
  
 Encryption
  
 • 
  
 Traffic flow confidentiality
  
 • 
  
 Encryption
  
 • 
  
 Traffic padding
  
 • 
  
 routing control
  
 123",NA
Data Integrity,"Ensuring data integrity means supplying a means of testing that the data has not been tampered with. 
  
 Usually this is done by forming a simple number out of the bytes in the data. This process is called 
 hashing
  
 and the resulting number is called a 
 hash
  or 
 hash value
 .
  
 A naive hashing algorithm is just to sum up all the bytes in the data. However, this still allows almost 
  
 any amount of changing the data around and still preserving the hash values. For example, an attacker 
  
 could just swap two bytes. This preserves the hash value, but could end up with you owing someone 
  
 $65,536 instead of $256.
  
 Hashing algorithms used for security purposes have to be “strong,” so that it is very difficult for an 
  
 attacker to find a different sequence of bytes with the same hash value. This makes it hard to modify the 
  
 124",NA
Symmetric Key Encryption,"There are two major mechanisms used for encrypting data. Symmetric key encryption uses a single key 
 that is the same for both encryption and decryption. This key needs to be known to both the encrypting and 
 the decrypting agents. How this key is transmitted between the agents is not discussed.
  
 As with hashing, there are many encryption algorithms. Many are now known to have 
 weaknesses, and in general algorithms become weaker over time as computers get faster. Go has 
 support for several symmetric key algorithms such as AES and DES.
  
  
 The algorithms are 
 block
  algorithms. That is, they work on blocks of data. If your data is not aligned to 
 the block size, you will have to pad it with extra blanks at the end.
  
  
 Each algorithm is represented by a Cipher object. This is created by NewCipher in the 
 appropriate package and takes the symmetric key as parameter.
  
 Once you have a cipher, you can use it to encrypt and decrypt blocks of data. We use AES-128, which 
 has a key size of 128 bits (16 bytes) and a block size of 128 bits. The size of the key determines which 
 version of AES is used. A program to illustrate this is Aes.go:
  
 /* Aes
  
  */
  
 package main
  
 import (
  
  
  ""bytes""
  
  
  ""crypto/aes""
  
  
  ""fmt"" 
  
 )
  
 func main() {
  
  
  key := []byte(""my key, len 16 b"")
  
  
  cipher, err := aes.NewCipher(key)
  
  
  if err != nil {
  
  
  
  fmt.Println(err.Error())
  
  
  }
  
  
  src := []byte(""hello 16 b block"")
  
  var enc [16]byte
  
  cipher.Encrypt(enc[0:], src)
  
  
  var decrypt [16]byte
  
  
  cipher.Decrypt(decrypt[0:], enc[0:])
  
  
  result := bytes.NewBuffer(nil)
  
  
  result.Write(decrypt[0:])
  
  
  fmt.Println(string(result.Bytes())) 
  
 }
  
  
 This encrypts and decrypts the 16-byte block ""hello 16 b block"" using the shared 16-byte key 
 ""my key, len 16 b"".
  
 126",NA
Public Key Encryption,"The other major type of encryption is public key encryption. Public key encryption and decryption requires 
 two
  keys: one to encrypt and a second one to decrypt. The encryption key is usually made public in some 
 way so that anyone can encrypt messages to you. The decryption key must stay private; otherwise, everyone 
 would be able to decrypt those messages! Public key systems are asymmetric, with different keys for 
 different uses.
  
 There are many public key encryption systems supported by Go. A typical one is the RSA scheme.
  
 A program generating RSA private and public keys from a random number is GenRSAKeys.go:
  
 /* GenRSAKeys
  
  */
  
 package main
  
 import (
  
  
  ""crypto/rand""
  
  
  ""crypto/rsa""
  
  
  ""crypto/x509""
  
  
  ""encoding/gob""
  
  
  ""encoding/pem""
  
  
  ""fmt""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  reader := rand.Reader
  
  bitSize := 512
  
  key, err := rsa.GenerateKey(reader, bitSize) 
 checkError(err)
  
  fmt.Println(""Private key primes"", key.Primes[0].String(), key.Primes[1].String()) 
 fmt.Println(""Private key exponent"", key.D.String())
  
  publicKey := key.PublicKey
  
  fmt.Println(""Public key modulus"", publicKey.N.String()) 
 fmt.Println(""Public key exponent"", publicKey.E)
  
  saveGobKey(""private.key"", key)
  
  saveGobKey(""public.key"", publicKey)
  
  
  savePEMKey(""private.pem"", key) 
  
 }
  
 func saveGobKey(fileName string, key interface{}) { outFile, 
 err := os.Create(fileName)
  
  checkError(err)
  
  encoder := gob.NewEncoder(outFile)
  
  err = encoder.Encode(key)
  
 127",NA
X.509 Certificates,"A Public Key Infrastructure (PKI) is a framework for a collection of public keys, along with 
 additional information such as owner name and location, and links between them giving some sort 
 of approval mechanism.
  
  
 The principal PKI in use today is based on X.509 certificates. For example, web browsers use them to 
 verify the identity of web sites.
  
  
 An example program to generate a self-signed X.509 certificate for my web site and store it in a .cer file 
 is GenX509Cert.go:
  
 /* GenX509Cert
  
  */
  
 package main
  
 import (
  
  
  ""crypto/rand""
  
  
  ""crypto/rsa""
  
  
  ""crypto/x509""
  
  
  ""crypto/x509/pkix""
  
  
  ""encoding/gob""
  
  
  ""encoding/pem""
  
  
  ""fmt""
  
  
  ""math/big""
  
  
  ""os""
  
  
  ""time"" 
  
 )
  
 129",NA
TLS,"Encryption/decryption schemes are of limited use if you have to do all the heavy lifting yourself. The 
 most popular mechanism on the Internet to give support for encrypted message passing is currently TLS 
 (Transport Layer Security), which was formerly SSL (Secure Sockets Layer).
  
 In TLS, a client and a server negotiate identity using X.509 certificates. Once this is complete, a secret 
 key is invented between them, and all encryption/decryption is done using this key. The negotiation is 
 relatively slow, but once it’s complete, the faster secret key mechanism is used. The server is 
 required
  to 
 have a certificate; the client 
 may
  have one if needed.",NA
A Basic Client,"We first illustrate connecting to a server that has a certificate signed by a “well known” certificate authority 
 (CA) such as RSA. The program to get head information from a web server can be adapted to get head 
 information from a TLS web server. The program is TLSGetHead.go. (We are illustrating TLS.Dial here, and 
 will discuss HTTPS in a later chapter.)
  
 /* TLSGetHead
  
  */ 
  
 package main
  
 import (
  
  
  ""crypto/tls""
  
  
  ""fmt""
  
  
  ""io/ioutil""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""host:port"")
  
  
  os.Exit(1)
  
  
  }
  
  
  service := os.Args[1]
  
  conn, err := tls.Dial(""tcp"", service, nil)
  
  checkError(err)
  
  _, err = conn.Write([]byte(""HEAD / HTTP/1.0\r\n\r\n"")) 
 checkError(err)
  
  result, err := ioutil.ReadAll(conn)
  
  checkError(err)
  
  fmt.Println(string(result))
  
  
  conn.Close()
  
  
  os.Exit(0) 
  
 }
  
 132",NA
Server Using a Self-Signed Certificate,"If the server uses a self-signed certificate, as might be used internally in an organization or when 
 experimenting, the Go package when will generate an error: ""x509: certificate signed by unknown 
 authority"". Either the certificate must be installed into the client's operating system (which will be O/S 
 dependent), or the client must install the certificate as a root CA. We will show this second way.
  
 An echo server using TLS with 
 any
  certificate is TLSEchoServer.go:
  
 /* TLSEchoServer
  
  */ 
  
 package main
  
 import (
  
  ""crypto/rand""
  
  ""crypto/tls""
  
 133",NA
Conclusion,"Security is a huge area in itself, and this chapter barely touches on it. However, the major concepts have 
 been covered. What has not been stressed is how much security needs to be built into the design phase: 
 security as an afterthought is nearly always a failure.
  
 136",NA
CHAPTER 8,NA,NA
HTTP,"The World Wide Web is a major distributed system, with millions of users. A site may become a web 
 host by running an HTTP server. While web clients are typically users with a browser, there are many 
 other “user agents” such as web spiders, web application clients, and so on.
  
  
 The Web is built on top of the HTTP (Hypertext Transport Protocol), which is layered on top of TCP. 
 HTTP has been through four publically available versions. Version 1.1 (the third version) is the most 
 commonly used, but there is expected to be a rapid transition to HTTP/2 and this is now at over 10% of the 
 current traffic. 
  
 This chapter is an overview of HTTP, followed by the Go APIs to manage HTTP 
 connections.",NA
URLs and Resources,"URLs specify the location of a 
 resource
 . A resource is often a static file, such as an HTML document, an 
 image, or a sound file. But increasingly, it may be a dynamically generated object, perhaps based on 
 information stored in a database.
  
 When a user agent requests a resource, what is returned is not the resource itself, but some 
  
 representation
  of that resource. For example, if the resource is a static file, then what is sent to the user 
 agent is a copy of the file.
  
 Multiple URLs may point to the same resource, and an HTTP server will return appropriate 
 representations of the resource for each URL. For example, an company might make product information 
 available both internally and externally using different URLs for the same product. The internal 
 representation of the product might include information such as internal contact officers for the product, 
 while the external representation might include the location of stores selling the product.
  
 This view of resources means that the HTTP protocol can be fairly simple and straightforward, while an 
 HTTP server can be arbitrarily complex. HTTP has to deliver requests from user agents to servers and 
 return a byte stream, while a server might have to do any amount of processing of the request.",NA
I18n,"There are complications arising from the increasing internationalization (i18n) of the Internet. Hostnames 
 may be given in an internationalized form known as IDN (Internationalized Domain Name). In order to 
 preserve compatibility with legacy implementations that do not understand Unicode (such as older e-mail 
 servers), non-ASCII domain names are mapped into an ASCII representation known as 
 punycode
 . For 
 example, the domain name 
 日本語
 .jp has the punycode value xn—wgv71a119e.jp. The translation from a 
 non-ASCII domain to a punycode value is not performed automatically by the Go net libraries (as of Go 1.7), 
 but there is an extension package called golang.org/x/net/idna that will convert between Unicode and its 
 punycode value. There is an ongoing discussion at “Figure Out IDNA Punycode Story” (
 https://github. 
 com/golang/go/issues/13835
 ) about this topic.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_8
  
 137",NA
HTTP Characteristics,"HTTP is a stateless, connectionless, reliable protocol. In the simplest form, each request from a user agent is 
 handled reliably and then the connection is broken.
  
 In the earliest version of HTTP, each request involved a separate TCP connection, so if many resources 
 were required (such as images embedded in an HTML page), then many TCP connections had to be set up 
 and torn down in a short space of time.
  
  
 HTTP 1.1 added many optimizations in HTTP, which added complexity to the simple structure, but 
 created a more efficient and reliable protocol. HTTP/2 has adopted a binary form for further efficient gains.",NA
Versions,"There are four versions of HTTP:
  
 • 
  
 Version 0.9 (1991): Totally obsolete
  
 • 
  
 Version 1.0 (1996): Almost obsolete
  
 • 
  
 Version 1.1 (1999): Most popular version at present
  
 • 
  
 Version 2 (2015): The latest version
  
 Each version must understand the requests and responses of earlier versions.",NA
HTTP 0.9,"Request format:
  
 Request = Simple-Request
  
 Simple-Request = ""GET"" SP Request-URI CRLF",NA
Response Format,"A response is of the form:
  
 Response = Simple-Response
  
 Simple-Response = [Entity-Body]
  
 138",NA
HTTP 1.0,"This version added much more information to the requests and responses. Rather than ""grow"" the 0.9 
 format, it was just left alongside the new version.",NA
Request Format,"The format of requests from client to server is:
  
 Request = Simple-Request | Full-Request
  
 Simple-Request = ""GET"" SP Request-URI CRLF
  
 Full-Request = Request-Line
  
  
  
  *(General-Header
  
  
   
  | Request-Header
  
  
   
  | Entity-Header)
  
  
  CRLF
  
  
  
  [Entity-Body]
  
 A Simple-Request is an HTTP/0.9 request and must be replied to by a Simple-Response. 
 A Request-Line has this format:
  
 Request-Line = Method SP Request-URI SP HTTP-Version CRLF
  
 Where
  
 Method = ""GET"" | ""HEAD"" | POST |
  
  
  extension-method
  
 Here’s an example:
  
 GET http://jan.newmarch.name/index.html HTTP/1.0",NA
Response Format,"A response is of the form:
  
 Response = Simple-Response | Full-Response
  
 Simple-Response = [Entity-Body]
  
 Full-Response = Status-Line
  
  
  *(General-Header
  
  
  
  | Response-Header
  
  
  
  | Entity-Header)
  
  
  CRLF
  
  
  [Entity-Body]
  
 The Status-Line gives information about the fate of the request:
  
 Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
  
 139",NA
HTTP 1.1,"HTTP 1.1 fixes many problems with HTTP 1.0, but is more complex because of it. This version is done by 
 extending or refining the options available to HTTP 1.0. For example:
  
 • 
  
 There are more commands such as TRACE and CONNECT
  
 140",NA
HTTP/2,"All the earlier versions of HTTP are text-based. The most significant departure for HTTP/2 is that it is a 
 binary format. In order to ensure backward compatibility, this can't be managed by sending a binary 
 message to an older server to see what it does. Instead an HTTP 1.1 message is sent with extra attributes, 
 essentially asking if the server wants to switch to HTTP/2. If it doesn't understand the extra fields it 
 replies with a normal HTTP 1.1 response and the session continues with HTTP 1.1.
  
 Otherwise the server can respond that it is willing to change, and the session can continue with 
 HTTP/2.
  
 The 0.9 protocol took one page. The 1.0 protocol was described in about 20 pages and includes the 0.9 
 protocol. The 1.1 protocol takes 120 pages and is a substantial extension to 1.0, whereas HTTP/2 takes 
 about 96 pages. The HTTP/2 specification just adds to the HTTP 1.1 specification.",NA
Simple User Agents,"User agents such as browsers make requests and get responses. This involves Go types and associated 
 method calls.",NA
The Response Type,"The response type is as follows:
  
 type Response struct {
  
  Status     string // e.g. ""200 OK""
  
  StatusCode int    // e.g. 200
  
  Proto      string // e.g. ""HTTP/1.0""
  
 141",NA
The HEAD Method,"We examine this data structure through examples. Each HTTP request type has its own Go function in the 
 net/http package The simplest request is from a user agent called HEAD, which asks for information about 
 a resource and its HTTP server. This function can be used to make the query:
  
 func Head(url string) (r *Response, err error)
  
 The status of the response is in the response field Status, while the field Header is a map of the header 
 fields in the HTTP response. A program called Head.go to make this request and display the results is as 
 follows:
  
 /* Head
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""host:port"")
   
  
 os.Exit(1)
  
  
  }
  
  
  url := os.Args[1]
  
 142",NA
The GET Method,"Usually, we want to retrieve a representation of a resource rather than just get information about it. The 
 GET request will do this and can be done using the following:
  
 func Get(url string) (r *Response, finalURL string, err error)
  
  
 The content of the response is in the response field Body, which is of type io.ReadCloser. We can print 
 the content to the screen with the program Get.go:
  
 /* Get
  
  */
  
 package main
  
 143",NA
Configuring HTTP Requests,"Go also supplies a lower-level interface for user agents to communicate with HTTP servers. As you might 
 expect, not only does it give you more control over the client requests, but it also requires you to spend 
 more effort in building the requests. However, there is only a small increase in complexity.
  
  
 The data type used to build requests is the type Request. This is a complex type, and we only show 
 the principal fields for now. Several fields, and the full Go doc, are omitted.
  
 145",NA
The Client Object,"To send a request to a server and get a reply, the convenience object Client is the easiest way. This 
 object can manage multiple requests and will look after issues such as whether the server keeps the TCP 
 connection alive, and so on.
  
 This is illustrated in the following program, ClientGet.go.
  
 The program shows how to add HTTP headers, as we add the header Accept-Charset to only accept 
 UTF-8. There is a little hiccup here, caused by a bug in Go which has only been fixed in Go 1.8. The Client. Do 
 function will automatically do a redirect if it gets a 301, 302, 303, or 307 response. Prior to Go 1.8, it didn't 
 copy across the HTTP headers in this redirect.
  
 If you try against a site such as 
 http://www.google.com
 , then it will redirect to a site such as 
 http:// 
 www.google.com.au
  but will lose the Accept-Charset header and return ISO8859-1 (as it should do 
 according to the 1999 HTTP 1.1 specification!). With that proviso—that the program may not give 
 correct results on versions prior to Go 1.8—the program is as follows:
  
 /* ClientGet
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""net/http/httputil""
  
  
  ""net/url""
  
  
  ""os""
  
  
  ""strings"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""http://host:port/page"")
  
  
  os.Exit(1)
  
  
  }
  
  
  url, err := url.Parse(os.Args[1])
  
  
  checkError(err)
  
  client := &http.Client{}
  
  request, err := http.NewRequest(""HEAD"", url.String(), nil)
  
  // only accept UTF-8
  
  request.Header.Add(""Accept-Charset"", ""utf-8;q=1, ISO-8859-1;q=0"") 
 checkError(err)
  
  response, err := client.Do(request)
  
  checkError(err)
  
  if response.Status != ""200 OK"" {
  
  
  fmt.Println(response.Status)
  
  
  os.Exit(2)
  
  }
  
 147",NA
Proxy Handling,"It is very common now for HTTP requests to pass through specific HTTP proxies. This is in addition to the 
 servers that form the TCP connection and act at the application layer. Companies use proxies to limit what 
 their own staff can see, while many organizations use proxy services such as Cloudflare to act as caches, 
 reducing the load on the organization’s own servers. Accessing web sites through proxies requires 
 additional handling by the client.",NA
Simple Proxy,"HTTP 1.1 laid out how HTTP should work through a proxy. A GET request should be made to a proxy. 
 However, the URL requested should be the full URL of the destination. In addition, the HTTP header should 
 contain a Host field, set to the proxy. As long as the proxy is configured to pass such requests through, then 
 that is all that needs to be done.
  
 Go considers this to be part of the HTTP transport layer. To manage this, it has a class Transport. This 
 contains a field that can be set to a 
 function
  that returns an URL for a proxy. If we have an URL as a string for 
 the proxy, the appropriate transport object is created and then given to a client object as follows:
  
 proxyURL, err := url.Parse(proxyString) 
  
 transport := &http.Transport{Proxy: http.ProxyURL(proxyURL)} client 
 := &http.Client{Transport: transport}
  
 The client can then continue as before.
  
 The following program ProxyGet.go illustrates this
  
 /* ProxyGet
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""io""
  
  
  ""net/http""
  
  
  ""net/http/httputil""
  
  
  ""net/url""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 3 {
  
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""http://proxy-host:port  
  
  
  
 http://host:port/page"")
  
  
  
  os.Exit(1)
  
  
  }
  
  
  proxyString := os.Args[1]
  
  
  proxyURL, err := url.Parse(proxyString)
  
  
  checkError(err)
  
  
  rawURL := os.Args[2]
  
 149",NA
Authenticating Proxy,"Some proxies will require authentication, by a username and password in order to pass requests. A common 
 scheme is “basic authentication” in which the username and password are concatenated into a string 
 ""user:password"" and then Base64 encoded. This is then given to the proxy by the HTTP request header 
 ""Proxy-Authorization"" with the flag that it is the basic authentication 
  
  
 The following program ProxyAuthGet.go illustrates this, adding the Proxy-Authentication header to the 
 previous proxy program:
  
 /* ProxyAuthGet
  
  */
  
 package main
  
 import (
  
  
  ""encoding/base64""
  
  
  ""fmt""
  
  
  ""io""
  
  
  ""net/http""
  
  
  ""net/http/httputil""
  
  
  ""net/url""
  
  
  ""os"" 
  
 )
  
 const auth = ""jannewmarch:mypassword""
  
 func main() {
  
  
  if len(os.Args) != 3 {
  
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""http://proxy-host:port  
  
  
  
 http://host:port/page"")
  
  
  
  os.Exit(1)
  
  
  }
  
  
  proxy := os.Args[1]
  
 151",NA
HTTPS Connections by Clients,"For secure, encrypted connections, HTTP uses TLS, which is described in Chapter 
 7
 . The protocol of 
 HTTP+TLS is called HTTPS and uses https:// URLs instead of http:// URLs.
  
 Servers are required to return valid X.509 certificates before a client will accept data from them. If the 
 certificate is valid, then Go handles everything under the hood and the clients given previously run okay 
 with https URLs. That is, programs such as the earlier ClientGet.go run unchanged—you just give them an 
 HTTPS URL.
  
 Many sites have invalid certificates. They may have expired, they may be self-signed instead of by a 
 recognized certificate authority, or they may just have errors (such as having an incorrect server name). 
 Browsers such as Firefox put a big warning notice with a “Get me out of here!” button, but you can carry 
 on at your risk, which many people do.
  
 Go presently bails out when it encounters certificate errors. However, you can configure a client to 
 ignore certificate errors. This is, of course, not advisable—sites with misconfigured certificates may 
 have other problems.
  
 In Chapter 
 7
 , we generated self-signed X.509 certificates. Later in this chapter, we will give an HTTPS 
 server using X.509 certificates, and if the self-signed certificates are used, then ClientGet.go will generate 
 this error:
  
  x509: certificate signed by unknown authority
  
  
 A client that removes these errors and continues does so by turning on the Transport configuration flag 
 InsecureSkipVerify. The unsafe program is TLSUnsafeClientGet.go:
  
 /* TLSUnsafeClientGet
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""net/url""
  
  
  ""os""
  
  
  ""strings""
  
  
  ""crypto/tls"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""https://host:port/page"")
  
  
  os.Exit(1)
  
  
  }
  
 153",NA
Servers,"The other side to building a client is a web server handling HTTP requests. The simplest—and earliest—
 servers just returned copies of files. However, any URL can now trigger an arbitrary computation in current 
 servers.",NA
File Server,"We start with a basic file server. Go supplies a 
 multiplexer
 , that is, an object that will read and interpret 
 requests. It hands out requests to handlers, which run in their own thread. Thus much of the work of 
 reading HTTP requests, decoding them, and branching to suitable functions in their own thread is done for 
 us.
  
 For a file server, Go also gives a FileServer object, which knows how to deliver files from the local file 
 system. It takes a “root” directory, which is the top of a file tree in the local system, and a pattern to match 
 URLs against. The simplest pattern is /, which is the top of any URL. This will match all URLs.
  
  
 An HTTP server delivering files from the local file system is almost embarrassingly trivial given these 
 objects. It is FileServer.go:
  
 /* File Server
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  // deliver files from the directory /var/www
  
  fileServer := http.FileServer(http.Dir(""/var/www""))
  
  // register the handler and deliver requests to it err := 
 http.ListenAndServe("":8000"", fileServer)
  
 155",NA
Handler Functions,"In this last program, the handler was given in the second argument to ListenAndServe. Any number of 
 handlers can be registered first by calls to Handle or HandleFunc, with these signatures:
  
 func Handle(pattern string, handler Handler) 
  
 func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
  
 The second argument to ListenAndServe could be nil, and then calls are dispatched to all registered 
 handlers. Each handler should have a different URL pattern. For example, the file handler might have URL 
 pattern /, while a function handler might have URL pattern /cgi-bin. A more specific pattern takes 
 precedence over a more general pattern.
  
  
 Common CGI programs are test-cgi (written in the shell) and printenv (written in Perl), which print the 
 values of the environment variables. A handler can be written to work in a similar manner as PrintEnv.go.
  
 /* Print Env
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""os"" 
  
 ) 
  
 Arial 
  
 func main() {
  
  
  // file handler for most files
  
  
  fileServer := http.FileServer(http.Dir(""/var/www""))
  
  
 http.Handle(""/"", fileServer)
  
 156",NA
Bypassing the Default Multiplexer,"HTTP requests received by a Go server are usually handled by a multiplexer, which examines the path in the 
 HTTP request and calls the appropriate file handler, etc. You can define your own handlers. These can be 
 registered with the default multiplexer by calling http.HandleFunc, which takes a pattern and a function. 
 The functions such as ListenAndServe then take a nil handler function. This was done in the last example.
  
  
 However, if you want to take over the multiplexer role then you can give a non-nil function as the 
 handler function to ListenAndServe. This function will then be responsible for managing the requests and 
 responses.
  
  
 The following example is trivial, but illustrates the use of this. The multiplexer function simply returns 
 a ""204 No content"" for 
 all
  requests to ServerHandler.go:
  
 /* ServerHandler
  
  */
  
 package main
  
 import (
  
  
  ""net/http"" 
  
 )
  
 func main() {
  
  myHandler := http.HandlerFunc(func(rw http.ResponseWriter, request *http.Request) {
  
  // 
 Just return no content - arbitrary headers can be set, arbitrary body
  
  
 rw.WriteHeader(http.StatusNoContent)
  
  })
  
  
  http.ListenAndServe("":8080"", myHandler) }
  
 The server may be tested by running telnet against it to give output such as this:
  
 $telnet localhost 8080 
  
 Trying 127.0.0.1...
  
 Connected to localhost. 
  
 Escape character is '^]'.
  
 GET / HTTP/1.0
  
 HTTP/1.0 204 No Content 
  
 Date: Tue, 10 Jan 2017 05:32:53 GMT
  
 Or by using this:
  
 curl -v localhost:8080
  
 To give this output:
  
 * Rebuilt URL to: localhost:8080/ 
  
 *   Trying 127.0.0.1...
  
 * Connected to localhost (127.0.0.1) port 8080 (#0)
  
 158",NA
HTTPS,"For secure, encrypted connections, HTTP uses TLS, which is described in Chapter 
 7
 . The protocol of 
 HTTP+TLS is called HTTPS and uses https:// URLs instead of http:// URLs.
  
 For a server to use HTTPS, it needs an X.509 certificate and a private key file for that certificate. Go at 
 present requires that these be PEM-encoded as used in Chapter 
 7
 . Then the HTTP function ListenAndServe 
 is replaced with the HTTPS (HTTP+TLS) function ListenAndServeTLS.
  
 The file server program given earlier can be written as an HTTPS server as HTTPSFileServer.go:
  
 /* HTTPSFileServer
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  // deliver files from the directory /var/www
  
  fileServer := http.FileServer(http.Dir(""/var/www""))
  
  // register the handler and deliver requests to it
  
  err := http.ListenAndServeTLS("":8000"", ""jan.newmarch.name.pem"",
  
  ""private.pem"", fileServer)
  
  checkError(err)
  
  // That's it!
  
 }
  
 func checkError(err error) {
  
  
  if err != nil {
  
  
  
  fmt.Println(""Fatal error "", err.Error())
   
  
 os.Exit(1)
  
  
  } 
  
 }
  
 159",NA
Conclusion ,"Go has extensive support for HTTP. This is not surprising, since Go was partly invented to fill a need by 
 Google 
  
 for their own servers. This chapter discussed the various levels of support given by Go for HTTP and HTTPS.
  
 160",NA
CHAPTER 9,NA,NA
Templates,"Most server-side languages have a mechanism for taking predominantly static pages and inserting a 
 dynamically generated component, such as a list of items. Typical examples are scripts in Java Server Pages, 
 PHP scripting, and many others. Go has adopted a relatively simple scripting language in the template 
 package.
  
 The package is designed to take text as input and output different text, based on transforming the 
 original text using the values of an object. Unlike JSP or similar, it is not restricted to HTML files but it is 
 likely to find greatest use there. We first describe the text/template package and later the html/template 
 package.
  
 The original source is called a 
 template
  and will consist of text that is transmitted unchanged, and 
 embedded commands that can act on and change text. The commands are delimited by {{ ... }} , similar to the 
 JSP commands <%= ... =%> and PHP’s <?php ... ?>.",NA
Inserting Object Values,"A template is applied to a Go object. Fields from that Go object can be inserted into the template, and you 
 can “dig” into the object to find subfields, etc. The current object is represented as the 
 cursor
 ., so that to 
 insert the value of the current object as a string, you use {{.}}. The package uses the fmt package by default 
 to work out the string used as inserted values.
  
  
 To insert the value of a field of the current cursor object, you use the field name prefixed by .. For 
 example, if the current cursor object is of type
  
 type Person struct {
  
  
  Name      string
  
  
  Age       int
  
  
  Emails     []string
  
  
  Jobs       []*Job 
  
 }
  
 You insert the values of Name and Age as follows:
  
 The name is {{.Name}}. 
  
 The age is {{.Age}}.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_9
  
 161",NA
Using Templates,"Once you have a template, you can apply it to an object to generate a new string, using the object to fill in 
 the template values. This is a two-step process that involves parsing the template and then applying it to 
 an object. The result is output to a Writer, as in:
  
 t := template.New(""Person template"") 
  
 t, err := t.Parse(templ) 
  
 if err == nil {
  
  
  buff := bytes.NewBufferString("""")
  
  
  t.Execute(buff, person) 
  
 }
  
 An example program to apply a template to an object and print to standard output is PrintPerson.go:
  
 /**
  
  * PrintPerson
  
  */
  
 package main
  
 162",NA
Pipelines,"The above transformations insert pieces of text into a template. Those pieces of text are essentially 
 arbitrary, whatever the string values of the fields are. If we want them to appear as part of an HTML 
 document (or other specialized form), we will have to escape particular sequences of characters. For 
 example, to display arbitrary text in an HTML document, we have to change < to &lt;. The Go templates have 
 a number of built-in functions, and one of these is html(). These functions act in a similar manner to UNIX 
 pipelines, reading from standard input and writing to standard output.
  
  
 To take the value of the current object . and apply HTML escapes to it, you write a “pipeline” in the 
 template:
  
 {{. | html}}
  
 And do similarly for other functions.
  
 164",NA
Defining Functions,"The templates use the string representation of an object to insert values, using the fmt package to convert 
 the object to a string. Sometimes this isn’t what is needed. For example, to avoid spammers getting hold of 
 e-mail addresses, it is quite common to see the symbol @ replaced by the word “at,” as in “jan at 
 newmarch.
  
 name”. If we want to use a template to display e-mail addresses in that form, we have to build a 
 custom function to do this transformation.
  
  
 Each template function has a name that is used in the templates themselves and an associated Go 
 function. These are linked by this type:
  
 type FuncMap map[string]interface{}
  
  
 For example, if we want our template function to be emailExpand, which is linked to the Go function 
 EmailExpander, we add this to the functions in a template as follows:
  
 t = t.Funcs(template.FuncMap{""emailExpand"": EmailExpander})
  
 The signature for EmailExpander is typically this:
  
 func EmailExpander(args ...interface{}) string
  
 For the use we are interested in, there should be only one argument to the function, which will be a 
 string. Existing functions in the Go template library have some initial code to handle non-conforming cases, 
 so we just copy that. Then it is just simple string manipulation to change the format of the e-mail address. A 
 program is PrintEmails.go:
  
 /**
  
  * PrintEmails
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""os""
  
  
  ""strings""
  
  
  ""text/template"" 
  
 )
  
 type Person struct {
  
  
  Name   string
  
  
  Emails []string 
  
 }
  
 const templ = `The name is {{.Name}}.
  
 {{range .Emails}}
  
  
  An email is ""{{. | emailExpand}}"" 
  
 {{end}} 
  
 `
  
 165",NA
Variables,"The template package allows you to define and use variables. As motivation for this, consider how we might 
 print each person’s e-mail address 
 prefixed
  by their name. The type we use is again this one:
  
 type Person struct {
  
  
  Name      string
  
  
  Emails     []string 
  
 }
  
 To access the e-mail strings, we use a range statement such as this:
  
 {{range .Emails}}
  
  
  {{.}} 
  
 {{end}}
  
 But at that point we cannot access the Name field, as . is now traversing the array elements and Name 
 is outside of this scope. The solution is to save the value of the Name field in a variable that can be 
 accessed anywhere in its scope. Variables in templates are prefixed by $. So we write this:
  
 {{$name := .Name}} 
  
 {{range .Emails}}
  
  
  Name is {{$name}}, email is {{.}} 
  
 {{end}}
  
 The program is PrintNameEmails.go:
  
 /**
  
  * PrintNameEmails
  
  */
  
 package main
  
 import (
  
  
  ""text/template""
  
  
  ""os""
  
  
  ""fmt"" 
  
 )
  
 type Person struct {
  
  
  Name   string
  
  
  Emails []string 
  
 }
  
 const templ = `{{$name := .Name}} 
  
 {{range .Emails}}
  
  
  Name is {{$name}}, email is {{.}} 
  
 {{end}} 
  
 `
  
 167",NA
Conditional Statements,"Continuing with the Person example, suppose you just want to print out the list of e-mails, without digging 
 into it. You can do that with a template:
  
 Name is {{.Name}} 
  
 Emails are {{.Emails}}
  
 This will print the following:
  
 Name is jan 
  
 Emails are [jan@newmarch.name jan.newmarch@gmail.com]
  
 Because this is how the fmt package will display a list.
  
 In many circumstances that may be fine, if that is what you want. Let’s consider a case where it is 
 almost 
 right, but not quite. There is a JSON package to serialize objects, which we looked at in Chapter 
 4
 . This would 
 produce the following:
  
 {""Name"": ""jan"",
  
  ""Emails"": [""jan@newmarch.name"", ""jan.newmarch@gmail.com""] }
  
 168",NA
The HTML / Template Package,"The preceding programs all dealt with the text/template package. This applies transformations without 
 regard to any context in which the text might be used. For example, if the text in PrintPerson.go changes to:
  
 job1 := Job{Employer: ""<script>alert('Could be nasty!')</script>"", Role: ""Director, Commerce and ICT""}
  
 The program will generate this text:
  
 An employer is <script>alert('Could be nasty!')</script>
  
 This will cause an unexpected effect if downloaded to a browser.
  
  
 The use of the html command in a pipeline can reduce this, as in {{. | html}}, and will produce the 
 following:
  
 An employer is &lt;script&gt;alert(&#39;Could be nasty!&#39;)&lt;/script&gt
  
  
 Applying this filter to all expressions will become tedious. In addition, it may not catch potentially 
 dangerous JavaScript, CSS, or URI expressions.
  
 The html/template package is designed to overcome these issues. By the simple step of replacing 
 text/template with html/template, the appropriate transformations will be applied to the resultant text, 
 sanitizing it so that it is suitable for web contexts.",NA
Conclusion,"The Go template package is useful for certain kinds of text transformations involving inserting values of 
 objects. It does not have the power of regular expressions for example, but it is faster and in many cases 
 will be easier to use than regular expressions.
  
 173",NA
CHAPTER 10,NA,NA
A Complete Web Server,"This chapter is principally an illustration of the HTTP chapter, building a complete Web server in Go. It also 
 shows how to use templates in order to use expressions in text files to insert variable values and to generate 
 repeated sections. It deals with serialized data and Unicode character sets. The programs in this chapter are 
 sufficiently long and complex so they are not always given in their entirety, but can be downloaded from the 
 book’s web site, which is 
 http://www.apress.com/9781484226919
 .
  
 I am learning Chinese. Rather, after many years of trying, I am still 
 attempting
  to learn Chinese. Of 
 course, rather than buckling down and getting on with it, I have tried all sorts of technical aids. I tried text 
 books, videos, and many other teaching aids. Eventually I realized that the reason for my poor progress 
 was that there 
 wasn't a good computer program for Chinese flashcards
 , and so in the interests of learning, I 
 needed to build one.
  
 I found a program in Python to do some of the task. But sad to say it wasn’t well written and after a few 
 attempts at turning it upside down and inside out, I came to the conclusion that it was better to start from 
 scratch. Of course, a web solution would be far better than a standalone one, because then all the other 
 people in my Chinese class could share it, as well as any other learners out there. And of course, the server 
 would be written in Go.
  
  
 I used the vocabulary from the lessons in the book 
 Intensive Spoken Chinese
  by Zhang Pengpeng 
 (Sinolingua, 2007, ISBN 978-7-80052577-3) but the program is applicable to any vocabulary sets.",NA
Browser Site Diagram,"The resultant program as viewed in the browser has three types of pages, illustrated in Figure 
 10-1
 .",NA
Home page ,NA,NA
List of ,NA,NA
Flashcard sets,NA,NA
Flashcard ,NA,NA
set ,NA,NA
words one ,NA,NA
at ,NA,NA
a time,NA,NA
Flashcard set ,NA,NA
all words,"Figure 10-1.
  Browser pages
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_10
  
 175",NA
Browser Files ,"The browser side has HTML, CSS, and JavaScript files. These are as follows:• 
  
 Home page (flashcards.html):
  
  
  
  
 • 
  
 html/ListFlashcardsStylesheet.css
  
 • 
  
 Flashcard set (ShowFlashcards.html):
  
  
  
  
 • 
  
 css/CardStyleSheet.css
  
  
  
  
 • 
  
 jscript/jquery.js
  
  
  
  
 • 
  
 jscript/slideviewer.js
  
 • 
  
 Flashcard set words (ListWords.html): None extra",NA
Basic Server ,"The server is an HTTP server as discussed in the previous chapter. It has a number of functions to 
 handle different URLs. The functions are outlined here:
  
 Path
  
 Function
  
 HTML Delivered
  
 /
  
 listFlashCards
  
 html/ListFlashcards.html
  
 /flashcards.html
  
 listFlashCards
  
 html/ListFlashcards.html
  
 /flashcardSets
  
 manageFlashCards
  
 html/showFlashcards.html
  
 /flashcardSets
  
 manageFlashCards
  
 html/ListWords.html
  
 /jscript/*
  
 fileServer
  
 Files from directory /jscript
  
 /html/*
  
 fileServer
  
 Files from directory /html
  
 177",NA
The listFlashCards Function,"The listFlashCards function is called to create HTML for the top-level page. The list of flashcard names is 
 extensible and is the set of file entries in the directory flashcardSets. This list is used to create the table in 
 the top-level page and is best done using the template package:
  
 <table>
  
  {{range .}}
  
  <tr>
  
   
  <td>
  
    
  {{.}}
  
   
  </td>
  
  </tr> 
  
 </table>
  
  
 Where the range is over the list of names. The file html/ListFlashcards.html contains this template as 
 well as the HTML for the side lists of card order, half card display, and the form buttons at the bottom. 
  
 Omitting the side lists and the submit buttons, the HTML is as follows:
  
 <html>
  
  <head>
  
   
  <title>
  
    
  Flashcards
  
   
  </title>
  
   
  <link type=""text/css"" rel=""stylesheet""
  
     
  href=""/html/ListFlashcardsStylesheet.css"">
  
  
  </link>
  
  </head>
  
  <body>
  
 179",NA
The manageFlashCards Function,"The manageFlashCards function is called to manage the form submission on pressing the “Show Cards in 
 Set” button or the “List Words in Set” button. It extracts values from the form request and then chooses 
 between showFlashCards and listWords:
  
 func manageFlashCards(rw http.ResponseWriter, req *http.Request) {
  
  set := req.FormValue(""flashcardSets"")
  
  order := req.FormValue(""order"")
  
  action := req.FormValue(""submit"")
  
  half := req.FormValue(""half"")
  
  cardname := ""flashcardSets/"" + set
  
  
  fmt.Println(""cardname"", cardname, ""action"", action)
  
  if 
 action == ""Show cards in set"" {
  
  
  
  showFlashCards(rw, cardname, order, half)
  
  } 
 else if action == ""List words in set"" {
  
  
  
  listWords(rw, cardname)
  
  
  } 
  
 }",NA
The Chinese Dictionary,"The previous code was fairly generic: it delivers static files using a FileServer, creates HTML tables using 
 templates based on a listing of files in a directory, and processes information from an HTML form. To 
 proceed further by looking at what is displayed in each card, we have to get into the application-specific 
 detail and that means looking at the source of words (a dictionary), how to represent it and the cards, 
 and how to send flashcard data to the browser. First, the dictionary.
  
 Chinese is a complex language—aren’t they all :-(. The written form is hieroglyphic, that is “pictograms,” 
 instead of using an alphabet. But this written form has evolved over time, and even recently split into two 
 forms: “traditional” Chinese as used in Taiwan and Hong Kong, and “simplified” Chinese as used in mainland 
 China. While most of the characters are the same, about 1,000 are different. Thus a Chinese dictionary will 
 often have two written forms of the same character.
  
 Most Westerners like me can’t understand these characters. So there is a “Latinized” form called Pinyin, 
 which writes the characters in a phonetic alphabet based on the Latin alphabet. It isn’t quite the Latin 
 alphabet, because Chinese is a tonal language, and the Pinyin form has to show the tones (much like accents 
 in French and other European languages). So a typical dictionary has to show four things: the traditional 
 form, the simplified form, the Pinyin, and the English. In addition (just like in English), a word may have 
  
 181",NA
The Dictionary Type ,"We use an Entry to hold the basic information about one word:
  
 type Entry struct {
  
  
  Traditional string
  
  
  Simplified string
  
  
  Pinyin     string
  
  
  Translations []string 
  
 }
  
 The word above would be represented by the following:
  
 Entry{Traditional: 
 好
 ,
  
  
  Simplified: 
 好
 ,
  
  
  Pinyin: `hao3`
  
  
  Translations: []string{`good`, `well`,`proper`,
  
  
  
  `good to`, `easy to`, `very`, `so`,  
  
  
  
  `(suffix indicating completion or readiness)`} }
  
 The dictionary itself is just an array of these entries:
  
 type Dictionary struct {
  
  
  Entries []*Entry 
  
 }
  
 182",NA
Flashcard Sets,"A single flashcard is meant to represent a Chinese word and the English translation of that word. We have 
 already seen that a single Chinese word can have many possible English meanings. But this dictionary also 
 sometimes has multiple occurrences of a Chinese word. For example, 
 好
  occurs at least twice, once with the 
 meaning we have already seen, but also with another meaning, “to be fond of”. It turned out to be overkill, 
 but to allow for this, each flashcard is given a full dictionary of words. Typically there is only one entry in 
 the dictionary! The rest of a flashcard is just the simplified and English words to act as possible keys:
  
 type FlashCard struct {
  
  
  Simplified string
  
  
  English    string
  
  
  Dictionary *dictionary.Dictionary 
  
 }
  
 The 
 set
  of flashcards is an array of these, plus the name of the set, and information that will be sent to 
 the browser for presentation of the set: random or fixed order, showing the top or bottom of each card 
 first, or random.
  
 type FlashCards struct {
  
  
  Name      string
  
  
  CardOrder string
  
  
  ShowHalf  string
  
  
  Cards     []*FlashCard 
  
 }
  
 We have shown one function for this type already, ListFlashCardsNames(). There is one other function 
 of interest for this type to load a JSON file for a flashcard set. This uses the techniques of Chapter 
 4
 , 
 serialization
 .
  
 func LoadJSON(fileName string, key interface{}) {
  
  
 inFile, err := os.Open(fileName)
  
  
  checkError(err)
  
  
  decoder := json.NewDecoder(inFile)
  
  
  err = decoder.Decode(key)
  
  
  checkError(err)
  
  
  inFile.Close() 
  
 }
  
  
 A typical flashcard set is of common words. When the JSON file is pretty printed by Python (print 
 json.dump(string, indent=4, separators=(',', ':'))), part of it looks like this:
  
 {
  
  
  ""ShowHalf"":"""",
  
  
  ""Cards"":[
  
  
  
  {
  
  
  
  
  ""Simplified"":""你好"",
  
  
  
  
  ""Dictionary"":{
  
  
  
  
  
  ""Entries"":[
  
  
  
  
  
  
  {
  
  
  
  
  
  
  
  ""Traditional"":""你好"",
  
 183",NA
Fixing Accents,"There is one last major task before we can complete the code for the server. The accents as given in the 
 dictionaries place the accent at the end of the Pinyin word, as in hao3 for hǎo. The translation to Unicode 
 can be performed by a custom template, as discussed in Chapter 
 9
 .
  
  
 The code for the Pinyin formatter is given here. Don’t bother reading it unless you are 
 really
  
 interested in knowing the rules for Pinyin formatting. The program is PinyinFormatter.go:
  
 package templatefuncs
  
 import (
  
  
  ""fmt""
  
  
  ""strings"" 
  
 )
  
 184",NA
The ListWords Function,"We can now return to the outstanding functions of the server. One was to list the words in a flashcards set. 
 This populates an HTML table using a template for a flashcards set. The HTML for this uses the template 
 package to walk over a FlashCards struct and insert the fields from that struct:
  
 <html>
  
  <head>
  
   
  <title>
  
    
  Words for {{.Name}}
  
   
  </title>
  
  </head>
  
  <body>
  
  
  <h1>
  
   
  Words for {{.Name}}
  
  
  </h1>
  
  
  <p>
  
   
  <table border=""1"" class=""sortable"">
  
    
  <tr>
  
     
  <th> English </th>
  
     
  <th> Pinyin </th>
  
 187",NA
The showFlashCards Function,"The final function to complete the server is showFlashCards. This changes the default values of CardOrder 
 and ShowHalf in the flashcard set based on the form submitted from the browser. It then applies the 
 PinyinFormatter and sends the resulting document to the browser. I captured the output of a command-line 
 session using the UNIX command script and then ran the command:
  
 GET /flashcardSets?flashcardSets=Common+Words&order=Random&half=Chinese&submit=Show+cards+i 
 n+set HTTP/1.0
  
 Part of the result is as follows:
  
 <html>
  
  <head>
  
   
  <title>
  
    
  Flashcards for Common Words
  
   
  </title>
  
  <link type=""text/css"" rel=""stylesheet""
  
  href=""/html/CardStylesheet.css"">
  
  </link>
  
 189",NA
Presentation on the Browser,"The final part of this system is how this HTML is shown in the browser. Figure 
 10-3
  shows a screen of four 
 parts displaying the English, the simplified Chinese, the alternative translations and the traditional/ 
 simplified pair. How this is done is by the JavaScript program downloaded to the server (this takes place 
 using the FileServer Go object). The JavaScript slideviewer.js file is actually pretty long and is omitted 
 from the text. It is included in the program files at 
 http://www.apress.com/9781484226919
 .",NA
Running the Server,"This is the first program in this book that uses our own imported files. All the previous programs have just 
 used a main file and the Go standard libraries. The imported files in the package’s dictionary, flashcards 
 and pinyin, need to be organized so that the go command can find them.
  
  
 The environment variable GOPATH needs to be set to a directory with a subdirectory src containing 
 the imported source files in the appropriate subdirectories:
  
 src/flashcards/FlashCards.go 
  
 src/pinyin/PinyinFormatter.go 
  
 src/dictionary/Dictionary.go
  
 The server can then be run on port 8000 (or other port) using a command such as this:
  
 go run Server.go :8000",NA
Conclusion,"This chapter has considered a relatively simple but complete web server, using static and dynamic 
 web pages with form handling and using templates for simplifying coding.
  
 191",NA
CHAPTER 11,NA,NA
HTML,"The Web was originally created to serve HTML documents. Now it is used to serve all sorts of documents 
 as well as data of different kinds. Nevertheless, HTML is still the main document type delivered over the 
 Web.
  
  
 HTML has been through a large number of versions, with the current version being HTML5. There have 
 also been many “vendor” versions of HTML, introducing tags that never made it into the standards.
  
 HTML is simple enough to be edited by hand. Consequently, many HTML documents are “ill formed,” 
 which means they don’t follow the syntax of the language. HTML parsers generally are not very strict and 
 will accept many “illegal” documents.
  
  
 The HTML package itself only has two functions—EscapeString and UnescapeString. These properly 
 handle characters such as <, converting them to &lt; and back again.
  
 A principal use of this might be to escape the markup in an HTML document so that if it is displayed in 
 a browser, it will show all the markup (much like Ctrl+U in Chrome on Linux or Option+Cmd+U on Mac 
 Chrome).
  
 I’m more likely to use this to show the text of a program as a web page. Most programming languages 
 have the < symbol and many have &. These mess up an HTML viewer unless escaped properly. I like to show 
 program text directly out of the file system rather than copy and paste it into a document, to avoid getting 
 out of synch.
  
  
 The following program EscapeString.go is a web server that shows its URL in preformatted code, 
 having escaped the troublesome characters:
  
 /*
  
  * This program serves a file in preformatted, code layout * Useful for 
 showing program text, properly escaping special * characters like '<', '>' 
 and '&'
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""html""
  
  
  ""io/ioutil""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_11
  
 193",NA
The Go HTML/Template Package,"There are many attacks that can be made on web servers, the most notable being SQL-injection, where a 
 user-agent enters data into a web form deliberately designed to be passed into a database and wreak 
 havoc there. Go does not have any particular support to avoid this, since there are many variances among 
 databases as to the SQL-injection techniques that can succeed. The SQL Injection Prevention Cheat Sheet 
 (see 
 https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet
 ) summarizes the 
 defenses against such attacks. The principal one is to avoid such attacks by using SQL 
 prepared statements, 
 which can be done using the Prepare function in the database/sql package.
  
  
 More subtle attacks are based on XSS—cross-site-scripting. This is where an attacker is not trying to 
 attack the web site itself, but stores malicious code on the server, to attack any of the clients of that web 
 site.
  
 194",NA
Tokenizing HTML,"The package golang.org/x/net/html in the Go sub-repositories contains a tokenizer for HTML. This allows 
 you to build a parse tree of HTML tokens. It is compliant with HTML5.
  
 It can be used after running this:
  
 go get golang.org/x/net/html
  
 An example program using this is ReadHTML.go:
  
 /* Read 
 HTML
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""golang.org/x/net/html""
  
  
  ""io/ioutil""
  
  
  ""os""
  
  
  ""strings"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""file"")
  
  
  os.Exit(1)
  
  
  }
  
 195",NA
XHTML/HTML,"There is also limited support for XHTML/HTML in the XML package, discussed in the next chapter.
  
 197",NA
JSON ,"There is good support for JSON, as discussed in Chapter 
 4
 .",NA
Conclusion ,"There isn’t much to this package. The sub-package html/template was discussed in Chapter 
 9
  on templates.
  
 198",NA
CHAPTER 12,NA,NA
XML,"XML is a significant markup language mainly intended as a means of representing structured data using 
 a text format. In the language we used in Chapter 
 4
 , it can be considered as a means of serializing data 
 structures as a text document. It is used to describe documents such as DocBook and XHTML. It is used 
 in specialized markup languages such as MathML and CML (Chemistry Markup Language). It is used to 
 encode data as SOAP messages for Web Services, and the Web Service can be specified using WSDL 
 (Web Services Description Language).
  
 At the simplest level, XML allows you to define your own tags for use in text documents. Tags can be 
 nested and can be interspersed with text. Each tag can also contain attributes with values. For example, the 
 file person.xml may contain:
  
 <person>
  
  <name>
  
   
  <family> Newmarch </family>
  
   
  <personal> Jan </personal>
  
  </name>
  
  <email type=""personal"">
  
   
  jan@newmarch.name
  
  </email>
  
  <email type=""work"">
  
   
  j.newmarch@boxhill.edu.au
  
  </email> 
  
 </person>
  
 The structure of any XML document can be described in a number of ways:
  
 • 
  
 A document type definition DTD is good for describing structure
  
 • 
  
 XML schema are good for describing the data types used by an XML document
  
 • 
  
 RELAX NG is proposed as an alternative to both
  
 There is argument over the relative value of each way of defining the structure of an XML document. 
 We won’t buy into that, as Go does not support any of them. Go cannot check for validity of any document 
 against a schema, but only for well-formedness. Even well-formedness is an important characteristic of 
 XML documents, and is often a problem with HTML documents in practice. That makes XML suitable for 
 representation of even very complex data, while HTML is not.
  
  
 Four topics are discussed in this chapter: parsing an XML stream, marshalling and unmarshalling Go 
 data into XML, and XHTML.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_12
  
 199",NA
Parsing XML,"Go has an XML parser that’s created using NewDecoder from the encoding/xml package. This takes an 
 io.Reader as a parameter and returns a pointer to Decoder. The main method of this type is Token, which 
 returns the next token in the input stream. The token is one of these types—StartElement, EndElement, 
 CharData, Comment, ProcInst, or Directive.
  
 We will use this type:
  
 type Name struct {
  
  
  Space, Local string 
  
 }
  
  
 The XML types are StartElement, EndElement, CharData, Comment, ProcInst, and Directive. They are 
 described next.",NA
The StartElement Type,"The type StartElement is a structure with two field types:
  
 type StartElement struct {
  
  
  Name Name
  
  
  Attr []Attr 
  
 }
  
 where
  
 type Attr struct {
  
  
  Name  Name
  
  
  Value string 
  
 }",NA
The EndElement Type,"This is also a structure as follows:
  
 type EndElement struct {
  
  
  Name Name 
  
 }",NA
The CharData Type,"This type represents the text content enclosed by a tag and is a simple type:
  
 type CharData []byte",NA
The Comment Type,"Similarly for this type:
  
 type Comment []byte
  
 200",NA
The ProcInst Type,"A ProcInst represents an XML processing instruction of the form <?target inst?>:
  
 type ProcInst struct {
  
  
  Target string
  
  
  Inst   []byte 
  
 }",NA
The Directive Type,"A Directive represents an XML directive of the form <!text>. The bytes do not include the <! and > 
 markers.
  
 type Directive []byte
  
 A program to print out the tree structure of an XML document is ParseXML.go:
  
 /* Parse XML
  
  */
  
 package main
  
 import (
  
  
  ""encoding/xml""
  
  
  ""fmt""
  
  
  ""io/ioutil""
  
  
  ""os""
  
  
  ""strings"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""file"")
  
  
  os.Exit(1)
  
  
  }
  
  
  file := os.Args[1]
  
  
  bytes, err := ioutil.ReadFile(file)
  
  
  checkError(err)
  
  
  r := strings.NewReader(string(bytes))
  
  parser := xml.NewDecoder(r)
  
  depth := 0
  
  for {
  
  
  token, err := parser.Token()
  
  
  if err != nil {
  
  
  
  break
  
  
  }
  
 201",NA
Unmarshalling XML,"Go provides a function called Unmarshal to unmarshal XML into Go data structures. The unmarshalling is 
 not perfect: Go and XML are different languages.
  
  
 We consider a simple example before looking at the details. First consider the XML document given 
 earlier:
  
 <person>
  
  <name>
  
   
  <family> Newmarch </family>
  
   
  <personal> Jan </personal>
  
  </name>
  
 203",NA
Marshalling XML,"Go also has support for marshalling data structures into an XML document. The function is:
  
 func Marshal(v interface}{) ([]byte, error)
  
 A program to marshal a simple structure is Marshal.go:
  
 /* Marshal
  
  */
  
 package main
  
 import (
  
  
  ""encoding/xml""
  
  
  ""fmt"" 
  
 )
  
 type Person struct {
  
  
  Name  Name
  
  
  Email []Email 
  
 }
  
 206",NA
XHTML,"HTML does not conform to XML syntax. It has unterminated tags such as <br>. XHTML is a cleanup of HTML 
 to make it compliant with XML. Documents in XHTML can be managed using the techniques above for XML. 
  
 XHTML does not appear to be as widely used as originally expected. My own suspicion is that an HTML 
 parser is usually tolerant of errors and when used in a browser generally makes a reasonable job of 
 rendering a document, XHTML parsers even in a browser tend to be more strict and often fail to render 
 anything upon encountering even a single XML error. This is not generally appropriate behavior for user-
 facing software.",NA
HTML,"There is some support in the XML package to handle HTML documents even though they may not be XML 
 compliant. The XML parser discussed earlier can handle many HTML documents if it is modified by turning 
 off strict parse checking.
  
 parser := xml.NewDecoder(r) 
  
 parser.Strict = false 
  
 parser.AutoClose = xml.HTMLAutoClose 
  
 parser.Entity = xml.HTMLEntity",NA
Conclusion,"Go has basic support for dealing with XML strings. It does not as yet have mechanisms for dealing with XML 
 specification languages such as XML Schema or Relax NG.
  
 207",NA
CHAPTER 13,NA,NA
Remote Procedure Call,"Socket and HTTP programming both use a message-passing paradigm. A client sends a message to a 
 server, which usually sends a message back. Both sides are responsible for creating messages in a 
 format understood by both sides, and in reading the data out of those messages.
  
 However, most standalone applications do not use message passing techniques much. Generally the 
 preferred mechanism is that of the 
 function
  (or method or procedure) call. In this style, a program will call a 
 function with a list of parameters, and on completion of the function call, will have a set of return values. 
 These values may be the function value, or if addresses have been passed as parameters then the contents of 
 those addresses might have been changed.
  
 The remote procedure call is an attempt to bring this style of programming into the network world. 
 Thus a client will make what looks to it like a normal procedure call. The client side will package this into 
 a network message and transfer it to the server. The server will unpack this and turn it back into a 
 procedure call on the server side. The results of this call will be packaged up for return to the client.
  
 Diagrammatically it looks like Figure 
 13-1
 .",NA
Client,NA,NA
3,NA,NA
Server,NA,NA
procedure,NA,NA
program,NA,NA
implementations,NA,NA
1,NA,NA
10,NA,NA
5,NA,NA
6,NA,NA
Client,NA,NA
Server,NA,NA
procedure,NA,NA
procedure,NA,NA
stubs,NA,NA
stubs,NA,NA
2,NA,NA
9,NA,NA
4,NA,NA
7,NA,NA
Network,NA,NA
Network,NA,NA
routines,NA,NA
8,NA,NA
routines,"Figure 13-1.
  The remote procedure call steps
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_13
  
 209",NA
Go’s RPC,"Go's RPC is so far unique to Go. It is different than the other RPC systems, so a Go client will only talk to a Go 
 server. It uses the Gob serialization system discussed in Chapter 
 4
 , which defines the data types that can be 
 used.
  
 RPC systems generally make some restrictions on the functions that can be called across the network. 
  
 This is so that the RPC system can properly determine which value arguments are sent, which reference 
 arguments receive answers, and how to signal errors.
  
 In Go, the restriction is that
  
 • 
  
 The method's type is exported (begins with a capital letter).
  
 • 
  
 The method is exported.
  
 • 
  
 The method has two arguments, both exported (or built-in) types. The first is for 
 data 
  
 passed into the method; the second is for returned results.
  
 210",NA
HTTP RPC Server,"Any RPC needs a transport mechanism to get messages across the network. Go can use HTTP or TCP. The 
 advantage of the HTTP mechanism is that it can leverage the HTTP support library. You need to add an RPC 
 handler to the HTTP layer, which is done using HandleHTTP, and then start an HTTP server. The complete 
 code is ArithServer.go:
  
 /**
  
  * ArithServer
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/rpc""
  
  
  ""errors""
  
  
  ""net/http"" 
  
 )
  
 type Values struct {
  
  
  A, B int 
  
 }
  
 type Quotient struct {
  
  
  Quo, Rem int 
  
 }
  
 type Arith int
  
 func (t *Arith) Multiply(args *Values, reply *int) error {
  
  *reply = 
 args.A * args.B
  
  
  return nil 
  
 }
  
 func (t *Arith) Divide(args *Values, quo *Quotient) error {
  
  if 
 args.B == 0 {
  
  
  
  return errors.New(""divide by zero"")
  
  
  }
  
  
  quo.Quo = args.A / args.B
  
  
  quo.Rem = args.A % args.B
  
  
  return nil 
  
 }
  
 func main() {
  
  arith 
 := 
 new(Arith)
  
  rpc.Register(arith)
  
  rpc.HandleHTTP()
  
 212",NA
HTTP RPC Client,"The client needs to set up an HTTP connection to the RPC server. It needs to prepare a structure with 
 the values to be sent, and the address of a variable in which to store the results. Then it can make a Call 
 with these arguments:
  
 • 
  
 The name of the remote function to execute
  
 • 
  
 The values to be sent
  
 • 
  
 The address of a variable in which to store the result
  
 A client that calls both functions of the arithmetic server is ArithClient.go:
  
 /** 
  
 * ArithClient
  
  */
  
 package main
  
 import (
  
  
  ""net/rpc""
  
  
  ""fmt""
  
  
  ""log""
  
  
  ""os"" 
  
 )
  
 type Args struct {
  
  
  A, B int 
  
 }
  
 type Quotient struct {
  
  
  Quo, Rem int 
  
 }
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""server"")
  
  
  os.Exit(1)
  
  
  }
  
  
  serverAddress := os.Args[1]
  
 213",NA
TCP RPC Server,"A version of the server that uses TCP sockets is TCPArithServer.go:
  
 /** 
  
 * TCPArithServer
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/rpc""
  
  
  ""errors""
  
  
  ""net""
  
  
  ""os"" 
  
 )
  
 214",NA
TCP RPC Client,"A client that uses the TCP server and calls both functions of the arithmetic server is TCPArithClient.go:
  
 /** 
  
 * TCPArithClient
  
  */
  
 package main
  
 import (
  
  
  ""net/rpc""
  
  
  ""fmt""
  
  
  ""log""
  
  
  ""os"" 
  
 )
  
 type Args struct {
  
  
  A, B int 
  
 }
  
 type Quotient struct {
  
  
  Quo, Rem int 
  
 }
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""server:port"")
   
  
 os.Exit(1)
  
  
  }
  
  
  service := os.Args[1]
  
  client, err := rpc.Dial(""tcp"", service)
  
  if err != nil {
  
  
  log.Fatal(""dialing:"", err)
  
  }
  
  // Synchronous call
  
  args := Args{17, 8}
  
  var reply int
  
 216",NA
Matching Values,"You may have noticed that the types of the value arguments are not the same on the HTTP client and HTTP 
 server. In the server, we used Values, while in the client we used Args. That doesn’t matter, as we are 
 following the rules of Gob serialization, and the names and types of the two structures’ fields match. Better 
 programming practice would say that the names should be the same, of course!
  
  
 However, this does point out a possible trap in using Go RPC. If we change the structure in the server to 
 be this:
  
 type Values struct {
  
  
  C, B int 
  
 }
  
 then Gob has no problems. On the client side, the unmarshalling will ignore the value of C given by the 
 server and use the default zero value for A. This could cause problems if, say, a divide by A (zero) was 
 done.
  
 Using Go RPC will require a rigid enforcement of the stability of field names and types by the 
  
 programmer. We note that there is no version control mechanism to do this, and no mechanism in Gob to 
 signal any possible mismatches. There is also no required external representation to act as a reference. If 
 you are just adding fields then it may be okay, but it will still need control. Perhaps adding a version field to 
 the data structure would help.",NA
JSON,"This section adds nothing new to the earlier concepts. It just uses a different “wire” format for the data, JSON 
 instead of Gob. As such, clients or servers could be written in other languages that understand sockets and 
 JSON.
  
 217",NA
JSON RPC Server,"A version of the server that uses JSON encoding is JSONArithServer.go:
  
 /* JSONArithServer
  
  */
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""net/rpc""
  
  
  ""net/rpc/jsonrpc""
  
  
  ""os""
  
  
  ""net""
  
  
  ""errors"" 
  
 )
  
 type Args struct {
  
  
  A, B int 
  
 }
  
 type Quotient struct {
  
  
  Quo, Rem int 
  
 }
  
 type Arith int
  
 func (t *Arith) Multiply(args *Args, reply *int) error {
  
  *reply = 
 args.A * args.B
  
  
  return nil 
  
 }
  
 func (t *Arith) Divide(args *Args, quo *Quotient) error {
  
  if args.B 
 == 0 {
  
  
  
  return errors.New(""divide by zero"")
  
  
  }
  
  
  quo.Quo = args.A / args.B
  
  
  quo.Rem = args.A % args.B
  
  
  return nil 
  
 }
  
 func main() {
  
  arith := new(Arith)
  
  rpc.Register(arith)
  
  tcpAddr, err := net.ResolveTCPAddr(""tcp"", "":1234"") 
 checkError(err)
  
  listener, err := net.ListenTCP(""tcp"", tcpAddr) 
 checkError(err)
  
 218",NA
JSON RPC Client,"A client that calls both functions of the arithmetic server is JSONArithClient.go:
  
 /* JSONArithCLient
  
  */
  
 package main
  
 import (
  
  
  ""net/rpc/jsonrpc""
  
  
  ""fmt""
  
  
  ""log""
  
  
  ""os"" 
  
 )
  
 type Args struct {
  
  
  A, B int 
  
 }
  
 type Quotient struct {
  
  
  Quo, Rem int 
  
 }
  
 219",NA
Conclusion,"RPC is a popular means of distributing applications. Several ways of doing it have been presented here, 
 based on the Gob or JSON serialization techniques, and using HTTP and TCP for transport.
  
 220",NA
CHAPTER 14,NA,NA
REST,"In previous chapters we looked at HTTP and gave an example of a web system. However, we didn’t give any 
 particular structure to the system, just what was simple enough for the problem. There is an architectural 
 style developed by one of the key authors of HTTP 1.1 (Roy Fielding) called 
 REST
  (REpresentational State 
 Transfer). In this chapter we look at the REST style and what it means for building web applications. We 
 have to go back to fundamentals for this.
  
 REST has many components that have to be followed if the term REST can be properly applied. 
  
 Unfortunately, it has become a buzzword, and many applications have “bits” of REST but not the full thing. 
 We discuss the Richardson Maturity Model, which says how far along the path to RESTful-ness an API has 
 gone.
  
  
 In the last chapter, we looked at RPCs (remote procedure calls). This is a completely different style than 
 REST. We also compare the two styles, looking at when it is appropriate to use each style.",NA
URIs and Resources,"Resources are the “things” that we want to interact with on a network or the Internet. I like to think of them 
 as objects, but there is no requirement that their implementation should be object-based—they should just 
 “look like” a thing, possibly with components.
  
 Each resource has one or more addresses known as URIs (uniform resource identifiers).
  
 ■
  Note
  The internationalized form is IRIs—internationalized resource identifiers.
  
 These have this generic form:
  
 scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
  
  
 Typical examples are URLs (uniform resource locator), where the scheme is http or https, and the host 
 refers to a computer by its IP address or DNS name, as follows:
  
 https://jan.newmarch.name/IoT/index.html
  
 There are non-HTTP URL schemes such as telnet, news, and ipp (Internet Printing Protocol). These also 
 contain a location component. There are also others, such as URNs (uniform resource names), which are 
 often wrappers around other identification systems, and they do not contain location information. For 
 example, the IETF has a standard URN scheme for books identified by their ISBN, such as the ISBN for this 
 book:
  
 urn:ISBN:978-1-4842-2692-6
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_14
  
 221",NA
Representations,"A representation of a resource is something that captures some information about a resource in some 
 form. For example, a representation of me from my Tax Office URI might be my tax returns in Australia. A 
 representation of me from my local pizza cafe would be a record of pizza purchases. A representation of 
 me from my web site would be an HTML document.
  
 This is one of the keys to REST: URIs identify resources and requests for that resource return a 
 representation of that resource. The resource itself remains on the server and is not sent to the client at all. 
 In fact, the resource might not even exist at all in any concrete form. For example, a representation might be 
 generated from the results of an SQL query that’s triggered by making a request to that URI.
  
 REST does not particularly talk about possibilities for negotiating the representation of a resource. HTTP 1.1 
 has an extensive section on how to do this, considering 
 server, client,
  and 
 transparent
  negotiation. 
  
 The Accept headers can be used by a client to specify, for example:
  
 Accept: application/xml; q=1.0, application/json; q=0.5 Accept-
 Language: fr 
  
 Accept-Charset: utf8
  
  
 This states that it would prefer the application/xml format but will accept application/json. The 
 server can either accept one of these or reply with the formats it will accept.
  
 222",NA
REST Verbs,"You can make certain requests to a URI. If you are making an HTTP request to an URL, HTTP defines the 
 requests that can made: GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, and CONNECT, as well as 
 extensions such as PATCH. There is only a limited number of these! This is very different than what we 
 have come to expect from O/O programming. For example, the Java JLabel has about 250 methods, such 
 as getText, setHorizontalAlignment, etc.
  
 REST is now commonly interpreted as taking just four verbs from HTTP: GET, PUT, POST, DELETE. 
 GET roughly corresponds to the getter-methods of O/O languages while PUT roughly corresponds to the 
 setter-methods of O/O languages. If a JLabel were a REST resource (which it isn’t), how would one single 
 GET verb make up for the hundred or so getter-methods of JLabel?
  
 The answer lies in the PATH component of URIs. A label has the properties of text, alignment, and so 
 on. These are really sub-resources of the label and could be written as sub-URIs of the label. So if the label 
 had a URI of http://jan.newmarch.name/my_label, then the subresources could have URIs:
  
 http://jan.newmarch.name/my_label/text 
  
 http://jan.newmarch.name/my_label/horizontalAlignment
  
  
 If you want to manipulate just the text of the label, you can use the URI of the text resource, not 
 getter/ setter-methods on the label itself.",NA
The GET Verb,"To retrieve a representation of a resource, you GET the resource. This will return some representation of the 
 resource. There may be innumerable possibilities to this choice. For example, a request for this book’s index 
 might return a representation of the index in French, using the UTF-8 character set, as an XML document, or 
 many other possibilities. The client and server can negotiate these possibilities.
  
 The GET verb is required to be 
 idempotent
 . That is, repeated requests should return the same results (to 
 within representation type). For example, multiple requests for the temperature of a sensor should return 
 the same result (unless of course the temperature has changed).
  
 Idempotency by default allows for caching. This is useful for reducing traffic on the web, and may save 
 battery power for sensors. Caching cannot always be guaranteed: a resource that returns the number of 
 times it has been accessed will give a different result each time it is accessed. This is unusual behavior and 
 would be signaled using the HTTP Cache-Control header.",NA
The PUT Verb,"If you want to change the state of a resource, you can PUT new values. There are two principal limitations to 
 PUT:
  
 • 
  
 You can only change the state of a resource whose URI you know
  
 • 
  
 The representation you send must cover all components of the resource
  
 For example, if you only want to change the text in a label, you send the PUT message to the URL 
 http://jan.newmarch.name/my_label/text, 
 not
  to http://jan.newmarch.name/my_label. Sending to the 
 label would require all of the hundred or so fields to be sent.
  
  
 PUT is idempotent, but is not 
 safe
 . That is, it changes the state of the resource, but repeated calls change 
 it to the same state.
  
 PUT and DELETE are not part of HTML, and most browsers do not support them directly. They can be 
 called in browsers with Ajax support. There are several discussions as to why they are not included. See for 
 example “Why are there are no PUT and DELETE methods on HTML forms?” at 
 http://softwareengineering. 
 stackexchange.com/questions/114156/why-are-there-are-no-put-and-delete-methods-on-html-forms
 .
  
 223",NA
The DELETE Verb,This deletes the resource. It is idempotent but not safe.,NA
The POST Verb,"POST is the do-everything-else verb to deal with situations not covered by the other verbs. There is 
 agreement about two uses of POST:
  
 • 
  
 If you want to create a new resource and you don’t know its URI, then POST a 
  
 representation of the resource to a URI that knows how to create the resource. 
  
 The returned representation should contain the URI of the new resource. 
 This is 
  
 important
 . To interact with a new resource you must know its URI, and the 
 return 
  
 from POST tells you that.
  
 • 
  
 If a resource has many attributes, and you only want to change one or a few of them, 
  
 then POST a representation with the changed values only
  
  
 There is intense argument about the respective roles of PUT and POST in edge cases. If you want to 
 create a new resource and 
 do
  know the URI it will have, then you could use either PUT or POST. Which one 
 you choose seems to depend on other factors…
  
  
 SOAP was designed as an RPC system on top of HTTP. It uses POST for 
 everything
 . HTML continues to 
 use POST in forms when it should have the option of using PUT. For these reasons, I do not use POST unless I 
 absolutely have to. I suppose others have their own principled reasons for using POST instead of PUT, but I 
 have no idea what they might be :-).
  
 Due to its open-ended scope, POST could be used for almost anything. Many of these uses could be 
 against the REST model, as is amply illustrated by SOAP. But some of these uses could be legitimate. POST 
 is usually non-idempotent and not safe, although particular cases could be either.",NA
No Maintained State,"Let’s establish this up-front: cookies are out. Cookies are often used to track the state of a user through an 
 interaction with a server, with a typical example being a shopping cart. A structure is created on the server 
 side and a cookie is returned to be used to signal that this is the shopping cart to be used.
  
 REST made the decision not to maintain any client state on the server. This simplifies interactions and 
 also sidesteps the tricky issues of how to restore consistency after the client or server has crashed. If the 
 server doesn’t need to maintain any state then it leads to a more robust server model.
  
 If you can’t use cookies, what do you do? It’s actually trivial: a cart is created on the server. Under REST, 
 that can only happen in response to a POST request, which returns a new URI for the new resource. So that is 
 what you use—the new URI. You can GET, PUT, POST, and DELETE to this URI, to do all things you want to 
 do directly on the resource without having to do workarounds with cookies.",NA
HATEOAS,"HATEOAS stands for “Hypermedia as the Engine of Application State”. It is generally recognized as an 
 awful acronym, but it has stuck. The basic principle is that navigating from one URI to another, which is 
 related in some way, should not be done by any out-of-band mechanism but that the new link must be 
 embedded in some way as a hyperlink within the representation of the first URI.
  
 224",NA
Representing Links,"Links are standardized in HTML documents. The Link tag defines an HTML element that can only appear in 
 an HTML header section. For example, a book with chapters, etc., might look like this if the links were given 
 as HTML link elements:
  
 <html>
  
  <head>
  
   
  <link rel= ""author"" title=""Jan Newmarch"" href=""https://jan.newmarch.name"">
  
  
  <link rel=""chapter"" title=""Introduction"" href=""Introduction/"">
  
    
  ...
  
 Link relations in HTML are of two types: those that are needed for the current document such as CSS 
 files, and those that point to related resources, as above. The first type is generally downloaded invisibly to 
 the user. The second type is generally not shown by browsers, but user agents following HATEOAS 
 principles will use them.
  
  
 XML has a variety of link specifications. These include XLink and Atom . Atom seems to be more 
 popular.
  
 Links based on XLink would appear as so:
  
 <People xmlns:xlink=""http://www.w3.org/1999/xlink""> 
 <Person xlink:type=""simple"" xlink:href=""http://..."">
  
  ...
  
  </Person>
  
  
  ...
  
 </People>
  
 225",NA
Transactions with REST,"How does REST handle transactions and indeed any other processes? They were not discussed in the 
 original thesis by Fielding.
  
  
 The Wikipedia entry for HATEOAS gives a poor example of managing transactions. It starts from an 
 HTTP request of this:
  
 GET /account/12345 HTTP/1.1 
  
 Host: somebank.org 
  
 Accept: application/xml
  
  ...
  
 Which returns an XML document as representation of the account:
  
 HTTP/1.1 200 OK
  
  Content-Type: application/xml
  
  Content-Length: ...
  
  <?xml version=""1.0""?>
  
  <account>
  
 226",NA
The Richardson Maturity Model,"Many systems claim to be RESTful. Most are not. I even came across one that claimed that SOAP was 
 RESTful, a clear case of a warped mental state. Martin Fowler discusses the Richardson Maturity Model, 
 which classifies systems according to their conformance to REST. (See 
 https://martinfowler.com/ 
 articles/richardsonMaturityModel.html
 .) 
  
  
 Level 0
  
 The starting point for the model is using HTTP as a transport system for remote 
 interactions, but without using any of the mechanisms of the web. Essentially what 
 you are doing here is using HTTP as a tunneling mechanism for your own remote 
 interaction mechanism, usually based on Remote Procedure Invocation.
  
 Level 1: Resources
  
 The first step toward the Glory of Rest in the RMM is to introduce resources. So now 
 rather than making all our requests to a singular service endpoint, we now start 
 talking to individual resources.
  
 227",NA
Flashcards Revisited,"In Chapter 
 10
 , we considered a web system consisting of a server and HTML pages rendered in a browser, 
 using JavaScript and CSS to control the browser-side interaction. There was no attempt to do anything 
 particularly structured, rather just as a traditional web system.
  
 ■
  Recap
  The web system of Chapter 
 10
  was used to demonstrate language learning using so-
 called 
  
 flashcards. The user is presented with a set of cards one at a time, showing a word in one 
 language and then 
  
 hopes to remember the translation, which is shown by “turning over” the card. The system 
 presented a list of 
  
 different card sets and then showed the cards one at a time in the selected set.
  
  
 We now approach the same situation as a HTTP client-server system built using the REST approach. 
 We will make a number of changes:
  
 • 
  
 URLs will be given appropriate to the situation. These will include the ‘root’ URL / as 
  
 well as URLs for each flashcard set and in addition, an URL for each flashcard.
  
 • 
  
 All user interaction code (HTML, JavaScript, and CSS) is omitted. The server will be 
  
 talking to an arbitrary user agent, and many will not understand the UI code.
  
 • 
  
 The server will not maintain or manage any client state. In the web example, form 
  
 data was sent from the browser to the server, which promptly returned it in a 
 slightly 
  
 different form. A client that wants to maintain state should do so itself.
  
 • 
  
 The server will be set up to manage a number of different serialization formats and 
  
 will deliver as appropriate after client-server negotiation.
  
 • 
  
 Heavy use will be made of HTTP mechanisms, particularly for error handling and 
  
 content negotiation.",NA
URLs,The URLs for this system and the actions that can be performed are as follows:,NA
The Demultiplexer (Demuxer),"REST is based on a small number of actions applied to URLs. A system that attempts to use REST principles 
 must be URL based.
  
 A server demuxer will examine URLs requested by clients and call handlers based on the URL pattern. 
 The standard Go demuxer ServeMux uses a particular pattern-matching mechanism: if an URL ends in / it 
 denotes a subtree of URLs rooted at that URL. If it ends without a / it represents that URL only. An URL is 
 matched against the handler with the longest pattern match.
  
 We need a handler for the root URL /. That will also match any URL such as /passwords unless another 
 handler catches it. In this system, no other handler will, so in the handler for / we need to return errors for 
 such attempts.
  
 A tricky part occurs because we used a hierarchical structure to our URLs. One particular flashcard set 
 will be /flashcardSets/CommonWords. This will actually be a directory of the cards for that particular set. 
 We have to register 
 two
  handlers: one for the URL /flashcardSets/CommonWords, which is the flashcard set 
 resource, and one for /flashcardSets/CommonWords/ (note the trailing /), which is the subtree containing 
 the individual cards and their URLs.
  
 The code in the main function to register these is as follows:
  
 http.HandleFunc(`/`, handleFlashCardSets) 
  
 files, err := ioutil.ReadDir(`flashcardSets`) 
  
 checkError(err) 
  
 for _, file := range files {
  
  
  cardset_url := `/flashcardSets/` + url.QueryEscape(file.Name())
  
  
 http.HandleFunc(cardset_url, handleOneFlashCardSet)
  
  
  http.HandleFunc(cardset_url + `/`, handleOneFlashCard) 
  
 } 
  
 229",NA
Content Negotiation,"Any web user agent can try to talk to any web server. The typical case of a browser talking to an HTML 
 server is what we are used to on the Web, but many will be familiar with using other user agents such as 
 curl, wget, and even telnet! The browser and other tools will use the Content-Type in HTTP replies to work 
 out what to do with content supplied.
  
 With a Web application, the user agent must be able to understand what the server is delivering, 
 because it is trying to play a part in an interaction that probably doesn’t have a user to help. RPC systems 
 often use an external specification that the client and server conform to. That is not the case here.
  
 The solution is that both parties must agree on a content format. This is done at the HTTP level. A client 
 will state that it will accept a range of formats. If the server agrees, then they carry on. If not, the server will 
 tell the client which formats it can accept and the client can start afresh if possible.
  
 The negotiation uses MIME types. There are hundreds of standard ones: text/html, application/pdf, 
 application/xml, … . A browser can render any HTML document it receives. An HTTP-aware music player 
 such as VLC can play any MP3 file it receives. But for the flashcard application it can’t handle any general 
 format, only messages that conform to an expected structure. These aren’t any standard MIME types that 
 would be suitable for negotiating a specialized protocol for this flashcard application. So, we make up our 
 own. The client and the server have to know that they are dealing with a shared MIME type, or they can’t 
 talk properly.
  
 There are rules from IANA for making up your own MIME types. I use the types application/x.
  
 flashcards. The server will be able to deliver JSON and XML, so the two acceptable MIME types are 
 application/x.flashcards+xml and application/x.flashcards+json.
  
  
 HTTP content negotiation says that the user agent can suggest a list of acceptable formats, weighted 
 between zero and one, as follows:
  
 Accept: application/x.flashcards+xml; q=0.8,
  
  application/x.flashcards+json; q=0.4
  
 The server can examine the request and decide if it can handle the format. We use the following code in 
 the server to determine for any type if the user agent has requested it, and with what weighting (zero means 
 not requested):
  
 const flashcard_xml string = ""application/x.flashcards+xml"" const 
 flashcard_json string = ""application/x.flashcards+json""
  
 type ValueQuality struct {
  
  
  Value   string
  
  
  Quality float64 
  
 }
  
 /* Based on https://siongui.github.io/2015/02/22/go-parse-accept-language/ */ func 
 parseValueQuality(s string) []ValueQuality {
  
  
  var vqs []ValueQuality
  
 230",NA
GET /,"The flashcard sets are all stored in the directory /flashcardSets. The GET / request needs to list all those 
 files and prepare them in a suitable format for the client. The format is a list of flashcard set names and 
 their 
 URLs
 . The URLs are required by HATEOAS: the list of names tell us what the sets are, but the client will need 
 their URLs in order to move to the stage of interacting with one of them.
  
 The data type for each FlashcardSet in the server contains the name of the set and its URL (as a string):
  
 type FlashcardSet struct {
  
  
  Name string
  
  
  Link string 
  
 }
  
  
 The set of flashcard sets on the server can be built from the directory of flashcard sets. The ioutil. 
 ReadDir() will create an array of os.FileInfo. This needs to be converted to a list of filenames as follows:
  
 files, err := ioutil.ReadDir(`flashcardSets`) 
  
 checkError(err) 
  
 numfiles := len(files) 
  
 cardSets := make([]FlashcardSet, numfiles, numfiles) 
  
 for n, file := range files {
  
  
  cardSets[n].Name = file.Name()
  
  
  // should be PathEscape, not in go 1.6
  
  
  cardSets[n].Link = `/flashcardSets/` + url.QueryEscape(file.Name()) }
  
 This creates an array of filenames and relative links to the resource on the server as /<name>. For the 
 CommonWords set, the relative link URL would be /flashcardSets/CommonWords. The scheme (http or 
 https) and the host (e.g., ""localhost"") are left up to the client to work out.
  
 Unfortunately, the filename may contain characters not legal in URL path names. The function url. 
 PathEscape escapes them all correctly, but is not available until Go 1.8. The function url.QueryEscape gets 
 everything right except for spaces in the filename, which it replaces with + instead of %20;.
  
  
 Finally, the server figures out if JSON or XML is preferred and runs it through a template to generate the 
 right output to the client. For XML, the template code is as follows:
  
 t, err := template.ParseFiles(""xml/ListFlashcardSets.xml"") 
  
 if err != nil {
  
  
  // parse error occurred in the template. Our error
  
  
  http.Error(rw, err.Error(), http.StatusInternalServerError)
  
  
 return 
  
 } 
  
 rw.Header().Set(""Content-Type"", flashcard_xml) 
  
 t.Execute(rw, cardSets)
  
 232",NA
POST /,"Here a client is asking for a new flashcard set to be created. The expectation is that the client will supply the 
 name of the flashcard set. We make it look like form submission data:
  
 name=<new flashcard set name>
  
 This is much simpler than GET in this case. Get the value out of the request as form data. Then check 
 that the requested name doesn’t have nasties in it like calling the flashcard set /etc/passwd. If it does, 
 return 403 ""Forbidden"". If it appears to be okay, create a directory with that name. Return a 403 again if it 
 fails (the directory may already exist). Otherwise, return 201 ""Created"" and the new relative URL:
  
 if req.Method == ""POST"" {
  
  
  name := req.FormValue(`name`)
  
  
  if hasIllegalChars(name) {
  
  
  
  rw.WriteHeader(http.StatusForbidden)
  
  
  return
  
 233",NA
Handling Other URLs,"We discussed the code for the server handling the / URL with GET and POST requests. There are two other 
 types of URL for this application—handling the cards in a set and handling each individual card. In terms of 
 the coding, though, this presents no new ideas.
  
 • 
  
 Getting a list of cards in a set is another directory listing.
  
 • 
  
 Posting a new card to a set means creating a file in the appropriate directory 
 with 
  
 content from the client.
  
 • 
  
 Deleting a set means removing a directory. This is okay if the directory is empty, 
  
 creates an error otherwise.
  
 • 
  
 Getting a card means reading the card file and sending its contents.
  
 • 
  
 Deleting a card means removing a file.
  
 There is nothing particularly new about any of these. We have not completed the code for some 
 operations such as DELETE: these return the HTTP code 501 'Not implemented'. We also return the 
 contents of individual cards as text/plain: they have a complex JSON/Go structure as used in Chapter 
 10
 , but 
 that is not needed for discussion of the REST aspects of this system.",NA
The Complete Server,"The complete server to handle requests to / and from there to other URLs follows. It requires the 
 flashcard sets and individual cards in order to run, and these are in the ZIP file at 
 http://www.apress. 
 com/9781484226919
  in the Ch14 folder.
  
 /* Server
  
  */
  
 package main
  
 import (
  
  ""fmt""
  
  ""html/template""
  
 234",NA
Client,"The client is relatively straightforward, offering nothing really new. This client asks for the content only in 
 XML format. A new part is that the content for the flashcard sets includes links as hypertext attributes 
 within a cardset tag. This may be turned into a field of a struct by the tag label xml:""href,attr"" in the Card 
 struct.
  
 This client gets the list of flashcard sets and their URLs in the getFlashcardSets() function (Step 1). This 
 returns a FlashcardSets struct. This can be used to present a list to a user, say, for selection of a particular 
 set. Once selected, the URL of that set can be used to interact with the resource.
  
 This client then creates a new flashcard set with name NewSet in the createFlashcardSet() function 
 (Step 2). The first time it is run, it will create the set and be returned the URL for that set. The second time 
 it is run, it will get an error from the server as a prohibited operation, since the set already exists.
  
  
 This client then takes the first set of flashcards from the URLs given by the server and asks for the set of 
 cards it holds (Step 3). It then picks the first card from the set and gets its content (Step 4).
  
 240",NA
Using REST or RPC,"The primary difference between REST and RPC is the interaction style. In RPC, you are calling functions, 
 passing objects or primitive types as arguments, and getting objects or primitive types in return. The 
 functions are 
 verbs
 : do 
 this
  to 
 that
 . REST, on the other hand, is about interacting with objects, asking them to 
 show their state or to change it in some way.
  
 The difference is shown by the Go RPC mechanism discussed in the last chapter and the REST 
 mechanism of this chapter. In Go RPC over HTTP, the server registers 
 functions
 , while in REST, the server 
 registers handlers for 
 URLs
 .
  
 Which is better? Neither. Which is faster? Neither. Which is better for a controlled environment? 
  
 Possibly RPC. Which is better for an open environment? Possibly REST.
  
 You will see arguments based on speed and resource allocation. RPC based on binary systems will 
 probably be faster than text-based HTTP systems. But SOAP is a text-based RPC system using HTTP and is 
 probably slower than REST. HTTP2 uses a binary format and when conveying binary data such as BSON will 
 probably be equivalent in speed to other binary systems. Just to confuse things further, the Apache Thrift 
 RPC allows a choice of data formats (binary, compact binary, JSON, and text) and transports (sockets, files, 
 and shared memory). One system demonstrates all options!
  
 A more important factor might be how tightly controlled the operational environment is. RPC systems 
 are tightly coupled, and a failure in one component could bring an entire system down. When there is a 
 single administrative authority, a limited set of hardware and software configurations and a clear channel 
 for fixing problems, then an RPC system can work well.
  
 On the other side, the web is uncontrolled. There is no single authority—even such ""universal"" services 
 such as DNS are highly distributed. There is a huge variety of hardware, operating systems, and software; 
 there will be little prospect of enforcing any policies; and if something breaks then there is often no one who 
 can be pointed at to fix it. In such a case, a loosely-coupled system may be better.
  
 REST over HTTP is a good match for this. HATEOAS allows servers to be reconfigured on the fly, 
 changing URLs as needed (even pointing to different servers!). HTTP is designed to cache results when it 
 can. Firewalls are usually configured to allow HTTP traffic and block most other. REST is a good choice here.
  
 It should be noted that REST is not the only HTTP-based system possible. SOAP has already been 
 mentioned. There are many commercial and highly successful systems that are ""almost"" REST—Richardson 
 levels 1 and 2. They do not enjoy the full benefits of the REST/HTTP match but still work.
  
  
 No doubt in future other models will arise. In the IoT space, CoAP is popular for low-power wireless 
 systems. It is also REST-based, but in a slightly different way than HTTP-REST.",NA
Conclusion,"REST is the architectural model of the web. It can be applied in many different ways, particularly as HTTP 
 and CoAP. This chapter illustrated REST as applied to HTTP.
  
 245",NA
CHAPTER 15,NA,NA
WebSockets,"The standard model of interaction between a web user agent such as a browser and a web server such as 
 Apache is that the user agent makes HTTP requests and the server makes a single reply to each one. In the 
 case of a browser, the request is made by clicking on a link, entering a URL into the address bar, clicking on 
 the forward or back buttons, etc. The response is treated as a new page and is loaded into a browser 
 window.
  
 This traditional model has many drawbacks. The first is that each request opens and closes a new TCP 
 connection. HTTP 1.1 solved this by allowing persistent connections, so that a connection could be held 
 open for a short period to allow for multiple requests (e.g., for images) to be made on the same server.
  
 While HTTP 1.1 persistent connections alleviate the problem of slow loading of a page with many 
 graphics, it does not improve the interaction model. Even with forms, the model is still that of submitting the 
 form and displaying the response as a new page. JavaScript helps in allowing error checking to be 
 performed on form data before submission, but does not change the model.
  
 AJAX (Asynchronous JavaScript and XML) made a significant advance to the user interaction model. 
  
 This allows a browser to make a request and just use the response to update the display in place using the 
 HTML Document Object Model (DOM). But again the interaction model is the same. AJAX just affects how 
 the browser manages the returned pages. There is no explicit extra support in Go for AJAX, as none is 
 needed: the HTTP server just sees an ordinary HTTP POST request with possibly some XML or JSON data, 
 and this can be dealt with using techniques already discussed.
  
 All of these are still browser (or user agent) to server communication. What is missing is server to 
 browser communications where a browser has set up a TCP connection to a server and reads messages 
 from the server. This can be filled by WebSockets: the browser (or any user agent) keeps open a long-lived 
 TCP connection to a WebSockets server. The TCP connection allows either side to send arbitrary packets, so 
 any application protocol can be used on a WebSocket.
  
 How a WebSocket is started is by the user agent sending a special HTTP request that says “switch to 
 WebSockets”. The TCP connection underlying the HTTP request is kept open, but both user agent and server 
 switch to using the WebSockets protocol instead of getting an HTTP response and closing the socket.
  
 Note that it is still the browser or user agent that initiates the WebSockets connection. The browser 
 does not run a TCP server of its own. While the specification as IETF RFC6455 is complex (see 
 https:// 
 tools.ietf.org/html/rfc6455
 ), the protocol is designed to be fairly easy to use. The client opens an HTTP 
 connection and then replaces the HTTP protocol with its own WS protocol, reusing the same TCP or a new 
 connection.
  
  
 Go has some support for WebSockets in a sub-repository, but actually recommends a third-party 
 package. This chapter considers both packages.
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-2692-
 6_15
  
 247",NA
WebSockets Server,"A WebSockets server starts off by being an HTTP server, accepting TCP connections and handling the HTTP 
 requests on the TCP connection. When a request comes in that switches that connection to being a 
 WebSockets connection, the protocol handler is changed from an HTTP handler to a WebSocket handler. So 
 it is only that TCP connection that gets its role changed, the server continues to be an HTTP server for other 
 requests, while the TCP socket underlying that one connection is used as a WebSocket.
  
 One of the simple servers discussed in Chapter 
 8
 , HTTP registered various handlers such as a file 
 handler or a function handler. To handle WebSockets requests, we simply register a different type of 
 handler—a WebSockets handler. Which handler the server uses is based on the URL pattern. For example, a 
 file handler might be registered for /, a function handler for /cgi-bin/..., and a WebSockets handler for /ws.
  
 An HTTP server that is only expecting to be used for WebSockets might run as follows:
  
 func main() {
  
  
  http.Handle(""/"", websocket.Handler(WSHandler))
  
  err := http.ListenAndServe("":12345"", nil)
  
  
 checkError(err) 
  
 }
  
  
 A more complex server might handle both HTTP and WebSockets requests simply by adding more 
 handlers.",NA
The Go Sub-Repository Package,"Go has the sub-repository package called golang.org/x/net/websocket. To use this, you must first 
 download it:
  
 go get golang.org/x/net/websocket
  
 The package documentation states the following:
  
 This package currently lacks some features found in an alternative and more actively 
 maintained WebSockets package: 
 https://godoc.org/github.com/gorilla/websocket
  
 This suggests that you might be better off using the alternative package. Nevertheless, we consider 
 this package here in keeping with the rest of this book of using the packages from the Go team. A later 
 section looks at the alternative package.",NA
The Message Object,"HTTP is a stream protocol. WebSockets are frame-based. You prepare a block of data (of any size) and send 
 it as a set of frames. Frames can contain strings in UTF-8 encoding or a sequence of bytes.
  
 The simplest way of using WebSockets is just to prepare a block of data and ask the Go WebSockets 
 library to package it as a set of frame data, send it across the wire, and receive it as the same block. The 
 websocket package contains a convenience object called Message to do just that. The Message object has two 
  
 248",NA
The JSON Object,"It is expected that many WebSockets clients and servers will exchange data in JSON format. For Go 
 programs, this means that a Go object will be marshalled into the JSON format, as described in Chapter 
 4 
 and then sent as UTF-8 strings, while the receiver will read this string and unmarshal it back into a Go 
 object.
  
  
 The websocket convenience object called JSON will do this for you. It has Send and Receive methods for 
 sending and receiving data, just like the Message object.
  
 251",NA
The Codec Type,"The Message and JSON objects are both instances of the type Codec. This type is defined as follows:
  
 type Codec struct {
  
  
  Marshal   func(v interface{}) (data []byte, payloadType byte, err error)
  
  Unmarshal 
 func(data []byte, payloadType byte, v interface{}) (err error) }
  
 The Codec type implements the Send and Receive methods used earlier.
  
 It is likely that WebSockets will also be used to exchange XML data. We can build an XML Codec object 
 by wrapping the XML marshal and unmarshal methods discussed in Chapter 
 12
  to give a suitable Codec 
 object.
  
 We can create a XMLCodec package in this way, called XMLCodec.go:
  
 package xmlcodec
  
 import (
  
  
  ""encoding/xml""
  
  
  ""golang.org/x/net/websocket"" 
  
 )
  
 func xmlMarshal(v interface{}) (msg []byte, payloadType byte, err error) {
  
  msg, err = 
 xml.Marshal(v)
  
  
  return msg, websocket.TextFrame, nil 
  
 }
  
 func xmlUnmarshal(msg []byte, payloadType byte, v interface{}) (err error) {
  
  err 
 = xml.Unmarshal(msg, v)
  
  
  return err 
  
 }
  
 var XMLCodec = websocket.Codec{xmlMarshal, xmlUnmarshal}
  
 This file should be installed in the src subdirectory of GOPATH:
  
 $GOPATH/src/xmlcodec/XMLCodec.go
  
 254",NA
WebSockets Over TLS,"A WebSocket can be built above a secure TLS socket. We discussed in Chapter 
 8
  how to use a TLS socket 
 using the certificates from Chapter 
 7
 . That is used unchanged for WebSockets. That is, we use 
  
 http.ListenAndServeTLS instead of http.ListenAndServe.
  
 Here is the echo server using TLS:
  
 /* EchoServerTLS
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""golang.org/x/net/websocket""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 func Echo(ws *websocket.Conn) {
  
  
  fmt.Println(""Echoing"")
  
  for n := 0; n < 10; n++ {
  
  
  msg := ""Hello  "" + string(n+48)
  
  
  fmt.Println(""Sending to client: "" + msg)
  
  
 err := websocket.Message.Send(ws, msg)
  
  if err != 
 nil {
  
  
  
  fmt.Println(""Can't send"")
  
  
  
  break
  
  
  }
  
  
  
  var reply string
  
  
  
  err = websocket.Message.Receive(ws, &reply)
  
  
  
  if err != nil {
  
  
  
  
  fmt.Println(""Can't receive"")
  
  
  
  
  break
  
  
  
  }
  
  
  
  fmt.Println(""Received back from client: "" + reply)
  
  } 
  
 }
  
 257",NA
WebSockets in an HTML Page,"The original driver for WebSockets was to allow full duplex interaction between an HTTP user agent such as 
 a browser and a server. The typical use case is expected to involve a JavaScript program in a browser 
 interacting with a server. In this section, we build a web/WebSockets server that delivers an HTML page 
 that sets up a WebSocket and displays information from that server using WebSockets. We are looking at 
 the situation illustrated in Figure 
 15-1
 .
  
 259",NA
Browser,NA,NA
Server,NA,NA
GET page,NA,NA
Page containing,NA,NA
JS ,NA,NA
JavaScript,NA,NA
Listening ,NA,NA
For ,NA,NA
onmessage,NA,NA
Display ,NA,NA
Msg ,NA,NA
message,NA,NA
Display ,NA,NA
Msg ,NA,NA
message,NA,NA
Display ,NA,NA
Msg ,NA,NA
message,"Figure 15-1.
  Full duplex interaction situation
  
 The age of the Internet of Things (IoT) is coming. Consequently we can expect data from sensors and 
 sensor networks to be used to drive actuators and to display information about an IoT network in browsers. 
 There are innumerable books about using Raspberry Pi's and Arduinos for building sensor networks, but we 
 will drastically simplify the situation by showing the CPU temperatures on a “sensor,” updating in a web 
 page every few seconds.
  
 The Linux sensors command from the Debian package lm-sensors writes to standard output the 
 values of sensors it knows about. The command sensors on my desktop machine produces output such as 
 the following:
  
 acpitz-virtual-0 
  
 Adapter: Virtual device 
  
 temp1:        +27.8°C  (crit = +105.0°C) 
  
 temp2:        +29.8°C  (crit = +105.0°C)
  
 coretemp-isa-0000 
  
 Adapter: ISA adapter 
  
 Physical id 0:  +58.0°C  (high = +105.0°C, crit = +105.0°C) Core 0:         
 +57.0°C  (high = +105.0°C, crit = +105.0°C) Core 1:         +58.0°C  (high = 
 +105.0°C, crit = +105.0°C)
  
 260",NA
The Gorilla Package,"The alternative package for WebSockets is the github.com/gorilla/websocket package. To use this, you will 
 need to run the following:
  
 go get github.com/gorilla/websocket
  
 263",NA
Echo Server,"The echo server using this package is EchoServerGorilla.go. It makes the HTTP to WebSockets transition 
 more explicit by introducing a call to a websocket.Upgrader object. It also more clearly distinguishes 
 between sending text and binary messages.
  
 /* EchoServerGorilla
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""github.com/gorilla/websocket""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 var upgrader = websocket.Upgrader{
  
  
  ReadBufferSize:  1024,
  
  
  WriteBufferSize: 1024, 
  
 }
  
 func Handler(w http.ResponseWriter, r *http.Request) {
  
  
 fmt.Println(""Handling /"")
  
  
  conn, err := upgrader.Upgrade(w, r, nil)
  
  
  if err != nil {
  
  
  
  fmt.Println(err)
  
  
  
  return
  
  
  }
  
  for n := 0; n < 10; n++ {
  
  msg := ""Hello  "" + string(n+48)
  
  fmt.Println(""Sending to client: "" + msg)
  
  err = conn.WriteMessage(websocket.TextMessage, []byte(msg))
  
  
  
  _, reply, err := conn.ReadMessage()
  
  
  
  if err != nil {
  
  
  
  
  fmt.Println(""Can't receive"")
  
  
  
  
  break
  
  
  
  }
  
  
  
  fmt.Println(""Received back from client: "" + string(reply[:]))
  
  }
  
  
  conn.Close() 
  
 }
  
 func main() {
  
  
  http.HandleFunc(""/"", Handler)
  
  
  err := http.ListenAndServe(""localhost:12345"", nil)
  
  
 checkError(err) 
  
 }
  
 264",NA
Echo Client,"The echo client using this package is EchoClientGorilla.go:
  
 /* EchoClientGorilla
  
  */ 
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""github.com/gorilla/websocket""
  
  
  ""io""
  
  
  ""net/http""
  
  
  ""os"" 
  
 )
  
 func main() {
  
  
  if len(os.Args) != 2 {
  
  
  
  fmt.Println(""Usage: "", os.Args[0], ""ws://host:port"")
  
  
  os.Exit(1)
  
  
  }
  
  
  service := os.Args[1]
  
  header := make(http.Header)
  
  header.Add(""Origin"", ""http://localhost:12345"")
  
  conn, _, err := websocket.DefaultDialer.Dial(service, header) 
 checkError(err)
  
  for {
  
  _, reply, err := conn.ReadMessage()
  
  if err != nil {
  
  if err == io.EOF {
  
  
  // graceful shutdown by server
  
  
  fmt.Println(`EOF from server`)
  
  
  break
  
  }
  
 265",NA
Conclusion,"The WebSockets standard is an IETF RFC, so no major changes are anticipated. This will allow HTTP user 
 agents and servers to set up bidirectional socket connections and should make certain interaction styles 
 much easier. Go has support from two packages for WebSockets.
  
 266",NA
Afterword,"This book looked at the basics of distributed programming and how this can be done in Go. There are 
 indefinite extensions to this. For example, you may be interested in how time is managed in distributed 
 systems, or how replicated databases maintain consistency (or weaker, eventual consistency). You may be 
 interested in algorithms for load balancing, or in techniques such as map-reduce, as is often used to process 
 queries across distributed databases, or in how grid computing systems can span thousands of computers of 
 different types, in different administrative domains. Or in how a dramatically simplified model is used for 
 cloud computing.
  
 Some of these are classic distributed system problems, and information may be found in books such as 
 Andrew S. Tanenbaum and Maarten Van Steen's book, 
 Distributed Systems - Principles and Paradigms
 . The 
 fundamentals of grid computing may be found in the book by Ian Foster and Carl Kesselman, titled 
 The Grid: 
 Blueprint for a New Computing Infrastructure
 , while map-reduce is covered in books on Hadoop (for Java).
  
 If you specifically want Go implementations of distributed frameworks, techniques, or algorithms not 
 in the standard Go libraries, you should look at sites like Go Projects (see 
 https://github.com/golang/go/ 
 wiki/Projects
 ), which maintains a list of active third-party Go projects.
  
 There are also other books dealing with topics in this area, such as 
 Web Development with Go
  by Shiju 
 Varghese, 
 Mastering Go Web Services
  by Nathan Kozyra, and several others. A good site that lists many books 
 is Golang books at 
 https://github.com/golang/go/wiki/Books
 .
  
 My own interests are increasingly in the IoT (Internet of Things) space. Here, you can see Go activity, 
 with frameworks such as Gobot (
 https://gobot.io/
 ) and Project Flogo (
 https://dzone.com/articles/ project-
 flogo-golang-powered-open-source-iot-integ
 ). The MQTT message passing protocol is getting some traction 
 in the IoT space, and the Eclipse Paho MQTT Go client (see 
 https://github.com/eclipse/ paho.mqtt.golang
 ) 
 can partake in this. And of course, Go runs on the Raspberry Pi, which is a good starting point for 
 experiments with the IoT. You can expect more activity in the IoT space using Go, as it can compile down to 
 the native machine code on several processor types.
  
 Enjoy your Go adventures!
  
 © Jan Newmarch 2017 
  
 J. Newmarch, 
 Network Programming with Go
 , DOI 10.1007/978-1-4842-
 2692-6
  
 267",NA
Index,NA,NA
 A,"Abstract syntax notation one (ASN.1) 
  
  
 ASCII characters, 63 
  
  
 Go asn1 package documentation, 62 
  
  
 ASN1basic.go, 63–64 
  
  
 character sets, 63 
  
  
 character strings, 62 
  
  
 data types and data structures, 61, 65 
  
  
 daytime client and server, 66–67 
  
  
 marshal and unmarshal data, 60 
  
  
 marshal and unmarshal structures, 65 
  
  
 pointers, 66 
  
  
 pointer variable, 63 
  
  
 PrintableString and IA5String, 63 
  
  
 structured types, 62 
  
  
 *time.Time, 63 
  
  
 UTC time type, 63 
  
 Access transparency, 17 
  
 Apache, 247 
  
 Arrays, 22 
  
 ASCII, 107, 109, 111, 113 
  
 Asynchronous communication, 10 
  
 Asynchronous JavaScript and XML (AJAX), 247 
 Authenticating proxy, 151, 153",NA
 B,"Block algorithms, 126 
  
 Body Area Network (BAN), 3 
 Browser files, 177 
  
 Browser site diagram, 175–
 177",NA
 C,"Certificate authority (CA), 132 
 Character, 108 
  
  
 ASCII, 109, 111 
  
  
 code, 108 
  
  
 encoding, 108 
  
  
 ISO 8859, 111 
  
  
 repertoire/set, 108
  
  
 sets and Go, 119 
  
  
 transport encoding, 109 
  
  
 unicode, 111–112 
  
  
 UTF-8, 112 
  
  
  
 ASCII client and server, 113 
  
  
  
 client and server, 112 
  
  
 UTF-16, 113 
  
  
  
 client and server, 114–116 
  
  
  
 little-endian and big-endian, 113 
 Character-handling mechanisms, 107 
 CharData type, 200 
  
 Chinese dictionary, 181–182 
  
 Client 
  
  
 Client.go, 241–244 
  
  
 getFlashcardSets() function, 240 
  
  
 XML format, content, 240 
  
 Client-server application, 8, 94 
  
 Client-server system, 7, 8 
  
 Client-side code, 210 
  
 Client state transition diagrams, 104 
  
 Codec type, 254, 256 
  
 Comment type, 200 
  
 Communication flows, 9 
  
  
 asynchronous communication, 10 
  
 publish/subscribe, 10 
  
  
 streaming communication, 10 
  
  
 synchronous communication, 10 
 Communications models, 5 
  
  
 message passing, 5–6 
  
  
 remote procedure call, 6–7 
  
 Complete server, 234, 236–240 
  
 Component distribution, 10 
  
  
 application logic, 10 
  
  
 data access, 10 
  
  
 fat 
 vs.
  thin, 14 
  
  
 Gartner classification, 11–13 
  
  
 presentation component, 10 
  
  
 three-tier models, 13 
  
 Concurrency transparency, 17 
  
 Connection models, 5 
  
  
 connectionless, 5 
  
  
 connection oriented, 5",NA
 E,"MIME types, 230 
  
  
 POST /, 233–234 
  
  
 range of formats, 230 
  
 server, 230–231 
  
  
 user agents, 230 
  
 CORBA, 210
  
 EBCDIC, 107 
  
 Echo client, 265–266 
  
 Echo server, 264–265 
  
 EndElement type, 200 
  
 Error values, 26–27 
  
 External data representation (XDR), 59",NA
 D,NA,NA
 F,"Data format, 91–92 
  
 Data integrity, 124 
  
 Data serialization 
  
  
 ASN.1 (
 see 
 Abstract syntax 
  
  
 notation one (ASN.1)) 
  
  
 Base64 encoding and decoding, 82
  
 Failure transparency, 18 
  
 Flashcard sets, 183–184 
  
 flashcards.ListFlashCardsNames(), 180 
 FlashCards struct, 187–189 
  
 Functions, 23–24
  
 external data representation (XDR), 59",NA
 G,"JSON (
 see 
 JavaScript object 
  
  
  
  
 notation (JSON)) 
  
  
 mutual agreement, 59 
  
  
 protocol buffers 
  
  
 binary encoding, 83 
  
  
 compiled personv3.pb.go file, 84 
  
 data types, 83 
  
  
 installing and compiling, 84 
  
  
 ONC RPC, 83 
  
  
 personv3.proto, 83 
  
  
 ProtocolBuffer.go, 85 
  
  
 self-describing data, 59 
  
  
 structured data, 57–58 
  
 Decryption key, 127 
  
 Default multiplexer, 158–159 
  
 Delay Tolerant 
  
  
  
 Networking (DNT), 29 
  
 The Demultiplexer (Demuxer), 229–230 
 Directive type, 201–203 
  
 Distributed computing, fallacies, 18 
  
  
 administrator, 19 
  
  
 homogenous network, 20 
  
  
 infinite bandwidth, 19 
  
  
 reliable network, 18 
  
  
 secure network, 19 
  
  
 topology doesn’t change, 19 
  
  
 zero latency, 19 
  
  
 zero transport cost, 20 
  
 Distributed computing models, 7
  
 270
  
 Gartner classification, 11 
  
  
 distributed database, 11 
  
 network file service, 12 
  
 secure shell, 13 
  
  
 terminal emulation, 12 
  
 Web, 12 
  
 Gateways, 4 
  
 GET method, 143–145 
  
 Gob serialization, 59 
  
 Go language, 21 
  
  
 character sets and, 119 
  
 error values, 26–27 
  
  
 functions, 23–24 
  
  
 GOPATH, 25 
  
  
 hashing algorithms, 125 
  
 ISO 8859 and, 117–118 
  
  
 maps, 24 
  
  
 methods, 24 
  
  
 multi-threading, 25 
  
  
 packages, 25 
  
  
 pointers, 23 
  
  
 RPC 
  
  
  
 HTTP client, 213–214 
  
  
 HTTP server, 212–
 213 
  
  
 restrictions, 210–
 211 
  
  
 TCP client, 216–
 217 
  
  
 TCP server, 214–
 216 
  
 runes, 112 
  
  
 running, 26",NA
 I,"ICMP packet payload, 53 
  
 Increasing internationalization (i18n), 137 
 Internationalization (i18n), 107 
  
 Internet, 32-bit unsigned integer, 30 
  
 Internet Control Message Protocol (ICMP), 53",NA
 H ,"Internet of Things (IoT), 29, 260 
    
 Internet Printing Protocol (ipp), 221 
 Handler file, 248 
  
 Internet protocol (IP) 
  
 Handler functions, 156 
  
  
 defined, 32 
  
 Hash, 124 
  
   
 description, 30 Hashing, 124 
  
  
 IPAddr type, 36–37 
  
 Hash value, 124–125 
  
  
 IPv4 addresses, 31 
  
 HEAD method, 142–143 
  
  
 IPv6 addresses, 31 
  
 Homograph attacks, 138 
  
   
 LookupHost function, 37 HTML, 207 
  
  
 LookupHostname function, 38 
   
 EscapeString and UnescapeString, 193 
  
  
 mask type, 33, 35–36 
  
   
 EscapeString.go, 193–194 
  
  
 process, 32–33 
  
   
 parsers, 193 
  
   
 ResolveIPAddr function, 37 
  
  
 ReadHTML.go, 195–197 
   
 String() method, 32
  
 template package, 194–195 
 tokenizing, 195–197
  
 ISO 8859, 111, 117–119 
  
 ISO security architecture
  
 WebSockets, 259–263 
  
 functions, 122–123
  
 HTTP 0.9, 138 
  
 levels, 122–123
  
 HTTP 1.0 
  
 mechanisms, 123–124
  
 request format, 139
  
  
 response format, 139–140 
  
 HTTP 1.1, 140–141, 247 
  
 HTTP/2, 141 
  
 HTTPS, 153 
  
 Hypermedia as the Engine of Application 
  
  
 State (HATEOAS) 
  
  
 appropriate links, 225 
  
  
 cookies/external API specifications, 225 
  
 IANA, 225 
  
  
 link formats, 225 
  
  
 principle, 224 
  
 Hypertext Application Language (HAL), 226 
 Hypertext Transport Protocol (HTTP) 
  
  
 characteristics, 138 
  
  
 client object, 147–148 
  
  
 configure requests, 145–146 
  
  
 connections by clients, 153–155 
  
  
 HTTP 0.9, 138 
  
  
 HTTP 1.0, 139–140 
  
  
 HTTP 1.1, 140–141 
  
  
 HTTP/2, 141 
  
  
 i18n, 137 
  
  
 proxy (
 see 
 Proxy, HTTP)",NA
 J,"JavaScript object notation (JSON) 
  
  
 array, 68 
  
  
 client and server, 72–73 
  
  
 Gob package 
  
  
  
 circular structures, 75 
  
  
  
 Decoder, 76 
  
  
  
 Encoder, 76 
  
  
  
 GobEchoClient.go, 78–79 
  
  
  
 GobEchoServer.go, 80 
  
  
  
 Gob marshalling and unmarshalling, 75 
  
  
 Go data types, 75 
  
  
  
 object, 251, 253 
  
  
  
 pointer types, 75 
  
  
  
 SaveGob.go, 76, 78 
  
  
  
 X.509 serialization, 75 
  
  
 JSONEchoServer.go, 73–74 
  
  
 RPC client, 219–220 
  
  
 RPC server, 218–219 
  
  
 SaveJSON.go, 69–71 
  
  
 string handling, 68 
  
  
 type-dependent default encodings, 69",NA
 K,"Keyed-Hash Message Authentication Code 
 (HMAC), 125",NA
 L,"Links 
  
  
 defined, 225 
  
  
 HTML types, 225 
  
  
 user agent and server, 226 
  
  
 W3C specification JSON-LD 1.0, 226 
  
 XML specifications, 225 
  
 Linux, 260–261 
  
 listFlashCards function, 179, 180 
  
 Local area network (LAN), 3 
  
 Localization (l10n), 107 
  
 Location transparency, 17",NA
 M,"manageFlashCards function, 181 
  
 Maps, 24 
  
 Marshalling, 210 
  
 Marshalling XML, 206–207 
  
 MD5 hashing, 125 
  
 Message 
  
  
 format, 90–91 
  
  
 object, 248, 250–251 
  
  
 passing, 5–6 
  
 Methods, 24 
  
 Metropolitan Area Network (MANs), 3 
 Middleware model, 14 
  
  
 examples, 14 
  
  
 functions, 15 
  
 Migration transparency, 17 
  
 Multiplexer, 155 
  
 Multi-threading, 25",NA
 N,"Networking, 3–4 
  
 404 not found messages, 
 156
  
 Performance 
  
  
  
  
 transparency, 18 
  
 Ping.go program, 53–55 
  
 PinyinFormatter, 189 
  
 PinyinFormatter.go, 184–187 
  
 Pipelines, 164 
  
 Pointers, 23 
  
 ProcInst type, 201 
  
 Protocol design 
  
  
 client code, 99–100 
  
  
 client-server application, 94 
  
 client side, 94 
  
  
 data format 
  
  
  
 byte format, 91–92 
  
  
  
 character format, 92 
  
  
 issues, 87 
  
  
 message format, 90–91 
  
  
 server code, 97–98 
  
  
 server side, 95 
  
  
 standalone application, 93 
  
 state information 
  
  
  
 client state diagram, 104 
  
  
 DCE file system, 102 
  
  
  
 NFS file system, 102 
  
  
  
 server pseudocode, 105 
  
  
 server state diagram, 105 
  
  
 state-transition 
  
  
  
   
 diagram, 103 
  
  
 text protocol, 96 
  
  
 textproto package, 101 
  
  
 version control, 90 
  
 Protocol layers, 1 
  
  
 alternative protocols, 3 
  
  
 ISO OSI protocol, 2 
  
  
 OSI layers, 2 
  
  
 TCP/IP protocols, 3 
  
 Proxy, HTTP 
  
  
 authenticating, 151, 153 
  
  
 simple, 149, 151 
  
 Public key encryption, 127 
  
  
 decryption key, 127 
  
  
 encryption key, 127 
  
  
 RSA scheme, 127–128",NA
 O,"Open systems interconnect (OSI), 29 
 levels, 122 
  
 protocol, 2
  
 Public Key Infrastructure (PKI), 
 129 Punycode, 137",NA
 R,"Register function, 211
  
  
 seven-layer model, 122
  
 Remote procedure calls (RPCs), 6, 210,221. 
  
 See also 
 REST Verbs",NA
" P, Q ","HTTP client, 213–214
  
 HTTP server, 212–213
  
 PacketConn interface, 53 
 Packet encapsulation, 4–5 
 PathEscape function, 230
  
 272
  
 JSON client, 219–220 
  
 JSON server, 218 
  
 restrictions, 210–211",NA
 T,"PUT verb, 223 
  
 The Richardson Maturity 
  
  
 Model, 227–228
  
 TCP, 247 
  
  
 connections 
  
  
  
 staying alive method, 47 
  
  
  
 timeout, 47",NA
 S ,"RPC client, 216–217 
  
  
   
 RPC server, 214–216 
  
 Scalability transparency, 17 
  
 TCPConn type 
  
 Secure Sockets Layer (SSL), 132 
  
  
 daytime server, 42–44 
  
 Self-signed certificate, 133, 135–136 
  
   
 description, 40 Servers 
  
  
 TCP client, 40–42 
  
   
 default multiplexer, 158–159 
  
 TCP/IP protocols, 3 
  
   
 distribution, 9 
  
 TCP/IP stack, 29 
  
   
 file, 155–156 
  
   
 connection-oriented protocol, 30 
  
  
 handler functions, 156–157 
  
  
 IP datagrams, 30 
  
 Server-side code, 210 
  
  
 vs.
  OSI, 30 
  
 Server state transition diagrams, 105 
  
  
 RFCs, 29 
  
 Services 
  
   
 UDP, 30 
  
  
 host machines, 38 
  
  
 virtual 
 circuit, 30 
  
   
 ports, 38–39 
  
 Templates 
  
   
 TCPAddr type, 39, 40 
  
  
 conditional statements, 168–169, 171–
 173 
  
  
 TCP and UDP methods, 38 
  
   
 fmt package, 161 
  
  
 types of, 38 
   
 functions 
 defining, 165–166 
  
 SetKeepAlive method, 53 
  
  
 HTML package, 173
  
 SetReadBuffer method, 53 
  
 showFlashCards function, 189–191
  
 object values inserting, 161–164 
 parsing, process, 162–164
  
 SimpleEchoServer.go program, 44–46 
  
 pipelines, 164
  
 Simple proxy, 149, 151 
  
 variables, 167
  
 273",NA
 V,"Version control, 88–90",NA
 W,"Web server 
  
  
 accents fixing, 184–187 
  
  
 browser pages, 175 
  
  
 browser 
  
  
  
 presentation, 191 
  
  
 flashcards, 191 
  
  
 flashcard sets, 183–184 
  
  
 functions, URLs, 177 
  
  
 pinyin, 191 
  
  
 Server.go, 178 
  
 WebSockets 
  
  
 HTML page, 259–263",NA
 U,"over TLS, 257–259 
  
 server, 248
  
  
 UDP datagrams 
  
  
 functions, 47 
  
  
 program, 47–49 
  
  
 source and destination information, 47 
 Unicode, 108, 111–112 
  
  
 Gotchas, 116–117 
  
 Uniform resource identifiers (URIs), 221, 
 222 Uniform resource locator (URLs), 137, 
 221 Uniform resource names (URNs), 221 
  
 Unmarshal function, 203–206 
  
 User Datagram Protocol (UDP), 30 
  
 UTF-7, 112 
  
 UTF-8, 112 
  
  
 ASCII client and server, 113 
  
  
 client and server, 112 
  
 UTF-16, 112–113 
  
  
 client and server, 114–116 
  
  
 little-endian and big-endian, 113 
  
 UTF-32, 112
  
 274
  
 Wide area network (WAN), 3 
 World Wide Web, 137",NA
" X, Y, Z","X.509 certificates, 153, 159 
  
  
 example, 129–131 
  
  
 PKI, 129 
  
 XHTML, 207 
  
 XML 
  
  
 marshalling, 206–207 
  
  
 parser, 200 
  
  
  
 CharData type, 200 
  
  
  
 Comment type, 200 
  
  
  
 Directive type, 201–203 
  
  
 EndElement type, 200 
  
  
 ProcInst type, 201 
  
  
  
 StartElement type, 200 
  
 unmarshalling, 203–206",NA
