Larger Text,Smaller Text,Symbol
Learning Go Programming,NA,NA
An insightful guide to learning the Go programming language,NA,NA
Vladimir Vivien,BIRMINGHAM - MUMBAI,NA
Learning Go Programming,"Copyright © 2016 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or 
 transmitted in any form or by any means, without the prior written permission of the 
 publisher, except in the case of brief quotations embedded in critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of the 
 information presented. However, the information contained in this book is sold without 
 warranty, either express or implied. Neither the author, nor Packt Publishing, and its 
 dealers and distributors will be held liable for any damages caused or alleged to be caused 
 directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this book by the appropriate use of capitals.
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 First published: October 2016
  
 Production reference: 1201016
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham 
  
 B3 2PB, UK.
  
 ISBN 978-1-78439-543-8
  
 www.packtpub.com",NA
Credits,"Authors Copy Editor
  
 Vladimir Vivien Safis Editing
  
 Reviewers Project Coordinator
  
 Quintessence Anx Nidhi Joshi 
  
 Parth Desai
  
 Abhishek Kumar
  
 Chris Schaefer
  
 Commissioning Editor Proofreader
  
 Akram Hussain Safis Editing
  
 Acquisition Editor Indexer
  
 Manish Nainnani Aishwarya Gangawane 
  
 Content Development Editor Graphics
  
 Aishwarya Pandere Disha Haria
  
 Technical Editor Production Coordinator
  
 Mohita Vyas Nilesh Mohite",NA
About the Author,"Vladimir Vivien
  (
 @vladimirvivien
 ) is a software engineer living in the United States. He is a 
 previously published author and has written code in languages such as Java, JavaScript, 
 Python, C to name a few.  Vladimir has work in diverse industries including technology, 
 publishing, financial, and healthcare. After years of building enterprise systems using Java, 
 Vladimir came to Go for its simplicity and stayed for its concurrency and fast build time.
  
 Vladimir continues to use Go as his primary language to build and create open source 
 software (
 https://github.com/vladimirivivien
 ).",NA
About the Reviewers,"Quintessence Anx
 . is a superhero (also called as Cloud Engineer) at Stark & Wayne LLC by 
 day and an astronomer with a passion for the Internet of Things by night. She is a chapter 
 leader for her local Girl Develop It, where she empowers women programmers of all levels 
 and abilities through classes and hands-on project experiences, as well as co-founder of City 
 of Light 2.0, an organization working to bring more affordable, reliable, and faster internet 
 to Western New York
  
 Parth Desai
  is a polygot programmer and architect, and has worked on almost all popular 
 languages like Golang, python, C#. He regularly contributes to various open-source golang 
 projects, like a notification engine called “Khabar”, a http framework written in golang 
 called “Gottp”, and media server called “moire”. He implemented url signing protocol 
 using cryptography in python, from scratch.
  
 He has also written custom single sign on solution (SSO) in c#, with proper implementation 
 of oauth and saml protocols. He also developed pluggable architecture to facilitate easier 
 adding and removing of authentication providers for the SSO. Currently, He is working as a 
 lead backend engineer, and designing and implementing scalable systems in golang and 
 python. You can reach out to him on linkedin at 
 https://in.linkedin.com/in/parthdesa i0 8
 . Or on 
 his email-id 
 desaiparth08@gmail.com
 .",NA
www.PacktPub.com,"For support files and downloads related to your book, please visit 
 www.PacktPub.com
 .
  
 Did you know that Packt offers eBook versions of every book published, with PDF and 
 ePub files available? You can upgrade to the eBook version at 
 www.PacktPub.com
  and as a 
 print book customer, you are entitled to a discount on the eBook copy. Get in touch with us 
 at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for a 
 range of free newsletters and receive exclusive discounts and offers on Packt books and 
 eBooks.
  
  
 https://www.packtpub.com/mapt
  
 Get the most in-demand software skills with Mapt. Mapt gives you full access to all Packt 
 books and video courses, as well as industry-leading tools to help you plan your 
 personal development and advance your career.",NA
Why subscribe?,"Fully searchable across every book published by Packt
  
 Copy and paste, print, and bookmark content
  
 On demand and accessible via a web browser",NA
Table of Contents,"Preface
  
 1
  
 Chapter 1: A First Step in Go
  
 7
  
 The Go programming language 
 Playing with Go 
  
  
 No IDE required 
  
  
 Installing Go 
  
  
 Source code examples 
  
 Your first Go program 
  
 Go in a nutshell 
  
  
 Functions 
  
  
 Packages 
  
  
 The workspace 
  
  
 Strongly typed 
  
  
 Composite types 
  
  
 The named type 
  
  
 Methods and objects 
  
  
 Interfaces 
  
  
 Concurrency and channels 
  
  
 Memory management and safety 
  
 Fast compilation 
  
  
 Testing and code coverage 
  
  
 Documentation 
  
  
 An extensive library 
  
  
 The Go Toolchain 
  
 Summary
  
 Chapter 2: Go Language Essentials
  
 8
  
  
 1
 0 
  
 1
 1 
  
 1
 1 
  
 1
 2 
  
 1
 2 
  
 1
 3 
  
 1
 5 
  
 1
 6 
  
 1
 6 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 2 
  
 The Go source file 
  
  
 Optional semicolon 
  
  
 Multiple lines 
  
 Go identifiers 
  
  
 The blank identifier 
  
  
 Muting package imports 
  
  
 Muting unwanted function results 
  
 Built-in identifiers
  
 2
 7 
  
 2
 9 
  
 3
 0 
  
 3
 2 
  
 3
 2 
  
 3
 2 
  
 3
 3",NA
Preface,"Go is an open source programming language that lets programmers easily build reliable 
 and scalable programs. It does this by offering a simple syntax which makes it fun to write 
 correct and predictable code using concurrency idioms and a robust standard library.
  
 Go has a large and active online community and there are several Go conferences that take 
 place around the world yearly.  Starting with 
 https://golang.org/
 , you will find 
  
 numerous places on the web that provide documentations, blogs, videos, and slides that 
 cover a wide range of Go-related topics.  On GitHub, the story is no different; some of the 
 best known projects that are driving the future of cloud computing, for instance, are written 
 in Go with an ever growing list.
  
 As you would expect, getting started with Go is simple, fast, and well documented. 
 However, “getting into” Go can be more challenging, especially for newcomers from other 
 languages.  My first attempt at Go failed.  Even after reading the prescribed documentations 
 and going through the tutorials, there was a gap in understanding driven by my own biases 
 from previous programming experiences.  Months later I returned to Go and got into it. 
  
 This time I read the language specs, I read blogs, watch videos, and searched the web for 
 any discussion that provided design motivations and in-depth explanations of the 
 language.
  
 Learning Go is a book intended to help new, and seasoned programmers alike, to get into 
 the Go programming language.  With this book, I have attempted to write the book I would 
 have like to have read when I was starting out with Go.  It distills the language specs, the 
 documentations, the blogs, the videos, slides, and my own experiences of writing Go into 
 content that carefully provides the right amount of depth and insights to help you 
  
 understand the language and its design.
  
 I hope that you enjoy it.",NA
What this book covers,"Chapter 1
 , A First Step in Go,
  the reader is introduced to Go at a high-level and take a tour of 
 the features that have made the language a favorite among its adopters.",NA
What you need for this book,"To follow the examples in this book, you will need Go version 1.6 or later.  Go supports 
 architectures including AMD64, x386, and ARM running the following operating systems:
  
 Windows XP (or later)
  
 Mac OSX 10.7 (or later)
  
 Linux 2.6 (or later)
  
 FreeBSD 8 (or later)",NA
Who this book is for,"If you have prior exposure to programming and are interested learning the Go, this book is 
 designed for you. While it assumes that you are familiar with concepts such as variables, 
 data types, arrays, methods, and functions, the book is designed to allow you to follow 
 chapter by chapter or skip around to the topics you want to learn about.",NA
Conventions,"In this book, you will find a number of text styles that distinguish between different kinds of 
 information. Here are some examples of these styles and an explanation of their meaning.
  
 Code words in text, database table names, folder names, filenames, file extensions, 
 pathnames, dummy URLs, user input, and Twitter handles are shown as follows: ""Save the 
 source code in a file called 
 helloworld.go
  anywhere inside your GOPATH.""
  
 A block of code is set as follows:
  
 package main 
  
 import ""fmt"" 
  
 func main() {
  
  fmt.Println(""Hello, World!"") 
  
 }
  
 Any command-line input or output is written as follows:
  
 $> go version 
  
 go version go1.6.1 linux/amd64",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this book-
 what you liked or disliked. Reader feedback is important for us as it helps us develop titles 
 that you will really get the most out of. To send us general feedback, simply e-mail 
 feedback@packtpub.com
 , and mention the book's title in the subject of your message. If there 
 is a topic that you have expertise in and you are interested in either writing or contributing 
 to a book, see our author guide at 
 www.packtpub.com/authors
 .",NA
Customer support,"Now that you are the proud owner of a Packt book, we have a number of things to help you 
 to get the most from your purchase.",NA
Downloading the example code,"You can download the example code files for this book from your account at 
 http://www.p 
 acktpub.com
 . If you purchased this book elsewhere, you can visit 
 http://www.packtpub.c 
 om/support
  and register to have the files e-mailed directly to you.
  
 You can download the code files by following these steps:
  
 1. Log in or register to our website using your e-mail address and password.
  
 2. Hover the mouse pointer on the 
 SUPPORT
  tab at the top.
  
 3. Click on 
 Code Downloads & Errata
 .
  
 4. Enter the name of the book in the 
 Search
  box.",NA
Downloading the color images of this book,"We also provide you with a PDF file that has color images of the screenshots/diagrams used 
 in this book. The color images will help you better understand the changes in the output. 
 You can download this file from 
 http://www.packtpub.com/sites/default/files/downl 
 oads/LearningGoPrograming_ColorImages.pdf
 .",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books-maybe a mistake in the text or the code-
 we would be grateful if you could report this to us. By doing so, you can save other readers 
 from frustration and help us improve subsequent versions of this book. If you find any 
 errata, please report them by visiting 
 http://www.packtpub.com/submit-errata
 , selecting your 
 book, clicking on the 
 Errata Submission Form
  link, and entering the details of your errata. 
 Once your errata are verified, your submission will be accepted and the errata will be 
 uploaded to our website or added to any list of existing errata under the Errata section of 
 that title.
  
 To view the previously submitted errata, go to 
 https://www.packtpub.com/books/conten t/support
  
 and enter the name of the book in the search field. The required information will appear 
 under the 
 Errata
  section.",NA
Piracy,"Piracy of copyrighted material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works in any form on the Internet, please provide us with 
 the location address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected pirated 
 material.
  
 We appreciate your help in protecting our authors and our ability to bring you valuable 
 content.",NA
Questions,"If you have a problem with any aspect of this book, you can contact us 
  
 at 
 questions@packtpub.com
 , and we will do our best to address the problem.",NA
A First Step in Go ,NA,NA
,"In the first chapter of the book, you will be introduced to Go and take a tour of the features 
 that have made the language a favorite among its adopters. The start of the chapter 
 provides the motivation behind the Go programming language. If you are impatient, 
 however, you are welcome to skip to any of the other topics and learn how to write your 
 first Go program. Finally, the 
 Go in a nutshell
  section provides a high-level summary of the 
 characteristics of the language.
  
 The following topics are covered in this chapter:
  
 The Go programming language
  
 Playing with Go
  
 Installing Go
  
 Your first Go program
  
 Go in a nutshell",NA
The Go programming language,"Since the invention of the C language in the early 1970s by 
 Dennis Ritchie
  at Bell Labs, the 
 computing industry has produced many popular languages that are based directly on (or 
 have borrowed ideas from) its syntax. Commonly known as the C-family of languages, they 
 can be split into two broad evolutionary branches. In one branch, derivatives such as C++, 
 C#, and Java have evolved to adopt a strong type system, object orientation, and the use of 
 compiled binaries. These languages, however, tend to have a slow build-deploy cycle and 
 programmers are forced to adopt a complex object-oriented type system to attain runtime 
 safety and speed of execution:
  
  
 In the other evolutionary linguistic branch are languages such as Perl, Python, and 
 JavaScript that are described as dynamic languages for their lack of type safety formalities, 
 use of lightweight scripting syntax, and code interpretation instead of compilation. Dynamic 
 languages have become the preferred tool for web and cloud scale development where 
 speed and ease of deployment are valued over runtime safety. The interpreted nature of 
 dynamic languages means, however, they generally run slower than their compiled 
 counterparts. In addition, the lack of type safety at runtime means the correctness of the 
 system scales poorly as the application grows.",NA
Playing with Go,"Before we jump head-first into installing and running Go tools on your local machine, let us 
 take a look at the 
 Go Playground
 . The creators of the language have made available a 
 simple way to familiarize yourself with the language without installing any tools. Known as 
 the Go Playground, it is a web-based tool, accessible from 
 https://play.golang.org/
 , that uses an 
 editor metaphor to let developers test their Go skills by writing code directly within the web 
 browser window. The Playground gives its users the ability to compile and run their code 
 on Google's remote servers and get immediate results as shown in the following screenshot:
  
  
 The editor is basic, as it is meant to be used as a learning tool and a way to share code with 
 others. The Playground includes practical features such as line numbers and formatting to 
 ensure your code remains readable as it goes beyond a few lines long. Since this is a free 
 service that consumes real compute resources, Google understandably imposes a few 
 limitations on what can be done with Playground:
  
 You are restricted on the amount of memory your code will consume
  
 Long-running programs will be killed
  
 [ 10 ]",NA
No IDE required,"Besides the Go Playground, how is one supposed to write Go code anyway? Writing Go 
 does not require a fancy 
 Integrated Development Environment
  (
 IDE
 ). As a matter of fact, 
 you can get started writing your simple Go programs with your favorite plain text editor 
 that is bundled with your OS. There are, however, Go plugins for most major text editors 
 (and full-blown IDEs) such as Atom, Vim, Emacs, Microsoft Code, IntelliJ, and many others. 
 There is a complete list of editors and IDE plugins for Go which can be found at 
 https://g 
 ithub.com/golang/go/wiki/IDEsAndTextEditorPlugins
 .",NA
Installing Go,"To start programming with Go on your local machine you will need to install the 
 Go 
 Toolchain
  on your computer. At the time of writing, Go comes ready to be installed on the 
 following major OS platforms:
  
 Linux
  
 FreeBSD Unix
  
 Mac OSX
  
 Windows
  
 The official installation packages are all available for 32-bit and 64-bit Intel-based 
  
 architectures. There are also official binary releases that are available for ARM architectures 
 as well. As Go grows in popularity, there will certainly be more binary distribution choices 
 made available in the future.
  
 Let us skip the detailed installation instructions as they will certainly change by the time 
 you read this. Instead, you are invited to visit 
 http://golang.org/doc/install
  and follow the 
 directions given for your specific platform. Once completed, be sure to test your installation 
 is working before continuing to use the following command:
  
 $> go version 
  
 go version go1.6.1 linux/amd64",NA
Source code examples,"The programming examples presented throughout this book are available on the GitHub 
 source code repository service. There you will find all source files grouped by chapters in 
 the repository at 
 https://github.com/vladimirvivien/learning-go/
 . To save the readers a few 
 keystrokes, the examples use a shortened URL, that starts with 
 golang.fyi
 , that points 
 directly to the respective file in GitHub.
  
 Alternatively, you can follow along by downloading and unzipping (or cloning) the 
 repository locally. Create a directory structure in your 
 GOPATH
  so that the root of the source 
 files is located at 
 $GOPATH/src/github.com/vladimirvivien/learning-go/
 .",NA
Your first Go program,"After installing the Go tools successfully on your local machine, you are now ready to write 
 and execute your first Go program. For that, simply open your favorite text editor and type 
 in the simple Hello World program shown in the following code:
  
 package main 
  
 import ""fmt"" 
  
 func main() {
  
  fmt.Println(""Hello, World!"") 
  
 }
  
 golang.fyi/ch01/helloworld.go",NA
Go in a nutshell,"By design, Go has a simple syntax. Its designers wanted to create a language that is clear, 
 concise, and consistent with few syntactic surprises. When reading Go code, keep this 
 mantra in mind: w
 hat you see is what it is
 . Go shies away from a clever and terse coding style 
 in favor of code that is clear and readable as exemplified by the following program:
  
 // This program prints molecular information for known metalloids // including atomic 
 number, mass, and atom count found 
  
 // in 100 grams of each element using the mole unit.
  
 // See http://en.wikipedia.org/wiki/Mole_(unit) package main
  
 import ""fmt""
  
 const avogadro float64 = 6.0221413e+23 
  
 const grams = 100.0
  
 type amu float64
  
 func (mass amu) float() float64 {
  
  return float64(mass) 
  
 }
  
 type metalloid struct {
  
  name   string
  
  number int32
  
  weight amu 
  
 }
  
 var metalloids = []metalloid{
  
  metalloid{""Boron"", 5, 10.81},
  
  metalloid{""Silicon"", 14, 28.085},
  
  metalloid{""Germanium"", 32, 74.63},
  
  metalloid{""Arsenic"", 33, 74.921},",NA
Functions,"Go programs are composed of functions, the smallest callable code unit in the language. In 
 Go, functions are typed entities that can either be named (as shown in the previous 
 example) or be assigned to a variable as a value:
  
 // a simple Go function 
  
 func moles(mass amu) float64 {
  
  
  return float64(mass) / grams 
  
 }
  
 Another interesting feature about Go functions is their ability to return multiple values as a 
 result of a call. For instance, the previous function could be re-written to return a value of 
 type 
 error
  in addition to the calculated 
 float64
  value:
  
 func moles(mass amu) (float64, error) {
  
  if mass < 0 {
  
  
  
  return 0, error.New(""invalid mass"")
  
  }
  
  
  return (float64(mass) / grams), nil }
  
 The previous code uses the multi-return capabilities of Go functions to return both the mass 
 and an error value. You will encounter this idiom throughout the book used as a mean to 
 properly signal errors to the caller of a function. There will be further discussion on multi-
 return value functions covered in 
 Chapter 5
 , 
 Functions in Go
 .
  
 [ 15 ]",NA
Packages,"Source files containing Go functions can be further organized into directory structures 
 known as a package. Packages are logical modules that are used to share code in Go as 
 libraries. You can create your own local packages or use tools provided by Go to 
  
 automatically pull and use remote packages from a source code repository. You will learn 
 more about Go packages in 
 Chapter 6
 , 
 Go Packages and Programs
 .",NA
The workspace,"Go follows a simple code layout convention to reliably organize source code packages and 
 to manage their dependencies. Your local Go source code is stored in the workspace, which 
 is a directory convention that contains the source code and runtime artifacts. This makes it 
 easy for Go tools to automatically find, build, and install compiled binaries. Additionally, 
 Go tools rely on the 
 workspace
  setup to pull source code packages from remote 
  
 repositories, such as Git, Mercurial, and Subversion, and satisfy their dependencies.",NA
Strongly typed,"All values in Go are statically typed. However, the language offers a simple but expressive 
 type system that can have the feel of a dynamic language. For instance, types can be safely 
 inferred as shown in the following code snippet:
  
 const grams = 100.0
  
 As you would expect, constant grams would be assigned a numeric type, 
 float64
 , to be 
 precise, by the Go type system. This is true not only for constants, but any variable can use a 
 short-hand form of declaration and assignment as shown in the following example:
  
 package main 
  
 import ""fmt"" 
  
 func main() {
  
  var name = ""Metalloids""
  
  var triple = [3]int{5,14,84}
  
  elements := []string{""Boron"",""Silicon"", ""Polonium""} isMetal := false
  
  fmt.Println(name, triple, elements, isMetal)
  
 }",NA
Composite types,"Besides the types for simple values, Go also supports composite types such as 
 array
 , 
 slice
 , 
 and 
 map
 . These types are designed to store indexed elements of values of a specified type. 
 For instance, the 
 metalloid
  example shown previously makes use of a slice, which is a 
 variable-sized array. The variable 
 metalloid
  is declared as a 
 slice
  to store a collection of the 
 type 
 metalloid
 . The code uses the literal syntax to combine the declaration and assignment of 
 a 
 slice
  of type 
 metalloid
 :
  
 var metalloids = []metalloid{
  
  
  metalloid{""Boron"", 5, 10.81},
  
  
  metalloid{""Silicon"", 14, 28.085},
  
  
  metalloid{""Germanium"", 32, 74.63},
  
  
  metalloid{""Arsenic"", 33, 74.921},
  
  
  metalloid{""Antimony"", 51, 121.760},
  
  
  metalloid{""Tellerium"", 52, 127.60},
  
  
  metalloid{""Polonium"", 84, 209.0}, 
  
 }
  
 Go also supports a 
 struct
  type which is a composite that stores named elements called 
 fields as shown in the following code:
  
 func main() {
  
  planet := struct {
  
   
  name string
  
   
  diameter int
  
  }{""earth"", 12742} 
  
 }
  
 The previous example uses the literal syntax to declare 
 struct{name string; diameter int}
  with 
 the value 
 {""earth"", 12742}
 . You can read all about composite types in 
 Chapter 7
 , 
 Composite 
 Types
 .",NA
The named type,"As discussed, Go provides a healthy set of built-in types, both simple and composite. Go 
 programmers can also define new named types based on an existing underlying type as 
 shown in the following snippet extracted from 
 metalloid
  in the earlier example:
  
 type amu float64
  
 type metalloid struct {
  
  name string
  
  number int32
  
  weight amu 
  
 }
  
 The previous snippet shows the definition of two named types, one called 
 amu
 , which uses 
 type 
 float64
  as its underlying type. Type 
 metalloid
 , on the other hand, uses a 
 struct 
 composite type as its underlying type, allowing it to store values in an indexed data 
 structure. You can read more about declaring new named types in 
 Chapter 4
 , 
 Data Types
 .",NA
Methods and objects,"Go is not an object-oriented language in a classical sense. Go types do not use a class 
 hierarchy to model the world as is the case with other object-oriented languages. However, 
 Go can support the object-based development idiom, allowing data to receive behaviors. 
 This is done by attaching functions, known as methods, to named types.
  
 The following snippet, extracted from the metalloid example, shows the type 
 amu
  receiving 
 a method called 
 float()
  that returns the mass as a 
 float64
  value:
  
 type amu float64
  
 func (mass amu) float() float64 {
  
  
  return float64(mass) 
  
 }
  
 The power of this concept is explored in detail in 
 Chapter 8
 , 
 Methods, Interfaces, and Objects
 .",NA
Interfaces,"Go supports the notion of a programmatic interface. However, as you will see in 
 Chapter 8
 , 
 Methods, Interfaces, and Objects
 , the Go interface is itself a type that aggregates a set of 
 methods that can project capabilities onto values of other types. Staying true to its simplistic 
 nature, implementing a Go interface does not require a keyword to explicitly declare an 
 interface. Instead, the type system implicitly resolves implemented interfaces using the 
 methods attached to a type.
  
 For instance, Go includes the built-in interface called 
 Stringer
 , defined as follows:
  
 type Stringer interface {
  
  
  String() string 
  
 }
  
 Any type that has the method 
 String()
  attached, automatically implements the 
 Stringer 
 interface. So, modifying the definition of the type 
 metalloid
 , from the previous program, to 
 attach the method 
 String()
  will automatically implement the 
 Stringer
  interface:
  
 type metalloid struct {
  
   
  name string
  
   
  number int32
  
   
  weight amu 
  
 } 
  
 func (m metalloid) String() string {
  
  return fmt.Sprintf(
  
   
  ""%-10s %-10d %-10.3f %e"",
  
   
  m.name, m.number, m.weight.float(), atoms(moles(m.weight)), ) 
  
 }
  
 golang.fyi/ch01/metalloids2.go
  
 The 
 String()
  methods return a pre-formatted string that represents the value of a 
 metalloid
 . 
 The function 
 Print()
 , from the standard library package 
 fmt
 , will 
  
 automatically call the method 
 String()
 , if its parameter implements 
 stringer
 . So, we can use 
 this fact to print 
 metalloid
  values as follow:
  
 func main() {
  
  fmt.Print(headers())
  
  for _, m := range metalloids {
  
   
  fmt.Print(m, ""\n"")
  
  } 
  
 }",NA
Concurrency and channels,"One of the main features that has rocketed Go to its current level of adoption is its inherent 
 support for simple concurrency idioms. The language uses a unit of concurrency known as 
 a 
 goroutine
 , which lets programmers structure programs with independent and highly 
 concurrent code.
  
 As you will see in the following example, Go also relies on a construct known as a channel 
 used for both communication and coordination among independently running 
  
 goroutines
 . This approach avoids the perilous and (sometimes brittle) traditional approach of 
 thread communicating by sharing memory. Instead, Go facilitates the approach of sharing 
 by communicating using channels. This is illustrated in the following example that uses 
 both 
 goroutines
  and channels as processing and communication primitives:
  
 // Calculates sum of all multiple of 3 and 5 less than MAX value. // See 
 https://projecteuler.net/problem=1 
  
 package main
  
 import (
  
  ""fmt"" 
  
 )
  
 const MAX = 1000
  
 func main() {
  
  work := make(chan int, MAX)
  
  result := make(chan int)
  
  // 1. Create channel of multiples of 3 and 5 // concurrently 
 using goroutine
  
  go func(){
  
  
  for i := 1; i < MAX; i++ {
  
   
  if (i % 3) == 0 || (i % 5) == 0 {
  
    
  work <- i // push for work
  
   
  }
  
  
  }
  
  
  close(work)
  
  }()
  
  // 2. Concurrently sum up work and put result //    in channel 
 result
  
  go func(){",NA
Memory management and safety,"Similar to other compiled and statically-typed languages such as C and C++, Go lets 
 developers have direct influence on memory allocation and layout. When a developer 
 creates a 
 slice
  (think 
 array
 ) of bytes, for instance, there is a direct representation of those 
 bytes in the underlying physical memory of the machine. Furthermore, Go borrows the 
 notion of pointers to represent the memory addresses of stored values giving Go programs 
 the support of passing function parameters by both value and reference.
  
 Go asserts a highly opinionated safety barrier around memory management with little to no 
 configurable parameters. Go automatically handles the drudgery of bookkeeping for 
 memory allocation and release using a runtime garbage collector. Pointer arithmetic is not 
 permitted at runtime; therefore, developers cannot traverse memory blocks by adding to or 
 subtracting from a base memory address.",NA
Fast compilation,"Another one of Go's attractions is its millisecond build-time for moderately-sized projects. 
 This is made possible with features such as a simple syntax, conflict-free grammar, and a 
 strict identifier resolution that forbids unused declared resources such as imported 
 packages or variables. Furthermore, the build system resolves packages using transitivity 
 information stored in the closest source node in the dependency tree. Again, this reduces 
 the code-compile-run cycle to feel more like a dynamic language instead of a compiled 
 language.",NA
Testing and code coverage,"While other languages usually rely on third-party tools for testing, Go includes both a built-
 in API and tools designed specifically for automated testing, benchmarking, and code 
 coverage. Similar to other features in Go, the test tools use simple conventions to 
  
 automatically inspect and instrument the test functions found in your code.
  
 The following function is a simplistic implementation of the Euclidean division algorithm 
 that returns a quotient and a remainder value (as variables 
 q
  and 
 r
 ) for positive integers:
  
 func DivMod(dvdn, dvsr int) (q, r int) { r = dvdn
  
  for r >= dvsr {
  
   
  q += 1
  
   
  r = r - dvsr
  
  }
  
  return 
  
 }
  
 golang.fyi/ch01/testexample/divide.go
  
 In a separate source file, we can write a test function to validate the algorithm by 
 checking the remainder value returned by the tested function using the Go test API as 
 shown in the following code:
  
 package testexample 
  
 import ""testing"" 
  
 func TestDivide(t *testing.T) {
  
  dvnd := 40
  
   
  for dvsor := 1; dvsor < dvnd; dvsor++ {
  
    
  q, r := DivMod(dvnd, dvsor)
  
  if (dvnd % dvsor) != r {
  
   
  t.Fatalf(""%d/%d q=%d, r=%d, bad remainder."", dvnd, dvsor, q, r)
   
  }",NA
Documentation,"Documentation is a first-class component in Go. Arguably, the language's popularity is in 
 part due to its extensive documentation (see 
 http://golang.org/pkg
 ). Go comes with the Godoc 
 tool, which makes it easy to extract documentation from comment text embedded directly 
 in the source code. For example, to document the function from the previous section, we 
 simply add comment lines directly above the 
 DivMod
  function as shown in the following 
 example:
  
 // DivMod performs a Eucledan division producing a quotient and remainder. // This version only works 
 if dividend and divisor > 0.
  
 func DivMod(dvdn, dvsr int) (q, r int) { ...
  
 }
  
 The Go documentation tool can automatically extract and create HTML-formatted pages. 
 For instance, the following command will start the Godoc tool as a server on 
 localhost 
 port 6000
 :
  
 $> godoc -http="":6001""",NA
An extensive library,"For its short existence, Go rapidly grew a collection of high-quality APIs as part of its 
 standard library that are comparable to other popular and more established languages. The 
 following, by no means exhaustive, lists some of the core APIs that programmers get out-of-
 the-box:
  
 Complete support for regular expressions with search and replace
  
 Powerful IO primitives for reading and writing bytes
  
 Full support for networking from socket, TCP/UDP, IPv4, and IPv6
  
 APIs for writing production-ready HTTP services and clients
  
 Support for traditional synchronization primitives (mutex, atomic, and so on)
  
 General-purpose template framework with HTML support
  
 Support for JSON/XML serializations
  
 RPC with multiple wire formats
  
 APIs for archive and compression algorithms: 
 tar
 , 
 zip
 /
 gzip
 , 
 zlib
 , and so on
  
 Cryptography support for most major algorithms and hash functions
  
 Access to OS-level processes, environment info, signaling, and much more",NA
The Go Toolchain,"Before we end the chapter, one last aspect of Go that should be highlighted is its collection 
 of tools. While some of these tools were already mentioned in previous sections, others are 
 listed here for your awareness:
  
 fmt
 : Reformats source code to adhere to the standard
  
 vet
 : Reports improper usage of source code constructs
  
 lint
 : Another source code tool that reports flagrant style infractions
  
 goimports
 : Analyzes and fixes package import references in source code
  
 godoc
 : Generates and organizes source code documentation
  
 generate
 : Generates Go source code from directives stored in source code
  
 get
 : Remotely retrieves and installs packages and their dependencies
  
 build
 : Compiles code in a specified package and its dependencies
  
 run
 : Provides the convenience of compiling and running your Go program
  
 test
 : Performs unit tests with support for benchmark and coverage reports
  
 oracle
  static analysis tool: Queries source code structures and elements
  
 cgo
 : Generates source code for interoperability between Go and C",NA
Summary,"Within its relatively short existence, Go has won the hearts of many adopters who value 
 simplicity as a way to write code that is exact and is able to scale in longevity. As you have 
 seen from the previous sections in this chapter, it is easy to get started with your first Go 
 program.
  
 The chapter also exposed its readers to a high-level summary of the most essential features 
 of Go including its simplified syntax, its emphasis on concurrency, and the tools that make 
 Go a top choice for software engineers, creating systems for the age of data center 
  
 computing. As you may imagine, this is just a taste of what's to come.
  
 In the following chapters, the book will continue to explore in detail the syntactical 
 elements and language concepts that make Go a great language to learn. Let's Go!",NA
Go Language Essentials ,NA,NA
,"In the previous chapter, we established the elemental characteristics that make Go a great 
 language with which to create modern system programs. In this chapter, we dig deeper into 
 the language's syntax to explore its components and features.
  
 We will cover the following topics:
  
 The Go source file
  
 Identifiers
  
 Variables
  
 Constants
  
 Operators",NA
The Go source file ,"We have seen, in 
 Chapter 1
 , 
 A First Step in Go
 , some examples of Go programs. In this
  
 section, we will examine the Go source file. Let us consider the following source code file
  
 (which prints 
 ""Hello World""
  greetings in different languages):
  
  
 golang.fyi/ch02/helloworld2.go
  
 A typical Go source file, such as the one listed earlier, can be divided into three main
  
 sections, illustrated as follows:
  
 The 
 Package Clause
 :
  
  //1 Package Clause
  
  package main
  
 [ 27 ]",NA
Optional semicolon,"You may have noticed that Go does not require a semicolon as a statement separator. This is 
 a trait borrowed from other lighter and interpreted languages. The following two programs 
 are functionally equivalent. The first program uses idiomatic Go and omits the semicolons:
  
  
 The second version of the program, shown as follows, uses superfluous semicolons to 
 explicitly terminate its statements. While the compiler may thank you for your help, this is 
 not idiomatic in Go:
  
  
 Although semicolons in Go are optional, Go's formal grammar still requires them as 
 statement terminators. So, the Go compiler will insert semicolons at the end of source code 
 lines that end with the following:
  
 An identifier
  
 A literal value for string, Boolean, numeric, or complex
  
 A control flow directive such as break, continue, or return
  
 A closing parenthesis or bracket such as 
 )
 , 
 }
 , or 
 ]
  
 The increment 
 ++
  or the decrement 
 --
  operator",NA
Multiple lines,"Breaking up expressions into multiple lines must follow the semi-colon rules discussed in 
 the previous section. Mainly, in a multi-line expression, each line must end with a token that 
 prevents the premature insertion of a semi-colon, as illustrated in the following table. It 
 should be noted that rows in the table with an invalid expression will not compile:
  
 Expression 
  
 Valid
  
 lonStr := ""Hello World! "" + 
  
 Yes, the 
 +
  operator prevents a premature semi-colon 
 ""How are you?"" 
  
 from being inserted.
  
 lonStr := ""Hello World! "" 
  
 No, a semi-colon will be inserted after the first line, 
 + ""How are you?"" 
  
 semantically breaking the line.
  
 fmt.Printf(""[%s] %d %d %v"", str, 
 num1, num2, nameMap)
  
 Yes, the comma properly breaks the expression.",NA
Go identifiers,"Go identifiers are used to name program elements including packages, variables, functions, 
 and types. The following summarizes some attributes about identifiers in Go:
  
 Identifiers support the Unicode character set
  
 The first position of an identifier must be a letter or an underscore
  
 Idiomatic Go favors mixed caps (camel case) naming
  
 Package-level identifiers must be unique across a given package
  
 Identifiers must be unique within a code block (functions, control statements)",NA
The blank identifier,"The Go compiler is particularly strict about the use of declared identifiers for variables or 
 packages. The basic rule is: 
 you declare it, you must use it
 . If you attempt to compile code with 
 unused identifiers such as variables or named packages, the compilers will not be pleased 
 and will fail compilation.
  
 Go allows you to turn off this behavior using the blank identifier, represented by the 
 _ 
 (underscore) character. Any declaration or assignment that uses the blank identifier is not 
 bound to any value and is ignored at compile time. The blank identifier is usually used in 
 two contexts, as listed in the following subsections.",NA
Muting package imports,"When a package declaration is preceded by an underscore, the compiler allows the package 
 to be declared without any further referenced usage:
  
 import ""fmt"" 
  
 import ""path/filepath"" 
  
 import _ ""log""
  
 In the previous code snippet, the package 
 log
  will be muted without any further reference 
 in the code. This can be a handy feature during active development of new code, where 
 developers may want to try new ideas without constantly having to comment out or delete 
 the declarations. Although a package with a blank identifier is not bound to any reference, 
 the Go runtime will still initialize it. 
 Chapter 6
 , 
 Go Packages and Programs
 , discusses the 
 package initialization lifecycle.",NA
Muting unwanted function results,"When a Go function call returns multiple values, each value in the return list must be 
 assigned to a variable identifier. In some cases, however, it may be desirable to mute 
 unwanted results from the return list while keeping others, as shown in the following call:
  
 _, execFile := filepath.Split(""/opt/data/bigdata.txt"")
  
 The previous call to the function 
 filepath.Split(""/opt/data/bigdata.txt"")
  takes a path and 
 returns two values: the first is the parent path (
 /opt/data
 ) and the second is the file name 
 (
 bigdata.txt
 ). The first value is assigned to the blank identifier and is, therefore, unbounded 
 to a named identifier, which causes it to be ignored by the compiler. In future discussions, 
 we will explore other uses of this idiom's other contexts, such as error-handling and 
 for
  
 loops.",NA
Built-in identifiers,"Go comes with a number of built-in identifiers. They fall into different categories, including 
 types, values, and built-in function.",NA
Types,"The following identifiers are used for Go's built-in types:
  
 Category Identifier
  
 Numeric 
  
 byte
 , 
 int
 , 
 int8
 , 
 int16
 , 
 int32
 , 
 int64
 , 
 rune
 , 
 uint
 , 
 uint8
 , 
 uint16
 , 
 uint32
 , 
  
 uint64
 , 
 float32
 , 
 float64
 , 
 complex64
 , 
 complex128
 , 
 uintptr
  
 String 
  
 string
  
 Boolean 
  
 bool
  
 Error 
  
 error",NA
Values,"These identifiers have preassigned values:
  
 Category 
  
 Identifier
  
 Boolean constants 
  
 true
 , 
 false
  
 Constant counter 
  
 iota
  
 Uninitialized value
  nil",NA
Functions,"The following functions are available as part of Go's built-in pre-declared identifiers:
  
 Category 
  
 Identifier
  
 Initialization 
  
 make()
 , 
 new()
  
 Collections 
  
 append()
 , 
 cap()
 , 
 copy()
 , 
 delete()
  
 Complex numbers
  complex()
 , 
 imag()
 , 
 real()
  
 Error Handling 
  
 panic()
 , 
 recover()",NA
Go variables,"Go is a strictly typed language, which implies that all variables are named elements that are
  
 bound to both a value and a type. As you will see, the simplicity and flexibility of its syntax
  
 make declaring and initializing variables in Go feel more like a dynamically-typed
  
 language.",NA
Variable declaration,"Before you can use a variable in Go, it must be declared with a named identifier for future
  
 reference in the code. The long form of a variable declaration in Go follows the format
  
 shown here:
  
 var <identifier list> <type>
  
 [ 34 ]",NA
The zero-value,"The previous source code shows several examples of variables being declared with a variety 
 of types. Then the variables are assigned a value inside the function 
 main()
 . At first glance, it 
 would appear that these declared variables do not have an assigned value when they are 
 declared. This would contradict our previous assertion that all Go variables are bound to a 
 type and a value.
  
 How can we declare a variable and not bind a value to it? During declaration of a variable, if 
 a value is not provided, Go will automatically bind a default value (or a zero-value) to the 
 variable for proper memory initialization (we see how to do both declaration and 
  
 initialization in one expression later).
  
 The following table shows Go types and their default zero-values:
  
 Type Zero-Value
  
 string """"
  (empty string)
  
 Numeric 
 –
  Integers: 
 byte
 , 
 int
 , 
 int8
 , 
 int16
 , 0 
 int32
 , 
 int64
 , 
 rune
 , 
 uint
 , 
 uint8
 , 
 uint16
 , 
  
 uint32
 , 
 uint64
 , 
 uintptr
  
 Numeric 
 –
  Floating point: 
 float32
 , 
 float64 
 0.0
  
 bool 
 false
  
 Array 
 Each index position has a zero-value corresponding to the array's element type.
  
 Struct 
 An empty 
 struct
  with each member having its respective zero-value.
  
 Other types: Interface, function, channel, slice, nil map, 
 and pointer",NA
Initialized declaration,"As hinted earlier, Go also supports the combination of both variable declaration and 
 initialization as one expression using the following format:
  
 var <identifier list> <type> = <value list or initializer expressions>
  
 [ 36 ]",NA
Omitting variable types,"So far, we have discussed what is called the long form of Go's variable declaration and 
 initialization. To make the language feel closer to its dynamically-typed cousins, the type 
 specification can be omitted, as shown in the following declaration format:
  
 var <identifier list> = <value list or initializer expressions>
  
 During compilation, the compiler infers the type of the variable based on the assigned value 
 or the initializer expression on the right-hand side of the equal sign, as shown in the 
 following example.
  
 var name, desc = ""Mars"", ""Planet"" 
  
 var radius = 6755 
  
 var mass = 641693000000000.0 
  
 var active = true 
  
 var satellites = []string{
  
  ""Phobos"",
  
  ""Deimos"", 
  
 }
  
 golang.fyi/ch02/vardec3.go",NA
Short variable declaration,"Go can further reduce the variable declaration syntax using the 
 short variable declaration 
 format. In this format, the declaration loses the var keyword and the type specification, and 
 uses an assignment operator 
 :=
  (colon-equal), as shown:
  
 <identifier list> := <value list or initializer expressions>
  
 This is a simple and uncluttered idiom that is commonly used when declaring variables in 
 Go. The following code sample shows usage of the short variable declarations:
  
 func main() {
  
  
  name := ""Neptune""
  
  
  desc := ""Planet""
  
  
  radius := 24764
  
  
  mass := 1.024e26
  
  
  active := true
  
  
  satellites := []string{
  
  
   
  ""Naiad"", ""Thalassa"", ""Despina"", ""Galatea"", ""Larissa"",
  
  ""S/2004 N 1"", 
 ""Proteus"", ""Triton"", ""Nereid"", ""Halimede"",
   
  
  ""Sao"", ""Laomedeia"", 
 ""Neso"", ""Psamathe"",
  
  
  } 
  
 ...
  
 }
  
 golang.fyi/ch02/vardec4.go",NA
Restrictions for short variable declaration,"For convenience, the short form of the variable declaration does come with several 
 restrictions that you should be aware of to avoid confusion:
  
 Firstly, it can only be used within a function block
  
 The assignment operator 
 :=
 , declares variable and assign values
  
 :=
  cannot be used to update a previously declared variable
  
 Updates to variables must be done with an equal sign
  
 While these restrictions may have their justifications rooted in the simplicity of Go's 
 grammar, they are generally viewed as a source of confusion for newcomers to the 
 language. For instance, the colon-equal operator cannot be used with package-level 
 variables assignments. Developers learning Go may find it compelling to use the 
 assignment operator as a way to update a variable, but that would cause a compilation 
 error.",NA
Variable scope and visibility,"Go uses lexical scoping based on code blocks to determine the visibility of variables within 
 a package. Depending on the location where a variable is declared, within the source text, 
 will determine its scope. As a general rule, a variable is only accessible from within the 
 block where it is declared and visible to all nested sub-blocks.",NA
Variable declaration block,"Go's syntax allows the declaration of top-level variables to be grouped together into blocks 
 for greater readability and code organization. The following example shows a rewrite of 
 one of the previous examples using the variable declaration block:
  
 var (
  
  name string = ""Earth""
  
  desc string = ""Planet""
  
  radius int32 = 6378
  
  mass float64 = 5.972E+24
  
  active bool = true
  
  satellites []string 
  
 )
  
 golang.fyi/ch02/vardec5.go",NA
Go constants,"In Go, a constant is a value with a literal representation such as a string of text, Boolean, or 
 numbers. The value for a constant is static and cannot be changed after initial assignment.
  
 While the concept they represent is simple, constants, however, have some interesting 
 properties that make them useful, especially when working with numeric values.",NA
Constant literals,"Constants are values that can be represented by a text literal in the language. One of the 
 most interesting properties of constants is that their literal representations can either be 
 treated as typed or untyped values. Unlike variables, which are intrinsically bound to a 
 type, constants can be stored as untyped values in memory space. Without that type 
 constraint, numeric constant values, for instance, can be stored with great precision.
  
 The followings are examples of valid constant literal values that can be expressed in Go:
  
 ""Mastering Go"" 
  
 'G' 
  
 false 
  
 111009 
  
 2.71828 
  
 94314483457513374347558557572455574926671352 1e+500 5.0i",NA
Typed constants,"Go constant values can be bound to named identifiers using a constant declaration. Similar 
 to a variable declaration, Go uses the 
 const
  keyword to indicate the declaration of a 
 constant. Unlike variables, however, the declaration must include the literal value to be 
 bound to the identifier, as shown in the following format:
  
 const <identifier list> type = <value list or initializer expressions>
  
 Constants cannot have any dependency that requires runtime resolution. The compiler 
 must be able to resolve the value of a constant at compile time. This means all constants 
 must be declared and initialized with a value literal (or an expression that results to a 
 constant value).
  
 The following snippet shows some typed constants being declared:
  
 const a1, a2 string = ""Mastering"", ""Go"" 
  
 const b rune = 'G' 
  
 const c bool = false 
  
 const d int32 = 111009 
  
 const e float32 = 2.71828 
  
 const f float64 = math.Pi * 2.0e+3 
  
 const g complex64 = 5.0i 
  
 const h time.Duration = 4 * time.Second
  
 golang.fyi/ch02/const.go
  
 Notice in the previous source snippet that each declared constant identifier is explicitly 
 given a type. As you would expect, this implies that the constant identifier can only be used 
 in contexts that are compatible with its types. However, the next section explains how this 
 works differently when the type is omitted in the constant declaration.",NA
Untyped constants,"Constants are even more interesting when they are untyped. An untyped constant is 
 declared as follows:
  
 const <identifier list> = <value list or initializer expression>",NA
Assigning untyped constants,"Untyped constant values are of limited use until they are assigned to variables, used as 
 function parameters, or are part of an expression assigned to a variable. In a strongly-typed 
 language like Go, this means there is a potential for some type adjustment to ensure that the 
 value stored in the constant can be properly assigned to the target variable. One advantage 
 of using untyped constants is that the type system relaxes the strict application of type 
 checking. An untyped constant can be assigned to different, though compatible, types of 
 different precision without any complaint from the compiler, as shown in the following 
 example:
  
 const m2 = 1.414213562373095048801688724209698078569671875376... var u1 
 float32 = m2 
  
 var u2 float64 = m2 
  
 u3 := m2",NA
Constant declaration block,"As you may have guessed, constant declarations, can be organized as code blocks to 
 increase readability. The previous example can be rewritten as follows:
  
 const (
  
  a1, a2 string        = ""Mastering"", ""Go"" b      rune          = 'G'
  
  c      bool          = false
  
  d      int32         = 111009
  
  e      float32       = 2.71828
  
  f      float64       = math.Pi * 2.0e+3 g      complex64     = 5.0i
  
  h      time.Duration = 4 * time.Second ...
  
 )
  
 golang.fyi/ch02/const2.go
  
 [ 45 ]",NA
Constant enumeration,"One interesting usage of constants is to create enumerated values. Using the declaration 
 block format (shown in the preceding section), you can easily create numerically increasing 
 enumerated integer values. Simply assign the pre-declared constant value 
 iota
  to a constant 
 identifier in the declaration block, as shown in the following code sample:
  
 const (
  
  StarHyperGiant = iota
  
  StarSuperGiant
  
  StarBrightGiant
  
  StarGiant
  
  StarSubGiant
  
  StarDwarf
  
  StarSubDwarf
  
  StarWhiteDwarf
  
  StarRedDwarf
  
  StarBrownDwarf 
  
 )
  
 golang.fyi/ch02/enum0.go
  
 The compiler will then automatically do the following:
  
 Declare each member in the block as an untyped integer constant value
  
 Initialize 
 iota
  with a value of zero
  
 Assign 
 iota
 , or zero, to the first constant member (
 StarHyperGiant
 )
  
 Each subsequent constant is assigned an 
 int
  value increased by one
  
 So the previous list of constants would be assigned a sequence of values going from zero to 
 nine. Whenever 
 const
  appears as a declaration block, it resets the counter to zero. In the 
 following snippet, each set of constants is enumerated from zero to four separately:
  
 const (
  
  StarHyperGiant = iota
  
  StarSuperGiant
  
  StarBrightGiant
  
  StarGiant
  
  StarSubGiant 
  
 ) 
  
 const (
  
  StarDwarf = iota
  
  StarSubDwarf
  
  StarWhiteDwarf
  
  StarRedDwarf",NA
Overriding the default enumeration type,"By default, an enumerated constant is declared as an untyped integer value. However, you 
 can override the default type of the enumerated values by providing an explicit numeric 
 type for your enumerated constants, as shown in the following code sample:
  
 const (
  
  StarDwarf byte = iota
  
  StarSubDwarf
  
  StarWhiteDwarf
  
  StarRedDwarf
  
  StarBrownDwarf 
  
 )
  
 You can specify any numeric type that can represent integers or floating point values. For 
 instance, in the preceding code sample, each constant will be declared as type 
 byte
 .",NA
Using iota in expressions,"When 
 iota
  appears in an expression, the same mechanism works as expected. The 
 compiler will apply the expression for each successive increasing value of 
 iota
 . The 
 following example assigns even numbers to the enumerated members of the constant 
 declaration block:
  
 const (
  
  StarHyperGiant = 2.0*iota
  
  StarSuperGiant
  
  StarBrightGiant
  
  StarGiant
  
  StarSubGiant 
  
 )
  
 golang.fyi/ch02/enum2.go
  
 As you may expect, the previous example assigns an even value to each enumerated 
 constants, starting with 0, as shown in the following output:
  
  StarHyperGiant = 0    [float64]",NA
Skipping enumerated values,"When working with enumerated constants, you may want to throw away certain values 
 that should not be part of the enumeration. This can be accomplished by assigning iota to 
 the blank identifier at the desired position in the enumeration. For instance, the following 
 skips the values 0 and 
 64
 :
  
 _              = iota    // value 0 
  
 StarHyperGiant = 1 << iota 
  
 StarSuperGiant 
  
 StarBrightGiant 
  
 StarGiant 
  
 StarSubGiant 
  
 _          // value 64 
  
 StarDwarf 
  
 StarSubDwarf 
  
 StarWhiteDwarf 
  
 StarRedDwarf 
  
 StarBrownDwarf
  
 golang.fyi/ch02/enum3.go
  
 Since we skip 
 iota
  position 
 0
 , the first assigned constant value is at position 
 1
 . This results in 
 expression 
 1 << iota
  resolving to 
 1 << 1 = 2
 . The same is done at the sixth position, where 
 expression 
 1 << iota
  returns 
 64
 . That value will be skipped and not assigned to any constant, 
 as shown in the following output:
  
  StarHyperGiant = 2
  
  StarSuperGiant = 4
  
  StarBrightGiant = 8
  
  StarGiant = 16
  
  StarSubGiant = 32
  
  StarDwarf = 128
  
  StarSubDwarf = 256
  
  StarWhiteDwarf = 512
  
  StarRedDwarf = 1024
  
  StarBrownDwarf = 2048",NA
Go operators,"Staying true to its simplistic nature, operators in Go do exactly what you would expect, 
 mainly, they allow operands to be combined into expressions. There are no hidden surprise 
 behaviors with Go operators as there is no support for operator-overloading as found in C++ 
 or Scala. This was a deliberate decision from the designers to keep the semantics of the 
 language simple and predictable.
  
 This section explores the most common operators that you will encounter as you start with 
 Go. Other operators are covered throughout other chapters of the book.",NA
Arithmetic operators,"The following table summarizes the arithmetic operators supported in Go.
  
 Operator Operation 
  
 Compatible types
  
 *
 , 
 /
 , 
 -
  
 Multiplication, division, and 
  
 Integers, floating points, and complex numbers 
  
 subtraction
  
 %
  
 Remainder
  
 Integers
  
 +
  
 Addition
  
 Integers, floating points, complex numbers, and
  
 strings (concatenation)
  
 Note that the addition operator, 
 +
 , can be applied to strings such as in the expression 
 var i = 
 ""G is"" + "" for Go""
 . The two string operands are concatenated to create a new string that is 
 assigned to variable 
 i
 .",NA
The increment and decrement operators,"As with other C-like languages, Go supports the 
 ++
  (increment) and the 
 --
  (decrement) 
 operators. When applied, these operators increase, or decrease, the operand's value by 
 one, respectively. The following shows a function that uses the decrement operator to 
 traverse the letters in string s in the reverse order:
  
 func reverse(s string) {
  
  for i := len(s) - 1; i >= 0; {
  
   
  fmt.Print(string(s[i]))
  
   
  i--
  
  } 
  
 }",NA
Go assignment operators,"Operator Description
  
 = 
  
 The simple assignment works as expected. It updates the left operand with the 
  
 value of the right.
  
 := 
  
 The colon-equal operator declares a new variable, the left-side operator, and assigns 
  
 it the value (and type) of the operand on the right.
  
 += 
  
 Apply the indicated operation using the left and the right operator and store the 
 , 
 -= 
  
 result in the left operator. For instance, 
 a *= 8
  implies 
 a = a * 8
 .
  
 , 
 *= 
  
 , 
 /= 
  
 , 
 %=",NA
Bitwise operators,"Go includes full support for manipulating values at their most elemental forms. The 
 following summarizes bitwise operators supported by Go:
  
 Operator Description
  
 & 
  
 Bitwise AND
  
 | 
  
 Bitwise OR
  
 a ^ b 
  
 Bitwise XOR",NA
Logical Operators,"The following is a list of Go logical operations on Boolean values:
  
 Operator Operation
  
 && 
  
 Logical AND
  
 || 
  
 Logical OR
  
 ! 
  
 Logical NOT",NA
Comparison operators,"All Go types can be tested for equality, including basic and composite types. However, only 
 string, integer, and floating-point values can be compared using ordering operators, as is 
 summarized in the following table:
  
 Operator Operation 
  
 Supported type
  
 == 
  
 Equal 
  
 String, numeric, Boolean, interface, pointer, and struct types
  
 != 
  
 Not Equal 
  
 String, numeric, Boolean, interface, pointer, and struct types
  
 [ 51 ]",NA
Operator precedence,"Since Go has fewer operators than are found in its counterparts such as C or Java, its 
 operator precedence rules are far simpler. The following table lists Go's operator precedence 
 echelon, starting with the highest:
  
 Operation 
  
 Precedence
  
 Multiplicative
  *
 ,
  /
 ,
  %
 ,
  <<
 ,
  >>
 ,
  &
 ,
  &^
  
 Additive 
  
 +
 ,
  -
 ,
  |
 ,
  ^
  
 Comparative 
  
 ==
 ,
  !=
 ,
  <
 ,
  <=
 ,
  >
 ,
  >=
  
 Logical AND 
  
 &&
  
 Logical OR 
  
 ||",NA
Summary,"This chapter covered a lot of ground around the basic constructs of the Go language. It 
 started with the structure of Go's source code text file and progressed to cover variable 
 identifiers, declarations, and initializations. The chapter also provided extensive coverage of 
 Go constants, constant declaration, and operators.
  
 At this point, you may feel a bit overwhelmed by so much pedestrian information about the 
 language and its syntax. The good news is that you don't have to know all of these details to 
 be productive with the language. In the following chapters, we will continue to explore 
 some of the more interesting bits about Go, including data types, functions, and packages.",NA
Go Control Flow ,NA,NA
,"Go borrows several of its control flow syntax from the C-family of languages. It supports all 
 of the expected control structures, including 
 if...else
 , 
 switch
 , 
 for
  loop, and even 
 goto
 . 
 Conspicuously absent, though, are 
 while
  or 
 do...while
  statements. The following topics in this 
 chapter examine Go's control flow elements, some of which you may already be familiar 
 with, and others that bring a new set of functionalities not found in other 
  
 languages:
  
 The 
 if
  statement
  
 The 
 switch
  statement
  
 The type 
 Switch
  
 The 
 for
  statement",NA
The if statement,"The 
 if
  statement, in Go, borrows its basic structural form from other C-like languages. The 
 statement conditionally executes a code block when the Boolean expression that follows the 
 if
  keyword evaluates to 
 true
 , as illustrated in the following abbreviated program, which 
 displays information about world currencies:
  
 import ""fmt""
  
 type Currency struct {
  
  Name    string
  
  Country string
  
  Number  int 
  
 }
  
 var CAD = Currency{",NA
The if statement initialization,"The 
 if
  statement supports a composite syntax where the tested expression is preceded by an 
 initialization statement. At runtime, the initialization is executed before the test expression 
 is evaluated, as illustrated in this code snippet (from the program listed earlier):
  
 if num1 := 388; num1 > 100 || num1 < 900 { 
 fmt.Println(""Currency:"", num1)
  
  printCurr(num1) 
  
 }
  
 The initialization statement follows normal variable declaration and initialization rules. The 
 scope of the initialized variables is bound to the 
 if
  statement block, beyond which they 
 become unreachable. This is a commonly used idiom in Go and is supported in other flow 
 control constructs covered in this chapter.",NA
Switch statements,"Go also supports a 
 switch
  statement similar to that found in other languages such as, C or 
 Java. The 
 switch
  statement in Go achieves multi-way branching by evaluating values or 
 expressions from 
 case
  clauses, as shown in the following, abbreviated, source code:
  
 import ""fmt""
  
 type Curr struct {
  
  Currency string
  
  Name     string
  
  Country  string
  
  Number   int 
  
 }
  
 var currencies = []Curr{
  
  Curr{""DZD"", ""Algerian Dinar"", ""Algeria"", 12}, Curr{""AUD"", ""Australian 
 Dollar"", ""Australia"", 36}, Curr{""EUR"", ""Euro"", ""Belgium"", 978},
  
  Curr{""CLP"", ""Chilean Peso"", ""Chile"", 152},
  
  Curr{""EUR"", ""Euro"", ""Greece"", 978},
  
  Curr{""HTG"", ""Gourde"", ""Haiti"", 332},
  
  ...
  
 }
  
 func isDollar(curr Curr) bool {
  
  var bool result
  
  switch curr {",NA
Using expression switches,"Expression switches are flexible and can be used in many contexts where control flow of a 
 program needs to follow multiple path. An expression switch supports many attributes, as 
 outlined in the following bullets:
  
 Expression switches can test values of any types. For instance, the following code 
 snippet (from the previous program listing) tests variable 
 Curr
  of type 
 struct
 :
  
  func isDollar(curr Curr) bool {
  
  var bool result
  
  switch curr {
  
  
  default:
  
  
  result = false
  
  
  case Curr{""AUD"", ""Australian Dollar"", ""Australia"", 36}:
  
  result = true
  
  
  case Curr{""HKD"", ""Hong Kong Dollar"", ""Hong Koong"", 344}:
  
  result = true
  
  
  case Curr{""USD"", ""US Dollar"", ""United States"", 840}:
  
  result = true
  
  }
  
  return result
  
  }
  
 [ 59 ]",NA
The fallthrough cases,"There is no automatic 
 fall through
  in Go's 
 case
  clause as there is in the C or Java 
 switch 
 statements. Recall that a 
 switch
  block will exit after executing its first matching case. The 
 code must explicitly place the 
 fallthrough
  keyword, as the last statement in a 
 case
  block, to 
 force the execution flow to fall through the successive 
 case
  block. The following code 
 snippet shows a 
 switch
  statement with a 
 fallthrough
  in each case block:
  
 func isDollar2(curr Curr) bool {
  
  switch curr {
  
  case Curr{""AUD"", ""Australian Dollar"", ""Australia"", 36}:
  
  
  
 fallthrough
  
  case Curr{""HKD"", ""Hong Kong Dollar"", ""Hong Kong"", 344}:
   
  
 fallthrough
  
  case Curr{""USD"", ""US Dollar"", ""United States"", 840}:
  
  
  return 
 true
  
  default:
  
   
  return false
  
  } 
  
 }
  
 golang.fyi/ch03/switchstmt.go
  
 When a case is matched, the 
 fallthrough
  statements cascade down to the first statement of 
 the successive 
 case
  block. So, if 
 curr = Curr{""AUD"", ""Australian Dollar"", ""Australia"", 36}
 , the first 
 case will be matched. Then the flow cascades down to the first statement of the second 
 case block, which is also a 
 fallthrough
  statement. This causes the first statement, to return 
 true
 , of the third case block to execute. This is functionally equivalent to the following 
 snippet:
  
 switch curr { 
  
 case Curr{""AUD"", ""Australian Dollar"", ""Australia"", 36},
  
  
  
 Curr{""HKD"", ""Hong Kong Dollar"", ""Hong Kong"", 344},
  
  
  
 Curr{""USD"", ""US Dollar"", ""United States"", 840}: return true 
  
 default:
  
  
  return false 
  
 }
  
 [ 61 ]",NA
Expressionless switches,"Go supports a form of the 
 switch
  statement that does not specify an expression. In this 
 format, each 
 case
  expression must evaluate to a Boolean value 
 true
 . The following 
 abbreviated source code illustrates the uses of an expressionless 
 switch
  statement, as listed 
 in function 
 find()
 . The function loops through the slice of 
 Curr
  values to search for a match 
 based on field values in the 
 struct
  function that's passed in:
  
 import (
  
  ""fmt""
  
  ""strings"" 
  
 ) 
  
 type Curr struct {
  
  Currency string
  
  Name     string
  
  Country  string
  
  Number   int 
  
 }
  
 var currencies = []Curr{
  
  Curr{""DZD"", ""Algerian Dinar"", ""Algeria"", 12}, Curr{""AUD"", ""Australian 
 Dollar"", ""Australia"", 36}, Curr{""EUR"", ""Euro"", ""Belgium"", 978},
  
  Curr{""CLP"", ""Chilean Peso"", ""Chile"", 152},
  
  ...
  
 }
  
 func find(name string) {
  
  for i := 0; i < 10; i++ {
  
   
  c := currencies[i]
  
   
  switch {
  
   
  case strings.Contains(c.Currency, name),
  
  
  
  strings.Contains(c.Name, name),
  
    
  strings.Contains(c.Country, name):
  
  
  
  fmt.Println(""Found"", c)
  
   
  }
  
  } 
  
 }
  
 golang.fyi/ch03/switchstmt2.go
  
 [ 62 ]",NA
Switch initializer,"The 
 switch
  keyword may be immediately followed by a simple initialization statement 
 where variables, local to the 
 switch
  code block, may be declared and initialized. This 
 convenient syntax uses a semi-colon between the initializer statement and the 
 switch 
 expression to declare variables, which may appear anywhere in the 
 switch
  code block. The 
 following code sample shows how this is done by initializing two variables, 
 name
  and 
 curr
 , 
 as part of the 
 switch
  declaration:
  
 func assertEuro(c Curr) bool {
  
  switch name, curr := ""Euro"", ""EUR""; {
  
  case c.Name == name:
  
   
  return true
  
  case c.Currency == curr:
  
   
  return true
  
  }
  
  return false 
  
 }
  
 golang.fyi/ch03/switchstmt2.go",NA
Type switches,"Given Go's strong type support, it should be of little surprise that the language supports the 
 ability to query type information. The type 
 switch
  is a statement that uses the Go interface 
 type to compare the underlying type information of values (or expressions). A full 
  
 discussion on interface types and type assertion is beyond the scope of this section. You can 
 find more details on the subject in 
 Chapter 8
 , 
 Methods, Interfaces, and Objects
 .
  
 Nevertheless, for the sake of completeness, a short discussion on type switches is provided 
 here. For now, all you need to know is that Go offers the type 
 interface{}
 , or empty 
 interface, as a super type that is implemented by all other types in the type system. When a 
 value is assigned type 
 interface{}
 , it can be queried using the type 
 switch
 , as shown in 
 function 
 findAny()
  in the following code snippet, to query information about its 
  
 underlying type:
  
 func find(name string) {
  
  for i := 0; i < 10; i++ {
  
   
  c := currencies[i]
  
   
  switch {
  
   
  case strings.Contains(c.Currency, name),
  
  
  
  strings.Contains(c.Name, name),
  
    
  strings.Contains(c.Country, name):
  
  
  
  fmt.Println(""Found"", c)
  
   
  }
  
  } 
  
 }
  
 func findNumber(num int) {
  
  for _, curr := range currencies {
  
   
  if curr.Number == num {
  
    
  fmt.Println(""Found"", curr)
  
   
  }
  
  } 
  
 }
  
 func findAny(val interface{}) {
  
  switch i := val.(type) {
  
  case int:
  
   
  findNumber(i)",NA
The for statements,"As a language related to the C-family, Go also supports 
 for
  loop style control structures. 
 However, as you may have come to expect by now, Go's 
 for
  statements work interestingly 
 differently and simply. The 
 for
  statement in Go supports four distinct idioms, as 
  
 summarized in the following table:
  
 For Statement Usage
  
 For condition 
  
 Used to semantically replace 
 while
  and 
 do...while
  loops: 
  
 for x 
 < 10 { 
  
  
 ...
  
 }
  
 Infinite loop 
  
 The conditional expression may be omitted to create an infinite loop: 
  
 for { 
  
  
 ...
  
 }
  
 Traditional 
  
 This is the traditional form of the C-family 
 for
  loop with the initializer, test, 
  
 and update clauses: 
  
  
 for x:=0; x < 10; x++ { 
  
  
 ...
  
 }
  
 For range 
  
 Used to iterate over an expression representing a collection of items stored in 
  
 an array, string (array of rune), slice, map, and channel: 
  
  
 for i, val := range values { 
  
  
 ...
  
 }
  
 Notice, as with all other control statements in Go, the 
 for
  statements do not use 
 parentheses around their expressions. All statements for the loop code block must be 
 enclosed within curly brackets or the compiler will produce an error.",NA
For condition,"The 
 for
  condition uses a construct that is semantically equivalent to the 
 while
  loop found in 
 other languages. It uses the keyword 
 for
 , followed by a Boolean expression that allows the 
 loop to proceed as long as it is evaluated to true. The following abbreviated source listing 
 shows an example of this form of the 
 for
  loop:
  
 type Curr struct {
  
  Currency string",NA
Infinite loop,"When the Boolean expression is omitted in the 
 for
  statement, the loop runs indefinitely, as 
 shown the following example:
  
 for {
  
  // statements here 
  
 }
  
 This is equivalent to the 
 for(;;)
  or the 
 while (true)
  found in other languages, such as C or 
 Java.
  
 [ 67 ]",NA
The traditional for statement,"Go also supports the traditional form of the 
 for
  statement, which includes an initialization 
 statement, a conditional expression, and an update statement, all separated by a semi-colon.
  
 This is the form of the statement that is traditionally found in other C-like languages. The 
 following source snippet illustrates the use of a traditional for statement in the function 
 sortByNumber
 :
  
 type Curr struct {
  
  Currency string
  
  Name     string
  
  Country  string
  
  Number   int 
  
 }
  
 var currencies = []Curr{
  
  Curr{""KES"", ""Kenyan Shilling"", ""Kenya"", 404}, Curr{""AUD"", ""Australian 
 Dollar"", ""Australia"", 36}, ...
  
 }
  
 func sortByNumber() {
  
  N := len(currencies)
  
  for i := 0; i < N-1; i++ {
  
   
  currMin := i
  
   
  for k := i + 1; k < N; k++ {
  
   
  if currencies[k].Number < currencies[currMin].Number {
  
  
    
  currMin = k
  
   
  }
  
   
  }
  
   
  // swap
  
   
  if currMin != i {
  
     
  temp := currencies[i]
  
   
  currencies[i] = currencies[currMin]
  
   
  currencies[currMin] = temp
  
   
  }
  
  } 
  
 }
  
 golang.fyi/ch03/forstmt.go
  
 The previous example implements a selection sort that sorts the 
 slice
  currencies by 
 comparing the 
 Number
  field of each 
 struct
  value. The different sections of the 
 for 
 statement are highlighted using the following snippet of code (from the preceding 
 function):",NA
The for range,"Lastly, the 
 for
  statement supports one additional form that uses the keyword 
 range
  to 
 iterate over an expression that evaluates to an array, slice, map, string, or channel. The for-
 range loop has this generic form:
  
 for [<identifier-list> :=] range <expression> { 
 …
  }
  
 [ 70 ]",NA
"The break, continue, and goto statements","Go supports a group of statements designed specifically to exit abruptly out of a running 
 code block, such as switch and for statement, and transfer control to a different section of 
 the code. All three statements can accept a label identifier that specifies a targeted location 
 in the code where control is to be transferred.",NA
The label identifier,"Before diving into the core of this section, it is worthwhile to look at the label used by these 
 statements. Declaring a label in Go requires an identifier followed by a colon, as shown in 
 the following snippet:
  
 DoSearch:
  
 Naming your label is a matter of style. However, one should follow the identifier naming 
 guidelines covered in the previous chapter. A label must be enclosed within a function. The 
 Go compiler will not allow unused labels to dangle in the code. Similar to variables, if a 
 label is declared, it must be referenced in the code.",NA
The break statement,"As in other C-like languages, the Go 
 break
  statement terminates and exits the innermost 
 enclosing 
 switch
  or 
 for
  statement code block and transfers control to another part of the 
 running program. The 
 break
  statement can accept an optional label identifier specifying a 
 labeled location, in the enclosing function, where the flow of the program will resume. Here 
 are some attributes of the label for the 
 break
  statement to remember:
  
 The label must be declared within the same running function where the 
 break 
  
 statement is located
  
 A declared label must be followed immediately by the enclosing control 
 statement (a 
 for
  loop or 
 switch
  statement) where the break is nested
  
 If a 
 break
  statement is followed by a label, control is transferred, not to the location where 
 the label is, but rather to the statement immediately following the labeled block. If a label is 
 not provided, the 
 break
  statement abruptly exits and transfers control to the next statement 
 following its enclosing 
 for
  statement (or 
 switch
  statement) block.",NA
The continue statement,"The 
 continue
  statement causes the control flow to immediately terminate the current 
 iteration of the enclosing 
 for
  loop and jump to the next iteration. The 
 continue
  statement 
 can take an optional label as well. The label has similar properties to that of the 
 break 
 statement:
  
 The label must be declared within the same running function where the 
  
 continue
  statement is located
  
 The declared label must be followed immediately by an enclosing 
 for
  loop 
  
 statement where the continue statement is nested
  
 [ 74 ]",NA
The goto statement,"The 
 goto
  statement is more flexible, in that it allows flow control to be transferred to an 
 arbitrary location, inside a function, where a target label is defined. The 
 goto
  statement 
 causes an abrupt transfer of control to the label referenced by the 
 goto
  statement. The 
 following shows Go's 
 goto
  statement in action in a simple, but functional example:
  
 import ""fmt""
  
 func main() {
  
  var a string 
  
 Start:
  
  for {
  
   
  switch {
  
   
  case a < ""aaa"":
  
    
  goto A",NA
Summary,"This chapter provided a walkthrough of the mechanism of control flow in Go, including 
 if
 , 
 switch
 , and 
 for
  statements. While Go's flow control constructs appear simple and easy to use, 
 they are powerful and implement all branching primitives expected of a modern language. 
 Readers are introduced to each concept with ample detail and examples to ensure clarity of 
 the topics. The next chapter continues our look into Go fundamentals by 
  
 introducing the reader to the Go type systems.",NA
Data Types ,NA,NA
,"Go is a strongly-typed language, which means any language element that stores (or 
 expression that produces) a value has a type associated with it. In this chapter, readers will 
 learn about the features of the type system as they explore the common data types 
 supported by the language as outlined in the following:
  
 Go types
  
 Numeric types
  
 Boolean type
  
 Pointers
  
 Type declaration
  
 Type conversion",NA
Go types,"To help launch the conversation about types, let us take a peek at the types available. Go 
 implements a simple type system that provides programmers direct control over how 
 memory is allocated and laid out. When a program declares a variable, two things must 
 take place:
  
 The variable must receive a type
  
 The variable will also be bound to a value (even when none is assigned)
  
 This allows the type system to allocate the number of bytes necessary to store the declared 
 value. The memory layout for declared variables maps directly to their declared types.",NA
Numeric types,"Go's numeric types include support for integral and decimal values with a variety of sizes 
 ranging from 8 to 64 bits. Each numeric type has its own layout in memory and is 
 considered unique by the type system. As a way of enforcing this, and to avoid any sort of 
 confusion when porting Go on different platforms, the name of a numeric type reflects its 
 size requirement. For instance, type 
 int16
  indicates an integer type that uses 16 bits for 
 internal storage
 .
  This means that numberic values must be explicitly be converted when 
 crossing type boundaries in assignments, expressions, and operations.
  
 The following program is not all that functional, since all values are assigned to the blank 
 identifier. However, it illustrates all of the numeric data types supported in Go.
  
 package main 
  
 import (
  
  ""math""
  
  ""unsafe"" 
  
 )
  
 var _ int8 = 12 
  
 var _ int16 = -400 
  
 var _ int32 = 12022 
  
 var _ int64 = 1 << 33 
  
 var _ int = 3 + 1415
  
 var _ uint8 = 18 
  
 var _ uint16 = 44 
  
 var _ uint32 = 133121 
  
 var i uint64 = 23113233 
  
 var _ uint = 7542 
  
 var _ byte = 255 
  
 var _ uintptr = unsafe.Sizeof(i)
  
 var _ float32 = 0.5772156649 
  
 var _ float64 = math.Pi",NA
Unsigned integer types,"The following table lists all available types that can represent unsigned integers and their
  
 storage requirements in Go:
  
 Type 
  
 Size 
  
 Description
  
 uint8 
  
 Unsigned 8-bit 
  
 Range 0 
 –
  255
  
 uint16 
  
 Unsigned 16-bit 
  
 Range 0 
 –
  65535
  
 uint32 
  
 Unsigned 32-bit 
  
 Range 0 
 –
  4294967295
  
 uint64 
  
 Unsigned 64-bit 
  
 Range 0 
 –
  18446744073709551615
  
 uint 
  
 Implementation specific A pre-declared type designed to represent either the 32 or
  
 64-bit integers. As of version 1.x of Go, 
 uint
  represents a
  
 32-bit unsigned integer.
  
 byte 
  
 Unsigned 8-bit 
  
 Alias for the 
 unit8
  type.
  
 uintptr
  Unsigned 
  
 An unsigned integer type designed to store pointers
  
 (memory addresses) for the underlying machine
  
 architecture.",NA
Signed integer types,"The following table lists all available types that can represent signed integers and their
  
 storage requirements in Go:
  
 Type 
  
 Size Description
  
 int8 
  
 Signed 8-bit Range -128 
 –
  127
  
 int16
  Signed 16-bit Range -32768 
 –
  32767
  
 [ 81 ]",NA
Floating point types,"Go supports the following types for representation of decimal values using IEEE standards:
  
 Type
  
 Size
  
 Description
  
 float32
  Signed 32-bit IEEE-754 standard representation of single precision floating point 
  
 values.
  
 float64
  Signed 64-bit IEEE-754 standard representation of double-precision floating point 
  
 values.",NA
Complex number types,"Go also supports representation of complex numbers with both imaginary and real parts as 
 shown by the following table:
  
 Type 
  
 Size 
  
 Description
  
 complex64 
  
 float32 Represents complex numbers with real and imaginary parts stored as 
  
  
 float32
  values.
  
 complex128
  float64 Represents complex numbers with real and imaginary parts stored as 
  
 float64
  values.",NA
Numeric literals,"Go supports the natural representation of integer values using a sequence of digits with a 
 combination of a sign and decimal point (as seen in the previous example). Optionally, Go 
 integer literals can also represent hexadecimal and octal numbers as illustrated in the 
 following program:
  
 package main 
  
 import ""fmt""",NA
Boolean type,"In Go, Boolean binary values are stored using the 
 bool
  type. Although a variable of type 
 bool
  
 is stored as a 1-byte value, it is not, however, an alias for a numeric value. Go provides two 
 pre-declared literals, 
 true
  and 
 false
 , to represent Boolean values as shown in the following 
 example:
  
 package main 
  
 import ""fmt""
  
 func main() {
  
  var readyToGo bool = false
  
  if !readyToGo {
  
  
  fmt.Println(""Come on"")
  
  } else {
  
  
  fmt.Println(""Let's go!"")
  
  } 
  
 }
  
 golang.fyi/ch04/bool.go",NA
Rune and string types,"In order to start our discussion about the 
 rune
  and 
 string
  types, some background context is 
 in order. Go can treat character and string literal constants in its source code as Unicode.
  
 It is a global standard whose goal is to catalog symbols for known writing systems by 
 assigning a numerical value (known as code point) to each character.",NA
The rune,"So, what exactly does the 
 rune
  type have to do with Unicode? The rune is an alias for the 
 int32
  type. It is specifically intended to store Unicode integer values encoded as UTF-8. Let 
 us take a look at some rune literals in the following program:
  
  
 golang.fyi/ch04/rune.go
  
 [ 85 ]",NA
The string,"In Go, a string is implemented as a slice of immutable byte values. Once a string value is 
 assigned to a variable, the value of that string is never changed. Typically, string values are 
 represented as constant literals enclosed within double quotes as shown in the following 
 example:",NA
Interpreted and raw string literals,"The following snippet (from the previous example) includes two string literals assigned to 
 variable 
 txt2
  and 
 txt3
  respectively. As you can see, these two literals have the exact same 
 content, however, the compiler will treat them differently:
  
 var (
  
  txt2 = ""水\x20brings\x20\x6c\x69\x66\x65."" txt3 = `
  
  水\x20
  
  brings\x20
  
 [ 87 ]",NA
Pointers,"In Go, when a piece of data is stored in memory, the value for that data may be accessed 
 directly or a pointer may be used to reference the memory address where the data is 
 located. As with other C-family languages, pointers in Go provide a level of indirection that 
 let programmers process data more efficiently without having to copy the actual data value 
 every time it is needed.",NA
The pointer type,"Similar to C/C++, Go uses the 
 *
  operator to designate a type as a pointer. The following 
 snippet shows several pointers with different underlying types:
  
 package main 
  
 import ""fmt""
  
 var valPtr *float32 
  
 var countPtr *int 
  
 var person *struct {
  
  name string
  
  age  int 
  
 } 
  
 var matrix *[1024]int 
  
 var row []*int64
  
 func main() {
  
  fmt.Println(valPtr, countPtr, person, matrix, row) }
  
 golang.fyi/ch04/pointers.go
  
 Given a variable of type 
 T
 , Go uses expression 
 *T
  as its pointer type. The type system 
 considers 
 T
  and 
 *T
  as distinct and are not fungible. The zero value of a pointer, when it is 
 not pointing to anything, is the address 0, represented by the literal 
 constant 
 nil.",NA
The address operator,"Pointer values can only be assigned addresses of their declared types. One way you can do 
 so in Go is to use the address operator 
 &
 (ampersand) to obtain the address value of a 
 variable as shown in the following example:
  
 package main 
  
 import ""fmt""",NA
The new() function,"The built-in function 
 new(<type>)
  can also be used to initialize a pointer value. It first 
 allocates the appropriate memory for a zero-value of the specified type. The function then 
 returns the address for the newly created value. The following program uses the 
 new() 
 function to initialize variables 
 intptr
  and 
 p
 :
  
 package main 
  
 import ""fmt""
  
 func main() {
  
  intptr := new(int)
  
  *intptr = 44
  
  p := new(struct{ first, last string })
  
  p.first = ""Samuel""
  
  p.last = ""Pierre""
  
  fmt.Printf(""Value %d, type %T\n"", *intptr, intptr) fmt.Printf(""Person 
 %+v\n"", p) 
  
 }
  
 golang.fyi/ch04/newptr.go
  
 Variable 
 intptr
  is initialized as 
 *int
  and 
 p
  as 
 *struct{first, last string}
 . Once initialized, both 
 values are updated accordingly later in the code. You can use the 
 new() 
 function to 
 initialize pointer variables with zero values when the actual values are not available at 
 the time of initialization.
  
 [ 91 ]",NA
Pointer indirection – accessing referenced values,"If all you have is an address, you can access the value to which it points by applying the 
 * 
 operator to the pointer value itself (or dereferencing). The following program illustrates this 
 idea in functions 
 double()
  and 
 cap()
 :
  
 package main 
  
 import (
  
  ""fmt""
  
  ""strings"" 
  
 )
  
 func main() {
  
  a := 3
  
  double(&a)
  
  fmt.Println(a)
  
  p := &struct{ first, last string }{""Max"", ""Planck""} cap(p)
  
  fmt.Println(p) 
  
 }
  
 func double(x *int) {
  
  *x = *x * 2 
  
 }
  
 func cap(p *struct{ first, last string }) { p.first = 
 strings.ToUpper(p.first)
  
  p.last = strings.ToUpper(p.last) 
  
 }
  
 golang.fyi/ch04/derefptr.go
  
 In the preceding code, the expression 
 *x = *x * 2
 , in function 
 double()
 , can be 
 decomposed as follows to understand how it works:
  
 Expression 
  
 Step
  
 *x * 2 
  
 Original expression where
  x
  is of type 
 *int
 .
  
 *(*x) * 2 
  
 Dereferencing pointers by applying 
 * 
 to address values.
  
 3 * 2 = 6 
  
 Dereferenced value of 
 *(*x) = 3
 .
  
 *(*x) = 6 
  
 The right side of this expression dereferences the value of 
 x
 . It is updated with 
  
 the result 6.
  
 [ 92 ]",NA
Type declaration,"In Go, it is possible to bind a type to an identifier to create a new named type that can be 
 referenced and used wherever the type is needed. Declaring a type takes the general format 
 as follows:
  
 type <name identifier> <underlying type name>
  
 The type declaration starts with the keyword 
 type
  followed by a 
 name identifier 
 and the name 
 of an existing 
 underlying type
 . The underlying type can be a built-in named type such as one 
 of the numeric types, a Boolean, or a string type as shown in the following snippet of type 
 declarations:
  
 type truth bool 
  
 type quart float64 
  
 type gallon float64 
  
 type node string
  
 A type declaration can also use a composite 
 type literal
  as its underlying 
 type. Composite types include array, slice, map, and struct. This section 
 focuses on non-composite types. For further details on composite types, 
 refer to 
 Chapter 7
 , 
 Composite Types
 .
  
 The following sample illustrates how named types work in their most basic forms. The code 
 in the example converts temperature values. Each temperature unit is represented by a 
 declared type including 
 fahrenheit
 , 
 celsius
 , and 
 kelvin
 .
  
 package main 
  
 import ""fmt""
  
 type fahrenheit float64 
  
 type celsius float64 
  
 type kelvin float64
  
 func fharToCel(f fahrenheit) celsius {
  
  return celsius((f - 32) * 5 / 9) 
  
 }",NA
Type conversion,"In general, Go considers each type to be different. This means under normal circumstances, 
 values of different types are not fungible in assignment, function parameters, and 
  
 expression contexts. This is true for built-in and declared types. For instance, the following 
 will cause a build error due to type mismatch:
  
 package main 
  
 import ""fmt""
  
 type signal int
  
 func main() {
  
  var count int32
  
  var actual int
  
  var test int64 = actual + count
  
  var sig signal
  
  var event int = sig",NA
Summary,"This chapter presented its readers with an introduction the Go type system. The chapter 
 opened with an overview of types and dove into a comprehensive exploration of the basic 
 built-in types such as numeric, Boolean, string, and pointer types. The discussion continued 
 by exposing the reader to other important topics such as named type definition. The chapter 
 closed with coverage of the mechanics of type conversion. In coming chapters, you will get a 
 chance to learn more about other types such as composite, function, and interface.",NA
Functions in Go ,NA,NA
,"One of Go's syntactical 
 tour de force
  is via its support for higher-order functions as is found 
 in dynamic languages such as Python or Ruby. As we will see in this chapter, a function is 
 also a typed entity with a value that can be assigned to a variable. In this chapter, we are 
 going to explore functions in Go covering the following topics:
  
 Go functions
  
 Passing parameter values
  
 Anonymous functions and closures
  
 Higher-order functions
  
 Error signaling handling
  
 Deferring function calls
  
 Function panic and recovery",NA
Go functions,"In Go, functions are first-class, typed programming elements. A declared function literal 
 always has a type and a value (the defined function itself) and can optionally be bound to a 
 named identifier. Because functions can be used as data, they can be assigned to variables or 
 passed around as parameters of other functions.",NA
Function declaration ,"Declaring a function in Go takes the general form illustrated in the following figure. This
  
 canonical form is used to declare named and anonymous functions.
  
  
 [ 98 ]",NA
The function type,"Normally, the name identifier, declared in a function literal, is used to invoke the function 
 using an invocation expression whereby the function identifier is followed by a parameter 
 list. This is what we have seen throughout the book so far and it is illustrated in the 
 following example calling the 
 fib 
 function:
  
 func main() {
  
  fib(41) 
  
 }
  
 When, however, a function's identifier appears without parentheses, it is treated as a 
 regular variable with a type and a value as shown in the following program:
  
 package main 
  
 import ""fmt""
  
 func add(op0 int, op1 int) int {
  
  return op0 + op1 
  
 }
  
 func sub(op0, op1 int) int {
  
  return op0 - op1 
  
 }
  
 func main() {
  
  var opAdd func(int, int) int = add
  
  opSub := sub
  
  fmt.Printf(""op0(12,44)=%d\n"", opAdd(12, 44)) 
 fmt.Printf(""sub(99,13)=%d\n"", opSub(99, 13)) }
  
 golang.fyi/ch05/functype.go",NA
Variadic parameters,"The last parameter of a function can be declared as 
 variadic
  (
 variable length arguments
 ) by 
 affixing ellipses (
 …
 ) before the parameter's type. This indicates that zero or more values of 
 that type may be passed to the function when it is called.
  
 The following example implements two functions that accept variadic parameters. The first 
 function calculates the average of the passed values and the second function sums up the 
 numbers passed in as arguments:
  
 package main 
  
 import ""fmt""
  
 func avg(nums ...float64) float64 {
  
  n := len(nums)
  
  t := 0.0
  
  for _, v := range nums {
  
   
  t += v
  
  }
  
  return t / float64(n) 
  
 }
  
 func sum(nums ...float64) float64 {
  
  var sum float64
  
  for _, v := range nums {
  
   
  sum += v
  
  }
  
  return sum 
  
 }
  
 func main() {
  
  fmt.Printf(""avg([1, 2.5, 3.75]) =%.2f\n"", avg(1, 2.5, 3.75)) points := []float64{9, 4, 3.7, 
 7.1, 7.9, 9.2, 10}",NA
Function result parameters,"Go functions can be defined to return one or more result values. So far in the book, most of 
 the functions we have encountered have been defined to return a single result value. In 
 general, a function is able to return a list of result values, with diverse types, separated by a 
 comma (see the previous section, 
 Function declaration
 ).
  
 To illustrate this concept, let us examine the following simple program which defines a 
 function that implements an Euclidian division algorithm (see 
 http://en.wikipedia.org/ 
 wiki/Division_algorithm)
 . The 
 div 
 function returns both the quotient and the 
  
 remainder values as its result:
  
 package main 
  
 import ""fmt""
  
 func div(op0, op1 int) (int, int) {
  
  r := op0
  
  q := 0
  
  for r >= op1 {",NA
Named result parameters,"In general, the result list of a function's signature can be specified using variable identifiers 
 along with their types. When using named identifiers, they are passed to the function as 
 regular declared variables and can be accessed and modified as needed. Upon encountering 
 a 
 return
  statement, the last assigned result values are returned. This is illustrated in the 
 following source snippet, which is a rewrite of the previous program:
  
 func div(dvdn, dvsr int) (q, r int) {
  
  r = dvdn
  
  for r >= dvsr {
  
   
  q++
  
   
  r = r - dvsr
  
  }",NA
Passing parameter values,"In Go, all parameters passed to a function are done so by value. This means a local copy of 
 the passed values is created inside the called function. There is no inherent concept of 
 passing parameter values by reference. The following code illustrates this mechanism by 
 modifying the value of the passed parameter, 
 val
 , inside the 
 dbl 
 function:
  
 package main 
  
 import (
  
  ""fmt""
  
  ""math"" 
  
 )
  
 func dbl(val float64) {
  
  val = 2 * val // update param
  
  fmt.Printf(""dbl()=%.5f\n"", val) 
  
 }
  
 func main() {
  
  p := math.Pi
  
  fmt.Printf(""before dbl() p = %.5f\n"", p) dbl(p)
  
  fmt.Printf(""after dbl() p = %.5f\n"", p) }
  
 golang.fyi/ch05/funcpassbyval.go
  
 When the program runs, it produces the following output that chronicles the state of the 
 p 
 variable before it is passed to the 
 dbl
  function. The update is made locally to the passed 
 parameter variable inside the 
 dbl
  function, and lastly the value of the 
 p
  variable after the 
 dbl
  function is called:
  
 $> go run funcpassbyval.go 
  
 before dbl() p = 3.14159
  
 [ 105 ]",NA
Achieving pass-by-reference,"While the pass-by-value is appropriate in many cases, it is important to note that Go can 
 achieve pass-by-reference semantics using pointer parameter values. This allows a called 
 function to reach outside of its lexical scope and change the value stored at the location 
 referenced by the pointer parameter as is done in the 
 half
  function in the following 
 example:
  
 package main 
  
 import ""fmt""
  
 func half(val *float64) {
  
  fmt.Printf(""call half(%f)\n"", *val)
  
  *val = *val / 2 
  
 }
  
 func main() {
  
  num := 2.807770
  
  fmt.Printf(""num=%f\n"", num)
  
  half(&num)
  
  fmt.Printf(""half(num)=%f\n"", num) 
  
 }
  
 golang.fyi/ch05/funcpassbyref.go
  
 In the previous example, the call to the 
 half(&num)
  function in 
 main()
  updates, in place, the 
 original value referenced by its 
 num
  parameter. So, when the code is executed, it shows the 
 original value of 
 num
  and its value after the call to the 
 half
  function:
  
 $> go run funcpassbyref.go 
  
 num=2.807770 
  
 call half(2.807770) 
  
 half(num)=1.403885",NA
Anonymous Functions and Closures,"Functions can be written as literals without a named identifier. These are known as 
 anonymous functions and can be assigned to a variable to be invoked later as shown in the 
 following example:
  
 package main 
  
 import ""fmt""
  
 var (
  
  mul = func(op0, op1 int) int {
  
   
  return op0 * op1
  
  }
  
  sqr = func(val int) int {
  
   
  return mul(val, val)
  
  } 
  
 )
  
 func main() {
  
  fmt.Printf(""mul(25,7) = %d\n"", mul(25, 7)) fmt.Printf(""sqr(13) 
 = %d\n"", sqr(13)) 
  
 }
  
 golang.fyi/ch05/funcs.go
  
 The previous program shows two anonymous functions declared and bound to the 
 mul
  and 
 sqr 
 variables. In both cases, the functions take in parameters and return a value. Later in 
 main()
 , the variables are used to invoke the function code bound to them.",NA
Invoking anonymous function literals,"It is worth noting that an anonymous function does not have to be bound to an identifier.
  
 The function literal can be evaluated, in place, as an expression that returns the function's 
 result. This is done by ending the function literal with a list of argument values, enclosed in 
 parentheses, as shown in the following program:
  
 package main 
  
 import ""fmt""
  
 func main() {
  
  fmt.Printf(
  
   
  ""94 (°F) = %.2f (°C)\n"",
  
   
  func(f float64) float64 {
  
   
  
  return (f - 32.0) * (5.0 / 9.0)
  
  
  
 }(94),
  
  ) 
  
 }
  
 golang.fyi/ch05/funcs.go
  
 The literal format not only defines the anonymous function, but also invokes it. For 
 instance, in the following snippet (from the previous program), the anonymous function 
 literal is nested as a parameter to 
 fmt.Printf()
 . The function itself is defined to accept a 
 parameter and returns a value of type 
 float64
 .
  
 fmt.Printf(
  
  ""94 (°F) = %.2f (°C)\n"",
  
  func(f float64) float64 {
  
   
  return (f - 32.0) * (5.0 / 9.0) }(94), 
  
 )
  
 Since the function literal ends with a parameter list enclosed within parentheses, the 
 function is invoked as an expression.",NA
Closures,"Go function literals are closures. This means they have lexical visibility to non-local 
 variables declared outside of their enclosing code block. The following example illustrates 
 this fact:
  
 package main 
  
 import (
  
  ""fmt""",NA
Higher-order functions,"We have already established that Go functions are values bound to a type. So, it should not 
 be a surprise that a Go function can take another function as a parameter and also return a 
 function as a result value. This describes the notion known as a higher-order function, 
 which is a concept adopted from mathematics. While types such as 
 struct
  let 
  
 programmers abstract data, higher-order functions provide a mechanism to encapsulate and 
 abstract behaviors that can be composed together to form more complex behaviors.
  
 To make this concept clearer, let us examine the following program, which uses a higher-
 order function, 
 apply
 , to do three things. It accepts a slice of integers and a function as 
 parameters. It applies the specified function to each element in the slice. Lastly, the 
 apply 
 function also returns a function as its result:
  
 package main 
  
 import ""fmt""
  
 func apply(nums []int, f func(int) int) func() {",NA
Error signaling and handling,"At this point, let us address how to idiomatically signal and handle errors when you make a 
 function call. If you have worked with languages such as Python, Java, or C#, you may be 
 familiar with interrupting the flow of your executing code by throwing an exception when 
 an undesirable state arises.",NA
Signaling errors,"To better understand what has been described in the previous paragraph, let us start with 
 an example. The following source code implements an anagram program, as described in 
 Column 2 from Jon Bentley's popular 
 Programming Pearls
  book (second edition). The code 
 reads a dictionary file (
 dict.txt
 ) and groups all words with the same anagram. If the code 
 does not quite make sense, please see 
 golang.fyi/ch05/anagram1.go
  for an annotated explanation 
 of how each part of the program works.
  
 package main
  
 import (
  
  ""bufio""
  
  ""bytes""
  
  ""fmt""
  
  ""os""
  
  ""errors"" 
  
 )
  
 // sorts letters in a word (i.e. ""morning"" -> ""gimnnor"") func sortRunes(str 
 string) string {
  
  runes := bytes.Runes([]byte(str))
  
  var temp rune
  
  for i := 0; i < len(runes); i++ {
  
   
  for j := i + 1; j < len(runes); j++ {
  
   
  
  if runes[j] < runes[i] {
  
   
  
  temp = runes[i]
  
   
  
  runes[i], runes[j] = runes[j], temp
  
  
  
  }
  
   
  }
  
  }
  
  return string(runes) 
  
 }
  
 // load loads content of file fname into memory as []string",NA
Error handling,"As described previously, signaling of an erroneous state is as simple as returning a non-nil 
 value, of type 
 error
 , during execution of a function. The caller may choose to handle the 
 error
  or 
 return
  it for further evaluation up the call stack as was done in the 
  
 load
  function. This idiom forces errors to propagate upwards until they are handled at 
 some point. The next snippet shows how the error generated by the 
 load
  function is 
 handled in the 
 main
  function:
  
 func main() {
  
  words, err := load(""dict.txt"")
  
  if err != nil {
  
   
  fmt.Println(""Unable to load file:"", err)
   
  
 os.Exit(1)
  
  }
  
  ...
  
 }
  
 Since the 
 main
  function is the topmost caller in the call stack, it handles the error by 
 terminating the entire program.
  
 This is all there is to the mechanics of error handling in Go. The language forces the 
 programmer to always test for an erroneous state on every function call that returns a value 
 of the type 
 error
 . The 
 if…not…nil error
  handling idiom may seem excessive and verbose to 
 some, especially if you are coming from a language with formal exception mechanisms. 
 However, the gain here is that the program can construct a robust execution flow where 
 programmers always know where errors may come from and handle them appropriately.",NA
The error type,"The 
 error
  type is a built-in interface and, therefore must be implemented before it can be 
 used. Fortunately, the Go standard library comes with implementations ready to be used.
  
 We have already used one of the implementation from the package, 
 errors
 :
  
 errors.New(""Dictionary file name cannot be empty."")
  
 You can also create parameterized error values using the 
 fmt.Errorf
  function as shown in the 
 following snippet:
  
 func load(fname string) ([]string, error) { if fname == """" {
  
   
  return nil, errors.New(
  
 [ 114 ]",NA
Deferring function calls,"Go supports the notion of deferring a function call. Placing the keyword 
 defer
  before a 
 function call has the interesting effect of pushing the function unto an internal stack, 
 delaying its execution right before the enclosing function returns. To better explain this, let 
 us start with the following simple program that illustrates the use of 
 defer
 :
  
 package main 
  
 import ""fmt""
  
 func do(steps ...string) {
  
  defer fmt.Println(""All done!"")
  
  for _, s := range steps {
  
 [ 115 ]",NA
Using defer,"The 
 defer
  keyword modifies the execution flow of a program by delaying function calls. 
 One idiomatic usage for this feature is to do a resource cleanup. Since defer will always get 
 executed when the surrounding function returns, it is a good place to attach cleanup code 
 such as:
  
 Closing open files
  
 Releasing network resources
  
 Closing the Go channel
  
 Committing database transactions
  
 And do on
  
 To illustrate, let us return to our anagram example from earlier. The following code snippet 
 shows a version of the code where defer is used to close the file after it has been loaded. The 
 load
  function calls 
 file.Close()
  right before it returns:
  
 func load(fname string) ([]string, error) { ...
  
  file, err := os.Open(fname)
  
  if err != nil {
  
   
  return nil, err
  
  }
  
  defer file.Close() 
  
 ...
  
 }
  
 golang.fyi/ch05/anagram2.go
  
 The pattern of opening-defer-closing resources is widely used in Go. By placing the 
 deferred intent immediately after opening or creating a resource allows the code to read 
 naturally and reduces the likeliness of creating a resource leakage.",NA
Function panic and recovery,"Earlier in the chapter, it was stated that Go does not have the traditional exception 
 mechanism offered by other languages. Nevertheless, in Go, there is a way to abruptly exit 
 an executing function known as function panic. Conversely, when a program is panicking, 
 Go provides a way of recovering and regaining control of the execution flow.",NA
Function panic,"During execution, a function may panic because of any one of following:
  
 Explicitly calling the 
 panic
  built-in function
  
 Using a source code package that panics due to an abnormal state
  
 Accessing a nil value or an out-of-bound array element
  
 Concurrency deadlock
  
 When a function panics, it aborts and executes its deferred calls. Then its caller panics, 
 causing a chain reaction as illustrated in the following figure:
  
  
 The panic sequence continues all the way up the call stack until the 
 main
  function is reached 
 and the program exits (crashes). The following source code snippet shows a version of the 
 anagram program that will cause an explicit panic if an output anagram file already exists 
 when it tries to create one. This is done illustratively to cause the 
 write
  function to panic 
 when there is a file error:
  
 package main 
  
 ...
  
 func write(fname string, anagrams map[string][]string) { file, err := 
 os.OpenFile(
  
   
  fname,
  
   
  os.O_WRONLY+os.O_CREATE+os.O_EXCL,
  
   
  0644,
  
  )
  
  if err != nil {
  
   
  msg := fmt.Sprintf(
  
   
  
  ""Unable to create output file: %v"", err,",NA
Function panic recovery,"When a function panics, as explained earlier, it can crash an entire program. That may be 
 the desired outcome depending on your requirements. It is possible, however, to regain 
 control after a panic sequence has started. To do this, Go offers the built-in function called 
 recover
 .
  
 [ 119 ]",NA
Summary,"This chapter presented its reader with an exploration of Go functions. It started with an 
 overview of named function declarations, followed by a discussion on function parameters. 
 The chapter delved into a discussion of function types and function values. The last portion 
 of the chapter discussed the semantics of error handling, panic, and recovery. The next 
 chapter continues the discussion of functions; however, it does so within the context of Go 
 packages. It explains the role of a package as a logical grouping of Go functions (and other 
 code elements) to form sharable and callable code modules.",NA
Go Packages and Programs ,NA,NA
,"Chapter 5
 , 
 Functions in Go
  covered functions, the elementary level of abstraction for code 
 organization that makes code addressable and reusable. This chapter continues up the 
 ladder of abstraction with a discussion centered around Go packages. As will be covered in 
 detail here, a package is a logical grouping of language elements stored in source code files 
 that can be shared and reused, as covered in the following topics:
  
 The Go package
  
 Creating packages
  
 Building packages
  
 Package visibility
  
 Importing packages
  
 Package initialization
  
 Creating programs
  
 Remote packages",NA
The Go package,"Similar to other languages, Go source code files are grouped into compilable and sharable 
 units known as packages. However, all Go source files must belong to a package (there is no 
 such notion as a default package). This strict approach allows Go to keep its compilation 
 rules and package resolution rules simple by favoring convention over configuration. Let us",NA
Understanding the Go package,"Before we dive into package creation and use, it is crucial to take a high-level view of the 
 concept of packages to help steer the discussion later. A Go package is both a physical and a 
 logical unit of code organization used to encapsulate related concepts that can be reused. By 
 convention, a group of source files stored in the same directory are considered to be part of 
 the same package. The following illustrates a simple directory tree, where each directory 
 represents a package containing some source code:
  
  foo
  
 ├── blat.go
  
 └── bazz
  
   
 ├── quux.go
  
   
 └── qux.go
  
 golang.fyi/ch06-foo
  
 While not a requirement, it is a recommended convention to set a package's name, in each 
 source file, to match the name of the directory where the file is located. For instance, source 
 file 
 blat.go
  is declared to be part of package 
 foo
 , as shown in the following code, because it is 
 stored in directory named 
 foo
 :
  
 package foo
  
 import (
  
  ""fmt""
  
  ""foo/bar/bazz"" 
  
 )
  
 func fooIt() {
  
  fmt.Println(""Foo!"")
  
  bazz.Qux() 
  
 }
  
 golang.fyi/ch06-foo/foo/blat.go",NA
The workspace,"Another important concept to understand when discussing packages is that of the
  
 Go workspace
 . The workspace is simply an arbitrary directory that serves as a namespace
  
 used to resolved packages during certain tasks such as compilation. By convention, Go tools
  
 expect three specifically named subdirectories in a workspace directory: 
 src
 , 
 pkg
 , and 
 bin
 .
  
 These subdirectories store Go source files along with all built package artifacts respectively.
  
 Establishing a static directory location where Go packages are kept together has the
  
 following advantages:
  
 Simple setup with near-zero configuration
  
 Fast compilation by reducing code search to a known location
  
 Tools can easily create source graph of code and package artifacts
  
 Automatic inference and resolution of transitive dependencies from source
  
 Project setup can be made portable and easily distributable
  
 [ 124 ]",NA
Creating a workspace,"Creating a workspace is as simple as setting an operating system environment named 
 GOPATH
  and assigning to it the root path of the location of the workspace directory. On a 
 Linux machine, for instance, where the root directory for the workspace is 
  
 /home/username/Go
 , the workspace would be set as:
  
 $> export GOPATH=/home/username/Go
  
 When setting up the 
 GOPATH
  environment variable, it is possible to specify multiple 
 locations where packages are stored. Each directory is separated by an OS-dependent path 
 delimiter character (in other words, colon for Linux/Unix, semi-colon for Windows) as 
 shown below:
  
 $> export GOPATH=/home/myaccount/Go;/home/myaccount/poc/Go",NA
The import path,"Before moving on to the detail of setting up and using packages, one last important concept 
 to cover is the notion of an 
 import path
 . The relative path of each package, under workspace 
 path 
 $GOPATH/src
 , constitutes a global identifier known as the package's 
 import path
 .
  
 This implies that no two packages can have the same import path values in a given 
 workspace.
  
 Let us go back to our simplified directory tree from earlier. For instance, if we set the 
 workspace to some arbitrary path value such as 
 GOPATH=/home/username/Go
 :
  
 /home/username/Go
  
 └── foo
  
 ├── ablt.go
  
 └── bazz
  
   
 ├── quux.go
  
   
 └── qux.go
  
 From the sample workspace illustrated above, the directory path of the packages is mapped 
 to their respective import paths as shown in the following table:
  
 Directory Path 
  
 Import Path
  
 /home/username/Go/foo 
  
 ""foo""
  
 /home/username/Go/foo/bar 
  
 ""foo/bar""
  
 /home/username/Go/foo/bar/bazz
  ""foo/bar/bazz""",NA
Creating packages,"Until now, the chapter has covered the rudimentary concepts of the Go package; now it is 
 time to dive deeper and look at the creation of Go code contained in packages. One of the 
 main purposes of a Go package is to abstract out and aggregate common logic into sharable 
 code units. Earlier in the chapter, it was mentioned that a group of Go source files in a 
 directory is considered to be a package. While this is technically true, there is more to the 
 concept of a Go package than just shoving a bunch of files in a directory.
  
 To help illustrate the creation of our first packages, we will enlist the use of example source 
 code found in 
 github.com/vladimirvivien/learning-go/ch06
 . The code in that directory
  
 defines a set of functions to help calculate electrical values using 
 Ohm's Law
 . The following 
 shows the layout of the directories that make up the packages for the example (assuming 
 they are saved in some workspace directory 
 $GOPATH/src
 ):
  
 github.com/vladimirvivien/learning-go/ch06├── current
  
 │├── curr.go
  
 │└── doc.go
  
 ├── power
  
 │├── doc.go
  
 │├── ir
  
 ││└── power.go
  
 │├── powlib.go
  
 │└── vr
  
 │└── power.go
  
 ├── resistor
  
 │├── doc.go
  
 │├── lib.go
  
 │├── res_equivalence.go
  
 │├── res.go
  
 │└── res_power.go
  
 └── volt
  
 ├── doc.go
  
 └── volt.go
  
 Package layout for Ohm's Law example
  
 [ 128 ]",NA
Declaring the package,"Go source files must declare themselves to be part of a package. This is done using the 
 package
  clause, as the first legal statement in a Go source file. The declared package 
 consists of the 
 package
  keyword followed by a name identifier. The following shows 
 source file 
 volt.go
  from the 
 volt
  package:
  
 package volt
  
 func V(i, r float64) float64 {
  
  return i * r 
  
 }
  
 func Vser(volts ...float64) (Vtotal float64) { for _, v := range volts {
  
   
  Vtotal = Vtotal + v
  
  }
  
  return 
  
 }
  
 func Vpi(p, i float64) float64 {
  
  return p / i",NA
Multi-File packages,"The logical content of a package (source code elements such as types, functions, variables, 
 and constants) can physically scale across multiple Go source files. A package directory can 
 contain one or more Go source files. For instance, in the following example, package 
 resistor
  
 is unnecessarily split among several Go source files to illustrate this point:
  
 package resistor 
  
 func recip(val float64) float64 {
  
  return 1 / val 
  
 } 
  
 golang.fyi/ch06/resistor/lib.go
  
 package resistor 
  
 func Rser(resists ...float64) (Rtotal float64) { for _, r := range resists {
  
   
  Rtotal = Rtotal + r
  
  }
  
  return 
  
 } 
  
 func Rpara(resists ...float64) (Rtotal float64) { for _, r := range resists 
 {
  
   
  Rtotal = Rtotal + recip(r)
  
  }
  
  return 
  
 } 
  
 golang.fyi/ch06/resistor/res_equivalance.go
  
 package resistor 
  
 func R(v, i float64) float64 {
  
  return v / i 
  
 } 
  
 golang.fyi/ch06/resistor/res.go",NA
Naming packages,"As mentioned earlier, Go expects each package in a workspace to have a unique fully 
 qualified import path. Your program may have as many packages as you want and your 
 package structure can be as deep as you like in the workspace. However, idiomatic Go 
 prescribes some 
 rules 
 for the naming and organization of your packages to make creating 
 and using packages simple.",NA
Use globally unique namespaces,"Firstly, it is a good idea to fully qualify the import path of your packages in a global context, 
 especially if you plan to share your code with others. Consider starting the name of your 
 import path with a namespace scheme that uniquely identifies you or your organization. 
 For instance, company 
 Acme, Inc.
  may choose to start all of their Go package names with 
 acme.com/apps
 . So a fully qualified import path for a package would be 
  
 ""acme.com/apps/foo/bar""
 .
  
 Later in this chapter, we will see how package import paths can be used 
 when integrating Go with source code repository services such as GitHub.",NA
Add context to path,"Next, as you devise a naming scheme for your package, use the package's path to add 
 context to the name of your package name. The context in the name should start generic 
 and get more specific from left to right. As an example, let us refer to the import paths for 
 the power package (from the example earlier). The calculation of power values is split 
 among three sub-packages shown as follows:
  
 github.com/vladimirvivien/learning-go/ch06/
 power
  
 github.com/vladimirvivien/learning-go/ch06/
 power/ir
  
 github.com/vladimirvivien/learning-go/ch06/
 power/vr
  
 The parent path 
 power
  contains package members with broader context. The sub-packages 
 ir
  and 
 vr
  contain members that are more specific with narrower contexts. This naming 
 pattern is used heavily in Go, including the built-in packages such as the following:
  
 crypto/md5
  
 net/http
  
 net/http/httputil
  
 reflect
  
 Note a package depth of one is a perfectly legitimate package name (see 
 reflect
 ) as long as 
 it captures both context and the essence of what it does. Again, keep things simple. Avoid 
 the temptation of nesting your packages beyond a depth of more than three inside your 
 namespace. This temptation will be especially strong if you are a Java developer used to 
 long nested package names.",NA
Use short names,"When reviewing the names of built-in Go packages, one thing you will notice is the brevity 
 of the names compared to other languages. In Go, a package is considered to be a collection 
 of code that implements a specific set of closely related functionalities. As such, the import 
 paths of your packages should be succinct and reflect what they do without being 
  
 excessively long. Our example source code exemplifies this by naming the package 
 directory with short names such as volt, power, resistance, current. In their respective 
 contexts, each directory name states exactly what the package does.",NA
Building packages,"The Go tools reduce the complexity of compiling your code by applying certain conventions 
 and sensible defaults. Although a full discussion of Go's build tool is beyond the scope of 
 this section (or chapter), it is useful to understand the purpose and use of the 
 build
  and 
 install
  tools. In general, the use of the build and install tools is as follows:
  
 $> go build [<package import path>]
  
 The 
 import path
  can be explicitly provided or omitted altogether. The 
 build
  tool accepts the 
 import path
  expressed as either fully qualified or relative paths. Given a properly setup 
 workspace, the following are all equivalent ways to compile package 
 volt
 , from the earlier 
 example:
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go 
  
 $> go build ./ch06/volt 
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go build ./volt 
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06/volt $> go build .
  
 $> cd $GOPATH/src/ 
  
 $> go build github.com/vladimirvivien/learning-go/ch06/current /volt
  
 The 
 go build
  command above will compile all Go source files and their dependencies 
 found in directory 
 volt
 . Furthermore, it is also possible to build all of your packages and 
 sub-packages in a given directory using the wildcard parameter appended to an import 
 path shown as follows:
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go build 
 ./...
  
 The previous will build all packages and sub-packages found in the directory 
 $GOPATH/src/github.com/vladimirvivien/learning-go/ch06
 .",NA
Installing a package,"By default, the build command outputs its results into a tool-generated temporary directory 
 that is lost after the build process completes. To actually generate a usable artifact, you must 
 use the 
 install
  tool to keep a copy of the compiled object files.
  
 The 
 install
  tool has the exact semantics as the build tool:
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go 
 install ./volt
  
 In addition to compiling the code, it also saves and outputs the result to workspace location 
 $GOPATH/pkg
  as shown in the following:
  
 $GOPATH/pkg/linux_amd64/github.com/vladimirvivien/learning-go/└── ch06
  
 └── volt.a
  
 The generated object files (with the 
 .a
  extension) allow the package to be reused and linked 
 against other packages in the workspace. Later in the chapter, we will examine how to 
 compile executable programs.",NA
Package visibility,"Regardless of the number of source files declared to be part of a package, all source code 
 elements (types, variables, constants, and functions), declared at a package level, share a 
 common scope. Therefore, the compiler will not allow an element identifier to be re-
 declared more than once in the entire package. Let us use the following code snippets to 
 illustrate this point, assuming both source files are part of the same package 
  
 $GOPATH/src/foo
 :
  
 package foo 
  
 package foo 
  
 var ( 
  
 var bar struct{
  
  
  bar int = 12
  
  
  x, y int 
  
 ) 
  
 } 
  
 func qux () { 
  
 func quux() {
  
  
  bar += bar
  
  
  bar = bar * bar 
  
 } 
  
 } 
  
 foo/file1.go 
  
 foo/file2.go
  
 Illegal variable identifier re-declaration",NA
Package member visibility,"The usefulness of a package is its ability to expose its source elements to other packages. 
 Controlling the visibility of elements of a package is simple and follows this rule: 
 capitalized 
 identifiers are exported automatically
 . This means any type, variable, constant, or function with 
 capitalized identifiers is automatically visible from outside of the package where it is 
 declared.
  
 Referring to the Ohm's Law example, described earlier, the following illustrates this 
 functionality from the package 
 resistor
  (found in 
  
 github.com/vladimirvivien/learning-go/ch06/resistor
 ):
  
 Code
  
 package resistor 
  
 func R(v, i float64) float64 {
  
 Description 
  
 Function 
 R
  is automatically exported and can be accessed from 
 other packages as: 
 resistor.R()
  
  return v / i 
  
 }",NA
Importing package,"At this point, you should have a good understanding of what a package is, what it does, 
 and how to create one. Now, let us see how to use a package to import and reuse its 
 members. As you will find in several other languages, the keyword 
 import
  is used to 
 import source code elements from an external package. It allows the importing source to 
 access exported elements found in the imported package (see the 
 Package scope and visibility 
 section earlier in the chapter). The general format for the import clause is as follows:
  
 import [package name identifier] 
 “
 <import path>
 ”
  
 Notice that the import path must be enclosed within double quotes. The 
 import
  statement 
 also supports an optional package identifier that can be used to explicitly name the 
 imported package (discussed later). The import statement can also be written as an import 
 block, as shown in the following format. This is useful where there are two or more import 
 packages listed:
  
 import (
  
 [package name identifier] 
 “
 <import path>
 ”
  
 )",NA
Specifying package identifiers,"As was mentioned, an 
 import
  declaration may explicitly declare a name identifier for the 
 import, as shown in the following import snippet:
  
 import res ""github.com/vladimirvivien/learning-go/ch06/resistor""
  
 Following the format described earlier, the name identifier is placed before the import path 
 as shown in the preceding snippet. A named package can be used as a way to shorten or 
 customize the name of a package. For instance, in a large source file with numerous usage of 
 a certain package, this can be a welcome feature to reduce keystrokes.
  
 Assigning a name to a package is also a way to avoid package identifier collisions in a given 
 source file. It is conceivable to import two or more packages, with different import paths, 
 that resolve to the same package names. As an example, you may need to log information 
 with two different logging systems from different libraries, as illustrated in the following 
 code snippet:
  
 package foo 
  
 import (
  
  flog ""github.com/woom/bat/logger""
  
  hlog ""foo/bar/util/logger"" 
  
 )
  
 func main() {
  
  flog.Info(""Programm started"")
  
  err := doSomething()
  
  if err != nil {
  
  
  hlog.SubmitError(""Error - unable to do something"") } 
  
 }
  
 As depicted in the previous snippet, both logging packages will resolve to the same name 
 identifier of 
 ""logger""
  by default. To resolve this, at least one of the imported packages must 
 be assigned a name identifier to resolve the name clash. In the previous example, both 
 import paths were named with a meaningful name to help with code comprehension.",NA
The dot identifier,"A package can optionally be assigned a dot (period) as its identifier. When an 
 import 
 statement uses the dot identifier (
 .
 ) for an import path, it causes members of the imported 
 package to be merged in scope with that of the importing package. Therefore, imported 
 members may be referenced without additional qualifiers. So if package 
 logger
  is imported 
 with the dot identifier in the following source code snippet, when accessing exported 
 member function 
 SubmitError
  from the logger package, the package name is omitted:
  
 package foo
  
 import (
  
  . ""foo/bar/util/logger"" 
  
 )
  
 func main() {
  
  err := doSomething()
  
  if err != nil {
  
  
  SubmitError(""Error - unable to do something"") } 
  
 }
  
 While this feature can help reduce repetitive keystrokes, it not an encouraged practice. By 
 merging the scope of your packages, it becomes more likely to run into identifier collisions.",NA
The blank identifier,"When a package is imported, it is a requirement that one of its members be referenced in the 
 importing code at least once. Failure to do so will result in a compilation error. While this 
 feature helps simplify package dependency resolution, it can be cumbersome, especially in 
 the early phase of a developing code.
  
 Using the blank identifier (similar to variable declarations) causes the compiler to bypass 
 this requirement. For instance, the following snippet imports the built-in package 
 fmt
 ; 
 however, it never uses it in the subsequent source code:
  
 package foo 
  
 import (
  
  _ ""fmt""
  
  ""foo/bar/util/logger"" 
  
 )
  
 func main() {
  
 [ 139 ]",NA
Package initialization,"When a package is imported, it goes through a series of initialization sequences before its 
 members are ready to be used. Package-level variables are initialized using dependency 
 analysis that relies on lexical scope resolution, meaning variables are initialized based on 
 their declaration order and their resolved transitive references to each other. For instance, in 
 the following snippet, the resolved variable declaration order in package 
 foo
  will be 
 a
 , 
 y
 , 
 b
 , 
 and 
 x
 :
  
 package foo 
  
 var x = a + b(a) 
  
 var a = 2 
  
 var b = func(i int) int {return y * i} 
  
 var y = 3
  
 Go also makes use of a special function named 
 init
  that takes no arguments and returns 
 no result values. It is used to encapsulate custom initialization logic that is invoked when 
 the package is imported. For instance, the following source code shows an 
 init
  function 
 used in the 
 resistor
  package to initialize function variable 
 Rpi
 :
  
 package resistor
  
 var Rpi func(float64, float64) float64
  
 func init() {
  
  Rpi = func(p, i float64) float64 {
  
   
  return p / (i * i)
  
  } 
  
 }
  
 func Rvp(v, p float64) float64 {
  
  return (v * v) / p",NA
Creating programs,"So far in the book, you have learned how to create and bundle Go code as reusable 
 packages. A package, however, cannot be executed as a standalone program. To create a 
 program (also known as a command), you take a package and define an entry point of 
 execution as follows:
  
 Declare (at least one) source file to be part of a special package called 
 main
  
 Declare one function name 
 main()
  to be used as the entry point of the program
  
 The function 
 main
  takes no argument nor returns any value. The following shows the 
 abbreviated source code for the 
 main
  package used in the Ohm's Law example (from 
 earlier). It uses the package 
 flag
 , from Go's standard library, to parse program arguments 
 formatted as 
 flag
 :
  
 package main 
  
 import (
  
  ""flag""
  
  ""fmt""
  
  ""os""
  
  ""github.com/vladimirvivien/learning-go/ch06/current"" 
 ""github.com/vladimirvivien/learning-go/ch06/power""
  
  ""github.com/vladimirvivien/learning-go/ch06/power/ir"" 
 ""github.com/vladimirvivien/learning-go/ch06/power/vr"" res 
 ""github.com/vladimirvivien/learning-go/ch06/resistor"" 
 ""github.com/vladimirvivien/learning-go/ch06/volt"" 
  
 )",NA
Accessing program arguments,"When a program is executed, the Go runtime makes all command-line arguments available 
 as a slice via package variable 
 os.Args
 . For instance, when the following program is 
 executed, it prints all command-line arguments passed to the program:
  
 package main 
  
 import (
  
  ""fmt""
  
  ""os"" 
  
 )
  
 func main() {
  
  for _, arg := range os.Args {
  
   
  fmt.Println(arg)
  
  } 
  
 }
  
 golang.fyi/ch06-args/hello.go
  
 The following is the output of the program when it is invoked with the shown arguments:
  
 $> go run hello.go hello world how are you? 
 /var/folders/.../exe/hello 
  
 hello 
  
 world 
  
 how 
  
 are 
  
 you?
  
 Note that the command-line argument 
 ""hello world how are you?""
 , placed after the 
 program's name, is split as a space-delimited string. Position 0 in slice 
 os.Args
  holds the 
 fully qualified name of the program's binary path. The rest of the slice stores each item in 
 the string respectively.",NA
Building and installing programs,"Building and installing Go programs follow the exact same procedures as building a regular 
 package (as was discussed earlier in the 
 Building and installing packages
  section). When you 
 build source files of an executable Go program, the compiler will generate an executable 
 binary file by transitively linking all the decencies declared in the 
 main
  package. The build 
 tool will name the output binary, by default the same name as the directory where the Go 
 program source files are located.
  
 For instance, in the Ohm's Law example, the file 
 main.go
 , which is located in the directory 
 github.com/vladimirvivien/learning-go/ch06
 , is declared to be part of the 
 main 
 package. The 
 program can be built as shown in the following:
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go build 
 .
  
 When the 
 main.go
  source file is built, the build tool will generate a binary named 
 ch06 
 because the source code for the program is located in a directory with that name. You can 
 control the name of the binary using the output flag 
 -o
 . In the following example, the build 
 tool creates a binary file named 
 ohms
 .
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go build 
 -o ohms
  
 Lastly, installing a Go program is done in exactly the same way as installing a regular 
 package using the Go 
 install
  command:
  
 $> cd $GOPATH/src/github.com/vladimirvivien/learning-go/ch06 $> go 
 install .
  
 When a program is installed using the Go install command, it will be built, if necessary, and 
 its generated binary will be saved in the 
 $GOPAHT/bin
  directory. Adding the workspace 
 bin
  
 directory to your OS's 
 $PATH
  environment variable will make your Go program available 
 for execution.
  
 Go-generated programs are statically linked binaries. They require no 
 additional dependencies to be satisfied to run. However, Go-compiled 
 binaries include the Go runtime. This is the set of operations that handle 
 functionalities such as garbage collection, type information, reflection, 
 goroutines scheduling, and panic management. While a comparable C 
 program would be order of magnitudes smaller, Go's runtime comes with 
 the tools that make Go enjoyable.",NA
Remote packages,"One of the tools that is shipped with Go allows programmers to retrieve packages directly 
 from remote source code repositories. Go, by default, readily supports integration with 
 version control systems including the following:
  
 Git (
 git
 , 
 http://git-scm.com/
 )
  
 Mercurial (
 hg
 , 
 https://www.mercurial-scm.org/
 )
  
 Subversion (
 svn
 , 
 http://subversion.apache.org/
 )
  
 Bazaar (
 bzr
 , 
 http://bazaar.canonical.com/
 )
  
 In order for Go to pull package source code from a remote repository, you 
 must have a client for that version control system installed as a command 
 on your operating system's execution path. Under the cover, Go launches 
 the client to interact with the source code repository server.
  
 The 
 get
  command-line tool allows programmers to retrieve remote packages using a fully 
 qualified project path as the import path for the package. Once the package is downloaded, 
 it can be imported for use in local source files. For instance, if you wanted to include one of 
 the packages from the Ohm's Law example from preceding snippet, you would issue the 
 following command from the command-line:
  
 $> go get github.com/vladimirvivien/learning-go/ch06/volt
  
 The 
 go get
  tool will download the specified import path along with all referenced 
 dependencies. The tool will then build and install the package artifacts in 
 $GOPATH/pkg
 . If 
 the 
 import
  path happens to be a program, go get will generate the binary in 
 $GOPATH/bin 
 as 
 well as any referenced packages in 
 $GOPATH/pkg
 .",NA
Summary,"This chapter presented an extensive look into the notion of source code organization and 
 packages. Readers learned about the Go workspace and the import path. Readers were also 
 introduced to the creation of packages and how to import packages to achieve code 
 reusability. The chapter introduced mechanisms such as visibility of imported members and 
 package initialization. The last portion of the chapter discussed the steps that are necessary 
 to create an executable Go program from packaged code.
  
 This was a lengthy chapter, and deservedly so to do justice to such a broad topic as package 
 creation and management in Go. The next chapter returns to the Go types discussion with a 
 detailed treatment of the composite types, such as array, slice, struct, and map.
  
 [ 147 ]",NA
Composite Types ,NA,NA
,"In prior chapters, you may have caught glimpses of the use of composite types such as 
 arrays, slices, maps, and structs in some of the sample code. While early exposure to these 
 types may have left you curious, rest assured in this chapter you will get a chance to learn 
 all about these composite types. This chapter continues what started in 
 Chapter 4
 , 
 Data 
 Types
 , with discussions covering the following topics:
  
 The array type
  
 The slice type
  
 The map type
  
 The struct type",NA
The array type,"As you would find in other languages, Go arrays are containers for storing sequenced 
 values of the same type that are numerically indexed. The following code snippet shows 
 samples of variables that are assigned array types:
  
 var val [100]int 
  
 var days [7]string 
  
 var truth [256]bool 
  
 var histogram [5]map[string]int
  
 golang.fyi/ch07/arrtypes.go",NA
Array initialization,"When an array variable is not explicitly initialized, all of its elements will be assigned the 
 zero-value for the declared type of the elements. An array can be initialized with a 
 composite literal value with the following general format:
  
 <array_type>{<comma-separated list of element values>}",NA
Declaring named array types,"The type of an array can become awkward for reuse. For each declaration, it becomes 
 necessary to repeat the declaration, which can be error prone. The way to handle this 
 idiomatically is to alias array types using type declarations. To illustrate how this works, 
 the following code snippet declares a new named type, 
 matrix
 , using a multi-dimension 
 array as its underlying type:
  
 type matrix [2][2][2][2]byte
  
 func main() {
  
  var mat1 matrix
  
  mat1 = initMat()
  
  fmt.Println(mat1) 
  
 }
  
 func initMat() matrix {
  
  return matrix{
  
   
  {{{4, 4}, {3, 5}}, {{55, 12}, {22, 4}}},
  
  
  {{{2, 2}, 
 {7, 9}}, {{43, 0}, {88, 7}}}, } 
  
 }
  
 golang.fyi/ch07/arrtype_dec.go",NA
Using arrays,"Arrays are static entities that cannot grow or shrink in size once they are declared with a 
 specified length. Arrays are a great option when a program needs to allocate a block of 
 sequential memory of a predefined size. When a variable of an array type is declared, it is 
 ready to be used without any further allocation semantics.
  
 So the following declaration of the 
 image
  variable would allocate a memory block 
 composed of 256 adjacent 
 int
  values initialized with zeroes, as shown in the following 
 figure:
  
 var image [256]byte
  
  
 Similar to C and Java, Go uses the square brackets index expression to access values stored 
 in an array variable. This is done by specifying the variable identifier followed by an index 
 of the element enclosed within the square brackets, as shown in the following code 
 sample:
  
 p := [5]int{122,6,23,44,6} 
  
 p[4] = 82 
  
 fmt.Println(p[0])
  
 The previous code updates the fifth element and prints the first element in the array.",NA
Array length and capacity,"The built-in 
 len
  function returns the declared length of an array type. The built-in 
 cap 
 function can be used on an array to return its capacity. For instance, in the following source 
 snippet, the array 
 seven
  of type 
 [7]string
  will return 
 7
  as its length and capacity:
  
 func main() {
  
  seven := [7]string{""grumpy"", ""sleepy"", ""bashful""} fmt.Println(len(seven), 
 cap(seven)) 
  
 }
  
 For arrays, the 
 cap()
  function always returns the same value as 
 len()
 . This is because the 
 maximum capacity of an array value is its declared length. The capacity function is better 
 suited for use with the slice type (discussed later in the chapter).",NA
Array traversal,"Array traversal can be done using the traditional 
 for
  statement or with the more idiomatic 
 for…range
  statement. The following snippet of code shows array traversal done with both 
 the 
 for
  statement, to initialize an array with random numbers in 
 init()
 , and the 
 for 
 range 
 statement used to realize the 
 max()
  function:
  
 const size = 1000 
  
 var nums [size]int
  
 func init() {
  
  rand.Seed(time.Now().UnixNano())
  
  for i := 0; i < size; i++ {
  
   
  nums[i] = rand.Intn(10000)
  
  } 
  
 }
  
 func max(nums [size]int) int {
  
  temp := nums[0]
  
  for _, val := range nums {
  
   
  if val > temp {
  
   
  
  temp = val
  
   
  }
  
  }
  
  return temp 
  
 }
  
 golang.fyi/ch07/arrmax_iter.go",NA
Array as parameters,"Arrays values are treated as a single unit. An array variable is not a pointer to a location in 
 memory, but rather represents the entire block of memory containing the array elements. 
 This has the implications of creating a new copy of an array value when the array variable is 
 reassigned or passed in as a function parameter.
  
 This could have unwanted side effects on memory consumption for a program. One fix for 
 is to use pointer types to reference array values. In the following example, a named type, 
 numbers
 , is declared to represent array type 
 [1024 * 1024]]int
 . Instead of taking the array 
 value directly as parameters, functions
  initialize()
  and 
 max()
  receive a pointer of type 
 *numbers
 , as shown in the following source snippet:
  
 type numbers [1024 * 1024]int 
  
 func initialize(nums *numbers) {
  
  rand.Seed(time.Now().UnixNano())
  
  for i := 0; i < size; i++ {
  
   
  nums[i] = rand.Intn(10000)
  
  } 
  
 } 
  
 func max(nums *numbers) int {
  
  temp := nums[0]
  
  for _, val := range nums {
  
   
  if val > temp {
  
   
  
  temp = val
  
   
  }
  
  }
  
  return temp 
  
 } 
  
 func main() {
  
  var nums *numbers = new(numbers)
  
  initialize(nums) 
  
 }
  
 golang.fyi/ch07/arrptr.go",NA
The slice type,"The slice type is commonly used as the idiomatic construct for indexed data in Go. The slice 
 is more flexible and has many more interesting characteristics than arrays. The slice itself is 
 a composite type with semantics similar to arrays. In fact, a slice uses an array as its 
 underlying data storage mechanism. The general form of a slice type is given as follows:
  
 [ ]<element_type>
  
 The one obvious difference between a slice and an array type is omission of the size in the 
 type declaration, as shown in the following examples:
  
 var (
  
  
  image []byte",NA
Slice initialization,"A slice is represented by the type system as a value (the next section explores the internal 
 representation of a slice). However, unlike the array type, an uninitialized slice has a zero 
 value of 
 nil
 , which means any attempt to access elements of an uninitialized slice will cause 
 a program to panic.
  
 One of the simplest ways to initialize a slice is with a composite literal value using the 
 following format (similar to an array):
  
 <slice_type>{<comma-separated list of element values>}
  
 The literal value for a slice is composed of the slice type followed by a set of comma-
 separated values, enclosed in curly brackets, that are assigned to the elements of the slice.
  
 The following code snippet illustrates several slice variables initialized with composite 
 literal values:
  
 var (
  
  
  ids []string = []string{""fe225"", ""ac144"", ""3b12c""}
  
  
  vector = []float64{12.4, 44, 126, 2, 11.5}
  
  
  months = []string {
  
  
  
  ""Jan"", ""Feb"", ""Mar"", ""Apr"",
  
  
  
  ""May"", ""Jun"", ""Jul"", ""Aug"",
  
  
  
  ""Sep"", ""Oct"", ""Nov"", ""Dec"",
  
  
  }
  
  
  // slice of map type (maps are covered later)
  
  
  tables = []map[string][]int {
  
  
  
  {
  
  
  
  
  ""age"":{53, 13, 5, 55, 45, 62, 34, 7},
  
  
  
  
  ""pay"":{124, 66, 777, 531, 933, 231},
  
  
  
  },
  
  
  }
  
  
  graph  = [][][][]int{
  
  
  
  {{{44}, {3, 5}}, {{55, 12, 3}, {22, 4}}},
  
  
  
  {{{22, 12, 9, 19}, {7, 9}}, {{43, 0, 44, 12}, {7}}},
  
  } 
  
 )
  
 golang.fyi/ch07/sliceinit.go
  
 As mentioned, the composite literal value of a slice is expressed using a similar form as the 
 array. However, the number of elements provided in the literal is not bounded by a fixed 
 size. This implies that the literal can be as large as needed. Under the cover though, Go 
 creates and manages an array of appropriate size to store the values expressed in the literal.",NA
Slice representation,"Earlier it was mentioned that the slice value uses an underlying array to store data. The 
 name 
 slice
 , in fact, is a reference to a slice of data segment from the array. Internally, a slice 
 is represented by a composite value with the followings three attributes:
  
 Attribute Description
  
 a 
 pointer 
  
 The pointer is the address of the first element of the slice stored in an 
  
  
 underlying array. When the slice value is uninitialized, its pointer value is nil, 
  
 indicating that it is not pointing to an array yet.
  
 Go uses the pointer as the zero value of the slice itself. An uninitialized slice 
 will return nil as its zero value. However, the slice value is not treated as a 
 reference value by the type system. This means certain functions can be applied 
 to a nil slice while others will cause a panic.
  
 Once a slice is created, the pointer does not change. To point to a different 
 starting point, a new slice must be created.
  
 a 
 length 
  
 The length indicates the number of contiguous elements that can be accessed 
  
 starting with the first element. It is a dynamic value that can grow up to the 
  
 capacity of the slice (see capacity next).
  
 The length of a slice is always less than or equal to its capacity. Attempts to 
 access elements beyond the length of a slice, without resizing, will result in a 
 panic. This is true even when the capacity is larger than the length.
  
 a 
 capacity 
  
 The capacity of a slice is the maximum number of elements that may be stored in 
  
 the slice, starting from its first element. The capacity of a slice is bounded by the 
  
 length of the underlying array.
  
 So, when the following variable 
 halfyr
  is initialized as shown:
  
 halfyr := []string{""Jan"",""Feb"",""Mar"",""Apr"",""May"",""Jun""}
  
 It will be stored in an array of type 
 [6]string
  with a pointer to the first element, a length, 
 and a capacity of 
 6
 , as represented graphically in the following figure:",NA
Slicing,"Another way to create a slice value is by slicing an existing array or another slice value (or 
 pointers to these values). Go provides an indexing format that makes it easy to express the 
 slicing operation, as follows:
  
 <slice or array value>[<low_index>:<high_index>]
  
 The slicing expression uses the [
 :
 ] operator to specify the low and high bound indices, 
 separated by a colon, for the slice segment.
  
 The 
 low
  value is the zero-based index where the slice segment starts
  
 The 
 high
  value is the 
 n 
 th
  element offset where the segment stops
  
 The following table shows examples of slice expressions by re-slicing the following value: 
 halfyr := []string{""Jan"",""Feb"",""Mar"",""Apr"",""May"",""Jun""}
 .
  
 Expression 
 all := 
  
 halfyr[:]
  
 Description 
  
 Omitting the low and high indices in the expression is equivalent to 
 the following:
  
 all := halfyr[0 : 6]
  
 This produces a new slice segment equal to the original, which starts 
 at index position 0 and stops at offset position 
 6
 : 
  
 [""Jan"",""Feb"",""Mar"",""Apr"",""May"",""Jun""]
  
 q1 := 
  
 Here the slice expression omits low index value and specifies a slice 
 halfyr[:3] 
  
 segment length of 
 3
 . It returns new slice, 
 [""Jan"",""Feb"",""Mar""]
 .
  
 q2 := 
  
 This creates a new slice segment with the last three elements by specifying 
 halfyr[3:] 
  
 the staring index position of 
 3
  and omitting the high bound index value, 
  
 which defaults to 
 6
 .
  
 mapr := 
  
 To clear any confusion about slicing expressions, this example shows how 
 halfyr[2:4] 
  
 to create a new slice with the months 
 ""Mar""
  and 
 ""Apr""
 . This returns a 
  
 slice with the value
  [""Mar"",""Apr""]
 .",NA
Slicing a slice,"Slicing an existing slice or array value does not create a new underlying array. The new 
 slice creates new pointer location to the underlying array. For instance, the following code 
 shows the slicing of the slice value 
 halfyr
  into two additional slices:
  
 var (
  
  
  halfyr = []string{
  
  
  
  ""Jan"", ""Feb"", ""Mar"",
  
  
  
  ""Apr"", ""May"", ""Jun"",
  
  
  }
  
  q1 = halfyr[:3]
  
  q2 = halfyr[3:] 
  
 )
  
 golang.fyi/ch07/slice_reslice.go
  
 The backing array may have many slices projecting a particular view of its data. The 
 following figure illustrates how slicing in the previous code may be represented visually:
  
  
 Notice that both slices 
 q1
  and 
 q2
  are pointing to different elements in the same underlying 
 array. Slice 
 q1
  has an initial length of 
 3
  with a capacity of 
 6
 . This implies 
 q1
  can be resized 
 up to 
 6
  elements in total. Slice 
 q2
 , however, has a size of 
 3
  and a capacity of 
 3
  and cannot 
 grow beyond its initial size (slice resizing is covered later).",NA
Slicing an array,"As mentioned, an array can also be sliced directly. When that is the case, the provided array 
 value becomes the underlying array. The capacity and the length the slices will be 
  
 calculated using the provided array. The following source snippet shows the slicing of an 
 existing array value called months:
  
 var (
  
  
  months [12]string = [12]string{
  
  
  
  ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
   
  ""Jul"", 
 ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"",
  
  }
  
  
  halfyr = months[:6]
  
  
  q1 = halfyr[:3]
  
  
  q2 = halfyr[3:6]
  
  
  q3 = months[6:9]
  
  
  q4 = months[9:] 
  
 )
  
 golang.fyi/ch07/slice_reslice_arr.go",NA
Slice expressions with capacity,"Lastly, Go's slice expression supports a longer form where the maximum capacity of the 
 slice is included in the expression, as shown here:
  
 <slice_or_array_value>[<low_index>:<high_index>:max]
  
 The 
 max
  attribute specifies the index value to be used as the maximum capacity of the new 
 slice. That value may be less than, or equal to, the actual capacity of the underlying array.
  
 The following example slices an array with the max value included:
  
 var (
  
  
  months [12]string = [12]string{
  
  
  
  ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
   
  ""Jul"", 
 ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"",
  
  }
  
  
  summer1 = months[6:9:9] 
  
 )
  
 golang.fyi/ch07/slice_reslice_arr.go
  
 [ 161 ]",NA
Making a slice,"A slice can be initialized at runtime using the built-in function 
 make
 . This function creates a 
 new slice value and initializes its elements with the zero value of the element type. An 
 uninitialized slice has a nil zero value an indication that it is not pointing an underlying 
 array. Without an explicitly initialization, with a composite literal value or using the 
 make()
  
 function, attempts to access elements of a slice will cause a panic. The following snippet 
 reworks the previous example to use the 
 make()
  function to initialize the slice:
  
 func main() {
  
  months := make([]string, 6)
  
  ...
  
 }
  
 golang.fyi/ch07/slicemake.go
  
 The 
 make()
  function takes as an argument the type of the slice to be initialized and an 
 initial size for the slice. Then it returns a slice value. In the previous snippet, 
 make()
  does 
 the followings:
  
 Creates an underlying array of type 
 [6]string
  
 Creates the slice value with length and capacity of 
 6
  
 Returns a slice value (not a pointer)
  
 After initialization with the 
 make()
  function, access to a legal index position will return the 
 zero value for the slice element instead of causing a program panic. The 
 make()
  function can 
 take an optional third parameter that specifies the maximum capacity of the slice, as shown 
 in the following example:
  
 func main() {
  
  months := make([]string, 6, 12)
  
  ...
  
 }
  
 golang.fyi/ch07/slicemake2.go",NA
Using slices,"The simplest operation to do with a slice value is to access its elements. As was mentioned, 
 slices use index notation to access its elements similar to arrays. The following example 
 accesses element at index position 0 and updates to 
 15
 :
  
 func main () {
  
  h := []float64{12.5, 18.4, 7.0}
  
  h[0] = 15
  
  fmt.Println(h[0])
  
  ...
  
 }
  
 golang.fyi/ch07/slice_use.go
  
 When the program runs, it prints the updated value using index expression 
 h[0]
  to retrieve 
 the value of the item at position 
 0
 . Note that the slice expression with only the index 
 number, 
 h[0]
  for instance, returns the value of the item at that position. When, however, the 
 expression includes a colon, say 
 h[2:]
  or 
 h[:6]
 , that expression returns a new slice.
  
 Slice traversal can be done using the traditional 
 for
 statement or with the, more idiomatic, 
 for…range
  statement as shown in the following code snippets:
  
 func scale(factor float64, vector []float64) []float64 { for i := range vector {
  
   
  vector[i] *= factor
  
  }
  
  return vector 
  
 }
  
 func contains(val float64, numbers []float64) bool { for _, num := range 
 numbers {
  
   
  if num == val {
  
   
  
  return true
  
   
  }
  
  }
  
  return false 
  
 }
  
 golang.fyi/ch07/slice_loop.go",NA
Slices as parameters,"When a function receives a slice as its parameter, the internal pointer of that slice points to 
 the underlying array of the slice. Therefore, all updates to the slice, within the function, will 
 be seen by the function's caller. For instance, in the following code snippet, all changes to 
 the 
 vector
  parameter will be seen by the caller of function 
 scale
 :
  
 func scale(factor float64, vector []float64) { for i := range vector {
  
   
  vector[i] *= factor
  
  } 
  
 }
  
 golang.fyi/ch07/slice_loop.go",NA
Length and capacity,"Go provides two built-in functions to query the length and capacity attributes of a slice. 
 Given a slice, its length and maximum capacity can be queried, using the 
 len
  and 
 cap 
 functions respectively, as shown in the following example:
  
 func main() {
  
  
  var vector []float64
  
  
  fmt.Println(len(vector)) // prints 0, no panic
  
  h := 
 make([]float64, 4, 10)
  
  
  fmt.Println(len(h), "","", cap(h)) 
  
 }
  
 Recall that a slice is a value (not a pointer) that has a nil as its zero-value. Therefore, the 
 code is able to query the length (and capacity) of an uninitialized slice without causing a 
 panic at runtime.",NA
Appending to slices,"The one indispensable feature of slice types is their ability to dynamically grow. By default, 
 a slice has a static length and capacity. Any attempt to access an index beyond that limit will 
 cause a panic. Go makes available the built-in variadic function 
 append
  to dynamically add 
 new values to a specified slice, growing its lengths and capacity, as necessary. The following 
 code snippet shows how that is done:
  
 func main() {
  
  months := make([]string, 3, 3)
  
  months = append(months, ""Jan"", ""Feb"", ""March"",
  
   
  ""Apr"", ""May"", ""June"")
  
  months = append(months, []string{""Jul"", ""Aug"", ""Sep""}...) months = append(months, 
 ""Oct"", ""Nov"", ""Dec"")
  
  fmt.Println(len(months), cap(months), months) 
  
 }
  
 golang.fyi/ch07/slice_append.go
  
 The previous snippet starts with a slice with a size and capacity of 
 3
 . The 
 append
  function is 
 used to dynamically add new values to the slice beyond its initial size and capacity. 
 Internally, 
 append
  will attempt to fit the appended values within the target slice. If the slice 
 has not been initialized or has an inadequate capacity, append will allocate a new 
  
 underlying array, to store the values of the updated slice.",NA
Copying slices,"Recall that assigning or slicing an existing slice value simply creates a new slice value 
 pointing to the same underlying array structure. Go offers the 
 copy
  function, which returns a 
 deep copy of the slice along with a new underlying array. The following snippet shows a 
 clone()
  function, which makes a new copy of a slice of numbers:
  
 func clone(v []float64) (result []float64) { result = 
 make([]float64, len(v), cap(v)) copy(result, v)
  
  return 
  
 }
  
 golang.fyi/ch07/slice_use.go
  
 In the previous snippet, the 
 copy
  function copies the content of 
 v
  slice into 
 result
 . Both 
 source and target slices must be the same size and of the same type or the copy operation 
 will fail.",NA
Strings as slices,"Internally, the string type is implemented as a slice using a composite value that points to an 
 underlying array of rune. This affords the string type the same idiomatic treatment given to 
 slices. For instance, the following code snippet uses index expressions to extract slices of 
 strings from a given string value:
  
 func main() {
  
  msg := ""Bobsayshelloworld!""
  
  fmt.Println(
  
   
  msg[:3], msg[3:7], msg[7:12],
  
   
  msg[12:17], msg[len(msg)-1:],
  
  ) 
  
 }
  
 golang.fyi/ch07/slice_string.go
  
 The slice expression on a string will return a new string value pointing to its underlying 
 array of runes. The string values can be converted to a slice of byte (or slice of rune) as 
 shown in the following function snippet, which sorts the characters of a given string:
  
 func sort(str string) string {
  
  bytes := []byte(str)
  
  var temp byte
  
  for i := range bytes {
  
   
  for j := i + 1; j < len(bytes); j++ {
  
   
  
  if bytes[j] < bytes[i] {
  
   
  
  temp = bytes[i]
  
   
  
  bytes[i], bytes[j] = bytes[j], temp
  
  
  
  }
  
   
  }
  
  }
  
  return string(bytes) 
  
 }
  
 golang.fyi/ch07/slice_string.go
  
 The previous code shows the explicit conversion of a slice of bytes to a string value. Note 
 that each character may be accessed using the index expression.",NA
The map type,"The Go map is a composite type that is used as containers for storing unordered elements of 
 the same type indexed by an arbitrary key value. The following code snippet shows a 
 variety of map variables declarations with a variety of key types:
  
 var (
  
  legends map[int]string
  
  histogram map[string]int
  
  calibration map[float64]bool
  
  matrix map[[2][2]int]bool    // map with array key type table 
 map[string][]string    // map of string slices
  
  // map (with struct key) of map of string log map[struct{name 
 string}]map[string]string )
  
 golang.fyi/ch07/maptypes.go
  
 The previous code snippet shows several variables declared as maps of different types with 
 a variety of key types. In general, map type is specified as follows:
  
 map[<key_type>]<element_type>
  
 The 
 key
  specifies the type of a value that will be used to index the stored elements of the 
 map. Unlike arrays and slices, map keys can be of any type, not just 
 int
 . Map keys, however, 
 must be of types that are comparable including numeric, string, Boolean, pointers, arrays, 
 struct, and interface types (see 
 Chapter 4
 , Data Types
 , for discussion on comparable types).",NA
Map initialization,"Similar to a slice, a map manages an underlying data structure, opaque to its user, to store 
 its values. An uninitialized map has a nil zero-value as well. Attempts to insert into an 
 uninitialized map will result in a program panic. Unlike a slice, however, it is possible to 
 access elements from a nil map, which will return the zero value of the element.
  
 Like other composite types, maps may be initialized using a composite literal value of the 
 following form:
  
 <map_type>{<comma-separated list of key:value pairs>}
  
 [ 167 ]",NA
Making Maps,"Similar to a slice, a map value can also be initialized using the 
 make
  function. Using the 
 make function initializes the underlying storage allowing data to be inserted in the map as 
 shown in the following short snippet:
  
 func main() {
  
  hist := make(map[int]string)
  
  hist[""Jan""] = 100
  
  hist[""Feb""] = 445
  
  hist[""Mar""] = 514 
  
 ...
  
 }
  
 golang.fyi/ch07/maptypes.go
  
 The 
 make
  function takes as argument the type of the map and it returns an initialized map. 
 In the previous example, the 
 make
  function will initialize a map of type 
 map[int]string
 .
  
 The 
 make
  function can optionally take a second parameter to specify the capacity of the 
 map. However, a map will continue to grow as needed ignoring the initial capacity 
 specified.
  
 [ 168 ]",NA
Using maps,"As is done with slice and arrays, index expressions are used to access and update the 
 elements stored in maps. To set or update a 
 map
  element, use the index expression, on the 
 left side of an assignment, to specify the key of the element to update. The following snippet 
 shows an element with the 
 ""Jan""
  key being updated with the value 
 100
 :
  
 hist := make(map[int]string) 
  
 hist[""Jan""] = 100
  
 Accessing an element with a given key is done with an index expression, placed on the right 
 side of an assignment, as shown in the following example, where the value indexed with the 
 ""Mar""
  key is assigned the 
 val
  variable:
  
 val := hist[""Mar""]
  
 Earlier it was mentioned that accessing a non-existent key will return the zero-value for that 
 element. For instance, the previous code would return 0 if the element with the key 
 ""Mar"" 
 does not exist in the map. As you can imagine, this can be a problem. How would you know 
 whether you are getting an actual value or the zero-value? Fortunately, Go provides a way 
 to explicitly test for the absence of an element by returning an optional Boolean value as 
 part of the result of an index expression, as shown in the following snippet:
  
 func save(store map[string]int, key string, value int) { val, ok := store[key]
  
  if !ok {
  
   
  store[key] = value
  
  }else{
  
   
  panic(fmt.Sprintf(""Slot %d taken"", val))
  
  } 
  
 }
  
 golang.fyi/ch07/map_use.go
  
 The function in the preceding snippet tests the existence of a key before updating its value. 
 Called the 
 comma-ok
  idiom, the Boolean value stored in the 
 ok
  variable is set to false when 
 the value is not actually found. This allows the code to distinguish between the absence of a 
 key and the zero value of the element.",NA
Map traversal,"The 
 for…range
  loop statement can be used to walk the content of a map value. The 
 range 
 expression emits values for both key and element values with each iteration. The following 
 code snippet shows the traversal of map 
 hist
 :
  
 for key, val := range hist {
  
  adjVal := int(float64(val) * 0.100)
  
  fmt.Printf(""%s (%d):"", key, val)
  
  for i := 0; i < adjVal; i++ {
  
   
  fmt.Print(""."")
  
  }
  
  fmt.Println() 
  
 }
  
 golang.fyi/ch07/map_use.go
  
 Each iteration returns a key and its associated element value. Iteration order, however, is 
 not guaranteed. The internal map iterator may traverse the map in a different order with 
 each run of the program. In order to maintain a predictable traversal order, keep (or 
 generate) a copy of the keys in a separate structure, such as a slice for instance. During 
 traversal, range over the slice of keys to traverse in a predictable manner.
  
 You should be aware that update done to the emitted value during the 
 iteration will be lost. Instead, use an index expression, such as 
 hist[key] 
 to 
 update an element during iteration. For details on 
 for…range
  loop, refer to 
 Chapter 3
 , 
 Go Control Flow
 , for a thorough explanation of Go 
 for 
 loops.
  
 [ 170 ]",NA
Map functions,"Besides the 
 make
  function, discussed earlier, map types support two additional functions 
 discussed in the following table:
  
 Function 
  
 Description
  
 len(map) 
  
 As with other composite types, the built-in 
 len()
  function returns the 
  
 number of entries in a map. For instance, the following would print 
 3
 : 
  
 h 
 := map[int]bool{3:true, 7:false, 9:false} 
  
  
 fmt.Println(len(h))
  
 The 
 len
  function will return zero for an uninitialized map.
  
 delete(map, key) The built-in 
 delete
  function deletes an element from a given map 
  
 associated with the provided key. The following code snippet would print 
 2
 : 
 h := map[int]bool{3:true, 7:false, 9:false} 
  
 delete(h,7) 
  
 fmt.Println(len(h))",NA
Maps as parameters,"Because a map maintains an internal pointer to its backing storage structure, all updates to 
 map parameter within a called function will be seen by the caller once the function returns. 
 The following sample shows a call to the 
 remove
  function to change the content of a map.
  
 The passed variable, 
 hist
 , will reflect the change once the 
 remove
  function returns:
  
 func main() {
  
  hist := make(map[string]int)
  
  hist[""Jun""] = 644
  
  hist[""Jul""] = 113
  
  remove(hit, ""Jun"")
  
  len(hist) // returns 1 
  
 } 
  
 func remove(store map[string]int, key string) error { _, ok := store[key]
  
  if !ok {
  
   
  return fmt.Errorf(""Key not found"")
  
  }
  
  delete(store, key)
  
  return nil 
  
 }
  
 golang.fyi/ch07/map_use.go",NA
The struct type,"The last type discussed in this chapter is Go's 
 struct
 . It is a composite type that serves as a 
 container for other named types known as fields. The following code snippet shows several 
 variables declared as structs:
  
 var(
  
  empty struct{}
  
  car struct{make, model string}
  
  currency struct{name, country string; code int} node struct{
  
   
  edges []string
  
   
  weight int
  
  }
  
  person struct{
  
   
  name string
  
   
  address struct{
  
   
  
  street string
  
   
  
  city, state string
  
   
  
  postal string
  
   
  }
  
  } 
  
 )
  
 golang.fyi/ch07/structtypes.go
  
 Note that the struct type has the following general format:
  
 struct{<field declaration set>}
  
 The 
 struct
  type is constructed by specifying the keyword 
 struct
  followed by a set of field 
 declarations enclosed within curly brackets. In its most common form, a field is a unique 
 identifier with an assigned type which follows Go's variable declaration conventions as 
 shown in the previous code snippet (
 struct
  also support anonymous fields, covered later).
  
 It is crucial to understand that the type definition for a 
 struct
  includes all of its declared 
 fields. For instance, the type for the person variable (see earlier code snippet) is the entire 
 set of fields in the declaration 
 struct { name string; address struct { street string; city string; 
 state string; postal string }}
 . Therefore, any variable or expression requiring that type must 
 repeat that long declaration. We will see later how that is mitigated by using named types 
 for 
 struct
 .
  
 [ 172 ]",NA
Accessing struct fields,"A struct uses a 
 selector expression
  (or dot notation) to access the values stored in fields. For 
 instance, the following would print the value of the 
 name
  field of the person struct variable 
 from the previous code snippet:
  
 fmt.Pritnln(person.name)
  
 Selectors can be chained to access fields that are nested inside a struct. The following 
 snippet would print the street and city for the nested address value of a 
 person
  variable:
  
 fmt.Pritnln(person.address.street) 
  
 fmt.Pritnln(person.address.city)",NA
Struct initialization,"Similar to arrays, structs are pure values with no additional underlying storage structure. 
 The fields for an uninitialized struct are assigned their respective zero values. This 
 means an uninitialized struct requires no further allocation and is ready to be used.
  
 Nevertheless, a struct variable can be explicitly initialized using a composite literal of the 
 following form:
  
 <struct_type>{<positional or named field values>}
  
 The composite literal value for a struct can be initialized by a set of field values specified by 
 their respective positions. Using this approach, all field values must be provided, to match 
 their respective declared types, as shown in the following snippet:
  
 var(
  
  currency = struct{
  
   
  name, country string
  
   
  code int
  
  }{
  
   
  ""USD"", ""United States"",
  
   
  840,
  
  } 
  
 ...
  
 )
  
 golang.fyi/ch07/structinit.go",NA
Declaring named struct types,"Attempting to reuse struct types can get unwieldy fast. For instance, having to write 
 struct { name string; address struct { street string; city string;
  
 state string; postal string }}
  to express a struct type, every time it is needed, would not 
 scale, would be error prone, and would make for grumpy Go developers. Luckily, the 
 proper idiom to fix this is to use named types, as illustrated in the following source code 
 snippet:
  
 type person struct {
  
  name    string
  
  address address 
  
 }
  
 type address struct {
  
  street      string
  
  city, state string
  
  postal      string 
  
 }
  
 func makePerson() person {
  
  addr := address{",NA
The anonymous field,"Previous definitions of struct types involved the use of named fields. However, it is also 
 possible to define a field with only its type, omitting the identifier. This is known as an 
 anonymous field. It has the effect of embedding the type directly into the struct.
  
 This concept is demonstrated in the following code snippet. Both types, 
 diameter
  and the 
 name, are embedded as 
 anonymous
  fields in the 
 planet
  type:
  
 type diameter int
  
 type name struct {
  
  long   string
  
  short  string
  
  symbol rune 
  
 } 
  
 type planet struct {
  
  diameter
  
  name
  
  desc string 
  
 }
  
 func main() {
  
  earth := planet{
  
   
  diameter: 7926,
  
   
  name: name{
  
   
  
  long:   ""Earth"",
  
   
  
  short:  ""E"",",NA
Promoted fields,"Fields of an embedded struct can be 
 promoted
  to its enclosing type. Promoted fields appear 
 in selector expressions without the qualified name of their types, as shown in the following 
 example:
  
 func main() { 
  
 ...",NA
Structs as parameters,"Recall that struct variables store actual values. This implies that a new copy of a struct value 
 is created whenever a 
 struct
  variable is reassigned or passed in as a function parameter.
  
 For instance, the following will not update the value of name after the call to 
 updateName()
 :
  
 type person struct {
  
  name    string
  
  title string 
  
 } 
  
 func updateName(p person, name string) { p.name = 
 name 
  
 }
  
 func main() {
  
  p := person{}
  
  p.name = ""uknown""
  
  ...
  
  updateName(p, ""Vladimir Vivien"") 
  
 }
  
 golang.fyi/ch07/struct_ptr.go",NA
Field tags,"The last topic on structs has to do with field tags. During the definition of a 
 struct
  type, 
 optional 
 string
  values may be added to each field declaration. The value of the string is 
 arbitrary and it can serve as hints to tools or other APIs that use reflection to consume the 
 tags.
  
 The following shows a definition of the Person and Address structs that are tagged with 
 JSON annotation which can be interpreted by Go's JSON encoder and decoder (found in the 
 standard library):
  
 type Person struct {
  
  Name    string `json:""person_name""`
  
  Title   string `json:""person_title""`
  
  Address `json:""person_address_obj""` 
  
 }
  
 type Address struct {
  
  Street string `json:""person_addr_street""` City   string 
 `json:""person_city""`
  
  State  string `json:""person_state""`",NA
Summary,"This chapter covered a lot of ground as it walked through each of the composite types found 
 in Go to provide insightful coverage of their characteristics. The chapter opened with a 
 coverage of the array type, where readers learned how to declare, initialize, and use array 
 values. Next, readers learned all about the slice type, specifically the declaration, 
  
 initialization, and practical examples that uses slice index expressions to create new or re-
 slice existing slices. The chapter covered the map type, which included information on map 
 initialization, access, update, and traversal. Lastly, the chapter provided information about 
 the definition, initialization, and usage of the struct type.
  
 Needless to say, this is probably one of the longest chapters of the book. However, the 
 information covered here will prove to be invaluable as the book continues to explore new 
 topics. The next chapter will introduce the idea of using Go to support object-like idioms 
 using methods and interfaces.",NA
"Methods, Interfaces, and ",NA,NA
,NA,NA
Objects,"Using your skills at this point, you can write an effective Go program using the 
  
 fundamental concepts covered so far. As you will see in this chapter, the Go type system 
 can support idioms that go beyond simple functions. While the designers of Go did not 
 intend to create an object-oriented language with deep class hierarchies, the language is 
 perfectly capable of supporting type compositions with advanced features to express the 
 creation of complex object-like structures, as covered in the following topics:
  
 Go methods
  
 Objects in Go
  
 The interface type
  
 Type assertion",NA
Go methods,"A Go function can be defined with a scope narrowed to that of a specific type. When a 
 function is scoped to a type, or attached to the type, it is known as a 
 method
 . A method is 
 defined just like any other Go function. However, its definition includes a 
 method receiver
 , 
 which is an extra parameter placed before the method's name, used to specify the host type 
 to which the method is attached.",NA
Value and pointer receivers,"One aspect of methods that has escaped discussion so far is that receivers are normal 
 function parameters. Therefore, they follow the pass-by-value mechanism of Go functions.
  
 This implies that the invoked method gets a copy of the original value from the declared 
 type.",NA
Objects in Go,"The lengthy introductory material from the previous sections was the setup to lead to the 
 discussion of objects in Go. It has been mentioned that Go was not designed to function as 
 traditional object-oriented language. There are no object or class keywords defined in Go.
  
 So then, why are we discussing objects in Go at all? Well, it turns out that Go perfectly 
 supports object idioms and the practice of object-oriented programming without the heavy 
 baggage of classical hierarchies and complex inheritance structures found in other object-
 oriented languages.
  
 Let us review some of the primordial features usually attributed to an object-oriented 
 language in the following table.
  
 Object feature 
  
 Go Comment
  
 Object: A data type 
  
 Yes In Go all types can achieve this. There is no special type called a that 
 stores states and 
  
 class or object to do this. Any type can receive a set of method to exposes 
 behavior 
  
 define its behavior, although the 
 struct
  type comes the closest to 
  
 what is 
 commonly called an object in other languages.
  
 Composition 
  
 Yes Using a type such as a 
 struct
  or an 
 interface
  (discussed 
  
 later), 
 it is possible to create objects and express their polymorphic 
  
 relationships through 
 composition.",NA
The struct as object,"Nearly all Go types can play the role of an object by storing states and exposing methods 
 that are capable of accessing and modifying those states. The 
 struct
  type, however, offers 
 all of the features that are traditionally attributed to objects in other languages, such as:
  
 Ability to host methods
  
 Ability to be extended via composition
  
 Ability to be sub-typed (with help from the Go 
 interface
  type)
  
 The remainder of the chapter will base its discussion of objects on using the 
 struct
  type.",NA
Object composition,"Let us start with the following simple example to demonstrate how the 
 struct
  type may be 
 used as an object that can achieve polymorphic composition. The following source 
  
 code snippet implements a typical structure that models components of motorized 
  
 transportation including 
 fuel, engine
 , 
 vehicle
 , 
 truck
 , and 
 plane
 :
  
 type fuel int 
  
 const (
  
  
  GASOLINE fuel = iota
  
  
  BIO
  
  
  ELECTRIC
  
  
  JET 
  
 ) 
  
 type vehicle struct {
  
  
  make string
  
  
  model string 
  
 }
  
 type engine struct {
  
  fuel fuel
  
  thrust int 
  
 } 
  
 func (e *engine) start() {
  
  fmt.Println (""Engine started."") 
  
 }
  
 type truck struct {
  
  vehicle
  
  engine
  
  axels int
  
  wheels int
  
  class int 
  
 } 
  
 func (t *truck) drive() {
  
  fmt.Printf(""Truck %s %s, on the go!\n"", t.make, t.model) }
  
 type plane struct {
  
  vehicle
  
  engine
  
  engineCount int
  
  fixedWings bool
  
  maxAltitude int 
  
 } 
  
 func (p *plane) fly() {
  
  fmt.Printf(",NA
Field and method promotion,"Now that the objects have been established in the previous section, let us spend some time 
 discussing the visibility of fields, methods, and embedded types inside the structs. The 
 following source snippet shows a continuation of the previous example. It declares and 
 initializes a variable 
 t
  of type 
 truck
  and 
 p
  for 
 plane
 . The former is initialized using a struct 
 literal and the latter is updated using dot notation:
  
 func main() {
  
  t := &truck {
  
   
  vehicle:vehicle{""Ford"", ""F750""},
  
  
  engine:engine{GASOLINE+BIO,700},
   
  
 axels:2,
  
   
  wheels:6,
  
   
  class:3,
  
  }
  
  t.start()
  
  t.drive()
  
  p := &plane{}
  
  p.make = ""HondaJet""
  
  p.model = ""HA-420""
  
  p.fuel = JET
  
  p.thrust = 2050
  
  p.engineCount = 2
  
  p.fixedWings = true
  
  p.maxAltitude = 43000
  
  p.start()
  
  p.fly()
  
 }
  
 golang.fyi/ch08/structobj.go
  
 One of the more interesting details in the previous snippet is how the 
 struct
  type 
  
 embedding mechanism promotes fields and methods when accessed using dot notation. For 
 instance, the following fields (
 make
 , 
 mode
 , 
 fuel
 , and 
 thrust
 ), are all declared in types that are 
 embedded inside of the 
 plane
  type:
  
 p.make = ""HondaJet"" 
  
 p.model = ""HA-420"" 
  
 p.fuel = JET 
  
 p.thrust = 2050",NA
The constructor function,"Since Go does not support classes, there is no such concept as a constructor. However, one 
 conventional idiom you will encounter in Go is the use of a factory function to create and 
 initialize values for a type. The following snippet shows a portion of the previous example 
 that has been updated to use a constructor function for creating new values of the 
 plane 
 and 
 truck
  types:
  
 type truck struct {
  
  vehicle
  
  engine
  
  axels int
  
  wheels int
  
  class int 
  
 } 
  
 func newTruck(mk, mdl string) *truck {
  
  return &truck {vehicle:vehicle{mk, mdl}} }
  
 type plane struct {
  
  vehicle
  
  engine
  
  engineCount int
  
  fixedWings bool
  
  maxAltitude int 
  
 } 
  
 func newPlane(mk, mdl string) *plane {",NA
The interface type,"When you talk to people who have been doing Go for a while, they almost always list the 
 interface as one of their favorite features of the language. The concept of interfaces in Go, 
 similar to other languages, such as Java, is a set of methods that serves as a template to 
 describe behavior. A Go interface, however, is a type specified by the 
 interface{}
  literal, 
 which is used to list a set of methods that satisfies the interface. The following example 
 shows the 
 shape
  variable being declared as an interface:
  
 var shape interface {
  
  
  area() float64
  
  
  perim() float64 
  
 }
  
 In the previous snippet, the 
 shape
  variable is declared and assigned an unnamed type, 
 interface{area()float64; perim()float64}
 . Declaring variables with unnamed 
 interface
  literal 
 types is not really practical. Using idiomatic Go, an 
 interface
  type is almost always 
 declared as a named 
 type
 . The previous snippet can be rewritten to use a named interface 
 type, as shown in the following example:
  
 type shape interface {
  
  area() float64
  
  perim() float64 
  
 } 
  
 var s shape",NA
Implementing an interface,"The interesting aspect of interfaces in Go is how they are implemented and ultimately used. 
 Implementing a Go interface is done implicitly. There is no separate element or keyword 
 required to indicate the intent of implementation. Any type that defines the method set of 
 an 
 interface
  type automatically satisfies its implementation.
  
 The following source code shows the 
 rect
  type as an implementation of the 
 interface 
 type 
 shape
 . The 
 rect
  type is defined as a 
 struct
  with receiver methods 
 area
  and 
 perim
 .
  
 This fact automatically qualifies 
 rect
  as an implementation of 
 shape
 :
  
 type shape interface {
  
  area() float64
  
  perim() float64 
  
 }
  
 type rect struct {
  
  name string
  
  length, height float64 
  
 }
  
 func (r *rect) area() float64 {
  
  return r.length * r.height 
  
 }
  
 func (r *rect) perim() float64 {
  
  return 2*r.length + 2*r.height 
  
 }
  
 golang.fyi/ch08/interface_impl.go",NA
Subtyping with Go interfaces,"Earlier, during the discussion on objects, it was mentioned that Go favors composition (
 has-
 a
 ) relationships when building objects. While that is true, Go can also express 
 “
 is-
 a
 ”
 relationships among objects using subtyping via interfaces. In our previous example, it 
 can be argued that the 
 rect
  type (and any other type that implements the methods 
 area 
 and 
 perim
 ) can be treated as a subtype of 
 shape
 , as shown in the following figure:
  
  
 As you may expect, any subtype of 
 shape
  can participate in expressions or be passed as 
 functions (or methods) parameters where the 
 shape
  type is expected. This is shown in the 
 following code snippet where both types, 
 rect
  (defined previously) and 
 triangle
 , are able to 
 be passed to the 
 shapeInfo(shape)
  function to return a 
 string
  value containing shape 
 calculations:
  
 type triangle struct {
  
  name string
  
  a, b, c float64 
  
 }
  
 func (t *triangle) area() float64 {
  
  return 0.5*(t.a * t.b) 
  
 }
  
 func (t *triangle) perim() float64 {
  
  return t.a + t.b + math.Sqrt((t.a*t.a) + (t.b*t.b)) }
  
 func (t *triangle) String() string {
  
  return fmt.Sprintf(
  
   
  ""%s[sides: a=%.2f b=%.2f c=%.2f]"",
  
  
  
 t.name, t.a, t.b, t.c,
  
 [ 193 ]",NA
Implementing multiple interfaces,"The implicit mechanism of interfaces allows any named type to satisfy multiple interface 
 types at once. This is achieved simply by having the method set of a given type intersect 
 with the methods of each 
 interface
  type to be implemented. Let us re-implement the 
 previous code to show how this is done. Two new interfaces are introduced, 
 polygon
  and 
 curved
 , to better capture and categorize information and the behavior of shapes, as shown 
 in the following code snippet:
  
 type shape interface {
  
  area() float64 
  
 }
  
 type polygon interface {
  
  perim() 
  
 }
  
 type curved interface {
  
  circonf() 
  
 } 
  
 type rect struct {...} 
  
 func (r *rect) area() float64 {
  
  return r.length * r.height 
  
 } 
  
 func (r *rect) perim() float64 {
  
  return 2*r.length + 2*r.height",NA
Interface embedding,"Another interesting aspects of the 
 interface
  type is its support for type embedding (similar 
 to the 
 struct
  type). This gives you the flexibility to structure your types in ways that 
 maximize type reuse. Continuing with the shape example, the following code snippet 
 reorganizes and reduces the previous interface count from three to two by embedding 
 shape into the other two types:
  
 type shape interface {
  
  area() float64 
  
 }
  
 type polygon interface {
  
  shape
  
  perim() 
  
 }
  
 type curved interface {
  
  shape
  
  circonf() 
  
 }
  
 golang.fyi/ch08/interface_impl3.go
  
 The following illustration shows how the interface types may be combined so the 
 is-
 a
  relationship still satisfies the relationships between code components:",NA
The empty interface type,"The 
 interface{}
  type, or the empty 
 interface
  type, is the literal representation of an 
 interface
  
 type with an empty method set. According to our discussion so far, it can be deduced that 
 all types implement the empty interface
  since all types can have a method set with zero or more 
 members.
  
 When a variable is assigned the 
 interface{}
  type, the compiler relaxes its build-time type 
 checks. The variable, however, still carries type information that can be queried at runtime.
  
 The following code illustrates how this works:
  
 func main() {
  
  var anyType interface{}
  
  anyType = 77.0
  
  anyType = ""I am a string now""
  
  fmt.Println(anyType)
  
  printAnyType(""The car is slow"")
  
  m := map[string] string{""ID"":""12345"", ""name"":""Kerry""} printAnyType(m)
  
  printAnyType(1253443455) 
  
 }
  
 func printAnyType(val interface{}) {
  
  fmt.Println(val) 
  
 }
  
 golang.fyi/ch08/interface_empty.go
  
 In the previous code, the 
 anyType
  variable is declared to be of the type 
 interface{}
 . It is able 
 to be assigned values of different types without complaints from the compiler:
  
 anyType = 77.0 
  
 anyType = ""I am a string now""",NA
Type assertion,"When an interface (empty or otherwise) is assigned to a variable, it carries type information 
 that can be queried at runtime. Type assertion is a mechanism that is available in Go to 
 idiomatically narrow a variable (of 
 interface
  type) down to a concrete type and value that are 
 stored in the variable. The following example uses type assertion in the 
 eat
  function to select 
 which 
 food
  type to select in the 
 eat
  function:
  
 type food interface {
  
  eat() 
  
 }
  
 type veggie string 
  
 func (v veggie) eat() {
  
  fmt.Println(""Eating"", v) 
  
 }
  
 type meat string 
  
 func (m meat) eat() {
  
  fmt.Println(""Eating tasty"", m) 
  
 }
  
 func eat(f food) {
  
  veg, ok := f.(veggie)
  
  if ok {
  
   
  if veg == ""okra"" {
  
   
  
  fmt.Println(""Yuk! not eating "", veg)
  
  
  
 }else{
  
   
  
  veg.eat()
  
   
  }",NA
Summary,"This chapter attempted to give a broad and, at the same, somewhat comprehensive view of 
 several important topics including methods, interfaces, and objects in Go. The chapter 
 started with coverage of attaching methods to types using receiver parameters. Next the 
 reader was introduced to objects and how to create idiomatic object-based programming in 
 Go. Lastly, the chapter presented a comprehensive overview of the interface type and how it 
 is used to support object semantics in Go. The next chapter takes the reader through one of 
 the most fundamental concepts that has made Go such a sensation among developers: 
 concurrency!
  
 [ 201 ]",NA
Concurrency ,NA,NA
,"Concurrency is considered to be the one of the most attractive features of Go. Adopters of 
 the language revel in the simplicity of its primitives to express correct concurrency 
  
 implementations without the pitfalls that usually come with such endeavors. This chapter 
 covers the necessary topics to understand and create concurrent Go programs, including the 
 following:
  
 Goroutines
  
 Channels
  
 Writing concurrent programs
  
 The sync package
  
 Detecting race conditions
  
 Parallelism in Go",NA
Goroutines,"If you have worked in other languages, such as Java or C/C++, you are probably familiar 
 with the notion of concurrency. It is the ability of a program to run two or more paths of 
 execution independently. This is usually done by exposing a thread primitive directly to the 
 programmer to create and manage concurrency.
  
 Go has its own concurrency primitive called the 
 goroutine
 , which allows a program to 
 launch a function (routine) to execute independently from its calling function. Goroutines 
 are lightweight execution contexts that are multiplexed among a small number of OS-
 backed threads and scheduled by Go's runtime scheduler. That makes them cheap to create 
 without the overhead requirements of true kernel threads. As such, a Go program can",NA
The go statement,"Goroutines are launched using the 
 go
  statement as follows:
  
 go <function or expression>
  
 A goroutine is created with the 
 go
  keyword followed by the function to schedule for 
 execution. The specified function can be an existing function, an anonymous function, or an 
 expression that calls a function. The following code snippet shows an example of the use of 
 goroutines:
  
 func main() {
  
  go count(10, 50, 10)
  
  go count(60, 100, 10)
  
  go count(110, 200, 20) 
  
 } 
  
 func count(start, stop, delta int) {
  
  for i := start; i <= stop; i += delta {
  
  
  
 fmt.Println(i)
  
  } 
  
 }
  
 golang.fyi/ch09/goroutine0.go
  
 In the previous code sample, when the 
 go count()
  statement is encountered in the 
 main 
 function, it launches the 
 count
  function in an independent execution context. Both the 
 main 
 and 
 count
  functions will be executing concurrently. As a side effect, 
 main
  will complete 
 before any of the 
 count
  functions get a chance to print anything to the console.
  
 Later in the chapter, we will see how to handle synchronization idiomatically between 
 goroutines. For now, let us use 
 fmt.Scanln()
  to block and wait for keyboard input, as 
 shown in the following sample. In this version, the concurrent functions get a chance to 
 complete while waiting for keyboard input:
  
 func main() {
  
  go count(10, 30, 10)
  
  go count(40, 60, 10)
  
  go count(70, 120, 20)
  
  fmt.Scanln() // blocks for kb input 
  
 }
  
 golang.fyi/ch09/goroutine1.go",NA
Goroutine scheduling,"In general, all goroutines run independently of each other, as depicted in the following 
 illustration. A function that creates a goroutine does not wait for it to return, it continues 
 with its own execution stream unless there is a blocking condition. Later, the chapter covers 
 synchronization idioms to coordinate goroutines:
  
  
 Go's runtime scheduler uses a form of cooperative scheduling to schedule goroutines. By 
 default, the scheduler will allow a running goroutine to execute to completion. However, 
 the scheduler will automatically yield to another goroutine for execution if one of the 
 following events occurs:
  
 A 
 go
  statement is encountered in the executing goroutine
  
 A channel operation is encountered (channels are covered later)
  
 A blocking system call (file or network IO for instance) is encountered
  
 After the completion of a garbage collection cycle",NA
Channels,"When talking about concurrency, one of the natural concerns that arises is that of data 
 safety and synchronization among concurrently executing code. If you have done 
 concurrent programming in languages such as Java or C/C++, you are likely familiar with 
 the, sometimes brittle, choreography required to ensure running threads can safely access 
 shared memory values to achieve communication and synchronization between threads.
  
 This is one area where Go diverges from its C lineage. Instead of having concurrent code 
 communicate by using shared memory locations, Go uses channels as a conduit between 
 running goroutines to communicate and share data. The blog post 
 Effective Go
  (
 https://go 
 lang.org/doc/effective_go.html
 ) has reduced this concept to the following slogan:
  
 Do not communicate by sharing memory; instead, share memory by communicating.
  
 The concept of channel has its roots in 
 communicating sequential 
  
 processes
  (
 CSP
 ), work done by renowned computer scientist C. A. Hoare, 
 to model concurrency using communication primitives. As will be 
  
 discussed in this section, channels provide the means to synchronize and 
 safely communicate data between running goroutines.
  
 This section discusses the Go channel type and provides insights into its characteristics. 
 Later, you will learn how to use channels to craft concurrent programs.",NA
The Channel type,"The channel type declares a conduit within which only values of a given element type may 
 be sent or received by the channel. The 
 chan
  keyword is used to specify a channel type, as 
 shown in the following declaration format:
  
 chan <element type>
  
 The following code snippet declares a bidirectional channel type, 
 chan int
 , assigned to the 
 variable 
 ch
 , to communicate integer values:
  
 func main() {
  
  var ch chan int
  
  ...
  
 }",NA
The send and receive operations,"Go uses the 
 <-
  (arrow) operator to indicate data movement within a channel. The following 
 table summarizes how to send or receive data from a channel:
  
 Example 
  
 Operation Description
  
 intCh <- 12 
  
 Send 
  
 When the arrow is placed to the left of the value, variable or 
  
  
 expression, it indicates a send operation to the channel it points 
  
  
 to. In this example, 
 12
  is sent into channel 
 intCh
 .
  
 value := <-
  
 Receive
  
 When the 
 <-
  operator is place to the left of a channel, it indicates
  
 intCh
  
 a receive operation from the channel. The 
 value
  variable is
  
 assigned the value received from the 
 intCh
  channel.
  
 An uninitialized channel has a 
 nil
  zero value and must be initialized using the built-in 
 make 
 function. As will be discussed in the following sections, a channel can be initialized as either 
 unbuffered or buffered, depending on its specified capacity. Each of type of channel has 
 different characteristics that are leveraged in different concurrency constructs.",NA
Unbuffered channel,"When the 
 make
  function is invoked without the capacity argument, it returns a bidirectional 
 unbuffered
  channel. The following snippet shows the creation of an unbuffered channel of 
 type 
 chan int
 :
  
 func main() {
  
  ch := make(chan int) // unbuffered channel ...
  
 }
  
 The characteristics of an unbuffered channel are illustrated in the following figure:",NA
Buffered channel,"When the 
 make
  function uses the capacity argument, it returns a bidirectional 
 buffered 
 channel, as shown in the following snippet:
  
 func main
  
  ch := make(chan int, 3) // buffered channel }
  
 The previous code will create a buffered channel with a capacity of 
 3
 . The buffered channel 
 operates as a first-in-first-out blocking queue, as illustrated in the following figure:
  
  
  
  
  
  
 The buffered channel depicted in the preceding figure has the following characteristics:
  
 When the channel is empty, the receiver blocks until there is at least one element
  
 The sender always succeeds as long as the channel is not at capacity
  
 When the channel is at capacity, the sender blocks until at least one element is 
  
 received
  
 Using a buffered channel, it is possible to send and receive values within the same 
 goroutine without causing a deadlock. The following shows an example of sending and 
 receiving using a buffered channel with a capacity of 
 4
  elements:
  
 func main() {
  
  ch := make(chan int, 4)
  
  ch <- 2
  
  ch <- 4
  
  ch <- 6
  
  ch <- 8
  
  fmt.Println(<-ch)
  
  fmt.Println(<-ch)
  
  fmt.Println(<-ch)",NA
Unidirectional channels,"At declaration, a channel type may also include a unidirectional operator (using the 
 <-
 arrow again) to indicate whether a channel is send-only or receive-only, as listed in the 
 following table:
  
 Declaration Operation
  
 <-
  chan <element type>
  Declares a receive-only channel as shown later. 
 var 
 inCh chan<- int
  
 chan 
 <-
 <element type> 
 Declares a send-only channel as shown later. 
 var outCh <-chan int
  
 The following code snippet shows function 
 makeEvenNums
  with a send-only channel 
 argument of type 
 chan <- int
 :
  
 func main() {
  
  ch := make(chan int, 10)",NA
Channel length and capacity,"The 
 len
  and 
 cap
  functions can be used to return a channel's length and capacity 
  
 respectively. The 
 len
  function returns the current number of elements queued in the channel 
 prior to being read by a receiver. For instance, the following code snippet will print 
 2
 :
  
 func main() {
  
  ch := make(chan int, 4)
  
  ch <- 2
  
  ch <- 2
  
  fmt.Println(len(ch)) 
  
 }
  
 The 
 cap
  function returns the declared capacity of the channel type which, unlike length, 
 remains constant throughout the life of the channel.",NA
Closing a channel,"Once a channel is initialized it is ready for send and receive operations. A channel will 
 remain in that open state until it is forcibly closed using the built-in 
 close
  function, as shown 
 in the following example:
  
 func main() {
  
  ch := make(chan int, 4)
  
  ch <- 2
  
  ch <- 4
  
  close(ch)
  
  // ch <- 6 // panic, send on closed channel
  
  fmt.Println(<-ch)
  
  fmt.Println(<-ch)
  
  fmt.Println(<-ch) // closed, returns zero value for element
  
 }
  
 golang.fyi/ch09/chan2.go
  
 Once a channel is closed, it has the following properties:
  
 Subsequent send operations will cause a program to panic
  
 Receive operations never block (regardless of whether buffered or unbuffered)
  
 All receive operations return the zero value of the channel's element type
  
 In the previous snippet, the 
 ch
  channel is closed after two send operations. As indicated in 
 the comment, a third send operation would cause a panic because the channel is closed. On 
 the receiving side, the code gets the two elements in the channel before it is closed. A third 
 receive operation returns 
 0
 , the zero value for the channel's elements.",NA
Writing concurrent programs,"Up to this point, the discussions about goroutines and channels remained deliberately 
 separated to ensure that each topic is properly covered. However, the true power of 
 channels and goroutines are realized when they are combined to create concurrent 
 programs, as covered in this section.",NA
Synchronization,"One of the primary uses of channels is synchronization between running goroutines. To 
 illustrate this use case, let us examine the following code, which implements a word 
 histogram. The program reads the words from the 
 data
  slice then, on a separate goroutine, 
 collects the occurrence of each word:
  
 func main() {
  
  data := []string{
  
   
  ""The yellow fish swims slowly in the water"",
  
   
  ""The brown dog barks loudly after a drink ..."",
  
  
  ""The dark 
 bird bird of prey lands on a small ..."", }
  
  histogram := make(map[string]int)
  
 [ 215 ]",NA
Streaming data,"A natural use of channels is to stream data from one goroutine to another. This pattern is 
 quite common in Go code and for it to work, the followings must be done:
  
 Continuously send data on a channel
  
 Continuously receive the incoming data from that channel
  
 Signal the end of the stream so the receiver may stop",NA
Using for…range to receive data,"The previous pattern is so common in Go that the idiom is built into the language in the 
 form of the following 
 for…range
  statement:
  
 for <elemem> := range <channel>{
 …
 }
  
 With each iteration, this 
 for…range
  statement will block until it receives incoming data 
 from the indicated channel, as shown in the following snippet:
  
 func main(){ 
  
 ...
  
  go func() {
  
  
  defer close(wordsCh)
  
  
  for _, line := range data {
  
  
  
  words := strings.Split(line, "" "")
   
  for _, 
 word := range words {
  
  
  
  word = strings.ToLower(word)
   
  
 wordsCh <- word
  
  
  
  }",NA
Generator functions,"Channels and goroutines provide a natural substrate for implementing a form of 
 producer/producer pattern using generator functions. In this approach, a goroutine is 
 wrapped in a function which generates values that are sent via a channel returned by the 
 function. The consumer goroutine receives these values as they are generated.
  
 The word histogram has been updated to use this pattern, as shown in the following code 
 snippet:
  
 func main() {
  
  data := []string{""The yellow fish swims..."", ...} histogram := 
 make(map[string]int)
  
  words := words(data) // returns handle to data channel for word := range 
 words {
  
   
  histogram[word]++
  
  } 
  
 ...
  
 }
  
 // generator function that produces data func words(data 
 []string) <-chan string { out := make(chan string)
  
  go func() {",NA
Selecting from multiple channels,"Sometimes it is necessary for concurrent programs to handle send and receive operations for 
 multiple channels at the same time. To facilitate such endeavor, the Go language supports 
 the 
 select
  statement that multiplexes selection among multiple send and receive operations:
  
 select {
  
 case <send_ or_receive_expression>:
  
 default:
  
 }
  
 The 
 case
  statement operates similarly to a 
 switch
  statement with 
 case
  clauses. The 
 select
  
 statement, however, selects one of the send or receive cases which succeeded. If two or more 
 communication cases happen to be ready at the same time, one will be selected at random. 
 The default case is always selected when no other cases succeed.
  
 [ 221 ]",NA
Channel timeout,"One popular idiom that is commonly encountered with Go concurrency is the use of the 
 select statement, introduced previously, to implement timeouts. This works by using the 
 select statement to wait for a channel operation to succeed within a given time duration 
 using the API from the 
 time
  package (
 https://golang.org/pkg/time/
 ).
  
 The following code snippet shows a version of the word histogram example that times out 
 if the program takes longer than 200 microseconds to count and print the words:
  
 func main() {
  
  data := []string{...}
  
  histogram := make(map[string]int)
  
  done := make(chan struct{})
  
  go func() {
  
  
  defer close(done)
  
  
  words := words(data) // returns handle to channel
  
  for word := 
 range words {
  
  
  
  histogram[word]++
  
  
  }
  
  
  for k, v := range histogram {
  
  
  
  fmt.Printf(""%s\t(%d)\n"", k, v)
  
  
  }
  
  }()
  
  select {
  
  case <-done:
  
   
  fmt.Println(""Done counting words!!!!"")
  
  case <-time.After(200 * time.Microsecond):
  
   
  fmt.Println(""Sorry, took too long to count."") } 
  
 } 
  
 func words(data []string) <-chan string {...}
  
 golang.fyi/ch09/pattern6.go",NA
The sync package,"There are instances when accessing shared values using traditional methods are simpler and 
 more appropriate then the use of channels. The 
 sync
  package (
 https://golang.org/pk g/sync/
 ) 
 provides several synchronization primitives including mutual exclusion (mutex) locks and 
 synchronization barriers for safe access to shared values, as discussed in this section.",NA
Synchronizing with mutex locks,"Mutex locks allow serial access of shared resources by causing goroutines to block and wait 
 until locks are released. The following sample illustrates a typical code scenario with the 
 Service
  type, which must be started before it is ready to be used. After the service has 
 started, the code updates an internal bool variable, 
 started
 , to store its current state:
  
 type Service struct {
  
  started bool
  
  stpCh   chan struct{}
  
  mutex   sync.Mutex 
  
 } 
  
 func (s *Service) Start() {
  
  s.stpCh = make(chan struct{})
  
  go func() {
  
   
  s.mutex.Lock()
  
   
  s.started = true
  
   
  s.mutex.Unlock()
  
   
  <-s.stpCh // wait to be closed.
  
  }() 
  
 } 
  
 func (s *Service) Stop() {
  
  s.mutex.Lock()
  
  defer s.mutex.Unlock()
  
  if s.started {
  
   
  s.started = false
  
   
  close(s.stpCh)",NA
Synchronizing access to composite values,"The previous section discussed concurrency safety when sharing access to simple values. 
 The same level of care must be applied when sharing access to composite type values such 
 as maps and slices, since Go does not offer concurrency-safe version of these types, as 
 illustrated in the following example:
  
 type Service struct {
  
  started bool
  
  stpCh   chan struct{}
  
  mutex   sync.RWMutex
  
  cache   map[int]string 
  
 }
  
 func (s *Service) Start() {
  
  ...
  
  go func() {
  
  s.mutex.Lock()
  
  s.started = true
  
  s.cache[1] = ""Hello World""
  
  ...
  
  s.mutex.Unlock()
  
  <-s.stpCh // wait to be closed.
  
  }() 
  
 } 
  
 ...
  
 func (s *Service) Serve(id int) {
  
  s.mutex.RLock()
  
  msg := s.cache[id]
  
  s.mutex.RUnlock()
  
  if msg != """" {
  
   
  fmt.Println(msg)
  
  } else {
  
   
  fmt.Println(""Hello, goodbye!"")
  
  } 
  
 }
  
 golang.fyi/ch09/sync4.go",NA
Concurrency barriers with sync.WaitGroup,"Sometimes when working with goroutines, you may need to create a synchronization 
 barrier where you wish to wait for all running goroutines to finish before proceeding. The 
 sync.WaitGroup
  type is designed for such a scenario, allowing multiple goroutines to 
 rendezvous at specific point in the code. Using WaitGroup requires three things:
  
 The number of participants in the group via the Add method
  
 Each goroutine calls the Done method to signal completion
  
 Use the Wait method to block until all goroutines are done
  
 WaitGroup is often used as a way to implement work distribution patterns. The following 
 code snippet illustrates work distribution to calculate the sum of multiples of 
 3
  and 
 5
  up to 
 MAX
 . The code uses the 
 WaitGroup
  variable, 
 wg
 , to create a concurrency barrier that waits for 
 two goroutines to calculate the partial sums of the numbers, then gathers the result after all 
 goroutines are done:
  
 const MAX = 1000
  
 func main() {
  
  values := make(chan int, MAX)
  
  result := make(chan int, 2)
  
  var wg sync.WaitGroup
  
  wg.Add(2)
  
  go func() { // gen multiple of 3 & 5 values
   
  for i := 1; i < MAX; 
 i++ {
  
   
  
  if (i%3) == 0 || (i%5) == 0 {
  
   
  
  values <- i // push downstream
  
  
  
  }
  
   
  }
  
   
  close(values)
  
  }()
  
  work := func() { // work unit, calc partial result defer wg.Done()
  
  r := 0",NA
Detecting race conditions,"Debugging concurrent code with a race condition can be time consuming and frustrating. 
 When a race condition occurs, it is usually inconsistent and displays little to no discernible 
 pattern. Fortunately, since Version 1.1, Go has included a race detector as part of its 
 command-line tool chain. When building, testing, installing, or running Go source code, 
 simply add the 
 -race
  command flag to enable the race detector instrumentation of your 
 code.",NA
Parallelism in Go,"So far, the discussion in this chapter has focused on synchronizing concurrent programs. As 
 was mentioned earlier in the chapter, the Go runtime scheduler automatically multiplexes 
 and schedules goroutines across available OS-managed threads. This means concurrent 
 programs that can be parallelized have the ability to take advantage of the underlying 
 processor cores with little to no configuration. For instance, the following code cleanly 
 segregates its work unit (to calculate sums of multiples of 3 and 5) to be calculated by 
 launching 
 workers
  number of goroutines:
  
 const MAX = 1000 
  
 const workers = 2
  
 func main() {",NA
Summary,"Concurrency can be a complex topic in any language. This chapter covered the major topics 
 to guide readers around the use of concurrency primitives in the Go language. The first 
 section of the chapter outlined the crucial properties of goroutines, including the creation 
 and usage of the 
 go
  statement. Next, the chapter covered the mechanism of Go's runtime 
 scheduler and the notion of channels used for communication between running goroutines.
  
 Lastly, users were introduced to several concurrency patterns used to create concurrent 
 programs using goroutines, channels, and the synchronization primitives from the sync 
 package.
  
 Next, you will be introduced to the standard APIs to do data input and output in Go.",NA
Data IO in Go ,NA,NA
,"Previous chapters of this book focused mainly on fundamentals. In this and future chapters, 
 readers are introduced to some of the powerful APIs provided by Go's standard library. 
 This chapter discusses in detail how to input, process, transform, and output data using 
 APIs from the standard library and their respective packages with the following topics:
  
 IO with readers and writers
  
 The io.Reader interface
  
 The io.Writer interface
  
 Working with the io package
  
 Working with files
  
 Formatted IO with fmt
  
 Buffered IO
  
 In-memory IO
  
 Encoding and decoding data",NA
IO with readers and writers,"Similar to other languages, such as Java, Go models data input and output as a stream that 
 flows from sources to targets. Data resources, such as files, networked connections, or even 
 some in-memory objects, can be modeled as streams of bytes from which data can be 
 read
  or 
 written
  to, as illustrated in the following figure:
  
  
 The stream of data is represented as a 
 slice of bytes
  (
 []byte
 ) that can be accessed for reading 
 or writing. As we will explore in this chapter, the 
 io
  package makes available the 
  
 io.Reader
  interface to implement code that 
 reads
  and transfers data from a source into a 
 stream of bytes. Conversely, the 
 io.Writer
  interface lets implementers create code that reads 
 data from a provided stream of bytes and 
 writes
  it as output to a target resource. Both 
 interfaces are used extensively in Go as a standard idiom to express IO operations. This 
 makes it possible to interchange readers and writers of different implementations and 
 contexts with predictable results.",NA
The io.Reader interface,"The 
 io.Reader
  interface, as shown in the following listing, is simple. It consists of a single 
 method, 
 Read([]byte)(int, error)
 , intended to let programmers implement code that 
 reads
  
 data, from an arbitrary source, and transfers it into the provided slice of bytes.
  
 type Reader interface {
  
  
  Read(p []byte) (n int, err error) }
  
 [ 233 ]",NA
Chaining readers,"Chances are the standard library already has a reader that you can reuse 
 –
  so it is common 
 to wrap an existing reader and use its stream as the source for the new implementation. The 
 following snippet shows an updated version of 
 alphaReader
 . This time, it takes an 
 io.Reader
  
 as its source as shown in the following code:
  
 type alphaReader struct {
  
  src io.Reader 
  
 }",NA
The io.Writer interface,"The 
 io.Writer
  interface, as shown in the following code, is just as simple as its reader 
 counterpart:
  
 type Writer interface {
  
  Write(p []byte) (n int, err error) 
  
 }
  
 The interface requires the implementation of a single method, 
 Write(p []byte)(c int, e error)
 , 
 that copies data from the provided stream 
 p
  and 
 writes
  that data to a sink resource such as 
 an in-memory structure, standard output, a file, a network connection, or any number of 
 io.Writer
  implementations that come with the Go standard library. The 
 Write
  method 
 returns the number of bytes copied from 
 p
  followed by an 
 error
  value if any was 
 encountered.
  
 The following code snippet shows the implementation of the 
 channelWriter
  type, a writer 
 that decomposes and serializes its stream that is sent over a Go channel as consecutive 
 bytes:
  
 type channelWriter struct {
  
  Channel chan byte 
  
 }
  
 func NewChannelWriter() *channelWriter { return 
 &channelWriter{
  
   
  Channel: make(chan byte, 1024),",NA
Working with the io package,"The obvious place to start with IO is, well, the 
 io
  package (
 https://golang.org/pkg/io
 ).
  
 As we have already seen, the 
 io
  package defines input and output primitives as the 
 io.Reader
  and 
 io.Writer
  interfaces. The following table summarizes additional functions 
 and types, available in the 
 io
  package, that facilitate streaming IO operations.
  
 Function 
  
 Description
  
 io.Copy() 
  
 The 
 io.Copy
  function (and its variants 
 io.CopyBuffer
  and 
  
 io.CopyN
 ) make it easy to copy data from an arbitrary 
 io.Reader 
  
 source into an equally arbitrary 
 io.Writer
  sink as shown in the 
  
 following snippet: 
  
  
 data := strings.NewReader(""Write   me down."") 
  
  
 file, _ := os.Create(""./iocopy.data"") 
  
  
 io.Copy(file, data) 
  
  
 golang.fyi/ch10/iocopy.go
  
 PipeReader 
  
 The 
 io
  package includes the 
 PipeReader
  and 
 PipeWriter
  types that 
 PipeWriter 
  
 model IO operations as an in-memory pipe. Data is written to the 
  
 pipe's 
 io.Writer
  and can independently be read at the pipe's 
  
 io.Reader
 . The following abbreviated snippet illustrates a simple 
  
 pipe that writes a string to the writer 
 pw
 . The data is then 
 consumed 
  
 with the 
 pr
  reader and copied to a file: 
  
  
 file, _ := os.Create(""./iopipe.data"") 
  
  
 pr, pw := io.Pipe() 
  
  
 go func() {
  
  
  
  fmt.Fprint(pw, ""Pipe   streaming"")
  
  
  
  pw.Close() 
  
  
 }() 
  
  
 wait := make(chan struct{}) 
  
  
 go func() {
  
  
  
  io.Copy(file, pr)
  
  
  
  pr.Close()
  
  
  
  close(wait) 
  
  
 }() 
  
  
 <-wait //wait for pr to finish 
  
  
 golang.fyi/ch10/iopipe.go
  
 Note that the pipe writer will block until the reader completely 
 consumes the pipe content or an error is encountered. Therefore, 
 both the reader and writer should be wrapped in a goroutine to 
 avoid deadlocks.",NA
Working with files,"The 
 os
  package (
 https://golang.org/pkg/os/
 ) exposes the 
 os.File
  type which represents a file 
 handle on the system. The 
 os.File
  type implementsseveral IO primitives, including the 
 io.Reader
  and 
 io.Writer
  interfaces, which allows file content to be processed using the 
 standard streaming IO API.",NA
Creating and opening files,"The 
 os.Create
  function creates a new file with the specified path. If the file already exists, 
 os.Create
  will overwrite it. The 
 os.Open
  function, on the other hand, opens an existing file for 
 reading.",NA
Function os.OpenFile,"The 
 os.OpenFile
  function provides generic low-level functionalities to create a new file or 
 open an existing file with fine-grained control over the file's behavior and its permission.
  
 Nevertheless, the 
 os.Open
  and 
 os.Create
  functions are usually used instead as they 
 provide a simpler abstraction then the 
 os.OpenFile
  function.
  
 [ 242 ]",NA
Files writing and reading,"We have already seen how to use the 
 os.Copy
  function to move data into or out of a file. 
 Sometimes, however, it will be necessary to have complete control over the logic that writes 
 or reads file data. The following code snippet, for instance, uses the 
 WriteString
  method from 
 the 
 os.File
  variable, 
 fout,
  to create a text file:
  
 func main() {
  
  rows := []string{
  
   
  ""The quick brown fox"",
  
   
  ""jumps over the lazy dog"",
  
  }
  
 [ 243 ]",NA
"Standard input, output, and error","The 
 os
  package includes three pre-declared variables, 
 os.Stdin
 , 
 os.Stdout
 , and 
 os.Stderr
 , 
 that represent file handles for standard input, output, and error of the OS respectively. 
 The following snippet reads the file 
 f1
  and writes its content to 
 io.Stdout
 , standard output, 
 using the 
 os.Copy 
 function (standard input is covered later):
  
 func main() {
  
  f1, err := os.Open(""./file0.go"")
  
  if err != nil {
  
   
  fmt.Println(""Unable to open file:"", err)
   
  
 os.Exit(1)
  
  }
  
  defer f1.Close()
  
  n, err := io.Copy(os.Stdout, f1)
  
  if err != nil {
  
  
  fmt.Println(""Failed to copy:"", err)
  
  os.Exit(1)
  
  }
  
  fmt.Printf(""Copied %d bytes from %s \n"", n, f1.Name()) }
  
 golang.fyi/ch10/osstd.go
  
 [ 245 ]",NA
Formatted IO with fmt,"One of the most widely used packages for IO is 
 fmt
  (
 https://golang.org/pkg/fmt
 ). It comes 
 with an amalgam of functions designed for formatted input and output. The most 
 common usage of the 
 fmt
  package is for writing to standard output and reading from 
 standard input. This section also highlights other functions that make 
 fmt
  a great tool for 
 IO.",NA
Printing to io.Writer interfaces,"The 
 fmt
  package offers several functions designed to write text data to arbitrary 
  
 implementations of io.Writer. The 
 fmt.Fprint
  and 
 fmt.Fprintln
  functions write text with the 
 default format while 
 fmt.Fprintf
  supports format specifiers. The following code snippet 
 writes a columnar formatted list of 
 metalloid
  data to a specified text file using the 
 fmt.Fprintf 
 function:
  
 type metalloid struct {
  
  name   string
  
  number int32
  
  weight float64 
  
 }
  
 func main() {
  
  var metalloids = []metalloid{
  
   
  {""Boron"", 5, 10.81},
  
   
  ...
  
  {""Polonium"", 84, 209.0},
  
  }
  
  file, _ := os.Create(""./metalloids.txt"") defer file.Close()
  
  for _, m := range metalloids {
  
   
  fmt.Fprintf(
  
   
  
  file,
  
   
  
  ""%-10s %-10d %-10.3f\n"",
  
   
  m.name, m.number, m.weight,
   
  )
  
  } 
  
 }
  
 golang.fyi/ch10/fmtfprint0.go
  
 [ 246 ]",NA
Printing to standard output,"The 
 fmt.Print
 , 
 fmt.Printf
 , and 
 fmt.Println
  have the exact same characteristics as the previous 
 Fprint
 -series of functions seen earlier. Instead of an arbitrary 
 io.Writer 
 however, they write 
 text to the standard output file handle 
 os.Stdout
  (see the section 
 Standard output, input, and 
 error
  covered earlier).
  
 The following abbreviated code snippet shows an updated version of the previous example 
 that writes the list of metalloids to a standard output instead of a regular file. Note that it is 
 the same code except for the use of the 
 fmt.Printf
  instead of the 
 fmt.Fprintf
  function:
  
 type metalloid struct { ... } 
  
 func main() {
  
  var metalloids = []metalloid{
  
   
  {""Boron"", 5, 10.81},
  
   
  ...
  
  
  {""Polonium"", 84, 209.0},
  
  }
  
  for _, m := range metalloids {
  
   
  fmt.Printf(
  
   
  
  ""%-10s %-10d %-10.3f\n"",
  
   
  m.name, m.number, m.weight,
   
  )
  
  } 
  
 }
  
 golang.fyi/ch10/fmtprint0.go",NA
Reading from io.Reader,"The 
 fmt
  package also supports formatted reading of textual data from 
 io.Reader 
 interfaces. 
 The 
 fmt.Fscan
  and 
 fmt.Fscanln
  functions can be used to read multiple values, separated by 
 spaces, into specified parameters. The 
 fmt.Fscanf
  function supports format specifiers for a 
 richer and flexible parsing of data input from 
 io.Reader 
  
 implementations.",NA
Reading from standard input,"Instead of reading from an arbitrary 
 io.Reader
 , the 
 fmt.Scan
 , 
 fmt.Scanf
 , and 
 fmt.Scanln
  are 
 used to read data from standard input file handle, 
 os.Stdin
 . The following code snippet 
 shows a simple program that reads text input from the console:
  
 func main() {
  
  var choice int
  
  fmt.Println(""A square is what?"")
  
  fmt.Print(""Enter 1=quadrilateral 2=rectagonal:"")
  
  n, err := fmt.Scanf(""%d"", &choice)
  
  if n != 1 || err != nil {
  
   
  fmt.Println(""Follow directions!"")
  
  
  return
  
  }
  
  if choice == 1 {
  
   
  fmt.Println(""You are correct!"") } else {
  
   
  fmt.Println(""Wrong, Google it."") } 
  
 }
  
 golang.fyi/ch10/fmtscan1.go
  
 In the previous program, the 
 fmt.Scanf
  function parses the input using the format specifier 
 ""%d""
  to read an integer value from the standard input. The function will throw an error if 
 the value read does not match exactly the specified format. For instance, the following 
 shows what happens when character 
 D
  is read instead of an integer:
  
 $> go run fmtscan1.go 
  
 A square is what?
  
 Enter 1=quadrilateral 2=rectagonal: D 
  
 Follow directions!",NA
Buffered IO,"Most IO operations covered so far have been unbuffered. This implies that each read and 
 write operation could be negatively impacted by the latency of the underlying OS to handle 
 IO requests. Buffered operations, on the other hand, reduces latency by buffering data in 
 internal memory during IO operations. The 
 bufio
  package (
 https://golang.org/pkg/buf io
 /) offers 
 functions for buffered read and write IO operations.
  
 [ 249 ]",NA
Buffered writers and readers,"The 
 bufio
  package offers several functions to do buffered writing of IO streams using an 
 io.Writer
  interface. The following snippet creates a text file and writes to it using buffered IO:
  
 func main() {
  
  rows := []string{
  
   
  ""The quick brown fox"",
  
   
  ""jumps over the lazy dog"",
  
  }
  
  fout, err := os.Create(""./filewrite.data"") writer := 
 bufio.NewWriter(fout)
  
  if err != nil {
  
  
  fmt.Println(err)
  
  
  os.Exit(1)
  
  }
  
  defer fout.Close()
  
  for _, row := range rows {
  
   
  writer.WriteString(row)
  
  }
  
  writer.Flush() 
  
 }
  
 golang.fyi/ch10/bufwrite0.go
  
 In general, the constructor functions in the 
 bufio
  package create a buffered writer by 
 wrapping an existing 
 io.Writer
  as its underlying source. For instance, the previous code 
 creates a buffered writer using the 
 bufio.NewWriter
  function by wrapping the io.File 
 variable, 
 fout
 .
  
 To influence the size of the internal buffer, use the constructor function 
  
 bufio.NewWriterSize(w io.Writer, n int)
  to specify the internal buffer size. The 
 bufio.Writer
  
 type also offers the methods 
 Write
  and 
 WriteByte
  for writing raw bytes and 
 WriteRune
  for 
 writing Unicode-encoded characters.
  
 Reading buffered streams can be done simply by calling the constructor function 
 bufio.NewReader
  to wrap an existing 
 io.Reader
 . The following code snippet creates a 
 bufio.Reader
  variable 
 reader
  by wrapping the 
 file
  variable as its underlying source:
  
 func main() {
  
  file, err := os.Open(""./bufread0.go"")
  
  if err != nil {
  
   
  fmt.Println(""Unable to open file:"", err)",NA
Scanning the buffer,"The 
 bufio
  package also makes available primitives that are used to scan and tokenize 
 buffered input data from an 
 io.Reader
  source. The 
 bufio.Scanner
  type scans input data using 
 the 
 Split
  method to define tokenization strategies. The following code snippet shows a 
 reimplementation of the planetary example (from earlier). This time, the code uses 
  
 bufio.Scanner
  (instead of the 
 fmt.Fscan
  function) to scan the content of the text file using the 
 bufio.ScanLines
  function:
  
 func main() {
  
  file, err := os.Open(""./planets.txt"")
  
  if err != nil {
  
   
  fmt.Println(""Unable to open file:"", err)
   
  return
  
  }
  
  defer file.Close()",NA
In-memory IO,"The 
 bytes
  package offers common primitives to achieve streaming IO on blocks of bytes, 
 stored in memory, represented by the 
 bytes.Buffer
  type. Since the 
 bytes.Buffer
  type 
 implements both 
 io.Reader
  and 
 io.Writer
  interfaces it is a great option to stream data into or 
 out of memory using streaming IO primitives.
  
 The following snippet stores several string values in the 
 byte.Buffer
  variable, 
 book
 . Then the 
 buffer is streamed to 
 os.Stdout
 :
  
 func main() {
  
  var books bytes.Buffer
  
  books.WriteString(""The Great Gatsby"") 
 books.WriteString(""1984"")",NA
Encoding and decoding data,"Another common aspect of IO in Go is the encoding of data, from one representation to 
 another, as it is being streamed. The encoders and decoders of the standard library, found in 
 the 
 encoding 
 package (
 https://golang.org/pkg/encoding/
 ), use the 
 io.Reader
  and 
 io.Writer
  
 interfaces to leverage IO primitives as a way of streaming data during encoding and 
 decoding.
  
 Go supports several encoding formats for a variety of purposes including data conversion, 
 data compaction, and data encryption. This chapter will focus on encoding and decoding 
 data using the 
 Gob
  and 
 JSON
  format for data conversion. In 
 Chapter 11
 , 
 Writing Networked 
 Programs
 , we will explore using encoders to convert data for client and server 
  
 communication using 
 remote procedure calls
  (
 RPC
 ).",NA
Binary encoding with gob,"The 
 gob
  package (
 https://golang.org/pkg/encoding/gob
 ) provides an encoding format that can 
 be used to convert complex Go data types into binary. Gob is self-describing, meaning 
 each encoded data item is accompanied by a type description. The encoding process 
 involves streaming the gob-encoded data to an io.Writer so it can be written to a resource 
 for future consumption.
  
 The following snippet shows an example code that encodes variable 
 books
 , a slice of the 
 Book
  type with nested values, into the 
 gob
  format. The encoder writes its generated binary 
 data to an os.Writer instance, in this case the 
 file 
 variable of the 
 *os.File
  type:
  
 type Name struct {
  
  First, Last string 
  
 }
  
 type Book struct {
  
  Title       string
  
  PageCount   int
  
  ISBN        string
  
  Authors     []Name
  
  Publisher   string
  
  PublishDate time.Time 
  
 }
  
 func main() {
  
  books := []Book{
  
   
  Book{
  
   
  
  Title:       ""Leaning Go"",
  
   
  
  PageCount:   375,
  
   
  
  ISBN:        ""9781784395438"",
  
   
  
  Authors:     []Name{{""Vladimir"", ""Vivien""}},
  
  
  
  Publisher:   ""Packt"",
  
   
  
  PublishDate: time.Date(
  
   
  
  2016, time.July,
  
   
  
  0, 0, 0, 0, 0, time.UTC,
  
   
  
  ),
  
   
  },
  
   
  Book{
  
   
  
  Title:       ""The Go Programming Language"",
  
  
  
  PageCount:   380,
  
   
  
  ISBN:        ""9780134190440"",
  
   
  
  Authors:     []Name{
  
   
  
  {""Alan"", ""Donavan""},
  
   
  
  {""Brian"", ""Kernighan""},
  
   
  
  },
  
   
  
  Publisher:   ""Addison-Wesley"",",NA
Encoding data as JSON,"The encoding package also comes with a 
 json
  encoder sub-package (
 https://golang.org/ 
 pkg/encoding/json/)
  to support JSON-formatted data. This greatly broadens the number of 
 languages with which Go programs can exchange complex data structures. JSON encoding 
 works similarly as the encoder and decoder from the gob package. The difference is that the 
 generated data takes the form of a clear text JSON-encoded format instead of a binary. The 
 following code updates the previous example to encode the data as JSON:
  
 type Name struct {
  
  First, Last string 
  
 }
  
 type Book struct {",NA
Controlling JSON mapping with struct tags,"By default, the name of a struct field is used as the key for the generated JSON object. This 
 can be controlled using 
 struct
  type tags to specify how JSON object key names are mapped 
 during encoding and decoding of the data. For instance, the following code snippet declares 
 struct fields with the 
 json:
  tag prefix to specify how object keys are to be encoded and 
 decoded:
  
 type Book struct {
  
  Title       string      `json:""book_title""` PageCount   int         
 `json:""pages,string""` ISBN        string      `json:""-""`
  
  Authors     []Name      `json:""auths,omniempty""` Publisher   string      
 `json:"",omniempty""` PublishDate time.Time   `json:""pub_date""` 
  
 }
  
 golang.fyi/ch10/json2.go
  
 The tags and their meaning are summarized in the following table:
  
 Tags Description
  
 Title string `json:""book_title""`
  
 PageCount int
  
 `json:""pages,string""`
  
 ISBN string `json:""-""`
  
 Maps the 
 Title
  struct field to the JSON object 
 key, 
 ""book_title""
 .
  
 Maps the 
 PageCount
  struct field to the JSON 
 object key, 
 ""pages"",
  and outputs the value as a 
 string instead of a number.
  
 The dash causes the 
 ISBN
  field to be skipped 
 during encoding and decoding.
  
 [ 259 ]",NA
Custom encoding and decoding,"The JSON package uses two interfaces, 
 Marshaler
  and 
 Unmarshaler
 , to hook into encoding 
 and decoding events respectively. When the encoder encounters a value whose type 
 implements 
 json.Marshaler
 , it delegates serialization of the value to the method 
 MarshalJSON
  
 defined in the Marshaller interface. This is exemplified in the following abbreviated code 
 snippet where the type 
 Name
  is updated to implement 
 json.Marshaller 
 as shown:
  
 type Name struct {
  
  First, Last string 
  
 }
  
 [ 260 ]",NA
Summary,"This chapter provides a high-level view of Go's data input and output idioms and the 
 packages involved in implementing IO primitives. The chapter starts by covering the 
 fundamentals of a stream-based IO in Go with the 
 io.Reader
  and 
 io.Writer
  interfaces.
  
 Readers are walked through the implementation strategies and examples for both an 
 io.Reader
  and an 
 io.Writer
 .
  
 The chapter goes on to cover packages, types, and functions that that support the streaming 
 IO mechanism including working with files, formatted IO, buffered, and in-memory IO. The 
 last portion of the chapter covers encoders and decoders that convert data as it is being 
 streamed. In the next chapter, the IO theme is carried further when the discussion turns to 
 creating programs that use IO to communicate via networking.",NA
Writing Networked Services ,NA,NA
,"One of the many reasons for Go's popularity, as a system language, is its inherent support 
 for creating networked programs. The standard library exposes APIs ranging from low-
 level socket primitives to higher-level service abstractions such as HTTP and RPC. This 
 chapter explores fundamental topics about creating connected applications including the 
 following:
  
 The net package
  
 A TCP API server
  
 The HTTP package
  
 A JSON API server",NA
The net package,"The starting point for all networked programs in Go is the
 net
  package (
 https://golang.or 
 g/pkg/net
 ). It provides a rich API to handle low-level networking primitives as well as 
 application-level protocols such as HTTP. Each logical component of a network is 
  
 represented by a Go type including hardware interfaces, networks, packets, addresses, 
 protocols, and connections. Furthermore, each type exposes a multitude of methods giving 
 Go one of the most complete standard libraries for network programming supporting both 
 IPv4 and IPv6.
  
 Whether creating a client or a server program, Go programmers will need, at a minimum, 
 the network primitives covered in the following sections. These primitives are offered as",NA
Addressing,"One of the basic primitives, when doing network programming, is the 
 address
 . The types 
 and functions of the 
 net
  package use a string literal to represent an address such as 
 ""127.0.0.1""
 . The address can also include a service port separated by a colon such as 
 ""74.125.21.113:80""
 . Functions and methods in the 
 net
  package also support string literal 
 representation for IPv6 addresses such as 
 ""::1""
  or 
  
 ""[2607:f8b0:4002:c06::65]:80""
  for an address with a service port of 80.",NA
The net.Conn Type,"The 
 net.Conn
  interface represents a generic connection established between two nodes on the 
 network. It implements 
 io.Reader
  and 
 io.Writer
  interfaces which allow connected nodes to 
 exchange data using streaming IO primitives. The 
 net
  package offers network protocol-
 specific implementations of the 
 net.Conn
  interface such as 
 IPConn
 , 
 UDPConn
 , and 
 TCPConn
 . 
 Each implementation exposes additional methods specific to its respective network and 
 protocol. However, as we will see in this chapter, the default method set defined in 
 net.Conn is adequate for most uses.",NA
Dialing a connection,"Client programs use the 
 net.Dial
  function, which has the following signature, to connect to 
 a host service over the network:
  
 func Dial(network, address string) (Conn, error)
  
 The function takes two parameters where the first parameter, 
 network
 , specifies the network 
 protocol for the connection which can be:
  
 tcp
 , 
 tcp4
 , 
 tcp6
  : 
 tcp
  defaults to 
 tcp4
  
 udp
 , 
 udp4
 , 
 udp6
 : 
 udp
  defaults to 
 udp4
  
 ip
 , 
 ip4
 , 
 ip6
 : 
 ip
  defaults to 
 ip4
  
 unix
 , 
 unixgram
 , 
 unixpacket
 : for Unix domain sockets
  
 The latter parameter of the 
 net.Dial
  function specifies a string value for the host address to 
 which to connect. The address can be provided as IPv4 or IPv6 addresses as discussed 
 earlier. The 
 net.Dial
  function returns an implementation of the 
 net.Conn
  interface that 
 matches the specified network parameter.",NA
Listening for incoming connections,"When creating a service program, one the first steps is to announce the port which the 
 service will use to listen for incoming requests from the network. This is done by invoking 
 the 
 net.Listen
  function which has the following signature:
  
 func Listen(network, laddr string) (net.Listener, error)
  
 It takes two parameters where the first parameter specifies a protocol with valid values of 
 ""tcp""
 , 
 ""tcp4""
 , 
 ""tcp6""
 , 
 ""unix""
 , or 
 ""unixpacket""
 .
  
 The second parameter is the local host address for the service. The local address can be 
 specified without an IP address such as 
 "":4040""
 . Omitting the IP address of the host means 
 that the service is bound to all network card interfaces installed on the host. As an 
  
 alternative, the service can be bound to a specific network hardware interface on the host by 
 specifying its IP address on the network, that is, 
 ""10.20.130.240:4040""
 .
  
 A successful call to the 
 net.Listen
  function returns a value of the 
 net.Listener
  type (or a non-
 nil error if it fails). The 
 net.Listener
  interface exposes methods used to manage the life cycle 
 of incoming client connections. Depending on the value of the 
 network
  parameter (
 ""tcp""
 , 
 ""tcp4""
 , 
 ""tcp6""
 , and so on.), 
 net.Listen
  will return either a 
 net.TCPListener 
 or 
 net.UnixListener
 ,
  
 both of which are concrete implementations of the 
 net.Listener 
 interface.",NA
Accepting client connections,"The 
 net.Listener
  interface uses the 
 Accept
  method to block indefinitely until a new 
 connection arrives from a client. The following abbreviated code snippet shows a simple 
 server that returns the string 
 “
 Nice to meet you!
 ”
  to each client connection and then 
 disconnects immediately:
  
 func main() {
  
  listener, err := net.Listen(""tcp"", "":4040"") if err != nil {
  
   
  fmt.Println(err)
  
   
  return
  
  }
  
  defer listener.Close()
  
  for {
  
   
  conn, err := listener.Accept()
  
   
  if err != nil {
  
   
  
  fmt.Println(err)
  
   
  
  return
  
   
  }
  
   
  conn.Write([]byte(""Nice to meet you!""))
  
  
  conn.Close()
  
  } 
  
 }
  
 golang.fyi/ch11/listen0.go
  
 In the code, the 
 listener.Accept
  method returns a value of the 
 net.Conn
  type to handle data 
 exchange between the server and the client (or it returns a non-nil 
 error
  if it fails). The 
 conn.Write([]byte(""Nice to meet you!""))
  method call is used to write the response to the client. 
 When the server program is running, it can be tested using a 
 telnet
  client as shown in the 
 following output:
  
 $> go run listen0.go & 
  
 [1] 83884
  
 $> telnet 127.0.0.1 4040 
  
 Trying 127.0.0.1...
  
 Connected to localhost.
  
 Escape character is '^]'.
  
 Nice to meet you! Connection closed by foreign host.
  
 [ 268 ]",NA
A TCP API server,"At this point, the chapter has covered the minimum networking components necessary to 
 create client and service programs. The remainder of the chapter will discuss different 
 versions of a server that implement a 
 monetary currency information
  service. The service 
 returns ISO 4217 monetary currency information with each request. The intent is to show 
 the implications of creating networked services, along with their clients, using different 
 application-level protocols.
  
 Earlier we introduced a very simple server to demonstrate the necessary steps required to 
 set up a networked service. This section dives deeper into network programming by 
 creating a TCP server that scales to handle many concurrent connections. The server code 
 presented in this section has the following design goals:
  
 Use raw TCP to communicate between client and server
  
 Develop a simple text-based protocol, over TCP, for communication
  
 Clients can query the server for global currency information with text commands
  
 Use a goroutine per connection to handle connection concurrency
  
 Maintain connection until the client disconnects
  
 The following lists an abbreviated version of the server code. The program uses the 
 curr 
 package (found at 
 https://github.com/vladimirvivien/learning-go/ch11/curr0
 ), not discussed here, to 
 load monetary currency data from a local CSV file into slice 
 currencies
 .",NA
Connecting to the TCP server with telnet,"Because the currency server presented earlier uses a simple text-based protocol, it can be 
 tested using a telnet client, assuming the server code has been compiled and running (and 
 listening on port 
 4040
 ). The following shows the output of a telnet session querying the 
 server for currency information:
  
 $> telnet localhost 4040 
  
 Trying ::1...
  
 Connected to localhost.
  
 Escape character is '^]'.
  
 GET Gourde 
  
 Gourde HTG 332 HAITI 
  
 GET USD 
  
 US Dollar USD 840 AMERICAN SAMOA 
  
 US Dollar USD 840 BONAIRE, SINT EUSTATIUS AND SABA US Dollar 
 USD 840 GUAM 
  
 US Dollar USD 840 HAITI 
  
 US Dollar USD 840 MARSHALL ISLANDS (THE) 
  
 US Dollar USD 840 UNITED STATES OF AMERICA (THE) ...",NA
Connecting to the TCP server with Go,"A simple TCP client can also be written in Go to connect to the TCP server. The client 
 captures the command from the console's standard input and sends it to the server as is 
 shown in the following code snippet:
  
 var host, port = ""127.0.0.1"", ""4040"" 
  
 var addr = net.JoinHostPort(host, port) 
  
 const prompt = ""curr"" 
  
 const buffLen = 1024
  
 func main() {
  
  conn, err := net.Dial(""tcp"", addr)
  
  if err != nil {
  
   
  fmt.Println(err)
  
   
  return
  
  }
  
  defer conn.Close()
  
  var cmd, param string
  
  // repl - interactive shell for client
  
  for {
  
   
  fmt.Print(prompt, ""> "")
  
   
  _, err = fmt.Scanf(""%s %s"", &cmd, &param)
  
   
  if err != nil {
  
   
  
  fmt.Println(""Usage: GET <search string or *>"")
  
  
  
  continue
  
   
  }
  
   
  // send command line
  
   
  cmdLine := fmt.Sprintf(""%s %s"", cmd, param)
  
   
  if n, err := conn.Write([]byte(cmdLine));
  
   
  n == 0 || err != nil {
  
   
  
  fmt.Println(err)
  
   
  
  return
  
   
  }
  
  // stream and display response",NA
The HTTP package,"Due to its importance and ubiquity, HTTP is one of a handful of protocols directly 
 implemented in Go. The 
 net/http
  package (
 https://golang.org/pkg/net/http/) 
 provides code to 
 implement both HTTP clients and HTTP servers. This section explores the fundamentals of 
 creating HTTP clients and servers using the 
 net/http
  package. Later, we will return our 
 attention back to building versions of our currency service using HTTP.",NA
The http.Client type,"The 
 http.Client
  struct represents an HTTP client and is used to create HTTP requests and 
 retrieve responses from a server. The following illustrates how to retrieve the text content of 
 Beowulf from Project Gutenberg's website located at 
 http://gutenberg.org/ca 
 che/epub/16328/pg16328.txt
 , using the 
 client
  variable of the 
 http.Client
  type and prints its 
 content to a standard output:
  
 func main() {
  
  client := http.Client{}
  
  resp, err := client.Get(
  
   
  "" http://gutenberg.org/cache/epub/16328/pg16328.txt"") if err != nil {
  
   
  fmt.Println(err)
  
   
  return
  
  }
  
  defer resp.Body.Close()
  
  io.Copy(os.Stdout, resp.Body)
  
 [ 275 ]",NA
Configuring the client,"Besides the methods to communicate with the remote server, the 
 http.Client
  type exposes 
 additional attributes that can be used to modify and control the behavior of the client. For 
 instance, the following source snippet sets the timeout to handle a client request to 
 complete within 21 seconds using the 
 Timeout
  attribute of the 
 Client
  type:
  
 func main() {
  
  client := &http.Client{
  
   
  Timeout: 21 * time.Second
  
  }
  
  resp, err := client.Get(
  
   
  ""http://tools.ietf.org/rfc/rfc7540.txt"") if err != nil {
  
   
  fmt.Println(err)
  
   
  return
  
  }
  
  defer resp.Body.Close()
  
  io.Copy(os.Stdout, resp.Body) 
  
 }
  
 golang.fyi/ch11/httpclient2.go
  
 [ 277 ]",NA
Handling client requests and responses,"An 
 http.Request
  value can be explicitly created using the 
 http.NewRequest
  function. A request 
 value can be used to configure HTTP settings, add headers, and specify the content body of 
 the request. The following source snippet uses the 
 http.Request
  type to create a new request 
 which is used to specify the headers sent to the server:
  
 func main() {
  
  client := &http.Client{}
  
  req, err := http.NewRequest(
  
   
  ""GET"", ""http://tools.ietf.org/rfc/rfc7540.txt"", nil, )
  
  req.Header.Add(""Accept"", ""text/plain"")
  
  req.Header.Add(""User-Agent"", ""SampleClient/1.0"")
  
  resp, err := client.Do(req)
  
  if err != nil {
  
   
  fmt.Println(err)
  
   
  return
  
  }
  
  defer resp.Body.Close()
  
  io.Copy(os.Stdout, resp.Body) 
  
 }
  
 golang.fyi/ch11/httpclient3.go",NA
A simple HTTP server,"The HTTP package provides two main components to accept HTTP requests and serve 
 responses:
  
 The 
 http.Handler
  interface
  
 The 
 http.Server
  type",NA
The default server,"It should be noted that the HTTP package includes a default server that can be used in 
 simpler cases when there is no need for configuration of the server. The following 
  
 abbreviated code snippet starts a simple server without explicitly creating a server variable:
  
 type msg string
  
 func (m msg) ServeHTTP(
  
   
  resp http.ResponseWriter, req *http.Request) { 
 resp.Header().Add(""Content-Type"", ""text/html"") 
 resp.WriteHeader(http.StatusOK)
  
  fmt.Fprint(resp, m) 
  
 }
  
  func main() {
  
  msgHandler := msg(""Hello from high above!"") 
 http.ListenAndServe("":4040"", msgHandler) 
  
 }
  
 golang.fyi/ch11/httpserv2.go",NA
Routing requests with http.ServeMux,"The 
 http.Handler
  implementation introduced in the previous section is not sophisticated.
  
 No matter what URL path is sent with the request, it sends the same response back to the 
 client. That is not very useful. In most cases, you want to map each path of a request URL to 
 a different response.
  
 Fortunately, the HTTP package comes with the 
 http.ServeMux
  type which can multiplex 
 incoming requests based on URL patterns. When an 
 http.ServeMux
  handler receives a 
 request, associated with a URL path, it dispatches a function that is mapped to that URL. 
 The following abbreviated code snippet shows 
 http.ServeMux
  variable 
 mux
  configured to 
 handle two URL paths 
 ""/hello""
  and 
 ""/goodbye""
 :
  
 func main() {
  
  mux := http.NewServeMux()
  
  hello := func(resp http.ResponseWriter, req *http.Request) {
   
  
 resp.Header().Add(""Content-Type"", ""text/html"")
  
   
  resp.WriteHeader(http.StatusOK)
  
   
  fmt.Fprint(resp, ""Hello from Above!"")
  
  }
  
  goodbye := func(resp http.ResponseWriter, req *http.Request) {
  
  
 resp.Header().Add(""Content-Type"", ""text/html"")
  
  
  resp.WriteHeader(http.StatusOK)
  
  
  fmt.Fprint(resp, ""Goodbye, it's been real!"")
  
  }
  
  mux.HandleFunc(""/hello"", hello)
  
  mux.HandleFunc(""/goodbye"", goodbye)
  
  http.ListenAndServe("":4040"", mux) 
  
 }
  
 golang.fyi/ch11/httpserv3.go",NA
The default ServeMux,"It is worth pointing out that the HTTP package makes available a default ServeMux 
 internally. When used, it is not necessary to explicitly declare a ServeMux variable. Instead 
 the code uses the package function, 
 http.HandleFunc,
  to map a path to a handler function as 
 illustrated in the following code snippet:
  
 func main() {
  
  hello := func(resp http.ResponseWriter, req *http.Request) { ...
  
  }
  
  goodbye := func(resp http.ResponseWriter, req *http.Request) { ...
  
  }
  
  http.HandleFunc(""/hello"", hello)
  
  http.HandleFunc(""/goodbye"", goodbye)
  
  http.ListenAndServe("":4040"", nil) 
  
 }
  
 golang.fyi/ch11/httpserv4.go
  
 To launch the server, the code calls 
 http.ListenAndServe("":4040"", nil)
  where the ServerMux 
 parameter is set to 
 nil
 . This implies that the server will default to the per-declared 
 package instance of http.ServeMux to handle incoming requests.
  
 [ 283 ]",NA
A JSON API server,"Armed with the information from the last section, it is possible to use the HTTP package to 
 create services over HTTP. Earlier we discussed the perils of creating services using raw 
 TCP directly when we created a server for our global monetary currency service. In this 
 section, we explore how to create an API server for the same service using HTTP as the 
 underlying protocol. The new HTTP-based service has the following design goals:
  
 Use HTTP as the transport protocol
  
 Use JSON for structured communication between client and server
  
 Clients query the server for currency information using JSON-formatted requests
  
 The server respond using JSON-formatted responses
  
 The following shows the code involved in the implementation of the new service. This time, 
 the server will use the 
 curr1
  package (see 
 github.com/vladimirvivien/learning-go /ch11/curr1
 ) to 
 load and query ISO 4217 currency data from a local CSV file.
  
 The code in the curr1 package defines two types, 
 CurrencyRequest
  and 
 Currency
 , 
 intended to represent the client request and currency data returned by the server, 
 respectively as listed here:
  
 type Currency struct {
  
  Code    string `json:""currency_code""` Name    string 
 `json:""currency_name""` Number  string 
 `json:""currency_number""` Country string 
 `json:""currency_country""` }
  
 type CurrencyRequest struct {
  
  Get   string `json:""get""`
  
  Limit int    `json:limit` 
  
 }
  
 golang.fyi/ch11/curr1/currency.go
  
 Note that the preceding struct types shown are annotated with tags that describe the JSON 
 properties for each field. This information is used by the JSON encoder to encode the key 
 name of JSON objects (see 
 Chapter 10
 , 
 Data IO in Go
 , for detail on encoding). The 
  
 remainder of the code, listed in the following snippet, defines the functions that set up the 
 server and the handler function for incoming requests:
  
 import (
  
  ""encoding/json""
  
  ""fmt""",NA
Testing the API server with cURL,"Because the server is implemented over HTTP, it can easily be tested with any client-side 
 tools that support HTTP. For instance, the following shows how to use the
 cURL
  command 
 line tool (
 http://curl.haxx.se/
 ) to connect to the API end-point and retrieve currency 
 information about the 
 Euro
 :
  
 $> curl -X POST -d '{""get"":""Euro""}' http://localhost:4040/currency 
 [ 
  
 ...
  
  {
  
   
  ""currency_code"": ""EUR"",
  
   
  ""currency_name"": ""Euro"",
  
   
  ""currency_number"": ""978"",
  
   
  ""currency_country"": ""BELGIUM""
  
  },
  
  {
  
   
  ""currency_code"": ""EUR"",
  
   
  ""currency_name"": ""Euro"",
  
   
  ""currency_number"": ""978"",
  
   
  ""currency_country"": ""FINLAND""
  
  },
  
  {
  
   
  ""currency_code"": ""EUR"",
  
   
  ""currency_name"": ""Euro"",
  
   
  ""currency_number"": ""978"",
  
   
  ""currency_country"": ""FRANCE""
  
  }, 
  
 ...
  
 ]",NA
An API server client in Go,"An HTTP client can also be built in Go to consume the service with minimal efforts. As is 
 shown in the following code snippet, the client code uses the 
 http.Client
  type to 
 communicate with the server. It also uses the 
 encoding/json
  sub-package to decode 
 incoming data (note that the client also makes use of the 
 curr1
  package, shown earlier, 
 which contains the types needed to communicate with the server):
  
 import (
  
  ""bytes""
  
  ""encoding/json""
  
  ""fmt""
  
  ""net/http""
  
  "" github.com/vladimirvivien/learning-go/ch11/curr1"" )
  
 func main() {
  
  var param string
  
  fmt.Print(""Currency> "")
  
  _, err := fmt.Scanf(""%s"", &param)
  
  buf := new(bytes.Buffer)
  
  currRequest := &curr1.CurrencyRequest{Get: param} err = 
 json.NewEncoder(buf).Encode(currRequest) if err != nil {
  
  
  fmt.Println(err)
  
  
  return
  
  }
  
  // send request
  
  client := &http.Client{}
  
  req, err := http.NewRequest(
  
  
  ""POST"", ""http://127.0.0.1:4040/currency"", buf) if err != nil {
  
  
  fmt.Println(err)
  
  
  return
  
  }
  
  resp, err := client.Do(req)
  
  if err != nil {
  
 [ 287 ]",NA
A JavaScript API server client,"So far, we have seen how to use the API service using the 
 cURL
  command-line tool and a 
 native Go client. This section shows the versatility of using HTTP to implement networked 
 services by showcasing a web-based JavaScript client. In this approach, the client is a web-
 based GUI that uses modern HTML, CSS, and JavaScript to create an interface that interacts 
 with the API server.
  
 First, the server code is updated with an additional handler to serve the static HTML file 
 that renders the GUI on the browser. This is illustrated in the following code:
  
 // serves HTML gui 
  
 func gui(resp http.ResponseWriter, req *http.Request) { file, err := 
 os.Open(""./currency.html"")
  
  if err != nil {
  
   
  resp.WriteHeader(http.StatusInternalServerError)
  
  
  
 fmt.Println(err)
  
   
  return
  
  }",NA
Summary,"This chapter condenses several important notions about creating networked services in Go. 
 It starts with a walkthrough of Go's 
 net
  package including the 
 net.Conn
  type to create a 
 connection between network nodes, the 
 net.Dial
  function to connect to a remote service, and 
 the 
 net.Listen
  function to handle incoming connections from a client. The chapter continues 
 to cover different implementations of clients and server programs and shows the 
 implications of creating custom protocols directly over raw TCP versus using an existing 
 protocol such as HTTP with JSON data format.
  
 The next chapter takes a different direction. It explores the packages, types, functions, and 
 tools that are available in Go to facilitate source code testing.
  
 [ 292 ]",NA
Code Testing ,NA,NA
,"Testing is a critical ritual of modern software development practices. Go brings testing 
 directly into the development cycle by offering an API and command-line tool to seamlessly 
 create and integrate automated test code. Here we will cover the Go testing suite, including 
 the following:
  
 The Go test tool
  
 Writing Go tests
  
 HTTP testing
  
 Test coverage
  
 Code benchmark",NA
The Go test tool,"Prior to writing any test code, let's take a detour to discuss the tooling for automated testing 
 in Go. Similar to the 
 go build
  command, the 
 go test
  command is designed to compile and 
 exercise test source files in specified packages, as illustrated in the following command:
  
 $> go test .",NA
Test file names,"The test command uses the import path standard (see 
 Chapter 6
 , 
 Go Packages and Programs
 )
  
 to specify which packages to test. Within a specified package, the test tool will compile all 
 files with the 
 *_test.go
  name pattern. For instance, assuming that we have a project that
  
 has a simple implementation of a mathematical vector type in a file called 
 vec.go
 , a
  
 sensible name for its test file would be 
 vec_test.go
 .",NA
Test organization,"Traditionally, test files are kept in the same package (directory) as the code being tested.
  
 This is because there is no need to separate tests files, as they are excluded from the 
 compiled program binary. The following shows the directory layout for a typical Go 
 package, in this instance the 
 fmt
  package from the standard library. It shows all of the test
  
 files for the package in the same directory as the regular source code:
  
 $>tree go/src/fmt/
  
 ├── doc.go
  
 ├── export_test.go
  
 ├── fmt_test.go
  
 ├── format.go
  
 ├── norace_test.go
  
 ├── print.go
  
 ├── race_test.go
  
 ├── scan.go
  
 ├── scan_test.go
  
 └── stringer_test.go",NA
Writing Go tests,"A Go test file is simply a set of functions with the following signature:
  
 func Test<Name>(*testing.T)
  
 Here, 
 <Name>
  is an arbitrary name that reflects the purpose of the test. The test functions are 
 intended to exercise a specific functional unit (or unit test) of the source code.
  
 Before we write the test functions, let us review the code that will be tested. The following 
 source snippet shows a simple implementation of a mathematical vector with 
 Add
 , 
 Sub
 , and 
 Scale
  methods (see the full source code listed at 
 https://github.com/vladimirvivien/l earning-
 go/ch12/vector/vec.go
 ). Notice that each method implements a specific behavior as a unit of 
 functionality, which will make it easy to test:
  
 type Vector interface {
  
  Add(other Vector) Vector
  
  Sub(other Vector) Vector
  
  Scale(factor float64)
  
  ...
  
 }
  
 func New(elems ...float64) SimpleVector {
  
  return 
 SimpleVector(elems) 
  
 }
  
 type SimpleVector []float64
  
 func (v SimpleVector) Add(other Vector) Vector { 
 v.assertLenMatch(other)
  
  otherVec := other.(SimpleVector)
  
  result := make([]float64, len(v))
  
  for i, val := range v {
  
   
  result[i] = val + otherVec[i]
  
  }
  
  return SimpleVector(result) 
  
 }",NA
The test functions,"The test source code in file 
 vec_test.go
  defines a series of functions that exercise the 
 behavior of type 
 SimpleVector
  (see the preceding section) by testing each of its methods 
 independently:
  
 import ""testing""
  
 func TestVectorAdd(t *testing.T) {
  
  v1 := New(8.218, -9.341)
  
  v2 := New(-1.129, 2.111)
  
  v3 := v1.Add(v2)
  
  expect := New(
  
  
  v1[0]+v2[0],
  
  
  v1[1]+v2[1],
  
  )
  
  if !v3.Eq(expect) {
  
  
  t.Logf(""Addition failed, expecting %s, got %s"",
   
  expect, v3)
  
  
  t.Fail()
  
  }
  
  t.Log(v1, ""+"", v2, v3) 
  
 }
  
 func TestVectorSub(t *testing.T) {
  
  v1 := New(7.119, 8.215)
  
 [ 296 ]",NA
Running the tests,"As mentioned in the introductory section of this chapter, test functions are executed using 
 the 
 go test
  command-line tool. For instance, if we run the following command from within 
 the package vector, it will automatically run all of the test functions of that package:
  
 $> cd vector 
  
 $> go test .
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.001s",NA
Filtering executed tests,"During the development of a large set of test functions, it is often desirable to focus on a 
 function (or set of functions) during debugging phases. The Go test command-line tool 
 supports the 
 -run
  flag, which specifies a regular expression that executes only functions 
 whose names match the specified expression. The following command will only execute test 
 function 
 TestVectorAdd
 :
  
 $> go test -run=VectorAdd -v 
  
 === RUN   TestVectorAdd
  
 --- PASS: TestVectorAdd (0.00s) 
  
 PASS 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.025s
  
 The use of the 
 -v
  flag confirms that only one test function, 
 TestVectorAdd
 , has been 
 executed. As another example, the following executes all test functions that end with 
 VectorA.*$
  or match function name 
 TestVectorMag
 , while ignoring everything else:
  
 > go test -run=""VectorA.*$|TestVectorMag"" -v 
  
 === RUN   TestVectorAdd
  
 --- PASS: TestVectorAdd (0.00s) 
  
 === RUN   TestVectorMag
  
 --- PASS: TestVectorMag (0.00s) 
  
 === RUN   TestVectorAngle
  
 --- PASS: TestVectorAngle (0.00s) 
  
 PASS 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.043s",NA
Test logging,"When writing new or debugging existing test functions, it is often helpful to print 
  
 information to a standard output. Type 
 testing.T
  offers two logging methods: 
 Log
 , which 
 uses a default formatter, and 
 Logf
 , which formats its output using formatting verbs (as 
 defined in package to 
 fmt
 ). For instance, the following test function snippet from the vector 
 example shows the code logging information with 
 t.Logf(""Vector = %v; Unit vector = %v\n"", v, 
 expect)
 :
  
 func TestVectorUnit(t *testing.T) {
  
  v := New(5.581, -2.136)
  
  mag := v.Mag()
  
  expect := New((1/mag)*v[0], (1/mag)*v[1])
  
  if !v.Unit().Eq(expect) {
  
  
  t.Logf(""Vector Unit failed, expecting %s, got %s"",
  
  
  expect, 
 v.Unit())
  
  
  t.Fail()
  
  }
  
  t.Logf(""Vector = %v; Unit vector = %v\n"", v, expect) }
  
 golang.fyi/ch12/vector/vec_test.go
  
 As seen previously, the Go test tool runs tests with minimal output unless there is a test 
 failure. However, the tool will output test logs when the verbose flag 
 -v
  is provided. For 
 instance, running the following in package vector will mute all logging statements:
  
 > go test -run=VectorUnit 
  
 PASS 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.005s
  
 When the verbose flag 
 -v
  is provided, as shown in the following command, the test runtime 
 prints the output of the logs as shown:
  
 $> go test -run=VectorUnit -v 
  
 === RUN   TestVectorUnit
  
 --- PASS: TestVectorUnit (0.00s) 
  
 vec_test.go:100: Vector = [5.581,-2.136]; Unit vector = 
  
 [0.9339352140866403,-0.35744232526233] 
  
 PASS 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.001s",NA
Reporting failure,"By default, the Go test runtime considers a test a success if the test function runs and 
 returns normally without a panic. For example, the following test function is broken, since 
 its expected value is not properly calculated. The test runtime, however, will always report 
 it as passing because it does not include any code to report the failure:
  
 func TestVectorDotProd(t *testing.T) {
  
  
  v1 := New(7.887, 4.138).(SimpleVector)
  
  
  v2 := New(-8.802, 6.776).(SimpleVector)
  
  
  actual := v1.DotProd(v2)
  
  
  expect := v1[0]*v2[0] - v1[1]*v2[1]
  
  
  if actual != expect {
  
  
  
  t.Logf(""DotPoduct failed, expecting %d, got %d"",
   
  expect, 
 actual)
  
  
  } 
  
 }
  
 golang.fyi/ch12/vec_test.go
  
 This false positive condition may go unnoticed, especially if the verbose flag is turned off, 
 minimizing any visual clues that it is broken:
  
 $> go test -run=VectorDot 
  
 PASS 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.001s
  
 One way the previous test can be fixed is by using the 
 Fail
  method from type 
 testing.T 
 to 
 signal failure, as shown in the following snippet:
  
 func TestVectorDotProd(t *testing.T) { 
  
 ...
  
  
  if actual != expect {
  
  
  
  t.Logf(""DotPoduct failed, expecting %d, got %d"",
   
  expect, 
 actual)
  
  
  
  t.Fail()
  
  
  } 
  
 }",NA
Skipping tests,"It is sometimes necessary to skip test functions due to a number of factors such as 
 environment constraints, resource availability, or inappropriate environment settings. The 
 testing API makes it possible to skip a test function using the 
 SkipNow
  method from type 
 testing.T
 . The following source code snippet will only run the test function when the 
 arbitrary operating system environment variable named 
 RUN_ANGLE
  is set. Otherwise, it 
 will skip the test:
  
 func TestVectorAngle(t *testing.T) {
  
  if os.Getenv(""RUN_ANGLE"") == """" {",NA
Table-driven tests,"One technique you often encounter in Go is the use of table-driven tests. This is where a set 
 of input and expected output is stored in a data structure, which is then used to cycle 
 through different test scenarios. For instance, in the following test function, the 
 cases 
 variable, of type 
 []struct{vec SimpleVector; expected float64}
 , to store several vector values and 
 their expected magnitude values used to test the vector method 
 Mag
 :
  
 func TestVectorMag(t *testing.T) {
  
  cases := []struct{
  
   
  vec SimpleVector
  
   
  expected float64
  
  }{
  
  
  {New(1.2, 3.4), math.Sqrt(1.2*1.2 + 3.4*3.4)},
  
  
  {New(-0.21, 7.47), math.Sqrt(-0.21*-0.21 + 7.47*7.47)},
  
  {New(1.43, -5.40), 
 math.Sqrt(1.43*1.43 + -5.40*-5.40)},
  
  {New(-2.07, -9.0), math.Sqrt(-2.07*-2.07 + -
 9.0*-9.0)}, }
  
  for _, c := range cases {
  
  
  mag := c.vec.Mag()
  
  
  if mag != c.expected {
  
   
  
  t.Errorf(""Magnitude failed, execpted %d, got %d"",
  
  
   
  c.expected, mag)
  
  
  }
  
  } 
  
 }
  
 golang.fyi/ch12/vector/vec.go
  
 With each iteration of the loop, the code tests the value calculated by the 
 Mag
  method 
 against an expected value. Using this approach, we can test several combinations of input 
 and their respective output, as is done in the preceding code. This technique can be 
 expanded as necessary to include more parameters. For instance, a name field can be used 
 to name each case, which is useful when the number of test cases is large. Or, to be even 
 more fancy, one can include a function field in the test case struct to specify custom logic to 
 use for each respective case.",NA
HTTP testing,"In 
 Chapter 11
 , 
 Writing Networked Services
 , we saw that Go offers first-class APIs to build client 
 and server programs using HTTP. The 
 net/http/httptest
  sub-package, part of the Go 
 standard library, facilitates the testing automation of both HTTP server and client code, as 
 discussed in this section.
  
 To explore this space, we will implement a simple API service that exposes the vector 
 operations (covered in earlier sections) as HTTP endpoints. For instance, the following 
 source snippet partially shows the methods that make up the server (for a complete listing, 
 see 
 https://github.com/vladimirvivien/learning-go/ch12/service/serv.go)
 :
  
 package main
  
 import (
  
  ""encoding/json""
  
  ""fmt""
  
  ""net/http""
  
  ""github.com/vladimirvivien/learning-go/ch12/vector"" 
  
 ) 
  
 func add(resp http.ResponseWriter, req *http.Request) {
  
  var params []vector.SimpleVector
  
  if err := json.NewDecoder(req.Body).Decode(&params);
  
  
  err != nil {
  
   
  
  resp.WriteHeader(http.StatusBadRequest)
  
   
  
  fmt.Fprintf(resp, ""Unable to parse request: %s\n"", err)
  
  
  
  
 return
  
  }
  
  if len(params) != 2 {
  
   
  
  resp.WriteHeader(http.StatusBadRequest)
  
   
  
  fmt.Fprintf(resp, ""Expected 2 or more vectors"")
  
   
  
  return
  
  }
  
  result := params[0].Add(params[1])
  
  if err := json.NewEncoder(resp).Encode(&result); err != nil {
   
  
  
 resp.WriteHeader(http.StatusInternalServerError)
  
   
  
  fmt.Fprintf(resp, err.Error())
  
   
  
  return
  
  } 
  
 } 
  
 ...
  
 func main() {
  
  mux := http.NewServeMux()
  
  mux.HandleFunc(""/vec/add"", add)
  
  mux.HandleFunc(""/vec/sub"", sub)",NA
Testing HTTP server code,"When writing HTTP server code, you will undoubtedly run into the need to test your code, 
 in a robust and repeatable manner, without having to set up some fragile code harness to 
 simulate end-to-end testing. Type 
 httptest.ResponseRecorder
  is designed specifically to 
 provide unit testing capabilities for exercising the HTTP handler methods by inspecting 
 state changes to the http.ResponseWriter in the tested function. For instance, the following 
 snippet uses 
 httptest.ResponseRecorder
  to test the server's 
 add
  method:
  
 import (
  
  ""net/http""
  
  ""net/http/httptest""
  
  ""strconv""
  
  ""strings""
  
  ""testing""
  
  ""github.com/vladimirvivien/learning-go/ch12/vector"" )
  
 func TestVectorAdd(t *testing.T) {
  
  reqBody := ""[[1,2],[3,4]]""
  
  req, err := http.NewRequest(
  
   
  ""POST"", ""http://0.0.0.0/"", strings.NewReader(reqBody)) if err != nil {
  
   
  
  t.Fatal(err)
  
  }
  
  actual := vector.New(1, 2).Add(vector.New(3, 4))
  
  w := httptest.NewRecorder()
  
  add(w, req)
  
 [ 306 ]",NA
Testing HTTP client code,"Creating test code for an HTTP client is more involved, since you actually need a server 
 running for proper testing. Luckily, package 
 httptest
  provides type 
 httptest.Server
  to 
 programmatically create servers to test client requests and send back mock responses to the 
 client.
  
 To illustrate, let us consider the following code, which partially shows the implementation 
 of an HTTP client to the vector server presented earlier (see the full code listing at 
 https:// 
 github.com/vladimirvivien/learning-go/ch12/client/client.go)
 . The 
 add
  method encodes the 
 parameters 
 vec0
  and 
 vec2
  of type 
 vector.SimpleVector
  as JSON objects, which are sent to the 
 server using 
 c.client.Do(req)
 . The response is decoded from the JSON array into type 
 vector.SimpleVector
  assigned to variable 
 result
 :
  
 type vecClient struct {
  
   
  svcAddr string
  
   
  client *http.Client 
  
 } 
  
 func (c *vecClient) add(
  
  vec0, vec1 vector.SimpleVector) (vector.SimpleVector, error) { uri := c.svcAddr + 
 ""/vec/add""
  
  // encode params
  
  var body bytes.Buffer
  
  
  params := []vector.SimpleVector{vec0, vec1}
  
  if err := json.NewEncoder(&body).Encode(&params); err != nil {",NA
Test coverage,"When writing tests, it is often important to know how much of the actual code is getting 
 exercised (or covered) by the tests. That number is an indication of the penetration of the 
 test logic against the source code. Whether you agree or not, in many software development 
 practices, test coverage is a critical metric as it is a measure of how well the code is tested.
  
 Fortunately, the Go test tool comes with a built-in coverage tool. Running the Go test 
 command with the 
 -cover
  flag instruments the original source code with coverage logic. It 
 then runs the generated test binary, providing a summary of the overall coverage profile of 
 the package, as shown in the following:
  
 $> go test -cover 
  
 PASS 
  
 coverage: 87.8% of statements 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     0.028s
  
 The result shows a well-tested code with a coverage number of 
 87.8%
 . We can use the test 
 tool to extract more details about the section of the code that is tested. To do this, we use 
 the
 -coverprofile
  flag to record coverage metrics to a file, as shown:
  
 $> go test -coverprofile=cover.out",NA
The cover tool,"Once the coverage data is saved, it can be presented in a textual tab-formatted table using 
 the 
 go tool cover
  command. The following shows a partial output of the breakdown of the 
 coverage metrics for each tested function in the coverage file generated previously:
  
 $> go tool cover -func=cover.out 
  
 ...
  
 learning-go/ch12/vector/vec.go:52:  Eq          100.0% learning-
 go/ch12/vector/vec.go:57:  Eq2         83.3% learning-
 go/ch12/vector/vec.go:74:  Add         100.0% learning-
 go/ch12/vector/vec.go:85:  Sub         100.0% learning-
 go/ch12/vector/vec.go:96:  Scale       100.0% ...
  
 The 
 cover
  tool can overlay the coverage metrics over the actual code, providing a visual 
 aid to show the covered (and uncovered) portion of the code. Use the 
 -html
  flag to 
 generate an HTML page using the coverage data gathered previously:
  
  $> go tool cover -html=cover.out",NA
Code benchmark,"The purpose of benchmarking is to measure a code's performance. The Go test command-
 line tool comes with support for the automated generation and measurement of benchmark 
 metrics. Similar to unit tests, the test tool uses benchmark functions to specify what portion 
 of the code to measure. The benchmark function uses the following function naming pattern 
 and signature:
  
 func Benchmark<Name>(*testing.B)
  
 Benchmark functions are expected to have names that start with 
 benchmark
  and accept a 
 pointer value of type 
 *testing.B
 . The following shows a function that benchmarks the 
 Add
  
 method for type 
 SimpleVector
  (introduced earlier):
  
 import (
  
  
  ""math/rand""
  
  
  ""testing""
  
  
  ""time"" 
  
 ) 
  
 ...
  
 func BenchmarkVectorAdd(b *testing.B) {
  
  r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i < b.N; i++ 
 {
  
   
  v1 := New(r.Float64(), r.Float64())
  
   
  v2 := New(r.Float64(), r.Float64())
  
   
  v1.Add(v2)
  
  } 
  
 }
  
 golang.fyi/ch12/vector/vec_bench_test.go
  
 Go's test runtime invokes the benchmark functions by injecting pointer 
 *testing.B
  as a 
 parameter. That value defines methods for interacting with the benchmark framework such 
 as logging, failure-signaling, and other functionalities similar to type 
 testing.T
 . Type 
 testing.B
  
 also offers additional benchmark-specific elements, including an integer field 
 N
 .
  
 It is intended to be the number of iterations that the benchmark function should use for 
 effective measurements.
  
 The code being benchmarked should be placed within a 
 for
  loop bounded by 
 N
 , as 
 illustrated in the previous example. For the benchmark to be effective, there should be no 
 variances in the size of the input for each iteration of the loop. For instance, in the preceding 
 benchmark, each iteration always uses a vector of size 
 2
  (while the actual values of the 
 vectors are randomized).",NA
Running the benchmark,"Benchmark functions are not executed unless the test command-line tool receives the flag 
 -
 bench
 . The following command runs all the benchmarks functions in the current package:
  
 $> go test -bench=.
  
 PASS 
  
 BenchmarkVectorAdd-2           2000000           761 ns/op 
  
 BenchmarkVectorSub-2           2000000           788 ns/op 
  
 BenchmarkVectorScale-2         5000000           269 ns/op 
  
 BenchmarkVectorMag-2           5000000           243 ns/op 
  
 BenchmarkVectorUnit-2          3000000           507 ns/op 
  
 BenchmarkVectorDotProd-2       3000000           549 ns/op 
  
 BenchmarkVectorAngle-2         2000000           659 ns/op 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     14.123s
  
 Before dissecting the benchmark result, let us understand the previously issued command.
  
 The 
 go test -bench=.
  command first executes all the test functions in the package followed 
 by all the benchmark functions (you can verify this by adding the verbose flag 
 -v 
 to the 
 command).
  
 Similar to the 
 -run
  flag, the 
 -bench
  flag specifies a regular expression used to select the 
 benchmark functions that get executed. The 
 -bench=.
  flag matches the name of all 
 benchmark functions, as shown in the previous example. The following, however, only runs 
 benchmark functions that contain the pattern 
 ""VectorA""
  in their names. This includes the 
 BenchmarkVectroAngle()
  and 
 BenchmarkVectorAngle()
  functions:
  
 $> go test -bench=""VectorA"" 
  
 PASS 
  
 BenchmarkVectorAdd-2     2000000           764 ns/op 
  
 BenchmarkVectorAngle-2   2000000           665 ns/op 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     4.396s",NA
Skipping test functions,"As mentioned previously, when benchmarks are executed, the test tool will also run all test 
 functions. This may be undesirable, especially if you have a large number of tests in your 
 package. A simple way to skip the test functions during benchmark execution is to set the 
 -
 run
  flag to a value that matches no test functions, as shown in the following:
  
 > go test -bench=. -run=NONE -v 
  
 PASS 
  
 BenchmarkVectorAdd-2           2000000           791 ns/op 
 BenchmarkVectorSub-2           2000000           777 ns/op",NA
The benchmark report,"Unlike tests, a benchmark report is always verbose and displays several columns of metrics, 
 as shown in the following:
  
 $> go test -run=NONE -bench=""Add|Sub|Scale"" 
  
 PASS 
  
 BenchmarkVectorAdd-2     2000000           800 ns/op 
  
 BenchmarkVectorSub-2     2000000           798 ns/op 
  
 BenchmarkVectorScale-2   5000000           266 ns/op 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     6.473s
  
 The first column contains the names of the benchmark functions, with each name suffixed 
 with a number that reflects the value of 
 GOMAXPROCS
 , which can be set at test time using 
 the 
 -cpu
  flag (relevant for running benchmarks in parallel).
  
 The next column displays the number of iterations for each benchmark loop. For instance, 
 in the previous report, the first two benchmark functions looped 2 million times, while the 
 final benchmark function iterated 5 million times. The last column of the report shows the 
 average time it takes to execute the tested function. For instance, the 5 million calls to the 
 Scale
  method executed in benchmark function 
 BenchmarkVectorScale
  took on average 266 
 nanoseconds to complete.",NA
Adjusting N,"By default, the test framework gradually adjusts 
 N
  to be large enough to arrive at stable and 
 meaningful metrics over a period of 
 one second
 . You cannot change 
 N
  directly. However, you 
 can use flag 
 -benchtime
  to specify a benchmark run time and thus influence the number of 
 iterations during a benchmark. For instance, the following runs the benchmark for a period 
 of 
 5
  seconds:
  
 > go test -run=Bench -bench=""Add|Sub|Scale"" -benchtime 5s PASS 
  
 BenchmarkVectorAdd-2    10000000           784 ns/op",NA
Comparative benchmarks,"Another useful aspect of benchmarking code is to compare the performance of different 
 algorithms that implement similar functionalities. Exercising the algorithms using 
 performance benchmarks will indicate which of the implementations may be more 
 compute- and memory-efficient.
  
 For instance, two vectors are said to be equal if they have the same magnitude and same 
 direction (or have an angle value of zero between them). We can implement this definition 
 using the following source snippet:
  
 const zero = 1.0e-7 
  
 ...
  
 func (v SimpleVector) Eq(other Vector) bool { ang := v.Angle(other)
  
  if math.IsNaN(ang) {
  
   
  return v.Mag() == other.Mag()
  
  }
  
  return v.Mag() == other.Mag() && ang <= zero }
  
 golang.fyi/ch12/vector/vec.go
  
 When the preceding method is benchmarked, it yields to the following result. Each of its 3 
 million iterations takes an average of half a millisecond to run:
  
 $> go test -run=Bench -bench=Equal1 
  
 PASS 
  
 BenchmarkVectorEqual1-2  3000000           454 ns/op 
  
 ok    github.com/vladimirvivien/learning-go/ch12/vector     1.849s",NA
Summary,"This chapter provided a broad introduction to the practice of writing tests in Go. It 
 discussed several key topics, including the use of the 
 go test
  tool to compile and execute 
 automated tests. Readers learned how to write test functions to ensure their code is 
 properly tested and covered. The chapter also discussed the topic of testing HTTP clients 
 and servers. Finally, the chapter introduced the topic of benchmarking as a way to 
 automate, analyze, and measure code performance using built-in Go tools.",NA
Index,NA,NA
A ,"address operator  
 89 
  
 anonymous field, struct
  
  about  
 175
  
  promoted fields  
 176 
  
 arithmetic operators  
 49 
  
 array
  
  about  
 148
 , 
 149
  
  array traversal  
 153
  
  as parameters  
 154
 , 
 155
  
  initialization  
 149
 , 
 150
 , 
 151
  
  length and capacity  
 153
  
  named array types, declaring  
 151
  
 traversal  
 154
  
  using  
 152 
  
 assignment operators  
 50 
  
 attributes, slice
  
  a capacity  
 158
  
  a length  
 158
  
  a pointer  
 158",NA
B ,"bitwise operators  
 50 
  
 blank identifier  
 139
  
  about  
 32
  
  package imports, muting  
 32
  
  unwanted function results, muting  
 33 
 Boolean type  
 84 
  
 break statement  
 73
 , 
 74 
  
 buffered IO
  
  about  
 249
  
  buffer, scanning  
 251
  
  buffered writers and readers  
 250 
  
 bufio package
  
  reference  
 249 
  
 built-in identifiers
  
  about  
 33
  
  functions  
 34
  
  types  
 33
  
  values  
 34",NA
C ,"code benchmark
  
  about  
 312
  
  benchmark report  
 314
  
  comparative benchmarks  
 315
 , 
 316
  N, 
 adjusting  
 314
  
  running  
 313
  
  test functions, skipping  
 313 
  
 code coverage  
 22 
  
 code testing
  
  about  
 293 
  
 comparison operators  
 51 
  
 complex number types
  
  complex128  
 82
  
  complex64  
 82 
  
 composite types
  
  about  
 17
 , 
 148
  
  array  
 148
  
  map  
 167
  
  slice  
 155
  
  struct  
 172 
  
 constant enumeration
  
  about  
 46
  
  default enumeration type, overriding  
 47
  
 enumerated values, skipping  
 48
  
  iota, using in expressions  
 47 
  
 constants
  
  about  
 42
  
  declaration block  
 45
  
  literals  
 42
  
  typed constants  
 43
  
  untyped constants  
 43",NA
D ,"data
  
  binary encoding, with gob  
 254
  
 custom decoding  
 260
  
  custom encoding  
 260
  
  decoding  
 253
  
  encoding  
 253
  
  encoding, as JSON  
 256 
  
 decrement operators  
 49 
  
 default ServeMux  
 283 
  
 documentation
  
  about  
 23
  
  URL  
 23 
  
 dot identifier  
 139",NA
E ,"encoding package
  
  reference  
 253 
  
 error
  
  error type  
 114
  
  example, reference link  
 111
  
 handling  
 110
 , 
 114
  
  signaling  
 111
  
  signalling  
 110
 , 
 113 
  
 Euclidian division algorithm
  
  reference link  
 103 
  
 expressions
  
  iota, using  
 47 
  
 extensive library  
 24",NA
F ,"files
  
  creating  
 241
  
  opening  
 242
  
  reading  
 243
  
  standard error  
 245
  
 standard input  
 245
  
  reference  
 246 
  
 for statements
  
  about  
 66
  
  for condition  
 66
  
  infinite loop  
 67
  
  range  
 70
 , 
 71
  
  traditional for statement  
 68
 , 
 69 
  
 formatted IO, with fmt
  
  about  
 246
  
  io.Reader, reading from  
 247
  
  io.Writer interfaces, printing to  
 246
  
 standard input, reading from  
 249
  
 standard output, printing to  
 247 
 function calls
  
  defer, using  
 117
  
  deferring  
 115 
  
 function result parameters
  
  about  
 103
  
  function result parameters  
 105
  
  named result parameters  
 104 
  
 functions
  
  about  
 15
  
  panic recovery  
 119
 , 
 120
 , 
 121
  
  panicking  
 117
 , 
 118",NA
G ,"Go functions
  
  about  
 97
 , 
 99
  
  declaration  
 98
  
  function type  
 101
 , 
 102
  
  result parameters  
 103
  
  signature  
 101
  
  variadic parameters  
 102
 , 
 103 
 Go package
  
  about  
 122
 , 
 123
 , 
 124
  
  import path  
 127
  
  workspace  
 124
 , 
 125 
  
 Go Playground
  
 [ 319 ]",NA
H ,"Hello World program
  
  writing  
 12 
  
 higher-order functions
  
  about  
 109 
  
 HTTP package
  
  about  
 275
  
  client requests, handling  
 278
  
  http.Client type  
 275
 , 
 277
  
  http.Client type, configuring  
 277
 , 
 278
  
 requests, routing with http.ServeMux  
 282
  
 responses, handling  
 279
  
  simple HTTP server  
 279
 , 
 280
 , 
 281 
  
 HTTP testing
  
  HTTP client code, testing  
 307
 , 
 309
  
  HTTP server code, testing  
 306 
  
 http.Client struct  
 275",NA
I ,"IDE plugins
  
  URL  
 11 
  
 identifiers
  
  about  
 32
  
  attributes  
 32
  
  blank identifier  
 32
  
  built-in identifiers  
 33 
  
 if statement
  
  about  
 53
  
  initialization  
 57 
  
 import path  
 127 
  
 in-memory IO  
 252 
  
 increment operators  
 50 
  
 io package
  
  reference  
 239
  
  working with  
 239
  
 [ 320 ]",NA
J ,"JSON API server
  
  about  
 284
 , 
 286
  
  API server client, in Go  
 287
  
  JavaScript API server client  
 288
 , 
 291
  
 testing, with cURL  
 286 
  
 JSON mapping
  
  controlling, with struct tags  
 259",NA
L ,"label identifier  
 73 
  
 logical operators  
 51",NA
M ,"map functions
  
  delete(map,key)  
 171
  
 len(map)  
 171 
  
 map
  
  about  
 167
  
  as parameter  
 171
  
  creating  
 168
  
  functions  
 171
  
  initialization  
 167
 , 
 168
  
 traversal  
 170
  
  using  
 169 
  
 methods  
 18 
  
 multi-file packages  
 130",NA
N ,"named types  
 18 
  
 naming, packages
  
  about  
 131
  
  context, adding to path  
 132
  
 short names, using  
 132
  
 net/http package
  
  reference  
 275 
  
 networked services
  
  writing  
 264 
  
 new() function  
 91 
  
 numeric types
  
  about  
 80
  
  complex number types  
 82
  
  floating point types  
 82
  
  numeric literals  
 82
  
  signed integer types  
 81
  
  unsigned integer types  
 81",NA
O ,"objects, Go  
 18 
  
 operators
  
  about  
 49
  
  arithmetic operators  
 49
  
  assignment operators  
 50
  
  bitwise operators  
 50
  
  comparison operators  
 51
  
  decrement operators  
 49
  
  increment operators  
 49
  
  logical operators  
 51
  
  precedence  
 52 
  
 os package
  
  reference  
 241 
  
 os.OpenFile function
  
  about  
 242
 , 
 243",NA
P ,"package identifier
  
  specifying  
 138 
  
 package visibility
  
  about  
 134
 , 
 135
  
  package member visibility  
 135
  
 [ 321 ]",NA
R ,"remote packages
  
  about  
 146 
  
 remote procedure calls (RPC)  
 253 
 reusable errors
  
  declaration, reference link  
 115 
 rules  
 131 
  
 rune type  
 84
 , 
 85
 , 
 86",NA
S ,"short variable declaration 
 about  
 39
  
  restrictions  
 40
  
  interpreted and raw string literals  
 87 
 struct tags
  
  JSON mapping, controlling with  
 259 
 struct
  
  about  
 172
  
  anonymous field  
 175
  
  as parameters  
 177
 , 
 178
  
  field tags  
 178
  
  fields, accessing  
 173
  
  initialization  
 173
 , 
 174
  
  named struct types, declaring  
 174 
 switch statements
  
  about  
 57
  
  expression switches, using  
 59
  
 [ 322 ]",NA
T ,"TCP API server
  
  about  
 269
 , 
 270
 , 
 272
  
  connecting to, with Go  
 273
  
 connecting to, with telnet  
 272 
 test coverage
  
  about  
 310
  
  cover tool  
 310
 , 
 311 
  
 testing  
 22 
  
 type
  
  conversion, scenarios  
 96
  
  converting  
 94
 , 
 96
  
  declaring  
 93
  
  uint64  
 81
  
  uint8  
 81
  
  uintpr  
 81 
  
 untyped constants
  
  about  
 43
  
  assigning  
 44",NA
V ,"variables
  
  about  
 34
  
  declaration  
 34
  
  declaration block  
 42
  
  initialized declaration  
 36
  
  scope  
 40
  
  short variable declaration  
 39
  
 types, omitting  
 37
  
  visibility  
 40
  
  zero-value  
 36
  
  
 typed constants  
 43",NA
U ,"unsigned integer types 
 byte  
 81
  
  uint  
 81
  
  uint16  
 81
  
  uint32  
 81
  
 variadic (variable length arguments)  
 102",NA
W ,"workspace, Go package
  
  about  
 124
 , 
 125
  
  bin directory  
 125
  
  creating  
 126
 , 
 127
  
  pkg directory  
 126
  
  src directory  
 126",NA
