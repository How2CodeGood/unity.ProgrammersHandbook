Larger Text,Smaller Text,Symbol
Programming in Go,NA,NA
Developer’s Library Series,"Visit 
 developers-library.com 
 for a complete list of available products",NA
T,"he 
 Developer’s Library Series
  from Addison-Wesley provides 
 practicing programmers with unique, high-quality references and 
  
 tutorials on the latest programming languages and technologies they use in 
 their daily work. All books in the Developer’s Library are written by expert 
 technology practitioners who are exceptionally skilled at organizing and 
 presenting information in a way that’s useful for other programmers. 
  
 Developer’s Library books cover a wide range of topics, from open-source 
 programming languages and databases, Linux programming, Microsoft,  and 
 Java, to Web development, social networking platforms, Mac/iPhone 
 programming, and Android programming.",NA
Programming in Go ,NA,NA
Creating Applications for the 21st Century,"Mark Summerfield
  
  
 Upper Saddle River, NJ
  ·
  Boston
  ·
  Indianapolis
  ·
  San Francisco
  
 p
  New York
  ·
  Toronto
  ·
  Montreal
  ·
  London
  ·
  Munich
  ·
  Paris
  ·
  Madrid
  p
  
 Capetown
  ·
  Sydney
  ·
  Tokyo
  ·
  Singapore
  ·
  Mexico City",NA
Contents at a Glance,"Tables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 xv 
  
 1 
  
 7 
  
 51 
  
 81 
  
 139 
  
 185 
  
 253 
  
 315 
  
 361 
  
 407 
  
 435 
  
 437 
  
 441 
  
 443
  
 Introduction
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 1. An Overview in Five Examples
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 2. Booleans and Numbers
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 3. Strings
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 
 4. Collection Types
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 5. 
 Procedural Programming
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 6. Object-Oriented Programming
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 7. Concurrent Programming
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 
 8. File Handling
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 9. 
 Packages
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Appendix A. Epilogue
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Appendix B. The Dangers of Software Patents
  
 . . . . . . . . . . . . . . . . . .
  
 Appendix C. Selected Bibliography
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Index
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 www.qtrac.eu/gobook.html",NA
Contents,"Tables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 xv
  
 1 
  
 1 
  
 4 
  
 5
  
 7 
  
 7 
  
 9 
  
 14 
  
 16 
  
 21 
  
 29 
  
 40 
  
 48
  
 51 
  
 51 
  
 53 
  
 54 
  
 56 
  
 57 
  
 59 
  
 61 
  
 64 
  
 70 
  
 72 
  
 73 
  
 75 
  
 78
  
 Introduction
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Why Go?
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 The Structure of the Book
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Chapter 1
 .
  An Overview in Five Examples
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.1. Getting Going . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.2. Editing, Compiling, and Running
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.3. Hello Who? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.4. Big 
 Digits—Two-Dimensional Slices . . . . . . . . . . . . . . . . . . . . . . . . . . 1.5. Stack—
 Custom Types with Methods . . . . . . . . . . . . . . . . . . . . . . . . . . 1.6. Americanise—
 Files, Maps, and Closures . . . . . . . . . . . . . . . . . . . . . .
  
 1.7. Polar to Cartesian—Concurrency
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.8. Exercise
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 2
 .
  Booleans and Numbers
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.1. 
 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.1.1. Constants and Variables
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.1.1.1. Enumerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.2. 
 Boolean Values and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.3. 
 Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3.1. Integer Types
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3.1.1. Big Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.3.2. 
 Floating-Point Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3.2.1. Complex Types
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.4. Example: Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.4.1. Implementing Simple Statistics Functions . . . . . . . . . . . . . . . .
  
 2.4.2. Implementing a Basic HTTP Server . . . . . . . . . . . . . . . . . . . . . . 2.5. 
 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 ix",NA
Tables,"2.1.
  
 2.2.
  
 2.3.
  
 2.4.
  
 2.5.
  
 2.6.
  
 2.7.
  
 2.8.
  
 2.9.
  
 2.10. 
  
 2.11. 
  
 3.1.
  
 3.2.
  
 3.3.
  
 3.4.
  
 3.5.
  
 3.6.
  
 3.7.
  
 3.8.
  
 3.9.
  
 3.10. 
  
 3.11. 
  
 3.12. 
  
 3.13. 
  
 3.14. 
  
 3.15. 
  
 3.16. 
  
 3.17. 
  
 3.18. 
  
 3.19. 
  
 4.1.
  
 Go’s Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 52
  
 Go’s Predefined Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 52
  
 Boolean and Comparison Operators . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 57
  
 Arithmetic Operators Applicable to All Built-In Numbers . . . . . .
  
 59
  
 Go’s Integer Types and Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 60
  
 Arithmetic Operators Applicable Only to Built-In Integer Types
  
 60
  
 Go’s Floating-Point Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 64
  
 The Math Package’s Constants and Functions #1 . . . . . . . . . . . . . .
  
 65
  
 The Math Package’s Constants and Functions #2 . . . . . . . . . . . . . .
  
 66
  
 The Math Package’s Constants and Functions #3 . . . . . . . . . . . . . .
  
 67
  
 The Complex Math Package’s Functions . . . . . . . . . . . . . . . . . . . . . .
  
 71
  
 Go’s String and Character Escapes . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 84
  
 String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 85
  
 The Fmt Package’s Print Functions . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 94
  
 The Fmt Package’s Verbs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 95
  
 The Fmt Package’s Verb Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 96
  
 The Strings Package’s Functions #1 . . . . . . . . . . . . . . . . . . . . . . . . . . 108 The 
 Strings Package’s Functions #2 . . . . . . . . . . . . . . . . . . . . . . . . . . 109 The 
 Strconv Package’s Functions #1 . . . . . . . . . . . . . . . . . . . . . . . . . . 114 The 
 Strconv Package’s Functions #2 . . . . . . . . . . . . . . . . . . . . . . . . . . 115 The Utf8 
 Package’s Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118 The Unicode 
 Package’s Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
  
 The Regexp Package’s Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 121
  
 The Regexp Package’s Escape Sequences . . . . . . . . . . . . . . . . . . . .
  
 121
  
 The Regexp Package’s Character Classes . . . . . . . . . . . . . . . . . . . .
  
 122
  
 The Regexp Package’s Zero-Width Assertions . . . . . . . . . . . . . . . .
  
 122
  
 The Regexp Package’s Quantifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 The 
 Regexp Package’s Flags and Groups . . . . . . . . . . . . . . . . . . . . . . 123
  
 The
  *
 regexp.Regexp Type’s Methods #1 . . . . . . . . . . . . . . . . . . . . . .
  
 124
  
 The
  *
 regexp.Regexp Type’s Methods #2 . . . . . . . . . . . . . . . . . . . . . .
  
 125
  
 Slice Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 151
  
 xv",NA
Introduction,"The purpose of this book is to teach solid idiomatic Go programming using all the 
 features the language provides, as well as the most commonly used Go packages 
 from Go’s standard library. The book is also designed to serve as a useful reference 
 once the language is learned. To meet both of these goals the book is quite 
 comprehensive and tries to cover every topic in just one place—and with forward 
 and backward cross-references throughout.
  
 Go is quite C-like in spirit, being a small and efficient language with convenient low-
 level facilities such as pointers. Yet Go also offers many features associated with 
 high- or very high-level languages, such as Unicode strings, powerful built-in data 
 structures, duck typing, garbage collection, and high-level concurrency support that 
 uses communication rather than shared data and locks. Go also has a large and 
 wide-ranging standard library.
  
 The reader is assumed to have programming experience in a mainstream pro-
 gramming language such as C,C++,Java,Python,or similar,although all of Go’s unique 
 features and idioms are illustrated with complete runnable examples that are fully 
 explained in the text.
  
 To successfully learn any programming language it is necessary to write pro-grams 
 in that language. To this end the book’s approach is wholly practical,and readers are 
 encouraged to experiment with the examples, try the exercises, and write their own 
 programs to get hands-on experience. As with all my previous books, the quoted 
 code snippets are of “live code”; that is, the code was auto-matically extracted from
  
 .go
  source files and directly embedded in the PDF that went to the publisher—so 
 there are no cut and paste errors, and the code works. Wherever possible, small but 
 complete programs and packages are used as ex-amples to provide realistic use 
 cases. 
 The 
 examples, 
 exercises,and 
 solutions 
 are 
 available 
 online 
 at
  
 www.qtrac.eu/gobook.html
 .
  
 The book’s key aim is to teach the Go
  language,
  and although many of the standard 
 Go packages are used, not all of them are. This is not a problem, since reading the 
 book will provide enough Go knowledge for readers to be able to make use of any of 
 the standard packages, or any third-party Go package, and of course, be able to 
 create their own packages.
  
 Why Go?
  
 The Go programming language began as an internal Google project in 2007.The 
 original design wasby Robert Griesemer and Unix luminariesRob Pike and Ken 
 Thompson. On November 10, 2009, Go was publicly unveiled under a liberal
  
 1",NA
1,NA,NA
An Overview in Five ,NA,NA
Examples,"§1.1. Getting Going 
 ➤
  7
  
 §1.2. Editing, Compiling, and Running 
 ➤
  9
  
 §1.3. Hello Who? 
 ➤
  14
  
 §1.4. Big Digits—Two-Dimensional Slices 
 ➤
  16
  
 §1.5. Stack—Custom Types with Methods 
 ➤
  21
  
 §1.6. Americanise—Files, Maps, and Closures 
 ➤
  29
  
 §1.7. Polar to Cartesian—Concurrency 
 ➤
  40
  
 This chapter provides a series of five explained examples. Although the exam-ples 
 are tiny, each of them (apart from “Hello Who?”) does something useful, and 
 between them they provide a rapid overview of Go’s key features and some of its 
 key packages. (What other languages often call “modules” or “libraries”are called
  
 packages
  in Go terminology, and all the packages supplied with Go as standard are 
 collectively known as the
  Go standard library
 .) The chapter’s pur-pose is to provide 
 a flavor of Go and to give a feel for the scope of what needs to be learned to program 
 successfully in Go. Don’t worry if some of the syntax or idioms are not immediately 
 understandable;everything shown in this chapter is covered thoroughly in 
 subsequent chapters.
  
 Learning to program Go the Go way will take a certain amount of time and practice. 
 For those wanting to port substantial C, C++, Java, Python, and other programs to 
 Go, taking the time to learn Go—and in particular how its object-orientation and 
 concurrency featureswork—will save time and effort in the long run. And for those 
 wanting to create Go applications from scratch it is best to do so making the most of 
 all that Go offers, so again the upfront investment in learning time is important—
 and will pay back later.",NA
1.1. Getting Going,"Go programsare compiled rather than interpreted so as to have the best possible 
 performance. Compilation is very fast—dramatically faster than can be the case 
 with some other languages, most notably compared with C and C++.
  
 7",NA
i,"Go’s official web site is
  golang.org
  which hosts the most up-to-date Go docu-
 mentation. The “Packages” link provides access to the documentation on all the 
 Go standard library’s packages—and to their source code, which can be very 
 helpful when the documentation itself is sparse. The “Commands” link leads to 
 the documentation for the programs distributed with Go (e.g., the compilers, 
 build tools, etc.). The “Specification” link leads to an accessible, in-formal, and 
 quite thorough Go language specification. And the “Effective Go”link leads to a 
 document that explains many best practices.
  
 The web site also features a sandbox in which small (somewhat limited) Go 
 programs can be written, compiled, and run, all online. This is useful for be-
 ginners for checking odd bits of syntax and for learning the Go
  fmt
  package’s 
 sophisticated text formatting facilitiesor the
  regexp
  package’sregular expres-sion 
 engine. The Go web site’s search box searches only the Go documenta-tion; to 
 search for Go resources generally, visit
  go-lang.cat-v.org/go-search
 .
  
 The Go documentation can also be viewed locally, for example, in a web browser. 
 To do this, run Go’s
  godoc
  tool with a command-line argument that tells it to 
 operate as a web server. Here’s how to do this in a Unix console (
 xterm
 ,
  gnome-
 terminal
 ,
  konsole
 ,
  Terminal.app
 , or similar):
  
 $
  godoc -http=:8000
  
 Or in a Windows console (i.e., a
  Command Prompt
  or
  MS-DOS Prompt
  window):
  
 C:\>
 godoc -http=:8000
  
 The port number used here is arbitrary—simply use a different one if it conflicts 
 with an existing server. This assumes that
  godoc
  is in your
  PATH
 .
  
 To view the served documentation, open a web browser and give it a location of
  
 http://localhost:8000
 . This will present a page that looks very similar to the
  
 golang.org
  web site’s front page. The “Packages” link will show the docu-
 mentation for Go’s standard library, plus any third-party packages that have been 
 installed under
  GOROOT
 . If
  GOPATH
  is defined (e.g., for local programs and 
 packages), a link will appear beside the “Packages” link through which the 
 relevant documentation can be accessed. (The
  GOROOT
  and
  GOPATH
  environment 
 variables are discussed later in this chapter and in Chapter 9.)
  
 It is also possible to view the documentation for a whole package or a single item 
 in a package in the console using
  godoc
  on the command line. For ex-ample, 
 executing
  godoc image NewRGBA
  will output the documentation for the 
 image.NewRGBA()
  function, and executing
  godoc image/png
  will output the docu-
 mentation for the entire
  image/png
  package.",NA
"1.2. Editing, Compiling, and Running","Go programs are written as plain text Unicode using the UTF-8 encoding.
 ★
 Most 
 modern text editors can handle this automatically, and some of the most popular 
 may even have support for Go color syntax highlighting and automatic
  
 ★
  Some Windows editors (e.g., Notepad) go against the Unicode standard’s recommendation and insert 
 the bytes
  0xEF
 ,
  0xBB
 ,
  0xBF
 , at the start of UTF-8 files. This book’s examples assume that UTF-8 files do not 
 have these bytes.",NA
i,"One side effect of Go’s fast compilation is that it makes it realistic to write Go 
 programs that can be treated as shebang
  #!
  scripts on Unix-like systems. This 
 requires a one-off step of installing a suitable tool. At the time of this writing, two 
 rival tools provide the necessary functionality:
 gonow
  (
 github.com/ kless/gonow
 ), 
 and
  gorun
  (
 wiki.ubuntu.com/gorun
 ).
  
 Once
  gonow
  or
  gorun
  is available, we can make any Go program into a shebang 
 script. This is done with two simple steps. First, add either 
 #!/usr/bin/env gonow
  
 or
  #!/usr/bin/env gorun
 , as the very first line of the
  .go 
 file that contains the
  main()
  
 function (in package
  main
 ). Second, make the file executable (e.g., with
  chmod +x
 ). 
 Such files can only be compiled by
  gonow
  or 
 gorun
  rather than in the normal way 
 since the
  #!
  line is not legal in Go.
  
 When
  gonow
  or
  gorun
  executes a
  .go
  file for the first time, it will compile the file 
 (extremely fast, of course), and then run it. On subsequent uses, the program will 
 only be recompiled if the
  .go
  source file has been modified since the previous 
 compilation. This makes it possible to use Go to quickly and conveniently create 
 various small utility programs, for example, for system administration tasks.
  
 indentation. If your editor doesn’t have Go support, try entering the editor’s name in 
 the Go search engine to see if there are suitable add-ons. For editing convenience, all 
 of Go’s keywords and operators use ASCII characters; however, Go identifiers can 
 start with any Unicode letter followed by any Unicode letters or digits, so Go 
 programmers can freely use their native language.
  
 To get a feel for how we edit, compile, and run a Go program we’ll start with the 
 classic “Hello World” program—although we’ll make it a tiny bit more sophisticated 
 than usual. First we will discuss compiling and running, then in the next section we 
 will go through the source code—in file
  hello/hello.go
 —in detail, since it 
 incorporates some basic Go ideas and features.
  
 All of the book’s examples are available from
  www.qtrac.eu/gobook.html
  and unpack 
 to directory
  goeg
 . So file
  hello.go
 ’s full path (assuming the exam-ples were unpacked 
 in the home directory—although anywhere will do) is 
 $HOME/goeg/src/hello/hello.go
 . 
 When referring to files the book always assumes the first three components of the 
 path, which is why in this case the path is giv-en only as
  hello/hello.go
 . (Windows 
 users must, of course, read “
 /
 ”s as “
 \
 ”s and use the directory they unpacked the 
 examples into, such as
  C:\goeg
  or
  %HOME-PATH%\goeg
 .)
  
 If you have installed Go from a binary package or built it from source and in-stalled 
 it as root or Administrator, you should have at least one environment variable,
  
 GOROOT
 , which contains the path to the Go installation, and your
  PATH 
 should now 
 include
  $GOROOT/bin
  or
  %GOROOT%\bin
 . To check that Go is installed",NA
1.3. Hello Who?,"Now that we have seen how to build the
  hello
  program we will look at its source 
 code. Don’t worry about understanding all the details—everything shown in this 
 chapter (and much more!) is covered thoroughly in the subsequent chapters. Here is 
 the complete
  hello
  program (in file
  hello/hello.go
 ):
  
 // hello.go 
  
 package
  main
  
 import
  (
  
 ➊
  
  
 ""fmt"" 
  
  
 ""os"" 
  
  
 ""strings"" 
  
 )
  
 func
  main() {
  
  who :=
  ""World!""
  
 ➋
  
 ➌
  
 if len
 (os.Args) >
  1
  {
  /* os.Args[0] is ""hello"" or ""hello.exe"" */
  
  who = strings.Join(os.Args[
 1
 :],
  "" ""
 )
  
 ➍
  
  
  }
  
  
  fmt.Println(
 ""Hello""
 , who)
  
 ➎
  
 }
  
 Go uses C++-style comments:
  //
  for single-line comments that finish at the end of 
 the line and
  /*
  …
  */
  for comments that can span multiple lines. It is conven-tional in 
 Go to mostly use single-line comments, with spanning comments often used for 
 commenting out chunks of code during development.
 ★
  
 Every piece of Go code exists inside a package,and every Go program must have a
  
 main
  package with a
  main()
  function which serves as the program’s entry point, that 
 is, the function that is executed first. In fact, Go packages may also have 
 init()
  
 functions that are executed before
  main()
 , as we will see (§1.7, 
 ➤
  40); full details are 
 given later (§5.6.2, 
 ➤
  224). Notice that there is no conflict between the name of the 
 package and the name of the function.
  
 Go operates in terms of packages rather than files. This means that we can split a 
 package across as many files as we like, and from Go’s point of view if they all have 
 the same package declaration, they are all part of the same package and no different 
 than if all their contents were in a single file. Naturally,we can also
  
 ★
  We use some simple syntax highlighting and sometimes highlight lines or annotate them with numbers 
 (
 ➊
 , 
 ➋
 , …), for ease of reference in the text. None of this is part of the Go language.",NA
1.4. Big Digits—Two-Dimensional Slices,"The
  bigdigits
  program (in file
  bigdigits/bigdigits.go
 ) reads a number entered on the 
 command line (as a string), and outputs the same number onto the console using 
 “big” digits. Back in the twentieth century, at sites where lots of users shared a high-
 speed line printer, it used to be common practice for each user’s print job to be 
 preceded by a cover page that showed some identifying details such as their 
 username and the name of the file being printed,using this kind of technique.",NA
1.5. Stack—Custom Types with Methods,"Although Go supports object-oriented programming it provides neither class-es nor 
 inheritance (
 is-a
  relationships). Go does support the creation of custom types, and 
 Go makes aggregation (
 has-a
  relationships) extremely easy. Go also allows for the 
 complete separation of a type’s data from its behavior, and sup-ports
  duck 
 typing
 .Duck typing is a powerful abstraction mechanism that means that values can 
 be handled (e.g., passed to functions),based on the methods they provide, regardless 
 of their actual types. The terminology is derived from the phrase, “If it walks like a 
 duck, and quacks like a duck, it
  is
  a duck”. All of this produces a more flexible and 
 powerful alternative to the classes and inheritance approach—but does require 
 those of us used to the more traditional approach to make some significant 
 conceptual adjustments to really benefit from Go’s object orientation.
  
 Go representsdata using the fundamental built-in typessuch as
  keyword!!struct bool
 ,
  
 int
 , and
  string
 , or by aggregations of types using
  struct
 s.
 ★
 Go’s custom types are based 
 on the fundamental types, or on
  struct
 s, or on other custom types. (We will see some 
 simple examples later in this chapter; §1.7, 
 ➤
  40.)
  
 ★
 Unlike C++, Go’s
  struct
 s are
  not
  classes in disguise. For example, Go’s
  struct
 s support aggregation and 
 delegation, but not inheritance.",NA
"1.6. Americanise—Files, Maps, and Closures","To have any practical use a programming language must provide some means of 
 reading and writing external data. In previous sections we had a glimpse of Go’s 
 versatile and powerful print functions from its
  fmt
  package; in this section we will 
 look at Go’s basic file handling facilities. We will also look at some more advanced 
 featuressuch as Go’streatment of functionsand methodsas first-class values which 
 makes it possible to pass them as parameters. And in addition we will make use of 
 Go’s
  map
  type (also known as a data dictionary or hash).
  
 This section provides enough of the basics so that programs that read and write text 
 files can be written—thus making the examples and exercises more inter-esting. 
 Chapter 8 provides much more coverage of Go’s file handling facilities.
  
 By about the middle of the twentieth century, American English surpassed British 
 English as the most widely used form of English. In this section’s example we will 
 review a program that reads a text file and writes out a copy of the file into a new 
 file with any words using British spellings replaced with their U.S. counterparts. 
 (This doesn’t help with differences in semantics or idioms, of course.) The program 
 is in the file
  americanise/americanise.go
 , and we will review it top-down, starting with 
 its imports, then its
  main()
  function, then the functions that
  main()
  calls, and so on.
  
 ★
  This is why Go does not have or need the
  ->
  indirection operator used by C and C++.",NA
1.7. Polar to Cartesian—Concurrency,"One key aspect of the Go language is its ability to take advantage of modern 
 computerswith multiple processorsand multiple cores,and to do so without bur-
 dening programmers with lots of bookkeeping. Many concurrent Go programs can 
 be written without any explicit locking at all (although Go does have locking",NA
1.8. Exercise,"Copy the
  bigdigits
  directory to, say,
  my_bigdigits
 , and modify
  my_bigdigits/big-
  
 digits.go
  to produce a version of the
  bigdigits
  program (§1.4, 16
  
 ) that can
  
 optionally output the number with an overbar and underbar of “
 *
 ”s, and with 
 improved command-line argument handling.
  
 The original program output its usage message if no number was given; change this 
 so that the usage message is also output if the user gives an argument of
  -h 
 or
  --help
 . 
 For example:
  
  
  
 $
  ./bigdigits --help
  
 usage: bigdigits [-b|--bar] <whole-number>
  
 -b --bar  draw an underbar and an overbar
  
 If the
  --bar
  (or
  -b
 ) option is
  not
  present the program should have the same behavior 
 as before. Here is an example of the expected output if the option
  is 
 present:
  
  
  
 $
  ./bigdigits --bar 8467243
  
 *************************************************
  
  
  
 888      4     666   77777   222      4     333
  
  
 8   8    44    6          7  2   2    44    3   3
  
 8   8   4 4    6         7      2    4 4        3
  
  
  
 888   4  4    6666     7      2    4  4      33
  
  
 8   8  444444  6   6   7      2     444444      3
  
 8   8     4    6   6  7      2         4    3   3
  
  
 888      4     666   7      22222     4     333
  
 *************************************************
  
 The solution requires more elaborate command-line processing than the version 
 shown in the text, although the code producing the output only needs a small 
 change to output the overbar before the first row and the underbar after the last 
 row. Overall, the solution needs about 20 extra lines of code—the solution’s 
 main()
  
 function is twice as long as the original (~40 vs. ~20 lines), mostly due to the code 
 needed to handle the command line. A solution is provided in the file 
 bigdigits_ans/bigdigits.go
 .
  
 Hints:The solution also has a subtle difference in the way it builds up each row’s line 
 to prevent the bars extending too far. Also, the solution imports the
  strings 
 package 
 and uses the
  strings.Repeat(string, int)
  function. This function returnsa string that 
 containsthe
  string
  it is given as its first argument repeated by the number of times of 
 the
  int
  given as its second argument. Why not look this function up either locally 
 (see the sidebar “The Go Documentation”, 8 
  
 ), 
 or at
  golang.org/pkg/strings
 , and start to become familiar with the Go standard 
 library’s documentation.",NA
2,NA,NA
Booleans and ,NA,NA
Numbers,"§2.1. Preliminaries 
 ➤
  51
  
  
 §2.1.1. Constants and Variables 
 ➤
  53
  
 §2.2. Boolean Values and Expressions 
 ➤
  56
  
 §2.3. Numeric Types 
 ➤
  57
  
  
 §2.3.1. Integer Types 
 ➤
  59
  
  
 §2.3.2. Floating-Point Types 
 ➤
  64
  
 §2.4. Example: Statistics 
 ➤
  72
  
  
 §2.4.1. Implementing Simple Statistics Functions 
 ➤
  73
  
 §2.4.2. Implementing a Basic HTTP Server 
 ➤
  75
  
 This is the first of four chapters on procedural programming that lay down the 
 foundations for Go programming—whether procedural, object-oriented, concurrent, 
 or any combination of these approaches.
  
 This chapter covers Go’s built-in Boolean type and all of Go’s built-in numeric types, 
 and briefly introduces two of the numeric types from Go’s standard library. Apart 
 from the need to explicitly convert between different types of numbers and the 
 convenience of having a built-in complex type, programmers coming from C, C++, 
 and Java should find few surprises in this chapter.
  
 This chapter’s first section covers some of the language’s basics, such as how 
 comments are written, Go’s keywords and operators, what constitutes a valid 
 identifier, and so on. Once these preliminaries have been covered, there are sections 
 on Booleans, integers, and floating-point numbers, the latter including coverage of 
 complex numbers.",NA
2.1. Preliminaries,"Go supports two kinds of comments, both adopted from C++. Line comments begin 
 with
  //
  and end at the newline; these are treated simply as a newline. General 
 comments begin with
  /*
  and end with
  */
  and may span multiple lines. When a 
 general comment is all on one line (e.g.,
  /*
  inline comment
  */
 ), it is treated
  
 51",NA
2.1.1. Constants and Variables,"Constants are declared using the
  const
  keyword;variables can be declared using the
  
 var
  keyword, or using the short variable declaration syntax. Go can infer the type of 
 the declared type, although it is legal to specify it if we wish to or need to—for 
 example, to specify a type that is different from the type Go would normally infer. 
 Here are some example declarations:
  
 const
  limit =
  512 
  
 // constant; type-compatible with any number
  
 const
  top uint16 =
  1421 
  
 // constant; type: uint16
  
 start :=
  -19 
  
 // variable; inferred type: int
  
 end := int64(
 9876543210
 )
  // variable; type: int64
  
 var
  i int                
 // variable; value 0; type: int
  
 var
  debug =
  false 
  
 // variable; inferred type: bool
  
 checkResults :=
  true 
  
 // variable; inferred type: bool
  
 stepSize :=
  1.5 
  
 // variable; inferred type: float64
  
 acronym :=
  ""FOSS"" 
  
 // variable; inferred type: string
  
 For integer literals Go infers type
  int
 , for floating-point literals Go infers type 
 float64
 , 
 and for complex literals Go infers type
  complex128
  (the numbers in their names refer 
 to how many bits they occupy).The normal practice is to leave types unspecified 
 unless we want to use a specific type that Go won’t infer; we will discuss this further 
 in §2.3, 
 ➤
  57. Typed numeric constants (e.g.,
  top
 ) can only be used in expressions 
 with other numbers of the same type (unless converted). Untyped numeric 
 constants can be used in expressions with numbers of any built-in type, (e.g.,
  limit
  
 can be used in an expression with integers or in one with floating-point numbers).
  
 The variable
  i
  was not given any explicit value. This is perfectly safe in Go since Go
  
 always
  assigns variables their type’s zero value if no other value is specified.",NA
2.2. Boolean Values and Expressions,"Go provides two built-in Boolean values,
  true
  and
  false
 , both of type
  bool
 . Go supports 
 the standard logical and comparison operators, all of which produce a 
 bool
  result; 
 they are shown in Table 2.3.
  
 Boolean values and expressions are used in
  if
  statements (§5.2.1, 
 ➤
  192), in the 
 conditions of
  for
  statements (§5.3, 
 ➤
  203), and sometimes in the conditions of 
 switch
  
 statements’
  case
  clauses (§5.2.2, 
 ➤
  195), as we will see in Chapter 5.
  
 The binary logical operators (
 ||
  and
  &&
 ) use short-circuit logic. This means that if we 
 have
  b1
  ||
  b2
  and expression
  b1
  evaluates to
  true
 , the result must be
  true 
 no matter 
 what
  b2
  is, so
  true
  is returned and
  b2
  is not evaluated. Similarly, if we have
  b1
  &&
  b2
  
 and expression
  b1
  evaluates to
  false
 , the result must be
  false
 , so 
 false
  is returned and
  
 b2
  is not evaluated.
  
 Go is strict about the values that can be compared using the comparison oper-ators 
 (
 <
 ,
  <=
 ,
  ==
 ,
  !=
 ,
  >=
 ,
  >
 ). The two values must be of the same type, or—if they are 
 interfaces—they must implement the same interface type. If one value is a constant 
 then it must be of a type that is compatible with the other’s type. This means that an 
 untyped numeric constant can be compared with another value of
  any
  numeric type, 
 but numbers of different types—and that are not constants—cannot be compared 
 unless one of them is explicitly converted to be of the same type as the other. 
 (Numeric conversions are discussed in §2.3,
 ➤
  57.)",NA
2.3. Numeric Types,"Go provides a wide range of built-in numeric types, and the standard library adds 
 integers of type
  big.Int
  and rationals of type
  big.Rat
  which are of un-bounded size 
 (i.e., limited only by the machine’s memory). Every numeric type is distinct: This 
 means that we cannot use binary arithmetic operations or com-parisons (e.g.,
  +
  or
  <
 ) 
 on numeric values of different types (e.g., of type
  int32
  and type
  int
 ). Untyped 
 numeric constants are compatible with any (built-in) typed number they are in an 
 expression with,so we can add or compare an untyped nu-meric constant with 
 another number, no matter what the other number’s (built-in) type.
  
 If we need to perform arithmetic or comparisons on typed numbers of different 
 types we must perform conversions—usually to the biggest type to avoid loss of 
 accuracy. Conversions take the form
  type
 (
 value
 )
  and where valid (e.g., from one type 
 of number to another) they always succeed—even if this results in data loss. Here 
 are some examples:",NA
2.3.1. Integer Types,"Go provides 11 separate integer types, five signed and five unsigned, plus an in-
 teger type for storing pointers—their names and values are shown in Table 2.5 (
 ➤
  
 60). In addition, Go allows the use of
  byte
  as a synonym for the unsigned 
 uint8
  type, 
 and encourages the use of
  rune
  as a synonym for the
  int32
  type when working with 
 individual characters (i.e., Unicode code points).For most process-ing purposes the 
 only integer type that we need is
  int
 . This is suitable for loop counters, array and 
 slice indexes, and all general-purpose integer arithmetic; it is also normally the 
 integer type that offers the fastest processing speeds. At the time of this writing, the
  
 int
  type is represented by a signed 32-bit integer (even on 64-bit platforms), but is 
 expected to change to 64-bit in a future Go version.
  
 The other integer types that Go provides are needed when it comes to reading and 
 writing integers outside the program—for example, from and to files or network 
 connections. In such cases it is essential to know exactly how many bits must be 
 read or written so that integers can be handled without corruption.
  
 ★
  A
  panic
  is an exception; see Chapter 1 (32
  
 ) and §5.5, 
 ➤
  212.",NA
2.3.2. Floating-Point Types,"Go provides two types of floating-point numbers and two types of complex 
 numbers—their names and ranges are shown in Table 2.7. Floating-point numbers 
 in 
 Go 
 are 
 held 
 in 
 the 
 widely 
 used 
 IEEE-754 
 format 
 (
 http://en.wiki-
 pedia.org/wiki/IEEE_754-2008
 ). This format is also the native format used by many 
 microprocessorsand floating-point units,so in most casesGo isable to take direct 
 advantage of the hardware’s floating-point support.
  
 Table 2.7
  Go’s Floating-Point Types
  
  
 Type 
  
 float32
  
 Range
  
 
 3.4028234
 66385288598117041834 845169254 40
  
  
  
 38 
  
 10
  
 The mantissa is reliably accurate to about 7 decimal places.
  
  
 float64
  
 
 1.797693134 862315
 708145274 237317043567981
  
  
 308 
 10
  
 The mantissa is reliably accurate to about 15 decimal places.
  
  
 complex64 
  
 The real and imaginary parts are both of type
  float32
 .
  
 complex128
  The real and imaginary parts are both of type
  float64
 .
  
 Go floating-point numbers support all the arithmetic operations listed in Table 2.4 
 (59 ). Most of the
  math
  package’s constants and all of its functions are listed in 
 Tables 2.8 to 2.10 (
 ➤
  65–67).
  
 Floating-point numbers are written with a decimal point, or using exponential 
 notation, for example, 0.0, 3., 8.2,
   
 7
 .
 4,
   
 6e4, .1, 5.9E
  
 3. Computers commonly 
 represent floating-point numbersinternally using base 2—thismeansthat some 
 decimals can be represented exactly (such as 0.5),but others only approximately 
 (such as 0.1 and 0.2). Furthermore, the representation uses a fixed number of bits, 
 so there is a limit to the number of digits that can be held. This is not a Go-specific 
 problem, but one that afflicts floating-point numbers in all mainstream 
 programming languages. However, the imprecision isn’t always apparent, be-cause 
 Go usesa smart algorithm for outputting floating-point numbersthat uses the fewest 
 possible digits consistent with maintaining accuracy.",NA
2.4. Example: Statistics,"The purpose of this example (and the exercises that follow) is to provide some 
 context for (and practice of) Go programming. Just like in Chapter 1, the ex-ample 
 makes use of some Go features that haven’t yet been fully covered. This shouldn’t 
 cause problems since brief explanations and forward references are provided. The 
 example also introduces some very simple usage of the Go stan-dard library’s
  
 net/http
  package—this package makes it incredibly easy to create HTTP servers. As 
 appropriate to the main theme of the chapter, the example and the exercises are 
 numeric in flavor.
  
 The
  statistics
  program (in file
  statistics/statistics.go
 ) is a web application that asks the 
 user to enter a list of numbers and then does some very simple statistical 
 calculations. Figure 2.2 shows the program in action. We will review the program’s 
 code in two parts, first the implementation of the mathematical functionality, and 
 then the implementation of the application’s web page. We won’t show the whole 
 program (e.g., we will skip the imports and most of the constants), since it is 
 available for download, but we will cover enough to make it understandable.",NA
2.4.1. Implementing Simple Statistics Functions,"For convenience we have created an aggregate type that holds the numbers the user 
 entered and the two statistics we plan to calculate.
  
 type
  statistics
  struct
  {
  
  
  numbers []float64
  
  
  mean    float64
  
  
  median  float64 
  
 }
  
 A Go
  struct
  is similar to a C struct or to a Java class that has public data fields and no 
 methods—but not like a C++ struct since it isn’t a class. As we will see, Go
  struct
 s 
 provide excellent support for aggregation and embedding (§6.4,
 ➤
  275), and are 
 also often central to Go’s object-oriented functionality (Chap-ter 6).
  
 func
  getStats(numbers []float64) (stats statistics) {
  
  
 stats.numbers = numbers
  
  
  sort.Float64s(stats.numbers)
  
  
  stats.mean = sum(numbers) / float64(
 len
 (numbers))
  
  
 stats.median = median(numbers) 
  
  
  
 return
  stats 
  
 }
  
 This function accepts a slice of numbers (in this case as obtained by our
  process-
 Request()
  function 
 ➤
  77),and populatesits
  stats
  result value (of type
  statistics
 ) with 
 appropriate values. To compute the median we need the numbers to be",NA
2.4.2. Implementing a Basic HTTP Server,"The
  statistics
  program provides a single web page on the local host. Here is its 
 main()
  
 function.
  
 func
  main() {
  
  
  http.HandleFunc(
 ""/""
 , homePage) 
  
  
  
 if
  err := http.ListenAndServe(
 "":9001""
 ,
  nil
 ); err !=
  nil
  {
  
  
  
  log.Fatal(
 ""failed to start server""
 , err)
  
  
  } 
  
 }
  
 The
  http.HandleFunc()
  function takes two arguments: a path and a reference to a 
 function to call when that path is requested. The function must have the signature
  
 func(http.ResponseWriter, *http.Request)
 . We can register as many 
 path
 –
 function
  pairs 
 as we like. Here we have registered the
  /
  path (i.e., the web application’s home page) 
 with a custom
  homePage()
  function.
  
 The
  http.ListenAndServe()
  function starts up a web server at the given TCP network 
 address; here we have used localhost and port number 9001. The local host is 
 assumed if only the port number is given—we could just as easily have used an 
 address of
  ""localhost:9001""
  or
  ""127.0.0.1:9001""
 . (The port number we have chosen is 
 arbitrary—simply change the code to use a different one if it conflicts with an 
 existing server.) The second argument is used to specify which kind of server to 
 use—normally we pass
  nil
  to indicate that we want to use the default kind.
  
 The program has several string constants but we will only show one of them here.
  
  form       =
  `<form action=""/"" method=""POST""> 
  
 <label for=""numbers"">Numbers (comma or space-separated):</label><br /> <input 
 type=""text"" name=""numbers"" size=""30""><br /> 
  
 <input type=""submit"" value=""Calculate""> 
  
 </form>`
  
 The
  form
  string constant contains a
  <form>
  element which itself contains the
  text 
 and
  
 submit
  button
  <input>
  elements.",NA
2.5. Exercises,"There are two exercises for this chapter, both numeric in flavor. The first involves 
 modifying the
  statistics
  program we have just reviewed; the second involves creating 
 a simple mathematical web application from scratch.",NA
  ,"(
 x
   
  
 x
  2
 ) 
 n
   
  1
 , where
  x
  is each number,
   
 x
  is the
  
 mean, and
  n
  is the number of numbers.
  
 The mode is the most frequently occurring number—or numbers, if two or 
 more are equally the most frequently occurring. However, we return no mode if 
 all of the numbers occur with the same frequency. The mode is trickier than the 
 standard deviation, and needs about 20 lines of code.
  
 2. Create a web application for calculating the solution or solutionsto quadrat-
  
  
  
 2 
  
 ic equations using the standard formula
  x
  =
  
 b
 
  
 2
 a 
  
  
 b
   
  4
 ac 
 . Use complex num-
  
 bers so that it is possible to find solutions even when the discriminant (the
  
 2 
  
 b
   
  4
 ac
  part) is negative. Initially, just get the math working, as shown
  
 in Figure 2.4’s left-hand screenshot (
 ➤
  80). Then, modify your application
  
 to produce more intelligent output, as shown in Figure 2.4’s right-hand
  
 screenshot.",NA
3,NA,NA
Strings,"§3.1. Literals, Operators, and Escapes 
 ➤
  83
  
 §3.2. Comparing Strings 
 ➤
  86
  
 §3.3. Characters and Strings 
 ➤
  87
  
 §3.4. Indexing and Slicing Strings 
 ➤
  90
  
 §3.5. String Formatting with the Fmt Package 
 ➤
  93
  
 §3.5.1. Formatting Booleans 
 ➤
  97
  
  
 §3.5.2. Formatting Integers 
 ➤
  98
  
  
 §3.5.3. Formatting Characters 
 ➤
  99
  
  
 §3.5.4. Formatting Floating-Point Numbers 
 ➤
  100
  
 §3.5.5. Formatting Strings and Slices 
 ➤
  101
  
  
 §3.5.6. Formatting for Debugging 
 ➤
  103
  
 §3.6. Other String-Related Packages 
 ➤
  106
  
  
 §3.6.1. The Strings Package 
 ➤
  107
  
  
 §3.6.2. The Strconv Package 
 ➤
  113
  
  
 §3.6.3. The Utf8 Package 
 ➤
  117
  
  
 §3.6.4. The Unicode Package 
 ➤
  118
  
  
 §3.6.5. The Regexp Package 
 ➤
  120
  
 §3.7. Example: M3u2pls 
 ➤
  130
  
 This chapter covers Go’s
  string
  type and key string-related packages from the 
 standard library. The chapter’s sections include coverage of how to write literal 
 strings and use the string operators; how to index and slice (take substrings of) 
 strings;and how to format the output of strings,numbers,and other built-in and 
 custom types.
  
 Go’s high-level string-related functionality, such as its
  for
  …
  range
  loop which iterates 
 over a string character by character, the functions from the
  strings
  and 
 strconv
  
 packages,and Go’s ability to slice strings,are all that is needed for every-day 
 programming. Nonetheless, this chapter covers Go strings in depth, includ-
  
 81",NA
i,"Prior to Unicode it was not really possible to have plain text files that con-tained 
 text in different languages—for example, English with some quoted sentences in 
 Japanese and Russian—since separate encodings were used for separate 
 languages and each text file used a single encoding.
  
 Unicode is designed to be able to represent the characters from all of the world’s 
 writing systems, so a single text file using a Unicode encoding can contain text in 
 any mixture of languages—as well as math, “dingbats”, and other special 
 characters.
  
 Every Unicode character has a unique identifying number called a
  code point
 . 
 There are more than 100000 Unicode characters defined, with code points 
 ranging in value from
  0x0
  to
  0x10FFFF
  (the latter defined in Go as the constant 
 unicode.MaxRune
 ), with some large gaps and various special cases. In Unicode 
 documentation,code points are written using four or more hexadecimal digits in 
 the form
  U+
 hhhh
 —for example,
  U+21D4
  for the
  ⇔
  character.
  
 In Go, an individual code point (i.e., a character) is represented by a
  rune
  in 
 memory. (The
  rune
  type is a synonym for
  int32
 ; see §2.3.1, 59 
  
 .)
  
 Unicode text—whether in files or in memory—must be represented using an 
 encoding. The Unicode standard defines various Unicode Transformation 
 Formats(encodings),such as UTF-8,UTF-16,and UTF-32.Go uses the UTF-8 
 encoding for strings. UTF-8 is the most widely used encoding; it is also the de 
 facto standard encoding for text files and the default encoding for XML and JSON 
 files.
  
 The UTF-8 encoding uses between one and four bytes to represent each code 
 point. For strings that contain only 7-bit ASCII (US-ASCII) characters,there is a 
 one-to-one relationship between bytes and characters because each 7-bit ASCII 
 character is represented by a single byte (of the same value) in UTF-8. One 
 consequence of this is that UTF-8 stores English text very compactly (one byte 
 per character);another consequence is that a text file encoded using 7-bit ASCII is 
 indistinguishable from a UTF-8-encoded text file.
  
 ing some low-level details such as how strings are represented internally. The low-
 level aspects are interesting and can be useful to know in some situations.
  
 A Go string is an immutable sequence of arbitrary
  byte
 s. In most casesa string’s 
 bytes represent Unicode text using the UTF-8 encoding; (see the “Unicode”sidebar 
 above). The use of Unicode means that Go strings can contain text in a mixture of 
 any of the world’s languages, without any of the confusions and limitations of code 
 pages.
  
 Go’s
  string
  type is fundamentally different from the equivalent type in many other 
 languages. Java’s
  String
 , C++’s
  std::string
 , and Python 3’s
  str
  types are all",NA
"3.1. Literals, Operators, and Escapes","String literals are created using double quotes (
 ""
 ) or backticks (
 `
 ).Double quotes are 
 used to create interpreted string literals—such strings support the escape 
 sequences listed in Table 3.1 (
 ➤
  84) but may not span multiple lines. Backticks are 
 used to create raw string literals—these strings may span multiple lines; they do not 
 support any escape sequences and may contain any character except for a backtick. 
 Interpreted string literals are the most commonly used kind, but raw string literals 
 are useful for writing multiline messages, HTML, and regular expressions. Here are a 
 few examples.
  
 text1 :=
  ""\""what's that?\"", he said""
  // Interpreted string literal
  
 text2 :=
  `""what's that?"", he said` 
  
 // Raw string literal
  
 radicals :=
  ""√ √ √"" 
  
 // radicals == ""√ √ √""",NA
3.2. Comparing Strings,"As we have noted, Go strings support the usual comparison operators (
 <
 ,
  <=
 ,
  ==
 , 
 !=
 ,
  >
 ,
  
 >=
 ); these are shown in Table 2.3 (57 
  
 ).The comparison operators compare 
 strings byte by byte in memory. Comparisons are used directly—for example, to 
 compare two strings for equality, and indirectly—for example, when
  <
  is used to 
 compare the strings in a
  []string
  that is being sorted. Unfortunately, three problems 
 can arise when performing comparisons—these problems afflict every 
 programming language that uses Unicode strings; none of them is specific to Go.
  
 The first problem is that some Unicode characters can be represented by two or 
 more different byte sequences. For example, the character
  Å
  could be theÅngström 
 symbol or simply an
  A
  with a ring above—the two are often visually 
 indistinguishable. The Ångström symbol’sUnicode code point is
  U+212B
 ,but an
  A 
 with a ring above can be represented by Unicode code point
  U+00C5
  or by the two 
 code points
  U+0041
  (
 A
 ) and
  U+030A
  (
 
 ; combining ring above). In terms of UTF-8 
 bytes the Ångström symbol (
 Å
 ) is represented by the bytes
  [0xE2, 0x84, 0xAB]
 , the
 Å
  
 character by the bytes
  [0xC3, 0x85]
 ,and an
  A
  with the
  
  combining character by the 
 bytes
  [0x41, 0xCC, 0x81]
 . Of course, from a user’s point of view two
  Å
  charac-ters 
 ought to compare and sort as equals no matter what the underlying bytes.
  
 This first problem isn’t necessarily as significant as we might imagine since all UTF-
 8 byte sequences (i.e., strings) in Go are produced using the same code point to 
 bytes mappings. This means, for example, that an
  é
  character in a Go character or 
 string literal will always be represented by the same bytes. And, of course, if we are 
 only concerned with ASCII characters (i.e., English), the problem doesn’t occur at all. 
 And even when we deal with non-ASCII characters, the problem only really arises 
 when we have two different characters that look the same, or when we are reading 
 UTF-8 bytes from outside our program from a source that has used code point to 
 bytes mappings that are legal UTF-8 but which differ from Go’s mappings. If this 
 really does turn out to be a problem it is always possible to write a custom 
 normalization function that, for example, ensured that, say,
  é
  was always 
 represented by the bytes
  [0xC3, 0xA9]
  (which Go uses natively) rather than, say,
  
 [0x65, 0xCC, 0x81]
  (i.e., an
  e
  and an
  ´
  combining character).Normalizing Unicode 
 charactersis 
 explained 
 in 
 the 
 Unicode 
 Normal-ization 
 Forms 
 document 
 (
 unicode.org/reports/tr15
 ). At the time of this writing, the Go standard library has an
  
 experimental
  normalization package (
 exp/norm
 ).
  
 Since this first problem can only really arise with strings coming from external 
 sources—and then only if they use different code point to bytes mappings than Go—
 it is probably best handled by isolating the code that accepts external strings. The 
 isolating code could then normalize the strings it receives before providing them to 
 the rest of the program.",NA
3.3. Characters and Strings,"In Go,charactersare represented in two different (easy-to-interchange)ways. A 
 single character can be represented by a single
  rune
  (or
  int32
 ). From now on we will 
 use the terms “character”, “code point”, “Unicode character”, and “Unicode code 
 point” interchangeably to refer to a
  rune
  (or
  int32
 ) that holds a single character. Go
  
 string
 s represent sequences of zero or more characters—within a
  string
  each 
 character is represented by one or more UTF-8 encoded bytes.
  
 We can convert a single character into a one-character string using Go’s standard 
 conversion syntax (
 string(
 char
 )
 ). Here is an example.
  
 æs :=
  """" 
  
 for
  _, char :=
  range
  []rune{
 'æ'
 ,
  0xE6
 ,
  0346
 ,
  230
 ,
  '\xE6'
 ,
  'æ'
 } {
  
  
 fmt.Printf(
 ""[0x%X '%c'] ""
 , char, char)
  
  
  æs += string(char) 
  
 }",NA
i,"Big-O notation, O(…), is used in complexity theory to give approximate bounds for 
 processing and for memory use for particular algorithms. Most of the measures are 
 in proportion to
  n
  which is the number of items to process or the length of the item 
 to process. They could be measures of memory con-sumption or of processing 
 time.
  
 O(1) means constant time, that is, the fastest possible time no matter what 
 n
 ’s size. 
 O(log
  n
 ) means logarithmic time;this is very fast and in proportion to log
  n
 . O(
 n
 ) 
 means linear time; this is fast and in proportion to
  n
 . O(
 2 
 n
  ) means quadratic time; 
 this is starting to get slow and is in proportion to 
 n
  . O(
 m 
 n
  ) means polynomial time 
 which quickly becomes slow as
  n
  grows, especially if 
 m
  
  3. O(
 n
 !) means factorial 
 time; even for small values of
  n
  this can become too slow to be practical.
  
 This book uses big-O notation in a few places to give a feel for the costs of 
 processing, for example, the cost of converting from a
  string
  to a
  []rune
 .
  
  
 phrase :=
  ""vått og tørt"" 
  
 fmt.Printf(
 ""string: \""%s\""\n""
 , phrase) 
 fmt.Println(
 ""index rune    char bytes""
 ) 
 for
  index, 
 char :=
  range
  phrase {
  
  
  fmt.Printf(
 ""%-2d    %U  '%c'  % X\n""
 ,
  
  
  index, char, char,
  
  
  
  []byte(string(char))) 
  
 }
  
 string: ""vått og tørt"" index 
 rune    char bytes 0     U+0076  
 'v'  76 
  
 1     U+00E5  'å'  C3 A5 3     
 U+0074  't'  74 
  
 4     U+0074  't'  74 
  
 5     U+0020  ' '  20 
  
 6     U+006F  'o'  6F
  
 7     U+0067  'g'  67 
  
 8     U+0020  ' '  20 
  
 9     U+0074  't'  74 
  
 10    U+00F8  'ø'  C3 B8 
  
 12    U+0072  'r'  72 
  
 13    U+0074  't'  74
  
 We create the
  phrase
  string literal, and then we print it followed by a heading on the 
 next line. Then we iterate over every
  character
  in the string—Go’s
  for
 …
  range
  loop 
 decodes UTF-8 bytes into Unicode code points (
 rune
 s) as it iterates, so we don’t have 
 to concern ourselves with the underlying representation. For each character, we 
 print its index position, its code point value (using Unicode notation), the character 
 it represents, and the UTF-8 bytes used to encode the character.
  
 To get the list of bytes we convert the code point (
 char
  of type
  rune
 ) into a
  string 
 (which will contain a single character consisting of one or more UTF-8-encoded 
 bytes). Then we convert this one-character
  string
  into a
  []byte
 , that is, a byte",NA
3.4. Indexing and Slicing Strings,"As Table 3.2 (85 
  
 ) shows, Go supports string slicing using a subset of the syntax 
 used by Python. This syntax can be used for slices of
  any
  type, as we will see in 
 Chapter 4.
  
 Since Go
  string
 s store their text as UTF-8-encoded bytes we must be careful to only 
 ever slice on character boundaries. This is easy if we have 7-bit ASCII text since 
 every byte represents one character, but for non-ASCII text the situation is more 
 challenging since such characters may be represented by one or more bytes. Usually 
 we don’t need to slice strings at all but simply iterate over them character by 
 character using a
  for
  …
 range
  loop, but in some situations we really do want to extract 
 substrings using slicing. One way to be sure to use slice indexes that slice on 
 character boundaries is to use functions from Go’s
  strings 
 package, such as
  
 strings.Index()
  or
  strings.LastIndex()
 . The
  strings
  package’s functions are listed in 
 Tables 3.6 and 3.7 (
 ➤
  108–109).
  
 We will begin by looking at the different ways we can perceive a string. Index 
 positions—which are the positions of the string’s UTF-8 bytes—begin at 0 and go up 
 to the length of the string minus 1. It is also possible to index back from the end of 
 the slice using indexes of the form
  len(
 s
 ) -
  n
  where
  n
  is the number of bytes counting 
 back from the end. For example, given the assignment
  s := ""naïve""
 , Figure 3.1 shows 
 string
  s
  as Unicode characters, code points, and bytes, as well as some valid index 
 positions and a couple of slices.",NA
3.5. String Formatting with the Fmt Package,"Go’s standard library’s
  fmt
  package provides print functions for writing data as 
 strings to the console,to files and other values satisfying the
  io.Writer interface
 , and to 
 other strings. These functions are listed in Table 3.3 (
 ➤
  94). Some of the print 
 functions return an
  error
 . It is not uncommon to ignore this return value when 
 printing to the console,but the error should always be checked when printing to 
 files, network connections, and so on.
 ★
  
 The
  fmt
  package also provides various scan functions (such as
  fmt.Scan()
 , 
 fmt.Scanf()
 , 
 and
  fmt.Scanln()
 ) for reading data from the console, from files, and from strings. 
 Some of these functions are used in Chapter 8 (§8.1.3.2,
  
 ★
 Go also has two built-in print functions,
  print()
  and
  println()
 . These should
  not
  be used; they exist purely 
 for the convenience of Go compiler implementers and may be removed from the language.",NA
3.5.1. Formatting Booleans,"Boolean values are output using the
  %t
  (truth value) verb.
  
 fmt.Printf(
 ""%t %t\n""
 ,
  true
 ,
  false
 ) 
  
 true
 ·
 false
  
 If we want to output Booleans as integers we must do the conversion our-selves:
  
 fmt.Printf(
 ""%d %d\n""
 , IntForBool(
 true
 ), IntForBool(
 false
 )) 1
 ·
 0
  
 This makes use of a tiny custom function.
  
 func
  IntForBool(b bool) int { 
  
  
 if
  b {
  
 ★
  C, C++, and Python 2 programmers will find Go’s format strings familiar—but with some subtle 
 differences. For example, Go’s
  %d
  can be used for any integer regardless of its size or signedness.",NA
3.5.2. Formatting Integers,"Now we will look at the formatting of integers, starting with binary (base 2) output.
  
 fmt.Printf(
 ""|%b|%9b|%-9b|%09b|% 9b|\n""
 ,
  37
 ,
  37
 ,
  37
 ,
  37
 ,
  37
 ) 
 |100101|
 ···
 100101|100101
 ···
 |000100101|
 ···
 100101|
  
 The first format (
 %b
 ) uses the
  %b
  (binary) verb and outputs an integer as a binary 
 number using as few digits as possible. The second format (
 %9b
 ) specifies a width of 
 9 characters (which will be exceeded if necessary to avoid truncation), and uses the 
 default right justification. The third format (
 %-9b
 ) uses the
  -
  modifier to get left 
 justification. The fourth format (
 %09b
 ) uses
  0
  padding and the fifth format (
 % 9b
 ) 
 uses space padding.
  
 Octal formatting is similar to binary, but also supports an alternative format. It uses 
 the
  %o
  (octal) verb.
  
 fmt.Printf(
 ""|%o|%#o|%# 8o|%#+ 8o|%+08o|\n""
 ,
  41
 ,
  41
 ,
  41
 ,
  41
 ,
  -41
 ) 
 |51|051|
 ·····
 051|
 ····
 +051|-0000051|
  
 The alternative format is switched on by using the
  #
  modifier and causes a leading
  0
  
 to be output. The
  +
  modifier forces the sign to be output—without it, positive 
 numbers are output without a sign.
  
 Hexadecimal formatting uses the
  %x
  and
  %X
  (hexadecimal) verbs, the choice of 
 which specifies whether to use lowercase or uppercase letters for the digits
  A
 –
 F
 .
  
 i :=
  3931 
  
 fmt.Printf(
 ""|%x|%X|%8x|%08x|%#04X|0x%04X|\n""
 , i, i, i, i, i, i)
  
 |f5b|F5B|
 ·····
 f5b|00000f5b|0X0F5B|0x0F5B|
  
 For hexadecimal numbers the alternate format modifier (
 #
 ) causes a leading 
 0x
  or
  0X
  
 to be output. As with all numbers, if we specify a width that is wider",NA
3.5.3. Formatting Characters,"Go characters are
  rune
 s (i.e.,
  int32
 s), and they can be output as numbers or as 
 Unicode characters.
  
 fmt.Printf(
 ""%d %#04x %U '%c'\n""
 ,
  0x3A6
 ,
  934
 ,
  'Φ'
 ,
  'Φ'
 ) 
 934
 ·
 0x03a6
 ·
 U+03A6
 ·
 'Φ'
  
 Here we have output the Greek capital letter
  Phi
  (‘
 
 ’) as decimal and hexadeci-mal 
 integers, as a Unicode code point using the
  %U
  (Unicode) verb, and as a Uni-code 
 character using the
  %c
  (character or code point) verb.",NA
3.5.4. Formatting Floating-Point Numbers,"For floating-point numbers we can specify the overall width, the number of dig-its 
 after the decimal place—and whether to use standard or scientific notation.
  
 for
  _, x :=
  range
  []float64{
 -.258
 ,
  7194.84
 ,
  -60897162.0218
 ,
  1.500089e-8
 } {
  
  
  fmt.Printf(
 ""|%20.5e|%20.5f|%s|\n""
 , x, x, Humanize(x,
  20
 ,
  5
 ,
  '*'
 ,
  ','
 )) }
  
 |
 ········
 -2.58000e-01|
 ············
 -0.25800|************-0.25800|
  
  
 |
 ·········
 7.19484e+03|
 ··········
 7194.84000|*********7,194.84000|
  
  
 |
 ········
 -6.08972e+07|
 ·····
 -60897162.02180|***-60,897,162.02180|
  
 |
 ·········
 1.50009e-08|
 ·············
 0.00000|*************0.00000|
  
    
 Here we have used a
  for
  …
 range
  loop to iterate over the numbers in a slice literal of
  
 float64
  items.
  
 The custom
  Humanize()
  function returns a string representation of the number it is 
 given with grouping separators (for languages that use simple three-digit groups) 
 and padding.
  
 func
  Humanize(amount float64, width, decimals int,
  
  
  pad, separator rune) string {
  
  
  dollars, cents := math.Modf(amount)
  
  
  whole := fmt.Sprintf(
 ""%+.0f""
 , dollars)[
 1
 :]
  // Strip ""±""
  
  
  fraction :=
  """" 
  
  
  
 if
  decimals >
  0
  {
  
  
   
  fraction = fmt.Sprintf(
 ""%+.*f""
 , decimals, cents)[
 2
 :]
  // Strip ""±0""
  
  }
  
  
  sep := string(separator) 
  
  
  
 for
  i :=
  len
 (whole) -
  3
 ; i >
  0
 ; i -=
  3
  {
  
  
   
  whole = whole[:i] + sep + whole[i:]
  
  
  } 
  
  
  
 if
  amount <
  0.0
  {
  
  
   
  whole =
  ""-""
  + whole
  
  
  }
  
  
  number := whole + fraction
  
  
  gap := width - utf8.RuneCountInString(number) 
  
  
  
 if
  gap >
  0
  { 
  
  
   
  
 return
  strings.Repeat(string(pad), gap) + number
  
  
  } 
  
  
  
 return
  number 
  
 }
  
 The
  math.Modf()
  function returns the whole and fractional parts of a
  float64
  as two
  
 float64
 s. To get the whole part as a string we use the
  fmt.Sprintf()
  function",NA
3.5.5. Formatting Strings and Slices,"Strings can be output with a minimum field width (which the print functions will 
 pad with spaces if the string is too short), and with a maximum number of 
 characters(which will result in truncation for any string that’s too long).Strings can 
 be output as Unicode (i.e., characters), or as a sequence of code points (i.e., 
 rune
 s) or 
 as the UTF-8 bytes that represent them.",NA
3.5.6. Formatting for Debugging,"The
  %T
  (type) verb is used to print a built-in or custom value’s type, and the
  %v 
 verb is used to print a built-in value’s value. In fact,
  %v
  can also print the value of 
 custom types, using a default format for types that do not have a
  String() 
 method 
 defined, or using the type’s
  String()
  method if it has one.",NA
3.6. Other String-Related Packages,"Go’s considerable support for stringsdoesn’t stop at indexing and slicing,or with the 
 versatile
  fmt
  package’sfunctions. The
  strings
  package in particular provides very rich 
 functionality, and the
  strconv
 ,
  unicode/utf8
 , and
  unicode
  packages also provide lots of 
 useful functions. Examples that make use of functionality from all these packages 
 are presented in this section. Regular expressions—provided by the powerful
  regexp
  
 package introduced later in this section—are used in several examples throughout 
 the book.
  
 There are other packages in the standard library that provide string-related 
 functionality, and some of them are covered elsewhere in the book either in 
 examples or in exercises.",NA
3.6.1. The Strings Package,"A common requirement in string processing is to be able to split a string into a slice 
 of separate strings and then do further processing—for example, convert strings to 
 numbers or trim whitespace.
  
 To get a flavor of how to use some of the
  strings
  package’s functions we will review 
 some tiny examples that show some of the functions in use. All the package’s 
 functions are listed in Tables 3.6 and 3.7 (
 ➤
  108–109). Let’s start with splitting 
 strings.
  
 names :=
  ""Niccolò•Noël•Geoffrey•Amélie••Turlough•José"" 
 fmt.Print(
 ""|""
 ) 
  
 for
  _, name :=
  range
  strings.Split(names,
  ""•""
 ) {
  
  
  fmt.Printf(
 ""%s|""
 , name) 
  
 } 
  
 fmt.Println()
  
 |Niccolò|Noël|Geoffrey|Amélie||Turlough|José|
  
 Here we have a bullet-separated list of names (including one blank field) which we 
 split using the
  strings.Split()
  function. This function takes a string to split and a 
 separator string to split on and does as many splits as possible. (If we want to limit 
 the number of splits we can use the
  strings.SplitN()
  function instead.) If we used the
  
 strings.SplitAfter()
  function the output would look like this:
  
  
 |Niccolò•|Noël•|Geoffrey•|Amélie•|•|Turlough•|José|
  
  
 The
  strings.SplitAfter()
  function performs the same splits as the
  strings. Split()
  function 
 but keeps the separator. There is also a
  strings.SplitAfterN() 
 function for when we 
 want to split a specific number of times.
  
 If we need to be able to split on any of two or more different
  characters
  we can use 
 the
  strings.FieldsFunc()
  function.
  
 for
  _, record :=
  range
  []string{
 ""László Lajtha*1892*1963""
 , 
  
  
  
 ""Édouard Lalo\t1823\t1892""
 ,
  ""José Ángel Lamas|1775|1814""
 } {
  
  
 fmt.Println(strings.FieldsFunc(record,
  func
 (char rune) bool { 
  
  
  
   
 switch
  char { 
  
  
   
   
 case
  '\t'
 ,
  '*'
 ,
  '|'
 : 
  
  
   
   
 return true
  
  
   
  } 
  
  
   
  
 return false
  
  
  })) 
  
 }",NA
3.6.2. The Strconv Package,"The
  strconv
  package provides many functions for converting strings into oth-er types 
 and other types into strings. The package’s functions are listed in Ta-bles 3.8 and 3.9 
 (
 ➤
  114–115; see also the
  fmt
  package’s print and scan functions,§3.5, 93 
  
 and 
 §8.2, 
 ➤
  383.) Here we will review a few illustrative examples.
  
 One common requirement is to convert a string representation of a truth value into 
 a
  bool
 . This can be done using the
  strconv.ParseBool()
  function.
  
 for
  _, truth :=
  range
  []string{
 ""1""
 ,
  ""t""
 ,
  ""TRUE""
 ,
  ""false""
 ,
  ""F""
 ,
  ""0""
 ,
  ""5""
 } { 
  
  
 if
  b, 
 err := strconv.ParseBool(truth); err !=
  nil
  {
  
  
   
  fmt.Printf(
 ""\n{%v}""
 , err)
  
  
  }
  else
  {
  
  
   
  fmt.Print(b,
  "" ""
 )
  
  
  } 
  
 } 
  
 fmt.Println()
  
 true
 ·
 true
 ·
 true
 ·
 false
 ·
 false
 ·
 false
  
 {strconv.ParseBool:
 ·
 parsing
 ·
 ""5"":
 ·
 invalid
 ·
 syntax}",NA
3.6.3. The Utf8 Package,"The
  unicode/utf8
  package provides several useful functions for querying and 
 manipulating strings and
  []byte
 s which hold UTF-8 bytes—many of these are shown 
 in Table 3.10. Earlier we saw how to use the
  utf8.DecodeRuneInString()
  
 and
  utf.DecodeLastRuneInString()
  functions (91
  
 ) to get the first and last
  
 characters in a string.",NA
3.6.4. The Unicode Package,"The
  unicode
  package provides functions for querying Unicode code points to 
 determine if they meet certain criteria—for example, whether the character they 
 represent is a digit or a lowercase letter. Table 3.11 shows the most com-monly 
 used functions. In addition to those functions we would expect, such as 
 unicode.ToLower()
  and
  unicode.IsUpper()
 , a generic
  unicode.Is()
  function is pro-vided so 
 that we can check whether a character is in a particular Unicode cate-gory.",NA
3.6.5. The Regexp Package,"This subsection presents tables listing the
  regexp
  package’s functions and the regular 
 expression syntax the package supports, and includes a few illustrative examples. 
 Here and elsewhere in this book, we assume prior knowledge of regular 
 expressions, or “regexeps”.
 ★
  
 The
  regexp
  package is a Go implementation of Russ Cox’s RE2 regular expres-sion 
 engine.
 ✪
 This engine is fast and thread-safe. The RE2 engine doesn’t use 
 backtracking, so guarantees linear time execution O(
 n
 ) where
  n
  is the length of the 
 matched string, whereas backtracking engines can easily take exponential time O(
 n 
 2 
 ) (see the sidebar “Big-O Notation”, 89 ). The superior performance is gained at the 
 expense of having no support for backreferences in searches. However,it is usually 
 straightforward to work around this constraint by making good use of the
  regexp
  
 API.
  
 Table 3.12 lists the
  regexp
  package’s functions, including four functions for creating
  
 *regexp.Regexp
  values. These values provide the methods shown in Tables 3.18 and 
 3.19 (
 ➤
  124–125). The RE2 engine’s syntax supports the escape sequences listed in 
 Table 3.13 (
 ➤
  121), the character classes listed in Table 3.14 (
 ➤
  122), the zero-
 width assertions listed in Table 3.15 (
 ➤
  122), the quantifiers listed in Table 3.16 (
 ➤
  
 123), and the flags listed in Table 3.17 (
 ➤
  123).
  
 The
  regexp.Regexp.ReplaceAll()
  and
  regexp.Regexp.ReplaceAllString()
  methods support 
 both numbered and named replacements. Numbered replacements start at
  $1
  for 
 the first capturing parenthesized match. Named replacements refer to named 
 capture groups. Although replacements can be referred to by number or by name 
 (e.g.,
  $2
 ,
  $filename
 ), it is safest to use braces as delimiters (e.g.,
  ${2}
 ,
  ${filename}
 ). Use
  
 $$
  to include a literal
  $
  in a replacement string.
  
 ★
  A good textbook that teaches regexeps is
  Mastering Regular Expressions;
  see Appendix C. The author’s 
 book,
  Programming in Python 3,
 has a chapter that teaches Python regexeps (these support a subset of
  
 regexp
  syntax).This chapter is available as a free download from
  www.informit.com/title/ 9780321680563
  
 (click the “Sample Content” link and download Chapter 13).
  
 ✪
  Information on RE2, including links to documents covering its rationale, performance, and 
 implementation, is available from
  code.google.com/p/re2/
  .",NA
3.7. Example: M3u2pls,"In this section we will briefly review a short but complete program that reads an 
 arbitrary
  .m3u
  music playlist file given on the command line and outputs an 
 equivalent
  .pls
  playlist file. The program makes a lot of use of the
  strings 
 package and 
 other material covered in this and previous chapters, as well as introducing a few 
 minor new things.
  
 Here is an extract from an
  .m3u
  file with an ellipsis (…) used to elide most of the 
 songs.
  
 #EXTM3U 
  
 #EXTINF:315,David Bowie - Space Oddity 
  
 Music/David Bowie/Singles 1/01-Space Oddity.ogg 
 #EXTINF:-1,David Bowie - Changes 
  
 Music/David Bowie/Singles 1/02-Changes.ogg 
  
 ...
  
 #EXTINF:251,David Bowie - Day In Day Out 
  
 Music/David Bowie/Singles 2/18-Day In Day Out.ogg
  
 The file begins with the literal string
  #EXTM3U
 . Each song is represented by two 
 lines. The first line starts with the literal string
  #EXTINF:
  and is followed by the 
 song’s duration in seconds,then a comma, and then the song’s name. A duration of
  -1
  
 means that the length is unknown (in both formats). The second line is the path to 
 the file that stores the song—here we are using the open, patent-free Vorbis Audio 
 format in an Ogg container (
 www.vorbis.com
 ), and Unix-style path separators.
  
 Here is an extract from an equivalent
  .pls
  file, again with an ellipsis used to elide 
 most of the songs.
  
 [playlist] 
  
 File1=Music/David Bowie/Singles 1/01-Space Oddity.ogg 
 Title1=David Bowie - Space Oddity 
  
 Length1=315 
  
 File2=Music/David Bowie/Singles 1/02-Changes.ogg 
 Title2=David Bowie - Changes 
  
 Length2=-1 
  
 ...
  
 File33=Music/David Bowie/Singles 2/18-Day In Day Out.ogg 
 Title33=David Bowie - Day In Day Out",NA
3.8. Exercises,"There are two exercises for this chapter, the first involving the modification of an 
 existing command-line program, and the second requiring the creation of a web 
 application (optionally) from scratch.
  
 1. The previous section’s
  m3u2pls
  program does a decent job of converting 
 .m3u
  
 playlist files into
  .pls
  format. But what would make the program much more 
 useful is if it could also perform the reverse conversion, from 
 .pls
  format to
  .m3u
  
 format. For this exercise copy the
  m3u2pls
  directo-ry to, say,
  my_playlist
  and 
 create a new program called
  playlist
  that has the required functionality. Its 
 usage message should be
  usage: playlist <file.[pls|m3u]>
 .",NA
4,NA,NA
Collection Types,"§4.1. Values, Pointers, and Reference Types 
 ➤
  
 140§4.2. Arrays and Slices 
 ➤
  148
  
  
 §4.2.1. Indexing and Slicing Slices 
 ➤
  153
  
 §4.2.2. Iterating Slices 
 ➤
  154
  
  
 §4.2.3. Modifying Slices 
 ➤
  156
  
  
 §4.2.4. Sorting and Searching Slices 
 ➤
  160§4.3. 
 Maps 
 ➤
  164
  
  
 §4.3.1. Creating and Populating Maps 
 ➤
  166
  
 §4.3.2. Map Lookups 
 ➤
  168
  
  
 §4.3.3. Modifying Maps 
 ➤
  169
  
  
 §4.3.4. Key-Ordered Map Iteration 
 ➤
  170
  
 §4.3.5. Map Inversion 
 ➤
  170
  
 §4.4. Examples 
 ➤
  171
  
  
 §4.4.1. Example: Guess Separator 
 ➤
  171
  
  
 §4.4.2. Example: Word Frequencies 
 ➤
  174
  
 This chapter’s first section explains Go’s values, pointers, and reference types since 
 an understanding of these is necessary for the rest of the chapter and for 
 subsequent chapters. Go’s pointers work just like those in C and C++, both 
 syntactically and semantically—except that Go does not support pointer arith-metic, 
 thus eliminating a whole category of potential bugs that can affect C and C++ 
 programs. Nor does Go need
  free()
 or
  delete
  since Go has a garbage collector and 
 manages memory automatically.
 ★
 Values of Go’s reference types are cre-ated in a 
 unique and simple way and once created are used rather like Java or Python object 
 references. Go’s values work like those in most other mainstream languages.
  
 This chapter’s other sections are devoted to Go’s built-in collection types. All the 
 built-in collection types are covered—arrays, slices, and maps. These types are
  
 ★
  Go’s
  delete()
  function is used to delete keys from
  map
 s as we will see later in this chapter.
  
 139",NA
"4.1. Values, Pointers, and Reference Types","In this section we discuss what variables hold (values, pointers, and references—
 including array values, and slice and map references), whereas in the follow-ing 
 sections we explain how to actually use arrays, slices, and maps.
  
 In general, Go variables hold values. That is, we can think of a variable as“being” the 
 value it stores. The exceptions are variables that refer to channels, functions, 
 methods, maps, and slices—these hold references—and variables that hold 
 pointers.
  
 Values that are passed to functions or methods are copied. This is cheap for 
 Booleans and numbers because they only occupy from one to eight bytes each. 
 Passing strings by value is also cheap because Go compilers can safely optimize 
 passing them so that only a small amount of data is actually passed per string, no 
 matter how large the string is, since Go strings are immutable. (The amount per 
 string is 16 bytes on 64-bit machines and 8 bytes on 32-bit machines.
 ★
 ) Of course, if 
 a passed-in string is modified (e.g., using the
  +=
  operator), behind the scenes Go 
 must do a copy on write which is potentially expensive for large strings—but this is 
 a price that would have to be paid no matter what language was being used.
  
 Unlike C or C++, Go arrays are passed by value—so passing large arrays is 
 expensive. Fortunately, arrays are rarely needed in Go programming since slices are 
 used instead, as we will see in the next section. Passing a slice costs much the same 
 as passing a string (i.e., 16 bytes on 64-bit machines and 12 bytes on 32-bit 
 machines), no matter what the slice’s length or capacity.
 ★
 Nor is there any copy on 
 write overhead if the slice is modified, because unlike strings, slices are mutable 
 (i.e., if a slice is modified the modification is visible to all the variables—
 references—that refer to it).
  
 Figure 4.1 illustrates the relationship between variables and the memory they 
 occupy. In the figure, memory addresses are shown in gray since they will vary, and 
 bold is used to indicate changes.
  
 Conceptually, a variable is the name given to a piece of memory that holds a value of 
 a particular type. So if we have the short variable declaration
  y := 1.5
 ,
  
 ★
  The sizes in bytes were measured on a 64-bit machine and on a 32-bit machine at the time of this 
 writing. The amounts are implementation details that may vary but will never be large.",NA
4.2. Arrays and Slices,"A Go array is a fixed-length sequence of itemsof the same type.Multidimension-al 
 arrays can be created simply by using items that are themselves arrays.
  
 Array items are indexed using the
  []
  index operator by their 0-based position,so an 
 array’s first item is
  array
 [0]
  and its last item is
  array
 [len(
 array
 ) - 1]
 . Arrays are 
 mutable, so we can use the syntax
  array
 [
 index
 ]
  on the left of an assignment
  
 ★
  Go doesn’t have or need the
  ->
  dereferencing operator used in C and C++. Go’s
  .
  (dot) operator is 
 sufficient for most situations (e.g., to access the fields in a
  struct
  or a pointer to a
  struct
 ), and where it isn’t, 
 we can explicitly dereference using as many
  *
  operators as there are levels of indirection.",NA
4.2.1. Indexing and Slicing Slices,"A slice is a reference to a hidden array and slices of slices are also references to the 
 same hidden array. Here is an example to illustrate what this means.
  
 s := []string{
 ""A""
 ,
  ""B""
 ,
  ""C""
 ,
  ""D""
 ,
  ""E""
 ,
  ""F""
 ,
  ""G""
 } t := s[
 2
 :
 6
 ] 
  
 fmt.Println(t, s,
  ""=""
 , s[:
 4
 ],
  ""+""
 , s[
 4
 :]) 
  
 s[
 3
 ] =
  ""x"" 
  
 t[
 len
 (t)
 -1
 ] =
  ""y"" 
  
 fmt.Println(t, s,
  ""=""
 , s[:
 4
 ],
  ""+""
 , s[
 4
 :])
  
 [C D E F] [A B C D E F G] = [A B C D] + [E F G]
  
 [C x E y] [A B C x E y G] = [A B C x] + [E y G]
  
  
 When we change the data—whether via the original
  s
  slice or from the
  t
  slice of the
  s
  
 slice—the same underlying data is changed, so both slices are affected. The code 
 snippet also illustrates that given a slice
  s
  and an index position
  i
  (
 0
  
 i
  
  len(
 s
 )
 ),
  s
  is 
 equal to the concatenation of
  s
 [:
 i
 ]
  and
  s
 [
 i
 :]
 . We saw a similar equality in the previous 
 chapter in reference to strings:
  
 s == s[:i] + s[i:]
  // s is a string; i is an int; 0 <= i <= len(s)",NA
4.2.2. Iterating Slices,"One frequent requirement is to iterate over all the items in a slice. If we want to 
 access the items without modifying them we can use a
  for
  …
  range
  loop; and if we 
 need to modify items we can use a
  for
  loop with a loop counter. Here is an example 
 of the former.
  
 amounts := []float64{
 237.81
 ,
  261.87
 ,
  273.93
 ,
  279.99
 ,
  281.07
 ,
  303.17
 , 
  
  
 231.47
 ,
  227.33
 ,
  209.23
 ,
  197.09
 } 
  
 sum :=
  0.0 
  
 for
  _, amount :=
  range
  amounts {
  
  
  sum += amount 
  
 } 
  
 fmt.Printf(
 ""Σ %.1f → %.1f\n""
 , amounts, sum)
  
 Σ [237.8 261.9 273.9 280.0 281.1 303.2 231.5 227.3 209.2 197.1] → 2503.0
  
 The
  for
  …
  range
  loop assigns a 0-based loop counter, which in this case we have 
 discarded using the blank identifier (
 _
 ), and a
  copy
  of the corresponding item from 
 the slice. The copy is cheap even for strings (since they are passed by reference). 
 This means that any changes that are applied to the item affect only the copy, not 
 the item in the slice.
  
 Naturally, we can use slicing to iterate over just a portion of the slice. For example, if 
 we just wanted to iterate over the first five items we would write
  for _, amount := 
 range amounts[:5]
 .
  
 If we want to modify the items in the slice we must use a
  for
  loop that just provides 
 valid slice indexes and not copies of the slice’s items.",NA
4.2.3. Modifying Slices,"If we need to append to a slice we can use the built-in
  append()
  function. This 
 function takes the slice to be appended to and one or more
  individual
  items to 
 append. If we want to append a slice to a slice we must use the
  ...
  (ellipsis) operator 
 to tell Go to pass the slice to be added as individual values. The values to append 
 must be of the same type as the slice’s value type. In the case of a string we can 
 append its individual bytes to a byte slice by using the ellipsis syntax.
  
 s := []string{
 ""A""
 ,
  ""B""
 ,
  ""C""
 ,
  ""D""
 ,
  ""E""
 ,
  ""F""
 ,
  ""G""
 } 
  
 t := []string{
 ""K""
 ,
  ""L""
 ,
  ""M""
 ,
  ""N""
 } 
  
 u := []string{
 ""m""
 ,
  ""n""
 ,
  ""o""
 ,
  ""p""
 ,
  ""q""
 ,
  ""r""
 } 
  
 s =
  append
 (s,
  ""h""
 ,
  ""i""
 ,
  ""j""
 )
  // Append individual values 
  
 s =
  append
 (s, t...)          
 // Append all of a slice's values 
  
 s =
  append
 (s, u[
 2
 :
 5
 ]...) 
  
 // Append a subslice 
  
 b := []byte{
 'U'
 ,
  'V'
 } 
  
 letters :=
  ""wxy"" 
  
 b =
  append
 (b, letters...)    
 // Append a string's bytes to a byte slice 
 fmt.Printf(
 ""%v\n%s\n""
 , s, b)
  
 [A B C D E F G h i j K L M N o p q]
  
 UVwxy
  
  
 The built-in
  append()
  function takes a slice and one or more values and returns a 
 (possibly new) slice which has the original slice’s contents,plus the given value or 
 values as its last item or items. If the original slice’s capacity is sufficient for the new 
 items (i.e., its length plus the number of new items is within its capac-
  
 ★
  One compiler does this as follows. Whenever a method is created that operates on a value, say it is 
 called
  Method()
 , a wrapper method of the same name and signature is created that has a pointer 
 receiver—in effect,
  func (
 value
  *
 Type
 ) Method() { return (
 *
 value
 ).Method() }
 .",NA
4.2.4. Sorting and Searching Slices,"The standard library’s
  sort
  package provides functions for sorting slices of
  int
 s, 
 float64
 s, and
  string
 s, for checking if such a slice is sorted, and for searching for an 
 item in a sorted slice using the fast binary search algorithm. There are also generic
  
 sort.Sort()
  and
  sort.Search()
  functions that can easily be used with custom data. These 
 functions are listed in Table 4.2.
  
 The way that Go sorts numbers holds no surprises,as we saw in an earlier chap-ter 
 (73 
  
 ). However,
  string
 s are sorted purely in terms of the bytes that repre-sent 
 them, as we discussed in the previous chapter (§3.2, 86 
  
 ). This means, for 
 example,that string sorting is case-sensitive. Here are a couple of string sorting 
 examples and the results they produce.
  
 files := []string{
 ""Test.conf""
 ,
  ""util.go""
 ,
  ""Makefile""
 ,
  ""misc.go""
 ,
  ""main.go""
 } fmt.Printf(
 ""Unsorted:         
 %q\n""
 , files) 
  
 sort.Strings(files) 
  
 // Standard library sort function 
  
 fmt.Printf(
 ""Underlying bytes: %q\n""
 , files) 
  
 SortFoldedStrings(files)
  // Custom sort function 
  
 fmt.Printf(
 ""Case insensitive: %q\n""
 , files)
  
 Unsorted:         [""Test.conf"" ""util.go"" ""Makefile"" ""misc.go"" ""main.go""]
  
  
 Underlying bytes: [""Makefile"" ""Test.conf"" ""main.go"" ""misc.go"" ""util.go""]
  
   
 Case insensitive: [""main.go"" ""Makefile"" ""misc.go"" ""Test.conf"" ""util.go""]",NA
4.3. Maps,"A Go map is an unordered collection of
  key
 –
 value
  pairs whose capacity is limited 
 only by machine memory.
 ★
 Keys are unique and may only be of a type that sensibly 
 supports the
  ==
  and
  !=
  operators—so most of the built-in types can be used as keys 
 (e.g.,
  int
 ,
  float64
 ,
  rune
 ,
  string
 , comparable arrays and
  struct
 s, and custom types based 
 on these, as well as pointers). Slices and noncomparable arrays and
  struct
 s (i.e., 
 those whose items or fields don’t support
  ==
  and
  !=
 ), or custom types based on them, 
 may not be used as map keys. Pointers, reference types, or values of any built-in or 
 custom type can be used as values—including maps, so it is easy to create data 
 structures of arbitrary complexity. Go’s map operations are listed in Table 4.3.
  
 Maps are reference types that are cheap to pass (e.g., 8 bytes on 64-bit ma-chines 
 and 4 bytes on 32-bit machines), no matter how much data they hold. Map lookups 
 are fast—vastly faster than a linear search—although about two orders of 
 magnitude (i.e., 100 times) slower than direct indexing into an array or slice, 
 according to informal experiments.
 ✪
 This is still so fast that it makes sense to use 
 maps wherever they are needed, since performance is very unlike-ly to be a 
 problem in practice. Figure 4.5 shows a schematic of a map of type 
 map[string]float64
 .
  
 Since slices cannot be used as map keys it would appear that we cannot use byte 
 slices (
 []byte
 ) for keys. However, since the conversions
  string([]byte)
  and 
 []byte(string)
  
 do not change the bytes,we can safely convert
  []byte
 s into strings to use as map keys 
 and then convert them back to
  []byte
 s as needed.
  
 A map’s keys must all be of the same type, and so must its values—although the key 
 and value types can (and often do) differ. With respect to a map’s val-
  
 ★
 The Go map data structure is sometimes called a hash map, hash table, unordered map, dictionary, or 
 associative array in other contexts.
  
 ✪
  No time complexity data on maps was available at the time of this writing.",NA
4.3.1. Creating and Populating Maps,"Here is an example that shows the creation and population of a map with
  string 
 keys 
 and
  float64
  values.
  
 massForPlanet :=
  make
 (
 map
 [string]float64)
  // Same as: map[string]float64{} 
 massForPlanet[
 ""Mercury""
 ] =
  0.06 
  
 massForPlanet[
 ""Venus""
 ] =
  0.82 
  
 massForPlanet[
 ""Earth""
 ] =
  1.00 
  
 massForPlanet[
 ""Mars""
 ] =
  0.11 
  
 fmt.Println(massForPlanet)
  
 map[Venus:0.82 Mars:0.11 Earth:1 Mercury:0.06]
  
 For small maps it doesn’t really matter whether we specify their initial capacity, but 
 for large maps doing so can improve performance. In general it is best to specify the 
 initial capacity if it is known (even if only approximately).
  
 Maps use the
  []
  index operator just like arrays and slices, only for maps the index 
 inside the square brackets is of the map’s key type which might not be an 
 int
 —here, 
 for example, we have
  string
  keys.
  
 To print the map to the console we have used the
  fmt.Println()
  function; this uses the
  
 %v
  formatting verb and outputs the map’s items space-separated in
  key: value
  form. 
 Maps are unordered, so on a different machine the order of items printed may be 
 different from that shown here.
  
 As noted earlier, pointers can be used as map keys. We will look at an example 
 whose keys are of type
  *Point
  and where
  Point
  is defined as follows:
  
 type
  Point
  struct
 { x, y, z int }
  
 func
  (point Point) String() string { 
  
  
 return
  fmt.Sprintf(
 ""(%d,%d,%d)""
 , point.x, point.y, point.z) }
  
 The
  Point
  type stores three
  int
 s. It has a
  String()
  method which ensures that when we 
 print a
  *Point
  Go will use the
  String()
  method rather than simply printing the
  Point
 ’s 
 memory address.
  
 Incidentally, we can always force Go to print a memory address by using the
  %p
  
 format verb; the format verbs were covered earlier (§3.5.6, 103
  
 ).",NA
4.3.2. Map Lookups,"Go provides two very similar syntaxes for map lookups, both of which use the
  [] 
 index operator. Here are a couple of examples of the simplest syntax.
  
 population := populationForCity[
 ""Mumbai""
 ] 
  
 fmt.Println(
 ""Mumbai's population is""
 , population) 
  
 population = populationForCity[
 ""Emerald City""
 ] 
  
 fmt.Println(
 ""Emerald City's population is""
 , population)
  
 Mumbai's population is 12690000
  
 Emerald City's population is 0
  
  
 If we look up a key that is present in the map the corresponding value is re-turned. 
 But if the key is not present then the map’s value type’s zero value is returned. So, in 
 this example, we cannot tell whether the
  0
  returned for the 
 ""Emerald City""
  key means 
 that the population of Emerald City really is zero, or that the city isn’t in the map. 
 Go’s second map lookup syntax provides the solu-tion to this problem.
  
 city :=
  ""Istanbul"" 
  
 if
  population, found := populationForCity[city]; found {
  
  fmt.Printf(
 ""%s's 
 population is %d\n""
 , city, population) }
  else
  {
  
  
  fmt.Printf(
 ""%s's population data is unavailable\n""
 , city) } 
  
 city =
  ""Emerald City"" 
  
 _, present := populationForCity[city] 
  
 fmt.Printf(
 ""%q is in the map == %t\n""
 , city, present)
  
 Istanbul's population is 12610000
  
 ""Emerald City"" is in the map == false
  
  
 If we provide
  two
  variables for the map’s
  []
  index operator to return to, the first will 
 get the value that corresponds to the key (or the map’s value type’s zero value if the 
 key isn’t present), and the second will get
  true
  (or
  false
  if the key",NA
4.3.3. Modifying Maps,"Items, that is,
  key
 –
 value
  pairs, can be inserted into maps and deleted from maps. 
 And any given key’s value can be changed. Here are a few illustrative examples.
  
 fmt.Println(
 len
 (populationForCity), populationForCity) 
 delete
 (populationForCity,
  ""Shanghai""
 ) 
  
 // Delete 
 fmt.Println(
 len
 (populationForCity), populationForCity) 
 populationForCity[
 ""Karachi""
 ] =
  11620000
  // Update 
 fmt.Println(
 len
 (populationForCity), populationForCity) 
 populationForCity[
 ""Beijing""
 ] =
  11290000
  // Insert 
 fmt.Println(
 len
 (populationForCity), populationForCity)
  
 4 map[Shanghai:13680000 Mumbai:12690000 Istanbul:12610000 Karachi:10620000] 3 
 map[Mumbai:12690000 Istanbul:12610000 Karachi:10620000] 
  
 3 map[Mumbai:12690000 Istanbul:12610000 Karachi:11620000] 
  
 4 map[Mumbai:12690000 Istanbul:12610000 Karachi:11620000 Beijing:11290000]
  
 The syntax for inserting and updating map items is identical: If an item with the 
 given key isn’t present, a new item with the given key and value will be inserted; 
 and if an item with the given key is present, its value will be set to the given value, 
 and the original value will be discarded. And if we try to delete an item which isn’t 
 in the map, Go will safely do nothing.
  
 Keys cannot be changed as such,but the effect of changing a key can be achieved like 
 this:
  
 oldKey, newKey :=
  ""Beijing""
 ,
  ""Tokyo"" 
  
 value := populationForCity[oldKey] 
  
 delete
 (populationForCity, oldKey) 
  
 populationForCity[newKey] = value 
  
 fmt.Println(
 len
 (populationForCity), populationForCity)
  
 4 map[Mumbai:12690000 Istanbul:12610000 Karachi:11620000 Tokyo:11290000]
  
 We retrieve the old key’s value, delete the item which has the old key, and create a 
 new item with the new key and with the old key’s value.",NA
4.3.4. Key-Ordered Map Iteration,"When producing data for human consumption we often need to present the data in 
 some recognizable order. Here is an example that shows how to output the 
 populationForCity
  map in alphabetical (strictly speaking, Unicode code point) order 
 of city.
  
 cities :=
  make
 ([]string,
  0
 ,
  len
 (populationForCity)) 
  
 for
  city :=
  range
  populationForCity {
  
  
  cities =
  append
 (cities, city) 
  
 } 
  
 sort.Strings(cities) 
  
 for
  _, city :=
  range
  cities {
  
  
  fmt.Printf(
 ""%-10s %8d\n""
 , city, populationForCity[city]) }
  
 Beijing 
  
 Istanbul 
 Karachi 
  
 Mumbai
  
 1129000
 0 
  
 1261000
 0 
  
 1162000
 0 
  
 1269000
 0
  
  
 We begin by creating a slice of type
  []string
  with zero length (i.e., empty), but with 
 enough capacity to hold all of the map’s keys. Then we iterate over the map 
 retrieving only the keys (since we have used just one variable,
  city
 , rather than the 
 two needed to retrieve each
  key
 –
 value
  pair), and appending each city in turn to the
  
 cities
  slice. Next, we sort the slice, and then we iterate over the slice (ignoring the
  int
  
 index by using the blank identifier), looking up the corresponding city’s population 
 at each iteration.
  
 The algorithm shown here—create an empty slice large enough to hold all the map’s 
 keys, add all the map’s keys to the slice, sort the slice, and iterate over the slice to 
 produce ordered output—can be applied generally for key-ordered map iteration.
  
 An alternative to the approach taken here is to use an ordered data structure in the 
 first place—for example, an ordered map. We will see an example of this in a later 
 chapter (§6.5.3, 
 ➤
  302).
  
 Value ordering is also possible, for example, by doing a map inversion, as we will see 
 in the next subsection.",NA
4.3.5. Map Inversion,"We can easily invert a map whose
  values
  are unique—and whose type is acceptable 
 for use as map keys. Here is an example.
  
 cityForPopulation :=
  make
 (
 map
 [int]string,
  len
 (populationForCity))",NA
4.4. Examples,"In this section we will review two small examples, the first illustrating one- and two-
 dimensional slices, and the second illustrating maps, including map inver-sion 
 where the map’s values may not be unique, as well as slices and sorting.",NA
4.4.1. Example: Guess Separator,"In some situations we might receive a whole bunch of data files for processing 
 where each file has one record per line, but where different files might use dif-ferent 
 separators (e.g., tabs or whitespace or “
 *
 ”s). To be able to process such files in bulk 
 we need to be able to determine the separator used for each file. The
  guess_separator
  
 example shown in this section (in file
  guess_separator/ guess_separator.go
 ) attempts to 
 identify the separator for the file it is given to work on.
  
 Here is an example of a typical run:
  
  
  
 $
  ./guess_separator information.dat
  
 tab-separated
  
   
 The program reads in the first five lines (or as many lines as the file contains if fewer 
 than five) and uses these to guess the separator that is being used.
  
 As usual,we will review the
  main()
  function and the functions it calls (apart from one 
 that’s routine), and we will skip the imports.",NA
4.4.2. Example: Word Frequencies,"Textual analysis has a variety of uses, from data mining to the study of language 
 itself. In this subsection we will review an example that performs one of the most 
 basic forms of textual analysis: It counts the frequencies of words in the files it is 
 given.
  
 Frequency data can be presented in two different but equally sensible ways—as an 
 alphabetical list of words with their frequencies, and as an ordered list of frequency 
 values and the words that have the corresponding frequencies. The 
 wordfrequency
  
 program (in file
  wordfrequency/wordfrequency.go
 ) produces both kinds of output, as 
 illustrated below.
  
  
  
 $
  ./wordfrequency small-file.txt
  
  
 Word        Frequency
  
  
 ability             1
  
  
 about               1
  
  
 above               3
  
  
 ...
  
  
 years               1
  
 you               128
  
 Frequency → Words",NA
4.5. Exercises,"There are five exercises, each one requiring the creation of a small function, and 
 drawing on the coverage of slices and maps presented in this chapter. We have put 
 all five functions in the same
  .go
  file (
 chap4_ans/chap4_ans.go
 ), and added a 
 main()
  
 function that makes use of them all to make testing easier. (Proper unit testing is 
 covered later, in Chapter 9, §9.1.1.3, 
 ➤
  414.)
  
 1. Create a function that accepts an
  []int
  and returns an
  []int
  which is a copy of the 
 given
  []int
  but with duplicates removed. For example, given an argument of
  
 []int{9, 1, 9, 5, 4, 4, 2, 1, 5, 4, 8, 8, 4, 3, 6, 9, 5, 7, 5}
 , the function should return
  []int{9, 
 1, 5, 4, 2, 8, 3, 6, 7}
 . In the
  chap4_ans.go 
 solution file the function is called
  
 UniqueInts()
 . The function uses composite",NA
5,NA,NA
Procedural ,NA,NA
Programming,"§5.1. Statement Basics 
 ➤
  186
  
  
 §5.1.1. Type Conversions 
 ➤
  190
  
  
 §5.1.2. Type Assertions 
 ➤
  191
  
 §5.2. Branching 
 ➤
  192
  
  
 §5.2.1. If Statements 
 ➤
  192
  
  
 §5.2.2. Switch Statements 
 ➤
  195
  
 §5.3. Looping with For Statements 
 ➤
  203
  
 §5.4. Communication and Concurrency Statements 
 ➤
  205
  
 §5.4.1. Select Statements 
 ➤
  209
  
 §5.5. Defer, Panic, and Recover 
 ➤
  212
  
  
 §5.5.1. Panic and Recover 
 ➤
  213
  
 §5.6. Custom Functions 
 ➤
  219
  
  
 §5.6.1. Function Arguments 
 ➤
  220
  
  
 §5.6.2. The init() and main() Functions 
 ➤
  224
  
  
 §5.6.3. Closures 
 ➤
  225
  
  
 §5.6.4. Recursive Functions 
 ➤
  227
  
  
 §5.6.5. Choosing Functions at Runtime 
 ➤
  230
  
  
 §5.6.6. Generic Functions 
 ➤
  232
  
  
 §5.6.7. Higher Order Functions 
 ➤
  238
  
 §5.7. Example: Indent Sort 
 ➤
  244
  
 The purpose of this chapter is to complete the coverage of Go procedural pro-
 gramming that the earlier chapters began. Go can be used to write purely pro-
 cedural programs, to write object-oriented programs, or to write programs that 
 combine both paradigms. It is important to learn procedural Go since object-
 oriented Go builds on the procedural foundations, as does concurrent Go pro-
 gramming.
  
 185",NA
5.1. Statement Basics,"Formally, Go’s syntax requires the use of semicolons (
 ;
 ) as statement termina-tors in 
 many contexts. However, as we have seen, very few semicolons are need-ed in real 
 Go programs. This is because the compiler will conveniently insert semicolons 
 automatically at the end of nonblank lines that end with an identifi-er, a number 
 literal, a character literal, a string literal, certain keywords (
 break
 , 
 continue
 ,
  
 fallthrough
 ,
  return
 ), an increment or decrement operator (
 ++
  or
  --
 ), or a closing 
 parenthesis, bracket, or brace (
 )
 ,
  ]
 ,
  }
 ).
  
 Two common cases where semicolons must be manually inserted are when we want 
 to have two or more statements on the same line and in plain
  for
  loops (§5.3, 
 ➤
  
 203).
  
 An important consequence of the automatic semicolon insertion is that an opening 
 brace cannot occur on its own line.
  
 // Correct
  
 ✓
 // WRONG! (This won't compile.)
  
 ✗
  
 for
  i :=
  0
 ; i <
  5
 ; i++ { 
 for
  i :=
  0
 ; i <
  5
 ; i++
  
  fmt.Println(i) {
  
 }
  
  fmt.Println(i)
  
 }
  
 The right-hand code snippet won’t compile because the compiler will insert a 
 semicolon after the
  ++
 . Similarly, if we had an infinite loop (
 for
 ) with the brace 
 starting on the next line, the compiler would insert a semicolon after the
  for
 , and 
 again the code wouldn’t compile.
  
 The æsthetics of brace placement usually generate endless arguments—but not in 
 Go. This is partly because the automatic semicolons constrain brace placement and 
 partly because many Go users use the
  gofmt
  program which
  
 Use functions like
  fmt.Print()
  instead (§3.5, 93
  
 ).
  
 They exist for the convenience of Go compiler implementers and may be removed from the language.
 ★
  
 Table 5.1 does not list the built-in
  print()
  and
  println()
  functions since they should
  not
  be used.",NA
5.1.1. Type Conversions,"Go provides a means of converting between different—compatible—types, and such 
 conversions are useful and safe. For conversions between non-numeric types no 
 loss of accuracy occurs. But for conversions between nu-meric types, loss of 
 accuracy or other effects may occur. For example, if we have
  x
  := uint16(65000)
  and 
 then use the conversion
  y
  := int16(
 x
 )
 , since
  x
  is outside the
  int16
  range,
  y
 ’s value is set 
 to the unsurprising—but probably undesirable—value of
  -536
 .
  
 Here is the conversion syntax:
  
 resultOfType
  :=
  Type
 (
 expression
 )
  
 For numbers, essentially we can convert any integer or floating-point number to 
 another integer or floating-point type (with possible loss of accuracy if the target 
 type is smaller than the source type). The same applies to converting
  
 between
  complex128
  and
  complex64
  types. We discussed numeric conversions in
  
 §2.3 (58
  
 and 69
  
 ).
  
 A string can be converted to a
  []byte
  (its underlying UTF-8 bytes) or to a
  []rune 
 (its 
 Unicode code points), and both a
  []byte
  and a
  []rune
  can be converted to a 
 string
 . A 
 single character is a
  rune
  (i.e., an
  int32
 ), and can be converted to a one-character
  
 string
 . String and character conversions were covered in Chapter 3
  
 (87
  
 and 88
  
 ; also Table 3.2, 85
  
 , and Tables 3.8 and 3.9, 114–115
  
 ).
  
 Let’s look at a tiny illustrative example, starting with a simple custom type.
  
 type
  StringSlice []string
  
 This type also has a custom
  StringSlice.String()
  function (not shown) that returns a
  
 string
  representation of the string slice in the form used to create a custom
  StringSlice
  
 using composite literal syntax.
  
 fancy := StringSlice{
 ""Lithium""
 ,
  ""Sodium""
 ,
  ""Potassium""
 ,
  ""Rubidium""
 } 
 fmt.Println(fancy) 
  
 plain := []string(fancy) 
  
 fmt.Println(plain)",NA
5.1.2. Type Assertions,"A type’s
  method set
  is the set of all the methods that can be called on a value of the 
 type—this set is empty for types that have no methods. The Go
  interface{} 
 type is 
 used to represent the empty interface, that is, a value of a type whose method set 
 includes the empty set. Since every type has a method set that includes the empty 
 set (no matter how many methods it has), an
  interface{}
  can be used to represent a 
 value of
  any
  Go type. Furthermore, we can convert an 
 interface{}
  to a value of the 
 actual type it holds using a type
  switch
  (see §5.2.2.2,
 ➤
  197), or a type assertion, or 
 by doing introspection with Go’s
  reflect
  package (§9.4.9, 
 ➤
  427).
 ✪
  
 The use of variables of type
  interface{}
  (or of custom interface types) can arise when 
 we are handling data received from external sources, when we want to create 
 generic functions, and when doing object-oriented programming. To access the 
 underlying value, one approach is to use a type assertion using one of these 
 syntaxes:
  
 resultOfType
 ,
  boolean
  :=
  expression
 .(
 Type
 ) //
  Checked
  
 resultOfType
  :=
  expression
 .(
 Type
 )      //
  Unchecked; panic() on failure
  
 A successful checked type assertion returns the expression as a value of the 
 specified
  Type
  and
  true
  to indicate success. If the checked type assertion fails (i.e., the 
 expression’s type is not compatible with the specified
  Type
 ), a zero value of the 
 specified
  Type
  and
  false
  are returned. Unchecked type assertions either return the 
 expression as a value of the specified
  Type
  or call the built-in
  panic()
  
 ★
 Other more obscure conversions are also possible; these are covered in the Go specification (
 golang. 
 org/doc/go_spec.html
 ).
  
 ✪
 Python programmers may find it helpful to think of
  interface{}
  as being like an instance of
  object
 , and 
 Java programmersas being like an instance of
  Object
 ,although unlike Java’s
 Object
 ,
  interface{} 
 can be used 
 to represent both custom and built-in types. For C and C++ programmers,
  interface{} 
 is rather like a
  void
 *
  
 that knows what type it is.",NA
5.2. Branching,"Go provides three branching statements:
  if
 ,
  switch
 , and
  select
 —the latter is discussed 
 further on (§5.4.1, 
 ➤
  209). A branching effect can also be achieved using a map 
 whose keys are used to select the “branch” and whose values are corresponding 
 functions to call—something we will see later in the chapter (§5.6.5, 
 ➤
  230).",NA
5.2.1. If Statements,"Go’s
  if
  statement has the following syntax:
  
 if
  optionalStatement1
 ;
  booleanExpression1
  {
  
 block1
  
 }
  else if
  optionalStatement2
 ;
  booleanExpression2
  {",NA
5.2.2. Switch Statements,"There are two kinds of
  switch
  statement:expression switches and type switches. 
 Expression switches will be familiar to C, C++, and Java programmers, whereas type 
 switches are specific to Go. Both kinds are syntactically very similar, but unlike C, 
 C++, and Java, Go’s switch statements do not fall through (so there is no need to put 
 a
  break
  at the end of every
  case
 ); instead we can request fallthrough explicitly by 
 using the
  fallthrough
  statement when it is needed.
  
 5.2.2.1. Expression Switches
  
 Go’s
  expression
  switch
  statement has the following syntax:
  
 switch
  optionalStatement
 ;
  optionalExpression
  {
  
 case
  expressionList1
 :
  block1
  
 ...
  
 case
  expressionListN
 :
  blockN
  
 default
 :
  blockD
  
 }
  
 The semicolon is required if the optional statement is present, regardless of whether 
 the optional expression is present. Each block consists of zero or more statements.
  
 If the
  switch
  has no optional expression the compiler assumes an expression of 
 true
 . 
 The optional statement is the same kind of simple statement that can be
  
 used with
  if
  statements (193
  
 ). If variables are created in the optional state-
  
 ment (e.g., using the
  :=
  operator), their scope extends from the point of declara-tion 
 to the end of the complete
  switch
  statement—so they exist in every
  case
  and in the
  
 default
  case, and cease to exist at the end of the
  switch
  statement.
  
 The most efficient way to order
  case
 s is from most likely to least likely, although this 
 only really matters when there are lots of cases and the
  switch
  is executed 
 repeatedly. Since cases do
  not
  automatically fall through, there is no need to put a
  
 break
  at the end of each case’s block. If fallthrough is wanted we simply use a
  
 fallthrough
  statement. The
  default
  case is optional and if present may appear 
 anywhere. If no case’s expression matches, the default case is executed if it is 
 present; otherwise processing continues from the statement following the 
 switch
  
 statement.
  
 Each
  case
  must have an expression list of one or more comma-separated expressions 
 whose type matches the
  switch
  statement’s optional expression’s type. If no optional 
 expression is present the compiler sets it to
  true
 , that is, of type
  bool
 , in which case 
 every expression in each
  case
  clause’s expression list must evaluate to a
  bool
 .
  
 If a
  case
  or
  default
  clause has a
  break
  statement, the
  switch
  statement will im-
 mediately be broken out of, with control passing to the statement following the",NA
5.3. Looping with For Statements,"Go uses two kinds of
  for
  statements for looping, plain
  for
  statements and
  for
  …
 range
  
 statements. Here are their syntaxes:
  
 for
  { //
  Infinite loop 
  
 block 
  
 }
  
 for
  booleanExpression
  { //
  While loop 
  
 block 
  
 }
  
 for
  optionalPreStatement
 ;
  booleanExpression
 ;
  optionalPostStatement
  {
  
 ➊
 block 
  
 }
  
 for
  index
 ,
  char
  :=
  range
  aString
  { //
  String per character iteration
  
 ➋
 block 
  
 }
  
 for
  index
  :=
  range
  aString
  { //
  String per character iteration
  
 ➌
 block
  //
  char, size := 
 utf8.DecodeRuneInString(aString[index:]) 
 }
  
 for
  index
 ,
  item
  :=
  range
  anArrayOrSlice
  { //
  Array or slice iteration
  
 ➍
 block 
  
 }
  
 for
  index
  :=
  range
  anArrayOrSlice
  { //
  Array or slice iteration
  
 ➎
 block
  //
  item := 
 anArrayOrSlice[index] 
  
 }
  
 for
  key
 ,
  value
  :=
  range
  aMap
  { //
  Map iteration
  
 ➏
 block 
  
 }
  
 for
  key
  :=
  range
  aMap
  { //
  Map iteration
  
 ➐
  
 block
  //
  value := aMap[key] 
  
 }
  
 for
  item
  :=
  range
  aChannel
  { //
  Channel iteration block 
  
 }
  
 The braces are mandatory, but a semicolon is only needed if an optional pre-or post-
 statement is used (
 ➊
 ); both statements must be simple statements. If variables are 
 created in an optional statement or to capture the values produced by a
  range
  clause 
 (e.g., using the
  :=
  operator), their scope extends from the point of declaration to the 
 end of the complete
  for
  statement.",NA
5.4. Communication and Concurrency,NA,NA
Statements,"Go’s communication and concurrency features are covered in Chapter 7, but for 
 completeness of our coverage of procedural programming we will describe their 
 basic syntax here.
  
 ★
  goto
  statements have been generally despised since Edsger Dijkstra’s famous 1968 letter titled“Go-to 
 statement considered harmful” (
 www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF
 ).",NA
5.4.1. Select Statements,"Go’s
  select
  statement has the following syntax:
 ★
  
 select
  {
  
 case
  sendOrReceive1
 :
  block1
  
 ...
  
 case
  sendOrReceiveN
 :
  blockN
  
 default
 :
  blockD
  
 }
  
 In a
  select
  statement Go evaluates each send or receive statement in order from first 
 to last. If any of these statements can proceed (i.e., is not blocked), then of those that 
 can proceed, an
  arbitrary
  choice is made as to which one to use. If none can proceed 
 (i.e., if they are all blocked), there are two possible scenarios. If a
  default
  case is 
 present, the default case is executed and execution resumes from the statement 
 following the
  select
 ; but if there is no
  default
  case the
  select 
 will block until at least 
 one communication can proceed.
  
 A consequence of the
  select
  statement’s logic is as follows. A
  select
  with no 
 default
  
 case is
  blocking
  and will only complete when one communication case (receive or 
 send) has occurred. A
  select
  with a
  default
  case is
  nonblocking
  and executes 
 immediately, either because a communication case occurred, or if no 
 communication channel is ready, by executing the
  default
  case.
  
 To get to grips with the syntax we will review two short examples. The first ex-
 ample is rather contrived but does give a good idea of how the
  select
  statement 
 works. The second example shows a more realistic approach to use.
  
 channels :=
  make
 ([]
 chan
  bool,
  6
 ) 
  
 for
  i :=
  range
  channels {
  
  
  channels[i] =
  make
 (
 chan
  bool) 
  
 } 
  
 go func
 () { 
  
  
  
 for
  {
  
  
   
  channels[rand.Intn(
 6
 )] <-
  true
  
  
  } 
  
 }()
  
 In this snippet we have created six channels which can send and receive Booleans. 
 We have then created a single goroutine that hasan infinite loop with-in which one 
 of the channels is chosen at random and sent a
  true
  value on every iteration. The 
 goroutine immediately blocks, of course, since the channels are unbuffered and we 
 have not yet tried to receive from any of them.
  
 ★
  Go’s
  select
  statement has nothing to do with the POSIX
  select()
  function used to monitor file 
 descriptors—for that, use the
  syscall
  package’s
  Select()
  function.",NA
"5.5. Defer, Panic, and Recover","The
  defer
  statement is used to defer the execution of a function or method (or of an 
 anonymous function created on the spot) until just before the enclosing function or 
 method returns, but after the return values (if any) have been evaluated. This makes 
 it possible to modify a function’s
  named
  return values inside a deferred function 
 (e.g., by assigning to them using the
  =
  assignment operator).If more than one
  defer
  
 statement is used in a function or method,they are executed in LIFO (Last In First 
 Out) order.
  
 The most common uses of a
  defer
  statement are to ensure that a successfully opened 
 file is closed when we are finished with it, to close channels that are no longer 
 needed, or to catch panics.
  
 var
  file *os.File 
  
 var
  err
  error
  
 if
  file, err = os.Open(filename); err !=
  nil
  {
  
  log.Println(
 ""failed to open the file: ""
 , err)
  
 return",NA
5.5.1. Panic and Recover,"Go provides an exception handling mechanism through the use of its built-in 
 panic()
  
 and
  recover()
  functions. These functions could be used to provide a general-purpose 
 exception handling mechanism, similar to those available in some other languages 
 (e.g., C++, Java, and Python): But to do so is considered to be poor Go style.
  
 Go distinguishes between errors—things that might go wrong and that a program 
 should handle gracefully (e.g., a file that could not be opened)—and exceptions—
 something that “cannot” happen (e.g., a precondition which should always be true 
 that’s actually false).
  
 The idiomatic way to handle errorsin Go is to return an
  error
  as the last (or only) 
 return value from functions and methods and to always check any returned 
 error
 s. 
 (The one case where it is common to ignore returned
  error
  values is when printing 
 to the console.)
  
 For “cannot happen” situations we can call the built-in
  panic()
  function with any 
 value we like (e.g., a string that explains the invariant that has been broken).In other 
 languages we might use an assertion for these situations,but in Go we call 
 panic()
 . 
 During early development and prior to any releases the simplest and probably the 
 best approach is to call
  panic()
  to terminate the program to force problems to be 
 impossible to ignore so that they get fixed. Once we start deploy-ing our application 
 it is best to avoid termination when problems occur if at all possible, and this can be 
 done while still leaving any remaining
  panic()
  calls in place by adding deferred
  
 recover()
  calls in our packages. During recovery we can catch and log any panics (so 
 that they remain as visible problems), and re-turn non-
 nil error
 s to callers who can 
 then try to restore the program to a sane state from which it can safely continue to 
 run.
  
 ★
  In C++ destructors are used to clean up values. In Java and Python cleanup is problematic since they 
 cannot guarantee when or even if their
  finalizer()
 /
 __del__()
  method will be called.",NA
5.6. Custom Functions,"Functions are the bedrock of procedural programming and Go provides first-class 
 support for them. Go methods (covered in Chapter 6) are very similar to Go 
 functions, so this section is relevant for both procedural and object-oriented 
 programming.
  
 Here are the fundamental syntaxes for function definitions:
  
 func
  functionName
 (
 optionalParameters
 )
  optionalReturnType
  {
  
 body
  
 }
  
 func
  functionName
 (
 optionalParameters
 ) (
 optionalReturnValues
 ) {
  
 body
  
 }
  
 A function can take zero or more parameters. If there are no parameters the 
 parentheses are empty. If there is one or more, they are written
  params1 type1
 ,…,
  
 paramsN typeN
 , where
  params1
  is either a single parameter name or a comma-
 separated list of two or more parameter names of the given type. Parameters must 
 be passed in the order given: There is no equivalent to Python’s named pa-rameters, 
 although a similar effect can be achieved as we will see later (§5.6.1.3,
 ➤
  222).
  
 The very last parameter’s type may be preceded by an ellipsis (
 ...
 ). Such functions 
 are called
  variadic
 ; this means that the function will accept zero or more values of 
 that type as that parameter’s value and inside the function that parameter will be of 
 type
  []
 type
 .
  
 A function may return zero or more values. If there are none the open brace follows 
 the parameter’s closing parenthesis. If there is one unnamed return value it can be 
 written as
  type
 . If there are two or more unnamed return values, parentheses must 
 be used and they are written as
  (
 type1
 , …,
  typeN
 )
 . If there are one or more named 
 return values, parentheses must be used and they are written as
  (
 values1 type1
 , …,
  
 valuesN typeN
 )
 , where
  values1
  is either a single return value name or a comma-
 separated list of two or more return value names of the given type. Function return 
 values may all be unnamed or all be named, but not a mixture of both.
  
 Functions that have one or more return values
  must
  have at least one
  return 
 statement—or have a call to
  panic()
  as their final statement. If return values are 
 unnamed, the
  return
  statement must specify as many values as there are return 
 values, each with a type matching the corresponding return value. If the return 
 values are named the
  return
  statement can either specify values just like in the 
 unnamed case or be bare (i.e., giving no explicit values to return). Note that 
 although bare
  return
 s are legal, they are considered poor style—none of the book’s 
 examples uses them.",NA
5.6.1. Function Arguments,"We have already seen many examples of custom Go functions that accept a fixed 
 number of arguments of specified types. By using a parameter type of 
 interface{}
  we 
 can create functions that take arguments of any type. And by using a parameter type 
 that is an
  interface
  type—either our own custom 
 interface
  or one from the standard 
 library—we can create functions that take arguments of any type that has a specific 
 set of methods: We will look at these issues in Chapter 6 (§6.3, 
 ➤
  265).
  
 In this subsection we will look at other possibilities regarding function argu-ments. 
 In the first subsubsection we will see how to use functions’ return values directly 
 asargumentsto other functions. In the second subsubsectionwe will see how to 
 create functions that accept a variable number of arguments. And in the final 
 subsubsection we will discuss a technique that makes it possible to create functions 
 that can accept optional arguments.
  
 5.6.1.1. Function Calls as Function Arguments
  
 If we have a function or method that accepts one or more parameters,we can, of 
 course, call it with corresponding arguments. And in addition, we can call the 
 function with another function or method—providing that the other function 
 returns exactly the number of arguments required (and of the right types).
  
 Here is an example of a function that takes the lengths of the sides of a triangle (as 
 three
  int
 s) and outputs the triangle’s area using Heron’s formula.
  
 for
  i :=
  1
 ; i <=
  4
 ; i++ {
  
  
  a, b, c := PythagoreanTriple(i, i+
 1
 )
  
  
  
 Δ
 1
  := Heron(a, b, c)
  
  
  
 Δ
 2
  := Heron(PythagoreanTriple(i, i+
 1
 ))
  
  
  fmt.Printf(
 ""Δ1 == %10f == Δ2 == %10f\n""
 , Δ
 1
 , Δ
 2
 ) }",NA
5.6.2. The init() and main() Functions,"Go reserves two function names for special purposes:
  init()
  (in all packages) and
  
 main()
  (only in package
  main
 ). These two functions must always be defined as taking 
 no arguments and returning nothing. A package may have as many 
 init()
  functions as 
 we like. However, at the time of this writing, at least one Go compiler supports only 
 a single
  init()
  function per package, so we recommend using at most one
  init()
  
 function in each package.
  
 Go automatically calls
  init()
  functions in packages and the
  main
  package’s 
 main()
  
 function, so these should not be called explicitly. For programs and packages
  init()
  
 functions are optional; but every program must have a single 
 main()
  function in 
 package
  main
 .
  
 The initialization and execution of a Go program always begins with the
  main 
 package. If there are imports,each imported package is imported in turn. Pack-ages 
 are imported only once even if more than one package has an import state-ment for 
 the same package. (For example, several packages might import the 
 fmt
  package, but 
 after it has been imported once it will not be imported again since there is no need.) 
 When a package is imported, if it has its own imports, these are performed first. 
 Then, the package’s package-level constants and variables are created. And then the 
 package’s
  init()
  functions are called (if it has any). Eventually, all the packages 
 imported in the
  main
  package (and their imports and so on) are finished, at which 
 point the
  main
  package’s constants and variables are created and the
  main
  package’s
  
 init()
  functions are called (if it has any).And finally, the
  main
  package’s
  main()
  
 function is called and program execu-tion proper begins. This sequence of events is 
 illustrated in Figure 5.1.
  
 main
  
 pkg1
  
 pkg2
  
 pkg3
  
 import
  pkg1
  
 import
  pkg2
  
 import
  pkg3
  
 const ...
  
 const ...
  
 const ...
  
 const ...
  
 var ...
  
 var ...
  
 var ...
  
 var ...
  
 init()
  
 init()
  
 init()
  
 init()
  
 main()
  
 Figure 5.1
  Program startup sequence
  
 It is possible to put
  go
  statements in
  init()
  functions, but keep in mind that these run 
 before
  main.main()
  is called and so must not depend on anything created in
  main()
 .",NA
5.6.3. Closures,"A
  closure
  is a function which “captures” any constants and variables that are present 
 in the same scope where it is created, if it refers to them. This means that a closure 
 is able to access such constants and variables when the closure is called,even if it is 
 called far away from the place where it was created. It doesn’t matter if any 
 captured constants or variables have gone out of scope—so long as a closure refers 
 to them they are kept alive for the closure to use.
  
 In Go, every anonymous function (or
  function literal,
 as they are called in the Go 
 specification) is a closure.",NA
5.6.4. Recursive Functions,"A
  recursive
  function is a function that calls itself, and
  mutually recursive
  func-tions 
 are functions that call each other. Go fully supports recursive functions.
  
 Recursive functions generally have the same structure: an “outcase” and a“body”. 
 The outcase is usually a conditional statement such as an
  if
  statement that is used to 
 stop the recursion based on one of the arguments passed in. The body is where the 
 function does some processing and includes at least one call to itself (or to its 
 mutually recursive partner)—this call must pass an argument that is changed from 
 one it received and that will be checked in the outcase to ensure that the recursion 
 will ultimately finish.
  
 Recursive functions make it easy to work with recursive data structures (such as 
 binary trees), but they can be inefficient for, say, numerical computations.
  
 We will start with a very simple (and inefficient) example, just to show how 
 recursion is done. First we will see a call to a recursive function and its output, then 
 we will see the recursive function itself.
  
 for
  n :=
  0
 ; n <
  20
 ; n++ {
  
  
  fmt.Print(Fibonacci(n),
  "" ""
 ) 
  
 } 
  
 fmt.Println()
  
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
  
 The
  Fibonacci()
  function returns the
  n
 -th Fibonacci number.
  
 func
  Fibonacci(n int) int { 
  
  
  
 if
  n <
  2
  { 
  
  
   
 return
  n
  
  
  } 
  
  
  
 return
  Fibonacci(n-
 1
 ) + Fibonacci(n-
 2
 ) }",NA
5.6.5. Choosing Functions at Runtime,"Since Go functions are first-class values, it is possible to store them (i.e., refer-ences 
 to them) in variables—and this makes it possible to choose which function to 
 execute at runtime. Furthermore, Go’s ability to create closures means that we can 
 in effect create functions at runtime—so we could have two or more dif-ferent 
 implementations of the same function (each using a different algorithm), and create 
 just one of them to be used. We will look at both approaches in this subsection.
  
 5.6.5.1. Branching Using Maps and Function References
  
 In two earlier subsections (§5.2.1, 192
  
 and §5.2.2.1, 195
  
 ) we presented ex-
  
 tracts from custom
  ArchiveFileList()
  functions for calling a particular func-tion based 
 on a filename’s suffix. The first version of the function used an
  if 
 statement that 
 spanned seven lines; the canonical version’s
  switch
  statement spanned just five lines. 
 But what happens if the number of different file suffix-es we want to handle grows? 
 For the
  if
  version we would need to add an extra",NA
5.6.6. Generic Functions,"Earlier in the chapter we created a function for finding the smallest of the
  int 
 arguments it was passed (221 
  
 ). The algorithm used in that function could also 
 be applied to other numeric types, or even to strings, since it works for any type that 
 supports the
  <
  less than operator. In C++, for cases like this, we would create a 
 generic function that is parameterized by type which would result in",NA
5.6.7. Higher Order Functions,"A
  higher order function
  is a function that takes one or more other functions as 
 arguments and uses them in its own body.
  
 Let’s look at a very short and simple higher order function—but one whose 
 functionality may not be immediately apparent.
  
 func
  SliceIndex(limit int, predicate
  func
 (i int) bool) int { 
  
  
 for
  i :=
  0
 ; i < limit; i++ { 
  
  
   
  
 if
  predicate(i) { 
  
  
   
  
 return
  i
  
  
   
  }
  
  
  } 
  
  
  
 return
  -1 
  
 }
  
 This is a generic function that returns the index position of an item in a slice for 
 which the
  predicate()
  function returns
  true
 . So, this function can do exactly the same 
 job as the
  Index()
 ,
  IndexReflect()
 ,
  IntSliceIndex()
 , and
  IntIndexSlicer() 
 functions 
 discussed in the previous subsection—but with no code duplication and no type 
 switching or type assertions.
  
 The
  SliceIndex()
  function doesn’t know or care about the slice’s or the item’s types—
 indeed, the function knows nothing of the slice or the item it (indirect-ly) operates 
 on. The function expects its first argument to be the length of the slice and the 
 second argument to be a function that returns a Boolean for any given index 
 position in the slice indicating whether the desired item is at that position.",NA
5.7. Example: Indent Sort,"In this section we will review a custom function that sorts a slice of strings. What 
 makesthis function special (and why the standard library’s
  sort.Strings() 
 function is 
 insufficient on its own) is that the strings are sorted hierarchically, that is, within 
 their level of indentation. (The function is in the book’s source code in the file
  
 indent_sort/indent_sort.go
 .)
  
 Note that the algorithm used for the
  SortedIndentedStrings()
  function makes a critical 
 simplifying assumption: A string’s indentation is measured by the number of leading 
 spaces or tabs it has, so we are able to work in terms of single bytes rather than 
 having to concern ourselves with multibyte whitespace characters. (If we really 
 want to handle multibyte whitespace characters, one easy solution is to replace each 
 such character with a single space or tab in the stringsbefore feeding them to the
  
 SortedIndentedStrings()
  function,for example, using the
  strings.Map()
  function.)
  
 Let’s begin with a program that calls the function and outputs some unsorted 
 indented strings and the sorted strings, side by side for comparison (
 ➤
  245).
  
 Between them, the
  SortedIndentedStrings()
  function and its helper functions and 
 types use recursive functions, function references, and pointers to slices. So, 
 although what the function does is easy to see, the implementation of the solution 
 requires some thought. The solution uses some important Go function features that 
 were introduced in this chapter, as well as some ideas and tech-niques that were 
 covered in Chapter 4 and which are explained more fully in Chapter 6.
  
 The keys to our solution are the custom
  Entry
  and
  Entries
  types. For each string in 
 the original slice we will create an
  Entry
  whose
  key
  field will be used for sorting, 
 whose
  value
  field is the original string, and whose
  children
  field is a slice",NA
5.8. Exercises,"There are four exercises for this chapter. The first involves changing one of the 
 examples, some of whose code was shown in the chapter, and the others require the 
 creation of new functions. All the exercises are very short—the first is easy, the 
 second is straightforward, but the third and fourth are quite challenging!
  
 1. Copy the
  archive_file_list
  directory to, say,
  my_archive_file_list
 . Then modify the
  
 archive_file_list/archive_file_list.go
  file: Remove all the code for supporting 
 different
  ArchiveFileList()
  functions except for
  Archive-FileListMap()
  which should 
 be renamed
  ArchiveFileList()
 . Then add the capability of handling
  .tar.bz2
  
 (tarballs compressed with bzip2) files. This involves deleting about 11 lines 
 from
  main()
 , deleting four functions,import-ing an additional package, adding 
 one entry to the
  FunctionForSuffix
  map, and adding a few lines to the
  TarFileList()
  
 function. A solution is given in 
 archive_file_list_ans/archive_file_list.go
 .
  
 2. Create nonrecursive versions of the recursive
  IsPalindrome()
  functions 
  
 shown 
 earlier in the chapter (229 
  
 and 232 
  
 ). In the
  palindrome_ans/pal-
  
 indrome.go
  solution file the nonrecursiveASCII-only function is 10 lines long 
  
 and is radically different in structure to the recursive version. On the other 
  
 hand, the nonrecursive UTF-8 function is 14 lines long and is very similar 
  
 to the recursive version—although it does require some care.
  
 3. Create a
  CommonPrefix()
  function that takes a
  []string
  argument and re-turns a
  
 string
  with the common prefix (which might be an empty string) of all the 
 strings passed in. A solution is given in
  common_prefix/common_pre-fix.go
 ; the 
 solution is 22 lines long and uses a
  [][]rune
  to hold the strings to ensure that 
 when iterating we work in terms of whole characters even if the strings have 
 non-ASCII characters. The solution builds up the result in a
  bytes.Buffer
 . Despite 
 being very short, this function is by no means easy!
  
 (Some examples follow the next exercise.)
  
 4. Create a
  CommonPathPrefix()
  function that takes a
  []string
  of paths and re-turns a
  
 string
  with the common prefix (which might be an empty string) of all the paths 
 passed in—the prefix must consist of zero or more complete path components. 
 A solution is given in
  common_prefix/common_prefix.go
 ; the solution is 27 lines 
 long and uses a
  [][]string
  to hold the paths and the 
 filepath.Separator
  to identify 
 the platform-specific path separator. The so-lution builds up the result in a
  
 []string
  and joins them together as a single path at the end using the
  
 filepath.Join()
  function. Despite being really short, this function is challenging! 
 (Some examples follow.)
  
 Here is the output of the
  common_prefix
  program that exercises the functions 
 referred to in Exercises 3 and 4. The first of each pair of lines is a slice of strings and 
 the second line has the common prefix produced by the
  CommonPrefix()
  and 
 CommonPathPrefix()
  functions with an indication of whether the common prefixes 
 are the same.",NA
6,NA,NA
Object-Oriented ,NA,NA
Programming,"§6.1. Key Concepts 
 ➤
  254
  
 §6.2. Custom Types 
 ➤
  256
  
  
 §6.2.1. Adding Methods 
 ➤
  258
  
  
 §6.2.2. Validated Types 
 ➤
  263
  
 §6.3. Interfaces 
 ➤
  265
  
  
 §6.3.1. Interface Embedding 
 ➤
  270
  
 §6.4. Structs 
 ➤
  275
  
  
 §6.4.1. Struct Aggregation and Embedding 
 ➤
  275
  
 §6.5. Examples 
 ➤
  282
  
  
 §6.5.1. Example: FuzzyBool—A Single-Valued Custom Type 
 ➤
  282
  
 §6.5.2. Example: Shapes—A Family of Custom Types 
 ➤
  289
  
 §6.5.3. 
 Example: Ordered Map—A Generic Collection Type 
 ➤
  302
  
 The aim of this chapter is to show how to do object-oriented programming the Go 
 way. Programmerscoming from a proceduralbackground(e.g.,C)should find 
 everything in this chapter builds nicely on what they already know and what the 
 earlier chapters covered. But programmers coming from an inheritance-based 
 object-oriented background (e.g., C++, Java, Python) will need to put aside many of 
 the concepts and idioms they are used to—in particular, those relating to 
 inheritance—since Go takes a radically different approach to object-oriented 
 programming.
  
 Go’s standard library mostly provides packages of functions, although where 
 appropriate it also provides custom types that have methods. In earlier chap-ters 
 we created values of some custom types (e.g.,
  regexp.Regexp
  and
  os.File
 ) and called 
 methods on them. Furthermore, we even created our own simple custom types and 
 corresponding methods—for example, to support printing and sorting—so the basic 
 use of Go types and calling their methods is already fa-miliar.
  
 The chapter’s very short first section introduces some key concepts in Go object-
 oriented programming. The second section covers the creation of methodless 
 custom types, with subsections on adding methods to custom types and on cre-
  
 253",NA
6.1. Key Concepts,"What makes Go object orientation so different from, say, C++, Java, and (to a lesser 
 extent) Python, is that it does not support inheritance. When object-ori-ented 
 programming first became popular inheritance was touted as one of its biggest 
 advantages. But now, after a few decades of experience, it has turned out that this 
 feature has some significant drawbacks,especially when it comesto maintaining 
 large systems. Instead of using both aggregation and inheritance like most other 
 object-oriented languages, Go supports aggregation (also called composition)and
  
 embedding
  exclusively. To see the difference between aggrega-tion and embedding 
 let’s look at a tiny code snippet.
  
 type
  ColoredPoint
  struct
  {
  
  
  color.Color 
 // Anonymous field (embedding)
  
  x, y        
 int
  // Named fields (aggregation) 
 }
  
 Here,
  color.Color
  is a type from the
  image/color
  package and
  x
  and
  y
  are
  int
 s. In Go 
 terminology,
  color.Color
 ,
  x
 , and
  y
  are all
  fields
  in the
  ColoredPoint struct
 . The 
 color.Color
  
 field is anonymous (since it has no variable name) and is therefore an embedded 
 field. The
  x
  and
  y
  fields are named aggregated fields. If we created a
  ColoredPoint
  
 value (e.g.,
  point := ColoredPoint{}
 ), the fields would be accessed as
  point.Color
 ,
  point.x
 , 
 and
  point.y
 . Notice also that when accessing a field of a type from another package 
 we only use the last component of the name, that is,
  Color
  and not
  color.Color
 . (We 
 will discuss these matters in more detail in§6.2.1.1, 
 ➤
  261, §6.3, 
 ➤
  265, and §6.4, 
 ➤
  
 275.)
  
 The terms “class”, “object”, and “instance” are so well established in convention-al 
 inheritance-hierarchy-style object orientation, that in Go we avoid them al-together. 
 Instead, we talk about “types” and “values”, where values of custom types may have 
 methods.
  
 Without inheritance there are no virtual functions. Go’s answer to this is to support 
 type-safe duck typing. In Go, parameters can be specified as concrete",NA
6.2. Custom Types,"Custom types are created using Go’s
  type
  statement with the following syntax:
  
 type
  typeName typeSpecification
  
 The
  typeName
  can be any valid Go identifier that is unique to the enclosing package 
 or function. The
  typeSpecification
  can be any built-in type (such as a
  string
 ,
  int
 , slice, 
 map, or channel), an
  interface
  (see §6.3, 
 ➤
  265), a
  struct 
 (seen in earlier chapters, 
 with more coverage later in this one, §6.4, 
 ➤
  275), or a function signature.
  
 In some situations creating a custom type is sufficient, while in others we need to 
 add methods to the custom type to make it really useful. Here are some examples of 
 methodless custom types.
  
 type
  Count int 
  
 type
  StringMap
  map
 [string]string 
  
 type
  FloatChan
  chan
  float64",NA
6.2.1. Adding Methods,"A method is a special kind of function that is called on a value of a custom type and 
 that is (usually) passed the value it is called on. The value is passed as a pointer or 
 value depending on how the method is defined. The syntax for defin-ing methods is 
 almost identical to that for defining functions, except that be-tween the
  func
  
 keyword and the method’s name we must write the
  receiver
 —this is written in 
 parentheses, either as the type of value that the method belongs to or as a variable 
 name and the type. When the method is called, the receiver’s variable (if present) is 
 automatically set to the value or pointer that the method was called on.
  
 We can add one or more methods to any custom type. A method’s receiver is always 
 a value of the type or a pointer to a value of the type. However, ev-ery method name 
 must be unique for any given type. One consequence of the unique name 
 requirement is that we cannot have two methods of the same name where one takes 
 a pointer and the other a value. Another consequence is that there is no support for 
 overloaded methods, that is, methods with the same name but different signatures. 
 One way to provide the equivalent of overloaded",NA
6.2.2. Validated Types,"For many simple custom types, no validation is necessary. For example, we might 
 have
  type Point { X, Y int }
 , for which any values of
  X
  and
  Y
  are valid. Furthermore, 
 since Go guarantees to initialize all variables (including
  struct 
 fields) to their zero 
 values, the need for explicit constructors is reduced.
  
 For those situations where the default zero-value initialization isn’t sufficient, we 
 can create a construction function. Go doesn’t support constructors, so we must call 
 construction functions explicitly. To support this we must document",NA
6.3. Interfaces,"In Go an
  interface
  is a custom type that specifies a set of one or more method 
 signatures. Interfaces are wholly abstract, so it is not possible to instantiate an 
 interface. However, it is possible to create a variable whose type is that of an 
 interface—and which can then be assigned a value of any concrete type that has the 
 methods the interface requires.
  
 The
  interface{}
  type is the interface that specifies the empty set of methods. Every 
 value satisfies the
  interface{}
  type whether the value has methods or not—after all, if 
 a value does have methods,its set of methods includes the emp-ty set of methods as 
 well as the methods it actually has. This is why the
  inter-face{}
  type can be used for
  
 any
 value. We cannot call methodsdirectly on a value passed as an
  interface{}
  (even if 
 it has some), since the interface it is fulfilling has no methods. So, in general, it is 
 better to pass values either as their actual type or as an interface that hasthe 
 methodsthat we want to use. Of course,if we do use the
  interface{}
  type for values 
 with methods, we can access those meth-ods by using a type assertion (§5.1.2, 191 
  
 ) 
 or a type switch (§5.2.2.2, 197 
  
 ), or even by using introspection 
 (§9.4.9, 
 ➤
  427).
  
 Here is a very simple interface.",NA
6.3.1. Interface Embedding,"Go interfaces (and
  struct
 s, as we will see in the next section) have excellent sup-port 
 for embedding. Interfaces can embed other interfaces and the effect is al-most the 
 same as if we had written the embedded interface’s method signatures in the 
 interface that embeds it. Let’s illustrate this with a simple example.
  
 type
  LowerCaser
  interface
  {
  
  
  LowerCase() 
  
 }
  
 type
  UpperCaser
  interface
  {
  
  
  UpperCase() 
  
 }
  
 type
  LowerUpperCaser
  interface
  {
  
  
  LowerCaser
  // As if we had written LowerCase()
  
  
 UpperCaser
  // As if we had written UpperCase() 
 }
  
 The
  LowerCaser interface
  specifies a single method,
  LowerCase()
 , that takes no 
 arguments and returns nothing. The
  UpperCaser interface
  is similar. The 
 LowerUpperCaser interface
  embeds the two other interfaces. This means that for a 
 concrete type to satisfy the
  LowerUpperCaser interface
 , it must have
  LowerCase() 
 and
  
 UpperCase()
  methods.",NA
6.4. Structs,"The simplest custom types in Go are based on Go’s built-in types—for example, 
 type 
 Integer int
  creates a custom
  Integer
  type to which we could add our own methods. 
 Custom typescan also be based on
  struct
 s which are used to aggregate and embed 
 values together. This is particularly useful when the values—called 
 fields
  in the 
 context of
  struct
 s—are of different types, and so cannot be stored in a slice (unless 
 we use an
  []interface{}
 ). Go’s
  struct
 s are much closer to C’s structs than C++’s (e.g., 
 they are not classes), and they are more convenient to use because of their excellent 
 support for embedding.
  
 We have already seen numerous examples of
  struct
 s in earlier chapters and in this 
 chapter, and we will see many more throughout the rest of the book. 
 Nonetheless,there are some
  struct
  features that we have not yet seen,so we will 
 begin with some illustrative examples to show them.
  
 points := [][
 2
 ]int{{
 4
 ,
  6
 }, {}, {
 -7
 ,
  11
 }, {
 15
 ,
  17
 }, {
 14
 ,
  -8
 }} 
 for
  _, point :=
  range
  
 points {
  
  
  fmt.Printf(
 ""(%d, %d) ""
 , point[
 0
 ], point[
 1
 ]) 
  
 }
  
 The snippet’s
  points
  variable is a slice of arrays of type
  [2]int
 , so we must use the
  []
  
 index operator to get each coordinate. (Incidentally, the
  {}
  item is the same as
  {0, 0}
  
 thanks to Go’s automatic zero-value initialization.) For small amounts of simple data 
 this works fine, but there is a nicer way to do this using an anonymous
  struct
 .
  
 points := []
 struct
 { x, y int }{{
 4
 ,
  6
 }, {}, {
 -7
 ,
  11
 }, {
 15
 ,
  17
 }, {
 14
 ,
  -8
 }} 
 for
  _, point :=
  range
  
 points {
  
  
  fmt.Printf(
 ""(%d, %d) ""
 , point.x, point.y) 
  
 }
  
 Here, the snippet’s
  points
  variable is a slice of
  struct{ x, y int}
 s. Although the 
 struct
  
 itself is unnamed, we can access its data via its named fields which is easier and 
 safer than using array indexes.",NA
6.4.1. Struct Aggregation and Embedding,"We can embed
  struct
 s in the same way as we can embed interfaces or oth-er types, 
 that is, by including the type name of a
  struct
  as an anonymous field inside another
  
 struct
 . (Of course, if we gave the inner
  struct
  a variable name it would be an 
 aggregated named field rather than an embedded anony-mous field.)
  
 Usually an embedded field’s fields can be accessed directly using the
  .
  (dot) selector 
 operator without mentioning the type name, but if the containing",NA
6.5. Examples,"Now that we know how to create custom types we are ready to look at some more 
 realistic and complete examples. The first example shows how to create a simple 
 custom value type. The second example shows how to create a set of related
  
 interface
 s and
  struct
 s using embedding, and how to provide not only type-
 construction functions,but also a factory function that can create values of all the 
 package’s exported types. The third example shows how to implement a complete 
 custom generic collection type.",NA
6.5.1. Example: FuzzyBool—A Single-Valued Custom,NA,NA
Type,"In this section we will see how to create a single-valued custom type and its 
 supporting methods. This example is in file
  fuzzy/fuzzybool/fuzzybool.go
  and is based 
 on a
  struct
 .
  
 The built-in
  bool
  type is two-valued (
 true
  and
  false
 ), but in some areas of artifi-cial 
 intelligence, fuzzy Booleans are used. These have values corresponding to“true” and 
 “false”, and also to intermediates between them. In our implemen-tation we will use 
 floating-point values, with 0.0 denoting
  false
  and 1.0 denot-ing
  true
 . In this system, 
 0.5 means 50% true (50% false), and 0.25 means 25% true (75% false), and so on. 
 Here are some usage examples and the results they produce.",NA
6.5.2. Example: Shapes—A Family of Custom Types,"When we have a set of related classes—such as shapes—upon which we might want 
 to apply some generic operations (e.g., asking a shape to draw itself), there are two 
 broad approacheswe can take to implementing them. The one most like-ly to be 
 familiar to C++, Java, and Python programmersis to use a hierarchy—in Go’s case,of 
 embedded
  interface
 s. However,it is often more convenient and ver-satile to create 
 independent
  interface
 s that can be freely composed. In this sub-section we will show 
 both approaches, the first in file
  shaper1/ shapes/shapes.go 
 and the second in file
  
 shaper2/shapes/shapes.go
 . (Note that when the packages’types, functions, and 
 methods are the same—which most of them are—we will simply refer to the “
 shapes
  
 package”. Naturally, we will distinguish them as the“
 shaper1 shapes
  package” or the 
 “
 shaper2 shapes
  package” when discussing code that is specific to one of them.)
  
 Figure 6.3 shows an example of what the
  shapes
  package can do—in this case it is 
 used to create a white rectangle and to draw on it a circle and some polygons with 
 different numbers of sides and using various colors.
  
  
 Figure 6.3
  The
  shaper
  example’s
  shapes.png
  file
  
 The
  shapes
  package provides three exported functions for working with images and 
 three types for creating shapes values—two of which are exported. The hierarchical
  
 shapes1 shapes
  package provides three exported
  interface
 s and the compositional
  
 shapes2 shapes
  package provides five exported
  interface
 s. We will begin with the 
 image-related code—the convenience functions—then we will look at the
  interfaces
  
 (in two separate subsubsections), and finally, we will review the concrete shape-
 related code.
  
 6.5.2.1. Package-Level Convenience Functions
  
 The standard library’s
  image
  package providesthe
  image.Image interface
 .This
  in-terface
  
 specifies three methods:
  image.Image.ColorModel()
  to return the image’s color model 
 (as a
  color.Model
 ),
  image.Image.Bounds()
  to return the image’s bound-ing box (as an
  
 image.Rectangle
 ), and
  image.Image.At(
 x
 ,
  y
 )
  which returns the
  col-or.Color
  value for the 
 given pixel. Notice that there is no
  image.Image
  method for setting a pixel—even 
 though several
  image
  types provide a
  Set(x, y int, fill",NA
i,"In this subsection, the
  shaper
  example illustrates how to use
  struct
  embed-ding to 
 achieve an inheritance-like effect. This technique may appeal to those porting C++ 
 or Java code to Go (or to those learning Go from a C++ or Java background). 
 However, although this approach works: 
  
 The Go way is not to simulate inheritance,but to avoid it altogether.
  
 In the context of the example this would mean having independent
  struct
 s:
  
 type
  Circle
  struct
  { 
 type
  RegularPolygon
  struct
  {
  
  color.Color
  
  color.Color
  
  Radius int
  
  Radius int
  
 }
  
  Sides int
  
 }
  
 This still allows us to pass generic shape values—after all, if both shapes have
  
 Draw()
  methods that satisfy a
  Drawer interface
 , then both
  Circle
 s and 
 RegularPolygon
 s can be passed as
  Drawer
  values.
  
 Another point to note is that here we have made all the fields exported, with no 
 validation at all. This means that we must validate the fields when they are used, 
 rather than when they are set. Both approaches to validation are sensible: Which 
 is best depends on the circumstances.
  
 The book’s
  shaper3
  example uses the
  struct
 s shown above and has the same 
 functionality as the
  shaper1
  and
  shaper2
  examples shown in this section. However,
  
 shaper3
  is written in a more Go-like style, with no embedding and doing its 
 validation at the point of use.
  
 func
  showShapeDetails(shape shapes.Shaper) {
  
  
  fmt.Print(
 ""fill=""
 , shape.Fill(),
  "" ""
 )
  // All shapes have a fill color 
  
  
 if
  shape, 
 ok := shape.(shapes.CircularShaper); ok {
  // shadow variable
  
  
  
  
 fmt.Print(
 ""radius=""
 , shape.Radius(),
  "" ""
 ) 
  
  
   
  
 if
  shape, ok := shape.(shapes.RegularPolygonalShaper); ok {
 //shadow
  
  
   
  
  fmt.Print(
 ""sides=""
 , shape.Sides(),
  "" ""
 )
  
  
   
  }
  
  
  }
  
  
  fmt.Println() 
  
 }
  
 In the
  shaper1 shapes
  package’s interface hierarchy,the
  Shaper interface
  specifies 
 Fill()
  
 and
  SetFill()
  methods, so these can be used immediately. But for other methods we 
 must use checked type assertions to see if the shape passed in sat-isfies the
  
 interface
 s that have the methods we want to call. Here, for example, we only access 
 the
  Radius()
  method if the shape fulfills the
  CircularShaper inter-",NA
6.5.3. Example: Ordered Map—A Generic Collection,NA,NA
Type,"This chapter’s final example is of a generic ordered map type that stores
  key
 –
 value
  
 pairs like Go’s built-in
  map
  type, only with all the pairs stored in key order. The 
 ordered map uses a left-leaning red-black tree so it is very fast, with a lookup time 
 complexity of O(log
 2
  n
 ).
 ★
 By comparison, an unbalanced binary tree’s performance 
 can degrade to that of a linked list (O(
 n
 )) if items are added in order. Balanced trees 
 do not suffer from this defect because they maintain the tree’s balance as items are 
 added and removed and thereby preserve their excellent performance 
 characteristics.
  
 Programmers with a background in inheritance-based object orientation (e.g., C++, 
 Java, Python) are likely to want to make the ordered map’s keys support the
  <
  less 
 than operator or a
  Less(
 other)
  bool
  method. This can easily be done by defining a
  
 Lesser interface
  that requires such a method, and providing tiny wrapper types for
  
 int
 ,
  string
 ,
  MyType
 , and so on, that implement the method. However, the right way to 
 do this in Go is somewhat different.
  
 For our Go ordered map we will impose no direct constraint on the key type. 
 Instead, we give each map a “less than” function to use for comparing its keys. This 
 means that it doesn’t matter whether our keys support the
  <
  operator or not—so 
 long as we can provide a suitable less than comparison function for them.
  
 Before looking at the implementation, let’s look at some examples of use, starting 
 with the creation and population of an ordered map.
  
 words := []string{
 ""Puttering""
 ,
  ""About""
 ,
  ""in""
 ,
  ""a""
 ,
  ""Small""
 ,
  ""Land""
 } wordForWord := 
 omap.NewCaseFoldedKeyed() 
  
 for
  _, word :=
  range
  words {
  
  
  wordForWord.Insert(word, strings.ToUpper(word)) 
  
 }
  
 Our ordered map is in package
  omap
  and is of type
  Map
 . To create a
  Map
  we must use 
 the
  omap.New()
  function, or one of the other
  Map
  construction functions, such as the
  
 omap.NewCaseFoldedKeyed()
  function we have used here, since the
  Map
 ’s zero value is 
 not usable. This particular construction function creates an empty
  Map 
 with a 
 predefined less than function that compares string keys case-insensitive-ly, and 
 returns a pointer to it (i.e., a
  *Map
 ).
  
 ★
  Our ordered map implementation is based on the left-leaning red-black trees described by Robert 
 Sedgewick 
 in
  
 www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
  
 and
  
 www.cs.princeton.edu/~rs/talks/ 
 LLRB/RedBlack.pdf
 . At the time of this writing, the Java implementations presented in these papers were 
 incomplete and had some errors, so we used ideas from Lee Stanza’s C++ code at
  www.teach-
 solaisgames.com/articles/balanced_left_leaning.html
  to complete our implementation.",NA
6.6. Exercises,"There are three exercises for this chapter. The first involves the creation of a small 
 but complete custom type whose fields must be validated. The second involves 
 adding new functionality to one of the custom types we discussed in this chapter. 
 The third requires the creation of a small custom collection type. The first two 
 exercises are not difficult; however, the third exercise is quite chal-lenging.
  
 1. Create a new package called
  font
  (e.g., in
  my_font/font.go
 ). The purpose of the 
 package is to provide values that represent font properties (e.g., a font’s family 
 and size). There should be a
  New()
  function that takes a family and size (both of 
 which must be validated) and returns a
  *Font
  (with valid un-exported 
 fields).Also provide getters and validating setters. For validation, don’t allow 
 empty family names and only allow font sizes between 5 and 144 points 
 inclusive: If invalid values are given set valid values (or the previous values for 
 setters), and log the problem. Be sure to provide a method that satisfies the
  
 fmt.Stringer interface
 .
  
 Here is an example of how to create, manipulate, and print a font using the 
 package.
  
 titleFont := font.New(
 ""serif""
 ,
  11
 ) 
  
 titleFont.SetFamily(
 ""Helvetica""
 ) 
  
 titleFont.SetSize(
 20
 ) 
  
 fmt.Println(titleFont)
  
 {font-family: ""Helvetica""; font-size: 20pt;}
  
 Once the package is ready, copy the example’s
  font/font_test.go
  file into the 
 my_font
  directory and run
  go test
  to do some very basic testing.
  
 A solution is given in
  font/font.go
 . The entire package is around 50 lines of code. 
 Incidentally, we chose to make the
  String()
  method return the font’s details in 
 CSS (Cascading Style Sheet) style. It would be straightforward,if a little tedious, 
 to extend this package to handle all the CSS font attributes, such as weight, 
 style, and variant.
  
 2. Copy an entire
  shaper
  example (the hierarchical
  shaper1
 , the compositional 
 shaper2
 , or the Go-style
  shaper3
 , whichever you prefer—although we recom-",NA
7,NA,NA
Concurrent ,NA,NA
Programming,"§7.1. Key Concepts 
 ➤
  317
  
 §7.2. Examples 
 ➤
  322
  
 §7.2.1. Example: Filter 
 ➤
  322
  
 §7.2.2. Example: Concurrent Grep 
 ➤
  326
  
 §7.2.3. Example: Thread-Safe Map 
 ➤
  334
  
 §7.2.4. Example: Apache Report 
 ➤
  341
  
 §7.2.5. Example: Find Duplicates 
 ➤
  349
  
 Concurrent programming allows developers to implement parallel algorithms and 
 to write programs that take advantage of multiple processors and multiple cores. 
 The downside is that in most mainstream programming languages (such as C, C++, 
 and Java) it is much harder to write, maintain, and debug concurrent programs than 
 single-threaded programs. Furthermore, it isn’t always possible to split up 
 processing to make using multiple threads worthwhile. And in any case, the hoped-
 for performance benefits are not always achieved due to the overhead of threading 
 itself, or simply because it is much easier to make mistakes in threaded programs.
  
 One solution is to avoid threading altogether. For example, we can pass the bur-dens 
 on to the operating system by using multiprocessing. However, this has the 
 disadvantages that it leaves us responsible for handling all the inter-process 
 communication ourselves, and usually has more overhead than shared-memory 
 concurrency.
  
 The Go solution is threefold. First, Go provides high-level support for concur-rent 
 programming that makes it much easier to do correctly;second, concurrent 
 processing is done in goroutines that are much more lightweight than threads; and 
 third, automatic garbage collection relieves programmers of the sometimes 
 fiendishly complex memory management required by concurrent programs.
  
 Go’s built-in high-level API for writing concurrent programs is based on CSP 
 (Communicating Sequential Processes). This means that explicit locking—and all 
 the care required to lock and unlock at the right times—can be avoided, with 
 synchronization achieved by sending and receiving data via thread-safe chan-nels. 
 This greatly simplifies the writing of concurrent programs. And whereas
  
 315",NA
7.1. Key Concepts,"In concurrent programming we typically want to split up the processing that needs 
 doing over one or more goroutines (in addition to the main orchestrating 
 goroutine), and either output results as soon as they are computed or gather the 
 results for outputting at the end.
  
 Even with Go’s high-level approach to concurrency there are pitfalls that we must 
 avoid. One such pitfall is when the program finishes almost immediately but 
 produces no results. Go programs automatically terminate when the main goroutine 
 terminates—even if other goroutines are processing at the time—so we must be 
 careful to keep the main goroutine alive long enough for all the work to be done.
  
 Another pitfall we must avoid is deadlock. One form of this problem is essential-ly 
 the opposite of the first pitfall: The main goroutine and all the processing go-
 routines are alive even though all the work has been done. This is typically due to a 
 failure to report the completion of processing. Another cause of deadlock is when 
 two different goroutines (or threads) are using locks to protect resources and try to 
 acquire the same locks at the same time, as illustrated in Figure 7.1. This kind of 
 deadlock can only occur when locking is used, so is a common risk in other 
 languages but quite rare in Go, since Go applications can avoid the use of locks by 
 using channels.
  
 Thread #1
  
 A
  
 B
  
 Thread #2
  
 Figure 7.1
  Deadlock: two or more blocked threads trying to acquire each other’s locks
  
 The most common way to avoid premature termination and nontermination is to 
 make the main goroutine wait for a “done” channel to report that the work is 
 finished (as we will see in a moment,and also in §7.2.2,
 ➤
  326 and §7.2.4,
 ➤
  341). (It 
 is also possible to use a sentinel value sent as the last “result”, but this is rather 
 clumsy compared to the other approaches.)
  
 Another way to avoid the pitfalls is to wait for all the processing goroutines to 
 report that they are finished using a
  sync.WaitGroup
 .However,using a
  sync.Wait-Group
  
 itself can cause a deadlock, particularly if the
  sync.WaitGroup.Wait()
  call occursin the 
 main goroutine when all the processing goroutinesare blocked (e.g., waiting to 
 receive on a channel). We will see how to use a
  sync.WaitGroup
  later (§7.2.5, 
 ➤
  349).
  
 It is still possible to get deadlocks in Go, even if we use only channels, and don’t use 
 locks. For example, suppose we have a set of goroutines that can ask each",NA
7.2. Examples,"Although Go uses relatively little syntax to provide goroutines and channels (
 <-
 ,
  
 chan
 ,
  go
 ,
  select
 ), this is sufficient to implement concurrency in a rich variety of ways. 
 In fact, so many different approaches are possible that is not practical to set forth 
 every possible variation in this chapter. So, instead, we will look at three patterns 
 that are commonly used for concurrent programs—a pipeline, multiple independent 
 concurrent jobs (with and without synchronized results), and multiple inter-
 dependent concurrent jobs—and see particular ways that these can be realized 
 using Go’s concurrency support.
  
 Between them, the examples shown here and the exercises at the end should 
 provide sufficient insight into and practice of concurrent Go programming, that both 
 these and other approaches can be used confidently in new programs.",NA
7.2.1. Example: Filter,"This first example is designed to show a particular concurrent programming 
 pattern. The program could easily be adapted to do other work that would benefit 
 from the program’s approach to concurrency.
  
 Those with a Unix background may have noticed that Go’s channels are rem-iniscent 
 of Unix pipes (except that channels are bidirectional whereas pipes are 
 unidirectional). Such pipes can be used to create pipelines where one pro-gram’s 
 output is fed to another program as input, whose output in turn is fed to a third 
 program, and so on. For example, we can get a list of all the Go files in Go’s source 
 tree (excluding test files) using the Unix pipeline command
  find $GOROOT/src -name 
 ""*.go"" | grep -v test.go
 . One of the beauties of this approach is that it is easy to extend. 
 For example, we could add
  | xargs wc -l
  to get each file listed with a count of the 
 number of lines it contains (plus a total at the end), and add
  | sort -n
  to get the files 
 listed in line count order (fewest to most).
  
 Real Unix-style pipelines can be created using the standard library’s
  io.Pipe() 
 function. For example, the Go standard library uses this function to compare images 
 (see file
  go/src/pkg/image/png/reader_test.go
 ).
  
 In addition to using
  io.Pipe()
  to create Unix-style pipelines it is also possible to create 
 pipelines using channels, and it is this latter technique that we will review here.
  
 The
  filter
  example program (in file
  filter/filter.go
 ), accepts some command-line 
 arguments(e.g.,to specify minimum and maximum file sizes and acceptable file 
 suffixes) and a list of files, and outputs those files from the list which match",NA
7.2.2. Example: Concurrent Grep,"One common concurrent programming pattern is where we have multiple jobs to 
 do, each of which can run to completion independently of the others. For example, 
 the Go standard library’s
  net/http
  package’s HTTP server follows this pattern, with 
 each request being served concurrently in its own goroutine and with no 
 communication between the goroutines. In this subsection we will illustrate one 
 approach to implementing this pattern using variants of a
  cgrep
 “concurrent grep” 
 program as an example.
  
 Unlike the standard library’s HTTP server, the
  cgrep
  examples spread their 
 processing over a fixed number of goroutines, rather than creating them ad hoc. (We 
 will see an example that creates a variable number of goroutines later;§7.2.5, 
 ➤
  
 349.)
  
 The
  cgrep
  programs take a regular expression and a list of files on the command line 
 and output the filename, line number, and every line in every file where the regular 
 expression matches. If there are no matches, there is no output at all.
  
 The
  cgrep1
  program (in file
  cgrep1/cgrep.go
 ) uses three channels, two of which are 
 used for sending and receiving
  struct
 s.",NA
7.2.3. Example: Thread-Safe Map,"Go’s
  sync
  and
  sync/atomic
  packages provide the low-level operations needed to 
 create concurrent algorithms and data structures. However, it is also possible to 
 take an existing data structure—such as a map or slice (or an
  omap.Map
 ; §6.5.3, 302 
  
 )—and make it thread-safe by ensuring that all accesses are serialized using 
 Go’s high-level channels.
  
 In this subsection we will develop a thread-safe map that has
  string
  keys and 
 interface{}
  values (i.e.,
  any
  values) and that can safely be shared by as many",NA
7.2.4. Example: Apache Report,"A frequent requirement in concurrent programs is for the concurrent processing to 
 update a shared data structure. One common solution is to use a mutex to serialize 
 accesses to the data structure. In Go, we can either use a mutex or use channels to 
 serialize accesses. In this subsection we will begin by showing an approach that uses 
 channels and the generic safe map developed in the previous subsection. Then we 
 will look at how to achieve the same thing using a shared 
 map
  protected by a mutex. 
 And finally, we will review how to use local
  map
 s that are independent and therefore 
 don’t need serialized accesses so as to maximize throughput, with channels used to 
 serialize the updating of a common
  map
  at the end.
  
 The
  apachereport
  programs all do the same thing: They read an Apache web server’s
  
 access.log
  file specified on the command line and output the number of accesses to 
 each unique HTML page that the log has recorded. These log files can easily grow 
 huge, so we have used one separate goroutine to read lines from the file and three 
 additional goroutines to share the processing of the lines. Each HTML page must be 
 added to a map with a count of 1 the first time it is seen, and this count must be 
 incremented each time the page is seen again. So, although multiple goroutines are 
 independently processing lines from the log file, they must all update the same map. 
 Each version of the program handles the updating of the map in a different way.
  
 7.2.4.1. Synchronizing with a Shared Thread-Safe Map
  
 In this subsubsection we will review the
  apachereport1
  program (in file
  apachere-
 port1/apachereport.go
 ). This program uses the safe map developed in the pre-vious 
 section to provide a shared thread-safe map. The program’s concurrency structure 
 is illustrated in Figure 7.6 (
 ➤
  342).
  
 In the figure, goroutine #2 is used to populate the work channel with lines from the 
 log file and goroutines #3 to #5 process each line and update the shared 
 safeMap
 . 
 The operations on the
  safeMap
  itself take place in yet another goroutine, so the 
 program uses six goroutines in total.
  
 var
  workers = runtime.NumCPU()
  
 func
  main() {
  
  
  runtime.GOMAXPROCS(runtime.NumCPU())
  // Use all the machine's cores 
  
  
 if len
 (os.Args) !=
  2
  || os.Args[
 1
 ] ==
  ""-h""
  || os.Args[
 1
 ] ==
  ""--help""
  {
  
  
  
  fmt.Printf(
 ""usage: %s <file.log>\n""
 , filepath.Base(os.Args[
 0
 ]))
  
  
  
  os.Exit(
 1
 )
  
  
  }
  
  
  lines :=
  make
 (
 chan
  string, workers*
 4
 )
  
  
  done :=
  make
 (
 chan struct
 {}, workers)",NA
7.2.5. Example: Find Duplicates,"This chapter’s final concurrency example is a program that attempts to find 
 duplicate files using file sizes and SHA-1 values rather than filenames.
 ★
  
 The program we will review is called
  findduplicates
  (in file
  findduplicates/find-
 duplicates.go
 ).The program usesthe standard library’s
 filepath.Walk()
  function to 
 iterate over all the files and directories in a given path, including subdirecto-ries, 
 and subsubdirectories, and so on. The program uses a variable number of 
 goroutines depending on the work it does. For each “big” file, a new goroutine is 
 created on the fly to compute that file’s SHA-1, while each “small” file’s SHA-1 is 
 computed in the current goroutine. This means that we don’t know in advance how 
 many goroutines any particular run of the program will use, although we can—and 
 do—set an upper limit.
  
 One way of handling a variable number of goroutines is to use a “done” channel just 
 like in earlier examples, only this time keeping a running count of how many 
 goroutines are created. An easier way is to use a
  sync.WaitGroup
  which achieves the 
 same thing but passes on the counting to Go.
  
 const
  maxGoroutines =
  100
  
 func
  main() {
  
  
  runtime.GOMAXPROCS(runtime.NumCPU())
  // Use all the machine's cores 
  
  
 if len
 (os.Args) ==
  1
  || os.Args[
 1
 ] ==
  ""-h""
  || os.Args[
 1
 ] ==
  ""--help""
  {
  
  
  
  fmt.Printf(
 ""usage: %s <path>\n""
 , filepath.Base(os.Args[
 0
 ]))
   
  
  
 os.Exit(
 1
 )
  
  
  }
  
 ★
  The SHA-1 secure hash algorithm produces a 20-byte value for any given chunk of data—such as a file. 
 Identical files will have the same SHA-1 values and different files will almost always have different SHA-1 
 values.",NA
7.3. Exercises,"This chapter has three exercises. The first involves creating a thread-safe data 
 structure. The second and third require the creation of small but complete 
 concurrent programs, with the third exercise being fairly challenging.
  
 1. Create a thread-safe slice type called
  safeSlice
  and the following exported 
  
 SafeSlice interface
 :
  
 ★
  At the time of this writing, Go has no locale support.",NA
8,NA,NA
File Handling,"§8.1. Custom Data Files 
 ➤
  362
  
  
 §8.1.1. Handling JSON Files 
 ➤
  365
  
  
 §8.1.2. Handling XML Files 
 ➤
  371
  
  
 §8.1.3. Handling Plain Text Files 
 ➤
  377
  
  
 §8.1.4. Handling Go Binary Files 
 ➤
  385
  
  
 §8.1.5. Handling Custom Binary Files 
 ➤
  387
  
 §8.2. Archive Files 
 ➤
  397
  
  
 §8.2.1. Creating Zip Archives 
 ➤
  397
  
  
 §8.2.2. Creating Optionally Compressed Tarballs 
 ➤
  399
  
 §8.2.3. Unpacking Zip Archives 
 ➤
  401
  
  
 §8.2.4. Unpacking Optionally Compressed Tarballs 
 ➤
  403
  
 In earlier chapters we saw several examples of reading, creating, and writing text 
 files. In this chapter we will look in more detail at Go’s file handling facilities and in 
 particular how to read and write files in standard formats (such as XML and JSON), 
 as well as custom plain text and binary formats.
  
 Since we have now covered all of Go’s language features (apart from creating 
 programs with our own custom packages and with third-party packages—which is 
 covered in the next chapter), we are free to use all the facilities that Go pro-vides. 
 We will take advantage of this freedom and make use of closures (§5.6.3, 225 
  
 ) to avoid repetitive code, and in some cases make more advanced use of Go’s 
 support for object orientation, in particular adding methods to functions.
  
 This chapter’s focus is on files rather than directories or the file system gen-erally. 
 For directories, the previous chapter’s
  findduplicates
  example (§7.2.5, 349 
  
 ) shows 
 how to iterate over the files and subdirectories of a directo-ry using the
  
 filepath.Walk()
  function. In addition, the standard library’s
  os 
 package’s
  os.File
  type 
 provides methods for reading the names in a directory (
 os.File.Readdirnames()
 ), and 
 for retrieving
  os.FileInfo
  values for each item in a directory (
 os.File.Readdir()
 ).
  
 361",NA
8.1. Custom Data Files,"It is quite common for programs to maintain internal data structures and to provide 
 import/export functionality to support data interchange, and also to facilitate the 
 processing of their data by external tools. Since our concern here is with file 
 handling, we will focus purely on how to write and read data to and from standard 
 and custom formats from and into a program’s internal data structures.
  
 For this section we will use the same data for all the examples so that we can get a 
 direct comparison between the various file formats. All the code is taken from the
  
 invoicedata
  program (in the
  invoicedata
  directory in the files
  invoicedata.go
 , 
 gob.go
 ,
  
 inv.go
 ,
  jsn.go
 ,
  txt.go
 , and
  xml.go
 ). The program takes two filenames as command-line 
 arguments, one to read and one to write (and which must be different). The 
 program then reads the data from the first file (in whatever format its suffix 
 indicates) and writes the same data to the second file (again, using whatever format 
 its suffix indicates).
  
 The files created by
  invoicedata
  work cross-platform, that is, a file created on, say, 
 Windows, is readable on Mac OS X and Linux, and vice versa, no matter which 
 format it is. Gzip-compressed files (e.g.,
  invoices.gob.gz
 ) can be read and written 
 seamlessly; compression is covered in the second section (§8.2, 
 ➤
  397).
  
 The data consists of an
  []*Invoice
 , that is, a slice of pointers to
  Invoice
  values. Each 
 invoice is held in an
  Invoice
  value, and each invoice holds zero or more items in its
  
 Items
  field of type
  []*Item
  (slice of pointers to
  Item
 ).
  
 type
  Invoice
  struct
  { 
  
 type
  Item
  struct
  {
  
  Id         int
  
  Id      string
  
  CustomerId int
  
  Price    float64
  
  Raised     time.Time
  
  Quantity int
  
  Due        time.Time
  
  Note     string
  
  Paid       bool 
  
 }
  
  Note       string
  
  Items      []*Item
  
 }
  
 These two
  struct
 s are used to hold the data. Table 8.1 shows some informal com-
 parisons of how long it took to read and write the same 50000 random invoices, and 
 the size of the file occupied by those invoicesin each format. The timingsare in 
 seconds rounded up to the nearest tenth of a second—they should be taken as 
 unitless since they will undoubtedly vary on different hardware under different",NA
8.1.1. Handling JSON Files,"According to
  www.json.org
 , JSON (JavaScript Object Notation) is a lightweight data 
 interchange format that is easy for humans to read and write, and easy for machines 
 to parse and generate. JSON is a plain text format using the UTF-8 encoding. JSON 
 has become increasingly popular—particularly for transferring data over network 
 connections—because it is more convenient to write, is (usually) much more 
 compact,and requires much less processing power to parse than XML.
  
 Here is the data for a single invoice in JSON format, but with most of the invoice’s 
 second item’s fields elided.
  
  
 {
   
  ""Id"": 4461,
  
  
  ""CustomerId"": 917,
  
  ""Raised"": ""2012-07-22"",",NA
8.1.2. Handling XML Files,"The XML (eXtensible Markup Language) format is widely used both as a data 
 interchange format and as a file format in its own right. XML is a much more 
 complex and sophisticated format than JSON,but is generally more verbose and 
 tedious to write by hand.
  
 The
  encoding/xml
  package can encode and decode
  struct
 s to and from XML for-mat in 
 a similar way to the
  encoding/json
  package. However, the XML encoding and 
 decoding functionality is much more demanding than for the
  encoding/json 
 package. 
 This is partly because the
  encoding/xml
  package requires
  struct
  fields to have suitably 
 formatted tags (whereas they are not always needed for JSON). Also,Go 1’s
  
 encoding/xml
  package does not have an
  xml.Marshaler interface
 , so we must write 
 more code to handle XML than for the JSON and Go binary formats.
  
 (This is expected to be resolved in a later Go 1.
 x
  release.)
  
 Here is a single example invoice in XML format with newlines and extra whitespace 
 included to make it fit the page and be easier to read.
  
  
 <INVOICE Id=""2640"" CustomerId=""968"" Raised=""2012-08-27"" Due=""2012-09-26""
  
  
 Paid=""false""><NOTE>See special Terms &amp; Conditions</NOTE>
  
  
 <ITEM Id=""MI2419"" Price=""342.80"" Quantity=""1""><NOTE></NOTE></ITEM>
  
  
 <ITEM Id=""OU5941"" Price=""448.99"" Quantity=""3""><NOTE>
  
  
 &quot;Blue&quot; ordered but will accept &quot;Navy&quot;</NOTE>
  
  
 </ITEM>
  
  
 <ITEM Id=""IF9284"" Price=""475.01"" Quantity=""1""><NOTE></NOTE></ITEM>
  
  
 <ITEM Id=""TI4394"" Price=""417.79"" Quantity=""2""><NOTE></NOTE></ITEM>
  
  
 <ITEM Id=""VG4325"" Price=""80.67"" Quantity=""5""><NOTE></NOTE></ITEM>
  
  
 </INVOICE>
  
           
 Having raw character data in tags (e.g., for the invoices’ and items’
  Note
  fields) is 
 rather tricky to handle when using the
  xml
  package’s encoder and decoder, so the
  
 invoicedata
  example uses explicit
  <NOTE>
  tags.
  
 8.1.2.1. Writing XML Files
  
 The
  encoding/xml
  package requires us to use
  struct
 s whose fields have
  encod-ing/xml
  
 package-specific tags. In view of this, we cannot use the
  Invoice
  and 
 Item struct
 s 
 directly for XML. So we have created the XML-specific
  XMLInvoices
 , 
 XMLInvoice
 , and
  
 XMLItem struct
 s to solve this. And since the
  invoicedata
  program requires us to have 
 parallel sets of
  struct
 s, we must also provide a means of con-verting between them. 
 Of course, applications that use XML as their primary",NA
8.1.4. Handling Go Binary Files,"The Go binary (“gob”) format is a self-describing sequence of binary values. In-
 ternally, the Go binary format consists of a sequence of zero or more chunks, each of 
 which has a byte count, a sequence of zero or more
  typeId
 –
 typeSpecifi-cation
  pairs, 
 and a
  typeId
 –
 value
  pair. The
  typeId
 –
 typeSpecification
 pairs may be omitted if the 
 value pair’s
  typeId
  is predefined (e.g.,
  bool
 ,
  int
 ,
  string
 , etc.); oth-erwise each of the 
 type pairs is used to describe a custom type (e.g., a custom 
 struct
 ). Type pair
  typeId
 s 
 are negated to distinguish between type pairs and value pairs. As we will see, we 
 don’t need to know any of the internals to make use of gob format, since the
  
 encoding/gob
  package takes care of all the low-level details for us, behind the 
 scenes.
 ★
  
 The
  encoding/gob
  package provides encoder and decoder functionality in much the 
 same way as the
  encoding/json
  package does, and is just as easy to use. In general, 
 gob format is the most convenient Go format to use for data files or for transmitting 
 data over network connections, providing that human readability is not a 
 requirement.
  
 8.1.4.1. Writing Go Binary Files
  
 Here is a method for writing an entire data set of
  []*Invoice
  items to an open file (or 
 anything else that fulfills the
  io.Writer interface
 ) in gob format.
  
 type
  GobMarshaler
  struct
 {}
  
 func
  (GobMarshaler) MarshalInvoices(writer io.Writer,
  
  invoices 
 []*Invoice)
  error
  {
  
  
  encoder := gob.NewEncoder(writer) 
  
  
  
 if
  err := encoder.Encode(magicNumber); err !=
  nil
  { 
  
  
  
 return
  err
  
  
  } 
  
  
  
 if
  err := encoder.Encode(fileVersion); err !=
  nil
  { 
   
  
 return
  err
  
  
  } 
  
  
  
 return
  encoder.Encode(invoices) 
  
 }
  
 We begin by creating a gob encoder that wraps the
  io.Writer
  and provides a writer to 
 which we can write our data.
  
 ★
 A more detailed description of the format is given in the documentation,
  golang.org/pkg/encoding/ gob/
 . 
 And Rob Pike has written an interesting blog post on gob format,
  blog.golang.org/2011/03/ gobs-of-data.html
  
 .",NA
8.1.5. Handling Custom Binary Files,"Although Go’s
  encoding/gob
  package is very easy to use and requires very little code, 
 we might still need to create our own custom binary formats. A custom binary 
 format is likely to achieve the most compact data representation possible",NA
8.2. Archive Files,"Go’s standard library provides support for several compression formats. This 
 includes gzip, so it is easy to make Go programs able to seamlessly write and read 
 files with gzip compression if they end with a
  .gz
  suffix and without compression 
 otherwise. In addition, the library has packages which allow us to write and read
  .zip
  
 files and tarballs (
 .tar
  and
  .tar.gz
 ), and to read
  .bz2
  files (typically,
  .tar.bz2
  files).
  
 In this section we will review extracts from two programs. The first,
  pack
  (in file 
 pack/pack.go
 ), accepts the name of an archive and a list of files to store in the archive 
 on the command line. It determines which file format to use based on the archive 
 filename’s suffix. The second,
  unpack
  (in file
  unpack/unpack.go
 ), also accepts the name 
 of an archive on the command line, and attempts to extract all the archive’s files, 
 recreating the directory structure as it goes if necessary.",NA
8.2.1. Creating Zip Archives,"To use the
  zip
  package for zipping we must first open a file to write to and then 
 create a
  *zip.Writer
  to write into it. Then, for each file we want to put in the
  .zip 
 archive, we must read the file and write its contents into an
  io.Writer
  obtained from 
 the
  *zip.Writer
 . The
  pack
  program uses two functions,
  createZip()
  and 
 writeFileToZip()
 , 
 to create a
  .zip
  file using this approach.
  
 func
  createZip(filename string, files []string)
  error
  {
  
  file, err := 
 os.Create(filename) 
  
  
  
 if
  err !=
  nil
  { 
  
  
   
 return
  err
  
  
  } 
  
  
  
 defer
  file.Close()
  
  
  zipper := zip.NewWriter(file)
  
 ★
  File permission flags are traditionally written using octal numbers, as indicated by a leading 
 0
 . A value 
 of
  0666
  makes the file readable and writable by everyone—however, a
  umask
  of
  0022
  (a common setting) 
 modifies this to
  0644
 , thus making a file readable and writable by its creator and readable but not 
 writable by everyone else.",NA
8.2.2. Creating Optionally Compressed Tarballs,"Creating tarballs is fairly similar to creating
  .zip
  archives, with the key differ-ences 
 being that we write all the data to the same writer,and that we must write a full 
 header before each file’s data, not just a filename. Our implementation for the
  pack
  
 program uses the
  createTar()
  and
  writeFileToTar()
  functions.",NA
8.2.3. Unpacking Zip Archives,"Unzipping a
  .zip
  file is just as straightforward as zipping one, only we must re-create 
 the directory structure if the archive contains filenames that include paths.
  
 func
  unpackZip(filename string)
  error
  {
  
  
  reader, err := zip.OpenReader(filename) 
  
  
  
 if
  err !=
  nil
  { 
  
  
   
  
 return
  err
  
  
  } 
  
  
  
 defer
  reader.Close() 
  
  
  
 for
  _, zipFile :=
  range
  reader.Reader.File {
  
  
   
  name := sanitizedName(zipFile.Name)
  
  
   
  mode := zipFile.Mode() 
  
  
   
  
 if
  mode.IsDir() { 
  
  
   
   
 if
  err = os.MkdirAll(name,
  0755
 ); err !=
  nil
  { 
  
  
   
   
   
 return
  err
  
  
   
   
  }
  
  
   
  }
  else
  { 
  
  
   
   
 if
  err = unpackZippedFile(name, zipFile); err !=
  nil
  { 
  
  
   
   
  
 return
  err
  
  
   
   
  }
  
  
   
  }
  
  
  }",NA
8.2.4. Unpacking Optionally Compressed Tarballs,"Unpacking tar files is slightly easier than packing them. However, just as when we 
 unzip a
  .zip
  file, we must re-create the directory structure if the archive contains 
 filenames that include paths.
  
 func
  unpackTar(filename string)
  error
  {
  
  
  file, err := os.Open(filename) 
  
  
  
 if
  err !=
  nil
  { 
  
  
   
  
 return
  err
  
  
  } 
  
  
  
 defer
  file.Close() 
  
  
  
 var
  fileReader io.ReadCloser = file 
  
  
  
 if
  strings.HasSuffix(filename,
  "".gz""
 ) { 
  
  
   
  
 if
  fileReader, err = gzip.NewReader(file); err !=
  nil
  { 
  
  
  
  
 return
  err
  
  
   
  } 
  
  
   
  
 defer
  fileReader.Close()
  
  
  }
  
  
  reader := tar.NewReader(fileReader) 
  
  
  
 return
  unpackTarFiles(reader) 
  
 }
  
 This function opens the tarball in Go’s conventional way and defers closing the file. 
 If the file is gzip-compressed we create a gzip decompression filter and defer closing 
 it. The
  gzip.NewReader()
  function returns a
  *gzip.Reader
  which fulfills the
  io.ReadCloser 
 interface
 , just as the
  file
  (of type
  *os.File
 ) does.
  
 With the file reader set up, we create a
  *tar.Reader
  to read from it and pass on the 
 rest of the work to a helper function.",NA
8.3. Exercises,"There are three exercises for this chapter. The first one involves a small but slightly 
 subtle modification to one of the programs presented in this chapter. The second 
 requires the writing of a short—but tricky—new program from scratch. The third 
 involves substantial changes to another of this chapter’s ex-amples.
  
 1. Copy the
  unpack
  directory to, say,
  my_unpack
 , and modify the
  unpack.go
  pro-gram 
 so that it can additionally unpack
  .tar.bz2
  (bzip2-compressed) files. This 
 requires small changes to a couple of functions, and the addition of about ten 
 lines to the
  unpackTar()
  function. The change is a tiny bit tricky because the
  
 bzip2.NewReader()
  function doesn’t return an
  io.ReadCloser
 . A solution is 
 provided in the file
  unpack_ans/unpack.go
  which is about ten lines longer than 
 the original example.
  
 2. Windows text files (
 .txt
 ) often use the UTF-16-LE (UTF-16 little-endian) 
 encoding. UTF-16-encoded files must always begin with a byte order mark, 
 [0xFF, 0xFE]
  for little-endian or
  [0xFE, 0xFF]
  for big-endian. Write a program that 
 reads a UTF-16-encoded file named on the command line, and writes out the 
 same text using the UTF-8 encoding either to
  os.Stdout
  or to a file named on the 
 command line. Be sure to read both little- and big-endian UTF-16 encodings 
 correctly. The book’s examples come with a couple of",NA
9,NA,NA
Packages,"§9.1. Custom Packages 
 ➤
  408
  
  
 §9.1.1. Creating Custom Packages 
 ➤
  408
  
  
 §9.1.2. Importing Packages 
 ➤
  416
  
 §9.2. Third-Party Packages 
 ➤
  417
  
 §9.3. A Brief Survey of Go’s Commands 
 ➤
  418
  
 §9.4. A Brief Survey of the Go Standard Library 
 ➤
  419
  
  
 §9.4.1. Archive and Compression Packages 
 ➤
  419
  
  
 §9.4.2. Bytes and String-Related Packages 
 ➤
  419
  
  
 §9.4.3. Collection Packages 
 ➤
  421
  
  
 §9.4.4. File, Operating System, and Related Packages 
 ➤
  423
  
 §9.4.5. Graphics-Related Packages 
 ➤
  425
  
  
 §9.4.6. Mathematics Packages 
 ➤
  425
  
  
 §9.4.7. Miscellaneous Packages 
 ➤
  425
  
  
 §9.4.8. Networking Packages 
 ➤
  427
  
  
 §9.4.9. The Reflect Package 
 ➤
  427
  
 The Go standard library has a large number of packages, which provide a wide 
 range of functionality out of the box. In addition, many third-party packages are 
 available from the Go Dashboard at
  godashboard.appspot.com/project
 .
  
 Go also allows us to create our own custom packages. These packages can be 
 installed into our copy of Go’s standard library, or kept in our own Go tree (i.e., in 
 the, or one of the,
  GOPATH
  paths).
  
 In this chapter we will look at how to create and import packages, including our 
 own custom packages and third-party packages. Then we will very briefly re-view 
 some of the commands(programs)supplied with the
  gc
 compiler. And final-ly, we 
 will briefly review Go’s standard library so that we can avoid reinventing the wheel.
  
 407",NA
9.1. Custom Packages,"Up to now, almost all of the examples we have reviewed have been in a single 
 package:
  main
 . For any given package, Go allows us to split the package’s code over 
 as many files as we like, providing only that they are all in the same di-rectory. For 
 example, Chapter 8’s
  invoicedata
  example uses a single package (
 main
 ), even though 
 it consists of six separate files (
 invoicedata.go
 ,
  gob.go
 ,
  inv.go
 , 
 jsn.go
 ,
  txt.go
 ,and
  
 xml.go
 ).This is achieved simply by making the first statement in each file (excluding 
 comments),
  package main
 .
  
 For larger applications we might want to create application-specific packages to 
 help partition an application’s functionality into logical units. Also, we might want to 
 create packages containing functionality that we want a family of ap-plications to be 
 able to use. Go doesn’t make any distinction between a pack-age intended for use by 
 a single application and a package to be shared across our applications; however, 
 we can create an implied distinction by putting our application-specific packages in 
 subdirectories of our application and shared packages in subdirectories directly 
 under a
  GOPATH
  source directory
 . A
  GOPATH 
 source directory isa directory called
  
 src
 ;every directory in the
  GOPATH
  should con-tain an
  src
  directory,since this is what 
 Go’s tools (commands)expect. The source code for our programs and packages 
 should be kept in subdirectories under the (or a, if there is more than one)
  GOPATH 
 src
  directory.
  
 It is also possible to install our own packages directly into the Go tree (i.e.,under 
 GOROOT
 ), but there is no advantage to doing this and it could be inconvenient on 
 systems where Go is installed using a package management system or an installer or 
 even if it is built by hand.",NA
9.1.1. Creating Custom Packages,"It is best to create custom packages in the
  GOPATH src
  directory (or one of the 
 GOPATH src
  directories). Application-specific packages can be created within the 
 application directory, but packages we want to share ought to be created directly 
 under a
  GOPATH src
  directory, ideally under a unique directory to avoid name 
 conflicts.
  
 By convention, the source code for a package is put in a directory with the same 
 name as the package. The source code may be split across as many files as we like 
 and the files can have arbitrary names (so long as they end with
  .go
 ). In this book we 
 have adopted the convention of giving the
  .go
  file (or one of them, if there is more 
 than one) the same name as the package.
  
 The
  stacker
  example from Chapter 1 (§1.5, 21 
  
 ) consists of a program (in file 
 stacker.go
 ) and an application-specific package (
 stack
  in file
  stack.go
 ), and uses the 
 following directory layout:
  
 aGoPath
 /src/stacker/stacker.go",NA
9.1.2. Importing Packages,"Go allows us to alias package names. This feature can be convenient and useful—for 
 example, making it easy to switch between two implementations of a package. For 
 instance,we could import a package like this:
 import bio ""bio_v1""
 , so that in our code 
 the
  bio_v1
  package is accessed as
  bio
  instead of
  bio_v1
 . Later, when a more mature 
 implementation is available,we could switch to it by chang-ing the import to
  import 
 bio ""bio_v2""
 . This will work if both
  bio_v1
  and
  bio_v2 
 provide the same APIs (or if
  
 bio_v2
 ’s API is a superset of
  bio_v1
 ’s), and means that the rest of the code can be left 
 unchanged. On the other hand, aliasing standard library package names is probably 
 best avoided, since it could cause confusion or irritation to maintainers later on.",NA
9.2. Third-Party Packages,"The
  go
  tool that we have used throughout the book to build programs and pack-ages 
 (e.g., the
  omap
  package) can also be used to download, build, and install third-party 
 packages. (Of course, this assumes that our computer is connect-ed to the Internet.) 
 A list of third-party packages is maintained at
  godash-board.appspot.com/project
 . (An 
 alternative approach is to download the source code—often obtained as a copy 
 directly from a distributed version control system—and build the package ourselves 
 locally.)
  
 To install one of the Go Dashboard’s packages, first click its link to go to the 
 package’s home page. Somewhere on the package’s web site there should be a 
 go get
  
 command that shows how to download and install the package.
  
 For example, if we were to click the Go Dashboard’s
  freetype-go.googlecode.com/ 
 hg/freetype
  link, it would take us to the
  code.google.com/p/freetype-go/
  page which 
 shows the installation command up front (at the time of this writing):
  go get freetype-
 go.google- code.com/hg/freetype
 .
  
 When it comes to third-party packages,
  go get
  must, of course, install them 
 somewhere. By default it will use the first path listed in the
  GOPATH
  environment",NA
9.3. A Brief Survey of Go’s Commands,"A Go installation for the
  gc
  compiler naturally includes compilers and linkers (
 6g
 ,
  6l
 , 
 etc.), but also a number of other tools. The most useful of these is
  go
 , which can be 
 used as a build tool for our own programs and packages, as a tool for downloading 
 and installing third-party programs and packages, and as a tool for executing unit 
 tests and for benchmarking, as we saw earlier (§9.1.1.3, 414 
  
 ). Execute
  go help
  
 for a full list of the commands available and
  go help 
 command
  for help on the specified
  
 command
 . There is also the
  godoc
  tool for showing documentation (“The Go 
 Documentation”, 8 ).
  
 In addition to the tools we have used in the book, there are several other tools and
  
 go
  tool commands, a few of which we will mention here. One is
  go vet 
 which does 
 some simple error checking on Go programs, specifically on the
  fmt 
 package’s print 
 functions.
  
 Another command is
  go fix
 . Sometimes a new Go release incorporates changes to the 
 language—or more often, to library APIs—that invalidate existing code. By running
  
 go fix
  over our code base, all of our code can be automatically updated. We
  strongly
  
 recommend that
  .go
  files are registered with a version control system, and that they 
 are all checked in, or are at least backed up, before running
  go fix
 .This will allow us 
 to easily see what changes were applied and be able to roll back any or all of them if 
 the fixes break the code. We can also use",NA
9.4. A Brief Survey of the Go Standard Library,"The Go standard library includes a large number of packages that between them 
 provide a wide range of functionality. The overview provided here is highly 
 selective and very brief. This is because the contents of the library are likely to 
 continue to grow after this book is published, so it is best to look at the library APIs 
 online (
 golang.org/pkg/
 ) or locally using
  godoc
 , both to see the most up-to-date 
 information and to get a comprehensive overview of what is available in each 
 package.
  
 The
  exp
  “experimental” package is where packages that might
  potentially
  be added 
 to the standard library begin life, so these packages should not be used unless we 
 specifically want to participate in their development (e.g., testing, commenting, or 
 submitting patches). The
  exp
  package is normally available when pulling Go from 
 Google’s Go source tree, and but it may not be included in prebuilt packages. All the 
 other packages are okay to use, although at the time of this writing, some were 
 incomplete.",NA
9.4.1. Archive and Compression Packages,"Go can read and write tarballs and
  .zip
  files. The relevant packages are 
 archive/tar
  
 and
  archive/zip
 , and for compressed tarballs,
  compress/gzip
  and 
 compress/bzip2
 . The 
 book’s
  pack
  and
  unpack
  examples illustrate the use of these
  
 (§8.2, 397
  
 ).
  
 Other compression formats are also supported; for example, Lempel-Ziv-Welch 
 (
 compress/lzw
 ) which is used for
  .tiff
  images and
  .pdf
  files.",NA
9.4.2. Bytes and String-Related Packages,"The
  bytes
  and
  strings
  packages have many functions in common, only the former 
 operateson
  []byte
  values and the latter on
  string
  values. For strings,the 
 strings
  
 package provides all the most useful utilities to find substrings, replace
  
 substrings, split strings, trim strings, and change case (see §3.6.1, 107
  
 ). The
  
 strconv
  package provides conversionsfrom numbers and Booleans to stringsand
  
 vice versa (see §3.6.2, 113
  
 ).",NA
9.4.3. Collection Packages,"Slices are the most efficient collection type provided by Go, but sometimes it is 
 useful or necessary to use a more specialized collection type. For many situations 
 the built-in
  map
  type is sufficient, but the Go standard library also provides the
  
 container
  package which contains various collection packages.
  
 The
  container/heap
  package provides functions for manipulating a heap, where the 
 heap must be a value of a custom type that satisfies the
  heap.Interface 
 defined in the
  
 heap
  package. A heap (strictly speaking, a
  min-heap
 ) maintains its values in an order 
 such that the first element is always the smallest (or largest for a
  max-heap
 )—this is 
 known as the heap property. The
  heap.Interface 
 embeds the
  sort.Interface
  and adds
  
 Push()
  and
  Pop()
  methods. (We discussed the
  sort.Interface
  in §4.2.4, 160 
  
 and 
 §5.7, 244 .)
  
 It is easy to create a simple custom heap type that satisfies the
  heap.Interface
 . Here is 
 an example of such a heap in use.
  
 ints := &IntHeap{
 5
 ,
  1
 ,
  6
 ,
  7
 ,
  9
 ,
  8
 ,
  2
 ,
  4
 } 
  
 heap.Init(ints)
  // Heapify 
  
 ints.Push(
 9
 ) 
  
 // IntHeap.Push() doesn't preserve the heap property 
 ints.Push(
 7
 ) 
  
 ints.Push(
 3
 ) 
  
 heap.Init(ints)
  // Must reheapify after heap-breaking changes 
  
 for
  ints.Len() >
  0
  {
  
  
  fmt.Printf(
 ""%v ""
 , heap.Pop(ints)) 
  
 } 
  
 fmt.Println()
  // prints: 1 2 3 4 5 6 7 7 8 9 9
  
 Here is the complete custom heap implementation.
  
 type
  IntHeap []int 
  
 func
  (ints *IntHeap) Less(i, j int) bool {",NA
"9.4.4. File, Operating System, and Related Packages","The standard library provides many packages to support file and directory han-
 dling and interaction with the operating system. In many cases these packages 
 provide operating-system-neutral abstractions that make it straightforward to 
 create cross-platform Go applications.
  
 The
  os
  (“operating system”) package provides functions for operating-system 
 interactions,such as changing the current working directory,changing file mode and 
 ownership, getting and setting environment variables, and creating and removing 
 files and directories. In addition, this package provides functions for creating and 
 opening files (
 os.Create()
  and
  os.Open()
 ), and for retrieving file attributes (e.g., via the
  
 os.FileInfo
  type), all of which we have seen used in earlier chapters. (See, for 
 example, §7.2.5, 349 , and Chapter 8.)
  
 Once a file is opened, especially in the case of text files, it is very common to want to 
 access it via a buffer (e.g., to read lines as strings rather than as byte slices). The 
 functionality we need is provided by the
  bufio
  package, and again, we have seen 
 many examples of its use in earlier chapters. In addition to using 
 bufio.Reader
 s and
  
 bufio.Writer
 s for reading and writing strings, we can also read (and unread)
  rune
 s, 
 read (and unread) single bytes, read multiple bytes, as well as write
  rune
 s and single 
 or multiple bytes.
  
 ★
  Older versions of Go may have the
  container/vector
  package. This package is deprecated—use
  
 slices and the built-in
  append()
  function instead (§4.2, 148
  
 ).",NA
9.4.5. Graphics-Related Packages,"Go’s
  image
  package provides some high-level functions and types for creating and 
 holding image data. It also has a number of packages that provide encoders
  
 and decoders for various standard graphics file formats, such as
  image/jpeg
  and
  
 image/png
 . We discussed some of these earlier in this chapter (§9.1.2, 416
  
 ), and
  
 in one of Chapter 7’s exercises.
  
 The
  image/draw
  package provides some basic drawing functionality as we saw in
  
 Chapter 6 (§6.5.2,289
  
 ).The third-party
  freetype
  package adds more functions
  
 for drawing. The
  freetype
  package itself can draw text using any specified TrueType 
 font, and the
  freetype/raster
  package can draw lines and cubic and quadratic curves. 
 (We discussed obtaining and installing the
  freetype
  package
  
 earlier; §9.2, 417
  
 .)",NA
9.4.6. Mathematics Packages,"The
  math/big
  package provides unlimited (except by memory) size integers
  
 (
 big.Int
 ) and rationals (
 big.Rat
 ); these were discussed earlier (§2.3, 57
  
 ). The
  
 pi_by_digits
  example shows the use of
  big.Int
 s (§2.3.1.1, 61
  
 ). The
  math/big
  
 package also provides a
  big.ProbablyPrime()
  function.
  
 The
  math
  package provides all the standard mathematical functions (based on
  
 float64
 s) and several standard constants. See Tables 2.8, 2.9, and 2.10
  
 (65–67
  
 ).
  
 The
  math/cmplx
  package provides some standard functions for complex numbers
  
 (based on
  complex128
 s). See Table 2.11 (71
  
 ).",NA
9.4.7. Miscellaneous Packages,"In addition to the packages that can be roughly grouped together, the standard 
 library contains a number of packages that stand more or less alone.
  
 The
  crypto
  package can provide hashes using the MD5, SHA-1, SHA-224, SHA-256, 
 SHA-384, and SHA-512 algorithms. (Support for each algorithm is supplied by a 
 package, e.g.,
  crypto/sha512
 .) In addition, the
  crypto
  package has packages that 
 provide encryption and decryption using a variety of algorithms, such as AES, DES, 
 and so on, each in packages with corresponding names (e.g., 
 crypto/aes
 ,
  crypto/des
 ).",NA
9.4.8. Networking Packages,"The Go standard library has many packages that support networking and relat-ed 
 programming. The
  net
  package provides functions and types for communi-cating 
 using Unix domain and network sockets, TCP/IP, and UDP. The package also 
 provides functions for domain name resolution.
  
 The
  net/http
  package makes use of the
  net
  package and has functionality for parsing 
 HTTP requests and replies, and provides a basic HTTP client. The 
 net/http
  package 
 also includes an easy-to-extend HTTP server, as we saw in Chapter 2 (§2.4, 72 
  
 ) and Chapter 3’s exercises. The
  net/url
  package provides URL 
 parsing and query escaping.
  
 Some other high-level networking packagesare included in the standard library. One 
 is the
  net/rpc
  (“Remote Procedure Call”) package which allows a server to provide 
 objects whose exported methods can be called by clients. Another is the
  net/smtp
  
 (“Simple Mail Transport Protocol”) package which can be used to send email.",NA
9.4.9. The Reflect Package,"The
  reflect
  package provides runtime reflection (also called
  introspection
 ), that is, 
 the ability to access and interact with values of arbitrary types at runtime.
  
 The package also provides some useful utility functions such as
  reflect.Deep-Equal()
  
 which can compare any two values—for example, slices, which aren’t comparable 
 using the
  ==
  and
  !=
  operators.
  
 Every value in Go has two attributes:its actual value and its type. The
  reflect. TypeOf()
  
 function can tell us the type of any value.
  
 x :=
  8.6 
  
 y := float32(
 2.5
 ) 
  
 fmt.Printf(
 ""var x %v = %v\n""
 , reflect.TypeOf(x), x) 
 fmt.Printf(
 ""var y %v = %v\n""
 , reflect.TypeOf(y), y)
  
 var x float64 = 8.6
  
 var y float32 = 2.5
  
  
 Here we have output two floating-point variables and their types as Go
  var 
 declarations using reflection.
  
 When the
  reflect.ValueOf()
  function is called on a value it returns a
  reflect. Value
  which 
 holds the value but isn’t the value itself. If we want to access the held value we must 
 use one of the
  reflect.Value
  methods.
  
 word :=
  ""Chameleon"" 
  
 value := reflect.ValueOf(word)",NA
9.5. Exercises,"This chapter has three inter-related exercises. The first exercise involves the 
 creation of a small custom package. The second exercise involves the creation of a 
 test for the package. And the third exercise is to write a program that makes use of 
 the package. The exercises increase in difficulty with the third one being rather 
 challenging.
  
 1. Create a package, called, say,
  my_linkutil
  (in file
  my_linkutil/my_linkutil. go
 ). The 
 package should provide two functions. The first function is 
 LinksFromURL(string) 
 ([]string, error)
  which given a URL string (e.g., 
 ""http://www.qtrac.eu/index.html""
 ), 
 returns a slice of all the web page’s 
 unique
  anchor links (i.e.,
  <a>
  tags’
  href
  
 attribute values), and
  nil
  (or
  nil 
 and an
  error
 ). The second function is
  
 LinksFromReader(io.Reader) ([]string, error)
  which does the same thing only it 
 reads from an
  io.Reader
  (e.g., an open file or an
  http.Response.Body
 ). The
  
 LinksFromURL()
  function should use the
  LinksFromReader()
  function internally.
  
 A solution is given in
  linkcheck/linkutil/linkutil.go
 . The solution’s first function is 
 about 11 lines and makes use of the
  net/http
  package’s 
 http.Get()
  function. The 
 second 
 function 
 is 
 around 
 16 
 lines 
 and 
 makes 
 use 
 of 
 the
  
 regexp.Regexp.FindAllSubmatch()
  function.
  
 2. Go’s standard library provides support for HTTP testing (e.g., the
  net/http/ 
 httptest
  package), but for this exercise we will be content with testing the 
 my_linkutil.LinksFromReader()
  function developed in the previous exer-cise. To 
 this end, create a test file (e.g.,
  my_linkutil/my_linkutil_test.go
 ) containing a single 
 test,
  TestLinksFromReader(*testing.T)
 . The test should read in an HTML file from 
 the file system and a links file which lists the file’s unique anchor links, and it 
 should then compare the links found in the HTML file by the
  
 my_linkutil.LinksFromReader()
  function with the links in the links file.
  
 ★
  Rob Pike has written an interesting and useful blog entry on Go reflection,
  blog.golang.org/2011/ 09/laws-
 of-reflection.html
 .",NA
A,NA,NA
Epilogue,"The Go developers took a long hard look at some of the most widely used pro-
 gramming languages and tried to discern which features were really useful and 
 productive to have, and which were redundant or even counterproductive. They 
 also drew on the many decadesof programming experiencethat they collectively 
 have had. As a result they produced the Go programming language.
  
 In the tradition of Objective-C and C++, Go is an object-oriented “better C”. Like Java, 
 Go has its own syntax,so it doesn’t have to maintain C compatibility in the way that 
 Objective-C and C++ do. But unlike Java, Go compiles to native code and isn’t limited 
 to the speed of a virtual machine.
  
 In addition to Go’s novel approach to object orientation with its emphasis on ab-
 stract interfaces and concrete types with smart embedding and aggregation, Go also 
 supports advanced features such as function literals and closures. And Go’s built-in 
 map and slice types between them serve almost every data structure need. Go’s 
 Unicode-based string type uses the world’s de facto standard encod-ing (UTF-8),and 
 the standard library providesexcellent support at both the byte and character level.
  
 Go’s support for concurrency is outstanding. Its lightweight goroutines and its type-
 safe and high-level channels make it much easier to create concurrent programs 
 compared with many other languages (e.g., C, C++, or Java). And Go’s lightning-fast 
 compilation times are a breath of fresh air, especially to anyone used to building 
 large C++ programs and libraries.
  
 Go is already being used by a variety of commercial and noncommercial 
 organizations. And Go is used internally by Google, as well as being available 
 alongside Java and Python, as a language for developing web applications with the 
 Google App Engine (
 code.google.com/appengine/docs/go/overview.html
 ).
  
 The language is still evolving quite quickly,yet thanks to the
  go fix
  tool,it is easy to 
 update code to work with the latest release. Furthermore, the Go developers intend 
 to keep all Go 1.
 x
  versions backward compatible with Go 1 to ensure that Go users 
 have a language that is both stable and being improved at the same time.
  
 Go’s standard library is very wide ranging, but even in those cases where it doesn’t 
 have the functionality we need, we can always see if what we want is available from 
 the Go Dashboard (
 godashboard.appspot.com/project
 ), or in some
  
 435",NA
B,NA,NA
The Dangers of ,NA,NA
Software Patents,"Patents are a curious anomaly in capitalist economies, since they are the grant of a 
 private monopoly by the State. Adam Smith roundly condemns monopolies in
  The 
 Wealth of Nations
 .
  
 In modern times patents enjoy widespread support from a broad range of 
 businesses—fromsmall vacuumcleaner manufacturersto giant pharmaceutical 
 companies. But when it comes to
  software
  patents, it is difficult to find anyone who 
 positively supports them except for patent trolls (companies that buy and lease out 
 patent rights but which create nothing themselves),and their lawyers. Back in 1991 
 Bill Gates said, “If people had understood how patents would be granted when most 
 of today’s ideas were invented, and had taken out patents, the industry would be at 
 a complete standstilltoday.” Of course,hisview appears to be somewhat more 
 nuanced today.
  
 Software patents affect every business that produces software—whether for sale or 
 for in-house use. Even nonsoftware giants such as Kraft Foods and Ford Motor Co. 
 are having to spend large sums of money defending against software patent 
 lawsuits. But every programmer is exposed to risk. For example, linked lists have 
 been patented—but not by their inventors Allen Newell, Cliff Shaw, and Herbert 
 Simon when they came up with the idea back in 1955–6, but by someone else, 50 
 years later (
 www.google.com/patents/about?id=26aJAAAAEBAJ&dq= linked+list
 ). The 
 same thing has happened with skip lists, invented by William Pugh in 1990 and 
 patented over a decade later by someone else. Sadly, there are tens of thousands of 
 other software patents that could be cited as examples, al-though we will mention 
 just one more, “A system and method causes a computer to detect and perform 
 actions on structuresidentified in computer data” granted to Apple in 1999 and 
 which 
 covers 
 all 
 software 
 that 
 manipulates 
 data 
 structures 
 (
 www.google.com/patents?id=aFEWAAAAEBAJ&dq=5,946,647
 ).
  
 It is easy to imagine that overly broad, obvious, or otherwise meritless patents 
 would be easy to invalidate, but in practice, even giants like Google have found 
 themselves paying out millions of dollars in legal fees to defend themselves. How 
 then can startups and small and medium-sized enterprises (SMEs) hope to bring 
 innovative software to market without being shaken down—again and again—by 
 patent troll “businesses” which feed like parasites on the work of others?
  
 437",NA
C,NA,NA
Selected ,NA,NA
Bibliography,"Advanced Programming in the UNIX
 →
  Environment,Second Edition
  
 W. Richard Stevens and Stephen A. Rago (Addison-Wesley, 2005, 
 ISBN-13: 978-0-201-43307-4)
  
 A thorough in-depth introduction to Unix programming using the Unix system 
 call APIs and the standard C library. (The book’s examples are in C.)
  
 The Art of Multiprocessor Programming
  
 Maurice Herlihy and Nir Shavit (Morgan Kaufmann, 2008, ISBN-
 13: 978-0-12-370591-4)
  
 This book providesa thorough introduction to mostly low-level multithread-ed 
 programming, including small but complete working examples (in Java) that 
 demonstrate all the key techniques.
  
 Clean Code: A Handbook of Agile Software Craftsmanship
  
 Robert C. Martin (Prentice Hall, 2009, ISBN-13: 978-0-13-235088-4)
  
 This book addresses many of the “tactical” issues in programming: good 
 naming, function design, refactoring, and similar. The book has many 
 interesting and useful ideas that should help any programmer improve their 
 coding style and make their programsmore maintainable. (The book’s examples 
 are in Java.)
  
 Code Complete: A Practical Handbook of Software Construction,Second Edition 
  
 Steve McConnell (Microsoft Press, 2004, ISBN-13: 978-0-7356-1967-8)
  
 This book shows how to build solid software, going beyond the language 
 specifics into the realms of ideas, principles, and practices. The book is packed 
 with ideas that will make any programmer think more deeply about their 
 programming.
  
 Design Patterns: Elements of Reusable Object-Oriented Software
  
 Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-
 Wesley, 1995, ISBN-13: 978-0-201-63361-0)
  
 One of the most influential programming books of modern times, even if it isn’t 
 always easy to read. The design patterns are fascinating and of great practical 
 use in everyday programming.
  
 441",NA
Index,NA,NA
Symbols & Numbers,"!
  logical
  NOT
  operator, 57 
  
 !=
  inequality operator, 56–57, 68–69, 
  
 70, 164 
  
 "" ""
  double quotes, 83 
  
 #!
  shebang scripts, 10 
  
 $
  replacements in regular expres-
  
 sions, 120, 126, 129 
  
 %
  modulus operator and formatting 
  
 placeholder, 47, 60, 69;
  see also 
  
 format specifier 
  
 %=
  augmented modulus operator, 60 
 &
  
 address of and bitwise
  AND
  opera-
  
 tor, 45, 46, 55, 60, 142, 143, 144, 
  
 167, 246, 247, 248, 267, 269, 284, 
  
 382, 383, 384, 387, 393, 394, 395 
 &&
  logical
  AND
  operator, 56, 57 
  
 &=
  augmented bitwise
  AND
  operator, 
  
 60 
  
 &^
  bitwise clear operator, 60 
  
 &^=
  augmented bitwise clear opera-
  
 tor, 60 
  
 *
 multiplication, dereference, point-
  
 er 
 declaration operator and for-
  
 matting 
 placeholder, 26, 59, 69, 
  
 96, 100, 
 142, 143, 144, 178, 247, 
  
 248, 249, 
 259, 284, 305, 370, 382, 
  
 394 
  
 *=
  augmented multiplication opera-
  
 tor, 59, 147 
  
 +
  addition, concatenation, and unary 
  
 plus operator, 20, 59, 84, 85, 226 
 ++
  increment operator, 20, 59, 186, 
  
 188 
  
 +=
  augmented addition and string 
  
 append operator, 20, 59, 84, 85, 
  
 88, 140;
  see also
  append()
  
 -
  subtraction and unary minus oper-
  
 ator, 59
  
 --
  decrement operator, 20, 59, 186, 
  
 188
  
 -=
  augmented subtraction operator, 
  
 59 
  
 .
  selector operator, 148, 275 
  
 ...
  ellipsis operator, 149, 156, 158, 
  
 160, 176, 219, 221, 222, 233, 242, 
  
 268, 287, 378 
  
 /
  division operator, 59 
  
 /* */
  multiline comments, 14, 51 
 //
  
 single-line comments, 14, 51 
  
 /=
  augmented division operator, 59 
 :=
  
 short variable declaration opera-
  
 tor, 15, 18, 36, 53, 188, 189, 198, 
  
 203 
  
 ;
  semicolon, 15, 186 
  
 <
  less than comparison operator, 
  
  
 56–57 
  
 <-
  send/receive communication oper-
  
 ator, 44, 45, 207, 210, 318–357 
 <<
  
 bitwise shift left operator, 55, 60
  
 <<=
  augmented bitwise shift left op-
  
 erator, 60 
  
 <=
  less than or equal comparison op-
  
 erator, 56–57 
  
 =
  assignment operator, 16, 18, 36, 
  
 188, 212 
  
 ==
  equality operator, 56–57, 68–69, 
  
 70, 164 
  
 >
  greater than comparison operator, 
  
 56–57 
  
 >=
  greater than or equal comparison 
  
 operator, 56–57
  
 >>
  bitwise right shift operator, 60
  
 >>=
  augmented bitwise right shift 
  
 operator, 60
  
 []
  index and slice operator,16,28,85, 
  
 91, 203, 242, 339, 355, 357, 393
  
 443",NA
A,"Abs() 
  
 cmplx
  package, 71 
  
 math
  package, 65, 68 
  
 abstract vs. concrete types, 22 
  
 abstraction and abstract types;
  see 
  
  
 interfaces 
  
 access operator;
  see
  []
  index oper-
  
  
 ator 
  
 access, serialized, 318–319, 335, 341 
 accessing
  map
 s, 39, 168–169, 231 
  
 accuracy, floating-point, 64
  
 Acos() 
  
 cmplx
  package, 71 
 math
  package, 65
  
 Acosh() 
  
  
 cmplx
  package, 71 
  
  
 math
  package, 65 
  
 Add() 
  
  
 Int
  type, 63 
  
  
 WaitGroup
  type, 350, 351, 352, 354 
 address;
  see
  pointers 
  
 After()
  (
 time
  package), 332, 333, 426 
 aggregation, 254–256, 275–282;
  see 
  
  
 also
  embedding 
  
 alert or bell (
 \a
 ), 84 
  
 aliasing, package names, 409, 418 
 americanise
  (example), 29–40 
  
 and, logical;
  see
  &&
  operator 
  
 anonymous fields,
  struct
  keyword 
 anonymous functions, 36, 37, 110, 
  
  
 112, 206, 208, 212, 216, 218, 225, 
  
  
 226, 239, 240, 243, 290 
  
 anonymous
  struct
 , 275 
  
 apachereport
  (example), 341–349 
  
 API (Application Programming In-
  
  
 terface);
  see
  interfaces 
  
 App Engine, Google, 2, 435 
  
 append()
  (built-in),25, 27, 55, 77, 129, 
  
  
 132, 150,151,156–157,158,159, 
  
  
 160, 170, 176, 178, 179, 187, 232, 
  
  
 240, 247, 249, 272, 355, 374, 382, 
  
  
 392, 410;
  see also
  += 
  
 AppendBool()
  (
 strconv
  package), 114 
 AppendFloat()
  (
 strconv
  package), 114 
 AppendInt()
  (
 strconv
  package), 114 
 AppendQuote()
  (
 strconv
  package), 114 
 AppendQuoteRune()
  (
 strconv
  package), 
  
  
 114 
  
 AppendQuoteRuneToASCII()
  (
 strconv 
  
  
 package), 114 
  
 AppendUInt()
  (
 strconv
  package), 114 
 archive files;
  see
  .tar
  files and
  .zip 
  
  
 files 
  
 archive
  (package) 
  
  
 tar
  (package);
  see
  top-level entry 
  
 zip
  (package);
  see
  top-level entry 
 archive_file_list
  (exercise), 250",NA
B,"backslash (
 \
 ), 84 
  
 backreferences, in regular expres-
  
 sions, 126
  
 backspace (
 \b
 ), 84 
  
 backticks (
 ` `
 ), 75, 96 
  
 backtracking,in regular expressions, 
  
  
 120 
  
 balanced binary tree;
  see
  omap
  exam-
  
  
 ple 
  
 bare returns, 34, 189, 219 
  
 Base()
  (
 filepath
  package), 19, 
  
  
  
 131–132, 194, 327 
  
 benchmarking, 415–416 
  
 big
  (package;
  math
  package) 
  
  
 Int
  (type);
  see
  top-level entry 
  
  
 NewInt()
 , 63 
  
  
 ProbablyPrime()
 , 425 
  
  
 Rat
  (type);
  see
  top-level entry 
  
 big-O notation, 89 
  
 bigdigits
  (example), 16–21, 48 
  
 bigdigits
  (exercise), 48 
  
 BigEndian
  (variable;
  binary
  package), 
  
  
 389 
  
 binary files, 387–397;
  see also
  .gob 
  
  
 files 
  
 binary number, formatting as, 98 
 binary
  (package;
  encoding
  package), 
  
  
 388, 391 
  
  
 BigEndian
  (variable), 389 
  
  
 LittleEndian
  (variable), 388, 389 
  
 Read()
 , 391, 393, 395 
  
  
 Write()
 , 388 
  
 binary tree;
  see
  omap
  example 
  
 binary vs. linear search, 162–163 
 bisectLeft()
  (example), 314 
  
 blank identifier (
 _
 ), 36, 52–53, 154, 
  
  
 170, 188, 291, 358, 417;
  see also 
  
  
 identifiers 
  
 blocking, channel, 207–208, 209;
  see 
  
  
 also
  channels 
  
 bool
  (type; built-in), 53, 56–57, 195, 
  
  
 204, 318 
  
  
 formatting, 97 
  
 Bool()
  (
 Value
  type), 428 
  
 Boolean expressions, 193, 204 
  
 braces (
 { }
 ), 15, 186",NA
C,"C code, external, 9 
  
 Call()
  (
 Value
  type), 429, 430 
  
 Caller()
  (
 runtime
  package), 291 
  
 calling functions, 220–221;
  see also 
  
 functions 
  
 CanBackquote()
  (
 strconv
  package), 
  
 114 
  
 CanSet()
  (
 Value
  type), 428 
  
 cap()
  (built-in), 24, 149, 151, 152, 
  
 157, 187, 324 
  
 carriage return (
 \r
 ), 84 
  
 case
  (keyword);
  see
  select
  and
  switch 
  
 statements 
  
 Cbrt()
  (
 math
  package), 65 
  
 Ceil()
  (
 math
  package), 65 
  
 cgo
  (tool), 9 
  
 cgrep
  (example), 326–334 
  
 chan
  (keyword), 43, 44, 208, 209, 210, 
  
 318–357;
  see also
  channels",NA
D,"Dashboard, Go, 2 
  
 data structures, slices,
  map
  type, and 
  
  
 struct 
  
 database
  (package) 
  
 sql
  (package), 423 
  
 deadlock, 317–318, 340 
  
 debugging, 55, 103–106 
  
 decimal number, formatting as, 99; 
  
  
 see also
  int
  type 
  
 declarations, order of, 21 
  
 Decode() 
  
 gob
  package 
  
  
   
 Decoder
  type, 387 
  
 json
  package 
  
  
   
 Decoder
  type, 369, 370 
  
 xml
  package 
  
  
   
 Decoder
  type, 375, 377 
  
 DecodeConfig()
  (
 image
  package), 358 
 DecodeLastRune()
  (
 utf8
  package), 118 
 DecodeLastRuneInString()
  (
 utf8
  pack-
  
  
 age), 91, 118, 229, 230 
  
 Decoder
  (type) 
  
 gob
  package 
  
  
   
 Decode()
 , 387 
  
 json
  package), 369 
  
  
   
 Decode()
 , 369, 370 
  
 xml
  package 
  
  
   
 Decode()
 , 375, 377 
  
 DecodeRune()
  (
 utf8
  package), 118 
  
 DecodeRuneInString()
  (
 utf8
  package), 
  
  
 91, 92, 93, 118, 203, 229, 230 
 DeepEqual()
  (
 reflect
  package), 57, 
  
  
 236, 427 
  
 default
  (keyword);
  see
  select
  and 
  
  
 switch
  statements
  
 defer
  (statement), 31–32, 35, 36, 44, 
  
  
 97, 176, 211–213, 216, 218, 333, 
  
  
 343, 353, 378, 398, 400 
  
 defining methods, 25 
  
 definitions, order of, 21 
  
 delegation;
  see
  embedding 
  
 delete()
  (built-in), 165, 169, 187, 
  
  
 339 
  
 dereferencing pointers;
  see
  pointers 
 dictionary;
  see
  map
  type 
  
 Dim()
  (
 math
  package), 65 
  
 Div()
  (
 Int
  type), 63 
  
 division by zero, 68 
  
 documentation, Go, 8 
  
 documentation, package, 411–413 
 domain name resolution;
  see
  net 
  
  
  
 package 
  
 Done()
  (
 WaitGroup
  type), 350, 352, 
  
  
 354 
  
 double quotes (
 "" ""
 ), 83 
  
 doubly linked list;
  see
  list
  package 
 downloading Go, 9 
  
 downsizing;
  see
  conversions 
  
 Draw()
  (
 draw
  package), 290 
  
 draw
  (package;
  image
  package) 
  
  
 Draw()
 , 290 
  
  
 Image
  (interface), 290, 293, 319 
 duck typing, 21, 32, 254–255, 268 
 Duration
  (type;
  time
  package), 332, 
  
  
 333",NA
E,"E
  (constant;
  math
  package), 65, 104, 
  
 105 
  
 Elem()
  (
 Value
  type), 429 
  
 else
  (keyword);
  see
  if
  statement 
 embedding, 254–256, 261, 270–274, 
  
 275–282, 294, 300;
  see also
  ag-
  
 gregation 
  
 empty interface;
  see
  interface{} 
  
 empty
  struct
 , 328",NA
F,"factory function, 226, 291, 298 
  
 fallthrough
  (statement), 186, 195, 
  
 196–197 
  
 false
  (built-in);
  see
  bool
  type 
  
 fast compilation, 2 
  
 fast
  string
  concatenation, 88 
  
 Fatal()
  (
 log
  package), 19, 20, 32, 
  
 131–132, 342 
  
 Fatalf()
  (
 log
  package), 20, 327 
  
 FieldByName()
  (
 Value
  type), 428 
  
 fields;
  see
  struct
  keyword 
  
 Fields()
  (
 strings
  package), 38, 39, 
  
 76, 77, 107–110, 108, 111 
  
 FieldsFunc()
  (
 strings
  package), 108, 
  
 178",NA
G,"Gamma()
  (
 math
  package), 66 
  
 garbage collector, 3, 32, 40, 139, 141 
 gc
  (tool), 9 
  
 gccgo
  (tool), 9 
  
 generic functions, 232–238;
  see also 
  
 higher order functions 
  
 Gerrand, Andrew, 2, 207
  
 Getgid()
  (
 os
  package), 401 
  
 getters, 264–265 
  
 Getuid()
  (
 os
  package), 401 
  
 GID;
  see
  Getgid() 
  
 Glob()
  (
 filepath
  package), 176, 410 
 globbing, file, 176, 410–411
  
 Go
  
 building programs, 11–13
  
  
 comments, 14, 51 
  
  
 Dashboard, 2 
  
  
 documentation, 8 
  
  
 downloading, 9 
  
  
 history of, 1 
  
  
 identifiers, 9, 42, 52–53, 58;
  see 
  
  
 also
  blank identifier 
  
  
 installing, 9, 10–11 
  
  
 shebang (
 #!
 ) scripts, 10 
  
  
 source code encoding, 9 
  
  
 specification, 69 
  
 go build
  (tool), 11–12, 23, 409, 411 
 .go
  
 files, 84, 408, 410 
  
 go fix
  (tool), 418 
  
 go get
  (tool), 417–418 
  
 go install
  (tool), 1, 13, 409 
  
 go
  (statement), 45, 206, 208, 209, 
  
  
 211, 224, 320–357;
  see also
  gor-
  
  
 outines 
  
 go test
  (tool), 415–416 
  
 go version
  (tool), 11 
  
 go vet
  (tool), 418 
  
 GOARCH
  (constant;
  runtime
  package), 
  
  
 410, 424 
  
 .gob
  files, 385–387 
  
 gob
  (package;
  encoding
  package), 385 
  
 GobDecoder
  (interface), 386 
  
  
 GobEncoder
  (interface), 386 
  
  
 NewDecoder()
 , 386 
  
  
 NewEncoder()
 , 385 
  
 godashboard.appspot.com
  (web site), 
  
  
 407, 417, 423, 426 
  
 godoc
  (tool), 8, 411–413, 419 
  
 gofmt
  (tool), 186, 188, 419 
  
 golang.org
  (web site), 8, 436",NA
H,"HandleFunc()
  (
 http
  package), 75, 218 
 handling errors, 24, 32, 213 
  
 hash table;
  see
  map
  type 
  
 HasPrefix()
  (
 strings
  package), 108, 
  
 132, 
 194, 246, 260, 382 
  
 HasSuffix()
  (
 strings
  package), 108, 
  
 131–132, 226, 400, 403 
  
 Header
  (constant;
  xml
  package), 373 
 Header
  (type;
  tar
  package), 401, 404 
 heap
  (package;
  container
  package), 
  
 421–422
  
 hello
  (example), 14–16 
  
 hexadecimal number, formatting as, 
  
  
 98, 102 
  
 higher order functions, 37, 38, 
  
  
  
 238–244, 257 
  
 history, of Go, 1 
  
 Hoare, C. A. R, 3 
  
 html
  (package) 
  
  
 EscapeString()
 , 78 
  
  
 template
  (package),
  see
  top-level 
  
  
 entry 
  
 HTMLEscape()
  (
 template
  package), 78 
 http
  (package;
  net
  package) 
  
  
 HandleFunc()
 , 75, 218 
  
  
 ListenAndServe()
 , 75 
  
  
 Request
  (type);
  see
  top-level entry 
  
 ResponseWriter
  (interface), 76 
  
 Humanize()
  (example), 100 
  
 Hyphen
  (constant;
  unicode
  package), 
  
  
 272 
  
 Hypot()
  (
 math
  package), 66, 304",NA
I,"identifiers, Go, 9, 42, 52–53, 58;
  see 
  
  
 also
  blank identifier 
  
 IEEE-754 floating-point format, 64 
 if
  
 (statement), 15, 189, 192–194, 
  
  
 220;
  see also
  switch
  statement 
 Ilogb()
  (
 math
  package), 66 
  
 imag()
  (built-in), 70, 101, 187 
  
 Image
  (interface) 
  
  
 draw
  package, 290, 293, 319 
  
  
 image
  package, 289, 293, 319 
  
 image
  (package), 289, 425 
  
  
 DecodeConfig()
 , 358 
  
  
 draw
  (package), 290 
  
  
 Image
  (interface), 289, 293, 319 
  
 jpeg
  (package), 293 
  
  
 NewRGBA()
 , 290, 319 
  
  
 png
  (package), 293 
  
  
 RGBA
  (type), 290 
  
  
 Uniform()
 , 290",NA
J,"J0()
  (
 math
  package), 66 
  
 J1()
  (
 math
  package), 66 
  
 JavaScript Object Notation;
  see 
  
  
 JSON 
  
 Jn()
  (
 math
  package), 66 
  
 Join()
  (
 strings
  package), 14, 16, 55, 
  
 108, 111, 180, 414 
  
 .jpeg
  and
  .jpg
  files, 293 
  
 jpeg
  (package;
  image
  package), 293 
 JSON (JavaScript Object Notation), 
  
 199–202, 363, 365–371 
  
 json
  (package;
  encoding
  package), 
  
 202, 366",NA
K,"keywords, 52
  
 case
 ;
  see
  select
  and
  switch
  state-
  
 ments 
  
 chan
 , 43, 44, 208, 209, 210, 
  
  
 318–357;
  see also
  channels 
 const
 , 45, 53, 58, 133, 336, 364, 
  
 379, 390 
  
 default
 ;
  see
  select
  and
  switch 
  
  
 statements 
  
 else
 ;
  see
  if
  statement 
  
 func
 , 14, 15, 25, 35, 45, 55, 208, 
  
 216, 218, 219, 223, 226, 232, 
  
 238, 240, 241, 243, 246, 291, 
  
 303, 305, 323, 324, 343, 378, 
  
 379, 388, 389, 413 
  
 interface
 , 220, 237, 265–274,294, 
  
 295, 335, 364 
  
 iota
 , 54, 336 
  
 nil
 , 27, 216, 257, 305 
  
 range
 , 19, 38, 39, 74, 89, 110, 147, 
  
 154, 155, 168, 170, 172, 200, 
  
 203–205, 324, 325, 330, 331, 
  
 339, 343, 355, 390 
  
 struct
 , 42, 73, 96, 104, 132, 167, 
  
 199, 202, 222, 223, 233, 237, 
  
 241, 245, 255, 259–260, 
  
  
 261–262, 275–282, 284, 285, 
  
 305, 308, 326, 328, 330, 335, 
  
 337, 343, 350, 354, 362, 366, 
  
 372, 387
  
  
 type
 , 24, 42, 55, 73, 132, 198–199, 
  
 202, 223, 245, 246, 254, 255, 
  
 256–257, 265, 284, 294, 295, 
  
 305, 335, 366, 379, 389, 412 
  
 var
 , 23, 53, 188, 192, 201, 241, 
  
 257, 272, 378, 382, 388 
  
  
 see also
  statements 
  
 Kind
  (type;
  reflect
  package), 430 
  
 Kind()
  (
 Value
  type), 235",NA
L,"label, 205, 331 
  
 LastIndex()
  (
 strings
  package), 92, 
  
  
 108, 194 
  
 LastIndexAny()
  (
 strings
  package), 
  
  
 108 
  
 LastIndexFunc()
  (
 strings
  package), 
  
  
 92, 108 
  
 Ldexp()
  (
 math
  package), 66 
  
 left-justification, of output, 96, 98 left-
 leaning red-black tree;
  see
  omap 
  
  
 example 
  
 len()
  (built-in), 15, 20, 24, 27, 69, 85, 
  
  
 90, 148, 149, 151, 152, 157, 159, 
  
  
 165, 169, 187, 340 
  
 Len()
  (
 reflect
  package), 235, 430 
  
 Lgamma()
  (
 math
  package), 66 
  
 library types;
  see
  standard library’s 
  
  
 types 
  
 linear vs. binary search, 162–163 
 linefeed;
  see
  newline 
  
 linkcheck
  (exercise), 432 
  
 linkutil
  (exercise), 431–432 
  
 list
  (package;
  container
  package), 
  
  
 422–423 
  
 ListenAndServe()
  (
 http
  package), 75 
 LiteralPrefix()
  (
 Regexp
  type), 125 
 literals, 58 
  
  
 character, 20 
  
  
 complex, 53, 70 
  
  
 composite, 18, 45, 150, 152, 153,
  
 166, 167",NA
M,".m3u
  files, 130–135 
  
 m3u2pls
  (example), 130–135 
  
 main
  (package), 14, 15, 206, 224
  
 main()
  (special function), 14, 15, 206, 
  
  
 214, 215, 224–225, 327 
  
 make()
  (built-in), 26, 38, 39, 43, 44, 
  
  
 127, 129, 150, 151, 152, 157, 159, 
  
  
 165, 172, 176, 178, 179, 187, 207, 
  
  
 208, 209, 211, 240, 242, 246, 247, 
  
  
 323, 324, 328, 337, 339, 341, 346, 
  
  
 348, 355, 374, 392, 393, 395, 410 
 Make2D()
  (exercise), 181 
  
 Map()
  (
 strings
  package), 108, 
  
  
  
 111–112, 132, 133, 258 
  
 map
  to
  .ini
  file (exercise), 182 
  
 map
  (type; built-in), 38, 39, 77, 127, 
  
  
 146, 164–171, 175–180, 199, 
  
  
  
 242, 243, 298, 318, 335, 339, 345, 
  
  
 346, 348, 355, 356 
  
  
 accessing, 39, 168–169, 231 
  
  
 formatting, 106 
  
  
 inversion, 170–171, 179 
  
  
 iterating, 170, 203 
  
  
 modifying, 169 
  
  
 multivalued, 175 
  
  
 operations, 165 
  
  
 see also
  omap
  example 
  
 Marshal()
  (
 json
  package), 368, 370 
 Match() 
  
  
 regexp
  package, 121 
  
  
 Regexp
  type, 125, 333, 334 
  
 MatchReader() 
  
  
 regexp
  package, 121 
  
  
 Regexp
  type, 125 
  
 MatchString() 
  
  
 regexp
  package, 121 
  
  
 Regexp
  type, 125 
  
 math
  (package), 69 
  
  
 Abs()
 , 65, 68 
  
  
 Acos()
 , 65 
  
  
 Acosh()
 , 65 
  
  
 Asin()
 , 65 
  
  
 Asinh()
 , 65 
  
  
 Atan()
 , 65 
  
  
 Atan2()
 , 65 
  
  
 Atanh()
 , 65",NA
N,"Name
  (type;
  xml
  package), 372, 374 
 named fields;
  see
  struct
  keyword
  
 named replacements in regular ex-
  
  
 pressions, 126 
  
 named return values, 36, 189, 212, 
  
  
 219, 221, 309 
  
 named vs. unnamed custom types, 
  
  
 22 
  
 NaN() 
  
  
 cmplx
  package, 71 
  
  
 math
  package, 67 
  
 net
  (package), 427 
  
  
 http
  (package),
  see
  top-level en-
  
  
 try 
  
  
 rpc
  (package), 427 
  
  
 smtp
  (package), 427 
  
  
 url
  (package), 427 
  
 New() 
  
  
 errors
  package, 27, 33, 194, 384 
  
 sha1
  package, 353, 354 
  
 new()
  (built-in), 145, 146, 152, 187, 
  
  
 346 
  
 NewDecoder() 
  
  
 gob
  package, 386 
  
  
 json
  package, 369 
  
  
 xml
  package, 375 
  
 NewEncoder() 
  
  
 gob
  package, 385 
  
  
 json
  package, 367 
  
  
 xml
  package, 373 
  
 NewInt()
  (
 big
  package), 63 
  
 newline (
 \n
 ), 51, 84 
  
 NewReader() 
  
  
 bufio
  package, 35, 45, 176, 333, 
  
  
 380 
  
  
 gzip
  package, 403 
  
  
 strings
  package, 108 
  
  
 tar
  package, 403 
  
 NewReplacer()
  (
 strings
  package), 108 
 NewRGBA()
  (
 image
  package), 290, 319 
 NewTicker()
  (
 time
  package), 426 
  
 NewWriter() 
  
  
 bufio
  package, 35, 378 
  
  
 gzip
  package, 400 
  
  
 tar
  package, 400",NA
O,"O_RDWR
  (constant;
  os
  package), 397 
 objects;
  see
  values 
  
 octal number, formatting as, 98 
  
 Ogg container, 130 
  
 omap
  (example), 302–310, 409, 
  
  
  
 412–413, 414–416 
  
 Open()
  (
 File
  type), 31, 176, 212, 333, 
  
  
 342, 353, 398, 400 
  
 OpenFile()
  (
 File
  type), 31, 397 
  
 OpenReader()
  (
 zip
  package), 401, 402 
 operations on
  map
 s, 165 
  
 operations on slices, 151 
  
 operators 
  
 !
  logical
  NOT
 , 57 
  
 !=
  inequality, 56–57, 68–69, 70, 
  
  
  
 164 
  
 %
  modulus and formatting place-
  
  
  
 holder, 47, 60, 69;
  see also
  for-
  
   
 mat specifier 
  
 %=
  augmented modulus, 60
  
 &
  address of and bitwise
  AND
 , 45, 
 46, 55, 60, 142, 143, 144, 167, 246, 
 247, 248, 267, 269, 284, 382, 383, 
 384, 387, 393, 394, 395 
  
 &&
  logical
  AND
 , 56, 57
  
 &=
  augmented bitwise
  AND
 , 60 
 &^
  
 bitwise clear, 60 
  
 &^=
  augmented bitwise clear, 60
  
 *
 multiplication, dereference, 
  
 pointer declaration and for-
 matting placeholder, 26, 59, 69, 96, 
 100, 142, 143, 144, 178, 247, 248, 
 249, 259, 284, 305, 370, 382, 394 
  
 *=
  augmented multiplication, 59, 
 147 
  
 +
  addition, concatenation, and 
 unary plus, 20, 59, 85, 226
  
 ++
  increment, 20, 59, 186, 188 
  
 +=
  augmented addition and 
  
 string append, 20, 59, 84, 85, 88, 
 140
  
 -
  subtraction and unary minus, 59
  
 --
  decrement, 20, 59, 186, 188
  
 -=
  augmented subtraction, 59
  
 .
  selector, 148, 275 
  
 ...
  ellipsis, 149, 156, 158, 160, 176, 
 219, 221, 222, 233, 242, 268, 287, 
 378 
  
 /
  division, 59 
  
 /=
  augmented division, 59
  
 :=
  short variable declaration, 15, 
 18, 36, 53, 140, 188, 189, 198, 203 
  
 <
  less than comparison, 56–57 
 <-
  
 send/receive communication, 44, 
 45, 207, 210, 318–357
  
 <<
  bitwise shift left, 55, 60 
  
 <<=
  augmented bitwise shift left, 
 60 
  
 <=
  less than or equal comparison, 
 56–57",NA
P,"pack
  (example), 397–405 
  
 package, 14, 215–216, 407–431
  
 aliasing names, 409, 418
  
 collection, 421–423;
  see also
  con-
 tainer
  package 
  
 custom, 24–29, 408–417 
  
 documenting, 411–413 
  
 main
 , 14, 15 
  
 third-party, 417–418
  
 variables, 18 
  
 see also
  bufio
 ,
  bytes
 ,
  cmplx
 ,
  con-
 tainer
 ,
  crypto
 ,
  draw
 ,
  encoding
 , 
 errors
 ,
  
 filepath
 ,
  fmt
 ,
  http
 ,
  im-age
 ,
  io
 ,
  ioutil
 ,
  
 json
 ,
  math
 ,
  net
 , 
 os
 ,
  rand
 ,
  regexp
 ,
  
 reflect
 ,
  run-time
 ,
  sha1
 ,
  sort
 ,
  strings
 ,
  
 sync
 , and
  time
  packages
  
 package
  (statement), 408, 412
  
 Pad()
  (example), 99
  
 padding, of output, 96, 98
  
 palindrome
  (example), 232
  
 panic()
  (built-in), 32, 69, 70, 113, 
  
  
 187, 191,196,213–218,219,220, 
  
 243 
  
 parameters, 22, 141–142, 220–223, 
  
 254–255 
  
 Parse()
  (
 time
  package), 370, 376, 377, 
  
 383, 395
  
 ParseBool()
  (
 strconv
  package), 98, 
  
 115, 116
  
 ParseFloat()
  (
 strconv
  package), 77, 
  
 115, 116
  
 ParseForm()
  (
 Request
  type), 76
  
 Stderr
  (stream), 20, 32, 46",NA
Q,"quadratic
  (exercise), 79 
  
 quantifiers in regular expressions, 
  
 123 
  
 Quote()
  (
 strconv
  package), 115, 117 
 QuoteMeta()
  (
 regexp
  package), 121, 
  
 128 
  
 QuoteRune()
  (
 strconv
  package), 115 
 QuoteRuneToASCII()
  (
 strconv
  pack-
  
 age), 115 
  
 quotes;
 see
  "" ""
  double quotes and raw 
  
 strings",NA
R,"rand
  (package) 
  
  
 crypto
  package, 426 
  
  
 math
  package, 426 
  
  
  
 Intn()
 , 209, 426 
  
 range
  (keyword), 19, 38, 39, 74, 89, 
  
  
 110, 147, 154, 155, 168, 170, 172, 
  
  
 200, 203–205,324,325,330,331, 
  
  
 339, 343, 355, 390 
  
 Rat
  (type;
  big
  package), 57, 61 
  
 rationals;
  see
  Rat
  type 
  
 raw string (
 ` `
 ), 75, 96 
  
 RE2 regular expression engine;
  see 
  
  
 regexp
  package 
  
 Read()
  (
 binary
  package), 391, 393, 
  
  
 395 
  
 ReadAll()
  (
 ioutil
  package), 424 
  
 ReadAt()
  (
 File
  type), 397",NA
S,"safemap
  (example), 334–340 
  
 safeslice
  (exercise), 357–358 
  
 Scan()
  (
 fmt
  package), 383 
  
 Scanf()
  (
 fmt
  package), 383 
  
 Scanln()
  (
 fmt
  package), 383 
  
 scientific notation, 64, 101 
  
 scope, 141, 225, 239, 240 
  
 scoping problem;
  see
  shadow vari-
  
 ables 
  
 Search()
  (
 sort
  package), 161, 163 
 SearchFloat64s()
  (
 sort
  package), 161 
 searching, slices, 162–164 
  
 searching,
  string
 s, 87 
  
 SearchInts()
  (
 sort
  package), 161 
  
 SearchStrings()
  (
 sort
  package), 161 
 Seek()
  (
 File
  type), 397 
  
 select
  (statement), 209–212, 321, 
  
 331, 
 333 
  
 self;
  see
  receiver 
  
 semicolon (
 ;
 ), 15, 186
  
 send,channel;
 see
 channels,
 <-
  opera-
  
  
 tor, and
  chan
  keyword 
  
 Separator
  (constant;
  filepath
  pack-
  
  
 age), 134, 135 
  
 serialized access, 318–319, 335, 341 
 SetFlags()
  (
 log
  package), 426 
  
 SetInt()
  (
 Value
  type), 429 
  
 SetOutput()
  (
 log
  package), 426 
  
 SetString()
  (
 Value
  type), 428 
  
 setters, 264–265 
  
 SHA-1 (Secure Hash Algorithm), 
  
  
 349, 354–53 
  
 sha1
  (package;
  crypto
  package) 
  
  
 New()
 , 353, 354 
  
  
 Size
  (constant), 355 
  
 shadow variables, 36, 189, 192, 200, 
  
  
 201, 281, 282, 300, 301 
  
 shaper
  (example), 289–301 
  
 shaper
  (exercise), 311–313 
  
 shebang (
 #!
 ) scripts, 10 
  
 short circuit logic, 56 
  
 short variable declaration, 15, 53, 
  
  
 140, 188 
  
 Signbit()
  (
 math
  package), 67 
  
 Simple Mail Transport Protocol 
  
  
  
 (SMTP), 427 
  
 simple statement, 193, 195, 203 
  
 SimpleFold()
  (
 unicode
  package), 119 
 simplification, of whitespace, 111, 
  
  
 128–129 
  
 SimplifyWhitespace()
  (example), 111 
 Sin() 
  
  
 cmplx
  package, 71 
  
  
 math
  package, 45, 67 
  
 SinCos()
  (
 math
  package), 67 
  
 Sinh() 
  
  
 cmplx
  package, 71 
  
  
 math
  package, 67 
  
 Size
  (constant;
  sha1
  package), 355 
 Size()
  (
 FileInfo
  interface), 351, 353, 
  
  
 401 
  
 sizeimages
  (exercise), 359",NA
T,"tab (
 \t
 ), 84 
  
 tags,
  struct
 , 279, 371, 372, 428 
  
 Tan() 
  
 cmplx
  package, 71 
  
 math
  package, 67 
  
 Tanh() 
  
 cmplx
  package, 71 
  
 math
  package, 67 
  
 .tar
  files, 399–401, 403–405 
  
 tar
  (package;
  archive
  package), 
  
  
  
 399–401, 403–405 
  
 Header
  (type), 401, 404 
  
 NewReader()
 , 403 
  
 NewWriter()
 , 400 
  
 Reader
  (type), 403, 405 
  
 Writer
  (type);
  see
  top-level entry 
 Taylor, Ian Lance, 2 
  
 TCP/IP;
  see
  net
  package 
  
 TempFile()
  (
 ioutil
  package), 424 
  
 template
  (package;
  html
  package), 
  
  
 420–421 
  
 template
  (package;
  text
  package), 
  
  
 420–421 
  
 HTMLEscape()
 , 78 
  
 terminal;
  see
  Stderr
 ,
  Stdin
 , and
  Std-
  
  
 out
  streams 
  
 Terminal_Punctuation
  (constant;
  uni-
  
  
 code
  package), 258 
  
 termination, 15, 317, 321 
  
 terminator, statement (
 ;
 ), 186 
  
 testing
  (package), 414–416
  
 text;
  see
  string
  type 
  
 text files;
  see
  .txt
  files 
  
 text
  (package) 
  
  
 template
  (package),
  see
  top-level 
  
  
 entry 
  
 third-party packages, 417–418 
  
 this;
  see
  receiver 
  
 Thompson, Ken, 1 
  
 threads;
  see
  channels, goroutines, 
  
  
 and the
  chan
  and
  go
  keywords 
 Tick()
  (
 time
  package), 426 
  
 time
  (package), 426 
  
  
 After()
 , 332, 333, 426 
  
  
 Duration
  (type), 332, 333 
  
  
 NewTicker()
 , 426 
  
  
 Parse()
 , 370, 376, 377, 383, 395 
  
 Tick()
 , 426 
  
  
 Time
  (type);
  see
  top-level entry 
  
 Unix()
 , 391 
  
 Time
  (type;
  time
  package), 362, 363, 
  
  
 368, 377, 383, 390, 394, 395, 426 
  
 Format()
 , 368, 379, 390 
  
  
 Unix()
 , 391 
  
 Title()
  (
 strings
  package), 109 
  
 To()
  (
 unicode
  package), 119
  
 ToLower() 
  
  
 strings
  package, 109, 162, 163, 
  
 177, 194, 246, 259, 293, 306, 
  
 324 
  
  
 unicode
  package, 119, 272 
  
 tools 
  
  
 5g
 ,
  6g
 ,
  8g
 , 9 
  
  
 5l
 ,
  6l
 ,
  8l
 , 9 
  
  
 cgo
 , 9 
  
  
 gc
 , 9 
  
  
 gccgo
 , 9 
  
  
 go build
 , 11–12, 23, 409, 411 
  
  
 go fix
 , 418 
  
  
 go get
 , 417–418 
  
  
 go install
 , 1, 13, 409 
  
  
 go test
 , 415–416 
  
  
 go version
 , 11 
  
  
 go vet
 , 418",NA
U,"UDP;
  see
  net
  package 
  
 UID;
  see
  Getuid() 
  
 uint
  (type; built-in), 60, 69 
  
 uint8
  (type; built-in);
  see
  byte
  type 
 uint16
  (type; built-in), 60, 388, 393 
 uint32
  (type; built-in), 60, 388, 393 
 uint64
  (type; built-in), 60 
  
 uintptr
  (type; built-in), 60 
  
 unbound methods (method expres-
  
  
 sions), 263 
  
 unchecked type assertion;
  see
  type 
  
  
 assertions 
  
 unexported identifiers, 52, 264 
  
 Unicode, 52, 82–84, 86–87 
  
  
 normalization, 86 
  
  
 U+FFFD
  replacement character, 85, 
  
  
 118 
  
  
 whitespace, 92 
  
 Unicode code point;
  see
  rune
  type 
  
 unicode
  (package), 118, 420 
  
  
 Hyphen
  (constant), 272 
  
  
 Is()
 , 118, 119, 258, 272 
  
  
 IsControl()
 , 119",NA
V,"Valid()
  (
 utf8
  package), 118 
  
 validation, 263–265 
  
 ValidString()
  (
 utf8
  package), 118 
 Value
  
 (type;
  reflect
  package), 235, 
  
  
 427–431 
  
  
 Bool()
 , 428 
  
  
 Call()
 , 429, 430 
  
  
 CanSet()
 , 428 
  
  
 Complex()
 , 428 
  
  
 Elem()
 , 429 
  
  
 FieldByName()
 , 428 
  
  
 Float()
 , 428 
  
  
 Index()
 , 235, 236, 428 
  
  
 Int()
 , 428, 430 
  
  
 Interface()
 , 235",NA
W,"Wait()
  (
 WaitGroup
  type), 317, 350, 
  
  
 354 
  
 WaitGroup
  (type;
  sync
  package), 317, 
  
  
 350 
  
 Add()
 , 350, 351, 352, 354 
  
 Done()
 , 350, 352, 354 
  
 Wait()
 , 317, 350, 354 
  
 Walk()
  (
 filepath
  package), 349, 352
  
 web applications, 2, 72, 79–80 
  
 web sites 
  
  
 endsoftpatents.org
 , 439 
  
  
 godashboard.appspot.com
 , 407, 
  
  
   
 417, 423, 426 
  
  
 golang.org
 , 8, 436 
  
  
 www.nosoftwarepatents.com
 , 439 
  
 www.qtrac.eu
 , 1 
  
 while loop;
  see
  for
  loop 
  
 whitespace, 92, 111, 128–129 
  
 wordfrequencies
  (example), 174–180 
 wrapper function, 218, 226 
  
 Write()
  (
 binary
  package), 388 
  
 WriteAt()
  (
 File
  type), 397 
  
 WriteCloser
  (interface;
  io
  package), 
  
  
 400 
  
 WriteFile()
  (
 ioutil
  package), 424 
 WriteHeader()
  (
 Writer
  type), 401 
  
 Writer
  (interface;
  io
  package), 32, 34, 
  
  
 35, 93, 255, 354, 364, 366, 373, 
  
  
 378, 385, 388, 399 
  
 Writer
  (type) 
  
  
 bufio
  package, 35, 38 
  
  
  
 Flush()
 , 35, 36, 378 
  
  
  
 WriteString()
 , 35, 37 
  
  
 gzip
  package, 400 
  
  
 tar
  package, 400 
  
  
  
 WriteHeader()
 , 401 
  
  
 zip
  package, 397, 398 
  
  
  
 CreateHeader()
 , 398, 399 
  
 WriteRune()
  (
 Buffer
  type), 111 
  
 WriteString() 
  
  
 Buffer
  type, 88, 111, 200, 243 
  
  
 Writer
  type, 35, 37 
  
 writing files;
  see
  File
  type and
  ioutil 
  
  
 package",NA
X,"XML format, 363, 371–377 
  
 xml
  (package;
  encoding
  package), 371, 
  
  
 372 
  
  
 Decoder
  (type);
  see
  top-level entry",NA
Y,"Y0()
  (
 math
  package), 67 
  
 Y1()
  (
 math
  package), 67 
  
 Yn()
  (
 math
  package), 67",NA
Z,"zero, division by, 68 
  
 zero value, 27, 33, 39, 53, 54, 149, 
  
  
  
 150, 152, 168, 173, 189, 191, 216, 
  
  
  
 222, 257, 263, 275, 308, 346, 383 
  
 zero-width assertions in regular ex-
  
  
  
 pressions, 122 
  
 .zip
  files, 397–399, 401–403 
  
 zip
  (package;
  archive
  package), 
  
  
  
 397–399, 401–403 
  
 FileHeader
  (type), 399 
  
 FileInfoHeader()
 , 398, 399 
  
 NewWriter()
 , 398 
  
 OpenReader()
 , 401, 402 
  
 ReadCloser
  (type), 401 
  
 Writer
  (type);
  see
  top-level entry 
  
 ZP
  (zero
  Point
 ;
  image
  package), 290",NA
