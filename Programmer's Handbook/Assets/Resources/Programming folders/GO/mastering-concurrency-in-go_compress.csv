Larger Text,Smaller Text,Symbol
Mastering Concurrency in Go,NA,NA
Discover and harness Go's powerful concurrency ,NA,NA
"features to develop and build fast, scalable network ",NA,NA
systems,NA,NA
Nathan Kozyra,BIRMINGHAM - MUMBAI,NA
Mastering Concurrency in Go,"Copyright © 2014 Packt Publishing
  
 All rights reserved. No part of this book may be reproduced, stored in a retrieval 
 system, or transmitted in any form or by any means, without the prior written 
 permission of the publisher, except in the case of brief quotations embedded in 
 critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of 
 the information presented. However, the information contained in this book is sold 
 without warranty, either express or implied. Neither the author nor Packt Publishing, 
 and its dealers and distributors will be held liable for any damages caused or alleged 
 to be caused directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this book by the appropriate use of capitals. 
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 First published: July 2014
  
 Production reference: 1160714
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham B3 2PB, UK.
  
 ISBN 978-1-78398-348-3
  
 www.packtpub.com
  
 Cover image by Pratyush Mohanta (
 tysoncinematics@gmail.com
 )",NA
Credits,"Author 
  
 Nathan Kozyra
  
 Reviewers 
  
 Jeremy R. Budnack 
  
 János Fehér 
  
 Aleksandar S. Sokolovski 
 Michele Della Torre 
  
 Commissioning Editor 
 Julian Ursell
  
 Acquisition Editor 
 Kevin Colaco
  
 Content Development Editor 
 Athira Laji
  
 Technical Editors 
  
 Pratik More 
  
 Pooja Nair 
  
 Shweta S. Pant 
  
 Rohit Kumar Singh
  
 Copy Editors 
  
 Roshni Banerjee 
  
 Sarang Chari 
  
 Janbal Dharmaraj 
  
 Sayanee Mukherjee 
 Karuna Narayanan 
 Laxmi Subramanian
  
 Project Coordinator 
 Danuta Jones
  
 Proofreaders 
  
 Simran Bhogal
  
 Ameesha Green
  
 Paul Hindle
  
 Indexers 
  
 Hemangini Bari
  
 Priya Subramani
  
 Graphics 
  
 Abhinash Sahu
  
 Production Coordinator 
 Conidon Miranda
  
 Cover Work 
  
 Conidon Miranda",NA
About the Author,"Nathan Kozyra
  has been programming both recreationally and professionally for 
 more than a decade now. His first experience came while writing games on his 
 grandfather's Commodore 64, and in the ensuing decades, he's crafted technological 
 solutions and applications in nearly every major language for a host of software and 
 media companies as a developer, advisor, creative technologist, and CTO. He is 
 currently the CTO of Pointslocal. A new-language enthusiast and C++ stalwart, his 
 attention was quickly captured by Google's Go language, both for the language's 
 creators and ethos as well as its apparent post-C approach to systems languages. 
 Having dived in quickly, Go is now his go-to language for fast, concurrent applications.
  
 This book is dedicated to Mary and Ethan.",NA
About the Reviewers,"Jeremy R. Budnack
  is a software engineer and consultant from Buffalo, NY. 
  
 His career includes almost 15 years of experience in software development and systems 
 administration, spanning many diverse technology stacks and programming languages 
 (including C#, Ruby, and Go). He currently works for Stark & Wayne, LLC., specializing in 
 building cloud-based solutions using a variety of technologies including Cloud Foundry, 
 BOSH, OpenStack, and vSphere.
  
 János Fehér
  has been involved in a wide variety of projects since 1996, including 
 technical support for NATO operations and development of high-performance 
 computing grids, national TV and radio websites, and web applications for universities 
 and adult learning. In recent years, he has been heavily involved in distributed and 
 concurrent software architectures. He is currently the Head of Development for Intern 
 Avenue.
  
 To my love, Szilvi, who painted my cycling shoes full with gophers.",NA
www.PacktPub.com,NA,NA
"Support files, eBooks, discount offers, ",NA,NA
and more,"You might want to visit 
 www.PacktPub.com
  for support files and downloads related to your book.
  
 Did you know that Packt offers eBook versions of every book published, with PDF and ePub files 
 available? You can upgrade to the eBook version at 
 www.PacktPub.com
  and as a print book 
 customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
 service@ 
 packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for a range of 
 free newsletters and receive exclusive discounts and offers on Packt books and eBooks.
  
 TM
  
 http://PacktLib.PacktPub.com
  
 Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book library. 
 Here, you can access, read and search across Packt's entire library of books.",NA
Why subscribe?,"• 
  
 Fully searchable across every book published by Packt
  
 • 
  
 Copy and paste, print and bookmark content
  
 • 
  
 On demand and accessible via web browser",NA
Free access for Packt account holders,"If you have an account with Packt at 
 www.PacktPub.com
 , you can use this to access PacktLib today 
 and view nine entirely free books. Simply use your login credentials for immediate access.",NA
Table of Contents,"Preface 
  
 1
  
 Chapter 1: An Introduction to Concurrency in Go 
  
 9
  
 Introducing goroutines 
  
 A patient goroutine 
  
 Implementing the defer control mechanism 
  
  
 Using Go's scheduler 
  
  
 Using system variables 
  
 Understanding goroutines versus coroutines 
  
 Implementing channels 
  
 Channel-based sorting at the letter capitalization factory 
 Cleaning up our goroutines 
  
  
 Buffered or unbuffered channels 
  
 Using the select statement 
  
 Closures and goroutines 
  
 Building a web spider using goroutines and channels 
 Summary 
  
 Chapter 2: Understanding the Concurrency Model 
  
 9 
  
 11 
  
 13 
  
 15 
  
 20 
  
 21 
  
 22 
  
 25 
  
 29 
  
 29 
  
 29 
  
 33 
  
 35 
  
 40
  
 41
  
 Understanding the working of goroutines 
  
 Synchronous versus asynchronous goroutines 
 Designing the web server plan 
  
 Visualizing concurrency 
  
 RSS in action 
  
 An RSS reader with self diagnostics 
  
 Imposing a timeout 
  
 A little bit about CSP 
  
 The dining philosophers problem 
  
 Go and the actor model 
  
 4
 1 
  
 4
 2 
  
 4
 2 
  
 4
 4 
  
 4
 9 
  
 5
 0 
  
 5
 7 
  
 5
 7 
  
 5
 8 
  
 6
 0",NA
Preface,"I just love new programming languages. Perhaps it's the inevitable familiarity and ennui 
 with regard to existing languages and the frustration with existing tools, syntaxes, 
 coding conventions, and performance. Maybe I'm just hunting for that one ""language to 
 rule them all"". Whatever the reason, any time a new or experimental language is 
 released, I have to dive right in.
  
 This has been a golden age for new languages and language design. Think about it: the 
 C language was released in the early 1970s—a time when resources were so scarce 
 that verbosity, clarity, and syntactical logic were often eschewed for thrift. And most of 
 the languages we use today were either originally written in this era or were directly 
 influenced by those languages.
  
 Since the late 1980s and early 1990s, there has been a slow flood of powerful new 
 languages and paradigms—Perl, Python, Ruby, PHP, and JavaScript—have taken an 
 expanding user base by storm and has become one of the most popular languages (up 
 there with stalwarts such as C, C++, and Java). Multithreading, memory caching, and APIs 
 have allowed multiple processes, dissonant languages, applications, and even separate 
 operating systems to work in congress.
  
 And while this is great, there's a niche that until very recently was largely unserved: 
 powerful, compiled, cross-platform languages with concurrency support that are geared 
 towards systems programmers.",NA
What this book covers,"Chapter 1
 , 
 An Introduction to Concurrency in Go
 , introduces goroutines and channels, 
 and will compare the way Go handles concurrency with the approach other languages 
 use. We'll build some basic concurrent applications utilizing these new concepts.
  
 Chapter 2
 , 
 Understanding the Concurrency Model
 , focuses on resource allocation, sharing 
 memory (and when not to), and data. We will look at channels and channels of channels 
 as well as explain exactly how Go manages concurrency internally.
  
 Chapter 3
 , 
 Developing a Concurrent Strategy
 , discusses approach methods for 
 designing applications to best use concurrent tools in Go. We'll look at some 
 available third-party packages that can play a role in your strategy.
  
 Chapter 4
 , 
 Data Integrity in an Application
 , looks at ensuring that delegation of 
 goroutines and channels maintain the state in single thread and multithread 
 applications.
  
 Chapter 5
 , 
 Locks, Blocks, and Better Channels
 , looks at how Go can avoid dead 
 locks out of the box, and when and where they can still occur despite Go's 
 language design.
  
 Chapter 6
 , 
 C10K – A Non-blocking Web Server in Go
 , tackles one of the Internet's most 
 famous and esteemed challenges and attempt to solve it with core Go packages. 
  
 We'll then refine the product and test it against common benchmarking tools.
  
 [
  3 
 ]",NA
What you need for this book,"To work along with this book's examples, you'll need a computer running Windows, OS 
 X, or quite a few Linux variants that support Go. For this book, our Linux examples and 
 notes reference Ubuntu.
  
 If you do not already have Go 1.3 or newer installed, you will need to get it either 
 from the binaries download page on 
 http://golang.org/
  or through your 
 operating system's package manager.
  
 To use all of the examples in this book, you'll also need to have the following 
 software installed:
  
 • 
  
 MySQL (
 http://dev.mysql.com/downloads/
 )
  
 • 
  
 Couchbase (
 http://www.couchbase.com/download
 )
  
 Your choice of IDE is a matter of personal preference, as anyone who's worked with 
 developers can attest. That said, there are a few that lend themselves better to some 
 languages than others and a couple that have good support for Go. This author uses 
 Sublime Text, which plays very nice with Go, is lightweight, and allows you to build 
 directly from within the IDE itself. Anywhere you see screenshots of code, it will be from 
 within Sublime Text.
  
 And while there's a good amount of baked-in support for Go code, there's also a nice 
 plugin collection for Sublime Text called GoSublime, available at 
 https://github. 
 com/DisposaBoy/GoSublime
 .
  
 [
  4 
 ]",NA
Who this book is for ,"If you are a systems or network programmer with some knowledge of Go and 
 concurrency, but would like to know about the implementation of concurrent systems 
 written in Go this is the book for you. The goal of this book is to enable you to write 
 high-performance, scalable, resource-thrifty systems and network applications in Go.
  
 In this book, we'll write a number of basic and somewhat less - basic network and 
 systems applications. It's assumed that you've worked with these types of 
 applications before. If you haven't, some extracurricular study may be warranted to 
 be able to fully digest this content.",NA
Conventions ,"In this book, you will find a number of styles of text that distinguish between 
 different kinds of information. Here are some examples of these styles, and an 
 explanation of their meaning.
  
 Code words in text, database table names, folder names, filenames, file extensions, 
 pathnames, dummy URLs, user input, and Twitter handles are shown as follows: ""The 
 setProxy
  function is called after every request, and you can see it as the first line in 
 our handler.""
  
 A block of code is set as follows:
  
 package main
  
 import 
  
 ( 
  
 ""net/http"" 
  
 ""html/template"" 
  
 ""time"" 
  
 ""regexp"" 
  
 ""fmt"" 
  
 ""io/ioutil"" 
  
 ""database/sql"" 
  
 ""log"" 
  
 ""runtime"" 
  
 _ ""github.com/go-sql-
 driver/mysql"" 
  
 )
  
 [
  5 
 ]",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this 
 book—what you liked or may have disliked. Reader feedback is important for us to 
 develop titles that you really get the most out of.
  
 To send us general feedback, simply send an e-mail to 
 feedback@packtpub.com
 , 
 and mention the book title via the subject of your message.
  
 If there is a topic that you have expertise in and you are interested in either writing or 
 contributing to a book, see our author guide on 
 www.packtpub.com/authors
 .",NA
Customer support,"Now that you are the proud owner of a Packt book, we have a number of things to help 
 you to get the most from your purchase.",NA
Downloading the example code,"You can download the example code files for all Packt books you have purchased from 
 your account at 
 http://www.packtpub.com
 . If you purchased this book elsewhere, 
 you can visit 
 http://www.packtpub.com/support
  and register to have the files e-
 mailed directly to you.",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books—maybe a mistake in the text or the 
 code—we would be grateful if you would report this to us. By doing so, you can save other 
 readers from frustration and help us improve subsequent versions of this book. If you find 
 any errata, please report them by visiting 
 http://www.packtpub. com/submit-
 errata
 , selecting your book, clicking on the 
 erratasubmissionform
  link, and entering 
 the details of your errata. Once your errata are verified, your submission will be accepted 
 and the errata will be uploaded on our website, or added to any list of existing errata, 
 under the Errata section of that title. Any existing errata can be viewed by selecting your 
 title from 
 http://www.packtpub.com/support
 .
  
 [
  7 
 ]",NA
Piracy,"Piracy of copyright material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works, in any form, on the Internet, please provide us 
 with the location address or website name immediately so that we can pursue a remedy.
  
 Please contact us at 
 copyright@packtpub.com
  with a link to the suspected 
 pirated material.
  
 We appreciate your help in protecting our authors, and our ability to bring you 
 valuable content.",NA
Questions,"You can contact us at 
 questions@packtpub.com
  if you are having a problem 
 with any aspect of the book, and we will do our best to address it.
  
 [
  8 
 ]",NA
An Introduction to ,NA,NA
Concurrency in Go,"While Go is both a great general purpose and low-level systems language, one of its 
 primary strengths is the built-in concurrency model and tools. Many other 
 languages have third-party libraries (or extensions), but inherent concurrency is 
 something unique to modern languages, and it is a core feature of Go's design.
  
 Though there's no doubt that Go excels at concurrency—as we'll see in this 
 book—what it has that many other languages lack is a robust set of tools to 
 test and build concurrent, parallel, and distributed code.
  
 Enough talk about Go's marvelous concurrency features and tools, let's jump in.",NA
Introducing goroutines,"The primary method of handling concurrency is through a goroutine. Admittedly, our 
 first piece of concurrent code (mentioned in the preface) didn't do a whole lot, simply 
 spitting out alternating ""hello""s and ""world""s until the entire task was complete.",NA
A patient goroutine,"From here, we'll implement a 
 WaitGroup
  struct to ensure our goroutines run entirely 
 before moving on with our application. In this case, when we say patient, it's in contrast to 
 the way we've seen goroutines run outside of a parent method with our previous 
 example. In the following code, we will implement our first 
 Waitgroup 
 struct:
  
 package main
  
 import ( 
  
  
  ""fmt"" 
  
  
  ""sync"" 
  
  
  ""time"" 
  
 )
  
 [
  11 
 ]",NA
Implementing the defer control ,NA,NA
mechanism,"While we're here, we should take a moment and talk about defer. Go has an elegant 
 implementation of the defer control mechanism. If you've used defer (or something 
 functionally similar) in other languages, this will seem familiar—it's a useful way of 
 delaying the execution of a statement until the rest of the function is complete.
  
 [
  13 
 ]",NA
Using Go's scheduler,"With a lot of concurrent and parallel applications in other languages, the 
  
 management of both soft and hard threads is handled at the operating system level. This 
 is known to be inherently inefficient and expensive as the OS is responsible for context 
 switching, among multiple processes. When an application or process can manage its 
 own threads and scheduling, it results in faster runtime. The threads granted to our 
 application and Go's scheduler have fewer OS attributes that need to be considered in 
 context to switching, resulting in less overhead.
  
 If you think about it, this is self-evident—the more you have to juggle, the slower it is 
 to manage all of the balls. Go removes the natural inefficiency of this mechanism by 
 using its own scheduler.
  
 There's really only one quirk to this, one that you'll learn very early on: if you don't 
 ever yield to the main thread, your goroutines will perform in unexpected ways (or 
 won't perform at all).
  
 [
  15 
 ]",NA
Using system variables,"So what if you want to know how many threads your code has made available to you?
  
 Go has an environment variable returned from the runtime package function 
 GOMAXPROCS
 . To find out what's available, you can write a quick application similar to 
 the following code:
  
 package main
  
 import ( 
  
  
  ""fmt"" 
  
  
  ""runtime"" 
  
 )
  
 func listThreads() int {
  
  
  threads := 
 runtime.GOMAXPROCS(0)
  
  
  return threads 
  
 }
  
 func main() {
  
  runtime.GOMAXPROCS(2)
  
  fmt.Printf(""%d thread(s) available to Go."", listThreads())
  
 }
  
 A simple Go build on this will yield the following output:
  
 2 thread(s) available to Go.
  
 The 
 0
  parameter (or no parameter) delivered to 
 GOMAXPROCS
  means no change is 
 made. You can put another number in there, but as you might imagine, it will only 
 return what is actually available to Go. You cannot exceed the available cores, but you 
 can limit your application to use less than what's available.
  
 [
  20 
 ]",NA
Understanding goroutines versus ,NA,NA
coroutines,"At this point, you may be thinking, ""Ah, goroutines, I know these as coroutines."" Well, 
 yes and no.
  
 A coroutine is a cooperative task control mechanism, but in its most simplistic sense, a 
 coroutine is not concurrent. While coroutines and goroutines are utilized in similar 
 ways, Go's focus on concurrency provides a lot more than just state control and yields. 
 In the examples we've seen so far, we have what we can call 
 dumb
  goroutines. 
  
 Although they operate in the same time and address space, there's no real 
  
 communication between the two. If you look at coroutines in other languages, you may 
 find that they are often not necessarily concurrent or asynchronous, but rather they 
 are step-based. They yield to 
 main()
  and to each other, but two coroutines might not 
 necessarily communicate between each other, relying on a centralized, explicitly 
 written data management system.
  
 [
  21 
 ]",NA
Implementing channels,"So far, we've dabbled in concurrent processes that are capable of doing a lot but not 
 effectively communicating with each other. In other words, if you have two processes 
 occupying the same processing time and sharing the same memory and data, you must 
 have a way of knowing which process is in which place as part of a larger task.
  
 Take, for example, an application that must loop through one paragraph of Lorem 
 Ipsum and capitalize each letter, then write the result to a file. Of course, we will not 
 really need a concurrent application to do this (and in fact, it's an endemic function of 
 almost any language that handles strings), but it's a quick way to demonstrate the 
 potential limitations of isolated goroutines. Shortly, we'll turn this primitive example 
 into something more practical, but for now, here's the beginning of our capitalization 
 example:
  
 package main
  
 import ( 
  
  
  ""fmt"" 
  
  
  ""runtime"" 
  
  
  ""strings"" 
  
 )
  
 [
  22 
 ]",NA
Channel-based sorting at the letter ,NA,NA
capitalization factory,"Let's take the last example and do something (slightly) more purposeful by 
 attempting to capitalize the preamble of Abraham Lincoln's Gettysburg address 
 while mitigating the sometimes unpredictable effect of concurrency in Go, as shown 
 in the following code:
  
 package main
  
 import( 
  
  
  ""fmt"" 
  
  
  ""sync"" 
  
  
  ""runtime"" 
  
  
  ""strings"" 
  
 )
  
 var initialString string
  
 var finalString string
  
 var stringLength int
  
 func addToFinalStack(letterChannel chan string, wg 
  
  *sync.WaitGroup) {
  
  letter := <-letterChannel
  
  finalString += letter
  
  wg.Done()
  
 }
  
 func capitalize(letterChannel chan string, currentLetter string, 
  
  wg *sync.WaitGroup) {
  
  thisLetter := strings.ToUpper(currentLetter)
  
 [
  25 
 ]",NA
Cleaning up our goroutines,"You may be wondering why we need a 
 WaitGroup
  struct when using channels. 
 After all, didn't we say that a channel gets blocked until it receives data? This is 
 true, but it requires one other piece of syntax.
  
 A nil or uninitialized channel will always get blocked. We will discuss the potential uses 
 and pitfalls of this in 
 Chapter 7
 , 
 Performance and Scalability,
  and 
 Chapter 10
 , 
 Advanced 
 Concurrency and Best Practices
 .
  
 You have the ability to dictate how a channel blocks the application based on a 
 second option to the 
 make
  command by dictating the channel buffer.",NA
Buffered or unbuffered channels,"By default, channels are unbuffered, which means they will accept anything sent on 
 them if there is a channel ready to receive. It also means that every channel call will 
 block the execution of the application. By providing a buffer, the channel will only block 
 the application when many returns have been sent.
  
 A buffered channel is synchronous. To guarantee asynchronous performance, 
 you'll want to experiment by providing a buffer length. We'll look at ways to 
 ensure our execution falls as we expect in the next chapter.
  
  
 Go's channel system is based on 
 Communicating Sequential 
  
  
 Processes
  (
 CSP
 ), a formal language to design concurrent patterns 
  
 and multiprocessing. You will likely encounter CSP on its own 
  
 when people describe goroutines and channels.",NA
Using the select statement,"One of the issues with first implementing channels is that whereas goroutines were 
 formerly the method of simplistic and concurrent execution of code, we now have a 
 single-purpose channel that dictates application logic across the goroutines. Sure, the 
 channel is the traffic manager, but it never knows when traffic is coming, when it's no 
 longer coming, and when to go home, unless being explicitly told. It waits passively for 
 communication and can cause problems if it never receives any.
  
 [
  29 
 ]",NA
Closures and goroutines ,"You may have noticed the anonymous goroutine in Lorem Ipsum:
  
  go func() {
  
  go capitalize(index, length, letters, &finalIpsum) 
 }()
  
 While it isn't always ideal, there are plenty of places where inline functions work 
 best in creating a goroutine.
  
 [
  33 
 ]",NA
Building a web spider using goroutines ,NA,NA
and channels,"Let's take the largely useless capitalization application and do something practical with 
 it. Here, our goal is to build a rudimentary spider. In doing so, we'll accomplish the 
 following tasks:
  
 • 
  
 Read five URLs
  
 • 
  
 Read those URLs and save the contents to a string
  
 • 
  
 Write that string to a file when all URLs have been scanned and read
  
 These kinds of applications are written every day, and they're the ones that benefit the 
 most from concurrency and non-blocking code.
  
 It probably goes without saying, but this is not a particularly elegant web scraper. For 
 starters, it only knows a few start points—the five URLs that we supply it. Also, it's 
 neither recursive nor is it thread-safe in terms of data integrity.
  
 That said, the following code works and demonstrates how we can use channels and 
 the 
 select
  statements:
  
 package main
  
 import( 
  
  
  ""fmt"" 
  
  
  ""io/ioutil"" 
  
  
  ""net/http"" 
  
  
  ""time"" 
  
 )
  
 [
  35 
 ]",NA
Summary,"In this chapter, we learned how to go from simple goroutines and instantiating channels 
 to extending the basic functionality of goroutines and allowing cross-channel, 
 bidirectional communication within concurrent processes. We looked at new ways to 
 create blocking code to prevent our main process from ending before our goroutines. 
 Finally, we learned about using select statements to develop reactive channels that are 
 silent unless data is sent along a channel.
  
 In our rudimentary web spider example, we employed these concepts together to 
 create a safe, lightweight process that could extract all links from an array of URLs, 
 grab the content via HTTP, and store the resulting response.
  
 In the next chapter, we'll go beneath the surface to see how Go's internal scheduling 
 manages concurrency and start using channels to really utilize the power, thrift, and 
 speed of concurrency in Go.
  
 [
  40 
 ]",NA
Understanding the ,NA,NA
Concurrency Model,"Now that we have a sense of what Go is capable of and how to test drive some 
 concurrency models, we need to look deeper into Go's most powerful features to 
 understand how to best utilize various concurrent tools and models.
  
 We played with some general and basic goroutines to see how we can run concurrent 
 processes, but we need to see how Go manages scheduling in concurrency before we get 
 to communication between channels.",NA
Understanding the working of goroutines,"By this point, you should be well-versed in what goroutines do, but it's worth 
 understanding 
 how
  they work internally in Go. Go handles concurrency with 
 cooperative scheduling, which, as we mentioned in the previous chapter, is 
 heavily dependent on some form of blocking code.
  
 The most common alternative to cooperative scheduling is preemptive scheduling, 
 wherein each subprocess is granted a space of time to complete and then its execution 
 is paused for the next.
  
 Without some form of yielding back to the main thread, execution runs into issues. 
 This is because Go works with a single process, working as a conductor for an 
 orchestra of goroutines. Each subprocess is responsible to announce its own 
 completion. As compared to other concurrency models, some of which allow for direct, 
 named communication, this might pose a sticking point, particularly if you haven't 
 worked with channels before.",NA
Synchronous versus asynchronous ,NA,NA
goroutines,"Understanding the concurrency model is sometimes an early pain point for 
 programmers—not just for Go, but across languages that use different models as 
 well. Part of this is due to operating in a 
 black box
  (depending on your terminal 
 preferences); a developer has to rely on logging or errors with data consistency to 
 discern asynchronous and/or multiple core timing issues.
  
 As the concepts of synchronous and asynchronous or concurrent and nonconcurrent 
 tasks can sometimes be a bit abstract, we will have a bit of fun here in an effort to 
 demonstrate all the concepts we've covered so far in a visual way.
  
 There are, of course, a myriad of ways to address feedback and logging. You can write 
 to files in 
 console/terminal/stdout…
 , most of which are inherently linear in nature. 
 There is no concise way to represent concurrency in a logfile. Given this and the fact 
 that we deal with an emerging language with a focus on servers, let's take a different 
 angle.
  
 Instead of simply outputting to a file, we'll create a visual feedback that shows 
 when a process starts and stops on a timeline.",NA
Designing the web server plan,"To show how approaches differ, we'll create a simple web server that loops through 
 three trivial tasks and outputs their execution marks on an X-second timeline. We'll do 
 this using a third-party library called 
 svgo
  and the built-in 
 http
  package for Go.
  
 To start, let's grab the 
 svgo
  library via 
 go get
 :
  
 go get github.com/ajstarks/svgo
  
 [
  42 
 ]",NA
Visualizing concurrency,"Our first attempt at visualizing concurrency will have two simple goroutines running the 
 drawPoint
  function in a loop with 100 iterations. After running this, you can visit 
 localhost:1900/visualize
  and see what concurrent goroutines look like.
  
 If you run into problems with port 1900 (either with your firewall or through a port 
 conflict), feel free to change the value on line 99 in the 
 main()
  function. You may also 
 need to access it through 
 127.0.0.1
  if your system doesn't resolve localhost.
  
 [
  44 
 ]",NA
RSS in action,"Let's take the concept of 
 Rich Site Summary
  / 
 Really Simple Syndication
  (
 RSS
 ) and 
 inject some real potential delays to identify where we can best utilize goroutines in an 
 effort to speed up execution and prevent blocking code. One common way to bring real-
 life, potentially blocking application elements into your code is to use something 
 involving network transmission.
  
 This is also a great place to look at timeouts and close channels to ensure that our 
 program doesn't fall apart if something takes too long.
  
 To accomplish both these requirements, we'll build a very basic RSS reader that will 
 simply parse through and grab the contents of five RSS feeds. We'll read each of these as 
 well as the provided links on each, and then we'll generate an SVG report of the process 
 available via HTTP.
  
 [
  49 
 ]",NA
An RSS reader with self diagnostics,"Let's take a look at what we've learned so far, and use it to fetch and parse a set of RSS 
 feeds concurrently while returning some visual feedback about the process in an 
 internal web browser, as shown in the following code:
  
 package main
  
 import( 
  
  
  ""github.com/ajstarks/svgo"" 
  
  
  rss ""github.com/jteeuwen/go-pkg-rss""     
  
  
  ""net/http"" 
  
  
  ""log"" 
  
  
  ""fmt"" 
  
  
  ""strconv"" 
  
  
  ""time"" 
  
  
  ""os"" 
  
  
  ""sync"" 
  
  
  ""runtime"" 
  
 )
  
 type Feed struct 
 {
  
  url string
  
  status int
  
  itemCount int
  
 [
  50 
 ]",NA
Imposing a timeout,"So what happens if nothing runs within our timeline? As you might expect, we'll get 
 three bars with no activity in them. It's important to consider how to kill processes that 
 aren't doing what we expect them to. In this case, the best method is a timeout. 
  
 The 
 Get
  method in the 
 http
  package does not natively support a timeout, so you'll have 
 to roll your own 
 rssFeed.Fetch
  (and underlying 
 http.Get()
 ) implementation if you 
 want to prevent these requests from going into perpetuity and killing your application. 
 We'll dig into this a bit later; in the mean time, take a look at the 
  
 Transport
  struct, available in the core 
 http
  package at 
 http://golang.org/pkg/ 
 net/http/#Transport
 .",NA
A little bit about CSP,"We touched on CSP briefly in the previous chapter, but it's worth exploring a bit 
 more in the context of how Go's concurrency model operates.
  
 CSP evolved in the late 1970s and early 1980s through the work of Sir Tony Hoare and 
 is still in the midst of evolution today. Go's implementation is heavily based on CSP, but 
 it neither entirely follows all the rules and conventions set forth in its initial description 
 nor does it follow its evolution since.
  
 One of the ways in which Go differs from true CSP is that as it is defined, a process in 
 Go will only continue so long as there exists a channel ready to receive from that 
 process. We've already encountered a couple of deadlocks that were the result of a 
 listening channel with nothing to receive. The inverse is also true; a deadlock can 
 result from a channel continuing without sending anything, leaving its receiving 
 channel hanging indefinitely.
  
 This behavior is endemic to Go's scheduler, and it should really only pose problems 
 when you're working with channels initially.
  
  
 Hoare's original work is now available (mostly) free from a number of 
  
  
 institutions. You can read, cite, copy, and redistribute it free of charge 
  
 (but not for commercial gain). If you want to read the whole thing, 
  
 you can grab it at 
 http://www.cs.ucf.edu/courses/cop4020/
  
 sum2009/CSP-hoare.pdf
 .
  
 The complete book itself is also available at 
 http://www.
  
 usingcsp.com/cspbook.pdf
 .
  
 As of this publishing, Hoare is working as a researcher at Microsoft.
  
 [
  57 
 ]",NA
The dining philosophers problem,"You may have heard of the dining philosophers problem, which describes the kind of 
 problems concurrent programming was designed to solve. The dining philosophers 
 problem was formulated by the great Edsger Dijkstra. The crux of the problem is a 
 matter of resources—five philosophers sit at a table with five plates of food and five 
 forks, and each can only eat when he has two forks (one to his left and another to his 
 right). A visual representation is shown as follows:
  
  
 With a single fork on either side, any given philosopher can only eat when he has a fork 
 in both hands and must put both back on the table when complete. The idea is to 
 coordinate the meal such that all of the philosophers can eat in perpetuity without any 
 starving—two philosophers must be able to eat at any moment and there can be no 
 deadlocks. They're philosophers because when they're not eating, they're thinking. In a 
 programming analog, you can consider this as either a waiting channel or a sleeping 
 process.
  
 [
  58 
 ]",NA
Go and the actor model,"The actor model is something that you'll likely be very familiar with if you're an Erlang or 
 Scala user. The difference between CSP and the actor model is negligible but important. 
 With CSP, messages from one channel can only be completely sent if another channel is 
 listening and ready for them. The actor model does not necessarily require a ready 
 channel for another to send. In fact, it stresses direct communication rather than relying 
 on the conduit of a channel.
  
 Both systems can be nondeterministic, which we've already seen demonstrated in 
 Go/CSP in our earlier examples. CSP and goroutines are anonymous and 
 transmission is specified by the channel rather than the source and destination. 
  
 An easy way to visualize this in pseudocode in the actor model is as follows:
  
 a = new Actor
  
 b = new Actor
  
 a -> b(""message"")
  
 In CSP, it is as follows:
  
 a = new Actor
  
 b = new Actor
  
 c = new Channel
  
 a -> c(""sending something"")
  
 b <- c(""receiving something"")
  
 Both serve the same fundamental functionality but through slightly different ways.",NA
Object orientation,"As you work with Go, you will notice that there is a core characteristic that's often 
 espoused, which users may feel is wrong. You'll hear that Go is not an object-oriented 
 language, and yet you have structs that can have methods, those methods in turn can 
 have methods, and you can have communication to and from any instantiation of it. 
 Channels themselves may feel like primitive object interfaces, capable of setting and 
 receiving values from a given data element.
  
 The message passing implementation of Go is, indeed, a core concept of object-
 oriented programming. Structs with interfaces operate essentially as classes, and Go 
 supports polymorphism (although not parametric polymorphism). Yet, many who 
 work with the language (and who have designed it) stress that it is not object oriented. 
 So what gives?
  
 [
  60 
 ]",NA
Demonstrating simple polymorphism in Go,"As mentioned before, if you expect polymorphism to resemble object-oriented 
 programming, this may not represent a syntactical analogue. However, the use of 
 interfaces as an abstraction of class-bound polymorphic methods is just as clean, 
 and in many ways, more explicit and readable. Let's look at a very simple 
 implementation of polymorphism in Go:
  
 type intInterface struct {
  
 }
  
 type stringInterface struct {
  
 }
  
 func (number intInterface) Add (a int, b int) int {
  
  return a + b;
  
 }
  
 func (text stringInterface) Add (a string, b string) string {
  
  return a + b
  
 }
  
 func main() {
  
  number := new (intInterface)
  
  fmt.Println( number.Add(1,2) )
  
  text := new (stringInterface)
  
  fmt.Println( text.Add(""this old man"","" he played one""))
  
 }
  
 [
  61 
 ]",NA
Using concurrency,"It hasn't yet been mentioned, but we should be aware that concurrency is not always 
 necessary and beneficial for an application. There exists no real rule of thumb, and it's 
 rare that concurrency will introduce problems to an application; but if you really think 
 about applications as a whole, not all will require concurrent processes.
  
 So what works best? As we've seen in the previous example, anything that 
  
 introduces potential latency or I/O blocking, such as network calls, disk reads, third-
 party applications (primarily databases), and distributed systems, can benefit from 
 concurrency. If you have the ability to do work while other work is being done on an 
 undetermined timeline, concurrency strategies can improve the speed and reliability of 
 an application.
  
 The lesson here is you should never feel compelled to shoehorn concurrency into an 
 application that doesn't really require it. Programs with inter-process dependencies (or 
 lack of blocking and external dependencies) may see little or no benefit from 
 implementing concurrency structures.",NA
Managing threads,"So far, you've probably noticed that thread management is not a matter that requires 
 the programmer's utmost concern in Go. This is by design. Goroutines aren't tied to a 
 specific thread or threads that are handled by Go's internal scheduler. However, this 
 doesn't mean that you neither have access to the threads nor the ability to control what 
 individual threads do. As you know, you can already tell Go how many threads you have 
 (or wish to use) by using 
 GOMAXPROCS
 . We also know that using this can introduce 
 asynchronous issues as it pertains to data consistency and execution order.
  
 At this point, the main issue with threads is not how they're accessed or utilized, but how 
 to properly control execution flow to guarantee that your data is predictable and 
 synchronized.
  
 [
  62 
 ]",NA
Using sync and mutexes to lock data,"One issue that you may have run into with the preceding examples is the notion of 
 atomic data. After all, if you deal with variables and structures across multiple 
 goroutines, and possibly processors, how do you ensure that your data is safe across 
 them? If these processes run in parallel, coordinating data access can sometimes be 
 problematic.
  
 Go provides a bevy of tools in its 
 sync
  package to handle these types of problems. How 
 elegantly you approach them depends heavily on your approach, but you should never 
 have to reinvent the wheel in this realm.
  
 We've already looked at the 
 WaitGroup
  struct, which provides a simple method to tell 
 the main thread to pause until the next notification that says a waiting process has 
 done what it's supposed to do.
  
 Go also provides a direct abstraction to a mutex. It may seem contradictory to call 
 something a direct abstraction, but the truth is you don't have access to Go's 
 scheduler, only an approximation of a true mutex.
  
 We can use a mutex to lock and unlock data and guarantee atomicity in our data. 
  
 In many cases, this may not be necessary; there are a great many times where the order 
 of execution does not impact the consistency of the underlying data. However, when we 
 do have concerns about this value, it's helpful to be able to invoke a lock explicitly. Let's 
 take the following example:
  
 package main
  
 import( 
  
  
  ""fmt"" 
  
  
  ""sync"" 
  
 )
  
 func main() {
  
  current := 0
  
  iterations := 100
  
  wg := new (sync.WaitGroup);
  
  for i := 0; i < iterations; i++ {
  
  wg.Add(1)
  
 [
  63 
 ]",NA
Summary,"In this chapter, we've tried to remove some of the ambiguity of Go's concurrency 
 patterns and models by giving visual, real-time feedback to a few applications, 
 including a rudimentary RSS aggregator and reader. We examined the dining 
 philosophers problem and looked at ways you can use the Go concurrency topics to 
 solve the problem neatly and succinctly. We compared the way CSP and actor models 
 are similar and ways in which they differ.
  
 In the next chapter, we will take these concepts and apply them to the process of 
 developing a strategy to maintain concurrency in an application.
  
 [
  65 
 ]",NA
Developing a Concurrent ,NA,NA
Strategy,"In the previous chapter, we looked at the concurrency model that Go relies on to 
 make your life as a developer easier. We also saw a visual representation of 
 parallelism and concurrency. These help us to understand the differences and 
 overlaps between serialized, concurrent, and parallel applications.
  
 However, the most critical part of any concurrent application is not the concurrency 
 itself but communication and coordination between the concurrent processes.
  
 In this chapter, we'll look at creating a plan for an application that heavily factors 
 communication between processes and how a lack of coordination can lead to 
 significant issues with consistency. We'll look at ways we can visualize our concurrent 
 strategy on paper so that we're better equipped to anticipate potential problems.",NA
Applying efficiency in complex ,NA,NA
concurrency,"When designing applications, we often eschew complex patterns for simplicity, with 
 the assumption that simple systems are often the fastest and most efficient. It seems 
 only logical that a machine with fewer moving parts will be more efficient than one 
 with more.
  
 The paradox here, as it applies to concurrency, is that adding redundancy and 
 significantly more movable parts often leads to a more efficient application. If we consider 
 concurrent schemes, such as goroutines, to be infinitely scalable resources, employing 
 more should always result in some form of efficiency benefit. This applies not just to 
 parallel concurrency but to single core concurrency as well.",NA
Identifying race conditions with race ,NA,NA
detection,"If you've ever written an application that depends on the exact timing and 
 sequencing of functions or methods to create a desired output, you're already 
 quite familiar with race conditions.
  
 These are particularly common anytime you deal with concurrency and far more so 
 when parallelism is introduced. We've actually encountered a few of them in the first 
 few chapters, specifically with our incrementing number function.
  
 The most commonly used educational example of race conditions is that of a bank 
 account. Assume that you start with $1,000 and attempt 200 $5 transactions. Each 
 transaction requires a query on the current balance of the account. If it passes, the 
 transaction is approved and $5 is removed from the balance. If it fails, the transaction is 
 declined and the balance remains unchanged.
  
 This is all well and good until the query happens at some point during a concurrent 
 transaction (in most cases in another thread). If, for example, a thread asks ""Do you have 
 $5 in your account?"" as another thread is in the process of removing $5 but has not yet 
 completed, you can end up with an approved transaction that should have been 
 declined.
  
 Tracking down the cause of race conditions can be—to say the least—a gigantic 
 headache. With Version 1.1 of Go, Google introduced a race detection tool that can 
 help you locate potential issues.
  
 [
  68 
 ]",NA
Using mutual exclusions,"Typically, mutual exclusion is considered a low-level and best-known approach to 
 synchronicity in your application—you should be able to address data consistency 
 within communication between your channels. However, there will be instances 
 where you need to truly block read/write on a value while you work with it.
  
 At the CPU level, a mutex represents an exchange of binary integer values across 
 registers to acquire and release locks. We'll deal with something on a much higher 
 level, of course.
  
 We're already familiar with the sync package from our use of the 
 WaitGroup
  struct, but 
 the package also contains the conditional variables 
 struct Cond
  and 
 Once
 , which will 
 perform an action just one time, and the mutual exclusion locks 
 RWMutex 
 and 
 Mutex
 . As 
 the name 
 RWMutex
  implies, it is open to multiple readers and/or writers to lock and 
 unlock; there is more on this later in this chapter and in 
 Chapter 5
 , 
 Locks, Blocks, and 
 Better Channels
 .
  
 [
  72 
 ]",NA
Exploring timeouts,"Another noteworthy thing we can do with channels is explicitly kill them after a 
 specified amount of time. This is an operation that will be a bit more involved 
 should you decide to manually handle mutual exclusions.
  
 The ability to kill a long-running routine through the channel is extremely helpful; 
 consider a network-dependent operation that should not only be restricted to a short 
 time period but also not allowed to run for a long period. In other words, you want to 
 offer the process a few seconds to complete; but if it runs for more than a minute, our 
 application should know that something has gone wrong enough to stop attempting to 
 listen or send on that channel. The following code demonstrates using a timeout channel 
 in a 
 select
  call:
  
 func main() {
  
  ourCh := make(chan string,1)
  
 [
  77 
 ]",NA
Importance of consistency,"In our example, we'll build an events scheduler. If we are available for a meeting and we 
 get two concurrent requests for a meeting invite, we'll get double-booked should a race 
 condition exist. Alternately, locked data across two goroutines may cause both the 
 requests to be denied or will result in an actual deadlock.
  
 We want to guarantee that any request for availability is consistent—there should 
 neither be double-booking nor should a request for an event be blocked incorrectly 
 (because two concurrent or parallel routines lock the data simultaneously).",NA
Synchronizing our concurrent operations,"The word synchronization literally refers to temporal existence—things occurring at the 
 same time. It seems then that the most apt demonstration of synchronicity will be 
 something involving time itself.
  
 [
  78 
 ]",NA
The project – multiuser appointment ,NA,NA
calendar,"What do you do when you decide to write a program?
  
 If you're like a lot of people, you think about the program; perhaps you and a team will 
 write up a spec or requirements document, and then you'll get to coding. 
  
 Sometimes, there will be a drawing representing some facsimile of the way the 
 application will work.
  
 Quite often, the best way to nail down the architecture and the inner workings of an 
 application is to put pencil to paper and visually represent the way the program will 
 work. For a lot of linear or serial applications, this is often an unnecessary step as 
 things will work in a predictable fashion that should not require any specific 
 coordination within the application logic itself (although coordinating third-party 
 software likely benefits from specification).
  
 [
  79 
 ]",NA
Visualizing a concurrent pattern,"As we have already discussed, we wish to create a basic blueprint of how our application 
 should function as a starting point. Here, we'll implement some control flow, which 
 relates to user activity, to help us decide what functionality we'll need to include. The 
 following diagram illustrates how the control flow may look like:
  
 Concurrent Schedule Requests
  
 Mutex or channel
  
 Is User Available?
  
 No
  
 Yield
  
 Yes
  
 To
  
 Channel
  
 Schedule and return to channel
  
 In the previous diagram, we anticipate where data can be shared using concurrent and 
 parallel processes to locate points of failure. If we design concurrent applications in such 
 graphical ways, we're less likely to find race conditions later on.
  
 While we talked about how Go helps you to locate these after the application has 
 completed running, our ideal development workflow is to attempt to cut these 
 problems off at the start.
  
 [
  81 
 ]",NA
Developing our server requirements,"Now that we have an idea of how the scheduling process should work, we need to 
 identify components that our application will need. In this case, the components are as 
 follows:
  
 • 
  
 A web server handler
  
 • 
  
 A template for output
  
 • 
  
 A system for determining dates and times",NA
Web server,"In our visualizing concurrency example from the previous chapter, we used Go's built-
 in 
 http
  package, and we'll do the same here. There are a number of good frameworks 
 out there for this, but they primarily extend the core Go functionality rather than 
 reinventing the wheel. The following are a few of these functionalities, listed from 
 lightest to heaviest:
  
 • 
  
 Web.go: 
 http://webgo.io/
  
 Web.go is very lightweight and lean, and it provides some routing 
 functionality not available in the 
 net
 /
 http
  package.
  
 • 
  
 Gorilla: 
 http://www.gorillatoolkit.org/
  
 Gorilla is a Swiss army knife to augment the 
 net
 /
 http
  package. It's not 
 particularly heavy, and it is fast, utilitarian, and very clean.
  
 • 
  
 Revel: 
 http://robfig.github.io/revel/
  
 Revel is the heaviest of the three, but it focuses on a lot of intuitive code, 
 caching, and performance. Look for it if you need something mature that will 
 face a lot of traffic.
  
 In 
 Chapter 6
 , 
 C10K – A Non-blocking Web Server in Go
 , we'll roll our own web server 
 and framework with the sole goal of extreme high performance.",NA
The Gorilla toolkit,"For this application, we'll partially employ the Gorilla web toolkit. Gorilla is a fairly 
 mature web-serving platform that fulfills a few of our needs here natively, namely the 
 ability to include regular expressions in our URL routing. (Note: Web.Go also extends 
 some of this functionality.) Go's internal HTTP routing handler is rather simplistic; you 
 can extend this, of course, but we'll take a shortcut down a well-worn and reliable path 
 here.
  
 [
  82 
 ]",NA
Using templates,"As Go is intended as a system language, and as system languages often deal with the 
 creation of servers with clients, some care was put into making it a well-featured 
 alternative to create web servers.
  
 Anyone who's dealt with a ""web language"" will know that on top of that you'll need a 
 framework, ideally one that handles the presentation layer for the web. While it's true 
 that if you take on such a project you'll likely look for or build your own framework, Go 
 makes the templating side of things very easy.
  
 The template package comes in two varieties: 
 text
  and 
 http
 . Though they both serve 
 different end points, the same properties—affording dynamism and flexibility—apply 
 to the presentation layer rather than strictly the application layer.
  
  
 The 
 text
  template package is intended for general plaintext 
  
  
 documents, while the 
 http
  template package handles the generation 
  
 of HTML and related documents.
  
 These templating paradigms are all too common these days; if you look at the 
 http
 /
 template
  package, you'll find some very strong similarities to Mustache, one 
 of the more popular variants. While there is a Mustache port in Go, there's nothing 
 there that isn't handled by default in the template package.
  
  
 For more information on Mustache, visit 
 http://mustache.
  
  
 github.io/
 .
  
 One potential advantage to Mustache is its availability in other languages. If you ever 
 feel the need to port some of your application logic to another language (or existing 
 templates into Go), utilizing Mustache could be advantageous. That said, you sacrifice a 
 lot of the extended functionality of Go templates, namely the ability to take out Go code 
 from your compiled package and move it directly into template control structures. 
 While Mustache (and its variants) has control flows, they may not mirror Go's 
 templating system. Take the following example:
  
 <ul> 
  
 {{range .Users}} 
  
 <li>A User </li> 
  
 {{end}} 
  
 </ul>
  
 [
  83 
 ]",NA
Time,"We're not doing a whole lot of math here; time will be broken into hour blocks and 
 each will be set to either occupied or available. At this time, there aren't a lot of 
 external 
 date
 /
 time
  packages for Go. We're not doing any heavy-date math, but it 
 doesn't really matter because Go's 
 time
  package should suffice even if we were.
  
 In fact, as we have literal hour blocks from 9 a.m. to 5 p.m., we just set these to 
 the 24-hour time values of 9-17, and invoke a function to translate them into 
 linguistic dates.",NA
Endpoints,"We'll want to identify the REST endpoints (via 
 GET
  requests) and briefly 
 describe how they'll work. You can think of these as modules or methods in 
 the model-view-controller architecture. The following is a list of the endpoint 
 patterns we'll use:
  
 • 
  
 • 
  
 • 
  
 entrypoint/register/{name}
 : This is where we'll go to add a name to 
 the list of users. If the user exists, it will fail.
  
 entrypoint/viewusers
 : Here, we'll present a list of users with their 
 timeslots, both available and occupied.
  
 entrypoint/schedule/{name}/{time}
 : This will initialize an attempt 
 to schedule an appointment.
  
 Each will have an accompanying template that will report the status of the 
 intended action.
  
 [
  84 
 ]",NA
Custom structs ,"We'll deal with users and responses (web pages), so we need two structs to represent 
 each. One struct is as follows:
  
 type User struct 
 {
  
  
  Name string
  
  
  email string
  
  
  times[int] bool 
  
 }
  
 The other struct is as follows:
  
 type Page struct 
 {
  
  
  Title string
  
  
  Body string 
  
 }
  
 We will keep the page as simple as possible. Rather than doing a lot of iterative 
 loops, we will produce the HTML within the code for the most part.
  
 Our endpoints for requests will relate to our previous architecture, using the 
 following code:
  
 func users(w http.ResponseWriter, r *http.Request) { } 
  
 func register(w http.ResponseWriter, r *http.Request) { 
 } 
  
 func schedule(w http.ResponseWriter, r *http.Request) { 
 }",NA
A multiuser Appointments Calendar ,"In this section, we'll quickly look at our sample Appointments Calendar application, 
 which attempts to control consistency of specific elements to avoid obvious race 
 conditions. The following is the full code, including the routing and templating:
  
 package main
  
 import(
  
  ""net/http""
  
  ""html/template""
  
  ""fmt""
  
 [
  85 
 ]",NA
A note on style,"You'll note that despite preferring camelCase for most of our variables, we have some 
 uppercase variables within structs. This is an important Go convention worth 
 mentioning: any struct variable that begins with a capital letter is 
 public
 . Any variable 
 that begins with a lowercase letter is 
 private
 .
  
 If you attempt to output a private (or nonexistent) variable in your template files, 
 template rendering will fail.
  
 [
  93 
 ]",NA
A note on immutability,"Note that whenever possible, we'll avoid using the string type for comparative 
 operations, especially in multithreaded environments. In the previous example, we 
 use integers and Booleans to decide availability for any given user. In some 
 languages, you may feel empowered to assign the time values to a string for ease of 
 use. For the most part, this is fine, even in Go; but assuming that we have an infinitely 
 scalable, shared calendar application, we run the risk of introducing memory issues if 
 we utilize strings in this way.
  
 The string type is the sole immutable type in Go; this is noteworthy if you end up 
 assigning and reassigning values to a string. Assuming that memory is yielded after a 
 string is converted to a copy, this is not a problem. However, in Go (and a couple of other 
 languages), it's entirely possible to keep the original value in memory. 
  
 We can test this using the following example:
  
 func main() {
  
  testString := ""Watch your top / resource monitor""
  
  for i:= 0; i < 1000; i++ {
  
  testString = string(i)
  
  }
  
  doNothing(testString)  
  
  time.Sleep(10 * time.Second)
  
 }
  
 When run in Ubuntu, this takes approximately 1.0 MB of memory; some of that no doubt 
 overhead, but a useful reference point. Let's up the ante a bit—though having 1,000 
 relatively small pointers won't have much impact—using the following line of code:
  
 for i:= 0; i < 100000000; i++ {
  
 Now, having gone through 100 million memory assignments, you can see the impact 
 on memory (it doesn't help that the string itself is at this point longer than the initial, 
 but it doesn't account for the full effect). Garbage collection takes place here too, which 
 impacts CPU. On our initial test here, both CPU and memory spiked. If we substitute 
 this for an integer or a Boolean assignment, we get much smaller footprints.
  
 [
  94 
 ]",NA
Summary,"This chapter has hopefully directed you towards exploring methods to plan and 
 chart out your concurrent applications before delving in. By briefly touching on 
 race conditions and data consistency, we attempted to highlight the importance of 
 anticipatory design. At the same time, we utilized a few tools for identifying such 
 issues, should they occur.
  
 Creating a robust script flowchart with concurrent processes will help you locate 
 possible pitfalls before you create them, and it will give you a better sense of how 
 (and when) your application should be making decisions with logic and data.
  
 In the next chapter, we'll examine data consistency issues and look at advanced 
 channel communication options in an effort to avoid needless and often expensive 
 mitigating functions, mutexes, and external processes.
  
 [
  95 
 ]",NA
Data Integrity in ,NA,NA
an Application,"By now, you should be comfortable with the models and tools provided in Go's core to 
 provide mostly race-free concurrency.
  
 We can now create goroutines and channels with ease, manage basic communication 
 across channels, coordinate data without race conditions, and detect such conditions as 
 they arise.
  
 However, we can neither manage larger distributed systems nor deal with potentially 
 lower-level consistency problems. We've utilized a basic and simplistic mutex, but we 
 are about to look at a more complicated and expressive way of handling mutual 
 exclusions.
  
 By the end of this chapter, you should be able to expand your concurrency patterns from 
 the previous chapter into distributed systems using a myriad of concurrency models 
 and systems from other languages. We'll also look—at a high level—at some consistency 
 models that you can utilize to further express your precoding strategies for single-
 source and distributed applications.",NA
Getting deeper with mutexes and sync,"In 
 Chapter 2
 , 
 Understanding the Concurrency Model
 , we introduced 
 sync.mutex
  and 
 how to invoke a mutual exclusion lock within your code, but there's some more nuance 
 to consider with the package and the mutex type.
  
 We've mentioned that in an ideal world, you should be able to maintain 
  
 synchronization in your application by using goroutines alone. In fact, this would 
 probably be best described as the canonical method within Go, although the 
 sync 
 package does provide a few other utilities, including mutexes.",NA
The cost of goroutines,"As you work with goroutines, you might get to a point where you're spawning dozens or 
 even hundreds of them and wonder if this is going to be expensive. This is particularly 
 true if your previous experience with concurrent and/or parallel programming was 
 primarily thread-based. It's commonly accepted that maintaining threads and their 
 respective stacks can begin to bog down a program with 
  
 performance issues. There are a few reasons for this, which are as follows:
  
 • 
  
 • 
  
 • 
  
 Memory is required just for the creation of a thread 
  
 Context switching at the OS level is more complex and expensive than in-
 process context switching 
  
 Very often, a thread is spawned for a very small process that could be 
 handled otherwise
  
 It's for these reasons that a lot of modern concurrent languages implement something 
 akin to goroutines (C# uses the async and await mechanism, Python has greenlets/ green 
 threads, and so on) that simulate threads using small-scale context switching.
  
 However, it's worth knowing that while goroutines are (or can be) cheap and cheaper 
 than OS threads, they are not free. At a large (perhaps enormous) measure, even cheap 
 and light goroutines can impact performance. This is particularly important to note as we 
 begin to look at distributed systems, which often scale larger and at faster rates.
  
 The difference between running a function directly and running it in a goroutine is 
 negligible of course. However, keep in mind that Go's documentation states:
  
 It is practical to create hundreds of thousands of goroutines in the same 
 address space.
  
 Given that stack creation uses a few kilobytes per goroutine, in a modern 
  
 environment, it's easy to see how that could be perceived as a nonfactor. However, 
 when you start talking about thousands (or millions) of goroutines running, it can and 
 likely will impact the performance of any given subprocess or function. 
  
 You can test this by wrapping functions in an arbitrary number of goroutines and 
 benchmarking the average execution time and—more importantly—memory usage. 
  
 At approximately 5KB per goroutine, you may find that memory can become a factor, 
 particularly on low-RAM machines or instances. If you have an application that runs 
 heavy on a high-powered machine, imagine it reaching criticality in one or more 
 lower-powered machines. Consider the following example:
  
 for i:= 0; i < 1000000000; i++ {
  
  go someFunction()
  
 }
  
 [
  100 
 ]",NA
Working with files,"Files are a great example of areas where data consistency issues such as race conditions 
 can lead to more permanent and catastrophic problems. Let's look at a piece of code that 
 might continuously attempt to update a file to see where we could run into race 
 conditions, which in turn could lead to bigger problems such as an application failing or 
 losing data consistency:
  
 package main
  
 import( 
  
  
  ""fmt"" 
  
  
  ""io/ioutil"" 
  
  
  ""strconv"" 
  
  
  ""sync"" 
  
 )
  
 func writeFile(i int) {
  
  rwLock.RLock();
  
  ioutil.WriteFile(""test.txt"",  
  
  []byte(strconv.FormatInt(int64(i),10)), 0x777)
  
  rwLock.RUnlock();
  
 [
  101 
 ]",NA
Getting low – implementing C,"One of the most interesting developments in language design in the past decade or two 
 is the desire to implement lower-level languages and language features via API. Java lets 
 you do this purely externally, and Python provides a C library for interaction between 
 the languages. It warrants mentioning that the reasons for doing this vary—among them 
 applying Go's concurrency features as a wrapper for legacy C code—and you will likely 
 have to deal with some of the memory management associated with introducing 
 unmanaged code to garbage-collected applications.
  
 Go takes a hybrid approach, allowing you to call a C interface through an import, 
 which requires a frontend compiler such as GCC:
  
 import ""C""
  
 So why would we want to do this?
  
 There are some good and bad reasons to implement C directly in your project. An 
 example of a good reason might be to have direct access to the inline assembly, which 
 you can do in C but not directly in Go. A bad reason could be any that has a solution 
 inherent in Golang itself.
  
 To be fair, even a bad reason is not bad if you build your application reliably, but it does 
 impose an additional level of complexity to anyone else who might use your code. If Go 
 can satisfy the technical and performance requirements, it's always better to use a single 
 language in a single project.
  
 There's a famous quote from C++ creator Bjarne Stroustrup on C and C++:
  
 C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you 
 do, it blows your whole leg off.
  
 Jokes aside (Stroustrup has a vast collection of such quips and quotes), the 
 fundamental reasoning is that the complexity of C often prevents people from 
 accidentally doing something catastrophic.
  
 [
  103 
 ]",NA
Touching memory in cgo ,"The most important takeaway from the preceding example is to remember that 
 anytime you go into or out of C, you need to manage memory manually (or at least 
 more directly than with Go alone). If you've ever worked in C (or C++), you know that 
 there's no automatic garbage collection, so if you request memory space, you must also 
 free it. Calling C from Go does not preclude this.",NA
The structure of cgo ,"Importing C into Go will take you down a syntactical side route, as you probably 
 noticed in the preceding code. The first thing that will appear glaringly different is the 
 actual implementation of C code within your application.
  
 [
  104 
 ]",NA
The other way around,"Using C within Go is obviously a potentially powerful tool for code migration, 
 implementing lower-level code, and roping in other developers, but what about the 
 inverse? Just as you can call C from within Go, you can call Go functions as external 
 functions within your embedded C.
  
 The end game here is the ability to work with and within C and Go in the same 
 application. By far the easiest way to handle this is by using gccgo, which is a 
 frontend for GCC. This is different than the built-in Go compiler; it is possible to go 
 back and forth between C and Go without gccgo, but using it makes this process 
 much simpler.
  
 [
  105 
 ]",NA
Getting even lower – assembly in Go,"If you can shoot your foot off with C and you can blow your leg off with C++, just 
 imagine what you can do with assembly in Go.
  
 It isn't possible to use assembly directly in Go, but as Go provides access to C directly and 
 C provides the ability to call inline assembly, you can indirectly use it in Go.
  
 But again, just because something is possible doesn't mean it should be done—if you find 
 yourself in need of assembly in Go, you should consider using assembly directly and 
 connecting via an API.
  
 Among the many roadblocks that you may encounter with assembly in (C and then in) 
 Go is the lack of portability. Writing inline C is one thing—your code should be 
 relatively transferable between processor instruction sets and operating systems—but 
 assembly is obviously something that requires a lot of specificity.
  
 All that said, it's certainly better to have the option to shoot yourself in the foot whether 
 you choose to take the shot or not. Use great care when considering whether you need C 
 or assembly directly in your Go application. If you can get away with communicating 
 between dissonant processes through an API or interprocess conduit, always take that 
 route first.
  
 One very obvious drawback of using assembly in Go (or on its own or in C) is you lose 
 the cross-compilation capabilities that Go provides, so you'd have to modify your code 
 for every destination CPU architecture. For this reason, the only practical times to use 
 Go in C are when there is a single platform on which your application should run.
  
 Here's an example of what an ASM-in-C-in-Go application might look like. Keep in 
 mind that we've included no ASM code, because it varies from one processor type to 
 another. Experiment with some boilerplate assembly in the following 
 __asm__ 
 section:
  
 package main
  
 /*
  
 #include <stdio.h>
  
 void asmCall() {
  
 __asm__( """" );
  
  printf(""I come from a %s"",""C function with embedded asm\n"");
  
 [
  109 
 ]",NA
Distributed Go,"So far, we've talked quite a bit about managing data within single machines, though with 
 one or more cores. This is complicated enough as is. Preventing race conditions and 
 deadlocks can be hard to begin with, but what happens when you introduce more 
 machines (virtual or real) to the mix?
  
 [
  111 
 ]",NA
Some common consistency models,"Luckily, there are some non-core Go solutions and strategies that we can utilize to 
 improve our ability to control data consistency.
  
 Let's briefly look at a few consistency models that we can employ to manage our data 
 in distributed systems.",NA
Distributed shared memory,"On its own, a 
 Distributed Shared Memory
  (
 DSM
 ) system does not intrinsically 
 prevent race conditions, as it is merely a method for more than one system to share 
 real or partitioned memory.
  
 In essence, you can imagine two systems with 1 GB of memory, each allocating 500 MB to 
 a shared memory space that is accessible and writable by each. Dirty reads are possible as 
 are race conditions unless explicitly designed. The following figure is a visual 
 representation of how two systems can coordinate using shared memory:
  
  
 We'll look at one prolific but simple example of DSM shortly, and play with a library 
 available to Go for test driving it.
  
 [
  113 
 ]",NA
First-in-first-out – PRAM,"Pipelined RAM
  (
 PRAM
 ) consistency is a form of first-in-first-out methodology, in 
 which data can be read in order of the queued writes. This means that writes read 
 by any given, separate process may be different. The following figure represents 
 this concept:",NA
Looking at the master-slave model,"The master-slave consistency model is similar to the leader/follower model that we'll 
 look at shortly, except that the master manages all operations on data and broadcasts 
 rather than receiving write operations from a slave. In this case, replication is the primary 
 method of transmission of changes to data from the master to the slave. 
  
 In the following diagram, you will find a representation of the master-slave model with 
 a master server and four slaves:
  
  
 While we can simply duplicate this model in Go, we have more elegant solutions 
 available to us.
  
 [
  114 
 ]",NA
The producer-consumer problem,"In the classic producer-consumer problem, the producer writes chunks of data to a 
 conduit/buffer, while a consumer reads chunks. The issue arises when the buffer is full: 
 if the producer adds to the stack, the data read will not be what you intend. To avoid 
 this, we employ a channel with waits and signals. This model looks a bit like the 
 following figure:
  
  
 If you're looking for the semaphore implementation in Go, there is no explicit usage of the 
 semaphore. However, think about the language here—fixed-size channels with waits and 
 signals; sounds like a buffered channel. Indeed, by providing a buffered channel in Go, you 
 give the conduit here an explicit length; the channel mechanism gives you the 
 communication for waits and signals. This is incorporated in Go's concurrency model. 
 Let's take a quick look at a producer-consumer model as shown in the following code:
  
 package main
  
 import( 
  
  ""fmt"" 
  
 )
  
 var comm = make(chan bool)
  
 var done = make(chan bool)
  
 func producer() {
  
  for i:=0; i< 10; i++ {
  
  comm <- true
  
  }
  
 [
  115 
 ]",NA
Looking at the leader-follower model ,"In the leader/follower model, writes are broadcasted from a single source to any 
 followers. Writes can be passed through any number of followers or be restricted to 
 a single follower. Any completed writes are then broadcasted to the followers. 
  
 This can be visually represented as the following figure:
  
  
 We can see a channel analog here in Go as well. We can, and have, utilized a single 
 channel to handle broadcasts to and from other followers.
  
 [
  116 
 ]",NA
Atomic consistency / mutual exclusion,"We've looked at atomic consistency quite a bit. It ensures that anything that is not 
 created and used at essentially the same time will require serialization to guarantee 
 the strongest form of consistency. If a value or dataset is not atomic in nature, we can 
 always use a mutex to force linearizability on that data.
  
 Serial or sequential consistency is inherently strong, but can also lead to performance 
 issues and degradation of concurrency.
  
 Atomic consistency is often considered the strongest form of ensuring consistency.",NA
Release consistency,"The release consistency model is a DSM variant that can delay a write's 
 modifications until the time of first acquisition from a reader. This is known as 
 lazy release consistency. We can visualize lazy release consistency in the 
 following serialized model:
  
  
 This model as well as an eager release consistency model both require an 
  
 announcement of a release (as the name implies) when certain conditions are met. In 
 the eager model, that condition requires that a write would be read by all read 
 processes in a consistent manner.
  
 In Go, there exists alternatives for this, but there are also packages out there if 
 you're interested in playing with it.
  
 [
  117 
 ]",NA
Using memcached,"If you're not familiar with memcache(d), it's a wonderful and seemingly obvious way to 
 manage data across distributed systems. Go's built-in channels and goroutines are 
 fantastic to manage communication and data integrity within a single machine's 
 processes, but neither are built for distributed systems out of the box.
  
 Memcached, as the name implies, allows data sharing memory among multiple 
 instances or machines. Initially, memcached was intended to store data for quick 
 retrieval. This is useful for caching data for systems with high turnover such as web 
 applications, but it's also a great way to easily share data across multiple servers 
 and/or to utilize shared locking mechanisms.
  
 In our earlier models, memcached falls under DSM. All available and invoked 
 instances share a common, mirrored memory space within their respective 
 memories.
  
 It's worth pointing out that race conditions can and do exist within memcached, and you 
 still need a way to deal with that. Memcached provides one method to share data across 
 distributed systems, but does not guarantee data atomicity. Instead, memcached operates 
 on one of two methods for invalidating cached data as follows:
  
 • 
  
 • 
  
 Data is explicitly assigned a maximum age (after which, it is removed from the 
 stack)
  
 Or data is pushed from the stack due to all available memory being used by 
 newer data
  
 It's important to note that storage within memcache(d) is, obviously, ephemeral and not 
 fault resistant, so it should only be used where data should be passed without threat of 
 critical application failure.
  
 At the point where either of these conditions is met, the data disappears and the next 
 call to this data will fail, meaning the data needs to be regenerated. Of course, you can 
 work with some elaborate lock generation methods to make memcached operate in a 
 consistent manner, although this is not standard built-in functionality of memcached 
 itself. Let's look at a quick example of memcached in Go using Brad Fitz's gomemcache 
 interface (
 https://github.com/bradfitz/gomemcache
 ):
  
 package main
  
 import ( 
  
  
  ""github.com/bradfitz/gomemcache/memcache"" 
  
  ""fmt"" 
  
 )
  
 [
  118 
 ]",NA
Circuit,"An interesting third-party library to handle distributed concurrency that has 
 popped up recently is Petar Maymounkov's Go' circuit. Go' circuit attempts to 
 facilitate distributed coroutines by assigning channels to listen to one or more 
 remote goroutines.
  
 The coolest part of Go' circuit is that simply including the package makes your 
 application ready to listen and operate on remote goroutines and work with 
 channels with which they are associated.
  
 Go' circuit is in use at Tumblr, which proves it has some viability as a large-scale and 
 relatively mature solutions platform.
  
 [
  119 
 ]",NA
Summary,"Equipped now with some methods and models to manage not only local data across 
 single or multithreaded systems, but also distributed systems, you should start to 
 feel pretty comfortable with protecting the validity of data in concurrent and parallel 
 processes.
  
 We've looked at both forms of mutual exclusions for read and read/write locks, 
 and we have started to apply these to distributed systems to prevent blocks and 
 race conditions across multiple networked systems.
  
 In the next chapter, we'll explore these exclusion and data consistency concepts a 
 little deeper, building non-blocking networked applications and learn to work with 
 timeouts and give parallelism with channels a deeper look.
  
 We'll also dig a little deeper into the sync and OS packages, in particular looking at 
 the 
 sync.atomic
  operations.
  
 [
  121 
 ]",NA
"Locks, Blocks, and ",NA,NA
Better Channels,"Now that we're starting to get a good grasp of utilizing goroutines in safe and 
 consistent ways, it's time to look a bit more at what causes code blocking and 
 deadlocks. Let's also explore the 
 sync
  package and dive into some profiling and 
 analysis.
  
 So far, we've built some relatively basic goroutines and complementary channels, but we 
 now need to utilize some more complex communication channels between our 
 goroutines. To do this, we'll implement more custom data types and apply them directly 
 to channels.
  
 We've not yet looked at some of Go's lower-level tools for synchronization and 
 analysis, so we'll explore 
 sync.atomic
 , a package that—along with 
 sync. 
 Mutex
 —allows for more granular control over state.
  
 Finally, we'll delve into pprof, a fabulous tool provided by Go that lets us analyze our 
 binaries for detailed information about our goroutines, threads, overall heap, and 
 blocking profiles.
  
 Armed with some new tools and methods to test and analyze our code, we'll be 
 ready to generate a robust, highly-scalable web server that can be used to safely 
 and quickly handle any amount of traffic thrown at it.",NA
Understanding blocking methods in Go ,"So 
 far, we've encountered a few pieces of blocking code, intentional and unintentional, 
 through our exploration and examples. At this point, it's prudent to look at the various 
 ways we can introduce (or inadvertently fall victim to) blocking code.
  
 By looking at the various ways Go code can be blocked, we can also be better prepared to 
 debug cases when concurrency is not operating as expected in our application.",NA
"Blocking method 1 – a listening, waiting ",NA,NA
channel ,"The most concurrently-focused way to block your code is by leaving a serial channel 
 listening to one or more goroutines. We've seen this a few times by now, but the 
 basic concept is shown in the following code snippet:
  
 func thinkAboutKeys() {
  
  
  for {
  
  
  fmt.Println(""Still Thinking"")
  
  
  time.Sleep(1 * time.Second)
  
  
  } 
  
 }
  
 func main() {
  
  
  fmt.Println(""Where did I leave my keys?"")
  
  blockChannel := make(chan int)
  
  go thinkAboutKeys()
  
  <-blockChannel
  
  
  fmt.Println(""OK I found them!"") 
  
 }
  
 [
  124 
 ]",NA
Sending more data types via channels,"Go's use of channels (structs and functions) as first-class citizens provides us 
 with a lot of interesting ways of executing, or at least trying, new approaches of 
 communication between channels.
  
 One such example is to create a channel that handles translation through a function 
 itself, and instead of communicating directly through the standard syntax, the channel 
 executes its function. You can even do this on a slice/array of functions iterating through 
 them in the individual functions.
  
 [
  125 
 ]",NA
Creating a function channel ,"So far, we've almost exclusively worked in single data type and single value channels. 
 So, let's try sending a function across a channel. With first-class channels, we need no 
 abstraction to do this; we can just send almost anything directly over a channel as 
 shown in the following code snippet:
  
 func abstractListener(fxChan chan func() string ) {
  
  fxChan <- func() string {
  
  
  return ""Sent!""
  
  
  } 
  
 }
  
 func main() {
  
  fxChan := make (chan func() string)
  
  defer close(fxChan)
  
  go abstractListener(fxChan)
  
  select {
  
  case rfx := <- fxChan:
  
  msg := rfx()
  
  fmt.Println(msg)      
  
  fmt.Println(""Received!"")
  
  }
  
 }
  
 This is like a callback function. However, it also is intrinsically different, as it is not just 
 the method called after the execution of a function, but also serves as the mode of 
 communication between functions.
  
 Keep in mind that there are often alternatives to passing functions across channels, so 
 this will likely be something very specific to a use case rather than a general practice.
  
 Since your channel's type can be virtually any available type, this functionality opens 
 up a world of possibilities, which can be potentially confusing abstractions. A struct or 
 interface as a channel type is pretty self-explanatory, as you can make application-
 related decisions on any of its defined properties.
  
 Let's see an example of using an interface in this way in the next section.
  
 [
  126 
 ]",NA
Using an interface channel ,"As with our function channel, being able to pass an interface (which is a 
 complementary data type) across a channel can be incredibly useful. Let's look at 
 an example of sending across an interface:
  
 type Messenger interface 
 {
  
  
  Relay() string 
  
 }
  
 type Message struct {
  
  
  status string 
  
 }
  
 func (m Message) Relay() string {
  
  
  return m.status 
  
 }
  
 func alertMessages(v chan Messenger, i int) {
  
  
  m := new(Message)
  
  
  m.status = ""Done with "" + 
 strconv.FormatInt(int64(i),10)
  
  v <- m 
  
 }
  
 func main () {
  
  msg := make(chan Messenger)
  
  for i:= 0; i < 10; i++ {
  
  go alertMessages(msg,i)
  
  }
  
  
  select {
  
  
  case message := <-msg:
  
    
  fmt.Println (message.Relay())
  
  
  }
  
  
  <- msg 
  
 }
  
 This is a very basic example of how to utilize interfaces as channels; in the previous 
 example, the interface itself is largely ornamental. In actuality, we're passing newly-
 created message types through the interface's channel rather than interacting directly 
 with the interface.
  
 [
  127 
 ]",NA
"Using structs, interfaces, and more complex channels","Creating a custom type for our channel allows us to dictate the way our intra-channel 
 communication will work while still letting Go dictate the context switching and behind-
 the-scenes scheduling.
  
 Ultimately, this is mostly a design consideration. In the previous examples, we used 
 individual channels for specific pieces of communication in lieu of a one-size-fits-all 
 channel that passes a multitude of data. However, you may also find it advantageous to 
 use a single channel to handle a large amount of communication between 
  
 goroutines and other channels.
  
 The primary consideration in deciding whether to segregate channels into individual bits 
 of communication or a package of communications depends on the aggregate mutability 
 of each.
  
 For example, if you'll always want to send a counter along with a function or string and 
 they will always be paired in terms of data consistency, such a method might make 
 sense. If any of those components can lose synchronicity en route, it's more logical to 
 keep each piece independent.
  
  
 Maps in Go
  
  
 As mentioned, maps in Go are like hash tables elsewhere and 
  
 immediately related to slices or arrays.
  
 In the previous example we were checking to see if a username/
  
 key exists already; for this purpose Go provides a simple method for 
  
 doing so. When attempting to retrieve a hash with a nonexistent key, 
  
 a zero value is returned, as shown in the following lines of code:
  
 if Users[user.name] {
  
  fmt.Fprintln(conn, ""Unfortunately, that username 
  
 is in 
  
  use!"");
  
 }
  
 This makes it syntactically simple and clean to test against a map 
  
 and its keys.
  
 One of the best features of maps in Go is the ability to make keys out 
  
 of any comparable type, which includes strings, integers, Booleans 
  
 as well as any map, struct, slice, or channel that is comprised 
  
 exclusively of those types.
  
 This one-to-many channel can work as a master-slave or broadcaster-subscriber model. 
 We'll have a channel that listens for messages and routes them to appropriate users and a 
 channel that listens for broadcast messages and queues them to all users.
  
 [
  128 
 ]",NA
The net package – a chat server with interfaced ,NA,NA
channels,"Here, we'll need to introduce a relevant package that will be required to handle most of 
 the communication for our application(s). We've touched on the 
 net
  package a bit while 
 dabbling in the SVG output generation example to show concurrency—
 net
 / 
 http
  is just a 
 small part of a broader, more complex, and more feature-full package.
  
 The basic components that we'll be using will be a TCP listener (server) and a TCP 
 dialer (client). Let's look at the basic setup for these.
  
 Server
  
 Listening on a TCP port couldn't be easier. Simply initiate the 
 net.Listen() 
 method and handle the error as shown in the following lines of code:
  
  listener, err := net.Listen(""tcp"", "":9000"")
  
  if err != nil {
  
  fmt.Println (""Could not start server!"")
  
  }
  
 If you get an error starting the server, check your firewall or modify the port—it's 
 possible that something is utilizing port 9000 on your system.
  
 As easy as that is, it's just as simple on our client/dialer side.
  
 Client
  
 In this case, we have everything running on localhost as shown in the following lines of 
 code. However, in a real-world application we'd probably have an intranet address 
 used here:
  
  conn, err := net.Dial(""tcp"",""127.0.0.1:9000"")
  
  if err != nil {
  
  fmt.Println(""Could not connect to server!"")
  
  }
  
 In this application, we demonstrate two different ways to handle byte buffers of 
 unknown lengths on 
 Read()
 . The first is a rather crude method of trimming a string 
 using 
 strings.TrimRight()
 . This method allows you to define characters you aren't 
 interested in counting as part of the input as shown in the following line of code. Mostly, 
 it's whitespace characters that we can assume are unused parts of the buffer length.
  
 sendMessage := []byte(cM.name + "": "" + 
  
  
  strings.TrimRight(string(buf),"" \t\r\n""))
  
 [
  130 
 ]",NA
Handling direct messages,"For the most part, this chat client is a simple echo server, but as mentioned, we also 
 include an ability to do non-globally broadcast messages by invoking the Twitter style 
 @
  syntax.
  
 We handle this mainly through regular expressions, wherein if a message matches 
 @user
  then only that user will see the message; otherwise, it's broadcasted to all. This is 
 somewhat inelegant, because senders of the direct message will not see their own direct 
 message if their usernames do not match the intended names of the users.
  
 [
  131 
 ]",NA
Examining our client ,"Our client application is a bit simpler primarily because we don't care as much 
 about blocking code.
  
 While we do have two concurrent operations (wait for the message and wait for user 
 input to send the message), this is significantly less complicated than our server, 
 which needs to concurrently listen to each created user and distribute sent 
 messages, respectively.
  
 Let's now compare our chat client to our chat server. Obviously, the client has less 
 overall maintenance of connections and users, and so we do not need to use nearly as 
 many channels. Let's take a look at our chat client's code:
  
 chat-client.go
  
 package main
  
 import 
  
 ( 
  
  
  ""fmt"" 
  
  
  ""net"" 
  
  
  ""os"" 
  
  
  ""bufio"" 
  
  
  ""strings"" 
  
 )
  
 [
  137 
 ]",NA
Blocking method 2 – the select statement in ,NA,NA
a loop ,"Have you noticed yet that the 
 select
  statement itself blocks? Fundamentally, the 
 select
  statement is not different from an open listening channel; it's just wrapped in 
 conditional code.
  
 [
  139 
 ]",NA
Cleaning up goroutines,"Any channel that is left waiting and/or left receiving will result in a deadlock. Luckily, 
 Go is pretty adept at recognizing these and you will almost without fail end up in a 
 panic when running or building the application.
  
 Many of our examples so far have utilized the deferred 
 close()
  method of 
 immediately and cleanly grouping together similar pieces of code that should 
 execute at different points.
  
 While garbage collection handles a lot of the cleanup, we're largely left to take care of 
 open channels to ensure we don't have a process waiting to receive and/or something 
 waiting to send, both waiting at the same time for each other. Luckily, we'll be unable 
 to compile any such program with a detectable deadlock condition, but we also need to 
 manage closing channels that are left waiting.
  
 Quite a few of the examples so far have ended with a generic integer or Boolean 
 channel that just waits—this is employed almost exclusively for the channel's 
 blocking effect and allows us to demonstrate the effects and output of concurrent 
 code while the application is still running. In many cases, this generic channel is an 
 unnecessary bit of syntactical cruft as shown in the following lines of code:
  
 <-youMayNotNeedToDoThis
  
 close(youmayNotNeedToDoThis)
  
 The fact that there's no assignment happening is a good indicator this is an example of 
 such cruft. If we had instead modified that to include an assignment, the previous code 
 would be changed to the following instead:
  
 v := <-youMayNotNeedToDoThis
  
 It might indicate that the value is useful and not just arbitrary blocking code.
  
 [
  140 
 ]",NA
Blocking method 3 – network connections ,NA,NA
and reads,"If you run the code from our earlier chat server's client without starting the server, you'll 
 notice that the 
 Dial
  function blocks any subsequent goroutine. We can test this by 
 imposing a longer-than-normal timeout on the connection or by simply closing the client 
 application after logging in, as we did not implement a method for closing the TCP 
 connection.
  
 As the network reader we're using for the connection is buffered, we'll always have a 
 blocking mechanism while waiting for data via TCP.",NA
Creating channels of channels,"The preferred and sanctioned way of managing concurrency and state is exclusively 
 through channels.
  
 We've demonstrated a few more complex types of channels, but we haven't looked at 
 what can become a daunting but powerful implementation: channels of channels. This 
 might at first sound like some unmanageable wormhole, but in some situations we want 
 a concurrent action to generate more concurrent actions; thus, our 
  
 goroutines should be capable of spawning their own.
  
 As always, the way you manage this is through design while the actual code may simply 
 be an aesthetic byproduct here. Building an application this way should make your code 
 more concise and clean most of the time.
  
 Let's revisit a previous example of an RSS feed reader to demonstrate how we could 
 manage this, as shown in the following code:
  
 package main
  
 import (
  
  ""fmt""
  
 )
  
 type master chan Item
  
 var feedChannel chan master
  
 var done chan bool
  
 [
  141 
 ]",NA
Pprof – yet another awesome tool,"Just when you think you've seen the entire spectrum of Go's amazing tool set, there's 
 always one more utility that, once you realize it exists, you'll wonder how you ever 
 survived without it.
  
 Go format is great for cleaning up your code; the 
 -race
  flag is essential for detecting 
 possible race conditions, but an even more robust, hands-in-the-dirt tool exists that is 
 used to analyze your final application, and that is pprof.
  
 Google created pprof initially to analyze loop structures and memory allocation 
 (and related types) for C++ applications.
  
 It's particularly useful if you think you have performance issues not uncovered by the 
 testing tools provided in the Go runtime. It's also a fantastic way to generate a visual 
 representation of the data structures in any application.
  
 Some of this functionality also exists as part of the Go testing package and its 
 benchmarking tools—we'll explore that more in 
 Chapter 7
 , 
 Performance and Scalability
 .
  
 Getting the runtime version of pprof to work requires a few pieces of setup first. 
 We'll need to include the 
 runtime.pprof
  package and the 
 flag
  package, which 
 allows command-line parsing (in this case, for the output of pprof).
  
 [
  143 
 ]",NA
Handling deadlocks and errors,"Anytime you encounter a deadlock error upon compilation in your code, you'll see the 
 familiar string of semi-cryptic errors explaining which goroutine was left holding the bag, 
 so to speak.
  
 However, keep in mind you always have the ability to invoke your own panic using 
 Go's built-in panic, and this can be incredibly useful for building your own error-
 catching safeguards to ensure data consistency and ideal operation. The code is as 
 follows:
  
 package main
  
 import 
  
 ( 
  
  
  ""os"" 
  
 )
  
 func main() {
  
  panic(""Oh No, we forgot to write a program!"")
  
  os.Exit(1)
  
 }
  
 This can be utilized anywhere you wish to give detailed exit information to either 
 developers or end users.
  
 [
  150 
 ]",NA
Summary,"Having explored some new ways to examine the way that Go code can block and 
 deadlock, we also have some tools at our disposal that can be used to examine CPU 
 profiles and resource usage now.
  
 Hopefully, by this point, you can build some complex concurrent systems with simple 
 goroutines and channels all the way up to multiplexed channels of structs, interfaces, 
 and other channels.
  
 We've built some somewhat-functional applications so far, but next we're going to 
 utilize everything we've done to build a usable web server that solves a classic 
 problem and can be used to design intranets, file storage systems, and more.
  
 In the next chapter, we'll take what we've done in this chapter with regard to 
 extensible channels and apply it to solving one of the oldest challenges the Internet has 
 to offer: concurrently serving 10,000 (or more) connections.
  
 [
  151 
 ]",NA
C10K – A Non-blocking ,NA,NA
Web Server in Go,"Up to this point, we've built a few usable applications; things we can start with and 
 leapfrog into real systems for everyday use. By doing so, we've been able to 
 demonstrate the basic and intermediate-level patterns involved in Go's concurrent 
 syntax and methodology.
  
 However, it's about time we take on a real-world problem—one that has vexed 
 developers (and their managers and VPs) for a great deal of the early history of the 
 Web.
  
 In addressing and, hopefully, solving this problem, we'll be able to develop a high-
 performance web server that can handle a very large volume of live, active traffic.
  
 For many years, the solution to this problem was solely to throw hardware or 
 intrusive caching systems at the problem; so, alternately, solving it with 
 programming methodology should excite any programmer.
  
 We'll be using every technique and language construct we've learned so far, but we'll do 
 so in a more structured and deliberate way than we have up to now. Everything we've 
 explored so far will come into play, including the following points:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 Creating a visual representation of our concurrent application 
  
 Utilizing goroutines to handle requests in a way that will scale 
  
 Building robust channels to manage communication between goroutines and the 
 loop that will manage them 
  
 Profiling and benchmarking tools (JMeter, ab) to examine the way our event 
 loop actually works 
  
 Timeouts and concurrency controls—when necessary—to ensure data and 
 request consistency",NA
Attacking the C10K problem,"The genesis of the C10K problem is rooted in serial, blocking programming, which 
 makes it ideal to demonstrate the strength of concurrent programming, especially in 
 Go.
  
 The proposed problem came from developer Dan Kegel, who famously asked:
  
 It's time for web servers to handle ten thousand clients simultaneously, don't you 
 think? After all, the web is a big place now.
  
 - Dan Kegel (http://www.kegel.com/c10k.html)
  
 When he asked this in 1999, for many server admins and engineers, serving 10,000 
 concurrent visitors was something that would be solved with hardware. The notion that 
 a single server on common hardware could handle this type of CPU and network 
 bandwidth without falling over seemed foreign to most.
  
 The crux of his proposed solutions relied on producing non-blocking code. Of course, 
 in 1999, concurrency patterns and libraries were not widespread. C++ had some 
 polling and queuing options available via some third-party libraries and the earliest 
 predecessor to multithreaded syntaxes, later available through Boost and then C++11.
  
 Over the coming years, solutions to the problem began pouring in across various flavors 
 of languages, programming design, and general approaches. At the time of publishing 
 this book, the C10K problem is not one without solutions, but it is still an excellent 
 platform to conduct a very real-world challenge to high-performance Go.
  
 Any performance and scalability problem will ultimately be bound to the underlying 
 hardware, so as always, your mileage may vary. Squeezing 10,000 concurrent connections 
 on a 486 processor with 500 MB of RAM will certainly be more 
  
 challenging than doing so on a barebones Linux server stacked with memory and multiple 
 cores.
  
 It's also worth noting that a simple echo server would obviously be able to assume 
 more cores than a functional web server that returns larger amounts of data and 
 accepts greater complexity in requests, sessions, and so on, as we'll be dealing with 
 here.
  
 [
  154 
 ]",NA
"Failing of servers at 10,000 concurrent ",NA,NA
connections,"As you may recall, when we discussed concurrent strategies back in 
 Chapter 3
 , 
 Developing a Concurrent Strategy
 , we talked a bit about Apache 
 and its load-balancing tools.
  
 When the Web was born and the Internet commercialized, the level of interactivity 
 was pretty minimal. If you're a graybeard, you may recall the transition from 
 NNTP/IRC and the like and how extraordinarily rudimentary the Web was.
  
 To address the basic proposition of [page request] → [HTTP response], the 
 requirements on a web server in the early 1990s were pretty lenient. Ignoring 
 all of the error responses, header readings and settings, and other essential (but 
 unrelated to the in → out mechanism) functions, the essence of the early servers 
 was shockingly simple, at least compared to the modern web servers.
  
  
 The first web server was developed by the father of the Web, Tim 
  
  
 Berners-Lee.
  
 Developed at CERN (such as WWW/HTTP itself), CERN httpd 
  
 handled many of the things you would expect in a web server 
  
 today—hunting through the code, you'll find a lot of notation 
  
 that will remind you that the very core of the HTTP protocol is 
  
 largely unchanged. Unlike most technologies, HTTP has had an 
  
 extraordinarily long shelf life.
  
 Written in C in 1990, it was unable to utilize a lot of concurrency 
  
 strategies available in languages such as Erlang. Frankly, doing 
  
 so was probably unnecessary—the majority of web traffic was a 
  
 matter of basic file retrieval and protocol. The meat and potatoes 
  
 of a web server were not dealing with traffic, but rather dealing 
  
 with the rules surrounding the protocol itself.
  
 You can still access the original CERN httpd site and download 
  
 the source code for yourself from 
 http://www.w3.org/
  
 Daemon/
 . I highly recommend that you do so as both a history 
  
 lesson and a way to look at the way the earliest web server 
  
 addressed some of the earliest problems.
  
 However, the Web in 1990 and the Web when the C10K question was first posed 
 were two very different environments.
  
 [
  155 
 ]",NA
Using concurrency to attack C10K,"There are two primary approaches to handle a large volume of concurrent requests. 
 The first involves allocating threads per connection. This is what Apache (and a few 
 others) do.
  
 On the one hand, allocating a thread to a connection makes a lot of sense—it's 
 isolated, controllable via the application's and kernel's context switching, and can 
 scale with increased hardware.
  
 [
  156 
 ]",NA
Taking another approach,"In an attempt to create our web server that can handle 10,000 concurrent connections, 
 we'll obviously leverage our goroutine/channel mechanism to put an event loop in front 
 of our content delivery to keep new channels recycled or created constantly.
  
 For this example, we'll assume we're building a corporate website and infrastructure for 
 a rapidly expanding company. To do this, we'll need to be able to serve both static and 
 dynamic content.
  
 The reason we want to introduce dynamic content is not just for the purposes of 
 demonstration—we want to challenge ourselves to show 10,000 true concurrent 
 connections even when a secondary process gets in the way.
  
 As always, we'll attempt to map our concurrency strategy directly to goroutines and 
 channels. In a lot of other languages and applications, this is directly analogous to an 
 event loop, and we'll approach it as such. Within our loop, we'll manage the available 
 goroutines, expire or reuse completed ones, and spawn new ones where necessary.
  
 In this example visualization, we show how an event loop (and corresponding 
 goroutines) can allow us to scale our connections without employing too many 
 hard
  resources such as CPU threads or RAM:
  
 Requests
  
  
  
  
  
 Event Loop
  
 Server
  
 (goroutines)
  
  
  
  
  
 [
  158 
 ]",NA
Building our C10K web server,"Our web server will be responsible for taking requests, routing them, and serving 
 either flat files or dynamic files with templates parsed against a few different data 
 sources.
  
 As mentioned earlier, if we exclusively serve flat files and remove much of the 
 processing and network latency, we'd have a much easier time with handling 10,000 
 concurrent connections.
  
 Our goal is to approach as much of a real-world scenario as we can—very little of the Web 
 operates on a single server in a static fashion. Most websites and applications utilize 
 databases, 
 CDNs
  (
 Content Delivery Networks
 ), dynamic and uncached template parsing, 
 and so on. We need to replicate them whenever possible.
  
 For the sake of simplicity, we'll separate our content by type and filter them through 
 URL routing, as follows:
  
 • 
  
 • 
  
 • 
  
 /static/[request]
 : This will serve 
 request.html
  directly
  
 /template/[request]
 : This will serve 
 request.tpl
  after its been parsed 
 through Go
  
 /dynamic/[request][number]
 : This will also serve 
 request.tpl
  and parse it 
 against a database source's record
  
 By doing this, we should get a better mixture of possible HTTP request types that 
 could impede the ability to serve large numbers of users simultaneously, especially in 
 a blocking web server environment.
  
 We'll utilize the 
 html/template
  package to do parsing—we've briefly looked at the 
 syntax before, and going any deeper is not necessarily part of the goals of this book. 
 However, you should look into it if you're going to parlay this example into something you 
 use in your environment or have any interest in building a framework.
  
  
 You can find Go's exceptional library to generate safe data-driven 
  
  
 templating at 
 http://golang.org/pkg/html/template/
 .
  
 [
  159 
 ]",NA
Benchmarking against a blocking web server,"It's only fair to add some starting benchmarks against a blocking web server first so 
 that we can measure the effect of concurrent versus nonconcurrent architecture.
  
 For our starting benchmarks, we'll eschew any framework, and we'll go with our old 
 stalwart, Apache.
  
 For the sake of completeness here, we'll be using an Intel i5 3GHz machine with 8 GB of 
 RAM. While we'll benchmark our final product on Ubuntu, Windows, and OS X here, we'll 
 focus on Ubuntu for our example.
  
 Our localhost domain will have three plain HTML files in 
 /static
 , each trimmed to 80 
 KB. As we're not using a framework, we don't need to worry about raw dynamic 
 requests, but only about static and dynamic requests in addition to data source 
 requests.
  
 For all examples, we'll use a MySQL database (named 
 master
 ) with a table called 
 articles
  that will contain 10,000 duplicate entries. Our structure is as follows:
  
 CREATE TABLE articles (
  
  article_id INT NOT NULL AUTO_INCREMENT,
  
  article_title VARCHAR(128) NOT NULL,
  
  article_text VARCHAR(128) NOT NULL,
  
  PRIMARY KEY (article_id)
  
 )
  
 With ID indexes ranging sequentially from 0-10,000, we'll be able to generate random 
 number requests, but for now, we just want to see what kind of basic response we can get 
 out of Apache serving static pages with this machine.
  
 For this test, we'll use Apache's ab tool and then gnuplot to sequentially map the 
 request time as the number of concurrent requests and pages; we'll do this for our 
 final product as well, but we'll also go through a few other benchmarking tools for it to 
 get some better details.
  
 [
  160 
 ]",NA
Handling requests,"In an earlier chapter, we handled URL routing with Gorilla, a compact but feature-full 
 framework. The Gorilla toolkit certainly makes this easier, but we should also know how 
 to intercept the functionality to impose our own custom handler.
  
 Here is a simple web router wherein we handle and direct requests using a custom 
 http.Server
  struct, as shown in the following code:
  
 var routes []string
  
 type customRouter struct {
  
 }
  
 func (customRouter) ServeHTTP(rw http.ResponseWriter, r 
  
  
 *http.Request) {
  
  
  
 fmt.Println(r.URL.Path); 
  
 }
  
 func main() {
  
  var cr customRouter;
  
  server := &http.Server {
  
  Addr: "":9000"",
  
  Handler:cr,
  
  ReadTimeout: 10 * time.Second,
  
  WriteTimeout: 10 * time.Second,
  
  MaxHeaderBytes: 1 << 20,
  
  }
  
  
  server.ListenAndServe() 
  
 }
  
 [
  162 
 ]",NA
Routing requests,"So, let's take a step back and look again at routing our traffic through a traditional web 
 server to include not only our static content, but also the dynamic content.
  
 [
  165 
 ]",NA
Serving pages,"First up are our static pages. While we handled this the idiomatic way earlier, there 
 exists the ability to rewrite our requests, better handle specific 404 error pages, and so 
 on by using the 
 http.ServeFile
  function, as shown in the following code:
  
  path := r.URL.Path;
  
  staticPatternString := ""static/(.*)""
  
  templatePatternString := ""template/(.*)""
  
  dynamicPatternString := ""dynamic/(.*)""
  
  staticPattern := regexp.MustCompile(staticPatternString)
  
  templatePattern := regexp.MustCompile(templatePatternString)
  
  dynamicDBPattern := regexp.MustCompile(dynamicPatternString)
  
  if staticPattern.MatchString(path) {
  
  page := staticPath + staticPattern.ReplaceAllString(path,  
  
  
 ""${1}"") + "".html""
  
  http.ServeFile(rw, r, page)
  
  }
  
 Here, we simply relegate all requests starting with 
 /static/(.*)
  to match the 
 request in addition to the 
 .html
  extension. In our case, we've named our test file (the 
 80 KB example file) 
 test.html
 , so all requests to it will go to 
 /static/test
 .
  
 We've prepended this with 
 staticPath
 , a constant defined upcode. In our case, it's 
 /var/www/
 , but you'll want to modify it as necessary.
  
 [
  166 
 ]",NA
Parsing our template,"In our next phase, we'll measure the impact of reading and parsing a template. To 
 effectively match the previous tests, we'll take our HTML static file and impose some 
 variables on it.
  
 [
  167 
 ]",NA
External dependencies,"Finally, we need to bring in our biggest potential bottleneck, which is the database. As 
 mentioned earlier, we'll simulate random traffic by generating a random integer 
 between 1 and 10,000 to specify the article we want.
  
 Randomization isn't just useful on the frontend—we'll want to work around any 
 query caching within MySQL itself to limit nonserver optimizations.",NA
Connecting to MySQL,"We can route our way through a custom connection to MySQL using native Go, but as is 
 often the case, there are a few third-party packages that make this process far less 
 painful. Given that the database here (and associated libraries) is tertiary to the 
 primary exercise, we'll not be too concerned about the particulars here.
  
 The two mature MySQL driver libraries are as follows:
  
 • 
  
 Go-MySQL-Driver
  (
 https://github.com/go-sql-driver/mysql
 )
  
 • 
  
 MyMySQL
  (
 https://github.com/ziutek/mymysql
 )
  
 For this example, we'll go with the Go-MySQL-Driver. We'll quickly install it using the 
 following command:
  
 go get github.com/go-sql-driver/mysql
  
 [
  171 
 ]",NA
Multithreading and leveraging multiple ,NA,NA
cores,"You may be wondering how performance may vary when invoking additional processor 
 cores—as mentioned earlier, this can sometimes have an unexpected effect.
  
 In this case, we should expect only improved performance in our dynamic requests and 
 static requests. Any time the cost of context switching in the OS might outweigh the 
 performance advantages of additional cores, we can see paradoxical performance 
 degradation. In this case, we do not see this effect and instead see a relatively similar line, 
 as shown in the following graph:",NA
Exploring our web server,"Our final web server is capable of serving static, template-rendered, and dynamic 
 content well within the confines of the goal of 10,000 concurrent connections on 
 even the most modest of hardware.
  
 The code—much like the code in this book—can be considered a jumping-off point and 
 will need refinement if put into production. This server lacks anything in the form of 
 error handling but can ably serve valid requests without any issue. Let's take a look at 
 the following server's code:
  
 package main
  
 impor
 t 
  
 (
  
 [
  174 
 ]",NA
Timing out and moving on,"One thing we did not focus on in our server is the notion of lingering connection 
 mitigation. The reason we didn't worry much about it is because we were able to hit 
 10,000 concurrent connections in all three approaches without too much issue, 
 strictly by utilizing Go's powerful built-in concurrency features.
  
 [
  178 
 ]",NA
Summary,"The C10K problem may seem like a relic today, but the call to action was 
 symptomatic of the type of approaches to systems' applications that were 
 primarily employed prior to the rapid expansion of concurrent languages 
 and application design.
  
 Just 15 years ago, this seemed a largely insurmountable problem facing systems 
 and server developers worldwide; now, it's handled with only minor tweaking and 
 consideration by a server designer.
  
 Go makes it easy to get there (with a little effort), but reaching 10,000 (or 100,000 or 
 even 1,000,000) concurrent connections is only half the battle. We must know what to 
 do when problems arise, how to seek out maximum performance and responsiveness 
 out of our servers, and how to structure our external dependencies such that they do 
 not create roadblocks.
  
 In our next chapter, we'll look at squeezing even more performance out of our 
 concurrent applications by testing some distributed computing patterns and best 
 utilizing memory management.
  
 [
  180 
 ]",NA
Performance and Scalability,"To build a high-powered web server in Go with just a few hundred lines of code, you 
 should be quite aware of how concurrent Go provides us with exceptional tools for 
 performance and stability out of the box.
  
 Our example in 
 Chapter 6
 , 
 C10K – A Non-blocking Web Server in Go
 , also showed how 
 imposing blocking code arbitrarily or inadvertently into our code can introduce some 
 serious bottlenecks and quickly torpedo any plans to extend or scale your application.
  
 What we'll look at in this chapter are a few ways that can better prepare us to take our 
 concurrent application and ensure that it's able to continuously scale in the future and 
 that it is capable of being expanded in scope, design, and/or capacity.
  
 We'll expand a bit on 
 pprof
 , the CPU profiling tool we looked at briefly in previous 
 chapters, as a way to elucidate the way our Go code is compiled and to locate possible 
 unintended bottlenecks.
  
 Then we'll expand into distributed Go and into ways to offer some performance-
 enhancing parallel-computing concepts to our applications. We'll also look at the 
 Google App Engine, and at how you can utilize it for your Go-based applications to 
 ensure scalability is placed in the hands of one of the most reliable hosting 
 infrastructures in the world.
  
 Lastly, we'll look at memory utilization, preservation, and how Google's garbage 
 collector works (and sometimes doesn't). We'll finally delve a bit deeper into using 
 memory caching to keep data consistent as well as less ephemeral, and we will also see 
 how that dovetails with distributed computing in general.",NA
High performance in Go,"Up to this point, we've talked about some of the tools we can use to help discover 
 slowdowns, leaks, and inefficient looping.
  
 Go's compiler and its built-in deadlock detector keep us from making the kind of 
 mistake that's common and difficult to detect in other languages.
  
 We've run time-based benchmarks based on specific changes to our concurrency 
 patterns, which can help us design our application using different methodologies to 
 improve overall execution speed and performance.",NA
Getting deeper into pprof,"The pprof tool was first encountered in 
 Chapter 5
 , 
 Locks, Blocks, and Better Channels
 , and 
 if it still feels a bit cryptic, that's totally understandable. What pprof shows you in export 
 is a 
 call graph
 , and we can use this to help identify issues with loops or expensive calls 
 on the heap. These include memory leaks and processor-intensive methods that can be 
 optimized.
  
 One of the best ways to demonstrate how something like this works is to build 
 something that doesn't. Or at least something that doesn't work the way it should.
  
 You might be thinking that a language with garbage collection might be immune to these 
 kinds of memory issues, but there are always ways to hide mistakes that can lead to 
 memory leakage. If the GC can't find it, it can sometimes be a real pain to do so yourself, 
 leading to a lot of—often feckless—debugging.
  
 To be fair, what constitutes a memory leak is sometimes debated among computer 
 science members and experts. A program that continuously consumes RAM may not be 
 leaking memory by technical definition if the application itself could re-access any given 
 pointers. But that's largely irrelevant when you have a program that crashes and burns 
 after consuming memory like an elephant at a buffet.
  
 The basic premise of creating a memory leak in a garbage-collected language relies on 
 hiding the allocation from the compiler—indeed, any language in which you can access 
 and utilize memory directly provides a mechanism for introducing leaks.
  
 We'll review a bit more about garbage collection and Go's implementation later in this 
 chapter.
  
 So how does a tool like pprof help? Very simply put, by showing you 
 where
  your 
 memory and CPU utilization goes.
  
 [
  182 
 ]",NA
Parallelism's and concurrency's impact on ,NA,NA
I/O pprof ,"One issue you'll likely run into pretty quickly when using pprof is when you've 
 written a script or application that is especially bound to efficient runtime 
 performance. This happens most frequently when your program executes too 
 quickly to properly profile.
  
 A related issue involves network applications that require connections to profile; in 
 this case, you can simulate traffic either in-program or externally to allow proper 
 profiling.
  
 We can demonstrate this easily by replicating something like the preceding example 
 with goroutines as follows:
  
 const TESTLENGTH = 20000
  
 type DataType struct 
 {
  
  
  a,b,c,d,e,f,g int64
  
  
  longByte []byte  
  
 }
  
 func (dt DataType) init() {
  
 }
  
 var profile = flag.String(""cpuprofile"", """", ""output pprof data to 
  
  file"")
  
 func main() {
  
  flag.Parse()
  
  if *profile != """" {
  
  
  flag,err := os.Create(*profile)
  
  
  if err != nil {
  
    
  fmt.Println(""Could not create profile"",err)
  
  }
  
  
  pprof.StartCPUProfile(flag)
  
  
  defer pprof.StopCPUProfile()
  
  }
  
 [
  188 
 ]",NA
main.func·001 ,NA,NA
1298 (99.6%),"It's not nearly as informative, is it?
  
 [
  189 
 ]",NA
Using the App Engine,"While not right for every project, Google's App Engine can open up a world of 
 scalability when it comes to concurrent applications, without the hassle of VM 
 provisioning, reboots, monitoring, and so on.
  
 The App Engine is not entirely dissimilar to Amazon Web Services, DigitalOcean, and 
 the ilk, except for the fact that you do not need to necessarily involve yourself in the 
 minute details of direct server setup and maintenance. All of them provide a single 
 spot to acquire and utilize virtual computing resources for your applications.
  
 Rather, it can be a more abstract environment within Google's architecture with which 
 to house and run your code in a number of languages, including—no surprise here—the 
 Go language itself.
  
 While large-scale apps will cost you, Google provides a free tier with reasonable 
 quotas for experimentation and small applications.
  
 The benefits as they relate to scalability here are two-fold: you're not responsible for 
 ensuring uptime on the instances as you would be in an AWS or DigitalOcean scenario. 
 Who else but Google will have not only the architecture to support anything you can 
 throw at it, but also have the fastest updates to the Go core itself?
  
 There are some obvious limitations here that coincide with the advantages, of course, 
 including the fact that your core application will be available exclusively via 
 http 
 (although it will have access to plenty of other services).
  
  
 To deploy apps to the App Engine, you'll need the SDK for Go, 
  
  
 available for Mac OS X, Linux, and Windows, at 
 https://
  
 developers.google.com/appengine/downloads#Google_
  
 App_Engine_SDK_for_Go
 .
  
 Once you've installed the SDK, the changes you'll need to make to your code are 
 minor—the most noteworthy point is that for most cases, your Go tool command will 
 be supplanted by 
 goapp
 , which handles serving your application locally and then 
 deploying it.
  
 [
  191 
 ]",NA
Distributed Go,"We've certainly covered a lot about concurrent and parallel Go, but one of the biggest 
 infrastructure challenges for developers and system architects today has to do with 
 cooperative computing.
  
 Some of the applications and designs that we've mentioned previously scale from 
 parallelism to distributed computing.
  
 Memcache(d) is a form of in-memory caching, which can be used as a queue among 
 several systems.
  
 Our master-slave and producer-consumer models we presented in 
 Chapter 4
 , 
 Data 
 Integrity in an Application
 , have more to do with distributed computing than single-
 machine programming in Go, which manages concurrency idiomatically. These models 
 are typical concurrency models in many languages, but can be scaled to help us design 
 distributed systems as well, utilizing not just many cores and vast resources but also 
 redundancy.
  
 The basic premise of distributed computing is to share, spread, and best absorb the 
 various burdens of any given application across many systems. This not only 
 improves performance on aggregate, but provides some sense of redundancy for the 
 system itself.
  
 This all comes at some cost though, which are as follows:
  
 • 
  
 Potential for network latency
  
 • 
  
 Creating slowdowns in communication and in application execution
  
 • 
  
 Overall increase in complexity both in design and in maintenance
  
 • 
  
 Potential for security issues at various nodes along the distributed route(s)
  
 • 
  
 Possible added cost due to bandwidth considerations
  
 This is all to say, simply, that while building a distributed system can provide great 
 benefits to a large-scale application that utilizes concurrency and ensures data 
 consistency, it's by no means right for every example.",NA
Types of topologies,"Distributed computing recognizes a slew of logical topologies for distributed design. 
 Topology is an apt metaphor, because the positioning and logic of the systems involved 
 can often represent physical topology.
  
 Out of the box, not all of the accepted topologies apply to Go. When we design 
 concurrent, distributed applications using Go, we'll generally rely on a few of the 
 simpler designs, which are as follows.
  
 [
  192 
 ]",NA
Type 1 – star,"The star topology (or at least this particular form of it), resembles our master-slave or 
 producer-consumer models as outlined previously.
  
 The primary method of data passing involves using the master as a message-passing 
 conduit; in other words, all requests and commands are coordinated by a single 
 instance, which uses some routing method to pass messages. The following diagram 
 shows the star topology:
  
 Master
  
 Slaves/Subscribers
  
 We can actually very quickly design a goroutine-based system for this. The following code 
 is solely the master's (or distributed destination's) code and lacks any sort of security 
 considerations, but shows how we can parlay network calls to goroutines:
  
 package main
  
 import 
  
 (
  
  
  ""fmt""
  
  
  ""net""
  
 )
  
 Our standard, basic libraries are defined as follows:
  
 type Subscriber struct {
  
  
  Address net.Addr
  
  
  Connection net.Conn
  
  
  do chan Task  
  
 }
  
 type Task struct 
 {
  
  
  name string 
  
 }
  
 [
  193 
 ]",NA
Type 2 – mesh ,"The mesh is very similar to the star with one major difference: each node is able to 
 communicate not just through the master, but also directly with other nodes as well. 
 This is also known as a 
 complete graph
 . The following diagram shows a mesh 
 topology:
  
  
 For practical purposes, the master must still handle assignments and pass 
 connections back to the various nodes.
  
 This is actually not particularly difficult to add through the following simple 
 modification of our previous server code:
  
 func serverListen (listener net.Listener) {
  
  
  for {
  
  
  conn,_ := listener.Accept()
  
  SubscriberCount++
  
  
  subscriber := Subscriber{ Address: conn.RemoteAddr(),  
    
  Connection: conn }
  
  
  subscriber.awaitTask()
  
  
  _ = append(Subscribers,subscriber)
  
  
  broadcast()
  
  
  } 
  
 }
  
 [
  196 
 ]",NA
The Publish and Subscribe model,"In both the previous topologies, we've replicated a Publish and Subscribe model with a 
 central/master handling delivery. Unlike in a single-system, concurrent pattern, we lack 
 the ability to use channels directly across separate machines (unless we use something 
 like Go's Circuit as described in 
 Chapter 4
 , 
 Data Integrity in an Application
 ).
  
 Without direct programmatic access to send and receive actual commands, we rely on 
 some form of API. In the previous examples, there is no actual task being sent or 
 executed, but how could we do this?
  
 Obviously, to create tasks that can be formalized into non-code transmission, we'll 
 need a form of API. We can do this one of two ways: serialization of commands, 
 ideally via JSONDirect transmission, and execution of code.
  
 As we'll always be dealing with compiled code, the serialization of commands option 
 might seem like you couldn't include Go code itself. This isn't exactly true, but 
 passing full code in any language is fairly high on lists of security concerns.
  
 But let's look at two ways of sending data via API in a task by removing a URL from a 
 slice of URLs for retrieval. We'll first need to initialize that array in our 
 main 
 function 
 as shown in the following code:
  
 type URL struct {
  
  URI string
  
  Status int
  
  Assigned Subscriber
  
  SubscriberID int
  
 }
  
 Every URL in our array will include the URI, its status, and the subscriber address to 
 which it's been assigned. We'll formalize the status points as 0 for unassigned, 1 for 
 assigned and waiting, and 2 for assigned and complete.
  
 [
  197 
 ]",NA
Serialized data ,"In our first option in the API, we'll send and receive serialized data in JSON. Our master 
 will be responsible for formalizing its command and associated data. In this case, we'll 
 want to transmit a few things: what to do (in this case, retrieve) with the relevant data, 
 what the response should be when it is complete, and how to address errors.
  
 We can represent this in a custom struct as follows:
  
 type Assignment struct {
  
  
  command string
  
  
  data string
  
  
  successResponse string
  
  
  errorResponse string 
  
 } 
  
 ...
  
  asmnt := Assignment{command:""process"", 
  
  url:""http://www.golang.org"",successResponse:""success"", 
  
  errorResponse:""error""}
  
  json, _ := json.Marshal(asmnt )
  
  send(string(json))",NA
Remote code execution ,"The remote code execution option is not necessarily separate from serialization of 
 commands, but instead of structured and interpreted formatted responses, the 
 payload could be code that will be run via a system command.
  
 [
  198 
 ]",NA
Other topologies,"There exist quite a few topology types that are more complicated to manage as part of a 
 messaging queue.
  
 The following diagram shows the bus topology:
  
  
 The bus topology network is a unidirectional transmission system. For our purposes, it's 
 neither particularly useful nor easily managed, as each added node needs to announce its 
 availability, accept listener responsibility, and be ready to cede that responsibility when a 
 new node joins.
  
 The advantage of a bus is quick scalability. This comes with serious disadvantages 
 though: lack of redundancy and single point of failure.
  
 Even with a more complex topology, there will always be some issue with potentially 
 losing a valuable cog in the system; at this level of modular redundancy, some additional 
 steps will be necessary to have an always-available system, including automatic double or 
 triple node replication and failovers. That's a bit more than we'll get into here, but it's 
 important to note that the risk will be there in any event, although it would be a little 
 more vulnerable with a topology like the bus.
  
 [
  199 
 ]",NA
Message Passing Interface,"There exists a slightly more formalized version of what we built previously, called 
 Message Passing Interface. MPI was borne from early 1990s academia as a standard for 
 distributed communication.
  
 Originally written with FORTRAN and C in mind, it is still a protocol, so it's largely 
 language agnostic.
  
 MPI allows the management of topology above and beyond the basic topologies we were 
 able to build for a resource management system, including not only the line and ring but 
 also the common bus topology.
  
 For the most part, MPI is used by the scientific community; it is a highly concurrent and 
 analogous method for building large-scale distributed systems. Point-to-point 
 operations are more rigorously defined with error handling, retries, and dynamic 
 spawning of processes all built in.
  
 [
  200 
 ]",NA
Some helpful libraries,"There's little doubt that Go provides some of the best ancillary tools available to 
 any compiled language out there. Compiling to native code on a myriad of 
 systems, deadlock detection, pprof, fmt, and more allow you to not just build 
 high-performance applications, but also test them and format them.
  
 This hasn't stopped the community from developing other tools that can be used for 
 debugging or aiding your concurrent and/or distributed code. We'll take a look at a 
 few great tools that may prove worthy of inclusion in your app, particularly if it's 
 highly visible or performance critical.",NA
Nitro profiler,"As you are probably now well aware, Go's pprof is extremely powerful and useful, if 
 not exactly user-friendly.
  
 If you love pprof already, or even if you find it arduous and confusing, you may love 
 Nitro profiler twice as much. Coming from Steve Francia of spf13, Nitro profiler allows 
 you to produce even cleaner analyses of your application and its functions and steps, as 
 well as providing more usable a/b tests of alternate functions.
  
  
 Read more about Nitro profiler at 
 http://spf13.com/project/
  
  
 nitro
 .
  
 You can get it via 
 github.com/spf13/nitro
 .
  
 [
  201 
 ]",NA
Heka,"Heka is a data pipeline tool that can be used to gather, analyze, and distribute raw 
 data. Available from Mozilla, Heka is more a standalone application rather than a 
 library, but when it comes to acquiring, analyzing, and distributing data such as server 
 logfiles across multiple servers, Heka can prove itself worthy.
  
 Heka is also written in Go, so make sure to check out the source to see how Mozilla 
 utilizes concurrency and Go in real-time data analysis.
  
  
 You can visit the Heka home page at 
 http://heka-docs.
  
  
 readthedocs.org/en/latest/
  and the Heka source page 
  
 at 
 https://github.com/mozilla-services/heka
 .",NA
GoFlow,"Finally, there's GoFlow, a flow-based programming paradigm tool that lets you 
 segment your application into distinct components, each capable of being bound to 
 ports, channels, the network, or processes.
  
 While not itself a performance tool, GoFlow might be an appropriate approach to 
 extending concurrency for some applications.
  
  
 Visit GoFlow at 
 https://github.com/trustmaster/goflow
 .",NA
Memory preservation,"At the time of this writing, Go 1.2.2's compiler utilizes a naive mark/sweep garbage 
 collector, which assigns a reference rank to objects and clears them when they are no 
 longer in use. This is noteworthy only to point out that it is widely considered a 
 relatively poor garbage collection system.
  
 [
  202 
 ]",NA
Garbage collection in Go,"To get an idea of how the garbage collector is managing the stack at any time, take a look 
 at the 
 runtime.MemProfileRecord
  object, which keeps track of presently living objects 
 in the active stack trace.
  
 You can call the profile record when necessary and then utilize it against the 
 following methods to get a few interesting pieces of data:
  
 • 
  
 • 
  
 • 
  
 InUseBytes()
 : This method has the bytes used presently as per the 
 memory profile 
  
 InUseObjects()
 :This method has the number of live objects in use 
 Stack()
 : This method has the full stack trace
  
 You can place the following code in a heavy loop in your application to get a peek at all 
 of these:
  
  var mem runtime.MemProfileRecord
  
  obj := mem.InUseObjects();
  
  bytes := mem.InUseBytes();
  
  stack := mem.Stack();
  
  fmt.Println(i,obj,bytes)",NA
Summary,"We can now build some pretty high-performance applications and then utilize some of 
 Go's built-in tools and third-party packages to seek out the most performance in a 
 single instance application as well as across multiple, distributed systems.
  
 In the next chapter, we're going to wrap everything together to design and build a 
 concurrent server application that can work quickly and independently, and easily 
 scale in performance and scope.
  
 [
  203 
 ]",NA
Concurrent Application ,NA,NA
Architecture,"By now, we've designed small bits of concurrent programs, primarily in a single 
 piece keeping concurrency largely isolated. What we haven't done yet is tie 
 everything together to build something a little more robust, complex, and more 
 daunting to manage from an administrator's perspective.
  
 Simple chat applications and web servers are fine and dandy. However, you will 
 eventually need more complexity and require external software to meet all of the 
 more advanced requirements.
  
 In this case, we'll build something that's satisfied by a few dissonant services: a file 
 manager with revision control that supplies web and shell access. Services such as 
 Dropbox and Google Drive allow users to keep and share files among peers. On the 
 other hand, GitHub and its ilk allow for a similar platform but with the critical added 
 benefit of revision control.
  
 Many organizations face problems with the following sharing and distribution options:
  
 • 
  
 Limitations on repositories, storage, or number of files
  
 • 
  
 Potential inaccessibility if the services are down
  
 • 
  
 Security concerns, particularly for sensitive information
  
 Simple sharing applications such as Dropbox and Google Drive are great at storing data 
 without a large amount of revision control options. GitHub is an excellent collaborative 
 revision control and distribution system, but comes with many costs and the mistakes by 
 developers can lead to large and potentially serious security lapses.",NA
Designing our concurrent application,"When designing a concurrent application, we will have three components running in 
 separate processes. A file listener will be alerted to make changes to files in specified 
 locations. A web-CLI interface will allow users to augment or modify files, and a backup 
 process will be bound to the listener to provide automated copies of new file changes. 
 With that in mind, these three processes will look a bit like 
  
 what is shown in the following diagram:
  
  
 Our file listener process will do the following three things:
  
 • 
  
 Keep an eye on any file changes
  
 • 
  
 Broadcast to our web/CLI servers and the backup process
  
 • 
  
 Maintain the state of any given file in our database / data store
  
 [
  206 
 ]",NA
Identifying our requirements,"The most critical step in our architectural design process is really zooming in on the 
 required features, packages, and technologies that we'll need to implement. For our file 
 management and revision control application, there are a few key points that will stand 
 out:
  
 • 
  
 • 
  
 • 
  
 • 
  
 • 
  
 A web interface that allows file uploads, downloads, and revisions. A 
 command-line interface that allows us to roll back changes and modify files 
 directly.
  
 A filesystem listener that finds changes made to a shared location.
  
 A data store system that has strong Go tie-in and allows us to maintain 
 information about files and users in a mostly consistent manner. This 
 system will also maintain user records.
  
 A concurrent log system that maintains and cycles logs of changed files.
  
 We're somewhat complicating things by allowing the following three different ways to 
 interface with the overall application:
  
 • 
  
 • 
  
 • 
  
 Via the Web that requires a user and login. This also allows our users to access 
 and modify files even if they happen to be somewhere not connected to the 
 shared drive.
  
 Via the command line. This is archaic but also extremely valuable anytime a user 
 is traversing a filesystem, particularly power users not in a GUI.
  
 Via the filesystem that changes itself. This is the shared drive mechanism 
 wherein we assume that any user with access to this will be making valid 
 modifications to any files.
  
 [
  207 
 ]",NA
Using NoSQL as a data store in Go,"One of the biggest concessions with using NoSQL is, obviously, the lack of 
 standardization when it comes to CRUD operations (create, read, update, and 
 delete). SQL has been standardized since 1986 and is pretty airtight across a 
 number of databases—from MySQL to SQL Server and from Microsoft and Oracle 
 all the way down to PostgreSQL.
  
 [
  208 
 ]",NA
MongoDB,"MongoDB is one of the most popular NoSQL platforms available. Written in 2009, it's 
 also one of the most mature platforms, but comes with a number of tradeoffs that have 
 pushed it somewhat out of favor in the recent years.
  
 Even so, Mongo does what it does in a reliable fashion and with a great deal of speed. 
 Utilizing indices, as is the case with most databases and data stores, improves query 
 speed on reads greatly.
  
 Mongo also allows for some very granular control of guarantees as they apply to reads, 
 writes, and consistency. You can think of this as a very vague analog to any language 
 and/or engine that supports syntactical dirty reads.
  
 [
  209 
 ]",NA
Redis,"Redis is another key/value data store and, as of recently, took the number one spot in 
 terms of total usage and popularity. In an ideal Redis world, an entire dataset is held in 
 memory. Given the size of many datasets, this isn't always possible; however, coupled 
 with Redis' ability to eschew durability, this can result in some very high performance 
 results when used in concurrent applications.
  
 Another useful feature of Redis is the fact that it can inherently hold different data 
 structures. While you can make abstractions of such data by unmarshalling JSON 
 objects/arrays in Mongo (and other data stores), Redis can handle sets, strings, arrays, 
 and hashes.
  
 There are two major accepted libraries for Redis in Go:
  
 • 
  
 Radix
 : This is a minimalist client that's barebones, quick, and dirty. To 
 install Radix, run the following command:
  
 go get github.com/fzzy/radix/redis
  
 • 
  
 Redigo
 : This more robust and a bit more complex, but provides a lot of the 
 more intricate functionality that we'll probably not need for this project. To 
 install Redigo, run the following command:
  
 go get github.com/garyburd/redigo/redis
  
 We'll now see a quick example of getting a user's name from the data store of 
 Users 
 in Redis using Redigo:
  
 package main
  
 import 
  
 ( 
  
  ""fmt"" 
  
  ""github.com/garyburd/redigo/redis"" 
  
 )
  
 [
  211 
 ]",NA
Tiedot,"If you've worked a lot with NoSQL, then the preceding engines all likely seemed very 
 familiar to you. Redis, Couch, Mongo, and so on are all virtual stalwarts in what is a 
 relatively young technology.
  
 Tiedot, on the other hand, probably isn't as familiar. We're including it here only 
 because the document store itself is written in Go directly. Document manipulation is 
 handled primarily through a web interface, and it's a JSON document store like several 
 other NoSQL solutions.
  
 As document access and handling is governed via HTTP, there's a somewhat 
 counterintuitive workflow, shown as follows:
  
  
 [Your Go 
 Application]
  
  
 Web Interface
  
  
 [Go Application   Tiedot]
  
  
 As that introduces a potential spot for latency or failure, this keeps from being an ideal 
 solution for our application here. Keep in mind that this is also a feature of a few of the 
 other solutions mentioned earlier, but since Tiedot is written in Go, it would be 
 significantly easier to connect to it and read/modify data using a package. While this 
 book was being written, this did not exist.
  
 Unlike other HTTP- or REST-focused alternatives such as CouchDB, Tiedot relies on 
 URL endpoints to dictate actions, not HTTP methods.
  
 You can see in the following code how we might handle something like this through 
 standard libraries:
  
 package main
  
 import 
  
 ( 
  
  
  ""fmt"" 
  
  
  ""json"" 
  
  
  ""http"" 
  
 )
  
 type Collection struct {
  
  Name string
  
 }
  
 [
  213 
 ]",NA
CouchDB,"CouchDB from Apache Incubator is another one of the big boys in NoSQL big data. As a 
 JSON document store, CouchDB offers a great deal of flexibility when it comes to your 
 data store approach.
  
 CouchDB supports ACID semantics and can do so concurrently, which provides a 
 great deal of performance benefit if one is bound to those properties. In our 
 application, that reliance on ACID consistency is somewhat flexible. By design, it will 
 be failure tolerant and recoverable, but for many, even the possibility of data loss 
 with recoverability is still considered catastrophic.
  
 Interfacing with CouchDB happens via HTTP, which means there is no need for a 
 direct implementation or Go SQL database hook to use it. Interestingly, CouchDB 
 uses HTTP header syntax to manipulate data, as follows:
  
 • 
  
 GET
 : This represents read operations
  
 • 
  
 PUT
 : This represents creation operations
  
 • 
  
 DELETE
 : This represents deletion and update operations
  
 [
  214 
 ]",NA
Cassandra,"Cassandra, another Apache Foundation project, isn't technically a NoSQL solution but a 
 clustered (or cluster-able) database management platform.
  
 Like many NoSQL applications, there is a limitation in the traditional query methods in 
 Cassandra, for example, subqueries and joins are generally not supported.
  
 We're mentioning it here primarily because of its focus on distributed computing as 
 well as the ability to programmatically tune whether data consistency or performance 
 is more important. Much of that is equally expressed in our solution, Couchbase, but 
 Cassandra has a deeper focus on distributed data stores.
  
 Cassandra does, however, support a subset of SQL that will make it far more familiar to 
 developers who have dabbled in MySQL, PostgreSQL, or the ilk. Cassandra's built-in 
 handling of highly concurrent integrations makes it in many ways ideal for Go, although it 
 is an overkill for this project.
  
 The most noteworthy library to interface with Cassandra is gocql, which focuses on 
 speed and a clean connection to the Cassandra connection. Should you choose to use 
 Cassandra in lieu of Couchbase (or other NoSQL), you'll find a lot of the methods that 
 can be simply replaced.
  
 [
  215 
 ]",NA
Couchbase,"Couchbase is a relative newcomer in the field, but it was built by people from both 
 CouchDB and memcached. Written in Erlang, it shares many of the same focuses on 
 concurrency, speed, and non-blocking behavior that we've come to expect from a great 
 deal of our Go applications.
  
 Couchbase also supports a lot of the other features we've discussed in the previous 
 chapters, including easy distribution-based installations, tuneable ACID compliance, and 
 low-resource consumption.
  
 [
  216 
 ]",NA
Setting up our data store,"After installing Couchbase, you can access its administration panel by default at 
 localhost and port 8091.
  
 You'll be given an opportunity to set up an administrator, other IPs to connect (if 
 you're joining a cluster), and general data store design.
  
 After that, you'll need to set up a bucket, which is what we'll use to store all 
 information about individual files. Here is what the interface for the bucket 
 setup looks like:
  
  
 [
  219 
 ]",NA
Monitoring filesystem changes,"When it came to NoSQL options, we had a vast variety of solutions at our disposal. This 
 is not the case when it comes to applications that monitor filesystem changes. While 
 Linux flavors have a fairly good built-in solution in inotify, this does restrict the 
 portability of the application.
  
 So it's incredibly helpful that a cross-platform library for handling this exists in 
 Chris Howey's fsnotify.
  
 Fsnotify works on Linux, OSX, and Windows and allows us to detect when files in any 
 given directory are created, deleted, modified, or renamed, which is more than 
 enough for our purposes.
  
 Implementing fsnotify couldn't be easier, either. Best of all it's all non-blocking, so if 
 we throw the listener behind a goroutine, we can have this run as part of the 
 primary server application code.
  
 The following code shows a simple directory listener:
  
 package main
  
 import ( 
  
  
  ""github.com/howeyc/fsnotify"" 
  
  
  ""fmt"" 
  
  
  ""log"""" 
  
 )
  
 func main() {
  
  scriptDone := make(chan bool)
  
  dirSpy, err := fsnotify.NewWatcher()
  
  if err != nil {
  
  log.Fatal(err)
  
  }
  
  go func() {
  
  for {
  
  select {
  
  case fileChange := <-dirSpy.Event:
  
  log.Println(""Something happened to a file:"",  
  
  fileChange)
  
  case err := <-dirSpy.Error:
  
  log.Println(""Error with fsnotify:"", err)
  
  }
  
 [
  221 
 ]",NA
Managing logfiles,"Like many basic features in a developer's toolbox, Go provides a fairly complete 
 solution built-in for logging. It handles many of the basics, such as creating 
 timestamp-marked log items and saving to disk or to console.
  
 One thing the basic package misses out on is built-in formatting and log rotation, 
 which are key requirements for our file manager application.
  
 Remember that key requirements for our application include the ability to work 
 seamlessly in our concurrent environment and be ready to scale to a distributed 
 network if need be. This is where the fine 
 log4go
  application comes in handy. Log4go 
 allows logging to file, console, and memory and handles log rotation inherently.
  
  
 Log4go can be found at 
 https://code.google.com/p/
  
  
 log4go/
 .
  
 To install Log4go, run the following command:
  
 go get code.google.com/p/log4go
  
 Creating a logfile that handles warnings, notices, debug information, and critical 
 errors is simple and appending log rotation to that is similarly simple, as shown in 
 the following code:
  
 package main
  
 import 
  
 ( 
  
  
  logger ""code.google.com/p/log4go"" 
  
 )
  
 func main() {
  
  logMech := make(logger.Logger);
  
 [
  222 
 ]",NA
Handling configuration files ,"When it comes to configuration files and parsing them, you have a lot of options, 
 from simple to complicated.
  
 We could, of course, simply store what we want in JSON, but that format is a little 
 tricky to work directly for humans—it will require escaping characters and so on, 
 which makes it vulnerable to errors.
  
 Instead, we'll keep things simple by using a standard 
 ini config
  file library in gcfg, 
 which handles 
 gitconfig
  files and traditional, old school 
 .ini
  format, as shown in the 
 following code snippet:
  
 [revisions] 
  
 count = 2 
  
 revisionsuffix = .rev 
  
 lockfiles = false
  
 [logs] 
  
 rotatelength = 86400
  
 [alarms] 
  
 emails = sysadmin@example.com,ceo@example.com
  
  
 You can find gcfg at 
 https://code.google.com/p/gcfg/
 .
  
  
 [
  223 
 ]",NA
Detecting file changes ,"Now we need to focus on our file listener. You may recall this is the part of the 
 application that will accept client connections from our web server and our backup 
 application and announce any changes to files.
  
 The basic flow of this part is as follows:
  
 1. Listen for changes to files in a goroutine.
  
 2. Accept connections and add to the pool in a goroutine.
  
 3. If any changes are detected, announce them to the entire pool.
  
 [
  224 
 ]",NA
Sending changes to clients ,"Here is the broadcast message that goes to all existing connections. We pass along our 
 JSON-encoded 
 Message
  struct with the current version, the current location, and the 
 hash for reference. Our other servers will then react accordingly:
  
 func alertServers(hash string, name string, action string, location 
 string, version int) {
  
 [
  226 
 ]",NA
Checking records against Couchbase ,"When it comes to checking for existing records against Couchbase, we check whether a 
 hash exists in our Couchbase bucket. If it doesn't, we create it. If it does, we do nothing. To 
 handle shutdowns more robustly, we should also ingest existing records into our 
 application. The code for doing this is as follows:
  
 var Clients []Client 
  
 var Files map[string] 
 File
  
 func main() {
  
  Files = make(map[string]File)
  
  endScript := make(chan bool)
  
  couchbaseClient, err := couchbase.Connect(""http://localhost:8091/"") 
 if err != nil {
  
 [
  229 
 ]",NA
Backing up our files ,"Since we're sending our commands on the wire, so to speak, our backup process needs 
 to listen on that wire and respond with any changes. Given that modifications will be 
 sent via localhost, we should have minimal latency on both the network and the file side.
  
 We'll also return some information as to what happened with the file, although at this 
 point we're not doing much with that information. The code for this is as follows:
  
 package main
  
 import 
  
 ( 
  
  
  ""fmt"" 
  
  
  ""net"" 
  
  
  ""io"" 
  
  
  ""os"" 
  
  
  ""strconv"" 
  
  
  ""encoding/json"" 
  
 )
  
 var backupFolder = ""mnt/backup/""
  
 Note that we have a separate folder for backups, in this case, on a Windows machine. 
  
 If we happen to accidentally use the same directory, we run the risk of infinitely 
 duplicating and backing up files. In the following code snippet, we'll look at the 
 Message
  struct itself and the 
 backup
  function, the core of this part of the application:
  
 type Message struct {
  
  
  Hash string ""json:hash""
  
  
  Action string ""json:action""
  
  
  Location string ""json:location""
  
  
  Name string ""json:name""  
  
  
  Version int ""json:version"" 
  
 }
  
 func backup (location string, name string, version int) {
  
  
  newFileName := backupFolder + name + ""."" +  
  
  strconv.FormatInt(int64(version),10)
  
  
  fmt.Println(newFileName)
  
  
  org,_ := os.Open(location)
  
  
  defer org.Close()
  
  
  cpy,_ := os.Create(newFileName)
  
  
  defer cpy.Close()
  
  
  io.Copy(cpy,org) 
  
 }
  
 [
  231 
 ]",NA
Designing our web interface ,"To interact with the filesystem, we'll want an interface that displays all of the current 
 files with the version, last modified time, and alerts to changes, and allows drag-and-
 drop creation/replacement of files.
  
 Getting a list of files will be simple, as we'll grab them directly from our 
 file_manager 
 Couchbase bucket. Changes will be sent through our file manager process via TCP, which 
 will trigger an API call, illuminating changes to the file for our web user.
  
 A few of the methods we've used here are duplicates of the ones we used in the 
 backup process and could certainly benefit from some consolidation; still, the 
 following is the code for the web server, which allows uploads and shows 
 notifications for changes:
  
 package main
  
 import 
  
 ( 
  
  
  ""net"" 
  
  
  ""net/http"" 
  
  
  ""html/template"" 
  
  
  ""log"" 
  
  
  ""io"" 
  
  
  ""os"" 
  
  
  ""io/ioutil"" 
  
  
  ""github.com/couchbaselabs/go-couchbase"" 
  
  
  ""time""   
  
  
  ""fmt"" 
  
  
  ""crypto/md5"" 
  
  
  ""encoding/hex"" 
  
  
  ""encoding/json"" 
  
 )
  
 type File struct {
  
  Hash string ""json:hash""
  
  Name string ""json:file_name""
  
  Created int64 ""json:created""
  
  CreatedUser  int ""json:created_user""
  
  LastModified int64 ""json:last_modified""
  
  LastModifiedUser int ""json:last_modified_user""
  
  Revisions int ""json:revisions""
  
  Version int ""json:version""
  
 }
  
 [
  233 
 ]",NA
Reverting a file's history – command line,"The final component we'd like to add to this application suite is a command-line file 
 revision process. We can keep this one fairly simple, as we know where a file is located, 
 where its backups are located, and how to replace the former with the latter. As with 
 before, we have some global configuration variables and a replication of our 
 generateHash()
  function:
  
 [
  238 
 ]",NA
Using Go in daemons and as a service ,"A minor note on running something like this part of the application—you'll ideally 
 wish to keep these applications as active, restartable services instead of standalone, 
 manually executed background processes. Doing so will allow you to keep the 
 application active and manage its life from external or server processes.
  
 This sort of application suite would be best suited on a Linux box (or boxes) and 
 managed with a daemon manager such as daemontools or Ubuntu's built-in Upstart 
 service. The reason for this is that any long-term downtime can result in lost data and 
 inconsistency. Even storing file data details in the memory (Couchbase and memcached) 
 provides a vulnerability for lost data.
  
 [
  240 
 ]",NA
Checking the health of our server,"Of the many ways to check general server health, we're in a good position here without 
 having to build our own system, thanks in great part to Couchbase itself. If you visit the 
 Couchbase web admin, under your cluster, server, and bucket views, clicking on any will 
 present some real-time statistics, as shown in the following screenshot:
  
  
 These areas are also available via REST if you wish to include them in the application to 
 make your logging and error handling more comprehensive.
  
 [
  241 
 ]",NA
Summary,"We now have a top to bottom application suite that is highly concurrent, ropes in 
 several third-party libraries, and mitigates potential failures with logging and 
 catastrophe recovery.
  
 At this point, you should have no issue constructing a complex package of software with a 
 focus on maintaining concurrency, reliability, and performance in Go. Our file monitoring 
 application can be easily modified to do more, use alternative services, or scale to a 
 robust, distributed environment.
  
 In the next chapter, we'll take a closer look at testing our concurrency and 
  
 throughput, explore the value of panic and recover, as well as dealing with logging 
 vital information and errors in a safe, concurrent manner in Go.
  
 [
  242 
 ]",NA
Logging and Testing ,NA,NA
Concurrency in Go,"At this stage, you should be fairly comfortable with concurrency in Go and should be 
 able to implement basic goroutines and concurrent mechanisms with ease.
  
 We have also dabbled in some distributed concurrency patterns that are managed not 
 only through the application itself, but also through third-party data stores for 
 networked applications that operate concurrently in congress.
  
 Earlier in this book, we examined some preliminary and basic testing and logging. 
  
 We looked at the simpler implementations of Go's internal test tool, performed some 
 race condition testing using the race tool, and performed some rudimentary load and 
 performance testing.
  
 However, there's much more to be looked at here, particularly as it relates to the 
 potential black hole of concurrent code—we've seen unexpected behavior among 
 code that runs in goroutines and is non-blocking.
  
 In this chapter, we'll further investigate load and performance testing, look at unit 
 testing in Go, and experiment with more advanced tests and debugging. 
  
 We'll also look at best practices for logging and reporting, as well as take a 
 closer look at panicking and recovering.
  
 Lastly, we'll want to see how all of these things can be applied not just to our 
 standalone concurrent code, but also to distributed systems.
  
 Along the way, we'll introduce a couple of frameworks for unit testing in a 
 variety of different styles.",NA
Handling errors and logging ,"Though we haven't specifically mentioned it, the idiomatic nature of error handling in 
 Go makes debugging naturally easier by mandate.
  
 One good practice for any large-scale function inside Go code is to return an error as a 
 return value—for many smaller methods and functions, this is potentially burdensome 
 and unnecessary. Still, it's a matter for consideration whenever we're building 
 something that involves a lot of moving pieces.
  
 For example, consider a simple 
 Add()
  function:
  
 func Add(x int, y int) int {
  
  
  return x + y 
  
 }
  
 If we wish to follow the general rule of ""always return an error value"", we may be 
 tempted to convert this function to the following code:
  
 package main 
  
 import 
  
 (
  
  
  ""fmt""
  
  
  ""errors""
  
  
  ""reflect"" 
  
 )
  
 func Add(x int, y int) (int, error) {
  
  
  var err error
  
  
  xType := reflect.TypeOf(x).Kind()
  
  
  yType := reflect.TypeOf(y).Kind()
  
  
  if xType != reflect.Int || yType != reflect.Int {
  
  
  fmt.Println(xType)
  
  
  err = errors.New(""Incorrect type for integer a or b!"")
  
  
 }
  
  
  return x + y, err 
  
 }
  
 func main() {
  
  
  sum,err := Add(""foo"",2)
  
  
  if err != nil {
  
  
  fmt.Println(""Error"",err)
  
  
  }
  
  
  fmt.Println(sum) 
  
 }
  
 [
  244 
 ]",NA
Breaking out goroutine logs ,"One way of handling messaging and logging that keeps a focus on concurrency and 
 isolation is to shackle our goroutine with its own logger that will keep everything 
 separate from the other goroutines.
  
 At this point, we should note that this may not scale—that is, it may at some point 
 become expensive to create thousands or tens of thousands of goroutines that have 
 their own loggers, but at a minimal size, this is totally doable and manageable.
  
 To do this logging individually, we'll want to tie a 
 Logger
  instance to each goroutine, as 
 shown in the following code:
  
 package main
  
 import 
  
 (
  
  
  ""log""
  
 [
  246 
 ]",NA
Using the LiteIDE for richer and easier ,NA,NA
debugging,"In the earlier chapters of this book, we briefly addressed IDEs and gave a few 
 examples of IDEs that have a tight integration with Go.
  
 As we're examining logging and debugging, there's one IDE we previously and 
 specifically didn't mention before, primarily because it's intended for a very small 
 selection of languages—namely, Go and Lua. However, if you end up working 
 primarily or exclusively in Go, you'll find it absolutely essential, primarily as it relates 
 to debugging, logging, and feedback capabilities.
  
 LiteIDE
  is cross-platform and works well on OS X, Linux, and Windows. The number of 
 debugging and testing benefits it presents in a GUI form are invaluable, particularly if 
 you're already very comfortable with Go. That last part is important because developers 
 often benefit most from ""learning the hard way"" before diving in with tools that simplify 
 the programming process. It's almost always better to know how and why something 
 works or doesn't work at the core before being presented with pretty icons, menus, and 
 pop-up windows. Having said that, LiteIDE is a fantastic, free tool for the advanced Go 
 programmer.
  
 By formalizing a lot of the tools and error reporting from Go, we can easily plow 
 through some of the more vexing debugging tasks by seeing them onscreen.
  
 LiteIDE also brings context awareness, code completion, 
 go fmt
 , and more into 
 our workspace. You can imagine how an IDE tuned specifically for Go can help you 
 keep your code clean and bug free. Refer to the following screenshot:
  
 [
  248 
 ]",NA
Sending errors to screen,"Throughout this book, we have usually handled soft errors, warnings, and general 
 messages with the 
 fmt.Println
  syntax by sending a message to the console.
  
 While this is quick and easy for demonstration purposes, it's probably ideal to use 
 the 
 log
  package to handle these sorts of things. This is because we have more 
 versatility, as 
 log
  relates to where we want our messages to end up.
  
 [
  249 
 ]",NA
Logging errors to file,"There are a lot of ways to send an error to a logfile—we can, after all, handle this 
 with built-in file operation OS calls. In fact, this is what many people do.
  
 However, the 
 log
  package offers some standardization and potential symbiosis 
 between the command-line feedback and more permanent storage of errors, 
 warnings, and general information.
  
 The simplest way to do this is to open a file using the 
 os.OpenFile()
  method (and 
 not the 
 os.Open()
  method) and pass that reference to our log instantiation as 
 io.Writer
 .
  
 [
  250 
 ]",NA
Logging errors to memory ,"When we talk about logging errors to memory, we're really referring to a data store, 
 although there's certainly no reason other than volatility and limited resources to reject 
 logging to memory as a viable option.
  
 While we'll look at a more direct way to handle networked logging through 
  
 another package in the next section, let's delineate our various application errors in a 
 concurrent, distributed system without a lot of hassle. The idea is to use shared memory 
 (such as Memcached or a shared memory data store) to pass our log messages.
  
 While these will technically still be logfiles (most data stores keep individual records 
 or documents as JSON-encoded hard files), it has a distinctively different feel than 
 traditional logging.
  
 Going back to our old friend from the previous chapter—CouchDB—passing our logging 
 messages to a central server can be done almost effortlessly, and it allows us to track not 
 just individual machines, but their individual concurrent goroutines. 
  
 The code is as follows:
  
 package main
  
 import 
  
 (
  
  
  ""github.com/couchbaselabs/go-couchbase""
  
  
  ""io""
  
  
  ""time""
  
  
  ""fmt""
  
  
  ""os""
  
  
  ""net/http""
  
  
  ""crypto/md5""
  
  
  ""encoding/hex"" 
  
 ) 
  
 type LogItem struct {
  
  
  ServerID string ""json:server_id""
  
  
  Goroutine int ""json:goroutine""
  
  
  Timestamp time.Time ""json:time""
  
  
  Message string ""json:message""
  
  
  Page string ""json:page"" 
  
 }
  
 [
  252 
 ]",NA
Using the log4go package for robust ,NA,NA
logging ,"As with most things in Go, where there's something satisfactory and extensible in the 
 core page, it can be taken to the next level by a third party—Go's wonderful logging 
 package is truly brought to life with 
 log4go
 .
  
 Using log4go greatly simplifies the process of file logging, console logging, and 
 logging via TCP/UDP.
  
  
 For more information on log4go, visit 
 https://code.google.
  
  
 com/p/log4go/
 .
  
 Each instance of a 
 log4go Logger
  interface can be configured by an XML 
 configuration file and can have filters applied to it to dictate where messaging goes. 
 Let's look at a simple HTTP server to show how we can direct specific logs to 
 location, as shown in the following code:
  
 package main
  
 import (
  
  
  ""code.google.com/p/log4go""
  
  
  ""net/http""
  
  
  ""fmt""
  
  
  ""github.com/gorilla/mux"" 
  
 )
  
 [
  254 
 ]",NA
Panicking,"With all the discussion of capturing errors and logging them, we should probably 
 consider the 
 panic()
  and 
 recover()
  functionality in Go.
  
 As briefly discussed earlier, 
 panic()
  and 
 recover()
  operate as a more basic, 
 immediate, and explicit error detection methodology than, say, 
 try
 /
 catch
 /
 finally 
 or 
 even Go's built-in error return value convention. As designed, 
 panic()
  unwinds the 
 stack and leads to program exit unless 
 recover()
  is invoked. This means that unless 
 you explicitly recover, your application will end.
  
 So, how is this useful other than for stopping execution? After all, we can catch an 
 error and simply end the application manually through something similar to the 
 following code:
  
 package main
  
 import
  
 (
  
  ""fmt""
  
 [
  259 
 ]",NA
Recovering ,"The 
 panic()
  function on its own is fairly simple, and it really becomes useful when 
 paired with 
 recover()
  and 
 defer()
 .
  
 Take, for example, an application that returns meta information about a file from the 
 command line. The main part of the application will listen for user input, pass this into a 
 function that will open the file, and then pass that file reference to another function that 
 will get the file's details.
  
 [
  260 
 ]",NA
Logging our panics,"In the preceding code, we can integrate a logging mechanism pretty simply in addition to 
 catching our panics.
  
 One consideration about logging that we haven't discussed is the notion of when to 
 log. As our previous examples illustrate, we can sometimes run into problems that 
 should be logged but may be mitigated by future user action. As such, we can choose 
 to log our errors immediately or save it until the end of execution or a greater 
 function.
  
 The primary benefit of logging immediately is that we're not susceptible to an 
 actual crash preventing our log from being saved. Take the following example:
  
 type LogItem struct {
  
  Message string
  
  Function string
  
 }
  
 var Logs []LogItem
  
 We've created a log 
 struct
  and a slice of 
 LogItems
  using the following code:
  
 func SaveLogs() {
  
  logFile := log4go.NewFileLogWriter(""errors.log"",false)
  
  logFile.SetFormat(""%d %t - %M (%S)"")
  
  logFile.SetRotate(true)
  
  logFile.SetRotateSize(0)
  
  logFile.SetRotateLines(500)
  
  logFile.SetRotateDaily(false)
  
  errorLog := make(log4go.Logger)
  
  errorLog.AddFilter(""file"",log4go.DEBUG,logFile)
  
 [
  263 
 ]",NA
Catching stack traces with concurrent code,"In earlier Go releases, the ability to properly execute a stack trace from our source was a 
 daunting task, which is emblematic of some of the many complaints and concerns users 
 had early on about general error handling in Go.
  
 While the Go team has remained vigilant about the 
 right
  way to do this (as they have 
 with several other key language features such as a lack of generics), stack traces and 
 stack info have been tweaked a bit as the language has grown.",NA
Using the runtime package for granular ,NA,NA
stack traces,"In an effort to capture stack traces directly, we can glean some helpful pieces of 
 information from the built-in runtime package.
  
 Specifically, Go provides a couple of tools to give us insight into the invocation 
 and/or breakpoints of a goroutine. The following are the functions within the 
 runtime package:
  
 • 
  
 • 
  
 • 
  
 runtime.Caller()
 : This returns information about the parent function of a 
 goroutine
  
 runtime.Stack()
 : This allocates a buffer for the amount of data in a stack 
 trace and then fills that with the trace
  
 runtime.NumGoroutine()
 : This returns the total number of open goroutines
  
 We can utilize all three preceding tools to better describe the inner workings of any 
 given goroutine and related errors.
  
 [
  265 
 ]",NA
Summary,"Debugging, testing, and logging concurrent code can be particularly cumbersome, often 
 when concurrent goroutines fail in a seemingly silent fashion or fail to execute 
 whatsoever.
  
 We looked at various methods of logging, from file to console to memory to 
 network logging, and examined how concurrent application pieces can fit into these 
 various implementations.
  
 By now, you should be comfortable and natural in creating robust and expressive 
 logs that rotate automatically, impose no latency or bottlenecks, and assist in 
 debugging your applications.
  
 You should feel comfortable with the basics of the runtime package. We'll dive into 
 the testing package, controlling goroutines more explicitly, and unit testing as we 
 dig deeper in the next chapter.
  
 In addition to further examining the testing and runtime packages, in our final 
 chapter, we'll also broach the topic of more advanced concurrency topics in Go as 
 well as review some overall best practices as they relate to programming in the Go 
 language.
  
 [
  269 
 ]",NA
Advanced Concurrency ,NA,NA
and Best Practices,"Once you're comfortable with the basic and intermediate usage of concurrency 
 features in Go, you may find that you're able to handle the majority of your 
 development use cases with bidirectional channels and standard concurrency tools.
  
 In 
 Chapter 2
 , 
 Understanding the Concurrency Model
 , and 
 Chapter 3
 , 
 Developing a 
 Concurrent Strategy
 , we looked at the concurrency models, not just of Go but of other 
 languages as well, and compared the way they—and distributed models—can work. In 
 this chapter, we'll touch on those and some higher level concepts with regard to 
 designing and managing your concurrent application.
  
 In particular, we're going to look at central management of goroutines and their 
 associated channels—out of the box you may find goroutines to be a set-it-and-forget-it 
 proposition; however, there are cases where we might want more granular control of a 
 channel's state.
  
 We've also looked quite a bit at testing and benchmarking from a high level, but we'll look 
 at some more detailed and complex methods for testing. We'll also explore a primer on 
 the Google App Engine, which will give us access to some specific testing tools we haven't 
 yet used.
  
 Finally, we'll touch upon some general best practices for Go, which will surely 
 pertain not just to concurrent application design but your future work in general 
 with the language.",NA
Going beyond the basics with channels,"We've talked about quite a few different channel implementations—channels of 
 different type (interfaces, functions, structs, and channels)—and touched upon the 
 differences in buffered and unbuffered channels. However, there's still a lot more we 
 can do with the design and flow of our channels and goroutines.
  
 By design, Go wants you to keep things simple. And that's fantastic for 90 percent of 
 what you'll do with Go. But there are other times where you'll need to dig a little 
 deeper for a solution, or when you'll need to save resources by preserving the amount 
 of open goroutine processes, channels, and more.
  
 You may, at some point, want some hands on control of the size and state, and 
 also the control of a running or closed goroutine, so we'll look at doing that.
  
 Just as importantly, designing your goroutines to work in concert with the 
 application design as a whole can be critical to unit testing, which is a topic 
 we'll touch on in this final chapter.",NA
Building workers,"Earlier in this book, we talked about concurrency patterns and a bit about workers. We 
 even brought the workers concept into play in the previous chapter, when we were 
 building our logging systems.
  
 Truly speaking, ""worker"" is a fairly generic and ambiguous concept, not just in Go, but 
 in general programming and development. In some languages, it's an object/ 
 instantiated class, and in others it's a concurrent actor. In functional programming 
 languages, worker is a graduated function return passed to another.
  
 If we go back to the preface, we will see that we have literally used the Go gopher as an 
 example of a worker. In short, a worker is something more complex than a single 
 function call or programmatic action that will perform a task one or more times.
  
 So why are we talking about it now? When we build our channels, we are creating a 
 mechanism to do work. When we have a struct or an interface, we're combining 
 methods and values at a single place, and then doing work using that 
 object
  as both a 
 mechanism for the work as well as a place to store information about that work.
  
 This is particularly useful in application design, as we're able to delegate various 
 elements of an application's functionality to distinct and well-defined workers. 
 Consider, for example, a server pinging application that has specific pieces doing 
 specific things in a self-contained, compartmentalized manner.
  
 [
  272 
 ]",NA
Implementing nil channel blocks ,"One of the bigger problems in designing something like a pipeline or producer/ 
 consumer model is there's somewhat of a black hole when it comes to the state of 
 any given goroutine at any given time.
  
 Consider the following loop, wherein a producer channel creates an arbitrary set of 
 consumer channels and expects each to do one and only one thing:
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""time"" 
  
 )
  
 const CONSUMERS = 5
  
 func main() {
  
  Producer := make(chan (chan int))
  
  for i := 0; i < CONSUMERS; i++ {
  
  go func() {
  
  
  time.Sleep(1000 * time.Microsecond)
  
  
  conChan := make(chan int)
  
  go func() {
  
  
  for {
  
  
  select {
  
  
  case _,ok := <-conChan:
  
    
  if ok  {
  
    
  Producer <- conChan
  
    
  }else {
  
    
  return
  
    
  }
  
  
  default:
  
  
  }
  
  
  }
  
  }()
  
  
  conChan <- 1
  
  
  close(conChan)
  
  }()
  
  }
  
 [
  278 
 ]",NA
Using nil channels,"In the earlier versions of Go, you could communicate across uninitialized, thus nil or 0-
 value channels without a panic (although your results would be unpredictable). 
  
 Starting from Go Version 1, communication across nil channels produced a 
 consistent but sometimes confusing effect.
  
 It's vital to note that within a select switch, transmission on a nil channel on its own will 
 still cause a deadlock and panic. This is something that will most often creep up when 
 utilizing global channels and not ever properly initializing them. The following is an 
 example of such transmission on a nil channel:
  
 func main() {
  
  var channel chan int
  
  channel <- 1
  
  for {
  
  select {
  
  
  case <- channel:
  
  
  default:
  
  }
  
  }
  
 }
  
 As the channel is set to its 
 0
  value (nil, in this case), it blocks perpetually and the Go 
 compiler will detect this, at least in more recent versions. You can also duplicate this 
 outside of a 
 select
  statement, as shown in the following code:
  
  var done chan int
  
  defer close(done)
  
  defer log.Println(""End of script"")
  
  go func() {
  
  time.Sleep(time.Second * 5)
  
  done <- 1
  
  }()
  
  for {
  
  select {
  
  
  case <- done:
  
    
  log.Println(""Got transmission"")
  
    
  return
  
  
  default:
  
  }
  
  }
  
 [
  280 
 ]",NA
Implementing more granular control over ,NA,NA
goroutines with tomb,"As with many such problems—both niche and common—there exists a third-party 
 utility for grabbing your goroutines by the horns.
  
 Tomb is a library that provides diagnostics to go along with any goroutine and 
 channel—it can tell a master channel if another goroutine is dead or dying.
  
 In addition, it allows you to explicitly kill a goroutine, which is a bit more nuanced than 
 simply closing the channel it is attached to. As previously mentioned, closing the channel 
 is effectively neutering a goroutine, although it could ultimately still be active.
  
 You are about to find a simple fetch-and-grab body script that takes a slice of URL 
 structs (with status and URI) and attempts to grab the HTTP response for each and 
 apply it to the struct. But instead of just reporting information from the goroutines, 
 we'll have the ability to send ""kill messages"" to each of a ""master"" struct's child 
 goroutines.
  
 In this example, we'll run the script for 10 seconds, and if any of the goroutines fail to do 
 their job in that allotted time, it will respond that it was unable to get the URL's body due 
 to a kill send from the master struct that invoked it:
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""io/ioutil""
  
  
  
 ""launchpad.net/tomb""
  
  
  ""net/http""
  
  
  ""strconv""
  
  
  ""sync""
  
  
  ""time"" 
  
 )
  
 var URLS []URL
  
 type GoTomb struct {
  
  
  tomb tomb.Tomb 
  
 }
  
 [
  281 
 ]",NA
Timing out with channels ,"One somewhat critical point with channels and 
 select
  loops that we haven't 
 examined particularly closely is the ability—and often necessity—to kill a 
 select 
 loop after a certain timeout.
  
 Many of the applications we've written so far are long-running or perpetually-running, 
 but there are times when we'll want to put a finite time limit on how long goroutines can 
 operate.
  
 The 
 for { select { } }
  switch we've used so far will either live perpetually 
 (with a default case) or wait to be broken from one or more of the cases.
  
 There are two ways to manage interval-based tasks—both as part of the time 
 package, unsurprisingly.
  
 The 
 time.Ticker
  struct allows for any given operation after the specified period of 
 time. It provides C, a blocking channel that can be used to detect activity sent after 
 that period of time; refer to the following code:
  
 package main
  
 import (
  
  
  ""log""
  
  
  ""time"" 
  
 )
  
 [
  284 
 ]",NA
Building a load balancer with concurrent ,NA,NA
patterns ,"When we built our server pinging application earlier in this chapter, it was probably 
 pretty easy to imagine taking this to a more usable and valuable space.
  
 Pinging a server is often the first step in a health check for a load balancer. Just as Go 
 provides a usable out-of-the-box web server solution, it also presents a very clean 
 Proxy
  
 and 
 ReverseProxy
  struct and methods, which makes creating a load balancer rather 
 simple.
  
 Of course, a round-robin load balancer will need a lot of background work, 
 specifically on checking and rechecking as it changes the 
 ReverseProxy 
 location between requests. We'll handle these with the goroutines triggered 
 with each request.
  
 Finally, note that we have some dummy URLs at the bottom in the configuration—
 changing those to production URLs should immediately turn the server that runs this 
 into a working load balancer. Let's look at the main setup for the application:
  
 package main
  
 import (
  
  
  ""fmt""
  
  
  ""log""
  
  
  ""net/http""
  
  
  ""net/http/httputil""
  
  
  ""net/url""
  
  
  ""strconv""
  
  
  ""time"" 
  
 )
  
 const MAX_SERVER_FAILURES = 10 
  
 const DEFAULT_TIMEOUT_SECONDS = 5 
  
 const MAX_TIMEOUT_SECONDS = 60 
  
 const TIMEOUT_INCREMENT = 5 
  
 const MAX_RETRIES = 5
  
 [
  286 
 ]",NA
Choosing unidirectional and bidirectional ,NA,NA
channels,"For the purpose of simplicity, we've designed most of our applications and sample code 
 with bidirectional channels, but of course any channel can be set unidirectionally. This 
 essentially turns a channel into a ""read-only"" or ""write-only"" channel.
  
 If you're wondering why you should bother limiting the direction of a channel 
 when it doesn't save any resources or guarantee an issue, the reason boils down to 
 simplicity of code and limiting the potential for panics.
  
 By now we know that sending data on a closed channel results in a panic, so if we 
 have a write-only channel, we'll never accidentally run into that problem in the 
 wild. Much of this can also be mitigated with 
 WaitGroups
 , but in this case that's a 
 sledgehammer being used on a nail. Consider the following loop:
  
 const TOTAL_RANDOMS = 100
  
 func concurrentNumbers(ch chan int) {
  
  for i := 0; i < TOTAL_RANDOMS; i++ {
  
  ch <- i
  
  }
  
 }
  
 func main() {
  
  ch := make(chan int)
  
 [
  292 
 ]",NA
Using receive-only or send-only channels,"When we limit the direction or the read/write capability of our channels, we also 
 reduce the potential for closed channel deadlocks if one or more of our processes 
 inadvertently sends on such a channel.
  
 So the short answer to the question ""When is it appropriate to use a unidirectional 
 channel?"" is ""Whenever you can.""
  
 Don't force the issue, but if you can set a channel to read/write only, it may preempt 
 issues down the road.",NA
Using an indeterminate channel type,"One trick that can often come in handy, and we haven't yet addressed, is the ability to 
 have what is effectively a typeless channel.
  
 If you're wondering why that might be useful, the short answer is concise code and 
 application design thrift. Often this is a discouraged tactic, but you may find it useful from 
 time to time, especially when you need to communicate one or more disparate concepts 
 across a single channel. The following is an example of an indeterminate channel type:
  
 [
  293 
 ]",NA
Using Go with unit testing,"As with many of the basic and intermediate development and deployment 
 requirements you may have, Go comes with a built-in application for handling unit 
 tests.
  
 The basic premise behind testing is that you create your package and then create a 
 testing package to run against the initial application. The following is a very basic 
 example:
  
 mathematics.go
  
 package mathematics
  
 func Square(x int) int {
  
  return x * 3
  
 }
  
 mathematics_test.go
  
 package mathematics
  
 import
  
 (
  
  ""testing""
  
 )
  
 func Test_Square_1(t *testing.T) {
  
  if Square(2) != 4 {
  
  t.Error(""Square function failed one test"")
  
  }
  
 }
  
 A simple Go test in that subdirectory will give you the response you're looking for. While 
 this was admittedly simple—and purposefully flawed—you can probably see how easy it 
 is to break apart your code and test it incrementally. This is enough to do very basic unit 
 tests out of the box.
  
 Correcting this would then be fairly simple—the same test would pass on the 
 following code:
  
 func Square(x int) int {
  
  return x * x
  
 }
  
 The testing package is somewhat limited; however, as it provides basic pass/fails 
 without the ability to do assertions. There are two third-party packages that can step 
 in and help in this regard, and we'll explore them in the following sections.
  
 [
  295 
 ]",NA
GoCheck,"GoCheck
  extends the basic testing package primarily by augmenting it with 
 assertions and verifications. You'll also get some basic benchmarking utility out of it 
 that works a little more fundamentally than anything you'd need to engineer using 
 Go.
  
  
 For more details on GoCheck visit 
 http://labix.org/gocheck
  
  
 and install it using 
 go get gopkg.in/check.v1
 .",NA
Ginkgo and Gomega,"Unlike GoCheck, Ginkgo (and its dependency Gomega) takes a different approach to 
 testing, utilizing the 
 behavior-driven development
  (
 BDD
 ) model. Behavior-driven 
 development is a general model for making sure your application does what it should at 
 every step, and Ginkgo formalizes that into some easily parseable properties.
  
 BDD tends to complement test-driven development (for example, unit testing) rather than 
 replacement. It seeks to answer a few critical questions about the way people (or other 
 systems) will interact with your application. In that sense, we'll generally describe a 
 process and what we expect from that process in fairly human-friendly terms. The 
 following is a short snippet of such an example:
  
 Describe(""receive new remote TCP connection"", func() {
  
  Context(""user enters a number"", func() {
  
  It(""should be an integer"", func() {
  
  })
  
  })
  
 })
  
 This allows testing to be as granular as unit testing, but also expands the way we 
 handle application usage in verbose and explicit behaviors.
  
 If BDD is something you or your organization is interested in, this is a fantastic, 
 mature package for implementing deeper unit testing.
  
  
 For more information on Ginkgo go to 
 https://github.com/
  
  
 onsi/ginkgo
  and install it using 
 go get github.com/onsi/
  
 ginkgo/ginkgo
 .
  
 For more information on dependency, refer to 
 go get github.com/
  
 onsi/gomega
 .
  
 [
  296 
 ]",NA
Using Google App Engine,"If you're unfamiliar with Google App Engine, the short version is it's a cloud 
 environment that allows for simple building and deployment of 
 Platform-As-A-
 Service
  (
 paas
 ) solutions.
  
 Compared to a lot of similar solutions, Google App Engine allows you to build and test 
 your applications in a very simple and straightforward way. Google App Engine allows 
 you to write and deploy in Python, Java, PHP, and of course, Go.
  
 For the most part, Google App Engine provides a standard Go installation that 
 makes it easy to dovetail off of the 
 http
  package. But it also gives you a few 
 noteworthy additional packages that are unique to Google App Engine itself:
  
 Package
  
 Description
  
  
 appengine/memcache
  
 appengine/mail
  
 appengine/log 
  
 appengine/user
  
 appengine/search
  
 appengine/xmpp
  
 appengine/urlfetch
  
 appengine/aetest
  
 This provides a distributed memcache 
  
 installation unique to Google App Engine This 
 allows you to send e-mails through an SMTP-
 esque platform 
  
 Given your storage may be more ephemeral 
 here, it formalizes a cloud version of the log 
 This opens both identity and OAuth 
  
 capabilities 
  
 This gives your application the power of 
  
 Google search on your own data via datastore 
 This provides Google Chat-like capabilities
  
 This is a crawler functionality
  
 This extends unit testing for Google App 
 Engine
  
 While Go is still considered beta for Google App Engine, you can expect that if anyone 
 was able to competently deploy it in a cloud environment, it would be Google.",NA
Utilizing best practices,"The wonderful thing with Go when it comes to best practices is that even if you 
 don't necessarily do everything right, either Go will yell at you or provide you with 
 the tools necessary to fix it.
  
 If you attempt to include code and not use it, or if you attempt to initialize a variable and 
 not use it, Go will stop you. If you want to clean up your code's formatting, Go enables it 
 with 
 go fmt
 .
  
 [
  297 
 ]",NA
Structuring your code ,"One of the easiest things you can do when building a package from scratch is to 
 structure your code directories in an idiomatic way. The standard for a new 
 package would look something like the following code:
  
 /projects/
  
  
  thisproject/
  
  
  bin/
  
  
  pkg/
  
  
  src/
  
    
  package/
  
     
  mypackage.go
  
 Setting up your Go code like this is not just helpful for your own organization, but 
 allows you to distribute your package more easily.",NA
Documenting your code ,"For anyone who has worked in a corporate or collaborative coding environment, 
 documentation is sacrosanct. As you may recall earlier, using the 
 godoc
  command 
 allows you to quickly get information about a package at the command line or via an ad 
 hoc localhost server. The following are the two basic ways you may use 
 godoc
 :
  
 Using godoc
  
 Description
  
 godoc fmt 
  
 godoc -http=:3000
  
 This brings 
 fmt
  documentation to the screen 
 This hosts the documentation on port 
 :3030
  
 Go makes it super easy to document your code, and you absolutely should. By 
 simply adding single-line comments above each identifier (package, type, or 
 function), you'll append that to the contextual documentation, as shown in the 
 following code:
  
 // A demo documentation package 
  
 package documentation
  
 // The documentation struct object 
  
 // Chapter int represents a document's chapter // 
 Content represents the text of the documentation 
 type Documentation struct {
  
  
  Chapter int
  
  
  Content string 
  
 }
  
 [
  298 
 ]",NA
Making your code available via go get,"Assuming you've kept your code in a manner consistent with the organizational 
 techniques as listed previously, making your code available via code repositories and 
 hosts should be a cinch.
  
 Using GitHub as the standard, here's how we might design our third-party 
 application:
  
 1. Make sure you stick to the previous structural format.
  
 2. Keep your source files under the directory structures they'll live in 
 remotely. In other words, expect that your local structure will reflect the 
 remote structure.
  
 3. Perhaps obviously, commit only the files you wish to share in the 
  
 remote repository.
  
 Assuming your repository is public, anyone should be able to get (
 go get
 ) and 
 then install (
 go install
 ) your package.",NA
Keeping concurrency out of your packages,"One last point that might seem somewhat out of place given the context of the book—if 
 you're building separate packages that will be imported, avoid including concurrent 
 code whenever possible.
  
 This is not a hard-and-fast rule, but when you consider potential usage, it makes 
 sense—let the main application handle the concurrency unless your package 
 absolutely needs it. Doing so will prevent a lot of hidden and difficult-to-debug 
 behavior that may make your library less appealing.
  
 [
  299 
 ]",NA
Summary,"It is my sincere hope that you've been able to explore, understand, and utilize the 
 depths of Go's powerful abilities with concurrency through this book.
  
 We've gone over a lot, from the most basic, channel-free concurrent goroutines to 
 complex channel types, parallelism, and distributed computing, and we've brought some 
 example code along at every step.
  
 By now, you should be fully equipped to build anything your heart desires in code, in a 
 manner that is highly concurrent, fast, and error-free. Beyond that, you should be able to 
 produce well-formed, properly-structured, and documented code that can be used by 
 you, your organization, or others to implement concurrency where it is best utilized.
  
 Concurrency itself is a vague concept; it's one that means slightly different things to 
 different people (and across multiple languages), but the core goal is always fast, 
 efficient, and reliable code that can provide performance boosts to any application.
  
 Armed with a full understanding of both the implementation of concurrency in Go as 
 well as its inner workings, I hope you continue your Go journey as the language 
 evolves and grows, and similarly implore you to consider contributing to the Go 
 project itself as it develops.
  
 [
  300 
 ]",NA
Index,NA,NA
Symbols,"/dynamic/[request][number]  
 159--gif flag  146
  
 --gv flag  146
  
 --pdf flag  146
  
 -race flag  71, 76, 143 
  
 /static/[request]  159
  
 --SVG flag  146 
  
 /template/[request]  159
  
 --text flag  146
  
 --web flag  146",NA
A,"AB, Apache 
  
  
 URL  161 
  
 actor model 
  
  
 and CSP, difference between  60 
 Add() function  246 
  
 Add() method  13 
  
 addToScrapedText function  37, 39 
 Apache server 
  
  
 disadvantages  156 
  
 Apache Zookeeper 
  
  
 URL  121 
  
 App Engine 
  
  
 benefits  191 
  
  
 URL  191 
  
  
 using  191 
  
 appengine/aetest  297 
  
 appengine/log  297 
  
 appengine/mail  297 
  
 appengine/memcache  297 
  
 appengine/search  297 
  
 appengine/urlfetch  297
  
 appengine/user  297 
  
 appengine/xmpp  297 
  
 applicationStatus variable  36 
  
 assembly 
  
  
 used, in Go  109-111 
  
 asynchronous goroutine 
  
  
 versus synchronous goroutine  42 
  
 atomic consistency / mutual exclusion  
 117",NA
B,"backup function  231 
  
 backup process, concurrent 
  
   
 application  206, 207 
  
 behavior-driven development (BDD)  296 
 best practices, Go 
  
  
 code availability, via go get  299 
  
  
 code, documenting  298, 299 
  
  
 code, structuring  298 
  
  
 utilizing  297 
  
 bidirectional channel 
  
  
 selecting  292, 293 
  
 Blocking method 1 
  
  
 serial channel, listening  124 
  
 Blocking method 2 
  
  
 select statement, using  140 
  
 Blocking method 3 
  
  
 network connections  141 
  
  
 reads  141 
  
 blocking methods 
  
  
 Blocking method 1  124 
  
  
 Blocking method 2  139 
  
  
 in Go  124 
  
 blocking web server 
  
  
 benchmarking against  160-162 
  
 Body variable  282",NA
C,"C 
  
  
 implementing  103, 104 
  
 C10K 
  
  
 attacking, concurrent connections used  157 
 C10K problem 
  
  
 another approach  158 
  
  
 concurrency used, to attack C10K  156, 157 
  
 handling  154 
  
  
 servers, failing at concurrent 
  
   
 connections  155, 156 
  
 C10K web server 
  
  
 blocking web server, benchmarking 
  
   
 against  160-162 
  
  
 building  159 
  
  
 requests, handling  162-165 
  
  
 requests, routing  165, 166 
  
 call graph  182 
  
 Cassandra 
  
  
 about  215, 216 
  
  
 features  215 
  
 CDNs (Content Delivery Networks)  159 cgo 
  
  
 memory space  104 
  
  
 structure  104, 105 
  
 channels 
  
  
 best practices  272 
  
  
 buffered channel  29 
  
  
 complex channels, using  128, 129 
  
  
 creating, of channels  141-143 
  
  
 data types, sending via  125 
  
  
 function channel, creating  126 
  
  
 goroutines, cleaning  29 
  
  
 implementing  22-25 
  
  
 interface channel, using  127 
  
  
 interfaces, using  128, 129 
  
  
 letter capitalization  25-28 
  
  
 select statement, using  29-33 
  
  
 structs, using  128, 129
  
  
 timing out with  284, 285 
  
  
 unbuffered channel  29 
  
  
 used, for building web spider  35-39 
  
 checkServerStatus() method  274, 276 
  
 client 
  
  
 about  130, 131 
  
  
 examining  137 
  
 Client struct  225 
  
 close() method  140 
  
 closure 
  
  
 working  34, 35 
  
 code 
  
  
 documenting  298 
  
  
 structuring  298 
  
 code availability 
  
  
 via go get  299 
  
 command-line file revision process, 
  
   
 concurrent application 
  
  
 about  238-240 
  
  
 Go, using in daemons  240 
  
 Communicating Sequential Processes 
  
   
 (CSP)  29 
  
 complete graph. 
 See
   mesh topology 
  
 complex channels 
  
  
 using  128, 129 
  
 complex concurrency 
  
  
 efficiency, applying in  67, 68 
  
 concurrency 
  
  
 impacting, on I/O pprof  188-190 
  
  
 using  62 
  
  
 visualizing  44-49 
  
 concurrent application 
  
  
 backup process  206 
  
  
 command-line file revision process  238-240 
  
 configuration files, handling  223, 224 
  
  
 designing  206 
  
  
 file changes, detecting  224-226 
  
  
 file listener  206 
  
  
 files, backing up  231, 232 
  
  
 filesystem changes, monitoring  221 
  
  
 logfiles, managing  222 
  
  
 NoSQL, using  208 
  
  
 requisites, identifying  207, 208 
  
  
 server health, checking  241 
  
  
 web-CLI interface  206 
  
  
 web interface, designing  233-238
  
 [
  302 
 ]",NA
D,"daemontools  240 
  
 data 
  
  
 locking, mutex used  63-65 
  
  
 locking, sync package used  63-65 
  
 data types 
  
  
 sending, via channels  125 
  
 deadlocks 
  
  
 handling  150 
  
 debugging 
  
  
 LiteIDE, used for  248 
  
 defer control mechanism 
  
  
 Go's scheduler, using  15-20 
  
  
 implementing  13, 14 
  
  
 system variables, using  20, 21 
  
 DELAY_INCREMENT value  273 
  
 DELETE syntax  214 
  
 Dial function  141 
  
 dining philosophers problem  58, 59 
 direct messages 
  
  
 handling  131-134 
  
 Distributed Go 
  
  
 about  111, 112, 192 
  
  
 topology types  192 
  
 Distributed Shared Memory. 
 See
   DSM 
 Done() command  56 
  
 draw2d 
  
  
 about  44 
  
  
 URL  44 
  
 driver libraries, MySQL 
  
  
 Go-MySQL-Driver  171 
  
  
 MyMySQL  171 
  
 DSM  113",NA
E,"efficiency 
  
  
 applying, in complex concurrency  67, 68 
 endpoint patterns 
  
  
 entrypoint/register/{name}  84 
  
  
 entrypoint/schedule/{name}/{time}  84 
  
 entrypoint/viewusers  84 
  
 entrypoint/register/{name}  84 
  
 entrypoint/schedule/{name}/{time}  84 
 entrypoint/viewusers  84
  
 [
  303 
 ]",NA
F,"file changes, concurrent application 
  
  
 detecting  224-226 
  
  
 records, checking against 
  
   
 Couchbase  229, 230 
  
  
 sending, to clients  226-229 
  
 file listener, concurrent application  206 
 files 
  
  
 errors, logging to  250, 251 
  
  
 working with  101, 102 
  
 files, concurrent application 
  
  
 backing up  231, 232 
  
 filesystem changes, concurrent 
 application 
  
 monitoring  221 
  
 first-in-first-out (PRAM)  114 
  
 fsnotify  221 
  
 functionality, Go 
  
  
 panicking  259, 260 
  
  
 recovering  260-262 
  
 function channel 
  
  
 creating  126",NA
G,"garbage collection 
  
  
 used, in Go  203 
  
 gcfg 
  
  
 URL  223 
  
 generateHash() function  238 
 getArticle function  178
  
 getFileDetails() method  262 
  
 getLetters function  33 
  
 Get method  57 
  
 GET syntax  214 
  
 Ginkgo 
  
  
 about  296 
  
  
 URL  296 
  
 gnuplot 
  
  
 URL  161 
  
 Go 
  
  
 assembly, using  109-111 
  
  
 blocking methods, using  124 
  
  
 concurrency impact, on I/O pprof  188-190 
  
 drawback  109 
  
  
 garbage collection, using  203 
  
  
 Ginkgo  296 
  
  
 GoCheck  296 
  
  
 Gomega  296 
  
  
 maps, using  128 
  
  
 NoSQL, using  209 
  
  
 parallelism impact, on I/O pprof  188-190 
  
 performance  182 
  
  
 polymorphism, demonstrating in  61, 62 
  
 pprof tool  143-150, 182-187 
  
  
 stack traces, catching with concurrent 
  
   
 code  265 
  
  
 structs, using  129 
  
  
 used, with unit testing  295 
  
 go:ngine 
  
  
 about  44 
  
  
 URL  44 
  
 GoCheck 
  
  
 about  296 
  
  
 URL  296 
  
 Go' circuit 
  
  
 about  119, 120 
  
  
 URL  120 
  
 godoc 
  
  
 using  298 
  
 godoc command  298 
  
 GoFlow 
  
  
 about  202 
  
  
 URL  202 
  
 go get command  43, 50 
  
 GOMAXPROCS  62 
  
 Gomega  296
  
 [
  304 
 ]",NA
H,"happenedRlock() method  99 
 healthCheck function  289 
 Heka 
  
  
 about  202 
  
  
 URL  202
  
 Hoare 
  
  
 about  57 
  
  
 URL  57 
  
 http.FileServer method  
 163 
  
 HTTP header syntax 
  
  
 DELETE  214 
  
  
 GET  214 
  
  
 PUT  214 
  
 http.ServeFile function  
 166 
  
 http template package  83",NA
I,"immutability  94, 95 
  
 indeterminate channel type 
  
  
 using  293 
  
 Initiate() function  133 
  
 InService property  288 
  
 interface channel 
  
  
 using  127 
  
 interfaces 
  
  
 using  128, 129 
  
 interval function  99 
  
 InUseBytes() method  203 
  
 InUseObjects() method  203 
  
 I/O pprof 
  
  
 concurrency, impacting on  188-190 
  
 parallelism, impacting on  188-190 
 itemsHandler function  53 
  
 ItemWrapper struct  234",NA
J,"JMeter 
  
  
 using  90",NA
L,"lastChecked variable  235 
  
 leader/follower model  116 
 letter capitalization, 
 channels 
  
 example  25-28 
  
 libraries, Go 
  
  
 about  201 
  
  
 GoFlow  202 
  
  
 Heka  202 
  
  
 Nitro profiler  201
  
 [
  305 
 ]",NA
M,"main() function  54, 144, 236, 
 283 main() method  136 
  
 makefile  106-108 
  
 maps 
  
  
 used, in Go  128 
  
 master-slave model  114 
  
 memcached 
  
  
 Go' circuit  119, 120 
  
  
 using  118, 119 
  
 memory 
  
  
 errors, logging to  252, 253 
  
 memory leak 
  
  
 creating  182 
  
 memory preservation 
  
  
 in Go  202
  
 mesh topology  196, 197 
  
 Message Passing Interface. 
 See
   MPI 
 Message struct  226, 234 
  
 mgo 
  
  
 URL  210 
  
 MongoDB 
  
  
 about  209-211 
  
  
 features  209 
  
 MPI 
  
  
 about  200 
  
  
 URL  201 
  
 MPICH 
  
  
 URL  201 
  
 multiple cores 
  
  
 leveraging  174 
  
  
 multithreading  174 
  
 multiuser appointment calendar 
  
  
 about  79, 80 
  
  
 concurrent pattern, visualizing  81 
  
 endpoints  84 
  
  
 example  85, 90-93 
  
  
 server requirements, developing  82 
  
 structs  85 
  
 Mustache 
  
  
 advantage  83 
  
  
 URL  83 
  
 mutex 
  
  
 used, to lock data  63-65 
  
  
 using  97-99 
  
 mutex variable  77 
  
 mutual exclusions 
  
  
 using  72-77 
  
 MyMySQL 
  
  
 URL  171 
  
 MySQL 
  
  
 connecting to  171-173 
  
  
 driver libraries  171",NA
N,"net.Listen() method  130 
  
 net package 
  
  
 about  130 
  
  
 Client  130, 131 
  
  
 direct messages, handling  131-137 
  
 Server  130 
  
 network connections  141
  
 [
  306 
 ]",NA
O,"object orientation, Go  60, 
 61 Open() method  172 
  
 OpenMPI 
  
  
 URL  201 
  
 os.OpenFile() method  250",NA
P,"panic() function  259, 260 
  
 panicking, Go  259, 260 
  
 panics 
  
  
 logging  263, 265 
  
 parallelism 
  
  
 impacting, on I/O pprof  188-190 
 Pipelined RAM (PRAM)  114 
  
 Platform-As-A-Service (paas)  297 
 polymorphism 
  
  
 demonstrating, in Go  61, 62 
  
 pprof tool  143-150, 181-187 
  
 private  93 
  
 producer-consumer problem  115 
 profiling tools  149 
  
 pseudocode, actor model  60 
  
 pseudocode, CSP  60 
  
 public  93 
  
 Publish and Subscribe model  197 
 PUT syntax  214",NA
Q,"Query command  178 
  
 QueryRow() function  
 178",NA
R,"race conditions 
  
  
 identifying, with race detection  68-72 
  
 mutual exclusions, using  72-77 
  
  
 timeouts, exploring  77, 78 
  
 race detection 
  
  
 race conditions, identifying with  68-72 
 Radix  211 
  
 re2 syntax 
  
  
 URL  134 
  
 reads  141 
  
 readURLs function  36, 39 
  
 receive-only channel 
  
  
 using  293 
  
 recover() function  259, 260 
  
 recovering, Go  260-262 
  
 Redigo  211 
  
 Redis 
  
  
 about  211 
  
  
 features  211 
  
  
 libraries  211 
  
  
 Redigo, using  211 
  
  
 URL  212 
  
 regexp.QuoteMeta() method  132 
  
 registerError()  265 
  
 release consistency model  117 
  
 remote code execution option 
  
  
 about  199 
  
  
 advantages  199 
  
  
 disadvantages  199 
  
 removeFile function  227 
  
 requests 
  
  
 handling  162-165 
  
  
 routing  165, 166 
  
 requisites, concurrent application 
  
  
 identifying  207, 208 
  
 restricted() function  256 
  
 Revel 
  
  
 URL  82 
  
 ReverseProxy method  290
  
 [
  307 
 ]",NA
S,"saveLogs() function  267 
  
 screen 
  
  
 errors, sending to  249 
  
 SELECT command  178 
  
 select statement 
  
  
 using  29-33, 139 
  
 send-only channel 
  
  
 using  293 
  
 separate packages 
  
  
 building  299 
  
 serial channel 
  
  
 listening  124 
  
 serialized data 
  
  
 transmitting  198 
  
 ServeHTTP method  166 
  
 server 
  
  
 about  130 
  
  
 creating  273
  
 server health, concurrent application 
  
  
 checking  241 
  
 server requirements 
  
  
 developing  82 
  
  
 templates, using  83, 84 
  
  
 time  84 
  
  
 web server  82 
  
 servers 
  
  
 failing, at concurrent connections  155, 156 
 SetFormat option  257 
  
 setProxy function  291 
  
 SetRotateLines()  257 
  
 SetRotate option  257 
  
 Sleep() method  99 
  
 Stack() method  203 
  
 stack traces 
  
  
 catching, with concurrent code  265 
  
  
 runtime package, used for  265-268 
  
 star topology  193-195 
  
 static pages 
  
  
 external dependencies  171 
  
  
 serving  166, 167 
  
  
 template, parsing  167-170 
  
 strings.TrimRight() method  130 
  
 structs 
  
  
 about  85 
  
  
 used, in Go  129 
  
  
 using  128, 129 
  
 style  93 
  
 SVG 
  
  
 need for  44 
  
 synchronous goroutine 
  
  
 versus asynchronous goroutine  42 
  
 sync.mutex struct  98 
  
 sync package 
  
  
 about  97, 98 
  
  
 used, to lock data  63-65 
  
 system variables 
  
  
 using  20, 21",NA
T,"template.ParseFiles() method  
 170 templates 
  
  
 parsing  167-170 
  
  
 using  83, 84 
  
 text template package  83
  
 [
  308 
 ]",NA
U,"unbuffered channel  29 
  
 unidirectional channel 
  
  
 selecting  292, 293 
  
 unit testing 
  
  
 Go, using with  295 
  
 unlocks 
  
  
 performing, on RWMutex  99 
 unsafe package  185 
  
 updateFile function  229, 235 
 Upstart service, Ubuntu  240 
 URI variable  282 
  
 URL struct  282 
  
 url variable  51",NA
V,"visualization example  158, 159",NA
W,"Waitgroup struct 
  
  
 implementing  11-13 
  
 web-CLI interface, concurrent 
  
   
 application  206 
  
 web command  146 
  
 Web.Go 
  
  
 URL  82 
  
 web interface, concurrent 
 application 
  
 designing  233-238 
  
 web server 
  
  
 about  82 
  
  
 connection mitigation  178, 179 
  
  
 exploring  174-178 
  
  
 history  155 
  
 web server plan 
  
  
 designing  42-44 
  
 web spider 
  
  
 building, channels used  35-39 
  
  
 building, goroutines used  35-39 
  
 workers 
  
  
 about  272 
  
  
 building  272-277
  
 [
  309 
 ]",NA
Thank you for buying ,NA,NA
Mastering Concurrency in Go,NA,NA
About Packt Publishing,"Packt, pronounced 'packed', published its first book ""
 Mastering phpMyAdmin for Effective 
 MySQL Management
 "" in April 2004 and subsequently continued to specialize in publishing 
 highly focused books on specific technologies and solutions.
  
 Our books and publications share the experiences of your fellow IT professionals in adapting and 
 customizing today's systems, applications, and frameworks. Our solution based books give you the 
 knowledge and power to customize the software and technologies you're using to get the job done. 
 Packt books are more specific and less general than the IT books you have seen in the past. Our 
 unique business model allows us to bring you more focused information, giving you more of what 
 you need to know, and less of what you don't.
  
 Packt is a modern, yet unique publishing company, which focuses on producing quality, 
 cutting-edge books for communities of developers, administrators, and newbies alike. For 
 more information, please visit our website: 
 www.packtpub.com
 .",NA
About Packt Open Source,"In 2010, Packt launched two new brands, Packt Open Source and Packt Enterprise, in order to 
 continue its focus on specialization. This book is part of the Packt Open Source brand, home to 
 books published on software built around Open Source licenses, and offering information to 
 anybody from advanced developers to budding web designers. The Open Source brand also runs 
 Packt's Open Source Royalty Scheme, by which Packt gives a royalty to each Open Source project 
 about whose software a book is sold.",NA
Writing for Packt,"We welcome all inquiries from people who are interested in authoring. Book proposals should be 
 sent to 
 author@packtpub.com
 . If your book idea is still at an early stage and you would like to 
 discuss it first before writing a formal book proposal, contact us; one of our commissioning editors 
 will get in touch with you. 
  
 We're not just looking for published authors; if you have strong technical skills but no writing 
 experience, our experienced editors can help you develop a writing career, or simply get some 
 additional reward for your expertise.",NA
Yii Application Development ,NA,NA
Cookbook ,"Second Edition
  
 ISBN: 978-1-78216-310-7              Paperback: 408 pages
  
 A Cookbook covering both practical Yii application 
 development tips and the most important Yii features
  
 1. 
  
 2. 
  
 3. 
  
 Learn how to use Yii even more efficiently.
  
 Full of practically useful solutions and concepts 
 you can use in your application.
  
 Both important Yii concept descriptions and 
 practical recipes are inside.",NA
Real-time Web Application ,NA,NA
Development using Vert.x 2.0,"ISBN: 978-1-78216-795-2             Paperback: 122 pages
  
 An intuitive guide to building applications for the 
 real-time web with the Vert.x platform
  
 1. 
  
 2. 
  
 3. 
  
 Get started with developing applications for 
 the real-time Web.
  
 From concept to deployment, learn the full 
 development workflow of a real-time web 
 application.
  
 Utilize the Java skills you already have while 
 stepping up to the next level.
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
Python Network Programming ,NA,NA
Cookbook,"ISBN: 978-1-84951-346-3            Paperback: 234 pages
  
 Over 70 detailed recipes to develop practical 
 solutions for a wide range of real-world network 
 programming tasks
  
 1. 
  
 2. 
  
 3. 
  
 Demonstrates how to write various bespoke 
 client/server networking applications using 
 standard and popular third-party Python 
 libraries.
  
 Learn how to develop client programs for 
 networking protocols such as HTTP/HTTPS, 
 SMTP, POP3, FTP, CGI, XML-RPC, SOAP, and 
 REST.
  
 Provides practical, hands-on recipes combined 
 with short and concise explanations on code 
 snippets.",NA
Tcl 8.5 Network Programming ,"ISBN: 978-1-84951-096-7             Paperback: 588 pages
  
 Build network-aware applications using Tcl, a 
 powerful dynamic programming language
  
 1. 
  
 2. 
  
 3. 
  
 Develop network-aware applications with Tcl.
  
 Implement the most important network 
 protocols in Tcl.
  
 Packed with hands-on-examples, case 
 studies, and clear explanations for better 
 understanding.
  
  
 Please check 
 www.PacktPub.com
  for information on our titles",NA
