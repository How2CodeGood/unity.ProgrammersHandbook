Larger Text,Smaller Text,Symbol
Ruby for Rails,Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>,NA
Ruby for ,NA,NA
Rails ,NA,NA
R,UBY,NA
 T,ECHNIQUESFOR,NA
 ,NA,NA
R,AILS,NA
 D,EVELOPERS,NA
DAVID A. BLACK,"M A N N I N G 
  
  
  
 Greenwich 
  
  
 (74° w. long.)",NA
brief contents,NA,NA
P,NA,NA
ART,NA,NA
 I,NA,NA
T,NA,NA
HE,NA,NA
 R,NA,NA
UBY,NA,NA
/R,NA,NA
AILSLANDSCAPE,NA,NA
 ...........................1,"1
  
 ■
  How Ruby works
  
 3
  
 2
  
 ■
     How Rails works
  
 33
  
 3
  
 ■
     Ruby-informed Rails development
  
 67",NA
P,NA,NA
ART,NA,NA
 II,NA,NA
R,NA,NA
UBYBUILDINGBLOCKS,NA,NA
 ................................93,"4
  
 ■
     Objects and variables
  
 95
  
 5
  
 ■
     Organizing objects with classes
  
 121
  
 6
  
 ■
     Modules and program organization
  
 154
  
 7
  
 ■
     The default object (self) and scope
  
 177
  
 8
  
 ■
     Control flow techniques
  
 206",NA
P,NA,NA
ART,NA,NA
 III ,NA,NA
B,NA,NA
UILT,NA,NA
-,NA,NA
INCLASSESANDMODULES,NA,NA
 ...............231,"9
  
 ■
     Built-in essentials
  
 233
  
 10
  
 ■
     Scalar objects
  
 257
  
 11
  
 ■
     Collections, containers, and enumerability
  
 277
  
 vii
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
P,NA,NA
ART,NA,NA
 IV ,NA,NA
R,NA,NA
AILSTHROUGH,NA,NA
 R,NA,NA
UBY,NA,NA
", ",NA,NA
RRRRRRRR,NA,NA
I,NA,NA
R,NA,NA
UBYTHROUGH,NA,NA
 R,NA,NA
AILS,NA,NA
 ............................. 369,"14 
  
 15 
  
 16 
  
 17
  
 appendix
  
 ■
     (Re)modeling the R4RMusic application universe
  
 371
  
 ■
     Programmatically enhancing ActiveRecord models
  
 392
  
 ■
     Enhancing the controllers and views
  
 422
  
 ■
     Techniques for exploring the Rails source code
  
 455
  
 ■
     Ruby and Rails installation and resources
  
 471
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
contents,"foreword
  
 xix
  
 xxxii
  
 preface
  
 xxi
  
 acknowledgments
  
 xxiii
  
 about this book
  
 xxvi
  
 about the cover illustration",NA
P,NA,NA
ART,NA,NA
 1 T,NA,NA
HE,NA,NA
 R,NA,NA
UBY,NA,NA
/R,NA,NA
AILSLANDSCAPE,NA,NA
 ...........................1,NA,NA
1 ,NA,NA
How Ruby ,NA,NA
works,NA,NA
3,"1.1 
 The mechanics of writing a Ruby program 
 4 
 Getting the preliminaries in place
  
 5  
 ■
   A Ruby literacy bootstrap 
  
 guide
  
 5  
 ■
   A brief introduction to method calls and Ruby 
 objects
  
 7
  
 Writing and saving a sample 
 program
  
 8  
 ■
   Feeding the program to 
  
 Ruby
  
 9  
 ■
   Keyboard and file input
  
 11  
 ■
   One program, 
  
 multiple files
  
 14
  
 1.2 
 Techniques of interpreter invocation 
 15 
 Command-line switches
  
 16  
 ■
   A closer look at 
  
 interactive Ruby interpretation with 
 irb
  
 20
  
 1.3 
 Ruby extensions and programming libraries 
 21 
 Using standard extensions and 
 libraries
  
 21  
 ■
   Using 
  
 C extensions
  
 22  
 ■
   Writing extensions and 
 libraries
  
 23
  
 ix
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
2 ,NA,NA
3 ,"Ruby installation
  
 25  
 ■
   Important standard Ruby tools 
  
 and applications
  
 27
  
 1.5 
 Summary 31",NA
How Rails ,NA,NA
works,NA,NA
33,"2.1 
 Inside the Rails framework 34 
 A framework user’s–eye view of application 
 development
  
 35
  
 Introducing the MVC framework 
 concept
  
 36
  
 Meet MVC in the (virtual) flesh
  
 37
  
 2.2 
 Analyzing Rails’ implementation of MVC 
 38 
 2.3 
 A Rails application walk-through 
 41 
 Introducing R4RMusic, the music-store 
 application
  
 42
  
 Modeling the first iteration of the music-store 
 domain
  
 43
  
 Identifying and programming the 
 actions
  
 50  
 ■
   Designing 
  
 the views
  
 53  
 ■
   Connecting to the application
  
 58
  
 2.4 
 Tracing the lifecycle of a Rails run 
 59 
 Stage 1: server to dispatcher
  
 61  
 ■
   Stage 2: dispatcher 
  
 to controller
  
 62  
 ■
   Stage 3: performance of a controller 
  
 action
  
 62  
 ■
    Stage 4: the fulfillment of the 
 view
  
 65
  
 2.5 
 Summary 65",NA
Ruby-informed Rails ,NA,NA
development,NA,NA
67,"3.1 
 A first crack at knowing what your code does 
 69 
 Seeing Rails as a domain-specific 
 language
  
 70  
 ■
   Writing program 
  
 code with a configuration flavor
  
 73  
 ■
   YAML and configuration 
  
 that’s actually programming
  
 75
  
 3.2 
 Starting to use Ruby to do more in your code 
 77 
 Adding functionality to a controller
  
 79  
 ■
   Deploying the Rails helper 
  
 files
  
 80  
 ■
   Adding functionality to 
 models
  
 82
  
 3.3 
 Accomplishing application-related skills and tasks 
 85 
 Converting legacy data to 
 ActiveRecord
  
 85
  
 The irb-based Rails application 
 console
  
 89
  
 3.4 
 Summary 90 
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
P,NA,NA
ART,NA,NA
 2 R,NA,NA
UBYBUILDINGBLOCKS,NA,NA
 .................................93,NA,NA
4 ,NA,NA
5 ,NA,NA
Objects and ,NA,NA
variables,NA,NA
95,"4.1 
 From “things” to objects 
 96 
 Introducing object-oriented 
 programming
  
 97  
 ■
   I, 
 object!
  
 98
  
 Modeling objects more closely: the behavior of a 
 ticket
  
 103
  
 4.2 
 The innate behaviors of an object 
 108 
 Identifying objects uniquely with the object_id 
 method
  
 109
  
 Querying an object’s abilities with the respond_to? 
 method
  
 110
  
 Sending messages to objects with the send 
 method
  
 111
  
 4.3 
 Required, optional, and default-valued arguments 
 112 
 Required and optional arguments
  
 112  
 ■
   Default values for 
  
 arguments
  
 113  
 ■
   Order of arguments
  
 114
  
 4.4 
 Local variables and variable assignment 
 115 
 Variable assignment in depth
  
 117  
 ■
   Local variables 
  
 and the things that look like them
  
 119
  
 4.5 
 Summary 120",NA
Organizing objects with ,NA,NA
classes,NA,NA
121,"5.1 Classes and instances 
 122 
 A first class
  
 123  
 ■
   Instance variables and object state
  
 126
  
 5.2 
 Setter methods 
 130 
 The equal sign (=) in method 
 names
  
 131
  
 ActiveRecord properties and other =-method 
 applications
  
 133
  
 5.3 
 Attributes and the attr_* method family 
 136 
 Automating the creation of attribute 
 handlers
  
 137  
 ■
   Two (getter/
  
 setter) for one
  
 138  
 ■
   Summary of attr_* methods
  
 139
  
 5.4 
 Class methods and the Class class 140 
 Classes are objects too!
  
 140  
 ■
   When, and why, to write a class 
  
 method
  
 141  
 ■
   Class methods vs. instance methods, 
 clarified
  
 143
  
 The Class class and Class.new
  
 144
  
 5.5 
 Constants up close 
 145 
 Basic usage of constants
  
 145  
 ■
   Reassigning vs. 
  
 modifying constants
  
 146
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
6 ,NA,NA
Modules and program ,NA,NA
organization,NA,NA
154,"6.1 
 Basics of module creation and use 
 155 
 A module encapsulating “stack-like-
 ness”
  
 157  
 ■
   Mixing a module 
  
 into a class
  
 158  
 ■
   Leveraging the module further
  
 160
  
 6.2 
 Modules, classes, and method lookup 
 163 
 Illustrating the basics of method 
 lookup
  
 163  
 ■
   Defining the same 
  
  
 method more than 
 once 
  
 with super 168
  
 166  
 ■
   Going up the method search path",NA
7 ,"6.3 
 Class/module design and naming 
 170 
 Mix-ins and/or inheritance
  
 171  
 ■
   Modular organization 
  
 in Rails source and boilerplate code
  
 173
  
 6.4 Summary 
 176",NA
The default object (self) and ,NA,NA
scope,NA,NA
177,"7.1 
  Understanding self, the current/default object 
 179 
 Who gets to be self, and where
  
 179  
 ■
   Self as default receiver of 
  
 messages
  
 184  
 ■
   Instance variables and 
 self
  
 186
  
 7.2 
 Determining scope 
 188 
 Global scope and global variables
  
 188  
 ■
   Local scope
  
 191
  
 Scope and resolution of constants
  
 194
  
 7.3 
 Deploying method access rules 
 197 
 Private methods
  
 197  
 ■
   Private methods as ActionController 
  
 access protection
  
 199  
 ■
   Protected methods
  
 201
  
 7.4 
 Writing and using top-level methods 
 203 
  
 7.5 
 Defining a top-level method 203  
 ■
   Predefined (built-in) 
  
 top-level methods 
  
 204
  
 Summary 205",NA
8 ,NA,NA
Control flow ,NA,NA
techniques,NA,NA
206,"211
  
 8.1 
 Conditional code execution 
 207 
 The if keyword and friends
  
 208  
 ■
   Conditional modifiers",NA
P,NA,NA
ART,NA,NA
 3 B,NA,NA
UILT,NA,NA
-,NA,NA
INCLASSESANDMODULES,NA,NA
 ...................231,NA,NA
9 ,NA,NA
Built-in ,NA,NA
essentials,NA,NA
233,"238 
 9.1 Ruby’s literal constructors 
 234 
 9.2 
 Recurrent syntactic sugar 236 
 Special treatment of +=
  
 237
  
 9.3 
 Methods that change their receivers (or don’t) 
 Receiver-changing basics
  
 239  
 ■
   bang (!) methods
  
 240
  
 Specialized and extended receiver-changing  in 
  
 9.4 
 ActiveRecord 
 objects
  
 241
  
 252
  
 Built-in and custom to_* (conversion) methods 
 242 
 9.5 
 Writing your own to_* 
 methods
  
 243
  
 Iterators 
 reiterated 
 244 
 9.6 
 Boolean states, Boolean objects, and nil 
 245 
 9.7 
 True and false as states
  
 246  
 ■
   true and false as 
 objects
  
 248
  
 The special object 
 nil
  
 249
  
 Comparing two objects 
 251 
 9.8 
 Equality 
 tests
  
 251  
 ■
   Comparisons and the Comparable 
 module
  
 Listing an object’s methods 
 253 
 9.9 
 Generating filtered and selective method 
 lists
  
 254
  
 Summary 
 255 
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
10 ,NA,NA
Scalar objects,NA,NA
257,"260
  
 10.1 
 Working with strings 258 
 String basics
  
 258  
 ■
   String 
 operations
  
 Comparing strings
  
 265
  
 10.2 
 Symbols and their uses 
 267 
 Key differences between symbols and strings
  
 267
  
 Rails-style method arguments, revisited
  
 268
  
 10.3 
 Numerical objects 
 270 
 Numerical classes
  
 270  
 ■
   Performing arithmetic 
 operations
  
 271
  
 10.4 
 Times and dates 
 272 
 10.5 
 Summary 275",NA
11 ,NA,NA
"Collections, containers, and ",NA,NA
enumerability,NA,NA
277,"11.1 
 Arrays and hashes compared 
 278 
 11.2 
 Using arrays 279 
 Creating a new array
  
 279  
 ■
   Inserting, retrieving, and removing 
 array 
  
 elements
  
 280  
 ■
   Combining arrays with other 
 arrays
  
 283  
 ■
   Array 
  
 transformations
  
 285  
 ■
   Array iteration, filtering, and 
 querying
  
 286
  
 Ruby lessons from ActiveRecord collections
  
 289
  
 11.3 
 Hashes 
 292 
 Creating a new hash
  
 293  
 ■
   Inserting, retrieving, and removing 
 hash 
  
 pairs
  
 294  
 ■
   Combining hashes with other hashes
  
 296  
 ■
   Hash 
  
 transformations
  
 297  
 ■
   Hash iteration, filtering, and 
 querying
  
 298
  
 Hashes in Ruby and Rails method calls
  
 301
  
 11.4 
 Collections central: the Enumerable module 
 303 
 Gaining enumerability through each
  
 304
  
 Strings as Enumerables
  
 306
  
 11.5 
 Sorting collections 
 307 
 Sorting and the Comparable module
  
 309
  
 Defining sort order in a block
  
 310
  
 11.6 
 Summary 311",NA
12 ,NA,NA
Regular expressionsand regexp-basedstring ,NA,NA
operations,NA,NA
312,"12.1 
 What are regular expressions? 
 313 
 314
  
 A word to the regex-wise
  
 314  
 ■
   A further word to 
 everyone
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
13 ,"CONTENTS
  
 xv
  
 12.2 
 Writing regular expressions 314 
 The regular expression literal 
 constructor
  
 315
  
 Building a pattern
  
 316
  
 12.3 
 More on matching and MatchData 
 319 
 Capturing submatches with 
 parentheses
  
 319
  
 Match success and failure
  
 321
  
 12.4 
 Further regular expression techniques  
 323 
 Quantifiers and greediness
  
 323  
 ■
   Anchors and lookahead 
  
 assertions
  
 326  
 ■
   Modifiers
  
 328  
 ■
   Converting strings and 
  
 regular expressions to each other
  
 329
  
 12.5 
 Common methods that use regular expressions 
 331 
 String#scan
  
 332  
 ■
   
 String#split
  
 332  
 ■
   sub/sub! and 
  
 gsub/gsub!
  
 333  
 ■
   grep
  
 334
  
 12.6 
 Summary 335",NA
Ruby dynamics,NA,NA
337,"13.1 
 The position and role of singleton classes 
 338 
 Where the singleton methods live
  
 339  
 ■
   Examining and modifying a 
  
 singleton class directly
  
 340  
 ■
   Singleton classes on the method 
 lookup 
  
 path
  
 342  
 ■
   Class methods in (even more) depth
  
 345
  
 13.2 
 The eval family of methods 
 347 
 eval
  
 347  
 ■
   instance_eval
  
 349  
 ■
   The most useful 
  
 eval: class_eval (a.k.a. module_eval)
  
 349
  
 13.3 
 Callable objects 
 351 
 Proc objects
  
 351  
 ■
   Creating anonymous functions with the 
  
 lambda keyword
  
 355  
 ■
   Code blocks, 
 revisited
  
 356  
 ■
   Methods 
  
 as objects
  
 357
  
 13.4 
 Callbacks and hooks 
 359 
 Intercepting unrecognized messages with 
 method_missing
  
 360
  
 Trapping include operations with 
 Module#included
  
 361
  
 Intercepting inheritance with 
 Class#inherited
  
 363
  
 Module#const_missing
  
 365
  
 13.5 
 Overriding and adding to core functionality 
 365 
 A cautionary tale
  
 366
  
 13.6 
 Summary 367 
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
P,NA,NA
ART,NA,NA
 4 R,NA,NA
AILSTHROUGH,NA,NA
 R,NA,NA
UBY,NA,NA
", ",NA,NA
U,NA,NA
UUUUUU,NA,NA
R,NA,NA
UBYTHROUGH,NA,NA
 R,NA,NA
AILS,NA,NA
 ..................................369,NA,NA
14 ,NA,NA
15 ,NA,NA
16 ,NA,NA
(Re)modeling the R4RMusic application ,NA,NA
universe,NA,NA
371,"14.1 
 Tracking the capabilities of an  
 ActiveRecord model instance 372 
 An overview of model instance 
 capabilities
  
 373
  
 Inherited and automatic ActiveRecord model 
 behaviors
  
 374
  
 Semi-automatic behaviors via 
 associations
  
 378
  
 14.2 
 Advancing the domain model 
 380 
 Abstracting and adding models (publisher and 
 edition)
  
 380
  
 The instruments model and many-to-many 
 relations
  
 382
  
 Modeling for use: customer and 
 order
  
 386
  
 14.3 Summary 
 390",NA
Programmatically enhancing ActiveRecord ,NA,NA
models,NA,NA
392,"15.1 
 Soft vs. hard model enhancement 
 393 
 An example of model-enhancement 
 contrast
  
 394
  
 15.2 
 Soft programmatic extension of models 
 396 
 Honing the Work model through soft 
 enhancements
  
 398  
 ■
   Modeling 
  
 the customer’s business
  
 399  
 ■
   Fleshing out the Composer
  
 401
  
 Ruby vs. SQL in the development of soft 
 enhancements
  
 401
  
 15.3 
 Hard programmatic enhancement of model  
 functionality 404 
 Prettification of string properties
  
 404  
 ■
   Calculating a work’s 
  
 period
  
 409  
 ■
   The remaining business of the 
 Customer
  
 414
  
 15.4 
 Extending model functionality with class methods 
 419 
 Soft and hard class methods
  
 419
  
 15.5 Summary 
 421",NA
Enhancing the controllers and ,NA,NA
views,NA,NA
422,"16.1 
 Defining helper methods for view templates 
 424 
 Organizing and accessing custom helper 
 methods
  
 425
  
 The custom helper methods for 
 R4RMusic
  
 427
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
17 ,NA,NA
appendix,NA,NA
Techniques for exploring the Rails source ,NA,NA
code,NA,NA
455,"17.1 
 Exploratory technique 1: panning for info 
 456 
 Sample info panning: belongs_to
  
 457
  
 17.2 
 Exploratory technique 2: shadowing Ruby 
 458 
 Choosing a starting point
  
 458  
 ■
   Choose among forks in the 
  
 road intelligently
  
 459  
 ■
   On the trail of 
 belongs_to
  
 460
  
 A transliteration of belongs_to
  
 463
  
 17.3 
 Exploratory technique 3: consulting the  
 documentation 464 
 A roadmap of the online Rails API 
 documentation
  
 466
  
 17.4 Summary 469",NA
Ruby and Rails installation and ,NA,NA
resources,NA,NA
471,NA,NA
index,NA,NA
477,NA,NA
foreword,"I can’t learn a language for the sake of it. I need to have a concrete desire to do 
 some-thing with it—to solve a problem or a task, to create something of value... 
 That’s how I got into Ruby around the summer of 2003. I wanted to build a Web 
 application and decided this was the perfect opportunity to learn Ruby. That Web 
 application was Basecamp, which eventually served as the point of extraction for 
 Rails.
  
  Coming from PHP and Java, I remember how many of Ruby’s most wonderful 
 features seemed odd at first. “What is it exactly that makes blocks so special?” I 
 thought. “They’re just convenience for writing a line of code at the beginning and 
 the end.” Little did I know... As I started using Ruby and extracting Rails, I quickly 
 wised up. Ruby is such an incredibly rich and expressive language that it’s hard to 
 appreciate its beauty by simply relating it to past experiences with other 
 languages.
  
  To create Basecamp, I needed to live and breathe Ruby. And when I did, I kept 
 finding aspects of the language that were exactly what I needed for the situation at 
 hand. Tasks that would have made my eyes roll in PHP or Java made my smile light 
 up as Ruby time and time again showed that programming could be simple, fun, 
 and outright beautiful.
  
  As I was learning the language, I often consulted the ruby-talk mailing list. One 
 voice in particular seemed to know Ruby well and appeared to have the ambition 
 as well as the ability to help others understand it more fully. That voice belonged 
 to David A. Black, the author of this book.
  
 xix",NA
preface,"When the editors at Manning asked me whether I thought the time was ripe for a 
 new Ruby book, and if so, what it should be about and who should write it, I 
 answered:
  
  
  “Yes
 ....  
 A Ruby language book purpose-written for Rails practitioners.... Me.”
  
  
 They agreed.
  
  I warmly welcomed the opportunity. I’d been thinking along “Ruby for 
 Rails”lines since I started using the Ruby on Rails framework in the Fall of 2004 
 (which, by the way, makes me an almost-early adopter). Rails had been first 
 released that summer, and I learned about it from the presentation by David 
 Heinemeier Hans-son, the creator of Rails, at the 2004 International Ruby 
 Conference.
  
 Ruby for Rails
  sounds like it might mean “…as opposed to regular Ruby,” a tool 
 for dividing Ruby users into Rails and non-Rails camps. I saw it as the opposite: 
 real Ruby, regular Ruby, on its own terms, but studied primarily because of what it 
 can do for Rails developers. I was in a good position to understand the potential of 
 this approach: I’d been programming in Ruby for almost four years before I started 
 using Rails; and when I did start using it, I quickly gained a view of how a deeper 
 knowledge of Ruby could help Rails programmers achieve their goals. 
  
  An alarm went off in my head, therefore, when I saw how many budding Rails 
 developers were asking themselves whether it was necessary to learn Ruby in 
 order to use Rails. The fact that this question was the subject of disagreement and 
 debate surprised me. And it suggested a couple of points. 
  
 xxi",NA
acknowledgments,"This book has benefited from support of many kinds from many quarters. 
  
  At Manning Publications, assistant acquisitions editor Megan Yockey and pub-
 lisher’s assistant Blaise Bace saw me ably and enthusiastically through the 
 proposal and contract phases of the project. I worked initially, and productively, 
 with devel-opment editor Doug Bennett; subsequently, for reasons of scheduling 
 and logis-tics, my project was reassigned to development editor Lianna Wlasiuk, 
 who worked with me in an intense, sustained way through the writing of the book, 
 cou-pling a marvelous collegiality with a gentle but firm refusal to settle for 
 anything other than a strong, polished product. 
  
  Review editor Karen Tegtmeyer sought, and found, specialists from both the 
 Ruby and Rails spheres to review the manuscript at the various prescribed phases 
 of partial completion—a process I like to think I became less surly about, the more 
 evidence I saw of how materially helpful it could be. Book designer Dottie Marsico 
 worked with me on the illustrations; I have Dottie to thank for my new-found 
 OpenOffice Draw skills as well as for her encouragement and quick respon-
 siveness to questions and concerns. 
  
  As the book moved through the latter stages of preparation and into the pro-
 duction stages, I had the indispensable support and help of production director 
 Mary Piergies, who coordinated the geographically far-flung process in a way that 
 brought it unity and momentum. To copy editor Tiffany Taylor I can pay no greater 
 tribute than to say that I quickly got into the habit of telling OpenOffice to hide the 
 history of changes in the document and only show me the text as it
  
 xxiii
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
about this book,"Welcome to 
 Ruby for Rails
 . This book is an introduction to the Ruby programming 
 language, purpose-written for people whose main reason for wanting to know 
 Ruby is that they’re working with, or are interested in working with, the Ruby on 
 Rails framework and want to do Rails knowledgeably and right. 
  
  Ruby is a general-purpose, object-oriented, interpreted programming language 
 designed and written by Yukihiro Matsumoto (known widely as “Matz”). Intro-
 duced in 1994, Ruby rose rapidly in popularity among Japanese programmers. By 
 the early 2000s, more than twenty Japanese-language books on Ruby had been 
 pub-lished. The first English-language book on Ruby, 
 Programming Ruby
  by Dave 
 Tho-mas and Andy Hunt, appeared in late 2000 and ushered in a wave of Ruby 
 enthusiasm outside of Japan. Ruby’s popularity in the West has grown steadily 
 since the appearance of the “Pickaxe book” (the nickname of the Thomas-Hunt 
 work, derived from its cover illustration). 
  
  But 2004 saw a second massive surge of interest, with the introduction of the 
 Ruby on Rails Web application framework by David Heinemeier Hansson. Built on 
 a cluster of separate component libraries, the Rails framework handles data-base 
 storage and retrieval, 
 HTML
  templating, and all the middle-layer work neces-sary 
 to connect the underlying data to the Web pages and input forms that display and 
 update it. 
  
  Rails has grown very rapidly in popularity, gaining a solid, wide reputation as a 
 tremendously powerful development tool. Partly cause, partly effect, Ruby has
  
 xxvi
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
about the cover ,NA,NA
illustration,"The figure on the cover of 
 Ruby for Rails
  is an “Officer of the Grand Signoir,” or an 
 officer in the army of the Ottoman Sultan. The illustration is taken from a collec-
 tion of costumes of the Ottoman Empire published on January 1, 1802, by Will-iam 
 Miller of Old Bond Street, London. The title page is missing from the collection and 
 we have been unable to track it down to date. The book’s table of contents 
 identifies the figures in both English and French, and each illustration bears the 
 names of two artists who worked on it, both of whom would no doubt be surprised 
 to find their art gracing the front cover of a computer programming book...two 
 hundred years later.
  
  The collection was purchased by a Manning editor at an antiquarian flea mar-
 ket in the “Garage” on West 26th Street in Manhattan. The seller was an American 
 based in Ankara, Turkey, and the transaction took place just as he was packing up 
 his stand for the day. The Manning editor did not have on his person the substan-
 tial amount of cash that was required for the purchase and a credit card and check 
 were both politely turned down. With the seller flying back to Ankara that evening 
 the situation was getting hopeless. What was the solution? It turned out to be 
 nothing more than an old-fashioned verbal agreement sealed with a hand-shake. 
 The seller simply proposed that the money be transferred to him by wire and the 
 editor walked out with the bank information on a piece of paper and the portfolio 
 of images under his arm. Needless to say, we transferred the funds the
  
 xxxii",NA
Part 1,NA,NA
The Ruby/Rails ,NA,NA
landscape,NA,NA
T,"his book is about the Ruby programming language, viewed chiefly from the 
 perspective of interest in the Ruby on Rails framework. The goal of this first part of 
 the book is to familiarize you with the landscape of both Ruby and Rails: what’s 
 there, and why, and how it all connects.
  
  
 This part contains three chapters: 
  
  
 Chapter 1, “How Ruby works,” is about the Ruby programming environment: how 
 to write and execute a Ruby program; where the files associated with Ruby are 
 located; and what tools Ruby gives you (in addition to the Ruby interpreter itself) to 
 help you write and maintain programs.
  
  
 Chapter 2, “How Rails works,” gives you a guided tour of the basic structure of the 
 Ruby on Rails framework: its components and how they interact; how the Rails 
 framework fits together with Ruby; and the relation between and among Ruby, Rails, 
 and a given Rails application. It also includes the first version of the book’s major 
 sample Rails application, the R4RMusic online sheet-music store. (The sec-ond 
 version of R4RMusic will be developed in part 4 of the book.) 
  
  
 Chapter 3, “Ruby-informed Rails development,” is a plunge into the process of 
 understanding in specific terms the ways that knowing Ruby well can help you as a 
 Rails developer. This chapter is thus a first fulfillment of the book’s overall goal—
 and, at the same time, an anchor for the detailed exploration of the Ruby lan-guage 
 to come in the next two parts.",NA
How Ruby works,"This chapter covers
  
  
 ■
  A Ruby literacy bootstrap guide
  
  
 ■
  An overview of the Ruby 
  
  
 programming environment
  
  
 ■
  Walk-throughs of sample Ruby programs
  
 3",NA
1.1 The mechanics of writing a Ruby program,"The goal of this section is to take you through the actual process of writing and 
 running a Ruby program. Don’t worry if some of what you see appears to be a bit of 
 a black box for the moment. The breadth-first approach we’re taking will help to 
 bootstrap you into the programming cycle from beginning to end. This, in turn, will 
 give you your bearings for the rest of the chapter and the detailed dis-cussion of 
 the Ruby language that lies ahead in parts 2 and 3. 
  
 NOTE
  
 Ruby, ruby, and
  … RUBY?!
  
 Ruby is a programming language. We talk
  
 about things like “learning Ruby,” and we ask questions like, “Do you 
 know Ruby?” The lowercase version, 
 ruby
 , is a computer program; specif-
 ically, it’s the Ruby 
 interpreter
 , the program that reads 
 your
  programs and 
 runs them. You’ll see this name used in sentences like, “I ran 
 ruby
  on my 
 file, but nothing happened,” or “What’s the full path to your 
 ruby
  execut-
 able?” Finally, there’s 
 RUBY
 —or, more precisely, there isn’t. Ruby isn’t an 
 acronym, and it’s never correct to spell it in all capital letters. People do 
 this, as they do (also wrongly) with Perl, perhaps because they’re used to 
 seeing language names like 
 BASIC
  and 
 FORTRAN
 . Ruby is not such a 
 language. It’s Ruby for the language, 
 ruby
  for the interpreter.",NA
1.2 Techniques of interpreter invocation,"You’ve roughed out the lifecycle of a Ruby program. Now you’re in a position to 
 back-and-fill a bit.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
1.3 Ruby extensions and programming libraries,"Earlier, you saw a simple example of the use of 
 require
  to pull in one file from 
 another during program execution. 
 require
  is the foundation of a huge amount of 
 Ruby’s power and richness as a programming language. Specifically, this mech-
 anism gives you access to the many 
 extensions
  and 
 programming libraries
  bundled 
 with the Ruby programming language—as well as an even larger number of exten-
 sions and libraries written independently by other programmers and made avail-
 able for use with Ruby. 
  
  The full range of Ruby’s standard library is outside of the scope of this book. 
 This section provides guidelines and pointers about what Ruby offers and how to 
 use libraries in your own programs. 
  
 1.3.1 Using standard extensions and libraries
  
 When you install Ruby on your system, you really install several layers. First is the 
 core Ruby language:
  the basic operations and programming techniques available 
 when you run the Ruby interpreter. 
  
  Second are a large number of 
 extensions
  and 
 programming libraries
  bundled 
 with Ruby—add-ons that help you write programs in different areas of 
 specialization. These are usually referred to collectively as the 
 standard library
 . 
 Ruby comes with extensions for a wide variety of projects and tasks: database 
 management, net-working, specialized mathematics, 
 XML
  processing, and many 
 more.",NA
1.4 Anatomy of the Ruby programming environment,"Installing Ruby on your system means installing numerous components of the lan-
 guage, possibly including the source code for the language, and definitely includ-
 ing a number of disk directories’ worth of Ruby-language libraries and support 
 files. You won’t necessarily use everything in this section every time you write 
 something in Ruby, but it’s good to know what’s there. Also, quite a few of the pro-
 gramming libraries that come bundled with Ruby are written 
 in
  Ruby—so know-
 ing your way around the Ruby installation will enable you to look at some well-
 written Ruby code and (we hope) absorb some good habits. 
  
  We’ll start with the Ruby source code.
  
 1.4.1 The layout of the Ruby source code
  
 The Ruby source code directory (tree) contains the files that house the program 
 code for the Ruby interpreter as well as a number of bundled add-ons. The core 
 Ruby language is written in C, so in order to read and fully understand the files, 
 you need to know C. But even if you don’t know C, you can learn a lot from perus-
 ing the comments and documentation contained in the source files. 
  
 TIP
  
 MAKE SURE YOUR PACKAGE MANAGER GIVES YOU ALL OF RUBY
  
 If you in-
  
 stall Ruby via a remote package manager, you may not end up with the 
 Ruby source on your machine. If that happens, and you want the source, 
 check for a package named “ruby-source” or something similar. If there’s 
 no such package, you can download the source from 
 ruby-lang.org
  and 
 un-tar it. See the book’s appendix for more information about installing 
 Ruby and pointers on how to get platform-specific information.
  
 If you examine a directory listing of the top-level directory of the Ruby source tree, 
 you’ll see the following:
  
 ■
  Several subdirectories, including 
 ext/
  and 
 lib/
  (both discussed shortly)
  
 ■
  Informational, legal, and license-related files (such as 
 COPYING
 , 
 GPL
 , and 
  
 README
 )
  
 ■
  Files pertaining to the process of building and installing Ruby (all the 
 con-
  
 fig*
  files, 
 Makefile.in
 , 
 install-sh
 , and so on)
  
 ■
  C program and header files (
 *.c
  and 
 *.h
 )
  
 Some of these files are only needed during the building of Ruby. Some of them are 
 copied over directly when Ruby is installed. And, of course, the building process",NA
1.5 Summary,"In this chapter, we’ve walked through some important foundational Ruby mate-rial 
 and facilities. You’ve learned some important terminology, including the dif-
 ference between Ruby (the programming language overall) and 
 ruby
  (the name of 
 the Ruby interpreter program). You’ve completed (in miniature, but still from start 
 to finish) the process of writing a Ruby program, saving it in a file, checking it for 
 syntax errors, and running it. You’ve gotten a taste of how to do keyboard input in 
 Ruby as well as file input and output. You’ve also learned how to pull in one 
 program file from another with 
 require
  and 
 load
 .
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
How Rails works,"This chapter covers
  
  
 ■
  Overview of the Rails framework
  
  
 ■
  Details of how Rails handles incoming requests
  
  
 ■
  Domain modeling and database creation
  
  
 ■
  A complete sample Rails application
  
 33",NA
2.1 Inside the Rails framework,"A framework is a program, set of programs, and/or code library that writes most of 
 your application for you. When you use a framework, your job is to write the parts 
 of the application that make it do the specific things you want.
  
 NOTE
  
 GETTING RAILS AND RAILS INFORMATION
  
 This book’s appendix contains
  
 information about installing Rails and pointers on where to get more in-
 formation. You may be working on a system with Rails installed already; 
 but if not, or if you want to make sure you have your finger on the pulse of 
 the major sources of Rails information, look at the appendix. 
  
 The term 
 framework
  comes from the field of building construction, where it refers 
 to a partially built house or building. Once a house reaches the framework stage, 
 much of the work of building is done—but the house looks exactly like any other 
 house in the same style at the same stage. It’s only after the framework is in place 
 that the builders and designers start to do things that make the house distinct from 
 other houses. 
  
  Unlike scaffolding, which gets removed once the house is built, the framework 
 is part of the house. That’s true in the case of Ruby on Rails, too. When you run 
 your application, the Rails framework—the code installed in the various Rails 
 directories on your computer—is part of it. You didn’t write that code, but it’s still 
 part of your application; it still gets executed when your application runs.",NA
2.2 Analyzing Rails’ implementation of MVC,"The 
 MVC
  concept is all about dividing the work of programming and the func-
 tioning of a program into three layers: model, view, and controller. In accordance 
 with its 
 MVC
  foundations, Rails is made up largely of three separate programming 
 libraries—separate in the sense that each has its own name and you can, if you 
 need to, use them separately from each other. 
  
  The three libraries forming the bulk of the Rails framework are listed in table 
 2.1. You can see these three libraries installed on your computer. They usu-ally 
 reside in the 
 gems
  area of a Ruby installation. (See the book’s appendix for 
 information about RubyGems.) Assuming a standard, default installation, you can 
 find them like this:
  
 $ cd 
 /usr/local/lib/ruby/gems/1.8/gems 
  
 $ ls",NA
2.3 A Rails application walk-through,"The steps we’ll follow in writing the 
 R4RM
 usic application are, in essence, the three 
 steps outlined at the beginning of this chapter and echoed in the 
 MVC
  con-cept—or, 
 in keeping with how we’ll proceed initially, the 
 MCV
  concept: modeling the domain, 
 programming the possible actions, and designing the available views. The goal at 
 the moment is to have something in place that we can add to incre-mentally. That’s 
 often the way Rails applications evolve.
  
 NOTE DOWNLOADING THE MUSIC STORE CODE AND SQL FROM THE BOOK’S WEB SITE 
  
 You can download the complete application code for 
 R4RM
 usic (both the 
 version developed in this chapter and the revised version devel-oped in part 4), 
 along with files containing the 
 SQL
  commands for creat-ing the tables and adding 
 some sample data to them, from the 
 Ruby for Rails
  Web site 
 (http://www.manning.com/books/black). Doing so will
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"<% @composers.each do |composer| %> 
  
  
 each 
  
 metho
 d
  
  <li><%= link_to ""#{composer.first_name} #{composer.last_name}"",
   
  :controller => ""composer"",
  
   
  :action     => ""show"",
  
   
  :id         => composer.id %>
  
  </li>
  
  <% end %> 
  
 </ul>
  
  
  
  
 The main action here is a loop, which goes through the list of works one at a time 
 (that’s the gist of the 
 each
  method 
 dd
 ). Each time through the loop, a list item is",NA
B,"created, complete with a hyperlink generated by the built-in Rails helper method 
 link_to
 . The advantage of automating the creation of the list of links in this man-
 ner is that it scales: Once you’ve written this template, together with the controller 
 that populates the 
 @composers
  variable in the first place (which takes all of two 
 lines of code), you never have to change it, whether your database has 3 compos-
 ers or 300. (With 300 composers, you may want to present them differently—a list 
 of letters, perhaps, each linked to a second-level action and template that displays 
 all the composers whose last names start with that letter. But once you’ve written 
 the templates you want, they deal with whatever data is thrown at them.)
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"@work.edition
 s method
  
  <% @work.editions.each do |ed| %> 
  
  <tr>
  
   
  <td><%= link_to ed.description || ""(no descr.)"",
    
  :controller => ""edition"",
  
    
  :action     => ""show"",
  
    
  :id         => ed.id %></td>
  
   
  <td><%= ed.publisher %></td>
  
  </tr>
  
  <% end %> 
  
 </table>
  
  
  
 In the 
 work/show.rhtml
  template, as in the 
 main/welcome
  template, an 
 each 
 instruction performs a loop through a list—this time, a list accessed through the 
 method call 
 @work.editions
 a
  ). Note that nowhere in any file have we defined a",NA
B,Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>,NA
2.4 Tracing the lifecycle of a Rails run,"You’ve seen the way a framework helps organize an application, and you’ve seen 
 the way Rails implements the 
 MVC
  concept. You’ve also walked through the pro-
 cess of writing and running a Rails application—a modest one, but one that 
 involves the three major steps. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
2.5 Summary,"In this chapter, we’ve surveyed the engineering of the Ruby on Rails framework. 
 You’ve read about the 
 MVC
  framework architecture and the Rails implementation 
 of it through ActiveRecord (which models entities based on database design), 
 ActionView (which provides templating facilities based on 
 ERb
 ), and ActionCon-
 troller (which runs interference between the data manipulation and its presenta-
 tion). You’ve also gone through the process of creating and running a working Rails 
 application—an application that you’ll be able to enhance in part 4 of the book, 
 thanks to your study of the Ruby language in the intervening chapters. We’ve taken 
 a close look at the stages involved in the processing of an incoming
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
Ruby-,NA,NA
informed Rails ,NA,NA
development,"In this chapter
  
  
 ■
  Exploration of Rails code as Ruby code
  
  
 ■
  Rails as a domain-specific language
  
  
 ■
  Configuration-like programming, and 
  
  
 programming-like configuration
  
  
 ■
  Walk-through of sample enhancements to 
  
  
 controller and model files
  
  
 ■
  Tips on legacy data conversion with Ruby
  
 67",NA
3.1 A first crack at knowing what your code does,"It’s hard to imagine that a case needs to be made for understanding your own code, 
 but it’s worth a few words. 
  
  Specific code examples designed to train you in knowing what your Rails code 
 is doing will be plentiful as we talk about Ruby and circle back to Rails later in the 
 book. In this section, we’ll look at some points and premises about knowing what 
 you’re doing—specifically, points about the relationship between Ruby and Rails. 
  
  The Rails framework does two things (among others) very well: It makes you 
 feel like you’re using not just Ruby but a 
 domain-specific language
  (
 DSL
 ) written in 
 Ruby; and it makes you feel like you’re not really programming but mainly writing 
 configuration files. Both of these characteristics testify to the power of Ruby (Ruby 
 is good as a host language for 
 DSL
 s) and to its skillful deployment in the Rails 
 framework. 
  
  But even when Rails coding feels like configuration—or feels like coding, but in 
 a language unto itself—it is still, nonetheless, Ruby. That means you’re well 
 advised to keep an eye on how the layers fit together: that is, on how Ruby and 
 Rails relate to each other and, contradictory as it may sound, what role Ruby plays 
 in the process of making Rails sometimes feel like a separate language from Ruby. 
  
  In this section, we’ll use the 
 Rails feels like configuration
  idea and the 
 Rails feels 
 like a programming language of its own 
 idea to examine the relationship between 
 Ruby and Rails—which is to say, the idea that 
 Rails programming is in fact Ruby 
 pro-gramming
 . This will give you an informative look at an important aspect of 
 know-ing what your Rails code is doing. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"yarray = array.to_yaml 
  
 puts ""YAML representation of array: "" 
  
 puts yarray 
  
 thawed = YAML.load(yarray) 
  
 puts ""Array re-loaded from YAML string: 
 "" 
  
 p thawed",NA
C,NA,NA
B ,"detailed string representation of an object, and the 
 p
  method 
 dd
 , which is equiva-",NA
C ,"lent to running 
 puts
  on the result of 
 inspect
 .) 
  
  
  The output from running this script is as follows:
  
 Original array: 
  
 [1, 2, 3, [4, ""five"", :six]] 
  
 YAML representation of array: 
  
 - 1
  
 - 2
  
 - 3
  
 - - 4
  
  - five
  
  - :six 
  
 Array re-loaded from YAML string: 
  
 [1, 2, 3, [4, ""five"", :six]]
  
 Note that 
 YAML
  not only remembers the nesting of the arrays, but also remembers 
 that “
 five
 ” was a string and 
 :six
  was a symbol. Rails uses 
 YAML
  in several 
 contexts.
  
 In 
 database.yml
 , you’ve seen blocks that look like this:
  
 development:
  
  adapter: mysql
  
  database: r4rmusic1_development
  
  username: r4r
  
  password: railzrulez
  
  socket: /tmp/mysql.sock
  
 Watch what happens when you run that through the 
 YAML.load
  method. Put those 
 lines in a file by themselves (say, 
 sample.yml
 ), and run the following command, 
 which reads the file back, converts it from a 
 YAML
  string to a Ruby object, and then 
 prints out a representation of that object (with 
 p
 ):
  
 ruby -ryaml -e 'p YAML.load(File.read(""sample.yml""))'
  
 The output, massaged here to look less run-together than it appears onscreen, is as 
 follows:
  
 {""development"" => {""socket""=>""/tmp/mysql.sock"",
  
  
  ""username""=>""r4r"",
  
  
  ""adapter""=>""mysql"",
  
  
  ""password""=>""railzrulez"",
  
  
  ""database""=>""r4rmusic1_development""
  
  } 
  
 }
  
 You’re seeing a printout of a Ruby hash, a data structure consisting of pairs made 
 up of one key and one value. Actually, you’re seeing two hashes. The first has the",NA
3.2 Starting to use Ruby to do more in your code,"You want to know Ruby techniques so that you can add to what your application 
 can do and increase the ease with which you get the application to do it. This 
 doesn’t mean everything you do will be spectacular. It means that you’ll be able to 
 do more, and do it easily. 
  
  Rails is your partner in this process. When you leverage your Ruby skills to 
 enhance your Rails application, you aren’t out-smarting Rails. You’re doing what 
 you’re expected to do: work within the Rails framework to achieve the best results 
 you can.
  
  Nor is this a platitude. It’s a characterization of how the Rails framework is 
 engineered. The details of what you do on every Rails project—not just the code, 
 but also the specifics of the setup and configuration—fall into three categories that 
 cover a wide spectrum of constraint and freedom: 
  
 ■
  Things you do a particular way because the rules of Rails say they have to be 
  
 done that way
  
 ■
  Customizations you’re likely to want to do and for which Rails provides an 
  
 infrastructure (while leaving you a lot of freedom as to specifics)",NA
B,sort_proc = case @order,NA
C,"when ""author""  then lambda {|r| [r.user.name.downcase, r.number] }
   
  when ""status"",
  
    
  ""title""   then lambda {|r| [r.send(@order).downcase, r.number]}
   
  when ""number""  then lambda {|r| -r.number }
  
  end
  
  @rcrs = Rcr.find(:all).sort_by &sort_proc",NA
D ,"end
  
 The variable 
 @order
  (an 
 instance variable
 ) is set to the value of the 
 CGI
  variable 
 order
 dd
 , defaulting to the string “number” if that 
 CGI
  variable isn’t set. At that",NA
B ,"point, the variable 
 sort_proc
  (sorting procedure) is set to one of three possible 
 lambda
  expressions (anonymous functions). Which lambda is chosen depends on 
 the value of 
 @order
 ; the selection is performed through a 
 case
  statement 
 dd
 .",NA
C,"Once the correct lambda has been chosen, all of the existing 
 RCR
 s are sorted 
 according to the logic of that lambda 
 dd
 , using the ActiveRecord 
 find
  method to",NA
D,"grab all the 
 RCR
 s and Ruby’s 
 sort_by
  method to filter the list through whichever 
 lambda is stashed in 
 sort_proc
 .
  
  
  If you know Ruby, this isn’t a difficult method to write. But you do have to know 
 Ruby! Specifically, you have to know the following:
  
 ■
  The 
 case
  statement
  
 ■
  The 
 lambda
  keyword, with which you create an anonymous function
  
 ■
  The 
 send
  method (notice how 
 status
  and 
 title
  can be handled together)
  
 ■
  The 
 sort_by
  method, to which you hand a lambda
  
 This code does nothing earth-shatteringly spectacular. You could write it (more 
 lengthily) without some of the techniques it uses. What 
 is
  spectacular is how much 
 you gain in the way of adaptability and ease of development when you know those 
 Ruby techniques.
  
  Rails knows that it’s a good idea to give the programmer freedom. You get sev-
 eral assists in exercising that freedom. An important one, to which we’ll now turn, 
 is the provision of the helper files.
  
 3.2.2 Deploying the Rails helper files
  
 The most common idioms and techniques—“common” meaning that many appli-
 cations have them in common—are provided by Rails. But Rails also provides ways 
 to address specific needs.",NA
3.3 Accomplishing application-related skills and tasks,"As stated in the introduction to this chapter, administrative and organizational 
 tasks won’t figure prominently in the rest of this book, but this area definitely 
 merits one section’s worth of attention. I hope you’ll find opportunities to use Ruby 
 in and around your Rails work in a variety of ways, and this section is designed to 
 encourage you to look for such opportunities. 
  
  We’ll use a common case as our main example: converting legacy data to a 
 Rails-usable format. This is an area where Ruby can help you a great deal—not 
 only because the target format is ActiveRecord, but because Ruby is good at 
 manipulating data in many formats and forms. 
  
  This section also includes an introduction to the irb-based application console, 
 which is basically an irb session into which your model files have been preloaded. 
 You can use this session interactively to examine and change database records and 
 run any methods that have been defined for the use of your models. As a subtopic, 
 the application console is an imperfect fit for this section; but because it’s irb 
 based, and irb is part of the general Ruby environment, we’ll count it among the 
 facilities Ruby gives you to enhance your work environment. (If you end up feeling 
 that the application console is an integral Rails development tool, so much the 
 better!)
  
 3.3.1 Converting legacy data to ActiveRecord
  
 When it comes to converting data, a lot depends on what you start with. You may 
 be dealing with an old relational database and have to convert it to Rails-friendly 
 SQL
 . Or you may need to turn information stored in flat text files into database 
 records. There’s no single scenario when it comes to the process of dealing with 
 legacy data. But Ruby skills can help you bootstrap that data into Rails-accessible 
 form in virtually any case. 
  
  We’ll look at an extended example here, based on a real-life case (that’s proba-
 bly similar to many real-life cases) involving data from a discussion board stored 
 in small text files. We get a lucky break because these text files are 
 YAML
  files. That 
 gives us a foot in the door when it comes to getting Ruby and, subsequently, Rails 
 to understand what’s in them.",NA
B,NA,NA
E,"files = Dir[""../file*""].sort
  
 files.each do |file|",NA
C,NA,NA
D,"m = YAML.load(File.read(file))  
 num  = m['number'] 
  
  prev = m['previous'] 
  
  user = User.find_by_name(m['username'])  
 unless user 
  
  user = User.new 
  
  user.name = m['username'] 
  
  user.save 
  
  end
  
  message = Message.new",NA
F,"message.save  mnums[num] = 
 message.id 
  
  
  message.user   = user  message.number = num",NA
G,NA,NA
G,NA,NA
H,"if prev 
  
  
  message.previous = Message.find(mnums[prev])  
 end 
  
  message.save",NA
I,"end
  
  
  
  
 The script initializes an empty 
 hash
  (key/value collection) called 
 mnums
 , which will 
 store message numbers in cases where one message is a response to another mes-
 sage 
 #1
 . Also, all of the names of the relevant legacy files are gathered, sorted",NA
B ,"alphabetically, into the array 
 files
 . The script now cycles through the original, 
 legacy data files one at a time, using 
 each
 #2
 . (Make sure that the files are named",NA
C ,"in such a way that an alphabetical sort of their names will put them in order by 
 date of message; for example, you could call them 
 file000
 , 
 file001
 , etc.)
  
  
  For each file, the script creates a Ruby object based on a 
 YAML
  reading of the 
 file’s contents 
 #3
 . (Remember that 
 YAML
  serializes Ruby data to string form and",NA
D ,"then can load it back from the string—stored in a file, in this case—to in-memory 
 data at runtime.) The variables 
 prev
  and 
 num
  store the values in the 
 previous
  and 
 number
  fields of this message. There will always be a value for 
 number
 , but there 
 will be a value for 
 previous
  only if this message was a response to another message.
  
 (We’ll need to know this later.)
  
  
  The script next searches for a user in the database matching the username from 
 the file. If it doesn’t find one, it creates a new user 
 #4
 . This ensures that each",NA
E ,"message will have a valid user associated with it. 
  
  The rest of the script handles the message . A new 
 message
  object is created to 
 store the message that’s being parsed from the file 
 #5
 . The 
 id
  field of the new mes-",NA
F ,"sage is stored in the 
 mnums
  hash, keyed to the number of the 
 legacy
  message. This 
 provides a mapping between the old message numbering sequence and the 
 sequence of id values in the new message database. 
  
  
  Various fields of the new message object are initialized to the corresponding 
 values from the file: 
 user
 , 
 number
 , 
 body
 , 
 title
 , and 
 date
 #6
 . If a previous message 
 exists",NA
G ,"to which this one was a response (which we’ll know based on whether the variable 
 prev
  has a value), that existing message is used to set the 
 previous
  field of the new 
 message 
 #7
 . Finally, the new message, with its properties set to reflect who wrote 
 it",NA
H ,"and the message to which it was a response (if any), is saved to the database 
 #8
 .",NA
I,NA,NA
B ,"=> #<Work:0x40a04cec @attributes={""title""=>""Sonata for Cello and Piano in 
  
 F\nMajor"", ""composer_id""=>""1"", ""id""=>""1""}> 
  
 >> e.price = 22.50
  
 => 22.5 
  
 >> e.publisher = ""Ruby F. Rails, Inc."" 
 => ""Ruby F. Rails, Inc."" 
  
 >> e.year = 2006",NA
C ,=> 2006,NA
C,NA,NA
D,">> e.description 
  
 => ""standard""",NA
E,"The console session makes changes to the database (the development database, by 
 default). Here, we create an 
 Edition
  object, assign something to its 
 work
  prop-erty 
 #1
  (so that it’s an edition 
 of
  something) as well as its 
 publisher
  and 
 year
 #2
 ,",NA
B ,NA,NA
C ,"and save it to the database. The 
 save
  operation returns 
 true
 #3
 , which means 
 it",NA
D ,"has succeeded. The new edition’s 
 description
  property is set automatically 
 to“standard” 
 #4
 , as we arranged.",NA
E,"You can make changes directly in your application’s program files while the 
 session is in progress. If you do, you must reload the files you’ve changed. You can 
 do this using the 
 load
  command (which, unlike 
 require
 , loads a file even if it has 
 already loaded the file once). For example, if you make a change to 
 edition.rb
 , 
 you type the following in the console session:
  
 >> load 'edition.rb'
  
 Rails knows how to find the file and reads it in again. 
  
  Don’t forget that the application console is also a regular irb session. If, like 
 many Ruby programmers, you become an irb devotee, you can save yourself the 
 trouble of starting up an extra session if the application console is running already 
 and you need to do a quick irb calculation or code test.",NA
3.4 Summary,"Chapter 3 has given you a grounding in a number of the many ways that knowing 
 Ruby can help you as a Rails developer. It’s a pivot chapter: not as detailed or 
 extensive in terms of Ruby or Rails applicability as what is to come later in the 
 book, but more detailed than anything that would have made sense before the first 
 two chapters. 
  
  You’ve seen examples of what it means to gain knowledge of what your Rails 
 code is doing, mainly in connection with the interplay between what looks like 
 con-figuration syntax and what is programming code. (That’s not the only area in 
 which it pays to understand the Ruby/Rails relationship, but it’s a good one to get a 
 han-dle on.) You’ve also seen some initial examples of how to deploy your own 
 code, both in cases where Rails provides you with an infrastructure for doing so 
 (helper methods and predefined hooks) and in cases where you’re writing 
 methods from",NA
Part 2,NA,NA
Ruby building blocks,NA,NA
T,"his is the first of two parts of this book devoted to the exploration and study 
 of the details of the Ruby programming language. This part comprises five chap-
 ters, over the course of which you’ll learn about the major building blocks of Ruby: 
 the essential constructs and techniques that drive Ruby programs and hold them 
 together. This discussion includes an introductory situating of Ruby as an object-
 oriented language. From there, we’ll move on to look at a series of topics 
 concerned with how Ruby programs are constructed and how Ruby represents 
 and manipulates data.
  
 The focus in this part of the book, as well as in part 3, is on learning the Ruby 
 language. But it’s still Ruby for Rails, and Rails won’t fade from view. Where possi-
 ble, Rails-related examples serve the double purpose of illustrating Ruby features 
 and also showing you Rails techniques or idioms, or nuggets of Rails information. 
 You’ll also find subsections that discuss in more depth the implications of particu-
 lar Ruby constructs for the Rails framework. 
  
 We'll start part 2 with a close look at Ruby objects (the most basic building 
 block) and variables. From there, we’ll segue to an exploration of how you can 
 organize and automate objects using the aggregation techniques made available by 
 Ruby’s class and module mechanisms. That will take us through chapter 6. Chapter 
 7 examines matters of scope in Ruby: where you are in the overall map of your 
 program at a given point during execution, and how to tell. Finally, chapter 8 
 introduces Ruby’s control-flow techniques: conditional execution 
 if
  structures, 
 looping, and other related programming facilities.
  
  
 In short, part 2 will take you through a considerable amount of both the what and 
 the how.",NA
Objects and variables,"In this chapter
  
  
 ■
  Objects and object orientation
  
  
 ■
  Innate vs. learned object capabilities
  
  
 ■
  Method-call syntax and semantics
  
  
 ■
  Variable assignment and usage
  
 95",NA
4.1 From “things” to objects,"When you use Ruby—even when you’re not writing applications, like Rails appli-
 cations, that operate in close parallel with a database—you’re always, to one 
 degree or another, dealing with the matter of mapping “things” to the universe of 
 your computer program. 
  
  In the case of Rails applications, this kind of mapping is front and center: You 
 design a database with tables and fields, and your program derives filenames, vari-
 able names, and much of its programming logic from that database. But apart from 
 Rails, Ruby 
 itself
 , as a programming language, is designed such that much of what 
 you do when you plan and write Ruby programs is to model domains, exam-ine 
 relations between entities or “things” (like composers and works, or teachers and 
 students, or shirts and buttons), and find ways to embed those relations in the 
 structure and terminology of your program. 
  
  When you write a computer program, you’re creating a kind of symbolic uni-
 verse whose components you manipulate using the syntax and semantics of your 
 programming language. Some programming languages, however, encourage you 
 further along this road than others. 
  
  Ruby is one of those.",NA
B,"end
  
 def ticket.seat
  
  ""Second Balcony, row J, seat 12"" 
  
 end
  
 def ticket.date
  
  ""01/02/03"" 
  
 end
  
 Let’s pause for a moment and make some observations. The majority of the meth-
 ods defined here return 
 string
  values. You can see this at a glance: They hand back 
 a value inside quotation marks. 
  
  The 
 price
  method 
 #1
  returns a 
 floating-point decimal number
 : 5.50. Floating-",NA
B ,"point numbers have more complexity and quirkiness than you may think. Some 
 day you’ll probably come across something peculiar-looking, like this frequently 
 cited example:
  
 puts 0.5 - 0.4 - 0.1
  
 -2.77555756156289e-17 
  
  
 Not zero!
  
 The problem—or, more accurately, the inevitable consequence of the laws of 
 mathematics and computers—is that decimal floating-point numbers of arbitrary 
 length can’t be stored and operated on in binary form with complete accuracy. So, 
 don’t be surprised if you see this sort of code.
  
 NOTE
  
 NOT ALL OBJECTS HAVE TO BE CREATED INDIVIDUALLY
  
 A little further
  
 on, you’ll learn how to create objects on a 
 factory
  basis, without have to 
 call 
 Object.new
  and manually add methods for every object. Ruby gives 
 you plenty of shortcuts; in practice, you rarely end up creating hand-
 crafted, one-at-a-time objects. We’re doing it here to give you a solid 
 understanding of objects and methods. That, in turn, will help you 
 understand the shortcuts when you encounter them.",NA
4.2 The innate behaviors of an object,"Even a newly created object isn’t a blank slate. As soon as an object comes into 
 existence, it already responds to a number of messages. Every object is “born” with 
 certain innate abilities. 
  
  
  To see a list of innate methods, you can call the 
 methods
  method (and throw in a 
 sort
  operation, to make it easier to browse visually):
  
 p Object.new.methods.sort
  
 The result is a list of all the messages (methods) this newly minted object comes 
 bundled with. (Warning: the output looks cluttered. This is how Ruby displays 
 arrays
 —and the 
 methods
  method gives you an array of method names. If you want 
 a list of the methods one per line, use 
 puts
  instead of 
 p
  in the command.)
  
 [""=="", ""==="", ""=~"", ""__id__"", ""__send__"", ""class"", 
  
 ""clone"", ""display"", ""dup"", ""eql?"", ""equal?"", ""extend"", 
 ""freeze"", ""frozen?"", ""hash"", ""id"", ""inspect"", 
  
 ""instance_eval"", ""instance_of?"", ""instance_variable_get"", 
 ""instance_variable_set"", ""instance_variables"", ""is_a?"", 
 ""kind_of?"", ""method"", ""methods"", ""nil?"", ""object_id"", 
 ""private_methods"", ""protected_methods"", ""public_methods"", 
 ""respond_to?"", ""send"", ""singleton_methods"", ""taint"", 
 ""tainted?"", ""to_a"", ""to_s"", ""type"", ""untaint""]
  
 Don’t worry if most of these methods make no sense to you right now. You can try 
 them in irb, if you’re curious to see what they do (and if you’re not afraid of get-
 ting some error messages).",NA
B,"else
  
  puts ""No such information available"" 
  
 end
  
 This version uses the 
 send
  method as an all-purpose way of getting a message to 
 the 
 ticket
  object. It relieves you of having to march through the whole list of 
 possible requests. Instead, having checked that the 
 ticket
  object will know what 
 to do 
 #1
 , you hand the 
 ticket
  the message and let it do its thing.",NA
B,"TIP USING 
 __send__
  INSTEAD OF 
 send 
  
 Sending
  is a broad concept: Email is 
 sent, data gets sent to 
 I/O
  sockets, and so forth. It’s not uncommon for programs to 
 define a method called 
 send
  that conflicts with Ruby’s built-in 
 send
  method. 
 Therefore, Ruby gives you an alternative way to call 
 send
 : 
 __send__
 . By 
 convention, no one ever writes a method with that name, so the built-in Ruby 
 version is always available and never comes into conflict with newly written 
 methods. It looks strange, but it’s safer than the plain 
 send
  version from the point 
 of view of method-name clashes.
  
 Most of the time, you’ll use the dot operator to send messages to objects. How-ever, 
 the 
 send
  alternative can be useful and powerful.",NA
"4.3 Required, optional, and default-valued arguments","Methods you write in Ruby can take more than one argument, or none at all. They 
 can also allow a variable number of arguments. We’ll look at a number of 
 permutations here. These are summarized in table 4.2 at the end of this section.
  
 4.3.1 Required and optional arguments
  
 When you call a Ruby method, you have to supply the correct number of argu-
 ments. If you don’t, Ruby tells you there’s a problem. For example,
  
 def obj.one_arg(x) 
  
 end
  
 obj.one_arg(1,2,3)
  
 results in:
  
 ArgumentError: wrong number of arguments (3 for 1)",NA
4.4 Local variables and variable assignment,"You’ve seen many examples of Ruby variables in action—specifically, 
 local vari-
 ables
 —and we’ve been describing assignment of values to variables with some 
 slightly loose (although convenient) terminology. It’s time to consolidate and for-
 malize our coverage of this topic. 
  
  Local variables are variables that hold their value only during the execution of a 
 particular section of code. They’re called 
 local
  precisely because once program 
 execution leaves the 
 scope
  where the variable was created, the variable’s name no 
 longer has any meaning. 
  
  Local variables give you a kind of scratch-pad facility. You can use, say, the vari-
 able name 
 x
  in more than one place; as long as those places have different scopes, 
 the two 
 x
  variables are treated as completely separate. 
  
  
  The classic case is a method definition. Watch what happens with 
 x
  in this 
 example:
  
 def say_goodbye
  
  x = ""Goodbye""
  
  puts x 
  
 end
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
4.5 Summary,"We’ve covered a lot of ground in this chapter. You’ve learned about creating a new 
 object and defining methods for it. You’ve learned about the message-sending 
 mechanism by which you send requests to objects for information or action. You 
 also learned how to use some of the important built-in methods that every Ruby 
 object comes with: 
 object_id
 , 
 respond_to?
 , and 
 send
 . And we looked in some 
 detail at the syntax for method argument lists, including the use of required, 
 optional, and default-valued arguments.
  
  Finally, we examined local variables and variable assignment. You saw that key-
 words and method calls can look like local variables; and Ruby has ways of figur-
 ing out what it’s seeing. You also learned that variables receive references to 
 objects, and more than one variable can refer to the same object. 
  
  The chapter started with some comments about domains, entities, models, and 
 objects; and we’ll end there, too. Writing a Ruby program consists largely of think-
 ing about how you might map elements of a domain (even a modest one-entity 
 domain like “a ticket to an event”) onto a system of objects: objects that can know 
 things and perform tasks. In this regard, object-oriented programming has a lot in 
 common with database design. Both involve creating symbolic structures—tables 
 and fields in one case, objects and methods and names (and more, as you’ll see) in 
 the other—that encapsulate domain characteristics and behavior. 
  
  And Rails, of course, stands between these two worlds, directing database traf-
 fic into object-oriented, Ruby-space form, and back again. We’re dealing with a 
 number of layers, but they converge nicely on the realm of modeling domains and 
 representing entities. 
  
  Creating Ruby objects one by one, as we’ve done here, isn’t much more than the 
 tip of the iceberg. We’ll open up the discussion exponentially next, by looking at 
 how to create objects on a multiple, factory basis using Ruby classes.",NA
Organizing ,NA,NA
objects ,NA,NA
with ,NA,NA
classes,"In this chapter
  
  
 ■
  Creating multiple objects “factory” style 
  
  
 with classes
  
  
 ■
  Setting and reading object state
  
  
 ■
  Automating creation of attribute read and write 
  
  
 methods
  
  
 ■
  Class inheritance mechanics
  
  
 ■
  Syntax and semantics of Ruby constants",NA
5.1 Classes and instances,"In most cases, a class consists chiefly of a collection of method definitions. The 
 class exists (also in most cases) for the purpose of being 
 instantiated
 : that is, of 
 hav-ing objects created that are 
 instances
  of the class. 
  
  
  Have you guessed that you’ve already seen instantiation in action? It’s our old 
 signature tune:
  
 obj = Object.new
  
 Object
  is a built-in Ruby class. When you use the dot notation on a class, you send 
 a message to the class. Classes can respond to messages, just like objects; in fact, as 
 you’ll see in more detail later, classes 
 are
  objects. The 
 new
  method is called a 
 con-
 structor
 , meaning a method whose purpose is to manufacture and return to you a 
 new instance of a class, a newly minted object.",NA
C ,=> true,NA
B,">> t.xmlschema 
  
 => ""2005-09-12T08:19:52-04:00""
  
 Here we send the unrecognized message 
 xmlschema
  to our 
 Time
  object 
 #1
 . Then",NA
B ,"we load the 
 time.rb
  file 
 #2
 —and, sure enough, our 
 Time
  object now has an",NA
C ,"xmlschema
  method. (That method, according to its documentation, “returns a 
 string which represents the time as dateTime defined by 
 XML
  Schema.”) 
  
  
  You can spread code for a single class over multiple files or over multiple loca-
 tions in the same file. Be aware, however, that it’s considered better practice not to 
 do so, when possible. In the case of the 
 Time
  extensions, people often suggest the 
 possibility of unification: giving 
 Time
  objects all the extension methods in the first 
 place, and not separating those methods into a separate library. It’s possible that 
 such unification will take place in a later release of Ruby. 
  
  Ruby is about objects; objects are instances of classes. That means it behooves 
 us to dig deeper into what the life of an instance consists of. We’ll look next at 
 instance variables
 , a special language feature designed to allow every instance of 
 every class in Ruby to set and maintain its own private stash of information. 
  
 5.1.2 Instance variables and object state
  
 When we created individual objects and wrote methods for each action or value 
 we needed, we hard-coded the value into the object through the methods. With 
 this technique, if a ticket costs $117.50, then it has a method called 
 price
  that 
 returns precisely that amount:
  
 ticket = Object.new 
  
 def ticket.price
  
  117.50 
  
 end",NA
B,"end
  
  def inst_var_report
  
   
  puts ""Inspecting the value of the instance variable....""
   
  puts @ivar
  
  end 
  
 end
  
 c = C.new 
  
 c.inst_var_init(""Just some string"") 
 c.inst_var_report",NA
D,NA,NA
C,"Thanks to the assignment 
 #1
  that happens as a result of the call to 
 inst_var_",NA
B,"init
 #2
 , when you ask for a report 
 #3
 , you get back what you put in: the phrase",NA
C ,NA,NA
D,"“Just some string”. Unlike a local variable, the instance variable 
 @ivar
  retains the 
 value assigned to it even after the method in which it was initialized has termi-
 nated. This property of instance variables—their survival across method calls—
 makes them suitable for maintaining state in an object. 
  
 Initializing an object with state 
  
 The scene is set to do something close to useful with our 
 Ticket
  class. The missing 
 step, which we’ll now fill in, is the 
 object initialization
  process. 
  
  When you create a class (like 
 Ticket
 ), you can, if you wish, include a special 
 method called 
 initialize
 . If you do so,that method will be executed 
 every time 
 you create a new instance of the class. 
  
  For example, if you write an 
 initialize
  method that prints a message
  
 class Ticket
  
  def initialize
  
  
  puts ""Creating a new ticket!""
  
  end 
  
 end",NA
5.2 Setter methods,"When you need to change an object’s state once it’s been set, or if you want to set 
 an object’s state at some point in your program other than the 
 initialize
  
 method, the heart of the matter is assigning (or reassigning) values to instance 
 variables. For example, if we want tickets to have the ability to discount 
 themselves, we could write an instance method like this inside the 
 Ticket
  class 
 definition:
  
 def discount(percent)
  
  @price = @price - (percent * 10) / 100 
  
 end
  
 This method represents a limited scenario, though. It isn’t a general-purpose 
 method for setting or changing an object’s price. 
  
  
  Writing such a method, however, is perfectly possible. Ruby provides some nice 
 facilities for writing setter methods, as we’ll now see.",NA
5.3 Attributes and the attr_* method family,"In Ruby terminology (and this would be understood by anyone familiar with 
 object-oriented programming principles, even though it might operate differently 
 in other languages), properties or characteristics of objects that you can set (write) 
 and/or get (read) are called 
 attributes
 . In the case of ticket objects, we would say 
 that each ticket has a 
 price
  attribute as well as a 
 date
  attribute and a 
 venue
  
 attribute. 
  
  Note the sneaking in of 
 read/write
  as synonyms for 
 set/get
  in the realm of 
 attributes. Ruby usage favors 
 read/write
 . For instance, our 
 price=
  method would 
 usually be described as an 
 attribute writer
  method. 
 date
  and 
 venue
  are 
 attribute 
 reader
  methods. The read/write terminology can be a little misleading at first, 
 because it sounds like there might be terminal or file 
 I/O
  going on. But once you",NA
5.4 Class methods and the Class class,"When you call methods on objects, you use this message-sending syntax:
  
 object.message
  
 You may have noticed that the object creation calls we’ve done have conformed to 
 the standard 
 object-dot-method
  syntax:
  
 Ticket.new
  
 Analyzing this call in the light of the message-sending formula, we can quickly 
 draw two conclusions:
  
 ■
  We’re sending the message 
 new
 .
  
 ■
  We’re sending that message to 
 an object called 
 Ticket
 , which we know to be a 
  
 class. 
 (We know it’s a class because of having written it previously.)
  
 The first of these conclusions is unremarkable; messages get sent all the time. The 
 second—the fact that the receiver of the message is a class—merits close atten-
 tion. Because classes are object factories, thinking of them as objects in their own 
 right takes a leap of imagination. Thinking of classes as receivers of messages also 
 feels odd at first—although, as you’ll see, it falls into place easily once you get over 
 the “classes are objects” hurdle. 
  
 5.4.1 Classes are objects too!
  
 Classes are special objects: They’re the only kind of object that has the power to 
 spawn new objects (instances). Nonetheless, they are objects. When you create a 
 class, like 
 Ticket
 , you can send messages to it, add methods to it, pass it around to 
 other objects as a method argument, and generally do anything to it you would 
 another object. 
  
  Here’s an example. Let’s say we’ve created our 
 Ticket
  class. At this point, 
 Ticket
  isn’t only a class from which objects (ticket instances) can arise. 
 Ticket 
 (the class) is also an object in its own right. As we’ve done with other objects, let’s 
 add a method to it.",NA
5.5 Constants up close,"Most classes consist principally of instance methods and/or class methods. Con-
 stants, however, are an important and common third ingredient in many classes. 
 You’ve already seen constants used as the names of classes. Constants can also be 
 used to set and preserve important data values 
 in
  classes. 
  
 5.5.1 Basic usage of constants
  
 The name of every constant begins with a capital letter. You assign to constants 
 much as you would to variables. Let’s say we decide to establish a list of predefined 
 venues for the 
 Ticket
  class—a list that every ticket object can refer to and select 
 from. We can assign the list to a constant. Constant definitions usually go at or near 
 the top of a class definition:
  
 class Ticket
  
  VENUES = [""Convention Center"", ""Fairgrounds"", ""Town Hall""]
  
 We can then use this list in instance methods or in class methods (constants are 
 visible anywhere in the class definition). We can also refer to the constant from
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
5.6 Inheritance,"Without getting too philosophical, it’s reasonable to say that in many cases, two or 
 more material objects or ideas relate to each other according to the principle of 
 the 
 general
  and 
 the specific
 :
  
 ■
  Musical instrument
  is general; 
 piano
  is specific. 
  
 ■
  Publication
  is general; 
 magazine
  is specific. 
  
 ■
  Vehicle
  is general; 
 bicycle
  is specific. 
  
 And so forth.
  
  Object-oriented programming involves mapping real-world entities and their 
 relationships onto computer data structures. And just as the general/specific ratio 
 looms large in the real world, it surfaces in object-oriented class design. 
  
  The relation between a general case and a specific case can be expressed 
 through the technique known as 
 inheritance
 . Inheritance is a relation between two 
 classes. To start with the notation, it looks like this:
  
 class Publication
  
  attr_accessor :publisher 
  
 end
  
 class Magazine < Publication 
  
 dd
 attr_accessor :editor 
  
 end
  
 In this example, 
 Magazine
  is a 
 subclass
  of 
 Publication
 . Conversely, 
 Publication
  
 is the 
 superclass
  of 
 Magazine
 . When it comes to instance methods, each class can 
 have its own, and the classes lower on the inheritance chain also get the methods 
 defined above. The model cascades:",NA
5.7 Summary,"In this chapter, you’ve learned the basics of Ruby classes. You’ve seen how writing 
 a class, and then creating instances of that class, allows you to share behaviors 
 among numerous objects. Through the use of setter methods, either written out or 
 automatically created with the 
 attr_*
  family of methods, we’ve demonstrated how 
 to create object attributes, which store object state in instance variables. 
  
  From there, we moved to the matter of classes as objects, as well as object 
 facto-ries. Class methods (methods added individually to class objects) can provide 
 gen-eral utility functionality connected with the class. 
  
  We then looked at Ruby constants, which are a special kind of data container 
 usually residing inside class definitions. Finally, we examined inheritance: a hier-
 archical, cascading relationship between a superclass and one or more subclasses.
  
  This gives you a firm foundation for understanding how objects come into being 
 and relate to each other in Ruby. Next, we’ll build on that foundation by looking at 
 another important building-block: modules.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
Modules ,NA,NA
and program ,NA,NA
organization,"In this chapter
  
  
 ■
  Encapsulation of behavior models in modules
  
  
 ■
  Modular extension of class and object capability
  
  
 ■
  The role of modules in the method lookup chain
  
  
 ■
  Designing class and module hierarchies
  
 154",NA
6.1 Basics of module creation and use,"Writing a module is similar to writing a class, except you start your definition with 
 the 
 module
  keyword instead of the 
 class
  keyword:
  
 module MyFirstModule 
  
 dd
 def say_hello 
  
 dddd
 puts ""Hello"" 
  
 dd
 end 
  
 end
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,NA,NA
C,"end
  
  def take_from_stack 
  
  @stack.pop",NA
D,"end
  
  end
  
  
  
 The 
 Stacklike
  module in listing 6.1 uses an 
 array
  (an ordered collection of 
 objects) to represent the stack. Upon initialization, a 
 Stacklike
  object’s instance 
 variable 
 @stack
  is initialized to a new, empty array 
 #1
 . When an object is added to",NA
B ,"the stack 
 #2
 , the operation is handled by pushing the object onto the array—that",NA
C ,"is, adding it to the end. Removing an object from the stack 
 #3
  involves popping an",NA
D ,"element from the array—that is, removing it from the end. (
 push
  and 
 pop
  are 
 instance methods of the 
 Array
  class. You’ll see them again when we look at con-
 tainer objects, including arrays, in chapter 11.)
  
  
  The module 
 Stacklike
  thus implements stacklikeness by selectively deploying 
 behaviors that already exist for 
 Array
  objects: Add an element to the end of the 
 array; take an element off the end. Arrays are more versatile than stacks; a stack 
 can’t do everything an array can. For example, you can remove elements from an 
 array in any order, whereas by definition the only element you can remove from a 
 stack is the one that was added most recently. But an array can do everything a 
 stack can. As long as we don’t ask it to do anything 
 un
 stacklike, using an array as a 
 kind of agent or proxy for the specifically stacklike add/remove actions makes 
 sense.
  
  We now have a module that implements stacklike behavior: maintaining a list 
 of items, such that new ones can be added to the end and the most recently added 
 one can be removed. The next question is, what can we do with this module? 
  
 6.1.2 Mixing a module into a class
  
 As you’ve seen, modules don’t have instances; so we 
 cannot
  do this:
  
 s = Stacklike.new 
  
  
 Wrong!
  
 In order to create instances (objects) we need a class; and in order to make those 
 objects stacklike, we need to mix our module into that class. But what class? The 
 most obviously stacklike thing is probably a 
 Stack
 . Save the code in listing 6.2 to 
 stack.rb
 , in the same directory as 
 stacklike.rb
 .",NA
B,"The business end of the 
 Stack
  class in listing 6.2 is the 
 include
  statement 
 #1
  with",NA
B,"which we have mixed in the 
 Stacklike
  module. It ensures that instances of 
 Stack 
 will exhibit the behaviors defined in 
 Stacklike
 . 
  
 NOTE
  
 SYNTAX OF 
 require
 /
 load
  VS. SYNTAX OF 
 include
  
 You may have noticed
  
 that when you use 
 require
  or 
 load
 , you put the name of the item you’re 
 requiring or loading in quotation marks, but with 
 include
 , you don’t. 
 require
  and 
 load
  take strings as their arguments, whereas 
 include
  
 takes the name of a module, in the form of a constant. The requirements to 
 require
  and 
 load
  are usually literal strings (in quotation marks), but a 
 string in a variable will also work. 
  
 Notice that our class’s name is a noun, whereas the module’s name is an adjective. 
 Neither of these practices is mandatory, but they’re both common. What we end up 
 with, expressed in everyday language, is a kind of predicate on the class:
  
 Stack objects are stacklike.
  
 That’s English for
  
 class Stack
  
 dd
 include Stacklike
  
 end
  
 To see the whole thing in action, let’s create a 
 Stack
  object and put it through its 
 paces. The code in listing 6.3 creates a 
 Stack
  object and performs some opera-
 tions on it; you can enter this code at the end of your 
 stack.rb
  file.
  
 Listing 6.3
  
 Creating and using an instance of class 
 Stack
  
  s = Stack.new",NA
B,"s.add_to_stack(""item 
 one"")  
 s.add_to_stack(""item 
 two"")  
 s.add_to_stack(""item three"")",NA
C,"puts ""Objects currently on the stack:""
  
  puts s.stack",NA
D,"puts taken
  
  puts ""Now on stack:""
  
  puts s.stack
  
  
  
  
 Listing 6.3 starts with the innocent-looking (but powerful) instantiation 
 #1
  of a",NA
B,"new 
 Stack
  object, which we’ve assigned to the variable 
 s
 . That 
 Stack
  object is born 
 with the knowledge of what to do when we ask it to perform stack-related actions, 
 thanks to the fact that its class mixed in the 
 Stacklike
  module. The rest of the code 
 involves asking it to jump through some stacklike hoops: adding items (strings) to 
 itself 
 #2
 , and popping the last one off itself 
 #3
 . Along the way, we ask",NA
C ,NA,NA
D ,"the object to report on its state. 
  
  
  Now let’s run the program. Here’s an invocation of 
 stack.rb
 , together with the 
 output from the run:
  
 $ ruby stack.rb 
  
 Objects currently on the stack: 
  
 item one 
  
 item two 
  
 item three 
  
 Removed this object: 
  
 item three 
  
 Now on stack: 
  
 item one 
  
 item two
  
 Sure enough, our little 
 Stack
  object knows what to do. It is, as advertised, 
 stacklike. The 
 Stack
  class is fine as far as it goes. But it may leave you wondering: 
 Why did we bother writing a module? 
  
 6.1.3 Leveraging the module further
  
 It would be possible to pack all the functionality of the 
 Stacklike
  module directly 
 in the 
 Stack
  class without writing a module. Listing 6.4 shows you what the class 
 would look like.
  
 Listing 6.4
  
 A nonmodular rewrite of the 
 Stack
  class
  
  class Stack
  
  
  attr_reader :stack
  
  def initialize
  
  
  @stack = Array.new",NA
B,"def load_and_report(obj) 
  
   
  print ""Loading object ""
  
   
  puts obj.object_id
  
   
  add_to_stack(obj)",NA
C,"end
  
  
  def unload
  
   
  take_from_stack",NA
D,"end
  
  end
  
  ch = CargoHold.new  
 sc1 = Suitcase.new",NA
E,"sc2 = Suitcase.new
  
  sc3 = Suitcase.new
  
  
 ch.load_and_report(sc1)
  
  
 ch.load_and_report(sc2)
  
  
 ch.load_and_report(sc3)
  
  first_unloaded = ch.unload
  
  print ""The first suitcase off the plane is...."" 
 puts first_unloaded.object_id
  
  
  
 At its heart, the program in listing 6.5 isn’t all that different from those in listings 
 6.2 and 6.3 (which you saved incrementally to 
 stack.rb
 ). It follows much the same 
 pro-cedure: mixing 
 Stacklike
  into a class 
 #1
 , creating an instance of that class 
 #5
 , 
 and",NA
B ,NA,NA
E ,"adding items to 
 #3
 , and removing them 
 from 
 #4
 , that instance (the stacklike thing—",NA
C ,NA,NA
D ,"the cargo hold, in this case). It also does some reporting of the current state of the 
 stack 
 #2
 , as the other program did.",NA
B,"The output from the cargo hold program looks like this (remember that 
 suitcases are referred to by their object id numbers, which may be different on 
 your system):
  
 Loading 
 object 
 942912 
  
 Loading 
 object 
 942892 
  
 Loading 
 object 
 942882 
  
 The 
 first 
 suitcase 
 off 
 the 
 plane 
 is....942882
  
 The cargo hold example shows how you can use an existing module for a new class. 
 Sometimes it pays to wrap the methods in new methods with better names for the",NA
"6.2 Modules, classes, and method lookup","You already know that when an object receives a message, the result may be the 
 execution of a method with the same name as the message in the object’s class, or a 
 method in that class’s superclass—and onward, up to the 
 Object
  class—or a 
 method in a module that has been mixed into any of those classes. But how 
 exactly 
 does this come about? And what happens in ambiguous cases—for example, if a 
 class and a mixed-in module both define a method with a given name? Which one 
 does the object choose to execute?
  
  It pays to answer these questions precisely. Imprecise accounts of what hap-
 pens are easy to come by. Sometimes they’re even adequate: If you say, “This 
 object has a 
 push
  method,” you may well succeed in communicating what you’re 
 trying to communicate, even though objects don’t “have” methods but, rather, find 
 them by searching classes and modules.
  
  But an imprecise account won’t scale. It won’t help you understand what’s 
 going on in more complex cases, and it won’t support you when you’re designing 
 your own code. Your best course of action is to learn what 
 really
  happens when 
 you send messages to objects. 
  
  Fortunately, the way it works turns out to be straightforward. 
  
 6.2.1 Illustrating the basics of method lookup
  
 In the interest of working toward a clear understanding of how objects find meth-
 ods, let’s back-pedal on the real-world references and, instead, write some classes 
 and modules with simple names like 
 C
  and 
 M
 . Doing so will help you concentrate on 
 the logic and mechanics of method lookup without having to think simulta-neously 
 about modeling a real-world domain. We’ll also write some methods that don’t do 
 anything except print a message announcing that they’ve been called. This will 
 help track the order of method lookup. 
  
  Look at the program in listing 6.6.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"puts ""'report' method in module M""
  
  
  end
  
  end
  
  class C
  
  
  include M
  
  
  def report",NA
C,"puts ""'report' method in class C""
  
   
  puts ""About to trigger the next higher-up report method...""
   
  super",NA
D,"puts ""Back from the 'super' call.""
  
  
  end
  
  end
  
  c = C.new 
 c.report",NA
E,"The output from running listing 6.9 is as follows:
  
  'report' method in class C
  
  About to trigger the next higher-up report 
 method...",NA
E ,"lookup process starts with 
 c
 ’s class (
 C
 )—and, sure enough, there is a 
 report 
 method 
 #2
 . That method is executed.",NA
C,"Inside the method, however, is a call to 
 super
 #3
 . That means even though you",NA
D ,"found a method corresponding to the message (“report”), you must keep looking 
 and find 
 the next match. 
 The next match for “report”, in this case, is the 
 report 
 method defined in module 
 M
 #1
 .",NA
B,"Note that 
 M#report
 would have been
  the first match in a search for a 
 report 
 method, if 
 C#report
  didn’t exist. The 
 super
  keyword gives you a way to call what 
 would have been the applicable version of a method, in cases where that method 
 has been overridden later in the lookup path. Why would you want to do this?
  
  Sometimes, particularly when you’re writing a subclass, a method in an existing 
 class does 
 almost
  what you want, but not quite. With 
 super
 , you can have the best 
 of both, by hooking into or wrapping the original method, as listing 6.10 illustrates.
  
 Listing 6.10
  
 Using 
 super
  to wrap a method in a subclass
  
  class Bicycle
  
  
  attr_reader :gears, :wheels, 
 :seats
  
  def initialize(gears = 1) 
  
  @wheels = 2",NA
B,"@seats = 1
  
   
  @gears = gears
  
  
  end
  
  end
  
  class Tandem < Bicycle
  
  
  def initialize(gears)
  
  
  super
  
  
  @seats = 2  
 end",NA
C,"end
  
  
  
  
 super
  gives us a nice clean way to make a tandem 
 almost
  like a bicycle. We change 
 only what needs to be changed (the number of seats 
 #2
 ), and we use 
 super
  to trig-",NA
C ,"ger the earlier 
 initialize
  method 
 #1
 , which sets bicycle-like default values for 
 the",NA
B,"other properties of the tandem. 
  
  When we call 
 super
 , we don’t explicitly forward the 
 gears
  argument that is 
 passed to 
 initialize
 . Yet when the original 
 initialize
  method in 
 Bicycle
  is",NA
6.3 Class/module design and naming,"The fact that Ruby has classes and modules—along with the fact that from an 
 object’s perspective, all that matters is whether a given method exists, not what 
 class or module the method’s definition is in—means that you have a lot of choice 
 when it comes to your programs’ design and structure. This richness of design 
 choice raises some considerations you should be aware of. 
  
  We’ve already looked at one case (the 
 Stack
  class) where it would have been 
 possible to put all the necessary method definitions into one class but was 
 advanta-geous to yank some of them out, put them in a module (
 Stacklike
 ), and 
 then mix the module into the class. There’s no rule for deciding when to do which. 
 It depends on your present and (to the extent you can judge them) future needs. 
 It’s sometimes tempting to break everything out into separate modules, because 
 mod-ules you write for one program may be useful in another (“I just know I’m 
 going to need that 
 ThreePronged
  module again some day!” says the packrat voice 
 in your head). But there’s such a thing as over-modularization. It depends on the 
 situation. And you have more than one program architecture design tool at your 
 disposal.",NA
6.4 Summary,"This chapter has been both a companion to and a continuation of the previous 
 chapter on classes. We’ve looked in detail at modules, which are similar to classes 
 in that they bundle methods and constants together, but which can’t be instanti-
 ated. You’ve seen examples of how you might use modules to express the design of 
 a program. We’ve taken an object’s-eye view of the process of finding and exe-
 cuting a method in response to a message. We’ve also looked at some techniques 
 you can use—including nesting classes and modules inside each other, which can 
 have the benefit of keeping namespaces separate and clear. Finally, we discussed 
 aspects of modular organization in the Rails framework source and in some of the 
 boilerplate code created by Rails when you initialize your application.
  
  Now that we’re nesting elements inside each other, the next topic we should 
 and will examine in detail is 
 scope
 : what happens to data and variables when your 
 program moves from one code context to another.",NA
The default ,NA,NA
object (self) ,NA,NA
and scope,"In this chapter
  
  
 ■
  The role of the current or default object, self
  
  
 ■
  Scoping rules for variables and constants
  
  
 ■
  Method access rules
  
 177",NA
"7.1  Understanding self, the current/default object","One of the cornerstones of Ruby programming—the backbone, in some respects—
 is the 
 default object
  or 
 current object
 , accessible to you in your program through 
 the keyword 
 self
 . At every point when your program is running, there is one and 
 only one self. Being self has certain privileges, as you’ll see. In this sec-tion, we’ll 
 look at how Ruby determines which object is self at a given point and what 
 privileges are granted to the object that is self. 
  
 7.1.1 Who gets to be self, and where
  
 There is always one (and only one) current object or self. You can tell which object 
 it is by following a small set of rules. These rules are summarized in table 7.1; the 
 table’s contents will be explained and illustrated as we go along. 
  
  To know which object is self, you need to know what context you’re in. In prac-
 tice, there aren’t all that many contexts to worry about. There’s the top level 
 (before you’ve entered any other context, such as a class definition). There are 
 class definition blocks, module definition blocks, and method definition blocks. 
 Aside from a few subtleties in the way these contexts interact, that’s about it. As 
 shown in table 7.1, self is determined by which of these contexts you’re in (class 
 and module definitions are similar and closely related).
  
  Figure 7.1 gives you a diagrammatic summary of the information from table 7.1. 
 Both show you that some object is always self, and that 
 which
  object is self depends 
 on where you are in the program. 
  
  The most basic and, in some respects, unique program context is the top level, 
 the context of the program before any class or module definition has been opened, 
 or after they’ve all been closed. We’ll look next at the top level’s ideas about self. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"dddd
 puts ""Class method of class C"" 
  
 dddd
 p self 
  
 dd
 end 
  
 end
  
 Note the use of 
 self.x
 #1
  rather than 
 C.x
 . This way of writing a class method takes",NA
B ,"advantage of the fact that in the class definition, self is 
 C
 . So, 
 defself.x
  is the same 
 as 
 defC.x
 . The 
 self.x
  version offers a slight advantage: If you ever decide to 
 rename the class, 
 self.x
  will adjust automatically to the new name. If you hard-
 code 
 C.x
 , you’ll have to change 
 C
  to your class’s new name. 
  
  Being self at a given point in the program comes with some privileges. The chief 
 privilege enjoyed by self is that of serving as the 
 default receiver of messages
 , as 
 you’ll see next. 
  
 7.1.2 Self as default receiver of messages
  
 Calling methods (that is, sending messages to objects) usually involves the dot 
 notation:
  
 obj.talk 
  
 ticket.venue 
  
 ""abc"".capitalize
  
 That’s the normal, full form of the method-calling syntax in Ruby. However, a spe-
 cial rule governs method calls: If the receiver of the message is self, 
 you can omit 
 the receiver and the dot. 
 Ruby will use self as the default receiver, meaning the 
 message you send will be sent to self, as the following equivalencies show:
  
 talk 
  
 Same as self.talk 
  
 venue 
   
   
 Same as self.venue 
  
 capitalize 
  
 Same as 
 self.capitalize",NA
B ,"end
  
 C.no_dot",NA
C,"The first call to 
 no_dot
 #1
  doesn’t have an explicit receiver; it’s a bareword. When",NA
B ,"Ruby sees this (and determines that it’s a method call, rather than a variable or 
 keyword), it figures that you mean it as shorthand for
  
 self.no_dot
  
 In the case of our example, 
 self.no_dot
  is the same as 
 C.no_dot
 , because we’re 
 inside 
 C
 ’s definition block and, therefore, self is 
 C
 . The result is that the method 
 C.no_dot
  is called, and we see the output. 
  
  The second time we call the method 
 #2
 , we’re back outside the class definition",NA
C ,"block. 
 C
  is no longer self. Therefore, to call 
 no_dot
 , we need to specify the receiver: 
 C
 .
  
  
  The most common use of the dotless method call occurs when you’re calling one 
 instance method from another. Here’s an example:
  
 class C 
  
 dd
 def x 
  
 dddd
 puts ""This is method 
 'x'"" 
  
 dd
 end
  
 dd
 def y 
  
 dddd
 puts ""This is method 'y', about to call x without a dot.""",NA
B,"dd
 end 
  
 dd
 @v = ""Instance variables can appear anywhere....""",NA
C,"end
  
 C.new.show_var
  
 The code prints the following:
  
 I am an instance variable initialized to a string.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"and the 
 @v
  outside it 
 #2
  are 
 completely unrelated
  to each other. They are both",NA
C,"instance variables, and both are named 
 @v
 , but they aren’t the same variable. They 
 belong to different objects. 
  
  Whose are they?
  
  The first 
 @v
  lies inside the definition block of an instance method of 
 C
 . That fact 
 has implications, not for a single object, but for instances of 
 C
  in general: Each 
 instance of 
 C
  that calls this method will have its own instance variable 
 @v
 . 
  
  The second 
 @v
  belongs to 
 the class object 
 C
 . 
 This is one of the many occasions 
 where it pays to remember that classes are objects. Any object may have its own 
 instance variables—its private stash of information and object state. Class objects 
 enjoy this privilege as much as any other object.
  
  The logic required to figure out what object owns a given instance variable is 
 simple and consistent: Every instance variable belongs to whatever object is play-
 ing the role of self (the current object) at the moment the code containing the 
 instance variable is executed. 
  
  
  Let’s do a quick rewrite of the example, this time making it a little more chatty 
 about what’s going on. Listing 7.2 shows the rewrite. 
  
 Listing 7.2
  
 Chatty examination of the relationship between instance variables and self
  
  class C
  
  puts ""Just inside class definition block. Here's self:"" 
 puts self
  
  @v = ""I am an instance variable initialized to a string"" puts 
 ""And here's the instance variable @v, belonging to self:"" puts 
 @v
  
  
  def show_var
  
   
  puts ""Inside an instance method definition block. Here's 
 self:""
  
  
  puts self
  
   
  puts ""And here's the instance variable @v, belonging to self:""
   
  puts @v
  
  
  end
  
  end
  
  c = C.new
  
  c.show_var
  
  
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
7.2 Determining scope,"Scope
  refers to the reach or visibility of variables. Different types of variables have 
 dif-ferent scoping rules. We’ll be talking chiefly about two types: 
 global
  and 
 local
  
 variables.
  
  Like the role of self, scope changes over the course of a program. Also as with 
 self, you can deduce what’s in what scope by reading the program as well as 
 running it. But scope and self aren’t the same thing. You can start a new local scope 
 without self changing. Sometimes scope and self change together. They have in 
 common the fact that they are both necessary to make sense of what you’re seeing. 
 Like knowing who self is, knowing what scope you’re in tells you the significance of 
 the code.
  
  
  We’ll talk first about global scope and then about local scope. Constants also 
 have scoping rules, which we’ll look at as well.
  
 7.2.1 Global scope and global variables
  
 We’re starting with the scope that’s used least often, but which you need to be 
 aware of: 
 global scope
 , meaning scope that covers the entire program. Global scope 
 is enjoyed by 
 global variables
 , which we haven’t looked at yet. Global variables are 
 distinguished by starting with a dollar-sign (
 $
 ) character. They are available every-
 where in your program. They walk through walls: Even if you start a new class or 
 method definition, even if the identity of self changes, the global variables you’ve 
 initialized will still be available to you. 
  
  In other words, global variables never go out of scope.In this example, a method 
 defined inside a class definition body (two scopes removed from the outer or top-
 level scope of the program) has access to a global variable initialized at the top:",NA
B ,"dd
 def show_info 
  
 dddd
 puts ""Title and composer: #{title}, #{composer}"" 
 dd
 end 
  
 end
  
 work = Work.new",NA
C ,"work.composer = ""Giuseppe Verdi"" work.title = ""La 
 Traviata""
  
 Shortcut composer 
    
  
 object by using name 
 work.show_info
  
 The 
 Work
  class 
 #1
  provides its instance (
 work
 ) 
 #2
  with the ability to store and",NA
B ,NA,NA
C ,"retrieve information about itself (its state). From outside the class, we organize our 
 code so that our queries and requests are all directed toward the 
 work
  object. 
  
  Here’s another version, using global variables:
  
 class Work
  
  
  def show_info
  
   
  puts ""Title and composer: #{$title}, #{$composer}""
  
  end
  
  end
  
  work = Work.new
  
  $composer = ""Giuseppe 
 Verdi""
  
  $title = ""La Traviata""
  
  work.show_info
  
 This version still has a 
 Work
  class and an instance of 
 Work
 . But the information is 
 handed around over the heads of the objects, so to speak, in a separate network of 
 global variables. It’s concise and easy, but it’s also drastically limited. What would 
 happen if you had lots of works? Or wanted to save a work, with all its internal 
 information, to a database? Your code would quickly become tangled.",NA
B ,"dd
 def local_a 
  
 dddd
 a = 2",NA
C ,"dddd
 puts a 
  
 dd
 end 
  
 dd
 puts a",NA
D ,"end
  
 c = C.new 
  
 c.local_a",NA
E,NA,NA
B ,"a different scope than the variable 
 a
  inside the method definition 
 #2
 . When you 
 get",NA
C ,"to the 
 putsa
  statement 
 after
  the method definition 
 #3
 , you’re back in the class",NA
D ,"definition local scope; the 
 a
  that gets printed is the 
 a
  you initialized back at the top, 
 not the 
 a
  that’s in scope in the method definition. Meanwhile, that 
 a
  isn’t printed 
 until later, when you’ve created a 
 C
  instance and sent the message 
 local_a
  to it 
 #4
 .",NA
E,"a = 0 
  
  
 Top level 
 def 
 t 
  
 (outer scope)
  
 puts ""Top level method t""
  
 end
  
 class C
  
  a = 1
  
  def self.x
  
 Class definition 
  
 scope
  
 a = 2
  
 Method 
  
 definition 
  
 scope
  
 puts ""C.x; a = #{a}"" 
  
 end
  
 def m
  
 a = 3 
  
 puts ""C#m; a = #{a}""
  
 end
  
 def n
  
 a = 4 
  
 puts ""C#n; a = #{a}""
  
 end
  
 puts ""Class scope: a = #{a}""
  
 end
  
 C.x 
  
 c = C.new 
  
 c.m 
  
 c.n
  
 puts ""Top level: a = #{a}""
  
 Figure 7.2
  
  Schematic view of local scopes at the top level, the class-definition level, and 
 the method-definition level",NA
B,"dddd
 # etc.
  
 The constant 
 String
  in this context 
 #1
  resolves to 
 Violin::String
 , as defined.",NA
B ,"Now let’s say that elsewhere in the overall 
 Violin
  class definition, you need to 
 refer to Ruby’s built-in 
 String
  class. If you have a plain reference to 
 String
 , it will 
 resolve to 
 Violin::String
 . To make sure you’re referring to the built-in, original 
 String
  class, you need to put the constant path separator 
 ::
  (double colon) at the 
 beginning of the class name:
  
 def history 
  
 dd
 ::String.new(maker + "", "" + 
 date) 
  
 end
  
 This way, you’ll get a Ruby 
 String
  object instead of a 
 Violin::String
  object. Like 
 the slash at the beginning of a pathname, the 
 ::
  in front of a constant means 
 start 
 the search for this at the top level
 . 
  
  We have one more major subtopic to cover in the realm of who gets to do what 
 where, and how, in Ruby programs. That subtopic is Ruby’s system of 
 method 
 access rules
 .",NA
7.3 Deploying method access rules,"As you’ve seen, the main business of a Ruby program is to send messages to 
 objects. And the main business of an object is to respond to messages. Sometimes 
 an object wants to be able to send 
 itself
  messages that it doesn’t necessarily want 
 anyone else to send it. For this scenario, Ruby provides the ability to make a 
 method 
 private
 . 
  
  There are two access levels other than private: 
 protected
  and 
 public
 . Public is 
 the default access level; if you don’t specify that a method is protected or private, 
 then it’s public. Public instance methods are the common currency of Ruby 
 program-ming. Most of the messages you send to objects are calling public 
 methods. 
  
  
  We’ll focus here on methods that aren’t public. Protected methods are a slight 
 variant of private methods, so we’ll look most closely at private methods. 
  
 7.3.1 Private methods
  
 Think of an object as someone you ask to perform a task for you. Let’s say you ask 
 someone to bake you a cake. In the course of baking you a cake, the baker will 
 presumably perform a lot of small tasks: measure sugar, crack an egg, stir batter, 
 and so forth. 
  
  The baker can do, and does do, all these things. But not all of them have equal 
 status when it comes to what the baker is willing to do 
 for other people, like you
 . It 
 would be weird if you called a baker and said, “Please stir some batter” or “Please 
 crack an egg.” What you say is, “Please bake me a cake,” and you let the baker deal 
 with the details. Object orientation is all about modeling behaviors, so let’s model 
 that behavior (loosely). We’ll use minimal, placeholder classes for some of the 
 objects in our domain, but we’ll develop the 
 Baker
  class a little further. 
  
  Save the code in listing 7.4 to a file called 
 baker.rb
 .
  
 Listing 7.4
  
 Baker
  and other baking-domain classes
  
  class Cake
  
  
  def initialize(batter)
  
   
  @batter = batter
  
   
  @baked = true
  
  
  end
  
  end
  
  class Egg
  
  end
  
  class Flour
  
  end",NA
B,"end
  
  
  
  
 There’s something new in this code: the 
 private
  method 
 #1
 . As arguments to this",NA
B,"method, you supply a list of methods you want to make private. (If you don’t sup-
 ply any arguments, the call to 
 private
  will act like an “on-switch”: all the instance 
 methods you define below it, until you reverse the effect by calling 
 public
  or 
 pro-
 tected
 , will be private.) 
  
  
 Private
  means that 
 the method can’t be called with an explicit receiver
 . You can’t 
 say
  
 b = Baker.new 
  
 b.add_egg
  
 As you’ll see, calling 
 add_egg
  this way results in a fatal error. 
 add_egg
  is a private 
 method, but you’ve specified the receiving object (
 b
 ) explicitly. That’s not allowed.
  
 OK
 ; let’s go along with the rules. We won’t specify a receiver. We’ll just say
  
 add_egg
  
 But wait. Can we call 
 add_egg
  in isolation? Where will the message go? How can a 
 method be called if there’s no object handling the message? 
  
  A little detective work will answer this question.
  
  If you don’t use an explicit receiver for a method call, Ruby assumes that you 
 want to send the message to 
 the current object, self. 
 Thinking logically, we can 
 conclude that",NA
B,"# here, create a new ""applicant"" object called ""app""; then:
  
  invite(app)",NA
C,"end
  
  # etc.
  
 Note the call to the 
 invite
  method 
 #2
 . This method sends the email to the appli-",NA
C ,"cant. It then returns (assuming it worked), and 
 acknowledge
 #1
  proceeds to ren-",NA
B ,"der its own 
 ER
 b template. 
 invite
  is a utility method, like 
 add_egg
 . It’s only of use 
 to the 
 UserController
  object that’s handling the tasks. It would be pointless to 
 allow the 
 invite
  method to be triggered by itself. Just as you wouldn’t ask a baker 
 to crack an egg, you shouldn’t ask the 
 RCR
 chive Rails application to invite some-one 
 (send them email). That’s the application’s business. 
  
  The problem is, if you use the 
 URL
  http://www.rcrchive.net/user/invite, the 
 application’s default behavior is to look inside the user controller and try to call a 
 method called 
 invite
  (just as it does with the methods you want it to call, like 
 acknowledge
 ). Called directly like that, the method will fail: It expects an argu-
 ment, and calling it without one, via a 
 URL
 , will cause a fatal error. 
  
  But there’s another issue: security. What if someone figures out a way to get 
 invite
  to execute? What if the method is rewritten in such a way that it doesn’t 
 crash when it’s called from the outside world? By letting people connect to the",NA
7.4 Writing and using top-level methods,"The most natural thing to do with Ruby is to design classes and modules, and 
 instantiate your classes. But sometimes you just want to write a quick script—a 
 few commands stuffed in a file and executed. 
  
  The files in the 
 script
  directory of any Rails application give you some exam-
 ples of scripts that consist solely of top-level programming instructions with no 
 class or module definitions. These scripts perform tasks like starting up a Web 
 server; creating a new controller, model, or view; or initiating an irb console ses-
 sion so you can test your program interactively. These more complex tasks rely on 
 code with lots of class and modules definitions. The script files themselves config-
 ure a few settings and then fire up the larger software components. 
  
  A quick review of 
 main
 : When you write code at the top level, Ruby provides 
 you automatically with a default self—a default default object, so to speak. This 
 object is a direct instance of 
 Object
 . When you ask it to describe itself
  
 puts self
  
 it says:
  
 main
  
 The object 
 main
  is like the backstop of a Ruby program: It’s the farthest back you 
 can fall. 
 main
  is the current object as soon as your program starts up. 
  
 7.4.1 Defining a top-level method
  
 Suppose you define a method at the top level:
  
 def talk
  
  puts ""Hello"" 
  
 end
  
 Who, or what, does the method belong to? It’s not inside a class or module defini-
 tion block, so it doesn’t appear to be an instance method of a class or module. It’s 
 not attached to any particular object (as in 
 defobj.talk
 ), so it’s not a singleton 
 method. What is it?
  
  
  By special decree (this is just the way it works!), top-level methods are 
 private 
 instance methods of the 
 Kernel
  module.
  
  That decree tells you a lot. 
  
  Because top-level methods are private, you can’t call them with an explicit 
 receiver; you can only call them by using the implied receiver, self. That means self 
 must be an object on whose method search path the given top-level method lies.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
7.5 Summary,"This chapter covered several important topics pertaining to the art of understand-
 ing 
 exactly
  what’s going on at a given point in a Ruby program. We talked about the 
 rotating role of self (the current or default object) which serves as the receiver for 
 method calls if no other receiver is explicitly named and which is the owner of all 
 instance variables. We also looked closely at variable scope in Ruby—the matter of 
 the visibility of variables, and the rules governing the separation of variables of the 
 same name from each other—and at the rules for looking up constants from any 
 scope. 
  
  We then examined Ruby’s method access rules (public, private, protected), and 
 saw that these rules are defined in terms of self, the class of self, and the iden-tity 
 and/or class of the receiver. Both self and method access also played key roles in 
 the chapter’s final topic: the workings of top-level methods. 
  
  The techniques in this chapter are of great importance to Ruby. Concepts like 
 the difference between instance variables in a class definition and instance vari-
 ables in an instance method definition are crucial and can easily be a source of mis-
 understanding. It’s easy to look at a Ruby program and get a general sense of 
 what’s going on. But to understand a program in depth—and to write well-
 organized, robust programs—you need to know how to detect where the various 
 local scopes begin and end, and how to evaluate the impact of Ruby’s assignment of 
 the role of self to a given object. 
  
  This chapter has shown you how to get your bearings in a Ruby program. It’s 
 also shown you some techniques you can use more accurately and effectively in 
 your code by virtue of having your bearings. But there’s more to explore, relating 
 to what you can 
 do
  in the landscape of a program, beyond understanding it. The 
 next chapter, on the subject of 
 control flow
 , will address some of these techniques.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
Control flow techniques,"In this chapter
  
  
 ■
  Conditional execution
  
  
 ■
  Loops and looping techniques
  
  
 ■
  Iterators
  
  
 ■
  Exceptions and error handling
  
 206",NA
8.1 Conditional code execution,"Allow a user access to a site if the password is correct. Print an error message unless 
 the requested item exists. Concede defeat if the king is checkmated. 
 The list of uses 
 for control-ling the flow of a program conditionally—executing specific lines or 
 segments of code only if certain conditions are met—is endless. Without getting 
 too philo-sophical, we might even say that decision-making based on 
 unpredictable but dis-cernible conditions is as common in programming as it is in 
 life. 
  
  Ruby gives you a number of ways to control program flow on a conditional 
 basis.",NA
B ,"when ""yes""",NA
C,"puts ""Good-bye!""
  
  exit 
  
 when ""no""
  
  puts ""OK, we'll continue"" 
  
 else",NA
D,"puts ""That's an unknown answer -- assuming you meant 'no'"" 
 end",NA
E,"The 
 case
  statement begins with the 
 case
  keyword 
 #1
 , continues through all the",NA
B,"when
  blocks 
 #2
  and an 
 else
  clause 
 #3
 , and ends with the 
 end
  keyword 
 #3
 . At most,",NA
C ,NA,NA
D ,NA,NA
E,"one match will succeed; only one 
 when
  expression will be executed. 
  
  You can put more than one possible match in a single 
 when
 , as this snippet 
 shows:
  
 case answer 
  
 when ""y"", ""yes""
  
  puts ""Good-bye!""
  
  exit 
  
 # etc.
  
 This code will say “Good-bye!” and exit if 
 answer
  is either “y” or “yes”. 
  
 How when works
  
 The basic idea of the 
 case
 /
 when
  structure is that you take an object and cascade 
 through a series of tests for a match, taking action based on the test that succeeds. 
 But what does 
 match
  mean in this context? What does it mean, in our example, to 
 say that 
 answer
  matches the word “yes”, or the word “no”, or neither? 
  
  Ruby has a concrete definition of match when it comes to 
 when
  statements. 
 Every Ruby object has a 
 case equality
  method called 
 ===
  (three equal signs, some-
 times called the “threequaloperator”). The outcome of calling the method deter-
 mines whether a 
 when
  clause has matched. 
  
  You can see this clearly if you look first at a 
 case
  statement and then at a trans-
 lation of this statement into threequal terms. Look again at the 
 case
  statement in 
 our previous example. Here’s the same thing (in effect, the same program code) 
 rewritten to show how the threequal method works, and also to illustrate some 
 nice syntactic sugar you get when you use the 
 ===
  method:
  
 if ""yes"" === answer 
  
  
  Syntactic sugar for the method call: 
  
  puts ""Good-bye!""
  
 if ""yes"".===(answer)",NA
B,Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>,NA
C,"puts ""Same location as ticket2!""
  
  when ticket3",NA
D,"puts ""Same location as ticket3!""
  
  else
  
   
  puts ""No match"" 
  
 end
  
  
  
 The output from listing 8.2 is as follows:
  
 ticket1 is for an event at: Town 
 Hall. 
  
 Same location as ticket3!
  
 The match was found through the implicit use of the 
 ===
  instance method of the 
 Ticket
  class 
 #1
 . Inside the 
 case
  statement, the first 
 when
  expression 
 #2
  triggers a",NA
B ,NA,NA
C ,"hidden call to 
 ===
 , equivalent to doing this:
  
 if ticket2 === ticket1
  
 Because the 
 ===
  method returns true or false based on a comparison of venues, 
 and 
 ticket2
 ’s venue isn’t the same as 
 ticket1
 ’s, the comparison between the two 
 tickets returns false. The body of the corresponding 
 when
  clause is therefore not 
 executed.
  
  The next test is then performed: another threequal or case-equality compari-
 son between 
 ticket1
  and 
 ticket3
 #3
 . This test returns true; that 
 when
  expressions",NA
D ,"succeeds, and the code in its body is executed. 
  
  This kind of interflow between method definitions (
 ===
 ) and code that doesn’t 
 look like it’s calling methods (
 case
 /
 when
 ) is typical of Ruby. The 
 case
 /
 when
  struc-
 ture provides an elegant way to perform cascaded conditional tests; and the fact 
 that it’s a bunch of 
 ===
  calls means you can make it do what you need by defining 
 the 
 ===
  method in your classes.",NA
8.2 Repeating actions with loops,"Ruby’s facilities for looping repeatedly through code also allow you to incorporate 
 conditional logic: You can loop 
 while
  a given condition is true (such as a variable 
 being equal to a given value), and you can loop 
 until
  a given condition is true. You 
 can also break out of a loop 
 unconditionally
 , terminating the loop at a certain point 
 and resume execution of the program after the loop. 
  
  
  We’ll look at several ways to loop—starting, appropriately, with a method 
 called 
 loop
 .
  
 8.2.1 Unconditional looping with the loop method
  
 The 
 loop
  method doesn’t take any normal arguments: You just call it. However, it 
 does take a special type of argument called a 
 code block
 . This code block contains 
 the code you want to loop through. Code blocks can be written in one of two ways: 
 either in curly braces (
 {}
 ) or with the keywords 
 do
  and 
 end
 . The following two 
 snippets are equivalent:
  
 loop { puts ""Looping forever!"" } 
  
 loop do puts ""Looping forever!"" end
  
 A loose convention holds that one-line code blocks use the curly braces, and multi-
 line blocks use 
 do
 /
 end
 . (If we were observing that convention, we’d use the first of 
 the versions shown here in preference to the second.) But Ruby doesn’t enforce 
 this convention. 
  
 NOTE
  
 THE DIFFERENCE BETWEEN 
 do
 /
 end
  AND 
 {}
  
 The two ways of delimiting a
  
 code block (
 do
 /
 end
  and 
 {}
 ) aren’t interchangeable: They differ in the 
 matter of 
 precedence
 . When you have a complex statement that involves 
 multiple method calls chained together, and code blocks are involved, the 
 choice of delimiter has a bearing on what is executed in what order and 
 which method call goes with which block. In the vast majority of cases, 
 you don’t have to worry about this. But it’s useful to know that the two 
 approaches aren’t quite identical, as you start to use code blocks more 
 (see section 8.3). 
  
 Code blocks will loom large as we proceed through the book—indeed, by the end 
 of this chapter. You’ll learn much more about what they are, when you use them, 
 and what they enable you to do. For now, though, we’ll just plug them in and watch 
 them go. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
"8.3 Code blocks, iterators, and the yield keyword","The control-flow techniques we’ve looked at so far involve controlling how many 
 times, or under what conditions, a segment of code gets executed. In this section, 
 we’ll examine a different kind of flow control facility. The techniques we’ll discuss 
 here don’t just perform an execute-or-skip operation on a segment of code; they 
 bounce control of the program from one scope to another, and back again.
  
  It may sound like we’ve gone back to talking about method calls. After all, when 
 you call a method on an object, control is passed to the body of the method (a 
 different scope), and when the method has finished executing, control returns to 
 the point right after the point where the method call took place. 
  
  We 
 are
  back in method-call territory, but we’re exploring new aspects of it, not 
 just revisiting the old. We’re talking about a new construct called a 
 code block
  and a 
 keyword by the name of 
 yield
 . 
  
 8.3.1 The basics of yielding to a block
  
 We’ve seen method calls, both with and without arguments. What we haven’t seen 
 (or, more accurately, have only seen in passing, in some of the loop examples in 
 sec-tion 8.2.2) is another optional component of a Ruby method call: the code 
 block.
  
  When you call a method—any method, any time, with or without arguments—
 you have the option of supplying a code block. The code block can consist of any 
 number of lines of Ruby code. This code is wrapped either in curly braces, like this
  
 object.method_name { 
  
 dddd
 # code inside block 
  
 dd
 }
  
 or in a 
 do
 /
 end
  keyword pair, like this:
  
 object.method_name do 
  
  
 dd
 # code inside block 
  
 dd
 end
  
 But 
 why
  would you add a block of code to a method call? You’d do it so that your 
 method can yield.
  
 The yield keyword in action
  
 If you provide a code block when you call a method, then 
 inside the method
 , you 
 can yield control to that code block—suspend execution of the method; execute the 
 code in the block; and return control to the method body, right after the call to 
 yield
 .
  
  It’s like a backward method call. Calling a method causes control to jump from 
 the line containing the call to the method body. The 
 yield
  keyword causes",NA
B,"puts ""About to yield control to the block...""
  
  yield",NA
C,"puts ""Back from the block—finished!""",NA
D,"end
  
 demo_of_yield { puts ""> Control has been passed to the block!"" }",NA
E,"The output from this code is as follows:
  
 Executing the method body...
  
 About to yield control to the block... 
  
 > Control has been passed to the block! 
  
 Back from the block—finished!
  
 When we call the method 
 demo_of_yield
 , program control jumps to the body of 
 the method, and the first two 
 puts
  statements 
 #1
  are executed. The method",NA
B ,"yields 
 #2
  to the code block 
 #4
 ; the code block is, syntactically, part of the 
 method",NA
C ,NA,NA
E ,"call
 , not part of the method, and therefore it’s physically (or lexically) detached 
 from the method.
  
  
  The code inside the block (a single 
 puts
  statement) is executed, after which the 
 block is finished. Control returns to the body of the method at the point 
 immediately after the 
 yield
 #3
 .",NA
D,"A method call in Ruby may involve passing around arguments, and it can also 
 involve the transfer of control back and forth between the method body and the 
 con-text of the method call. Any amount of back-and-forth is possible; a method can 
 yield more than once, and, as you’ll see, most methods that yield at all yield 
 repeatedly.
  
  Now, let’s look more closely at the behavior of our new construct, the code 
 block. 
  
 Passing arguments to a code block
  
 Code blocks have a lot in common with methods. Both consist of lines of code; both 
 get executed, one by being called directly, one by being yielded to. (There’s a way 
 to call code blocks directly, but we won’t get into that until chapter 13.)",NA
CB,converted = yield(temp),NA
D,NA,NA
E,"puts ""#{temp}\t#{converted}"" 
  
  end 
  
 end
  
 celsiuses = [0,10,20,30,40,50,60,70,80,90,100] 
 temp_chart(celsiuses) {|cel| cel * 9 / 5 + 32 }",NA
FG,"Here’s what’s happening in this example:
  
 ■
  The method 
 temp_chart
 #1
  takes an argument: a list (array) of Celsius 
  
 temperatures.
  
 ■
  The temperatures we’re going to convert are stashed in an array 
 #5
  assigned 
 to the variable 
 celsiuses
 , and 
 temp_chart
  is called 
 #6
  with 
 celsiuses
  as an",NA
G ,"argument—and with a code block provided. 
  
 ■
  Inside the method, a 
 for
  loop 
 #2
  goes through the array of temperatures. 
 Each time through the loop, the next value in the array is assigned to the 
 variable 
 temp
 . 
 temp
  is then yielded 
 #3
  to the code block. The return value",NA
D ,"from the block is assigned to the variable 
 converted
 . 
  
 ■
  Inside the code block 
 #6
 , the yielded argument is assigned to the variable 
  
 cel
 . The first time through, 
 cel
  is 0. The next time it’s 10, and so forth.",NA
B,"What you’re not seeing is the method body of 
 each
 —in this case, 
 Array#each 
 (because 
 [1,2,3,4,5]
 is an array). 
 Array#each
  is written in C; it’s part of the 
 core C implementation of Ruby (and it could be written in Ruby easily). It goes 
 through the array, one item at a time, and 
 yields
  the current item. In this example, 
 the code block 
 #1
  accepts each item as it’s yielded and returns that item multiplied 
 by 10.",NA
B,"Every 
 for
  statement is a wrapper around a call to 
 each
 . Some people prefer the 
 look and feel of the 
 for
  version. In particular, it seems to crop up a lot in 
 ER
 b files.
  
 You may see code like this in an ActionView template file:
  
 <% for s in @students %> 
  
 dd
 <%= link_to s.name, 
  
 ddddd
 :controller => ""student"", 
  
 ddddd
 :action 
 dd
 => ""grade"", 
  
 ddddd
 :id 
 ddddd
 => s.id %> 
  
 <% end %>
  
 rather than this:
  
 <% @students.each do |s| %> 
  
 d
 <%= link_to s.name, 
  
 dd
 # etc.
  
 <% end %>
  
 although you’ll definitely see both. The 
 for
  idiom is more familiar to program-
 mers accustomed to languages other than Ruby; 
 each
 , on the other hand, blends a 
 little better with other Ruby idioms. You can take your pick.
  
  So far, we’ve been surveying a cooperative landscape. Everything works so 
 nicely … but that’s not always the way it goes. Unexpected results happen when 
 programs run—and not just at the level of an 
 if
  test returning false. When things 
 go seriously wrong, programs need to react; and reacting to error conditions often 
 involves special kinds of control flow intervention. We’ll look next at Ruby facilities 
 for reacting to, and handling, error conditions.",NA
8.4 Error handling and exceptions,"Way back in chapter 1, we looked at how to test code for syntax errors:
  
 $ ruby -cw 
 filename.rb
  
 Passing the 
 -cw
  test means Ruby can run your program. But it doesn’t mean noth-
 ing will go wrong while your program is running. You can write a syntactically cor-
 rect program—a program that the interpreter will accept and execute—that does 
 all sorts of unacceptable things. Ruby handles unacceptable behavior at runtime by 
 raising an exception
 . 
  
 8.4.1 Raising and rescuing exceptions
  
 An 
 exception
  is a special kind of object, an instance of the class 
 Exception
  or a 
 descendant of that class. 
 Raising
  an exception means stopping normal execution of 
 the program and either dealing with the problem that’s been encountered or 
 exiting the program completely. 
  
  Which of these happens—dealing with it or aborting the program—depends on 
 whether you have provided a 
 rescue
  clause. If you haven’t provided such a clause, 
 the program terminates; if you have, control flows to the 
 rescue
  clause. 
  
  To see exceptions in action, try dividing by zero:
  
 $ ruby -e '1/0'
  
 Ruby raises an exception:
  
 -e:1:in `/': divided by 0 (ZeroDivisionError) 
 from -e:1
  
 ZeroDivisionError
  is the name of this particular exception. More technically, it’s 
 the name of a class—a descendant class of the class 
 Exception
 . Ruby has a whole 
 family tree of exceptions, all of them going back eventually to 
 Exception
 . 
  
 Some common exceptions
  
 Table 8.1 shows some common exceptions (each of which is a class, descended 
 from 
 Exception
 ) along with common reasons they are raised and an example of 
 code that will raise each one. 
  
  You can try these examples in irb; you’ll get an error message, but the session 
 shouldn’t terminate. The technique irb uses to make potentially fatal errors non-
 fatal is available to you, too. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"puts ""Something's wrong with your filename....""  
 raise e",NA
C,"end
  
 This is an example of how to rescue exceptions through the whole body of a 
 method definition. You don’t have to include explicit 
 begin
 /
 end
  delimiters, as long 
 as the 
 rescue
  clause is the last thing in the method; the method’s own 
 end 
 serves 
 as the 
 end
 , and the 
 begin
  is implied. (If you want a rescue scenario for only part of 
 a method definition, you need to reintroduce the 
 begin
 /
 end
  delimiters.)
  
  The major 
 new technique introduced in this example (and the main point here) is the fancy 
 rescue 
 line 
 #1
 . The 
 =>e
  construct puts the 
 Exception
  object",NA
B ,"into the variable 
 e
 . Once you’ve stored the exception in a variable, you can do 
 whatever else you want inside your 
 rescue
  clause (in this case, printing out a 
 vague, ominous error message 
 #2
 ) and then re-raise the exception by raising 
 e
 .",NA
C ,"This re-raise bubbles up to wherever your method was called from. For example, 
 this call to our method
  
 reraiser(""some_non_existent_filename"")
  
 outputs the following:
  
 Something's wrong with your filename....",NA
B ,"reraiser.rb:2:in `initialize': No such file 
  
  or directory - some_non_existent_filename 
  
  
 (Errno::ENOENT)",NA
C,"First, the 
 rescue
  clause intercepts the exception and prints out its message 
 #1
 .",NA
B ,"Then, the exception is re-raised, and this time 
 #2
  it isn’t rescued.",NA
C,"When it comes to the types of exceptions you can raise and rescue, you aren’t 
 limited to Ruby’s built-in exception classes. You can also create your own. 
  
 8.4.3 Creating your own exception classes
  
 You create a new exception class by inheriting from 
 Exception
  or from a descen-
 dant class of 
 Exception
 :",NA
8.5 Summary,"This chapter has covered several wide-ranging topics, all bundled together because 
 they have in common the fact that they involve control flow. Conditionals 
 (
 if
 /
 unless
  and 
 case
 /
 when
 ) move control around based on the truth or falsehood 
 of expressions. Loops (
 loop
 , 
 for
 , and 
 while
 /
 until
 ) repeat a segment of code 
 either unconditionally, conditionally, or once for each item in a list.
  
  Iterators—methods that yield to a code block you provide alongside the call to 
 the method—are among Ruby’s most distinctive features. You’ve learned how to 
 write and call an iterator, techniques you’ll encounter frequently later in this book 
 (and beyond).
  
  Finally, we looked at exceptions, Ruby’s mechanism for handling unrecoverable 
 error conditions. 
 Unrecoverable
  is relative: You can rescue an error condition and 
 continue execution, but you have to stage a deliberate intervention via a 
 rescue 
 block and thus divert and gain control of the program where otherwise it would 
 ter-minate. You can also create your own exception classes through inheritance 
 from the built-in Ruby exception classes. The Rails framework makes extensive use 
 of this technique, creating a spectrum of exceptions with specific, informative 
 names. 
  
  
  Equipped with knowledge of these techniques, we’ll turn next to the explora-
 tion of a series of built-in Ruby classes and modules.",NA
Part 3,NA,NA
Built-in classes and ,NA,NA
modules,NA,NA
I,"n part 3, we’ll look in detail at a number of the built-in classes and modules that 
 are part of the Ruby language. Some of them—strings and integers, for example—
 you’ve seen before, at least briefly or in a usage context. Here, we'll go into depth 
 about each of the classes and modules we look at, and you’ll learn how to use 
 several instance and/or class methods from each one. 
  
 The material presented here represents a selection of classes and modules, and 
 a selection of the methods 
 of
  those classes and modules. The selection is weighted 
 toward those that are more, rather than less, likely to be of use to Rails developers. 
 However, what's 
 really
  of use to Rails developers is a grasp of the Ruby language as 
 a system and a reasonably general Ruby literacy. A dual principle has guided the 
 con-tent of these chapters: not casting such a wide net that the Rails orientation 
 gets diluted out of existence, but also not scrubbing Ruby clean of its integral, 
 organic, systemic qualities.
  
 Chapter 9 covers some preliminaries that will help you get your bearings in the 
 subsequent chapters. It pulls together aspects that a lot of objects have in common, 
 so those points don’t have to be covered repeatedly or confined to one chapter 
 when they really apply to all. From chapter 10 on, we’ll discuss specific classes and 
 modules. Chapter 10 deals with scalar objects: one-dimensional objects like strings 
 and numbers. Chapter 11 covers Ruby’s built-in collection classes: 
 Array
  and 
 Hash
 . 
 In the course of these two chapters, you’ll also learn about the 
 Comparable
  and 
 Enu-merable
  modules, which are the source of searching, filtering, and sorting 
 capabil-ities for many Ruby classes (and which you can mix into your own classes).",NA
Built-in essentials,"In this chapter
  
  
 ■
  Literal object constructors
  
  
 ■
  Syntactic sugar
  
  
 ■
  Iterators in depth
  
  
 ■
  Boolean objects and states
  
  
 ■
  Object comparison techniques
  
  
 ■
  Runtime inspection of objects’ capabilities
  
 233",NA
9.1 Ruby’s literal constructors,"Ruby has a lot of built-in classes. Most of them can be instantiated using 
 new
 :
  
 str = String.new 
  
 arr = Array.new",NA
9.2 Recurrent syntactic sugar,"As you know, Ruby sometimes let you use sugary notation in place of the usual 
 object.method(args)
  method-calling syntax. This lets you do nice-looking things, 
 such as using a plus sign between two numbers, like an operator:
  
 x = 1 + 2
  
 Here’s the odd-looking method-style equivalent:
  
 x = 1.+(2)
  
 As you delve more deeply into Ruby and its built-in methods, be aware that certain 
 methods 
 always
  get this treatment. Methods in this special group—whether 
 they’re methods of built-in classes, or methods you write in your own classes—can 
 always be called with the syntactic sugar notation rather than the method-call 
 notation. For example, you can define the plus-sign method on an object you’ve 
 created. Here’s a somewhat bizarre but perfectly valid example:
  
 obj = Object.new 
  
 def obj.+(other_obj)
  
  ""Trying to add something to me, eh?"" 
  
 end
  
 puts obj + 100   # output: Trying to add something to me, eh?
  
 The plus sign in the 
 puts
  statement is a call to the 
 +
  method of 
 obj
 , with the inte-
 ger 100 as the single argument. If the method chooses to ignore the argument, and 
 not to perform addition of any kind, it can. 
  
  A number of Ruby’s automatically sugared methods are collected in table 9.2.
  
 Table 9.2
  
 Methods with operator-style syntactic sugar calling notation
  
  
 Category
  
 Name
  
 Definition example
  
 Calling example
  
 Sugared notation
  
 Arithmetic method/ 
 operators
  
 +
  
 def +(x)
  
 obj.+(x)
  
 obj + x
  
 -
  
 def -(x)
  
 obj.-(x)
  
 obj - x
  
 *
  
 def *(x)
  
 obj.*(x)
  
 obj * x
  
 /
  
 def /(x)
  
 obj./(x)
  
 obj / x
  
 %
  
 def %(x)
  
 obj.%(x)
  
 obj % x
  
 Get/set/append data
  
 []
  
 def [](x)
  
 obj.[](x)
  
 obj[x]
  
 []=
  
 def []=(x,y)
  
 obj.[]=(x,y)
  
 obj[x] = y
  
 <<
  
 def <<(x)
  
 obj.<<(x)
  
 obj << x",NA
9.3 Methods that change their receivers (or don’t),"The basic scenario of calling a method is always the same:
  
 1 
  
 A message is sent to a receiver (an object).
  
 2 
  
 The object executes the first method on its method lookup path whose 
  
 name matches the message (or handles the error condition if there’s no 
  
 such method).
  
 3 
  
 The method returns a value.
  
 That’s what 
 always
  happens. In addition, some things 
 sometimes
  happen. The first 
 two will be familiar; the third is what we’ll focus on here:
  
 ■
  A method call may (or may not) include arguments.
  
 ■
  A method may (or may not) yield one or more times to a code block 
  
 associated with the method call.
  
 ■
  A method may (or may not) 
 modify its receiver.
  
 What does it mean for a method to modify its receiver?",NA
9.4 Built-in and custom to_* (conversion) methods,"Ruby offers a number of built-in methods whose names start with 
 to_
  and end 
 with something that indicates a class 
 to
  which the method converts an object: 
 to_s 
 (to string), 
 to_a
  (to array), 
 to_i
  (to integer), and 
 to_f
  (to float). Not all objects 
 respond to all of these methods. But many objects respond to a lot of them, and the 
 principle is consistent enough to warrant looking at them collectively. 
  
  The most commonly used 
 to_
  method is probably 
 to_s
 . Every Ruby object 
 responds to 
 to_s
 ; every Ruby object has a way of displaying itself as a string. What 
 to_s
  does, as the following irb-session excerpts show, ranges from nothing, other 
 than return its own receiver, when the object is already a string
  
 >> ""I am already a 
 string!"".to_s 
  
 => ""I am already a string!""
  
 to a flattened, probably useless string representation of miscellaneous data
  
 >> [""one"", ""two"", ""three"", 4, 5, 6].to_s 
  
 => ""onetwothree456""
  
 to an informative, if cryptic, descriptive string about an object:
  
 >> Object.new.to_s 
  
 => ""#<Object:0x401f81a4>""
  
 (The numbers in the string representing the new object may be different on your 
 computer; they pertain to memory addresses.) 
  
  
  Another common and useful 
 to_
  method is 
 to_i
  (to integer). (It’s so useful that 
 we’ve already used it in earlier examples.) Unlike some programming languages,",NA
9.5 Iterators reiterated,"As we proceed with the core classes and modules, you’ll see a ton of iterators. 
 Consider this a reminder and a pep talk. 
  
  
  There’s no doubt that iterators add twists and turns to the basic method call 
 scenario. But it’s additive: New things happen, but the old things 
 still
  happen. 
  
  Every Ruby method call produces a return value. 
 That includes iterators
 . This 
 fact isn’t always obvious. In many cases, everything you care about happens in the 
 code block when the method yields to it. The eventual return value of the call to 
 the iterator may be anticlimactic. 
  
  The best example of an anticlimactic return value is the array method 
 each
 , a 
 basic iterator method that walks through the array one item at a time and yields 
 the item it’s on to the code block. You can do a lot inside an 
 each
  code block. But 
 the return value of 
 each
  is unexciting; 
 each
  returns its own receiver, the original 
 array:
  
 array = [1,2,3,4,5] 
  
 other = array.each {|n| puts ""Current element is #{n}"" }
  
 Here, 
 other
  is just another reference to (another variable attached to) 
 array
 . 
 There’s rarely any point in capturing the return value of 
 each
 . The action is in the 
 code block; the return value is a formality.",NA
"9.6 Boolean states, Boolean objects, and nil","Every expression in Ruby evaluates to an object; and every object has a Boolean 
 value of either 
 true
  or 
 false
 . Furthermore, 
 true
  and 
 false
  are objects. This idea 
 isn’t as convoluted as it sounds. If 
 true
  and 
 false
  weren’t objects, then a pure 
 Boolean expression like
  
 100 > 80
  
 would have no object to evaluate 
 to
 . 
  
  In many cases where you want to get at a truth/falsehood value, such as an 
 if 
 statement or a comparison between two numbers, you don’t have to manipulate 
 these special objects directly. In such situations, you can think of truth and false-
 hood as 
 states
 , rather than objects.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"puts ""Empty class definition is true!""
  
 else
  
  puts ""Empty class definition is false!"" 
  
 end
  
 if (class MyClass; 1; end)",NA
C,"puts ""Class definition with the number 1 in it is true!"" 
 else
  
  puts ""Class definition with the number 1 in it is false!"" 
 end
  
 if (def m; ""A call to this method would be 'true'!""; end)  
 puts ""Method definition is true!""",NA
D,else,NA
E,"puts ""Strings appear to be true!"" 
  
 else
  
  puts ""Strings appear to be false!"" 
  
 end
  
 if 100 > 50",NA
F,"puts ""100 is greater than 50!"" 
  
 else
  
  puts ""100 is not greater than 50!"" 
  
 end
  
  
  
  
 As you’ll see if you run the code in listing 9.3, empty class definitions 
 #1
  are false;",NA
B,"non-empty class definitions evaluate to the same value as the last value they con-
  
 tain 
 #2
  (in this example, the number 1); method definitions are false 
 #3
  (even if a",NA
C ,NA,NA
D,"call
  to the method would return a true value); strings are true 
 #4
 ; and 100 is",NA
E,"greater than 50 
 #5
 . You can use this simple 
 if
  technique to explore the Boolean",NA
F,"value of any Ruby expression. 
  
  The 
 if
  examples show that every expression in Ruby is either true or false, in 
 the sense of either passing or not passing an 
 if
  test. What these examples don’t 
 show you, however, is what these expressions evaluate 
 to
 . That is what the 
 if
  test 
 is really testing: It evaluates an expression (such as 
 classMyClass;end
 ) and pro-
 ceeds on the basis of whether the value produced by that evaluation is true. 
  
  
  To see what values are returned by the expressions whose truth-value we’ve 
 been testing, you can print those values:
  
 >> class MyClass; end",NA
B ,"=> nil 
  
 >> class MyClass; 1; end",NA
C ,"=> 1 
  
 >> def m; ""A call to this method would be 'true'!""; end",NA
D ,"=> nil 
  
 >> ""string literal!""",NA
E ,"=> ""string literal!"" 
  
 >> 100 > 50",NA
F ,"=> true
  
 Some of these expressions—the empty class definition 
 #1
  and the method defini-",NA
B ,"tion 
 #3
 —evaluate to 
 nil
 , which is a special object (discussed in section 9.6.3). All",NA
D ,"you need to know for the moment about 
 nil
  is that it has a Boolean value of false 
 (as you can detect from the behavior of the 
 if
  clauses that dealt with it in listing 
 9.3).",NA
C ,"because every class definition block evaluates to the last expression contained 
 inside it, or 
 nil
  if the block is empty.
  
  The string literal 
 #4
  evaluates to itself; it’s a literal object and doesn’t have to",NA
E ,"be calculated or processed into some other form when evaluated. Its value as an 
 expression is itself. 
  
  Finally, the comparison expression 
 100>50
 #5
  evaluates to 
 true
 —not just to",NA
F ,"something that has the Boolean value true, but to the object 
 true
 . The object 
 true 
 does have the Boolean value true. But, along with 
 false
 , it also has a special role to 
 play in the realm of truth and falsehood and how they’re represented in Ruby. 
  
 9.6.2 true and false as objects
  
 The Boolean objects 
 true
  and 
 false
  are special objects, each being the only 
 instance of a class especially created for it: 
 TrueClass
  and 
 FalseClass
 , 
 respectively.
  
 You can ask 
 true
  and 
 false
  to tell you their classes’ names, and they will:
  
 puts true.class    # output: TrueClass 
  
 puts false.class   # output: FalseClass
  
 The terms 
 true
  and 
 false
  are keywords. You can’t use them as variable or method 
 names; they are reserved for Ruby’s exclusive use. 
  
  You can pass the objects 
 true
  and 
 false
  around, assign them to variables, and 
 examine them, just like any other object. Here’s an irb session that puts 
 true 
 through its paces in its capacity as a Ruby object:
  
 >> a = true 
  
 => true 
  
 >> a = 1 unless a 
  
 => nil 
  
 >> a 
  
 => true 
  
 >> b = a 
  
 => true
  
 You’ll often see 
 true
  and 
 false
  used as method arguments and values in a 
 method-argument hash (structures similar to the 
 link_to
  examples in chapter 3). 
 That’s the gist of the 
 create_table
  example that started this section: For each 
 field you create in a table, you can specify 
 :null=>true
  (if you want the field to be 
 allowed to be null; this is also the default) or 
 :null=>false
  (if you don’t). 
  
  In most cases where a method asks for a Boolean argument or a Boolean value 
 for a key (such as 
 :null
  in 
 create_table
 ), it will work if you send it an expression 
 with a Boolean value of true of false:
  
 :null => 100 > 50",NA
9.7 Comparing two objects,"Ruby objects are created with the capacity to compare themselves to other objects 
 for equality, using any of several methods. Some objects can also compare them-
 selves to each other for greater-than and less-than relationships; and you can teach 
 objects that can’t do these things how to do them. 
  
  Tests for equality are the most common comparison tests, and we’ll start with 
 them. We’ll then look at a built-in Ruby module called 
 Comparable
 , which gives you 
 a quick way to impart knowledge of comparison operations to your classes and 
 objects—and which also is present in a number of built-in Ruby classes. 
  
 9.7.1 Equality tests
  
 Inside the 
 Object
  class, all equality-test methods do the same thing: They tell you 
 whether two objects are 
 exactly the same object
 . Here they are in action:
  
 >> a = Object.new 
  
 => #<Object:0x401c653c> 
  
 >> b = Object.new 
  
 => #<Object:0x401c4bd8> 
  
 >> a == a 
  
 => true 
  
 >> a == b 
  
 => false 
  
 >> a.eql?(a) 
  
 => true 
  
 >> a.eql?(b) 
  
 => false 
  
 >> a.equal?(a) 
  
 => true 
  
 >> a.equal?(b) 
  
 => false
  
 All three of these equality test methods—
 ==
 , 
 eql?
 , and 
 equal?
 —give the same 
 results in these examples: When you test 
 a
  against 
 a
 , the result is 
 true
 ; and when 
 you test 
 a
  against 
 b
 , the result is 
 false
 . We appear to have three ways of establish-
 ing that 
 a
  is 
 a
  but not 
 b
 .
  
  There isn’t much point in having three tests that do the same thing. Further 
 down the road, in classes other than the granddaddy 
 Object
  class, these methods 
 are redefined to do meaningful work for different objects. Two of them, at most, 
 are redefined; 
 equal?
  is usually left alone so that you can always use it to check 
 whether two objects are exactly the same object. 
  
  Furthermore, Ruby gives you a suite of tools for object comparisons, and not 
 always just comparison for equality. We’ll look next at how equality tests and their 
 redefinitions fit into the overall comparison picture. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"if self.estimate < other_bid.estimate
  
   
  -1
  
   
  elsif self.estimate > 
 other_bid.estimate
  
  
  
  1
  
   
  else
  
    
  0
  
   
  end
  
  end 
  
 end
  
  
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"Depending on which branch is executed, the method returns -1, 1, or 0. Those 
 three return values are predefined, prearranged signals to Ruby. Your 
 <=>
  method 
 must return one of those three values every time it’s called—and they always 
 mean less than, equal to, and greater than, in that order. 
  
  You can shorten this method. Bid estimates are either floating-point numbers 
 or integers (the latter, if you don’t bother with the cents parts of the figure). Num-
 bers 
 already
  know how to compare themselves to each other, including integers to 
 floats. 
 Bid
 ’s 
 <=>
  method can therefore piggyback on the existing 
 <=>
  methods of 
 the 
 Integer
  and 
 Float
  classes, like this:
  
 def <=>(other_bid) 
  
 dd
 self.estimate <=> 
 other_bid.estimate 
  
 end
  
 All Ruby numerical classes include 
 Comparable
  and have a definition for 
 <=>
 . The 
 same is true of the 
 String
  class; you can compare strings using the full assortment 
 of 
 Comparable
  method/operators.",NA
9.8 Listing an object’s methods,"It’s important not only that you learn the details of methods available to you in the 
 built-in classes, but also that you learn how to explore further. One way you can 
 explore further is to ask an object to tell you about its methods. 
  
  How you do this depends on the object. When you ask 
 Class
  and 
 Module 
 objects for their methods, you have to distinguish instance methods (methods that 
 instances of the class, or objects with access to the module, can call) from methods 
 the class or module can call (class methods and singleton methods of the module 
 object). 
  
  The simplest and most common case is when you want to know what messages 
 an object responds to—that is, what methods you can call on it. Ruby gives you a 
 typically simple way to do this (our examples are suitable for entering into irb; 
 we’ll let irb show us the results, rather than doing an explicit printout): 
  
 ""I am a String object"".methods
  
 This results in a huge array of method names. At the very least, you’ll want to sort 
 them so you can find what you’re looking for:
  
 ""I am a String object"".methods.sort",NA
9.9 Summary,"This chapter has covered several topics that pertain to multiple built-in classes. 
 You’ve seen Ruby’s literal constructors, which provide a concise alternative to call-
 ing 
 new
  on certain built-in classes. You’ve also seen how Ruby provides you with 
 syntactic sugar for particular method names, including a large number of meth-ods 
 with names that correspond to arithmetic operators. 
  
  We looked at the significance of methods that change their own receivers, 
 which many built-in methods do (many of them bang methods, which end with 
 !
 ). 
 We also examined the 
 to_*
  methods: built-in methods for performing conversions 
 from one core class to another. The chapter also reviewed the importance of iter-
 ators, something you’ll see a lot of in upcoming chapters. 
  
  You’ve also learned a number of important points and techniques concerning 
 Boolean (true/false) values and comparison between objects. You’ve seen that 
 every object in Ruby has a Boolean value and that Ruby also has special Boolean 
 objects (
 true
  and 
 false
 ) that represent those values in their simplest form. A 
 third special object, 
 nil
 , represents a state of undefinedness or absence. We also 
 discussed techniques for comparing objects using the standard comparison opera-
 tor (
 <=>
 ) and the 
 Comparable
  module. 
  
  Finally, we looked at ways to get Ruby objects to tell you what methods they 
 respond to—a kind of metaprogramming technique that can help you see and 
 understand what’s going on at a given point in your program. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
Scalar objects,"In this chapter
  
  
 ■
  Strings
  
  
 ■
  Symbols
  
  
 ■
  Numerics
  
  
 ■
  Date and time objects
  
 257",NA
10.1 Working with strings,"Ruby gives you two built-in classes that, between them, provide all the functional-
 ity of text: the 
 String
  class and the 
 Symbol
  class. We’ll start with strings, which are 
 the standard way to represent bodies of text of arbitrary content and length.
  
 10.1.1 String basics
  
 A 
 string literal
  is generally enclosed in quotation marks:
  
 ""This is a string.""
  
  Single quotes can also be used:
  
 'This is also a string.'
  
 But a single-quoted string behaves very differently, in some circumstances, than a 
 double-quoted string. The main difference is that 
 string interpolation
  doesn’t work 
 with single-quoted strings. Try these two snippets, and you’ll see the difference:
  
 puts ""Two plus two is #{2 + 
 2}."" 
  
 puts 'Two plus two is #{2 + 
 2}.'",NA
B ,">> str 
  
 => ""Hi """,NA
C,"The expression 
 str+""there.""
  evaluates to the new string “Hi there.” 
 #1
  but",NA
B ,"leaves 
 str
  unchanged 
 #2
 .",NA
C,"To add (append) a second string permanently to an existing string, use the 
 << 
 method, which also has a syntactic sugar, pseudo-operator form:
  
 >> str = ""Hi "" 
  
 => ""Hi "" 
  
 >> str << ""there."" 
  
 => ""Hi there."" 
  
 >> str 
  
 => ""Hi there.""",NA
B,"In this example, the original string 
 str
  has had the new string appended to it, as 
 you can see from the evaluation of 
 str
  at the end 
 #1
 .",NA
B,NA,NA
B ,"=> ""Good-bye."" 
  
 >> str 
  
 => ""Good-bye.""",NA
C,"The final value of 
 str
 #2 
 is “Good-bye.”, the string with which you have replaced 
 #1",NA
C ,NA,NA
B ,"str
 ’s original contents. Keep in mind that replacing a 
 string’s contents isn’t the same as creating a completely new string. 
 str
  still refers 
 to the same string, which means other variables referring to that string will also 
 reflect the change:
  
 >> str = ""Hi there.""
  
 => ""Hi there."" 
  
 >> x = str",NA
B ,"=> ""Hi there."" 
  
 >> str.replace(""Good-bye."") 
 => ""Good-bye.""",NA
C,">> x 
  
 => ""Good-bye.""
  
 In this example, 
 str
  and 
 x
  refer to one and the same string object; that’s estab-
 lished when you assign 
 str
  to 
 x
 #1
 . When that one and only string object has its",NA
B ,"contents replaced via a method call on 
 str
 #2
 , the string’s new contents are also",NA
C ,"reflected in 
 x
 . 
  
 replace
  thus lets you change a string in such a way that all existing references 
 to it (variables) still refer to the same string. It’s an example of a non-bang method 
 that changes an object in place. The name, 
 replace
 , conveys this fact, without the 
 need for the exclamation point. (Also, a bang method usually exists in a pair with a 
 non-bang version, and it’s impossible to imagine what “replacing the contents of a 
 string object” without changing the string would even mean.)",NA
B,">> str
  
 => ""Hello"" 
  
 >> str.reverse! 
  
 => ""olleH""",NA
C,">> str 
  
 => ""olleH""
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"expression as “olleH”. But the string is still “Hello”, as you can see when you ask irb 
 to show you the value of 
 str
 . The bang version, 
 reverse!
  #2
 , 
 does
  change the",NA
C ,"original string permanently—as you can see, again, by asking irb to display 
 str
 . 
  
  Meanwhile, we'll look next at working with substrings and individual   
 characters.
  
 Grabbing characters and substrings
  
 Strings come with a pair of get/set methods: the ubiquitous 
 []
  and 
 []=
  methods. 
 To grab the 
 n
 th character of a string, you use 
 []
  with an index (starting at zero). 
 But beware: You get back a number, not a character. Specifically, you get the 
 character’s 
 ASCII
  value. For example, here’s how to get the 
 ASCII
  value of the 
 character “c”:
  
 >> ""abc""[2] 
  
 => 99
  
 You can turn this number back into a character with the 
 chr
  method:
  
 >> ""abc""[2].chr 
  
 => ""c""
  
 You can also use a negative index. If you do, the index is counted from the right side 
 of the string:
  
 >> ""abc""[-2].chr 
  
 => ""b""
  
 (You’ll see more negative, right-hand indexing when we look in detail at arrays in 
 chapter 11.)
  
  
  You can grab a substring of a string by giving two arguments to 
 []
 , in which 
 case the first argument is the starting index and the second argument is the length 
 of the substring you want. For example, to get a four-character substring starting at 
 the sixth character (remember, strings are zero-indexed), you do this:
  
 >> ""This is a 
 string""[5,4] 
  
 => ""is a""
  
 TIP
  
 USING SUBSTRING SYNTAX TO GET ONE CHARACTER
  
 Because you can
  
 grab substrings of any length using the two-argument form of 
 String#[]
 , 
 you can grab any one character (without having to convert it back from an 
 ASCII
  value) by requesting a substring of length one: for example, 
 ""abc""[2,1]
  is “c”.
  
 The string set method 
 []=
  works the opposite way from 
 []
 : It changes the string 
 (in place) by inserting the substring you specify into the position you give. It also 
 has a two-argument form. Here it is in action:",NA
B ,"=> ""!"" 
  
 >> s 
  
 => ""This is a string!"" 
  
 >> s[2,2] = ""at""",NA
C ,"=> ""at"" 
  
 >> s 
  
 => ""That is a string!""
  
 This example includes two set operations; after each one, we print out the string.
  
 The first 
 #1
  changes the string’s last character from 
 .
  (period) to ! (exclamation",NA
B ,"point). The second 
 #2
  changes the third and fourth characters from 
 is
  to 
 at
 . The",NA
C ,"result is that evaluating 
 s
  now results in “That is a string!”
  
  
  These techniques give you fine-grained control over the contents of strings, 
 enabling you to do just about any manipulation you’re likely to need. 
  
  This survey has given you a good foundation in string manipulation, although 
 by no means have we exhausted the topic. Here, as usual, irb is your friend. Test 
 things, experiment, and see how the string methods interact with each other.
  
  Meanwhile, we’re going to move on to the matter of string comparisons. 
  
 10.1.3 Comparing strings
  
 As you know, Ruby objects can be compared in numerous ways; what the compari-
 sons mean, as well as which are available, varies from object to object. Strings have 
 a full set of comparison capabilities; strings are 
 comparable
 , in the technical sense 
 that the class 
 String
  mixes in the 
 Comparable
  module. 
  
  
  We’ll look here at the various kinds of comparisons you can perform between 
 one string and another. 
  
 Comparing two strings for equality
  
 Like Ruby objects in general, strings have several methods for testing equality. The 
 most common one is 
 ==
  (double equals sign), which comes with syntactic sugar 
 allowing you to use it like an operator. This method tests for equality of string 
 content:
  
 >> ""string"" == ""string"" 
  
 => true 
  
 >> ""string"" == ""house"" 
  
 => false
  
 The two literal 
 ""string""
  strings are different objects, but they have the same con-
 tent. Therefore, they pass the 
 ==
  test.",NA
10.2 Symbols and their uses,"Symbols are instances of the built-in Ruby class 
 Symbol
 . They have a literal 
 construc-tor: the leading colon. You can always recognize a symbol literal (and 
 distinguish it from a string, a variable name, a method name, or anything else) by 
 this token:
  
 :a 
  
 :book 
  
 :""Here's how to make a symbol with spaces in it.""
  
 You can also create a symbol programmatically, by calling the 
 to_sym
  method (also 
 known by the synonym 
 intern
 ) on a string, as irb shows:
  
 >> ""a"".to_sym 
  
 => :a 
  
 >> ""Converting string to symbol with intern...."".intern 
 => :""Converting string to symbol with intern....""
  
 Note the tell-tale leading colons on the evaluation results returned by irb. 
  
  You can also easily convert a symbol to a string:
  
 >> :a.to_s 
  
 => ""a""
  
 These examples illustrate how closely related symbols are to strings. Indeed they 
 are related, in that they share responsibility for representing units of text. How-
 ever, strings and symbols  differ in some important ways.
  
 10.2.1 Key differences between symbols and strings
  
 One major difference between symbols and strings is that only one symbol object 
 can exist for any given unit of text. Every time you see the notation for a particular 
 symbol (
 :a
 ), you’re seeing 
 the same symbol object
  represented. That differs from 
 the situation with strings. If you see two identical-looking string literals
  
 ""a"" 
  
 ""a""
  
 you’re seeing two different string objects (as the string comparison examples in 
 section 10.1.3 demonstrated). With symbols, any two that look the same 
 are
  the 
 same—the same object. You can test this with the 
 equal?
  comparison method, 
 which returns true only if both the method’s receiver and its argument are the 
 same object:
  
 >> :a.equal?(:a) 
  
 => true 
  
 >> ""a"".equal?(""a"") 
  
 => false",NA
10.3 Numerical objects,"In Ruby, numbers are objects. You can send messages to them, just as you can to 
 any object:
  
 n = 98.6 
  
 m = n.round 
  
 puts m",NA
B,"x = 12 
  
 if x.zero?
  
 dd
 puts ""x is zero"" 
  
 else 
  
 dd
 puts ""x is not zero""",NA
C ,"end
  
 puts ""The ASCII character equivalent of 97 is #{97.chr}""",NA
D,"As you’ll see if you run this code, floating-point numbers know how to round 
 themselves 
 #1
  (up or down). Numbers in general know 
 #2
  whether they are zero.",NA
B C ,"And integers can convert themselves to the character that corresponds to their 
 ASCII
  value 
 #3
 .",NA
D,"Numbers are objects; therefore, they have classes—a whole family tree of them.
  
 10.3.1 Numerical classes
  
 Several classes make up the numerical landscape. Figure 10.1 shows a slightly sim-
 plified view (mixed-in modules aren’t shown) of those classes, illustrating the 
 inheritance relations among them.
  
  The top class in the hierarchy of numerical 
 classes is 
 Numeric
 ; all the others descend from it. 
 The first branch in the tree is between floating-
 point and integral numbers: the 
 Float
  and 
 Integer 
 classes. Integers are broken into two classes: 
 Fixnum 
 and 
 Bignum
 . (Bignums, as you may surmise, 
 are very large integers. When you use or calculate 
 an inte-ger that’s big enough to be a Bignum, Ruby 
 han-dles the conversion automatically for you; you
  
 Numeric
  
  
 Float
  
 Integer
  
  
 Fixnum
  
 Bignum
  
 Figure 10.1 
  
 Numerical class hierarchy
  
 don’t have to worry about it.)",NA
B ,"=> 30
  
 The second 12 in the last expression 
 #1
  is a decimal 12; the 
 0x
  prefix applies only",NA
B ,"to the numbers it appears on.
  
  Integers beginning with 0 are interpreted as 
 octal
  (base eight):
  
 >> 012 
  
 => 10 
  
 >> 012 + 12 
  
 => 22 
  
 >> 012 + 0x12 
  
 => 28
  
 You can also use the 
 to_i
  method of strings to convert numbers in any base to 
 decimal. To perform such a conversion, you need to supply the base you want to",NA
10.4 Times and dates,"Ruby gives you lots of ways to manipulates times and dates—and Rails enhances 
 and extends Ruby’s time and date facilities with a variety of new methods. As a 
 Rails developer, you’re likely to use those added-on methods more than the raw 
 Ruby ones. Still, you should gain some familiarity with Ruby’s date and time librar-
 ies, for the sake of being able to use them when you need them as well as for the 
 sake of understanding where the Rails methods come from. 
  
  Times and dates are manipulated through three classes: 
 Time
 , 
 Date
 , and 
 DateTime
 . In order to reap their full benefits, you have to pull one or both of the 
 date
  and 
 time
  libraries into your program or irb session:
  
 require 'date' 
  
 require 'time'",NA
10.5 Summary,"In this chapter, you’ve seen the basics of the most common and important scalar 
 objects in Ruby: strings, symbols, numerical objects, and time/date objects. Some 
 of these topics involved consolidating points made earlier in the book; others
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
"Collections, ",NA,NA
"containers, and ",NA,NA
enumerability,"In this chapter:
  
  
 ■
  Arrays
  
  
 ■
  Hashes
  
  
 ■
  The 
 Enumerable
  module
  
  
 ■
  Filtering, transforming, and sorting collections
  
 277",NA
11.1 Arrays and hashes compared,"An 
 array
  is an ordered collection of objects, 
 ordered
  meaning that you can select 
 objects from the collection based on a consistent numerical index. You’ll have 
 noticed that we’ve already used arrays in some of the examples earlier in the book, 
 going back all the way to our first Rails application walk-through. It’s hard 
 not
  to 
 use arrays in Ruby. 
  
 Hashes
  are 
 unordered
  collections, meaning that they don’t have a sense of what 
 their first or second or 
 n
 th element is. Instead, they store objects in pairs, each pair 
 consisting of a 
 key
  and a 
 value
 . You retrieve a value by means of the key. Hashes (or 
 similar data storage types) are sometimes called 
 dictionaries
  or 
 associative arrays
  
 in other languages. They offer a tremendously—sometimes surprisingly—
 powerful way of storing and retrieving data. 
  
  Arrays and hashes are closely connected. An array is, in a sense, a hash, where 
 the keys are consecutive integers. Hashes are, in a sense, arrays, where the indices 
 are allowed to be anything, not just integers. Transformations of various kinds 
 between the two are common. Arrays “win,” in the sense that they are the more 
 basic and fundamental of the two. Quite a few operations that you perform on 
 hashes produce arrays. For instance, if you select key-value pairs based on some 
 cri-terion (such as selecting all pairs where the value is a capitalized string), your 
 selec-tion operation will hand you back an 
 array
  of the results. When you’re 
 dealing with",NA
11.2 Using arrays,"Arrays are the bread-and-butter way to handle collections of objects. An array is an 
 object whose job is to store other objects.
  
  Arrays are 
 ordered
  collections; you can get at their contents by the use of 
 numeri-cal indexes. The contents of an array always remain in the same order, 
 unless you change it. 
  
 11.2.1 Creating a new array
  
 There are two ways to create a new array. First, you can use the 
 new
  method:
  
 a = Array.new
  
 You can then add objects to the array (using techniques we’ll look at later). 
  
  
 The other way to create an array is by using the 
 literal array constructor
 [] 
 (square 
 brackets): 
  
 a = []
  
 When you use the literal constructor, you can also put objects into the array at the 
 same time you create it:
  
 a = [1,2,""three"",4, [] ]
  
 (Notice that the last element in this array is another array. That’s perfectly legiti-
 mate; you can nest arrays to as many levels as you wish.) 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"=> [nil, nil, nil] 
  
 >> Array.new(3,""abc"")",NA
C ,"=> [""abc"", ""abc"", ""abc""]
  
 If you give one argument to 
 Array.new
 #1
 , you get an array of the size you asked 
 for,",NA
B ,"with all elements set to 
 nil
 . If you give two arguments 
 #2
 , you get an array of the 
 size",NA
C ,"you asked for, with each element initialized to contain the second argument.
  
  
 You can even supply a code block to 
 Array.new
 . In that case, the elements of the 
 array are initialized by repeated calls to the block:
  
 >> n = 0 
  
 => 0 
  
 >> Array.new(3) { n += 1; n * 10 }",NA
B ,"=> [10, 20, 30]",NA
C,"In this example, the new array has a size of three. Each of the three elements is set 
 to the return value of the code block. The code inside the block 
 #1
 , executed",NA
B ,"three times, produces the values 10, 20, and 30—and those are the initial values in 
 the array 
 #2
 .",NA
C,"Pre-initializing arrays isn’t always necessary, because your arrays will grow as 
 you add elements to them. But if and when you need this functionality—and/or if 
 you see it in use and want to understand it—it’s there.
  
 WARNING
  
 BE CAREFUL WITH DEFAULT ARRAY ELEMENTS
  
 When you initialize multi-
  
 ple elements of an array using a second argument to 
 Array.new
 —as in 
 Array
 .new(3,""abc"")
 —
 all the elements
  of the array are initialized 
 to the 
 same object
 . If you do 
 a=Array.new(3,""abc"");a[0]<<""def"";putsa[1]
 , 
 the second element of the array is changed when you add 
 def
  to the first 
 element, because they’re the same string object. To create an array that 
 inserts a different “abc” string into each slot, you should use 
 Array.new(3){""abc""}
 . The code block runs three times, each time 
 generating a new string (same characters, different string object). 
  
 11.2.2 Inserting, retrieving, and removing array elements
  
 Because an array is an ordered collection, any object you add to the array goes 
 either at the beginning, at the end, or somewhere in the middle. The most gen-eral 
 technique for inserting one or more items into an array is the setter method 
 []=
  
 (square brackets and equal sign). This looks odd as a method name in the",NA
B ,"=> [""purple"", ""gray""] 
  
 >> a[3,2] = ""green"", ""blue""",NA
C ,"=> [""green"", ""blue""] 
  
 >> a 
  
 => [""red"", ""orange"", ""yellow"", ""green"", ""blue"", ""indigo"", ""violet""]",NA
D,"After initializing the array 
 a
 , we grab 
 #1
  two elements, starting at index 3 (the",NA
B ,"fourth element) of 
 a
 . The two elements are returned in an array. Next, we set the 
 fourth and fifth elements, using the 
 [3,2]
  notation 
 #2
 , to new values; these new 
 val-",NA
C ,"ues are then present in the whole array 
 #3
  when we ask irb to display it at the end.",NA
D,NA,NA
B,NA,NA
B,"Another useful array-combining method is 
 replace
 . As the name implies, 
 replace
  replaces the contents of one array with the contents of another:
  
 >> a = [1,2,3]
  
 => [1, 2, 3] 
  
 >> a.replace([4,5,6]) 
 => [4, 5, 6]",NA
B,">> a 
  
 => [4, 5, 6]
  
 The original contents of 
 a
  are gone, replaced 
 #1
  by the contents of the argument",NA
B ,"array 
 [4,5,6]
 . Note that a 
 replace
  operation is different from reassignment. If you 
 do this
  
 a = [1,2,3] 
  
 a = [4,5,6]
  
 the second assignment causes the variable 
 a
  to refer to a completely different array 
 object than the first. That’s not the same as replacing the elements of the 
 same
  
 array object. This starts to matter, in particular, when you have another vari-able 
 that refers to the original array. It’s worth looking closely at what’s at stake:
  
 >> a = [1,2,3] 
  
 => [1, 2, 3] 
  
 >> b = a",NA
B ,"=> [1, 2, 3] 
  
 >> a.replace([4,5,6]) 
  
 => [4, 5, 6] 
  
 >> b",NA
C ,"=> [4, 5, 6] 
  
 >> a = [7,8,9]",NA
D ,"=> [7, 8, 9] 
  
 >> b 
  
 => [4, 5, 6]",NA
E,"Once you’ve performed the assignment of 
 a
  to 
 b
 #1
 , 
 replacing
  the contents of 
 a",NA
B ,"means you’ve replaced the contents of 
 b
 #2
 , because the two variables refer to the",NA
C ,"same array. But when you reassign to 
 a
 #3
 , you break the connection; 
 a
  and 
 b
  now",NA
D ,"refer to different array objects: 
 b
  to the same old array 
 #4
 , 
 a
  to a new one.",NA
E,"No discussion of combining arrays would be complete without 
 zip
 . 
 zip
  does a 
 kind of parallel walk-through of two arrays, producing a third array containing 
 pairs of items taken from the original two:
  
 >> [1,2,3].zip([4,5,6]) 
  
 => [[1, 4], [2, 5], [3, 6]]",NA
B ,">> a.find_all {|item| item > 100 } 
  
 => []",NA
C,"The first 
 find_all
  operation returns an array of all the elements that pass the test 
 in the block: all elements that are greater than 5 
 #1
 . The second operation also",NA
B ,"returns an array, this time an array of all the elements in the original array that are 
 greater than 10. There aren’t any, so an empty array is returned 
 #2
 . (
 select
  is a",NA
C ,"synonym for 
 find_all
 ; the two names can be used interchangeably.)
  
  
  Just as you can select items, so you can reject items: find out which elements of 
 an array do 
 not
  return a true value when yielded to the block. Using the 
 a
  array 
 from the previous example, you can do this:
  
 >> a.reject {|item| item > 5 } 
  
 => [1, 2, 3, 4, 5]
  
 to get the array 
 minus
  any and all elements that are greater than 5. 
  
 Array querying methods
  
 Several methods allow you to gather information about an array from the array. 
 Table 11.1 shows some useful array query methods. 
  
  With the exception of 
 size
 , all the methods in table 11.1 return either 
 true
  or 
 false
 . They differ in this respect from the selecting methods like 
 find
  and 
 find_all
 , which return one or more elements from the array.",NA
B ,"=> [#<Edition:0x2354f78>, ...] 
  
 >> e.class 
  
 => Array",NA
C ,">> e.push(""Adding a string to the Editions collection!"") 
  
 ActiveRecord::AssociationTypeMismatch: Edition expected, got String",NA
D,NA,NA
B ,NA,NA
C,"collection of editions refuses to accept a string as an element: When you try to
  
 push
  a string onto the collection, you get a fatal error 
 #3
 .",NA
D,"This is a good illustration of the fact that a Ruby object (in this case, a collec-
 tion of editions) isn’t constrained to behave exactly the way a default or vanilla 
 instance of its class would behave. For Ruby objects, including objects that house 
 other objects, being created is just the beginning. What matters is how the object 
 gets shaped and used down the road. ActiveRecord collections consider them-
 selves instances of 
 Array
 , but they have special knowledge and behaviors that dif-
 ferentiate them from arrays in general. 
  
  
  This is a great example of the Ruby philosophy bearing fruit with practical 
 results. 
  
 Searching and filtering, ActiveRecord-style
  
 ActiveRecord’s approach to finding elements in collections is also instructive. At a 
 general level, you can perform find operations on the entire existing set of records 
 for any model you’ve defined. Here’s an example:
  
 Work.find(:all) 
  
 Work.find_by_title(""Sonata"")
  
 You’re operating at the class (and class method) level: You’re looking for 
 all
  
 existing objects (corresponding to database records, under the hood) of the given 
 class.
  
  A couple of points are noteworthy here. First, ActiveRecord uses 
 find(:all) 
 rather than 
 find_all
 . (Actually, either will work, but 
 find_all
  is considered old-
 style usage and is likely to disappear from future versions of ActiveRecord.) Sec-
 ond, note the call to the method 
 find_by_title
 . That method is created 
 automatically, because instances of 
 Work
  have 
 title
  attributes. This is another 
 example of the Rails framework giving you a good return on your investment: In 
 return for creating a database field called 
 title
 , you get a method that lets you 
 search specifically on that field. 
  
 find(:all)
  and its close relative 
 find(:first)
  can both be supplied with 
 condi-tions
 , which filter the results for you. These conditions are written as 
 SQL
  
 frag-ments, using the kind of expression you use in an 
 SQL
  query to narrow a 
 SELECT 
 operation. For example, to find all works whose titles start with the word 
 The
  (
 The Rite of Spring
 , 
 The Lark Ascending
 , and so on), you can do this:
  
 Work.find(:all, :conditions => ""title like 'The %'"")",NA
11.3 Hashes,"Like an array, a 
 hash
  is a collection of objects. Unlike an array, a hash is an 
 unordered
  collection: There is no such thing as the first or last or third-from-last 
 item in a hash. Instead, a hash consists of 
 key-valuepairs. 
 Hashes let you perform 
 lookup operations based on keys. 
  
  A typical use of a hash is to store complete strings along with their abbrevia-
 tions. Here’s a hash containing a selection of names and two-letter state abbrevia-
 tions, along with some code that exercises it. (The 
 =>
  operator  connects a key on 
 the left with the value corresponding to it on the right.)
  
 state_hash = { ""Connecticut"" => ""CT"",
  
  ""Delaware""    => ""DE"",
  
  ""New Jersey""  => ""NJ"",
  
  ""Virginia""    => ""VA"" 
 }
  
 print ""Enter the name of a state: "" 
  
 state = gets.chomp 
  
 abbr = state_hash[state] 
  
 puts ""The abbreviation is #{abbr}.""",NA
B ,"=> 0 
  
 >> h",NA
C ,"=> {""new key!""=>0}
  
 When you try to look up the key 
 newkey
 #1
 , it’s not there; it’s added, with the",NA
B ,"value 0, and then that value is printed out by irb. Next, when you ask irb to show 
 you the whole hash 
 #2
 , it contains the automatically added pair.",NA
C,"This technique has lots of uses. It lets you make assumptions about what’s in a 
 hash, even if nothing is there to start with. It also shows you another facet of Ruby’s 
 extensive repertoire of dynamic programming techniques, and the flexibil-ity of 
 hashes. 
  
  
  We’ll turn now to ways you can combine hashes with each other, as we did with 
 strings and arrays. 
  
 11.3.3 Combining hashes with other hashes
  
 The process of combining two hashes into one comes in two flavors: the destruc-
 tive flavor, where the first hash has the key/value pairs from the second hash 
 added to it directly; and the nondestructive flavor, where a new, third hash is cre-
 ated that combines the elements of the original two. 
  
  The destructive operation is performed with the 
 update
  method. Entries in the 
 first hash are overwritten permanently if the second hash has a corresponding key:
  
 h1 = {""Smith"" => ""John"",
  
  
  ""Jones"" => ""Jane"" } 
  
 h2 = {""Smith"" => ""Jim"" } 
  
 h1.update(h2)
  
 puts h1[""Smith""] 
  
  
 Output: Jim",NA
11.4 Collections central: the Enumerable module,"Ruby offers a number of predefined modules that you can mix into your own 
 classes. You’ve already seen the 
 Comparable
  module in action. Here, we’re going to 
 talk about one of the most commonly used Ruby modules: 
 Enumerable
 . We’ve 
 already encountered it indirectly: Both 
 Array
  and 
 Hash
  mix in 
 Enumerable
 , and by 
 doing so, they get methods like 
 select
 , 
 reject
 , 
 find
 , and 
 map
 . Those methods, and 
 others, are instance methods of the 
 Enumerable
  module. 
  
  You, too, can mix 
 Enumerable
  into your own classes:
  
 class C
  
  include Enumerable 
  
 end
  
 By itself, that doesn’t do much. To tap into the benefits of 
 Enumerable
 , you must 
 define an 
 each
  instance method in your class:
  
 class c
  
  include Enumerable
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"def each
  
  
  COLORS.each {|color| yield color }",NA
C,"end 
  
 end
  
 In this version, we ask the 
 COLORS
  array 
 #1
  to iterate via its own 
 each
 #2
 , and then",NA
B ,NA,NA
C ,"we yield each item as it appears in our block. 
  
  The 
 Enumerable
  module is powerful and in common use. Much of the search-
 ing and querying functionality you see in Ruby collection objects comes directly 
 from 
 Enumerable
 , as you can see by asking irb:
  
 >> Enumerable.instance_methods(false).sort",NA
B ,"=> [""all?"", ""any?"", ""collect"", ""detect"", ""each_with_index"", 
 ""entries"", ""find"", ""find_all"", ""grep"", ""include?"", ""inject"", 
 ""map"", ""max"", ""member?"", ""min"", ""partition"", ""reject"", 
  
 ""select"", ""sort"", ""sort_by"", ""to_a"", ""zip""]
  
 (The 
 false
  argument to 
 instance_methods
 #1
  suppresses instance methods",NA
B ,"defined in superclasses and other modules.) This example includes some meth-ods 
 you can explore on your own and some that we’ve discussed. The upshot is that the 
 Enumerable
  module is the home of most of the major built-in facilities Ruby offers 
 for collection traversal, querying, filtering, and sorting.",NA
11.5 Sorting collections,"If you have a class, and you want to be able to sort multiple instances of it, you need 
 to do the following:
  
 ■
  Define a comparison method for the class (
 <=>
 )
  
 ■
  Place the multiple instances in a container, probably an array
  
 It’s important to understand the separateness of these two steps. Why? Because 
 the ability to sort is granted by 
 Enumerable
 , but this does 
 not
  mean your class has 
 to mix in 
 Enumerable
 . Rather, you put your objects into a container object that 
 does 
 mix in 
 Enumerable
 . That container object, as an enumerable, has two sorting 
 methods, 
 sort
  and 
 sort_by
 , which you can use to sort the collection. 
  
  In the vast majority of cases, the container into which you place objects you 
 want sorted will be an array. Sometimes it will be a hash, in which case the result",NA
11.6 Summary,"In this chapter, we’ve looked principally at Ruby’s major container classes, 
 Array 
 and 
 Hash
 . They differ primarily in that arrays are ordered (indexed numerically), 
 whereas hashes are unordered and indexed by arbitrary objects (keys, each associ-
 ated with a value). Arrays, moreover, often operate as a kind of common currency 
 of collections: Results of sorting and filtering operations, even on non-arrays, are 
 usually returned in array form. 
  
  We’ve also examined the powerful 
 Enumerable
  module, which endows arrays, 
 hashes, and strings with a set of methods for searching, querying, and sorting. 
 Enumerable
  is the foundational Ruby tool for collection manipulation. 
  
  The chapter also looked at some special behaviors of ActiveRecord collections, 
 specialized collection objects that use Ruby array behavior as a point of departure 
 but don’t restrict themselves to array functionality. These objects provide an 
 enlightening example of the use of Ruby fundamentals as a starting point—but not 
 an ending point—for domain-specific functionality. 
  
  As we proceed to chapter 12, we’ll be moving in a widening spiral. Chapter 12 is 
 about regular expressions, which relate chiefly to strings but which will allow us to 
 cover some operations that combine string and collection behaviors.",NA
Regular ,NA,NA
expressions and ,NA,NA
regexp-based ,NA,NA
string operations,"In this chapter
  
  
 ■
  Regular expression syntax
  
  
 ■
  Pattern-matching operations
  
  
 ■
  The 
 MatchData
  class
  
  
 ■
  Built-in methods based on pattern matching
  
 312",NA
12.1 What are regular expressions?,"Regular expressions appear in many programming languages, with minor differ-
 ences among the incarnations. They have a weird reputation. Using them is a 
 powerful, concentrated technique; they burn through text-processing problems 
 like acid through a padlock. (Not all such problems, but a large number of them.) 
 They are also, in the view of many people (including people who understand them 
 well), difficult to use, difficult to read, opaque, unmaintainable, and ulti-mately 
 counterproductive. 
  
  You have to judge for yourself. The one thing you should 
 not
  do is shy away 
 from learning at least the basics of how regular expressions work and the Ruby 
 methods that utilize them. Even if you decide you aren’t a “regular expression 
 person,” you need a reading knowledge of them. And you’ll by no means be alone if 
 you end up using them in your own programs more than you anticipated.
  
  A number of Ruby built-in methods take regular expressions as arguments and 
 perform selection or modification on one or more string objects. Regular 
 expressions are used, for example, to 
 scan
  a string for multiple occurrences of a",NA
12.2 Writing regular expressions,"Regular expressions look like strings with a secret “Make hidden characters visi-
 ble” switched turned on—and a “Hide some regular characters” switch turned on, 
 too. You have to learn to read and write regular expressions as a thing unto them-
 selves. They’re not strings. They’re representations of 
 patterns
 . 
  
  A regular expression specifies a pattern. Any given string either matches that 
 pattern or doesn’t match it. The Ruby methods that use regular expressions use 
 them either to determine whether a given string matches a given pattern or to 
 make that determination and also take some action based on the answer. 
  
  Patterns of the kind specified by regular expressions are most easily under-
 stood, initially, in plain language. Here are several examples of patterns expressed 
 this way:",NA
12.3 More on matching and MatchData,"So far, we’ve looked at basic match operations:
  
 regex.match(string) 
  
 string.match(regex)
  
 These are essentially true/false tests: Either there’s a match, or there isn’t. Now 
 we’re going to examine what happens on successful and unsuccessful matches and 
 what a match operation can do for you beyond the yes/no answer.
  
 12.3.1 Capturing submatches with parentheses
  
 One of the most important techniques of regular expression construction is the use 
 of parentheses to specify 
 captures
 . 
  
  The idea is this. When you test for a match between a string—say, a line from a 
 file—and a pattern, it’s usually because you want to do something with the string 
 or, more commonly, with 
 part of the string. 
 The capture notation allows you to iso-
 late and save substrings of the string that match particular subpatterns. 
  
  For example, let’s say we have a string containing information about a person:
  
 Peel,Emma,Mrs.,talented amateur
  
 From this string, we need to harvest the person’s last name and title. We know the 
 fields are comma-separated, and we know what order they come in: last name, first 
 name, title, occupation. 
  
  
  To construct a pattern that matches such a string, we think along the following 
 lines:
  
 First
  some alphabetical characters, 
  
 then
  a comma, 
  
 then
  some alphabetical characters, 
  
 then
  a comma, 
  
 then
  either “Mr.” or “Mrs.”
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"print ""The entire part of the string that matched: "" 
 puts m[0]",NA
C ,"puts ""The three captures: "" 
  
 3.times do |index|",NA
D,"puts ""Capture ##{index + 1}: #{m.captures[index]}"" 
 end 
  
 puts ""Here's another way to get at the first capture:""
  
 print ""Capture #1: "" 
  
 puts m[1]",NA
E,"In this code, we use the 
 string
  method of 
 MatchData
 #1
  to get the entire string on",NA
B,"which the match operation was performed. To get the part of the string that 
 matched our pattern, we address the 
 MatchData
  object with square brackets, with",NA
C ,NA,NA
D ,"times through a code block and print out the submatches (the parenthetical cap-
 tures) in succession. Inside that code block, a method called 
 captures
  fishes out 
 the substrings that matched the parenthesized parts of the pattern. Finally, we take 
 another look at the first capture, this time through a different technique 
 #4
 :",NA
E ,"indexing the 
 MatchData
  object directly with square brackets and positive integers, 
 each integer corresponding to a capture. 
  
  Here’s the output of listing 12.1:
  
 The whole string we started with: My phone number is (123) 555-
 1234. The entire part of the string that matched: (123) 555-1234 
  
 The three captures: 
  
 Capture #1: 123 
  
 Capture #2: 555 
  
 Capture #3: 1234 
  
 Here's another way to get at the first capture: 
  
 Capture #1: 123
  
 This gives you a taste of the kinds of match data you can extract from a 
 MatchData 
 object. You can see that there are two ways of retrieving captures. We’ll focus on 
 those techniques next. 
  
 Two ways of getting the captures
  
 One way to get the parenthetical captures from a 
 MatchData
  object is by directly 
 indexing the object, array-style:
  
 m[0] 
  
  
 Entire match
  
 m[1] 
  
  
 First capture (first set of parentheses from left)
  
 m[2] 
  
  
 Second capture
  
 #etc.
  
 From 1 onward, these indices correspond to the 
 n
  in the 
 $
 n
  global variables that 
 contain the captured substrings. 
  
 MatchData
  objects also have a method called 
 captures
 , which returns all the 
 captured substrings in a single array. Because this is a regular array, the first item 
 in it—essentially, the same as the global variable 
 $1
 —is item 
 zero
 , not item one. In 
 other words, the following equivalencies apply
  
 m[1] == m.captures[0] 
  
 m[2] == m.captures[1]
  
 and so forth. 
  
  By far the most common data extracted from a 
 MatchData
  object consists of the 
 captured substrings. However, the object contains other information, which you 
 can take if you need it.",NA
12.4 Further regular expression techniques ,"This section includes coverage of a number of techniques of regular expression 
 design and usage that will help you both with the writing of your own regular 
 expressions and with your regular expression literacy. If matching 
 /abc/
  makes 
 sense to you now, matching 
 /^x?[yz]{2}.*\z/
  will make sense to you shortly.
  
 12.4.1 Quantifiers and greediness
  
 Regular expression syntax gives you ways to specify not only what you want but 
 also how many: exactly one of a particular character, 5 to 10 repetitions of a sub-
 pattern, and so forth. 
  
  All the quantifiers operate on either a single character or a parenthetical group. 
 When you specify that you want to match (say) three consecutive occur-rences of a 
 particular subpattern, that subpattern can be just one character, or it can be a 
 longer subpattern placed inside parentheses. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
12.5 Common methods that use regular expressions,"The payoff for gaining facility with regular expressions in Ruby is the ability to use 
 the methods that take regular expressions as arguments and do something with 
 them.
  
  To begin with, you can always use a match operation as a test in, say, a 
 find
  or 
 find_all
  operation on a collection. For example, to find all strings longer than 10 
 characters and containing at least 1 digit, from an array of strings, you can do this:
  
 array.find_all {|e| e.size > 10 and /\d/.match(e) }
  
 However, a number of methods, mostly pertaining to strings, are based more 
 directly on the use of regular expressions. We’ll look at several of them in this 
 section.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
12.6 Summary,"This chapter has introduced you to the fundamentals of regular expressions in 
 Ruby, including character classes, parenthetical captures, and anchors. You’ve seen 
 that regular expressions are objects—specifically, objects of the 
 Regexp 
 class—
 and that they respond to messages (such as “match”). We looked at the 
 MatchData
  
 class, instances of which hold information about the results of a match operation. 
 You’ve also learned how to interpolate strings into regular expressions (escaped or 
 unescaped, depending on whether you want the special characters in the string to 
 be treated as special in the regular expression) and how to generate a string 
 representation of a regular expression.
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
Ruby dynamics,"In this chapter
  
  
 ■
  Singleton classes and per-object behavior
  
  
 ■
  The eval family of methods
  
  
 ■
  Callable objects
  
  
 ■
  Runtime method hooks and callbacks
  
 337",NA
13.1 The position and role of singleton classes,"Our first dynamics topic is the topic of the 
 singleton class
 . The best way to under-
 stand what a singleton class is, and why it’s important, is to take a running leap at 
 it, starting with the basics.",NA
B,"class << c
  
  
  include M",NA
C,"end
  
  c.talk",NA
D,"The output from listing 13.1 is as follows:
  
 Hi from original class! 
  
 Hello from module!
  
 The first call to 
 talk
 dd
  executes the 
 talk
  instance method defined in 
 c
 ’s class, 
 C
 .",NA
B ,"Then we mix in the module 
 M
 , which also defines a method called 
 talk
 , into 
 c
 ’s 
 singleton class 
 dd
 . As a result, the next time we call 
 talk
  on 
 c
 dd
 , the 
 talk
  that",NA
C ,NA,NA
D ,"gets executed (the one that 
 c
  sees first) is the one defined in 
 M
 .",NA
13.2 The eval family of methods,"Like many languages, Ruby has a facility for executing code stored in the form of 
 strings at runtime. In fact, Ruby has a cluster of techniques to do this, each of which 
 serves a particular purpose but all of which operate on a similar principle: that of 
 saying in the middle of a program, “Whatever you read from the program file 
 before starting to execute this program, execute 
 this
 right now.”
  
  
  The most straightforward method for evaluating a string as code, and also the 
 most dangerous, is the method 
 eval
 . Other eval-family methods are a little softer, 
 not because they don’t also evaluate strings as code, but because that’s not all they 
 do. 
 instance_eval
  brings about a temporary shift in the value of self, and 
 class_eval
  (also known by the synonym 
 module_eval
 ) takes you on an ad hoc 
 side-trip into the context of a class definition block. These eval-family methods can 
 be called with a code block; they don’t always operate as bluntly as 
 eval
 , which 
 just executes strings.
  
  
  Let’s unpack this description with a closer look at 
 eval
  and the other eval 
 methods.
  
 13.2.1 eval
  
 eval
  executes the string you give it:
  
 >> eval(""2+2"") 
  
 => 4
  
 eval
  is the answer, or at least one answer, to a number of frequently asked ques-
 tions, such as, “How do I write a method and give it a name someone types in?”You 
 can do so like this:
  
 print ""Method name: "" 
  
 m = gets.chomp 
  
 eval(""def #{m}; puts 'Hi!'; end"") 
  
 eval(m)
  
 This code outputs the following:
  
 Hi!
  
 A new method is being written. Let’s say you run the code and type in 
 abc
 . The 
 string you subsequently use 
 eval
  on is
  
 def abc; puts 'Hi!'; end
  
 After you apply 
 eval
  to that string, a method called 
 abc
  exists. The second 
 eval
  
 exe-cutes the string “abc”—which, given the creation of the method in the previous
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
13.3 Callable objects,"A 
 callable object
  is an object to which you can send the message 
 call
 , with the 
 expectation that some code defined in the object (usually in a code block) will be 
 executed. The main callable objects in Ruby are methods (which you’ve already 
 seen), Proc objects, and lambdas. Proc objects are self-contained code sequences 
 that you can create, store, pass around as method arguments, and, when you wish, 
 execute with the 
 call
  method. Lambdas are similar to Proc objects. The differ-
 ences will emerge as we examine each in turn. 
  
 13.3.1 Proc objects
  
 You create a Proc object by instantiating the 
 Proc
  class, including a code block:
  
 pr = Proc.new { puts ""Inside a Proc's block"" }
  
 Note that the code block isn’t executed at this point. Instead, it’s saved as the body 
 of the Proc object. If you want to execute the block (the Proc object), you must call 
 it explicitly:
  
 pr.call
  
 It will report:
  
 Inside a Proc's block
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"puts a
  
  pr.call",NA
C,"end
  
 a = ""'a' to be used in Proc block""",NA
D,"pr = Proc.new { puts a }
  
 pr.call 
  
 call_some_proc(pr)
  
  
  
  
 As in the previous example, there’s an 
 a
  in the method definition 
 dd 
 and an 
 a
  in",NA
B,"the outer (calling) scope 
 dd
 . Inside the method is a call to a Proc object. The code",NA
D,"for that Proc object, we happen to know, consists of 
 putsa
 . Notice that when the
  
 Proc is called 
 from inside the method 
 dd
 , the 
 a
  that is printed out isn’t the 
 a
  defined",NA
C,"in the method; it’s the 
 a
  from the scope 
 where the Proc object was originallycreated
 :",NA
B,NA,NA
B ,"irb prints out is the return value of the execution of 
 pr
 , which returns 
 nil
  because 
 it ends with a 
 puts
  statement!) The second time we call 
 pr
 , all three variables are 
 assigned values; the fourth value, 4, is discarded, because there’s no variable left to 
 assign it to. 
  
  
  You can also sponge up all the arguments into a single argument, with the star 
 (
 *
 ) operator:
  
 pr = Proc.new {|*x| p x } 
  
 pr.call 
  
 pr.call(1) 
  
 pr.call(1,2)
  
 As you’ll see if you run this snippet, 
 x
  is set to an array on each call to the Proc. 
 Each time, the array contains all the arguments you’ve called the Proc with: 
  
 [] 
  
 [1] 
  
 [1, 2] 
  
 If you have multiple arguments and put the sponge last, it’s assigned an array of all 
 the arguments that haven’t been assigned to other variables already. Here’s an 
 example:
  
 pr = Proc.new {|x,*y| p x, y } 
  
 pr.call(1,2,3)
  
 The output
  
 1 
  
 [2, 3]
  
 represents 
 x
 , which was assigned the 1, and 
 y
 , which was assigned the remaining 
 arguments (2,3) as an array. 
  
  
  The bottom line is that Procs are a little less fussy than methods about their 
 argument count—their 
 arity
 . 
  
  
  Ruby offers several variations on the callable method-or-function theme. We’ll 
 look next at another form of anonymous function: the 
 lambda
 .",NA
B ,">> lam.call 
  
 A lambda!
  
 Lambdas, as you can see from irb’s evaluative printout 
 dd
 , aren’t objects of a class",NA
B ,"called 
 Lambda
 ; rather, they’re objects of class 
 Proc
 :
  
 >> lam.class 
  
 => Proc
  
 Like all Proc objects, they are closures; they carry the local context of their cre-
 ation around with them. 
  
  However, there’s a difference between Procs you create with 
 lambda
  and those 
 you created with 
 Proc.new
 . It’s a subtle difference, but one you may need to be 
 aware of at some point. It involves the 
 return
  keyword. 
 return
  inside a lambda 
 returns from the lambda. 
 return
  inside a Proc returns from the surrounding 
 method. 
  
 NOTE
  
 THE PROC/LAMBDA/BLOCK REALM IN FLUX
  
 In recent versions of Ruby—
  
 and in future versions, judging by discussions on various mailing lists and 
 forums—the matter of how Proc objects, code blocks, and lambdas relate 
 to each other has been, and still is, in a certain amount of flux. Don’t be 
 surprised if you see other differences, or even the elimination of differ-
 ences, from one version of Ruby to another. 
  
 Here’s an illustration of the difference:
  
 def return_test
  
  l = lambda { return }
  
  l.call",NA
B,"puts ""Still here!""
  
  p = Proc.new { return }
  
  p.call",NA
C,"puts ""You won't see this message!"" 
 end",NA
D,"return_test
  
 The output of this snippet is “Still here!” You’ll never see the second message 
 dd",NA
D ,"printed out because the call to the Proc object 
 dd
  triggers a return from the",NA
C,NA,NA
B ,"execution of the method continues where it left off. 
  
  Before we leave 
 lambda
 , it’s worth mentioning that 
 lambda
  has a synonym: 
 proc
 . However, because 
 proc
  and 
 Proc.new
  look and sound so similar, but don’t do 
 exactly the same thing, Matz has agreed in principle to phase out 
 proc
 , leaving just 
 Proc.new
  and 
 lambda
  as the techniques for creating anonymous functions. You’ll 
 probably continue to see the 
 proc
  keyword in use for a while; just remem-ber that 
 it’s a synonym for 
 lambda
 .
  
  
  We’re now going to take another look at 
 code blocks
 , in light of what we’ve dis-
 cussed about anonymous functions. 
  
 13.3.3 Code blocks, revisited
  
 A code block (the thing you type after a method call and to which the method 
 yields) exists only in the syntax of Ruby. There is no such thing as a 
 Block
  class or 
 Block object. The block is just some code that floats in front of the method inside 
 curly braces (or 
 do/end
 ), waiting to be used.
  
  However, you can 
 convert
  a code block into a Proc object, inside the method. 
 You do this by capturing the block in a variable. This variable is part of the argu-
 ment list of the method, but it has an ampersand (
 &
 ) at the beginning:
  
 def grab_block(&block)
  
  block.call 
  
 end
  
 grab_block { puts ""This block will end up in the variable 'block'"" }
  
 The 
 &var
  variable must be the last item in the argument list:
  
 def grab_block(x,y,*z,&block)
  
 You can also convert a Proc object or lambda 
 to
  a code block. You do this with the 
 ampersand:
  
 lam = lambda { puts ""This lambda will serve as a code block"" 
 } grab_block &lam
  
 Here’s another example:
  
 grab_block &lambda { puts ""This lambda will serve as a code block"" }
  
 The 
 &
  symbol serves in all of these cases as a signal that conversion back and forth 
 is going on, as between lambda/Proc on the one hand and code blocks on the other.",NA
13.4 Callbacks and hooks,"The use of 
 callbacks
  and 
 hooks
  is a fairly common meta-programming technique
 . 
 These methods are called when a particular event takes place during the run of a 
 Ruby program. An event is something like
  
 ■
  A nonexistent method being called on an object
  
 ■
  A class mixing in a module
  
 ■
  The subclassing of a class
  
 ■
  An instance method being added to a class
  
 ■
  A singleton method being added to an object
  
 ■
  A reference to a nonexistent constant
  
 For every event in that list, you can (if you choose) write a callback method that 
 will be executed when the event happens. These callback methods are per-object 
 or per-class, not global; if you want a method called when the class 
 Ticket
  gets 
 subclassed, you have to write the appropriate method specifically for class 
 Ticket
 .
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"end 
  
 # etc.
  
 Every time you inherit from 
 ActiveRecord::Base
 —essentially, every time you 
 cre-ate a new model definition—the name of your new class (
 child
 , in the code 
 dd
 )",NA
B ,"gets added to an array. That array is stored inside the hash 
 @@subclasses
 . 
  
 NOTE
  
 CLASS VARIABLES
  
 Class variables, like 
 @@subclasses
  in the example 
 from
  
 the 
 base.rb
  source file, are scoped in such a way that they are visible 
 when 
 self
  is the class to which they belong, a descendant (to any level) of 
 that class, or an instance of the class or its descendants. Despite their 
 name, they’re not really class scoped; they’re more like hierarchy scoped. 
 Matz",NA
13.5 Overriding and adding to core functionality,"One of Ruby’s most powerful features is the ability to change and augment the 
 language’s core functionality. You can open up core classes just as easily as you can 
 open up your own classes. And you can add new methods and override old ones to 
 your heart’s content. Want arrays to know how to shuffle themselves? Here’s how 
 to teach them:
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"old_match(string) || []
  
  end 
  
 end
  
 This code first sets up an 
 alias
  for 
 match
 , courtesy of the 
 alias
  keyword 
 dd
 . The",NA
B ,"alias means you can now call the method using either of two names. Then, the code 
 redefines 
 match
 . The new 
 match
  hooks into the original version of 
 match 
 (through 
 the alias) and then returns 
 either
  the result of calling the original ver-sion, 
 or
  (if 
 that call returns 
 nil
 ) an empty array. 
  
  You can now do this:
  
 /abc/.match(""X"")[1]
  
 Even though the match fails, the program won’t blow up, because the failed match 
 now returns an empty array rather than 
 nil
 . The worst you can do with the new 
 match
  is try to index an empty array, which is legal. (The value you’ll get is 
 nil
 , but 
 at least you’re not trying to 
 index
 nil
 .)",NA
13.6 Summary,"This chapter has given you a guided tour of some of the more meta aspects of 
 Ruby: techniques for manipulating not only your program’s data but also the pro-
 gramming environment. We’ve looked at singleton classes, Ruby’s mechanism for 
 making per-object behaviors a reality. We’ve discussed callable objects (Procs, 
 blocks, and their relatives); runtime evaluation of strings with 
 eval
 , as well as the 
 operations of the 
 *_eval
  family; and hooks you can use to make things happen at 
 predefined junctures (subclassing, calls to nonexistent methods, and so on). 
  
  You’ve also seen some of the power, as well as the risks, of the ability Ruby 
 gives you to pry open not only your own classes but also Ruby’s core classes. This 
 is something you should do sparingly, if at all—and it’s also something you should 
 be aware of other people doing. 
  
  We’ve reached the end of the parts of the book containing concentrated Ruby-
 language tutorial material. We’re now in a good position to return to the 
 R4RM
 usic 
 application and take it to the next level.",NA
Part 4,NA,NA
Rails through ,NA,NA
"Ruby, Ruby ",NA,NA
through Rails,NA,NA
T,"he purpose of this part of the book is to bring to full fruition the book’s over-
 all plan: helping you get more out of Rails by knowing more about Ruby. The goals 
 here are the goals of the book itself:
  
 ■
  Learning the Ruby foundations of specific Rails techniques
  
 ■
  Using your Ruby knowledge to add programming value and power to your 
  
 Rails applications by writing your own custom code
  
 ■
  Gaining skill and experience in examining the Rails source code 
  
 Over the course of the four chapters that make up part 4, we’ll revisit and revise 
 R4RM
 usic, the music store application from chapter 2. Along the way, we’ll use 
 selected features and components of the application as windows onto the inner 
 workings of both Ruby and Rails—and, of course, Ruby and Rails together. The 
 new version of 
 R4RM
 usic will include a Customer model and rudimentary but 
 operational shopping-cart capabilities. We’ll also implement more fine-tuned 
 facilities for handling musical works and published editions, along with the com-
 posers, instruments, and publishers associated with them. 
  
 The sequence of the first three chapters is guided by the development of the 
 phases of the application revision process. Domain model and database (re)design 
 come first, in chapter 14; then, in chapter 15, we’ll add custom-written Ruby code 
 to the model files, by way of enhancing and augmenting model functionality. Chap-
 ter 16 covers the updates and changes to the controller and view files, bringing to a 
 close the revision of the application.",NA
(Re)modeling the ,NA,NA
R4RMusic ,NA,NA
application ,NA,NA
universe,"In this chapter
  
  
 ■
  Expansion and enhancement of the music 
  
  
 store domain
  
  
 ■
  Inherited and automatic model capabilities
  
  
 ■
  Semi-automated capabilities via ActiveRecord 
  
  
 associations
  
 371",NA
14.1 Tracking the capabilities of an ActiveRecord model instance,"Rails entity models are Ruby classes. When you do things with Rails data—create a 
 composer, give a work a title—you’re dealing with 
 instances
  of those model classes",NA
14.2 Advancing the domain model,"Advancing the music store domain model will involve adding new entities and fine-
 tuning some old ones. 
  
  We’ll start with domain and database (re)design. From there, we’ll proceed to 
 look at all the model files: those we have to create and those we need to change. As 
 was the case in the earlier iteration of the music store, the 
 SQL
  will be Rails-
 friendly and will anticipate certain aspects of the model files. 
  
  As we go through these domain model revisions, the discussion will include 
 important techniques and points about how things work and what’s involved in 
 choosing a design, from the combined Ruby/Rails perspective. Understanding 
 these subtopics will give you a firm footing when we proceed to the matter of pro-
 grammatically altering entity models.
  
  We’re going to make various changes to the domain model. Some will pro-mote 
 properties
  to 
 entities
 —essentially, turning certain fields into tables. Some will be 
 new entities. Throughout, they will involve the creation of new associations. 
  
 14.2.1 Abstracting and adding models (publisher and edition)
  
 In the first iteration of the music store application, publishers were attached to edi-
 tions as simple text fields; the 
 editions
  table had a field called 
 publisher
 , into which 
 the name went. In this second iteration, we’ll put publishers in their own model.
  
  This approach will allow more detail to be stored: not only the name of the 
 publisher, but also the country. It will also make it easier to associate publishers 
 directly or indirectly with other entities, should that become necessary. It’s also 
 less likely, when the publishers are stored as separate records rather than text 
 strings, that a given publisher’s name will inadvertently be spelled two different 
 ways, creating the appearance of two publishers where there is only one.",NA
14.3 Summary,"We’ve worked on two fronts in this chapter: looking at three of the four ways in 
 which ActiveRecord model classes and objects come by their methods and capa-
 bilities, and revisiting and expanding our music store domain. All of this has been",NA
Programmatically ,NA,NA
enhancing ,NA,NA
ActiveRecord ,NA,NA
models,"In this chapter
  
  
 ■
  Soft and hard programmatic enhancements
  
  
 ■
  Ruby vs. SQL
  
  
 ■
  Instance-method enhancement of R4RMusic 
  
  
 models
  
  
 ■
  Programmatic enhancement at the class-
  
  
 method level
  
 392",NA
15.1 Soft vs. hard model enhancement,"In chapter 14, we identified four sources from which an ActiveRecord model can 
 gain capabilities: inheritance, automatically created methods, semi-automatically 
 created methods, and open-ended programming. This chapter is about the fourth 
 of these sources: methods you yourself write, for your own reasons and purposes, 
 in your model files: 
 programmatic enhancement
  of models.
  
  We’re going to divide programmatic enhancement into two categories. The 
 division we’ll make is descriptive, not official. Its purpose is to help you organize
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,def whole_name,NA
C,"first_name + "" "" +
  
   
  (if middle_name then middle_name + "" "" else """" end) +
   
  last_name
  
  end 
  
 end
  
  
  
 The first of the two new methods, 
 editions
 , is the passive or 
 soft
  one. It returns an 
 array of all the editions of all the works by this composer. These editions already 
 exist; all 
 editions
  does is gather them together. To do so, it walks one by one",NA
B,"editions. The entire mapping operation results in an array of arrays: one array for 
 each work, one entry for each edition. 
  
  We then flatten this array of arrays so it’s just one array of edition objects. 
 Finally, we 
 uniq
  it; doing so removes duplicate editions if, say, two works by the 
 same composer appear in one publication (which happens frequently). 
  
  From now on, our composer objects will respond to the “editions” message by 
 handing back an array containing all editions with works by the composer. Com-
 posers now can tell us what their works are (thanks to the 
 has_many
  association 
 with the 
 Work
  model) and can also tell us what editions contain one or more of 
 their works (thanks to the method we just wrote). 
  
  From the perspective of any code that might use this new method, there won’t 
 be any noticeable difference in syntax (given a composer object 
 comp
 ) between this
  
 eds = c.editions
  
 and this:
  
 works = c.works
  
 When you add an instance method to an ActiveRecord model class, that instance 
 method is just as real and has just as much programming status as the methods 
 that the objects of that class derive automatically or semi-automatically from 
 ActiveRecord. 
  
  The second of the two new methods in this revision of the 
 Composer
  class is 
 whole_name
 dd
 —and you’ll recognize it as closely related to an example from",NA
C ,"chapter 2, where we took a sneak peek at writing methods for model classes. The 
 whole_name
  method uses information available from the composer object’s exist-
 ing methods, methods the object has been given based on field names in the 
 com-
 posers
  database table. 
  
 whole_name
  creates a new object out of this information: a string that contains 
 existing data but that doesn’t directly correspond to any single property of the 
 object or to any single or collective existing ActiveRecord object. That’s what 
 makes 
 whole_name
  an example of hard programmatic enhancement. 
  
 Soft vs. hard model enhancement: the bottom line
  
 The bottom line is that the term 
 soft enhancement
  describes cases where you’re 
 giv-ing ActiveRecord an assist, so to speak. Our 
 editions
  method doesn’t do much 
 with
  the data it finds; its job is to extend the reach of the composer’s access to
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
15.2 Soft programmatic extension of models,"In this section, we’ll write methods in several of the 
 R4RM
 usic model files that 
 extend what the models can do by reaching along the path already established by 
 the model’s existing properties. For a change of pace, this section is orga-nized as a 
 series of questions; the answers involve Ruby code that extends the model’s 
 capabilities.
  
  The adoption of the “
 Q&A
 ” format serves several purposes. For one thing, it’s 
 close to what happens during a typical development cycle: You realize that you 
 need access to some information, and you write code that gives you that access. It 
 also points the way toward doing more. The examples here aren’t magical or 
 sacred. They represent a good-sized sampling of things you might want to do with",NA
15.3 Hard programmatic enhancement ,NA,NA
of model functionality,"In this section, we’re going to pull out the Ruby stops and show how you can add 
 new functionality to your models that may not have any direct relation to the 
 models’ basic properties and capabilities. Basically, you can define any method for 
 your models to respond to. The idea isn’t to create chaos, but to come up with 
 things you might want to know. 
  
  The examples here are clustered by type of example rather than in a question-
 and-answer format. This reflects the fact that hard enhancements tend to have a 
 purpose other than straightforward querying of an object for information; they 
 entail the creation of a new object or data structure rather than a culling of exist-
 ing objects. 
  
  
  In the sections that follow, we’ll develop hard programmatic enhancements of 
 several of the 
 R4RM
 usic models. The enhancements fall into three categories:
  
 ■
  Prettification of string properties
  
 ■
  Calculating a work’s period 
  
 ■
  Providing the customer with more functionality
  
 Your Ruby skills will get a workout here, and you’ll learn a few new techniques 
 along the way. 
  
 15.3.1 Prettification of string properties
  
 A common use for hard model enhancements is the 
 prettification
  of string proper-
 ties—the generation of a new string in which existing string information is 
 embedded and which looks better, for presentation, than the raw string data avail-
 able through the object would look. 
  
  We’ve already seen one example of prettification of strings: the 
 Com-
 poser#whole_name
  method defined for the purpose of easily displaying all the 
 components of a composer’s name together. This kind of thing can come in handy 
 frequently and can involve greater complexity and planning than just stringing 
 strings together. We’ll look at some examples here. 
  
 Formatting the names of the work’s instruments
  
 The 
 Work
  model is a good candidate for some pretty-formatting operations. It has a 
 title, an opus number, and a list of instruments, all of which are stored in raw form 
 and are in need of massaging on the way to public viewing.",NA
B ,"dddd
 ""op. #{opus}""",NA
C ,"dd
 else 
  
 dddd
 opus",NA
D ,"dd
 end 
  
 end
  
 Based on the test for a digit at the beginning of the opus 
 dd
 , we get back either",NA
B ,"the number with “op. ” in front of it 
 dd
  or the whole original opus string 
 dd
 .",NA
C ,NA,NA
D,"Now that we have nice-looking instrument 
 and opus strings available, we can put together a full-featured title string.
  
 The work’s prettified title
  
 Creating a nice title is a matter of putting the nice components in place, with a 
 couple of connector words. The format is represented by this example:
  
 Sonata in F Major, op. 99, for cello and piano",NA
B ,"dddd
 yrange.include?(year) && countries.include?(country) 
  
  
  
 dd
 end 
  
  
  
 dd
 PERIODS[pkey] || century",NA
C ,"end 
  
 This method uses two Boolean operators: the Boolean 
 or
  operator (
 ||
 ), which you 
 saw in action in the 
 nice_title
  method for editions, and the 
 and
  operator (
 &&
 ).",NA
C ,"either a value from the 
 PERIODS
  hash or the work’s century. If 
 PERIODS[pkey] 
 returns something true, which it will if 
 pkey
  is an existing key of 
 PERIODS
  
 (remember that strings like “Classical” are true in the Boolean sense), then the 
 method returns that value. If not (in other words, if 
 pkey
  isn’t an existing key, and 
 specifically if 
 pkey 
 is 
 nil
 ), the method returns the work’s century. 
  
  
  
 pkey
  is calculated by iterating through the keys of the 
 PERIODS
  hash 
 dd
 . Each 
 key,",NA
B ,"as you’ll recall, is an array consisting of a range of years (assigned to 
 yrange
 ) and 
 an array of countries (assigned to 
 countries
 ). If there’s a hash key whose year-
 range includes 
 year
 and 
 whose country-array includes 
 country
 , that hash key is 
 assigned to 
 pkey
 . The 
 and
  test is performed with the 
 &&
  operator. If no key is found 
 that passes the double test, 
 pkey
  is 
 nil
  and, subsequently, 
 PERIODS[pkey]
  is also 
 nil
 . If a key passes the tests, you get the corresponding value when you ask for it 
 dd
 .",NA
B,"We now 
 have a programmatic way to get a work to report its artistic period. We also have a 
 good example of a case where doing something programmatically has distinct 
 advantages over just putting data in a database. Yes, we could just cre-ate a field in 
 the 
 works
  table that contained the period. But by calculating the period 
 dynamically, we’ve made it a lot easier to make additions and changes. An entire 
 chart of periods is available at a glance and can be modified and aug-mented as 
 needed.
  
  On the other side of the convenience equation, if you were migrating the data-
 base to another application, you’d have to reconstruct a way to get at the period 
 information, since it wouldn’t be in the database—or you’d have to redesign the 
 database and write a script that determined each work’s period and put it in a 
 database field after all. And in making real-world decisions about data storage ver-
 sus programmatic calculation of values, you do have to weigh considerations of 
 that kind. 
  
  
  We’ll settle on doing periods programmatically, on the theory that the music 
 store application will be stable and fairly permanent. 
  
  
  Now we’ll return to a strong candidate for a considerable amount of hard model 
 enhancement: the 
 Customer
 .",NA
15.4 Extending model functionality with class methods,"Class methods, in general, are an appropriate choice when you want to calculate 
 something that pertains generally to a class’s domain, its field of expertise. That’s 
 true in the case of ActiveRecord model classes too. Although instance methods 
 make sense when what you want to achieve is at the level of a particular instance 
 (like determining a work’s century), class methods make sense when you want to 
 do something at a more abstract level—or, as is often the case, something that 
 involves searching and manipulation of 
 all
  the existing records for a given class. 
  
 15.4.1 Soft and hard class methods
  
 Class methods written for model classes, like instance methods, can be categorized 
 as 
 soft
  or 
 hard
 , depending on whether they search and retrieve existing data in a 
 relatively passive, low-impact way, or construct entirely new data structures out of 
 the data they find. Don’t forget that a number of the class methods your model 
 classes have by default are even more active than this—methods like 
 delete_all
 , 
 which clears the database table corresponding to the class of all its entries. You 
 probably won’t need to write class methods that do database housekeeping at that 
 level (ActiveRecord supplies a pretty full toolkit for those operations). Still, some of 
 the class methods you write for your model classes will be more active than others.
  
 Determining all editions for a list of works
  
 This is a specialized method, but it will come in handy at least once when we get to 
 view and controller enhancement in chapter 16. It’s a class method on the 
 Edition 
 class, and therefore it belongs in 
 edition.rb
  in the 
 app/models
  subdirectory:
  
 def Edition.of_works(works) 
  
 dd
 works.map {|work| work.editions }.flatten.uniq 
 end
  
 This method starts with a list of works—say, all the works by Bach, or all works 
 writ-ten in 1830, or whatever you want to sent it—and returns a list of editions of 
 all those works. It’s a useful method for crossing over from a works list to a corre-
 sponding editions list. 
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
15.5 Summary,"This chapter has taken you on a guided tour of a selection of programmatic 
 enhancements to the ActiveRecord model files from the music store application. 
 You’ve seen examples of both soft and hard enhancements—enhancements that 
 return instances or collections based on existing data, and enhancements that 
 manipulate data more actively to produce new representations in new data struc-
 tures. We’ve examined this at both the instance-method and class-method levels.
  
  Along the way, we’ve also noted some of the factors, pro and con, that may 
 influence you when you’re deciding whether to write a new method for a model or 
 carry out a database redesign that creates a new table or field. In the case of 
 determining the period of a work, for example, putting a tag like “Classical” in a 
 database field is possible and probably faster than calculating a work’s period on 
 the fly—but this approach is also less flexible and scalable, in the event that you 
 want to make changes, than maintaining a single hash of period information. These 
 and other factors are always present, and you need to make the best deci-sion you 
 can in each case. 
  
  This brings us to the end of our work on the domain-database-model side of the 
 music store universe. Next, we’ll turn to the realm of ActionPack: the view tem-
 plates, and the controllers that feed data to them. This is literally where the action 
 is and where the work we’ve put into enhancing the models bears visible fruit.",NA
Enhancing ,NA,NA
the controllers and ,NA,NA
views,"In this chapter
  
  
 ■
  Built-in and custom helper methods
  
  
 ■
  Using partial view templates
  
  
 ■
  Login and authentication
  
  
 ■
  Maintaining session state
  
  
 ■
  Dynamic determination of method branching
  
 422",NA
16.1 Defining helper methods for view templates,"The view and controller phases of the Model/View/Controller framework work 
 closely together. The basic contract between the controllers and the views is that 
 the controllers gather, sort, sift, and prepare data, which they store in instance 
 variables; and the views use those instance variables in 
 ER
 b templates. Sometimes, 
 however, you’ll need to manipulate data or make calculations in ways that can’t be 
 done in advance by the controller, but have to be done in the template. For exam-
 ple—really a whole category of examples—it’s convenient to have access in the 
 templates to shortcut methods that write out repetitive sequences of 
 HTML
 . 
  
  
  ActionPack, the parent package of both ActionController and ActionView, 
 provides two forms of help in the realm of shortcut methods available for use in 
 your templates. First, you can use any of a large number of predefined helper 
 methods; we’ve already seen an example of such a method: 
 link_to
 . Like many of 
 the other built-in ActionPack helper methods, 
 link_to
  gives you a programmatic 
 (method call–based) alternative to writing out 
 HTML
  markup manually. (We’re not 
 going to discuss the built-in helper methods extensively here; but you’ll come 
 across not only 
 link_to
  but 
 form_tag
 , 
 text_field
 , and others in 
 R4RM
 usic and in 
 the majority of Rails applications you write or see.) 
  
  
  The second way in which ActionPack provides you with helper-method facili-
 ties, and the one we’ll focus on in this section, is through the 
 helper file
  facility, 
 which gives you a structured way to define methods of your own that extend the",NA
16.2 Coding and deploying partial view templates,"To get Rails to display a view called 
 composer/show.rhtml
 , we put a file of that 
 name beneath the 
 app/views
  directory, and we request 
 composer/show
  as the 
 action in our 
 URL
 . The file contains template code, which is filled in based on 
 variables handed over from the controller (
 @composer
 , for example). 
  
  Meanwhile, inside 
 composer/show.rhtml
 , we can trigger the automatic inclu-
 sion of one or more 
 partial
  views. We summon up the partial view at a particular 
 place in the main or master template with a call to 
 render
 . 
  
 16.2.1 Anatomy of a master template
  
 The best way to see how partial templates fit into the overall template landscape is 
 by looking at an entire template file, such as the one shown in listing 16.1.
  
 Listing 16.1
  
 The 
 composer/show.rhtml
  template file
  
  <% @page_title = ""Editions of works by #{@composer.whole_name}"" %>
  
  <h2 class=""info""><%= @page_title %></h2>
  
  <p>Click on any edition to see details.</p>
  
  <%= render :partial => ""editions"" %>
  
  
  
 The 
 render
  method examines the name of the partial (
 editions
 , in this case), adds 
 an underscore at the beginning and the 
 .rhtml
  suffix at the end, and then looks for 
 the file of the resulting name: 
 _editions.rhtml
 . 
  
  
  The 
 _editions.rhtml
  partial template file is also in the 
 composer
  view direc-
 tory. It’s shown in listing 16.2. 
  
 Listing 16.2
  
 The 
 composer/_editions.rhtml
  partial template
  
  <ul> 
  
 ddd
 <% @composer.editions.map do |edition| %>
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
16.3 Updating the main controller,"This time around, we’ll start with the finished product and then account for how it 
 got that way. Listing 16.8 shows the entire 
 main_controller.rb
  file for this ver-
 sion of the application. 
  
 Listing 16.8
  
 The file 
 main_controller.rb
  
 class MainController < ApplicationController
  
  helper :work, :composer, :instrument
  
  def welcome
  
  
  @composers = Composer.find(:all).sort_by do |composer|
  
   
  [composer.last_name, composer.first_name, composer.middle_name]
  
  end
  
  
  @periods = Work.all_periods
  
  
  @instruments = Instrument.find(:all, :order => ""name ASC"" ) end
  
  def show_period
  
   
  @period = params[:id]
  
   
  works = Work.find(:all).select do |work| 
  
 dddddd
 (work.period == @period) || (work.century == 
 @period)
  
  
  end
  
   
  @editions = Edition.of_works(works)
  
  end 
  
 end
  
  
  
 There are only two methods (actions) defined in this file; but they’re both worth a 
 look.
  
 16.3.1 The new face of the welcome action
  
 In case you don’t remember (and don’t feel like looking it up), the main control-ler 
 file in the previous version of 
 R4RM
 usic looked like this:
  
 class MainController < ApplicationController
  
  def welcome
  
  
  @composers = Composer.find(:all).sort_by {|c|
  
  
  [c.last_name, c.first_name]
  
  
  }
  
  end 
  
 end
  
 The new 
 welcome
  action is bit more involved—but not much more than a bit. 
 Where the old 
 welcome
  stored data in one instance variable (a sorted list of 
 composers",NA
16.4 Incorporating customer signup and login,"The first thing we want customers to be able to do is sign up for an account; the 
 second thing we want them to be able to do is log in to the site. In the process of 
 making these actions possible, we’ll consider some issues of authorization and 
 security as they pertain to writing controller actions. 
  
  We’ll put both the login form and the signup form on the top-level welcome 
 screen. The controller action for signing up is 
 customer/signup
  (the 
 signup 
 method in the file 
 customer_controller.rb
 ). The login action is 
 customer/login
 .
  
 Any new views we create will be placed in the 
 app/views/customer
  directory. 
  
  Even though it’s backward, in terms of a customer’s relation to the site, let’s 
 start with the login process. Let’s assume that someone has successfully signed up 
 (or been manually created as a user), and that we need to make provisions for that 
 person to log in.
  
 16.4.1 The login and signup partial templates
  
 The main welcome view template, shown in listing 16.9, performs a rendering of 
 partials for login and signup forms. Those partials live in the 
 customer
  subdirec-
 tory of 
 app/views
 . The signup partial, 
 _signup.rhtml
 , contains the form shown in 
 listing 16.9.",NA
B,def get_customer,NA
C,"if session['customer']
  
  @c = Customer.find(session['customer'])
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B,"while 
 dd
 , sets the instance variable 
 @c
  to the 
 Customer
  object drawn from the data-",NA
C,"base record of the customer who’s logged in, thanks to the fact that the 
 login
  
 action saved that record’s 
 ID
  number to the 
 session
  hash. If there’s nothing in 
 ses-sion['customer']
 , then the method is 
 not
  assigned to 
 @c
 , and 
 @c
  defaults to 
 nil
 .
  
  For the lifespan of the current action, throughout the code that defines the 
 action, and anywhere in the templates, we can test 
 @c
 —and if it has a value, then 
 someone is logged in.
  
  You can now understand why the welcome template has this in it:
  
 <% if @c %>
  
  <%= render :partial => ""favorites"" %> 
  
 <% else %>
  
  <h2 class=""info"">Log in or create an account</h2> 
 # 
  
  # display of login and signup forms handled here # 
  
 <% end %>
  
 If a customer is logged in, then the site acts accordingly by showing that person’s 
 favorites. If not—the site also acts accordingly, by displaying login and signup 
 forms. It all depends on whether 
 @c
  is a customer object or 
 nil
 , as determined by 
 the 
 get_customer
  filter method. 
  
 Levels of authentication concern
  
 We now have a setup where we can always answer the question, “Who, if anyone, 
 is logged in?” That’s useful because we’re now free to do things like put customer-
 specific greetings (“Hi, David!”) on the screen—or lists of the cus-tomer’s favorite 
 composers.
  
  But those kinds of items are cosmetic. Even visitors who aren’t logged in are 
 allowed to look at the welcome screen and the catalogues of composers and works. 
 The real authentication issues involve placing orders. We don’t want casual 
 visitors adding to shopping carts; we only want that ability for those who are 
 logged in. (This isn’t a universal rule at all online shopping sites, but it’s the way 
 we’ll do it here.) We also don’t want one person prying into the shopping cart of 
 another.",NA
B ,"dd
 if Customer.find_by_nick(applicant['nick'])",NA
C ,"dddd
 report_error(""Nick already in use. Please choose another."") 
 dd
 elsif Customer.find_by_email(applicant['email']) 
  
 dddd
 report_error(""Account already exists for that email 
 address"") 
 dd
 end 
  
 end
  
 The assignment to 
 applicant
 dd
  is a hash based on the naming scheme of the",NA
B ,"input fields in the form. (We’ll see the form close up shortly.) To find out whether a 
 customer already exists with either the nick or the email address submitted on the 
 form, we use ActiveRecord’s convenient automatic 
 find_by_
 fieldname
 dd",NA
C,NA,NA
B,"<td><%= link_to ""View cart"",
  
    
  :controller => ""customer"",
  
    
  :action     => ""view_cart"" %></td>
  
  <td><%= link_to ""Log out"",
  
    
  :controller => ""customer"",
  
    
  :action     => ""logout"" %></td>
  
  
 <% end %>
  
  </tr> 
  
 </table>
  
 Notice the 
 <%if@c%>
  conditional clause 
 dd
 . The conditional ensures that the",NA
B ,"View Cart and Log Out options are displayed only if 
 @c
  is true, which is the case 
 only if someone is already logged in. 
  
  We now have signup, login, and logout in place. But as the innocent 
 phrase“View cart” reminds us, we’ve still haven’t implemented the business end of 
 the customer controller: We must enable customers to place and complete orders. 
 We’ll do that next.",NA
16.5 Processing customer orders,"Logging in is a good first step; but while a customer is logged in, we need to give 
 that customer the ability to
  
 ■
  Add an item to his or her shopping cart
  
 ■
  View the shopping cart
  
 ■
  Complete the order(s)
  
 This can be accomplished easily with a bit of judicious controller and template 
 programming. 
  
  What’s notable about the shopping cart, as we’re treating it here, is that it isn’t a 
 real object. There’s no 
 ShoppingCart
  class, no 
 shopping_cart_controller.rb 
 file, and so forth. 
 The shopping cart is essentially a view.
  
  The shopping cart view is the focal point of the ordering process. Every aspect 
 of shopping leads up to the view (browsing and choosing items to buy) or tails 
 away from it (completing orders). Because it sits in the middle of the process, logi-
 cally speaking, we’ll start by looking at the view and then flesh out the “how we get 
 there” and “where we go from there” phases.
  
 16.5.1 The view_cart action and template
  
 Let’s start by adding an action—an instance method—to the customer controller 
 file, 
 apps/controllers/customer_controller.rb
 :
  
 def view_cart 
  
 end
  
 (You don’t 
 have
  to write empty actions in controller files; if there’s a view, it will be 
 rendered when the same-named action is called. But the empty action is useful as a 
 visual marker.) 
  
  
  As to the view: Let’s start with a master template, 
 view_cart.rhtml
 , which will 
 mainly serve the purpose of calling up a partial containing the real business of the 
 cart. Here’s 
 view_cart.rhtml
 :
  
 <% @page_title = ""Shopping cart for #{@c.nick}"" %>
  
 <%= render :partial => ""cart"" %>
  
 (Remember that the instance variable 
 @c
  has been set to the logged-in customer.)
  
  The bulk of the shopping-cart view goes inside the partial template 
 _cart.rhtml
 , which is shown in listing 16.12.",NA
B,"<% count = @c.copies_of(edition) %>
  
  <tr>
  
  
  <td><%= link_to_edition_title(edition) %></td>",NA
C,"<td>
  
  
  <% edition.composers.each do |composer| %>",NA
D,"<%= link_to_composer(composer) %>
  
  
  <% end %></td>
  
  
  <td><%= edition.publisher.name %></td>",NA
E,"<td class=""price""><%= two_dec(edition.price) %>",NA
F,"<td class=""count""><%= count %></td>",NA
G,"<td class=""price""><%= two_dec(edition.price * count) %></td> 
 </tr> 
  
 <% end %>
  
  <tr><td colspan=""5"">TOTAL</td>
  
  <td class=""price""><%= two_dec(@c.balance) %></td>  
 </tr>",NA
H,"</table> 
  
 <p><%= link_to(""Complete purchases"",",NA
I,":controller => ""customer"",
  
  :action     => ""check_out"") %></p>
  
  
  
  
 This partial is relatively long, but its logic is straightforward. It consists of one 
 table
  
 and one link. The link, at the end, is to the 
 check_out
  action 
 dd
 . The table consists",NA
I,"of headers plus one row for each edition that the customer has on order 
 dd
 . The",NA
B,"table contains various pieces of information: title 
 dd
 , composer 
 dd
 , publisher 
 dd
 ,",NA
C ,NA,NA
D ,NA,NA
E,"price 
 dd
 , and copy count 
 dd
 . The subtotal for each edition is shown, as is the cus-",NA
F ,NA,NA
G,"tomer’s total balance 
 dd
 .",NA
H,"Thus the cart. Now, as promised, we’ll examine the “how we got there” side of 
 things: the process by which the customer selects an edition for inclusion in the 
 cart.",NA
B,":controller => 
 ""customer"",
  
    
  :action     => ""add_to_cart"",
  
    
  :id         => @edition.id %></li> <% end %> 
  
 </ul> 
  
 <h3>Contents:</h3> 
 <ul>",NA
C,"<% @edition.works.each do |work| %>
  
  <li><%= link_to_work(work) %>
  
   
  (<%= link_to_composer(work.composer) %>) 
 </li> 
  
 <% end %> 
  
 </ul>
  
  
  
  
 Note that the 
 _details.rhtml
  partial includes a section with the heading 
 Con-
 tents
 dd
 . Because editions in the new version of the application can contain mul-",NA
C ,"tiple works, it behooves us to display them all on the edition’s show view. 
  
  Also, there’s now a link 
 dd
 —included only if 
 @c
  is set—that allows the logged-",NA
B,"in customer to add the edition to his or her cart. That implies the existence of an 
 add_to_cart
  method, which we haven’t written yet but now will.",NA
16.6 Personalizing the page via dynamic code,"This is the last section where we’ll add a new feature to the music store applica-
 tion. It will take us back to the model-coding phase, but we’ll tie it into the con-
 troller/view phase through the creation of more partials.
  
  The goal is to personalize the welcome page by displaying a list of favorite com-
 posers and instruments based on the logged-in user’s ordering history. Some-
 where on the page, we’ll put something that says, “Your favorites!” and a list of 
 favorite (most often ordered) composers and instruments.
  
  This section is a bit of a cheat: It asks you to add a method to the customer 
 model file, 
 customer.rb
 , as well as writing template code that uses that method. 
 The writing of that method properly belongs in chapter 15. But as this is the last of 
 our enhancements to the application, it seems fitting to pull its various compo-
 nents together in one place.
  
 16.6.1 From rankings to favorites
  
 We’ve already written methods that rank composers and instruments according to 
 how many works by/for each the customer has ordered. Rankings come back as",NA
 B,"method_name = ""#{thing}_rankings"" 
  
  rankings = self.send(method_name) 
  
  # etc.",NA
 c ,"end
  
 The strategy is to construct the correct rankings-method name 
 dd
  (which may be",NA
B ,"composer_rankings
  or 
 instrument_rankings
  or something else if we ever add 
 another rankings method) and then call that method by sending the method name 
 to 
 self
 dd
 . The 
 favorites
  method determines the name of the correct",NA
C ,"rankings method 
 dynamically
 , based on the argument that was passed in. As long 
 as you name such methods with the convention 
 rankings_
 thing
 , and as long as 
 every rankings method returns a hash of 
 ID
 s and their rankings, this 
 favorites 
 method (once it’s completely written) will work for any and all of them.",NA
B,"method_name = ""#{thing}_rankings""
  
  rankings = self.send(method_name)
  
  return rankings[0,count].compact",NA
C ,"end
  
 The value plucked out of the options hash 
 dd
  serves to limit the number of ele-",NA
B ,"ments returned from the whole rankings array 
 dd
 . If the requested number is",NA
C ,"greater than the size of the rankings array, the result is padded with 
 nil
 s; but the 
 compact
  operation removes them. 
  
  We now have a generalized way to get a customer’s favorite things (composers, 
 instruments). Let’s go back and trace how the favorites mechanism figures in the 
 application.
  
 16.6.2 The favorites feature in action
  
 In principle, the favorites list works the same way as the other lists on the welcome 
 page (composer, instruments, and periods). The idea is to pepper the welcome 
 screen with as many browsing opportunities as possible; showing a visitor’s favor-
 ites is just another way to do this. The details of how the favorites list works are a 
 little different from the other three (including the fact that it isn’t shown if no one 
 is logged in). But it’s largely a variation on the same theme. 
  
  
  As you saw back in listing 16.7, the template for the main welcome view 
 includes a reference to a favorites partial:
  
 <% if @c %>
  
  <%= render :partial => ""favorites"" %> 
  
 <% else %>
  
  # etc.
  
 The favorites partial, in the file 
 app/views/main/_favorites.rhtml
 , is where the 
 call to the 
 favorites
  method goes. That partial is shown in listing 16.14.",NA
16.7 Summary,"This chapter, a companion piece to chapter 15, has taken you through the con-
 troller and view phases of the redesign and enhancement of the music store appli-
 cation (plus a brief foray back into the model phase, in the last section). You’ve 
 seen some of the tools that Rails gives you to help you with both organizing and 
 customizing your templates—in the form of partials and helper files—and used 
 those tools to keep the template code readable and manageable as the application 
 has grown. As a final enhancement, we updated the customer model file to include 
 a mechanism for determining favorites and added template code to the main 
 welcome view to display those favorites for the logged-in customer. 
  
  If you’re left with the sense that, as of this chapter, it’s become difficult to tell 
 where Rails programming ends and Ruby programming begins, then the chapter 
 has succeeded. 
 That’s the goal
 —to be able to bring Ruby skills to bear seamlessly 
 on Rails tasks. Whether it’s writing an action, or a method in a helper file, or a 
 highly specialized suite of methods like the rankings and favorites facility in the 
 music store application, the ideal situation is one in which you have a large number 
 of programming techniques at your command and you use whichever ones help 
 you get your application to do what you want it to do. 
  
  That, in a nutshell, is Ruby for Rails. 
  
  There’s only one more area to explore: the process of becoming acquainted 
 with the Rails source code. Chapter 17 will give you a guided tour of the basics of 
 this process.",NA
Techniques for ,NA,NA
exploring the Rails ,NA,NA
source code,"In this chapter
  
  
 ■
  Panning for information
  
  
 ■
  Shadowing Ruby
  
  
 ■
  Consulting the documentation
  
 455",NA
17.1 Exploratory technique 1: panning for info,"The first exploratory technique we’ll look at is the closest among the three to an 
 informal, ad hoc technique. Nevertheless, it’s extremely useful (and common), and 
 instructive in the matter of the structure and layout of the source code. 
  
  
  The idea of panning for info is to go directly to the source code tree and look 
 around. 
  
  If this sounds like a haphazard technique for studying the Rails source, try it for 
 a while; you’ll see that the layout and organization of the code imposes a cer-tain 
 order on your hunting. Panning for information in the source is a bit hack-erly, but 
 it’s not random or undirected. 
  
  Furthermore, digging around in the Rails libraries can lead to interesting side 
 discoveries. Looking for a specific method or class definition and, upon finding it, 
 pulling the whole file up in a text editor is like fetching a book from a shelf on a 
 library: There’s always a possibility that something else of interest nearby will 
 catch your eye. 
  
  And just as walking through a library without having a particular book in mind 
 can be rewarding, so too can you learn a lot through unstructured, free-floating 
 exploration of the Rails source code. But we’ll be more structured: As a sustained 
 case study in the info-panning technique, we’ll use the ActiveRecord association",NA
17.2 Exploratory technique 2: shadowing Ruby,"The second technique for following the trail of Rails into its own source code is to 
 shadow Ruby—to follow which program files are loaded and executed, in what 
 order, up to and including whatever file contains the code you’re trying to pin 
 down. This technique can be a good exercise in and of itself; it’s a useful way to 
 strengthen your familiarity with the combined Ruby/Rails landscape. It can also 
 give you a detailed understanding of mechanisms that may not be organized the 
 way you’d expect. We’ll see a concrete example of this somewhat mysterious pro-
 nouncement when we return to 
 belongs_to
  later in this section. 
  
  You have to use some judgment, and make some judgments, when you shadow 
 Ruby through the source code. You have to choose a reasonable starting point and 
 make sensible choices at forks in the road, where the source code files you’re 
 consulting don’t unambiguously pinpoint the sequence of execution without an 
 educated guess from you. We’ll expand on both of these judgment-call areas next; 
 after that, we’ll return to the 
 belongs_to
  case study. 
  
 17.2.1 Choosing a starting point
  
 When a request comes in to a Rails application from a Web server, certain things 
 always happen. When you’re trying to follow Ruby’s footsteps through the 
 execution process, it’s reasonable to stride pretty quickly, if at all, through the 
 preliminaries. 
  
  
  Here’s a summary of some steps you can take for granted without digging 
 through every file involved:",NA
BC,"module ClassMethods
  
  
  def a_sort_of_class_method",NA
D,"puts ""Instance method of ClassMethods module""
  
   
  puts ""So this can be made to act like a class method""
   
  puts ""(if a Class object calls it directly)""
  
  
  end
  
  end
  
  def self.included(c)",NA
E,"c.extend(ClassMethods)
  
  end
  
  end
  
  class B",NA
F,"include M
  
  end
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
B ,"plays the role of ActiveRecord. Module 
 A::M",NA
C ,"is the equivalent of 
 ActiveRecord::Associations
 . Like 
 ActiveRecord::Associations
 , 
 M
  contains a 
 nested module called 
 ClassMethods
  (whose name is preserved here to pinpoint 
 the main action). Class 
 A::B",NA
F ,"plays the role of 
 ActiveRecord::Base
 . 
  
  The method 
 A::M::ClassMethods#a_sort_of_class_method",NA
D ,"is the equiva-
 lent of 
 belongs_to
 : It’s defined as an instance method several levels deep that gets 
 attached directly to a 
 Class
  object—in this case, the object 
 A::B
 —courtesy of the 
 callback mechanism of 
 Module#included",NA
E ,"(or 
 append_features
 , in the case of 
 the Rails code). 
  
  This transliteration shows you the essence of the mechanism whereby an 
 instance method of a module ends up serving, from the programmer’s perspec-
 tive, as a separate class’s class method. This brings us full circle to the mysterious 
 claim at the beginning of section 17.2: that learning how to shadow Ruby through 
 the Rails source can help you understand mechanisms that may not be organized 
 the way you’d expect. From the way it’s used, you might expect 
 belongs_to
  to be a 
 normal class method; but it isn’t, and by tracking Ruby’s actions you can both see 
 that it isn’t and also gain a complete understanding of what it 
 is
 . 
  
  
  (As you’ll see in the course of our consideration of the third exploratory tech-
 nique—consulting the documentation—the way 
 belongs_to
  and the other associ-
 ation methods are defined results in a documentation anomaly: Even though they 
 look and feel and act like class methods, they’re instance methods of a module—
 and therefore they’re listed as instance methods in the Rails documentation.)
  
  This 
 brings us to the third and final technique for tracking through the Rails source 
 code.",NA
17.3 Exploratory technique 3: ,NA,NA
consulting the documentation,"The third technique for tracking something through the source is to use the doc-
 umentation. This will almost certainly be the technique you use most often, unless 
 you get interested in the source and deeply involved in exploring it. (Part of the 
 reason for presenting the other two techniques is to suggest to you that a deep 
 level of exploration is possible.)",NA
17.4 Summary,"This chapter has provided more payoff for the study of Ruby by taking you on a 
 guided, annotated tour of techniques for exploring and studying the Rails source 
 code. We’ve used the ActiveRecord association methods, particularly 
 belongs_to
 , 
 as a thread to follow as we walked through three techniques: panning for info with 
 grep
  and similar tools; shadowing Ruby through the twists and turns of class, 
 module, and method definitions (and we chose a particularly twisty example; it’s 
 likely to be easier, rather than harder, as you do more of this kind of thing on your
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
appendix: ,NA,NA
Ruby and Rails ,NA,NA
installation and ,NA,NA
resources,471,NA
A.1 Online resources for Ruby and Rails,"The Ruby language homepage is http://www.ruby-lang.org. You’ll also find the 
 ruby-docs page (http://www.ruby-doc.org) useful. The Ruby Language 
 FAQ
  can be 
 found at http://www.rubygarden.org/faq, and Ruby Garden (the same 
 URL
 , with-
 out /faq) is also a good resource. It includes a Wiki (http://www.rubygarden.org/ 
 ruby) with a lot of information. 
  
  The main English-language general-purpose Ruby mailing list is 
 ruby-talk
 , 
 which is also a two-way mirror of the Usenet group 
 comp.lang.ruby
  (accessible 
 via Google Groups). Another important mailing list, although somewhat more spe-
 cialized, is 
 ruby-core
 , where Ruby language design and development issues are 
 discussed. You can find information about subscribing to these lists at http:// 
 www.ruby-lang.org/en/20020104.html. 
  
  A great place to get Ruby advice is the 
 #ruby-lang
 IRC
  channel on 
 irc.freenode.net (or chat.freenode.net). If you ask too many Rails-specific 
 questions, you’ll be gently steered toward the Rails channel, 
 #rubyonrails
 .",NA
A.2 Common-case instructions ,NA,NA
for installing Ruby and Rails,"What follows is some quick, common-case advice about installing Ruby and Rails. 
 It isn’t a substitute for what’s online, but it covers a few common installation sce-
 narios fully enough that it may help you get started. 
  
  The procedures addressed here are these:
  
 1 
  
 Installing both Ruby and Rails on Windows
  
 2 
  
 Installing Ruby from the source code on *nix systems
  
 3 
  
 Installing Ruby with a native package manager on a *nix system
  
 4 
  
 Installing the RubyGems package manager
  
 5 
  
 Installing Rails with the RubyGems package manager
  
 If you’re running Windows, you may need only step 1 (section A.2.1). If you’re 
 running a *nix system, you’ll probably do 
 either
  step 2 or step 3 (sections A.2.2 and 
 A.2.3) followed by 
 both
  steps 4 and 5 (sections A.2.4 and A.2.5).
  
  
  Again, this is not, and does not claim to be, true for every case. If what’s here 
 doesn’t fit your case, look at the online resources. 
  
 A.2.1 One-Click Ruby and Instant Rails for Windows
  
 If you’re running Microsoft Windows, you can use the One-Click Ruby Installer, by 
 Curt Hibbs. It installs the Ruby language, dozens of popular extensions, a syntax-
 highlighting editor, and the free electronic first edition of the book 
 Programming 
 Ruby: The Pragmatic Programmer’s Guide
  on your system. You can find the One-
 Click Installer at http://rubyforge.org/projects/rubyinstaller. Once you’ve done 
 that, you can install the RubyGems package manager and Rails (see sections A.2.4 
 and A.2.5). 
  
  Or you can do it all in one step using another tool by Curt Hibbs: the Instant 
 Rails package for Windows (http://instantrails.rubyforge.org/wiki/wiki.pl). 
 Instant Rails installs Ruby, Rails, the Apache Web server, and 
 MySQL
  
 simultaneously.",NA
index,"Symbols
  
 actions, execution sequence 62
  
 ActiveRecord collections
  
  
  
 #{} (string interpolation 
  
 ActionView 39–40
  
 :all modifier of find 
  
 form helper methods 74, 136
  
 method 399, 417
  
 operator) 106
  
 helper files 80–82
  
 :conditions argument of find 
  
 % (modulo method) 236
  
 helper methods 35, 136
  
 method 399
  
 & prefix to Proc/lambda to use 
  
 ActiveRecord 39
  
 ActiveSupport library
  
 as code block 356
  
 (all) vs. find_all 291
  
 automatic translation of 
  
 * (multiplication method)
  
 automatic creation of instance 
  
 action name to filenames 
  
 6, 236
  
 methods by 338
  
 by 460
  
 + (addition method) 6, 236
  
 collections as 397
  
 dependencies.rb 459
  
 - (subtraction method) 6, 236
  
 conditions argument to 
  
 named-based inference 460
  
 find 291
  
 provides facilities used across 
  
 . (dot operator) 6–7, 100
  
 create (class method) 449
  
 several other 
  
 / (division method) 6, 236
  
 delete_all (class method) 419
  
 subsystems 460
  
 < (comparison method/
  
 find_by_field methods
  
 Apache Web server 58, 
  
 operator) 237
  
 291, 444
  
 60–61, 74
  
 <% %> (ERb tag delimiters) 30
  
 first argument to find 
  
 configuration file 
  
 <%= %> (ERb interpolative tag 
  
 method 291
  
 examples 61
  
 delimiters) 30
  
 illustrating receiver-changing 
  
 application domains
  
 << (append method) 236
  
 permutations with 241–242
  
 actions and views closely 
  
 <= (comparison method/
  
 library source code 457
  
 linked 36
  
 operator) 237
  
 manual 241
  
 choosing publicly available 
  
 == (comparison method/
  
 methods derived from 
  
 views of 36
  
 operator) 237
  
 database field names 135
  
 specifying actions within 35
  
 === (case equality operator) 237
  
 models inherit from Base 364
  
 application, connecting to
  
 > (comparison method/
  
 objects as Ruby instances
  
 58–59
  
 operator) 237
  
 122, 372
  
 arithmetic methods 
  
 >= (comparison method/
  
 Ruby lessons from collection 
  
 (operators), summary 6
  
 operator) 237
  
 handling 289–292
  
 arithmetic operations 271–272
  
 []= (index setter method) 236
  
 setter(=-terminated) methods 
  
 arrays 279–292
  
 A
  
 in 133–136
  
 + method 283
  
 source code files 460
  
 == used to determine dupli-
  
  
  
 ActionController 39–40
  
 supplies full toolkit for 
  
 cates for uniq method 286
  
 database record 419
  
 []= method 280
  
 See also
  controllers
  
 update_attribute method 418
  
 as anchor for more complex 
  
 ActionPack 39–40
  
 validation facilities 444
  
 container classes 289
  
 477
  
 Licensed to Uwe Ilgenstein <uwe.ilgenstein@gmx.net>",NA
