Larger Text,Smaller Text,Symbol
Developers the world over talk about ,NA,NA
Programming Ruby,NA,NA
 and the Ruby language. . .,"“Ruby is a wonderfully powerful and useful language, and whenever I’m working 
 with it, this book is at my side.”
  
 Martin Fowler
 , Chief Scientist, ThoughtWorks
  
 “If your world revolves around Java, as mine did, then you need this outstanding 
 book to learn all the wonderful things you’re missing. There’s just one catch: you’ll 
 be spoiled from then on. Indeed, after reading just a few pages of
  Programming 
 Ruby
 , programming in any language other than Ruby will feel like you’re pushing 
 rope.”
  
 Mike Clark
 , Author and Consultant
  
 “Ruby is smart, elegant, and fun, and it deserves a book that’s smart, elegant, and 
 fun. The first edition of
  Programming Ruby
  was such a book; the second edition is 
 even better.”
  
 James Britt
 , Administrator,
  http://ruby-doc.org
  
 “The best reason to learn a new programming language is to learn to think 
 differently. The best way to learn to think the Ruby way is to read
  Programming 
 Ruby
 . Several years ago, with the first edition of this book, I did just that. Since then, 
 I’ve had a constant stream of
  enjoyable
  Ruby programming experiences. This is due 
 in no insignificant part to the quality of the source from which I learned the language. 
 I’m not the only person I’ve heard say that every language should have a book like 
 this.”
  
 Chad Fowler
 , Codirector, Ruby Central, Inc.
  
 “The PickAxe got me started on Ruby. It is still the first book I turn to.”
  
 Ryan Davis
 , Founder, Seattle.rb
  
 “This book changed my life. Sounds rather clichéd, but it’s the truth. After six years 
 and 300,000 lines of Java code, I needed a change. That change occurred upon reading 
 the first edition of this book. With the support of a solid community and ever-growing 
 foundation of superb libraries, I founded a company that largely profits from applying 
 Ruby to solve real-world problems. Ruby is ready for prime time, and this new version 
 of the PickAxe will show a waiting world what a gem Ruby really is.”
  
 Rich Kilmer
 , President and CEO, InfoEther LLC
  
 “The first edition of PickAxe has been a desk-side companion for years. The second 
 edition will be an eagerly awaited replacement.”
  
 Tom Enebo
 , JRuby Developer",NA
Programming ,NA,NA
Ruby ,NA,NA
The Pragmatic ,NA,NA
Programmers’ Guide,NA,NA
Second Edition,NA,NA
Dave Thomas,with,NA
 Chad ,NA,NA
Fowler ,and,NA
 Andy ,NA,NA
Hunt,NA,NA
Contents,"F
 OREWORD TO THE
  F
 IRST
  E
 DITION 
 F
 OREWORD TO THE
  S
 ECOND
  E
 DITION 
 P
 REFACE 
  
 R
 OAD
  M
 AP
  
 xvii 
  
 xix 
  
 xx 
  
 xxvi",NA
P,NA,NA
ART,NA,NA
 I—F,NA,NA
ACETS OF,NA,NA
 R,NA,NA
UBY,"1 G
 ETTING
  S
 TARTED 
  
 2
  
 Installing Ruby
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
  
 Running Ruby
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
  
 Ruby Documentation: RDoc and ri
  . . . . . . . . . . . . . . . . . . . . . 7
  
 2 R
 UBY
 .
 NEW 
  
 9
  
 Ruby Is an Object-Oriented Language 
  
 . . . . . . . . . . . . . . . . . . . 9
  
 Some Basic Ruby 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
  
 Arrays and Hashes
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
  
 Control Structures
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
  
 Regular Expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
  
 Blocks and Iterators
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
  
 Reading and ’Riting
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
  
 Onward and Upward
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
  
 3 C
 LASSES
 , O
 BJECTS
 ,
  AND
  V
 ARIABLES 
  
 23
  
 Inheritance and Messages
  . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 25
  
 Objects and Attributes
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
  
 Class Variables and Class Methods
  . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 Access Control
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
  
 Variables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
  
 Prepared exclusively for Yeganefar 
  
 v",NA
P,NA,NA
ART,NA,NA
 II—R,NA,NA
UBY IN,NA,NA
 I,NA,NA
TS,NA,NA
 S,NA,NA
ETTING,"14 R
 UBY AND
  I
 TS
  W
 ORLD 
  
 167
  
 Command-Line Arguments
  . . . . . . . . . . . . . . . . . . . . . . . . . 167
  
 Program Termination 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
  
 Environment Variables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
  
 Where Ruby Finds Its Modules
  . . . . . . . . . . . . . . . . . . . . . . . 172
  
 Build Environment
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
  
 15 I
 NTERACTIVE
  R
 UBY
  S
 HELL 
  
 174
  
 Command Line
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
  
 Configuration 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
  
 Commands
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
  
 Restrictions 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
  
 rtags and xmp 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
  
 16 D
 OCUMENTING
  R
 UBY 
  
 187
  
 Adding RDoc to Ruby Code
  . . . . . . . . . . . . . . . . . . . . . . . . . 187
  
 Adding RDoc to C Extensions
  . . . . . . . . . . . . . . . . . . . . . . . . 195
  
 Running RDoc
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
  
 Displaying Program Usage 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . 200
  
 Prepared exclusively for Yeganefar",NA
P,NA,NA
ART,NA,NA
 III—R,NA,NA
UBY,NA,NA
 C,NA,NA
RYSTALLIZED,"22 T
 HE
  R
 UBY
  L
 ANGUAGE 
  
 302
  
 Source Layout
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
  
 The Basic Types
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
  
 Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
  
 Variables and Constants
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
  
 Predefined Variables 
 . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 318
  
 Expressions 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
  
 Boolean Expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 326
  
 if
  and
  unless
  Expressions
  . . . . . . . . . . . . . . . . . . . . . . . 
  
 328
  
 case
  Expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 328
  
 Loop Constructs
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 329
  
 Method Definition
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
  
 Invoking a Method
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
  
 Aliasing 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
  
 Class Definition
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
  
 Module Definitions 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
  
 Access Control
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
  
 Blocks, Closures, and Proc Objects
  . . . . . . . . . . . . . . . . . . . . . 341
  
 Exceptions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
  
 Catch and Throw
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
  
 23 D
 UCK
  T
 YPING 
  
 349
  
 Classes Aren’t Types
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
  
 Coding like a Duck 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
  
 Standard Protocols and Coercions
  . . . . . . . . . . . . . . . . . . . . . . 355
  
 Walk the Walk, Talk the Talk 
  
 . . . . . . . . . . . . . . . . . . . . . . . . 361
  
 24 C
 LASSES AND
  O
 BJECTS 
  
 362
  
 How Classes and Objects Interact
  . . . . . . . . . . . . . . . . . . . . . . 362
  
 Class and Module Definitions
  . . . . . . . . . . . . . . . . . . . . . . . . 370
  
 Top-Level Execution Environment 
 . . . . . . . . . . . . . . . . . . . . . 376
  
 Inheritance and Visibility 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . 376
  
 Freezing Objects
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
  
 25 L
 OCKING
  R
 UBY IN THE
  S
 AFE 
  
 379
  
 Safe Levels
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
  
 Tainted Objects 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
  
 Prepared exclusively for Yeganefar",NA
P,NA,NA
ART,NA,NA
 IV—R,NA,NA
UBY,NA,NA
 L,NA,NA
IBRARY,NA,NA
 R,NA,NA
EFERENCE,"27 B
 UILT
 -
 IN
  C
 LASSES AND
  M
 ODULES 
  
 402
  
 Alphabetical Listing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
  
 Array
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 406
  
 Bignum 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 420
  
 Binding
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 423
  
 Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 424
  
 Comparable
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 426
  
 Continuation 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 427
  
 Dir 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 428
  
 Enumerable
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 433
  
 Errno
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 439
  
 Exception 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 440
  
 FalseClass
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 443
  
 File
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 444
  
 File::Stat
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 456
  
 FileTest
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 462
  
 Fixnum 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 463
  
 Float
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 466
  
 GC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 470
  
 Hash
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 471
  
 Integer
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 480
  
 IO
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 482
  
 Kernel 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 495
  
 Marshal
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 514
  
 MatchData 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 516
  
 Math
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 519
  
 Method 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 522
  
 Module 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 524
  
 NilClass
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 540
  
 Numeric
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 541
  
 Prepared exclusively for Yeganefar",NA
P,NA,NA
ART,NA,NA
 V—A,NA,NA
PPENDIXES,"A
  
 S
 OCKET
  L
 IBRARY
  
 740
  
 B
  
 BasicSocket
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 741
  
 Socket
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 743
  
 IPSocket
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 747
  
 TCPSocket
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 748
  
 SOCKSSocket
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 749
  
 TCPServer
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 750
  
 UDPSocket
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 751
  
 UNIXSocket
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 753
  
 UNIXServer
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 754
  
 MKMF R
 EFERENCE
  
 755
  
 C
  
 mkmf
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 755
  
 S
 UPPORT
  
 758
  
 D
  
 Web Sites
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 758
  
 Download 
 Sites
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 759
  
 Usenet Newsgroup
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 759
  
 Mailing Lists
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 759
  
 B
 IBLIOGRAPHY
  
 761
  
 I
 NDEX
  
 762
  
 S
 UMMARY
  T
 ABLES
  
 797
  
  
 Prepared exclusively for Yeganefar",NA
List of Tables,"2.1
  
 Example variable and class names
  . . . . . . . . . . . . . . . . . . . .
  
 15 
  
 68 
  
 89 
  
 135 
 165 
 172 
 175 
 206 
 230 
 266 
 304 
 306 
 314 
 324 
 383 
 414 
 447 
 449 
 451 
 455 
 483 
 510 
 511 
 512 
 512 
 543 
 544 
 593 
 603 
 627 
 653 
 691
  
 5.1
  
 Character class abbreviations
  . . . . . . . . . . . . . . . . . . . . . . .
  
 7.1
  
 Common comparison operators
  . . . . . . . . . . . . . . . . . . . . . .
  
 11.1
  
 Two threads in a race condition
  . . . . . . . . . . . . . . . . . . . . . .
  
 13.1
  
 Debugger commands
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14.1
  
 Environment variables used by Ruby
  . . . . . . . . . . . . . . . . . . .
  
 15.1
  
 irb command-line options
  . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17.1
  
 Version operators
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18.1
  
 Command-line options for
  erb
  . . . . . . . . . . . . . . . . . . . . . .
  
 21.1
  
 C/Ruby data type conversion functions and 
 macros
  
 . . . . . . . . . . .
  
 22.1
  
 General delimited input
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.2
  
 Substitutions in double-quoted strings
  . . . . . . . . . . . . . . . . . .
  
 22.3
  
 Reserved words
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.4
  
 Ruby operators (high to low precedence)
  . . . . . . . . . . . . . . . . .
  
 25.1
  
 Definition of the safe levels
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 27.1
  
 Class
  Array
 :
  pack
  directives
  . . . . . . . . . . . . . . . . . . . . . . .
  
 27.2
  
 Class
  File
 : match-mode constants
  . . . . . . . . . . . . . . . . . . . .
  
 27.3
  
 Class
  File
 : path separators
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 27.4
  
 Class
  File
 : open-mode constants
  . . . . . . . . . . . . . . . . . . . . .
  
 27.5
  
 Class
  File
 : lock-mode constants
  . . . . . . . . . . . . . . . . . . . . .
  
 27.6
  
 Class
  IO
 : mode strings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 27.7
  
 Module
  Kernel
 :
  sprintf
  flag characters
  
 . . . . . . . . . . . . . . . .
  
 27.8
  
 Module
  Kernel
 :
  sprintf
  field types
  . . . . . . . . . . . . . . . . . . .
  
 27.9
  
 Module
  Kernel
 : file tests with a single argument
  
 . . . . . . . . . . . .
  
 27.10 Module
  Kernel
 : file tests with two arguments
  . . . . . . . . . . . . . . 
 27.11 
 Class
  Numeric
 : methods and subclasses
  . . . . . . . . . . . . . . . . . 
 27.12 Class
  
 Numeric
 :
  divmod
 ,
  modulo
 , and
  remainder
  . . . . . . . . . . . . 
 27.13 Class
  String
 : 
 backslash sequences in substitution strings
  . . . . . . . . 
 27.14 Class
  String
 :
  unpack
  
 directives
  . . . . . . . . . . . . . . . . . . . . . 
 27.15 Class
  Time
 :
  strftime
  directives
  . . . . . . 
 . . . . . . . . . . . . . . .
  
 28.1
  
 Class
  ERB
 : inline directives
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 28.2
  
 Class
  OptionParser
 : option definitions
  . . . . . . . . . . . . . . . . .
  
 Prepared exclusively for Yeganefar
  
 xv",NA
List of Figures,"3.1
  
 Variables hold object references.
  . . . . . . . . . . . . . . . . . . . . .
  
 39 
  
 42 
  
 103 
 145 
 154 
 158 
 163 
 188 
 189 
 190 
 191 
 196 
 198 
 201 
 202 
 220 
 225 
 232 
 248 
 272 
 283 
 327 
 363 
 364 
 367 
 369 
 441 
 523
  
 4.1
  
 How arrays are indexed
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8.1
  
 Ruby exception hierarchy
  . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12.1
  
 Roman numerals generation (with bugs)
  . . . . . . . . . . . . . . . . .
  
 12.2
  
 Test::Unit assertions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13.1
  
 Sample irb session
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13.2
  
 Comparing variable access costs using benchmark
  . . . . . . . . . . . .
  
 16.1
  
 Browse RDoc output for class counter
  . . . . . . . . . . . . . . . . . .
  
 16.2
  
 Browse RDoc output when source has 
 comments
  
 . . . . . . . . . . . .
  
 16.3
  
 Using ri to read documentation
  . . . . . . . . . . . . . . . . . . . . . .
  
 16.4
  
 Document for class
  Proc
  generated by RDoc/ri
  
 . . . . . . . . . . . . .
  
 16.5
  
 Ruby source file documented with RDoc
  . . . . . . . . . . . . . . . . .
  
 16.6
  
 C source file documented with RDoc
  . . . . . . . . . . . . . . . . . . .
  
 16.7
  
 Sample program using RDoc::usage
  . . . . . . . . . . . . . . . . . . .
  
 16.8
  
 Help generated by sample program
  . . . . . . . . . . . . . . . . . . . .
  
 17.1
  
 MomLog package structure
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 18.1
  
 Sample CGI Form
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18.2
  
 Erb processing a file with loops
  . . . . . . . . . . . . . . . . . . . . . .
  
 19.1
  
 Drawing on a Tk 
 Canvas
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21.1
  
 Wrapping objects around C data types
  . . . . . . . . . . . . . . . . . .
  
 21.2
  
 Building an extension
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.1
  
 State transitions for boolean range
  . . . . . . . . . . . . . . . . . . . .
  
 24.1
  
 A basic object, with its class and superclass
  . . . . . . . . . . . . . . .
  
 24.2
  
 Adding a metaclass to
  Guitar
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 24.3
  
 Adding a virtual class to an object
  
 . . . . . . . . . . . . . . . . . . . .
  
 24.4
  
 An included module and its proxy class
  
 . . . . . . . . . . . . . . . . .
  
 27.1
  
 Standard exception hierarchy
  . . . . . . . . . . . . . . . . . . . . . . .
  
 27.2
  
 Method
 #
 arity
  in action
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Prepared exclusively for Yeganefar
  
 xvi",NA
Foreword to the,NA,NA
First Edition,"Man is driven to create; I know I really love to create things. And while I’m not good 
 at painting, drawing, or music, I can write software.
  
 Shortly after I was introduced to computers, I became interested in programming lan-
 guages. I believed that an ideal programming language must be attainable, and I 
 wanted to be the designer of it. Later, after gaining some experience, I realized that 
 this kind of ideal, all-purpose language might be more difficult than I had thought. 
 But I was still hoping to design a language that would work for most of the jobs I did 
 everyday. That was my dream as a student.
  
 Years later I talked with colleagues about scripting languages, their power and possi-
 bility. As an object-oriented fan for more than fifteen years, it seemed to me that OO 
 programming was very suitable for scripting too. I did some research on the ’net for a 
 while, but the candidates I found, Perl and Python, were not exactly what I was look-
 ing for. I wanted a language more powerful than Perl and more object-oriented than 
 Python.
  
 Then, I remembered my old dream and decided to design my own language. At first I 
 was just toying around with it at work. But gradually it grew to be a tool good enough 
 to replace Perl. I named it
  Ruby
 —after the precious red stone—and released it to the 
 public in 1995.
  
 Since then a lot of people have become interested in Ruby. Believe it or not, Ruby is 
 actually more popular than Python in Japan right now. I hope that eventually it will 
 be just as well received all over the world.
  
 I believe that the purpose of life is, at least in part, to be happy. Based on this belief, 
 Ruby is designed to make programming not only easy but also fun. It allows you to 
 concentrate on the creative side of programming, with less stress. If you don’t believe 
 me, read this book and try Ruby. I’m sure you’ll find out for yourself.
  
 I’m very thankful to the people who have joined the Ruby community; they have 
 helped me a lot. I almost feel like Ruby is one of my children, but in fact, it is the result 
 of the",NA
Foreword to the,NA,NA
Second Edition,"No one in 1993 would have believed that an object-oriented language created by a 
 Japanese amateur language designer would end up being used worldwide and that the 
 language would become almost as popular as Perl. It was insane. I admit that. I didn’t 
 believe it either.
  
 But it happened, far exceeding my expectations. It was caused—at least in part—by 
 the first edition of this book. The famous Pragmatic Programmers chose a dynamic 
 language that was virtually unknown to anyone outside of Japan and wrote a good 
 book about it. It was just like a miracle.
  
 That’s now history. The future starts now. We have the second edition of
  
 Programming Ruby
 , which is better than the first one. It’s no longer a miracle. This 
 time, the grown-up Ruby community helped to develop the book. I just needed to sit 
 and watch the community working together.
  
 I really appreciate the Pragmatic Programmers, Dave Thomas and Andy Hunt, and 
 other people from the community who helped with this book (guys, sorry for not 
 nam-ing you personally). I love the friendliness of the Ruby community. It’s the best 
 soft-ware community I have ever seen. I also appreciate every programmer in the 
 world who uses Ruby.
  
 The stone has started rolling. It will became a great mountain and fill the whole earth.
  
 Yukihiro Matsumoto
 , a.k.a.
  “Matz”
  
  
 Japan, August 2004
  
 Prepared exclusively for Yeganefar 
  
 xix",NA
Preface,"This book is the second edition of the PickAxe, as
  Programming Ruby
  is known to 
 Rubyists. It is a tutorial and reference for the Ruby programming language. If you 
 have the first edition, you’ll find that this version is a significant rewrite.
  
 When Andy and I wrote the first edition, we had to explain the background and 
 appeal of Ruby. Among other things, we wrote “When we discovered Ruby, we 
 realized that we’d found what we’d been looking for. More than any other language 
 with which we have worked, Ruby
  stays out of your way
 . You can concentrate on 
 solving the problem at hand, instead of struggling with compiler and language issues. 
 That’s how it can help you become a better programmer: by giving you the chance to 
 spend your time creating solutions for your users, not for the compiler.”
  
 That belief is even stronger today. Four years later. Ruby is still our language of 
 choice: I use it for client applications, I use it to run our publishing business, and I 
 use it for all those little programming jobs I do just to get things running smoothly.
  
 In those four years, Ruby has progressed nicely. A large number of methods have 
 been added to the built-in classes and modules, and the size of the standard library 
 (those libraries included in the Ruby distribution) has grown tremendously. The 
 community now has a standard documentation system (RDoc), and RubyGems may 
 well become the system of choice for packaging Ruby code for distribution.
  
 This change has been wonderful, but it left the original PickAxe looking a tad dated. 
 This book remedies that: like its predecessor, it is written for the very latest version 
 of Ruby.",NA
Ruby Versions,"This version of the PickAxe documents Ruby 1.8 (and in particular covers changes 
 incorporated into Ruby 1.8.2).
 1
  
 1.
  
 Ruby version numbering follows the same scheme used for many other open-source projects. 
 Releases
  
 with even subversion numbers—1.6, 1.8, and so on—are stable, public releases. These are the releases that 
 are prepackaged and made available on the various Ruby Web sites. Development versions of the software
  
 Prepared exclusively for Yeganefar 
 xx",NA
Changes in the Book,"Apart from the updates to support Ruby 1.8, you’ll find that the book has changed 
 somewhat from the original edition.
  
 In the first half of the book, I’ve added six new chapters.
  Getting Started
  is a more 
 complete introduction to getting up-and-running with Ruby than we had in the first 
 book. The second new chapter,
  Unit Testing
 , reflects a growing emphasis on using 
 testing among Rubyists. Three new chapters cover tools for the Ruby programmer:
  
 irb 
 for experimenting with Ruby,
  RDoc
  for documenting your code, and
  RubyGems
  
 for packing code for distribution. Finally, a new chapter covers
  duck typing
 , that 
 slightly slippery philosophy of programming that fits in so well with the ideas behind 
 Ruby.
  
 That’s not all that’s new. You’ll also find that the chapter on threads has been 
 extended significantly with a discussion on synchronization and that the chapter on 
 writing Ruby extensions has been largely rewritten. The chapter on Web 
 programming now discusses alternative templating systems and has a section on 
 SOAP. The language reference chapter has been significantly extended (particularly 
 when dealing with the new rules for blocks, procs, breaks, and returns).
  
 The next quarter of the book, which documents the built-in classes and modules, has 
 more than 250 significant changes. Many of them are new methods, some are depre-
 cated old methods, and some are methods with significant new behavior. You’ll also 
 find a number of new modules and classes documented.
  
 Finally, the book includes a section on the standard library. The library has grown 
 extensively since Ruby 1.6 and is now so big that I couldn’t document it to any level 
 of detail without making the book thousands of pages long. At the same time, the 
 Ruby Documentation project has been busy adding RDoc documentation to the 
 library source itself. (I explain RDoc in Chapter
  16
  on page
  187
 .) This means that 
 you will increasingly be able to get accurate, up-to-date documentation on a library 
 module
  
 have odd subversion numbers, such as 1.7 and 1.9. These you’ll have to download and build for yourself, as 
 described on page
  3
 .",NA
Resources,"Visit the Ruby Web site
  http://www.ruby-lang.org
  to see what’s new. Chat with other 
 Ruby users on the newsgroup or mailing lists (see Appendix
  C
 ).
  
 And I’d certainly appreciate hearing from you. Comments, suggestions, errors in the 
 text, and problems in the examples are all welcome. E-mail us at
  
 rubybook@pragmaticprogrammer.com
  
 If you tell us about errors in the book, I’ll add them to the errata list at
  
 http://www.pragmaticprogrammer.com/titles/ruby/errata.html
  
 You’ll find links to the source code for almost all the book’s example code at
  
 http://www.pragmaticprogrammer.com/titles/ruby",NA
Acknowledgments,"For the second edition of the PickAxe, I asked on the Ruby mailing list if anyone 
 would consider helping review the text. I was overwhelmed with the response: almost 
 one hundred people volunteered. To keep it manageable, I had to restrict the list on a 
 first-come basis. Even so, my wonderful reviewers produced more than 1.5Mb of 
 review text. These folks picked on everything, from misplaced commas to missing 
 methods. I couldn’t have gotten better help. So a big “thank you” to Richard 
 Amacker, David A. Black, Tony Bowden, James Britt, Warren Brown, Mike Clark, 
 Ryan Davis (thanks for the Japanese PDF!), Guy Decoux, Friedrich Dominicus, 
 Thomas Enebo, Chad Fowler, Hal Fulton, Ben Giddings, Johan Holmberg, Andrew 
 Johnson, Rich Kilmer, Robert Klemme, Yukihiro Matsumoto, Marcel Molina Jr., 
 Roeland Moors, Michael Neumann,",NA
Notation Conventions,"Throughout this book, we use the following typographic notations.
  
 Literal code examples are shown using a typewriter-like font.
  
 class SampleCode 
  
 def run 
  
  
 #...
  
 end 
  
 end
  
 Within the text,
  Fred
 #
 do_something
  is a reference to an instance method (in this case 
 do_something
 ) of class
  Fred
 ,
  Fred.new
 2
 is a class method, and
  Fred::EOF
  is a class 
 constant. The decision to use a hash character to indicate instance methods was a 
 tough one: it isn’t valid Ruby syntax, but we thought that it was important to 
 differentiate between the instance and class methods of a particular class. When you 
 see us write 
 File.read
 , you know we’re talking about the class method
  read
 . When 
 instead we write
  File
 #
 read
 , we’re referring to the instance method
  read
 .
  
 The book contains many snippets of Ruby code. Where possible, we’ve tried to show 
 what happens when they run. In simple cases, we show the value of expressions on 
 the same line as the expression. For example:
  
 a = 1 
  
 b = 2
  
 a + b
  
 →
  
 3
  
 Here, you can see that the result of evaluating
  a + b
  is the value 3, shown to the right 
 of the arrow. Note that if you simply run this program, you wouldn’t see the value 3 
 output—you’d need to use a method such as
  puts
  to write it out.
  
 At times, we’re also interested in the values of assignment statements, in which case 
 we’ll show them.
  
 a = 1
  
 →
  
 1
  
 b = 2
  
 →
  
 2
  
 a + b
  
 →
  
 3
  
 If the program produces more complex output, we show it below the program code.
  
 3.times { puts ""Hello!"" }
  
 produces:
  
 Hello! 
  
 Hello! 
  
 Hello!
  
 2.
  
 In some other Ruby documentation, you may see class methods written as
  Fred::new
 . This is perfectly
  
 valid Ruby syntax; we just happen to think that
  Fred.new
  is less distracting to read.
  
 Prepared exclusively for Yeganefar",NA
Road Map,"The main text of this book has four separate parts, each with its own personality, and 
 each addressing different aspects of the Ruby language.
  
 In Part I,
  Facets of Ruby
 , you’ll find a Ruby tutorial. It starts with some notes on 
 getting Ruby running on your system followed by a short chapter on some of the 
 terminology and concepts that are unique to Ruby. This chapter also includes enough 
 basic syntax so that the other chapters will make sense. The rest of the tutorial is a 
 top-down look at the language. There we talk about classes and objects, types, 
 expressions, and all the other things that make up the language. We end with chapters 
 on unit testing and digging yourself out when trouble strikes.
  
 One of the great things about Ruby is how well it integrates with its environment. 
 Part II,
  Ruby in Its Setting
 , investigates this. Here you’ll find practical information on 
 using Ruby: using the interpreter options, using irb, documenting your Ruby code, 
 and packaging your Ruby gems so that others can enjoy them. You’ll also find 
 tutorials on some common Ruby tasks: using Ruby with the Web, creating GUI 
 applications using Tk, and using Ruby in a Microsoft Windows environment 
 (including wonderful things such as native API calls, COM integration, and Windows 
 Automation). And you’ll discover just how easy it is to extend Ruby and to embed 
 Ruby within your own code.
  
 Part III,
  Ruby Crystallized
 , contains more advanced material. Here you’ll find all the 
 gory details about the language, the concept of
  duck typing
 , the metaclass model, 
 tainting, reflection, and marshaling. You could probably speed-read this the first time 
 through, but we think you’ll come back to it as you start to use Ruby in earnest.
  
 The
  Ruby Library Reference
  is Part IV. It’s big. We document more than 950 methods
  
 1.8
  
  
 in more than 48 built-in classes and modules (up from 800 methods in 40 classes and
  
 modules in the previous 
 edition).
  
 On top of that, we now document the library modules
  
 that are included in the standard Ruby distribution (98 of them).
  
 So, how should you read this book? Well, depending on your level of expertise with 
 programming in general, and OO in particular, you may initially want to read just a 
 few portions of the book. Here are our recommendations.
  
 If you’re a beginner, you may want to start with the tutorial material in Part I. Keep the 
 library reference close at hand as you start to write programs. Get familiar with",NA
Part I,NA,NA
Facets of Ruby,"Prepared exclusively for Yeganefar
  
 1",NA
Chapter 1,NA,NA
Getting Started,"Before we start talking about the Ruby language, it’d be useful if we helped you get 
 Ruby running on your computer. That way you can try sample code and experiment 
 on your own as you read along. We’ll also show you some different ways to run 
 Ruby.",NA
Installing Ruby,"Quite often, you won’t even need to download Ruby. It now comes preinstalled on 
 many Linux distributions, and Mac OS X includes Ruby (although the version of 
 Ruby pre-installed on OS X is normally several minor releases behind the current 
 Ruby version). Try typing
  ruby -v
  at a command prompt—you may be pleasantly 
 surprised.
  
 If you don’t already have Ruby on your system, or if you’d like to upgrade to a newer 
 version, you can install it pretty simply. But first, you have a choice to make: go for a 
 binary distribution, or build Ruby from source?",NA
Binary Distributions,"A binary distribution of Ruby simply works out of the box. You install it, and it runs. 
 Binary distributions are prebuilt for a particular operating environment and are 
 conve-nient if you don’t want to mess around with building Ruby from source. The 
 downside of a binary distribution is that you have to take it as given: it may be a 
 minor release or two behind the leading edge, and it may not have the optional 
 libraries that you might want. If you can live with that, you’ll need to find a binary 
 distribution for your operating system and machine architecture.
  
 For RPM-based Linux systems, you can search on
  http://www.rpmfind.net
  for a 
 suitable Ruby RPM. Enter
  ruby
  as a search term, and select from the listed version 
 numbers, architectures, and distributions. For example,
  ruby-1.8.2.i386
  is a binary 
 distribution of Ruby 1.8.2 for Intel x86 architectures.",NA
Building Ruby from Source,"Because Ruby is an open-source project, you can download the source code to the 
 inter-preter and build it on your own system. Compared to using a binary distribution, 
 this gives you a lot more control over where things go, and you can keep your 
 installation totally up-to-date. The downside is that you’re taking on the responsibility 
 of managing the build and installation process. This isn’t onerous, but it can be scary 
 if you’ve never installed an open-source application from source.
  
 The first thing to do is to download the source. This comes in three flavors, all from 
 http://www.ruby-lang.org
 .
  
 1. The stable release in
  tarball
  format. A tarball is an archive file, much like a
  zip 
  
 file. Click the
  Download Ruby
  link, and then click the
  stable release
  link.
  
 2. The
  stable snapshot
 . This is a tarball, created nightly, of the latest source code in 
 Ruby’s stable development branch. The stable branch is intended for production 
 code and in general will be reliable. However, because the snapshot is taken 
 daily, new features may not have received thorough testing yet—the stable 
 tarball in item (1) will be generally more reliable.
  
 Prepared exclusively for Yeganefar",NA
Source Code from This Book,"We’ve made the source code from this book available for download from our web 
 site at
  http://pragmaticprogrammer.com/titles/ruby/code
 . Sometimes, the listings of 
 code in the book correspond to a complete source file. Other times, the book contains 
 just a part of the source in a file—the program file may contain additional scaffolding 
 to make the code compile.",NA
Running Ruby,"Now that Ruby is installed, you’d probably like to run some programs. Unlike 
 compiled languages, you have two ways to run Ruby—you can type in code 
 interactively, or you can create program files and run them. Typing in code 
 interactively is a great way to experiment with the language, but for code that’s more 
 complex, or that you will want to run more than once, you’ll need to create program 
 files and run them.
  
 1.
  
 See
  http://www.cygwin.com
  for details.",NA
Interactive Ruby,"One way to run Ruby interactively is simply to type
  ruby
  at the shell prompt. Here
  
 we typed in the single
  puts
  expression and an end-of-file character (which is Ctrl+D
  
 on our system). This process works, but it’s painful if you make a typo, and you can’t
  
 really see what’s going on as you type.
  
 %
  ruby
  
 puts ""Hello, world!""
  
 ^D
  
 Hello, world!
  
 For most folks,
  irb
 —Interactive Ruby—is the tool of choice for executing Ruby inter-
  
 actively. irb is a Ruby Shell, complete with command-line history, line-editing capabil-
  
 ities, and job control. (In fact, it has its own chapter beginning on page
  174
 .) You run
  
 irb from the command line. Once it starts, just type in Ruby code. It will show you the
  
 value of each expression as it evaluates it.",NA
Ruby Programs,"You can run a Ruby program from a file as you would any other shell script, Perl 
 program, or Python program. Simply run the Ruby interpreter, giving it the script 
 name as an argument.
  
 %
  ruby myprog.rb
  
 You can also use the Unix “shebang” notation as the first line of the program file.
 2
  
 #!/usr/local/bin/ruby -w
  
 puts ""Hello, world!""
  
 If you make this source file executable (using, for instance,
  chmod +x myprog.rb
 ), Unix 
 lets you run the file as a program.
  
 %
  ./myprog.rb 
  
 Hello, world!
  
 You can do something similar under Microsoft Windows using file associations, and 
 you can run Ruby GUI applications by double-clicking their names in Explorer.
  
 2.
  
 If your system supports it, you can avoid hard-coding the path to Ruby in the “shebang” line by using
  
 #!/usr/bin/env ruby
 , which will search your path for
  ruby
  and then execute it.
  
 Prepared exclusively for Yeganefar",NA
Ruby Documentation: RDoc and ri,"As the volume of the Ruby libraries has grown, it has become impossible to docu-
 ment them all in one book; the standard library that comes with Ruby now contains 
 more than 9,000 methods. Fortunately, an alternative to paper documentation exists 
 for these methods (and classes and modules). Many are now documented internally 
 using a system called
  RDoc
 .
  
 If a source file is documented using RDoc, its documentation can be extracted and 
 converted into HTML and ri formats.
  
 Several sites on the Web contain a complete set of the RDoc documentation for 
 Ruby, but
  http://www.ruby-doc.org
  is probably the best known. Browse on over, and 
 you should be able to find at least some form of documentation for any Ruby library. 
 They’re adding new documentation all the time.
  
 The ri tool is a local, command-line viewer for this same documentation. Most Ruby 
 distributions now also install the resources used by the ri program.
  
 To find the documentation for a class, type
  ri
  ClassName
 . For example, the following 
 lists the summary information for the
  GC
  class. (For a list of classes with ri 
 documenta-tion, type
  ri -c
 .)
  
 %
  ri GC
  
 ----------------------------------------------------------- Class: GC 
  
 The GC module provides an interface 
 to Ruby's mark and sweep 
  
 garbage collection mechanism. Some of the underlying methods are 
  
 also available via the ObjectSpace module.
  
 ---------------------------------------------------------------------
  
 Class methods: 
  
  
 disable, enable, start
  
 Instance methods: 
  
  
 garbage_collect
  
 For information on a particular method, give its name as a parameter.
  
 %
  ri enable
  
 ---------------------------------------------------------- GC::enable 
  
 GC.enable => true or false
  
 ---------------------------------------------------------------------
  
 Enables garbage collection, returning 
 true if garbage collection 
  
 was previously disabled.
  
 GC.disable 
  
 #=> false 
  
 GC.enable 
  
 #=> true 
  
 GC.enable 
  
 #=> false
  
 Prepared exclusively for Yeganefar",NA
Chapter 2,NA,NA
Ruby.new,"When we originally designed this book, we had a grand plan (we were younger then). 
 We wanted to document the language from the top down, starting with classes and 
 objects and ending with the nitty-gritty syntax details. It seemed like a good idea at 
 the time. After all, most everything in Ruby is an object, so it made sense to talk 
 about objects first.
  
 Or so we thought.
  
 Unfortunately, it turns out to be difficult to describe a language that way. If you 
 haven’t covered strings,
  if
  statements, assignments, and other details, it’s difficult to 
 write examples of classes. Throughout our top-down description, we kept coming 
 across low-level details we needed to cover so that the example code would make 
 sense.
  
 So, we came up with another grand plan (they don’t call us pragmatic for nothing). 
 We’d still describe Ruby starting at the top. But before we did that, we’d add a short 
 chapter that described all the common language features used in the examples along 
 with the special vocabulary used in Ruby, a kind of minitutorial to bootstrap us into 
 the rest of the book.",NA
Ruby Is an Object-Oriented Language,"Let’s say it again. Ruby is a genuine object-oriented language. Everything you 
 manip-ulate is an object, and the results of those manipulations are themselves 
 objects. How-ever, many languages make the same claim, and their users often have a 
 different inter-pretation of what
  object-oriented
  means and a different terminology 
 for the concepts they employ.
  
 So, before we get too far into the details, let’s briefly look at the terms and notation that 
 we’ll
  be using.",NA
Some Basic Ruby,"Not many people like to read heaps of boring syntax rules when they’re picking up a 
 new language, so we’re going to cheat. In this section we’ll hit some of the 
 highlights—the stuff you’ll just
  have
  to know if you’re going to write Ruby 
 programs. Later, in Chapter
  22
 , which begins on page
  302
 , we’ll go into all the gory 
 details.
  
 Let’s start with a simple Ruby program. We’ll write a method that returns a cheery, 
 personalized greeting. We’ll then invoke that method a couple of times.
  
 def say_goodnight(name) 
  
 result = ""Good night, "" + name 
  
 return result 
  
 end
  
 # Time for bed...
  
 puts say_goodnight(""John-Boy"") 
  
 puts say_goodnight(""Mary-Ellen"")
  
 As the example shows, Ruby syntax is clean. You don’t need semicolons at the ends 
 of statements as long as you put each statement on a separate line. Ruby comments 
 start with a
  #
  character and run to the end of the line. Code layout is pretty much up 
 to",NA
Arrays and Hashes,"Ruby’s arrays and hashes are indexed collections. Both store collections of objects, 
 accessible using a key. With arrays, the key is an integer, whereas hashes support any 
 object as a key. Both arrays and hashes grow as needed to hold new elements. It’s 
 more efficient to access array elements, but hashes provide more flexibility. Any 
 particular array or hash can hold objects of differing types; you can have an array 
 containing an integer, a string, and a floating-point number, as we’ll see in a minute.
  
 You can create and initialize a new array object using an
  array literal
 —a set of 
 elements between square brackets. Given an array object, you can access individual 
 elements by supplying an index between square brackets, as the next example shows. 
 Note that Ruby array indices start at zero.
  
 a = [ 1, 'cat', 3.14 ] 
  
 # array with three elements 
  
 # access the first element
  
 a[0]
  
 →
  
 1
  
 # set the third element 
  
 a[2] = nil 
  
 # dump out the array
  
 a
  
 →
  
 [1, ""cat"", nil]
  
 You may have noticed that we used the special value
  nil
  in this example. In many 
 languages, the concept of
  nil
  (or
  null
 ) means “no object.” In Ruby, that’s not the case; 
 nil
  is an object, just like any other, that happens to represent nothing. Anyway, back 
 to arrays and hashes.
  
 Prepared exclusively for Yeganefar",NA
Control Structures,"Ruby has all the usual control structures, such as
  if
  statements and
  while
  loops. Java, 
 C, and Perl programmers may well get caught by the lack of braces around the bodies 
 of these statements. Instead, Ruby uses the keyword
  end
  to signify the end of a body.
  
 if count > 10 
  
 puts ""Try again"" 
  
 elsif tries == 3 
  
 puts ""You lose"" 
  
 else 
  
 puts ""Enter a number"" 
  
 end
  
 Similarly,
  while
  statements are terminated with
  end
 .
  
 while weight < 100 and num_pallets <= 30 
  
 pallet = next_pallet() 
  
 weight += pallet.weight 
  
 num_pallets += 1 
  
 end
  
 Most statements in Ruby return a value, which means you can use them as conditions. 
 For example, the method
  gets
  returns the next line from the standard input stream or 
 nil
  when end of file is reached. Because Ruby treats
  nil
  as a false value in conditions, 
 you could write the following to process the lines in a file.
  
 while line = gets 
  
 puts line.downcase 
  
 end
  
 Here, the assignment statement sets the variable
  line
  to either the next line of text or 
 nil
 , and then the
  while
  statement tests the value of the assignment, terminating the 
 loop when it is
  nil
 .
  
 Prepared exclusively for Yeganefar",NA
Regular Expressions,"Most of Ruby’s built-in types will be familiar to all programmers. A majority of lan-
 guages have strings, integers, floats, arrays, and so on. However, regular expression 
 support is typically built into only scripting languages, such as Ruby, Perl, and awk. 
 This is a shame: regular expressions, although cryptic, are a powerful tool for 
 working with text. And having them built in, rather than tacked on through a library 
 interface, makes a big difference.
  
 Entire books have been written about regular expressions (for example,
  Mastering 
 Reg-ular Expressions
  [
 Fri02
 ]), so we won’t try to cover everything in this short 
 section. Instead, we’ll look at just a few examples of regular expressions in action. 
 You’ll find full coverage of regular expressions starting on page
  64
 .
  
 A regular expression is simply a way of specifying a
  pattern
  of characters to be 
 matched in a string. In Ruby, you typically create a regular expression by writing a 
 pattern between slash characters (/
 pattern
 /). And, Ruby being Ruby, regular 
 expressions are objects and can be manipulated as such.
  
 For example, you could write a pattern that matches a string containing the text
  Perl
  or 
 the text
  Python
  using the following regular expression.
  
 /Perl|Python/
  
 Prepared exclusively for Yeganefar",NA
Blocks and Iterators,"This section briefly describes one of Ruby’s particular strengths. We’re about to look 
 at code blocks: chunks of code you can associate with method invocations, almost as 
 if they were parameters. This is an incredibly powerful feature. One of our reviewers 
 commented at this point: “This is pretty interesting and important, and so if you 
 weren’t paying attention before, you should probably start now.” We’d have to agree.
  
 You can use code blocks to implement callbacks (but they’re simpler than Java’s 
 anony-mous inner classes), to pass around chunks of code (but they’re more flexible 
 than C’s function pointers), and to implement iterators.
  
 Code blocks are just chunks of code between braces or between
  do
 ...
  end
 .
  
 { puts ""Hello"" } 
  
 # this is a block
  
 do 
  
 ### 
  
 club.enroll(person) 
  
  
 # and so is this 
  
 person.socialize 
  
  
 # 
  
 end 
  
 ###
  
 Why are there two kinds of delimiter? It’s partly because sometimes one feels more 
 natural to write than another. It’s partly too because they have different precedences: 
 the braces bind more tightly than the
  do
 /
 end
  pairs. In this book, we try to follow what 
 is becoming a Ruby standard and use braces for single-line blocks and
  do
 /
 end
  for 
 multiline blocks.
  
 Once you’ve created a block, you can associate it with a call to a method. You do this 
 by putting the start of the block at the end of the source line containing the method 
 call. For example, in the following code, the block containing
  puts ""Hi""
  is associated 
 with the call to the method
  greet
 .
  
 greet { puts ""Hi"" }
  
 If the method has parameters, they appear before the block.
  
 verbose_greet(""Dave"", ""loyal customer"") { puts ""Hi"" }
  
 A method can then invoke an associated block one or more times using the Ruby
  yield 
 statement. You can think of
  yield
  as being something like a method call that calls out 
 to the block associated with the method containing the
  yield
 .
  
 The following example shows this in action. We define a method that calls
  yield
  
 twice. We then call this method, putting a block on the same line, after the call (and 
 after any arguments to the method).
 2
  
 2.
  
 Some people like to think of the association of a block with a method as a kind of parameter passing.
  
 This works on one level, but it isn’t really the whole story. You may be better off thinking of the block and 
 the method as coroutines, which transfer control back and forth between themselves.
  
 Prepared exclusively for Yeganefar",NA
Reading and ’Riting,"Ruby comes with a comprehensive I/O library. However, in most of the examples in 
 this book we’ll stick to a few simple methods. We’ve already come across two 
 methods that do output.
  puts
  writes its arguments, adding a newline after each.
  print
  
 also writes its arguments, but with no newline. Both can be used to write to any I/O 
 object, but by default they write to standard output.
  
 Another output method we use a lot is
  printf
 , which prints its arguments under the 
 control of a format string (just like
  printf
  in C or Perl).
  
 printf(""Number: %5.2f,\nString: %s\n"", 1.23, ""hello"")
  
 produces:
  
 Number: 1.23, 
  
 String: hello
  
 In this example, the format string
  ""Number: %5.2f,\nString: %s\n""
  tells
  printf 
 to 
 substitute in a floating-point number (allowing five characters in total, with two after 
 the decimal point) and a string. Notice the newlines (
 \n
 ) embedded in the string; each 
 moves the output onto the next line.
  
 You have many ways to read input into your program. Probably the most traditional 
 is to use the routine
  gets
 , which returns the next line from your program’s standard 
 input stream.
  
 line = gets 
  
 print line
  
 Prepared exclusively for Yeganefar",NA
Onward and Upward,"That’s it. We’ve finished our lightning-fast tour of some of the basic features of Ruby.
  
 We’ve had a look at objects, methods, strings, containers, and regular expressions, seen
  
 some simple control structures, and looked at some rather nifty iterators. We hope this
  
 chapter has given you enough ammunition to be able to attack the rest of this book.
  
 Time to move on, and up—up to a higher level. Next, we’ll be looking at classes and
  
 objects, things that are at the same time both the highest-level constructs in Ruby and
  
 the essential underpinnings of the entire language.",NA
Chapter 3,NA,NA
"Classes, Objects, and",NA,NA
Variables,"From the examples we’ve shown so far, you may be wondering about our earlier 
 asser-tion that Ruby is an object-oriented language. Well, this chapter is where we 
 justify that claim. We’re going to be looking at how you create classes and objects in 
 Ruby and at some of the ways in which Ruby is more powerful than most object-
 oriented lan-guages. Along the way, we’ll be implementing part of our next billion-
 dollar product, the Internet Enabled Jazz and Bluegrass jukebox.
  
 After months of work, our highly paid Research and Development folks have deter-
 mined that our jukebox needs
  songs
 . So it seems like a good idea to start by setting 
 up a Ruby class that represents things that are songs. We know that a real song has a 
 name, an artist, and a duration, so we’ll want to make sure that the song objects in our 
 program do, too.
  
 We’ll start by creating the basic class
  Song
 ,
 1
 which contains just a single method, 
 initialize
 .
  
 class Song 
  
 def initialize(name, artist, duration) 
  
  
 @name 
  
 = name 
  
  
 @artist 
  
 = artist 
  
  
 @duration = duration 
  
 end 
  
 end
  
 initialize
  is a special method in Ruby programs. When you call
  Song.new
  to create a new
  
 Song
  object, Ruby allocates some memory to hold an uninitialized object and
  
 1.
  
 As we mentioned on page
  14
 , class names start with an uppercase letter, and method names normally
  
 start with a lowercase letter.
  
 Prepared exclusively for Yeganefar 
  
 23",NA
Inheritance and Messages,"Inheritance allows you to create a class that is a refinement or specialization of 
 another class. For example, our jukebox has the concept of songs, which we 
 encapsulate in class
  Song
 . Then marketing comes along and tells us that we need to 
 provide karaoke support. A karaoke song is just like any other (it doesn’t have a vocal 
 track, but that doesn’t concern us). However, it also has an associated set of lyrics, 
 along with timing information. When our jukebox plays a karaoke song, the lyrics 
 should flow across the screen on the front of the jukebox in time with the music.
  
 An approach to this problem is to define a new class,
  KaraokeSong
 , that is just like 
 Song
  
 but with a lyric track.
  
 class KaraokeSong < Song 
  
 def initialize(name, artist, duration, lyrics) 
  
  
 super(name, artist, duration) 
  
  
 @lyrics = lyrics 
  
 end 
  
 end
  
 The “
 < Song
 ” on the class definition line tells Ruby that a
  KaraokeSong
  is a
  sub-class
  of
  
 Song
 . (Not surprisingly, this means that
  Song
  is a
  superclass
  of
  KaraokeSong
 . People 
 also talk about parent-child relationships, so
  KaraokeSong
 ’s parent would be 
 Song
 .) For 
 now, don’t worry too much about the
  initialize
  method; we’ll talk about that
  super
  call 
 later.
  
 Let’s create a
  KaraokeSong
  and check that our code worked. (In the final system, the 
 lyrics will be held in an object that includes the text and timing information.) To test 
 our class, though, we’ll just use a string. This is another benefit of dynamically typed 
 languages—we don’t have to define everything before we start running code.",NA
Objects and Attributes,"The
  Song
  objects we’ve created so far have an internal state (such as the song title and 
 artist). That state is private to those objects—no other object can access an object’s 
 instance variables. In general, this is a Good Thing. It means that the object is solely 
 responsible for maintaining its own consistency.
  
 However, an object that is totally secretive is pretty useless—you can create it, but 
 then you can’t do anything with it. You’ll normally define methods that let you 
 access and manipulate the state of an object, allowing the outside world to interact 
 with the object. These externally visible facets of an object are called its
  attributes
 .
  
 For our
  Song
  objects, the first thing we may need is the ability to find out the title and 
 artist (so we can display them while the song is playing) and the duration (so we can 
 display some kind of progress bar).
  
 Prepared exclusively for Yeganefar",NA
Writable Attributes,"Sometimes you need to be able to set an attribute from outside the object. For 
 example, let’s assume that the duration that is initially associated with a song is an 
 estimate (perhaps gathered from information on a CD or in the MP3 data). The first 
 time we play the song, we get to find out how long it actually is, and we store this 
 new value back in the
  Song
  object.
  
 In languages such as C++ and Java, you’d do this with
  setter functions
 .
  
 class JavaSong { 
  
 // Java code 
  
 private Duration _duration; 
  
 public void setDuration(Duration newDuration) { 
  
  
 _duration = newDuration; 
  
 } 
  
 } 
  
 s = new Song(....); 
  
 s.setDuration(length);
  
 In Ruby, the attributes of an object can be accessed as if they were any other variable. 
 We’ve seen this above with phrases such as
  song.name
 . So, it seems natural to be able 
 to assign to these variables when you want to set the value of an attribute. In Ruby 
 you do that by creating a method whose name ends with an equals sign. These 
 methods can be used as the target of assignments.
  
 class Song 
  
 def duration=(new_duration) 
  
  
 @duration = new_duration 
  
 end 
  
 end 
  
 song = Song.new(""Bicylops"", ""Fleck"", 260) 
  
 song.duration
  
 →
  
  
 260 song.duration = 257 
   
 # set attribute with updated value 
  
 song.duration
  
 →
  
 257
  
 Prepared exclusively for Yeganefar",NA
Virtual Attributes,"These attribute-accessing methods do not have to be just simple wrappers around an 
 object’s instance variables. For example, you may want to access the duration in min-
 utes and fractions of a minute, rather than in seconds as we’ve been doing.
  
 class Song 
  
 def duration_in_minutes 
  
  
 @duration/60.0 
  
 # force floating point 
  
 end 
  
 def duration_in_minutes=(new_duration) 
  
  
 @duration = (new_duration*60).to_i 
  
 end 
  
 end 
  
 song = Song.new(""Bicylops"", ""Fleck"", 260)
  
 song.duration_in_minutes
  
 →
  
 4.33333333333333
  
 song.duration_in_minutes = 4.2
  
 song.duration
  
 →
  
 252
  
 Here we’ve used attribute methods to create a virtual instance variable. To the out-
 side world,
  duration_in_minutes
  seems to be an attribute like any other. Internally, 
 though, it has no corresponding instance variable.
  
 This is more than a curiosity. In his landmark book
  Object-Oriented Software Con-
 struction
  [
 Mey97
 ], Bertrand Meyer calls this the
  Uniform Access Principle
 . By 
 hiding the difference between instance variables and calculated values, you are 
 shielding the rest of the world from the implementation of your class. You’re free to 
 change how things work in the future without impacting the millions of lines of code 
 that use your class. This is a big win.",NA
"Attributes, Instance Variables, and Methods","This description of attributes may leave you thinking that they’re nothing more than 
 methods—why’d we need to invent a fancy name for them? In a way, that’s 
 absolutely right. An attribute
  is
  just a method. Sometimes an attribute simply returns 
 the value of an instance variable. Sometimes an attribute returns the result of a 
 calculation. And",NA
Class Variables and Class Methods,"So far, all the classes we’ve created have contained instance variables and instance 
 methods: variables that are associated with a particular instance of the class, and 
 meth-ods that work on those variables. Sometimes classes themselves need to have 
 their own states. This is where class variables come in.",NA
Class Variables,"A class variable is shared among all objects of a class, and it is also accessible to the 
 class methods that we’ll describe later. Only one copy of a particular class variable 
 exists for a given class. Class variable names start with two “at” signs, such as
  
 @@count
 . Unlike global and instance variables, class variables must be initialized 
 before they are used. Often this initialization is just a simple assignment in the body 
 of the class definition.
  
 For example, our jukebox may want to record how many times each song has been 
 played. This count would probably be an instance variable of the
  Song
  object. When a 
 song is played, the value in the instance is incremented. But say we also want to 
 know how many songs have been played in total. We could do this by searching for 
 all the
  Song
  objects and adding their counts, or we could risk excommunication from 
 the Church of Good Design and use a global variable. Instead, we’ll use a class 
 variable.
  
 class Song 
  
 @@plays = 0 
  
 def initialize(name, artist, duration) 
  
  
 @name 
  
 = name 
  
  
 @artist 
  
 = artist 
  
  
 @duration = duration 
  
  
 @plays 
  
 = 0 
  
 end",NA
Class Methods,"Sometimes a class needs to provide methods that work without being tied to any par-
 ticular object. We’ve already come across one such method. The
  new
  method creates 
 a new
  Song
  object but is not itself associated with a particular song.
  
 song = Song.new(....)
  
 You’ll find class methods sprinkled throughout the Ruby libraries. For example, 
 objects of class
  File
  represent open files in the underlying file system. However, class
  
 File 
 also provides several class methods for manipulating files that aren’t open and 
 there-fore don’t have a
  File
  object. If you want to delete a file, you call the class 
 method 
 File.delete
 , passing in the name.
  
 File.delete(""doomed.txt"")
  
 Class methods are distinguished from instance methods by their definition; class 
 meth-ods are defined by placing the class name and a period in front of the method 
 name (but also see the sidebar on page
  34
 ).
  
 class Example
  
 def instance_method 
  
 # instance method 
  
 end
  
 def Example.class_method 
  
 # class method 
  
 end
  
 end",NA
Singletons and Other Constructors,"Sometimes you want to override the default way in which Ruby creates objects. As 
 an example, let’s look at our jukebox. Because we’ll have many jukeboxes, spread all 
 over the country, we want to make maintenance as easy as possible. Part of the 
 requirement is to log everything that happens to a jukebox: the songs played, the 
 money received, the strange fluids poured into it, and so on. Because we want to 
 reserve the network bandwidth for music, we’ll store these log files locally. This 
 means we’ll need a class that handles logging. However, we want only one logging 
 object per jukebox, and we want that object to be shared among all the other objects 
 that use it.
  
 Enter the Singleton pattern, documented in
  Design Patterns
  [
 GHJV95
 ]. We’ll arrange 
 things so that the only way to create a logging object is to call
  MyLogger.create
 , and 
 we’ll ensure that only one logging object is ever created.
  
 class MyLogger 
  
 private_class_method :new 
  
 @@logger = nil 
  
 def MyLogger.create 
  
  
 @@logger = new unless @@logger 
  
  
 @@logger 
  
 end 
  
 end
  
 By making
  MyLogger
 ’s
  new
  method private, we prevent anyone from creating a log-
 ging object using the conventional constructor. Instead, we provide a class method, 
 MyLogger.create
 . This method uses the class variable
  @@logger
  to keep a reference",NA
Access Control,"When designing a class interface, it’s important to consider just how much access to 
 your class you’ll be exposing to the outside world. Allow too much access into your 
 class, and you risk increasing the coupling in your application—users of your class 
 will be tempted to rely on details of your class’s implementation, rather than on its 
 logical interface. The good news is that the only easy way to change an object’s state 
 in Ruby is by calling one of its methods. Control access to the methods, and you’ve 
 controlled access to the object. A good rule of thumb is never to expose methods that 
 could leave an object in an invalid state. Ruby gives you three levels of protection.
  
 •
  Public methods
  can be called by anyone—no access control is enforced. Methods 
  
 are public by default (except for
  initialize
 , which is always private).
  
 •
  Protected methods
  can be invoked only by objects of the defining class and its 
  
 subclasses. Access is kept within the family.
  
 •
  Private methods
  cannot be called with an explicit receiver—the receiver is 
 always 
 self
 . This means that private methods can be called only in the context of 
 the current object; you can’t invoke another object’s private methods.
  
 The difference between “protected” and “private” is fairly subtle and is different in 
 Ruby than in most common OO languages. If a method is protected, it may be called 
 by
  any
  instance of the defining class or its subclasses. If a method is private, it may 
 be called only within the context of the calling object—it is never possible to access 
 another object’s private methods directly, even if the object is of the same class as the 
 caller.
  
 Prepared exclusively for Yeganefar",NA
Specifying Access Control,"You specify access levels to methods within class or module definitions using one or 
 more of the three functions
  public
 ,
  protected
 , and
  private
 . You can use each func-tion in 
 two different ways.
  
 If used with no arguments, the three functions set the default access control of subse-
 quently defined methods. This is probably familiar behavior if you’re a C++ or Java 
 programmer, where you’d use keywords such as
  public
  to achieve the same effect.
  
 class MyClass 
  
  
 def method1 
  
 # default is 'public' 
  
  
 #...
  
  
 end 
  
 protected 
  
 # subsequent methods will be 'protected' 
   
  
 # will be 'protected' def method2 
  
  
  
 #...
  
  
 end 
  
 private 
  
 # subsequent methods will be 'private' 
  
  
 def method3 
  
 # will be 'private' 
  
  
  
 #...
  
  
 end 
  
 public 
   
 # subsequent methods will be 'public' 
  
  
 def method4 
  
 # and this will be 'public' 
  
  
  
 #...
  
  
 end 
  
 end
  
 Alternatively, you can set access levels of named methods by listing them as arguments 
 to the access control functions.
  
 class MyClass 
  
 def method1 
  
 end 
  
 # ... and so on 
  
 public 
  
 :method1, :method4 
  
 protected :method2 
  
 private 
  
  
 :method3 end
  
 It’s time for some examples. Perhaps we’re modeling an accounting system where 
 every debit has a corresponding credit. Because we want to ensure that no one can 
 break this rule, we’ll make the methods that do the debits and credits private, and 
 we’ll define our external interface in terms of transactions.
  
 Prepared exclusively for Yeganefar",NA
Variables,"Now that we’ve gone to the trouble to create all these objects, let’s make sure we 
 don’t lose them. Variables are used to keep track of objects; each variable holds a 
 reference to an object.
  
 Let’s confirm this with some code.
  
 person = ""Tim""
  
 person.id
  
 →
  
 936870
  
 person.class
  
 →
  
 String
  
 person
  
 →
  
 ""Tim""
  
  
 Prepared exclusively for Yeganefar",NA
Chapter 4,NA,NA
"Containers, Blocks,",NA,NA
and Iterators,"A jukebox with one song is unlikely to be popular (except perhaps in some very, very 
 scary bars), so pretty soon we’ll have to start thinking about producing a catalog of 
 available songs and a playlist of songs waiting to be played. Both of these are
  
 contain-ers:
  objects that hold references to one or more other objects.
  
 Both the catalog and the playlist need a similar set of methods: add a song, remove a 
 song, return a list of songs, and so on. The playlist may perform additional tasks, such 
 as inserting advertising every so often or keeping track of cumulative play time, but 
 we’ll worry about these things later. In the meantime, it seems like a good idea to 
 develop some kind of generic
  SongList
  class, which we can specialize into catalogs 
 and playlists.",NA
Containers,"Before we start implementing, we’ll need to work out how to store the list of songs 
 inside a
  SongList
  object. We have three obvious choices. We could use the Ruby 
 Array
  
 type, use the Ruby
  Hash
  type, or create our own list structure. Being lazy, for now 
 we’ll look at arrays and hashes and choose one of these for our class.",NA
Arrays,"The class
  Array
  holds a collection of object references. Each object reference occupies a 
 position in the array, identified by a non-negative integer index.
  
 You can create arrays by using literals or by explicitly creating an
  Array
  object. A 
 literal array is simply a list of objects between square brackets.
  
 Prepared exclusively for Yeganefar 
  
 40",NA
Hashes,"Hashes
  (sometimes known as
  associative arrays
 ,
  maps
 , or
  dictionaries
 ) are similar to 
 arrays in that they are indexed collections of object references. However, while you 
 index arrays with integers, you can index a hash with objects of any type: strings, 
 regular expressions, and so on. When you store a value in a hash, you actually supply",NA
Implementing a SongList Container,"After that little diversion into arrays and hashes, we’re now ready to implement the 
 jukebox’s
  SongList
 . Let’s invent a basic list of methods we need in our
  SongList
 . We’ll 
 want to add to it as we go along, but this will do for now.
  
 append(song)
  →
  list 
  
  
 Append the given song to the list.
  
 delete_first()
  →
  song 
  
  
 Remove the first song from the list, returning that song.
  
 delete_last()
  →
  song 
  
  
 Remove the last song from the list, returning that song.
  
 [index]
  →
  song 
  
  
 Return the song at the integer
  
 index
 .
  
 with_title(title)
  →
  song 
  
  
 Return the song with the given title.
  
 This list gives us a clue to the implementation. The ability to append songs at the end, 
 and remove them from both the front and end, suggests a
  dequeue
 —a double-ended 
 queue—which we know we can implement using an
  Array
 . Similarly, the ability to 
 return a song at an integer position in the list is supported by arrays.",NA
Blocks and Iterators,"Our next problem with
  SongList
  is to implement the method
  with_title
  that takes a 
 string and searches for a song with that title. This seems straightforward: we have an 
 array of songs, so we’ll go through it one element at a time, looking for a match.
  
 class SongList 
  
 def with_title(title) 
  
  
 for i in 0...@songs.length 
  
    
 return @songs[i] if title == @songs[i].name 
  
  
 end 
  
  
 return nil 
  
 end 
  
 end
  
 This works, and it looks comfortingly familiar: a
  for
  loop iterating over an array. What 
 could be more natural?
  
 It turns out there
  is
  something more natural. In a way, our
  for
  loop is somewhat too 
 intimate with the array; it asks for a length, and it then retrieves values in turn until it 
 finds a match. Why not just ask the array to apply a test to each of its members? 
 That’s just what the
  find
  method in
  Array
  does.
  
 class SongList 
  
 def with_title(title) 
  
  
 @songs.find {|song| title == song.name } 
  
 end 
  
 end
  
 The method
  find
  is an
  iterator
 —a method that invokes a block of code repeatedly. 
 Iterators and code blocks are among the more interesting features of Ruby, so let’s 
 spend a while looking into them (and in the process we’ll find out exactly what that 
 line of code in our
  with_title
  method actually does).",NA
Implementing Iterators,"A Ruby iterator is simply a method that can invoke a block of code. At first sight, a 
 block in Ruby looks just like a block in C, Java, C#, or Perl. Unfortunately, in this 
 case looks are deceiving—a Ruby block
  is
  a way of grouping statements, but not in 
 the conventional way.
  
 First, a block may appear only in the source adjacent to a method call; the block is 
 written starting on the same line as the method call’s last parameter (or the closing",NA
Blocks for Transactions,"Although blocks are often the target of an iterator, they also have other uses. Let’s look 
 at a few.
  
 You can use blocks to define a chunk of code that must be run under some kind of 
 trans-actional control. For example, you’ll often open a file, do something with its 
 contents, and then want to ensure that the file is closed when you finish. Although 
 you can do this",NA
Blocks Can Be Closures,"Let’s get back to our jukebox for a moment (remember the jukebox?). At some point 
 we’ll be working on the code that handles the user interface—the buttons that people 
 press to select songs and control the jukebox. We’ll need to associate actions with 
 those buttons: press
  START
  and the music starts. It turns out that Ruby’s blocks are a 
 convenient way to do this. Let’s start by assuming that the people who made the 
 hardware implemented a Ruby extension that gives us a basic button class. (We talk 
 about extending Ruby beginning on page
  261
 .)
  
 start_button 
 = 
 Button.new(""Start"") 
  
 pause_button 
 = 
 Button.new(""Pause"") 
  
 # ...
  
 What happens when the user presses one of our buttons? In the
  Button
  class, the hard-
 ware folks rigged things so that a callback method,
  button_pressed
 , will be invoked. 
 The obvious way of adding functionality to these buttons is to create subclasses of 
 Button
  and have each subclass implement its own
  button_pressed
  method.
  
 class StartButton < Button 
  
 def initialize 
  
  
 super(""Start"") 
  
 # invoke Button's initialize 
  
 end 
  
 def button_pressed 
  
  
 # do start actions...
  
 end 
  
 end
  
 start_button = StartButton.new
  
 Prepared exclusively for Yeganefar",NA
Containers Everywhere,"Containers, blocks, and iterators are core concepts in Ruby. The more you write in 
 Ruby, the more you’ll find yourself moving away from conventionallooping 
 constructs. Instead, you’ll write classes that support iteration over their contents. And 
 you’ll find that this code is compact, easy to read, and a joy to maintain.
  
 Prepared exclusively for Yeganefar",NA
Chapter 5,NA,NA
Standard Types,"So far we’ve been having fun implementing pieces of our jukebox code, but we’ve 
 been negligent. We’ve looked at arrays, hashes, and procs, but we haven’t really 
 covered the other basic types in Ruby: numbers, strings, ranges, and regular 
 expressions. Let’s spend a few pages on these basic building blocks now.",NA
Numbers,"Ruby supports integers and floating-point numbers. Integers can be any length (up to 
 a maximum determined by the amount of free memory on your system). Integers 
 within a certain range (normally
  −2
 30
 to
  2
 30
 −1
  or
  −2
 62
 to
  2
 62
 −1
 ) are held internally in 
 binary form and are objects of class
  Fixnum
 . Integers outside this range are stored in 
 objects of class
  Bignum
  (currently implemented as a variable-length set of short 
 integers). This process is transparent, and Ruby automatically manages the 
 conversion back and forth.
  
 num = 81 
  
 6.times do 
  
 puts ""#{num.class}: #{num}"" 
  
 num *= num 
  
 end
  
 produces:
  
 Fixnum: 81 
  
 Fixnum: 6561 
  
 Fixnum: 43046721 
  
 Bignum: 1853020188851841 
  
 Bignum: 3433683820292512484657849089281 
  
 Bignum: 11790184577738583171520872861412518665678211592275841109096961
  
 You write integers using an optional leading sign, an optional base indicator (
 0
  for 
 octal,
  0d
  for decimal [the default],
  0x
  for hex, or
  0b
  for binary), followed by a string of 
 digits in the appropriate base. Underscore characters are ignored in the digit string 
 (some folks use them in place of commas in larger numbers).",NA
Strings,"Ruby strings are simply sequences of 8-bit bytes. They normally hold printable 
 charac-ters, but that is not a requirement; a string can also hold binary data. Strings 
 are objects of class
  String
 .
  
 Strings are often created using string literals—sequences of characters between 
 delim-iters. Because binary data is otherwise difficult to represent within program 
 source, you can place various escape sequences in a string literal. Each is replaced 
 with the corresponding binary value as the program is compiled. The type of string 
 delimiter determines the degree of substitution performed. Within single-quoted 
 strings, two con-secutive backslashes are replaced by a single backslash, and a 
 backslash followed by a single quote becomes a single quote.
  
 'escape using ""\\""'
  
 →
  
 escape using ""\""
  
 'That\'s right'
  
 →
  
 That's right
  
 Double-quoted strings support a boatload more escape sequences. The most common 
 is probably
  \n
 , the newline character. Table
  22.2
  on page
  306
  gives the complete list. 
 In addition, you can substitute the value of any Ruby code into a string using the 
 sequence 
 #{
  expr
  }
 . If the code is just a global variable, a class variable, or an instance 
 variable, you can omit the braces.
  
 ""Seconds/day: #{24*60*60}""
  
 →
  
 Seconds/day: 86400
  
 Ho! Ho! Ho! Merry Christmas!
  
 ""#{'Ho! '*3}Merry Christmas!""
  
 →
  
 ""This is line #$.""
  
 →
  
 This is line 3
  
  
 Prepared exclusively for Yeganefar",NA
Working with Strings,"String
  is probably the largest built-in Ruby class, with more than 75 standard methods. 
 We won’t go through them all here; the library reference has a complete list. Instead, 
 we’ll look at some common string idioms—things that are likely to pop up during 
 day-to-day programming.
  
 Let’s get back to our jukebox. Although it’s designed to be connected to the Internet, 
 it also holds copies of some popular songs on a local hard drive. That way, if a 
 squirrel chews through our ’net connection, we’ll still be able to entertain the 
 customers.
  
 For historical reasons (are there any other kind?), the list of songs is stored as rows in 
 a flat file. Each row holds the name of the file containing the song, the song’s 
 duration, the artist, and the title, all in vertical bar–separated fields. A typical file may 
 start
  
 /jazz/j00132.mp3
  
 | 3:45 | Fats
  
 Waller
  
 | Ain't Misbehavin'
  
 /jazz/j00319.mp3
  
 | 2:58 | Louis
  
 Armstrong
  
 | Wonderful World
  
 /bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
  
 :
  
 :
  
 :
  
 :
  
 Looking at the data, it’s clear that we’ll be using some of class
  String
 ’s many methods 
 to extract and clean up the fields before we create
  Song
  objects based on them. At a 
 minimum, we’ll need to
  
 • break each line into fields,
  
 • convert the running times from mm:ss to seconds, and
  
 • remove those extra spaces from the artists’ names.
  
 Our first task is to split each line into fields, and
  String
 #
 split
  will do the job nicely. In 
 this case, we’ll pass
  split
  a regular expression,
  /\s*\|\s*/
 , that splits the line into 
 tokens wherever
  split
  finds a vertical bar, optionally surrounded by spaces. And, 
 because the line read from the file has a trailing newline, we’ll use
  String
 #
 chomp
  to 
 strip it off just before we apply the split.
  
 File.open(""songdata"") do |song_file| 
  
 songs = SongList.new
  
 song_file.each do |line| 
  
 file, length, name, title = line.chomp.split(/\s*\|\s*/) 
  
 songs.append(Song.new(title, name, length)) 
  
 end
  
 puts songs[1] 
  
 end
  
 produces:
  
 Song: Wonderful World--Louis Armstrong (2:58)
  
 Unfortunately, whoever created the original file entered the artists’ names in 
 columns, so some of them contain extra spaces. These will look ugly on our high-
 tech, super-twist, flat-panel, Day-Glo display, so we’d better remove these extra 
 spaces before",NA
Ranges,"Ranges occur everywhere: January to December, 0 to 9, rare to well-done, lines 50 
 through 67, and so on. If Ruby is to help us model reality, it seems natural for it to 
 support these ranges. In fact, Ruby goes one better: it actually uses ranges to 
 implement three separate features: sequences, conditions, and intervals.",NA
Ranges as Sequences,"The first and perhaps most natural use of ranges is to express a sequence. Sequences 
 have a start point, an end point, and a way to produce successive values in the 
 sequence. In Ruby, these sequences are created using the “. .” and “. . .” range 
 operators. The two-dot form creates an inclusive range, and the three-dot form creates 
 a range that excludes the specified high value.
  
 1..10 
  
 'a'..'z' 
  
 my_array = [ 1, 2, 3 ] 
  
 0...my_array.length
  
 Prepared exclusively for Yeganefar",NA
Ranges as Conditions,"As well as representing sequences, ranges may also be used as conditional 
 expressions. Here, they act as a kind of toggle switch—they turn on when the 
 condition in the first part of the range becomes true, and they turn off when the 
 condition in the second part becomes true. For example, the following code fragment 
 prints sets of lines from standard input, where the first line in each set contains the 
 word
  start
  and the last line contains the word
  end
 .
  
 while line = gets 
  
 puts line if line =~ /start/ .. line =~ /end/ 
  
 end
  
 Behind the scenes, the range keeps track of the state of each of the tests. We’ll show 
 some examples of this in the description of loops that starts on page
  94
 .
  
 1.8
  
  
 In older versions of Ruby, bare ranges could be used as conditions in
  if
 ,
  while
 , and
  
 similar statements.
  
 You could, for example, have written the previous code fragment as
  
 while gets 
  
 print if /start/../end/ 
  
 end
  
 This is no longer supported. Unfortunately, no error is raised; the test will simply suc-
 ceed each time.",NA
Ranges as Intervals,"A final use of the versatile range is as an interval test: seeing if some value falls within 
 the interval represented by the range. We do this using
  ===
 , the case equality operator.
  
 (1..10)
  
 === 5
  
 →
  
 true
  
 (1..10)
  
 === 15
  
 false
  
 →
  
 (1..10)
  
 === 3.14159
  
 →
  
 true
  
 ('a'..'j') === 'c'
  
 →
  
 true
  
 ('a'..'j') === 'z'
  
 →
  
 false
  
 The example of a case expression on page
  92
  shows this test in action, determining a 
 jazz style given a year.",NA
Regular Expressions,"Back on page
  59
  when we were creating a song list from a file, we used a regular 
 expression to match the field delimiter in the input file. We claimed that the 
 expression 
 line.split(/\s*\|\s*/)
  matched a vertical bar surrounded by optional 
 whitespace. Let’s explore regular expressions in more detail to see why this claim is 
 true.",NA
Patterns,"Every regular expression contains a pattern, which is used to match the regular expres-
 sion against a string.
  
 Within a pattern, all characters except ., |, (, ), [, ], {, }, +, \, ^, $, *, and ? match 
 themselves.
  
 show_regexp('kangaroo', /angar/)
  
 →
  
 k<<angar>>oo
  
 show_regexp('!@%&-_=+', /%&/)
  
 →
  
 !@<<%&>>-_=+
  
 If you want to match one of these special characters literally, precede it with a back-
 slash. This explains part of the pattern we used to split the song line,
  /\s*\|\s*/
 . The
  \|
  
 means “match a vertical bar.” Without the backslash, the
  |
  would have meant 
 alternation
  (which we’ll describe later).
  
 show_regexp('yes | no', /\|/)
  
 →
  
 yes <<|>> no
  
 show_regexp('yes (no)', /\(no\)/)
  
 yes <<(no)>>
  
 →
  
 show_regexp('are you sure?', /e\?/)
  
 →
  
 are you sur<<e?>>
  
 A backslash followed by an alphanumeric character is used to introduce a special 
 match construct, which we’ll cover later. In addition, a regular expression may 
 contain
  #{...} 
 expression substitutions.
  
 Anchors
  
 By default, a regular expression will try to find the first match for the pattern in a 
 string. Match
  /iss/
  against the string “Mississippi,” and it will find the substring “iss” 
 starting at position one. But what if you want to force a pattern to match only at the 
 start or end of a string?
  
 The patterns
  ^
  and
  $
  match the beginning and end of a line, respectively. These are 
 often used to
  anchor
  a pattern match: for example,
  /^option/
  matches the word
  option
  
 only if it appears at the start of a line. The sequence
  \A
  matches the beginning of a 
 string, and
  \z
  and
  \Z
  match the end of a string. (Actually,
  \Z
  matches the end of a 
 string
  unless 
 the string ends with a
  \n
 , it which case it matches just before the
  \n
 .)
  
 show_regexp(""this is\nthe time"", /^the/)
  
 →
  
 this is\n<<the>> time
  
 show_regexp(""this is\nthe time"", /is$/)
  
 →
  
 this <<is>>\nthe time
  
 show_regexp(""this is\nthe time"", /\Athis/)
  
 →
  
 <<this>> is\nthe time
  
 show_regexp(""this is\nthe time"", /\Athe/)
  
 no match
  
 →
  
 Similarly, the patterns
  \b
  and
  \B
  match word boundaries and nonword boundaries, 
 respectively. Word characters are letters, numbers, and underscores.
  
 show_regexp(""this is\nthe time"", /\bis/)
  
 →
  
 this <<is>>\nthe time
  
 show_regexp(""this is\nthe time"", /\Bis/)
  
 th<<is>> is\nthe time
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
Pattern-Based Substitution,"Sometimes finding a pattern in a string is good enough. If a friend challenges you to 
 find a word that contains the letters
  a
 ,
  b
 ,
  c
 ,
  d
 , and
  e
  in order, you could search a word 
 list with the pattern
  /a.*b.*c.*d.*e/
  and find
  abjectedness
 ,
  absconded
 ,
  ambuscade
 , and
  
 carbacidometer
 , among others. That has to be worth something.
  
 However, sometimes you need to change things based on a pattern match. Let’s go 
 back to our song list file. Whoever created it entered all the artists’ names in 
 lowercase. When we display them on our jukebox’s screen, they’d look better in 
 mixed case. How can we change the first character of each word to uppercase?
  
 The methods
  String
 #
 sub
  and
  String
 #
 gsub
  look for a portion of a string matching their 
 first argument and replace it with their second argument.
  String
 #
 sub
  performs one 
 replacement, and
  String
 #
 gsub
  replaces every occurrence of the match. Both rou-tines 
 return a new copy of the
  String
  containing the substitutions. Mutator versions 
 String
 #
 sub!
  and
  String
 #
 gsub!
  modify the original string.
  
 a = ""the quick brown fox""
  
 a.sub(/[aeiou]/,
  
 '*')
  
 →
  
 ""th* quick brown fox""
  
 a.gsub(/[aeiou]/, '*')
  
 →
  
 ""th* q**ck br*wn f*x""
  
 a.sub(/\s\S+/,
  
 '')
  
 →
  
 ""the brown fox""
  
 a.gsub(/\s\S+/, '')
  
 →
  
 ""the""
  
  
 Prepared exclusively for Yeganefar",NA
Object-Oriented Regular Expressions,"We have to admit that while all these weird variables are very convenient to use, they 
 aren’t very object oriented, and they’re certainly cryptic. And didn’t we say that 
 every-thing in Ruby was an object? What has gone wrong here?
  
 Nothing, really. It’s just that when Matz designed Ruby, he produced a fully object-
 oriented regular expression handling system. He then made it look familiar to Perl 
 programmers by wrapping all these $-variables on top of it all. The objects and 
 classes are still there, underneath the surface. So let’s spend a while digging them out.
  
 We’ve already come across one class: regular expression literals create instances of 
 class
  Regexp
  (documented beginning on page
  579
 ).",NA
Chapter 6,NA,NA
More about Methods,"So far in this book, we’ve been defining and using methods without much thought. 
 Now it’s time to get into the details.",NA
Defining a Method,"As we’ve seen, a method is defined using the keyword
  def
 . Method names should 
 begin with a lowercase letter.
 1
 Methods that act as queries are often named with a 
 trailing
  ?
 , such as
  instance_of?
 . Methods that are “dangerous,” or modify the receiver, 
 may be named with a trailing
  !
 . For instance,
  String
  provides both a
  chop
  and a
  chop!
 . 
 The first one returns a modified string; the second modifies the receiver in place. And 
 methods that can be assigned to (a feature we discussed on page
  29
 ) end with an 
 equals sign (
 =
 ).
  ?
 ,
  !
 , and
  =
  are the only “weird” characters allowed as method name 
 suffixes.
  
 Now that we’ve specified a name for our new method, we may need to declare some 
 parameters. These are simply a list of local variable names in parentheses. (The 
 paren-theses are optional around a method’s arguments; our convention is to use them 
 when a method has arguments and omit them when it doesn’t.)
  
 def my_new_method(arg1, arg2, arg3) 
  
 # 3 arguments # 
 Code for the method would go here 
  
 end
  
 def my_other_new_method # No arguments # Code for the method would go 
 here 
  
 end
  
 Ruby lets you specify default values for a method’s arguments—valuesthat will be 
 used if the caller doesn’t pass them explicitly. You do this using the assignment 
 operator.
  
 1.
  
 You won’t get an immediate error if you use an uppercase letter, but when Ruby sees you calling the
  
 method, it will first guess that it is a constant, not a method invocation, and as a result it may parse the call 
 incorrectly.",NA
Variable-Length Argument Lists,"But what if you want to pass in a variable number of arguments or want to capture 
 multiple arguments into a single parameter? Placing an asterisk before the name of 
 the parameter after the “normal” parameters does just that.
  
 def varargs(arg1, *rest) 
  
 ""Got #{arg1} and #{rest.join(', ')}"" 
  
 end
  
 varargs(""one"")
  
 →
  
 ""Got one and ""
  
 varargs(""one"", ""two"")
  
 ""Got one and two""
  
 →
  
 varargs ""one"", ""two"", ""three""
  
 →
  
 ""Got one and two, three""
  
 In this example, the first argument is assigned to the first method parameter as usual. 
 However, the next parameter is prefixed with an asterisk, so all the remaining 
 arguments are bundled into a new
  Array
 , which is then assigned to that parameter.",NA
Methods and Blocks,"As we discussed in the section on blocks and iterators beginning on page
  46
 , when a 
 method is called, it may be associated with a block. Normally, you simply call the 
 block from within the method using
  yield
 .
  
 def take_block(p1) 
  
 if block_given?
  
  
 yield(p1) 
  
 else 
  
  
 p1 
  
 end 
  
 end
  
 take_block(""no block"")
  
 →
  
 ""no block""
  
 take_block(""no block"") {|s| s.sub(/no /, '') }
  
 ""block""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
Calling a Method,"You call a method by specifying a receiver, the name of the method, and optionally 
 some parameters and an optional block.
  
 connection.download_MP3(""jitterbug"") {|p| show_progress(p) }
  
 In this example, the object
  connection
  is the receiver,
  download_MP3
  is the name of the 
 method,
  ""jitterbug""
  is the parameter, and the stuff between the braces is the associated 
 block.
  
 For class and module methods, the receiver will be the class or module name.
  
 File.size(""testfile"")
  
 →
  
 66
  
 Math.sin(Math::PI/4)
  
 →
  
 0.707106781186548
  
 If you omit the receiver, it defaults to
  self
 , the current object.
  
 self.class
  
 →
  
 Object
  
 self.frozen?
  
 false
  
 →
  
 frozen?
  
 →
  
 false
  
 self.id
  
 967900
  
 →
  
 id
  
 →
  
 967900
  
 This defaulting mechanism is how Ruby implements private methods. Private 
 methods may
  not
  be called with a receiver, so they must be methods available in the 
 current object.
  
 Also, in the previous example we called
  self.class
 , but we could not call the method 
 class
  without a receiver. This is because
  class
  is also a keyword in Ruby (it intro-duces 
 class definitions), so its stand-alone use would generate a syntax error.
  
 Prepared exclusively for Yeganefar",NA
Method Return Values,"Every called method returns a value (although no rule says you have to use that 
 value). The value of a method is the value of the last statement executed during the 
 method’s execution. Ruby has a
  return
  statement, which exits from the currently 
 executing method. The value of a
  return
  is the value of its argument(s). It is idiomatic 
 Ruby to omit the
  return
  if it isn’t needed.
  
 def meth_one 
  
 ""one"" 
  
 end
  
 meth_one
  
 →
  
 ""one""
  
 def meth_two(arg) 
  
 case 
  
 when arg > 0 
  
  
 ""positive"" 
  
 when arg < 0 
  
  
 ""negative"" 
  
 else 
  
  
 ""zero"" 
  
 end 
  
 end
  
  
 meth_two(23)
  
 →
  
 ""positive""
  
 meth_two(0)
  
 →
  
 ""zero""
  
 2. 
  
 3.
  
 Other Ruby documentation sometimes calls these method calls without parentheses
  commands
 . In 
 particular, you
  must
  use parentheses on a method call that is itself a parameter to another method
  
 call (unless it is the last parameter).
  
 Prepared exclusively for Yeganefar",NA
Chapter 7,NA,NA
Expressions,"So far we’ve been fairly cavalier in our use of expressions in Ruby. After all,
  a = b + c
  
 is pretty standard stuff. You could write a whole heap of Ruby code without reading 
 any of this chapter.
  
 But it wouldn’t be as much fun
  ;-)
 .
  
 One of the first differences with Ruby is that anything that can reasonably return a 
 value does: just about everything is an expression. What does this mean in practice?
  
 Some obvious things include the ability to chain statements together.
  
 a = b = c = 0
  
 →
  
 0
  
 [ 3, 1, 7, 0 ].sort.reverse
  
 →
  
 [7, 3, 1, 0]
  
 Perhaps less obvious, things that are normally statements in C or Java are expressions 
 in Ruby. For example, the
  if
  and
  case
  statements both return the value of the last 
 expression executed.
  
 song_type = if song.mp3_type == MP3::Jazz 
  
  
  
 if song.written < Date.new(1935, 1, 1) 
  
  
 Song::TradJazz 
  
  
  
 else 
  
  
  
 Song::Jazz 
  
  
  
 end 
  
  
 else 
  
  
  
 Song::Other 
  
  
 end
  
 rating = case votes_cast 
  
 when 0...10 
  
 then Rating::SkipThisOne when 10...50 
  
 then 
 Rating::CouldDoBetter else 
  
  
 Rating::Rave 
  
 end
  
 We’ll talk more about
  if
  and
  case
  starting on page
  90
 .
  
 Prepared exclusively for Yeganefar 
  
 81",NA
Operator Expressions,"Ruby has the basic set of operators (+, -, *, /, and so on) as well as a few surprises. A 
 complete list of the operators, and their precedences, is given in Table
  22.4
  on page
  
 324
 .
  
 In Ruby, many operators are actually implemented as method calls. For example, 
 when you write
  a*b + c
  you’re actually asking the object referenced by
  a
  to execute the 
 method
  *
  , passing in the parameter
  b
 . You then ask the object that results from that 
 calculation to execute the
  +
  method, passing
  c
  as a parameter. This is equivalent to 
 writing
  
 (a.*(b)).+(c)
  
 Because everything is an object, and because you can redefine instance methods, you 
 can always redefine basic arithmetic if you don’t like the answers you’re getting.
  
 class Fixnum 
  
 alias old_plus +
  
 # Redefine addition of Fixnums. This 
  
 # is a BAD IDEA!
  
 def +(other) 
  
  
 old_plus(other).succ 
  
 end 
  
 end
  
 1 + 2
  
 →
  
 4
  
 a = 3
  
 a += 4
  
 →
  
 8
  
 a + a + a
  
 26
  
 →
  
 More useful is that classes you write can participate in operator expressions just as if 
 they were built-in objects. For example, we may want to be able to extract a number 
 of seconds of music from the middle of a song. We could do this using the indexing 
 operator
  [ ]
  to specify the music to be extracted.
  
 class Song
  
 def [](from_time, to_time) 
  
 result = Song.new(self.title + "" [extract]"", 
  
   
 self.artist, 
  
   
 to_time - from_time) 
  
 result.set_start_time(from_time)
  
 result 
  
 end
  
 end
  
 This code fragment extends class
  Song
  with the method
  [ ]
 , which takes two 
 parameters (a start time and an end time). It returns a new song, with the music 
 clipped to the given interval. We could then play the introduction to a song with code 
 such as
  
 song[0, 15].play",NA
Miscellaneous Expressions,"As well as the obvious operator expressions and method calls, and the (perhaps) less 
 obvious statement expressions (such as
  if
  and
  case
 ), Ruby has a few more things that 
 you can use in expressions.",NA
Command Expansion,"If you enclose a string in backquotes (sometimes called backticks), or use the 
 delimited form prefixed by
  %x
 , it will (by default) be executed as a command by your 
 underlying operating system. The value of the expression is the standard output of 
 that command. Newlines will not be stripped, so it is likely that the value you get 
 back will have a trailing return or linefeed character.
  
 `date`
  
 →
  
 ""Thu Aug 26 22:36:31 CDT 2004\n""
  
 `ls`.split[34]
  
 →
  
 ""book.out""
  
 %x{echo ""Hello there""}
  
 ""Hello there\n""
  
 →
  
 You can use expression expansion and all the usual escape sequences in the command 
 string.
  
 for i in 0..3 
  
 status = `dbmanager status id=#{i}` 
  
 # ...
  
 end
  
 The exit status of the command is available in the global variable
  $?
 .
  
 Redefining Backquotes
  
 In the description of the command output expression, we said that the string in back-
 quotes would “by default” be executed as a command. In fact, the string is passed to 
 the method called
  Kernel.`
  (a single backquote). If you want, you can override this.
  
 alias old_backquote ` 
  
 def `(cmd) 
  
 result = old_backquote(cmd) 
  
 if $? != 0 
  
  
 fail ""Command #{cmd} failed: #$?"" 
  
 end 
  
 result 
  
 end 
  
 print `date` 
  
 print `data`
  
 produces:
  
 Thu Aug 26 22:36:31 CDT 2004 
  
 prog.rb:10: command not found: data 
  
 prog.rb:5:in ``': Command data failed: 32512 (RuntimeError) from prog.rb:10
  
 Prepared exclusively for Yeganefar",NA
Assignment,"Just about every example we’ve given so far in this book has featured assignment. 
 Perhaps it’s about time we said something about it.
  
 An assignment statement sets the variable or attribute on its left side (the
  lvalue
 ) to 
 refer to the value on the right (the
  rvalue
 ). It then returns that value as the result of 
 the assignment expression. This means you can chain assignments, and you can 
 perform assignments in some unexpected places.
  
 a = b = 1 + 2 + 3
  
 a
  
 →
  
 6
  
 b
  
 →
  
 6
  
 a = (b = 1 + 2) + 3
  
 a
  
 →
  
 6
  
 b
  
 →
  
 3
  
 File.open(name = gets.chomp)
  
 Ruby has two basic forms of assignment. The first assigns an object reference to a 
 variable or constant. This form of assignment is hardwired into the language.
  
 instrument = ""piano"" 
  
 MIDDLE_A = 440
  
 The second form of assignment involves having an object attribute or element 
 reference on the left side.
  
 song.duration = 234 
  
 instrument[""ano""] = ""ccolo""
  
 These forms are special, because they are implemented by calling methods in the 
 lvalues, which means you can override them.
  
 We’ve already seen how to define a writable object attribute. Simply define a method 
 name ending in an equals sign. This method receives as its parameter the 
 assignment’s rvalue.
  
 class Song 
  
 def duration=(new_duration) 
  
  
 @duration = new_duration 
  
 end 
  
 end
  
 These attribute-setting methods don’t have to correspond with internal instance vari-
 ables, and you don’t need an attribute reader for every attribute writer (or vice versa).
  
 class Amplifier 
  
 def volume=(new_volume) 
  
  
 self.left_channel = self.right_channel = new_volume 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Parallel Assignment,"During your first week in a programming course (or the second semester if it was a 
 party school), you may have had to write code to swap the values in two variables.
  
 int a = 1; 
  
 int b = 2; 
  
 int temp;
  
 temp = a; 
  
 a = b; 
  
 b = temp;
  
 You can do this much more cleanly in Ruby.
  
 a, b = b, a
  
 Ruby assignments are effectively performed in parallel, so the values assigned are not 
 affected by the assignment itself. The values on the right side are evaluated in the 
 order in which they appear before any assignment is made to variables or attributes 
 on the left. A somewhat contrived example illustrates this. The second line assigns to 
 the variables 
 a
 ,
  b
 , and
  c
  the values of the expressions
  x
 ,
  x += 1
 , and
  x += 1
 , respectively.
  
 x = 0
  
 =
  
 x, (x += 1), (x += 1)
  
 →
  
 0
  
 a, b, c
  
 →
  
 [0, 1, 2]
  
 When an assignment has more than one lvalue, the assignment expression returns an 
 array of the rvalues. If an assignment contains more lvalues than rvalues, the excess 
 lvalues are set to
  nil
 . If a multiple assignment contains more rvalues than lvalues, the 
 extra rvalues are ignored. If an assignment has just one lvalue and multiple rvalues, 
 the rvalues are converted to an array and assigned to the lvalue.
  
 Prepared exclusively for Yeganefar",NA
Other Forms of Assignment,"In common with many other languages, Ruby has a syntactic shortcut:
  a = a + 2
  may be 
 written as
  a += 2
 .
  
 The second form is converted internally to the first. This means that operators you have 
 defined as methods in your own classes work as you’d expect.
  
 class Bowdlerize 
  
 def initialize(string) 
  
  
 @value = string.gsub(/[aeiou]/, '*') 
  
 end 
  
 def +(other) 
  
  
 Bowdlerize.new(self.to_s + other.to_s) 
  
 end 
  
 def to_s 
  
  
 @value 
  
 end 
  
 end
  
 a = Bowdlerize.new(""damn "")
  
 →
  
 d*mn
  
 a += ""shame""
  
 →
  
 d*mn sh*m*
  
 Something you won’t find in Ruby are the autoincrement (++) and autodecrement (--) 
 operators of C and Java. Use the
  +=
  and
 -=
  forms instead.",NA
Conditional Execution,"Ruby has several different mechanisms for conditional execution of code; most of 
 them should feel familiar, and many have some neat twists. Before we get into them, 
 though, we need to spend a short time looking at boolean expressions.",NA
Boolean Expressions,"Ruby has a simple definition of truth. Any value that is not
  nil
  or the constant
  false 
 is 
 true. You’ll find that the library routines use this fact consistently. For example, 
 IO
 #
 gets
 , which returns the next line from a file, returns
  nil
  at end of file, enabling you 
 to write loops such as
  
 Prepared exclusively for Yeganefar",NA
The Value of Logical Expressions,"In the text, we said things such as “
 and
  evaluates to true if both operands are true.” 
 But it’s actually slightly more subtle than that. The operators
  and
 ,
  or
 ,
  &&
  and
  ||
  
 actually return the first of their arguments that determine the truth or falsity of the 
 condition. Sounds grand. What does it mean?
  
 Take the expression “
 val1 and val2
 ”. If
  val1
  is either
  false
  or
  nil
 , then we know the 
 expression cannot be true. In this case, the value of
  val1
  determines the overall value 
 of the expression, so it is the value returned. If
  val1
  has some other value, then the 
 overall value of the expression depends on
  val2
 , so its value is returned.
  
 Prepared exclusively for Yeganefar",NA
If and Unless Expressions,"An
  if
  expression in Ruby is pretty similar to “if” statements in other languages.
  
 if song.artist == ""Gillespie"" then 
  
 handle = ""Dizzy"" 
  
 elsif song.artist == ""Parker"" then 
  
 handle = ""Bird"" 
  
 else 
  
 handle = ""unknown"" 
  
 end
  
 If you lay out your
  if
  statements on multiple lines, you can leave off the
  then
  keyword.
  
 if song.artist == ""Gillespie"" 
  
 handle = ""Dizzy"" 
  
 elsif song.artist == ""Parker"" 
  
 handle = ""Bird"" 
  
 else 
  
 handle = ""unknown"" 
  
 end
  
 However, if you want to lay out your code more tightly, you can separate the boolean 
 expression from the following statements with the
  then
  keyword.
  
 Prepared exclusively for Yeganefar",NA
Case Expressions,"The Ruby
  case
  expression is a powerful beast: a multiway
  if
  on steroids. And just to 
 make it even more powerful, it comes in two flavors.
  
 The first form is fairly close to a series of
  if
  statements: it lets you list a series of con-
 ditions and execute a statement corresponding to the first one that’s true. For 
 example, leap years must be divisible by 400, or divisible by 4 and not by 100.
  
 leap = case 
  
 when year % 400 == 0: true 
  
 when year % 100 == 0: false 
  
 else year % 4 
  
 == 0 
  
 end
  
 The second form of the
  case
  statement is probably more common. You specify a target 
 at the top of the
  case
  statement, and each
  when
  clause lists one or more comparisons.
  
 case input_line
  
 when ""debug"" 
  
 dump_debug_info 
  
 dump_symbols
  
 when /p\s+(\w+)/ 
  
 dump_variable($1)
  
 when ""quit"", ""exit"" 
  
 exit
  
 else 
  
 print ""Illegal command: #{input_line}"" 
  
 end
  
 As with
  if
 ,
  case
  returns the value of the last expression executed, and you can use a 
 then
  
 keyword if the expression is on the same line as the condition.
  
 Prepared exclusively for Yeganefar",NA
Loops,"Don’t tell anyone, but Ruby has pretty primitive built-in looping constructs.
  
 The
  while
  loop executes its body zero or more times as long as its condition is true. For 
 example, this common idiom reads until the input is exhausted.
  
 while line = gets 
  
 # ...
  
 end
  
 The
  until
  loop is the opposite; it executes the body
  until
  the condition becomes true.
  
 until play_list.duration > 60 
  
 play_list.add(song_list.pop) 
  
 end
  
 As with
  if
  and
  unless
 , you can use both of the loops as statement modifiers.
  
 a = 1 
  
 a *= 2 while a < 100 
  
 a -= 10 until a < 100
  
 a
  
 →
  
 98
  
 On page
  89
  in the section on boolean expressions, we said that a range can be used as 
 a kind of flip-flop, returning true when some event happens and then staying true 
 until a second event occurs. This facility is normally used within loops. In the 
 example that follows, we read a text file containing the first ten ordinal numbers 
 (“first,” “second,”and so on) but print only the lines starting with the one that matches 
 “third” and ending with the one that matches “fifth.”
  
 file = File.open(""ordinal"") 
  
 while line = file.gets 
  
 puts(line) 
  
 if line =~ /third/ .. line =~ /fifth/ 
  
 end
  
 produces:
  
 third 
  
 fourth 
  
 fifth
  
 You may find folks who come from Perl writing the previously example slightly differ-
 ently.
  
 file = File.open(""ordinal"") 
  
 while file.gets 
  
 print if ~/third/ .. ~/fifth/ 
  
 end
  
 produces:
  
 third 
  
 fourth 
  
 fifth
  
 Prepared exclusively for Yeganefar",NA
Iterators,"If you read the beginning of the previous section, you may have been 
 discouraged.“Ruby has pretty primitive built-in looping constructs,” it said. Don’t 
 despair, gentle reader, for we have good news. Ruby doesn’t need any sophisticated 
 built-in loops, because all the fun stuff is implemented using Ruby iterators.
  
 For example, Ruby doesn’t have a “for” loop—at least not the kind you’d find in C, 
 C++, and Java. Instead, Ruby uses methods defined in various built-in classes to 
 provide equivalent, but less error-prone, functionality.
  
 Let’s look at some examples.
  
 Prepared exclusively for Yeganefar",NA
For . . . In,"Earlier we said that the only built-in Ruby looping primitives were
  while
  and
  until
 . 
 What’s this
  for
  thing, then? Well,
  for
  is almost a lump of syntactic sugar. When you 
 write
  
 for song in songlist 
  
 song.play 
  
 end
  
 Ruby translates it into something like
  
 songlist.each do |song| 
  
 song.play 
  
 end
  
 The only difference between the
  for
  loop and the
  each
  form is the scope of local 
 variables that are defined in the body. This is discussed on page
  99
 .
  
 You can use
  for
  to iterate over any object that responds to the method
  each
 , such as an
  
 Array
  or a
  Range
 .
  
 for i in ['fee', 'fi', 'fo', 'fum'] 
  
 print i, "" "" 
  
 end 
  
 for i in 1..3 
  
 print i, "" "" 
  
 end 
  
 for i in File.open(""ordinal"").find_all {|line| line =~ /d$/} print i.chomp, "" "" 
  
 end
  
 produces:
  
 fee fi fo fum 1 2 3 second third
  
 As long as your class defines a sensible
  each
  method, you can use a
  for
  loop to traverse 
 its objects.
  
 class Periods 
  
 def each 
  
  
 yield ""Classical"" 
  
  
 yield ""Jazz"" 
  
  
 yield ""Rock"" 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
"Break, Redo, and Next","The loop control constructs
  break
 ,
  redo
 , and
  next
  let you alter the normal flow through a 
 loop or iterator.
  
 break
  terminates the immediately enclosing loop; control resumes at the statement 
 following the block.
  redo
  repeats the loop from the start, but without reevaluating the 
 condition or fetching the next element (in an iterator).
  next
  skips to the end of the 
 loop, effectively starting the next iteration.
  
 while line = gets 
  
 next if line =~ /^\s*#/ 
  
 # skip comments 
  
 break if line =~ /^END/ 
  
 # stop at end 
  
   
 # substitute stuff in backticks and try again redo if 
 line.gsub!(/`(.*?)`/) { eval($1) } 
  
 # process line ...
  
 end
  
 These keywords can also be used with any of the iterator-based looping mechanisms.
  
 i=0 
  
 loop do 
  
 i += 1 
  
 next if i < 3 
  
 print i 
  
 break if i > 4 
  
 end
  
 produces:
  
 345
  
 1.8
  
  
 As of Ruby 1.8,
  
 break
  and
  next
  can be given arguments. When used in conventional
  
 loops, it probably makes sense only to do this with
  break
  (as any value given to
  next 
 is 
 effectively lost). If a conventional loop doesn’t execute a
  break
 , its value is
  nil
 .
  
 result = while line = gets 
  
  
 break(line) if line =~ /answer/ 
  
 end
  
 process_answer(result) if result
  
 If you want the nitty-gritty detail of how
  break
  and
  next
  work with blocks and procs, 
 have a look at the reference description starting on page
  343
 . If you are looking for a
  
 Prepared exclusively for Yeganefar",NA
Retry,"The
  redo
  statement causes a loop to repeat the current iteration. Sometimes, though, 
 you need to wind the loop right back to the very beginning. The
  retry
  statement is just 
 the ticket.
  retry
  restarts any kind of iterator loop.
  
 for i in 1..100 
  
 print ""Now at #{i}. Restart? "" 
  
 retry if gets =~ /^y/i 
  
 end
  
 Running this interactively, you may see
  
 Now at 1. Restart? n 
  
 Now at 2. Restart? y 
  
 Now at 1. Restart? n 
  
 . . .
  
 retry
  will reevaluate any arguments to the iterator before restarting it. Here’s an exam-
 ple of a do-it-yourself
  until
  loop.
  
 def do_until(cond) 
  
 break if cond 
  
 yield 
  
 retry 
  
 end
  
 i = 0
  
 do_until(i > 10) do 
  
 print i, "" "" 
  
 i += 1 
  
 end
  
 produces:
  
 0 1 2 3 4 5 6 7 8 9 10",NA
"Variable Scope, Loops, and Blocks","The
  while
 ,
  until
 , and
  for
  loops are built into the language and do not introduce new 
 scope; previously existing locals can be used in the loop, and any new locals created 
 will be available afterward.
  
 The blocks used by iterators (such as
  loop
  and
  each
 ) are a little different. Normally, the 
 local variables created in these blocks are not accessible outside the block.
  
 Prepared exclusively for Yeganefar",NA
Chapter 8,NA,NA
"Exceptions,",NA,NA
"Catch, and Throw","So far we’ve been developing code in Pleasantville, a wonderful place where nothing 
 ever, ever goes wrong. Every library call succeeds, users never enter incorrect data, 
 and resources are plentiful and cheap. Well, that’s about to change. Welcome to the 
 real world!
  
 In the real world, errors happen. Good programs (and programmers) anticipate them 
 and arrange to handle them gracefully. This isn’t always as easy as it may sound. 
 Often the code that detects an error does not have the context to know what to do 
 about it. For example, attempting to open a file that doesn’t exist is acceptable in 
 some circum-stances and is a fatal error at other times. What’s your file-handling 
 module to do?
  
 The traditional approach is to use return codes. The
  open
  method returns some 
 specific value to say it failed. This value is then propagated back through the layers 
 of calling routines until someone wants to take responsibility for it.
  
 The problem with this approach is that managing all these error codes can be a pain. 
 If a function calls
  open
 , then
  read
 , and finally
  close
 , and each can return an error 
 indication, how can the function distinguish these error codes in the value it returns to 
 its
  caller?
  
 To a large extent, exceptions solve this problem. Exceptions let you package informa-
 tion about an error into an object. That exception object is then propagated back up 
 the calling stack automatically until the runtime system finds code that explicitly 
 declares that it knows how to handle that type of exception.",NA
The Exception Class,"The package that contains the information about an exception is an object of class 
 Exception
  or one of class
  Exception
 ’s children. Ruby predefines a tidy hierarchy of",NA
Handling Exceptions,"Our jukebox downloads songs from the Internet using a TCP socket. The basic code is 
 simple (assuming that the filename and the socket are already set up).
  
 op_file = File.open(opfile_name, ""w"") 
  
 while data = socket.read(512) 
  
 op_file.write(data) 
  
 end
  
 What happens if we get a fatal error halfway through the download? We certainly don’t 
 want to store an incomplete song in the song list. “I Did It My *click*.”
  
 Let’s add some exception-handling code and see how it helps. To do exception han-
 dling, we enclose the code that could raise an exception in a
  begin
 /
 end
  block and use 
 one or more
  rescue
  clauses to tell Ruby the types of exceptions we want to handle. In 
 this particular case we’re interested in trapping
  SystemCallError
  exceptions (and, by 
 implication, any exceptions that are subclasses of
  SystemCallError
 ), so that’s what 
 appears on the
  rescue
  line. In the error-handling block, we report the error, close and 
 delete the output file, and then reraise the exception.
  
 op_file = File.open(opfile_name, ""w"") 
  
 begin 
  
 # Exceptions raised by this code will 
  
 # be caught by the following rescue clause 
  
 while data = socket.read(512) 
  
  
 op_file.write(data) 
  
 end
  
 rescue SystemCallError 
  
 $stderr.print ""IO failed: "" + $!
  
 op_file.close 
  
 File.delete(opfile_name) 
  
 raise 
  
 end
  
 When an exception is raised, and independent of any subsequent exception handling, 
 Ruby places a reference to the associated
  Exception
  object into the global variable
  $!
  
 Prepared exclusively for Yeganefar",NA
System Errors,"System errors are raised when a call to the operating system returns an error code. On 
 POSIX systems, these errors have names such as
  EAGAIN
  and
  EPERM
 . (If you’re on a 
 Unix box, you could type
  man errno
  to get a list of these errors.)
  
 Ruby takes these errors and wraps them each in a specific exception object. Each is a 
 subclass of
  SystemCallError
 , and each is defined in a module called
  Errno
 . This means 
 you’ll find exceptions with class names such as
  Errno::EAGAIN
 ,
  Errno::EIO
 , and
  
 Errno::EPERM
 . If you want to get to the underlying system error code,
  Errno 
 exception 
 objects each have a class constant called (somewhat confusingly)
  Errno
  that contains 
 the value.
  
 1.
  
 This comparison happens because exceptions are classes, and classes in turn are kinds of
  Module
 . The
  
 ===
  method is defined for modules, returning
  true
  if the class of the operand is the same as or an ancestor of 
 the receiver.",NA
Tidying Up,"Sometimes you need to guarantee that some processing is done at the end of a block 
 of code, regardless of whether an exception was raised. For example, you may have a 
 file open on entry to the block, and you need to make sure it gets closed as the block 
 exits.
  
 The
  ensure
  clause does just this.
  ensure
  goes after the last
  rescue
  clause and contains a 
 chunk of code that will always be executed as the block terminates. It doesn’t matter 
 if the block exits normally, if it raises and rescues an exception, or if it is terminated 
 by an uncaught exception—the
  ensure
  block will get run.
  
 f = File.open(""testfile"") 
  
 begin 
  
 # .. process 
  
 rescue 
  
 # .. handle error 
  
 ensure 
  
 f.close unless f.nil?
  
 end
  
 The
  else
  clause is a similar, although less useful, construct. If present, it goes after the 
 rescue
  clauses and before any
  ensure
 . The body of an
  else
  clause is executed only if no 
 exceptions are raised by the main body of code.
  
 f = File.open(""testfile"") 
  
 begin 
  
 # .. process 
  
 rescue 
  
 # .. handle error 
  
 else 
  
 puts ""Congratulations-- no errors!"" 
  
 ensure 
  
 f.close unless f.nil?
  
 end",NA
Play It Again,"Sometimes you may be able to correct the cause of an exception. In those cases, you 
 can use the
  retry
  statement within a
  rescue
  clause to repeat the entire
  begin
 /
 end 
 block. 
 Clearly, tremendous scope exists for infinite loops here, so this is a feature to use 
 with caution (and with a finger resting lightly on the interrupt key).
  
 As an example of code that retries on exceptions, have a look at the following, adapted 
 from Minero Aoki’s
  net/smtp.rb
  library.
  
 @esmtp = true
  
 begin 
  
 # First try an extended login. If it fails because the 
  
 # server doesn't support it, fall back to a normal login
  
 if @esmtp then 
  
 @command.ehlo(helodom) 
  
 else 
  
 @command.helo(helodom) 
  
 end
  
 rescue ProtocolError 
  
 if @esmtp then 
  
  
 @esmtp = false 
  
  
 retry 
  
 else 
  
  
 raise 
  
 end 
  
 end
  
 This code tries first to connect to an SMTP server using the
  EHLO
  command, which is 
 not universally supported. If the connection attempt fails, the code sets the
  @esmtp 
 variable to
  false
  and retries the connection. If this fails a second time, the exception is 
 raised up to the caller.",NA
Raising Exceptions,"So far we’ve been on the defensive, handling exceptions raised by others. It’s time to 
 turn the tables and go on the offensive. (Some say your gentle authors are always 
 offensive, but that’s a different book.)
  
 You can raise exceptions in your code with the
  Kernel.raise
  method (or its somewhat 
 judgmental synonym,
  Kernel.fail
 ).
  
 raise 
  
 raise ""bad mp3 encoding"" 
  
 raise InterfaceException, ""Keyboard failure"", caller
  
 Prepared exclusively for Yeganefar",NA
Adding Information to Exceptions,"You can define your own exceptions to hold any information that you need to pass 
 out from the site of an error. For example, certain types of network errors may be 
 transient depending on the circumstances. If such an error occurs, and the 
 circumstances are right, you could set a flag in the exception to tell the handler that it 
 may be worth retrying the operation.
  
 class RetryException < RuntimeError 
  
 attr :ok_to_retry 
  
 def initialize(ok_to_retry) 
  
  
 @ok_to_retry = ok_to_retry 
  
 end 
  
 end
  
 2.
  
 Technically, this argument can be any object that responds to the message
  exception
  by returning an
  
 object such that
  object.kind_of?(Exception)
  is true.
  
 Prepared exclusively for Yeganefar",NA
Catch and Throw,"While the exception mechanism of
  raise
  and
  rescue
  is great for abandoning execu-tion 
 when things go wrong, it’s sometimes nice to be able to jump out of some deeply 
 nested construct during normal processing. This is where
  catch
  and
  throw
  come in 
 handy.
  
 catch (:done) do 
  
 while line = gets 
  
  
 throw :done unless fields = line.split(/\t/) 
  
  
 songlist.add(Song.new(*fields)) 
  
 end 
  
 songlist.play 
  
 end
  
 catch
  defines a block that is labeled with the given name (which may be a
  Symbol
  or a
  
 String
 ). The block is executed normally until a
  throw
  is encountered.
  
 When Ruby encounters a
  throw
 , it zips back up the call stack looking for a
  catch 
 block 
 with a matching symbol. When it finds it, Ruby unwinds the stack to that point and 
 terminates the block. So, in the previous example, if the input does not contain 
 correctly formatted lines, the
  throw
  will skip to the end of the corresponding
  catch
 , not 
 only terminating the
  while
  loop but also skipping the playing of the song list. If the 
 throw
  is called with the optional second parameter, that value is returned as the value 
 of the
  catch
 .
  
 The following example uses a
  throw
  to terminate interaction with the user if
  !
  is typed 
 in response to any prompt.
  
 Prepared exclusively for Yeganefar",NA
Chapter 9,NA,NA
Modules,"Modules are a way of grouping together methods, classes, and constants. Modules give 
 you two major benefits.
  
 1. Modules provide a namespace and prevent name clashes.
  
 2. Modules implement the mixin facility.",NA
Namespaces,"As you start to write bigger and bigger Ruby programs, you’ll naturally find your-self 
 producing chunks of reusable code—libraries of related routines that are generally 
 applicable. You’ll want to break this code into separate files so the contents can be 
 shared among different Ruby programs.
  
 Often this code will be organized into classes, so you’ll probably stick a class (or a set 
 of interrelated classes) into a file.
  
 However, there are times when you want to group things together that don’t naturally 
 form a class.
  
 An initial approach may be to put all these things into a file and simply load that file 
 into any program that needs it. This is the way the C language works. However, this 
 approach has a problem. Say you write a set of the trigonometry functions
  sin
 ,
  cos
 , 
 and so on. You stuff them all into a file,
  trig.rb
 , for future generations to enjoy. 
 Meanwhile, Sally is working on a simulation of good and evil, and she codes a set of 
 her own useful routines, including
  be_good
  and
  sin
 , and sticks them into
  moral.rb
 . Joe, 
 who wants to write a program to find out how many angels can dance on the head of 
 a pin, needs to load both
  trig.rb
  and
  moral.rb
  into his program. But both define a 
 method called
  sin
 . Bad news.
  
 Prepared exclusively for Yeganefar 
 110",NA
Mixins,"Modules have another, wonderful use. At a stroke, they pretty much eliminate the need 
 for multiple inheritance, providing a facility called a
  mixin
 .
  
 In the previous section’s examples, we defined module methods, methods whose 
 names were prefixed by the module name. If this made you think of class methods, 
 your next thought may well be “what happens if I define instance methods within a 
 module?”",NA
Iterators and the Enumerable Module,"You’ve probably noticed that the Ruby collection classes support a large number of 
 operations that do various things with the collection: traverse it, sort it, and so on. 
 You may be thinking, “Gee, it’d sure be nice if
  my
  class could support all these neat-o 
 features, too!” (If you actually thought that, it’s probably time to stop watching reruns 
 of 1960s television shows.)
  
 Well, your classes
  can
  support all these neat-o features, thanks to the magic of mixins 
 and module
  Enumerable
 . All you have to do is write an iterator called
  each
 , which 
 returns the elements of your collection in turn. Mix in
  Enumerable
 , and suddenly your 
 class supports things such as
  map
 ,
  include?
 , and
  find_all?
 . If the objects in your 
 collection implement meaningful ordering semantics using the
  <=>
  method, you’ll 
 also get methods such as
  min
 ,
  max
 , and
  sort
 .",NA
Composing Modules,"Back on page
  49
  we discussed the
  inject
  method of
  Enumerable
 .
  Enumerable
  is another 
 standard mixin, implementing a bunch of methods in terms of the host class’s
  
 Prepared exclusively for Yeganefar",NA
Instance Variables in Mixins,"People coming to Ruby from C++ often ask us, “What happens to instance variables 
 in a mixin? In C++, I have to jump through some hoops to control how variables are 
 shared in a multiple-inheritance hierarchy. How does Ruby handle this?”
  
 Well, for starters, it’s not really a fair question, we tell them. Remember how instance 
 variables work in Ruby: the first mention of an
  @
 -prefixed variable creates the 
 instance variable
  in the current object,
  self
 .
  
 For a mixin, this means that the module you mix into your client class (the
  mixee?
 ) 
 may create instance variables in the client object and may use
  attr_reader
  and friends 
 to define accessors for these instance variables. For instance, the
  Observable
  module in 
 the following example adds an instance variable
  @observer_list
  to any class that 
 includes it.
  
 module Observable 
  
 def observers 
  
  
 @observer_list ||= [] 
  
 end
  
 def add_observer(obj) 
  
 observers << obj 
  
 end
  
 def notify_observers 
  
  
 observers.each {|o| o.update } 
  
 end 
  
 end
  
 However, this behavior exposes us to a risk. A mixin’s instance variables can clash 
 with those of the host class or with those of other mixins. The example that follows 
 shows a class that uses our
  Observer
  module but that unluckily also uses an instance 
 variable called
  @observer_list
 . At runtime, this program will go wrong in some hard-
 to-diagnose ways.
  
 class TelescopeScheduler
  
 # other classes can register to get notifications 
  
 # when the schedule changes 
  
 include Observable
  
 def initialize 
  
 @observer_list = [] 
  
 # folks with telescope time 
  
 end
  
 def add_viewer(viewer) 
  
 @observer_list << viewer 
  
 end
  
 # ... 
  
 end
  
 For the most part, mixin modules don’t try to carry their own instance data around—
 they use accessors to retrieve data from the client object. But if you need to create
  
 Prepared exclusively for Yeganefar",NA
Resolving Abmiguous Method Names,"One of the other questions folks ask about mixins is, how is method lookup handled? 
 In particular, what happens if methods with the same name are defined in a class, in 
 that class’s parent class, and in a mixin included into the class?
  
 The answer is that Ruby looks first in the immediate class of an object, then in the 
 mixins included into that class, and then in superclasses and their mixins. If a class 
 has multiple modules mixed in, the last one included is searched first.",NA
Including Other Files,"Because Ruby makes it easy to write good, modular code, you’ll often find yourself 
 producing small files containing some chunk of self-contained functionality—an 
 inter-face to
  x
 , an algorithm to do
  y
 , and so on. Typically, you’ll organize these files 
 as class or module libraries.
  
 Prepared exclusively for Yeganefar",NA
Chapter 10,NA,NA
Basic Input and Output,"Ruby provides what at first sight looks like two separate sets of I/O routines. The first 
 is the simple interface—we’ve been using it pretty much exclusively so far.
  
 print ""Enter your name: "" 
  
 name = gets
  
 A whole set of I/O-related methods is implemented in the
  Kernel
  module—
 gets
 , 
 open
 ,
  
 print
 ,
  printf
 ,
  putc
 ,
  puts
 ,
  readline
 ,
  readlines
 , and
  test
 —that makes it simple and 
 convenient to write straightforward Ruby programs. These methods typi-cally do I/O 
 to standard input and standard output, which makes them useful for writing filters. 
 You’ll find them documented starting on page
  495
 .
  
 The second way, which gives you a lot more control, is to use
  IO
  objects.",NA
What Is an IO Object?,"Ruby defines a single base class,
  IO
 , to handle input and output. This base class is 
 subclassed by classes
  File
  and
  BasicSocket
  to provide more specialized behavior, but 
 the principles are the same. An
  IO
  object is a bidirectional channel between a Ruby 
 program and some external resource.
 1
 An
  IO
  object may have more to it than meets the 
 eye, but in the end you still simply write to it and read from it.
  
 In this chapter, we’ll be concentrating on class
  IO
  and its most commonly used 
 subclass, class
  File
 . For more details on using the socket classes for networking, see 
 the section beginning on page
  740
 .
  
 1.
  
 For those who just have to know the implementation details, this means that a single
  IO
  object can
  
 sometimes be managing more than one operating system file descriptor. For example, if you open a pair of 
 pipes, a single
  IO
  object contains both a read pipe and a write pipe.
  
 Prepared exclusively for Yeganefar 
 119",NA
Opening and Closing Files,"As you may expect, you can create a new file object using
  File.new
 .
  
 file = File.new(""testfile"", ""r"") 
  
 # ... process the file 
  
 file.close
  
 You can create a
  File
  object that is open for reading, writing, or both, according to the 
 mode string. (Here we opened
  testfile
  for reading with an
  ""r""
 . We could also have used
  
 ""w""
  for write or
  ""rw""
  for read-write. The full list of allowed modes appears on page
  
 483
 .) You can also optionally specify file permissions when creating a file; see the 
 description of
  File.new
  on page
  449
  for details. After opening the file, we can work 
 with it, writing and/or reading data as needed. Finally, as responsible software 
 citizens, we close the file, ensuring that all buffered data is written and that all related 
 resources are freed.
  
 But here Ruby can make life a little bit easier for you. The method
  File.open
  also 
 opens a file. In regular use, it behaves just like
  File.new
 . However, if a block is asso-
 ciated with the call,
  open
  behaves differently. Instead of returning a new
  File
  object, it 
 invokes the block, passing the newly opened
  File
  as a parameter. When the block 
 exits, the file is automatically closed.
  
 File.open(""testfile"", ""r"") do |file| 
  
 # ... process the file 
  
 end
  
 This second approach has an added benefit. In the earlier case, if an exception is 
 raised while processing the file, the call to
  file.close
  may not happen. Once the file 
 variable goes out of scope, then garbage collection will eventually close it, but this 
 may not happen for a while. Meanwhile, resources are being held open.
  
 This doesn’t happen with the block form of
  File.open
 . If an exception is raised inside 
 the block, the file is closed before the exception is propagated on to the caller. It’s as 
 if the
  open
  method looks like the following.
  
 class File 
  
 def File.open(*args) 
  
  
 result = f = File.new(*args) 
  
  
 if block_given?
  
  
 begin 
  
   
 result = yield f 
  
  
 ensure 
  
   
 f.close 
  
  
 end 
  
 end
  
  
 return result 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Reading and Writing Files,"The same methods that we’ve been using for “simple” I/O are available for all file 
 objects. So,
  gets
  reads a line from standard input (or from any files specified on the 
 command line when the script was invoked), and
  file.gets
  reads a line from the file 
 object
  file
 .
  
 For example, w could create a program called
  copy.rb
 .
  
 while line = gets 
  
 puts line 
  
 end
  
 If we run this program with no arguments, it will read lines from the console and copy 
 them back to the console. Note that each line is echoed once the return key is pressed.
  
 (In this and later examples, we show user input in a bold font.)
  
 %
  ruby copy.rb 
  
 These are lines 
  
 These are lines 
  
 that I am typing 
  
 that I am typing 
  
 ^D
  
 We can also pass in one or more filenames on the command line, in which case
  gets 
 will read from each in turn.
  
 %
  ruby copy.rb testfile 
  
 This is line one 
  
 This is line two 
  
 This is line three 
  
 And so on...
  
 Finally, we can explicitly open the file and read from it.
  
 File.open(""testfile"") do |file| 
  
 while line = file.gets 
  
  
 puts line 
  
 end 
  
 end
  
 produces:
  
 This is line one 
  
 This is line two 
  
 This is line three 
  
 And so on...
  
 As well as
  gets
 , I/O objects enjoy an additional set of access methods, all intended to 
 make our lives easier.
  
 Prepared exclusively for Yeganefar",NA
Iterators for Reading,"As well as using the usual loops to read data from an
  IO
  stream, you can also use 
 various Ruby iterators.
  IO
 #
 each_byte
  invokes a block with the next 8-bit byte from the
  
 IO
  object (in this case, an object of type
  File
 ).
  
 File.open(""testfile"") do |file| 
  
 file.each_byte {|ch| putc ch; print ""."" } 
  
 end
  
 produces:
  
 T.h.i.s. .i.s. .l.i.n.e. .o.n.e.
  
 .T.h.i.s. .i.s. .l.i.n.e. .t.w.o.
  
 .T.h.i.s. .i.s. .l.i.n.e. .t.h.r.e.e. 
  
 .A.n.d. .s.o. .o.n.......
  
 .
  
 IO
 #
 each_line
  calls the block with each line from the file. In the next example, we’ll 
 make the original newlines visible using
  String
 #
 dump
 , so you can see that we’re not 
 cheating.
  
 File.open(""testfile"") do |file| 
  
 file.each_line {|line| puts ""Got #{line.dump}"" } 
  
 end
  
 produces:
  
 Got ""This is line one\n"" 
  
 Got ""This is line two\n"" 
  
 Got ""This is line three\n"" 
  
 Got ""And so on...\n""
  
 You can pass
  each_line
  any sequence of characters as a line separator, and it will break 
 up the input accordingly, returning the line ending at the end of each line of data. 
 That’s why you see the
  \n
  characters in the output of the previous example. In the 
 next example, we’ll use the character
  e
  as the line separator.
  
 File.open(""testfile"") do |file|
  
 file.each_line(""e"") {|line| 
  
 end
  
 produces:
  
 Got ""This is line"" 
  
 Got "" one"" 
  
 Got ""\nThis is line"" 
  
 Got "" two\nThis is line"" 
  
 Got "" thre"" 
  
 Got ""e"" 
  
 Got ""\nAnd so on...\n""
  
 puts ""Got #{ line.dump }"" }
  
 Prepared exclusively for Yeganefar",NA
Writing to Files,"So far, we’ve been merrily calling
  puts
  and
  print
 , passing in any old object and 
 trusting that Ruby will do the right thing (which, of course, it does). But what exactly 
 is
  it doing?
  
 The answer is pretty simple. With a couple of exceptions, every object you pass to
  
 puts 
 and
  print
  is converted to a string by calling that object’s
  to_s
  method. If for some 
 reason the
  to_s
  method doesn’t return a valid string, a string is created containing the 
 object’s class name and ID, something like
  #<ClassName:0x123456>
 .
  
 The exceptions are simple, too. The
  nil
  object will print as the string “nil,” and an 
 array passed to
  puts
  will be written as if each of its elements in turn were passed 
 separately to
  puts
 .
  
 What if you want to write binary data and don’t want Ruby messing with it? Well, 
 normally you can simply use
  IO
 #
 print
  and pass in a string containing the bytes to be 
 written. However, you can get at the low-level input and output routines if you really 
 want—look at the documentation for
  IO
 #
 sysread
  and
  IO
 #
 syswrite
  on page
  493
 .
  
 And how do you get the binary data into a string in the first place? The three common 
 ways are to use a literal, poke it in byte by byte, or use
  Array
 #
 pack
 .
  
 Prepared exclusively for Yeganefar",NA
Talking to Networks,"Ruby is fluent in most of the Internet’s protocols, both low-level and high-level.
  
 For those who enjoy groveling around at the network level, Ruby comes with a set of 
 classes in the socket library (documented starting on page
  740
 ). These classes give 
 you access to TCP, UDP, SOCKS, and Unix domain sockets, as well as any 
 additional socket types supported on your architecture. The library also provides 
 helper classes to make writing servers easier. Here’s a simple program that gets 
 information about the“mysql” user on our local machine using the finger protocol.
  
 require 'socket'
  
 client = TCPSocket.open('127.0.0.1', 'finger')
  
 client.send(""mysql\n"", 0) 
  
 puts client.readlines 
  
 client.close
  
 produces:
  
 # 0 means standard packet
  
 Login: mysql 
  
 Name: MySQL Server
  
 Directory: /var/empty 
  
 Never logged in. 
  
 No Mail.
  
 No Plan.
  
 Shell: /usr/bin/false
  
 At a higher level, the
  lib/net
  set of library modules provides handlers for a set of 
 application-level protocols (currently FTP, HTTP, POP, SMTP, and telnet). These are 
 documented starting on page
  677
 . For example, the following program lists the 
 images that are displayed on the Pragmatic Programmer home page.
  
 require 'net/http'
  
 h = Net::HTTP.new('www.pragmaticprogrammer.com', 80)
  
 response = h.get('/index.html', nil)
  
 if response.message == ""OK"" 
  
 puts response.body.scan(/<img src=""(.*?)""/m).uniq 
  
 end
  
 produces:
  
 images/title_main.gif 
  
 images/dot.gif 
  
 /images/Bookshelf_1.5_in_green.png 
  
 images/sk_all_small.jpg 
  
 images/new.jpg
  
 Although attractively simple, this example could be improved significantly. In 
 particu-lar, it doesn’t do much in the way of error handling. It should really report 
 “Not Found”errors (the infamous 404), and should handle redirects (which happen 
 when a web server gives the client an alternative address for the requested page).
  
 Prepared exclusively for Yeganefar",NA
Chapter 11,NA,NA
Threads and Processes,"Ruby gives you two basic ways to organize your program so that you can run 
 different parts of it “at the same time.” You can split up cooperating tasks
  within
  the 
 program, using multiple threads, or you can split up tasks between different 
 programs, using multiple processes. Let’s look at each in turn.",NA
Multithreading,"Often the simplest way to do two things at once is by using
  Ruby threads
 . These are 
 totally in-process, implemented within the Ruby interpreter. That makes the Ruby 
 threads completely portable—they don’t rely on the operating system. At the same 
 time, you don’t get certain benefits from having native threads. What does this mean?
  
 You may experience thread starvation (that’s where a low-priority thread doesn’t get 
 a chance to run). If you manage to get your threads deadlocked, the whole process 
 may grind to a halt. And if some thread happens to make a call to the operating 
 system that takes a long time to complete, all threads will hang until the interpreter 
 gets control back. Finally, if your machine has more than one processor, Ruby threads 
 won’t take advantage of that fact—because they run in one process, and in a single 
 native thread, they are constrained to run on one processor at a time.
  
 All this sounds scary. In practice, though, in many circumstances the benefits of using 
 threads far outweigh any potential problems that may occur. Ruby threads are an effi-
 cient and lightweight way to achieve parallelism in your code. You just need to 
 under-stand the underlying implementation issues and design accordingly.",NA
Creating Ruby Threads,"Creating a new thread is pretty straightforward. The code that follows is a simple 
 exam-ple. It downloads a set of Web pages in parallel. For each URL that it is asked 
 to down-load, the code creates a separate thread that handles the HTTP transaction.
  
 Prepared exclusively for Yeganefar 
 127",NA
Threads and Exceptions,"What happens if a thread raises an unhandled exception? It depends on the setting of 
 the
  abort_on_exception
  flag (documented on pages
  612
  and
  615
 ) and on the setting of 
 the interpreter’s
  debug
  flag (described on page
  168
 ).
  
 If
  abort_on_exception
  is
  false
  and the debug flag is not enabled (the default con-dition), 
 an unhandled exception simply kills the current thread—all the rest continue to run. 
 In fact, you don’t even hear about the exception until you issue a
  join
  on the thread 
 that raised it.
  
 In the following example, thread 2 blows up and fails to produce any output. However, 
 you can still see the trace from the other threads.
  
 threads = [] 
  
 4.times do |number| 
  
 threads << Thread.new(number) do |i| 
  
  
 raise ""Boom!"" if i == 2 
  
  
 print ""#{i}\n"" 
  
 end 
  
 end 
  
 threads.each {|t| t.join }
  
 produces:
  
 0 
  
 1 
  
 3 
  
 prog.rb:4: Boom! (RuntimeError) 
  
 from prog.rb:8:in `join' 
  
 from prog.rb:8 
  
 from prog.rb:8:in `each' 
  
 from prog.rb:8
  
 Prepared exclusively for Yeganefar",NA
Controlling the Thread Scheduler,"In a well-designed application, you’ll normally just let threads do their thing; building 
 timing dependencies into a multithreaded application is generally considered to be 
 bad form, as it makes the code far more complex and also prevents the thread 
 scheduler from optimizing the execution of your program.
  
 However, sometimes you need to control threads explicitly. Perhaps the jukebox has 
 a thread that displays a light show. We may need to stop it temporarily when the 
 music stops. You may have two threads in a classic producer-consumer relationship, 
 where the consumer has to pause if the producer gets backlogged.
  
 Class
  Thread
  provides a number of methods to control the thread scheduler. Invoking 
 Thread.stop
  stops the current thread, and invoking
  Thread
 #
 run
  arranges for a par-
 ticular thread to be run.
  Thread.pass
  deschedules the current thread, allowing others to 
 run, and
  Thread
 #
 join
  and
  Thread
 #
 value
  suspend the calling thread until a given thread 
 finishes.
  
 We can demonstrate these features in the following, totally pointless program. It 
 creates two child threads, t1 and t2, each of which runs an instance of class
  Chaser
 . 
 The
  chase 
 method increments a count but doesn’t let it get more than two higher than 
 the count in the other thread. To stop it getting higher, the method issues a
  
 Thread.pass
 , which allows the
  chase
  in the other thread to catch up. To make it 
 interesting (for some minor definition of
  interesting
 ), we have the threads suspend 
 themselves initially and then start a random one first.
  
 class Chaser 
  
 attr_reader :count 
  
 def initialize(name) 
  
  
 @name = name 
  
  
 @count = 0 
  
 end 
  
 def chase(other) 
  
  
 while @count < 5 
  
    
 while @count - other.count > 1 
  
    
 Thread.pass 
  
    
 end 
  
    
 @count += 1 
  
    
 print ""#@name: #{count}\n"" 
  
  
 end 
  
 end 
  
 end
  
 c1 = Chaser.new(""A"") 
  
 c2 = Chaser.new(""B"")
  
 threads = [ 
  
 Thread.new { Thread.stop; c1.chase(c2) }, 
  
 Thread.new { Thread.stop; c2.chase(c1) } 
  
 ]
  
 Prepared exclusively for Yeganefar",NA
Mutual Exclusion,"The lowest-level method of blocking other threads from running uses a global
  thread-
 critical
  condition. When the condition is set to
  true
  (using the
  Thread.critical= 
 method), 
 the scheduler will not schedule any existing thread to run. However, this does not 
 block new threads from being created and run. Certain thread operations (such as 
 stopping or killing a thread, sleeping in the current thread, and raising an exception) 
 may cause a thread to be scheduled even when in a critical section.
  
 Using
  Thread.critical=
  directly is certainly possible, but it isn’t terribly conven-ient. In 
 fact, we strongly recommend you don’t use it unless you have a black belt in 
 multithreading (and a penchant for long debugging sessions). Fortunately, Ruby 
 comes packaged with several alternatives. Right now we’ll look at one of these, the
  
 Monitor 
 library. You may also want to look at the
  Sync
  library (on page
  717
 ), the
  
 Mutex_m 
 library (beginning on page
  676
 ), and the
  Queue
  class implemented in the
  
 thread
  library (on page
  722
 ).",NA
Monitors,"While the threading primitives provide basic synchronization, they can be tricky to 
 use. Over the years, various folks have come up with higher-level alternatives. One 
 that works particularly well in object-oriented systems is the concept of a
  monitor
 .
  
 Monitors wrap an object containing some kind of resource with synchronization func-
 tions. To see them in action, let’s look at a simple counter that is accessed from two 
 threads.
  
 class Counter 
  
 attr_reader :count 
  
 def initialize 
  
  
 @count = 0 
  
  
 super 
  
 end 
  
 def tick 
  
  
 @count += 1 
  
 end 
  
 end
  
 c = Counter.new
  
 t1 = Thread.new { 10000.times { c.tick } } 
  
 t2 = Thread.new { 10000.times { c.tick } }
  
 t1.join 
  
 t2.join
  
 c.count
  
 →
  
 11319
  
 Perhaps surprisingly, the count doesn’t equal 20,000. The reason is a simple line of 
 code.
  
 @count += 1
  
 This line is actually more complex than it first appears. Within the Ruby interpreter, it 
 might break down into
  
 val = fetch_current(@count) 
  
 add 1 to val 
  
 store val back into @count
  
 Now imagine two threads executing this code at the same time. Table
  11.1
  on the 
 next page shows the thread number (
 t1
  and
  t2
 ), the code being executed, and the 
 value of the counter (which we initialize to 0).
  
 Even though our basic set of load/add/store instructions executed five times, we 
 ended up with a count of three. Because thread 1 interrupted the execution of thread 2 
 in the middle of a sequence, when thread 2 resumed it stored a stale value back into
  
 @count
 .",NA
Queues,"Most of the examples in this chapter use the
  Monitor
  class for synchronization. How-
 ever, another technique is useful, particularly when you need to synchronize work 
 between producers and consumers. The
  Queue
  class, located in the
  thread
  library, 
 implements a thread-safe queuing mechanism. Multiple threads can add and remove 
 objects from the queue, and each addition and removal is guaranteed to be atomic. 
 For an example of this, see the description of the
  thread
  library on page
  722
 .",NA
Condition Variables,"Monitors give us half of what we need, but there’s a problem. Say we have two 
 threads accessing a shared queue. One needs to add entries, and the other needs to 
 read them (perhaps the list represents songs waiting to be played on our jukebox: it 
 gets added to when customers make selections, and gets emptied as records get 
 played).
  
 We know we need to synchronize access, so we try something like
  
 require 'monitor'
  
 playlist = [] 
  
 playlist.extend(MonitorMixin)
  
 # Player thread 
  
 Thread.new do 
  
 record = nil 
  
 loop do
  
 playlist.synchronize do
  
 # < <
  
 BUG!!!
  
    
 sleep 0.1 while playlist.empty? 
  
    
 record = playlist.shift 
  
  
 end 
  
  
 play(record) 
  
 end 
  
 end
  
 # Customer request thread thread 
  
 Thread.new do 
  
 loop do 
  
  
 req = get_customer_request 
  
  
 playlist.synchronize do 
  
    
 playlist << req 
  
  
 end 
  
 end 
  
 end",NA
Running Multiple Processes,"Sometimes you may want to split a task into several process-sized chunks—or 
 perhaps you need to run a separate process that was not written in Ruby. Not a 
 problem: Ruby has a number of methods by which you may spawn and manage 
 separate processes.",NA
Spawning New Processes,"You have several ways to spawn a separate process; the easiest is to run some 
 command and wait for it to complete. You may find yourself doing this to run some 
 separate command or retrieve data from the host system. Ruby does this for you with 
 the
  system 
 and backquote (or backtick) methods.
  
 system(""tar xzf test.tgz"")
  
 →
  
 true
  
 result = `date`
  
 result
  
 →
  
 ""Thu Aug 26 22:36:55 CDT 2004\n""
  
 The method
  Kernel.system
  executes the given command in a subprocess; it returns 
 true
  
 if the command was found and executed properly and
  false
  otherwise. In case of 
 failure, you’ll find the subprocess’s exit code in the global variable
  $?
 .
  
 One problem with
  system
  is that the command’s output will simply go to the same 
 destination as your program’s output, which may not be what you want. To capture 
 the standard output of a subprocess, you can use the backquote characters, as with
  
 `date` 
 in the previous example. Remember that you may need to use
  String
 #
 chomp
  to 
 remove the line-ending characters from the result.
  
 OK, this is fine for simple cases—we can run some other process and get the return 
 status. But many times we need a bit more control than that. We’d like to carry on a 
 conversation with the subprocess, possibly sending it data and possibly getting some 
 back. The method
  IO.popen
  does just this. The
  popen
  method runs a command as a 
 subprocess and connects that subprocess’s standard input and standard output to a 
 Ruby
  IO
  object. Write to the
  IO
  object, and the subprocess can read it on standard 
 input. Whatever the subprocess writes is available in the Ruby program by reading 
 from the
  IO
  object.
  
 For example, on our systems one of the more useful utilities is
  pig
 , a program that 
 reads words from standard input and prints them in pig latin (or igpay atinlay). We 
 can use this when our Ruby programs need to send us output that our five-year-olds 
 shouldn’t be able to understand.
  
 pig = IO.popen(""/usr/local/bin/pig"", ""w+"") 
  
 pig.puts ""ice cream after they go to bed"" 
  
 pig.close_write 
  
 puts pig.gets
  
 produces:
  
 iceway eamcray afterway eythay ogay otay edbay
  
 This example illustrates both the apparent simplicity and the real-world complexi-ties 
 involved in driving subprocesses through pipes. The code certainly looks simple 
 enough: open the pipe, write a phrase, and read back the response. But it turns out 
 that the
  pig
  program doesn’t flush the output it writes. Our original attempt at this 
 exam-ple, which had a
  pig.puts
  followed by a
  pig.gets
 , hung forever. The
  pig
  program
  
 Prepared exclusively for Yeganefar",NA
Independent Children,"Sometimes we don’t need to be quite so hands-on: we’d like to give the subprocess 
 its assignment and then go on about our business. Sometime later, we’ll check to see 
 if it has finished. For instance, we may want to kick off a long-running external sort.
  
 exec(""sort testfile > output.txt"") if fork.nil? 
  
 # The sort is now running in a child process 
  
 # carry on processing in the main program
  
 # ... dum di dum ...
  
 # then wait for the sort to finish 
  
 Process.wait
  
 The call to
  Kernel.fork
  returns a process ID in the parent, and
  nil
  in the child, so the 
 child process will perform the
  Kernel.exec
  call and run sort. Sometime later, we issue a
  
 Process.wait
  call, which waits for the sort to complete (and returns its process ID).
  
 Prepared exclusively for Yeganefar",NA
Blocks and Subprocesses,"IO.popen
  works with a block in pretty much the same way as
  File.open
  does. If you pass 
 it a command, such as
  date
 , the block will be passed an
  IO
  object as a parameter.
  
 IO.popen(""date"") {|f| puts ""Date is #{f.gets}"" }
  
 produces:
  
 Date is Thu Aug 26 22:36:55 CDT 2004
  
 The
  IO
  object will be closed automatically when the code block exits, just as it is with 
 File.open
 .
  
 If you associate a block with
  Kernel.fork
 , the code in the block will be run in a Ruby 
 subprocess, and the parent will continue after the block.
  
 fork do 
  
 puts ""In child, pid = #$$"" 
  
 exit 99 
  
 end 
  
 pid = Process.wait 
  
 puts ""Child terminated, pid = #{pid}, status = #{$?.exitstatus}""
  
 produces:
  
 In child, pid = 25823 
  
 Child terminated, pid = 25823, status = 99
  
 $?
  is a global variable that contains information on the termination of a subprocess. See 
 the section on
  Process::Status
  beginning on page
  570
  for more information.
  
 Prepared exclusively for Yeganefar",NA
Chapter 12,NA,NA
Unit Testing,"Unit testing (described in the sidebar on the next page) is a technique that helps 
 devel-opers write better code. It helps before the code is actually written, as thinking 
 about testing leads you naturally to create better, more decoupled designs. It helps as 
 you’re writing the code, as it gives you instant feedback on how accurate your code 
 is. And it helps after you’ve written code, both because it gives you the ability to 
 check that the code still works and because it helps others understand how to use your 
 code.
  
 Unit testing is a Good Thing.
  
 But why have a chapter on unit testing in the middle of a book on Ruby? Because 
 unit testing and languages such as Ruby seem to go hand in hand. The flexibility of 
 Ruby makes writing tests easy, and the tests make it easier to verify that your code is 
 working. Once you get into the swing of it, you’ll find yourself writing a little code, 
 writing a test or two, verifying that everything is copacetic, and then writing some 
 more code.
  
 Unit testing is also pretty trivial—run a program that calls part of your application’s 
 code, get back some results, and then check the results are what you expected.
  
 Let’s say we’re testing a Roman number class. So far the code is pretty simple: it just 
 lets us create an object representing a certain number and display that object in 
 Roman numerals. Figure
  12.1
  on page
  145
  shows our first stab at an implementation.
  
 We could test this code by writing another program, like this.
  
 require 'roman'
  
 r = Roman.new(1) 
  
 fail ""'i' expected"" unless r.to_s == ""i""
  
 r = Roman.new(9) 
  
 fail ""'ix' expected"" unless r.to_s == ""ix""
  
 However, as the number of tests in a project grows, this kind of ad-hoc approach can 
 start to get complicated to manage. Over the years, various unit testing frameworks 
 have emerged to help structure the testing process. Ruby comes with one preinstalled, 
 Nathaniel Talbott’s Test::Unit framework.",NA
Test::Unit Framework,"The Test::Unit framework is basically three facilities wrapped into a neat package.
  
 1. It gives you a way of expressing individual tests.
  
 2. It provides a framework for structuring the tests.
  
 3. It gives you flexible ways of invoking the tests.",NA
Assertions == Expected Results,"Rather than have you write series of individual
  if
  statements in your tests, Test::Unit
  
 provides a series of assertions that achieve the same thing. Although a number of dif-
  
 ferent styles of assertion exist, they all follow basically the same pattern. Each assertion
  
 gives you a way of specifying a desired result or outcome and a way of passing in the
  
 actual outcome. If the actual doesn’t equal the expected, the assertion outputs a nice
  
 message and records the fact as a failure.
  
 For example, we could rewrite our previous test of the Roman class in Test::Unit. For
  
 now, ignore the scaffolding code at the start and end, and just look at the
  assert_equal
  
 methods.",NA
Structuring Tests,"Earlier we asked you to ignore the scaffolding around our tests. Now it’s time to look 
 at it.
  
 You include Test::Unit facilities in your unit test with the following line.
  
 require 'test/unit'
  
 Unit tests seem to fall quite naturally into high-level groupings, called
  test cases
 , and 
 lower level groupings, the test methods themselves. The test cases generally contain 
 all the tests relating to a particular facility or feature. Our Roman number class is 
 fairly simple, so all the tests for it will probably be in a single test case. Within the 
 test case, you’ll probably want to organize your assertions into a number of test 
 methods, where each method contains the assertions for one type of test: one method 
 could check regular number conversions, another could test error handling, and so on.
  
 The classes that represent test cases must be subclasses of Test::Unit::TestCase. The 
 methods that hold the assertions must have names that start with
  test
 . This is impor-
 tant: Test::Unit uses reflection to find tests to run, and only methods whose names 
 start with
  test
  are eligible.
  
 Prepared exclusively for Yeganefar",NA
Organizing and Running Tests,"The test cases we’ve shown so far are all runnable Test::Unit programs. If, for 
 example, the test case for the Roman class was in a file called
  test_roman.rb
 , we could 
 run the tests from the command line using
  
 %
  ruby test_roman.rb 
  
 Loaded suite test_roman 
  
 Started 
  
 ..
  
 Finished in 0.039257 seconds.
  
 2 tests, 9 assertions, 0 failures, 0 errors
  
 Test::Unit is clever enough to notice that there’s no main program, so it collects up all 
 the test case classes and runs each in turn.
  
 If we want, we can ask it to run just a particular test method.
  
 %
  ruby test_roman.rb --name test_range 
  
 Loaded suite test_roman 
  
 Started 
  
 .
  
 Finished in 0.006445 seconds.
  
 1 tests, 4 assertions, 0 failures, 0 errors",NA
Where to Put Tests,"Once you get into unit testing, you may well find yourself generating almost as much 
 test code as production code. All of those tests have to live somewhere. The problem 
 is that if you put them alongside your regular production code source files, your 
 direc-tories start to get bloated—effectively you end up with two files for every 
 production source file.
  
 A common solution is to have a
  test/
  directory where you place all your test source 
 files. This directory is then placed parallel to the directory containing the code you’re 
 developing. For example, for our Roman numeral class, we may have
  
 roman
  
 lib/ 
  
 roman.rb 
  
 other files...
  
 test/ 
  
 test_roman.rb 
  
 other tests...
  
 other stuff
  
 Prepared exclusively for Yeganefar",NA
Test Suites,"After a while, you’ll grow a decent collection of test cases for your application. You 
 may well find that these tend to cluster: one group of cases tests a particular set of 
 functions, and another group tests a different set of functions. If so, you can group 
 those test cases together into
  test suites
 , letting you run them all as a group.
  
 Prepared exclusively for Yeganefar",NA
Chapter 13,NA,NA
When Trouble Strikes,"Sad to say, it is possible to write buggy programs using Ruby. Sorry about that.
  
 But not to worry! Ruby has several features that will help debug your programs. 
 We’ll look at these features, and then we’ll show some common mistakes you can 
 make in Ruby and how to fix them.",NA
Ruby Debugger,"Ruby comes with a debugger, which is conveniently built into the base system. You 
 can run the debugger by invoking the interpreter with the
  -r debug
  option, along with 
 any other Ruby options and the name of your script.
  
 ruby -r debug
  [
  debug-options
  ] [
  programfile
  ] [
  program-arguments
  ]
  
 The debugger supports the usual range of features you’d expect, including the ability 
 to set breakpoints, to step into and step over method calls, and to display stack frames 
 and variables. It can also list the instance methods defined for a particular object or 
 class, and it allows you to list and control separate threads within Ruby. Table
  13.1
  
 on page
  165
  lists all the commands that are available under the debugger.
  
 If your Ruby installation has
  readline
  support enabled, you can use cursor keys to 
 move back and forth in command history and use line-editing commands to amend 
 previous input.
  
 To give you an idea of what the Ruby debugger is like, here is a sample session (with 
 user input in bold face type).
  
 %
  ruby -r debug t.rb 
  
 Debug.rb 
  
 Emacs support available.
  
 t.rb:1:def fact(n) 
  
 (rdb:1)
  list 1-9 
  
 [1, 10] in t.rb
  
 Prepared exclusively for Yeganefar 
 155",NA
Interactive Ruby,"If you want to play with Ruby, we recommend Interactive Ruby—irb, for short. irb is
  
 essentially a Ruby “shell” similar in concept to an operating system shell (complete
  
 with job control). It provides an environment where you can “play around” with the
  
 language in real time. You launch irb at the command prompt.
  
 irb
  [
  irb-options
  ] [
  ruby_script
  ] [
  program-arguments
  ]
  
 irb will display the value of each expression as you complete it. For instance:
  
 % irb
  
 irb(main):001:0>
  a = 1 +
  
 irb(main):002:0*
  2 * 3 /
  
 irb(main):003:0*
  4 % 5
  
 Prepared exclusively for Yeganefar",NA
Editor Support,"The Ruby interpreter is designed to read a program in one pass; this means you can 
 pipe an entire program to the interpreter’s standard input, and it will work just fine.
  
 We can take advantage of this feature to run Ruby code from inside an editor. In 
 Emacs, for instance, you can select a region of Ruby text and use the command
  Meta-|
  
 to execute Ruby. The Ruby interpreter will use the selected region as standard input, 
 and output will go to a buffer named
  *Shell Command Output*
 . This feature has come in 
 quite handy for us while writing this book—just select a few lines of Ruby in the 
 middle of a paragraph and try it!
  
 You can do something similar in the vi editor using
  :%!ruby
  which
  replaces
  the pro-
 gram text with its output, or
  :w !ruby
 , which displays the output without affecting the 
 buffer. Other editors have similar features.
  
 While we are on the subject, this would probably be a good place to mention that a 
 Ruby mode for Emacs is included in the Ruby source distribution as
  ruby-mode.el 
 in 
 the
  misc/
  subdirectory. You can also find syntax-highlighting modules for vim
  
 Prepared exclusively for Yeganefar",NA
But It Doesn’t Work!,"So you’ve read through enough of the book, you start to write your very own Ruby 
 program, and it doesn’t work. Here’s a list of common gotchas and other tips.
  
 • First and foremost, run your scripts with warnings enabled (the
  -w
  command-line 
  
 option).
  
 • If you happen to forget a “,” in an argument list—especially to print—you can 
  
 produce some very odd error messages.
  
 • A parse error at the last line of the source often indicates a missing
  end
  keyword, 
  
 sometimes quite a bit earlier.
  
 • An attribute setter is not being called. Within a class definition, Ruby will parse 
 setter=
  as an assignment to a local variable, not as a method call. Use the form 
 self.setter=
  to indicate the method call.
  
 class Incorrect 
  
 attr_accessor :one, :two 
  
 def initialize 
  
  
 one = 1 
  
 # incorrect - sets local variable 
  
  
 self.two = 2 
  
 end 
  
 end
  
 obj = Incorrect.new
  
 obj.one
  
 →
  
 nil
  
 obj.two
  
 →
  
 2
  
 • Objects that don’t appear to be properly set up may have been victims of an incor-
  
 rectly spelled
  initialize
  method.
  
 class Incorrect 
  
 attr_reader :answer 
  
 def initialise 
  
 # < < < spelling error 
  
  
 @answer = 42 
  
 end 
  
 end
  
 ultimate = Incorrect.new
  
 ultimate.answer
  
 →
  
 nil
  
 The same kind of thing can happen if you misspell the instance variable name.
  
 Prepared exclusively for Yeganefar",NA
But It’s Too Slow!,"Ruby is an interpreted, high-level language, and as such it may not perform as fast as 
 a lower-level language such as C. In the following sections, we’ll list some basic 
 things you can do to improve performance; also have a look in the index under
  
 Performance 
 for other pointers.
  
 Typically, slow-running programs have one or two performance graveyards, places 
 where execution time goes to die. Find and improve these, and suddenly your whole 
 program springs back to life. The trick is finding them. The
  Benchmark
  module and 
 the Ruby profilers can help.",NA
Benchmark,"You can use the
  Benchmark
  module, also described on page
  636
 , to time sections of 
 code. For example, we may wonder which is faster: a large loop using variables local 
 to the loop’s block or using variables from the surrounding scope. Figure
  13.2
  on the 
 following page shows how to use
  Benchmark
  to find out.
  
 You have to be careful when benchmarking,because oftentimes Ruby programs can 
 run slowly because of the overhead of garbage collection. Because this garbage 
 collection can happen any time during your program’s execution, you may find that 
 benchmark-ing gives misleading results, showing a section of code running slowly 
 when in fact the slowdown was caused because garbage collection happened to 
 trigger while that code was executing. The
  Benchmark
  module has the
  bmbm
  method 
 that runs the tests twice, once as a rehearsal and once to measure performance, in an 
 attempt to minimize the dis-tortion introduced by garbage collection. The 
 benchmarking process itself is relatively well mannered—it doesn’t slow down your 
 program much.",NA
The Profiler,"Ruby comes with a code profiler (documentation begins on page
  696
 ). The profiler 
 shows you the number of times each method in the program is called and the average 
 and cumulative time that Ruby spends in those methods.
  
 You can add profiling to your code using the command-line option
  -r profile
  or from 
 within the code using
  require 'profile'
 . For example:
  
 require 'profile'
  
 count = 0 
  
 words = File.open(""/usr/share/dict/words"")
  
 while word = words.gets 
  
 word = word.chomp!
  
 if word.length == 12 
  
  
 count += 1 
  
 end 
  
 end
  
 puts ""#{count} twelve-character words""
  
 The first time we ran this (without profiling) against a dictionary of almost 235,000 
 words, it takes several seconds to complete. This seems excessive, so we added the
 -r 
 profile
  command-line option and tried again. Eventually we saw output that looked 
 like the following.",NA
Part II,NA,NA
Ruby in Its Setting,"Prepared exclusively for Yeganefar
  
 166",NA
Chapter 14,NA,NA
Ruby and Its World,"It’s an unfortunate fact of life that our applications have to deal with the big, bad 
 world. In this chapter, we’ll look at how Ruby interacts with its environment. 
 Microsoft Win-dows users will probably also want to look at platform-specific 
 information beginning on page
  253
 .",NA
Command-Line Arguments,"“In the beginning was the command line.”
 1
 Regardless of the system in which Ruby is 
 deployed, whether it be a super high-end scientific graphics workstation or an embed-
 ded PDA device, you’ve got to start the Ruby interpreter somehow, and that gives us 
 the opportunity to pass in command-line arguments.
  
 A Ruby command line consists of three parts: options to the Ruby interpreter, option-
 ally the name of a program to run, and optionally a set of arguments for that program.
  
 ruby
  [
  options
  ] [
  --
  ] [
  programfile
  ] [
  arguments
  ]
  
 The Ruby options are terminated by the first word on the command line that doesn’t 
 start with a hyphen, or by the special flag
  --
  (two hyphens).
  
 If no filename is present on the command line, or if the filename is a single hyphen (
 -
 ), 
 Ruby reads the program source from standard input.
  
 Arguments for the program itself follow the program name. For example:
  
 % ruby -w - ""Hello World""
  
 will enable warnings, read a program from standard input, and pass it the quoted string 
 ""Hello World""
  as an argument.
  
 1.
  
 This is the title of a marvelous essay by Neal Stephenson (available online at
  
 http://www.spack.org/index.cgi/InTheBeginningWasTheCommandLine
 ).
  
 Prepared exclusively for Yeganefar 
 167",NA
Command-Line Options,"-0[
 octal
 ] 
  
 The 0 flag (the digit zero) specifies the record separator character (\0, if no digit 
 follows).
  -00
  indicates paragraph mode: records are separated by two successive 
 default record separator characters.
  -0777
  reads the entire file at once (as it is an 
 illegal character). Sets
  $/
 .
  
 -a 
  
 Autosplit mode when used with
  -n
  or
  -p
 ; equivalent to executing
  $F = $_.split 
  
 at the 
 top of each loop iteration.
  
 -C
  directory 
  
  
 Changes working directory to
  directory
  before executing.
  
 -c 
  
 Checks syntax only; does not execute the program.
  
 --copyright 
  
  
 Prints the copyright notice and exits.
  
 1.8
  
  
 -d, --debug
  
 Sets
  $DEBUG
  and
  $VERBOSE
  
 to
  true
 . This can be used by your programs to enable
  
 additional tracing.
  
 -e '
 command
 ' 
  
 Executes
  command
  as one line of Ruby source. Several
  -e
 ’s are allowed, and the 
 commands are treated as multiple lines in the same program. If
  programfile
  is
  
 1.8
  
  
 omitted when
  -e
  is present, execution stops after the
  -e
  commands have been
  
 run. Programs
  
 run using
  -e
  have access to the old behavior of ranges and regular
  
 expressions in conditions—ranges of integers compare against the current input 
 line number, and regular expressions match against
  $_
 .
  
 -F
  pattern 
  
 Specifies the input field separator (
 $;
 ) used as the default for
  split()
  (affects the
 -a
  
 option).
  
 -h, --help 
  
  
 Displays a short help screen.
  
 -I
  directories 
  
 Specifies directories to be prepended to
  $LOAD_PATH
  (
 $:
 ). Multiple
  -I
  options may 
 be present. Multiple directories may appear following each
  -I
 , separated by a colon 
 ( : ) on Unix-like systems and by a semicolon ( ; ) on DOS/Windows systems.
  
 -i [
 extension
 ] 
  
 Edits
  ARGV
  files in place. For each file named in
  ARGV
 , anything you write to stan-
 dard output will be saved back as the contents of that file. A backup copy of the 
 file will be made if
  extension
  is supplied.
  
 % ruby -pi.bak -e ""gsub(/Perl/, 'Ruby')"" *.txt
  
 Prepared exclusively for Yeganefar",NA
ARGV,"Any command-line arguments after the program filename are available to your Ruby 
 program in the global array
  ARGV
 . For instance, assume
  test.rb
  contains the following 
 program:
  
 ARGV.each {|arg| p arg }
  
 Invoke it with the following command line:
  
 % ruby -w test.rb ""Hello World"" a1 1.6180
  
 It’ll generate the following output:
  
 ""Hello World"" 
  
 ""a1"" 
  
 ""1.6180""
  
 There’s a gotcha here for all you C programmers—
 ARGV[0]
  is the first argument to 
 the program, not the program name. The name of the current program is available in 
 the global variable
  $0
 . Notice that all the values in
  ARGV
  are strings.
  
 If your program attempts to read from standard input (or uses the special file
  ARGF
 , 
 described on page
  321
 ), the program arguments in
  ARGV
  will be taken to be filenames, 
 and Ruby will read from these files. If your program takes a mixture of arguments 
 and filenames, make sure you empty the nonfilename arguments from the
  ARGV
  array 
 before reading from the files.",NA
Program Termination,"The method
  Kernel
 #
 exit
  terminates your program, returning a status value to the 
 operating system. However, unlike some languages,
  exit
  doesn’t terminate the pro-
 gram immediately.
  Kernel
 #
 exit
  first raises a
  SystemExit
  exception, which you may 
 catch, and then performs a number of cleanup actions, including running any 
 registered 
 at_exit
  methods and object finalizers. See the reference for
  Kernel
 #
 exit
  
 beginning on page
  500
  for details.
  
 Prepared exclusively for Yeganefar",NA
Environment Variables,"You can access operating system environment variables using the predefined variable 
 ENV
 . It responds to the same methods as
  Hash
 .
 2
  
 ENV['SHELL']
  
 →
  
 ""/bin/sh""
  
 ENV['HOME']
  
 →
  
 ""/Users/dave""
  
 ENV['USER']
  
 ""dave""
  
 →
  
 ENV.keys.size
  
 →
  
 34
  
 ENV.keys[0, 7]
  
 [""MANPATH"", ""TERM_PROGRAM"", ""TERM"", ""SHELL"",
  
 →
  
 ""SAVEHIST"", ""HISTSIZE"", ""MAKEFLAGS""]
  
 The values of some environment variables are read by Ruby when it first starts. These 
 variables modify the behavior of the interpreter, as shown in Table
  14.1
  on the next 
 page.",NA
Writing to Environment Variables,"A Ruby program may write to the
  ENV
  object. On most systems this changes the 
 values of the corresponding environment variables. However, this change is local to 
 the pro-cess that makes it and to any subsequently spawned child processes. This 
 inheritance of environment variables is illustrated in the code that follows. A 
 subprocess changes an environment variable, and this change is inherited by a 
 process that it then starts. However, the change is not visible to the original parent. 
 (This just goes to prove that parents never really know what their children are doing.)
  
 puts ""In parent, term = #{ENV['TERM']}"" 
  
 fork do 
  
 puts ""Start of child 1, term = #{ENV['TERM']}"" 
  
 ENV['TERM'] = ""ansi"" 
  
 fork do 
  
  
 puts ""Start of child 2, term = #{ENV['TERM']}"" 
  
 end 
  
 Process.wait 
  
 puts ""End of child 1, term = #{ENV['TERM']}"" 
  
 end 
  
 Process.wait 
  
 puts ""Back in parent, term = #{ENV['TERM']}""
  
 produces:
  
 In parent, term = xterm-color 
  
 Start of child 1, term = xterm-color 
  
 Start of child 2, term = ansi 
  
 End of child 1, term = ansi 
  
 Back in parent, term = xterm-color
  
 2.
  
 ENV
  is not actually a hash, but if you need to, you can convert it into a
  Hash
  using
  ENV#to_hash
 .
  
  
 Prepared exclusively for Yeganefar",NA
Where Ruby Finds Its Modules,"You use
  require
  or
  load
  to bring a library module into your Ruby program. Some of 
 these modules are supplied with Ruby, some you may have installed off the Ruby 
 Application Archive, and some you may have written yourself. How does Ruby find 
 them?
  
 When Ruby is built for your particular machine, it predefines a set of standard 
 directo-ries to hold library stuff. Where these are depends on the machine in question. 
 You can determine this from the command line with something like
  
 % ruby -e 'puts $:'
  
 1.8
  
  
 On a typical Linux box, you’ll probably find something such as the following. Note
  
 that as of Ruby 1.8,
  
 the order of these directories has changed—architecture-specific
  
 directories now follow their machine-independent counterparts.
  
 /usr/local/lib/ruby/site_ruby/1.8 
  
 /usr/local/lib/ruby/site_ruby/1.8/i686-linux 
  
 /usr/local/lib/ruby/site_ruby 
  
 /usr/local/lib/ruby/1.8 
  
 /usr/local/lib/ruby/1.8/i686-linux 
  
 .
  
 Prepared exclusively for Yeganefar",NA
Build Environment,"When Ruby is compiled for a particular architecture, all the relevant settings used to 
 build it (including the architecture of the machine on which it was compiled, compiler 
 options, source code directory, and so on) are written to the module
  Config
  within the 
 library file
  rbconfig.rb
 . After installation, any Ruby program can use this module to get 
 details on how Ruby was compiled.
  
 require 'rbconfig.rb' 
  
 include Config
  
 CONFIG[""host""]
  
 →
  
 ""powerpc-apple-darwin7.5.0""
  
 CONFIG[""libdir""]
  
 ""/Users/dave/ruby1.8/lib""
  
 →
  
 Extension libraries use this configuration file in order to compile and link properly on 
 any given architecture. See Chapter
  21
  beginning on page
  261
  and the reference for 
 mkmf
  beginning on page
  755
  for details.
  
 3.
  
 The separator between entries depends on your platform. For Windows, it’s a semicolon; for Unix, it’s
  
 a colon.
  
 Prepared exclusively for Yeganefar",NA
Chapter 15,NA,NA
Interactive Ruby Shell,"Back on page
  156
  we introduced irb, a Ruby module that lets you enter Ruby 
 programs interactively and see the results immediately. This chapter goes into more 
 detail on using and customizing irb.",NA
Command Line,"irb is run from the command line.
  
 irb
  [
  irb-options
  ] [
  ruby_script
  ] [
  program arguments
  ]
  
 The command-line options for irb are listed in Table
  15.1
  on the next page. Typically, 
 you’ll run irb with no options, but if you want to run a script and watch the blow-by-
 blow description as it runs, you can provide the name of the Ruby script and any 
 options for that script.
  
 Once started, irb displays a prompt and waits for input. In the examples that follow, 
 we’ll use irb’s default prompt, which shows the current binding, the indent (nesting) 
 level, and the line number.
  
 At a prompt, you can type Ruby code. irb includes a Ruby parser, so it knows when 
 statements are incomplete. When this happens, the prompt will end with an asterisk. 
 You can leave irb by typing
  exit
  or
  quit
 , or by entering an end-of-file character 
 (unless 
 IGNORE_EOF
  mode is set).
  
 %
  irb 
  
 irb(main):001:0>
  1 + 2 
  
 => 3 
  
 irb(main):002:0>
  3 + 
  
 irb(main):003:0*
  4 
  
 => 7 
  
 irb(main):004:0>
  quit 
  
 %
  
 Prepared exclusively for Yeganefar 
 174",NA
Tab Completion,"If your Ruby installation has
  readline
  support, then you can use irb’s completion 
 facility. Once loaded (and we’ll get to how to load it shortly), completion changes the 
 meaning of the
  TAB
  key when typing expressions at the irb prompt. When you press 
 TAB
  partway through a word, irb will look for possible completions that make sense at 
 that point. It there is only one, irb will fill it in automatically. If there’s more than one 
 valid option, irb initially does nothing. However, if you hit
  TAB
  again, it will display 
 the list of valid completions at that point.
  
 For example, you may be in the middle of an irb session, having just assigned a string 
 object to the variable
  a
 .
  
 irb(main):002:0>
  a = ""cat"" 
  
 => ""cat""
  
 You now want to try the method
  String
 #
 reverse
  on this object. You start by typing 
 a.re
  
 and then hit
  TAB
  twice.
  
 Prepared exclusively for Yeganefar",NA
Subsessions,"irb supports multiple, concurrent sessions. One is always current; the others lie 
 dormant until activated. Entering the command
  irb
  within irb creates a subsession, 
 entering the 
 jobs
  command lists all sessions, and entering
  fg
  activates a particular 
 dormant session.",NA
Subsessions and Bindings,"If you specify an object when you create a subsession, that object becomes the value 
 of
  self
  in that binding. This is a convenient way to experiment with objects. In the 
 following example, we create a subsession with the string “wombat” as the default 
 object. Methods with no receiver will be executed by that object.
  
 %
  irb 
  
 irb(main):001:0>
  self 
  
 => main 
  
 irb(main):002:0>
  irb ""wombat"" 
  
 irb#1(wombat):001:0>
  self 
  
 => ""wombat"" 
  
 irb#1(wombat):002:0>
  upcase 
  
 => ""WOMBAT"" 
  
 irb#1(wombat):003:0>
  size 
  
 => 6 
  
 irb#1(wombat):004:0>
  gsub(/[aeiou]/, '*') 
  
 => ""w*mb*t"" 
  
 irb#1(wombat):005:0>
  irb_exit 
  
 irb(main):003:0>
  self 
  
 => main 
  
 irb(main):004:0>
  upcase 
  
 NameError: undefined local variable or method `upcase' for main:Object",NA
Configuration,"irb is remarkably configurable. You can set configuration options with command-line 
 options, from within an initialization file, and while you’re inside irb itself.",NA
Initialization File,"irb uses an initialization file in which you can set commonly used options or execute 
 any required Ruby statements. When irb is run, it will try to load an initialization file 
 from one of the following sources in order:
  ~/.irbrc
 ,
  .irbrc
 ,
  irb.rc
 ,
  _irbrc
 , and 
 $irbrc
 .
  
 Within the initialization file you may run any arbitrary Ruby code. You can also set 
 configuration values. The list of configuration variables is given starting on page
  
 181
 —the values that can be used in an initialization file are the symbols (starting with 
 a colon). You use these symbols to set values into the
  IRB.conf
  hash. For example, to 
 make
  SIMPLE
  the default prompt for all your irb sessions, you could have the 
 following in your initialization file.
  
 IRB.conf[:PROMPT_MODE] = :SIMPLE
  
 As an interesting twist on configuring irb, you can set
  IRB.conf[:IRB_RC]
  to a
  Proc 
 object. This proc will be invoked whenever the irb context is changed and will 
 receive the configuration for that context as a parameter. You can use this facility to 
 change the configuration dynamically based on the context. For example, the 
 following
  .irbrc 
 file sets the prompt so that only the main prompt shows the irb level, 
 but continuation prompts and the result still line up.
  
 IRB.conf[:IRB_RC] = proc do |conf| 
  
 leader = "" "" * conf.irb_name.length 
  
 conf.prompt_i = ""#{conf.irb_name} --> "" 
  
 conf.prompt_s = leader + ' \-"" ' 
  
 conf.prompt_c = leader + ' \-+ '
  
 conf.return_format 
  
 puts ""Welcome!"" 
  
 end
  
 = leader + "" ==> %s\n\n""
  
 An irb session using this
  .irbrc
  file looks like the following.
  
 % irb 
  
 Welcome!
  
 irb -->
  1 + 2 
  
 ==> 3
  
 irb -->
  2 + 
  
 \-+
  6 
  
 ==> 8
  
 Prepared exclusively for Yeganefar",NA
Extending irb,"Because the things you type to irb are interpreted as Ruby code, you can effectively 
 extend irb by defining new top-level methods. For example, you may want to be able 
 to look up the documentation for a class or method while in irb. If you add the 
 following to your
  .irbrc
  file, you’ll add a method called
  ri
 , which invokes the external 
 ri command on its arguments.
  
 def ri(*names) 
  
 system(%{ri #{names.map {|name| name.to_s}.join("" "")}}) 
  
 end
  
 The next time you start irb, you’ll be able to use this method to get documentation.
  
 irb(main):001:0> ri
  Proc
  
 --------------------------------------------------------- Class: Proc 
  
 Proc objects are blocks of code that 
 have been bound to a set of 
  
 local variables. Once bound, the code may be called in 
 different 
  
 contexts and still access those variables.
  
 and so on...
  
 irb(main):002:0> ri
  :strftime
  
 ------------------------------------------------------- Time#strftime 
  
 time.strftime( string ) => string
  
 ---------------------------------------------------------------------
  
 Formats time according to the 
 directives in the given format 
  
 string. Any text not listed as a directive will be passed 
 through 
  
 to the output string.
  
 Format meaning: 
  
 %a - The abbreviated weekday name (``Sun'')
  
 %A - The
  
 full
  
 weekday
  
 name (``Sunday'')
  
 %b - The abbreviated month name (``Jan'')
  
 %B - The
  
 full
  
 month
  
 name (``January'')
  
 %c - The preferred local date and time representation 
  
 %d - Day of the month (01..31) 
  
 and so on...
  
 irb(main):003:0>
  ri ""String.each""
  
 --------------------------------------------------------- String#each 
  
 str.each(separator=$/) 
 |substr| block 
  
 => str 
  
  
 str.each_line(separator=$/) |substr| block 
  
 => str
  
 ---------------------------------------------------------------------
  
 Splits str using the 
 supplied parameter as the record separator 
  
 ($/ by default), passing 
 each substring in turn to the supplied 
  
 block. If a zero-length 
 record separator is supplied, the string 
  
 is split on \n characters, 
 except that multiple successive 
  
 newlines are appended 
 together.
  
 print ""Example one\n"" 
  
 ""hello\nworld"".each |s| p s 
  
 and so on...
  
 Prepared exclusively for Yeganefar",NA
Interactive Configuration,"Most configuration values are also available while you’re running irb. The list 
 starting on the current page shows these values as
  conf.
 xxx
 . For example, to change 
 your prompt back to
  DEFAULT
 , you could use the following.
  
 irb(main):001:0>
  1 + 
  
 irb(main):002:0*
  2 
  
 => 3 
  
 irb(main):003:0>
  conf.prompt_mode = :SIMPLE 
  
 => :SIMPLE 
  
 >>
  1 + 
  
 ?>
  2 
  
 => 3",NA
irb Configuration Options,"In the descriptions that follow, a label of the form
  :XXX
  signifies a key used in the 
 IRB.conf
  hash in an initialization file, and
  conf.xxx
  signifies a value that can be set 
 interactively. The value in square brackets at the end of the description is the option’s 
 default.
  
 :AUTO_INDENT
  /
  conf.auto_indent_mode 
  
  
 If
  true
 , irb will indent nested structures as you type them. [false]
  
 :BACK_TRACE_LIMIT
  /
  conf.back_trace_limit 
  
  
 Displays lines
  n
  initial and
  n
  final lines of backtrace. [16]
  
 :CONTEXT_MODE
  
 What binding to use for new workspaces: 0
 →
  proc at the top level, 1
 →
  binding in a loaded, 
 anonymous file, 2
 →
  per thread binding in a loaded file, 3
 →
  binding in a top-level function.
  
 [3]
  
 :DEBUG_LEVEL
  /
  conf.debug_level 
  
  
 Sets the internal debug level to
  n
 . Useful if you’re debugging irb’s lexer. 
 [0]
  
 :IGNORE_EOF
  /
  conf.ignore_eof 
  
 Specifies the behavior of an end of file received on input. If true, it will be ignored; other-
 wise, irb will quit. [false]
  
 :IGNORE_SIGINT
  /
  conf.ignore_sigint 
  
 If false, ^C (Ctrl+c) will quit irb. If true, ^C during input will cancel input and return to the 
 top level; during execution, ^C will abort the current operation. [true]
  
 :INSPECT_MODE
  /
  conf.inspect_mode 
  
 Specifies how values will be displayed:
  true
  means use
  inspect
 ,
  false
  uses
  to_s
 , and 
 nil
  uses
  
 inspect
  in nonmath mode and
  to_s
  in math mode. [nil]",NA
Commands,"At the irb prompt, you can enter any valid Ruby expression and see the results. You 
 can also use any of the following commands to control the irb session.
  
 exit, quit, irb_exit, irb_quit 
  
 Quits this irb session or subsession. If you’ve used
  cb
  to change bindings (see 
 below), exits from this binding mode.
  
 conf, context, irb_context 
  
 Displays current configuration. Modifying the configuration is achieved by invok-
 ing methods of
  conf
 . The list starting on page
  181
  shows the available
  conf
  set-
 tings. For example, to set the default prompt to something subservient, you could 
 use
  
 irb(main):001:0>
  conf.prompt_i = ""Yes, Master? "" 
  
 => ""Yes, Master? "" 
  
 Yes, Master?
  1 + 2
  
 cb, irb_change_binding
  
 ⟨
  obj
  ⟩
  
  
 Creates and enters a new binding that has its own scope for local variables. If
  obj 
  
 is given, it will be used as self in the new binding.
  
 irb
   
 ⟨
  obj
  ⟩
  
 Starts an irb subsession. If
  obj
  is given, it will be used as self.
  
 jobs, irb_jobs 
  
  
 Lists irb subsessions.
  
 fg
  n
 , irb_fg
  n 
  
 Switches into the specified irb subsession.
  n
  may be any of: an irb subsession 
 number, a thread ID, an irb object, or the object that was the value of
  self
  when a 
 subsession was launched.
  
 kill
  n
 , irb_kill
  n 
  
  
 Kills an irb subsession.
  n
  may be any of the values as described for
  irb_fg
 .
  
 Prepared exclusively for Yeganefar",NA
Configuring the Prompt,"You have a lot of flexibility in configuring the prompts that irb uses. Sets of prompts
  
 are stored in the prompt hash,
  IRB.conf[:PROMPT]
 .
  
 For example, to establish a new prompt mode called “MY_PROMPT”, you could enter
  
 the following (either directly at an irb prompt or in the
  .irbrc
  file).
  
 IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
  
 :PROMPT_I => '-->', # normal prompt
  
 :PROMPT_S => '--""', # prompt for continuing strings
  
 :PROMPT_C => '--+', # prompt for continuing statement
  
 :RETURN => "" ==>%s\n"" # format to return value
  
 }
  
 Once you’ve defined a prompt, you have to tell irb to use it. From the command line,
  
 you can use the
  --prompt
  option. (Notice how the name of the prompt mode is auto-
  
 matically converted to uppercase, with hyphens changing to underscores.)
  
 % irb --prompt my-prompt
  
 If you want to use this prompt in all your future irb sessions, you can set it as a config-
  
 uration value in your
  .irbrc
  file.
  
 IRB.conf[:PROMPT_MODE] = :MY_PROMPT
  
 The symbols
  PROMPT_I
 ,
  PROMPT_S
 , and
  PROMPT_C
  specify the format for each of the
  
 prompt strings. In a format string, certain “%” sequences are expanded.
  
 Flag
  
 Description
  
 %
 N 
  
 %
 m 
  
 %
 M 
  
 %l
  
 Current command.
  
 to_s
  of the main object (self).
  
 inspect
  of the main object (self).
  
 Delimiter type. In strings that are continued across a line break,
  %l
  will 
 display
  
 the type of delimiter used to begin the string, so you’ll know how to end it. The
  
 delimiter will be one of
  ""
 ,
  '
 ,
  /
 ,
  ]
 , or
  `
 .
  
 %
 n
 i 
 Indent level. The optional number
  n
  is used as a width specification to printf,
  
 as
  printf(""%
 n
 d"")
 .
  
 %
 n
 n 
 %%
  
 Current line number (
 n
  used as with the indent level). 
 A literal percent sign.
  
 For instance, the default prompt mode is defined as follows.
  
 IRB.conf[:PROMPT_MODE][:DEFAULT] = {
  
 :PROMPT_I => ""%N(%m):%03n:%i> "",
  
 :PROMPT_S => ""%N(%m):%03n:%i%l "",
  
 :PROMPT_C => ""%N(%m):%03n:%i* "",
  
 :RETURN => ""%s\n""
  
 }
  
 Prepared exclusively for Yeganefar",NA
Restrictions,"Because of the way irb works, it is slightly incompatibility with the standard Ruby 
 interpreter. The problem lies in the determination of local variables.
  
 Normally, Ruby looks for an assignment statement to determine if something is a 
 variable—if a name hasn’t been assigned to, then Ruby assumes that name is a 
 method call.
  
 eval ""var = 0"" 
  
 var
  
 produces:
  
 prog.rb:2: undefined local variable or method `var' 
  
 for main:Object (NameError)
  
 In this case, the assignment is there, but it’s within a string, so Ruby doesn’t take it into 
 account.
  
 irb, on the other hand, executes statements as they are entered.
  
 irb(main):001:0>
  eval ""var = 0"" 
  
 0 
  
 irb(main):002:0>
  var 
  
 0
  
 In irb, the assignment was executed before the second line was encountered, so
  var
  is 
 correctly identified as a local variable.
  
 If you need to match the Ruby behavior more closely, you can place these statements 
 within a
  begin
 /
 end
  pair.
  
 irb(main):001:0>
  begin 
  
 irb(main):002:1* 
  
 eval ""var = 0"" 
  
 irb(main):003:1> 
  
 var 
  
 irb(main):004:1>
  end 
  
 NameError: undefined local variable or method `var' 
  
 (irb):3:in `irb_binding'",NA
rtags and xmp,"Just in case irb wasn’t already complex enough, let’s add a few more wrinkles. Along 
 with the main irb program, the irb suite includes some extra goodies. In the next sec-
 tions we’ll look at two:
  rtags
  and
  xmp
 .
  
 rtags
  
 rtags
  is a command used to create a
  TAGS
  file for use with either the Emacs or vi editor.
  
 Prepared exclusively for Yeganefar",NA
Chapter 16,NA,NA
Documenting Ruby,"1.8
  
  
 As of version 1.8,
  
 Ruby comes bundled with RDoc, a tool that extracts and formats
  
 documentation that’s embedded in Ruby source code files. This tool is used to doc-
 ument the built-in Ruby classes and modules. An increasing number of libraries and 
 extensions are also documented this way.
  
 RDoc does two jobs. First, it analyzes Ruby and C source files, looking for 
 information to document.
 1
 Second, it takes this information and converts it into 
 something readable. Out of the box, RDoc produces two kinds of output: HTML and 
 ri. Figure
  16.1
  on the following page shows some HTML-format RDoc output in a 
 browser window. This is the result of feeding RDoc a Ruby source file with no 
 additional documentation—RDoc does a credible job of producing something 
 meaningful. If our source code contains comments, RDoc can use them to spice up 
 the documentation it produces. Typically, the comment before an element is used to 
 document that element, as shown in Fig-ure
  16.2
  on page
  189
 .
  
 RDoc can also be used to produce documentation that can be read by the
  ri
  command-
 line utility. For example, if we ask RDoc to document the code in Figure
  16.2
  this 
 way, we can then access the documentation using ri, as shown in Figure
  16.3
  on page
  
 190
 . New Ruby distributions have the built-in classes and modules (and some 
 libraries) doc-umented this way. Figure
  16.4
  on page
  191
  shows the output produced 
 if you type
  ri Proc
 .",NA
Adding RDoc to Ruby Code,"RDoc parses Ruby source files to extract the major elements (classes, modules, meth-
 ods, attributes, and so on). You can choose to associate additional documentation 
 with these by simply adding a comment block before the element in the file.
  
 1.
  
 RDoc can also document Fortran 77 programs.
  
 Prepared exclusively for Yeganefar
  
 187",NA
Hyperlinks,"Names of classes, source files, and any method names containing an underscore or
  
 preceded by a hash character are automatically hyperlinked from comment text to their
  
 description.
  
 Hyperlinks to the ’net starting
  http:
 ,
  mailto:
 ,
  ftp:
 , and
  www:
  are recognized. An
  
 HTTP URL that references an external image file is converted into an inline <IMG...>
  
 tag. Hyperlinks starting
  link:
  are assumed to refer to local files whose paths are rela-
  
 tive to the
  --op
  directory, where output files are stored.
  
 Hyperlinks can also be of the form
  label[url]
 , in which case the label is used in
  
 the displayed text and
  url
  is used as the target. If the label contains multiple words,
  
 surround it in braces:
  {two words}[url]
 .",NA
Lists,"Lists are typed as indented paragraphs with
  
 • a * or - (for bullet lists),
  
 • a digit followed by a period for numbered lists,
  
 • an uppercase or lowercase letter followed by a period for alpha lists.
  
 For example, you could produce something like the previous text with
  
 # Lists are typed as indented paragraphs with:
  
 # * a '*' or '-' (for bullet lists)
  
 # * a digit followed by a period for
  
 # 
  
 numbered lists
  
 # * an upper or lower case letter followed
  
 # 
  
 by a period for alpha lists.
  
 Note how subsequent lines in a list item are indented to line up with the text in the
  
 element’s first line.
  
 Labeled lists (sometimes called
  description lists
  are typed using square brackets for the
  
 label.
  
 #
  
 [cat]
  
 small domestic animal
  
 #
  
 [+cat+]
  
 command to copy standard input
  
 #
  
 to standard output
  
 Labeled lists may also be produced by putting a double colon after the label. This sets
  
 the result in tabular form, so the descriptions all line up.
  
 # cat:: small domestic animal
  
 # +cat+:: command to copy standard input
  
 # to standard output
  
 Prepared exclusively for Yeganefar",NA
Headings,"Headings are entered on lines starting with equals signs. The more equals signs, the
  
 higher the level of heading.
  
 # = Level One Heading
  
 # == Level Two Heading
  
 # and so on...
  
 Rules (horizontal lines) are entered using three or more hyphens.
  
 # and so it goes...
  
 #----
  
 # The next section...",NA
Documentation Modifiers,"Method parameter lists are extracted and displayed with the method description. If a
  
 method calls
  yield
 , then the parameters passed to yield will also be displayed. For
  
 example, consider the following code.
  
 def fred
  
 ...
  
 yield line, address
  
 This will get documented as:
  
 fred() {|line, address| ... }
  
 You can override this using a comment containing
  :yields: ...
  on the same line as
  
 the method definition.
  
 def fred 
  
 # :yields: index, position
  
 ...
  
 yield line, address
  
 which will get documented as
  
 fred() {|index, position| ... }
  
 Prepared exclusively for Yeganefar",NA
Adding RDoc to C Extensions,"RDoc also understands many of the conventions used when writing extensions to Ruby 
 in C.
  
 Most C extensions have an
  Init_
 Classname
  function. RDoc takes this as the class 
 definition—any C comment before the
  Init_
  method will be used as the class’s docu-
 mentation.
  
 The
  Init_
  function is normally used to associate C functions with Ruby method names. 
 For example, a
  Cipher
  extension may define a Ruby method
  salt=
 , implemented by the 
 C function
  salt_set
  using a call such as
  
 rb_define_method(cCipher, ""salt="", salt_set, 1);
  
 RDoc parses this call, adding the
  salt=
  method to the class documentation. RDoc then 
 searches the C source for the C function
  salt_set
 . If this function is preceded by a 
 comment block, RDoc uses this for the method’s documentation.
  
 This basic scheme works with no effort on your part beyond writing the normal doc-
 umentation in the comments for functions. However, RDoc cannot discern the calling 
 sequence for the corresponding Ruby method. In this example, the RDoc output will
  
 Prepared exclusively for Yeganefar",NA
Running RDoc,"You run RDoc from the command line.
  
 %
  rdoc
  [options] 
  
 [filenames...]
  
 Type
  rdoc --help
  for an up-to-date option summary.
  
 Files are parsed, and the information they contain collected, before any output is pro-
 duced. This allows cross-references between all files to be resolved. If a name is a 
 directory, it is traversed. If no names are specified, all Ruby files in the current direc-
 tory (and subdirectories) are processed.
  
 A typical use may be to generate documentation for a package of Ruby source (such as 
 RDoc itself).
  
 %
  rdoc
  
 This command generates HTML documentation for all the Ruby and C source files in 
 and below the current directory. These will be stored in a documentation tree starting 
 in the subdirectory
  doc/
 .
  
 RDoc uses file extensions to determine how to process each file. Filenames ending
  .rb 
 and
  .rbw
  are assumed to be Ruby source. Files ending
  .c
  are parsed as C files. All 
 other files are assumed to contain just markup (with or without leading
  #
  comment 
 markers). If directory names are passed to RDoc, they are scanned recursively for C 
 and Ruby source files only. To include nonsource files such as
  README
 s in the 
 documentation process, their names must be given explicitly on the command line.
  
 When writing a Ruby library, you often have some source files that implement the 
 public interface, but the majority are internal and of no interest to the readers of your 
 documentation. In these cases, construct a
  .document
  file in each of your project’s 
 directories. If RDoc enters a directory containing a
  .document
  file, it will process only 
 the files in that directory whose names match one of the lines in that file. Each line in 
 the file can be a filename, a directory name, or a wildcard (a file system 
 “glob”pattern). For example, to include all Ruby files whose names start
  main
 , along 
 with the file
  constants.rb
 , you could use a
  .document
  file containing
  
 main*.rb 
  
 constants.rb
  
 Some project standards ask for documentation in a top-level
  README
  file. You may 
 find it convenient to write this file in RDoc format, and then use the
  :include:
  directive 
 to incorporate this document into that for the main class.
  
 Prepared exclusively for Yeganefar",NA
Create Documentation for ri ,"RDoc is also used to create documentation which will be later displayed using ri.
  
 When you run ri, it by default looks for documentation in three places:
 2 
  
  
 1. the
  system
  documentation directory, which holds the documentation distributed 
   
 with Ruby, and which is created by the Ruby install process, 
  
  
 2. the
  site
  directory, which contains sitewide documentation added locally, and 
  
 3. the
  user
  documentation directory, stored under the user’s own home directory. You 
 can find these three directories in the following locations.
  
 •
  $datadir/ri/<ver>/system/...
  
 •
  $datadir/ri/<ver>/site/...
  
 •
  ~/.rdoc/...
 .
  
 The variable
  $datadir
  is the configured data directory for the installed Ruby. Find your 
 local
  datadir
  using 
  
  
 ruby -r rbconfig -e 'p Config::CONFIG[""datadir""]' 
  
 To add documentation to ri, you need to tell RDoc which output directory to use. For 
 your own use, it’s easiest to use the
  --ri
  option.
  
  
 % rdoc --ri 
  
 file1.rb file2.rb 
  
 If you want to install sitewide documentation, use the
  --ri-site
  option.
  
  
 % rdoc --ri-site file1.rb file2.rb 
  
 The
  --ri-system
  option is normally used only to install documentation for Ruby’s built-
 in classes and standard libraries. You can regenerate this documentation from the Ruby 
 source distribution (not from the installed libraries themselves).
  
 % cd <ruby source base>/lib 
  
 % rdoc --ri-system",NA
Displaying Program Usage ,"Most command line programs have some kind of facility to describe their correct 
 usage; give them invalid parameters and they’ll report a short error message followed 
 by a syn-opsis of their actual options. And, if you’re using RDoc, you’ll probably have 
 described
  
 2.
  
 You can override the directory location using the
  --op
  option to RDoc, and subsequently using the
  
 --doc-dir
  option with ri.",NA
Chapter 17,NA,NA
Package Management,NA,NA
with RubyGems,"RubyGems is a standardized packaging and installation framework for libraries and 
 applications, making it easy to locate, install, upgrade, and uninstall Ruby packages. 
 It provides users and developers with four main facilities.
  
 1. A standardized package format,
  
 2. A central repository for hosting packages in this format,
  
 3. Installation and management of multiple, simultaneously installed versions of the 
  
 same library,
  
 4. End-user tools for querying, installing, uninstalling, and otherwise manipulating 
  
 these packages.
  
 Before RubyGems came along, installing a new library involved searching the Web, 
 downloading a package, and attempting to install it—only to find that its 
 dependencies haven’t been met. If the library you want is packaged using RubyGems, 
 however, you can now simply ask RubyGems to install it (and all its dependencies). 
 Everything is done for you.
  
 In the RubyGems world, developers bundle their applications and libraries into single 
 files called
  gems
 . These files conform to a standardized format, and the RubyGems 
 system provides a command-linetool, appropriately named
  gem
 , for manipulating 
 these gem files.
  
 In this chapter, we’ll see how to
  
 1. Install RubyGems on your computer.
  
 2. Use RubyGems to install other applications and libraries.
  
 3. Write your own gems.
  
 Prepared exclusively for Yeganefar 
 203",NA
Installing RubyGems,"To use RubyGems, you’ll first need to download and install the RubyGems system 
 from the project’s home page at
  http://rubygems.rubyforge.org
 . After downloading and 
 unpacking the distribution, you can install it using the included installation script.
  
 %
  cd rubygems-0.7.0 
  
 %
  ruby install.rb
  
 Depending on your operating system, you may need suitable privileges to write files 
 into Ruby’s
  site_ruby/
  and
  bin/
  directories.
  
 The best way to test that RubyGems was installed successfully also happens to be the 
 most important command you’ll learn.
  
 %
  gem help 
  
 RubyGems is a sophisticated package manager for Ruby. This is a basic help message 
 containing pointers to more information.
  
 Usage: 
  
 gem -h/--help 
  
 gem -v/--version 
  
 gem command [arguments...] [options...]
  
 Examples: 
  
 gem install rake 
  
 gem list --local 
  
 gem build package.gemspec 
  
 gem help install
  
 Further help: 
  
 gem help commands list all 'gem' commands 
  
 gem help examples show some examples of usage 
  
 gem help <COMMAND> show help on COMMAND 
  
   
 (e.g. 'gem help install') 
  
 Further information: 
  
 http://rubygems.rubyforge.org
  
 Because RubyGems’ help is quite comprehensive, we won’t go into detail about each 
 of the available RubyGems commands and options in this chapter.",NA
Installing Application Gems,"Let’s start by using RubyGems to install an application that is written in Ruby. Jim 
 Weirich’s Rake (
 http://rake.rubyforge.org
 ) holds the distinction of being the first 
 application that was available as a gem. Not only that, but it’s generally a great tool 
 to have around, as it is a build tool similar to Make and Ant. In fact, you can even use 
 Rake to build gems!
  
 Locating and installing Rake with RubyGems is simple.
  
 Prepared exclusively for Yeganefar",NA
Installing and Using Gem Libraries,"Using RubyGems to install a complete application was a good way to get your feet 
 wet and to start to learn your way around the
  gem
  command. However, in most cases, 
 you’ll use RubyGems to install Ruby libraries for use in your own programs. Since 
 RubyGems enables you to install and manage multiple versions of the same library, 
 you’ll also need to do some new, RubyGems-specific things when you require those 
 libraries in your code.
  
 Perhaps you’ve been asked by your mother to create a program to help her maintain 
 and publish a diary. You have decided that you would like to publish the diary in 
 HTML format, but you are worried that your mother may not understand all of the ins 
 and outs of HTML markup. For this reason, you’ve opted to use one of the many 
 excellent tem-plating packages available for Ruby. After some research, you’ve 
 decided on Michael Granger’s BlueCloth, based on its reputation for being very 
 simple to use.
  
 You first need to find and install the BlueCloth gem.
  
 %
  gem query -rn Blue
  
 *** REMOTE GEMS ***
  
 BlueCloth (0.0.4, 0.0.3, 0.0.2) 
  
 BlueCloth is a Ruby implementation of Markdown, a text-to-HTML conversion tool for web 
 writers. Markdown allows you to write using an easy-to-read, easy-to-write plain text format, 
 then convert it to structurally valid XHTML (or HTML).
  
 Prepared exclusively for Yeganefar",NA
Generating API Documentation,"Being that this is your first time using BlueCloth, you’re not exactly sure how to use 
 it. You need some API documentation to get started. Fortunately, with the addition of 
 the
 --rdoc
  option to the
  install
  command, RubyGems will generate RDoc documen-
 tation for the gem it is installing. For more information on RDoc, see Chapter
  16
  on 
 page
  187
 .
  
 %
  gem install -r BlueCloth --rdoc
  
 Attempting remote installation of 'BlueCloth' 
  
 Successfully installed BlueCloth, version 0.0.4 
  
 Installing RDoc documentation for BlueCloth-0.0.4... 
  
 WARNING: Generating RDoc on .gem that may not have RDoc.
  
 bluecloth.rb: cc..............................
  
 Generating HTML...
  
 Having generated all this useful HTML documentation, how can you view it? You 
 have at least two options. The hard way (though it really isn’t that hard) is to open 
 RubyGems’ documentation directory and browse the documentation directly. As with 
 most things in RubyGems, the documentation for each gem is stored in a central, pro-
 tected, RubyGems-specific place. This will vary by system and by where you may 
 explicitly choose to install your gems. The most reliable way to find the documents is 
 to ask the
  gem
  command where your RubyGems main directory is located. For exam-
 ple:
  
 %
  gem environment gemdir 
  
 /usr/local/lib/ruby/gems/1.8
  
 RubyGems stores generated documentation in the
  doc/
  subdirectory of this directory, 
 in this case
  /usr/local/lib/ruby/gems/1.8/doc
 . You can open the file
  index. html
  and 
 view the documentation. If you find yourself using this path often, you can create a 
 shortcut. Here’s one way to do that on Mac OS X boxes.
  
 %
  gemdoc=`gem environment gemdir`/doc 
  
 %
  ls $gemdoc 
  
 BlueCloth-0.0.4 
  
 %
  open $gemdoc/BlueCloth-0.0.4/rdoc/index.html
  
 Prepared exclusively for Yeganefar",NA
Let’s Code!,"Now you’ve got BlueCloth installed and you know how to use it, you’re ready to 
 write some code. Having used RubyGems to download the library, we can now also 
 use it to load the library components into our application. Prior to RubyGems, we’d 
 say something like
  
 require 'bluecloth'
  
 With RubyGems, though, we can take advantage of its packaging and versioning sup-
 port. To do this, we use
  require_gem
  in place of
  require
 .
  
 require 'rubygems' 
  
 require_gem 'BlueCloth', "">= 0.0.4"" 
  
 doc = BlueCloth::new <<MARKUP
  
 This is some sample [text][1]. 
  
 Just a simple test.
  
 [1]: http://ruby-lang.org 
  
 MARKUP
  
 puts doc.to_html
  
 produces:
  
 Just learning to use [BlueCloth][1].
  
 <p>This is some sample <a href=""http://ruby-lang.org"">text</a>. 
  
 Just
  
 learning to use <a href=""http://ruby-lang.org"">BlueCloth</a>.
  
 Just a simple test.</p>
  
 The first two lines are the RubyGems-specific code. The first line loads the RubyGems
  
 core libraries that we’ll need in order to work with installed gems.
  
 require 'rubygems'
  
 Prepared exclusively for Yeganefar",NA
Dependent on RubyGems?,"Astute readers (that’s all of you) will have noticed that the code we’ve created so far 
 is dependent on the RubyGems package being installed. In the long term, that’ll be a 
 fairly safe bet (we’re guessing that RubyGems will make its way into the Ruby core 
 distribution). For now, though, RubyGems is not part of the standard Ruby 
 distribution,",NA
Creating Your Own Gems,"By now, you’ve seen how easy RubyGems makes things for the users of an applica-
 tion or library and are probably ready to make a gem of your own. If you’re creating 
 code to be shared with the open-source community, RubyGems are an ideal way for 
 end-users to discover, install, and uninstall your code. They also provide a powerful 
 way to manage internal, company projects, or even personal projects, since they make 
 upgrades and rollbacks so simple. Ultimately, the availability of more gems makes 
 the Ruby community stronger. These gems have to come from somewhere; we’re 
 going to show you how they can start coming from you.
  
 Let’s say you’ve finally gotten your mother’s online diary application, MomLog, fin-
 ished, and you have decided to release it under an open-source license. After all, 
 other programmers have mothers, too. Naturally, you want to release MomLog as a 
 gem (moms love it when you give them gems).",NA
Package Layout,"The first task in creating a gem is organizing your code into a directory structure that 
 makes sense. The same rules that you would use in creating a typical tar or zip 
 archive apply in package organization. Some general conventions follow.
  
 • Put all of your Ruby source files under a subdirectory called
  lib/
 . Later, we’ll 
 show you how to ensure that this directory will be added to Ruby’s
  $LOAD_PATH 
 when users load this gem.
  
 • If it’s appropriate for your project, include a file under
  lib/yourproject.rb
  that 
 performs the necessary
  require
  commands to load the bulk of the project’s func-
 tionality. Before RubyGems’ autorequire feature, this made things easier for 
 others to use a library. Even with RubyGems, it makes it easier for others to 
 explore your code if you give them an obvious starting point.
  
 • Always include a
  README
  file including a project summary, author contact infor-
 mation, and pointers for getting started. Use RDoc format for this file so you
  
 Prepared exclusively for Yeganefar",NA
The Gem Specification,"Now that you’ve got your files laid out as you want them, it’s time to get to the heart 
 of gem creation: the gem specification, or
  gemspec
 . A gemspec is a collection of 
 metadata in Ruby or YAML (see page
  737
 ) that provides key information about your 
 gem. The gemspec is used as input to the gem-building process. You can use several 
 different mechanisms to create a gem, but they’re all conceptually the same. Here’s 
 your first, basic MomLog gem.
  
 require 'rubygems'
  
 SPEC = Gem::Specification.new do |s| 
  
 s.name 
  
 = ""MomLog"" 
  
 s.version 
  
 = ""1.0.0"" 
  
 s.author 
  
 = ""Jo Programmer"" 
  
 s.email 
  
  
 = ""jo@joshost.com"" s.homepage = ""http://www.joshost.com/MomLog"" 
  
 s.platform = Gem::Platform::RUBY 
  
 s.summary 
  
 = ""An online Diary for families"" 
  
 candidates = Dir.glob(""{bin,docs,lib,tests}/**/*"") 
  
 s.files 
  
 = candidates.delete_if do |item| 
  
   
  
 item.include?(""CVS"") || item.include?(""rdoc"") 
  
  
 end 
  
 s.require_path 
  
  
 = ""lib"" 
  
 s.autorequire 
  
   
 = ""momlog"" 
  
 s.test_file 
  
    
 = ""tests/ts_momlog.rb"" 
  
 s.has_rdoc 
  
    
 = true 
  
 s.extra_rdoc_files = [""README""] 
  
 s.add_dependency(""BlueCloth"", "">= 0.0.4"") 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Runtime Magic,"The next two attributes,
  require_path
  and
  autorequire
 , let you specify the direc-tories 
 that will be added to the
  $LOAD_PATH
  when
  require_gem
  loads the gem, as well as any 
 files that will automatically be loaded using
  require
 . In this example, 
 lib
  refers to a 
 relative path under the MomLog gem directory, and the
  autorequire 
 will cause
  
 lib/momlog.rb
  to be required when
  require_gem ""MomLog""
  is called. For each of these 
 two attributes, RubyGems provides corresponding plural versions, 
 require_paths
  and
  
 autorequires
 . These take arrays, allowing you to have many files automatically loaded 
 from different directories when the gem is loaded using 
 require_gem
 .",NA
Adding Tests and Documentation,"The
  test_file
  attribute holds the relative pathname to a single Ruby file included in the 
 gem that should be loaded as a
  Test::Unit
  test suite. (You can use the plural form,
  
 test_files
 , to reference an array of files containing tests.) For details on how to create a 
 test suite, see Chapter
  12
  on page
  143
  on unit testing.
  
 Finishing up this example, we have two attributes controlling the production of local 
 documentation of the gem. The
  has_rdoc
  attribute specifies that you have added RDoc 
 comments to your code. It’s possible to run RDoc on totally uncommented code, pro-
 viding a browsable view of its interfaces, but obviously this is a lot less valuable than 
 running RDoc on well-commented code.
  has_rdoc
  is a way for you to tell the 
 world,“Yes. It’s worth generating the documentation for this gem.”
  
 Prepared exclusively for Yeganefar",NA
Adding Dependencies,"For your gem to work properly, users are going to need to have BlueCloth installed.
  
 We saw earlier how to set a load-time version dependency for a library. Now we need 
 to tell our gemspec about that dependency, so the installer will ensure that it is 
 present while installing MomLog. We do that with the addition of a single method 
 call to our 
 Gem::Specification
  object.
  
 s.add_dependency(""BlueCloth"", "">= 0.0.4"")
  
 The arguments to our
  add_dependency
  method are identical to those of
  require_gem
 , 
 which we explained earlier.
  
 After generating this gem, attempting to install it on a clean system would look some-
 thing like this.
  
 %
  gem install pkg/MomLog-1.0.0.gem 
  
 Attempting local installation of 'pkg/MomLog-1.0.0.gem' 
  
 /usr/local/lib/ruby/site_ruby/1.8/rubygems.rb:50:in `require_gem': (LoadError) 
  
 Could not find RubyGem BlueCloth (>= 0.0.4)
  
 Because you are performing a local installation from a file, RubyGems won’t attempt 
 to resolve the dependency for you. Instead, it fails noisily, telling you that it needs 
 Blue-Cloth to complete the installation. You could then install BlueCloth as we did 
 before, and things would go smoothly the next time you attempted to install the 
 MomLog gem.
  
 If you had uploaded MomLog to the central RubyGems repository and then tried to 
 install it on a clean system, you would be prompted to automatically install BlueCloth 
 as part of the MomLog installation.
  
 %
  gem install -r MomLog 
  
 Attempting remote installation of 'MomLog' 
  
 Install required dependency BlueCloth? [Yn] 
  
 y 
  
 Successfully installed MomLog, version 1.0.0
  
 Now you’ve got both BlueCloth and MomLog installed, and your mother can start 
 happily publishing her diary. Had you chosen not to install BlueCloth, the installation 
 would have failed as it did during the local installation attempt.
  
 As you add more features to MomLog, you may find yourself pulling in additional 
 external gems to support those features. The
  add_dependency
  method can be called 
 multiple times in a single gemspec, supporting as many dependencies as you need it 
 to support.",NA
Ruby Extension Gems,"So far, all of the examples we’ve looked at have been pure Ruby code. However, 
 many Ruby libraries are created as native extensions (see Chapter
  21
  on page
  261
 ). 
 You have two ways to package and distribute this kind of library as a gem. You can 
 distribute the gem in source format and have the installer compile the code at 
 installation time. Alter-natively, you can precompile the extensions and distribute one 
 gem for each separate platform you want to support.
  
 For source gems, RubyGems provides an additional
  Gem::Specification
  attribute called
  
 extensions
 . This attribute is an array of paths to Ruby files that will generate 
 Makefiles. The most typical way to create one of these programs is to use Ruby’s
  
 mkmf 
 library (see Chapter
  21
  on page
  261
  and the appendix about
  mkmf
  on page
  755
 ). 
 These files are conventionally named
  extconf.rb
 , though any name will do.
  
 Your mom has a computerized recipe database that is near and dear to her heart. She 
 has been storing her recipes in it for years, and you would like to give her the ability 
 to publish these recipes on the Web for her friends and family. You discover that the 
 recipe program, MenuBuilder, has a fairly nice native API and decide to write a Ruby 
 extension to wrap it. Since the extension may be useful to others who aren’t 
 necessarily using MomLog, you decide to package it as a separate gem and add it as 
 an additional dependency for MomLog.
  
 Here’s the gemspec.
  
 require 'rubygems'
  
 spec = Gem::Specification.new do |s| 
  
 s.name = ""MenuBuilder"" 
  
 s.version = ""1.0.0"" 
  
 s.author = ""Jo Programmer"" 
  
 s.email = ""jo@joshost.com"" 
  
 s.homepage = ""http://www.joshost.com/projects/MenuBuilder"" 
  
 s.platform = Gem::Platform::RUBY 
  
 s.summary = ""A Ruby wrapper for the MenuBuilder recipe database."" s.files = [""ext/main.c"", 
 ""ext/extconf.rb""] 
  
 s.require_path = ""."" 
  
 s.autorequire = ""MenuBuilder"" 
  
 s.extensions = [""ext/extconf.rb""] 
  
 end
  
 if $0 == __FILE__ 
  
 Gem::manage_gems 
  
 Gem::Builder.new(spec).build 
  
 end
  
 Note that you have to include source files in the specification’s
  files
  list so they’ll be 
 included in the gem package for distribution.
  
 When a source gem is installed, RubyGems runs each of its
  extensions
  programs and 
 then executes the resultant Makefile.
  
 Prepared exclusively for Yeganefar",NA
Building the Gem File,"The MomLog gemspec we just created is runnable as a Ruby program. Invoking it will 
 create a gem file,
  MomLog-0.5.0.gem
 .
  
 %
  ruby momlog.gemspec 
  
 Attempting to build gem spec 'momlog.gemspec' 
  
 Successfully built RubyGem 
  
 Name: MomLog 
  
 Version: 0.5.0 
  
 File: MomLog-0.5.0.gem",NA
Building with Rake,"Last but certainly not least, we can use Rake to build gems (remember Rake, the 
 pure-Ruby build tool we mentioned back on page
  204
 ). Rake uses a command file 
 called a 
 Rakefile
  to control the build. This defines (in Ruby syntax!) a set of
  rules
  and
  
 tasks. 
 The intersection of make’s rule-driven concepts and Ruby’s power make for a 
 build and release automator’s dream environment. And, what release of a Ruby 
 project would be complete without the generation of a gem?
  
 For details on how to use Rake, see
  http://rake.rubyforge.org
 . Its documents are 
 comprehensive and always up-to-date. Here, we’ll focus on just enough Rake to build 
 a gem. From the Rake documentation:
  
 Tasks are the main unit of work in a Rakefile. Tasks have a name (usually given as a 
 symbol or a string), a list of prerequisites (more symbols or strings), and a list of 
 actions (given as a block).
  
 Normally, you can use Rake’s built-in
  task
  method to define your own named tasks in 
 your Rakefile. For special cases, it makes sense to provide helper code to automate 
 some of the repetitive work you would have to do otherwise. Gem creation is one of
  
 Prepared exclusively for Yeganefar",NA
Maintaining Your Gem,NA,NA
(and One Last Look at MomLog),"You’ve released MomLog, and it’s attracting new, adoring users every week. You have 
 taken great care to package it cleanly and are using Rake to build your gem.
  
 Your gem being “in the wild” with your contact information attached to it, you know 
 that it’s only a matter of time before you start receiving feature requests (and fan 
 mail!) from your users. But, your first request comes via a phone call from none other 
 than dear old Mom. She has just gotten back from a vacation in Florida and asks you 
 how she can include her vacation pictures in her diary. You don’t think an 
 explanation of command-line FTP would be time well spent, and being the ever-
 devoted son or daugh-ter, you spend your evening coding a nice photo album module 
 for MomLog.
  
 Since you have added functionality to the application (as opposed to just fixing a 
 bug), you decide to increase MomLog’s version number from 1.0.0 to 1.1.0. You also 
 add a set of tests for the new functionality and a document about how to set up the 
 photo upload functionality.
  
 Figure
  17.1
  on the next page shows the complete directory structure of your final 
 Mom-Log 1.1.0 package. The final gem specification (extracted from the Rakefile) 
 looks like this.
  
 spec = Gem::Specification.new do |s| 
  
 s.name 
  
 = ""MomLog"" 
  
 s.version 
  
 = ""1.1.0"" 
  
 s.author 
  
 = ""Jo Programmer"" 
  
 s.email 
  
  
 = ""jo@joshost.com"" s.homepage = ""http://www.joshost.com/MomLog"" 
  
 s.platform = Gem::Platform::RUBY 
  
 s.summary 
  
 = ""An online diary, recipe publisher, "" + 
  
   
 ""and photo album for families."" 
  
 s.files = FileList[""{bin,tests,lib,docs}/**/*""].exclude(""rdoc"").to_a s.require_path 
  
   
 = ""lib"" s.autorequire 
  
  
 = ""momlog"" 
  
 s.test_file 
  
  
  
 = ""tests/ts_momlog.rb"" 
  
 s.has_rdoc 
  
  
  
 = true 
  
 s.extra_rdoc_files = [""README"", ""docs/DatabaseConfiguration.rdoc"", 
  
  
 ""docs/Installing.rdoc"", ""docs/PhotoAlbumSetup.rdoc""] s.add_dependency(""BlueCloth"", "">= 
 0.0.4"") 
  
 s.add_dependency(""MenuBuilder"", "">= 1.0.0"") 
  
 end",NA
Chapter 18,NA,NA
Ruby and the Web,"Ruby is no stranger to the Internet. Not only can you write your own SMTP server, 
 FTP daemon, or Web server in Ruby, but you can also use Ruby for more usual tasks 
 such as CGI programming or as a replacement for PHP.
  
 Many options are available for using Ruby to implement Web applications, and a 
 single chapter can’t do them all justice. Instead, we’ll try to touch some of the 
 highlights and point you toward libraries and resources that can help.
  
 Let’s start with some simple stuff: running Ruby programs as Common Gateway Inter-
 face (CGI) programs.",NA
Writing CGI Scripts,"You can use Ruby to write CGI scripts quite easily. To have a Ruby script generate 
 HTML output, all you need is something like
  
 #!/usr/bin/ruby 
  
 print ""Content-type: text/html\r\n\r\n"" 
  
 print ""<html><body>Hello World! It's #{Time.now}</body></html>\r\n""
  
 Put this script in a CGI directory, mark it as executable, and you’ll be able to access it 
 via your browser. (If your Web server doesn’t automatically add headers, you’ll need 
 to add the response header yourself.)
  
 #!/usr/bin/ruby 
  
 print ""HTTP/1.0 200 OK\r\n"" 
  
 print ""Content-type: text/html\r\n\r\n"" 
  
 print ""<html><body>Hello World! It's #{Time.now}</body></html>\r\n""
  
 However, that’s hacking around at a pretty low level. You’d need to write your own 
 request parsing, session management, cookie manipulation, output escaping, and so 
 on. Fortunately, options are available to make this easier.
  
 Prepared exclusively for Yeganefar 
 222",NA
Using cgi.rb,"Class
  CGI
  provides support for writing CGI scripts. With it, you can manipulate forms, 
 cookies, and the environment; maintain stateful sessions; and so on. It’s a fairly large 
 class, but we’ll take a quick look at its capabilities here.",NA
Quoting,"When dealing with URLs and HTML code, you must be careful to quote certain char-
 acters. For instance, a slash character (
  /
  ) has special meaning in a URL, so it must 
 be “escaped” if it’s not part of the pathname. That is, any
  /
  in the query portion of the 
 URL will be translated to the string
  %2F
  and must be translated back to a
  /
  for you to 
 use it. Space and ampersand are also special characters. To handle this,
  CGI
  provides 
 the routines
  CGI.escape
  and
  CGI.unescape
 .
  
 require 'cgi' 
  
 puts CGI.escape(""Nicholas Payton/Trumpet & Flugel Horn"")
  
 produces:
  
 Nicholas+Payton%2FTrumpet+%26+Flugel+Horn
  
 More frequently, you may want to escape HTML special characters.
  
 require 'cgi' 
  
 puts CGI.escapeHTML(""a < 100 && b > 200"")
  
 produces:
  
 a &lt; 100 &amp;&amp; b &gt; 200
  
 To get really fancy, you can decide to escape only certain HTML elements within a 
 string.
  
 require 'cgi' 
  
 puts CGI.escapeElement('<hr><a href=""/mp3"">Click Here</a><br>','A')
  
 produces:
  
 <hr>&lt;a href=&quot;/mp3&quot;&gt;Click Here&lt;/a&gt;<br>
  
 Here only the
  A
  element is escaped; other elements are left alone. Each of these 
 methods has an “
 un
 -” version to restore the original string.
  
 require 'cgi' 
  
 puts CGI.unescapeHTML(""a &lt; 100 &amp;&amp; b &gt; 200"")
  
 produces:
  
 a < 100 && b > 200
  
 Prepared exclusively for Yeganefar",NA
Query Parameters,"HTTP requests from the browser to your application may contain parameters, either 
 passed as part of the URL or passed as data embedded in the body of the request.
  
 Processing of these parameters is complicated by the fact that a value with a given 
 name may be returned multiple times in the same request. For example, say we’re 
 writing a survey to find out why folks like Ruby. The HTML for our form looks like 
 this.
  
 <html> 
  
 <head><title>Test Form</title></head> 
  
 <body> 
  
  
 I like Ruby because:
  
 <form target=""cgi-bin/survey.rb""> 
  
  
 <input type=""checkbox"" name=""reason"" value=""flexible"" /> 
   
 It's 
 flexible<br /> 
  
  
 <input type=""checkbox"" name=""reason"" value=""transparent"" /> 
  
  
 It's transparent<br /> 
  
  
 <input type=""checkbox"" name=""reason"" value=""perlish"" /> 
  
  
 It's like 
 Perl<br /> 
  
  
 <input type=""checkbox"" name=""reason"" value=""fun"" /> 
  
   
 It's fun
  
 <p> 
  
 Your name: <input type=""text"" name=""name""> 
  
 </p>
  
 <input type=""submit""/>
  
 </form>
  
 </body> 
  
 </html>
  
 When someone fills in this form, they might check multiple reasons for liking Ruby 
 (as shown in Figure
  18.1
  on the following page). In this case, the form data 
 corresponding to the name
  reason
  will have three values, corresponding to the three 
 checked boxes.
  
 Class
  CGI
  gives you access to form data in a couple of ways. First, we can just treat the 
 CGI object as a hash, indexing it with field names and getting back field values.
  
 require 'cgi' 
  
 cgi = CGI.new
  
 1.8
  
  
 cgi['name']
  
 →
  
 ""Dave Thomas""
  
 cgi['reason']
  
 →
  
 ""flexible""
  
 However, this doesn’t work well with the
  reason
  field: we see only one of the three
  
 values
 .
  
 We can ask to see them all by using the
  CGI
 #
 params
  method. The value returned
  
 by
  params
  acts like a hash containing the request parameters. You can both read and 
 write this hash (the latter allows you to modify the data associated with a request). 
 Note that each of the values in the hash is actually an array.",NA
Installing eruby in Apache,"If you want to use
  erb
 -like page generation for a Web site that gets a reasonable 
 amount of traffic, you’ll probably want to switch across to using
  eruby
 , which has 
 better per-formance. You can then configure the Apache Web server to automatically 
 parse Ruby-embedded documents using eRuby, much in the same way that PHP does. 
 You create Ruby-embedded files with an
  .rhtml
  suffix and configure the Web server 
 to run the 
 eruby
  executable on these documents to produce the desired HTML output.
  
 Prepared exclusively for Yeganefar",NA
Cookies,"Cookies are a way of letting Web applications store their state on the user’s machine. 
 Frowned upon by some, cookies are still a convenient (if unreliable) way of 
 remember-ing session information.
  
 The Ruby CGI class handles the loading and saving of cookies for you. You can 
 access the cookies associated with the current request using the
  CGI
 #
 cookies
  method, 
 and you can set cookies back into the browser by setting the
  cookies
  parameter of
  
 CGI
 #
 out
  to reference either a single cookie or an array of cookies.
  
 #!/usr/bin/ruby 
  
 COOKIE_NAME = 'chocolate chip' 
  
 require 'cgi' 
  
 cgi = CGI.new 
  
 values = cgi.cookies[COOKIE_NAME] 
  
 if values.empty?
  
 msg = ""It looks as if you haven't visited recently"" 
  
 else 
  
 msg = ""You last visited #{values[0]}"" 
  
 end 
  
 cookie = CGI::Cookie.new(COOKIE_NAME, Time.now.to_s) 
  
 cookie.expires = Time.now + 30*24*3600 # 30 days 
  
 cgi.out(""cookie"" => cookie ) { msg }
  
 Prepared exclusively for Yeganefar",NA
Sessions,"Cookies by themselves still need a bit of work to be useful. We really want
  session: 
 information that persists between requests from a particular Web browser. Sessions 
 are handled by class
  CGI::Session
 , which uses cookies but provides a higher-level 
 abstraction.
  
 As with cookies, sessions emulate a hashlike behavior, letting you associate values 
 with keys. Unlike cookies, sessions store the majority of their data on the server, 
 using the browser-resident cookie simply as a way of uniquely identifying the server-
 side data. Sessions also give you a choice of storage techniques for this data: it can be 
 held in regular files, in a PStore (see the description on page
  698
 ), in memory, or 
 even in your own customized store.
  
 Sessions should be closed after use, as this ensures that their data is written out to the 
 store. When you’ve permanently finished with a session, you should delete it.
  
 require 'cgi' 
  
 require 'cgi/session'
  
 cgi = CGI.new(""html3"") 
  
 sess = CGI::Session.new(cgi, 
  
 ""session_key"" => ""rubyweb"", 
  
 ""prefix"" => ""web-session."" 
  
 )
  
 if sess['lastaccess'] 
  
 msg = ""You were last here #{sess['lastaccess']}."" 
  
 else 
  
 msg = ""Looks like you haven't been here for a while"" 
  
 end
  
 count = (sess[""accesscount""] || 0).to_i 
  
 count += 1
  
 msg << ""<p>Number of visits: #{count}""
  
 sess[""accesscount""] = count 
  
 sess[""lastaccess""] 
  
 = Time.now.to_s 
  
 sess.close
  
 cgi.out { 
  
 cgi.html { 
  
  
 cgi.body { 
  
    
 msg 
  
  
 } 
  
 } 
  
 }
  
 The code in the previous example used the default storage mechanism for sessions: per-
  
 1.8
  
  
 sistent data was stored in files in your default temporary directory (see
  Dir.tmpdir
 ).
  
 The filenames will all start
  web-session.
  and will end with a hashed version
  
 of the
  
 session number. See
  ri CGI::Session
  for more information.
  
 Prepared exclusively for Yeganefar",NA
Improving Performance,"You can use Ruby to write CGI programs for the Web, but, as with most CGI 
 programs, the default configuration has to start a new copy of Ruby with every cgi-
 bin page access. That’s expensive in terms of machine utilization and can be painfully 
 slow for Web surfers. The Apache Web server solves this problem by supporting 
 loadable
  modules
 .
  
 Typically, these modules are dynamically loaded and become part of the running 
 Web server process—you have no need to spawn another interpreter over and over 
 again to service requests; the Web server
  is
  the interpreter.
  
 And so we come to
  mod_ruby
  (available from the archives), an Apache module that 
 links a full Ruby interpreter into the Apache Web server itself. The
  README
  file 
 included with
  mod_ruby
  provides details on how to compile and install it.
  
 Once installed and configured, you can run Ruby scripts pretty much as you could 
 without
  mod_ruby
 , except that now they will come up much faster. You can also take 
 advantage of the extra facilities that
  mod_ruby
  provides (such as tight integration into 
 Apache’s request handling).
  
 You have some things to watch, however. Because the interpreter remains in mem-
 ory between requests, it may end up handling requests from multiple applications. It’s 
 possible for libraries in these applications to clash (particularly if different libraries 
 contain classes with the same name). You also cannot assume that the same 
 interpreter will handle the series of requests from one browser’s session—Apache 
 will allocate handler processes using its internal algorithms.
  
 Some of these issues are resolved using the FastCGI protocol. This is an interesting 
 hack, available to all CGI-style programs, not just Ruby. It uses a very small proxy 
 program, typically running as an Apache module. When requests are received, this 
 proxy then forwards them to a particular long-running process that acts like a normal 
 CGI script. The results are fed back to the proxy, and then back to the browser. 
 FastCGI has the same advantages as running
  mod_ruby
 , as the interpreter is always 
 running in the background. It also gives you more control over how requests are 
 allocated to interpreters. You’ll find more information at
  http://www.fastcgi.com
 .",NA
Choice of Web Servers,"1.8
  
  
 So far, we’ve been running Ruby scripts under the control of the Apache Web server.
  
 However, Ruby 1.8
  
 and later comes bundled with WEBrick, a flexible, pure-Ruby
  
 HTTP server toolkit. Basically, it’s an extensible plug in–based framework that lets 
 you write servers to handle HTTP reuqests and responses. Here’s a basic HTTP 
 server that serves documents and directory indexes.",NA
SOAP and Web Services,"1.8
  
  
 Speaking of 
 SOAP,
  
 Ruby now comes with an implementation of SOAP.
 3
 This lets you
  
 write both servers and clients using Web services. By their nature, these applications 
 can operate both locally and remotely across a network. SOAP applications are also 
 unaware of the implementation language of their network peers, so SOAP is a conve-
 nient way of interconnecting Ruby applications with those written in languages such 
 as Java, Visual Basic, or C++.
  
 SOAP is basically a marshaling mechanism which uses XML to send data between 
 two nodes in a network. It is typically used to implement remote procedure calls, 
 RPCs, between distributed processes. A SOAP server publishes one or more 
 interfaces. These interfaces are defined in terms of data types and methods that use 
 those types. SOAP clients then create local proxies that SOAP connects to interfaces 
 on the server. A call to a method on the proxy is then passed to the corresponding 
 interface on the server. Return values generated by the method on the server are 
 passed back to the client via the proxy.
  
 Let’s start with a trivial SOAP service. We’ll write an object that does interest 
 calcula-tions. Initially, it offers a single method,
  compound
 , that determines compound 
 interest given a principal, an interest rate, the number of times interested is 
 compounded per year, and the number of years. For management purposes, we’ll also 
 keep track of how many times this method was called and make that count available 
 via an accessor. Note that this class is just regular Ruby code—it doesn’t know that 
 it’s running in a SOAP environment.
  
 class InterestCalculator
  
 attr_reader :call_count
  
 def initialize 
  
 @call_count = 0 
  
 end
  
 def compound(principal, rate, freq, years) 
  
 @call_count += 1 
  
 principal*(1.0 + rate/freq)**(freq*years) 
  
 end
  
 end
  
 Now we’ll make an object of this class available via a SOAP server. This will enable 
 client applications to call the object’s methods over the network. We’re using the 
 stand-alone server here, which is convenient when testing, as we can run it from the 
 command line. You can also run Ruby SOAP servers as CGI scripts or under
  
 mod_ruby
 .
  
 3.
  
 SOAP once stood for Simple Object Access Protocol. When folks could no longer stand the irony, the
  
 acronym was dropped, and now SOAP is just a name.",NA
SOAP and Google,"Obviously the real benefit of SOAP is the way it lets you interoperate with other 
 services on the Web. As an example, let’s write some Ruby code to send queries to 
 Google’s Web API.
  
 Before sending queries to Google, you need a developer key. This is available from 
 Google—go to
  http://www.google.com/apis
  and follow the instructions in step 2, 
 Create a Google Account
 . After you fill in your e-mail address and supply a 
 password, Google will send you a developer key. In the following examples, we’ll 
 assume that you’ve stored this key in the file
  .google_key
  in your home directory.
  
 Let’s start at the most basic level. Looking at the documentation for the Google API 
 method
  doGoogleSearch
 , we discover it has ten (!) parameters.
  
 key 
 The developer key
  
 q 
 The query string
  
 start 
 The index of the first required result
  
 maxResults 
 The maximum number of results to return per query
  
 filter 
 If enabled, compresses results so that similar pages and pages from the same 
 domain are only shown once
  
 restrict 
 Restricts the search to a subset of the Google Web index
  
 safeSearch 
 If enabled, removes possible adult content from the results
  
 lr 
 Restricts the search to documents in a given set of languages
  
 ie 
 Ignored (was input encoding)
  
 oe 
 Ignored (was output encoding)
  
 We can use the
  add_method
  call to construct a SOAP proxy for the
  doGoogleSearch 
 method. The following example does just that, printing out the first entry returned if 
 you search Google for the term
  pragmatic
 .
  
 Prepared exclusively for Yeganefar",NA
More Information,"Ruby Web programming is a big topic. To dig deeper, you may want to look at 
 Chapter 9 in
  The Ruby Way
  [
 Ful01
 ], where you’ll find many examples of network 
 and Web programming, and Chapter 6 of
  The Ruby Developer’s Guide
  [
 FJN02
 ], 
 where you’ll find some good examples of structuring CGI applications, along with 
 some example Iowa code.
  
 If SOAP strikes you being complex, you may want to look at using XML-RPC, which 
 is described briefly on page
  736
 .
  
 A number of other Ruby Web development frameworks are available on the ’net. 
 This is a dynamic area: new contenders appear constantly, and it is hard for a printed 
 book to be definitive. However, two frameworks that are currently attracting 
 mindshare in the Ruby community are
  
 • Rails (
 http://www.rubyonrails.org
 ), and
  
 • CGIKit (
 http://www.spice-of-life.net/cgikit/index_en.html
 ).
  
 Prepared exclusively for Yeganefar",NA
Chapter 19,NA,NA
Ruby Tk,"The Ruby Application Archive contains several extensions that provide Ruby with a 
 graphical user interface (GUI), including extensions for Fox, GTK, and others.
  
 The Tk extension is bundled in the main distribution and works on both Unix and 
 Windows systems. To use it, you need to have Tk installed on your system. Tk is a 
 large system, and entire books have been written about it, so we won’t waste time or 
 resources by delving too deeply into Tk itself but instead concentrate on how to 
 access Tk features from Ruby. You’ll need one of these reference books in order to 
 use Tk with Ruby effectively. The binding we use is closest to the Perl binding, so 
 you probably want to get a copy of
  Learning Perl/Tk
  [
 Wal99
 ] or
  Perl/Tk Pocket 
 Reference
  [
 Lid98
 ].
  
 Tk works along a composition model—that is, you start by creating a container (such 
 as a
  TkFrame
  or
  TkRoot
 ) and then create the widgets (another name for GUI 
 components) that populate it, such as buttons or labels. When you are ready to start 
 the GUI, you invoke
  Tk.mainloop
 . The Tk engine then takes control of the program, 
 displaying widgets and calling your code in response to GUI events.",NA
Simple Tk Application,"A simple Tk application in Ruby may look something like this.
  
 require 'tk' 
  
 root = TkRoot.new { title ""Ex1"" } 
 TkLabel.new(root) do
  
  
 text
  
 'Hello, World!'
  
 pack
  
 { padx 15 ; pady 15; side 'left' }
  
 end 
  
 Tk.mainloop
  
 Let’s look at the code a little more closely. After loading the
  tk
  extension module, we 
 create a root-level frame using
  TkRoot.new
 . We then make a
  TkLabel
  widget as a",NA
Widgets,"Creating widgets is easy. Take the name of the widget as given in the Tk 
 documentation and add a
  Tk
  to the front of it. For instance, the widgets
  Label
 ,
  Button
 , 
 and
  Entry 
 become the classes
  TkLabel
 ,
  TkButton
 , and
  TkEntry
 . You create an instance of 
 a widget using
  new
 , just as you would any other object. If you don’t specify a parent 
 for a given widget, it will default to the root-level frame. We usually want to specify 
 the parent of a given widget, along with many other options—color, size, and so on. 
 We also need to be able to get information back from our widgets while our program 
 is running by setting up
  callbacks
  (routines invoked when certain events happen) and 
 sharing data.",NA
Setting Widget Options,"If you look at a Tk reference manual (the one written for Perl/Tk, for example), you’ll 
 notice that options for widgets are usually listed with a hyphen—as a command-line 
 option would be. In Perl/Tk, options are passed to a widget in a
  Hash
 . You can do that 
 in Ruby as well, but you can also pass options using a code block; the name of the 
 option is used as a method name within the block and arguments to the option appear 
 as arguments to the method call. Widgets take a parent as the first argument, followed 
 by an optional hash of options or the code block of options. Thus, the following two 
 forms are equivalent.
  
 TkLabel.new(parent_widget) do 
  
 text 
  
 'Hello, World!' 
  
 pack('padx' => 5, 
  
  
 'pady' => 5, 
  
  
 'side' 
  
 => 'left') end 
  
 # or 
  
 TkLabel.new(parent_widget, 'text' => 'Hello, World!').pack(...)
  
 Prepared exclusively for Yeganefar",NA
Getting Widget Data,"We can get information back from widgets by using callbacks and by binding variables.
  
 Callbacks are very easy to set up. The
  command
  option (shown in the
  TkButton
  call in 
 the example that follows) takes a
  Proc
  object, which will be called when the callback 
 fires. Here we pass the proc in as a block associated with the method call, but we 
 could also have used
  Kernel.lambda
  to generate an explicit
  Proc
  object.
  
 require 'tk' 
  
 TkButton.new do 
  
 text ""EXIT"" 
  
 command { exit } 
  
 pack('side'=>'left', 'padx'=>10, 'pady'=>10) 
  
 end 
  
 Tk.mainloop
  
 We can also bind a Ruby variable to a Tk widget’s value using a
  TkVariable
  proxy. 
 This arranges things so that whenever the widget’s value changes, the Ruby variable 
 will automatically be updated, and whenever the variable is changed, the widget will 
 reflect the new value.
  
 We show this in the following example. Notice how the
  TkCheckButton
  is set up; the 
 documentation says that the
  variable
  option takes a
  var reference
  as an argu-ment. For 
 this, we create a Tk variable reference using
  TkVariable.new
 . Accessing 
 mycheck.value
  
 will return the string “
 0
 ” or “
 1
 ” depending on whether the checkbox is checked. You 
 can use the same mechanism for anything that supports a var reference, such as radio 
 buttons and text fields.
  
 require 'tk'
  
 packing = { 'padx'=>5, 'pady'=>5, 'side' => 'left' }
  
 checked = TkVariable.new
  
 def checked.status 
  
 value == ""1"" ? ""Yes"" : ""No"" 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Setting/Getting Options Dynamically,"In addition to setting a widget’s options when it’s created, you can reconfigure a 
 widget while it’s running. Every widget supports the
  configure
  method, which takes a
  
 Hash 
 or a code block in the same manner as
  new
 . We can modify the first example to 
 change the label text in response to a button click.
  
 require 'tk' 
  
 root = TkRoot.new { title ""Ex3"" }
  
 top = TkFrame.new(root) { relief 'raised'; border 5 }
  
 lbl = TkLabel.new(top) do 
  
 justify 'center' 
  
 text 'Hello, World!' 
  
 pack('padx'=>5, 'pady'=>5, 'side' => 'top') 
  
 end
  
 TkButton.new(top) do 
  
 text ""Ok"" 
  
 command { exit } 
  
 pack('side'=>'left', 'padx'=>10, 'pady'=>10) 
  
 end
  
 TkButton.new(top) do 
  
 text ""Cancel"" 
  
 command { lbl.configure('text'=>""Goodbye, Cruel World!"") } pack('side'=>'right', 
 'padx'=>10, 'pady'=>10) 
  
 end
  
 top.pack('fill'=>'both', 'side' =>'top') 
  
 Tk.mainloop
  
 Now when the
  Cancel
  button is clicked, the text in the label will change immediately 
 from “
 Hello, World!
 ” to “
 Goodbye, Cruel World!
 ”
  
 You can also query widgets for particular option values using
  cget
 .
  
 Prepared exclusively for Yeganefar",NA
Sample Application,"Here’s a slightly longer example, showing a genuine application—a pig latin 
 generator. Type in the phrase such as
  Ruby rules
 , and the
  Pig It
  button will instantly 
 translate it into pig latin.
  
 require 'tk'
  
 class PigBox 
  
 def pig(word) 
  
  
 leading_cap = word =~ /^[A-Z]/ 
  
  
 word.downcase!
  
 res = case word 
  
  
 when /^[aeiouy]/ 
  
   
 word+""way"" 
  
  
 when /^([^aeiouy]+)(.*)/ 
  
   
 $2+$1+""ay"" 
  
  
 else 
  
   
 word 
  
 end
  
  
 leading_cap ? res.capitalize : res 
  
 end
  
 def show_pig 
  
 @text.value = @text.value.split.collect{|w| pig(w)}.join("" "") end
  
 def initialize
  
 ph = { 'padx' => 10, 'pady' => 10 } root = 
 TkRoot.new { title ""Pig"" }
  
 # common options
  
 top = TkFrame.new(root) { background ""white"" }
  
 TkLabel.new(top) {text 'Enter Text:' ; pack(ph) }
  
 @text = TkVariable.new 
  
 TkEntry.new(top, 'textvariable' => 
  
 @text).pack(ph)
  
  
 pig_b = TkButton.new(top) { text 'Pig It'; pack ph} 
  
  
 pig_b.command { show_pig } 
  
  
 exit_b = TkButton.new(top) {text 'Exit'; pack ph} 
  
  
 exit_b.command { exit } 
  
  
 top.pack('fill'=>'both', 'side' =>'top') 
  
 end 
  
 end
  
 PigBox.new 
  
 Tk.mainloop
  
 Prepared exclusively for Yeganefar",NA
Binding Events,"Our widgets are exposed to the real world; they get clicked, the mouse moves over 
 them, the user tabs into them; all these things, and more, generate
  events
  that we can 
 capture. You can create a
  binding
  from an event on a particular widget to a block of 
 code, using the widget’s
  bind
  method.
  
 For instance, suppose we’ve created a button widget that displays an image. We’d like 
 the image to change when the user’s mouse is over the button.
  
 require 'tk'
  
 image1 = TkPhotoImage.new { file ""img1.gif"" } 
  
 image2 = TkPhotoImage.new { file ""img2.gif"" }
  
 b = TkButton.new(@root) do 
  
 image image1 
  
 command { exit } 
  
 pack 
  
 end
  
 b.bind(""Enter"") { b.configure('image'=>image2) } 
  
 b.bind(""Leave"") { b.configure('image'=>image1) }
  
 Tk.mainloop
  
 First, we create two GIF image objects from files on disk, using
  TkPhotoImage
 . Next 
 we create a button (very cleverly named “b”), which displays the image
  image1
 . We 
 then bind the
  Enter
  event so that it dynamically changes the image displayed by the 
 button to
  image2
  when the mouse is over the button, and the
  Leave
  event to revert back 
 to
  image1
  when the mouse leaves the button.",NA
Canvas,"Tk provides a
  Canvas
  widget with which you can draw and produce PostScript out-
 put. Figure
  19.1
  on the following page shows a simple bit of code (adapted from the 
 distribution) that will draw straight lines. Clicking and holding button 1 will start a 
 line, which will be “rubber-banded” as you move the mouse around. When you 
 release button 1, the line will be drawn in that position.
  
 A few mouse clicks, and you’ve got an instant masterpiece.
  
  
 As they say, “We couldn’t find the artist, so we had to hang the picture....”
  
 Prepared exclusively for Yeganefar",NA
Scrolling,"Unless you plan on drawing very small pictures, the previous example may not be all 
 that useful.
  TkCanvas
 ,
  TkListbox
 , and
  TkText
  can be set up to use scrollbars, so you can 
 work on a smaller subset of the “big picture.”
  
 Communication between a scrollbar and a widget is bidirectional. Moving the 
 scrollbar means that the widget’s view has to change; but when the widget’s view is 
 changed by some other means, the scrollbar has to change as well to reflect the new 
 position.
  
 Since we haven’t done much with lists yet, our scrolling example will use a scrolling 
 list of text. In the following code fragment, we’ll start by creating a plain old
  
 TkListbox 
 and an associated
  TkScrollbar
 . The scrollbar’s callback (set with
  command
 ) 
 will call the list widget’s
  yview
  method, which will change the value of the visible 
 portion of the list in the
  y
  direction.
  
 After that callback is set up, we make the inverse association: when the list feels the 
 need to scroll, we’ll set the appropriate range in the scrollbar using
  TkScrollbar
 #
 set
 .
  
 We’ll use this same fragment in a fully functional program in the next section.
  
 list_w = TkListbox.new(frame) do 
  
 selectmode 'single' 
  
 pack 'side' => 'left' 
  
 end
  
 list_w.bind(""ButtonRelease-1"") do 
  
 busy do 
  
  
 filename = list_w.get(*list_w.curselection) 
  
  
 tmp_img = TkPhotoImage.new { file filename } 
  
  
 scale 
  
 = tmp_img.height / 100 
  
  
 scale 
  
 = 1 if scale < 1 
  
  
 image_w.copy(tmp_img, 'subsample' => [scale, scale]) 
  
  
 image_w.pack 
  
 end 
  
 end
  
 scroll_bar = TkScrollbar.new(frame) do 
  
 command {|*args| list_w.yview *args } 
  
 pack 'side' => 'left', 'fill' => 'y' 
  
 end
  
 list_w.yscrollcommand 
  
 {|first,last| scroll_bar.set(first,last) }",NA
Just One More Thing,"We could go on about Tk for another few hundred pages, but that’s another book. 
 The following program is our final Tk example—a simple GIF image viewer. You 
 can select a GIF filename from the scrolling list, and a thumb nail version of the 
 image will be displayed. We’ll point out just a
  few
  more things.",NA
Translating from Perl/Tk Documentation,"That’s it, you’re on your own now. For the most part, you can easily translate the 
 doc-umentation given for Perl/Tk to Ruby. There are a few exceptions; some methods 
 are not implemented, and some extra functionality is undocumented. Until a Ruby/Tk 
 book comes out, your best bet is to ask on the newsgroup or read the source code.
  
 But in general, it’s pretty easy to see what’s happening. Remember that options may 
 be given as a hash, or in code block style, and the scope of the code block is within 
 the 
 TkWidget
  being used, not your class instance.",NA
Object Creation,"In the Perl/Tk mapping, parents are responsible for creating their child widgets. In 
 Ruby, the parent is passed as the first parameter to the widget’s constructor.
  
 Perl/Tk: $widget = $parent->Widget( [ option => value ] ) 
  
 Ruby: widget = TkWidget.new(parent, option-hash) 
  
 widget = TkWidget.new(parent) { code block }
  
 You may not need to save the returned value of the newly created widget, but it’s 
 there if you do. Don’t forget to pack a widget (or use one of the other geometry calls), 
 or it won’t be displayed.
  
 Prepared exclusively for Yeganefar",NA
Options,"Perl/Tk:-background => color
  
 Ruby: 'background' => color
  
 { background color }
  
 Remember that the code block scope is different.",NA
Variable References,"Perl/Tk:-textvariable => \$variable
  
 -textvariable => varRef
  
 Ruby: ref = TkVariable.new
  
 'textvariable' => ref
  
 { textvariable ref }
  
 Use
  TkVariable
  to attach a Ruby variable to a widget’s value. You can then use the
  
 value
  accessors in
  TkVariable
  (
 TkVariable
 #
 value
  and
  TkVariable
 #
 value=
 ) to
  
 affect the contents of the widget directly.
  
 Prepared exclusively for Yeganefar",NA
Chapter 20,NA,NA
Ruby and Microsoft Windows,"Ruby runs in a number of different environments. Some of these are Unix-based, and 
 others are based on the various flavors of Microsoft Windows. Ruby came from 
 people who were Unix-centric, but over the years it has also developed a whole lot of 
 useful features in the Windows world, too. In this chapter, we’ll look at these features 
 and share some secrets to using Ruby effectively under Windows.",NA
Getting Ruby for Windows,"Two flavors of Ruby are available for the Windows environment.
  
 The first is a version of Ruby that runs natively—that is, it is just another Windows 
 application. The easiest way to get this distribution is to use the One-Click Installer, 
 which loads a ready-made binary distribution onto your box. Follow the links from 
 http://rubyinstaller.rubyforge.org/
  to get the latest version.
  
 If you’re feeling more adventurous, or if you need to compile in libraries that aren’t 
 sup-plied with the binary distribution, then you can build Ruby from source. You’ll 
 need the Microsoft VC++ compiler and associated tools to do this. Download the 
 source of Ruby from
  http://www.ruby-lang.org
 , or use CVS to check out the latest 
 development version. Then read the file
  win32\README.win32
  for instructions.
  
 A second alternative uses an emulation layer called Cygwin. This provides a Unix-
 like environment on top of Windows. The Cygwin version of Ruby is the closest to 
 Ruby running on Unix platforms, but running it means you must also install Cygwin. 
 If you want to take this route, you can download the Cygwin version of Ruby from 
 http://ftp.ruby-lang.org/pub/ruby/binaries/cygwin/
 . You’ll also need Cyg-win itself. 
 The download link has a pointer to the required dynamic link library (DLL), or you 
 can go to
  http://www.cygwin.com
  and download the full package (but be careful: you 
 need to make sure the version you get is compatible with the Ruby you downloaded).
  
 Prepared exclusively for Yeganefar 
 253",NA
Running Ruby Under Windows,"You’ll find two executables in the Ruby Windows distribution.
  
 ruby.exe
  is meant to be used at a command prompt (a DOS shell), just as in the Unix 
 version. For applications that read and write to the standard input and output, this is 
 fine. But this also means that anytime you run
  ruby.exe
 , you’ll get a DOS shell even if 
 you don’t want one—Windows will create a new command prompt window and 
 display it while Ruby is running. This may not be appropriate behavior if, for 
 example, you double-click a Ruby script that uses a graphical interface (such as Tk), 
 or if you are running a Ruby script as a background task or from inside another 
 program.
  
 In these cases, you’ll want to use
  rubyw.exe
 . It is the same as
  ruby.exe
  except that it 
 does not provide standard in, standard out, or standard error and does not launch a 
 DOS shell when run.
  
 The installer (by default) sets file associations so that files with the extension
  .rb
  will 
 automatically use
  rubyw.exe
 . By doing this, you can double-click Ruby scripts, and 
 they will simply run without popping up a DOS shell.",NA
Win32API,"If you plan on doing Ruby programming that needs to access some Windows 32 API 
 functions directly, or that needs to use the entry points in some other DLLs, we’ve 
 got good news for you—the
  Win32API
  library.
  
 As an example, here’s some code that’s part of a larger Windows application used by 
 our book fulfillment system to download and print invoices and receipts. A Web 
 application generates a PDF file, which the Ruby script running on Windows 
 downloads into a local file. The script then uses the
  print
  shell command under 
 Windows to print this file.
  
 arg 
  
 = ""ids=#{resp.intl_orders.join("","")}"" 
  
 fname = ""/temp/invoices.pdf""
  
 site = Net::HTTP.new(HOST, PORT) 
  
 site.use_ssl = true 
  
 http_resp, = site.get2(""/fulfill/receipt.cgi?"" + arg, 
  
  
 'Authorization' => 'Basic ' + 
  
  
 [""name:passwd""].pack('m').strip )",NA
Windows Automation,"If groveling around in the low-level Windows API doesn’t interest you, Windows 
 Automation may—you can use Ruby as a client for Windows Automation thanks to
  
 1.8
  
  
 a Ruby extension called
  WIN32OLE
 , written by Masaki Suketa. Win32OLE is part of 
 the standard Ruby distribution.
  
 Windows Automation allows an automation controller (a client) to issue commands 
 and queries against an automation server, such as Microsoft Excel, Word, 
 PowerPoint, and so on.
  
 You can execute a method of an automation server by calling a method of the same 
 name from a
  WIN32OLE
  object. For instance, you can create a new
  WIN32OLE
  client 
 that launches a fresh copy of Internet Explorer and commands it to visit its home 
 page.
  
 ie = WIN32OLE.new('InternetExplorer.Application') 
  
 ie.visible = true 
  
 ie.gohome
  
 You could also make it navigate to a particular page.
  
 ie = WIN32OLE.new('InternetExplorer.Application') 
  
 ie.visible = true 
  
 ie.navigate(""http://www.pragmaticprogrammer.com"")
  
 Methods that aren’t known to
  WIN32OLE
  (such as
  visible
 ,
  gohome
 , or
  navigate
 ) are 
 passed on to the
  WIN32OLE
 #
 invoke
  method, which sends the proper commands to the 
 server.",NA
Getting and Setting Properties,"You can set and get
  properties
  from the server using normal Ruby hash notation. For 
 example, to set the
  Rotation
  property in an Excel chart, you could write
  
 excel = WIN32OLE.new(""excel.application"") 
  
 excelchart = excel.Charts.Add() 
  
 ...
  
 excelchart['Rotation'] = 45 
  
 puts excelchart['Rotation']
  
 An OLE object’s parameters are automatically set up as attributes of the
  WIN32OLE 
 object. This means you can set a parameter by assigning to an object attribute.
  
 excelchart.rotation = 45 
  
 r = excelchart.rotation
  
 The following example is a modified version of the sample file
  excel2.rb
  (found in the
  
 ext/win32/samples
  directory). It starts Excel, creates a chart, and then rotates it on the 
 screen. Watch out, Pixar!
  
 require 'win32ole'
  
 #-4100 is the value for the Excel constant xl3DColumn. 
  
 ChartTypeVal = -4100;
  
 excel = WIN32OLE.new(""excel.application"")
  
 # Create and rotate the chart
  
 excel['Visible'] = TRUE
  
 excel.Workbooks.Add() 
  
 excel.Range(""a1"")['Value'] = 3 
  
 excel.Range(""a2"")['Value'] = 2 
  
 excel.Range(""a3"")['Value'] = 1
  
 excel.Range(""a1:a3"").Select()
  
 excelchart = excel.Charts.Add() 
  
 excelchart['Type'] = ChartTypeVal
  
 30.step(180, 5) do |rot| 
  
 excelchart.rotation = rot 
  
 sleep(0.1) 
  
 end
  
 excel.ActiveWorkbook.Close(0) 
  
 excel.Quit()",NA
Named Arguments,"Other automation client languages such as Visual Basic have the concept of
  named 
 arguments
 . Suppose you had a Visual Basic routine with the signature
  
 Song(artist, title, length): rem Visual Basic
  
 Prepared exclusively for Yeganefar",NA
for each,"Where Visual Basic has a “for each” statement to iterate over a collection of items in 
 a server, a
  WIN32OLE
  object has an
  each
  method (which takes a block) to accomplish 
 the same thing.
  
 require 'win32ole'
  
 excel = WIN32OLE.new(""excel.application"")
  
 excel.Workbooks.Add 
  
 excel.Range(""a1"").Value = 10 
  
 excel.Range(""a2"").Value = 20 
  
 excel.Range(""a3"").Value = ""=a1+a2""
  
 excel.Range(""a1:a3"").each do |cell| 
  
 p cell.Value 
  
 end",NA
Events,"Your automation client written in Ruby can register itself to receive events from other 
 programs. This is done using the
  WIN32OLE_EVENT
  class. This example (based on 
 code from the Win32OLE 0.1.1 distribution) shows the use of an event sink that logs 
 the URLs that a user browses to when using Internet Explorer.
  
 require 'win32ole'
  
 $urls = []
  
 def navigate(url) 
  
 $urls << url 
  
 end
  
 def stop_msg_loop 
  
 puts ""IE has exited..."" 
  
 throw :done 
  
 end
  
 def default_handler(event, *args) 
  
 case event 
  
 when ""BeforeNavigate"" 
  
  
 puts ""Now Navigating to #{args[0]}..."" 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Optimizing,"As with most (if not all) high-level languages, it can be all too easy to churn out code 
 that is unbearably slow, but that can be easily fixed with a little thought.
  
 With
  WIN32OLE
 , you need to be careful with unnecessary dynamic lookups. Where 
 pos-sible, it is better to assign a
  WIN32OLE
  object to a variable and then reference 
 elements from it, rather than creating a long chain of “.” expressions.
  
 For example, instead of writing
  
 workbook.Worksheets(1).Range(""A1"").value 
 = 
 1 
  
 workbook.Worksheets(1).Range(""A2"").value 
 = 
 2 
  
 workbook.Worksheets(1).Range(""A3"").value 
 = 
 4 
  
 workbook.Worksheets(1).Range(""A4"").value = 8
  
 we can eliminate the common subexpressions by saving the first part of the expression 
 to a temporary variable and then make calls from that variable.
  
 worksheet = workbook.Worksheets(1)
  
 worksheet.Range(""A1"").value 
 = 
 1 
  
 worksheet.Range(""A2"").value 
 = 
 2 
  
 worksheet.Range(""A3"").value 
 = 
 4 
  
 worksheet.Range(""A4"").value = 8
  
 You can also create Ruby stubs for a particular Windows type library. These stubs 
 wrap the OLE object in a Ruby class with one method per entry point. Internally, the 
 stub uses the entry point’s number, not name, which speeds access.
  
 Generate the wrapper class using the
  olegen.rb
  script in the
  ext\win32ole\samples 
 directory, giving it the name of the type library to reflect on.
  
 C:\> ruby olegen.rb 'NetMeeting 1.1 Type Library' >netmeeting.rb
  
 Prepared exclusively for Yeganefar",NA
More Help,"If you need to interface Ruby to Windows NT, 2000, or XP, you may want to have a look at 
 Daniel Berger’s Win32Utils project (
 http://rubyforge.org/projects/win32utils/
 ).
  
 There you’ll find modules for interfacing to the Windows’ clipboard, event log, sched-
 uler, and so on.
  
 Also, the
  DL
  library (described briefly on page
  648
 ) allows Ruby pragrams to invoke 
 methods in dynamically loaded shared objects. On Windows, this means that your 
 Ruby code can load and invoke entry points in a Windows DLL. For example, the 
 following code, taken from the
  DL
  source code in the standard Ruby distribution, pops 
 up a mes-sage box on a Windows machine, and determines which button the user 
 clicked.
  
 require 'dl'
  
 User32 = DL.dlopen(""user32"")
  
 MB_OKCANCEL = 1",NA
Chapter 21,NA,NA
Extending Ruby,"It is easy to extend Ruby with new features by writing code in Ruby. But every now 
 and then you need to interface to things at a lower level. Once you start adding in 
 low-level code written in C, the possibilities are endless. Having said this, the stuff in 
 this chapter is pretty advanced and should probably be skipped the first time through 
 the book.
  
 Extending Ruby with C is pretty easy. For instance, suppose we are building a custom 
 Internet-ready jukebox for the Sunset Diner and Grill. It will play MP3 audio files 
 from a hard disk or audio CDs from a CD jukebox. We want to be able to control the 
 jukebox hardware from a Ruby program. The hardware vendor gave us a C header 
 file and a binary library to use; our job is to construct a Ruby object that makes the 
 appropriate C function calls.
  
 Much of the information in this chapter is taken from the
  README.EXT
  file that is 
 included in the distribution. If you are planning on writing a Ruby extension, you 
 may want to refer to that file for more details as well as the latest changes.",NA
Your First Extension,"Just to introduce extension writing, let’s write one. This extension is purely a test of 
 the process—it does nothing that you couldn’t do in pure Ruby. We’ll also present 
 some stuff without too much explanation—all the messy details will be given later.
  
 The extension we write will have the same functionality as the following Ruby class.
  
 class MyTest 
  
 def initialize 
  
  
 @arr = Array.new 
  
 end 
  
 def add(obj) 
  
  
 @arr.push(obj) 
  
 end 
  
 end",NA
Building Our Extension,"We’ll have a lot more to say about building extensions later. For now, though, all we 
 have to do is follow these steps.
  
 1. Create a file called
  extconf.rb
  in the same directory as our
  my_text.c
  C source 
  
 file. 
 The file
  extconf.rb
  should contain the following two lines.
  
 require 'mkmf' 
  
 create_makefile(""my_test"")
  
 2. Run
  extconf.rb
 . This will generate a Makefile.
  
 %
  ruby extconf.rb 
  
 creating Makefile
  
 3. Use
  make
  to build the extension. This is what happens on an OS X system.
  
 %
  make 
  
 gcc -fno-common -g -O2 -pipe -fno-common-I.
  
  
 -I/usr/lib/ruby/1.9/powerpc-darwin7.4.0
  
 -I/usr/lib/ruby/1.9/powerpc-darwin7.4.0 -I.
  
 -c my_test.c cc -
 dynamic -bundle -undefined suppress -flat_namespace
  
  
 -ldl -lobjc-
 L'/usr/lib' -o my_test.bundle my_test.o
  
 The result of all this is the extension, all nicely bundled up in a shared object (a
  .so
 , 
 .dll
 , 
 or [on OS X] a
  .bundle
 ).
  
 Prepared exclusively for Yeganefar",NA
Running Our Extension,"We can use our extension from Ruby simply by
  require
 -ing it dynamically at runtime 
 (on most platforms). We can wrap this up in a test to verify that things are working as 
 we expect.
  
 require 'my_test' 
  
 require 'test/unit'
  
 class TestTest < Test::Unit::TestCase
  
 def test_test 
  
 t = MyTest.new 
  
 assert_equal(Object, MyTest.superclass) 
  
 assert_equal(MyTest, t.class)
  
 t.add(1) 
  
 t.add(2)
  
  
 assert_equal([1,2], t.instance_eval(""@arr"")) 
  
 end 
  
 end
  
 produces:
  
 Finished in 0.002589 seconds.
  
 1 tests, 3 assertions, 0 failures, 0 errors
  
 Once we’re happy that our extension works, we can then install it globally by running 
 make install
 .",NA
Ruby Objects in C,"When we wrote our first extension, we cheated, because it didn’t really do anything 
 with the Ruby objects—it didn’t do calculations based on Ruby numbers, for 
 example. Before we can do this, we need to find out how to represent and access 
 Ruby data types from within C.
  
 Everything in Ruby is an object, and all variables are references to objects. When 
 we’re looking at Ruby objects from within C code, the situation is pretty much the 
 same. Most Ruby objects are represented as C pointers to an area in memory that 
 contains the object’s data and other implementation details. In C code, all these 
 references are via variables of type
  VALUE
 , so when you pass Ruby objects around, 
 you’ll do it by passing 
 VALUE
 s.
  
 This has one exception. For performance reasons, Ruby implements
  Fixnum
 s,
  Symbol
 s, 
 true
 ,
  false
 , and
  nil
  as so-called
  immediate values
 . These are still stored in variables of 
 type
  VALUE
 , but they aren’t pointers. Instead, their value is stored directly in the 
 variable.
  
 Prepared exclusively for Yeganefar",NA
Working With Immediate Objects,"As we said above, immediate values are not pointers:
  Fixnum
 ,
  Symbol
 ,
  true
 ,
  false
 , and
  nil
  
 are stored directly in
  VALUE
 .
  
 Fixnum
  values are stored as 31-bit numbers
 1
 that are formed by shifting the original 
 number left 1 bit and then setting the LSB, or least significant bit (bit 0), to 1. When 
 VALUE
  is used as a pointer to a specific Ruby structure, it is guaranteed always to 
 have an LSB of zero; the other immediate values also have LSBs of zero. Thus, a 
 simple bit test can tell you whether you have a
  Fixnum
 . This test is wrapped in a 
 macro,
  FIXNUM_P
 . Similar tests let you check for other immediate values.
  
 FIXNUM_P(
 value
 )
  →
  nonzero if value is a Fixnum 
  
 SYMBOL_P(
 value
 )
  →
  nonzero if value is a Symbol 
  
 NIL_P(
 value
 )
 →
  nonzero if value is nil 
  
 RTEST(
 value
 )
 →
  nonzero if value is neither nil nor false
  
 Several useful conversion macros for numbers as well as other standard data types are 
 shown in Table
  21.1
  on the following page.
  
 The other immediate values (
 true
 ,
  false
 , and
  nil
 ) are represented in C as the con-stants
  
 Qtrue
 ,
  Qfalse
 , and
  Qnil
 , respectively. You can test
  VALUE
  variables against these 
 constants directly or use the conversion macros (which perform the proper cast-ing).",NA
Working with Strings,"In C, we’re used to working with null-terminated strings. Ruby strings, however, are 
 more general and may well included embedded nulls. The safest way to work with
  
 1.
  
 Or 63-bit on wider CPU architectures.",NA
Working with Other Objects,"When
  VALUE
 s are not immediate, they are pointers to one of the defined Ruby object 
 structures—you can’t have a
  VALUE
  that points to an arbitrary area of mem-ory. The 
 structures for the basic built-in classes are defined in
  ruby.h
  and are named 
 R
 Classname
 :
  RArray
 ,
  RBignum
 ,
  RClass
 ,
  RData
 ,
  RFile
 ,
  RFloat
 ,
  RHash
 ,
  RObject
 , 
 RRegexp
 ,
  
 RString
 , and
  RStruct
 .
  
 You can check to see what type of structure is used for a particular
  VALUE
  in a number 
 of ways. The macro
  TYPE(
 obj
 )
  will return a constant representing the C type of the 
 given object:
  T_OBJECT
 ,
  T_STRING
 , and so on. Constants for the built-in classes are 
 defined in
  ruby.h
 . Note that the
  type
  we are referring to here is an implementation 
 detail—it is not the same as the class of an object.
  
 If you want to ensure that a value pointer points to a particular structure, you can use 
 the macro
  Check_Type
 , which will raise a
  TypeError
  exception if
  value
  is not of the 
 expected
  type
  (which is one of the constants
  T_STRING
 ,
  T_FLOAT
 , and so on).
  
 Check_Type(VALUE
  value
 , int
  type
 )
  
 Again, note that we are talking about “type” as the C structure that represents a 
 partic-ular built-in type. The class of an object is a different beast entirely. The class 
 objects for the built-in classes are stored in C global variables named
  rb_c
 Classname
  
 (for instance,
  rb_cObject
 ); modules are named
  rb_m
 Modulename
 .
  
 Prepared exclusively for Yeganefar",NA
Global Variables,"Most of the time, your extensions will implement classes, and the Ruby code uses 
 those classes. The data you share between the Ruby code and the C code will be 
 wrapped tidily inside objects of the class. This is how it should be.
  
 Sometimes, though, you may need to implement a global variable, accessible by both 
 your C extension and by Ruby code.
  
 The easiest way to do this is to have the variable be a
  VALUE
  (that is, a Ruby object). 
 You then bind the address of this C variable to the name of a Ruby variable. In this 
 case, the $ prefix is optional, but it helps clarify that this is a global variable. And 
 remember: making a stack-based variable a Ruby global is not going to work (for 
 long).
  
 static VALUE hardware_list;
  
 static VALUE Init_SysInfo() { 
  
 rb_define_class(....);
  
 hardware_list = rb_ary_new(); 
  
 rb_define_variable(""$hardware"", &hardware_list); 
  
 ...
  
 rb_ary_push(hardware_list, rb_str_new2(""DVD"")); 
  
 rb_ary_push(hardware_list, rb_str_new2(""CDPlayer1"")); 
  
 rb_ary_push(hardware_list, rb_str_new2(""CDPlayer2"")); 
  
 }
  
 The Ruby side can then access the C variable
  hardware_list
  as
  $hardware
 .
  
 $hardware
  
 →
  
 [""DVD"", ""CDPlayer1"", ""CDPlayer2""]
  
 Sometimes, though, life is more complicated. Perhaps you want to define a global 
 vari-able whose value must be calculated when it is accessed. You do this by defining
  
 hooked 
 and
  virtual
  variables. A hooked variable is a real variable that is initialized by 
 a named function when the corresponding Ruby variable is accessed. Virtual 
 variables are sim-ilar but are never stored: their value purely comes from evaluating 
 the hook function. See the API section that begins on page
  294
  for details.",NA
The Jukebox Extension,"We’ve covered enough of the basics now to return to our jukebox example—
 interfacing C code with Ruby and sharing data and behavior between the two worlds.",NA
Wrapping C Structures,"We’ve got the vendor’s library that controls the audio CD jukebox units, and we’re 
 ready to wire it into Ruby. The vendor’s header file looks like this.
  
 typedef struct _cdjb { 
  
 int statusf; 
  
 int request; 
  
 void *data; 
  
 char pending; 
  
 int unit_id; 
  
 void *stats; 
  
 } CDJukebox;
  
 // Allocate a new CDJukebox structure 
  
 CDJukebox *new_jukebox(void); 
  
 // Assign the Jukebox to a player 
  
 void assign_jukebox(CDJukebox *jb, int unit_id); 
  
 // Deallocate when done (and take offline) 
  
 void free_jukebox(CDJukebox *jb); 
  
 // Seek to a disc, track and notify progress 
  
 void jukebox_seek(CDJukebox *jb, 
  
 int disc, 
  
 int track, 
  
 void (*done)(CDJukebox *jb, int percent)); // ... others...
  
 // Report a statistic 
  
 double get_avg_seek_time(CDJukebox *jb);
  
 This vendor has its act together; while they might not admit it, the code is written 
 with an object-oriented flavor. We don’t know what all those fields mean within the 
 CDJukeBox
  structure, but that’s OK—we can treat it as an opaque pile of bits. The 
 vendor’s code knows what to do with it; we just have to carry it around.
  
 Prepared exclusively for Yeganefar",NA
API: C Data Type Wrapping,"VALUE 
  
 Data_Wrap_Struct
 ( VALUE class, void (*mark)(), 
  
  
  
  
 void (*free)(), void *ptr ) 
  
  
  
 Wraps the given C data type
  ptr
 , registers the two garbage collection 
  
  
 routines (see below), and returns a
  VALUE
  pointer to a genuine Ruby 
  
  
 object. The C type of the resulting object is
  T_DATA
 , and its Ruby 
  
  
 class is
  class
 .
  
 VALUE 
  
 Data_Make_Struct
 ( VALUE class,
  c-type
 , void (*mark)(), 
   
  
 void 
 (*free)(),
  c-type *
  ) 
  
  
  
 Allocates and sets to zero a structure of the indicated type first and 
  
  
 then proceeds as
  Data_Wrap_Struct
 .
  c-type
  is the name of the C 
  
  
 data type that you’re wrapping, not a variable of that type.
  
 Data_Get_Struct
 ( VALUE obj,
 c-type
 ,
 c-type *
  ) 
  
 Returns the original pointer. This macro is a type-safe wrapper 
 around the macro
  DATA_PTR(obj)
 , which evaluates the pointer.
  
 The object created by
  Data_Wrap_Struct
  is a normal Ruby object, except that it has an 
 additional C data type that can’t be accessed from Ruby. As you can see in Fig-ure
  
 21.1
  on the following page, this C data type is separate from any instance variables 
 that the object contains. But since it’s a separate thing, how do you get rid of it when 
 the garbage collector claims this object? What if you have to release some resource 
 (close some file, clean up some lock or IPC mechanism, and so on)?
  
 Ruby uses a mark and sweep garbage collection scheme. During the mark phase, 
 Ruby looks for pointers to areas of memory. It marks these areas as “in use” (because 
 some-thing is pointing to them). If those areas themselves contain more pointers, the 
 memory these pointers reference is also marked, and so on. At the end of the mark 
 phase, all memory that is referenced will have been marked, and any orphaned areas 
 will not have a mark. At this point the sweep phase starts, freeing off memory that 
 isn’t marked.
  
 To participate in Ruby’s mark-and-sweep garbage collection process, you must 
 define a routine to free your structure and possibly a routine to mark any references 
 from your structure to other structures. Both routines take a
  void
  pointer, a reference 
 to your structure. The
  mark
  routine will be called by the garbage collector during its 
 “mark”phase. If your structure references other Ruby objects, then your mark 
 function needs to identify these objects using
  rb_gc_mark(
 value
 )
 . If the structure 
 doesn’t reference other Ruby objects, you can simply pass
  0
  as a function pointer.",NA
Object Creation,"1.8
  
  
 Ruby 1.8 has rationalized the creation and initialization of objects.
  
 Although the old
  
 ways still work, the new way, using allocation functions, is much tidier (and is less 
 likely to be deprecated in the future).
  
 The basic idea is simple. Let’s say you’re creating an object of class
  CDPlayer
  in your 
 Ruby program.
  
 cd = CDPlayer.new
  
 Underneath the covers, the interpreter calls the class method
  new
  for
  CDPlayer
 . As 
 CDPlayer
  hasn’t defined a method
  new
 , Ruby looks into its parent, class
  Class
 .
  
 The implementation of
  new
  in class
  Class
  is fairly simple: it allocates memory for the 
 new object and then calls the object’s
  initialize
  method to initialize that memory.
  
 So, if our
  CDPlayer
  extension is to be a good Ruby citizen, it should work within this 
 framework. This means that we’ll need to implement an allocation function and an 
 initialize method.
  
 Allocation Functions
  
 The allocation function is responsible for creating the memory used by your object. If 
 the object you’re implementing doesn’t use any data other that Ruby instance 
 variables, then you don’t need to write an allocation function—Ruby’s default 
 allocator will work just fine. But if your class wraps a C structure, you’ll need to 
 allocate space for that structure in the allocation function. The allocation function 
 gets passed the class of the object being allocated. In our case it will in all likelihood 
 be a
  cCDPlayer
 , but we’ll use the parameter as given, as this means that we’ll work 
 correctly if subclassed.
  
 static VALUE cd_alloc(VALUE klass) { 
  
 CDJukebox *jukebox; 
  
 VALUE obj;
  
 // Vendor library creates the Jukebox 
  
 jukebox = new_jukebox();
  
 // then we wrap it inside a Ruby CDPlayer object 
  
 obj = Data_Wrap_Struct(klass, 0, cd_free, jukebox);
  
 return obj; 
  
 }
  
 You then need to register your allocation function in your class’s initialization code.",NA
Cloning Objects,"All Ruby objects can be copied using one of two methods,
  dup
  and
  clone
 . The two 
 methods are similar: Both produce a new instance of their receiver’s class by calling 
 the allocation function. Then they copy across any instance variables from the 
 original. 
 clone
  then goes a bit further and copies the original’s singleton class (if it has 
 one) and flags (such as the flag that indicates that an object is frozen). You can think 
 of
  dup
  as being a copy of the contents and
  clone
  as being a copy of the full object.
  
 However, the Ruby interpreter doesn’t know how to handle copying the internal state 
 of objects that you write as C extensions. For example, if your object wraps a C 
 structure that contains an open file descriptor, it’s up to the semantics of your 
 implementation whether that descriptor should simply be copied to the new object or 
 whether a new file descriptor should be opened.
  
 Prepared exclusively for Yeganefar",NA
Putting It All Together,"OK, finally we’re ready to write all the code for our
  CDPlayer
  class.
  
 #include ""ruby.h"" 
  
 #include ""cdjukebox.h""
  
 static VALUE cCDPlayer;
  
 Prepared exclusively for Yeganefar",NA
Memory Allocation,"You may sometimes need to allocate memory in an extension that won’t be used for 
 object storage—perhaps you’ve got a giant bitmap for a Bloom filter, an image, or a 
 whole bunch of little structures that Ruby doesn’t use directly.
  
 To work correctly with the garbage collector, you should use the following memory 
 allocation routines. These routines do a little bit more work than the standard
  malloc
 . 
 For instance, if
  ALLOC_N
  determines that it cannot allocate the desired amount of 
 mem-ory, it will invoke the garbage collector to try to reclaim some space. It will 
 raise a 
 NoMemError
  if it can’t or if the requested amount of memory is invalid.",NA
API: Memory Allocation,"type * 
  
 ALLOC_N
 (
  c-type
 , n )
  
 Allocates
  n c-type
  objects, where
  c-type
  is the literal name of the C 
 type, not a variable of that type.
  
 type * 
  
 ALLOC
 (
  c-type
  )
  
 Allocates a
  c-type
  and casts the result to a pointer of that type.
  
 Prepared exclusively for Yeganefar",NA
Ruby Type System,"1.8
  
  
 In Ruby, we
  
 rely less on the type (or class) on an object and more on its capabilities.
  
 This is called
  duck typing
 . We describe it in more detail in Chapter
  23
  on page
  349 
 You’ll find many examples of this if you examine the source code for the interpreter 
 itself. For example, the following code implements the
  Kernel.exec
  method.
  
 VALUE 
  
 rb_f_exec(argc, argv) 
  
 int argc; 
  
 VALUE *argv; 
  
 { 
  
 VALUE prog = 0; 
  
 VALUE tmp;
  
 if (argc == 0) { 
  
  
 rb_raise(rb_eArgError, ""wrong number of arguments""); 
  
 }
  
 tmp = rb_check_array_type(argv[0]); 
  
 if (!NIL_P(tmp)) { 
  
  
 if (RARRAY(tmp)->len != 2) { 
  
  
  
 rb_raise(rb_eArgError, ""wrong first argument""); 
  
  
 } 
  
  
 prog = RARRAY(tmp)->ptr[0]; 
  
  
 SafeStringValue(prog); 
  
  
 argv[0] = RARRAY(tmp)->ptr[1]; 
  
 } 
  
 if (argc == 1 && prog == 0) { 
  
  
 VALUE cmd = argv[0];
  
  
 SafeStringValue(cmd); 
  
  
 rb_proc_exec(RSTRING(cmd)->ptr); 
  
 } 
  
 else { 
  
  
 proc_exec_n(argc, argv, prog); 
  
 } 
  
 rb_sys_fail(RSTRING(argv[0])->ptr); 
  
 return Qnil; 
  
 /* dummy */ }
  
 Prepared exclusively for Yeganefar",NA
Creating an Extension,"Having written the source code for an extension, we now need to compile it so Ruby 
 can use it. We can either do this as a shared object, which is dynamically loaded at 
 runtime, or statically link the extension into the main Ruby interpreter itself. The 
 basic procedure is the same.
  
 1. Create the C source code file(s) in a given directory.
  
 2. Optionally create an supporting Ruby files in a
  lib
  subdirectory.
  
 3. Create
  extconf.rb
 .
  
 4. Run
  extconf.rb
  to create a
  Makefile
  for the C files in this directory.
  
 5. Run
  make
 .
  
 6. Run
  make install
 .",NA
Creating a Makefile with extconf.rb,"Figure
  21.2
  on the next page shows the overall workflow when building an extension. 
 The key to the whole process is the
  extconf.rb
  program that you, as a developer, create. 
 In
  extconf.rb
 , you write a simple program that determines what features are available 
 on the user’s system and where those features may be located. Executing 
 extconf.rb
  
 builds a customized
  Makefile
 , tailored for both your application and the system on 
 which it’s being compiled. When you run the
  make
  command against this 
 Makefile
 , 
 your extension is built and (optionally) installed.
  
 The simplest
  extconf.rb
  may be just two lines long, and for many extensions this is 
 sufficient.
  
 require 'mkmf' 
  
 create_makefile(""Test"")
  
 The first line brings in the
  mkmf
  library module (described starting on page
  755
 ). This 
 contains all the commands we’ll be using. The second line creates a
  Makefile
  for an 
 extension called “Test.” (Note that “Test” is the name of the extension; the makefile 
 will always be called
  Makefile
 .)
  Test
  will be built from all the C source files in the 
 current directory. When your code is loaded, Ruby will call its
  Init_Test
  method.
  
 Let’s say that we run this
  extconf.rb
  program in a directory containing a single source 
 file,
  main.c
 . The result is a makefile that will build our extension. On a Linux box, this 
 executes the following commands.
  
 gcc -fPIC -I/usr/local/lib/ruby/1.8/i686-linux -g -O2 \
  
 -c main.c -o main.o 
  
 gcc -shared -o Test.so main.o -lc
  
 The result of this compilation is
  Test.so
 , which may be dynamically linked into Ruby at 
 runtime with
  require
 .
  
 Prepared exclusively for Yeganefar",NA
Static Linking,"Finally, if your system doesn’t support dynamic linking, or if you have an extension 
 module that you want to have statically linked into Ruby itself, edit the file
  ext/Setup 
 in the distribution and add your directory to the list of extensions in the file. In your 
 extension’s directory, create a file named
  MANIFEST
  containing a list of all the files in 
 your extension (source,
  extconf.rb
 ,
  lib/
 , and so on). Then rebuild Ruby. The extensions 
 listed in
  Setup
  will be statically linked into the Ruby executable. If you want to 
 disable any dynamic linking, and link all extensions statically, edit
  ext/Setup 
 to 
 contain the following option.
  
 option nodynamic",NA
A Shortcut,"If you are extending an existing library written in C or C++, you may want to 
 investigate SWIG (
 http://www.swig.org
 ). SWIG is an interface generator: it takes a 
 library def-inition (typically from a header file) and automatically generates the glue 
 code needed to access that library from another language. SWIG supports Ruby, 
 meaning that it can generate the C source files that wrap external libraries in Ruby 
 classes.",NA
Embedding a Ruby Interpreter,"In addition to extending Ruby by adding C code, you can also turn the problem 
 around and embed Ruby itself within your application. You have two ways to do this. 
 The first is to let the interpreter take control by calling
  ruby_run
 . This is the easiest 
 approach, but it has one significant drawback—the interpreter never returns from a
  
 ruby_run
  call. Here’s an example.
  
 #include ""ruby.h""
  
 int main(void) { 
  
 /* ... our own application stuff ... */ 
  
 ruby_init(); 
  
 ruby_init_loadpath(); 
  
 ruby_script(""embedded""); 
  
 rb_load_file(""start.rb""); 
  
 ruby_run(); 
  
 exit(0); 
  
 }",NA
API: Embedded Ruby API,"void 
 ruby_init
 ( )
  
 Sets up and initializes the interpreter. This function should be called
  
 before any other Ruby-related functions.
  
 void 
 ruby_init_loadpath
 ( )
  
 Initializes the
  $:
  (load path) variable; necessary if your code loads
  
 any library modules.
  
 void 
 ruby_options
 ( int argc, char **argv )
  
 Gives the Ruby interpreter the command-line options.
  
 void 
 ruby_script
 ( char *name )
  
 Sets the name of the Ruby script (and
  $0
 ) to
  name
 .
  
 void 
 rb_load_file
 ( char *file )
  
 Loads the given file into the interpreter.
  
 void 
 ruby_run
 ( )
  
 Runs the interpreter.
  
 void 
 ruby_finalize
 ( )
  
 Shuts down the interpreter.
  
 For another example of embedding a Ruby interpreter within another program, see also
  
 eruby
 , which is described beginning on page
  229
 .",NA
Bridging Ruby to Other Languages,"So far, we’ve discussed extending Ruby by adding routines written in C. However, you
  
 can write extensions in just about any language, as long as you can bridge the two
  
 languages with C. Almost anything is possible, including awkward marriages of Ruby
  
 and C++, Ruby and Java, and so on.
  
 But you may be able to accomplish the same thing without resorting to C code. For
  
 example, you could bridge to other languages using middleware such as SOAP or
  
 COM. See the section on SOAP (page
  236
 ) and the section on Windows Automation
  
 beginning on page
  255
  for more details.
  
 Prepared exclusively for Yeganefar",NA
Ruby C Language API,"Last, but by no means least, here are some C-level functions that you may find useful 
 when writing an extension.
  
 Some functions require an
  ID
 : you can obtain an
  ID
  for a string by using
  rb_intern 
 and 
 reconstruct the name from an
  ID
  by using
  rb_id2name
 .
  
 As most of these C functions have Ruby equivalents that are already described in detail 
 elsewhere in this book, the descriptions here will be brief.
  
 The following listing is not complete. Many more functions are available—too many 
 to document them all, as it turns out. If you need a method that you can’t find here, 
 check
  ruby.h
  or
  intern.h
  for likely candidates. Also, at or near the bottom of each 
 source file is a set of method definitions that describes the binding from Ruby 
 methods to C functions. You may be able to call the C function directly or search for 
 a wrap-per function that calls the function you need. The following list, based on the 
 list in 
 README.EXT
 , shows the main source files in the interpreter.
  
 Ruby Language Core
  
  
 class.c
 ,
  error.c
 ,
  eval.c
 ,
  gc.c
 ,
  object.c
 , 
 Utility Functions 
  
  
 dln.c
 ,
  regex.c
 , 
  
 st.c
 ,
  util.c 
  
 Ruby Interpreter
  
 parse.y
 ,
  variable.c
  
 dmyext.c
 ,
  inits.c
 , 
 keywords main.c
 ,
  ruby.c
 ,
  version.c
  
 Base Library
  
 array.c
 ,
  bignum.c
 , 
 compar.c
 ,
  dir.c
 ,
  enum.c
 ,
  file.c
 ,
  hash.c
 ,
  io.c
 ,
  
 marshal.c
 , 
 math.c
 ,
  numeric.c
 ,
  pack.c
 ,
  prec.c
 ,
  process.c
 ,
  
 random.c
 ,
  range.c
 , 
 re.c
 ,
  signal.c
 ,
  sprintf.c
 , 
 string.c
 ,
  struct.c
 ,
  
 time.c",NA
API: Defining Classes,"VALUE 
  
 rb_define_class
 ( char *name, VALUE superclass )
  
 Defines a new class at the top level with the given
  name
  and
  super-
  
 class
  (for class
  Object
 , use
  rb_cObject
 ).
  
 VALUE 
  
 rb_define_module
 ( char *name )
  
 Defines a new module at the top level with the given
  name
 .
  
 VALUE 
  
 rb_define_class_under
 ( VALUE under, char *name,
  
 VALUE superclass )
  
 Defines a nested class under the class or module
  under
 .
  
 Prepared exclusively for Yeganefar",NA
API: Defining Structures,"VALUE 
  
 rb_struct_define
 ( char *name, char *attribute..., NULL )
  
 Defines a new structure with the given attributes.
  
 VALUE 
  
 rb_struct_new
 ( VALUE sClass, VALUE args..., NULL )
  
 Creates an instance of
  sClass
  with the given attribute values.
  
 VALUE 
  
 rb_struct_aref
 ( VALUE struct, VALUE idx )
  
 Returns the element named or indexed by
  idx
 .
  
 VALUE 
  
 rb_struct_aset
 ( VALUE struct, VALUE idx, VALUE val )
  
 Sets the attribute named or indexed by
  idx
  to
  val
 .",NA
API: Defining Methods,"In some of the function definitions that follow, the parameter
  argc
  specifies how many
  
 arguments a Ruby method takes. It may have the following values.
  
 argc
  
 Function Prototype
  
 0..17
  
 VALUE func(VALUE self, VALUE arg...)
  
 The C function will be called with this many actual arguments.
  
 −1
  
 VALUE func(int argc, VALUE *argv, VALUE self) 
  
 The C function will be given a variable number of arguments passed as a C
  
 array.
  
 −2
  
 VALUE func(VALUE self, VALUE args) 
  
 The C function will be given a variable number of arguments passed as a 
 Ruby
  
 array.
  
 In a function that has been given a variable number of arguments, you can use the C
  
 function
  rb_scan_args
  to sort things out (see below).
  
 Prepared exclusively for Yeganefar",NA
API: Defining Variables and Constants,"void 
 rb_define_const
 ( VALUE classmod, char *name, VALUE value )
  
 Defines a constant in the class or module
  classmod
 , with the given
  
 name
  and
  value
 .
  
 void 
 rb_define_global_const
 ( char *name, VALUE value )
  
 Defines a global constant with the given
  name
  and
  value
 .
  
 void 
 rb_define_variable
 ( const char *name, VALUE *object )
  
 Exports the address of the given
  object
  that was created in C to the
  
 Ruby namespace as
  name
 . From Ruby, this will be a global variable,
  
 so
  name
  should start with a leading dollar sign. Be sure to honor
  
 Ruby’s rules for allowed variable names; illegally named variables
  
 will not be accessible from Ruby.
  
 void 
 rb_define_class_variable
 ( VALUE class, const char *name,
  
 VALUE val )
  
 Defines a class variable
  name
  (which must be specified with a
  @@
  
 prefix) in the given
  class
 , initialized to
  value
 .
  
 void 
 rb_define_virtual_variable
 ( const char *name,
  
 VALUE(*getter)(),
  
 void(*setter)() )
  
 Exports a virtual variable to a Ruby namespace as the global $
 name
 .
  
 No actual storage exists for the variable; attempts to get and set the
  
 value will call the given functions with the prototypes.
  
 VALUE getter(ID id, VALUE *data,
  
 struct global_entry *entry);
  
 void setter(VALUE value, ID id, VALUE *data,
  
 struct global_entry *entry);
  
 You will likely not need to use the
  entry
  parameter and can safely
  
 omit it from your function declarations.
  
 void 
 rb_define_hooked_variable
 ( const char *name,
  
 VALUE *variable,
  
 VALUE(*getter)(),
  
 void(*setter)() )
  
 Defines functions to be called when reading or writing to
  variable
 .
  
 See also
  rb_define_virtual_variable
 .
  
 void 
 rb_define_readonly_variable
 ( const char *name,
  
 VALUE *value )
  
 Same as
  rb_define_variable
 , but read-only from Ruby.
  
 Prepared exclusively for Yeganefar",NA
API: Calling Methods,"VALUE 
  
 rb_create_new_instance
 ( (int argc, VALUE *argv,
  
 VALUE klass) )
  
 Return a new instance of class
  klass
 .
  argv
  is a pointer to an array of
  
 argc
  parameters.
  
 VALUE 
  
 rb_funcall
 ( VALUE recv, ID id, int argc, ... )
  
 Invokes the method given by
  id
  in the object
  recv
  with the given
  
 number of arguments
  argc
  and the arguments themselves (possibly
  
 none).
  
 VALUE 
  
 rb_funcall2
 ( VALUE recv, ID id, int argc, VALUE *args )
  
 Invokes the method given by
  id
  in the object
  recv
  with the given
  
 number of arguments
  argc
  and the arguments themselves given in
  
 the C array
  args
 .
  
 VALUE 
  
 rb_funcall3
 ( VALUE recv, ID id, int argc, VALUE *args )
  
 Same as
  rb_funcall2
  but will not call private methods.
  
 VALUE 
  
 rb_apply
 ( VALUE recv, ID name, int argc, VALUE args )
  
 Invokes the method given by
  id
  in the object
  recv
  with the given
  
 number of arguments
  argc
  and the arguments themselves given in
  
 the Ruby
  Array
  args
 .
  
 ID 
 rb_intern
 ( char *name )
  
 Returns an
  ID
  for a given
  name
 . If the name does not exist, a symbol
  
 table entry will be created for it.
  
 char * 
  
 rb_id2name
 ( ID id )
  
 Returns a name for the given
  id
 .
  
 VALUE 
  
 rb_call_super
 ( int argc, VALUE *args )
  
 Calls the current method in the superclass of the current object.
  
 Prepared exclusively for Yeganefar",NA
API: Exceptions,"void 
 rb_raise
 ( VALUE exception, const char *fmt, ... )
  
 Raises an
  exception
 . The given string
  fmt
  and remaining arguments
  
 are interpreted as with
  printf
 .
  
 void 
 rb_fatal
 ( const char *fmt, ... )
  
 Raises a
  Fatal
  exception, terminating the process. No rescue blocks
  
 are called, but ensure blocks will be called. The given string
  fmt
  and
  
 remaining arguments are interpreted as with
  printf
 .
  
 void 
 rb_bug
 ( const char *fmt, ... )
  
 Terminates the process immediately—no handlers of any sort will be
  
 called. The given string
  fmt
  and remaining arguments are interpreted
  
 as with
  printf
 . You should call this function only if a fatal bug has
  
 been exposed. You don’t write fatal bugs, do you?
  
 void 
 rb_sys_fail
 ( const char *msg )
  
 Raises a platform-specific exception corresponding to the last known
  
 system error, with the given
  msg
 .
  
 VALUE 
  
 rb_rescue
 ( VALUE (*body)(), VALUE args, VALUE(*rescue)(),
  
 VALUE rargs )
  
 Executes
  body
  with the given
  args
 . If a
  StandardError
  exception is
  
 raised, then execute
  rescue
  with the given
  rargs
 .
  
 VALUE 
  
 rb_ensure
 ( VALUE(*body)(), VALUE args, VALUE(*ensure)(),
  
 VALUE eargs )
  
 Executes
  body
  with the given
  args
 . Whether or not an exception is
  
 raised, execute
  ensure
  with the given
  rargs
  after
  body
  has completed.
  
 VALUE 
  
 rb_protect
 ( VALUE (*body)(), VALUE args, int *result )
  
 Executes
  body
  with the given
  args
  and returns nonzero in
  result
  if
  
 any exception was raised.
  
 void 
 rb_notimplement
 ( )
  
 Raises a
  NotImpError
  exception to indicate that the enclosed func-
  
 tion is not implemented yet or not available on this platform.
  
 void 
 rb_exit
 ( int status )
  
 Exits Ruby with the given
  status
 . Raises a
  SystemExit
  exception
  
 and calls registered exit functions and finalizers.
  
 Prepared exclusively for Yeganefar",NA
API: Iterators,"void 
 rb_iter_break
 ( )
  
 Breaks out of the enclosing iterator block.
  
 VALUE 
  
 rb_each
 ( VALUE obj )
  
 Invokes the
  each
  method of the given
  obj
 .
  
 VALUE 
  
 rb_yield
 ( VALUE arg )
  
 Transfers execution to the iterator block in the current context, pass-
  
 ing
  arg
  as an argument. Multiple values may be passed in an array.
  
 int 
 rb_block_given_p
 ( )
  
 Returns true if
  yield
  would execute a block in the current context—
  
 that is, if a code block was passed to the current method and is avail-
  
 able to be called.
  
 VALUE 
  
 rb_iterate
 ( VALUE (*method)(), VALUE args,
  
 VALUE (*block)(), VALUE arg2 )
  
 Invokes
  method
  with argument
  args
  and block
  block
 . A
  yield
  from
  
 that method will invoke
  block
  with the argument given to
  yield
  and
  
 a second argument
  arg2
 .
  
 VALUE 
  
 rb_catch
 ( const char *tag, VALUE (*proc)(), VALUE value )
  
 Equivalent to Ruby
  catch
 .
  
 void 
 rb_throw
 ( const char *tag , VALUE value )
  
 Equivalent to Ruby
  throw
 .",NA
API: Accessing Variables,"VALUE 
  
 rb_iv_get
 ( VALUE obj, char *name )
  
 Returns the instance variable
  name
  (which must be specified with a
  
 @
  prefix) from the given
  obj
 .
  
 Prepared exclusively for Yeganefar",NA
API: Object Status,"OBJ_TAINT
 ( VALUE obj )
  
 Marks the given
  obj
  as tainted.
  
 int 
 OBJ_TAINTED
 ( VALUE obj )
  
 Returns nonzero if the given
  obj
  is tainted.
  
 OBJ_FREEZE
 ( VALUE obj )
  
 Marks the given
  obj
  as frozen.
  
 Prepared exclusively for Yeganefar",NA
API: Commonly Used Methods,"VALUE 
  
 rb_ary_new
 ( )
  
 Returns a new
  Array
  with default size.
  
 VALUE 
  
 rb_ary_new2
 ( long length )
  
 Returns a new
  Array
  of the given
  length
 .
  
 VALUE 
  
 rb_ary_new3
 ( long length, ... )
  
 Returns a new
  Array
  of the given
  length
  and populated with the
  
 remaining arguments.
  
 VALUE 
  
 rb_ary_new4
 ( long length, VALUE *values )
  
 Returns a new
  Array
  of the given
  length
  and populated with the C
  
 array
  values
 .
  
 void 
 rb_ary_store
 ( VALUE self, long index, VALUE value )
  
 Stores
  value
  at
  index
  in array
  self
 .
  
 VALUE 
  
 rb_ary_push
 ( VALUE self, VALUE value )
  
 Pushes
  value
  onto the end of array
  self
 . Returns
  value
 .
  
 VALUE 
  
 rb_ary_pop
 ( VALUE self )
  
 Removes and returns the last element from the array
  self
 .
  
 VALUE 
  
 rb_ary_shift
 ( VALUE self )
  
 Removes and returns the first element from the array
  self
 .
  
 Prepared exclusively for Yeganefar",NA
Part III,NA,NA
Ruby Crystallized,"Prepared exclusively for Yeganefar
  
 301",NA
Chapter 22,NA,NA
The Ruby Language,"This chapter is a bottom-up look at the Ruby language. Most of what appears here is 
 the syntax and semantics of the language itself—we mostly ignore the built-in classes 
 and modules (these are covered in depth starting on page
  402
 ). However, Ruby 
 sometimes implements features in its libraries that in most languages would be part of 
 the basic syntax. We’ve included these methods here and have tried to flag them with 
 “Library”in the margin.
  
 The contents of this chapter may look familiar—with good reason. We’ve covered 
 just about all of this in the earlier tutorial chapters. Consider this chapter to be a self-
 contained reference to the core Ruby language.",NA
Source Layout,"Ruby programs are written in 7-bit ASCII, Kanji (using EUC or SJIS), or UTF-8. If a 
 code set other than 7-bit ASCII is used, the
  KCODE
  option must be set appropriately, 
 as shown on page
  169
 .
  
 Ruby is a line-oriented language. Ruby expressions and statements are terminated at 
 the end of a line unless the parser can determine that the statement is incomplete—for 
 example if the last token on a line is an operator or comma. A semicolon can be used 
 to separate multiple expressions on a line. You can also put a backslash at the end of 
 a line to continue it onto the next. Comments start with
  #
  and run to the end of the 
 physical line. Comments are ignored during syntax analysis.
  
 a = 1
  
 b = 2; c = 3
  
 d = 4 + 5 + 
  
 6 + 7 # no '\' needed
  
 e = 8 + 9 \ 
  
 + 10 
  
 # '\' needed
  
 Prepared exclusively for Yeganefar 
 302",NA
BEGIN and END Blocks,"Every Ruby source file can declare blocks of code to be run as the file is being loaded 
 (the
  BEGIN
  blocks) and after the program has finished executing (the
  END
  blocks).
  
 BEGIN { 
  
 begin code 
  
 }
  
 END { 
  
 end code 
  
 }
  
 A program may include multiple
  BEGIN
  and
  END
  blocks.
  BEGIN
  blocks are executed in 
 the order they are encountered.
  END
  blocks are executed in reverse order.",NA
General Delimited Input,"As well as the normal quoting mechanism, alternative forms of literal strings, arrays, 
 regular expressions, and shell commands are specified using a generalized delimited 
 syntax. All these literals start with a percent character, followed by a single character 
 that identifies the literal’s type. These characters are summarized in Table
  22.1
  on the 
 following page; the actual literals are described in the corresponding sections later in 
 this chapter.
  
 1.8
  
  
 Following the type character is a delimiter, which can be any nonalphabetic or non-
  
 multibyte character.
  
 If the delimiter is one of the characters
  (
 ,
  [
 ,
  {
 , or
  <
 , the literal
  
 consists of the characters up to the matching closing delimiter, taking account of 
 nested delimiter pairs. For all other delimiters, the literal comprises the characters up 
 to the next occurrence of the delimiter character.
  
 %q/this is a string/ 
  
 %q-string-
  
 %q(a (nested) string)
  
 Prepared exclusively for Yeganefar",NA
The Basic Types,"The basic types in Ruby are numbers, strings, arrays, hashes, ranges, symbols, and
  
 regular expressions.",NA
Integer and Floating-Point Numbers,"Ruby integers are objects of class
  Fixnum
  or
  Bignum
 .
  Fixnum
  objects hold integers that
  
 fit within the native machine word minus 1 bit. Whenever a
  Fixnum
  exceeds this range,
  
 it is automatically converted to a
  Bignum
  object, whose range is effectively limited only
  
 by available memory. If an operation with a
  Bignum
  result has a final value that will fit
  
 in a
  Fixnum
 , the result will be returned as a
  Fixnum
 .
  
 1.8
  
  
 Integers are written using an optional leading sign, an optional base indicator (
 0
  for
  
 octal,
  0d
  for decimal,
  
 0x
  for hex, or
  0b
  for binary), followed by a string of digits in the
  
 appropriate base. Underscore characters are ignored in the digit string.
  
 123456 
  
 => 123456 
  
 # Fixnum
  
 0d123456 
  
 => 123456 
  
 # Fixnum
  
 123_456 
  
 => 123456 
  
 # Fixnum - underscore ignored
  
 -543 
  
 => -543 
  
 # Fixnum - negative number
  
 0xaabb 
  
 => 43707 
  
 # Fixnum - hexadecimal
  
 0377 
  
 => 255 
  
 # Fixnum - octal
  
 -0b10_1010 
  
 => -42 
  
 # Fixnum - binary (negated)
  
 123_456_789_123_456_789 
  
 => 123456789123456789 # Bignum
  
 You can get the integer value corresponding to an ASCII character by preceding that
  
 character with a question mark. Control characters can be generated using
  ?\C-
 x
  and
  
 Prepared exclusively for Yeganefar",NA
Ranges,"Outside the context of a conditional expression,
  expr
 ..
 expr
  and
  expr
 ...
 expr
  construct 
 Range
  objects. The two-dot form is an inclusive range; the one with three dots is a 
 range that excludes its last element. See the description of class
  Range
  on page
  576
  for 
 details. Also see the description of conditional expressions on page
  327
  for other uses 
 of ranges.",NA
Arrays,"Literals of class
  Array
  are created by placing a comma-separated series of object ref-
 erences between square brackets. A trailing comma is ignored.
  
 arr = [ fred, 10, 3.14, ""This is a string"", barney(""pebbles""), ]
  
 1.8
  
  
 Arrays of strings can be constructed using the shortcut notations
  %w
  and
  
 %W
 .
  
 The low-
  
 ercase form extracts space-separated tokens into successive elements of the array. No 
 substitution is performed on the individual strings. The uppercase version also 
 converts the words to an array, but performs all the normal double-quoted string 
 substitutions on each individual word. A space between words can be escaped with a 
 backslash. This is a form of general delimited input, described on pages
  303
 –
 304
 .
  
 arr = %w( fred wilma barney betty great\ gazoo )
  
 arr
  
 →
  
 [""fred"", ""wilma"", ""barney"", ""betty"", ""great gazoo""]
  
 arr = %w( Hey!\tIt is now -#{Time.now}- )
  
 arr
  
 →
  
 [""Hey!\\tIt"", ""is"", ""now"", ""-#{Time.now}-""]
  
 arr = %W( Hey!\tIt is now -#{Time.now}- )
  
 arr
  
 →
  
 [""Hey!\tIt"", ""is"", ""now"", ""-Thu Aug 26 22:37:13 CDT 2004-""]",NA
Hashes,"A literal Ruby
  Hash
  is created by placing a list of key/value pairs between braces, 
 with either a comma or the sequence
  =>
  between the key and the value. A trailing 
 comma is ignored.
  
 Prepared exclusively for Yeganefar",NA
Symbols,"A Ruby symbol is an identifier corresponding to a string of characters, often a name.
  
 1.8
  
  
 You construct the symbol for a name by preceding the name with a colon, and you can 
 construct the symbol for an arbitrary string by preceding a string literal with a colon.
  
 Substitution occurs in double-quoted strings. A particular name or string will always 
 generate the same symbol, regardless of how that name is used within the program.
  
 :Object 
  
 :my_variable 
  
 :""Ruby rules"" 
  
 a = ""cat""
  
 :'catsup'
  
 →
  
 :catsup
  
 :""#{a}sup""
  
 →
  
 :catsup
  
 :'#{a}sup'
  
 :""\#{a}sup""
  
 →
  
 Other languages call this process
  interning,
  and call symbols
  atoms
 .",NA
Regular Expressions,"Regular expression literals are objects of type
  Regexp
 . They are created explicitly by 
 calling the
  Regexp.new
  constructor or implicitly by using the literal forms, /
 pattern
 / 
 and
  %r{
 pattern
 }
 . The
  %r
  construct is a form of general delimited input (described on 
 pages
  303
 –
 304
 ).
  
 /pattern/ 
  
 /pattern/
 options 
  
 %r{pattern} 
  
 %r{pattern}
 options 
  
 Regexp.new( 'pattern'
  [
  ,
  options
  ]
  )
  
 Regular Expression Options
  
 A regular expression may include one or more options that modify the way the 
 pattern matches strings. If you’re using literals to create the
  Regexp
  object, then the 
 options are one or more characters placed immediately after the terminator. If you’re 
 using 
 Regexp.new
 , the options are constants used as the second parameter of the 
 constructor.
  
 1.8
  
  
 i
  
 Case Insensitive
 . The pattern match will ignore the case of letters in the pattern and
  
 o
  
 string. Setting
  $=
  
 to make matches case insensitive is now deprecated.
  
 Substitute Once
 . Any
  #...
  substitutions in a particular regular expression literal
  
 will be performed just once, the first time it is evaluated. Otherwise, the substitu-
 tions will be performed every time the literal generates a
  Regexp
  object.
  
 m 
  
 Multiline Mode
 . Normally, “.” matches any character except a newline. With the 
  
 /m
  option, “.” matches any character.
  
 x 
  
 Extended Mode
 . Complex regular expressions can be difficult to read. The
  x
  option 
  
 allows you to insert spaces, newlines, and comments in the pattern to make it more 
  
 readable.
  
 Another set of options allows you to set the language encoding of the regular expres-
 sion. If none of these options is specified, the interpreter’s default encoding (set 
 using
 -K
  or
  $KCODE
 ) is used.
  
 n:
  
 no encoding (ASCII)
  
 e:
  
 EUC
  
 s:
  
 SJIS
  
 u:
  
 UTF-8
  
 Regular Expression Patterns
  
 regular characters 
  
 All characters except ., |, (, ), [, \, ^, {, +, $, *, and ? match themselves. 
 To match one of these characters, precede it with a backslash.
  
 ^ 
  
 Matches the beginning of a line.
  
 $ 
  
 Matches the end of a line.
  
 \A 
  
 Matches the beginning of the string.",NA
Names,"Ruby names are used to refer to constants, variables, methods, classes, and modules. 
 The first character of a name helps Ruby to distinguish its intended use. Certain 
 names, listed in Table
  22.3
  on the following page, are reserved words and should not 
 be used as variable, method, class, or module names.
  
 Method names are described in the section beginning on page
  330
 .
  
 In these descriptions,
  lowercase letter
  means the characters
  a
  though
  z
 , as well as _, 
 the underscore.
  Uppercase letter
  means
  A
  though
  Z
 , and
  digit
  means
  0
  through
  9
 . A
  
 name 
 is an uppercase letter, lowercase letters, or an underscore, followed by
  name 
 characters
 : any combination of upper- and lowercase letters, underscores, and digits.
  
 A
  local variable name
  consists of a lowercase letter followed by name characters. It 
 is conventional to use underscores rather than camelCase to write multiword names, 
 but the interpreter does not enforce this.
  
 fred
  
 anObject
  
 _x
  
 three_two_one
  
 An
  instance variable name
  starts with an “at” sign (
 @
 ) followed by a name. It is gen-
 erally a good idea to use a lowercase letter after the
  @
 .
  
 @name
  
 @_
  
 @size
  
 A
  class variable name
  starts with two “at” signs (
 @@
 ) followed by a name.
  
 @@name
  
 @@_
  
 @@Size
  
 A
  constant name
  starts with an uppercase letter followed by name characters. Class 
 names and module names are constants and follow the constant naming conventions. 
 By convention, constant object references are normally spelled using uppercase 
 letters and underscores throughout, while class and module names are MixedCase.
  
 module Math 
  
 ALMOST_PI = 22.0/7.0 
  
 end 
  
 class BigBlob 
  
 end
  
 Global variables
 , and some special system variables, start with a dollar sign (
 $
 ) fol-
 lowed by name characters. In addition, Ruby defines a set of two-character global 
 vari-able names in which the second character is a punctuation character. These 
 predefined",NA
Variable/Method Ambiguity,"When Ruby sees a name such as
  a
  in an expression, it needs to determine if it is a 
 local variable reference or a call to a method with no parameters. To decide which is 
 the case, Ruby uses a heuristic. As Ruby parses a source file, it keeps track of 
 symbols that have been assigned to. It assumes that these symbols are variables. 
 When it subsequently comes across a symbol that could be a variable or a method 
 call, it checks to see if it has seen a prior assignment to that symbol. If so, it treats the 
 symbol as a variable; otherwise it treats it as a method call. As a somewhat 
 pathological case of this, consider the following code fragment, submitted by 
 Clemens Hintze.
  
 def a 
  
 print ""Function 'a' called\n"" 
  
 99 
  
 end
  
 for i in 1..2 
  
 if i == 2 
  
  
 print ""a="", a, ""\n"" 
  
 else 
  
  
 a = 1 
  
  
 print ""a="", a, ""\n"" 
  
 end 
  
 end
  
 produces:
  
 a=1 
  
 Function 'a' called 
  
 a=99
  
 During the parse, Ruby sees the use of
  a
  in the first print statement and, as it hasn’t 
 yet seen any assignment to
  a
 , assumes that it is a method call. By the time it gets to 
 the second print statement, though, it
  has
  seen an assignment, and so treats
  a
  as a 
 variable.",NA
Variables and Constants,"Ruby variables and constants hold references to objects. Variables themselves do not 
 have an intrinsic type. Instead, the type of a variable is defined solely by the 
 messages to which the object referenced by the variable responds.
 2
  
 A Ruby
  constant
  is also a reference to an object. Constants are created when they are 
 first assigned to (normally in a class or module definition). Ruby, unlike less flexible 
 languages, lets you alter the value of a constant, although this will generate a warning 
 message.
  
 MY_CONST = 1 
  
 MY_CONST = 2 # generates a warning
  
 produces:
  
 prog.rb:2: warning: already initialized constant MY_CONST
  
 Note that although constants should not be changed, you can alter the internal states of 
 the objects they reference.
  
 MY_CONST = ""Tim"" 
  
 MY_CONST[0] = ""J"" 
  
 # alter string referenced by constant 
  
 MY_CONST
  
 →
 ""Jim""
  
 Assignment potentially
  aliases
  objects, giving the same object different names.",NA
Scope of Constants and Variables,"Constants
  defined within a class or module may be accessed unadorned anywhere 
 within the class or module. Outside the class or module, they may be accessed using 
 the scope operator,
  ::
  prefixed by an expression that returns the appropriate class or 
 mod-ule object. Constants defined outside any class or module may be accessed 
 unadorned
  
 1.8
  
  
 or by using the scope operator
  ::
  with no prefix. Constants may not be defined in meth-
  
 ods. Constants may be 
 added
  
 to existing classes and modules from the outside by using
  
 the class or module name and the scope operator before the constant name.
  
 OUTER_CONST = 99
  
 2.
  
 When we say that a variable is not typed, we mean that any given variable can at different times hold
  
 references to objects of many different types.",NA
Predefined Variables,"The following variables are predefined in the Ruby interpreter. In these descriptions, 
 the notation
  [r/o]
  indicates that the variables are read-only; an error will be raised if a 
 program attempts to modify a read-only variable. After all, you probably don’t want 
 to change the meaning of
  true
  halfway through your program (except perhaps if 
 you’re a politician). Entries marked
  [thread]
  are thread local.
  
 Many global variables look something like Snoopy swearing:
  $_
 ,
  $!
 ,
  $&
 , and so on. 
 This is for “historical” reasons, as most of these variable names come from Perl. If 
 you find memorizing all this punctuation difficult, you may want to have a look at the 
 library file called
  English
 , documented on page
  650
 , which gives the commonly used 
 global variables more descriptive names.
  
 Prepared exclusively for Yeganefar",NA
Global Constants,"The following constants are defined by the Ruby interpreter.
  
 DATA
  
 IO
  
 If the the main program file contains the directive
  __END__
 , then
  
 the constant
  DATA
  will be initialized so that reading from it will 
  
 return lines following
  __END__
  from the source file.
  
 FALSE
  
 FalseClass
  
 Synonym for
  false
 .
  
 NIL
  
 NilClass
  
 Synonym for
  nil
 .
  
 RUBY_PLATFORM
  
 String
  
 The identifier of the platform running this program. This string
  
 is in the same form as the platform identifier used by the GNU 
  
 configure utility (which is not a coincidence).
  
 RUBY_RELEASE_DATE
  
 String
  
 The date of this release.
  
 RUBY_VERSION
  
 String
  
 The version number of the interpreter.
  
 STDERR
  
 IO
  
 The actual standard error stream for the program. The initial
  
 value of
  $stderr
 .
  
 STDIN
  
 IO
  
 The actual standard input stream for the program. The initial
  
 value of
  $stdin
 .
  
 STDOUT
  
 IO
  
 The actual standard output stream for the program. The initial
  
 value of
  $stdout
 .
  
 SCRIPT_LINES__
  
 Hash
  
 If a constant
  SCRIPT_LINES__
  is defined and references a
  Hash
 ,
  
 Ruby will store an entry containing the contents of each file it 
  
 parses, with the file’s name as the key and an array of strings 
 as 
  
 the value. See
  Kernel.require
  on page
  507
  for an example.
  
 TOPLEVEL_BINDING
  
 Binding
  
 A
  Binding
  object representing the binding at Ruby’s top level—
  
 the level where programs are initially executed.
  
 TRUE
  
 TrueClass
  
 Synonym for
  true
 .
  
 The constant
  __FILE__
  and the variable
  $0
  are often used together to run code only if it 
 appears in the file run directly by the user. For example, library writers often use this 
 to include tests in their libraries that will be run if the library source is run directly, 
 but not if the source is required into another program.
  
 # library code 
  
 # ...
  
 if __FILE__ == $0 
  
 # tests...
  
 end",NA
Expressions,"Single terms in an expression may be any of the following.
  
 •
  Literal
 . Ruby literals are numbers, strings, arrays, hashes, ranges, symbols, and 
  
 regular expressions. There are described starting on page
  304
 .
  
 •
  Shell command
 . A shell command is a string enclosed in backquotes or in a 
 general delimited string (page
  303
 ) starting with
  %x
 . The value of the string is 
 the standard output of running the command represented by the string under the 
 host operating system’s standard shell. The execution also sets the
  $?
  variable 
 with the command’s exit status.
  
 filter = ""*.c"" 
  
 files = `ls #{filter}` 
  
 files = %x{ls #{filter}}
  
  
 1.8
  
 •
  Symbol generator
 . A
  Symbol
  object is created by prefixing an operator, string, 
  
  
 variable, constant, method, class, module name with a colon. The symbol object 
  
  
 will be unique for each different name but does not refer to a particular instance 
  
  
 of the name, so the symbol for (say)
  :fred
  will be the same regardless of context.
  
 A symbol is similar to the concept of atoms in other high-level languages.
  
 •
  Variable reference
  or
  constant reference
 . A variable is referenced by citing its 
 name. Depending on scope (see page
  315
 ), a constant is referenced either by cit-
 ing its name or by qualifying the name, using the name of the class or module 
 containing the constant and the scope operator (
 ::
 ).
  
 barney # variable reference 
  
 APP_NAMR # constant reference 
  
 Math::PI # qualified constant reference
  
 •
  Method invocation
 . The various ways of invoking a method are described starting 
  
 on page
  333
 .",NA
Operator Expressions,"Expressions may be combined using operators. Table
  22.4
  on the next page lists the 
 Ruby operators in precedence order. The operators with a in the Method column are 
 implemented as methods, and may be overridden.",NA
More on Assignment,"The assignment operator assigns one or more
  rvalues
  (the
  r
  stands for “right,” as 
 rvalues tend to appear on the right side of assignments) to one or more
  lvalues
  (“left” 
 values). What is meant by assignment depends on each individual lvalue.",NA
Block Expressions ,"begin 
  
  
  
 body 
  
  
 end 
  
 Expressions may be grouped between
  begin
  and
  end
 . The value of the block expres-sion 
 is the value of the last expression executed.
  
 Block expressions also play a role in exception handling, which is discussed starting on 
 page
  345
 .
  
 Prepared exclusively for Yeganefar",NA
Boolean Expressions,"Ruby predefines the globals
  false
  and
  nil
 . Both of these values are treated as being 
 false in a boolean context. All other values are treated as being true. The constant
  true 
 is available for when you need an explicit “true” value.
  
 And, Or, Not, and Defined?
  
 The
  and
  and
  &&
  operators evaluate their first operand. If false, the expression returns 
 the value of the first operand; otherwise, the expression returns the value of the 
 second operand.
  
 expr1
  
 and
  
 expr2
  
 expr1
  
 &&
  
 expr2
  
 The
  or
  and
  ||
  operators evaluate their first operand. If true, the expression returns the 
 value of their first operand; otherwise, the expression returns the value of the second 
 operand.
  
 expr1
  
 or
  
 expr2
  
 expr1
  
 ||
  
 expr2
  
 The
  not
  and
  !
  operators evaluate their operand. If true, the expression returns false. If 
 false, the expression returns true. For historical reasons, a string, regexp, or range 
 may not appear as the single argument to
  not
  or
  !
 .
  
 The word forms of these operators (
 and
 ,
  or
 , and
  not
 ) have a lower precedence than the 
 corresponding symbol forms (
 &&
 ,
  ||
 , and
  !
 ). See Table
  22.4
  on page
  324
  for details.
  
 The
  defined?
  operator returns
  nil
  if its argument, which can be an arbitrary expres-sion, 
 is not defined. Otherwise, it returns a description of that argument. For examples, see 
 page
  88
  in the tutorial.
  
 Comparison Operators
  
 The Ruby syntax defines the comparison operators
  ==
 ,
  ===
 ,
  <=>
 ,
  <
 ,
  <=
 ,
  >
 ,
  >=
 ,
  =~
 . All of 
 these operators are implemented as methods. By convention, the language also uses 
 the standard methods
  eql?
  and
  equal?
  (see Table
  7.1
  on page
  89
 ). Although the 
 operators have intuitive meaning, it is up to the classes that implement them to 
 produce mean-ingful comparison semantics. The library reference starting on page
  
 402
  describes the comparison semantics for the built-in classes. The module
  
 Comparable
  provides sup-port for implementing the operators
  ==
 ,
  <
 ,
  <=
 ,
  >
 ,
  >=
 , and the 
 method
  between?
  in terms of
  <=>
 . The operator
  ===
  is used in
  case
  expressions, 
 described on page
  328
 .
  
 Both
  ==
  and
  =~
  have negated forms,
  !=
  and
  !~
 . Ruby converts these during syntax anal-
 ysis:
  a != b
  is mapped to
  !(a == b)
 , and
  a !~ b
  is mapped to
  !(a 
  
 =~ b)
 . No methods 
 correspond to
  !=
  and
  !~
 .",NA
 and,unless,NA
 Expressions,"if
  boolean-expression
  [
  then | :
  ] 
  
 body 
  
 [
  elsif
  boolean-expression
  [
  then | :
  ] 
  
 body
  , ...
  ]
  
 [
  
 else
  
 ]
  
 body
  
 end
  
 unless
  boolean-expression
  [
  then | :
  ] 
  
 body 
  
 [
  else 
  
 body 
  
 ] 
  
 end
  
 The
  then
  keyword (or a colon) separates the body from the condition. It is not 
 required if the body starts on a new line. The value of an
  if
  or
  unless
  expression is the 
 value of the last expression evaluated in whichever body is executed.
  
 if
  and
  unless
  Modifiers
  
 expression
  if 
  
 boolean-expression 
  
 expression
  unless
  boolean-expression
  
 evaluates
  expression
  only if
  boolean-expression
  is true (for
  if
 ) or false (for
  unless
 ).",NA
Ternary Operator,"boolean-expression
  ?
  expr1
  :
  expr2
  
 returns
  expr1
  if
  boolean expression
  is true and
  expr2
  otherwise.
  
 case",NA
 Expressions,"Ruby has two forms of
  case
  statement. The first allows a series of conditions to be 
 evaluated, executing code corresponding to the first condition that is true.
  
 case 
  
 when
  condition
  [,
  condition
  ]... [
  then | :
  ] 
  
  
 body 
  
 when
  condition
  [,
  condition
  ]... [
  then | :
  ] 
  
  
 body 
  
 ...
  
 [
  else 
  
  
 ] 
 body 
  
 end
  
 The second form of a case expression takes a target expression following the
  case
  
 key-word. It searches for a match by starting at the first (top left) comparison, 
 performing 
 comparison
  ===
  target
 .
  
 Prepared exclusively for Yeganefar",NA
Loops,"while
  boolean-expression
  [
  do | :
  ] 
  
 body 
  
 end
  
 executes
  body
  zero or more times as long as
  boolean-expression
  is true.
  
 until
  boolean-expression
  [
  do | :
  ] 
  
 body 
  
 end
  
 executes
  body
  zero or more times as long as
  boolean-expression
  is false.
  
 In both forms, the
  do
  or colon separates
  boolean-expression
  from the
  body
  and can be 
 omitted when the body starts on a new line.
  
 for
  name
  [,
  name
  ]...
  in
  expression
  [
  do | :
  ] 
  
 body 
  
 end
  
 The
  for
  loop is executed as if it were the following
  each
  loop, except that local vari-
 ables defined in the body of the
  for
  loop will be available outside the loop, and those 
 defined within an iterator block will not.
  
 expression
 .each do |
  name
  [,
  name
  ]...
  | 
  
 body 
  
 end
  
 loop
 , which iterates its associated block, is not a language construct—it is a method in 
  
 Library 
 module
  Kernel
 .
  
 Prepared exclusively for Yeganefar",NA
",",redo,NA
",",next,NA
", and","retry
  
 break
 ,
  redo
 ,
  next
 , and
  retry
  alter the normal flow through a
  while
 ,
  until
 ,
  for
 , or iterator 
 controlled loop.
  
 break
  terminates the immediately enclosing loop—control resumes at the statement 
 following the block.
  redo
  repeats the loop from the start, but without reevaluating the 
 condition or fetching the next element (in an iterator). The
  next
  keyword skips to the 
 end of the loop, effectively starting the next iteration.
  retry
  restarts the loop, 
 reevaluating the condition.
  
 1.8
  
  
 break
  and
  next
  may optionally take one or more arguments.
  
 If used within a block,
  
 the given argument(s) are returned as the value of the yield. If used within a
  while
 , 
 until
 , or
  for
  loop, the value given to
  break
  is returned as the value of the statement, and 
 the value given to
  next
  is silently ignored. If break is never called, or if it is called 
 with no value, the loop returns
  nil
 .
  
 match = while line = gets 
  
  
 next if line =~ /^#/ 
  
  
 break line if line =~ /ruby/ 
  
 end
  
 match = for line in ARGF.readlines 
  
  
  
 next if line =~ /^#/ 
  
  
  
 break line if line =~ /ruby/ 
  
 end",NA
Method Definition,"def
  defname
  [
  (
  [
  arg
  [
  =
 val
  ]
 , ...
  ] [
  , 
 body 
  
 end
  
 *
 vararg
  ] [
  , &
 blockarg
  ]
  )
  ]
  
 defname
  is both the name of the method and optionally the context in which it is valid.
  
 Prepared exclusively for Yeganefar",NA
Method Arguments,"A method definition may have zero or more regular arguments, an optional array 
 argu-ment, and an optional block argument. Arguments are separated by commas, 
 and the argument list may be enclosed in parentheses.
  
 A regular argument is a local variable name, optionally followed by an equals sign 
 and an expression giving a default value. The expression is evaluated at the time the 
 method is called. The expressions are evaluated from left to right. An expression may 
 reference a parameter that precedes it in the argument list.
  
 def options(a=99, b=a+1) 
  
 [ a, b ] 
  
 end
  
 options
  
 →
  
 [99, 100]
  
 options 1
  
 →
  
 [1, 2]
  
 options 2, 4
  
 →
  
 [2, 4]
  
 The optional array argument must follow any regular arguments and may not have a 
 default. When the method is invoked, Ruby sets the array argument to reference a 
 new object of class
  Array
 . If the method call specifies any parameters in excess of the 
 regular argument count, all these extra parameters will be collected into this newly 
 created array.
  
 def varargs(a, *b) 
  
 [ a, b ] 
  
 end
  
 varargs 1
  
 →
  
 [1, []]
  
 varargs 1, 2
  
 →
  
 [1, [2]]
  
 varargs 1, 2, 3
  
 [1, [2, 3]]
  
 →
  
 If an array argument follows arguments with default values, parameters will first be 
 used to override the defaults. The remainder will then be used to populate the array.
  
 Prepared exclusively for Yeganefar",NA
Invoking a Method,"[
  receiver
 . 
  
 ]
  name 
  
 [ 
  
 parameters 
   
 ] [ 
   
 block 
   
 ] 
  
 [
  receiver
 ::
  ]
  name
  [ 
  
 parameters 
  
 ] [ 
  
 block 
  
 ]
  
 parameters
  
 ←
  
 (
  [
  param
 , ...
  ] 
  
 [
  ,
  hashlist
  ] [
  *
 array
  ] [
  &
 a_proc
  ]
  )
  
 block
  
 ←
  
 {
  blockbody
  } 
  
  
  
 do
  blockbody
  end
  
 Initial parameters are assigned to the actual arguments of the method. Following 
 these parameters may be a list of
  key
  =>
  value
  pairs. These pairs are collected into a 
 single new
  Hash
  object and passed as a single parameter.
  
 Following these parameters may be a single parameter prefixed with an asterisk. If 
 this parameter is an array, Ruby replaces it with zero or more parameters 
 corresponding to the elements of the array.
  
 def regular(a, b, *c) 
  
 # ..
  
 end 
  
 regular 1, 2, 3, 4 
  
 regular(1, 2, 3, 4) 
  
 regular(1, *[2, 3, 4])
  
 Prepared exclusively for Yeganefar",NA
super,"super
  
 [
  
 (
  [
  param
 , ...
  ] [
  *
 array
  ]
  )
  
 ]
  
 [
  block
  ]
  
 Within the body of a method, a call to
  super
  acts just like a call to that original 
 method, except that the search for a method body starts in the superclass of the object 
 that was found to contain the original method. If no parameters (and no parentheses) 
 are passed to
  super
 , the original method’s parameters will be passed; otherwise, the 
 parameters to
  super
  will be passed.",NA
Operator Methods,"expr1 
 operator 
  
 operator 
 expr1 
  
 expr1 operator expr2
  
 If the operator in an operator expression corresponds to a redefinable method (see the 
 Table
  22.4
  on page
  324
 ), Ruby will execute the operator expression as if it had been 
 written
  
 (
 expr1
 ).
 operator
 (
 expr2
 )",NA
Attribute Assignment,"receiver
 .
 attrname
  =
  rvalue
  
 When the form
  receiver
 .
 attrname
  appears as an lvalue, Ruby invokes a method named
  
 1.8
  
  
 attrname=
  in the receiver, passing
  rvalue
  as a single parameter. The value returned by
  
 this assignment
  
 is always
  rvalue
 —the return value of the method
  attrname=
  is dis-
  
 carded. If you want to access the return value (in the unlikely event that it isn’t the 
 rvalue
  anyway), send an explicit message to the method.",NA
Element Reference Operator,"receiver
 [
  expr
  [,
  expr
  ]...
  ] 
  
 receiver
 [
  expr
  [,
  expr
  ]...
  ] =
  rvalue
  
 When used as an rvalue, element reference invokes the method
  [ ]
  in the receiver, 
 passing as parameters the expressions between the brackets.
  
 When used as an lvalue, element reference invokes the method
  [ ]=
  in the receiver, 
 passing as parameters the expressions between the brackets, followed by the
  rvalue 
 being assigned.",NA
Aliasing,"alias
  new_name old_name
  
 creates a new name that refers to an existing method, operator, global variable, or 
 reg-ular expression backreference (
 $&
 ,
  $`
 ,
  $'
 , and
  $+
 ). Local variables, instance 
 variables, class variables, and constants may not be aliased. The parameters to
  alias
  
 may be names or symbols.
  
 class Fixnum 
  
 alias plus + 
  
 end
  
 1.plus(3)
  
 →
  
 4
  
 alias $prematch $`
  
 ""string"" =~ /i/
  
 →
  
 3
  
 $prematch
  
 →
  
 ""str""
  
 alias :cmd :`
  
 cmd ""date""
  
 →
  
 ""Thu Aug 26 22:37:16 CDT 2004\n""
  
  
 Prepared exclusively for Yeganefar",NA
Class Definition,"class
  [
  scope
 ::
  ]
  classname 
  
 [
  <
  superexpr
  ] 
  
 body 
  
 end
  
 class <<
  obj 
  
 body 
  
 end
  
 A Ruby class definition creates or extends an object of class
  Class
  by executing the 
 code in
  body
 . In the first form, a named class is created or extended. The resulting 
 Class
  object is assigned to a constant named
  classname
  (see below for scoping rules). 
 This name should start with an uppercase letter. In the second form, an anonymous 
 (singleton) class is associated with the specific object.
  
 If present,
  superexpr
  should be an expression that evaluates to a
  Class
  object that will be 
 the superclass of the class being defined. If omitted, it defaults to class
  Object
 .
  
 Within
  body
 , most Ruby expressions are executed as the definition is read. However:
  
 • Method definitions will register the methods in a table in the class object.
  
 • Nested class and module definitions will be stored in constants within the class, 
 not as global constants. These nested classes and modules can be accessed from 
 outside the defining class using “
 ::
 ” to qualify their names.
  
 module NameSpace 
  
 class Example 
  
  
 CONST = 123 
  
 end 
  
 end 
  
 obj = NameSpace::Example.new 
  
 a = NameSpace::Example::CONST
  
 • The
  Module
 #
 include
  method will add the named modules as anonymous super-
  
 classes of the class being defined.
  
 Prepared exclusively for Yeganefar",NA
Creating Objects from Classes,"obj
  =
  classexpr
 .new
  [
  
 (
  [
  args
 , ...
  ]
  )
  
 ]
  
 Class
  Class
  defines the instance method
  Class
 #
 new
 , which creates an object of the
  
 1.8
  
  
 class of the receiver (
 classexpr
  in the syntax example). This is done by calling the
  
 method
  classexpr
 .
 allocate
 .
  
 You can override this method, but your implementation
  
 must return an object of the correct class. It then invokes
  initialize
  in the newly created 
 object, and passes it any arguments originally passed to
  new
 .
  
 Prepared exclusively for Yeganefar",NA
Class Attribute Declarations,"Class attribute declarations are not part of the Ruby syntax: they are simply methods 
  
 Library 
 defined in class
  Module
  that create accessor methods automatically.
  
 class
  name 
  
 attr
  attribute 
  
 [
  ,
  writable
  ] 
  
 attr_reader 
  
 attribute
  [,
  attribute
  ]... 
  
 attr_writer 
  
 attribute
  [,
  attribute
  ]...
  
  
 attribute
  [,
  attribute
  ]... 
 attr_accessor 
  
 end",NA
Module Definitions,"module
  name 
  
 body 
  
 end
  
 A module is basically a class that cannot be instantiated. Like a class, its body is 
 executed during definition and the resulting
  Module
  object is stored in a constant. A 
 module may contain class and instance methods and may define constants and class 
 variables. As with classes, module methods are invoked using the
  Module
  object as a 
 receiver, and constants are accessed using the “
 ::
 ” scope resolution operator. The 
 name in a module definition may optionally be preceded by the names of enclosing 
 class(es) and/or module(s).
  
 CONST = ""outer"" 
  
 module Mod 
  
 CONST = 1 
  
 def Mod.method1 
  
 # module method 
  
  
 CONST + 1 
  
 end 
  
 end 
  
 module Mod::Inner 
  
 def (Mod::Inner).method2 
  
  
 CONST + "" scope"" 
  
 end 
  
 end
  
 Mod::CONST
  
 →
  
 1
  
 Mod.method1
  
 2
  
 →
  
 Mod::Inner::method2
  
 →
  
 ""outer scope""
  
  
 Prepared exclusively for Yeganefar",NA
Mixins—Including Modules,"class|module
  name 
  
 include
  expr 
  
 end
  
 A module may be included within the definition of another module or class using the 
 include
  
 method. The module or class definition containing the
  include
  gains access 
  
 Library 
 to the constants, class variables, and instance methods of the module it includes.
  
 If a module is included within a class definition, the module’s constants, class vari-
 ables, and instance methods are effectively bundled into an anonymous (and inaccess-
 ible) superclass for that class. Objects of the class will respond to messages sent to 
 the module’s instance methods. Calls to methods not defined in the class will be 
 passed to the module(s) mixed into the class before being passed to any parent class. 
 A module may choose to define an
  initialize
  method, which will be called upon the 
 creation of an object of a class that mixes in the module if either: (a) the class does 
 not define its own
  initialize
  method, or (b) the class’s
  initialize
  method invokes
  super
 .
  
 A module may also be included at the top level, in which case the module’s constants, 
 class variables, and instance methods become available at the top level.
  
 Module Functions
  
 Although
  include
  is useful for providing mixin functionality, it is also a way of bring-
 ing the constants, class variables, and instance methods of a module into another 
 name-space. However, functionality defined in an instance method will not be 
 available as a module method.
  
 module Math 
  
 def sin(x) 
  
  
 # 
  
 end 
  
 end
  
 # Only way to access Math.sin is... 
  
 include Math 
  
 sin(1)
  
 The method
  Module
 #
 module_function
  solves this problem by taking one or more 
  
 Library 
 module instance methods and copying their definitions into corresponding module methods.
  
 module Math 
  
 def sin(x) 
  
  
 # 
  
 end 
  
 module_function :sin 
  
 end
  
 Math.sin(1) 
  
 include Math 
  
 sin(1)
  
 Prepared exclusively for Yeganefar",NA
Access Control,"Ruby defines three levels of protection for module and class constants and methods:
  
 •
  Public
 . Accessible to anyone.
  
 •
  Protected
 . Can be invoked only by objects of the defining class and its subclasses.
  
 •
  Private
 . Can be called only in functional form (that is, with an implicit
  self
  as the 
 receiver). Private methods therefore can be called only in the defining class and 
 by direct descendents within the same object. See discussion starting on page
  35 
 for examples.
  
 private 
 [
  symbol
 , ...
  ] 
  
 protected 
 [
  symbol
 , ...
  ] 
  
 public 
 [
  symbol
 , ...
  ]
  
 Each function can be used in two different ways. 
  
 Library
  
 1. If used with no arguments, the three functions set the default access control of 
  
 subsequently defined methods.
  
 2. With arguments, the functions set the access control of the named methods and 
  
 constants.
  
 Access control is enforced when a method is invoked.",NA
"Blocks, Closures, and Proc Objects","A code block is a set of Ruby statements and expressions between braces or a
  do
 /
 end 
 pair. The block may start with an argument list between vertical bars. A code block 
 may appear only immediately after a method invocation. The start of the block (the 
 brace or the
  do
 ) must be on the same logical line as the end of the invocation.
  
 invocation
  
 do
  
 | a1, a2, ... |
  
 end
  
 invocation
  
 {
  
 | a1, a2, ... |
  
 }
  
 Braces have a high precedence;
  do
  has a low precedence. If the method invocation has 
 parameters that are not enclosed in parentheses, the brace form of a block will bind to 
 the last parameter, not to the overall invocation. The
  do
  form will bind to the 
 invocation.",NA
"Proc Objects,",break,NA
", and","next
  
 Ruby’s blocks are chunks of code attached to a method that operate in the context of 
 the caller. Blocks are not objects, but they can be converted into objects of class
  Proc
 . 
 There are three ways of converting a block into a
  Proc
  object.
  
 Prepared exclusively for Yeganefar",NA
Return and Blocks,"A
  return
  from inside a
  block
  that’s still in scope acts as a return from that scope. A 
 return from a block whose original context is not longer valid raises an exception
  
 Prepared exclusively for Yeganefar",NA
Exceptions,"Ruby exceptions are objects of class
  Exception
  and its descendents (a full list of the 
 built-in exceptions is given in Figure
  27.1
  on page
  441
 ).",NA
Raising Exceptions,"The
  Kernel.raise
  method raises an exception. 
  
 Library
  
 raise 
  
 raise
  string 
  
 raise
  thing
  [
  ,
  string
  [
  stack trace
  ] ]
  
 The first form reraises the exception in
  $!
  or a new
  RuntimeError
  if
  $!
  is
  nil
 .
  
 The second form creates a new
  RuntimeError
  exception, setting its message to the given 
 string.
  
 The third form creates an exception object by invoking the method
  exception
  on its 
 first argument. It then sets this exception’s message and backtrace to its second and 
 third arguments.
  
 Class
  Exception
  and objects of class
  Exception
  contain a factory method called 
 exception
 , so an exception class name or instance can be used as the first parame-ter to
  
 raise
 .
  
 When an exception is raised, Ruby places a reference to the
  Exception
  object in the 
 global variable
  $!
 .
  
 Prepared exclusively for Yeganefar",NA
Handling Exceptions,"Exceptions may be handled
  
 • within the scope of a
  begin
 /
 end
  block,
  
 begin
  
 code...
  
 code...
  
 [
  rescue 
  
 [
  parm, ...
  ] [
  =>
  var
  ] [
  then
  ] 
  
  
 error handling code...
  , ...
  ] 
  
 [
  else 
  
  
 no exception code...
  ] 
  
 [
  ensure 
  
  
 always executed code...
  ] 
  
 end
  
 • within the body of a method,
  
 def
  method and args 
  
 code...
  
 code...
  
 [
  rescue 
  
 [
  parm, ...
  ] [
  =>
  var
  ] [
  then
  ] 
  
  
 error handling code...
  , ...
  ] 
  
 [
  else 
  
  
 no exception code...
  ] 
  
 [
  ensure 
  
  
 always executed code...
  ] 
  
 end
  
  
 1.8
  
 • and after the execution of a single statement.
  
 statement
  [
  rescue
  statement
 , ...
  ]
  
 A block or method may have multiple
  rescue
  clauses, and each
  rescue
  clause may
  
 specify zero or more exception parameters. A
  rescue
  clause with no parameter is treated 
 as if it had a parameter of
  StandardError
 . This means that some lower-level
  
 exceptions will not be caught by a parameterless
  rescue
  class. If you want to rescue 
 every exception, use
  
 rescue Exception => e
  
 When an exception is raised, Ruby scans up the call stack until it finds an enclosing 
 begin
 /
 end
  block, method body, or statement with a
  rescue
  modifier. For each
  rescue
  
 1.8
  
  
 clause in that block, Ruby compares the raised exception against each of the
  rescue
  
 clause’s parameters in turn; each parameter is tested using
  parameter
 ===$!
 .
  
 If the
  
 raised exception matches a
  rescue
  parameter, Ruby executes the body of the
  rescue
  
 and stops looking. If a matching
  rescue
  clause ends with
  =>
  and a variable name, the
  
 variable is set to
  $!
 .",NA
Catch and Throw,"The method
  Kernel.catch
  executes its associated block. 
  
 Library
  
 catch (
  symbol
  |
  string
  ) 
  
 do 
  
 block...
  
 end
  
 The method
  Kernel.throw
  interrupts the normal processing of statements. 
  
 Library
  
 throw(
  symbol
  |
  string
  [
  ,
  obj
  ]
  )",NA
Chapter 23,NA,NA
Duck Typing,"You’ll have noticed that in Ruby we don’t declare the types of variables or methods—
 everything is just some kind of object.
  
 Now, it seems like folks react to this in two ways. Some like this kind of flexibility 
 and feel comfortable writing code with dynamically typed variables and methods. If 
 you’re one of those people, you might want to skip to the section called “Classes 
 Aren’t Types” on the following page. Some, though, get nervous when they think 
 about all those objects floating around unconstrained. If you’ve come to Ruby from a 
 language such as C# or Java, where you’re used to giving all your variables and 
 methods a type, you may feel that Ruby is just too sloppy to use to write “real” 
 applications.
  
 It isn’t.
  
 We’d like to spend a couple of paragraphs trying to convince you that the lack of 
 static typing is not a problem when it comes to writing reliable applications. We’re 
 not trying to criticize other languages here. Instead, we’d just like to contrast 
 approaches.
  
 The reality is that the static type systems in most mainstream languages don’t really 
 help that much in terms of program security. If Java’s type system were reliable, for 
 example, it wouldn’t need to implement
  ClassCastException
 . The exception is nec-
 essary, though, because there is runtime type uncertainty in Java (as there is in C++, 
 C#, and others). Static typing can be good for optimizing code, and it can help IDEs 
 do clever things with tooltip help, but we haven’t seen much evidence that it 
 promotes more reliable code.
  
 On the other hand, once you use Ruby for a while, you realize that dynamically typed 
 variables actually add to your productivity in many ways. You’ll also be surprised to 
 discover that your fears about the type chaos were unfounded. Large, long-running, 
 Ruby programs run significant applications and just don’t throw any type-related 
 errors. Why is this?
  
 Partly, it’s a question of common sense. If you coded in Java (pre Java 1.5), all your 
 containers were effectively untyped: everything in a container was just an
  Object
 , and",NA
Classes Aren’t Types,"The issue of types is actually somewhat deeper than an ongoing debate between 
 strong typing advocates and the hippie-freak dynamic typing crowd. The real issue is 
 the ques-tion, what is a type in the first place?
  
 If you’ve been coding in conventional typed languages, you’ve probably been taught 
 that the
  type
  of an object is its
  class
 —all objects are instances of some class, and that 
 class is the object’s type. The class defines the operations (methods) that the object 
 can support, along with the state (instance variables) on which those methods operate. 
 Let’s look at some Java code.
  
 Customer c; 
  
 c = database.findCustomer(""dave""); /* Java */
  
 This fragment declares the variable
  c
  to be of type
  Customer
  and sets it to reference the 
 customer object for Dave that we’ve created from some database record. So the type 
 of the object in
  c
  is
  Customer
 , right?
  
 Maybe. However, even in Java, the issue is slightly deeper. Java supports the concept 
 of
  interfaces
 , which are a kind of emasculated abstract base class. A Java class can be 
 declared as implementing multiple interfaces. Using this facility, you may have 
 defined your classes as follows.
  
 Prepared exclusively for Yeganefar",NA
Coding like a Duck,"If you want to write your programs using the duck typing philosophy, you really only
  
 1.8
  
  
 need to remember one thing: an object’s type is determined by what it can do, not
  
 by its class. (In fact, Ruby 1.8 now deprecates the method
  Object
 #
 type
  
 in favor of
  
 Object
 #
 class
  for just this reason: the method returns the class of the receiver, so the 
 name
  type
  was misleading.)
  
 What does this mean in practice? At one level, it simply means that there’s often little 
 value testing the class of an object.
  
 For example, you may be writing a routine to add song information to a string. If you 
 come from a C# or Java background, you may be tempted to write:
  
 def append_song(result, song) 
  
 # test we're given the right parameters 
  
 unless result.kind_of?(String) 
  
  
 fail TypeError.new(""String expected"") 
  
 end 
  
 unless song.kind_of?(Song) 
  
  
 fail TypeError.new(""Song expected"") 
  
 end
  
 result << song.title << "" ("" << song.artist << "")"" 
  
 end
  
 result = """"
  
 append_song(result, song)
  
 →
  
 ""I Got Rhythm (Gene Kelly)""
  
 Embrace Ruby’s duck typing and you’d write something far simpler.
  
 Prepared exclusively for Yeganefar",NA
Standard Protocols and Coercions,"Although not technically part of the language, the interpreter and standard library use 
 various protocols to handle issues that other languages would deal with using types.
  
 Some objects have more than one natural representation. For example, you may be 
 writing a class to represent Roman numbers (I, II, III, IV, V, and so on). This class
  
 1.
  
 The duck typing club doesn’t check to see if you’re a
  member
  anyway. . . .
  
  
 Prepared exclusively for Yeganefar",NA
Numeric Coercion,"Back on page
  356
  we said there were three types of conversion performed by the inter-
 preter. We covered loose and strict conversion. The third is numeric coercion.
  
 Here’s the problem. When you write “1+2”, Ruby knows to call the
  +
  on the object
  1 
 (a
  Fixnum
 ), passing it the
  Fixnum
  2 as a parameter. However, when you write “1+2.3”, 
 the same
  +
  method now receives a
  Float
  parameter. How can it know what to do 
 (particularly as checking the classes of your parameters is against the spirit of duck 
 typing)?
  
 The answer lies in Ruby’s coercion protocol, based on the method
  coerce
 . The basic 
 operation of
  coerce
  is simple. It takes two numbers (one as its receiver, the other as a 
 parameter). It returns a two-element array containing representations of these two 
 numbers (but with the parameter first, followed by the receiver). The
  coerce
  method
  
 Prepared exclusively for Yeganefar",NA
"Walk the Walk, Talk the Talk","Duck typing can generate controversy. Every now and then a thread flares on the 
 mail-ing lists, or someone blogs for or against the concept. Many of the contributors 
 to these discussions have some fairly extreme positions.
  
 Ultimately, though, duck typing isn’t a set of rules; it’s just a style of programming. 
 Design your programs to balance paranoia and flexibility. If you feel the need to con-
 strain the types of objects that the users of a method pass in, ask yourself why. Try to 
 determine what could go wrong if you were expecting a
  String
  and instead get an 
 Array
 . Sometimes, the difference is crucially important. Often, though, it isn’t. Try 
 erring on the more permissive side for a while, and see if bad things happen. If not, 
 perhaps duck typing isn’t just for the birds.
  
 Prepared exclusively for Yeganefar",NA
Chapter 24,NA,NA
Classes and Objects,"Classes and objects are obviously central to Ruby, but at first sight they can seem a 
 little confusing. There seem to be a lot of concepts: classes, objects, class objects, 
 instance methods, class methods, singleton classes, and virtual classes. In reality, 
 however, Ruby has just a single underlying class and object structure, which we’ll 
 discuss in this chap-ter. In fact, the basic model is so simple, we can describe it in a 
 single paragraph.
  
 A Ruby object has three components: a set of flags, some instance variables, and an 
 associated class. A Ruby class is an object of class
  Class
 , which contains all the object 
 things plus a list of methods and a reference to a superclass (which is itself another 
 class). All method calls in Ruby nominate a receiver (which is by default
  self
 , the 
 current object). Ruby finds the method to invoke by looking at the list of methods in 
 the receiver’s class. If it doesn’t find the method there, it looks in any included 
 modules, then in its superclass, modules in the superclass, and then in the superclass’s 
 superclass, and so on. If the method cannot be found in the receiver’s class or any of 
 its ancestors, Ruby invokes the method
  method_missing
  on the original receiver.
  
 And that’s it—the entire explanation. On to the next chapter.
  
 “But wait,” you cry, “I spent good money on this chapter. What about all this other 
 stuff—virtual classes, class methods, and so on. How do they work?” Good question.",NA
How Classes and Objects Interact,"All class/object interactions are explained using the simple model given above: 
 objects reference classes, and classes reference zero or more superclasses. However, 
 the imple-mentation details can get a tad tricky.
  
 We’ve found that the simplest way of visualizing all this is to draw the actual 
 structures that Ruby implements. So, in the following pages we’ll look at all the 
 possible combi-nations of classes and objects. Note that these are not class diagrams 
 in the UML sense; we’re showing structures in memory and pointers between them.",NA
"Your Basic, Everyday Object","Let’s start by looking at an object created from a simple class. Figure
  24.1
  shows an 
 object referenced by a variable,
  lucille
 ; the object’s class,
  Guitar
 ; and that class’s 
 superclass,
  Object
 . Notice how the object’s class reference,
  klass
 , points to the class 
 object and how the
  super
  pointer from that class references the parent class.
  
 If we invoke the method
  lucille.play()
 , Ruby goes to the receiver,
  lucille
 , and follows 
 the
  klass
  reference to the class object for
  Guitar
 . It searches the method table, finds
  
 play
 , and invokes it.
  
 If instead we call
  lucille.display()
 , Ruby starts off the same way but cannot find 
 display
  
 in the method table in class
  Guitar
 . It then follows the
  super
  reference to 
 Guitar
 ’s 
 superclass,
  Object
 , where it finds and executes the method.",NA
What’s the Meta?,"Astute readers (yup, that’s all of you) will have noticed that the
  klass
  members of 
 Class
  objects point to nothing meaningful in Figure
  24.1
 . We now have all the infor-
 mation we need to work out what they
  should
  reference.
  
 When you say
  lucille.play()
 , Ruby follows
  lucille
 ’s
  klass
  pointer to find a class object in 
 which to search for methods. So what happens when you invoke a
  
 Prepared exclusively for Yeganefar",NA
Object-Specific Classes,"Ruby allows you to create a class tied to a particular object. In the following example, 
 we create two
  String
  objects. We then associate an anonymous class with one of them, 
 overriding one of the methods in the object’s base class and adding a new method.
  
 a = ""hello"" 
  
 b = a.dup
  
 class <<a 
  
 def to_s 
  
  
 ""The value is '#{self}'"" 
  
 end 
  
 def two_times 
  
  
 self + self 
  
 end 
  
 end",NA
Mixin Modules,"When a class includes a module, that module’s instance methods become available as 
 instance methods of the class. It’s almost as if the module becomes a superclass of the 
 class that uses it. Not surprisingly, that’s about how it works. When you include a 
 module, Ruby creates an anonymous proxy class that references that module and 
 inserts that proxy as the direct superclass of the class that did the including. The 
 proxy class contains references to the instance variables and methods of the module. 
 This is important: the same module may be included in many different classes and 
 will appear in many different inheritance chains. However, thanks to the proxy class, 
 there is still",NA
Extending Objects,"Just as you can define an anonymous class for an object using
  class <<
 obj
 , you can mix a 
 module into an object using
  Object
 #
 extend
 . For example:
  
 module Humor 
  
 def tickle 
  
  
 ""hee, hee!"" 
  
 end 
  
 end
  
 a = ""Grouchy"" 
  
 a.extend Humor
  
 a.tickle
  
 →
  
 ""hee, hee!""
  
 There is an interesting trick with
  extend
 . If you use it within a class definition, the 
 module’s methods become class methods. This is because calling
  extend
  is equivalent 
 to
  self.extend
 , so the methods are added to
  self
 , which in a class definition is the class 
 itself.
  
 Prepared exclusively for Yeganefar",NA
Class and Module Definitions,"Having exhausted the combinations of classes and objects, we can (thankfully) get 
 back to programming by looking at the nuts and bolts of class and module definitions.
  
 In languages such as C++ and Java, class definitions are processed at compile time: 
 the compiler creates symbol tables, works out how much storage to allocate, 
 constructs dispatch tables, and does all those other obscure things we’d rather not 
 think too hard about.
  
 Ruby is different. In Ruby, class and module definitions are executable code. 
 Although parsed at compile time, the classes and modules are created at runtime, 
 when the def-inition is encountered. (The same is also true of method definitions.) 
 This allows you to structure your programs far more dynamically than in most 
 conventional languages. You can make decisions once, when the class is being 
 defined, rather than each time those objects of the class are used. The class in the 
 following example decides as it is being defined what version of a decryption routine 
 to create.
  
 module Tracing 
  
 # ...
  
 end
  
 class MediaPlayer 
  
 include Tracing if $DEBUG
  
 if ::EXPORT_VERSION 
  
 def decrypt(stream) 
  
   
 raise ""Decryption not available"" 
  
 end 
  
 else 
  
 def decrypt(stream) 
  
   
 # ...
  
 end 
  
 end
  
 end
  
 If class definitions are executable code, this implies that they execute in the context of 
 some object:
  self
  must reference
  something
 . Let’s find out what it is.
  
 class Test 
  
 puts ""Class of self = #{self.class}"" 
  
 puts ""Name of self 
  
 = #{self.name}"" 
  
 end
  
 produces:
  
 Class of self = Class 
  
 Name of self 
  
 = Test
  
 This means that a class definition is executed with that class as the current object. 
 Referring back to the section about metaclasses on page
  363
 , we can see that this 
 means",NA
Class Instance Variables,"If a class definition is executes in the context of some object, that implies that a class 
 may have instance variables.
  
 class Test 
  
 @cls_var = 123 
  
 def Test.inc 
  
  
 @cls_var += 1 
  
 end 
  
 end
  
 Test.inc
  
 →
  
 124
  
 Test.inc
  
 125
  
 →
  
 If classes have their own instance variables, can we use
  attr_reader
  and friends to 
 access them? We can, but we have to run these methods in the correct place. For reg-
 ular instance variables, the attribute accessors are defined at the class level. For class 
 instance variables, we have to define the accessors in the metaclass.
  
 class Test 
  
 @cls_var = 123 
  
 class <<self 
  
  
 attr_reader :cls_var 
  
 end 
  
 end
  
 Test.cls_var
  
 →
  
 123
  
 This leads us to an interesting point. Many of the directives that you use when defin-
 ing a class or module, things such as
  alias_method
 ,
  attr
 , and
  public
 , are simply methods 
 in class
  Module
 . This creates some intriguing possibilities—you can extend
  
 Prepared exclusively for Yeganefar",NA
Class Names Are Constants,"We’ve said that when you invoke a class method, all you’re doing is sending a 
 message to the
  
 Class
  object itself. When you say something such as
  
 String.new(""gumby"")
 , you’re sending the message
  new
  to the object that is class
  String
 . 
 But how does Ruby know to do this? After all, the receiver of a message should be an 
 object reference, which implies that there must be a constant called
  String
  somewhere 
 containing a ref-erence to the
  String
  object.
 1
 And in fact, that’s exactly what happens. 
 All the built-in classes, along with the classes you define, have a corresponding 
 global constant with the same name as the class. This is both straightforward and 
 subtle. The subtlety comes from the fact that two things are named (for example)
  
 String
  in the system. There’s a 
 constant
  that references class String (an object of class
  
 Class
 ), and there’s the (class) object itself.
  
 The fact that class names are just constants means that you can treat classes just like 
 any other Ruby object: you can copy them, pass them to methods, and use them in 
 expressions.
  
 def factory(klass, *args) 
  
 klass.new(*args) 
  
 end
  
 factory(String, ""Hello"")
  
 →
  
 ""Hello""
  
 factory(Dir,
  
 ""."")
  
 #<Dir:0x1c90e4>
  
 →
  
 flag = true
  
 (flag ? Array : Hash)[1, 2, 3, 4]
  
 →
  
 [1, 2, 3, 4]
  
 flag = false
  
 (flag ? Array : Hash)[1, 2, 3, 4]
  
 →
  
 {1=>2, 3=>4}
  
 This has another facet: if a class with no name is assigned to a constant, Ruby gives the 
 class the name of the constant.
  
 var = Class.new
  
 var.name
  
 →
  
 """"
  
 Wibble = var
  
  
 var.name
  
 →
  
 ""Wibble""
  
 1.
  
 It will be a constant, not a variable, because
  String
  starts with an uppercase letter.
  
  
 Prepared exclusively for Yeganefar",NA
Top-Level Execution Environment,"Many times in this book we’ve claimed that everything in Ruby is an object. 
 However, we’ve used one thing time and time again that appears to contradict this—
 the top-level Ruby execution environment.
  
 puts ""Hello, World""
  
 Not an object in sight. We may as well be writing some variant of Fortran or BASIC. 
 But dig deeper, and you’ll come across objects and classes lurking in even the 
 simplest code.
  
 We know that the literal
  ""Hello, World""
  generates a Ruby
  String
 , so that’s one object. 
 We also know that the bare method call to
  puts
  is effectively the same as 
 self.puts
 . But 
 what is
  self
 ?
  
 self.class
  
 →
  
 Object
  
 At the top level, we’re executing code in the context of some predefined object. 
 When we define methods, we’re actually creating (private) instance methods for class
  
 Object
 . This is fairly subtle; as they are in class
  Object
 , these methods are available 
 every-where. And because we’re in the context of
  Object
 , we can use all of
  Object
 ’s 
 meth-ods (including those mixed-in from
  Kernel
 ) in function form. This explains why 
 we can call
  Kernel
  methods such as
  puts
  at the top level (and indeed throughout 
 Ruby): these methods are part of every object.
  
 Top-level instance variables also belong to this top-level object.",NA
Inheritance and Visibility,"The one last wrinkle to class inheritance is fairly obscure.
  
 Within a class definition, you can change the visibility of a method in an ancestor class. 
 For example, you can do something like
  
 class Base 
  
 def aMethod 
  
  
 puts ""Got here"" 
  
 end 
  
 private :aMethod 
  
 end
  
 class Derived1 < Base 
  
 public :aMethod 
  
 end
  
 class Derived2 < Base 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Freezing Objects,"Sometimes you’ve worked hard to make your object exactly right, and you’ll be 
 damned if you’ll let anyone just change it. Perhaps you need to pass some kind of 
 opaque object between two of your classes via some third-party object, and you want 
 to make sure it arrives unmodified. Perhaps you want to use an object as a hash key 
 and need to make sure that no one modifies it while it’s being used. Perhaps 
 something is corrupting one of your objects, and you’d like Ruby to raise an 
 exception as soon as the change occurs.
  
 Ruby provides a very simple mechanism to help with this. Any object can be
  frozen
  
 by invoking
  Object
 #
 freeze
 . A frozen object may not be modified: you can’t change its 
 instance variables (directly or indirectly), you can’t associate singleton methods with 
 it, and, if it is a class or module, you can’t add, delete, or modify its methods. Once 
 frozen, an object stays frozen: there is no
  Object
 #
 thaw
 . You can test to see if an object 
 is frozen using
  Object
 #
 frozen?
 .
  
 What happens when you copy a frozen object? That depends on the method you use. 
 If you call an object’s
  clone
  method, the entire object state (including whether it is 
 frozen) is copied to the new object. On the other hand,
  dup
  typically copies only the 
 object’s contents—the new copy will not inherit the frozen status.",NA
Chapter 25,NA,NA
Locking Ruby in the Safe,"Walter Webcoder has a great idea for a portal site: the Web Arithmetic Page. Sur-
 rounded by all sorts of cool mathematical links and banner ads that will make him 
 rich is a simple Web form containing a text field and a button. Users type an 
 arithmetic expression into the field, click the button, and the answer is displayed. All 
 the world’s calculators become obsolete overnight; Walter cashes in and retires to 
 devote his life to his collection of car license plate numbers.
  
 Implementing the calculator is easy, thinks Walter. He accesses the contents of the 
 form field using Ruby’s CGI library and uses the
  eval
  method to evaluate the string as 
 an expression.
  
 require 'cgi'
  
 cgi = CGI.new(""html4"")
  
 # Fetch the value of the form field ""expression"" expr = 
 cgi[""expression""].to_s
  
 begin 
  
 result = eval(expr) 
  
 rescue Exception => detail 
  
 # handle bad expressions 
  
 end
  
 # display result back to user...
  
 Roughly seven seconds after Walter puts the application online, a twelve-year-old 
 from Waxahachie with glandular problems and no real life types
  system(""rm *"")
  
 into the form and, like his computer’s files, Walter’s dreams come tumbling down.
  
 Walter learned an important lesson:
  All external data is dangerous. Don’t let it close 
 to interfaces that can modify your system.
  In this case, the content of the form field 
 was the external data, and the call to
  eval
  was the security breach.
  
 Fortunately, Ruby provides support for reducing this risk. All information from the 
 outside world can be marked as
  tainted
 . When running in a safe mode, potentially 
 dangerous methods will raise a
  SecurityError
  if passed a tainted object.
  
 Prepared exclusively for Yeganefar 
 379",NA
Safe Levels,"The variable
  $SAFE
  determines Ruby’s level of paranoia. Table
  25.1
  on page
  383
  gives 
 more details of the checks performed at each safe level.
  
 $SAFE
  
 Constraints
  
 0
  
 No checking of the use of externally supplied (tainted) data is performed.
  
 This is Ruby’s default mode.
  
 ≥
  1
  
 ≥
  2
  
 ≥
  3
  
 ≥
  4
  
 Ruby disallows the use of tainted data by potentially dangerous operations. 
 Ruby prohibits the loading of program files from globally writable 
 locations. All newly created objects are considered tainted.
  
 Ruby effectively partitions the running program in two. Nontainted objects 
 may not be modified.
  
 The default value of
  $SAFE
  is zero under most circumstances. However, if a Ruby 
 script is run
  setuid
  or
  setgid
 ,
 1
 or if it run under
  mod_ruby
 , its safe level is automatically 
 set to 1. The safe level may also be set by using the
  -T
  command-line option and by 
 assigning to
  $SAFE
  within the program. It is not possible to lower the value of
  $SAFE 
 by assignment.
  
 The current value of
  $SAFE
  is inherited when new threads are created. However, 
 within each thread, the value of
  $SAFE
  may be changed without affecting the value in 
 other threads. This facility may be used to implement secure “sandboxes,” areas 
 where exter-nal code may run safely without risk to the rest of your application or 
 system. Do this by wrapping code that you load from a file in its own, anonymous 
 module. This will protect your program’s namespace from any unintended alteration.
  
 f=open(filename,""w"") 
  
 f.print ... 
  
 # write untrusted program into file.
  
 f.close 
  
 Thread.start do 
  
 $SAFE = 4 
  
 load(filename, true) 
  
 end
  
 With a
  $SAFE
  level of 4, you can load
  only
  wrapped files. See the description of 
 Kernel.load
  on page
  503
  for details.
  
 This concept is used by Clemens Wyss on Ruby CHannel (
 http://www.ruby.ch
 ). On this 
 site, you can run the code from the first edition of this book. You can also type
  
 1.
  
 A Unix script may be flagged to be run under a different user or group ID than the person running it.
  
 This allows the script to have privileges that the user does not have; the script can access resources that the 
 user would otherwise be prohibited from using. These scripts are called
  setuid
  or
  setgid
 .
  
 Prepared exclusively for Yeganefar",NA
Tainted Objects,"Any Ruby object derived from some external source (for example, a string read from 
 a file or an environment variable) is automatically marked as being tainted. If your 
 program uses a tainted object to derive a new object, then that new object will also be 
 tainted, as shown in the code below. Any object with external data somewhere in its 
 past will be tainted. This tainting process is performed regardless of the current safe 
 level. You can see if an object is tainted using
  Object
 #
 tainted?
 .
  
 # internal data
  
 →
  
 false
  
 # external data
  
 →
  
 true
  
 # =============
  
 # =============
  
 x1 = ""a string""
  
 y1 = ENV[""HOME""]
  
 x1.tainted?
  
 y1.tainted?
  
 x2 = x1[2, 4]
  
 false
  
 y2 = y1[2, 4]
  
 true
  
 →
  
 →
  
 x2.tainted?
  
 y2.tainted?
  
 x1 =~ /([a-z])/
  
 →
  
 0
  
 y1 =~ /([a-z])/
  
 →
  
 2
  
 $1.tainted?
  
 →
  
 false
  
 $1.tainted?
  
 →
  
 true
  
 You can force any object to become tainted by invoking its
  taint
  method. If the safe 
 level is less than 3, you can remove the taint from an object by invoking
  untaint
 .
 2 
 This 
 is not something to do lightly.
  
 Clearly, Walter should have run his CGI script at a safe level of 1. This would have 
 raised an exception when the program tried to pass form data to
  eval
 . Once this had 
 happened, Walter would have had a number of choices. He could have chosen to 
 imple-ment a proper expression parser, bypassing the risks inherent in using
  eval
 . 
 However, being lazy, it’s more likely he’d have performed some simple sanity check 
 on the form data and untaint it if it looked innocuous.
  
 2.
  
 You can also use some devious tricks to do this without using
  untaint
 . We’ll leave it up to your darker
  
 side to find them.
  
 Prepared exclusively for Yeganefar",NA
Chapter 26,NA,NA
"Reflection,",NA,NA
"ObjectSpace, and",NA,NA
Distributed Ruby,"One of the many advantages of dynamic languages such as Ruby is the ability to 
 introspect
 —to examine aspects of the program from within the program itself. Java, 
 for one, calls this feature
  reflection
  but Ruby’s capabilities go beyond Java’s.
  
 The word
  reflection
  conjures up an image of looking at oneself in the mirror—
 perhaps investigating the relentless spread of that bald spot on the top of one’s head. 
 That’s a pretty apt analogy: we use reflection to examine parts of our programs that 
 aren’t normally visible from where we stand.
  
 In this deeply introspective mood, while we are contemplating our navels and burning 
 incense (being careful not to swap the two tasks), what can we learn about our 
 program?
  
 We might discover
  
 • what objects it contains,
  
 • the class hierarchy,
  
 • the attributes and methods of objects, and
  
 • information on methods.
  
 Armed with this information, we can look at particular objects and decide which of 
 their methods to call at runtime—even if the class of the object didn’t exist when we 
 first wrote the code. We can also start doing clever things, perhaps modifying the 
 program as it’s running.
  
 Sound scary? It needn’t be. In fact, these reflection capabilities let us do some very 
 useful things. Later in this chapter we’ll look at distributed Ruby and marshaling, two 
 reflection-based technologies that let us send objects around the world and through 
 time.",NA
Looking at Objects,"Have you ever craved the ability to traverse
  all
  the living objects in your program? 
 We have! Ruby lets you perform this trick with
  ObjectSpace.each_object
 . We can use it 
 to do all sorts of neat tricks.
  
 For example, to iterate over all objects of type
  Numeric
 , you’d write the following.
  
 a = 102.7 
  
 b = 95.1 
  
 ObjectSpace.each_object(Numeric) {|x| p x }
  
 produces:
  
 95.1 
  
 102.7 
  
 2.71828182845905 
  
 3.14159265358979 
  
 2.22044604925031e-16 
  
 1.79769313486232e+308 
  
 2.2250738585072e-308
  
 Hey, where did all those extra numbers come from? We didn’t define them in our 
 program. If you look on pages
  466
  and
  519
 , you’ll see that the
  Float
  class defines 
 constants for the maximum and minimum float, as well as epsilon, the smallest distin-
 guishable difference between two floats. The
  Math
  module defines constants for
  e
  
 and
 π
 . Since we are examining
  all
  living objects in the system, these turn up as well.
  
 Let’s try the same example with different numbers.
  
 a = 102 
  
 b = 95 
  
 ObjectSpace.each_object(Numeric) {|x| p x }
  
 produces:
  
 2.71828182845905 
  
 3.14159265358979 
  
 2.22044604925031e-16 
  
 1.79769313486232e+308 
  
 2.2250738585072e-308
  
 Neither of the
  Fixnum
  objects we created showed up. That’s because
  ObjectSpace 
 doesn’t know about objects with immediate values:
  Fixnum
 ,
  Symbol
 ,
  true
 ,
  false
 , and
  nil
 .",NA
Looking Inside Objects,"Once you’ve found an interesting object, you may be tempted to find out just what it 
 can do. Unlike static languages, where a variable’s type determines its class, and 
 hence the methods it supports, Ruby supports liberated objects. You really cannot tell 
 exactly
  
 Prepared exclusively for Yeganefar",NA
Looking at Classes,"Knowing about objects is one part of reflection, but to get the whole picture, you also 
 need to be able to look at classes—the methods and constants that they contain.
  
 Looking at the class hierarchy is easy. You can get the parent of any particular class 
 using
  
 Class
 #
 superclass
 . For classes
  and
  modules,
  
 Module
 #
 ancestors
  lists both 
 superclasses and mixed-in modules.
  
 klass = Fixnum 
  
 begin 
  
 print klass 
  
 klass = klass.superclass 
  
 print "" < "" if klass 
  
 end while klass 
  
 puts 
  
 p Fixnum.ancestors
  
 produces:
  
 Fixnum < Integer < Numeric < Object 
  
 [Fixnum, Integer, Precision, Numeric, Comparable, Object, Kernel]
  
 1.
  
 Or under its bonnet, for objects created to the east of the Atlantic.
  
  
 Prepared exclusively for Yeganefar",NA
Looking Inside Classes,"We can find out a bit more about the methods and constants in a particular object. 
 Instead of just checking to see whether the object responds to a given message, we can
  
 1.8
  
  
 ask for methods by access level, and we can ask for just singleton methods. We can 
 also have a look at the object’s constants, local, and instance variables.
  
 class Demo 
  
 @@var = 99 
  
 CONST = 1.23
  
 private 
  
 def private_method 
  
 end 
  
 protected 
  
 def protected_method 
  
 end 
  
 public 
  
 def public_method 
  
   
 @inst = 1 
  
   
 i = 1 
  
   
 j = 2 
  
   
 local_variables 
  
 end
  
 def Demo.class_method 
  
 end 
  
 end
  
 Demo.private_instance_methods(false)
  
 →
  
 [""private_method""]
  
 Demo.protected_instance_methods(false)
  
 [""protected_method""]
  
 →
  
 Demo.public_instance_methods(false)
  
 →
  
 [""public_method""]
  
 Demo.singleton_methods(false)
  
 [""class_method""]
  
 →
  
 Demo.class_variables
  
 →
  
 [""@@var""]
  
 Demo.constants - Demo.superclass.constants
  
 [""CONST""]
  
 →
  
 demo = Demo.new
  
 demo.instance_variables
  
 →
  
 []
  
 # Get 'public_method' to return its local variables 
  
 # and set an instance variable
  
 demo.public_method
  
 →
  
 [""i"", ""j""]
  
 demo.instance_variables
  
 →
  
 [""@inst""]
  
  
 Prepared exclusively for Yeganefar",NA
Calling Methods Dynamically,"C and Java programmers often find themselves writing some kind of dispatch table: 
 functions that are invoked based on a command. Think of a typical C idiom where 
 you have to translate a string to a function pointer.
  
 typedef struct { 
  
 char *name; 
  
 void (*fptr)(); 
  
 } Tuple;
  
 Tuple list[]= { 
  
 { ""play"", 
  
 fptr_play }, 
  
 { ""stop"", 
  
 fptr_stop }, 
  
 { ""record"", fptr_record }, 
  
 { 0, 0 }, 
  
 };
  
 ...
  
 void dispatch(char *cmd) { 
  
 int i = 0; 
  
 for (; list[i].name; i++) { 
  
  
 if (strncmp(list[i].name,cmd,strlen(cmd)) == 0) { 
  
    
 list[i].fptr(); 
  
    
 return; 
  
  
 } 
  
 } 
  
 /* not found */ 
  
 }
  
 In Ruby, you can do all this in one line. Stick all your command functions into a 
 class, create an instance of that class (we called it
  commands
 ), and ask that object to 
 execute a method called the same name as the command string.
  
 commands.send(command_string)
  
 Oh, and by the way, it does much more than the C version—it’s dynamic. The Ruby 
 version will find new methods added at runtime just as easily.
  
 Prepared exclusively for Yeganefar",NA
Performance Considerations,"As we’ve seen in this section, Ruby gives us several ways to invoke an arbitrary 
 method of some object:
  Object
 #
 send
 ,
  Method
 #
 call
 , and the various flavors of
  eval
 .
  
 You may prefer to use any one of these techniques depending on your needs, but be 
 aware that
  eval
  is significantly slower than the others (or, for optimistic readers,
  send 
 and
  call
  are significantly faster than
  eval
 ).
  
 require 'benchmark' 
  
 include Benchmark
  
 test = ""Stormy Weather"" 
  
 m = test.method(:length) 
  
 n = 100000
  
 bm(12) {|x| 
  
 x.report(""call"") { n.times { m.call } } 
  
 x.report(""send"") { n.times { test.send(:length) } } 
  
 x.report(""eval"") { n.times { eval ""test.length"" } } 
  
 }
  
 produces:
  
 call
  
 user
  
 system
  
 total
  
 real
  
 0.250000
  
 0.000000
  
 0.250000 (
  
 0.340967)
  
 send
  
 0.210000
  
 0.000000
  
 0.210000 (
  
 0.254237)
  
 eval
  
 1.410000
  
 0.000000
  
 1.410000 (
  
 1.656809)
  
  
 Prepared exclusively for Yeganefar",NA
System Hooks,"A
  hook
  is a technique that lets you trap some Ruby event, such as object creation. The 
 simplest hook technique in Ruby is to intercept calls to methods in system classes. 
 Perhaps you want to log all the operating system commands your program executes. 
 Simply rename the method
  Kernel.system
  and substitute it with one of your own that 
 both logs the command and calls the original
  Kernel
  method.
  
 module Kernel 
  
 alias_method :old_system, :system 
  
 def system(*args) 
  
  
 result = old_system(*args) 
  
  
 puts ""system(#{args.join(', ')}) returned #{result}"" 
  
  
 result 
  
 end 
  
 end
  
 system(""date"") 
  
 system(""kangaroo"", ""-hop 10"", ""skippy"")
  
 produces:
  
 Thu Aug 26 22:37:22 CDT 2004 
  
 system(date) returned true 
  
 system(kangaroo, -hop 10, skippy) returned false
  
 A more powerful hook is catching objects as they are created. If you can be present 
 when every object is born, you can do all sorts of interesting things: you can wrap 
 them, add methods to them, remove methods from them, add them to containers to 
 implement persistence, you name it. We’ll show a simple example here: we’ll add a 
 time stamp to every object as it’s created. First, we’ll add a
  timestamp
  attribute to 
 every object in the system. We can do this by hacking class
  Object
  itself.
  
 class Object 
  
 attr_accessor :timestamp 
  
 end
  
 Then we need to hook object creation to add this time stamp. One way to do this is to 
 do our method renaming trick on
  Class
 #
 new
 , the method that’s called to allocate space 
 for a new object. The technique isn’t perfect—some built-in objects, such as literal 
 strings, are constructed without calling
  new
 —but it’ll work just fine for objects we 
 write.
  
 class Class 
  
 alias_method :old_new, 
  
 :new 
  
 def new(*args) 
  
  
 result = old_new(*args) 
  
  
 result.timestamp = Time.now 
  
  
 result 
  
 end 
  
 end",NA
Runtime Callbacks,"You can be notified whenever one of the following events occurs.
  
  
 Event
  
 Callback Method
  
 1.8
  
  
 1.8
  
  
 Adding an instance method
  
 Module
 #
 method_added
  
 Removing an instance method
  
 Module
 #
 method_removed
  
 Undefining an instance method
  
 Module
 #
 method_undefined
  
 1.8
  
  
 1.8
  
  
 Adding a singleton method
  
 Kernel.singleton_method_added
  
 Removing a singleton method
  
 Kernel.singleton_method_removed
  
 Undefining a singleton method
  
 Kernel.singleton_method_undefineded
  
 Subclassing a class
  
 Class
 #
 inherited
  
 Mixing in a module
  
 Module
 #
 extend_object
  
 By default, these methods do nothing. If you define the callback method in your 
 class, it’ll be invoked automatically. The actual call sequences are illustrated in the 
 library descriptions for each callback method.
  
 Keeping track of method creation and class and module usage lets you build an 
 accurate picture of the dynamic state of your program. This can be important. For 
 example, you may have written code that wraps all the methods in a class, perhaps to 
 add transactional support or to implement some form of delegation. This is only half 
 the job: the dynamic nature of Ruby means that users of this class could add new 
 methods to it at any time. Using these callbacks, you can write code that wraps these 
 new methods as they are created.
  
 Prepared exclusively for Yeganefar",NA
Tracing Your Program’s Execution,"While we’re having fun reflecting on all the objects and classes in our programs, let’s 
 not forget about the humble statements that make our code actually do things. It turns 
 out that Ruby lets us look at these statements, too.
  
 First, you can watch the interpreter as it executes code.
  set_trace_func
  executes a 
 Proc
  
 with all sorts of juicy debugging information whenever a new source line is exe-
 cuted, methods are called, objects are created, and so on. You’ll find a full description 
 on page
  508
 , but here’s a taste.
  
 class Test 
  
 def test 
  
  
 a = 1 
  
  
 b = 2 
  
 end 
  
 end
  
 set_trace_func proc {|event, file, line, id, binding, classname| printf ""%8s %s:%-2d %10s 
 %8s\n"", event, file, line, id, classname } 
  
 t = Test.new 
  
 t.test
  
 produces:
  
  
 line prog.rb:11 
  
   
 false 
  
 c-call prog.rb:11 
  
  
 new 
  
 Class 
  
 c-call prog.rb:11 initialize Object 
  
 c-return prog.rb:11 initialize 
  
 Object c-return prog.rb:11 
  
  
 new 
  
 Class 
  
  
 line prog.rb:12 
  
   
 false 
  
  
 call prog.rb:2 
  
 test 
  
    
 Test 
  
 line 
 prog.rb:3 
  
 test 
  
   
 Test 
  
  
 line prog.rb:4 
  
 test 
  
   
 Test 
  
 return prog.rb:4 
  
 test 
  
   
 Test
  
 The method
  trace_var
  (described on page
  511
 ) lets you add a hook to a global vari-able; 
 whenever an assignment is made to the global, your
  Proc
  object is invoked.",NA
How Did We Get Here?,"A fair question, and one we ask ourselves regularly. Mental lapses aside, in Ruby at 
 least you can find out exactly “how you got there” by using the method
  caller
 , which 
 returns an
  Array
  of
  String
  objects representing the current call stack.
  
 def cat_a 
  
 puts caller.join(""\n"") 
  
 end 
  
 def cat_b 
  
 cat_a 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Source Code,"Ruby executes programs from plain old files. You can look these files to examine the 
 source code that makes up your program using one of a number of techniques.
  
 The special variable
  __FILE__
  contains the name of the current source file. This leads to a 
 fairly short (if cheating) Quine—a program that outputs its own source code.
  
 print File.read(__FILE__)
  
 The method
  Kernel.caller
  returns the call stack—the list of stack frames in existence at 
 the time the method was called. Each entry in this list starts off with a filename, a 
 colon, and a line number in that file. You can parse this information to display source. 
 In the following example, we have a main program,
  main.rb
 , that calls a method in a 
 separate file,
  sub.rb
 . That method in turns invokes a block, where we traverse the call 
 stack and write out the source lines involved. Notice the use of a hash of file contents, 
 indexed by the filename.
  
 Here’s the code that dumps out the call stack, including source information.
  
 def dump_call_stack 
  
 file_contents = {}
  
 puts ""File
  
 Line
  
 Source Line""
  
 puts ""-------------------------+----+------------"" 
  
 caller.each do |position| 
  
  
 next unless position =~ /\A(.*?):(\d+)/ 
  
  
 file = $1 
  
  
 line = Integer($2) 
  
  
 file_contents[file] ||= File.readlines(file) 
  
  
 printf(""%-25s:%3d - %s"", file, line, 
  
   
 file_contents[file][line-1].lstrip) 
  
 end 
  
 end
  
 The (trivial) file
  sub.rb
  contains a single method.
  
 def sub_method(v1, v2) 
  
 main_method(v1*3, v2*6) 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Marshaling and Distributed Ruby,"Java features the ability to
  serialize
  objects, letting you store them somewhere and 
 reconstitute them when needed. You can use this facility, for instance, to save a tree 
 of objects that represent some portion of application state—a document, a CAD 
 drawing, a piece of music, and so on.
  
 Ruby calls this kind of serialization
  marshaling
  (think of railroad marshaling yards 
 where individual cars are assembled in sequence into a complete train, which is then 
 dispatched somewhere). Saving an object and some or all of its components is done 
 using the method
  Marshal.dump
 . Typically, you will dump an entire object tree starting 
 with some given object. Later, you can reconstitute the object using
  Marshal.load
 .
  
 Here’s a short example. We have a class
  Chord
  that holds a collection of musical 
 notes. We’d like to save away a particularly wonderful chord so we can e-mail it to a 
 couple of hundred of our closest friends. They can then load it into their copy of 
 Ruby and savor it too. Let’s start with the classes for
  Note
  and
  Chord
 .
  
 Note = Struct.new(:value) 
  
 class Note 
  
 def to_s 
  
  
 value.to_s 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
Custom Serialization Strategy,"Not all objects can be dumped: bindings, procedure objects, instances of class
  IO
 , and 
 singleton objects cannot be saved outside the running Ruby environment (a
  TypeError 
 will be raised if you try). Even if your object doesn’t contain one of these problematic 
 objects, you may want to take control of object serialization yourself.
  
 1.8
  
  
 Marshal
  provides the hooks you need. In the objects that require custom serialization, 
 simply implement two instance methods: one called
  marshal_dump 
 , which writes the
  
 object out to a string, and one called
  marshal_load
 , which reads a string that you’d 
 previously created and uses it to initialize a newly allocated object. (In earlier Ruby 
 versions you’d use methods called
  _dump
  and
  _load
 , but the new versions play better 
 with Ruby 1.8’s new allocation scheme.) The instance method
  marshal_dump
  should 
 return an object representing the state to be dumped. When the object is subsequently 
 reconstituted using
  Marshal.load
 , the method
  marshal_load
  will be called with this 
 object and will use it to set the state of its receiver—it will be run in the context of an 
 allocated but not initialized object of the class being loaded.
  
 For instance, here is a sample class that defines its own serialization. For whatever 
 reasons,
  Special
  doesn’t want to save one of its internal data members,
  @volatile
 .
  
 The author has decided to serialize the two other instance variables in an array.
  
 Prepared exclusively for Yeganefar",NA
YAML for Marshaling,"The
  Marshal
  module is built into the interpreter and uses a binary format to store 
 objects externally. While fast, this binary format has one major disadvantage: if the 
 interpreter changes significantly, the marshal binary format may also change, and old 
 dumped files may no longer be loadable.
  
 An alternative is to use a less fussy external format, preferably one using text rather 
 than binary files. One option, supplied as a standard library as of Ruby 1.8, is YAML.
 2
  
 We can adapt our previous marshal example to use YAML. Rather than implement 
 spe-cific loading and dumping methods to control the marshal process, we simply 
 define the method
  to_yaml_properties
 , which returns a list of instance variables to be 
 saved.
  
 2.
  
 http://www.yaml.org
 . YAML stands for YAML Ain’t Markup Language, but that hardly seems
  
 important.",NA
Distributed Ruby,"Since we can serialize an object or a set of objects into a form suitable for out-of-
 process storage, we can use this capability for the
  transmission
  of objects from one 
 process to another. Couple this capability with the power of networking, and
  voilà
 : 
 you
  
 1.8
  
  
 have a distributed object system. To save you the trouble of having to write the code, we
  
 suggest using Masatoshi Seki’s Distributed Ruby library (drb), which is now
  
 available
  
 as a standard Ruby library.
  
 Using drb, a Ruby process may act as a server, as a client, or as both. A drb server 
 acts as a source of objects, while a client is a user of those objects. To the client, it 
 appears that the objects are local, but in reality the code is still being executed 
 remotely.",NA
Compile Time? Runtime? Anytime!,"The important thing to remember about Ruby is that there isn’t a big difference 
 between“compile time” and “runtime.” It’s all the same. You can add code to a 
 running process. You can redefine methods on the fly, change their scope from
  public
  
 to
  private
 , and so on. You can even alter basic types, such as
  Class
  and
  Object
 .
  
 Once you get used to this flexibility, it is hard to go back to a static language such as 
 C++ or even to a half-static language such as Java.
  
 But then, why would you want to do that?
  
 Prepared exclusively for Yeganefar",NA
Part IV,NA,NA
Ruby Library Reference,"Prepared exclusively for Yeganefar
  
 401",NA
Chapter 27,NA,NA
Built-in Classes and Modules,"This chapter documents the classes and modules built into the standard Ruby 
 language. They are available to every Ruby program automatically; no
  require
  is 
 required. This section does not contain the various predefined variables and 
 constants; these are listed starting on page
  318
 .
  
 In the descriptions starting on page
  406
 , we show sample invocations for each method.
  
 new
  
 String.new(
  some_string
  )
  →
  new_string
  
 This description shows a class method that is called as
  String.new
 . The italic parame-
 ter indicates that a single string is passed in, and the arrow indicates that another 
 string is returned from the method. Because this return value has a different name 
 than that of the parameter, it represents a different object.
  
 When we illustrate instance methods, we show a sample call with a dummy object 
 name in italics as the receiver.
  
 each
  
 str
 .each(
  sep
 =
 $/
  ) {
 | record | block
  }
  →
  str
  
 The parameter to
  String
 #
 each
  is shown to have a default value; call
  each
  with no 
 parameter, and the value of
  $/
  will be used. This method is an iterator, so the call is 
 followed by a block.
  String
 #
 each
  returns its receiver, so the receiver’s name (
 str
  in this 
 case) appears again after the arrow.
  
 Some methods have optional parameters. We show these parameters between angle 
 brackets,
  ⟨
  xxx
  ⟩
 . (Additionally, we use the notation
  ⟨
  xxx
  ⟩
 ∗
 to indicate zero or more 
 occurrences of
  xxx
  and use
  ⟨
  xxx
  ⟩
 +
 to indicate one or more occurrences of
  xxx
 .)
  
 index
  
 self
 .index(
  str
  ⟨
  ,
  offset
  ⟩
  )
  →
  pos
  or
  nil
  
 Finally, for methods that can be called in several different forms, we list each form on a 
 separate line.
  
 Prepared exclusively for Yeganefar 
 402",NA
Alphabetical Listing,"Standard classes are listed alphabetically, followed by the standard modules. Within 
 each, we list the class (or module) methods, followed by its instance methods.
  
 Summary of Built-in Classes
  
 Array
  (page
  406
 ):
  Class:
  [ ], new.
  Instance:
  &, *, +, –, <<, <=>, ==, [ ], [ ]=, |, assoc, at, clear, 
 collect!, compact, compact!, concat, delete, delete_at, delete_if, each, each_index, empty?, eql?, 
 fetch, fill, first, flatten, flatten!, include?, index, indexes, indices, insert, join, last, length, map!, 
 nitems, pack, pop, push, rassoc, reject!, replace, reverse, reverse!, reverse_each, rindex, shift, 
 size, slice, slice!, sort, sort!, to_a, to_ary, to_s, transpose, uniq, uniq!, unshift, values_at.
  
 Bignum
  (page
  420
 ):
  Instance:
  Arithmetic operations, Bit operations, <=>, ==, [ ], abs, div, 
 divmod, eql?, modulo, quo, remainder, size, to_f, to_s.
  
 Binding
  (page
  423
 )
  
 Class
  (page
  424
 ):
  Class:
  inherited, new.
  Instance:
  allocate, new, superclass.
  
 Continuation
  (page
  427
 ):
  Instance:
  call.
  
 Dir
  (page
  428
 ):
  Class:
  [ ], chdir, chroot, delete, entries, foreach, getwd, glob, mkdir, new, open, 
 pwd, rmdir, unlink.
  Instance:
  close, each, path, pos, pos=, read, rewind, seek, tell.
  
 Exception
  (page
  440
 ):
  Class:
  exception, new.
  Instance:
  backtrace, exception, message, 
 set_backtrace, status, success?, to_s, to_str.
  
 FalseClass
  (page
  443
 ):
  Instance:
  &, ^, |.
  
 File
  (page
  444
 ):
  Class:
  atime, basename, blockdev?, chardev?, chmod, chown, ctime, delete, 
 directory?, dirname, executable?, executable_real?, exist?, exists?, expand_path, extname, file?, 
 fnmatch, fnmatch?, ftype, grpowned?, join, lchmod, lchown, link, lstat, mtime, new, open, 
 owned?, pipe?, readable?, readable_real?, readlink, rename, setgid?, setuid?, size, size?, 
 socket?, split, stat, sticky?, symlink, symlink?, truncate, umask, unlink, utime, writable?, 
 writable_real?, zero?.
  
 Instance:
  atime, chmod, chown, ctime, flock, lchmod, lchown, lstat, mtime, path, truncate.
  
 File::Stat
  (page
  456
 ):
  Instance:
  <=>, atime, blksize, blockdev?, blocks, chardev?, ctime, dev, 
 dev_major, dev_minor, directory?, executable?, executable_real?, file?, ftype, gid, grpowned?, ino, 
 mode, mtime, nlink, owned?, pipe?, rdev, rdev_major, rdev_minor, readable?, readable_real?, 
 setgid?, setuid?, size, size?, socket?, sticky?, symlink?, uid, writable?, writable_real?, zero?.
  
 Fixnum
  (page
  463
 ):
  Class:
  .
  Instance:
  Arithmetic operations, Bit operations, <=>, [ ], abs, div, 
 divmod, id2name, modulo, quo, size, to_f, to_s, to_sym, zero?.
  
 Float
  (page
  466
 ):
  Instance:
  Arithmetic operations, <=>, ==, abs, ceil, divmod, eql?, finite?, floor, 
 infinite?, modulo, nan?, round, to_f, to_i, to_int, to_s, truncate, zero?.
  
 Hash
  (page
  471
 ):
  Class:
  [ ], new.
  Instance:
  ==, [ ], [ ]=, clear, default, default=, default_proc, 
 delete, delete_if, each, each_key, each_pair, each_value, empty?, fetch, has_key?, 
 has_value?, include?, index, indexes, indices, invert, key?, keys, length, member?, merge, 
 merge!, rehash, reject, reject!, replace, select, shift, size, sort, store, to_a, to_hash, to_s, 
 update, value?, values, values_at.
  
 Integer
  (page
  480
 ):
  Instance:
  ceil, chr, downto, floor, integer?, next, round, succ, times, to_i, 
 to_int, truncate, upto.",NA
Array,"<
  
 Object
  
  rra
  
  
 Arrays are ordered, integer-indexed collections of any object. Array indexing starts at",NA
A,"0
 , as in C or Java. A negative index is assumed to be relative to the end of the array; 
 that is, an index of
  −1
  indicates the last element of the array,
  −2
  is the next to last 
 element in the array, and so on.
  
 Mixes in
  
 Enumerable
 :
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Class methods
  
 [ ]
  
 Array[
  ⟨
  obj
  ⟩
 ∗
 ]
  →
  an_array
  
 Returns a new array populated with the given objects. Equivalent to the operator form
  
 Array.[](
 ...
  )
 .
  
  
 Array.[]( 1, 'a', /^A/ )
  
 →
  
 [1, ""a"", /^A/]
  
 Array[ 1, 'a', /^A/ ]
  
 →
  
 [1, ""a"", /^A/]
  
 [ 1, 'a', /^A/ ]
  
 →
  
 [1, ""a"", /^A/]
  
 new
  
 Array.new
  →
  an_array 
  
 Array.new (
  size=0
 ,
  obj=
 nil
  )
  →
  an_array 
  
 Array.new(
  array
  )
  →
  an_array 
  
 Array.new(
  size
  ) {
 | i | block
  }
  →
  an_array
  
 Returns a new array. In the first form, the new array is empty. In the second it is 
 created
  
 1.8
  
  
 1.8
  
  
 with
  size
  copies of
  obj
  (that is,
  size
  references to the same
  obj
 ). The third form
  
 creates
  
 a copy of the array passed as a parameter (the array is generated by calling
  to_ary
  on
  
 the parameter). In the last form,
  
 an array of the given size is created. Each element in
  
 this array is calculated by passing the element’s index to the given block and storing
  
 the return value.
  
 Array.new
  
 →
  
 []
  
 Array.new(2)
  
 [nil, nil]
  
 →
  
 Array.new(5, ""A"")
  
 →
  
 [""A"", ""A"", ""A"", ""A"", ""A""]
  
 # only one instance of the default object is created
  
 a = Array.new(2, Hash.new)
  
 a[0]['cat'] = 'feline'
  
 a
  
 →
  
 [{""cat""=>""feline""}, {""cat""=>""feline""}]
  
 a[1]['cat'] = 'Felix'
  
 a
  
 →
  
 [{""cat""=>""Felix""}, {""cat""=>""Felix""}]
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 a[0]['cat'] = 'feline'
  
 a
  
 →
  
 [{""cat""=>""feline""}, {}]
  
 squares = Array.new(5) {|i| i*i} 
  
 squares
  
 →
 [0, 1, 4, 9, 16]
  
 copy = Array.new(squares) 
  
 # initialized by copying
  
 squares[5] = 25
  
 squares
  
 →
  
 [0, 1, 4, 9, 16, 25]
  
 copy
  
 →
  
 [0, 1, 4, 9, 16]
  
 Instance methods
  
 &
  
 arr
  &
  other_array
  →
  an_array 
 Set Intersection—Returns a new array containing elements common to the two 
 arrays,
  
 with no duplicates. The rules for comparing elements are the same as for hash keys. If
  
 you need setlike behavior, see the library class
  Set
  on page
  710
 .
  
  
 [ 1, 1, 3, 5 ] & [ 1, 2, 3 ]
  
 →
  
 [1, 3]
  
 *
  
 arr
  *
  int
  →
  an_array 
  
 arr
  *
  str
  →
  a_string
  
 Repetition—With an argument that responds to
  to_str
 , equivalent to
  arr
 .join(
 str
 )
 .
  
 Otherwise, returns a new array built by concatenating
  int
  copies of
  arr
 .
  
  
 [ 1, 2, 3 ] * 3
  
 →
  
 [1, 2, 3, 1, 2, 3, 1, 2, 3]
  
 [ 1, 2, 3 ] * ""--""
  
 →
  
 ""1--2--3""
  
 +
  
 arr
  +
  other_array
  →
  an_array 
 Concatenation—Returns a new array built by concatenating the two arrays together 
 to
  
 produce a third array.
  
  
 [ 1, 2, 3 ] + [ 4, 5 ]
  
 →
  
 [1, 2, 3, 4, 5]
  
 –
  
 arr
  -
  other_array
  →
  an_array 
 Array Difference—Returns a new array that is a copy of the original array, removing
  
 any items that also appear in
  other_array
 . If you need setlike behavior, see the library
  
 class
  Set
  on page
  710
 .
  
  
 [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]
  
 →
  
 [3, 3, 5]
  
 <<
  
 arr
  <<
  obj
  →
  arr 
 Append—Pushes the given object on to the end of this array. This expression returns
  
 the array itself, so several appends may be chained together. See also
  Array
 #
 push
 .
  
 [ 1, 2 ] << ""c"" << ""d"" << [ 3, 4 ]
  
 →
  
 [1, 2, ""c"", ""d"", [3, 4]]
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Comparison—Returns an integer
  −1
 ,
  0
 , or
  +1
  if this array is less than, equal to, or 
 greater than
  other_array
 . Each object in each array is compared (using
  <=>
 ). If any
  
 value isn’t equal, then that inequality is the return value. If all the values found are
  
 equal, then the return is based on a comparison of the array lengths. Thus, two arrays
  
 are “equal” according to
  Array
 #
 <=>
  if and only if they have the same length and the
  
 value of each element is equal to the value of the corresponding element in the other
  
 array.
  
  
 [ ""a"", ""a"", ""c"" ]
  
 <=> [ ""a"", ""b"", ""c"" ]
  
 →
  
 -1
  
 [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]
  
 →
  
 1
  
 ==
  
 arr
  ==
  obj
  →
  true
  or
  false 
 Equality—Two arrays are equal if they contain the same number of elements and if 
 each
  
 element is equal to (according to
  Object
 #
 ==
 ) the corresponding element in the other
  
 array. If
  obj
  is not an array, attempt to convert it using
  to_ary
  and return
  obj
 ==
 arr
 .
  
  
 [ ""a"", ""c"" ]
  
 == [ ""a"", ""c"", 7 ]
  
 →
  
 false
  
 [ ""a"", ""c"", 7 ] == [ ""a"", ""c"", 7 ]
  
 →
  
 true
  
 [ ""a"", ""c"", 7 ] == [ ""a"", ""d"", ""f"" ]
  
 →
  
 false
  
 [ ]
  
 arr
 [
 int
 ]
  →
  obj
  or
  nil 
  
 arr
 [
 start
 ,
  length
 ]
  →
  an_array
  or
  nil 
  
 arr
 [
 range
 ]
  →
  an_array
  or
  nil
  
 Element Reference—Returns the element at index
  int
 , returns a subarray starting at
  
 index
  start
  and continuing for
  length
  elements, or returns a subarray specified by
  range
 .
  
  
 1.8 
 Negative indices count backward from the end of the array (
 −1
  is the last element). Returns
  nil
  if the index of 
 the first element selected is greater than the array size. If
  
 the start index equals the array size and a
  length
  or
  range
  parameter is given, an empty
  
 array is returned. Equivalent to
  Array
 #
 slice
 .
  
 a = [ ""a"", ""b"", ""c"", ""d"", ""e"" ]
  
 a[2] +
  
 a[0] + a[1]
  
 →
  
 ""cab""
  
 a[6]
  
 →
  
 nil
  
 a[1, 2]
  
 [""b"", ""c""]
  
 →
  
 a[1..3]
  
 →
  
 [""b"", ""c"", ""d""]
  
 a[4..7]
  
 [""e""]
  
 →
  
 a[6..10]
  
 →
  
 nil
  
 a[-3, 3]
  
 [""c"", ""d"", ""e""]
  
 →
  
 # special cases
  
 a[5]
  
 →
  
 nil
  
 a[5, 1]
  
 →
  
 []
  
 a[5..10]
  
 []
  
 →",NA
A,"rray
  
 Element Assignment—Sets the element at index
  int
 , replaces a subarray starting at
  
 index
  start
  and continuing for
  length
  elements, or replaces a subarray specified by 
 range
 . If
  int
  is greater than the current capacity of the array, the array grows 
 automati-cally. A negative
  int
  will count backward from the end of the array. Inserts 
 elements if 
 length
  is zero. If
  obj
  is
  nil
 , deletes elements from
  arr
 . If
  obj
  is an array, the 
 form with the single index will insert that array into
  arr
 , and the forms with a length 
 or with a range will replace the given elements in
  arr
  with the array contents. An
  
 IndexError
  is raised if a negative index points past the beginning of the array. See also
  
 Array
 #
 push 
 and
  Array
 #
 unshift
 .
  
  
 a = Array.new
  
 →
  
 []
  
 a[4] = ""4"";
  
 a
  
 →
  
 [nil, nil, nil, nil, ""4""]
  
 a[0] = [ 1, 2, 3 ];
  
 a
  
 →
  
 [[1, 2, 3], nil, nil, nil, ""4""]
  
 a[0, 3] = [ 'a', 'b', 'c' ]; a
  
 →
  
 [""a"", ""b"", ""c"", nil, ""4""]
  
 a[1..2] = [ 1, 2 ];
  
 a
  
 →
  
 [""a"", 1, 2, nil, ""4""]
  
 a[0, 2] = ""?"";
  
 a
  
 →
  
 [""?"", 2, nil, ""4""]
  
 a[0..2] = ""A"";
  
 a
  
 →
  
 [""A"", ""4""]
  
 a[-1]
  
 = ""Z"";
  
 a
  
 →
  
 [""A"", ""Z""]
  
 a[1..-1] = nil;
  
 a
  
 →
  
 [""A""]
  
 |
  
 arr
  |
  other_array
  →
  an_array 
 Set Union—Returns a new array by joining this array with
  other_array
 , removing
  
 duplicates. The rules for comparing elements are the same as for hash keys. If you need 
 setlike behavior, see the library class
  Set
  on page
  710
 .
  
  
 [ ""a"", ""b"", ""c"" ] | [ ""c"", ""d"", ""a"" ]
  
 →
  
 [""a"", ""b"", ""c"", ""d""]
  
 assoc
  
 arr
 .assoc(
  obj
  )
  →
  an_array
  or
  nil 
 Searches through an array whose elements are also arrays comparing
  obj
  with the
  
 first element of each contained array using
  obj
 .==
  . Returns the first contained array 
 that matches (that is, the first
  assoc
 iated array) or
  nil
  if no match is found. See also 
 Array
 #
 rassoc
 .
  
 s1 = [ ""colors"", ""red"", ""blue"", ""green"" ] 
  
 s2 = [ ""letters"", ""a"", ""b"", ""c"" ] 
  
 s3 = ""foo""
  
  
 a
  
 = [ s1, s2, s3 ]
  
 a.assoc(""letters"")
  
 →
  
 [""letters"", ""a"", ""b"", ""c""]
  
 a.assoc(""foo"")
  
 →
  
 nil
  
 at
  
 arr
 .at(
  int
  )
  →
  obj
  or
  nil 
 Returns the element at index
  int
 . A negative index counts from the end of
  arr
 . 
 Returns
  
  
 Prepared exclusively for Yeganefar",NA
A,"a = [ ""a"", ""b"", ""c"", ""d"", ""e"" ]
  
  
 a.at(0)
  
 →
  
 ""a""
  
  
 a.at(-1)
  
 →
  
 ""e""
  
 clear
  
 Removes all elements from
  arr
 .
  
 arr
 .clear
  →
  arr
  
 a = [ ""a"", ""b"", ""c"", ""d"", ""e"" ]
  
  
 a.clear
  
 →
  
 []
  
 collect
 !
  
 arr
 .collect! {
 | obj| block
  }
  →
  arr 
 Invokes
  block
  once for each element of
  arr
 , replacing the element with the value
  
 returned by
  block
 . See also
  Enumerable
 #
 collect
 .
  
 a = [ ""a"", ""b"", ""c"", ""d"" ]
  
 a.collect! {|x| x + ""!"" }
  
 →
  
 [""a!"", ""b!"", ""c!"", ""d!""]
  
 a
  
 →
  
 [""a!"", ""b!"", ""c!"", ""d!""]
  
 compact
  
 Returns a copy of
  arr
  with all
  nil
  elements removed.
  
 [ ""a"", nil, ""b"", nil, ""c"", nil ].compact
  
 →",NA
A,"rray
  
 Deletes the element at the specified index, returning that element, or
  nil
  if the index is
  
 out of range. See also
  Array
 #
 slice!
 .
  
 a = %w( ant bat cat dog )
  
 a.delete_at(2)
  
 →
  
 ""cat""
  
 a
  
 →
  
 [""ant"", ""bat"", ""dog""]
  
 a.delete_at(99)
  
 →
  
 nil
  
 delete_if
  
 arr
 .delete_if {
 | item | block
  }
  →
  arr
  
 Deletes every element of
  arr
  for which
  block
  evaluates to
  true
 .
  
 a = [ ""a"", ""b"", ""c"" ]
  
  
 a.delete_if {|x| x >= ""b"" }
  
 →
  
 [""a""]
  
 each
  
  
 arr
 .each {
 | item | block
  }
  →
  arr 
 Calls
  block
  once for each element in
  arr
 , passing that element as a parameter.
  
 a = [ ""a"", ""b"", ""c"" ]
  
 a.each {|x| print x, "" -- "" }
  
 produces:
  
 a -- b -- c --
  
 each_index
  
 arr
 .each_index {
 | index | block
  }
  →
  arr
  
 Same as
  Array
 #
 each
  but passes the index of the element instead of the element itself.
  
 a = [ ""a"", ""b"", ""c"" ]
  
 a.each_index {|x| print x, "" -- "" }
  
 produces:
  
 0 -- 1 -- 2 --
  
 empty
 ?
  
  
 Returns
  true
  if
  arr
  array contains no elements.
  
 arr
 .empty?
  →
  true
  or
  false
  
  
  
 [].empty?
  
 →
  
 true
  
 [ 1, 2, 3 ].empty?
  
 →
  
 false
  
 eql?
  
 arr
 .eql?(
  other
  )
  →
  true
  or
  false 
 Returns
  true
  if
  arr
  and
  other
  are the same object or if
  other
  is an object of class
  Array
  
 with the same length and content as
  arr
 . Elements in the arrays are compared using
  
 Object
 #
 eql?
 . See also
  Array
 #
 <=>
 .
  
 [ ""a"", ""b"", ""c"" ].eql?([""a"", ""b"", ""c""])
  
 →
  
 true
  
 [ ""a"", ""b"", ""c"" ].eql?([""a"", ""b""])
  
 →
  
 false
  
 [ ""a"", ""b"", ""c"" ].eql?([""b"", ""c"", ""d""])
  
 →
  
 false
  
  
 Prepared exclusively for Yeganefar",NA
A,"Tries to return the element at position
  index
 . If the index lies outside the array, the 
 first
  
 form throws an
  IndexError
  exception, the second form returns
  default
 , and the third
  
 form returns the value of invoking the block, passing in the index. Negative values of
  
 index
  count from the end of the array.
  
 a = [ 11, 22, 33, 44 ]
  
  
 a.fetch(1)
  
 →
  
 22
  
 a.fetch(-1)
  
 →
  
 44
  
 a.fetch(-1, 'cat')
  
 →
  
 44
  
 a.fetch(4, 'cat')
  
 →
  
 ""cat""
  
 a.fetch(4) {|i| i*i }
  
 →
  
 16
  
 fill
  
 arr
 .fill(
  obj
  )
  →
  arr 
  
 arr
 .fill(
  obj
 ,
  start
  ⟨
  ,
  length
  ⟩
  )
  →
  arr 
  
 arr
 .fill(
  obj
 ,
  range
  )
  →
  arr 
  
 arr
 .fill {
 | i | block
  }
  →
  arr 
  
 arr
 .fill(
  start
  ⟨
  ,
  length
  ⟩
  ) {
 | i | block
  }
  →
  arr 
 arr
 .fill(
  range
  ) {
 | i | block
  }
  →
  arr
  
 The first three forms set the selected elements of
  arr
  (which may be the entire array) 
 to
  
 obj
 . A
  start
  of
  nil
  is equivalent to zero. A
  length
  of
  nil
  is equivalent to
  arr
 .
 length
 .
  
 1.8
  
  
 The last three forms
  
 fill the array with the value of the block. The block is passed the
  
 absolute index of each element to be filled.
  
 a = [ ""a"", ""b"", ""c"", ""d"" ]
  
  
 a.fill(""x"")
  
 →
  
 [""x"", ""x"", ""x"", ""x""]
  
 a.fill(""z"", 2, 2)
  
 →
  
 [""x"", ""x"", ""z"", ""z""]
  
 a.fill(""y"", 0..1)
  
 →
  
 [""y"", ""y"", ""z"", ""z""]
  
 a.fill {|i| i*i}
  
 →
  
 [0, 1, 4, 9]
  
 a.fill(-3) {|i| i+100}
  
 →
  
 [0, 101, 102, 103]
  
 first 
 1.8
  
  
 arr
 .first
  →
  obj
  or
  nil 
  
 arr
 .first(
  count
  )
  →
  an_array
  
 Returns the first element, or the first
  count
  elements, of
  arr
 . If the array is empty, the
  
 first form returns
  nil
 , and the second returns an empty array.
  
 a = [ ""q"", ""r"", ""s"", ""t"" ]
  
  
 a.first
  
 →
  
 ""q""
  
  
 a.first(1)
  
 →
  
 [""q""]
  
 a.first(3)
  
 →
  
 [""q"", ""r"", ""s""]
  
 flatten
  
 arr
 .flatten
  →
  an_array
  
 «
  
 Returns a new array that is a one-dimensional flattening of this array (recursively). 
 That
  
 is, for every element that is an array, extract its elements into the new array.
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 s = [ 1, 2, 3 ]
  
 →
  
 [1, 2, 3]
  
 t = [ 4, 5, 6, [7, 8] ]
  
 →
  
 [4, 5, 6, [7, 8]]
  
 a = [ s, t, 9, 10 ]
  
 →
  
 [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
  
  
 a.flatten
  
 →
  
 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  
 flatten!
  
 arr
 .flatten!
  →
  arr
  or
  nil 
 Same as
  Array
 #
 flatten
  but modifies the receiver in place. Returns
  nil
  if no modifi-
  
  
 cations were made (i.e.,
  arr
  contains no subarrays).
  
 a = [ 1, 2, [3, [4, 5] ] ]
  
 a.flatten!
  
 →
  
 [1, 2, 3, 4, 5]
  
 a.flatten!
  
 →
  
 nil
  
 a
  
 →
  
 [1, 2, 3, 4, 5]
  
 include?
  
 arr
 .include?(
  obj
  )
  →
  true
  or
  false
  
 Returns
  true
  if the given object is present in
  arr
  (that is, if any object
  ==
  obj
 ),
  false
  
 otherwise.
  
 a = [ ""a"", ""b"", ""c"" ]
  
  
 a.include?(""b"")
  
 →
  
 true
  
 a.include?(""z"")
  
 →
  
 false
  
 index
  
 arr
 .index(
  obj
  )
  →
  int
  or
  nil 
 Returns the index of the first object in
  arr
  that is
  ==
  to
  obj
 . Returns
  nil
  if no match is
  
 found.
  
 a = [ ""a"", ""b"", ""c"" ]
  
 a.index(""b"")
  
 →
  
 1
  
 a.index(""z"")
  
 →
  
 nil
  
 indexes
  
 arr
 .indexes(
  i1, i2, ... iN
  )
  →
  an_array
  
 1.8
  
  
 Deprecated; use
  Array
 #
 values_at
 .
  
 indices
  
 Deprecated; use
  Array
 #
 values_at
 .
  
 arr
 .indices(
  i1, i2, ... iN
  )
  →
  an_array
  
 1.8
  
  
 insert 
  
 1.8
  
  
 arr
 .insert(
  index
 ,
  ⟨
  obj
  ⟩
 +
 )
  →
  arr 
 If
  
 index
  is not negative, inserts the given values before the element with the given index.
  
 If
  index
  is
  −1
 , appends the values to
  arr
 . Otherwise inserts the values after the element 
 with the given index.
  
 a = %w{ a b c d }
  
 a.insert(2, 99)
  
 →
  
 [""a"", ""b"", 99, ""c"", ""d""]
  
 a.insert(-2, 1, 2, 3)
  
 [""a"", ""b"", 99, ""c"", 1, 2, 3, ""d""]
  
 →
  
 a.insert(-1, ""e"")
  
 →
  
 [""a"", ""b"", 99, ""c"", 1, 2, 3, ""d"", ""e""]
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Table 27.1. Template characters for
  Array#pack
  
  
 Directive
  
 Meaning
  
 1.8
  
  
 @
  
 Moves to absolute position
  
 A
  
 ASCII string (space padded, count is width)
  
 a
  
 ASCII string (null padded, count is width)
  
 B
  
 Bit string (descending bit order)
  
 b
  
 Bit string (ascending bit order)
  
 C
  
 Unsigned char
  
 c
  
 Char
  
 D, d
  
 Double-precision float, native format
  
 E
  
 Double-precision float, little-endian byte order
  
 e
  
 Single-precision float, little-endian byte order
  
 F, f
  
 Single-precision float, native format
  
 G
  
 Double-precision float, network (big-endian) byte order
  
 g
  
 Single-precision float, network (big-endian) byte order
  
 H
  
 Hex string (high nibble first)
  
 h
  
 Hex string (low nibble first)
  
 I
  
 Unsigned integer
  
 i
  
 Integer
  
 L
  
 Unsigned long
  
 l
  
 Long
  
 M
  
 Quoted printable, MIME encoding (see RFC2045)
  
 m
  
 Base64 encoded string
  
 N
  
 Long, network (big-endian) byte order
  
 n
  
 Short, network (big-endian) byte order
  
 P
  
 Pointer to a structure (fixed-length string)
  
 p
  
 Pointer to a null-terminated string
  
 Q, q
  
 64-bit number
  
 1.8
  
  
 S
  
 Unsigned short
  
 s
  
 Short
  
 U
  
 UTF-8
  
 u
  
 UU-encoded string
  
 V
  
 Long, little-endian byte order
  
 v
  
 Short, little-endian byte order
  
 w
  
 BER-compressed integer 
 1
  
 X
  
 Back up a byte
  
 x
  
 Null byte
  
 Z
  
 Same as A
  
 1
  The octets of a BER-compressed integer represent an unsigned integer in base 128, most significant digit 
 first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last (
 Self-
 Describing Binary Data Representation
 , MacLeod)
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Returns a string created by concatenating each element of the array to a string, 
 separat-
  
 ing each by
  separator
 .
  
  
 [ ""a"", ""b"", ""c"" ].join
  
 →
  
 ""abc""
  
 [ ""a"", ""b"", ""c"" ].join(""-"")
  
 →
  
 ""a-b-c""
  
 last 
  
 1.8
  
  
 arr
 .last
  →
  obj
  or
  nil 
  
 arr
 .last(
  count
  )
  →
  an_array
  
 Returns the last element, or last
  count
  elements, of
  arr
 . If the array is empty, the first
  
 form returns
  nil
 , the second an empty array.
  
 length
  
 [ ""w"", ""x"", ""y"", ""z"" ].last
  
 →
  
 ""z""
  
 arr
 .length
  →
  int
  
 [ ""w"", ""x"", ""y"", ""z"" ].last(1)
  
 [""z""]
  
 →
  
 [ ""w"", ""x"", ""y"", ""z"" ].last(3)
  
 →
  
 [""x"", ""y"", ""z""]
  
 Returns the number of elements in
  arr
 . See also
  Array
 #
 nitems
 .
  
  
 [ 1, nil, 3, nil, 5 ].length
  
 →
  
 5
  
 map!
  
 Synonym for
  Array
 #
 collect!
 .
  
 arr
 .map! {
 | obj| block
  }
  →
  arr
  
  
  
 nitems
   
 Returns the number of non-
 nil
  elements in
  arr
 . See also
  Array
 #
 length
 .
  
 arr
 .nitems
  →
  int 
  
 [ 1, nil, 3, nil, 5 ].nitems
  
 →
  
 3
  
 pack 
 1.8
  
  
 arr
 .pack (
  template
  )
  →
  binary_string 
 Packs the contents of
  arr
  into a binary sequence according to the directives in
  
 template
  
 (see Table
  27.1
  on the page before). Directives
  A
 ,
  a
 , and
  Z
  may be followed by a count,
  
 which gives the width of the resulting field. The remaining directives also may take a
  
 count, indicating the number of array elements to convert. If the count is an asterisk
  
 (
 *
 ), all remaining array elements will be converted. Any of the directives “
 sSiIlL
 ”may be 
 followed by an underscore (
 _
 ) to use the underlying platform’s native size for
  
 1.8
  
  
 the specified type; otherwise, they use a platform-independent size. Spaces are ignored
  
 in the template string. Comments
  
 starting with
  #
  to the next newline or end of string
  
 are also ignored. See also
  String
 #
 unpack
  on page
  602
 .
  
 a = [ ""a"", ""b"", ""c"" ]
  
 n = [ 65, 66, 67 ]
  
 a.pack(""A3A3A3"")
  
 →
  
 ""a
  
 b
  
 c
  
 ""
  
 a.pack(""a3a3a3"")
   
 ""a\000\000b\000\000c\000\000""
  
 →
  
 n.pack(""ccc"")
  
 →
  
 ""ABC""
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Removes the last element from
  arr
  and returns it or returns
  nil
  if the array is empty.
  
 a = [ ""a"", ""m"", ""z"" ]
  
 push
  
 a.pop
  
 →
  
 ""z""
  
 arr
 .push(
  ⟨
  obj
  ⟩
 ∗
 )
  →
  arr
  
 a
  
 [""a"", ""m""]
  
 →
  
 Appends the given argument(s) to
  arr
 .
  
 a = [ ""a"", ""b"", ""c"" ]
  
  
 a.push(""d"", ""e"", ""f"")
  
 →
  
 [""a"", ""b"", ""c"", ""d"", ""e"", ""f""]
  
 rassoc
  
 arr
 .rassoc(
  key
  )
  →
  an_array
  or
  nil 
 Searches through the array whose elements are also arrays. Compares
  key
  with the
  
 second element of each contained array using
  ==
 . Returns the first contained array that
  
 matches. See also
  Array
 #
 assoc
 .
  
 a = [ [ 1, ""one""], [2, ""two""], [3, ""three""], [""ii"", ""two""] ]
  
  
 a.rassoc(""two"")
  
 →
  
 [2, ""two""]
  
 a.rassoc(""four"")
  
 →
  
 nil
  
 reject!
  
 arr
 .reject! {
  block
  } item
  →
  arr
  or
  nil 
 Equivalent to
  Array
 #
 delete_if
 , but returns
  nil
  if no changes were made. Also see
  
 Enumerable
 #
 reject
 .
  
 replace
  
 arr
 .replace(
  other_array
  )
  →
  arr
  
 Replaces the contents of
  arr
  with the contents of
  other_array
 , truncating or expanding
  
 if necessary.
  
 a = [ ""a"", ""b"", ""c"", ""d"", ""e"" ]
  
 a.replace([ ""x"", ""y"", ""z"" ])
  
 →
  
 [""x"", ""y"", ""z""]
  
  
 a
  
 →
  
 [""x"", ""y"", ""z""]
  
 reverse
  
 arr
 .reverse
  →
  an_array
  
 Returns a new array using
  arr
 ’s elements in reverse order.
  
  
 [ ""a"", ""b"", ""c"" ].reverse
  
 →
  
 [""c"", ""b"", ""a""]
  
 [ 1 ].reverse
  
 →
  
 [1]
  
 reverse!
  
  
 1.8 
 Reverses
  arr
  in place.
  
 arr
 .reverse!
  →
  arr
  
 a = [ ""a"", ""b"", ""c"" ]
  
 a.reverse!
  
 →
  
 [""c"", ""b"", ""a""]
  
 a
  
 [""c"", ""b"", ""a""]
  
 →
  
 [ 1 ].reverse!
  
 →
  
 [1]
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Same as
  Array
 #
 each
 , but traverses
  arr
  in reverse order.
  
 a = [ ""a"", ""b"", ""c"" ]
  
 a.reverse_each {|x| print x, "" "" }
  
 produces:
  
 c b a
  
 rindex
  
 arr
 .rindex(
  obj
  )
  →
  int
  or
  nil 
 Returns the index of the last object in
  arr
  such that the object
  ==
  obj
 . Returns
  nil
  if no
  
 match is found.
  
 a = [ ""a"", ""b"", ""b"", ""b"", ""c"" ]
  
  
 a.rindex(""b"")
  
 →
  
 3
  
 a.rindex(""z"")
  
 →
  
 nil
  
 shift
  
 arr
 .shift
  →
  obj
  or
  nil 
 Returns the first element of
  arr
  and removes it (shifting all other elements down by
  
 one). Returns
  nil
  if the array is empty.
  
 args = [ ""-m"", ""-q"", ""filename"" ]
  
  
 args.shift
  
 →
  
 ""-m""
  
  
 args
  
 →
  
 [""-q"", ""filename""]
  
 size
  
 Synonym for
  Array
 #
 length
 .
  
 arr
 .size
  →
  int
  
  
  
 slice
  
 Synonym for
  Array
 #
 [ ]
 .
  
 arr
 .slice(
  int
  )
  →
  obj 
  
 arr
 .slice(
  start
 ,
  length
  )
  →
  an_array 
 arr
 .slice(
  range
  )
  →
  an_array
  
 a = [ ""a"", ""b"", ""c"", ""d"", ""e"" ]
  
 a.slice(2) + a.slice(0) + a.slice(1)
  
 →
  
 ""cab""
  
 a.slice(6)
  
 →
  
 nil
  
 a.slice(1, 2)
  
 →
  
 [""b"", ""c""]
  
 a.slice(1..3)
  
 →
  
 [""b"", ""c"", ""d""]
  
 a.slice(4..7)
  
 →
  
 [""e""]
  
 a.slice(6..10)
  
 nil
  
 →
  
 a.slice(-3, 3)
  
 →
  
 [""c"", ""d"", ""e""]
  
 # special cases
  
 a.slice(5)
  
 →
  
 nil
  
 a.slice(5, 1)
  
 []
  
 →
  
 a.slice(5..10)
  
 →
  
 []
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 Deletes the element(s) given by an index (optionally with a length) or by a range.
  
 Returns the deleted object, subarray, or
  nil
  if the index is out of range. Equivalent to
  
 def slice!(*args) 
  
 result = self[*args] 
  
 self[*args] = nil 
  
 result
  
 end
  
 a = [ ""a"", ""b"", ""c"" ]
  
  
 a.slice!(1)
  
 →
  
 ""b""
  
 a
  
 →
  
 [""a"", ""c""]
  
 a.slice!(-1)
  
 →
  
 ""c""
  
 a
  
 →
  
 [""a""]
  
 a.slice!(100)
  
 →
  
 nil
  
 a
  
 →
  
 [""a""]
  
 sort
  
 arr
 .sort
  →
  an_array 
  
 arr
 .sort {
 | a,b | block
  }
  →
  an_array
  
 Returns a new array created by sorting
  arr
 . Comparisons for the sort will be done 
 using
  
 the
  <=>
  operator or using an optional code block. The block implements a comparison
  
 between
  a
  and
  b
 , returning
  −1
 ,
  0
 , or
  +1
 . See also
  Enumerable
 #
 sort_by
 . 
 a = [ 
 ""d"", ""a"", ""e"", ""c"", ""b"" ]
  
  
 a.sort
  
 →
  
 [""a"", ""b"", ""c"", ""d"", ""e""]
  
 a.sort {|x,y| y <=> x }
  
 →
  
 [""e"", ""d"", ""c"", ""b"", ""a""]
  
 sort!
  
 arr
 .sort!
  →
  arr 
  
 arr
 .sort! {
 | a,b | block
  }
  →
  arr
  
 Sorts
  arr
  in place (see
  Array
 #
 sort
 ).
  arr
  is effectively frozen while a sort is in progress.
  
 a = [ ""d"", ""a"", ""e"", ""c"", ""b"" ]
  
  
 a.sort!
  
 →
  
 [""a"", ""b"", ""c"", ""d"", ""e""]
  
 a
  
 →
  
 [""a"", ""b"", ""c"", ""d"", ""e""]
  
 to_a
  
 arr
 .to_a
  →
  arr 
  
 array_subclass
 .to_a
  →
  array
  
 If
  arr
  is an array, returns
  arr
 . If
  arr
  is a subclass of
  Array
 , invokes
  to_ary
 , and uses
  
 the result to create a new array object.
  
 to_ary
  
 Returns
  arr
 .
  
 arr
 .to_ary
  →
  arr
  
  
 Prepared exclusively for Yeganefar",NA
A,"rray
  
 [ ""a"", ""e"", ""i"", ""o"" ].to_s
  
 →
  
 ""aeio""
  
  
 transpose
  
  
 1.8 
 Assumes that
  arr
  is an array of arrays and transposes the rows and columns. 
  
  
 arr
 .transpose
  →
  an_array
  
  
 a = [[1,2], [3,4], [5,6]]
  
 uniq
  
 a.transpose
  
 →
  
 [[1, 3, 5], [2, 4, 6]]
  
 arr
 .uniq
  →
  an_array
  
 Returns a new array by removing duplicate values in
  arr
 , where duplicates are detected
  
 by comparing using
  eql?
 .
  
 a = [ ""a"", ""a"", ""b"", ""b"", ""c"" ]
  
  
 a.uniq
  
 →
  
 [""a"", ""b"", ""c""]
  
 uniq!
  
 arr
 .uniq!
  →
  arr
  or
  nil 
 Same as
  Array
 #
 uniq
 , but modifies the receiver in place. Returns
  nil
  if no changes are
  
 made (that is, no duplicates are found).
  
 a = [ ""a"", ""a"", ""b"", ""b"", ""c"" ]
  
 a.uniq!
  
 →
  
 [""a"", ""b"", ""c""]
  
 b = [ ""a"", ""b"", ""c"" ]
  
 unshift
  
 b.uniq!
  
 →
  
 nil
  
 arr
 .unshift(
  ⟨
  obj
  ⟩
 +
 )
  →
  arr
  
 Prepends object(s) to
  arr
 .
  
 a = [ ""b"", ""c"", ""d"" ]
  
 a.unshift(""a"")
  
 →
  
 [""a"", ""b"", ""c"", ""d""]
  
 a.unshift(1, 2)
  
 →
  
 [1, 2, ""a"", ""b"", ""c"", ""d""]
  
 values_at
  
  
 1.8 
 Returns an array containing the elements in
  arr
  corresponding to the given selector(s). 
  
  
 arr
 .values_at(
  ⟨
  selector
  ⟩
 ∗
 )
  →
  an_array
  
 The selectors may be either integer indices or ranges.
  
 a = %w{ a b c d e f }
  
 a.values_at(1, 3, 5)
  
 →
  
 [""b"", ""d"", ""f""]
  
 a.values_at(1, 3, 5, 7)
  
 →
  
 [""b"", ""d"", ""f"", nil]
  
 a.values_at(-1, -3, -5, -7)
  
 →
  
 [""f"", ""d"", ""b"", nil]
  
 a.values_at(1..3, 2...5)
  
 →
  
 [""b"", ""c"", ""d"", ""c"", ""d"", ""e""]
  
  
 Prepared exclusively for Yeganefar",NA
Bignum,"<
  
 Integer
  
 um
  
  
 Bignum
  objects hold integers outside the range of
  Fixnum
 .
  Bignum
  objects are created",NA
B,"ign
  
 automatically when integer calculations would otherwise overflow a
  Fixnum
 . When a
  
 calculation involving
  Bignum
  objects returns a result that will fit in a
  Fixnum
 , the result 
 is automatically converted.
  
 For the purposes of the bitwise operations and
  [ ]
 , a
  Bignum
  is treated as if it were an 
 infinite-length bitstring with 2’s complement representation.
  
 While
  Fixnum
  values are immediate,
  Bignum
  objects are not—assignment and param-
 eter passing work with references to objects, not the objects themselves.
  
 Instance methods
  
 Arithmetic operations
  
 Performs various arithmetic operations on
  big
 .
  
 big
  
 +
  
 number
  
 Addition
  
 big
  
 –
  
 number
  
 Subtraction
  
 big
  
 *
  
 number
  
 Multiplication
  
 big
  
 /
  
 number
  
 Division
  
 big
  
 %
  
 number
  
 Modulo
  
 big
  
 **
  
 number
  
 Exponentiation
  
 big
  
 -@
  
 Unary minus
  
 Bit operations
  
 Performs various operations on the binary representations of the
  Bignum
 .
  
  
 ~
  big
  
 Invert bits
  
 big
  
 |
  
 number
  
 Bitwise
  OR
  
 big
  
 &
  
 number
  
 Bitwise
  AND
  
 big
  
 ^
  
 number
  
 Bitwise
  EXCLUSIVE OR
  
 big
  
 <<
  
 number
  
 Left-shift
  number
  bits
  
 big
  
 >>
  
 number
  
 Right-shift
  number
  bits (with sign extension)
  
 <=>
  
 big
  <=>
  number
  → −1
 ,
  0
 ,
  +1 
 Comparison—Returns
  −1
 ,
  0
 , or
  +1
  depending on whether
  big
  is less than, equal to, or 
 greater than
  number
 . This is the basis for the tests in
  Comparable
 .
  
  
 ==
  
 big
  ==
  obj
  →
  true
  or
  false 
 Returns
  true
  only if
  obj
  has the same value as
  big
 . Contrast this with
  Bignum
 #
 eql?
 ,
  
 which requires
  obj
  to be a
  Bignum
 .
  
 68719476736 == 68719476736.0
  
 →
  
 true",NA
B,"a = 9**15
  
 50.downto(0) do |n|
  
 print a[n]
  
 end
  
 produces:
  
 000101110110100000111000011110010100111100010111001
  
 abs
  
  
 Returns the absolute value of
  big
 .
  
 big
 .abs
  →
  bignum
  
  
  
 1234567890987654321.abs
  
 →
  
 1234567890987654321
  
 -1234567890987654321.abs
  
 →
  
 1234567890987654321
  
 div 
  
 1.8
  
  
 Synonym for
  Bignum
 #
 /
 .
  
 big
 .div(
  number
  )
  →
  other_number
  
  
 -1234567890987654321.div(13731)
  
 →
  
 -89910996357706
  
 -1234567890987654321.div(13731.0)
  
 →
  
 -89910996357705.5
  
 -1234567890987654321.div(-987654321)
  
 →
  
 1249999989
  
 divmo
 d
  
 See
  Numeric
 #
 divmod
  on page
  544
 .
  
 big
 .divmod(
  number
  )
  →
  array
  
  
  
 eql?
  
 big
 .eql?(
  obj
  )
  →
  true
  or
  false 
 Returns
  true
  only if
  obj
  is a
  Bignum
  with the same value as
  big
 . Contrast this with
  
 Bignum
 #
 ==
 , which performs type conversions.
  
  
 68719476736.eql? 68719476736
  
 →
  
 true
  
 68719476736
  
 ==
  
 68719476736
  
 →
  
 true
  
 68719476736.eql? 68719476736.0
  
 →
  
 false
  
 68719476736
  
 ==
  
 68719476736.0
  
 →
  
 true
  
 modul
 o 
 1.8
  
  
 Synonym for
  Bignum
 #
 %
 .
  
 big
 .modulo(
  number
  )
  →
  number
  
  
 quo 
 1.8
  
  
 Returns the floating-point result of dividing
  big
  by
  
 number
 .
  
 big
 .quo(
  number
  )
  →
  float
  
  
 -1234567890987654321.quo(13731)
  
 →
  
 -89910996357705.5
  
 -1234567890987654321.quo(13731.0)
  
 →
  
 -89910996357705.5
  
 -1234567890987654321.div(-987654321)
  
 →
  
 1249999989
  
  
 Prepared exclusively for Yeganefar",NA
B,"-1234567890987654321.remainder(13731.24)
  
 →
  
 -9906.22531493148
  
  
 size
  
 big
 .size
  →
  integer
  
  
 Returns the number of bytes in the machine representation of
  big
 .
  
 (256**10 - 1).size
  
 →
  
 12
  
 (256**20 - 1).size
  
 →
  
 20
  
 (256**40 - 1).size
  
 →
  
 40
  
 to_f
  
 big
 .to_f
  →
  float
  
  
 Converts
  big
  to a
  Float
 . If
  big
  doesn’t fit in a
  Float
 , the result is infinity.
  
 to_s 
  
 1.8
  
  
  
 big
 .to_s(
  base
 =10 )
  →
  str 
 Returns a string containing the representation of
  big
  radix
  base
  (2 to 36).
  
  
 12345654321.to_s
  
 →
  
 ""12345654321""
  
 12345654321.to_s(2)
  
 →
  
 ""1011011111110110111011110000110001""
  
 12345654321.to_s(8)
  
 →
  
 ""133766736061""
  
 12345654321.to_s(16)
  
 →
  
 ""2dfdbbc31""
  
 12345654321.to_s(26)
  
 →
  
 ""1dp1pc6d""
  
 78546939656932.to_s(36)
  
 →
  
 ""rubyrules""
  
  
 Prepared exclusively for Yeganefar",NA
Binding,"<
  
 Object
  
 ing
  
  
 Objects of class
  Binding
  encapsulate the execution context at some particular place in",NA
B,"ind
  
 the code and retain this context for future use. The variables, methods, value of
  self
 ,
  
 and possibly an iterator block that can be accessed in this context are all retained. 
 Binding objects can be created using
  Kernel
 #
 binding
  and are made available to the 
 callback of
  Kernel
 #
 set_trace_func
 .
  
 These binding objects can be passed as the second argument of the
  Kernel
 #
 eval 
 method, establishing an environment for the evaluation.
  
 class Demo 
  
 def initialize(n) 
  
   
 @secret = n 
  
 end 
  
 def get_binding 
  
   
 return binding() 
  
 end 
  
 end
  
 k1 = Demo.new(99) 
  
 b1 = k1.get_binding 
  
 k2 = Demo.new(-3) 
  
 b2 = k2.get_binding
  
 eval(""@secret"", b1)
  
 →
  
 99
  
 eval(""@secret"", b2)
  
 →
  
 -3
  
 eval(""@secret"")
  
 →
  
 nil
  
 Binding objects have no class-specific methods.
  
 Prepared exclusively for Yeganefar",NA
Class,"<
  
 Module
  
  
  
 Classes in Ruby are first-class objects—each is an instance of class
  Class
 .",NA
C,"lass
  
 When a new class is defined (typically using
  class
  Name
  ... end
 ), an object of type
  
 Class
  is created and assigned to a constant (
 Name
 , in this case). When
  Name.new
  is
  
 1.8
  
  
 called to create a new object, the
  new
  instance method in
  Class
  is run by default, 
 which
  
  
 in turn invokes
  allocate
  
 to allocate memory for the object, before finally calling the
  
 new object’s
  initialize
  method.
  
 Class methods
  
 inherited
  
 cls
 .inherited(
  sub_class
  )
  
 Invoked by Ruby when a subclass of
  cls
  is created. The new subclass is passed as a 
 parameter.
  
 class Top 
  
 def Top.inherited(sub) 
  
   
 puts ""New subclass: #{sub}"" 
  
 end 
  
 end
  
 class Middle < Top 
  
 end
  
 class Bottom < Middle 
  
 end
  
 produces:
  
 New subclass: Middle 
  
 New subclass: Bottom
  
 new 
 1.8
  
  
 Class.new(
  super_class
 =
 Object
  )
  ⟨
  {
  block
  }
  ⟩ →
  cls 
 Creates a new anonymous (unnamed) class with the given superclass (or
  Object
  if no
  
 parameter is given). If passed a block, that block is used as the body of the class.
  
 p = lambda do 
  
 def hello 
  
   
 ""Hello, Dave"" 
  
 end 
  
 end
  
 FriendlyClass = Class.new(&p) 
  
 f = FriendlyClass.new
  
 f.hello
  
 →
  
 ""Hello, Dave""
  
  
 Prepared exclusively for Yeganefar",NA
C,"lass
  
 an object, followed by calling
  initialize
  on that new object. You cannot override 
 allocate
  in normal programs; Ruby invokes it without going through conventional 
 method dispatch.
  
 class MyClass 
  
 def MyClass.another_new(*args) 
  
   
 o = allocate 
  
   
 o.send(:initialize, *args) 
  
   
 o 
  
 end 
  
 def initialize(a, b, c) 
  
   
 @a, @b, @c = a, b, c 
  
 end 
  
 end
  
 mc = MyClass.another_new(4, 5, 6)
  
  
 mc.inspect
  
 →
  
 ""#<MyClass:0x1c9378 @c=6, @b=5, @a=4>""
  
 new
   
  
 cls
 .new(
  ⟨
  args
  ⟩
 ∗
 )
  →
  obj
  
 Calls
  allocate
  to create a new object of
  cls
 ’s class and then invokes the newly created 
 object’s
  initialize
  method, passing it
  args
 .
  
 superclass
  
 cls
 .superclass
  →
  super_class
  or
  nil
  
 Returns the superclass of
  cls
  or returns
  nil
 .
  
 Class.superclass
  
 →
  
 Module
  
 Object.superclass
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
 Comparable,"Relies on:
  <=> 
  
 The
  Comparable
  mixin is used by classes whose objects may be ordered. The class 
 must define the
  <=>
  operator, which compares the receiver against another object,",NA
C,"omparable
  
 returning
  −1
 ,
  0
 , or
  +1
  depending on whether the receiver is less than, equal to, or 
 greater than the other object.
  Comparable
  uses
  <=>
  to implement the conventional 
 comparison operators (
 <
 ,
  <=
 ,
  ==
 ,
  >=
 , and
  >
 ) and the method
  between?
 .
  
 class CompareOnSize 
  
 include Comparable 
  
 attr :str 
  
 def <=>(other) 
  
   
 str.length <=> other.str.length 
  
 end 
  
 def initialize(str) 
  
   
 @str = str 
  
 end 
  
 end
  
 s1 = CompareOnSize.new(""Z"") 
  
 s2 = CompareOnSize.new([1,2]) 
  
 s3 = CompareOnSize.new(""XXX"")
  
 s1 < s2
  
 →
  
 true
  
 s2.between?(s1, s3)
  
 →
  
 true
  
 s3.between?(s1, s2)
  
 →
  
 false
  
 [ s3, s2, s1 ].sort
  
 →
  
 [""Z"", [1, 2], ""XXX""]
  
 Instance methods
  
 Comparisons
  
 obj
  <
  other_object
  →
  true
  or
  false 
 obj
  
 <=
  other_object
  →
  true
  or
  false 
 obj
  ==
  
 other_object
  →
  true
  or
  false 
 obj
  >=
  
 other_object
  →
  true
  or
  false 
 obj
  >
  
 other_object
  →
  true
  or
  false
  
 Compares two objects based on the receiver’s
  <=>
  method.
  
 between?
  
 obj
 .between?(
  min
 ,
  max
  )
  →
  true
  or
  false
  
 Returns
  false
  if
  obj
  <=>
  min
  is less than zero or if
  obj
  <=>
  max
  is greater than zero,
  
 true
  otherwise.
  
 3.between?(1, 5)
  
 →
  
 true
  
 6.between?(1, 5)
  
 false
  
 →
  
 'cat'.between?('ant', 'dog')
  
 →
  
 true
  
 'gnu'.between?('ant', 'dog')
  
 false
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
Continuation,"<
  
 Object
  
 tion
  
  
 Continuation
  objects are generated by
  Kernel
 #
 callcc
 . They hold a return address
  
 ontinu
 a
  
 and execution context, allowing a nonlocal return to the end of the
  callcc
  block from
  
  
 anywhere within a program. Continuations are somewhat analogous to a structured ver-",NA
C,"sion of C’s
  setjmp/longjmp
  (although they contain more state, so you may consider them 
 closer to threads).
  
 This (somewhat contrived) example allows the inner loop to abandon processing early.
  
 callcc do |cont| 
  
 for i in 0..4 
  
   
 print ""\n#{i}: "" 
  
   
 for j in i*5...(i+1)*5 
  
    
 cont.call() if j == 7 
  
    
 printf ""%3d"", j 
  
   
 end 
  
 end 
  
 end 
  
 print ""\n""
  
 produces:
  
 0:
  
 0
  
 1
  
 2
  
 3
  
 4
  
 1:
  
 5
  
 6
  
 This example shows that the call stack for methods is preserved in continuations.
  
 def strange 
  
 callcc {|continuation| return continuation} 
  
 print ""Back in method, "" 
  
 end 
  
 print ""Before method. "" 
  
 continuation = strange() 
  
 print ""After method. "" 
  
 continuation.call if continuation
  
 produces:
  
 Before method. After method. Back in method, After method.
  
 Instance methods
  
 call
  
 cont
 .call(
  ⟨
  args
  ⟩
 ∗
 )
  
 Invokes the continuation. The program continues from the end of the
  callcc
  block. If 
 no arguments are given, the original
  callcc
  returns
  nil
 . If one argument is given, 
 callcc
  
 returns it. Otherwise, an array containing
  args
  is returned.
  
 callcc {|cont|
  
 cont.call }
  
 →
  
 nil
  
 callcc {|cont|
  
 cont.call 1 }
  
 →
  
 1
  
 callcc {|cont|
  
 cont.call 1, 2, 3 }
  
 [1, 2, 3]
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
Dir,"<
  
  
 Object
  
  
 D
 IR
  
 428
  
 Objects of class
  Dir
  are directory streams representing directories in the underlying 
 filesystem. They provide a variety of ways to list directories and their contents. See
  
 also
  File
 , page
  444
 .
  
 ir
  
 The directory used in these examples contains the two regular files (
 config.h
  and",NA
D,"main.rb
 ), the parent directory (
 ..
 ), and the directory itself (
 .
 ).
  
 Mixes in
  
 Enumerable
 :
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Class methods
  
 [ ] 
  
 1.8
  
  
 Dir[
  glob_pattern
  ]
  →
  array
  
 Equivalent to calling
  Dir.glob(
 glob_pattern,
  
 0)
 .
  
 chdir
  
 Dir.chdir(
  ⟨
  dir
  ⟩
  )
  →
  0 
  
 Dir.chdir(
  ⟨
  dir
  ⟩
  ) {
 |
  path
  | block
  }
  →
  obj
  
 Changes the current working directory of the process to the given string. When called 
 without an argument, changes the directory to the value of the environment variable 
 HOME
  or
  LOGDIR
 . Raises a
  SystemCallError
  (probably
  Errno::ENOENT
 ) if the target 
 directory does not exist.
  
 1.8
  
  
 If a block is given, it is passed the
  
 name of the new current directory, and the block is
  
 executed with that as the current directory. The original working directory is restored 
 when the block exits. The return value of
  chdir
  is the value of the block.
  chdir
  blocks 
 can be nested, but in a multithreaded program an error will be raised if a thread 
 attempts to open a
  chdir
  block while another thread has one open. This is because the 
 underly-ing operating system only understands the concept of a single current 
 working directory at any one time.
  
 Dir.chdir(""/var/log"") 
  
 puts Dir.pwd
  
 Dir.chdir(""/tmp"") do 
  
 puts Dir.pwd
  
 Dir.chdir(""/usr"") do 
  
  
 puts Dir.pwd 
  
 end
  
 puts Dir.pwd 
  
 end
  
 puts Dir.pwd
  
 Prepared exclusively for Yeganefar",NA
D,"ir
  
 chroot
  
 Dir.chroot(
  dirname
  )
  →
  0
  
  
 Changes this process’s idea of the file system root. Only a privileged process may 
 make
  
 this call. Not available on all platforms. On Unix systems, see
  chroot(2)
  for more 
 information.
  
 Dir.chdir(""/production/secure/root"")
  
  
 Dir.chroot(""/production/secure/root"")
  
 →
  0
  
 Dir.pwd
  
 →
  ""/""
  
 delete
  
 Dir.delete(
  dirname
  )
  →
  0 
 Deletes the named directory. Raises a subclass of
  SystemCallError
  if the directory
  
 isn’t empty.
  
 entries
  
 Dir.entries(
  dirname
  )
  →
  array 
 Returns an array containing all of the filenames in the given directory. Will raise a
  
 SystemCallError
  if the named directory doesn’t exist.
  
  
 Dir.entries(""testdir"")
  
 →
  
 [""."", "".."", ""config.h"", ""main.rb""]
  
 foreac
 h
  
 Dir.foreach(
  dirname
  ) {
 | filename| block
  }
  →
  nil 
 Calls the block once for each entry in the named directory, passing the filename of 
 each
  
 entry as a parameter to the block.
  
 Dir.foreach(""testdir"") {|x| puts ""Got #{x}"" }
  
 produces:
  
 Got .
  
 Got ..
  
 Got config.h 
  
 Got main.rb
  
 getwd
  
 Dir.getwd
  →
  dirname 
 Returns a string containing the canonical path to the current working directory of this
  
 process. Note that on some operating systems this name may not be the name you gave 
 to
  Dir.chdir
 . On OS X, for example,
  /tmp
  is a symlink.
  
 Dir.chdir(""/tmp"")
  
 →
  
 0
  
 Dir.getwd
  
 ""/private/tmp""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
D,"ignored). Metacharacters in the pattern are
  
 * 
  
 Any sequence of characters in a filename:
  “*”
  will match all files,
  “c*”
  
 will match all files beginning with “c”,
  “*c”
  will match all files ending 
  
 with “c”, and
  “*c*”
  will match all files that have “c” in their name.
  
 ** 
  
 Matches zero of more directories (so
  “**/fred”
 ) matches a file named
  
 “fred” in or below the current directory).
  
 ? 
  
 Matches any one character in a filename.
  
 [
 chars
 ] 
  
 Matches any one of
  chars
 . If the first character in
  chars
  is ^, matches 
  
 any character not in the remaining set.
  
 {
 patt
 ,...} 
  
 Matches one of the patterns specified between braces. These patterns 
  
 may contain other metacharacters.
  
 \ 
  
 Removes any special significance in the next character.
  
 Dir.chdir(""testdir"")
  
 →
  
 0 
  
 Dir[""config.?""]
  
 →
  
 [""config.h""] 
  
 Dir.glob(""config.?"")
  
 →
  
  
 [""config.h""] Dir.glob(""*.[a-z][a-z]"")
  
 →
  
 [""main.rb""] 
  
 Dir.glob(""*.[^r]*"")
  
 →
  
 [""config.h""] 
  
 Dir.glob(""*.{rb,h}"")
  
  
 →
  
 [""main.rb"", ""config.h""] 
 Dir.glob(""*"")
  
 →
  
 [""config.h"", ""main.rb""] 
 Dir.glob(""*"", File::FNM_DOTMATCH)
  
 →
  
 [""."", "".."", ""config.h"", 
  
  
 ""main.rb""]
  
 Dir.chdir("".."")
  
 →
  
 0
  
 Dir.glob(""code/**/fib*.rb"")
  
 →
  
 [""code/fib_up_to.rb"",
  
 ""code/rdoc/fib_example.rb""]
  
  
 Dir.glob(""**/rdoc/fib*.rb"")
  
 →
  
 [""code/rdoc/fib_example.rb""]
  
 mkdir
   
 Dir.mkdir(
  dirname
  ⟨
  ,
  permissions
  ⟩
  )
  →
  0
  
 Makes a new directory named
  dirname
 , with permissions specified by the optional 
 parameter
  permissions
 . The permissions may be modified by the value of
  File.umask 
 and are ignored on Windows. Raises a
  SystemCallError
  if the directory cannot be 
 created. See also the discussion of permissions on page
  444
 .
  
 new
  
 Returns a new directory object for the named directory.
  
 Dir.new(
  dirname
  )
  →
  dir",NA
D,"Synonym for
  Dir.getwd
 .
  
 rmdir
   
 Dir.rmdir(
  dirname
  )
  →
  0
  
  
 Synonym for
  Dir.delete
 .
  
  
 unlink
  
 Synonym for
  Dir.delete
 .
  
 Dir.unlink(
  dirname
  )
  →
  0
  
 Instance methods
  
 close
   
 dir
 .close
  →
  nil 
 Closes the directory stream. Any further attempts to access
  dir
  will raise an
  IOError
 .
  
 d = Dir.new(""testdir"")
  
  
 d.close
  
 →
  
 nil
  
 each
  
 dir
 .each {
 | filename| block
  }
  →
  dir 
 Calls the block once for each entry in this directory, passing the filename of each 
 entry
  
 as a parameter to the block.
  
 d = Dir.new(""testdir"") 
  
 d.each {|name| puts ""Got #{name}"" }
  
 produces:
  
 Got .
  
 Got ..
  
 Got config.h 
  
 Got main.rb
  
 path
  
 Returns the path parameter passed to
  dir
 ’s constructor.
  
 dir
 .path
  →
  dirname
  
 1.8
  
  
 d = Dir.new("".."")
  
  
 d.path
  
 →
  
 ""..""
  
  
 pos
  
 Synonym for
  Dir
 #
 tell
 .
  
 dir
 .pos
  →
  int
  
 1.8
  
  
  
 Prepared exclusively for Yeganefar",NA
D,"d.pos = i
  
 →
  
 1
  
 d.read
  
 →
  
 ""..""
  
 read
  
 dir
 .read
  →
  filename
  or
  nil
  
  
 Reads the next entry from
  dir
  and returns it as a string. Returns
  nil
  at the end of the
  
 stream.
  
 d = Dir.new(""testdir"")
  
  
 d.read
  
 →
  
 "".""
  
  
 d.read
  
 →
  
 ""..""
  
 d.read
  
 →
  
 ""config.h""
  
 rewind
  
 Repositions
  dir
  to the first entry.
  
 dir
 .rewind
  →
  dir
  
 d = Dir.new(""testdir"")
  
  
 d.read
  
 →
  
 "".""
  
 d.rewind
  
 →
  
 #<Dir:0x1c96e8>
  
 d.read
  
 →
  
 "".""
  
 seek
  
 dir
 .seek(
  int
  )
  →
  dir 
 Seeks to a particular location in
  dir
 .
  int
  must be a value returned by
  Dir
 #
 tell
  (it is not
  
 necessarily a simple index into the entries).
  
  
 d = Dir.new(""testdir"")
  
 →
  
 #<Dir:0x1c9378>
  
  
 d.read
  
 →
  
 "".""
  
 i = d.tell
  
 →
  
 1
  
 d.read
  
 →
  
 ""..""
  
 d.seek(i)
  
 →
  
 #<Dir:0x1c9378>
  
 d.read
  
 →
  
 ""..""
  
 tell
  
 Returns the current position in
  dir
 . See also
  Dir
 #
 seek
 .
  
 dir
 .tell
  →
  int
  
 d = Dir.new(""testdir"")
  
 d.tell
  
 →
  
 1
  
 d.read
  
 →
  
 "".""
  
 d.tell
  
 →
  
 2
  
  
 Prepared exclusively for Yeganefar",NA
 Enumerable,"Relies on: each, <=>
  
 The
  Enumerable
  mixin provides collection classes with several traversal and searching 
 methods and with the ability to sort. The class must provide a method
  each
 , which 
 yields successive members of the collection. If
  Enumerable
 #
 max
 ,
  #min
 ,
  #sort
 , or 
 #sort_by
  is used, the objects in the collection must also implement a meaningful
  <=> 
 operator, as these methods rely on an ordering between members of the collection.",NA
E,"numerable
  
 Instance methods
  
 all? 
  
 1.8
  
  
 enum
 .all?
  ⟨
  {
 | obj | block
  }
  ⟩ →
  true
  or
  false 
 Passes each element of the collection to the given block. The method returns
  true
  if
  
 the block never returns
  false
  or
  nil
 . If the block is not given, Ruby adds an implicit
  
 block of
  {|obj| obj}
  (that is
  all?
  will return
  true
  only if none of the collection
  
 members is
  false
  or
  nil
 .)
  
  
 %w{ ant bear cat}.all? {|word| word.length >= 3}
  
 →
  
 true
  
 %w{ ant bear cat}.all? {|word| word.length >= 4}
  
 →
  
 false
  
 [ nil, true, 99 ].all?
  
 →
  
 false
  
 any? 
 1.8
  
  
 enum
 .any?
  ⟨
  {
 | obj | block
  }
  ⟩ →
  true
  or
  false 
 Passes each element of the collection to the given block. The method returns
  true
  if
  
 the block ever returns a value other than
  false
  or
  nil
 . If the block is not given, Ruby
  
 adds an implicit block of
  {|obj| obj}
  (that is,
  any?
  will return
  true
  if at least one of
  
 the collection members is not
  false
  or
  nil
 ).
  
  
 %w{ ant bear cat}.any? {|word| word.length >= 3}
  
 →
  
 true
  
 %w{ ant bear cat}.any? {|word| word.length >= 4}
  
 →
  
 true
  
 [ nil, true, 99 ].any?
  
 →
  
 true
  
 collect
  
 enum
 .collect {
 | obj | block
  }
  →
  array 
 Returns a new array containing the results of running
  block
  once for every element in
  
 enum
 .
  
  
 (1..4).collect {|i| i*i }
  
 →
  
 [1, 4, 9, 16]
  
 (1..4).collect { ""cat""
  
 }
  
 →
  
 [""cat"", ""cat"", ""cat"", ""cat""]
  
 detect
  
 enum
 .detect(
  ifnone
  =
  nil
  ) {
 | obj | block
  }
  →
  obj
  or
  nil 
 Passes each entry in
  enum
  to
  block
 . Returns the first for which
  block
  is not false. 
 Returns
  
 1.8
  
  
 nil
  if no object matches unless the proc
  ifnone
  
 is given, in which case it is called and
  
 its result returned.
  
 Prepared exclusively for Yeganefar",NA
E,"%w(cat dog wombat).each_with_index do |item, index|
  
 hash[item] = index
  
 end
  
  
 hash
  
 →
  
 {""cat""=>0, ""wombat""=>2, ""dog""=>1}
  
 entries
  
 Synonym for
  Enumerable
 #
 to_a
 .
  
 enum
 .entries
  →
  array
  
  
  
 find
  
 enum
 .find(
  ifnone
  =
  nil
  ) {
 | obj | block
  }
  →
  obj
  or
  nil 
 Synonym for
  Enumerable
 #
 detect
 .
  
  
 find_al
 l
  
 enum
 .find_all {
 | obj | block
  }
  →
  array 
 Returns an array containing all elements of
  enum
  for which
  block
  is not false (see 
 also
  
 Enumerable
 #
 reject
 ).
  
  
 (1..10).find_all {|i|
  
 i % 3 == 0 }
  
 →
  
 [3, 6, 9]
  
 grep
  
 enum
 .grep(
  pattern
  )
  →
  array 
 enum
 .grep(
  pattern
  ) {
 | obj | block
  }
  →
  array
  
 Returns an array of every element in
  enum
  for which
  pattern === element
 . If the
  
 optional
  block
  is supplied, each matching element is passed to it, and the block’s result
  
 is stored in the output array.
  
 (1..100).grep 38..44
  
 →
  
 [38, 39, 40, 41, 42, 43, 44]
  
 c = IO.constants
  
 c.grep(/SEEK/)
  
 →
  
 [""SEEK_CUR"", ""SEEK_SET"", ""SEEK_END""]
  
 res = c.grep(/SEEK/) {|v| IO.const_get(v) }
  
 res
  
 →
  
 [1, 0, 2]
  
 include?
  
 enum
 .include?(
  obj
  )
  →
  true
  or
  false
  
 Returns
  true
  if any member of
  enum
  equals
  obj
 . Equality is tested using
  ==
 .
  
 IO.constants.include? ""SEEK_SET""
  
 →
  
 true
  
 IO.constants.include? ""SEEK_NO_FURTHER""
  
 →
  
 false
  
  
 Prepared exclusively for Yeganefar",NA
E,"numerable
  
 1.8
  
  
 Combines the elements of
  enum
  by applying the block to an accumulator value 
 (
 memo
 )
  
 and each element in turn. At each step,
  memo
  is set to the value returned by the block.
  
 The first form lets you supply an initial value for
  memo
 . The second form uses the 
 first
  
 element of the collection as the initial value (and skips that element while iterating).
  
  
 # Sum some numbers",NA
E,"(5..10).inject {|sum, n| sum + n }
  
 →
  
 45
  
 # Multiply some numbers
  
 (5..10).inject(1) {|product, n| product * n }
  
 →
  
 151200
  
 # find the longest word 
  
 longest = %w{ cat sheep bear }.inject do |memo, word| 
  
  
 memo.length > word.length ? memo : word 
  
 end
  
 longest
  
 →
  
 ""sheep""
  
 # find the length of the longest word 
  
 longest = %w{ cat sheep bear }.inject(0) do |memo, word| 
  
  
 memo >= word.length ? memo : word.length 
  
 end
  
  
 longest
  
 →
  
 5
  
 map
   
 enum
 .map {
 | obj | block
  }
  →
  array
  
 Synonym for
  Enumerable
 #
 collect
 .
  
 max
  
 enum
 .max
  →
  obj 
  
 enum
 .max {
 | a,b | block
  }
  →
  obj
  
 Returns the object in
  enum
  with the maximum value. The first form assumes all 
 objects
  
 implement
  <=>
 ; the second uses the block to return
  a <=> b
 .
  
 a = %w(albatross dog horse)
  
 a.max
  
 →
  
 ""horse""
  
 a.max {|a,b| a.length <=> b.length }
  
 →
  
 ""albatross""
  
 member?
  
  
 enum
 .member?(
  obj
  )
  →
  true
  or
  false
  
 Synonym for
  Enumerable
 #
 include?
 .
  
 min
  
 enum
 .min
  →
  obj 
 enum
 .min {
 | a,b | block
  }
  →
  obj
  
 Returns the object in
  enum
  with the minimum value. The first form assumes all objects
  
 implement
  Comparable
 ; the second uses the block to return
  a <=> b
 .
  
 a = %w(albatross dog horse)
  
 a.min
  
 →
  
 ""albatross""
  
 a.min {|a,b| a.length <=> b.length }
  
 →
  
 ""dog""
  
  
 Prepared exclusively for Yeganefar",NA
E,"nu
  
 Returns an array containing the elements of
  enum
  for which
  block
  is false (see also
  
 Enumerable
 #
 find_all
 ).
  
  
 (1..10).reject {|i|
  
 i % 3 == 0 }
  
 →
  
 [1, 2, 4, 5, 7, 8, 10]
  
 select
  
 Synonym for
  Enumerable
 #
 find_all
 .
  
 enum
 .select {
 | obj | block
  }
  →
  array
  
  
  
 sort
  
 enum
 .sort
  →
  array 
  
 enum
 .sort {
 | a, b | block
  }
  →
  array
  
 Returns an array containing the items in
  enum
  sorted, either according to their own
  
 <=>
  method or by using the results of the supplied block. The block should return
  −
 1, 
 0, or +1 depending on the comparison between
  a
  and
  b
 . As of Ruby 1.8, the method 
 Enumerable
 #
 sort_by
  implements a built-in Schwartzian Transform, useful when key 
 computation or comparison is expensive.
  
  
 %w(rhea kea flea).sort
  
 →
  
 [""flea"", ""kea"", ""rhea""]
  
 (1..10).sort {|a,b| b <=> a}
  
 →
  
 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  
 sort_b
 y 
 1.8
  
  
 enum
 .sort_by {
 | obj | block
  }
  →
  array 
 Sorts
  enum
  using keys generated by mapping the values in
  enum
  through the given
  
 block, using the result of that block for element comparison.
  
 sorted = %w{ apple pear fig }.sort_by {|word| word.length}
  
 sorted
  
 →
  
 [""fig"", ""pear"", ""apple""]
  
 Internally,
  sort_by
  generates an array of tuples containing the original collection ele-
 ment and the mapped value. This makes
  sort_by
  fairly expensive when the keysets are 
 simple.
  
 require 'benchmark' 
  
 include Benchmark
  
 a = (1..100000).map {rand(100000)}
  
 bm(10) do |b| 
  
 b.report(""Sort"") 
  
 { a.sort } 
  
 b.report(""Sort by"") { a.sort_by {|a| a} } 
  
 end
  
 Prepared exclusively for Yeganefar",NA
E,"numerable
  
 Sort
  
 0.070000
  
 0.010000
  
 0.080000 (
  
 0.085860)
  
 Sort by
  
 1.580000
  
 0.010000
  
 1.590000 (
  
 1.811626)
  
 However, consider the case where comparing the keys is a nontrivial operation. The 
 following code sorts some files on modification time using the basic
  sort
  method.
  
 files = Dir[""*""]",NA
E,"sorted = files.sort {|a,b| File.new(a).mtime <=> File.new(b).mtime}
  
 sorted
  
 →
  
 [""mon"", ""tues"", ""wed"", ""thurs""]
  
 This sort is inefficient: it generates two new
  File
  objects during every comparison. A 
 slightly better technique is to use the
  Kernel
 #
 test
  method to generate the modification 
 times directly.
  
 files = Dir[""*""]
  
 sorted = files.sort do |a,b| 
  
 test(?M, a) <=> test(?M, b) 
  
 end
  
 sorted
  
 →
  
 [""mon"", ""tues"", ""wed"", ""thurs""]
  
 This still generates many unnecessary
  Time
  objects. A more efficient technique is to 
 cache the sort keys (modification times in this case) before the sort. Perl users often 
 call this approach a Schwartzian Transform, named after Randal Schwartz. We 
 construct a temporary array, where each element is an array containing our sort key 
 along with the filename. We sort this array and then extract the filename from the 
 result.
  
 sorted = Dir[""*""].collect {|f| 
  
  
 [test(?M, f), f] 
  
 }.sort.collect {|f| f[1] }
  
 sorted
  
 →
  
 [""mon"", ""tues"", ""wed"", ""thurs""]
  
 This is exactly what
  sort_by
  does internally.
  
 sorted = Dir[""*""].sort_by {|f| test(?M, f)}
  
 sorted
  
 →
  
 [""mon"", ""tues"", ""wed"", ""thurs""]
  
 sort_by
  can also be useful for multilevel sorts. One trick, which relies on the fact that 
 arrays are compared element by element, is to have the block return an array of each 
 of the comparison keys. For example, to sort a list of words first on their length and 
 then alphabetically, you could write.
  
 words = %w{ puma cat bass ant aardvark gnu fish } 
  
 sorted = words.sort_by {|w| [w.length, w] }
  
 sorted
  
 →
  
 [""ant"", ""cat"", ""gnu"", ""bass"", ""fish"", ""puma"", ""aardvark""]",NA
E,"Converts any arguments to arrays and then merges elements of
  enum
  with 
 correspond-
  
 ing elements from each argument. The result is an array containing the same number 
 of elements as
  enum
 . Each element is a
  n
 -element array, where
  n
  is one more than the 
 count of arguments. If the size of any argument is less than the number of elements in
  
 enum
 ,
  nil
  values are supplied. If a block given, it is invoked for each output array, 
 otherwise an array of arrays is returned.
  
 a = [ 4, 5, 6 ] 
  
 b = [ 7, 8, 9 ]
  
 (1..3).zip(a, b)
  
 →
  
 [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
  
 ""cat\ndog"".zip([1])
  
 →
  
 [[""cat\n"", 1], [""dog"", nil]]
  
 (1..3).zip
  
 [[1], [2], [3]]
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
 Errno,"Ruby exception objects are subclasses of
  Exception
 . However, operating systems typ-
 ically report errors using plain integers. Module
  Errno
  is created dynamically to map 
 these operating system errors to Ruby classes, with each error number generating its
  
 own subclass of
  SystemCallError
 . As the subclass is created in module
  Errno
 , its name 
 will start
  Errno::
 .
  
 Exception",NA
E,"rrno
  
 StandardError
  
 SystemCallError
  
 Errno::
 xxx
  
 The names of the
  Errno::
  classes depend on the environment in which Ruby runs. On a 
 typical Unix or Windows platform, you’ll find Ruby has
  Errno
  classes such as 
 Errno::EACCES
 ,
  Errno::EAGAIN
 ,
  Errno::EINTR
 , and so on.
  
 The integer operating system error number corresponding to a particular error is avail-
 able as the class constant
  Errno::
 error
 ::Errno
 .
  
 Errno::EACCES::Errno
  
 →
  
 13
  
 Errno::EAGAIN::Errno
  
 35
  
 →
  
 Errno::EINTR::Errno
  
 →
  
 4
  
 The full list of operating system errors on your particular platform is available as the 
 constants of
  Errno
 . Any user-defined exceptions in this module (including subclasses 
 of existing exceptions) must also define an
  Errno
  constant.
  
 Errno.constants
  
 →
  
 E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL,
  
 EAFNOSUPPORT, EAGAIN, EALREADY, ...
  
  
 1.8 
 As of Ruby 1.8 , exceptions are matched in
  rescue
  clauses using
  Module
 #
 ===
 . The 
 ===
  
 method is overridden for class
  SystemCallError
  to compare based on the
  Errno 
 value. Thus if two 
 distinct
  Errno
  classes have the same underlying
  Errno
  value, they will be treated as the same 
 exception by a
  rescue
  clause.",NA
Exception,"<
  
 Object
  
 E
 XCEPTION
  
 440
  
 Descendents of class
  Exception
  are used to communicate between
  raise
  methods and 
 rescue
  statements in
  begin/end
  blocks.
  Exception
  objects carry information about
  
 the exception—its type (the exception’s class name), an optional descriptive string, 
 and optional traceback information.
  
 The standard library defines the exceptions shown in Figure
  27.1
  on the following 
 page. See also the description of
  Errno
  on the page before.",NA
E,"xception
  
 Class methods
  
 exception
  
 Exception.exception(
  ⟨
  message
  ⟩
  )
  →
  exc
  
 Creates and returns a new exception object, optionally setting the message to
  message
 .
  
 new
  
 Exception.new(
  ⟨
  message
  ⟩
  )
  →
  exc
  
 Creates and returns a new exception object, optionally setting the message to
  message
 .
  
 Instance methods
  
 backtrace
  
 exc
 .backtrace
  →
  array
  
 Returns any backtrace associated with the exception. The backtrace is an array of
  
 strings, each containing either
  filename:line: in ‘method’
  or
  filename:line
 .
  
 def a 
  
 raise ""boom"" 
  
 end
  
 def b 
  
 a() 
  
 end
  
 begin 
  
 b() 
  
 rescue => detail 
  
 print detail.backtrace.join(""\n"") 
  
 end
  
 produces:
  
 prog.rb:2:in 
 `a' 
  
 prog.rb:6:in 
 `b' 
  
 prog.rb:10
  
 exception
  
 exc
 .exception(
  ⟨
  message
  ⟩
  )
  →
  exc
  or
  exception
  
 With no argument, returns the receiver. Otherwise, creates a new exception object of 
 the same class as the receiver but with a different message.
  
 Prepared exclusively for Yeganefar",NA
E,"xception
  
  
 message
  
 exc
 .message
  →
  msg
  
 Returns the message associated with this exception.
  
 set_backtrace
  
 exc
 .set_backtrace(
  array
  )
  →
  array
  
  
 Sets the backtrace information associated with
  exc
 . The argument must be an array of
  
 String
  objects in the format described in
  Exception
 #
 backtrace
 .
  
 status 
 1.8
  
  
 (
 SystemExit
  only)
  
 exc
 .status
  →
  status 
 Returns the exit status associated with this
  SystemExit
  exception.
  
 Normally this status is set using the
  Kernel
 #
 exit
 .
  
 Prepared exclusively for Yeganefar",NA
E,"xception
  
 success?
  
  
 1.8 
 (
 SystemExit
  only)
  
  
 exc
 .success?
  →
  true
  or
  false 
 Returns
  true
  is the exit status if
  nil
  or zero.",NA
E,"begin 
  
 exit(99) 
  
 rescue SystemExit => e 
  
 print ""This program "" 
  
 if e.success?
  
   
 print ""did"" 
  
 else 
  
   
 print ""did not"" 
  
 end 
  
 puts "" succeed"" 
  
 end
  
 produces:
  
 This program did not succeed
  
 to_s
  
 exc
 .to_s
  →
  msg 
 Returns the message associated with this exception (or the name of the exception if 
 no
  
 message is set).
  
 begin 
  
  
 raise ""The message"" 
  
 rescue Exception => e 
  
  
 puts e.to_s 
  
 end
  
 produces:
  
 The message
  
 to_str
  
 exc
 .to_str
  →
  msg 
 Returns the message associated with this exception (or the name of the exception if 
 no
  
 message is set). Implementing
  to_str
  gives exceptions a stringlike behavior.
  
 Prepared exclusively for Yeganefar",NA
FalseClass,"<
  
 Object
  
 F
 ALSE
 C
 LASS
  
 443
  
 The global value
  false
  is the only instance of class
  FalseClass
  and represents a log-
 ically false value in boolean expressions. The class provides operators allowing
  false 
 to participate correctly in logical expressions.
  
 Instance methods
  
 eClass
  
 &
  
 false
  &
  obj
  →
  false",NA
F,"als
  
 And—Returns
  false
 .
  obj
  is always evaluated as it is the argument to a method call—
  
 no short-circuit evaluation is performed in this case. In other words, the following 
 code, which uses
  &&
 , will not invoke the lookup method.
  
 def lookup(val) 
  
 puts ""Looking up #{val}"" 
  
 return true 
  
 end 
  
 false && lookup(""cat"")
  
 However, this code, using
  &
 , will:
  
 false & lookup(""cat"")
  
 produces:
  
 Looking up cat
  
 ^
  
 false
  ^
  obj
  →
  true
  or
  false
  
  
 Exclusive Or—If
  obj
  is
  nil
  or
  false
 , returns
  false
 ; otherwise, returns
  true
 .
  
 |
  
 false
  |
  obj
  →
  true
  or
  false 
 Or—Returns
  false
  if
  obj
  is
  nil
  or
  false
 ;
  true
  otherwise.
  
  
 Prepared exclusively for Yeganefar",NA
File,"<
  
 IO
  
 F
 ILE
  
 444
  
 A
  File
  is an abstraction of any file object accessible by the program and is closely 
 associated with class
  IO
 , page
  482
 .
  File
  includes the methods of module
  FileTest
  as 
 class methods, allowing you to write (for example)
  File.exist?(""foo"")
 .
  
 In this section,
  permission bits
  are a platform-specific set of bits that indicate permis-
  
 sions of a file. On Unix-based systems, permissions are viewed as a set of three 
 octets, for the owner, the group, and the rest of the world. For each of these entities, 
 permis-sions may be set to read, write, or execute the file.",NA
F,"ile
  
 Owner
  
 Group
  
 Other
  
  
 r
  
 w
  
 x
  
 r
  
 w
  
 x
  
 r
  
 w
  
 x
  
 4
  
 2
  
 1
  
 4
  
 2
  
 1
  
 4
  
 2
  
 1
  
 The permission bits
  0644
  (in octal) would thus be interpreted as read/write for owner 
 and read-only for group and other. Higher-order bits may also be used to indicate the 
 type of file (plain, directory, pipe, socket, and so on) and various other special 
 features. If the permissions are for a directory, the meaning of the execute bit 
 changes; when set, the directory can be searched.
  
 Each file has three associated times. The
  atime
  is the time the file was last accessed. 
 The
  ctime
  is the time that the file status (not necessarily the file contents) were last 
 changed. Finally, the
  mtime
  is the time the file’s data was last modified. In Ruby, all 
 these times are returned as
  Time
  objects.
  
 On non-POSIX operating systems, there may be only the ability to make a file read-
 only or read/write. In this case, the remaining permission bits will be synthesized to 
 resemble typical values. For instance, on Windows the default permission bits are
  
 0644
 , which means read/write for owner, read-only for all others. The only change 
 that can be made is to make the file read-only, which is reported as
  0444
 .
  
 See also
  Pathname
  on page
  693
 .
  
 Class methods
  
 atime
  
 File.atime(
  filename
  )
  →
  time 
 Returns a
  Time
  object containing the last access time for the named file, or returns
  
 epoch if the file has not been accessed.
  
 File.atime(""testfile"")
  
 →
  
 Thu Aug 26 22:36:07 CDT 2004
  
 basename
  
  
 File.basename(
  filename
  ⟨
  ,
  suffix
  ⟩
  )
  →
  string
  
 Returns the last component of the filename given in
  filename
 . If
  suffix
  is given and
  
 1.8
  
  
 present at the end of
  filename
 , it is removed. Any extension can be removed by giving
  
 «
  
 an extension of
  "".*""
 .
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 chardev?
  
  
 File.chardev?(
  filename
  )
  →
  true
  or
  false
  
  
 Returns
  true
  if the named file is a character device, and returns
  false
  if it isn’t or if
  
 the operating system doesn’t support this feature.
  
  
 File.chardev?(""/dev/tty"")
  
 →
  
 true
  
 chmod
   
  
 File.chmod(
  permission
  ⟨
  ,
  filename
  ⟩
 +
 )
  →
  int
  
 Changes permission bits on the named file(s) to the bit pattern represented by
  permis-
 sion
 . Actual effects are operating system dependent (see the beginning of this section).
  
 On Unix systems, see
  chmod(2)
  for details. Returns the number of files processed.
  
  
 File.chmod(0644, ""testfile"", ""out"")
  
 →
  
 2
  
 chown
  
 File.chown(
  owner
 ,
  group
  ⟨
  ,
  filename
  ⟩
 +
 )
  →
  int
  
 Changes the owner and/or group of the named file(s) to the given numeric owner and 
 group IDs. Only a process with superuser privileges may change the owner of a file. 
 The current owner of a file may change the file’s group to any group to which the 
 owner belongs. A
  nil
  or
  −1
  owner or group ID is ignored. Returns the number of files 
 processed.
  
 File.chown(nil, 100, ""testfile"")
  
 ctime
  
 File.ctime(
  filename
  )
  →
  time 
 Returns a
  Time
  object containing the time that the file status associated with the 
 named
  
 file was changed.
  
  
 File.ctime(""testfile"")
  
 →
  
 Thu Aug 26 22:37:31 CDT 2004
  
 delete
   
  
 File.delete(
  ⟨
  filename
  ⟩
 +
 )
  →
  int
  
 Deletes the named file(s). Returns the number of files processed. See also
  Dir.rmdir
 . 
 File.open(""testrm"", ""w+"") {}
  
 File.delete(""testrm"")
  
 →
  
 1
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 Returns all components of the filename given in
  filename
  except the last one.
  
 File.dirname(""/home/gumby/work/ruby.rb"")
  
 →
  
 ""/home/gumby/work""
  
 File.dirname(""ruby.rb"")
  
 →
  
 "".""
  
 executable?
  
 File.executable?(
  filename
  )
  →
  true
  or
  false
  
  
 Returns
  true
  if the named file is executable. The tests are made using the effective
  
 owner of the process.
  
 File.executable?(""testfile"")
  
 →
  
 false
  
 Same as
  File
 #
 executable?
 , but tests using the real owner of the process.
  
 exist?
  
 File.exist?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file or directory exists.
  
 File.exist?(""testfile"")
  
 →
  
 true
  
 exists?
  
  
 File.exists? (
  filename
  )
  →
  true
  or
  false
  
 Synonym for
  File.exist?
 .
  
  
 File.expand_path(
  filename
  ⟨
  ,
  dirstring
  ⟩
  )
  →
  filename
  
 expand_path
  
 Converts a pathname to an absolute pathname. Relative paths are referenced from the 
 current working directory of the process unless
  dirstring
  is given, in which case it 
 will be used as the starting point. The given pathname may start with a
  ~
 , which 
 expands to the process owner’s home directory (the environment variable
  HOME
  must 
 be set correctly).
  ~
 user
  expands to the named user’s home directory.
  
 File.expand_path(""~testuser/bin"")
  
 →
  
 ""/Users/testuser/bin""
  
 File.expand_path(""../../bin"", ""/tmp/x"")
  
 →
  
 ""/bin""
  
 extname
  
  
 1.8 
 Returns the extension (the portion of filename in
  path
  after the period). 
  
  
 File.extname(
  
 path
  )
  →
  string
  
 File.extname(""test.rb"")
  
 →
  
 "".rb""
  
 File.extname(""a/b/d/test.rb"")
  
 →
  
 "".rb""
  
 File.extname(""test"")
  
 →
  
 """"
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 must be matched by an explicit period in the pattern. A leading
  
 period is one at the start of the filename or (if
  FNM_PATHNAME
  is 
 spec-
  
 ified) following a slash.
  
  
 FNM_CASEFOLD
  
 Filename matches are case insensitive
  
  
 file?
  
 File.file?(
  filename
  )
  →
  true
  or
  false
  
  
 Returns
  true
  if the named file is a regular file (not a device file, directory, pipe, 
 socket,
  
 and so on).
  
 File.file?(""testfile"")
  
 →
  
 true
  
 File.file?(""."")
  
 →
  
 false
  
 fnmatch
  
  
 1.8 
 Returns true if
  path
  matches against
  glob_pattern
 . The pattern is not a regular expres-
  
 File.fnmatch(
  glob_pattern
 ,
  path
 ,
  ⟨
  flags
  ⟩
  )
  →
  true
  or
  false
  
 sion; instead it follows rules similar to shell filename globbing. Because
  fnmatch
  in 
 implemented by the underlying operating system, it may have different semantics to 
 Dir.glob
 . A
  glob_pattern
  may contain the following metacharacters.
  
 ** 
  
 * 
  
 ?
  
 [
  charset
  ]
  
 Matches subdirectories recursively.
  
 Matches zero or more characters.
  
 Matches any single character.
  
 Matches any character from the given set of characters. A range of
  
 characters is written as
  from
 -
 to
 . The set may be negated with an initial 
 caret (
 ^
 ).
  
 \
  
 Escapes any special meaning of the next character.
  
 flags
  is a bitwise OR of the
  FNM_xxx
  parameters listed on the current page. See also 
 Dir.glob
  on page
  430
 .
  
 File.fnmatch('cat',
  
 'cat')
  
 →
  
 true
  
 File.fnmatch('cat',
  
 'category')
  
 →
  
 false
  
 File.fnmatch('c{at,ub}s', 'cats')
  
 false
  
 →
  
 File.fnmatch('c{at,ub}s', 'cubs')
  
 →
  
 false
  
 File.fnmatch('c{at,ub}s', 'cat')
  
 false
  
 →
  
 File.fnmatch('c?t',
  
 'cat')
  
 →
  
 true
  
 File.fnmatch('c\?t',
  
 'cat')
  
 →
  
 false
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 File.fnmatch('c*',
  
 'cats')
  
 →
  
 true
  
 false
  
 File.fnmatch('c/**/t', 'c/a/b/c/t')
  
 →
  
 true
  
 File.fnmatch('c*t',
  
 'cat')
  
 →
  
 true
  
 File.fnmatch('c\at',
  
 'cat')
  
 →
  
 true
  
 File.fnmatch('c\at',
  
 'cat', File::FNM_NOESCAPE)
  
 →
  
 false
  
 File.fnmatch('a?b',
  
 'a/b')
  
 →
  
 true
  
 File.fnmatch('a?b',
  
 'a/b', File::FNM_PATHNAME)
  
 →
  
 false
  
 File.fnmatch('*',
  
 '.profile')
  
 →
  
 File.fnmatch('*',
  
 '.profile', File::FNM_DOTMATCH)
  
 →
  
 true
  
 File.fnmatch('*',
  
 'dave/.profile')
  
 →
  
 true
  
 File.fnmatch('*',
  
 'dave/.profile', File::FNM_DOTMATCH)
  
 →
  
 true
  
  
  
 File.fnmatch('*',
  
 'dave/.profile', File::FNM_PATHNAME)
  
 →
  
 false
  
 false
  
 File.fnmatch('*/*', 'dave/.profile', File::FNM_PATHNAME)
  
 →
  
 STRICT = File::FNM_PATHNAME | File::FNM_DOTMATCH
  
 File.fnmatch('*/*', 'dave/.profile', STRICT)
  
 →
  
 true
  
 File.ftype(
  filename
  )
  →
  filetype
  
 Identifies the type of the named file. The return string is one of
  file
 ,
  directory
 ,
  
 characterSpecial
 ,
  blockSpecial
 ,
  fifo
 ,
  link
 ,
  socket
 , or
  unknown
 .
  
 File.ftype(""testfile"")
  
 →
  
 ""file""
  
 File.ftype(""/dev/tty"")
  
 →
  
 ""characterSpecial""
  
 system(""mkfifo wibble"")
  
 →
  
 true
  
 File.ftype(""wibble"")
  
 →
  
 ""fifo""
  
 grpowned?
  
 File.grpowned?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the effective group ID of the process is the same as the group ID of the
  
 named file. On Windows, returns
  false
 .
  
 join
  
 File.grpowned?(""/etc/passwd"")
  
 →
  
 false
  
 File.join(
  ⟨
  string
  ⟩
 +
 )
  →
  filename
  
 Returns a new string formed by joining the strings using
  File::SEPARATOR
 . The vari-
  
 ous separators are listed in Table
  27.3
  on the next page.
  
  
 File.join(""usr"", ""mail"", ""gumby"")
  
 →
  
 ""usr/mail/gumby""
  
 lchmo
 d 
 1.8
  
  
 File.lchmod(
  permission
 ,
  ⟨
  filename
  ⟩
 +
 )
  →
  0 
 Equivalent to
  File.chmod
 , but does not follow symbolic links (so it will change the
  
 permissions associated with the link, not the file referenced by the link). Often not
  
 available.
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 1.8
  
  
 Equivalent to
  File.chown
 , but does not follow symbolic links (so it will change the
   
 owner associated with the link, not the file referenced by the link). Often not available.
  
 link
  
 File.link(
  oldname
 ,
  newname
  )
  →
  0 
 Creates a new name for an existing file using a hard link. Will not overwrite
  
 newname
  
 if it already exists (in which case
  link
  raises a subclass of
  SystemCallError
 ). Not available 
 on all platforms.
  
 File.link(""testfile"", ""testfile.lnk"")
  
 →
  
 0
  
 f = File.open(""testfile.lnk"")
  
 f.gets
  
 →
  
 ""This is line one\n""
  
 File.delete(""testfile.lnk"")
  
 lstat
  
 File.lstat(
  filename
  )
  →
  stat 
 Returns status information for
  file
  as an object of type
  File::Stat
 . Same as
  IO
 #
 stat
  
 (see page
  492
 ), but does not follow the last symbolic link. Instead, reports on the link 
 itself.
  
  
 File.symlink(""testfile"", ""link2test"")
  
 →
  
 0
  
 File.stat(""testfile"").size
  
 →
  
 66
  
 File.lstat(""link2test"").size
  
 →
  
 8
  
 File.stat(""link2test"").size
  
 →
  
 66
  
 mtime
   
 File.mtime(
  filename
  )
  →
  time 
 Returns a
  Time
  object containing the modification time for the named file.
  
  
 File.mtime(""testfile"")
  
 →
  
 Thu Aug 26 12:33:23 CDT 2004
  
 File.mtime(""/tmp"")
  
 →
  
 Thu Aug 26 22:36:41 CDT 2004
  
 new
  
 File.new(
  filename
 ,
  modestring
 =""r"" )
  →
  file 
  
 File.new(
  filename
  ⟨
  ,
  modenum
  ⟨
  , permission
  ⟩ ⟩
  )
  →
  file 
 File.new(
  fd
  ⟨
  ,
  modenum
  ⟨
  , permission
  ⟩ ⟩
  )
  →
  file
  
 Opens the file named by
  filename
  (or associates the already-open file given by
  fd
 ) 
 according to
  modestring
  (the default is
  r
 ) and returns a new
  File
  object. The
  mode-
 string
  is described in Table
  27.6
  on page
  483
 . The file mode may optionally be 
 specified as a
  Fixnum
  by
  or
 -ing together the flags described in Table
  27.4
  on page
  
 451
 . Optional",NA
F,"ile
  
 With no associated block,
  open
  is a synonym for
  File.new
 . If the optional code block is 
 given, it will be passed
  file
  as an argument, and the file will automatically be closed 
 when the block terminates. In this instance,
  File.open
  returns the value of the block.
  
 owned?
  
 File.owned?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the effective user ID of the process is the same as the owner of the
  
 named file.
  
  
 File.owned?(""/etc/passwd"")
  
 →
  
 false
  
 pipe?
  
 File.pipe?(
  filename
  )
  →
  true
  or
  false 
 Returns
  true
  if the operating system supports pipes and the named file is a pipe,
  false
  
 otherwise.
  
 File.pipe?(""testfile"")
  
 →
  
 false
  
 readable?
  
 File.readable?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is readable by the effective user ID of this process.
  
 File.readable?(""testfile"")
  
 →
  
 true
  
 readable_real?
  
 File.readable_real?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is readable by the real user ID of this process.
  
 File.readable_real?(""testfile"")
  
 →
  
 true
  
 readlink
  
 File.readlink(
  filename
  )
  →
  filename
  
 Returns the given symbolic link as a string. Not available on all platforms.
  
 File.symlink(""testfile"", ""link2test"")
  
 →
  
 0
  
 File.readlink(""link2test"")
  
 →
  
 ""testfile""
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 RDONLY
  
 Open for reading only.
  
 RDWR
  
 Open for reading and writing.
  
  
 TRUNC
  
 Open the file and truncate it to zero length if the file exists.
  
  
 WRONLY
  
 Open for writing only.
  
 rename
  
 File.rename(
  oldname
 ,
  newname
  )
  →
  0
  
  
 Renames the given file or directory to the new name. Raises a
  SystemCallError
  if the
  
 file cannot be renamed.
  
  
 File.rename(""afile"", ""afile.bak"")
  
 →
  
 0
  
 setgid
 ?
  
 File.setgid?(
  filename
  )
  →
  true
  or
  false 
 Returns
  true
  if the named file’s set-group-id permission bit is set, and returns
  false
  
 if it isn’t or if the operating system doesn’t support this feature.
  
  
 File.setgid?(""/usr/sbin/lpc"")
  
 →
  
 false
  
 setuid
 ?
  
 File.setuid?(
  filename
  )
  →
  true
  or
  false 
 Returns
  true
  if the named file’s set-user-id permission bit is set, and returns
  false
  if
  
 it isn’t or if the operating system doesn’t support this feature.
  
  
 File.setuid?(""/bin/su"")
  
 →
  
 false
  
 size
  
 Returns the size of the file in bytes.
  
 File.size(
  filename
  )
  →
  int
  
  
  
 File.size(""testfile"")
  
 →
  
 66
  
 size?
  
 File.size?(
  filename
  )
  →
  int
  or
  nil 
 Returns
  nil
  if the named file is of zero length; otherwise, returns the size. Usable as a
  
 condition in tests.
  
 File.size?(""testfile"")
  
 →
  
 66
  
 File.size?(""/dev/zero"")
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
F,"File.split(""ruby.rb"")
  
 →
  
 [""."", ""ruby.rb""]
  
 stat
  
 File.stat(
  filename
  )
  →
  stat
  
  
 Returns a
  File::Stat
  object for the named file (see
  File::Stat
 , page
  456
 ).
  
 stat = File.stat(""testfile"")
  
  
 stat.mtime
  
 →
  
 Thu Aug 26 12:33:23 CDT 2004
  
 stat.blockdev?
  
 →
  
 false
  
 stat.ftype
  
 →
  
 ""file""
  
 sticky
 ?
  
 File.sticky?(
  filename
  )
  →
  true
  or
  false 
 Returns
  true
  if the named file has its sticky bit set, and returns
  false
  if it doesn’t or if
  
 the operating system doesn’t support this feature.
  
 symlink
  
 File.symlink(
  oldname
 ,
  newname
  )
  →
  0 or
  nil
  
 Creates a symbolic link called
  newname
  for the file
  oldname
 . Returns
  nil
  on all plat-
  
 forms that do not support symbolic links.
  
 File.symlink(""testfile"", ""link2test"")
  
 →
  
 0
  
 symlink?
  
  
 File.symlink?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is a symbolic link, and returns
  false
  if it isn’t or if the
  
 operating system doesn’t support this feature.
  
 File.symlink(""testfile"", ""link2test"")
  
 →
  
 0
  
 File.symlink?(""link2test"")
  
 →
  
 true
  
 truncate
  
 File.truncate(
  filename
 ,
  int
  )
  →
  0
  
 Truncates the file
  filename
  to be at most
  int
  bytes long. Not available on all platforms.
  
 f = File.new(""out"", ""w"")
  
 f.write(""1234567890"")
  
 →
  
 10
  
 f.close
  
 →
  
 nil
  
 File.truncate(""out"", 5)
  
 →
  
 0
  
 File.size(""out"")
  
 →
  
 5
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 File.umask
  
 →
  
 6
  
 Synonym for
  File.delete
 . See also
  Dir.rmdir
 .
  
  
 File.open(""testrm"", ""w+"") {}
  
 →
  
 nil
  
 File.unlink(""testrm"")
  
 →
  
 1
  
 utime
  
 File.utime(
  accesstime
 ,
  modtime
  ⟨
  ,
  filename
  ⟩
 +
 )
  →
  int
  
 Changes the access and modification times on a number of files. The times must be
  
 instances of class
  Time
  or integers representing the number of seconds since epoch.
  
 Returns the number of files processed. Not available on all platforms.
  
 File.utime(0, 0, ""testfile"")
  
 →
  
 1
  
 File.mtime(""testfile"")
  
 →
  
 Wed Dec 31 18:00:00 CST 1969
  
 File.utime(0, Time.now, ""testfile"")
  
 →
  
 1
  
 File.mtime(""testfile"")
  
 →
  
 Thu Aug 26 22:37:33 CDT 2004
  
 writable?
  
 File.writable?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is writable by the effective user ID of this process.
  
 File.writable?(""/etc/passwd"")
  
 →
  
 false
  
 File.writable?(""testfile"")
  
 →
  
 true
  
 writable_real?
  
 File.writable_real?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is writable by the real user ID of this process.
  
 zero?
  
 File.zero?(
  filename
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named file is of zero length, and returns
  false
  otherwise.
  
 File.zero?(""testfile"")
  
 →
  
 false
  
 File.open(""zerosize"", ""w"") {}
  
 File.zero?(""zerosize"")
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 Changes permission bits on
  file
  to the bit pattern represented by
  permission
 . Actual
  
 effects are platform dependent; on Unix systems, see
  chmod(2)
  for details. Follows
  
 symbolic links. See the discussion of permissions on page
  444
 . Also see
  File
 #
 lchmod
 .
  
 f = File.new(""out"", ""w"");
  
  
 f.chmod(0644)
  
 →
  
 0
  
 chown
  
 file
 .chown(
  owner
 ,
  group
  )
  →
  
 0 Changes the owner and group of
  file
  to the given numeric owner and group IDs. 
 Only
  
 a process with superuser privileges may change the owner of a file. The current owner
  
 of a file may change the file’s group to any group to which the owner belongs. A
  nil
  
 or
  −1
  owner or group id is ignored. Follows symbolic links. See also
  File
 #
 lchown
 . 
 File.new(""testfile"").chown(502, 1000)
  
 ctime
  
 file
 .ctime
  →
  time 
 Returns a
  Time
  object containing the time that the file status associated with
  file
  was
  
 changed.
  
  
 File.new(""testfile"").ctime
  
 →
  
 Thu Aug 26 22:37:33 CDT 2004
  
 flock
  
 file
 .flock (
  locking_constant
  )
  →
  0 or
  false 
 Locks or unlocks a file according to
  locking_constant
  (a logical
  or
  of the values in
  
 Table
  27.5
  on the next page). Returns
  false
  if
  File::LOCK_NB
  is specified and the
  
 operation would otherwise have blocked. Not available on all platforms.
  
  
 File.new(""testfile"").flock(File::LOCK_UN)
  
 →
  
 0
  
 lchmo
 d 
 1.8
  
  
 file
 .lchmod(
  permission
  )
  →
  0 
 Equivalent to
  File
 #
 chmod
 , but does not follow symbolic links (so it will change the
  
 permissions associated with the link, not the file referenced by the link). Often not
  
 available.
  
 lchow
 n 
 1.8
  
  
 file
 .lchown(
  owner
 ,
  group
  )
  →
  0 
 Equivalent to
  File
 #
 chown
 , but does not follow symbolic links (so it will change the
  
 owner associated with the link, not the file referenced by the link). Often not available.
  
 Prepared exclusively for Yeganefar",NA
F,"ile
  
 file at the same time.
  
 LOCK_UN
  
 Unlock.
  
 lstat
  
 file
 .lstat
  →
  stat",NA
F,"Same as
  IO
 #
 stat
 , but does not follow the last symbolic link. Instead, reports on the
  
 link itself.
  
 File.symlink(""testfile"", ""link2test"")
  
 →
  
 0
  
 File.stat(""testfile"").size
  
 66
  
 →
  
 f = File.new(""link2test"")
  
  
 f.lstat.size
  
 →
  
 8
  
 f.stat.size
  
 →
  
 66
  
 mtime
  
 Returns a
  Time
  object containing the modification time for
  file
 .
  
 file
 .mtime
  →
  time
  
  
  
 File.new(""testfile"").mtime
  
 →
  
 Thu Aug 26 22:37:33 CDT 2004
  
 path
  
 file
 .path
  →
  filename
  
 Returns the pathname used to create
  file
  as a string. Does not normalize the name.
  
 File.new(""testfile"").path
  
 →
  
 ""testfile""
  
 File.new(""/tmp/../tmp/xxx"", ""w"").path
  
 →
  
 ""/tmp/../tmp/xxx""
  
 truncate
  
 file
 .truncate(
  int
  )
  →
  0
  
 Truncates
  file
  to at most
  int
  bytes. The file must be opened for writing. Not available
  
 on all platforms.
  
 f = File.new(""out"", ""w"")
  
 f.syswrite(""1234567890"")
  
 →
  
 10
  
 f.truncate(5)
  
 →
  
 0
  
 f.close()
  
 →
  
 nil
  
 File.size(""out"")
  
 →
  
 5
  
  
 Prepared exclusively for Yeganefar",NA
File::Stat,"<
  
 Object
  
 F
 ILE
 ::S
 TAT
  
 456
  
 Objects of class
  File::Stat
  encapsulate common status information for
  File
  objects.
  
 The information is recorded at the moment the
  File::Stat
  object is created; changes
  
 made to the file after that point will not be reflected.
  File::Stat
  objects are returned
  
 by
  IO
 #
 stat
 ,
  File.stat
 ,
  File
 #
 lstat
 , and
  File.lstat
 . Many of these methods may return 
 platform-specific values, and not all values are meaningful on all systems. See also
  
 Kernel
 #
 test
  on page
  510
 .
  
 ile::Stat
  
 Mixes in",NA
F,"Comparable
 :
  
 <, <=, ==, >=, >, between?
  
 Instance methods
  
 <=>
  
 statfile
  <=>
  other_stat
  → −1
 ,
  0
 ,
  1 
 Compares
  File::Stat
  objects by comparing their 
 respective modification times.
  
 f1 = File.new(""f1"", ""w"")
  
 sleep 1
  
 f2 = File.new(""f2"", ""w"")
  
 f1.stat <=> f2.stat
  
 →
  
 -1
  
 # Methods in Comparable are also available
  
  
 f1.stat > f2.stat
  
 →
  
 false
  
 f1.stat < f2.stat
  
 →
  
 true
  
 atime
  
 statfile
 .atime
  →
  time 
 Returns a
  Time
  object containing the last access time for
  statfile
 , or returns epoch if 
 the
  
 file has not been accessed.
  
  
 File.stat(""testfile"").atime
  
 →
  
 Wed Dec 31 18:00:00 CST 1969
  
 File.stat(""testfile"").atime.to_i
  
 →
  
 0
  
 blksize
  
 statfile
 .blksize
  →
  int 
 Returns the native file system’s block size. Will return
  nil
  on platforms that don’t
  
 support this information.
  
 File.stat(""testfile"").blksize
  
 →
  
 4096
  
 blockdev?
  
  
 statfile
 .blockdev?
  →
  true
  or
  false
  
 Returns
  true
  if the file is a block device, and returns
  false
  if it isn’t or if the operating
  
 system doesn’t support this feature.
  
 File.stat(""testfile"").blockdev?
  
 →
  
 false
  
 File.stat(""/dev/disk0"").blockdev?
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
F,"File.stat(""/dev/tty"").chardev?
  
 →
  
 true
  
  
 File.stat(""testfile"").chardev?
  
 →
  
 false
  
 ctime
  
 statfile
 .ctime
  →
  time
  
  
 Returns a
  Time
  object containing the time that the file status associated with
  statfile
  
 was changed.
  
  
 File.stat(""testfile"").ctime
  
 →
  
 Thu Aug 26 22:37:33 CDT 2004
  
 dev
  
 statfile
 .dev
  →
  int 
 Returns an integer representing the device on which
  statfile
  resides. The bits in the
  
 device integer will often encode major and minor device information.
  
 File.stat(""testfile"").dev
  
 →
  
 234881033
  
 ""%x"" % File.stat(""testfile"").dev
  
 →
  
 ""e000009""
  
 dev_major
  
 statfile
 .dev_major
  →
  int 
 the major part of
  File::Stat
 #
 dev
  or
  nil
  if the operating system doesn’t
  
 1.8
  
  
 Returns
  
 support this feature.
  
 File.stat(""testfile"").dev_major
  
 →
  
 14
  
 dev_minor",NA
F,"ile::
  
 Same as
  executable?
 , but tests using the real owner of the process.
  
 file?
  
 statfile
 .file?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  statfile
  is a regular file (not a device file, pipe, socket, and so on).
  
 File.stat(""testfile"").file?
  
 →
  
 true
  
 ftype
  
 statfile
 .ftype
  →
  type_string
  
  
 Identifies the type of
  statfile
 . The return string is one of:
  file
 ,
  directory
 ,
  char-
  
 acterSpecial
 ,
  blockSpecial
 ,
  fifo
 ,
  link
 ,
  socket
 , or
  unknown
 .
  
 gid
  
 File.stat(""/dev/tty"").ftype
  
 →
  
 ""characterSpecial""
  
 statfile
 .gid
  →
  int
  
 Returns the numeric group ID of the owner of
  statfile
 .
  
 File.stat(""testfile"").gid
  
 →
  
 502
  
  
 grpowned?
  
  
  
 statfile
 .grpowned?
  →
  true
  or
  false
  
 Returns true if the effective group ID of the process is the same as the group ID of
  
 statfile
 . On Windows, returns
  false
 .
  
  
 File.stat(""testfile"").grpowned?
  
 →
  
 true
  
 File.stat(""/etc/passwd"").grpowned?
  
 →
  
 false
  
 ino
  
 Returns the inode number for
  statfile
 .
  
 statfile
 .ino
  →
  int
  
  
  
 File.stat(""testfile"").ino
  
 →
  
 422829
  
 mode
  
 statfile
 .mode
  →
  int 
 Returns an integer representing the permission bits of
  statfile
 . The meaning of the 
 bits
  
 is platform dependent; on Unix systems, see
  stat(2)
 .
  
 File.chmod(0644, ""testfile"")
  
 →
  
 1
  
 File.stat(""testfile"").mode.to_s(8)
  
 →
  
 ""100644""
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile::Stat
  
 Returns the number of hard links to
  statfile
 .
  
 File.stat(""testfile"").nlink
  
 →
  
 1
  
 File.link(""testfile"", ""testfile.bak"")
  
 →
  
 0
  
 File.stat(""testfile"").nlink
  
 →
  
 2
  
 owned?
  
 statfile
 .owned?
  →
  true
  or
  false
  
  
 Returns
  true
  if the effective user ID of the process is the same as the owner of
  statfile
 .
  
 File.stat(""testfile"").owned?
  
 →
  
 true
  
 File.stat(""/etc/passwd"").owned?
  
 →
  
 false
  
  
 statfile
 .pipe?
  →
  true
  or
  false
  
 pipe?
  
  
 Returns
  true
  if the operating system supports pipes and
  statfile
  is a pipe.
  
 rdev
  
 statfile
 .rdev
  →
  int 
 Returns an integer representing the device type on which
  statfile
  (which should be a
  
 special file) resides. Returns
  nil
  if the operating system doesn’t support this feature.
  
 File.stat(""/dev/disk0s1"").rdev
  
 →
  
 234881025
  
 File.stat(""/dev/tty"").rdev
  
 →
  
 33554432
  
 rdev_major
  
 statfile
 .rdev_major
  →
  int 
 the major part of
  File::Stat
 #
 rdev
  or
  nil
  if the operating system doesn’t
  
 1.8
  
  
 Returns
  
 support this feature.
  
 File.stat(""/dev/disk0s1"").rdev_major
  
 →
  
 14
  
 File.stat(""/dev/tty"").rdev_major
  
 →
  
 2
  
 rdev_minor
  
 statfile
 .rdev_minor
  →
  int 
 the minor part of
  File::Stat
 #
 rdev
  or
  nil
  if the operating system doesn’t
  
 1.8
  
  
 Returns
  
 support this feature.
  
 File.stat(""/dev/disk0s1"").rdev_minor
  
 →
  
 1
  
 File.stat(""/dev/tty"").rdev_minor
  
 →
  
 0
  
 readable?
  
 statfile
 .readable?
  →
  true
  or
  false
  
 Returns
  true
  if
  statfile
  is readable by the effective user ID of this process.
  
 File.stat(""testfile"").readable?
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
F,"ile::Stat
  
 Returns
  true
  if
  statfile
  has the set-group-id permission bit set, and returns
  false
  if it 
 doesn’t or if the operating system doesn’t support this feature.
  
 File.stat(""testfile"").setgid?
  
 →
  
 false
  
 File.stat(""/usr/sbin/postdrop"").setgid?
  
 →
  
 true
  
 setuid?
  
 statfile
 .setuid?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  statfile
  has the set-user-id permission bit set, and returns
  false
  if it
  
 doesn’t or if the operating system doesn’t support this feature.
  
  
 File.stat(""testfile"").setuid?
  
 →
  
 false
  
 File.stat(""/usr/bin/su"").setuid?
  
 →
  
 true
  
 size
  
 Returns the size of
  statfile
  in bytes.
  
 statfile
 .size
  →
  int
  
  
  
 File.stat(""/dev/zero"").size
  
 →
  
 0
  
 File.stat(""testfile"").size
  
 →
  
 66
  
 size?
  
 statfile
 .size?
  →
  int
  or
  nil 
 Returns
  nil
  if
  statfile
  is a zero-length file; otherwise, returns the file size. Usable as a
  
 condition in tests.
  
 File.stat(""/dev/zero"").size?
  
 →
  
 nil
  
 File.stat(""testfile"").size?
  
 →
  
 66
  
 socket?
  
 statfile
 .socket?
  →
  true
  or
  false
  
 Returns
  true
  if
  statfile
  is a socket, and returns
  false
  if it isn’t or if the operating
  
 system doesn’t support this feature.
  
  
 File.stat(""testfile"").socket?
  
 →
  
 false
  
 sticky
 ?
  
 statfile
 .sticky?
  →
  true
  or
  false 
 Returns
  true
  if
  statfile
  has its sticky bit set, and returns
  false
  if it doesn’t or if the
  
 operating system doesn’t support this feature.
  
 File.stat(""testfile"").sticky?
  
 →
  
 false
  
  
 Prepared exclusively for Yeganefar",NA
F,"Returns the numeric user ID of the owner of
  statfile
 .
  
 File.stat(""testfile"").uid
  
 →
  
 502
  
 writable?
  
 statfile
 .writable?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  statfile
  is writable by the effective user ID of this process.
  
 File.stat(""testfile"").writable?
  
 →
  
 true
  
 writable_real?
  
 statfile
 .writable_real?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  statfile
  is writable by the real user ID of this process.
  
 File.stat(""testfile"").writable_real?
  
 →
  
 true
  
 zero?
  
 statfile
 .zero?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  statfile
  is a zero-length file;
  false
  otherwise.
  
 File.stat(""testfile"").zero?
  
 →
  
 false
  
  
 Prepared exclusively for Yeganefar",NA
 FileTest,"FileTest
  implements file test operations similar to those used in
  File::Stat
 . The
  
 methods in
  FileTest
  are duplicated in class
  File
 . Rather than repeat the documen-
  
 tation here, we list the names of the methods and refer you to the documentation for
  
 File
  starting on page
  444
 .
  FileTest
  appears to a somewhat vestigial module.
  
 1.8
  
  
 The
  FileTest
  methods are",NA
F,"ileTest
  
 blockdev?
 ,
  chardev?
 ,
  directory?
 ,
  executable?
 ,
  executable_real?
 ,
  exist?
 ,
  
 exists?
 ,
  file?
 ,
  grpowned?
 ,
  owned?
 ,
  pipe?
 ,
  readable?
 ,
  readable_real?
 ,
  
 setgid?
 ,
  setuid?
 ,
  size
 ,
  size?
 ,
  socket?
 ,
  sticky?
 ,
  symlink?
 ,
  world_readable? 
 ,
  
 world_writable?
 ,
  writable?
 ,
  writable_real?
 , and
  zero?
  
 Prepared exclusively for Yeganefar",NA
Fixnum,"<
  
 Integer
  
 F
 IXNUM
  
 463
  
 A
  Fixnum
  holds
  Integer
  values that can be represented in a native machine word 
 (minus 1 bit). If any operation on a
  Fixnum
  exceeds this range, the value is automati-
 cally converted to a
  Bignum
 .
  
 Fixnum
  objects have immediate value. This means that when they are assigned or 
 passed as parameters, the actual object is passed, rather than a reference to that 
 object. Assignment does not alias
  Fixnum
  objects. As there is effectively only one
  
 Fixnum 
 object instance for any given integer value, you cannot, for example, add a 
 singleton",NA
F,"ixnum
  
 method to a
  Fixnum
 .
  
 Instance methods 
  
 Arithmetic operations 
  
 Performs various arithmetic operations on
  fix
 .
  
 fix
  
 +
  
 numeric
  
 Addition
  
 fix
  
 –
  
 numeric
  
 Subtraction
  
 fix
  
 *
  
 numeric
  
 Multiplication
  
 fix
  
 /
  
 numeric
  
 Division
  
 fix
  
 %
  
 numeric
  
 Modulo
  
 fix
  
 **
  
 numeric
  
 Exponentiation
  
 fix
  
 -@
  
 Unary minus
  
 Bit operations 
  
  
 Performs various operations on the binary representations of the
  Fixnum
 .
  
  
 ~
  fix
  
 Invert bits
  
 fix
  
 |
  
 numeric
  
 Bitwise
  OR
  
 fix
  
 &
  
 numeric
  
 Bitwise
  AND
  
 fix
  
 ^
  
 numeric
  
 Bitwise
  EXCLUSIVE OR
  
 fix
  
 <<
  
 numeric
  
 Left-shift
  numeric
  bits
  
 fix
  
 >>
  
 numeric
  
 Right-shift
  numeric
  bits (with sign extension)
  
 <=>
  
 fix
  <=>
  numeric
  → −1
 ,
  0
 ,
  +1 
 Comparison—Returns
  −1
 ,
  0
 , or
  +1
  depending on whether
  fix
  is less than, equal to, or 
 greater than
  numeric
 . This is the basis for the tests in
  Comparable
 .
  
 42 <=> 13
  
 →
  
 1
  
 13 <=> 42
  
 →
  
 -1
  
 -1 <=> -1
  
 →
  
 0",NA
F,"Returns the absolute value of
  fix
 .
  
 -12345.abs
  
 →
  
 12345
  
 12345.abs
  
 →
  
 12345
  
 div 
  
 1.8
  
  
 fix
 .div(
  numeric
  )
  →
  integer 
 Synonym for
  Fixnum
 #
 /
 . Integer division always yields an 
 integral result.
  
  
 654321.div(13731)
  
 →
  
 47
  
 654321.div(13731.34)
  
 →
  
 47
  
 divmod
  
 fix
 .divmod(
  numeric
  )
  →
  array
  
  
 See
  Numeric
 #
 divmod
  on on page
  544
 .
  
 id2name
  
 fix
 .id2name
  →
  string
  or
  nil
  
  
 Returns the name of the object whose symbol ID is
  fix
 . If there is no symbol in the sym-
  
 bol table with this value, returns
  nil
 .
  id2name
  has nothing to do with the
  Object.id
  
 method. See also
  Fixnum
 #
 to_sym
 ,
  String
 #
 intern
  on page
  594
 , and class
  Symbol
  on
  
 page
  610
 .
  
  
 symbol = :@inst_var
  
 →
  
 :@inst_var
  
 id
  
 = symbol.to_i
  
 →
  
 9866
  
 id.id2name
  
 →
  
 ""@inst_var""
  
 modul
 o 
 1.8
  
  
 Synonym for
  Fixnum
 #
 %
 .
  
 fix
 .modulo(
  numeric
  )
  →
  numeric
  
  
 654321.modulo(13731)
  
 →
  
 8964
  
 654321.modulo(13731.24)
  
 →
  
 8952.72000000001
  
 quo 
 1.8
  
  
 Returns the floating-point result of dividing
  fix
  by
  numeric
 .
  
 fix
 .quo(
  numeric
  )
  →
  float
  
  
 654321.quo(13731)
  
 →
  
 47.6528293642124
  
 654321.quo(13731.24)
  
 →
  
 47.6519964693647
  
  
 Prepared exclusively for Yeganefar",NA
F,"ix
  
 Converts
  fix
  to a
  Float
 .
  
 to_s
  
 fix
 .to_s(
  base
 =10 )
  →
  string
  
  
 1.8
  
  
 Returns a string containing the representation of
  fix
  radix
  base
  (2 to 36).
  
 12345.to_s
  
 →
  
 ""12345""
  
 12345.to_s(2)
  
 →
  
 ""11000000111001""
  
 12345.to_s(8)
  
 →
  
 ""30071""
  
 12345.to_s(10)
  
 →
  
 ""12345""
  
 12345.to_s(16)
  
 →
  
 ""3039""
  
 12345.to_s(36)
  
 →
  
 ""9ix""
  
 84823723233035811745497171.to_s(36)
  
 →
  
 ""anotherrubyhacker""
  
 to_sy
 m
  
 fix
 .to_sym
  →
  symbol
  
  
 1.8
  
  
 Returns the symbol whose integer value is
  fix
 . See also
  Fixnum
 #
 id2name
 .
  
 fred = :fred.to_i
  
  
 fred.id2name
  
 →
  
 ""fred""
  
  
 fred.to_sym
  
 →
  
 :fred
  
 zero?
  
 Returns
  true
  if
  fix
  is zero.
  
 fix
 .zero?
  →
  true
  or
  false
  
 42.zero?
  
 →
  
 false
  
 0.zero?
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
Float,"<
  
 Numeric
  
 F
 LOAT
  
 466
  
 Float
  objects represent real numbers using the native architecture’s double-precision 
 floating-point representation.
  
 Class constants
  
 DIG
  
 Precision of
  Float
  (in decimal digits)
  
 loat
  
 EPSILON
  
 The smallest
  Float
  such that
  1.0+
  EPSILON
  = 1.0
  
 MANT_DIG
  
 The number of mantissa digits (base
  RADIX
 )",NA
F,"MAX
  
 The largest
  Float
  
 MAX_10_EXP
  
 The maximum integer
  x
  such that
  10
 x
 is a finite
  Float
  
 MAX_EXP
  
 The maximum integer
  x
  such that
  FLT
 _
 RADIX
 (x−1)
 is a finite
  
 Float
  
 MIN 
  
 MIN_10_EXP 
  
 MIN_EXP
  
 The smallest
  Float 
  
 The minimum integer
  x
  such that
  10
 x
 is a finite
  Float 
  
 The minimum integer
  x
  such that
  FLT
 _
 RADIX
 (x−1)
 is a finite
  
 Float
  
 RADIX 
  
 ROUND
 S
  
 The radix of floating-point representations 
  
 The rounding mode for floating-point operations. Possible values 
 include
  
 −1 
  
 0
  
 if the mode is indeterminate 
  
 if rounding is toward zero
  
 1
  
 if rounding is to nearest representable value
  
 2 
  
 3
  
 if rounding is toward
  +∞
  
 if rounding is toward
  −∞
  
 Instance methods
  
 Arithmetic operations
  
 Performs various arithmetic operations on
  flt
 .
  
  
 flt
  
 +
  
 numeric
  
 Addition
  
 flt
  
 –
  
 numeric
  
 Subtraction
  
 flt
  
 *
  
 numeric
  
 Multiplication
  
 flt
  
 /
  
 numeric
  
 Division
  
 flt
  
 %
  
 numeric
  
 Modulo
  
 flt
  
 **
  
 numeric
  
 Exponentiation
  
 flt
  
 -@
  
 Unary minus
  
 <=>
  
 flt
  <=>
  numeric
  → −1
 ,
  0
 ,
  +1 
 Returns
  −1
 ,
  0
 , or
  +1
  depending on whether
  flt
  is less than, equal to, or greater than 
 numeric
 . This is the basis for the tests in
  Comparable
 .
  
  
 Prepared exclusively for Yeganefar",NA
F,"Returns the absolute value of
  flt
 .
  
  
 (-34.56).abs
  
 →
  
 34.56
  
 -34.56.abs
  
 →
  
 34.56
  
 ceil
  
 flt
 .ceil
  →
  int
  
  
  
  
 Returns the smallest
  Integer
  greater than or equal to
  flt
 .
  
 1.2.ceil
  
 →
  
 2
  
 2.0.ceil
  
 →
  
 2
  
 (-1.2).ceil
  
 →
  
 -1
  
 (-2.0).ceil
  
 →
  
 -2
  
 divmo
 d
  
 flt
 .divmod(
  numeric
  )
  →
  array
  
  
  
  
 See
  Numeric
 #
 divmod
  on page
  544
 .
  
 eql?
  
 flt
 .eql?(
  obj
  )
  →
  true
  or
  false
  
  
 Returns
  true
  only if
  obj
  is a
  Float
  with the same value as
  flt
 . Contrast this with
  
 Float
 #
 ==
 , which performs type conversions.
  
  
 1.0.eql?(1)
  
 →
  
 false
  
 1.0 == 1
  
 →
  
 true
  
 finite?
  
 flt
 .finite?
  →
  true
  or
  false 
 Returns
  true
  if
  flt
  is a valid IEEE floating-point number (it is not infinite, and
  nan?
  is
  
 false
 ).
  
  
 (42.0).finite?
  
 →
  
 true
  
  
 (1.0/0.0).finite?
  
 →
  
 false
  
 floor
  
 Returns the largest integer less than or equal to
  flt
 .
  
 flt
 .floor
  →
  int
  
 1.2.floor
  
 →
  
 1
  
 2.0.floor
  
 →
  
 2
  
 (-1.2).floor
  
 →
  
 -2
  
 (-2.0).floor
  
 →
  
 -2
  
  
 Prepared exclusively for Yeganefar",NA
F,"loat
  
 1.8
  
  
 6543.21.modulo(137)
  
 →
  
 104.21
  
 6543.21.modulo(137.24)
  
 →
  
 92.9299999999996
  
 nan?
  
 flt
 .nan?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  flt
  is an invalid IEEE floating-point number.
  
 (-1.0).nan?
  
 →
  
 false
  
 (0.0/0.0).nan?
  
 →
  
 true
  
 round
  
 flt
 .round
  →
  int
  
  
 Rounds
  flt
  to the nearest integer. Equivalent to
  
 def round 
  
 case 
  
 when self > 0.0 then (self+0.5).floor 
  
 when self < 0.0 then return (self-0.5).ceil 
  
 else 0 
  
 end 
  
 end
  
  
 1.5.round
  
 →
  
 2
  
  
 (-1.5).round
  
 →
  
 -2
  
 to_f
  
 Returns
  flt
 .
  
 flt
 .to_f
  →
  flt
  
  
  
 to_i
  
 Returns
  flt
  truncated to an
  Integer
 .
  
 flt
 .to_i
  →
  int
  
  
  
 1.5.to_i
  
 →
  
 1
  
 (-1.5).to_i
  
 →
  
 -1
  
 to_int
  
 Synonym for
  Float
 #
 to_i
 .
  
 flt
 .to_int
  →
  int
  
  
 Prepared exclusively for Yeganefar",NA
F,Prepared exclusively for Yeganefar,NA
 GC,"The
  GC
  module provides an interface to Ruby’s mark and sweep garbage collection 
 mechanism. Some of the underlying methods are also available via the
  ObjectSpace 
 module, described beginning on page
  557
 .
  
 Module methods
  
 disable
  
 GC.disable
  →
  true
  or
  false 
 Disables garbage collection, returning
  true
  if garbage collection was already disabled.",NA
G,"C
  
 GC.disable
  
 →
  
 false
  
 GC.disable
  
 →
  
 true
  
 enable
   
 GC.enable
  →
  true
  or
  false 
 Enables garbage collection, returning
  true
  if garbage collection was disabled.
  
  
  
  
 GC.disable
  
 →
  
 false
  
 GC.enable
  
 →
  
 true
  
 GC.enable
  
 →
  
 false
  
 start
  
 Initiates garbage collection, unless manually disabled.
  
 GC.start
  →
  nil
  
  
 GC.start
  
 →
  
 nil
  
 Instance methods
  
 garbage_collect
  
 garbage_collect
  →
  nil
  
 Equivalent to
  GC.start
 .
  
  
 include GC
  
 garbage_collect
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
Hash,"<
  
 Object
  
 H
 ASH
  
 471
  
 A
  Hash
  is a collection of key/value pairs. It is similar to an
  Array
 , except that indexing 
 is done via arbitrary keys of any object type, not an integer index. The order in which 
 keys and/or values are returned by the various iterators over hash contents may seem 
 arbitrary and will generally not be in insertion order.
  
 Hashes have a
  default value
 . This value is returned when an attempt is made to access 
 keys that do not exist in the hash. By default, this value is
  nil
 .
  
 Mixes in
  
 h
  
 Enumerable
 : 
  
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,",NA
H,"ash
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Class methods
  
 [ ]
  
 Hash[
  ⟨
  key
  =>
  value
  ⟩
 ∗
 ]
  →
  hsh
  
 Creates a new hash populated with the given objects. Equivalent to creating a hash 
 using the literal
  {
  key
 =>
 value
 , ... }
 . Keys and values occur in pairs, so there must be an 
 even number of arguments.
  
  
 Hash[""a"", 100, ""b"", 200]
  
 →
  
 {""a""=>100, ""b""=>200}
  
 Hash[""a"" => 100, ""b"" => 200]
  
 →
  
 {""a""=>100, ""b""=>200}
  
 { ""a"" => 100, ""b"" => 200 }
  
 →
  
 {""a""=>100, ""b""=>200}
  
 new
  
 1.8
  
  
 Hash.new
  →
  hsh 
  
 Hash.new(
  obj
  )
  →
  hsh 
  
 Hash.new {
 | hash, key | block
  }
  →
  hsh
  
 Returns a new, empty hash. If this hash is subsequently accessed by a key that 
 doesn’t
  
 correspond to a hash entry, the value returned depends on the style of
  new
  used to 
 create the hash. In the first form, the access returns
  nil
 . If
  obj
  is specified, this single 
 object will be used for all
  default values
 . If a block is specified, it will be called with 
 the hash object and the key, and it should return the default value. It is the block’s 
 responsibility to store the value in the hash if required.
  
 h = Hash.new(""Go Fish"") 
  
 h[""a""] = 100 
  
 h[""b""] = 200
  
 h[""a""]
  
 →
  
 100
  
 h[""c""]
  
 →
  
 ""Go Fish""
  
 # The following alters the single default object
  
 h[""c""].upcase!
  
 →
  
 ""GO FISH""
  
 h[""d""]
  
 →
  
 ""GO FISH""
  
 h.keys
  
 [""a"", ""b""]
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
H,"ash
  
 Equality—Two hashes are equal if they have the same default value, they contain the
  
 same number of keys, and the value corresponding to each key in the first hash is 
 equal
  
 (using
  ==
 ) to the value for the same key in the second. If
  obj
  is not a hash, attempt to
  
 convert it using
  to_hash
  and return
  obj
  ==
  hsh
 .
  
 h1 = { ""a"" => 1, ""c"" => 2 } 
  
 h2 = { 7 => 35, ""c"" => 2, ""a"" => 1 } 
  
 h3 = { ""a"" => 1, ""c"" => 2, 7 => 35 } 
  
 h4 = { ""a"" => 1, ""d"" => 2, ""f"" => 35 }
  
  
 h1 == h2
  
 →
  
 false
  
 h2 == h3
  
 →
  
 true
  
 h3 == h4
  
 →
  
 false
  
 [ ]
  
 hsh
 [
  key
  ]
  →
  value 
 Element Reference—Retrieves the
  value
  stored for
  key
 . If not found, returns the 
 default
  
 value (see
  Hash.new
  for details).
  
 h = { ""a"" => 100, ""b"" => 200 }
  
  
 h[""a""]
  
 →
  
 100
  
 h[""c""]
  
 →
  
 nil
  
 [ ]=
  
 hsh
 [
  key
  ] =
  value
  →
  value 
 Element Assignment—Associates the value given by
  value
  with the key given by
  
 key
 .
  
 key
  should not have its value changed while it is in use as a key (a
  String
  passed as a 
 key will be duplicated and frozen).
  
 h = { ""a"" => 100, ""b"" => 200 } 
  
 h[""a""] = 9 
  
 h[""c""] = 4
  
  
 h
  
 →
  
 {""a""=>9, ""b""=>200, ""c""=>4}
  
  
  
 clear
  
 Removes all key/value pairs from
  hsh
 .
  
 {""a""=>100, ""b""=>200}
  
 hsh
 .clear
  →
  hsh
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 →
  
 h.clear
  
 →
  
 {}
  
  
 Prepared exclusively for Yeganefar",NA
H,"ash
  
 h.default
  
 →
  
 nil
  
 h.default(2)
  
 →
  
 nil
  
 h = Hash.new(""cat"")
  
 →
  
 {}
  
 h.default
  
 →
  
 ""cat""
  
 h.default(2)
  
 →
  
 ""cat""
  
 h = Hash.new {|h,k| h[k] = k.to_i*10}
  
 →
  
 {}
  
 h.default
  
 →
  
 0
  
 h.default(2)
  
 →
  
 20
  
 default=
  
 hsh
 .default =
  obj
  →
  hsh
  
  
 Sets the default value, the value returned for a key that does not exist in the hash. It is
  
 not possible to set the a default to a
  Proc
  that will be executed on each key lookup.
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.default = ""Go fish""
  
 h[""a""]
  
 →
  
 100
  
 h[""z""]
  
 →
  
 ""Go fish""
  
 # This doesn't do what you might hope...
  
 h.default = proc do |hash, key|
  
 hash[key] = key + key
  
 end
  
 h[2]
  
 →
  
 #<Proc:0x001c94e0@-:6>
  
 h[""cat""]
  
 →
  
 #<Proc:0x001c94e0@-:6>
  
 default_proc
  
  
 1.8 
 If
  Hash.new
  was invoked with a block, return that block; otherwise return
  nil
 . 
  
 hsh
 .default_proc
  →
  obj
  or
  nil
  
 h = Hash.new {|h,k| h[k] = k*k }
  
 →
  
 {}
  
 p = h.default_proc
  
 →
  
 #<Proc:0x001c997c@-:1>
  
 a = []
  
 →
  
 []
  
 p.call(a, 2)
  
  
 a
  
 →
  
 [nil, nil, 4]
  
 delete
  
 hsh
 .delete(
  key
  )
  →
  value 
  
 hsh
 .delete(
  key
  ) {
 | key | block
  }
  →
  value
  
 Deletes from
  hsh
  the entry whose key is to
  key
 , returning the corresponding value. If
  
 1.8
  
  
 the key is not found, returns
  nil
 .
  
 If the optional code block is given and the key is not
  
 found, pass it the key and return the result of
  block
 .
  
 Prepared exclusively for Yeganefar",NA
H,"h = { ""a"" => 100, ""b"" => 200 } 
  
 h.each {|key, value| puts ""#{key} is #{value}"" }
  
 produces:
  
 a is 100 
  
 b is 200
  
 each_key
  
 hsh
 .each_key {
 | key | block
  }
  →
  hsh
  
 Calls
  block
  once for each key in
  hsh
 , passing the key as a parameter.
  
 h = { ""a"" => 100, ""b"" => 200 } 
  
 h.each_key {|key| puts key }
  
 produces:
  
 a 
  
 b
  
 each_pair
  
 hsh
 .each_pair {
 | key, value | block
  }
  →
  hsh
  
 Synonym for
  Hash
 #
 each
 .
  
 each_value
  
 hsh
 .each_value {
 | value | block
  }
  →
  hsh
  
 Calls
  block
  once for each key in
  hsh
 , passing the value as a parameter.
  
 h = { ""a"" => 100, ""b"" => 200 } 
  
 h.each_value {|value| puts value }
  
 produces:
  
 100 
  
 200
  
 empty
 ?
  
 Returns
  true
  if
  hsh
  contains no key/value pairs.
  
 hsh
 .empty?
  →
  true
  or
  false
  
 {}.empty?
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
H,"ash
  
 h.fetch(""z"", ""go fish"")
  
 →
  
 ""go fish""
  
 h.fetch(""z"") {|el| ""go fish, #{el}""}
  
 →
  
 ""go fish, z""
  
 The following example shows that an exception is raised if the key is not found and a
  
 default value is not supplied.
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.fetch(""z"")
  
 produces:
  
 prog.rb:2:in `fetch': key not found (IndexError)
  
 from prog.rb:2
  
 has_key?
  
 hsh
 .has_key?(
  key
  )
  →
  true
  or
  false
  
 Returns
  true
  if the given key is present in
  hsh
 .
  
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.has_key?(""a"")
  
 →
  
 true
  
 h.has_key?(""z"")
  
 →
  
 false
  
 has_value?
  
 hsh
 .has_value?(
  value
  )
  →
  true
  or
  false
  
 Returns
  true
  if the given value is present for some key in
  hsh
 .
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.has_value?(100)
  
 →
  
 true
  
 h.has_value?(999)
  
 →
  
 false
  
 include?
  
 hsh
 .include?(
  key
  )
  →
  true
  or
  false
  
 Synonym for
  Hash
 #
 has_key?
 .
  
 index
  
 hsh
 .index(
  value
  )
  →
  key
  
 Searches the hash for an entry whose value
  ==
  value
 , returning the corresponding key.
  
 If multiple entries has this value, the key returned will be that on one of the entries. If
  
 not found, returns
  nil
 .
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.index(200)
  
 →
  
 ""b""
  
 h.index(999)
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
H,"h.invert
  
 →
  
 {0=>""a"", 100=>""n"", 200=>""d"", 300=>""y""}
  
 key?
  
 hsh
 .key?(
  key
  )
  →
  true
  or
  false
  
  
 Synonym for
  Hash
 #
 has_key?
 .
  
 keys
  
 hsh
 .keys
  →
  array
  
  
 Returns a new array populated with the keys from this hash. See also
  Hash
 #
 values
 .
  
 h = { ""a"" => 100, ""b"" => 200, ""c"" => 300, ""d"" => 400 }
  
  
 h.keys
  
 →
  
 [""a"", ""b"", ""c"", ""d""]
  
  
 length
  
 Returns the number of key/value pairs in the hash.
  
 hsh
 .length
  →
  fixnum
  
 h = { ""d"" => 100, ""a"" => 200, ""v"" => 300, ""e"" => 400 }
  
 h.length
  
 →
  
 4
  
 h.delete(""a"")
  
 →
  
 200
  
 h.length
  
 →
  
 3
  
 member?
  
 hsh
 .member?(
  key
  )
  →
  true
  or
  false
  
 Synonym for
  Hash
 #
 has_key?
 .
  
  
 hsh
 .merge(
  other_hash
  )
  →
  result_hash 
 hsh
 .merge(
  other_hash
  ) {
 |
  key
 ,
  old_val
 ,
  new_val
 | block
  }
  →
  result_hash
  
 Returns a new hash containing the contents of
  other_hash
  and the contents of
  hsh
 .
  
 merge 
 1.8
  
  
 With no block parameter, overwrites entries in
  hsh
  with duplicate keys with those from
  
 other_hash
 . If a block is specified, it is called with each duplicate key and the values 
 from the two hashes. The value returned by the block is stored in the new hash.
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
H,"ash
  
 h2 = { ""b"" => 254, ""c"" => 300 }
  
 h1.merge!(h2)
  
 →
  
 h1 = { ""a"" => 100, ""b"" => 200 }
  
  
 h1.merge!(h2) {|k,o,n| o}
  
 →
  
 {""a""=>100, ""b""=>200, ""c""=>300}
  
 h1
  
 →
  
 {""a""=>100, ""b""=>200, ""c""=>300}
  
 rehash
  
 hsh
 .rehash
  →
  hsh 
 Rebuilds the hash based on the current hash values for each key. If values of key 
 objects
  
 have changed since they were inserted, this method will reindex
  hsh
 . If
  Hash
 #
 rehash
  
 is called while an iterator is traversing the hash, an
  IndexError
  will be raised in the
  
 iterator.
  
 a = [ ""a"", ""b"" ]
  
 c = [ ""c"", ""d"" ]
  
 h = { a => 100, c => 300 }
  
 h[a]
  
 →
  
 100
  
 a[0] = ""z""
  
  
 h[a]
  
 →
  
 nil
  
 h.rehash
  
 →
  
 {[""z"", ""b""]=>100, [""c"", ""d""]=>300}
  
 h[a]
  
 →
  
 100
  
 reject
  
 hsh
 .reject {
 | key, value | block
  }
  →
  hash 
 Same as
  Hash
 #
 delete_if
 , but works on (and returns) a copy of
  hsh
 . Equivalent to
  
 hsh
 .dup.delete_if
 .
  
 reject!
  
 hsh
 .reject! {
 | key, value| block
  }
  →
  hsh
  or
  nil
  
  
 Equivalent to
  Hash
 #
 delete_if
 , but returns
  nil
  if no changes were made.
  
 replace
  
 hsh
 .replace(
  other_hash
  )
  →
  hsh
  
 Replaces the contents of
  hsh
  with the contents of
  other_hash
 .
  
 h = { ""a"" => 100, ""b"" => 200 }
  
 h.replace({ ""c"" => 300, ""d"" => 400 })
  
 →
  
 {""c""=>300, ""d""=>400}
  
  
 Prepared exclusively for Yeganefar",NA
H,"ash
  
 If the hash is empty, returns the default value, calls the default proc (with a key value 
 of
  nil
 ), or returns
  nil
 .
  
 h = { 1 => ""a"", 2 => ""b"", 3 => ""c"" }
  
 h.shift
  
 →
  
 [1, ""a""]
  
 h
  
 →
  
 {2=>""b"", 3=>""c""}
  
 size
  
 hsh
 .size
  →
  fixnum
  
  
 Synonym for
  Hash
 #
 length
 .
  
 sort
  
 hsh
 .sort
  →
  array 
  
 hsh
 .sort {
 | a, b | block
  }
  →
  array
  
  
 Converts
  hsh
  to a nested array of
  [
  key, value
  ]
  arrays and sorts it, using
  Array
 #
 sort
 .
  
 h = { ""a"" => 20, ""b"" => 30, ""c"" => 10
  
 }
  
 h.sort
  
 →
  
 [[""a"", 20], [""b"", 30], [""c"", 10]]
  
 h.sort {|a,b| a[1]<=>b[1]}
  
 →
  
 [[""c"", 10], [""a"", 20], [""b"", 30]]
  
 store
  
 hsh
 .store(
  key, value
  )
  →
  value
  
  
 Synonym for Element Assignment (
 Hash
 #
 []=
 ).
  
 to_a
  
 hsh
 .to_a
  →
  array
  
  
 Converts
  hsh
  to a nested array of
  [
  key, value
  ]
  arrays.
  
 h = { ""c"" => 300, ""a"" => 100, ""d"" => 400, ""c"" => 300
  
 }
  
 h.to_a
  
 →
  
 [[""a"", 100], [""c"", 300], [""d"", 400]]
  
 to_hash
  
 hsh
 .to_hash
  →
  hsh
  
  
 See page
  356
 .
  
  
 to_s
  
 hsh
 .to_s
  →
  string
  
  
 Converts
  hsh
  to a string by converting the hash to an array of
  [
  key, value
  ]
  pairs and
  
 then converting that array to a string using
  Array
 #
 join
  with the default separator.
  
 h = { ""c"" => 300, ""a"" => 100, ""d"" => 400, ""c"" => 300 }
  
 h.to_s
  
 →
 ""a100c300d400""
  
 Prepared exclusively for Yeganefar",NA
H,"values_at
  
  
 1.8 
 Returns an array consisting of values for the given key(s). Will insert the
  default value 
  
  
 hsh
 .values_at(
  ⟨
  key
  ⟩
 +
 )
  →
  array
  
  
 for keys that are not found.
  
 h = { ""a"" => 100, ""b"" => 200, ""c"" => 300 }
  
 h.values_at(""a"", ""c"")
  
 →
  
 [100, 300]
  
 h.values_at(""a"", ""c"", ""z"")
  
 →
  
 [100, 300, nil]
  
 h.default = ""cat""
  
 h.values_at(""a"", ""c"", ""z"")
  
 →
  
 [100, 300, ""cat""]
  
  
 Prepared exclusively for Yeganefar",NA
Integer,"<
  
 Numeric
  
 I
 NTEGER
  
 480
  
 Subclasses: Bignum, Fixnum
  
 Integer
  is the basis for the two concrete classes that hold whole numbers,
  Bignum
  and 
 Fixnum
 . (If you’ve come here looking for the iterator
  step
 , it’s on page
  545
 .)
  
 Instance methods
  
 ceil
  
 int
 .ceil
  →
  integer
  
  
  
 er
  
 Synonym for
  Integer
 #
 to_i
 .
  
 chr
  
 int
 .chr
  →
  string
  
 nt
 eg
  
  
  
  
 Returns a string containing the ASCII character represented by the receiver’s value.",NA
I,"65.chr
  
 →
  
 ""A""
  
  
 ?a.chr
  
 →
  
 ""a""
  
 230.chr
  
 →
  
 ""\346""
  
 downt
 o
  
 int
 .downto(
  integer
  ) {
 | i | block
  }
  →
  int
  
  
 Iterates
  block
 , passing decreasing values from
  int
  down to and including
  integer
 .
  
 5.downto(1) {|n| print n, "".. "" } 
  
 print "" Liftoff!\n"" 
  
 produces:
  
 5.. 4.. 3.. 2.. 1..
  
 Liftoff!
  
 floor
  
 int
 .floor
  →
  integer
  
 Returns the largest integer less than or equal to
  int
 . Equivalent to
  Integer
 #
 to_i
 .
  
 1.floor
  
 →
  
 1
  
 (-1).floor
  
 →
  
 -1
  
 integer?
  
  
 int
 .integer?
  →
  true
  
 Always returns
  true
 .
  
 next
  
 Returns the
  Integer
  equal to
  int
  + 1.
  
 int
 .next
  →
  integer
  
  
  
 1.next
  
 →
  
 2
  
 (-1).next
  
 →
  
 0
  
 round
  
 Synonym for
  Integer
 #
 to_i
 .
  
 int
 .round
  →
  integer
  
  
 Prepared exclusively for Yeganefar",NA
I,"to_int
  
 int
 .to_int
  →
  integer
  
  
 Synonym for
  Integer
 #
 to_i
 .
  
 truncate
  
 int
 .truncate
  →
  integer
  
  
 Synonym for
  Integer
 #
 to_i
 .
  
 upto
  
 int
 .upto(
  integer
  ) {
 | i | block
  }
  →
  int
  
  
 Iterates
  block
 , passing in integer values from
  int
  up to and including
  integer
 .
  
 5.upto(10) {|i| print i, "" "" } 
  
 produces: 
  
 5 6 7 8 9 10
  
 Prepared exclusively for Yeganefar",NA
IO,"<
  
  
 Object
  
  
 IO
  
 482
  
 Subclasses: File 
  
 Class
  IO
  is the basis for all input and output in Ruby. An I/O stream may be
  duplexed 
 (that is, bidirectional) and so may use more than one native operating system stream. 
 Many of the examples in this section use class
  File
 , the only standard subclass of
  IO
 . 
 The two classes are closely associated.
  
 As used in this section,
  portname
  may take any of the following forms.
  
 • A plain string represents a filename suitable for the underlying operating system.
  
 • A string starting with
  |
  indicates a subprocess. The remainder of the string follow-
  
 O
  
 ing the
  |
  is invoked as a process with appropriate input/output channels connected",NA
I,"to it.
  
 • A string equal to
  |-
  will create another Ruby instance as a subprocess.
  
 The
  IO
  class uses the Unix abstraction of
  file descriptors
 , small integers that represent 
 open files. Conventionally, standard input has an fd of 0, standard output an fd of 1, 
 and standard error an fd of 2.
  
 Ruby will convert pathnames between different operating system conventions if 
 possi-ble. For instance, on a Windows system the filename
  /gumby/ruby/test.rb
  will 
 be opened as
  \gumby\ruby\test.rb
 . When specifying a Windows-style filename in a 
 double-quoted Ruby string, remember to escape the backslashes.
  
 ""c:\\gumby\\ruby\\test.rb"" 
  
 Our examples here will use the Unix-style forward slashes;
  File::SEPARATOR
  can be 
 used to get the platform-specific separator character.
  
 I/O ports may be opened in any one of several different modes, which are shown in 
 this section as
  modestring
 . This mode string must be one of the values listed in Table
  
 27.6
  on the following page.
  
 Mixes in
  
 Enumerable
 : 
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all, grep, include?, inject, map, max, 
 member?, min, partition, reject, select, sort, sort_by, to_a, zip
  
 Prepared exclusively for Yeganefar",NA
I,"(DOS/Windows only) Binary file mode (may appear with any of the key letters
  
 listed above).
  
 Class methods
  
 for_f
 d 
 1.8
  
  
  
 Synonym for
  IO.new
 .
  
 IO.for_fd(
  int
 ,
  modestring
  )
  →
  io
  
  
 foreac
 h
  
 IO.foreach(
  portname
 ,
  separator
 =
 $/
  ) {
 | line | block
  }
  →
  nil 
 Executes the block for every line in the named I/O port, where lines are separated by
  
 separator
 .
  
 IO.foreach(""testfile"") {|x| puts ""GOT: #{x}"" }
  
 produces:
  
 GOT: This is line one
  
 GOT: This is line two
  
 GOT: This is line three
  
 GOT: And so on...
  
 new
  
 IO.new(
  int
 ,
  modestring
  )
  →
  io 
 Returns a new
  IO
  object (a stream) for the given integer file descriptor and mode 
 string.
  
 See also
  IO
 #
 fileno
  and
  IO.for_fd
 .
  
 a = IO.new(2, ""w"") 
  
 # '2' is standard error
  
 STDERR.puts ""Hello""
  
 a.puts ""World""
  
 produces:
  
 Hello
  
 World
  
 Prepared exclusively for Yeganefar",NA
I,"Creates a pair of pipe endpoints (connected to each other) and returns them as a two-
  
 element array of
  IO
  objects:
  [
  read_file
 ,
  write_file
  ]
 .
  write_file
  is automatically placed 
 into sync mode. Not available on all platforms.
  
 In the example below, the two processes close the ends of the pipe that they are not 
 using. This is not just a cosmetic nicety. The read end of a pipe will not generate an 
 end-of-file condition if any writers have the pipe still open. In the case of the parent 
 process, the
  rd.read
  will never return if it does not first issue a
  wr.close
 .
  
 rd, wr = IO.pipe
  
 if fork 
  
 wr.close 
  
 puts ""Parent got: <#{rd.read}>"" 
  
 rd.close 
  
 Process.wait 
  
 else 
  
 rd.close 
  
 puts ""Sending message to parent"" 
  
 wr.write ""Hi Dad"" 
  
 wr.close 
  
 end
  
 produces:
  
 Sending message to parent 
  
 Parent got: <Hi Dad>
  
 popen
  
 IO.popen(
  cmd
 ,
  modestring
 =""r"" )
  →
  io 
 IO.popen(
  cmd
 ,
  modestring
 =""r"" ) {
 | io | block
  }
  →
  obj
  
 Runs the specified command string as a subprocess; the subprocess’s standard input
  
 and output will be connected to the returned
  IO
  object. The parameter
  cmd
  may be a 
 string or an array of strings. In the latter case, the array is used as the
  argv
  parameter 
 for the new process, and no special shell processing is performed on the strings. If
  
 cmd",NA
I,"pipe = IO.popen(""uname"") 
  
 p(pipe.readlines) 
  
 puts ""Parent is #{Process.pid}"" 
  
 IO.popen(""date"") {|pipe| puts pipe.gets } 
  
 IO.popen(""-"") {|pipe| STDERR.puts ""#{Process.pid} is here, pipe=#{pipe}"" }
  
 produces:
  
 [""Darwin\n""] 
  
 Parent is 26841 
  
 Thu Aug 26 22:37:42 CDT 2004 
  
 26844 is here, pipe= 
  
 26841 is here, pipe=#<IO:0x1c9418>
  
 read 
 1.8
  
  
 IO.read(
  portname
 ,
  ⟨
  length
 =
 $/
  ⟨
  , offset
  ⟩ ⟩
  )
  →
  string 
 Opens the file, optionally seeks to the given offset, and then returns
  length
  bytes
  
 (defaulting to the rest of the file).
  read
  ensures the file is closed before returning.
  
 IO.read(""testfile"")
  
 →
  
 ""This is line one\nThis is line
  
 two\nThis is line three\nAnd so 
  
 on...\n""
  
 IO.read(""testfile"", 20)
  
 →
  
 ""This is line one\nThi""
  
 IO.read(""testfile"", 20, 10)
  
 →
  
 ""ne one\nThis is line ""
  
 readlines
  
 IO.readlines(
  portname
 ,
  separator
 =
 $/
  )
  →
  array
  
 Reads the entire file specified by
  portname
  as individual lines, and returns those lines
  
 in an array. Lines are separated by
  separator
 .
  
 a = IO.readlines(""testfile"")
  
 a[0]
  
 →
  
 ""This is line one\n""",NA
I,"STDOUT << ""Hello "" << ""world!\n""
  
 produces:
  
 Hello world!
  
 binmode 
  
 io
 .binmode
  →
  io
  
 Puts
  io
  into binary mode. This is useful only in MS-DOS/Windows environments. Once
  
 a stream is in binary mode, it cannot be reset to nonbinary mode.
  
 clone
  
 io
 .clone
  →
  io 
 Creates a new I/O stream, copying all the attributes of
  io
 . The file position is shared
  
 as well, so reading from the clone will alter the file position of the original, and vice
  
 versa.
  
 close
  
 io
 .close
  →
  nil 
 Closes
  io
  and flushes any pending writes to the operating system. The stream is 
 unavail-
  
 able for any further data operations; an
  IOError
  is raised if such an attempt is made.
  
 I/O streams are automatically closed when they are claimed by the garbage collector.
  
 close_read
  
 io
 .close_read
  →
  nil
  
 Closes the read end of a duplex I/O stream (i.e., one that contains both a read and a
  
 write stream, such as a pipe). Will raise an
  IOError
  if the stream is not duplexed.
  
 f = IO.popen(""/bin/sh"",""r+"")
  
 f.close_read
  
 f.readlines
  
 produces:
  
 prog.rb:3:in `readlines': not opened for reading (IOError)
  
 from prog.rb:3
  
 Prepared exclusively for Yeganefar",NA
I,"and returns
  false
  otherwise.
  
 f = File.new(""testfile"")
  
 f.close
  
 →
  
 nil
  
 f.closed?
  
 →
  
 true
  
 f = IO.popen(""/bin/sh"",""r+"")
  
  
 f.close_write
  
 →
  
 nil
  
 f.closed?
  
 →
  
 false
  
 f.close_read
  
 →
  
 nil
  
 f.closed?
  
 →
  
 true
  
 each
  
 io
 .each(
  separator
 =
 $/
  ) {
 | line | block
  }
  →
  io 
 Executes the block for every line in
  io
 , where lines are separated by
  separator
 .
  io
  
 must
  
 be opened for reading or an
  IOerror
  will be raised.
  
 f = File.new(""testfile"") 
  
 f.each {|line| puts ""#{f.lineno}: #{line}"" }
  
 produces:
  
 1: This is line one 
  
 2: This is line two 
  
 3: This is line three 
  
 4: And so on...
  
 each_byte
  
 io
 .each_byte {
 | byte | block
  }
  →
  nil
  
 Calls the given block once for each byte (a
  Fixnum
  in the range 0 to 255) in
  io
 , 
 passing
  
 the byte as an argument. The stream must be opened for reading or an
  IOerror
  will be 
 raised.
  
 f = File.new(""testfile"") 
  
 checksum = 0
  
 f.each_byte {|x| checksum ^= x }
  
 →
  
 #<File:testfile>
  
 checksum
  
 12
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
I,"Provides a mechanism for issuing low-level commands to control or query file-
 oriented
  
 I/O streams. Commands (which are integers), arguments, and the result are platform 
 dependent. If
  arg
  is a number, its value is passed directly. If it is a string, it is inter-
 preted as a binary sequence of bytes. On Unix platforms, see
  fcntl(2)
  for details. The
  
 Fcntl
  module provides symbolic names for the first argument (see page
  656
 ). Not 
 implemented on all platforms.
  
 fileno
  
 Returns an integer representing the numeric file descriptor for
  io
 .
  
 io
 .fileno
  →
  int
  
  
  
 STDIN.fileno
  
 →
  
 0
  
 STDOUT.fileno
  
 →
  
 1
  
 flush
  
 io
 .flush
  →
  io 
 Flushes any buffered data within
  io
  to the underlying operating system (note that this
  
 is Ruby internal buffering only; the OS may buffer the data as well).
  
 STDOUT.print ""no newline"" 
  
 STDOUT.flush
  
 produces:
  
 no newline
  
 fsync 
 1.8
  
  
 io
 .fsync
  →
  0 or
  nil 
 Immediately writes all buffered data in
  io
  to disk. Returns
  nil
  if the underlying oper-
  
 ating system does not support
  fsync(2)
 . Note that
  fsync
  differs from using
  IO
 #
 sync=
 . 
 The latter ensures that data is flushed from Ruby’s buffers but does not guarantee that 
 the underlying operating system actually writes it to disk.
  
 Prepared exclusively for Yeganefar",NA
I,"File.new(""testfile"").gets
  
 →
  
 ""This is line one\n""
  
  
 $_
  
 →
  
 ""This is line one\n""
  
  
 ioctl
  
 io
 .ioctl(
  cmd
 ,
  arg
  )
  →
  int
  
  
 Provides a mechanism for issuing low-level commands to control or query I/O 
 devices.
  
 The command (which is an integer), arguments, and results are platform dependent. If
  
 arg
  is a number, its value is passed directly. If it is a string, it is interpreted as a binary
  
 sequence of bytes. On Unix platforms, see
  ioctl(2)
  for details. Not implemented on
  
 all platforms.
  
 isatty
  
 io
 .isatty
  →
  true
  or
  false 
 Returns
  true
  if
  io
  is associated with a terminal device (tty), and returns
  false
  other-
  
 wise.
  
  
 File.new(""testfile"").isatty
  
 →
  
 false
  
 File.new(""/dev/tty"").isatty
  
 →
  
 true
  
 lineno
  
 io
 .lineno
  →
  int 
 Returns the current line number in
  io
 . The stream must be opened for reading.
  lineno
  
 counts the number of times
  gets
  is called, rather than the number of newlines encoun-
  
 tered. The two values will differ if
  gets
  is called with a separator other than newline.
  
 See also the
  $.
  variable.
  
 f = File.new(""testfile"")
  
 f.lineno
  
 →
  
 0
  
 f.gets
  
 ""This is line one\n""
  
 →
  
 f.lineno
  
 →
  
 1
  
 f.gets
  
 ""This is line two\n""
  
 →
  
 f.lineno
  
 →
  
 2
  
  
 Prepared exclusively for Yeganefar",NA
I,"Returns the process ID of a child process associated with
  io
 . This will be set by
  
 IO.popen
 .
  
 pipe = IO.popen(""-"")
  
 if pipe
  
 STDERR.puts ""In parent, child pid is #{pipe.pid}""
  
 else
  
 STDERR.puts ""In child, pid is #{$$}""
  
 end
  
 produces:
  
 In child, pid is 26884
  
 In parent, child pid is 26884
  
 pos
  
 Returns the current offset (in bytes) of
  io
 .
  
 io
 .pos
  →
  int
  
 f = File.new(""testfile"")
  
  
 f.pos
  
 →
  
 0
  
  
 f.gets
  
 →
  
 ""This is line one\n""
  
 f.pos
  
 →
  
 17
  
 pos=
  
 Seeks to the given position (in bytes) in
  io
 .
  
 io
 .pos =
  int
  →
  0
  
 f = File.new(""testfile"")
  
 f.pos = 17
  
 print
  
 f.gets
  
 →
  
 ""This is line two\n""
  
 io
 .print(
  ⟨
  obj
 =
 $_
  ⟩
 ∗
 )
  →
  nil
  
 Writes the given object(s) to
  io
 . The stream must be opened for writing. If the output
  
 record separator (
 $\
 ) is not
  nil
 , it will be appended to the output. If no arguments
  
 are given, prints
  $_
 . Objects that aren’t strings will be converted by calling their
  to_s 
 method. Returns
  nil
 .
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
I,"produces:
  
 AA
  
 puts
  
 io
 .puts(
  ⟨
  obj
  ⟩
 ∗
 )
  →
  nil
  
 Writes the given objects to
  io
  as with
  IO
 #
 print
 . Writes a newline after any that do
  
 not already end with a newline sequence. If called with an array argument, writes each
  
 element on a new line. If called without arguments, outputs a single newline.
  
 STDOUT.puts(""this"", ""is"", ""a"", ""test"")
  
 produces:
  
 this
  
 is
  
 a
  
 test
  
 read
  
 io
 .read(
  ⟨
  int
  ⟨
  , buffer
  ⟩ ⟩
  )
  →
  string
  or
  nil 
 Reads at most
  int
  bytes from the I/O stream or to the end of file if
  int
  is omitted. 
 Returns
  
 1.8
  
  
 nil
  if called at end of file. If
  buffer
  
 (a String) is provided, it is resized accordingly and
  
 input is read directly in to it.
  
 f = File.new(""testfile"")
  
 f.read(16)
  
 →
  
 ""This is line one""
  
 str = ""cat""
  
 f.read(10, str)
  
 →
  
 ""\nThis is l""
  
 str
  
 →
  
 ""\nThis is l""
  
 readchar 
  
 io
 .readchar
  →
  int
  
 Reads a character as with
  IO
 #
 getc
 , but raises an
  EOFError
  on end of file.
  
 readline
  
 io
 .readline(
  separator
 =
 $/
  )
  →
  string
  
 Reads a line as with
  IO
 #
 gets
 , but raises an
  EOFError
  on end of file.
  
  
 Prepared exclusively for Yeganefar",NA
I,"f2 = File.new(""testfile"")
  
  
 f2.readlines[0]
  
 →
  
 ""This is line one\n""
  
  
 f2.reopen(f1)
  
 →
  
 #<File:testfile>
  
 f2.readlines[0]
  
 →
  
 ""This is line one\n""
  
 rewind
  
 Positions
  io
  to the beginning of input, resetting
  lineno
  to zero.
  
 io
 .rewind
  →
  0
  
 f = File.new(""testfile"")
  
  
 f.readline
  
 →
  
 ""This is line one\n""
  
 f.rewind
  
 →
  
 0
  
 f.lineno
  
 →
  
 0
  
 f.readline
  
 →
  
 ""This is line one\n""
  
 seek
  
  
 io
 .seek(
  int
 ,
  whence
 =
 SEEK_SET
  )
  →
  0 
 Seeks to a given offset
  int
  in the stream according to the value of
  whence
 .
  
  
 IO::SEEK_CUR
  
 Seeks to
  int
  plus current position.
  
 IO::SEEK_END
  
 Seeks to
  int
  plus end of stream (you probably want a negative 
 value
  
 for
  int
 ).
  
 IO::SEEK_SET
  
 Seeks to the absolute location given by
  int
 .
  
 f = File.new(""testfile"")
  
  
 f.seek(-13, IO::SEEK_END)
  
 →
  
 0
  
  
  
 f.readline
  
 →
  
 ""And so on...\n""
  
 stat
  
 Returns status information for
  io
  as an object of type
  File::Stat
 .
  
 io
 .stat
  →
  stat
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
I,"Sets the “sync mode” to
  true
  or
  false
 . When sync mode is true, all output is immedi-
  
 ately flushed to the underlying operating system and is not buffered internally. Returns
  
 the new state. See also
  IO
 #
 fsync
 .
  
 f = File.new(""testfile"")
  
 f.sync = true
  
 sysread
  
  
 1.8 
 Reads
  int
  bytes from
  io
  using a low-level read and returns them as a string. If
  buffer
  (a 
  
  
 io
 .sysread(
  int
  ⟨
  ,
  buffer
  ⟩
  )
  →
  string
  
 String) is provided, input is read directly in to it. Do not mix with other methods that
  
 read from
  io
 , or you may get unpredictable results. Raises
  SystemCallError
  on error
  
 and
  EOFError
  at end of file.
  
 f = File.new(""testfile"")
  
 f.sysread(16)
  
 →
  
 ""This is line one""
  
 str = ""cat""
  
 f.sysread(10, str)
  
 →
  
 ""\nThis is l""
  
 str
  
 →
  
 ""\nThis is l""
  
 sysseek
  
  
 1.8 
 Seeks to a given
  offset
  in the stream according to the value of
  whence
  (see
  IO
 #
 seek
  for 
  
  
 io
 .sysseek(
  offset
 ,
  whence
 =
 SEEK_SET
  )
  →
  int
  
 values of
  whence
 ). Returns the new offset into the file.
  
 f = File.new(""testfile"")
  
 f.sysseek(-13, IO::SEEK_END)
  
 →
  
 53
  
 f.sysread(10)
  
 →
  
 ""And so on.""
  
 syswrite
  
 io
 .syswrite(
  string
  )
  →
  int
  
 Writes the given string to
  io
  using a low-level write. Returns the number of bytes writ-
  
 ten. Do not mix with other methods that write to
  io
 , or you may get unpredictable
  
 results. Raises
  SystemCallError
  on error.
  
 Prepared exclusively for Yeganefar",NA
I,"Synonym for
  IO
 #
 isatty
 .
  
 ungetc
  
 io
 .ungetc(
  int
  )
  →
  nil
  
  
 Pushes back one character onto
  io
 , such that a subsequent buffered read will return it.
  
 Only one character may be pushed back before a subsequent read operation (that is,
  
 you will be able to read only the last of several characters that have been pushed back).
  
 Has no effect with unbuffered reads (such as
  IO
 #
 sysread
 ).
  
  
 f = File.new(""testfile"")
  
 →
  
 #<File:testfile>
  
 c = f.getc
  
 →
  
 84
  
 f.ungetc(c)
  
 →
  
 nil
  
 f.getc
  
 →
  
 84
  
 write
  
 io
 .write(
  string
  )
  →
  int 
 Writes the given string to
  io
 . The stream must be opened for writing. If the argument
  
 is not a string, it will be converted to a string using
  to_s
 . Returns the number of bytes
  
 written.
  
 count = STDOUT.write( ""This is a test\n"" )
  
 puts ""That was #{count} bytes of data""
  
 produces:
  
 This is a test
  
 That was 15 bytes of data
  
 Prepared exclusively for Yeganefar",NA
 Kernel,"The
  Kernel
  module is included by class
  Object
 , so its methods are available in every 
 Ruby object. The
  Kernel
  instance methods are documented in class
  Object
  beginning 
 on page
  546
 . This section documents the module methods. These methods are called 
 without a receiver and thus can be called in functional form.
  
 Module methods
  
 Array
  
 Array(
  arg
  )
  →
  array 
 Returns
  arg
  as an
  Array
 . First tries to call
  arg
 .to_ary
 , then
  arg
 .to_a
 . If both fail,
  
 creates a single element array containing
  arg
  (unless
  arg
  is
  nil
 ).
  
  
 Array(1..5)
  
 →
  
 [1, 2, 3, 4, 5]
  
 el
  
 Float
  
 Float(
  arg
  )
  →
  float
  
 er
 n
  
 .",NA
K,"Returns
  arg
  converted to a float. Numeric types are converted directly, the rest are
  
 .
  
  
 converted using
  arg
 .to_f. As of Ruby 1.8,
  
 converting
  nil
  generates a
  TypeError
 .
  
  
 Float(1)
  
 →
  
 1.0
  
 Float(""123.456"")
  
 →
  
 123.456
  
 Integer
  
 Integer(
  arg
  )
  →
  int
  
  
 Converts
  arg
  to a
  Fixnum
  or
  Bignum
 . Numeric types are converted directly (floating-
 point numbers are truncated). If
  arg
  is a
  String
 , leading radix indicators (
 0
 ,
  0b
 , and
  0x
 ) 
 are honored. Others are converted using
  to_int
  and
  to_i
 . This behavior is different from 
 that of
  String
 #
 to_i
 .
  
 String
  
 Integer(123.999)
  
 →
  
 123
  
 String(
  arg
  )
  →
  string
  
 Integer(""0x1a"")
  
 26
  
 →
  
 Integer(Time.new)
  
 →
  
 1093577888
  
 Integer(nil)
  
 0
  
 →
  
 Converts
  arg
  to a
  String
  by calling its
  to_s
  method.
  
 String(self)
  
 →
  
 ""main""
  
  
 String(self.class)
  
 →
  
 ""Object""
  
 String(123456)
  
 ""123456""
  
 →
  
 ` (backquote)
  
  
  
 `
 cmd
  ` returns
 string
  
 Returns the standard output of running
  cmd
  in a subshell. The built-in syntax
  %x{...} 
 described on page
  83
  uses this method. Sets
  $?
  to the process status.
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 at_exit { puts ""cruel world"" } 
  
 do_at_exit(""goodbye "") 
  
 exit
  
 produces:
  
 goodbye cruel world
  
 autoload
  
 autoload(
  name
 ,
  file_name
  )
  →
  nil
  
 Registers
  file_name
  to be loaded (using
  Kernel.require
 ) the first time that the module
  
 name
  (which may be a
  String
  or a symbol) is accessed.
  
 autoload(:MyModule, ""/usr/local/lib/modules/my_module.rb"")
  
  
 1.8 
 Prior to Ruby 1.8, the
  name
  parameter was assumed to be in the top-level namespace. In 
 Ruby 1.8, the new method
  Module.autoload
  lets you define namespace-specific autoload hooks. 
 In the following code, Ruby 1.6 will load
  xxx.rb
  on references to 
 ::XXX
  whereas Ruby 1.8 will 
 autoload on references to
  X::XXX
 .
  
 module X 
  
 autoload :XXX, ""xxx.rb"" 
  
 end
  
 Note that
  xxx.rb
  should define a class in the correct namespace. That is, in this exam-ple
  
 xxx.rb
  should contain
  
 class X::XXX 
  
 # ...
  
 end",NA
K,"block_given?
  
 block_given?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  yield
  would execute a block in the current context.
  
 def try 
  
 if block_given?
  
   
 yield 
  
 else 
  
   
 ""no block"" 
  
 end 
  
 end
  
  
 try
  
 →
  
 ""no block""
  
 try { ""hello"" }
  
 →
  
 ""hello""
  
 try do ""hello"" end
  
 →
  
 ""hello""
  
 callcc
  
 callcc {
 | cont| block
  }
  →
  obj 
 Generates a
  Continuation
  object, which it passes to the associated block. Performing
  
 a
  cont
 .call
  will cause the
  callcc
  to return (as will falling through the end of the block). 
 The value returned by the
  callcc
  is the value of the block or the value passed to 
 cont
 .call
 . See
  Continuation
  on page
  427
  for more details. Also see
  Kernel.throw 
 for an 
 alternative mechanism for unwinding a call stack.
  
 caller
  
 caller(
  ⟨
  int
  ⟩
  )
  →
  array
  
 Returns the current execution stack—an array containing strings in the form
  file:line
  
 or 
 file:line: in ‘method’
 . The optional
  int
  parameter determines the number of initial 
 stack entries to omit from the result.
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 catch
  executes its block. If a
  throw
  is encountered, Ruby searches up its stack for
  
 a
  catch
  block with a tag corresponding to the
  throw
 ’s
  symbol
 . If found, that block
  
 is terminated, and
  catch
  returns the value given to
  throw
 . If
  throw
  is not called, the
  
 block terminates normally, and the value of
  catch
  is the value of the last expression 
 evaluated.
  catch
  expressions may be nested, and the
  throw
  call need not be in lexical 
 scope.
  
 def routine(n) 
  
 puts n 
  
 throw :done if n <= 0 
  
 routine(n-1) 
  
 end 
  
 catch(:done) { routine(4) }
  
 produces:
  
 4 
  
 3 
  
 2 
  
 1 
  
 0
  
 chomp
  
 chomp(
  ⟨
  rs
  ⟩
  )
  →
  $_ or
  string
  
 Equivalent to
  $_ = $_.chomp(
 rs
 )
 , except no assignment is made if
  chomp
  doesn’t change
  
 $_
 . See
  String
 #
 chomp
  on page
  589
 .
  
 $_ = ""now\n""
  
  
 chomp
  
 →
  
 ""now""
  
  
  
 chomp ""ow""
  
 →
  
 ""n""
  
 chomp ""xxx""
  
 →
  
 ""n""
  
 $_
  
 →
  
 ""n""
  
 chomp
 !
  
 Equivalent to
  $_.chomp!(
 rs
 )
 . See
  String
 #
 chomp!
  
 chomp!(
  ⟨
  rs
  ⟩
  )
  →
  $_ or
  nil
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
K,"$_ = a
  
 = ""now\r\n""
  
 chop!
  
 →
  
 ""now""
  
 chop!
  
 →
  
 ""no""
  
 chop!
  
 →
  
 ""n""
  
 chop!
  
 →
  
 """"
  
 chop!
  
 →
  
 nil
  
 $_
  
 →
  
 """"
  
 a
  
 →
  
 """"
  
 eval
  
  
 eval(
  string
  ⟨
  ,
  binding
  ⟨
  , file
  ⟨
  , line
  ⟩ ⟩ ⟩
 )
  →
  obj
  
  
 Evaluates the Ruby expression(s) in
  string
 . If
  binding
  is given, the evaluation is per-
  
 formed in its context. The binding may be a
  Binding
  object or a
  Proc
  object. If the
  
 optional
  file
  and
  line
  parameters are present, they will be used when reporting syntax
  
 errors.
  
 def get_binding(str)
  
 return binding
  
 end
  
 str = ""hello""
  
 1.8
  
  
 eval ""str + ' Fred'""
  
 →
  
 ""hello Fred""
  
 eval ""str + ' Fred'"", get_binding(""bye"")
  
 →
  
 ""bye Fred""
  
 As of Ruby 1.8,
  
 local variables assigned within an
  eval
  are available after the
  eval
  
 only if they were defined at the outer scope before the
  eval
  executed. In this way
  eval
  
 has the same scoping rules as blocks.
  
 a = 1
  
 eval ""a = 98; b = 99""
  
 puts a
  
 puts b
  
 Prepared exclusively for Yeganefar",NA
K,"used as the
  argv[0]
  value, which may show up in process listings. In MSDOS envi-
 ronments, the command is executed in a subshell; otherwise, one of the
  exec(2)
  sys-
 tem calls is used, so the running command may inherit some of the environment of 
 the original program (including open file descriptors). Raises
  SystemCallError
  if the 
 command
  couldn’t execute (typically
  Errno::ENOENT
 ).
  
 exec ""echo *"" 
  
 # echoes list of files in current directory # never get here
  
 exec ""echo"", ""*"" 
  
 # echoes an asterisk 
  
 # never get here
  
 exit
  
 exit(
  true
  |
  false
  |
  status
 =1 )
  
 1.8
  
  
 Initiates the termination of the Ruby script. If called in the scope of an exception han-
  
 dler, raises a
  SystemExit
  exception. This exception may be caught. Otherwise exits the 
 process using
  exit(2)
 . The optional parameter is used to return a status code to the 
 invoking environment. With an argument of
  true
 , exits with a status of zero. With
  
 1.8
  
  
 an argument that is false (or no argument), exits with a status of 1, otherwise exits with
  
 the given status. Note
  
 that the default exit value has changed from –1 to +1 in Ruby
  
 1.8.
  
 fork { exit 99 } 
  
 Process.wait 
  
 puts ""Child exits with status: #{$?.exitstatus}"" 
  
 begin 
  
   
 exit 
  
   
 puts ""never get here"" 
  
 rescue SystemExit 
  
   
 puts ""rescued a SystemExit exception"" 
  
 end 
  
 puts ""after begin block""
  
 Prepared exclusively for Yeganefar",NA
K,"fail
  
 fail
   
 fail(
  message
  ) 
  
 fail(
  exception
  ⟨
  ,
  message
  ⟨
  , array
  ⟩ ⟩
  ) 
  
 Synonym for
  Kernel.raise
 .
  
 fork
  
 fork
  ⟨
  {
  block
  }
  ⟩ →
  int
  or
  nil
  
 Creates a subprocess. If a block is specified, that block is run in the subprocess, and 
 the subprocess terminates with a status of zero. Otherwise, the
  fork
  call returns twice, 
 once in the parent, returning the process ID of the child, and once in the child, 
 returning
  nil
 . The child process can exit using
  Kernel.exit!
  to avoid running any
  at_exit
  
 func-tions. The parent process should use
  Process.wait
  to collect the termination 
 statuses of its children or use
  Process.detach
  to register disinterest in their status; 
 otherwise, the operating system may accumulate zombie processes.
  
 fork do 
  
 3.times {|i| puts ""Child: #{i}"" } 
  
 end 
  
 3.times {|i| puts ""Parent: #{i}"" } 
  
 Process.wait
  
 produces:
  
 Child: 0 
  
 Parent: 0 
  
 Child: 1 
  
 Parent: 1 
  
 Child: 2 
  
 Parent: 2
  
 Prepared exclusively for Yeganefar",NA
K,"This is line three
  
 And so on...
  
 The style of programming using
  $_
  as an implicit parameter is gradually losing favor
  
 in the Ruby community.
  
 global_variables
  
 global_variables
  →
  array
  
 Returns an array of the names of global variables.
  
 global_variables.grep /std/
  
 →
  
 [""$stdout"", ""$stdin"", ""$stderr""]
  
 gsub
  
 gsub(
  pattern
 ,
  replacement
  )
  →
  string 
 gsub(
  pattern
  ) {
  block
  }
  →
  string
  
 Equivalent to
  $_.gsub(...)
 , except that
  $_
  will be updated if substitution occurs.
  
 $_ = ""quick brown fox""
  
  
 gsub /[aeiou]/, '*'
  
 →
  
 ""q**ck br*wn f*x""
  
 $_
  
 →
  
 ""q**ck br*wn f*x""
  
 gsub!
  
 Equivalent to
  $_.gsub!(...)
 .
  
 gsub!(
  pattern
 ,
  replacement
  )
  →
  string
  or
  nil 
 gsub!(
  pattern
  ) {
  block
  }
  →
  string
  or
  nil
  
  
 $_ = ""quick brown fox""
  
 gsub! /cat/, '*'
  
 →
  
 nil
  
 ""quick brown fox""
  
 $_
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 the subprocess, the
  open
  call returns
  nil
 . If the command is not
  ""-""
 , the subprocess runs 
 the command. If a block is associated with an
  open(""|-"")
  call, that block will be run 
 twice—once in the parent and once in the child. The block parameter will be an 
 IO
  
 object in the parent and
  nil
  in the child. The parent’s
  IO
  object will be connected to the 
 child’s
  STDIN
  and
  STDOUT
 . The subprocess will be terminated at the end of the block.
  
 open(""testfile"") do |f| 
  
 print f.gets 
  
 end
  
 produces:
  
 This is line one
  
 Open a subprocess and read its output.
  
 cmd = open(""|date"") 
  
 print cmd.gets 
  
 cmd.close
  
 produces:
  
 Thu Aug 26 22:38:10 CDT 2004
  
 Open a subprocess running the same Ruby program.
  
 f = open(""|-"", ""w+"") 
  
 if f.nil?
  
 puts ""in Child"" 
  
 exit 
  
 else 
  
 puts ""Got: #{f.gets}"" 
  
 end
  
 Prepared exclusively for Yeganefar",NA
K,"S = Struct.new(:name, :state) 
  
 s = S['dave', 'TX'] 
  
 p s
  
 produces:
  
 #<struct S name=""dave"", state=""TX"">
  
 print
  
 Prints each object in turn to
  STDOUT
 .
  
 print(
  ⟨
  obj
  ⟩
 ∗
 )
  →
  nil
  
 1.8
  
  
 If the output field separator (
 $,
 ) is not
  nil
 , its
  
 contents will appear between each field. If the output record separator (
 $\
 ) is not
  nil
 , it 
 will be appended to the output. If no arguments are given, prints
  $_
 . Objects that 
 aren’t strings will be converted by calling their
  to_s
  method.
  
 print ""cat"", [1,2,3], 99, ""\n"" 
  
 $, = "", "" 
  
 $\ = ""\n"" 
  
 print ""cat"", [1,2,3], 99
  
 produces:
  
 cat12399 
  
 cat, 1, 2, 3, 99
  
 printf
  
 printf(
  io
 ,
  format
  ⟨
  ,
  obj
  ⟩
 ∗
 )
  →
  nil 
 printf(
  format
  ⟨
  ,
  obj
  ⟩
 ∗
 )
  →
  nil
  
 Equivalent to
  
 io.
 write sprintf(
 format, obj
  ...)
  
 or
  
 STDOUT.write sprintf(
 format, obj
  ...)
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 raise(
  message
  )
  
 raise(
  exception
  ⟨
  ,
  message
  ⟨
  , array
  ⟩ ⟩
  )
  
 With no arguments, raises the exception in
  $!
  or raises a
  RuntimeError
  if
  $!
  is
  nil
 .
  
 With a single
  String
  argument, raises a
  RuntimeError
  with the string as a message. 
 Otherwise, the first parameter should be the name of an
  Exception
  class (or an object 
 that returns an
  Exception
  when sent
  exception
 ). The optional second parameter sets the 
 message associated with the exception, and the third parameter is an array of call-
 back information. Exceptions are caught by the
  rescue
  clause of
  begin...end
  blocks.
  
 raise ""Failed to create socket"" 
  
 raise ArgumentError, ""No parameters"", caller
  
 rand
  
 rand(
  max
 =0 )
  →
  number 
 Converts
  max
  to an integer using
  max
 1
  = max
 .to_i.abs
 . If the result is zero, returns
  
 a pseudorandom floating-point number greater than or equal to 0.0 and less than 1.0. 
 Otherwise, returns a pseudorandom integer greater than or equal to zero and less than 
 max
 1
 .
  Kernel.srand
  may be used to ensure repeatable sequences of random num-bers 
 between different runs of the program. Ruby currently uses a modified Mersenne 
 Twister with a period of
  2
 19937
 − 1
 .
  
 srand 1234
  
 →
  
 0
  
 [ rand,
  
 rand ]
  
 [0.191519450163469, 0.49766366626136]
  
 →
  
 [ rand(10), rand(1000) ]
  
 →
  
 [6, 817]
  
 srand 1234
  
 →
  
 1234
  
 [ rand,
  
 rand ]
  
 →
  
 [0.191519450163469, 0.49766366626136]
  
 readline
  
  
 readline(
  ⟨
  separator
 =
 $/
  ⟩
  )
  →
  string
  
 Equivalent to
  Kernel.gets
 , except
  readline
  raises
  EOFError
  at end of file.
  
 Prepared exclusively for Yeganefar",NA
K,"require
 .
  
 SCRIPT_LINES__ = {} 
  
 require 'code/scriptlines' 
  
 puts ""Files: #{SCRIPT_LINES__.keys.join(', ')}"" 
  
 SCRIPT_LINES__['./code/scriptlines.rb'].each do |line| 
  
 puts ""Source: #{line}"" 
  
 end
  
 produces:
  
 3/8 
  
 Files: ./code/scriptlines.rb, /Users/dave/ruby1.8/lib/ruby/1.8/rational.rb Source: require 'rational' 
  
 Source: 
  
 Source: puts Rational(1,2)*Rational(3,4)
  
 scan
  
 scan(
  pattern
  )
  →
  array 
  
 scan(
  pattern
  ) {
  block
  }
  →
  $_
  
  
 Equivalent to calling
  $_.scan
 . See
  String
 #
 scan
  on page
  596
 .
  
 select
  
 select(
  read_array
  ⟨
  ,
  write_array
  ⟨
  , error_array
  ⟨
  , timeout
  ⟩ ⟩ ⟩
  )
  →
  array
  or
  nil
  
 Performs a low-level
  select
  call, which waits for data to become available from 
 input/output devices. The first three parameters are arrays of
  IO
  objects or
  nil
 . The last 
 is a timeout in seconds, which should be an
  Integer
  or a
  Float
 . The call waits
  
 1. 
  
 2.
  
 Or whatever the default shared library extension is on the current platform.
  
 Although this name is not converted to an absolute path, so that
  require 'a';require './a'
  will
  
 load
  a.rb
  twice. This is arguably a bug.
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 an exception), and
  return
  (return from a Ruby method). Tracing is disabled within the 
 context of
  proc
 .
  
 See the example starting on page
  393
  for more information.
  
 sleep
  
 sleep(
  numeric
 =0 )
  →
  fixnum 
 Suspends the current thread for
  numeric
  seconds (which may be a
  Float
  with 
 fractional
  
 seconds). Returns the actual number of seconds slept (rounded), which may be less 
 than that asked for if the thread was interrupted by a
  SIGALRM
  or if another thread 
 calls 
 Thread
 #
 run
 . An argument of zero causes
  sleep
  to sleep forever.
  
  
 Time.now
  
 →
  
 Thu Aug 26 22:38:10 CDT 2004
  
 sleep 1.9
  
 →
  
 2
  
 Time.now
  
 Thu Aug 26 22:38:12 CDT 2004
  
 →
  
 split
   
  
 split(
  ⟨
  pattern
  ⟨
  , limit
  ⟩ ⟩
  )
  →
  array
  
 Equivalent to
  $_.split(
 pattern
 ,
  limit
 )
 . See
  String
 #
 split
  on page
  598
 .
  
 sprintf
  
 sprintf(
  format_string
  ⟨
  ,
  arguments
  ⟩
 ∗
 )
  →
  string
  
 Returns the string resulting from applying
  format_string
  to any additional arguments. 
 Within the format string, any characters other than format sequences are copied to the 
 result.
  
 A format sequence consists of a percent sign, followed by optional flags, width, and 
 precision indicators, and then terminated with a field type character. The field type 
 controls how the corresponding
  sprintf
  argument is to be interpreted, and the flags
  
 Prepared exclusively for Yeganefar",NA
K,"ernel
  
 Seeds the pseudorandom number generator to the value of
  number
 .
 to_i.abs
 . If
  num-
  
 ber
  is omitted or zero, seeds the generator using a combination of the time, the 
 process ID, and a sequence number. (This is also the behavior if
  Kernel.rand
  is called 
 with-out previously calling
  srand
 , but without the sequence.) By setting the seed to a 
 known value, scripts that use
  rand
  can be made deterministic during testing. The 
 previous seed value is returned. Also see
  Kernel.rand
  on page
  506
 .
  
 sub
  
 sub(
  pattern
 ,
  replacement
  )
  →
  $_ 
  
 sub(
  pattern
  ) {
  block
  }
  →
  $_
  
  
 Equivalent to
  $_.sub(
 args
 )
 , except that
  $_
  will be updated if substitution occurs.
  
 sub!
  
 sub!(
  pattern
 ,
  replacement
  )
  →
  $_ or
  nil 
  
 sub!(
  pattern
  ) {
  block
  }
  →
  $_ or
  nil
  
  
 Equivalent to
  $_.sub!(
 args
 )
 .
  
 syscall
  
 syscall(
  fixnum
  ⟨
  ,
  args
  ⟩
 ∗
 )
  →
  int
  
 Calls the operating system function identified by
  fixnum
 . The arguments must be 
 either 
 String
  objects or
  Integer
  objects that fit within a native
  long
 . Up to nine 
 parameters may be passed. The function identified by
  fixnum
  is system dependent. On 
 some Unix systems, the numbers may be obtained from a header file called
  syscall.h
 .
  
 syscall 4, 1, ""hello\n"", 6 
 produces: 
  
 hello
  
 # '4' is write(2) on our system
  
 system
  
 system(
  command
  ⟨
  ,
  args
  ⟩
 ∗
 )
  →
  true
  or
  false
  
 Executes
  command
  in a subshell, returning
  true
  if the command was found and ran
  
 Prepared exclusively for Yeganefar",NA
K,"left-justify the result. If the asterisk is followed by a
  
 number and a dollar sign, use the indicated argument as
  
 the width.
  
 successfully,
  false
  otherwise. An error status is available in
  $?
 . The arguments are
  
 processed in the same way as for
  Kernel.exec
  on page
  500
 . Raises
  SystemCallError
  
 if the
  command
  couldn’t execute (typically
  Errno::ENOENT
 ).
  
 system(""echo *"") 
  
 system(""echo"", ""*"")
  
 produces:
  
 config.h main.rb
  
 *
  
 test
  
 test(
 cmd
 ,
  file1
  ⟨
  ,
  file2
  ⟩
  )
  →
  obj
  
 Uses the integer
  cmd
  to perform various tests on
  file1
  (Table
  27.9
  on page
  512
 ) or on
  
 file1
  and
  file2
  (Table
  27.10
 ).
  
 throw
  
 throw(
  symbol
  ⟨
  ,
  obj
  ⟩
  )
  
 Transfers control to the end of the active
  catch
  block waiting for
  symbol
 . Raises
  
 NameError
  if there is no
  catch
  block for the symbol. The optional second parame-
  
 ter supplies a return value for the
  catch
  block, which otherwise defaults to
  nil
 . For
  
 examples, see
  Kernel.catch
  on page
  498
 .
  
 Prepared exclusively for Yeganefar",NA
K,"o
  
 Convert argument as an octal number.
  
 p
  
 The value of
  argument.inspect
 .
  
 s
  
 Argument is a string to be substituted. If the format sequence contains a preci-
  
 sion, at most that many characters will be copied.
  
 u Treat argument as an unsigned decimal number.
  
 X Convert argument as a hexadecimal number using uppercase letters. Negative 
 numbers will be displayed with two leading periods (representing an infinite string of 
 leading
  FF
 s).
  
 Convert argument as a hexadecimal number. Negative numbers will be dis-x 
  
 played with two leading periods (representing an infinite string of leading
  FF
 s.)
  
 trace_var
  
 trace_var(
  symbol
 ,
  cmd
  )
  →
  nil 
 trace_var(
  symbol
  ) {
 | val | block
  }
  →
  nil
  
 Controls tracing of assignments to global variables. The parameter
  symbol
  identifies 
 the
  
 variable (as either a string name or a symbol identifier).
  cmd
  (which may be a string 
 or a
  Proc
  object) or the block is executed whenever the variable is assigned, and 
 receives the variable’s new value as a parameter. Only explicit assignments are 
 traced. Also see 
 Kernel.untrace_var
 .
  
 trace_var :$_, lambda {|v| puts ""$_ is now '#{v}'"" } 
  
 $_ = ""hello"" 
  
 sub(/ello/, ""i"") 
  
 $_ += "" Dave""
  
 produces:
  
 $_ is now 'hello' 
  
 $_ is now 'hi Dave'
  
 Prepared exclusively for Yeganefar",NA
K,"?M
  
 Last modification time for
  file1
  
 Time
  
 ?o
  
 True if
  file1
  exists and is owned by the caller’s effective UID
  
 true
  or
  false
  
 ?O
  
 True if
  file1
  exists and is owned by the caller’s real UID
  
 true
  or
  false
  
 ?p
  
 True if
  file1
  exists and is a fifo
  
 true
  or
  false
  
 ?r
  
 True if
  file1
  is readable by the effective UID/GID of the caller
  
 true
  or
  false
  
 ?R
  
 True if
  file1
  is readable by the real UID/GID of the caller
  
 true
  or
  false
  
 ?s
  
 If
  file1
  has nonzero size, return the size, otherwise return
  nil
  
 Integer or
  nil
  
 ?S
  
 True if
  file1
  exists and is a socket
  
 true
  or
  false
  
 ?u
  
 True if
  file1
  has the setuid bit set
  
 true
  or
  false
  
 ?w
  
 True if
  file1
  exists and is writable by the effective UID/ GID
  
 true
  or
  false
  
 ?W
  
 True if
  file1
  exists and is writable by the real UID/GID
  
 true
  or
  false
  
 ?x
  
 True if
  file1
  exists and is executable by the effective UID/GID
  
 true
  or
  false
  
 ?X
  
 True if
  file1
  exists and is executable by the real UID/GID
  
 true
  or
  false
  
 ?z
  
 True if
  file1
  exists and has a zero length
  
 true
  or
  false
  
 Table 27.10. File tests with two arguments
  
 Flag
  
 Description
  
 ?-
  
 ?= 
  
 ?< 
  
 ?>
  
 True if
  file1
  is a hard link to
  file2 
  
 True if the modification times of
  file1
  and
  file2
  are equal 
 True if the modification time of
  file1
  is prior to that of
  
 file2 
 True if the modification time of
  file1
  is after that of
  
 file2
  
  
 Prepared exclusively for Yeganefar",NA
K,Prepared exclusively for Yeganefar,NA
 Marshal,"The marshaling library converts collections of Ruby objects into a byte stream, allow-
 ing them to be stored outside the currently active script. This data may subsequently 
 be read and the original objects reconstituted. Marshaling is described starting on 
 page
  395
 . Also see the
  YAML
  library on page
  737
 .
  
 Marshaled data has major and minor version numbers stored along with the object 
 information. In normal use, marshaling can load only data written with the same 
 major version number and an equal or lower minor version number. If Ruby’s 
 “verbose” flag is set (normally using
  -d
 ,
  -v
 ,
  -w
 , or
  --verbose
 ), the major and minor 
 numbers must match exactly. Marshal versioning is independent of Ruby’s version 
 numbers. You can extract the version by reading the first two bytes of marshaled 
 data.
  
 str = Marshal.dump(""thing"")
  
 1.8
  
  
 RUBY_VERSION
  
 →
  
 ""1.8.2""",NA
M,"arshal
  
 str[0]
  
 →
  
 4
  
 str[1]
  
 →
  
 8
  
 Some objects cannot be dumped: if the objects to be dumped include bindings, proce-
  
 dure or method objects, instances of class
  IO
 , or singleton objects, or if you try to dump
  
 anonymous classes or 
 modules,
  
 a
  TypeError
  will be raised.
  
 If your class has special serialization needs (for example, if you want to serialize in 
 some specific format), or if it contains objects that would otherwise not be 
 serializable, you can implement your own serialization strategy. Prior to Ruby 1.8, 
 you defined the methods
  _dump
  and
  _load
 .
  
 1.8
  
  
 Ruby 1.8
  
 includes a more flexible interface to custom serialization using the instance
  
 methods
  marshal_dump
  and
  marshal_load
 : If an object to be marshaled responds to 
 marshal_dump
 , that method is called instead of
  _dump
 .
  marshal_dump
  can return an 
 object of any class (not just a String). A class that implements
  marshal_dump
  must also 
 implement
  marshal_load
 , which is called as an instance method of a newly allocated 
 object and passed the object originally created by
  marshal_load
 .
  
 The following code uses this new framework to store a
  Time
  object in the serialized 
 ver-sion of an object. When loaded, this object is passed to
  marshal_load
 , which 
 converts this time to a printable form, storing the result in an instance variable.
  
 class TimedDump 
  
 attr_reader :when_dumped
  
 def marshal_dump 
  
   
 Time.now 
  
 end 
  
 def marshal_load(when_dumped) 
  
   
 @when_dumped = when_dumped.strftime(""%I:%M%p"") 
  
 end 
  
 end",NA
M,"arshal
  
 Serializes
  obj
  and all descendent objects. If
  io
  is specified, the serialized data will be
  
 written to it; otherwise the data will be returned as a
  String
 . If
  limit
  is specified, the
  
 traversal of subobjects will be limited to that depth. If
  limit
  is negative, no checking 
 of
  
 depth will be performed.
  
 class Klass 
  
 def initialize(str) 
  
   
 @str = str 
  
 end 
  
 def say_hello 
  
   
 @str 
  
 end 
  
 end
  
 o = Klass.new(""hello\n"") 
  
 data = Marshal.dump(o) 
  
 obj = Marshal.load(data)
  
 load
  
 obj.say_hello
  
 →
  
 ""hello\n""
  
 load(
  from
  ⟨
  ,
  proc
  ⟩
  )
  →
  obj
  
 Returns the result of converting the serialized data in
  from
  into a Ruby object (possi-
 bly with associated subordinate objects).
  from
  may be either an instance of
  IO
  or an 
 object that responds to
  to_str
 . If
  proc
  is specified, it will be passed each object as it is 
 deserialized.
  
 restore
  
 restore(
  from
  ⟨
  ,
  proc
  ⟩
  )
  →
  obj
  
 A synonym for
  Marshal.load
 .
  
 Prepared exclusively for Yeganefar",NA
MatchData,"<
  
 Object
  
 M
 ATCH
 D
 ATA
  
 516
  
 All pattern matches set the special variable
  $~
  to a
  MatchData
  containing information
  
 about the match. The methods
  Regexp
 #
 match
  and
  Regexp
 #
 last_match
  also return a
  
 MatchData
  object. The object encapsulates all the results of a pattern match, results
  
 normally accessed through the special variables
  $&
 ,
  $'
 ,
  $`
 ,
  $1
 ,
  $2
 , and so on. Class
  
 Matchdata
  is also known as
  MatchingData
 .
  
 Instance methods
  
 [ ]
  
 match
 [
 i
 ]
  →
  obj 
  
 match
 [
 start
 ,
  length
 ]
  →
  array 
  
 match
 [
 range
 ]
  →
  array
  
 Match Reference—
 MatchData
  acts as an array, and may be accessed using the nor-
  
 mal array indexing techniques.
  match
 [0] is equivalent to the special variable
  $&
  and
  
 1.8
  
  
 returns the entire matched string.
  match
 [1],
  match
 [2], and so on, return the values of
  
 atchData
  
 the matched back references (portions of the pattern between parentheses). See also
  
 MatchData
 #
 select
  and
  MatchData
 #
 values_at
 .
  
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138."")",NA
M,"m[0]
  
 →
  
 ""HX1138""
  
 m[1, 2]
  
 →
  
 [""H"", ""X""]
  
 m[1..3]
  
 →
  
 [""H"", ""X"", ""113""]
  
 m[-3, 2]
  
 →
  
 [""X"", ""113""]
  
 begin
  
 match
 .begin(
  n
  )
  →
  int
  
  
 Returns the offset of the start of the
  n
 th element of the match array in the string.
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138."")
  
 m.begin(0)
  
 →
  
 1
  
 m.begin(2)
  
 →
  
 2
  
 captures
  
  
 1.8 
 Returns the array of all the matching groups. Compare to
  MatchData
 #
 to_a
 , which 
  
 match
 .captures
  →
  array
  
 returns both the complete matched string and all the matching groups.
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138."")
  
 m.captures
  
 →
  
 [""H"", ""X"", ""113"", ""8""]
  
 captures
  is useful when extracting parts of a match in an assignment.
  
 f1, f2, f3 = /(.)(.)(\d+)(\d)/.match(""THX1138."").captures
  
 f1
  
 →
  
 ""H""
  
 f2
  
 →
  
 ""X""
  
 f3
  
 →
  
 ""113""
  
  
 Prepared exclusively for Yeganefar",NA
M,"m.offset(4)
  
 →
  
 [6, 7]
  
 post_match
  
 match
 .post_match
  →
  string
  
  
 Returns the portion of the original string after the current match. Equivalent to the
  
 special variable
  $'
 .
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138: The Movie"")
  
 m.post_match
  
 →
  
 "": The Movie""
  
  
  
 pre_match
  
 match
 .pre_match
  →
  string
  
 Returns the portion of the original string before the current match. Equivalent to the
  
 special variable
  $`
 .
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138."")
  
  
 m.pre_match
  
 →
  
 ""T""
  
 select 
 1.8
  
  
  
 match
 .select {
 | val | block
  }
  →
  array 
 Returns an array containing all elements of
  match
  for which
  block
  is
  true
 .
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138: The Movie"")
  
  
 m.to_a
  
 →
  
 [""HX1138"", ""H"", ""X"", ""113"", ""8""]
  
 [""HX1138"", ""113""]
  
 m.select {|v| v =~ /\d\d/ }
  
 →
  
 size
  
 A synonym for
  MatchData
 #
 length
 .
  
 match
 .size
  →
  int
  
  
 Prepared exclusively for Yeganefar",NA
M,"atc
  
 matches.
  
 m = /(.)(.)(\d+)(\d)/.match(""THX1138: The Movie"")
  
 m.to_a
  
 →
  
 [""HX1138"", ""H"", ""X"", ""113"", ""8""]
  
 m.values_at(0, 2, -2)
  
 [""HX1138"", ""X"", ""113""]
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
 Math,"The
  Math
  module contains module methods for basic trigonometric and transcenden-
 tal functions. See class
  Float
  on page
  466
  for a list of constants that define Ruby’s 
 floating-point accuracy.
  
 Module constants
  
 E 
  
 PI
  
 Value of
  e
  (base of natural logarithms) 
  
 Value of
  π
  
 Module methods
  
 acos
  
 Math.acos(
  x
  )
  →
  float
  
  
 1.8
  
  
 Computes the arc cosine of
  x
 . Returns
  0..π
 .
  
 acosh
  
 Math.acosh(
  x
  )
  →
  float
  
  ath
  
 1.8
  
  
 Computes the inverse hyperbolic cosine of
  x
 .
  
 asin
  
 Math.asin(
  x
  )
  →
  float",NA
M,"1.8
  
  
 Computes the arc sine of
  x
 . Returns
  0..π
 .
  
 asinh
  
 Math.asinh(
  x
  )
  →
  float
  
  
 1.8
  
  
 Computes the inverse hyperbolic sine of
  x
 .
  
 atan
  
 Computes the arc tangent of
  x
 . Returns
  −
 π2
 ..
  π2
 .
  
 Math.atan(
  x
  )
  →
  float
  
  
 1.8
  
  
 atanh
  
 Math.atanh(
  x
  )
  →
  float
  
  
 1.8
  
  
 Computes the inverse hyperbolic tangent of
  x
 .
  
 atan2
  
 Math.atan2(
  y, x
  )
  →
  float
  
  
  
  
 Computes the arc tangent given
  y
  and
  x
 . Returns
  −π..π
 .
  
 cos
  
 Math.cos(
  x
  )
  →
  float
  
  
  
  
 Computes the cosine of
  x
  (expressed in radians). Returns
  −1..1
 .
  
 cosh
  
 Math.cosh(
  x
  )
  →
  float
  
  
 1.8
  
  
 Computes the hyperbolic cosine of
  x
  (expressed in radians).
  
  
 Prepared exclusively for Yeganefar",NA
M,"Returns a two-element array containing the normalized fraction (a
  Float
 ) and 
 exponent
  
 (a
  Fixnum
 ) of
  numeric
 .
  
 fraction, exponent = Math.frexp(1234)
  
 →
  
 [0.6025390625, 11]
  
 fraction * 2**exponent
  
 →
  
 1234.0
  
 hypot
  
 Math.hypot(
  x
 ,
  y
  )
  →
  float
  
  
 1.8
  
  
 Returns
  
 x
 2
 + y
 2
 , the hypotenuse of a right-angled triangle with sides
  x
  and
  y
 .
  
 Math.hypot(3, 4)
  
 →
  
 5.0
  
 ldexp
  
 Returns the value of
  float
  × 2
 integer
 .
  
 Math.ldexp(
  float
 ,
  integer
  )
  →
  
 float
  
  
 fraction, exponent = Math.frexp(1234)
  
  
 Math.ldexp(fraction, exponent)
  
 →
  
 1234.0
  
  
 log
  
  
  
 Math.log(
  numeric
  )
  →
  float
  
  
 Returns the natural logarithm of
  numeric
 .
  
  
  
 log10
   
  
 Math.log10(
  numeric
  )
  →
  float
  
 Returns the base 10 logarithm of
  numeric
 .
  
 sin
  
  
 Math.sin(
  numeric
  )
  →
  float 
 Computes the sine of
  numeric
  (expressed in radians). Returns
  −1..1
 .
  
  
 Prepared exclusively for Yeganefar",NA
M,"ath
  
 1.8
  
  
 Computes the hyperbolic tangent of
  numeric
  (expressed in radians).
  
  
 Prepared exclusively for Yeganefar",NA
Method,"<
  
 Object
  
 M
 ETHOD
  
 522
  
 Method objects are created by
  Object
 #
 method
 . They are associated with a particular
  
 object (not just with a class). They may be used to invoke the method within the object
  
 and as a block associated with an iterator. They may also be unbound from one object
  
 (creating an
  UnboundMethod
 ) and bound to another.
  
 def square(n)
  
 n*n 
  
 end
  
 meth
  
 = self.method(:square)
  
 →
  
 81
  
 meth.call(9)
  
 [ 1, 2, 3 ].collect(&meth)
  
 →
  
 [1, 4, 9]
  
 Instance methods
  
 [ ]
  
  
 meth
 [
  ⟨
  args
  ⟩
 ∗
 ]
  →
  object
  
  
  
 Synonym for
  Method.call
 .
  
  
 ethod
  
 == 
  
 1.8
  
  
 Returns
  true
  if
  meth
  is the same method as
  other
 .
  
 meth
 ==
  other
  →
  true
  or
  false",NA
M,"def fred()
  
 puts ""Hello""
  
 end
  
 alias bert fred
  
 →
  
 nil
  
 m1 = method(:fred)
  
 m2 = method(:bert)
  
 arity
  
 m1 == m2
  
 →
  
 true
  
 meth
 .arity
  →
  fixnum
  
 Returns an indication of the number of arguments accepted by a method. See Fig-
  
 ure
  27.2
  on the next page.
  
 call
  
 meth
 .call(
  ⟨
  args
  ⟩
 ∗
 )
  →
  object
  
 Invokes the
  meth
  with the specified arguments, returning the method’s return value.
  
 m = 12.method(""+"")
  
  
 m.call(3)
  
 →
  
 15
  
  
  
 m.call(20)
  
 →
  
 32
  
 eql?
  
 Returns
  true
  if
  meth
  is the same method as
  other
 .
  
 meth
 .eql?(
 other
 )
  →
  true
  or
  false
  
 «
  
 1.8
  
  
  
 Prepared exclusively for Yeganefar",NA
M,"ethod
  
  
 def fred() 
  
 puts ""Hello"" 
  
 end
  
 alias bert fred
  
 →
  
 nil
  
 m1 = method(:fred) 
  
 m2 = method(:bert)
  
 m1.eql?(m2)
  
 →
  
 false
  
  
 to_proc
  
  
 1.8 
 Returns a
  Proc
  object corresponding to this method. Because
  to_proc
  is called by the 
  
  
 meth
 .to_proc
  →
  prc
  
 interpreter when passing block arguments, method objects may be used following an 
 ampersand to pass a block to another method call. See the
  Thing
  example at the start 
 of this section.
  
 unbind 
 1.8
  
  
 meth
 .unbind
  →
  unbound_method 
 Dissociates
  meth
  from its current receiver. The resulting
  UnboundMethod
  can subse-
  
 quently be bound to a new object of the same class (see
  UnboundMethod
  on page
  630
 ).
  
 Prepared exclusively for Yeganefar",NA
Module,"<
  
 Object
  
 M
 ODULE
  
 524
  
 Subclasses: Class
  
 A
  Module
  is a collection of methods and constants. The methods in a module may be 
 instance methods or module methods. Instance methods appear as methods in a class 
 when the module is included; module methods do not. Conversely, module methods 
 may be called without creating an encapsulating object, and instance methods may 
 not. See also
  Module
 #
 module_function
  on page
  537
 .
  
 In the descriptions that follow, the parameter
  symbol
  refers to a symbol, which is either 
 a quoted string or a
  Symbol
  (such as
  :name
 ).
  
 module Mod 
  
 include Math 
  
 CONST = 1 
  
 def meth 
  
   
 # 
  
 ...
  
 end
  
 end
  
 →
  
 Module
  
 odule
  
 Mod.class
  
 Mod.constants
  
 →
  
 [""E"", ""CONST"", ""PI""]",NA
M,"Mod.instance_methods
  
 →
  
 [""meth""]
  
 Class methods
  
 constants
  
 Module.constants
  →
  array
  
 Returns an array of the names of all constants defined in the system. This list 
 includes
  
 the names of all modules and classes.
  
 p Module.constants.sort[1..5]
  
 produces:
  
 [""ARGV"", ""ArgumentError"", ""Array"", ""Bignum"", ""Binding""]
  
 nesting
  
 Module.nesting
  →
  array
  
 Returns the list of
  Modules
  nested at the point of call.
  
 module M1 
  
 module M2 
  
   
 $a = Module.nesting 
  
 end 
  
 end
  
 $a
  
 →
  
 [M1::M2, M1]
  
 $a[0].name
  
 ""M1::M2""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
M,"od
  
 Hierarchy Query—One module is considered
  greater than
  another if it is included in
  
 (or is a parent class of) the other module. The other operators are defined accordingly. 
 If there is no relationship between the modules, all operators return
  false
 .
  
 module Mixin 
  
 end
  
 module Parent 
  
 include Mixin 
  
 end
  
 module Unrelated 
  
 end
  
  
 Parent > Mixin
  
 →
  
 false
  
 Parent < Mixin
  
 →
  
 true
  
 Parent <= Parent
  
 →
  
 true
  
 Parent < Unrelated
  
 →
  
 nil
  
 Parent > Unrelated
  
 →
  
 nil
  
 <=>
  
 mod
  <=>
  other_mod
  → −1
 ,
  0
 ,
  +1 
 Comparison—Returns
  −1
  if
  mod
  includes
  other_mod
 ,
  0
  if
  mod
  is the same module as 
 other_mod
 , and
  +1
  if
  mod
  is included by
  other_mod
  or if
  mod
  has no relationship 
 with
  
 other_mod
 .
  
 ===
  
 mod
  ===
  obj
  →
  true
  or
  false 
 Case Equality—Returns
  true
  if
  obj
  is an instance of
  mod
  or one of
  mod
 ’s descendents.
  
 Of limited use for modules, but can be used in
  case
  statements to test objects by class.
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
 def doit 
  
  
 puts ""In Module A::B"" 
  
 end 
  
 module_function :doit
  
 end
  
 Other code can then include this module automatically.
  
 module A 
  
 autoload(:B, ""module_b"") 
  
 end
  
 A::B.doit 
  
 # autoloads ""module_b""
  
 produces:
  
 In Module A::B
  
 autoload?
  
  
 1.8 
 Returns the name of the file that will be autoloaded when the string or symbol
  name
  is 
  
 mod
 .autoload?(
  name
  )
  →
  file_name
  or
  nil
  
 referenced in the context of
  mod
 , or returns
  nil
  if there is no associated autoload.
  
 module A 
  
 autoload(:B, ""module_b"") 
  
 end
  
 A.autoload?(:B)
  
 →
  
 ""module_b""
  
 A.autoload?(:C)
  
 →
  
 nil
  
 class_eval
  
 mod
 .class_eval(
  string
  ⟨
  ,
  file_name
  ⟨
  , line_number
  ⟩ ⟩
  )
  →
  obj 
 mod
 .class_eval {
  block
  }
  →
  obj
  
 Synonym for
  Module.module_eval
 .
  
  
 Prepared exclusively for Yeganefar",NA
M,"Math.const_defined? ""PI""
  
 →
  
 true
  
  
 const_get
  
 mod
 .const_get(
  symbol
  )
  →
  obj
  
  
 Returns the value of the named constant in
  mod
 .
  
 Math.const_get :PI
  
 →
  
 3.14159265358979
  
 const_missing
  
  
 1.8 
 Invoked when a reference is made to an undefined constant in
  mod
 . It is passed a symbol 
  
  
 const_missing(
  symbol
  )
  →
  obj
  
  
 for the undefined constant and returns a value to be used for that constant. The 
 following code is very poor style. If a reference is made to an undefined constant, it 
 attempts to load a file whose name is the lowercase version of the constant (thus, 
 class
  Fred
  is assumed to be in file
  fred.rb
 ). If found, it returns the value of the loaded 
 class. It therefore implements a perverse kind of autoload facility.
  
 def Object.const_missing(name) 
  
 @looked_for ||= {} 
  
 str_name = name.to_s 
  
 raise ""Class not found: #{name}"" if @looked_for[str_name] @looked_for[str_name] 
 = 1 
  
 file = str_name.downcase 
  
 require file 
  
 klass = const_get(name) 
  
 return klass if klass 
  
 raise ""Class not found: #{name}"" 
  
 end
  
 Prepared exclusively for Yeganefar",NA
M,"end
  
 B.include?(A)
  
 →
  
 true
  
  
 C.include?(A)
  
 →
  
 true
  
 A.include?(A)
  
 →
  
 false
  
 included_modules
  
 mod
 .included_modules
  →
  array
  
 Returns the list of modules included in
  mod
 .
  
  
 module Mixin 
  
 end
  
 module Outer 
  
 include Mixin 
  
 end
  
 Mixin.included_modules
  
 →
  
 []
  
 Outer.included_modules
  
 →
  
 [Mixin]
  
 instance_method
  
  
 1.8 
 Returns an
  UnboundMethod
  representing the given instance method in
  mod
 . 
  
  
 mod
 .instance_method(
  symbol
  )
  →
  unbound_method
  
 class Interpreter 
  
 def do_a() print ""there, ""; end 
  
 def do_d() print ""Hello ""; 
  
 end 
  
 def do_e() print ""!\n""; 
  
 end 
  
 def do_v() print ""Dave""; 
  
 end
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
 defaults to
  false
  in versions of Ruby prior to January 2004.)
  
 module A 
  
 def method1() 
  
 end 
  
 end
  
 class B 
  
 def method2() 
  
 end 
  
 end
  
 class C < B 
  
 def method3() 
  
 end 
  
 end
  
 A.instance_methods 
  
 B.instance_methods(false) 
  
 C.instance_methods(false) 
  
 C.instance_methods(true).length
  
 method_defined?
  
 mod
 .method_defined?(
  symbol
  )
  →
  true
  or
  false
  
 Returns
  true
  if the named method is defined by
  mod
  (or its included modules and, if
  
 mod
  is a class, its ancestors). Public and protected methods are matched.
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
 1.8
  
  
 Evaluates the string or block in the context of
  mod
 . This can be used to add methods 
 to a class.
  module_eval
  returns the result of evaluating its argument. The optional
  
 file_name
  and
  line_number
  parameters set the text for error messages.
  
 class Thing 
  
 end 
  
 a = %q{def hello() ""Hello there!"" end} 
  
 Thing.module_eval(a) 
  
 puts Thing.new.hello() 
  
 Thing.module_eval(""invalid code"", ""dummy"", 123)
  
 produces:
  
 Hello there!
  
 dummy:123:in `module_eval': undefined local variable 
  
  
 or method `code' for Thing:Class
  
 name
  
 mod
 .name
  →
  string
  
 Returns the name of the module
  mod
 .
  
  
 mod
 .private_class_method(
  ⟨
  symbol
  ⟩
 +
 )
  →
  nil
  
 private_class_method
  
 Makes existing class methods private. Often used to hide the default constructor
  new
 .
  
 class SimpleSingleton 
  
 # Not thread safe 
  
 private_class_method :new 
  
 def SimpleSingleton.create(*args, &block) 
  
   
 @me = new(*args, &block) if ! @me 
  
   
 @me 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
M,"class B
  
 private 
  
 def method2() 
  
 end 
  
 end 
  
 class C < B 
  
 include A 
  
 def method3() 
  
 end 
  
 end
  
 A.method_defined? :method1
  
 →
  
 true
  
 C.private_method_defined? ""method1""
  
 false
  
 →
  
 C.private_method_defined? ""method2""
  
 →
  
 true
  
 C.method_defined? ""method2""
  
 false
  
 →
  
 protected_instance_methods
  
 1.8
  
  
 mod
 .protected_instance_methods(
  inc_super
 =
 true
  )
  →
  array 
 Returns a list of the protected instance methods defined in
  mod
 . If the optional 
 parame-
  
 ter is true, the methods of any ancestors are included. (The parameter defaults to
  false 
 in 
 versions of Ruby prior to January 2004.)
  
 protected_method_defined?
  mod
 .protected_method_defined?(
  symbol
  )
  →
  true
  or
  false
  
  
 1.8 
 Returns
  true
  if the named protected method is defined by
  mod
  (or its included modules
  
 and, if
  mod
  is a class, its ancestors).",NA
M,"od
  
 1.8
  
  
 mod
 .public_instance_methods(
  inc_super
 =
 true
  )
  →
  array 
 Returns a list of the public instance methods defined in
  mod
 . If the optional parameter
  
 is true, the methods of any ancestors are included. (The parameter defaults to
  false
  in 
 versions of Ruby prior to January 2004.)
  
 public_method_defined?
  
  
 1.8 
 Returns
  true
  if the named public method is defined by
  mod
  (or its included modules 
  
  
 mod
 .public_method_defined?(
  symbol
  )
  →
  true
  or
  false
  
 and, if
  mod
  is a class, its ancestors).
  
 module A 
  
 def method1() 
  
 end 
  
 end 
  
 class B 
  
 protected 
  
 def method2() 
  
 end 
  
 end 
  
 class C < B 
  
 include A 
  
 def method3() 
  
 end 
  
 end
  
 A.method_defined? :method1
  
 →
  
 true
  
 C.public_method_defined? ""method1""
  
 →
  
 true
  
 C.public_method_defined? ""method2""
  
 false
  
 →
  
 C.method_defined? ""method2""
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
 When this module is included in another, Ruby calls
  append_features
  in this module, 
 passing it the receiving module in
  other_mod
 . Ruby’s default implementation is to
  
 add the constants, methods, and module variables of this module to
  other_mod
  if this 
 module has not already been added to
  other_mod
  or one of its ancestors. Prior to 
 Ruby 1.8, user code often redefined
  append_features
 , added its own functionality, and 
 then
  
 1.8
  
  
 invoked
  super
  to handle the real include. In Ruby 1.8, you should instead implement
  
 the method
  Module
 #
 included
 .
  
 See also
  Module
 #
 include
  on page
  535
 .
  
 attr
  
 attr(
  symbol
 ,
  writable
 =
 false
  )
  →
  nil 
 Defines a named attribute for this module, where the name is
  symbol.
 id2name
 , cre-
  
 ating an instance variable (
 @name
 ) and a corresponding access method to read it. If 
 the optional
  writable
  argument is
  true
 , also creates a method called
  name=
  to set the 
 attribute.
  
 module Mod 
  
 attr :size, true 
  
 end
  
 is equivalent to:
  
 module Mod 
  
 def size 
  
   
 @size 
  
 end 
  
 def size=(val) 
  
   
 @size = val 
  
 end 
  
 end",NA
M,"private. (This is why we resort to the
  send
  hack in this example.)
  
 class A 
  
 def fred 
  
   
 puts ""In Fred"" 
  
 end 
  
 def create_method(name, &block) 
  
   
 self.class.send(:define_method, name, &block) 
  
 end 
  
 define_method(:wilma) { puts ""Charge it!"" } 
  
 end 
  
 class B < A 
  
 define_method(:barney, instance_method(:fred)) 
  
 end 
  
 b = B.new 
  
 b.barney 
  
 b.wilma 
  
 b.create_method(:betty) { p self } 
  
 b.betty
  
 produces:
  
 In Fred 
  
 Charge it!
  
 #<B:0x1c9134>
  
 Prepared exclusively for Yeganefar",NA
M,"o
  
 1.8
  
  
 Callback invoked whenever the receiver is used to extend an object. The object is passed
  
 as a parameter. This should be used in preference to
  Module
 #
 extend_object
  if your code 
 wants to perform some action when a module is used to extend an object.
  
 module A 
  
 def A.extended(obj) 
  
   
 puts ""#{self} extending '#{obj}'"" 
  
 end 
  
 end 
  
 ""cat"".extend(A)
  
 produces:
  
 A extending 'cat'
  
 include
  
 include(
  ⟨
  other_mod
  ⟩
 +
 )
  →
  mod
  
 Invokes
  Module.append_features
  (documented on page
  533
 ) on each parameter (in 
 reverse order). Equivalent to the following code.
  
 def include(*modules) 
  
 modules.reverse_each do |mod| 
  
   
 mod.append_features(self) 
  
   
 mod.included(self) 
  
 end 
  
 end
  
 included
  
 included(
  other_mod
  )
  
 1.8
  
  
 Callback invoked whenever the receiver is included in another module or class. This
  
  
 Prepared exclusively for Yeganefar",NA
M,"end
  
 module Chatty 
  
 def two() 
  
 end 
  
 end
  
 produces:
  
 Adding one 
  
 Adding two
  
 method_removed
  
 method_removed(
  symbol
  )
  
 1.8
  
  
 Invoked as a callback whenever a method is removed from the receiver.
  
 module Chatty 
  
 def Chatty.method_removed(id) 
  
   
 puts ""Removing #{id.id2name}"" 
  
 end 
  
 def one() 
  
 end 
  
 end 
  
 module Chatty 
  
 remove_method(:one) 
  
 end
  
 produces:
  
 Removing one
  
 method_undefined
  
 method_undefined(
  symbol
  )
  
 «
  
 1.8
  
  
 Invoked as a callback whenever a method is undefined in the receiver.
  
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
   
 ""This is one"" 
  
 end 
  
 module_function :one 
  
 end 
  
 class Cls 
  
 include Mod 
  
 def call_one 
  
   
 one 
  
 end 
  
 end
  
 Mod.one
  
 →
  
 ""This is one""
  
 c = Cls.new
  
 c.call_one
  
 →
  
 ""This is one""
  
 module Mod 
  
 def one 
  
   
 ""This is the new one"" 
  
 end 
  
 end
  
 private
  
 Mod.one
  
 →
  
 ""This is one""
  
 private(
  ⟨
  symbol
  ⟩
 ∗
 )
  →
  mod
  
 c.call_one
  
 →
  
 ""This is the new one""
  
 With no arguments, sets the default visibility for subsequently defined methods to 
 pri-vate. With arguments, sets the named methods to have private visibility. See 
 “Access Control” starting on page
  341
 .",NA
M,"class Dummy 
  
 @@var = 99 
  
 puts @@var 
  
 remove_class_variable(:@@var) 
  
 puts(defined? @@var) 
  
 end
  
 produces:
  
 99 
  
 nil
  
 remove_const
  
 remove_const(
  symbol
  )
  →
  obj
  
 Removes the definition of the given constant, returning that constant’s value. 
 Predefined
  
 classes and singleton objects (such as
  true
 ) cannot be removed.
  
 remove_method
  
 remove_method(
  symbol
  )
  →
  mod
  
 Removes the method identified by
  symbol
  from the current class. For an example, see
  
 Module.undef_method
 .
  
 undef_method
  
 undef_method(
  ⟨
  symbol
  ⟩
 +
 )
  →
  mod
  
 Prevents the current class from responding to calls to the named method(s). Contrast
  
 this with
  remove_method
 , which deletes the method from the particular class; Ruby will 
 still search superclasses and mixed-in modules for a possible receiver.
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
M,"odule
  
 In parent 
  
 prog.rb:23: undefined method `hello' for #<Child:0x1c92ec> (NoMethodError)
  
 Prepared exclusively for Yeganefar",NA
NilClass,"<
  
 Object
  
 N
 IL
 C
 LASS
  
 540
  
 The class of the singleton object
  nil
 .
  
 Instance methods
  
 &
  
 nil
  &
  obj
  →
  false 
 And—Returns
  false
 . As
  obj
  is an argument to a method call, it is always evaluated;
  
 there is no short-circuit evaluation in this case.
  
 nil && puts(""logical and"") 
  
 nil & 
  
 puts(""and"") 
  
 produces: 
  
 and
  
 ^
  
 nil
  ^
  obj
  →
  true
  or
  false
  
  
  
  
 Exclusive Or—Returns
  false
  if
  obj
  is
  nil
  or
  false
 , and returns
  true
  otherwise.
  
 |
  
 nil
  |
  obj
  →
  true
  or
  false
  
 ss
  
  
 ilCla
  
 Or—Returns
  false
  if
  obj
  is
  nil
  or
  false
 , and returns
  true
  otherwise.
  
  
 nil | false
  
 →
  
 false",NA
N,"nil | 99
  
 →
  
 true
  
 nil?
  
 Always returns
  true
 .
  
 nil
 .nil?
  →
  true
  
  
  
  
 to_a
  
 nil
 .to_a
  →
  []
  
  
  
  
 Always returns an empty array.
  
 nil.to_a
  
 →
  
 []
  
 to_f
  
 nil
 .to_f
  →
  0.0
  
  
 1.8
  
  
 Always returns zero.
  
 nil.to_f
  
 →
  
 0.0
  
 to_i
  
 Always returns zero.
  
 nil
 .to_i
  →
  0
  
  
  
  
 nil.to_i
  
 →
  
 0
  
 to_s
  
 Always returns the empty string.
  
 nil
 .to_s
  →
  """"
  
  
 nil.to_s
  
 →
  
 """"
  
  
 Prepared exclusively for Yeganefar",NA
Numeric,"<
  
 Object
  
 N
 UMERIC
  
 541
  
 Subclasses: Float, Integer
  
 Numeric is the fundamental base type for the abstract class
  Integer
  and the concrete 
 number classes
  Float
 ,
  Fixnum
 , and
  Bignum
 . Many methods in
  Numeric
  are overrid-den 
 in child classes, and
  Numeric
  takes some liberties by calling methods in these child 
 classes. A complete list of the methods defined in all five classes is shown in Table
  
 27.11
  on page
  543
 .
  
 Mixes in
  
 Comparable
 :
  
 <, <=, ==, >=, >, between?
  
 Instance methods
  
 +@
  
 Unary Plus—Returns the receiver’s value.
  
 +
 num
  →
  num
  
  
  
 ric
  
 -@
  
 Unary Minus—Returns the receiver’s value, negated.
  
 –
 num
  →
  numeric
  
 m
 e",NA
N,"u
  
 <=>
  
  
 num
  <=>
  other
  →
  0 or
  nil 
 Returns zero if
  num
  equals
  other
 , and returns
  nil
  otherwise.
  
  
  
  
 abs
  
 Returns the absolute value of
  num
 .
  
 num
 .abs
  →
  numeric
  
  
  
  
 12.abs
  
 →
  
 12
  
 (-34.56).abs
  
 →
  
 34.56
  
 -34.56.abs
  
 →
  
 34.56
  
 ceil
  
 num
 .ceil
  →
  int 
 Returns the smallest
  Integer
  greater than or equal to
  num
 . Class
  Numeric
  achieves
  
  
 this by converting itself to a
  Float
  and then invoking
  Float
 #
 ceil
 .
  
  
 1.ceil
  
 →
  
 1
  
 1.2.ceil
  
 →
  
 2
  
 (-1.2).ceil
  
 →
  
 -1
  
 (-1.0).ceil
  
 →
  
 -1
  
 coerce
  
 num
 .coerce(
  numeric
  )
  →
  array 
 coerce
  is both an instance method of
  Numeric
  and part of a type conversion protocol.
  
 When a number is asked to perform an operation and it is passed a parameter of a class 
 different to its own, it must first coerce both itself and that parameter into a common
  
 Prepared exclusively for Yeganefar",NA
N,"umeric
  
   
 case other 
  
   
 when Integer 
  
    
 begin 
  
    
 return other, Integer(self) 
  
    
 rescue 
  
    
 return Float(other), Float(self) 
  
    
 end 
  
   
 when Float 
  
    
 return other, Float(self) 
  
   
 else super 
  
   
 end 
  
 end 
  
 end
  
 1
  
 + ""2""
  
 →
  
 3
  
 1
  
 - ""2.3""
  
 →
  
 -1.3
  
 1.2 + ""2.3""
  
 3.5
  
 →
  
 1.5 - ""2""
  
 →
  
 -0.5
  
 coerce
  is discussed further on page
  358
 .
  
 div 
  
 1.8
  
  
 num
 .div(
  numeric
  )
  →
  int 
 Uses
  /
  to perform division, and then converts the result to an integer.
  Numeric
  does 
 not
  
 define the
  /
  operator; this is left to subclasses.
  
 Prepared exclusively for Yeganefar",NA
N,"umeric
  
 chr
  
 –
  
 –
  
 coerce
  
 –
  
 –
  
 div
  
 –
  
 defined in class
  Numeric
  
 divmod
  
 –
  
 and its subclasses. A
  
 downto
  
 –
  
  
 –
  
 –
  
 –",NA
N,"eql?
  
 –
  
 –
  
 –
  
  
  
 means that the method is
  
 finite?
  
 –
  
 –
  
 –
  
 defined in the
  
 floor
  
 –
  
 –
  
 –
  
 –
  
 corresponding class.
  
 hash
  
 –
  
  
 id2name
  
 –
  
 –
  
 –
  
 –
  
  
 infinite?
  
 –
  
 –
  
 –
  
 –
  
 –
  
 integer?
  
 –
  
 –
  
 modulo
  
 –
  
 –
  
 –
  
 –
  
 nan?
  
 –
  
  
 next
  
 –
  
 –
  
 –
  
 –
  
 –
  
  
 nonzero?
  
 –
  
 –
  
 –
  
 quo
  
 –
  
 –
  
 –
  
 remainder
  
 –
  
 –
  
 round
  
 –
  
 –
  
  
 size
  
 –
  
 –
  
 –
  
 –
  
 –
  
  
 step
  
 –
  
 –
  
 succ
  
 –
  
 –
  
 –
  
 –
  
 –
  
 times
  
 –
  
 –
  
 –
  
 –
  
 to_f
  
 –
  
  
 to_i
  
 –
  
 –
  
 –
  
 –
  
 –
  
  
 to_int
  
 –
  
 –
  
 –
  
 to_s
  
 to_sym
  
 –
  
 –
  
 –
  
 truncate
  
 –
  
 –
  
  
 upto
  
 –
  
 –
  
 –
  
 –
  
 –
  
  
 zero?
  
 –
  
 –
  
 –
  
 |
  
 –
  
 ~
  
 –
  
 –
  
 –
  
  
  
 Prepared exclusively for Yeganefar",NA
N,"Returns
  true
  if
  num
  and
  numeric
  are the same type and have equal values.
  
 1 == 1.0
  
 →
  
 true
  
 1.eql?(1.0)
  
 →
  
 false
  
 (1.0).eql?(1.0)
  
 →
  
 true
  
 floor
  
 num
 .floor
  →
  int 
 Returns the largest integer less than or equal to
  num
 .
  Numeric
  implements this by
  
  
 converting
  int
  to a
  Float
  and invoking
  Float
 #
 floor
 .
  
 1.floor
  
 →
  
 1
  
  
 (-1).floor
  
 →
  
 -1
  
 integer?
  
 num
 .integer?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  num
  is an
  Integer
  (including
  Fixnum
  and
  Bignum
 ).
  
 modulo
  
 num
 .modulo(
  numeric
  )
  →
  numeric
  
  
 Equivalent to
  num
 .
 divmod(
 numeric
 )[1]
 .
  
 nonzero? 
  
 num
 .nonzero?
  →
  num
  or
  nil 
  
 Returns
  num
  if
  num
  is not zero, and returns
  nil
  otherwise. This behavior is useful when 
  
 chaining comparisons.
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
N,"umeric
  
 1.8
  
  
 Invokes
  block
  with the sequence of numbers starting at
  num
 , incremented by
  step
  
 on each call. The loop finishes when the value to be passed to the block is greater
  
 than
  end_num
  (if
  step
  is positive) or less than
  end_num
  (if
  step
  is negative). If all the 
 arguments are integers, the loop operates using an integer counter. If any of the argu-
 ments are floating-point numbers, all are converted to floats, and the loop is 
 executed
 ⌊n + n ∗ ǫ⌋ + 1
  times, where
  n = (end
 _
 num −
  num
 )/step
 . Otherwise, the 
 loop starts at
  num
 , uses either the
  <
  or
  >
  operator to compare the counter against
  
 end_num
 , and increments itself using the
  +
  operator.
  
 1.step(10, 2) {|i| print i, "" "" } 
  
 Math::E.step(Math::PI, 0.2) {|f| print f, "" "" }
  
 produces:
  
 1 3 5 7 9 
  
 2.71828182845905 2.91828182845905 3.11828182845905
  
 to_int
  
 num
 .to_int
  →
  int
  
 Invokes the child class’s
  to_i
  method to convert
  num
  to an integer.
  
 truncate 
  
 num
 .truncate
  →
  int 
  
 Returns
  num
  truncated to an integer.
  Numeric
  implements this by converting its value
  
 to a float and invoking
  Float
 #
 truncate
 .
  
 zero?
  
 Returns
  true
  if
  num
  has a zero value.
  
 num
 .zero?
  →
  true
  or
  false
  
  
 Prepared exclusively for Yeganefar",NA
Object,"O
 BJECT
  
 546
  
 Subclasses: Array, Binding, Continuation, Data (used internally by the interpreter), 
 Dir, Exception, FalseClass, File::Stat, Hash, IO, MatchData, Method, Module, Nil-
 Class, Numeric, Proc, Process::Status, Range, Regexp, String, Struct, Symbol, 
 Thread, ThreadGroup, Time, TrueClass, UnboundMethod
  
 Object
  is the parent class of all classes in Ruby. Its methods are therefore available to all 
 objects unless explicitly overridden.
  
 Object
  mixes in the
  Kernel
  module, making the built-in kernel functions globally 
 accessible. Although the instance methods of
  Object
  are defined by the
  Kernel
  mod-
 ule, we have chosen to document them here for clarity.
  
 In the descriptions that follow, the parameter
  symbol
  refers to a symbol, which is either 
 a quoted string or a
  Symbol
  (such as
  :name
 ).
  
 Instance methods
  
 ==
  
 obj
  ==
  other_obj
  →
  true
  or
  false",NA
O,"bject
  
 Equality—At the
  Object
  level,
  ==
  returns
  true
  only if
  obj
  and
  other_obj
  are the same
  
 object. Typically, this method is overridden in descendent classes to provide class-
  
 specific meaning.
  
 ===
  
 obj
  ===
  other_obj
  →
  true
  or
  false
  
  
 Case Equality—A synonym for
  Object
 #
 ==
 , but typically overridden by descendents to
  
 provide meaningful semantics in
  case
  statements.
  
 =~
  
 obj
  =~
  other_obj
  →
  false 
 Pattern Match—Overridden by descendents (notably
  Regexp
  and
  String
 ) to provide
  
 meaningful pattern-match semantics.
  
 _ _id_ _
  
 obj
 ._ _id_ _
  →
  fixnum
  
 Synonym for
  Object
 #
 object_id
 .
  
  
 obj
 ._ _send_ _(
  symbol
  ⟨
  ,
  args
  ⟩
 +
 ⟨
  ,
  &block
  ⟩
  )
  →
  other_obj
  
 _ _send_ _
  
 Synonym for
  Object
 #
 send
 .
  
 class
  
 obj
 .class
  →
  klass 
 Returns the class of
  obj
 , now preferred over
  Object
 #
 type
 , as an object’s type in Ruby
  
 is only loosely tied to that object’s class. This method must always be called with an 
 explicit receiver, as
  class
  is also a reserved word in Ruby.
  
 1.class
  
 →
  
 Fixnum
  
 self.class
  
 Object
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 [ 4, 5, 6 ].display 
  
 puts
  
 produces:
  
 1cat456
  
 dup
  
 obj
 .dup
  →
  other_obj
  
 Produces a shallow copy of
  obj
 —the instance variables of
  obj
  are copied, but not the 
 objects they reference.
  dup
  copies the tainted state of
  obj
 . See also the discussion 
 under 
 Object
 #
 clone
 . In general,
  clone
  and
  dup
  may have different semantics in 
 descendent classes. While
  clone
  is used to duplicate an object, including its internal 
 state,
  dup 
 typically uses the class of the descendent object to create the new instance.
  
 eql?
  
 obj
 .eql?(
  other_obj
  )
  →
  true
  or
  false 
 Returns
  true
  if
  obj
  and
  other_obj
  have the same value. Used by
  Hash
  to test members
  
 for equality. For objects of class
  Object
 ,
  eql?
  is synonymous with
  ==
 . Subclasses 
 normally continue this tradition, but there are exceptions.
  Numeric
  types, for example, 
 perform type conversion across
  ==
 , but not across
  eql?
 , so
  
 1 == 1.0
  
 →
  
 true
  
 1.eql? 1.0
  
 false
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
O,"k = Klass.new
  
 k.hello
  
 →
  
 ""Hello from Klass.\n""
  
 k.extend(Mod)
  
 #<Klass:0x1c9300>
  
 →
  
 k.hello
  
 →
  
 ""Hello from Mod.\n""
  
 Writing
  obj
 .extend(Mod)
  is basically the same as the following.
  
 class <<obj 
  
 include Mod 
  
 end
  
 freeze
  
 obj
 .freeze
  →
  obj 
 Prevents further modifications to
  obj
 . A
  TypeError
  will be raised if modification is
  
 attempted. You cannot unfreeze a frozen object. See also
  Object
 #
 frozen?
 .
  
 a = [ ""a"", ""b"", ""c"" ] 
  
 a.freeze 
  
 a << ""z""
  
 produces:
  
 prog.rb:3:in `<<': can't modify frozen array (TypeError) 
  
 from prog.rb:3
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 Think of
  initialize_copy
  as a kind of copy constructor.
  
 inspec
 t
  
 obj
 .inspect
  →
  string",NA
O,"Returns a string containing a human-readable representation of
  obj
 . If not overridden,
  
 uses the
  to_s
  method to generate the string.
  
 [ 1, 2, 3..4, 'five' ].inspect
  
 →
  
 ""[1, 2, 3..4, \""five\""]""
  
 Time.new.inspect
  
 →
  
 ""Thu Aug 26 22:37:49 CDT 2004""
  
 instance_eval
  
 obj
 .instance_eval(
 string
  ⟨
  ,
  file
  ⟨
  , line
  ⟩ ⟩
  )
  →
  other_obj 
 obj
 .instance_eval {
  block
  }
  →
  other_obj
  
 Evaluates a string containing Ruby source code, or the given block, within the con-
  
 text of the receiver (
 obj
 ). To set the context, the variable
  self
  is set to
  obj
  while the
  
 code is executing, giving the code access to
  obj
 ’s instance variables. In the version of
  
 instance_eval
  that takes a
  String
 , the optional second and third parameters supply
  
 a filename and starting line number that are used when reporting compilation errors.
  
 class Klass
  
 def initialize
  
 @secret = 99
  
 end
  
 end
  
 k = Klass.new
  
 k.instance_eval { @secret }
  
 →
  
 99
  
  
 Prepared exclusively for Yeganefar",NA
O,"fred = Fred.new('cat', 99)
  
 fred.instance_variable_set(:@a, 'dog')
  
 →
  
 ""dog""
  
 fred.inspect
  
 →
  
 ""#<Fred:0x1c94e0 @b=99,
  
 @a=\""dog\"">""
  
 instance_variables
  
 obj
 .instance_variables
  →
  array
  
 Returns an array of instance variable names for the receiver. Note that simply 
 defining
  
 an accessor does not create the corresponding instance variable.
  
 class Fred 
  
 attr_accessor :a1 
  
 def initialize 
  
   
 @iv = 3 
  
 end 
  
 end
  
  
 Fred.new.instance_variables
  
 →
  
 [""@iv""]
   
 is_a?
  
 Synonym for
  Object
 #
 kind_of?
 .
  
  
  
 obj
 .is_a?(
  klass
  )
  →
  true
  or
  false
  
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 Looks up the named method in
  obj
 , returning a
  Method
  object (or raising
  NameError
 ).
  
 The
  Method
  object acts as a closure in
  obj
 ’s object instance, so instance variables and
  
 the value of
  self
  remain available.
  
 class Demo
  
 def initialize(n) 
  
   
 @iv = n 
  
 end 
  
 def hello() 
  
   
 ""Hello, @iv = #{@iv}"" 
  
 end 
  
 end
  
 k = Demo.new(99) 
  
 m = k.method(:hello)
  
 m.call
  
 →
  
 ""Hello, @iv = 99""
  
 l = Demo.new('Fred') 
  
 m = l.method(""hello"")
  
 m.call
  
 →
  
 ""Hello, @iv = Fred""
  
 method_missing
  
 obj
 .method_missing(
  symbol
  ⟨
  ,
  *args
  ⟩
  )
  →
  other_obj
  
 Invoked by Ruby when
  obj
  is sent a message it cannot handle.
  symbol
  is the symbol 
 for the method called, and
  args
  are any arguments that were passed to it. The 
 example below creates a class
  Roman
 , which responds to methods with names 
 consisting of roman numerals, returning the corresponding integer values. A more 
 typical use of 
 method_missing
  is to implement proxies, delegators, and forwarders.
  
 Prepared exclusively for Yeganefar",NA
O,"k.methods[0..9]
  
 ""nil?"", ""tainted?"", ""class"", ""my_method"", 
  
 ""singleton_methods"", ""=~""]
  
 k.methods.length
  
 →
  
 42
  
 k.methods(false)
  
 →
  
 [""single""]
  
 nil?
  
 obj
 .nil?
  →
  true
  or
  false
  
  
 All objects except
  nil
  return
  false
 . 
  
 object_id
  
  
 1.8 
 Returns an integer identifier for
  obj
 . The same number will be returned on all 
  
 obj
 .object_id
  
 →
  fixnum
  
 calls to
  object_id
  for a given object, and no two active objects will share an ID. 
 Object
 #
 object_id
  is a different concept from the
  :name
  notation, which returns the 
 symbol ID of
  name
 . Replaces the deprecated
  Object
 #
 id
 .
  
 private_methods
  
 obj
 .private_methods
  →
  array
  
 Returns a list of private methods accessible within
  obj
 . This will include the private
  
 methods in
  obj
 ’s ancestors, along with any mixed-in module functions.
  
 protected_methods
  
 obj
 .protected_methods
  →
  array
  
 Returns the list of protected methods accessible to
  obj
 .
  
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 Returns an array of the names of singleton methods for
  obj
 . If the optional
  all
  
 parameter
  
 1.8
  
  
 is true, the list will include methods in modules included in
  obj
 . (The parameter 
 defaults to
  false
  in versions of Ruby prior to January 2004.)
  
 module Other 
  
 def three() end 
  
 end
  
 class Single 
  
 def Single.four() end 
  
 end
  
 a = Single.new
  
 def a.one() end
  
 class << a 
  
 include Other 
  
 def two() end 
  
 end
  
 Single.singleton_methods
  
 →
  
 [""four""]
  
 a.singleton_methods(false)
  
 →
  
 [""two"", ""one""]
  
 a.singleton_methods(true)
  
 [""two"", ""one"", ""three""]
  
 →
  
 a.singleton_methods
  
 →
  
 [""two"", ""one"", ""three""]
  
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 obsolete\n[main]
  
 ""hello"".to_a
  
 →
  
 [""hello""]
  
 Time.new.to_a
  
 →
  
 [50, 37, 22, 26, 8, 2004, 4, 239, true, ""CDT""]
  
 to_s
  
 obj
 .to_s
  →
  string
  
  
 Returns a string representing
  obj
 . The default
  to_s
  prints the object’s class and an
  
 encoding of the object ID. As a special case, the top-level object that is the initial
  
 execution context of Ruby programs returns “main.”
  
 type
  
 Deprecated synonym for
  Object
 #
 class
 .
  
 obj
 .type
  →
  klass
  
 1.8
  
  
 untaint
  
 Removes the taint from
  obj
 .
  
 obj
 .untaint
  →
  obj
  
 Private instance methods
  
 initialize
  
 initialize(
  ⟨
  arg
  ⟩
 +
 )
  
 Called as the third and final step in object construction,
  initialize
  is responsible for
  
 setting up the initial state of the new object. You use the initialize method the same way
  
 you’d use constructors in other languages. If you subclass classes other than
  Object
 , you 
 will probably want to call
  super
  to invoke the parent’s initializer.
  
 «
  
  
 Prepared exclusively for Yeganefar",NA
O,"attr_reader :var 
  
 def initialize 
  
   
 @var = 99 
  
 end 
  
 def remove 
  
   
 remove_instance_variable(:@var) 
  
 end 
  
 end 
  
 d = Dummy.new
  
 d.var
  
 →
  
 99
  
 d.remove
  
 →
  
 99
  
 d.var
  
 →
  
 nil
  
 singleton_method_added
  
 singleton_method_added(
  symbol
  )
  
 1.8
  
  
 Invoked as a callback whenever a singleton method is added to the receiver.
  
 module Chatty 
  
 def Chatty.singleton_method_added(id) 
  
   
 puts ""Adding #{id.id2name} to #{self.name}"" 
  
 end 
  
 def self.one() 
  
 end 
  
 def two() 
  
 end 
  
 end 
  
 def Chatty.three() end
  
 Prepared exclusively for Yeganefar",NA
O,"bject
  
 def two()
  
 end
  
 def Chatty.three() end 
  
 class <<self
  
   
 remove_method :three 
  
   
 remove_method :one 
  
 end 
  
 end
  
 produces:
  
 Removing three 
  
 Removing one
  
 singleton_method_undefined
  
 singleton_method_undefined(
  symbol
  
 )
  
 1.8
  
  
 Invoked as a callback whenever a singleton method is undefined in the receiver.
  
 module Chatty 
  
 def Chatty.singleton_method_undefined(id) 
  
   
 puts ""Undefining #{id.id2name}"" 
  
 end 
  
 def Chatty.one() 
  
 end 
  
 class << self 
  
    
 undef_method(:one) 
  
 end 
  
 end
  
 produces:
  
 Undefining one
  
 Prepared exclusively for Yeganefar",NA
 ObjectSpace,"The
  ObjectSpace
  module contains a number of routines that interact with the garbage 
 collection facility and allow you to traverse all living objects with an iterator.
  
 ObjectSpace
  also provides support for object finalizers. These are procs that will be 
 called when a specific object is about to be destroyed by garbage collection.
  
 include ObjectSpace
  
 a, b, c = ""A"", ""B"", ""C"" 
  
 puts ""a's id is #{a.object_id}"" 
  
 puts ""b's id is #{b.object_id}"" 
  
 puts ""c's id is #{c.object_id}""
  
 define_finalizer(a, lambda {|id| puts ""Finalizer one on #{id}"" }) define_finalizer(b, lambda {|id| 
 puts ""Finalizer two on #{id}"" }) define_finalizer(c, lambda {|id| puts ""Finalizer three on #{id}"" 
 })
  
 produces:
  
 a's id is 936150 
  
 b's id is 936140
  
 c's id is 936130",NA
O,"bjectSpace
  
 Finalizer three on 936130
  
 Finalizer two on 936140
  
 Finalizer one on 936150
  
 Module methods",NA
O,"_id2ref
  
 ObjectSpace._id2ref(
  object_id
  )
  →
  obj
  
  
 Converts an object ID to a reference to the object. May not be called on an object ID 
 passed as a parameter to a finalizer.
  
 s = ""I am a string"" 
  
 oid = s.object_id 
  
 r = ObjectSpace._id2ref(oid) r 
  
 r.equal?(s)
  
 →
  
 ""I am a string""
  
 →
  
 936550
  
 →
  
 ""I am a string""
  
 →
  
 ""I am a string""
  
 →
  
 true
  
 define_finalizer
  
 ObjectSpace.define_finalizer(
  obj
 ,
  a_proc
 =proc() 
 )
  
 Adds
  a_proc
  as a finalizer, called when
  obj
  is about to be destroyed.
  
 each_object
  
 ObjectSpace.each_object(
  ⟨
  class_or_mod
  ⟩
  ) {
 | obj | block
  }
  →
  fixnum
  
 Calls the block once for each living, nonimmediate object in this Ruby process. If 
 class_or_mod
  is specified, calls the block for only those classes or modules that 
 match (or are a subclass of)
  class_or_mod
 . Returns the number of objects found. 
 Immediate objects (
 Fixnum
 s,
  Symbol
 s
  true
 ,
  false
 , and
  nil
 ) are never returned. In the 
 example below,
  each_object
  returns both the numbers we defined and several constants 
 defined in the
  Math
  module.
  
 Prepared exclusively for Yeganefar",NA
O,"bjectSpace
  
  
 Prepared exclusively for Yeganefar",NA
Proc,"<
  
 Object
  
 P
 ROC
  
 559
  
 Proc
  objects are blocks of code that have been bound to a set of local variables. Once 
 bound, the code may be called in different contexts and still access those variables.
  
 def gen_times(factor) 
  
 return Proc.new {|n| n*factor } 
  
 end
  
 times3 = gen_times(3) 
  
 times5 = gen_times(5)
  
 times3.call(12)
  
 →
  
 36
  
 times5.call(5)
  
 25
  
 →
  
 times3.call(times5.call(4))
  
 →
  
 60
  
 Class methods
  
 new
  
 Proc.new {
  block
  }
  →
  a_proc 
  
 Proc.new
  →
  a_proc
  
 Creates a new
  Proc
  object, bound to the current context.
  Proc.new
  may be called
  
 without a block only within a method with an attached block, in which case that block 
 is converted to the
  Proc
  object.
  
 def proc_from
  
 roc
  
 Proc.new 
  
 end",NA
P,"proc = proc_from { ""hello"" }
  
 proc.call
  
 →
  
 ""hello""
  
 Instance methods
  
 [ ]
  
 prc
 [
  ⟨
  params
  ⟩
 ∗
 ]
  →
  obj
  
 Synonym for
  Proc.call
 .
  
 == 
  
 1.8
  
  
  
 Returns
  true
  if
  prc
  is the same as
  other
 .
  
 prc
 ==
  other
  →
  true
  or
  false
  
  
 arity 
 1.8
  
  
 prc
 .arity
  →
  integer 
 Returns the number of arguments required by the block. If the block is declared to 
 take
  
 no arguments, returns
  0
 . If the block is known to take exactly
  n
  arguments, returns
  n
 . 
 If the block has optional arguments, return
  −(n+1)
 , where
  n
  is the number of 
 mandatory arguments. A
  proc
  with no argument declarations also returns
  −1
 , as it can 
 accept (and ignore) an arbitrary number of parameters.
  
 Prepared exclusively for Yeganefar",NA
P,"roc
  
 Invokes the block, setting the block’s parameters to the values in
  params
  using some-
  
 thing close to method-calling semantics. Returns the value of the last expression eval-
  
 uated in the block.
  
 a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}
  
 1.8
  
  
 a_proc.call(9, 1, 2, 3)
  
 →
  
 [9, 18, 27]
  
 a_proc[9, 1, 2, 3]
  
 →
  
 [9, 18, 27]
  
 If the block being called explicitly accepts a single parameter,
  call
  issues a warning
  
 unless it has been given exactly one parameter.
  
 Otherwise it happily accepts what it is
  
 given, ignoring surplus passed parameters and setting unset block parameters to
  nil
 .
  
 a_proc = Proc.new {|a| a} 
  
 a_proc.call(1,2,3)
  
 produces:
  
 prog.rb:1: warning: multiple values for a block parameter (3 for 1) from prog.rb:2
  
 If you want a block to receive an arbitrary number of arguments, define it to accept 
 *args
 .
  
 a_proc = Proc.new {|*a| a}
  
 a_proc.call(1,2,3)
  
 →
  
 [1, 2, 3]
  
 «
  
 Blocks created using
  Kernel.lambda
  check that they are called with exactly the right 
 number of parameters.
  
  
 Prepared exclusively for Yeganefar",NA
P,"roc
  
  
 Prepared exclusively for Yeganefar",NA
 Process,"The
  Process
  module is a collection of methods used to manipulate processes. Pro-
 grams that want to manipulate real and effective user and group IDs should also look 
 at the
  Process::GID
 , and
  Process::UID
  modules. Much of the functionality here is 
 duplicated in the
  Process::Sys
  module.
  
 Module constants
  
 PRIO_PGRP 
  
 PRIO_PROCESS 
 PRIO_USER 
  
 WNOHANG 
  
 WUNTRACED
  
 Process group priority.
  
 Process priority.
  
 User priority.
  
 Do not block if no child has exited. Not available on all 
 platforms. Return stopped children as well. Not available on all 
 platforms.
  
 Module methods
  
 abort
  
 abort
  
 abort(
  msg
  )
  
 1.8
  
  
 Synonym for
  Kernel.abort
 .
  
  
 detach
  
 Process.detach(
  pid
  )
  →
  thread",NA
P,"rocess
  
 1.8
  
  
 Some operating systems retain the status of terminated child processes until the parent
  
 collects that status (normally using some variant of
  wait()
 ). If the parent never collects
  
 this status, the child stays around as a
  zombie
  process.
  Process.detach
  prevents this by 
 setting up a separate Ruby thread whose sole job is to reap the status of the process 
 pid
  when it terminates. Use
  detach
  only when you do not intend to explicitly wait for 
 the child to terminate.
  detach
  checks the status only periodically (currently once each 
 second).
  
 In this first example, we don’t reap the first child process, so it appears as a zombie in 
 the process status display.
  
 pid = fork { sleep 0.1 } 
  
 sleep 1 
  
 system(""ps -o pid,state -p #{pid}"")
  
 produces:
  
 PID STAT 
  
 27836 ZN+
  
 In the next example,
  Process.detach
  is used to reap the child automatically—no child 
 processes are left running.
  
 pid = fork { sleep 0.1 } 
  
 Process.detach(pid) 
  
 sleep 1
  
 Prepared exclusively for Yeganefar",NA
P,"1.8
  
  
 Synonym for
  Kernel.exit!
 . No exit handlers are run. 0, 1, or
  status
  is returned to the
  
  
 underlying system as the exit status.
  
 Process.exit!(0)
  
 fork
  
 Process.fork
  ⟨
  {
  block
  }
  ⟩ →
  int
  or
  nil
  
 See
  Kernel.fork
  on page
  501
 .
  
 getpgid
  
 Process.getpgid(
  int
  )
  →
  int
  
 Returns the process group ID for the given process id. Not available on all platforms.
  
 Process.getpgid(Process.ppid())
  
 →
  
 25122
  
 getpgrp
  
 Process.getpgrp
  →
  int
  
 Returns the process group ID for this process. Not available on all platforms.
  
 Process.getpgid(0)
  
 →
  
 25122
  
 Process.getpgrp
  
 →
  
 25122
  
  
 Prepared exclusively for Yeganefar",NA
P,"rocess
  
 See also
  Process.maxgroups
 .
  
 Process.groups
  
 →
  
 [502, 79, 80, 81]
  
 groups=
  
  
 1.8 
 Sets the supplementary group IDs from the given array, which may contain either num-
  
 Process.groups =
  array
  →
  groups",NA
P,"bers of group names (as strings). Not available on all platforms. Only available to 
 super-users. See also
  Process.maxgroups
 .
  
 initgroups
  
  
 1.8 
 Initializes the group access list using the operating system’s
  initgroups
  call. Not 
  
  
 Process.initgroups(
  user
 ,
  base_group
  )
  →
  groups
  
 available on all platforms. May require superuser privilege.
  
 Process.initgroups(""dave"", 500)
  
 kill
  
 Process.kill(
  signal
 ,
  ⟨
  pid
  ⟩
 +
 )
  →
  int
  
 Sends the given signal to the specified process ID(s) or to the current process if
  pid
  is 
 zero.
  signal
  may be an integer signal number or a POSIX signal name (either with or 
 without a
  SIG
  prefix). If
  signal
  is negative (or starts with a
  -
  sign), kills process groups 
 instead of processes. Not all signals are available on all platforms.
  
 pid = fork do 
  
 Signal.trap(""USR1"") { puts ""Ouch!""; exit } 
  
 # ... do some work ...
  
 end
  
 Prepared exclusively for Yeganefar",NA
P,"ro
  
 Returns the process ID of this process. Not available on all platforms.
  
 Process.pid
  
 →
  
 27864
  
 ppid
  
 Process.ppid
  →
  int
  
  
 Returns the process ID of the parent of this process. Always returns 0 on Windows. 
 Not
  
 available on all platforms.
  
 puts ""I am #{Process.pid}"" 
  
 Process.fork { puts ""Dad is #{Process.ppid}"" }
  
 produces:
  
 I am 27866 
  
 Dad is 27866
  
 setpgid
  
 Process.setpgid(
  pid
 ,
  int
  )
  →
  0
  
 Sets the process group ID of
  pid
  (0 indicates this process) to
  int
 . Not available on all 
 platforms.
  
 setpgrp
  
 Process.setpgrp
  →
  0
  
 Equivalent to
  setpgid(0,0)
 . Not available on all platforms.
  
  
  
 Prepared exclusively for Yeganefar",NA
P,"rocess
  
 Process.uid
  
 →
  
 502
  
 uid=
  
  
 Process.uid=
  int
  →
  numeric 
 Sets the (integer) user ID for this process. Not available on all platforms.
  
  
  
  
 wait
  
 Process.wait
  →
  int 
 Waits for any child process to exit and returns the process ID of that child. Also sets
  
  
 $?
  to the
  Process::Status
  object containing information on that process. Raises a
  
 SystemError
  if there are no child processes. Not available on all platforms.
  
  
 Process.fork { exit 99 }
  
 →
  
 27878
  
 Process.wait
  
 →
  
 27878
  
 $?.exitstatus
  
 →
  
 99
  
 waitall 
 1.8
  
  
 Process.waitall
  →
  [ [
  pid1
 ,
 status
  ], ...] 
 Waits for all children, returning an array of
  pid
 /
 status
  pairs (where
  status
  is an object
  
 of class
  Process::Status
 ).
  
 Prepared exclusively for Yeganefar",NA
P,"rocess
  
 Waits for a child process to exit depending on the value of
  pid
 :
  
 < −1−1 
  
 0
  
 Any child whose progress group ID equals the absolute value of
  
 pid
 . Any child (equivalent to
  wait
 ).
  
 Any child whose process group ID equals that of the current process.
  
 > 0
  
 The child with the given PID.
  
 int
  may be a logical or of the flag values
  Process::WNOHANG
  (do not block if no child 
 available) or
  Process::WUNTRACED
  (return stopped children that haven’t been 
 reported). Not all flags are available on all platforms, but a flag value of zero will 
 work on all platforms.
  
 include Process
  
 pid = fork { sleep 3 }
  
 →
  
 27889
  
 Time.now
  
 →
  
 Thu Aug 26 22:38:17 CDT 2004
  
 waitpid(pid, Process::WNOHANG)
  
 →
  
 nil
  
 Time.now
  
 →
  
 Thu Aug 26 22:38:17 CDT 2004
  
 waitpid(pid, 0)
  
 →
  
 27889
  
 Time.now
  
 →
  
 Thu Aug 26 22:38:20 CDT 2004
  
 waitpid2
  
 Process.waitpid2(
  pid
 ,
  int
 =0 )
  →
  [
  pid
 ,
  status
  ]
  
 Waits for the given child process to exit, returning that child’s process ID and exit status
  
 (a
  Process::Status
  object).
  int
  may be a logical or of the values
  Process::WNOHANG 
 (do 
 not block if no child available) or
  Process::WUNTRACED
  (return stopped children that 
 haven’t been reported). Not all flags are available on all platforms, but a flag value of 
 zero will work on all platforms.
  
 Prepared exclusively for Yeganefar",NA
 Process::GID,"Provides a higher-level (and more portable) interface to the underlying operating sys-
 tem’s concepts of real, effective, and saved group IDs. Discussing of the semantics of 
 these IDs is well beyond the scope of this book: readers who want to know more 
 should consult POSIX documentation or read the
  intro(2)
  man pages on a recent Unix 
 platform. All these methods throw
  NotImplementedError
  if the host operating does not 
 support a sufficient set of calls. The descriptions that follow are based on notes in 
 ruby-talk:76218 by Hidetoshi Nagai.
  
 Module methods
  
 change_privilege
  
  
 1.8 
 Sets the real, effective, and saved group IDs to
  gid
 , raising an exception on failure (in 
  
  
 Process::GID.change_privilege(
  gid
  )
  →
  gid
  
 which case the state of the IDs is not known).
  
 This method is not compatible with
  Process.gid=
 .
  
 eid 
  
 1.8
  
  
  
 Process::GID.eid
  →
  egid 
 Returns the effective group ID for this process. Synonym for
  Process.egid
 .
  
 s::GID
  
  
 Process::GID.eid =
  egid
  
 eid=",NA
P,"roces
  
 1.8
  
  
 Synonym for
  Process::GID.grant_privilege
 .
  
 grant_privilege
  
  
 1.8 
 Sets the effective group ID to
  egid
 , raising an exception on failure. One some environ-
  
 Process::GID.grant_privilege(
  egid
  )
  →
  egid
  
  
 ments this may also change the saved group ID (see
  re_exchangeable?
 ).
  
 re_exchange
  
  
 1.8 
 Exchange the real and effective group IDs, setting the saved group ID to the new effec-
  
 Process::GID.re_exchange
  →
  egid
  
 tive group ID. Returns the new effective group ID.
  
 re_exchangeable?
  
  
 1.8 
 Returns
  true
  if real and effective group IDs can be exchanged on the host operating 
  
  
 Process::GID.re_exchangeable
  →
  true
  or
  false
  
 system, and returns
  false
  otherwise.
  
 rid 
  
 1.8
  
  
  
 Process::GID.rid
  →
  gid 
 Returns the real group ID for this process. Synonym for
  Process.gid
 .
  
  
 sid_available?
  
  
 1.8 
 Returns
  true
  if the underlying platform supports saved group IDs, and returns
  false 
  
  
 Process::GID.sid_available?
  →
  true
  or
  false
  
  
 Prepared exclusively for Yeganefar",NA
P,"rocess::GID
  
  
 Prepared exclusively for Yeganefar",NA
Process::Status,"<
  
 Object
  
 P
 ROCESS
 ::S
 TATUS
  
 570
  
 Process::Status
  encapsulates the information on the status of a running or termi-nated 
 system process. The built-in variable
  $?
  is either
  nil
  or a
  Process::Status 
 object.
  
 fork { exit 99 }
  
 →
  
 27186
  
 Process.wait
  
 →
  
 27186
  
 $?.class
  
 Process::Status
  
 →
  
 $?.to_i
  
 →
  
 25344
  
 $? >> 8
  
 →
  
 99
  
 $?.stopped?
  
 →
  
 false
  
 $?.exited?
  
 →
  
 true
  
 $?.exitstatus
  
 →
  
 99
  
 POSIX systems record information on processes using a 16-bit integer. The lower 
 bits recorded the process status (stopped, exited, signaled), and the upper bits 
 possibly con-tain additional information (for example, the program’s return code in 
 the case of exited processes). Before Ruby 1.8, these bits were exposed directly to the 
 Ruby program. Ruby now encapsulates these in a
  Process::Status
  object. To maximize 
 compatibil-
  
 ity, however, these objects retain a bit-oriented interface. In the descriptions that 
 follow, when we talk about the integer value of
  stat
 , we’re referring to this 16-bit 
 value.
  
 Instance methods
  
 cess::Status
  
 ==
  
 Returns
  true
  if the integer value of
  stat
  equals
  other
 .
  
 stat
  ==
  other
  →
  true
  or
  false",NA
P,"ro
  
 &
  
 stat
  &
  num
  →
  fixnum
  
  
 Logical AND of the bits in
  stat
  with
  num
 .
  
 fork { exit 0x37 } 
  
 Process.wait
  
 sprintf('%04x', $?.to_i)
  
 →
  
 ""3700""
  
 sprintf('%04x', $? & 0x1e00)
  
 →
  
 ""1600""
  
 >>
  
 stat
  >>
  num
  →
  fixnum
  
 Shift the bits in
  stat
  right
  num
  places.
  
 fork { exit 99 }
  
 →
  
 27192
  
 Process.wait
  
 →
  
 27192
  
 $?.to_i
  
 →
  
 25344
  
 $? >> 8
  
 →
  
 99
  
 coredump?
  
 stat
 .coredump
  →
  true
  or
  false
  
 Returns
  true
  if
  stat
  generated a coredump when it terminated. Not available on all
  
 platforms.
  
 Prepared exclusively for Yeganefar",NA
P,"rocess::Status
  
 Returns the ID of the process associated with this status object.
  
 fork { exit }
  
 →
  
 27199
  
 Process.wait
  
 →
  
 27199
  
 $?.pid
  
 →
  
 27199
  
 signaled?
  
 stat
 .signaled?
  →
  true
  or
  false
  
  
 Returns
  true
  if
  stat
  terminated because of an uncaught signal.
  
 pid = fork { sleep 100 }
  
 Process.kill(9, pid)
  
 →
  
 1
  
 Process.wait
  
 →
  
 27202
  
 $?.signaled?
  
 →
  
 true
  
 stopped?
  
 stat
 .stopped?
  →
  true
  or
  false
  
 Returns
  true
  if this process is stopped. This is returned only if the corresponding
  wait
  
 call had the
  WUNTRACED
  flag set.
  
 success?
  
 stat
 .success?
  →
  nil
 , or
  true
  or
  false
  
 Returns
  true
  if
  stat
  refers to a process that exited successfully, returns
  false
  if it
  
 exited with a failure, and returns
  nil
  if
  stat
  does not refer to a process that has exited.
  
 stopsi
 g
  
  
 stat
 .stopsig
  →
  fixnum
  or
  nil 
 Returns the number of the signal that caused
  stat
  to stop (or
  nil
  if self is not stopped).
  
  
 Prepared exclusively for Yeganefar",NA
P,"rocess::Status
  
 Equivalent to
  stat
 .to_i.to_s
 .
  
  
 Prepared exclusively for Yeganefar",NA
 Process::Sys,"Process::Sys
  provides system call–level access to the process user and group envi-
 ronment. Many of the calls are aliases of those in the
  Process
  module and are 
 packaged here for completeness. See also
  Process::GID
  and
  Process::UID
  for a higher-
 level (and more portable) interface.
  
 Module methods
  
 getegi
 d 
  
 1.8
  
  
  
 Process::Sys.getegid
  →
  gid 
 Returns the effective group ID for this process. Synonym for
  Process.egid
 .
  
  
 geteui
 d 
  
 1.8
  
  
  
 Process::Sys.getugid
  →
  uid 
 Returns the effective user ID for this process. Synonym for
  Process.euid
 .
  
  
 getgid 
  
 1.8
  
  
  
 Process::Sys.getgid
  →
  gid 
 Returns the group ID for this process. Synonym for
  Process.gid
 .
  
  
 getuid 
  
 1.8
  
  
  
 Process::Sys.getuid
  →
  uid 
 Returns the user ID for this process. Synonym for
  Process.uid
 .
  
 ess::Sys
  
 issetugid
  
  
 1.8 
 Returns
  true
  if this process was made setuid or setgid as a result of the last
  execve() 
  
  
 Process::Sys.issetugid
  →
  true
  or
  false",NA
P,"roc
  
 system call, and returns
  false
  if not. On systems that don’t support
  issetugid(2)
 , throws
  
 NotImplementedError
 .
  
 setegid
  
 Process::Sys.setegid(
  gid
  )
  
 1.8
  
  
 Set the effective group ID to
  gid
 , failing if the underlying system call fails. On 
 systems
  
 that don’t support
  setegid(2)
 , throws
  NotImplementedError
 .
  
 seteuid
  
 Process::Sys.seteuid(
  uid
  )
  
 1.8
  
  
 Set the effective user ID to
  uid
 , failing if the underlying system call fails. On systems
  
 that don’t support
  seteuid(2)
 , throws
  NotImplementedError
 .
  
 setgid
  
 Process::Sys.setgid(
  gid
  )
  
 1.8
  
  
 Set the group ID to
  gid
 , failing if the underlying system call fails. On systems that 
 don’t
  
 support
  setgid(2)
 , throws
  NotImplementedError
 .
  
 setregid
  
 Process::Sys.setregid(
  rgid
 ,
  egid
  )
  
 1.8
  
  
 Set the real and effective group IDs to
  rgid
  and
  egid
 , failing if the underlying system 
 call
  
 fails. On systems that don’t support
  setregid(2)
 , throws
  NotImplementedError
 .
  
 Prepared exclusively for Yeganefar",NA
P,"1.8
  
  
 Set the user ID to
  uid
 , failing if the underlying system call fails. On systems that 
 don’t
  
  
 support
  setuid(2)
 , throws
  NotImplementedError
 .
  
 Prepared exclusively for Yeganefar",NA
 Process::UID,"Provides a higher-level (and more portable) interface to the underlying operating sys-
 tem’s concepts of real, effective, and saved user IDs. For more information, see the 
 introduction to
  Process::GID
  on page
  568
 .
  
 Module methods
  
 change_privilege
  
  
 1.8 
 Sets the real, effective, and saved user IDs to
  uid
 , raising an exception on failure (in 
  
  
 Process::UID.change_privilege(
  uid
  )
  →
  uid
  
 which case the state of the IDs is not known). Not compatible with
  Process.uid=
 .
  
 eid 
  
 1.8
  
  
  
 Process::UID.eid
  →
  euid 
 Returns the effective user ID for this process. Synonym for
  Process.euid
 .
  
  
  
  
 Process::UID.eid =
  euid
  
 eid= 
 1.8
  
  
 Synonym for
  Process::UID.grant_privilege
 .
  
  
 grant_privilege
  
  
 1.8 
 Sets the effective user ID to
  euid
 , raising an exception on failure. One some environ-
  
  
  
 Process::UID.grant_privilege(
  euid
  )
  →
  euid
  
 ments this may also change the saved user ID.
  
 re_exchange
  
  
 1.8 
 Exchange the real and effective user IDs, setting the saved user ID to the new effective 
  
 Process::UID.re_exchange
  →
  euid
  
 ess::UID",NA
P,"roc
  
  
  
 user ID. Returns the new effective user 
 ID. 
  
 re_exchangeable?
  
  
 1.8 
 Returns
  true
  if real and effective user IDs can be exchanged on the host operating 
  
  
 Process::UID.re_exchangeable
  →
  true
  or
  false
  
 system, and returns
  false
  otherwise.
  
 rid 
  
 1.8
  
  
  
 Process::UID.rid
  →
  uid 
 Returns the real user ID for this process. Synonym for
  Process.uid
 .
  
  
 sid_available?
  
  
 1.8 
 Returns
  true
  if the underlying platform supports saved user IDs, and returns
  false 
  
  
 Process::UID.sid_available?
  →
  true
  or
  false
  
 otherwise. Currently, Ruby assumes support if the operating system has
  setresuid(2) 
 or
  seteuid(2)
  calls, or if the configuration includes the
  POSIX_SAVED_IDS
  flag.
  
 switch 
 1.8
  
  
 Process::UID.switch
  →
  euid 
  
 Process::UID.switch {
  block
  }
  →
  obj
  
 Handles the toggling of user privilege. In the block form, automatically toggles the 
 IDs
  
 back when the block terminates (as long as the block doesn’t use other Process::UID 
 calls to interfere). Without a block, returns the original effective user ID.",NA
Range,"<
  
 Object
  
 R
 ANGE
  
 576
  
 A
  Range
  represents an interval—a set of values with a start and an end. Ranges may 
 be constructed using the
  s
 ..
 e
  and
  s
 ...
 e
  literals or using
  Range.new
 . Ranges constructed 
 using
  ..
  run from the start to the end inclusively. Those created using
  ...
  exclude the 
 end value. When used as an iterator, ranges return each value in the sequence.
  
 (-1..-5).to_a
  
 →
  
 []
  
 (-5..-1).to_a
  
 [-5, -4, -3, -2, -1]
  
 →
  
 ('a'..'e').to_a
  
 →
  
 [""a"", ""b"", ""c"", ""d"", ""e""]
  
 ('a'...'e').to_a
  
 [""a"", ""b"", ""c"", ""d""]
  
 →
  
 Ranges can be constructed using objects of any type, as long as the objects can be 
 compared using their
  <=>
  operator and they support the
  succ
  method to return the next 
 object in sequence.
  
 class Xs 
  
 # represent a string of 'x's 
  
 include Comparable 
  
 attr :length 
  
 def initialize(n) 
  
   
 @length = n 
  
 end 
  
 def succ 
  
   
 Xs.new(@length + 1) 
  
 end 
  
 def <=>(other) 
  
   
 @length <=> other.length 
  
 end
  
 def to_s 
  
  
 sprintf ""%2d #{inspect}"", @length
  
 ange
  
 end 
  
 def inspect",NA
R,"'x' * @length 
  
 end 
  
 end
  
 r = Xs.new(3)..Xs.new(6)
  
 →
  
 xxx..xxxxxx
  
 r.to_a
  
 →
  
 [xxx, xxxx, xxxxx, xxxxxx]
  
 r.member?(Xs.new(5))
  
 true
  
 →
  
 In the previous code example, class
  Xs
  includes the
  Comparable
  module. This is 
 because
  Enumerable
 #
 member?
  checks for equality using
  ==
 . Including
  Comparable 
 ensures that the
  ==
  method is defined in terms of the
  <=>
  method implemented in
  Xs
 .
  
 Mixes in
  
 Enumerable
 :
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Prepared exclusively for Yeganefar",NA
R,"Returns the first object of
  rng
 .
  
 each
  
 rng
 .each {
 | i | block
  }
  →
  rng
  
  
 Iterates over the elements
  rng
 , passing each in turn to the block. Successive elements
  
 are generated using the
  succ
  method.
  
 (10..15).each do |n| 
  
  
 print n, ' ' 
  
 end
  
 produces:
  
 10 11 12 13 14 15
  
 end
  
 Returns the object that defines the end of
  rng
 .
  
 rng
 .end
  →
  obj
  
 (1..10).end
  
 →
  
 10
  
 (1...10).end
  
 →
  
 10
  
  
 Prepared exclusively for Yeganefar",NA
R,"1.8
  
  
 addition by one is used to generate successive elements. Otherwise
  step
  invokes
  succ 
 to iterate through range elements. The following code uses class
  Xs
  defined at the start 
 of this section.
  
 range = Xs.new(1)..Xs.new(10) 
  
 range.step(2) {|x| puts x} 
  
 range.step(3) {|x| puts x}
  
 produces:
  
 1 x 
  
 3 xxx 
  
 5 xxxxx 
  
 7 xxxxxxx 
  
 9 xxxxxxxxx 
  
 1 x 
  
 4 xxxx 
  
 7 xxxxxxx 
  
 10 xxxxxxxxxx
  
 Prepared exclusively for Yeganefar",NA
Regexp,"<
  
 Object
  
 R
 EGEXP
  
 579
  
 A
  Regexp
  holds a regular expression, used to match a pattern against strings. Regexps 
 are created using the
  /.../
  and
  %r...
  literals and using the
  Regexp.new
  constructor. This 
 section documents Ruby 1.8 regular expressions. Later versions of Ruby use a 
 different regular expression engine.
  
 Class constants
  
 EXTENDED 
  
 IGNORECASE 
 MULTILINE
  
 Ignore spaces and newlines in 
 regexp. Matches are case insensitive.
  
 Newlines treated as any other character.
  
 Class methods
  
 compile
  
 Regexp.compile(
  pattern
  ⟨
  ,
  options
  ⟨
  , lang
  ⟩ ⟩
  )
  →
  rxp
  
 Synonym for
  Regexp.new
 .
  
 escape
  
 Regexp.escape(
  string
  )
  →
  escaped_string 
 Escapes any characters that would have special meaning in a regular expression. For
  
 any string,
  Regexp.escape(
 str
 )=~
 str
  will be true.
  
 Regexp.escape('\\[]*?{}.')
  
 →
  
 \\\[\]\*\?\{\}\.
  
  
  
 last_match 
  
 Regexp.last_match
  →
  match
  
  
 1.8 
 The first form returns the
  MatchData
  object generated by the last successful pattern 
  
 Regexp.last_match(
  int
  )
  →
  string",NA
R,"egexp
  
  
  
 match. This is 
 equivalen page
  516
 . 
 The second fo
  
 /c(.)t/ =~ 'cat'
  
 t to r 
  
 rm 
 re
  
 →
  
 ading the global variable
  $~
 .
  MatchData
  is described on 
 turns the
  n
 th
 field in this
  MatchData
  object.
  
 0
  
 Regexp.last_match
  
 →
  
 #<MatchData:0x1c9468>
  
 Regexp.last_match(0)
  
 →
  
 ""cat""
  
 Regexp.last_match(1)
  
 →
  
 ""a""
  
 Regexp.last_match(2)
  
 →
  
 nil
  
 new 
 1.8
  
  
 Regexp.new(
  string
  ⟨
  ,
  options
  ⟨
  , lang
  ⟩ ⟩
  )
  →
  rxp 
 Regexp.new(
  regexp
  )
  →
  
 new_regexp
  
 Constructs a new regular expression from
  pattern
 , which can be either a
  String
  or a
  
 Regexp
 . In the latter case that regexp’s options are propagated, and new options may 
 not be specified (a change as of Ruby 1.8). If
  options
  is a
  Fixnum
 , it should be one or 
 more of
  Regexp::EXTENDED
 ,
  Regexp::IGNORECASE
 , and
  Regexp::POSIXLINE
 ,
  or
 -ed 
 together. Otherwise, if
  options
  is not
  nil
 , the regexp will be case insensitive. The
  lang
  
 Prepared exclusively for Yeganefar",NA
R,"egexp
  
 else
  
 print ""Mixed case\n""
  
 end
  
 produces:
  
 Upper case
  
 =~
  
 rxp
  =~
  string
  →
  int
  or
  nil 
 Match—Matches
  rxp
  against
  string
 , returning the offset of the start of the match or
  nil
  
 if the match failed. Sets
  $~
  to the corresponding
  MatchData
  or
  nil
 .
  
  
 /SIT/
  
 =~ ""insensitive""
  
 →
  
 nil
  
 /SIT/i =~ ""insensitive""
  
 →
  
 5
  
 ~
  
  
 ~
  rxp
  →
  int
  or
  nil 
 Match—Matches
  rxp
  against the contents of
  $_
 . Equivalent to
  rxp
  =~ $_
 .
  
 $_ = ""input data""
  
 ~ /at/
  
 →
  
 7
  
  
 Prepared exclusively for Yeganefar",NA
R,"# Let's see what the values are...
  
 Regexp::IGNORECASE
  
 →
  
 1
  
 Regexp::EXTENDED
  
 2
  
 →
  
 Regexp::MULTILINE
  
 →
  
 4
  
 /cat/.options
  
 0
  
 →
  
 /cat/ix.options
  
 3
  
 →
  
 Regexp.new('cat', true).options
  
 →
  
 1
  
 Regexp.new('cat', 0, 's').options
  
 →
  
 48
  
 r = /cat/ix
  
  
 Regexp.new(r.source, r.options)
  
 →
  
 /cat/ix
  
  
 source
  
 Returns the original string of the 
 pattern.
  
  
  
 rxp
 .source
  →
  string
  
 /ab+c/ix.source
  
 →
  
 ""ab+c""
  
  
 Prepared exclusively for Yeganefar",NA
R,"egexp
  
 s1 = r1.to_s
  
 →
  
 ""(?ix-m:ab+c)""
  
 r2 = Regexp.new(s1)
  
 →
  
 /(?ix-m:ab+c)/
  
 r1 == r2
  
 →
  
 false
  
 r1.source
  
 ""ab+c""
  
 →
  
 r2.source
  
 →
  
 ""(?ix-m:ab+c)""
  
  
 Prepared exclusively for Yeganefar",NA
 Signal,"Many operating systems allow signals to be sent to running processes. Some signals 
 have a defined effect on the process, and others may be trapped at the code level and 
 acted upon. For example, your process may trap the
  USR1
  signal and use it to toggle 
 debugging, and it may use
  TERM
  to initiate a controlled shutdown.
  
 pid = fork do 
  
 Signal.trap(""USR1"") do 
  
   
 $debug = !$debug 
  
   
 puts ""Debug now: #$debug"" 
  
 end 
  
 Signal.trap(""TERM"") do 
  
   
 puts ""Terminating..."" 
  
   
 shutdown() 
  
 end 
  
 # . . . do some work . . .
  
 end
  
 Process.detach(pid)
  
 # Controlling program: 
  
 Process.kill(""USR1"", pid) 
  
 # ...
  
 Process.kill(""USR1"", pid) 
  
 # ...
  
 Process.kill(""TERM"", pid)
  
 produces:
  
 Debug now: true
  
 Debug now: false 
  
 Terminating...
  
 ignal
  
 The list of available signal names and their interpretation is system dependent. Signal",NA
S,"delivery semantics may also vary between systems; in particular signal delivery may 
 not always be reliable.
  
 Module methods
  
 list
  
 Signal.list
  →
  hash 
 Returns a list of signal names mapped to the corresponding underlying signal 
 numbers.
  
 Signal.list
  
 →
  
 {""ABRT""=>6, ""ALRM""=>14, ""BUS""=>10, ""CHLD""=>20,
  
 ""CLD""=>20, ""CONT""=>19, ""EMT""=>7, ""FPE""=>8, ""HUP""=>1, 
  
 ""ILL""=>4, ""INFO""=>29, ""INT""=>2, ""IO""=>23, ""IOT""=>6, 
  
 ""KILL""=>9, ""PIPE""=>13, ""PROF""=>27, ""QUIT""=>3, 
  
 ""SEGV""=>11, ""STOP""=>17, ""SYS""=>12, ""TERM""=>15, 
  
 ""TRAP""=>5, ""TSTP""=>18, ""TTIN""=>21, ""TTOU""=>22, 
  
 ""URG""=>16, ""USR1""=>30, ""USR2""=>31, ""VTALRM""=>26, 
  
 ""WINCH""=>28, ""XCPU""=>24, ""XFSZ""=>25}
  
 Prepared exclusively for Yeganefar",NA
S,"ignal
  
  
 Prepared exclusively for Yeganefar",NA
String,"<
  
 Object
  
 S
 TRING
  
 585
  
 A
  String
  object holds and manipulates a sequence of bytes, typically representing 
 characters. String objects may be created using
  String.new
  or as literals (see page 
 305
 ).
  
 Because of aliasing issues, users of strings should be aware of the methods that 
 modify the contents of a
  String
  object. Typically, methods with names ending in
  !
  
 modify their receiver, while those without a
  !
  return a new
  String
 . However, 
 exceptions exist, such as
  String
 #
 []=
 .
  
 Mixes in
  
 Comparable
 :
  
 <, <=, ==, >=, >, between?
  
 Enumerable
 :
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Class methods
  
 new 
 1.8
  
  
 String.new(
  val
 ="""" )
  →
  str
  
 Returns a new string object containing a copy of
  val
  (which should
  
 be a
  String
  or
  
 implement
  to_str
 ).
  
 str1 = ""wibble"" 
  
 str2 = String.new(str1)",NA
S,"tring
  
 str1.object_id
  
 →
  
 936550
  
 str2.object_id
  
 →
  
 936540
  
  
 str1[1] = ""o"" 
 str1
  
 ""o"" 
  
  
 →
  
 ""wobble""
  
 str2
  
 ""wibble""
  
 →
  
 Instance methods
  
 %
  
 str
  %
  arg
  →
  string 
 Format—Uses
  str
  as a format specification, and returns the result of applying it to
  
 arg
 .
  
 If the format specification contains more than one substitution, then
  arg
  must be an 
 Array
  containing the values to be substituted. See
  Kernel.sprintf
  on page
  508
  for details 
 of the format string.
  
 ""%05d"" % 123
  
 →
  
 ""00123""
  
 ""%-5s: %08x"" % [ ""ID"", self.id ]
  
 →
  
 ""ID
  
 : 000ec4dc""",NA
S,"tring
  
 <=>
  is the basis for the methods
  <
 ,
  <=
 ,
  >
 ,
  >=
 , and
  between?
 , included from module
  
 Comparable
 . The method
  String
 #
 ==
  does not use
  Comparable
 #
 ==
 .
  
 ""abcdef"" <=> ""abcde""
  
 →
  
 1
  
 ""abcdef"" <=> ""abcdef""
  
 →
  
 0
  
 ""abcdef"" <=> ""abcdefg""
  
 →
  
 -1
  
 ""abcdef"" <=> ""ABCDEF""
  
 →
  
 1
  
 ==
  
 str
  ==
  obj
  →
  true
  or
  false
  
  
 1.8
  
  
  
 Equality—If
  obj
  is a
  String
 , returns
  true
  if
  str
  <=>
  obj
  equals zero; returns
  false
  
 otherwise. If
  obj
  is not a
  String
  but responds to
  to_str
 ,
  
 return
  obj
  ==
  str
 ; otherwise
  
 returns false.
  
  
 ""abcdef"" == ""abcde""
  
 →
  
 false
  
  
 ""abcdef"" == ""abcdef""
  
 →
  
 true
  
 ===
  
 Case Equality—Synonym for
  String
 #
 ==
 .
  
 str
  ===
  obj
  →
  true
  or
  false
  
  
 Prepared exclusively for Yeganefar",NA
S,"a[1..3]
  
 →
  
 ""ell""
  
 a[1...3]
  
 →
  
 ""el""
  
  
 a[-3,2]
  
 →
  
 ""er""
  
 a[-4..-2]
  
 ""her""
  
 →
  
 a[-2..-4]
  
 →
  
 """"
  
 a[/[aeiou](.)\1/]
  
 ""ell""
  
 →
  
 a[/[aeiou](.)\1/, 0]
  
 →
  
 ""ell""
  
 a[/[aeiou](.)\1/, 1]
  
 →
  
 ""l""
  
 a[/[aeiou](.)\1/, 2]
  
 →
  
 nil
  
 a[/(..)e/]
  
 →
  
 ""the""
  
 a[/(..)e/, 1]
  
 →
  
 ""th""
  
 a[""lo""]
  
 →
  
 ""lo""
  
 a[""bye""]
  
 nil
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 a[2, 4] = ""xyz""
  
 (a
  →
  ""hexyz"")
  
 a[-4, 2] = ""xyz""
  
 (a
  →
  ""hxyzlo"")
  
 a[2..4] = ""xyz""
  
 (a
  →
  ""hexyz"")
  
 a[-4..-2] = ""xyz""
  
 (a
  →
  ""hxyzo"")
  
 a[/[aeiou](.)\1(.)/] = ""xyz""
  
 (a
  →
  ""hxyz"")
  
 a[/[aeiou](.)\1(.)/, 1] = ""xyz""
  
 (a
  →
  ""hexyzlo"")
  
 a[/[aeiou](.)\1(.)/, 2] = ""xyz""
  
 (a
  →
  ""hellxyz"")
  
 a[""l""] = ""xyz""
  
 (a
  →
  ""hexyzlo"")
  
 a[""ll""] = ""xyz""
  
 (a
  →
  ""hexyzo"")
  
 a[2, 0] = ""xyz""
  
 (a
  →
  ""hexyzllo"")
  
 ~
  
 Equivalent to
  $_ =~
  str
 .
  
 ~
  str
 →
  int
  or
  nil
  
  
 capitalize
  
 str
 .capitalize
  →
  string
  
  
 Returns a copy of
  str
  with the first character converted to uppercase and the remainder
  
 to lowercase.
  
 ""hello"".capitalize
  
 →
  
 ""Hello""
  
  
 ""HELLO"".capitalize
  
 →
  
 ""Hello""
  
 ""123ABC"".capitalize
  
 →
  
 ""123abc""
  
 capitalize!
  
 str
 .capitalize!
  →
  str
  or
  nil
  
 «
  
 Modifies
  str
  by converting the first character to uppercase and the remainder to lower-
 case. Returns
  nil
  if no changes are made.",NA
S,"""hello\r\n"".chomp
  
 →
  
 ""hello""
  
  
 ""hello\n\r"".chomp
  
 →
  
 ""hello\n""
  
  
 ""hello\r"".chomp
  
 →
  
 ""hello""
  
 ""hello \n there"".chomp
  
 →
  
 ""hello \n there""
  
 ""hello"".chomp(""llo"")
  
 →
  
 ""he""
  
 chomp
 !
  
 str
 .chomp!(
  rs
 =
 $/
  )
  →
  str
  or
  nil
  
  
 Modifies
  str
  in place as described for
  String
 #
 chomp
 , returning
  str
 , or returning
  nil
  if
  
 no modifications were made.
  
 chop
  
 str
 .chop
  →
  string 
 Returns a new
  String
  with the last character removed. If the string ends with
  \r\n
 ,
  
 both characters are removed. Applying
  chop
  to an empty string returns an empty string.
  
 String
 #
 chomp
  is often a safer alternative, as it leaves the string unchanged if it doesn’t
  
 end in a record separator.
  
 Prepared exclusively for Yeganefar",NA
S,"such as DES encryption parameters. See the man page for
  crypt(3)
  for details.
  
 # standard salt
  
 ""secret"".crypt(""sh"")
  
 →
  
 ""shRK3aVg8FsI2""
  
 # On OSX: DES, 2 interactions, 24-bit salt
  
  
 ""secret"".crypt(""_...0abcd"")
  
 →
  
 ""_...0abcdROn65JNDj12""
  
 delete
   
  
 str
 .delete(
  ⟨
  string
  ⟩
 +
 )
  →
  new_string
  
 Returns a copy of
  str
  with all characters in the intersection of its arguments deleted.
  
 Uses the same rules for building the set of characters as
  String
 #
 count
 .
  
 ""hello"".delete(""l"",""lo"")
  
 →
  
 ""heo""
  
 ""hello"".delete(""lo"")
  
 →
  
 ""he""
  
 ""hello"".delete(""aeiou"", ""^e"")
  
 →
  
 ""hell""
  
 ""hello"".delete(""ej-m"")
  
 ""ho""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 Splits
  str
  using the supplied parameter as the record separator (
 $/
  by default), pass-
  
 ing each substring in turn to the supplied block. If a zero-length record separator is
  
 supplied, the string is split into paragraphs, each terminated by multiple
  \n
  characters.
  
 print ""Example one\n"" 
  
 ""hello\nworld"".each {|s| p s} 
  
 print ""Example two\n"" 
  
 ""hello\nworld"".each('l') {|s| p s} 
  
 print ""Example three\n"" 
  
 ""hello\n\n\nworld"".each('') {|s| p s}
  
 produces:
  
 Example one 
  
 ""hello\n"" 
  
 ""world"" 
  
 Example two 
  
 ""hel"" 
  
 ""l"" 
  
 ""o\nworl"" 
  
 ""d"" 
  
 Example three 
  
 ""hello\n\n\n"" 
  
 ""world""
  
 Prepared exclusively for Yeganefar",NA
S,"and
  $1
 ) cannot be substituted into it, as substitution into the string occurs before the 
 pattern match starts. However, the sequences
  \1
 ,
  \2
 , and so on may be used to 
 interpo-late successive groups in the match. These sequences are shown in Table
  
 27.13
  on the following page.
  
 In the block form, the current match is passed in as a parameter, and variables such as 
 $1
 ,
  $2
 ,
  $`
 ,
  $&
 , and
  $'
  will be set appropriately. The value returned by the block will be 
 substituted for the match on each call.
  
 The result inherits any tainting in the original string or any supplied replacement string.
  
 ""hello"".gsub(/[aeiou]/, '*')
  
 →
  
 ""h*ll*""
  
 ""hello"".gsub(/([aeiou])/, '<\1>')
  
 →
  
 ""h<e>ll<o>""
  
 ""hello"".gsub(/./) {|s| s[0].to_s + ' '}
  
 →
  
 ""104 101 108 108 111 ""
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 Returns
  true
  if
  str
  contains the given string or character.
  
 ""hello"".include? ""lo""
  
 →
  
 true
  
  
 ""hello"".include? ""ol""
  
 →
  
 false
  
 ""hello"".include? ?h
  
 →
  
 true
  
 index
  
 str
 .index(
  string
  ⟨
  ,
  offset
  ⟩
  )
  →
  int
  or
  nil 
 str
 .index(
  int
  ⟨
  ,
  offset
  ⟩
  )
  →
  int
  or
  nil 
 str
 .index(
  regexp
  ⟨
  ,
  offset
  ⟩
  )
  →
  int
  or
  nil
  
  
 Returns the index of the first occurrence of the given substring, character, or pattern in
  
 str
 . Returns
  nil
  if not found. If the second parameter is present, it specifies the position
  
 in the string to begin the search.
  
 ""hello"".index('e')
  
 →
  
 1
  
 ""hello"".index('lo')
  
 3
  
 →
  
 ""hello"".index('a')
  
 →
  
 nil
  
 ""hello"".index(101)
  
 →
  
 1
  
 ""hello"".index(/[aeiou]/, -3)
  
 →
  
 4
  
  
 Prepared exclusively for Yeganefar",NA
S,"lstrip
  
 str
 .lstrip
  →
  string
  
  
 1.8
  
  
 Returns a copy of
  str
  with leading whitespace characters removed. Also see the meth-
  
 ods
  String
 #
 rstrip
  and
  String
 #
 strip
 .
  
  
 ""
  
 hello
  
 "".lstrip
  
 →
  
 ""hello
  
 ""
  
 ""\000 hello
  
 "".lstrip
  
 →
  
 ""\000 hello
  
 ""
  
 ""hello"".lstrip
  
 →
  
 ""hello""
  
 lstrip!
  
 str
 .lstrip!
  →
  
 self or
  nil
  
 1.8
  
  
 Removes leading whitespace characters from
  str
 , returning
  nil
  if no change was made.
  
 See also
  String
 #
 rstrip!
  and
  String
 #
 strip!
 .
  
 ""
  
 hello
  
 "".lstrip!
  
 →
  
 ""hello
  
 ""
  
 ""hello"".lstrip!
  
 →
  
 nil
  
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 Replaces the contents and taintedness of
  str
  with the corresponding values in
  string
 .
  
 s = ""hello""
  
 →
  
 ""hello""
  
 s.replace ""world""
  
 →
  
 ""world""
  
 revers
 e
  
 str
 .reverse
  →
  string",NA
S,"Returns a new string with the characters from
  str
  in reverse order.
  
 # Every problem contains its own solution...
  
 ""stressed"".reverse
  
 →
  
 ""desserts""
  
  
 reverse!
  
  
  
 str
 .reverse!
  →
  str
  
 Reverses
  str
  in place.
  
  
  
  
 rindex
  
  
  
 str
 .rindex(
  string
  ⟨
  ,
  int
  ⟩
  )
  →
  int
  or
  nil 
 str
 .rindex(
  int
  ⟨
  ,
  int
  ⟩
  )
  →
  int
  or
  nil 
 str
 .rindex(
  regexp
  ⟨
  ,
  int
  ⟩
  )
  →
  int
  or
  nil
  
 Returns the index of the last occurrence of the given substring, character, or pattern in
  
 str
 . Returns
  nil
  if not found. If the second parameter is present, it specifies the position
  
 in the string to end the search—characters beyond this point will not be considered.
  
 Prepared exclusively for Yeganefar",NA
S,"scan
  
 str
 .scan(
  pattern
  )
  →
  array 
 str
 .scan(
  pattern
  ) {
 | match, ... | block
  }
  →
  str
  
  
 Both forms iterate through
  str
 , matching the pattern (which may be a
  Regexp
  or a
  
 String
 ). For each match, a result is generated and either added to the result array or
  
 passed to the block. If the pattern contains no groups, each individual result consists of
  
 the matched string,
  $&
 . If the pattern contains groups, each individual result is itself an
  
 array containing one entry per group. If the pattern is a
  String
 , it is interpreted literally
  
 (i.e., it is not taken to be a regular expression pattern).
  
 a = ""cruel world""
  
 a.scan(/\w+/)
  
 →
  
 [""cruel"", ""world""]
  
 a.scan(/.../)
  
 [""cru"", ""el "", ""wor""]
  
 →
  
 a.scan(/(...)/)
  
 →
  
 [[""cru""], [""el ""], [""wor""]]
  
 a.scan(/(..)(..)/)
  
 [[""cr"", ""ue""], [""l "", ""wo""]]
  
 →
  
 And the block form
  
 Prepared exclusively for Yeganefar",NA
S,"Deletes the specified portion from
  str
 , and returns the portion deleted. The forms that
  
 take a
  Fixnum
  will raise an
  IndexError
  if the value is out of range; the
  Range
  form will 
 raise a
  RangeError
 , and the
  Regexp
  and
  String
  forms will silently not change the string.
  
 string = ""this is a string""
  
 string.slice!(2)
  
 →
  
 105
  
 string.slice!(3..6)
  
 →
  
 "" is ""
  
 string.slice!(/s.*t/)
  
 →
  
 ""sa st""
  
 string.slice!(""r"")
  
 →
  
 ""r""
  
 string
  
 ""thing""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 ""a@1bb@2ccc"".split(/@(\d)/)
  
 →
  
 [""a"", ""1"", ""bb"", ""2"", ""ccc""]
  
 ""1, 2.34,56, 7"".split(/,\s*/)
  
 →
  
 [""1"", ""2.34"", ""56"", ""7""]
  
 [""h"", ""e"", ""l"", ""l"", ""o""]
  
 ""hello"".split(//)
  
 →
  
 ""hello"".split(//, 3)
  
 →
  
 [""h"", ""e"", ""llo""]
  
 ""hi mom"".split(/\s*/)
  
 [""h"", ""i"", ""m"", ""o"", ""m""]
  
 →
  
 →
  
 []
  
 """".split
  
 ""mellow yellow"".split(""ello"")
  
 →
  
 [""m"", ""w y"", ""w""]
  
 ""1,2,,3,4,,"".split(',')
  
  
 [""1"", ""2"", """", ""3"", ""4""]
  
  
 →
  
 ""1,2,,3,4,,"".split(',', 4)
  
 →
  
 [""1"", ""2"", """", ""3,4,,""]
  
 ""1,2,,3,4,,"".split(',', -4)
  
 [""1"", ""2"", """", ""3"", ""4"", """", """"]
  
 →
  
 squeeze
  
  
 str
 .squeeze(
  ⟨
  string
  ⟩
 ∗
 )
  →
  squeezed_tring
  
  
 Builds a set of characters from the
  string
  parameter(s) using the procedure described 
 for
  String
 #
 count
  on page
  590
 . Returns a new string where runs of the same character 
 that occur in this set are replaced by a single character. If no arguments are given, all 
 runs of identical characters are replaced by a single character.
  
 ""yellow moon"".squeeze
  
 →
  
 ""yelow mon""
  
 ""
  
 now
  
 is
  
 the"".squeeze("" "")
  
 →
  
 "" now is the""
  
 ""putters putt balls"".squeeze(""m-z"")
  
 ""puters put balls""
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
S,"substituted for the match on each call.
  
 ""hello"".sub(/[aeiou]/, '*')
  
 →
  
 ""h*llo""
  
 ""hello"".sub(/([aeiou])/, '<\1>')
  
 →
  
 ""h<e>llo""
  
 ""hello"".sub(/./) {|s| s[0].to_s + ' ' }
  
 →
  
 ""104 ello""
  
 sub!
  
 str
 .sub!(
  pattern
 ,
  replacement
  )
  →
  str
  or
  nil 
 str
 .sub!(
  pattern
  ) {
 | match | block
  }
  →
  str
  or
  nil
  
  
 Performs the substitutions of
  String
 #
 sub
  in place, returning
  str
 . Returns
  nil
  if no
  
 substitutions were performed.
  
 succ
  
 str
 .succ
  →
  string 
 Returns the successor to
  str
 . The successor is calculated by incrementing characters
  
 starting from the rightmost alphanumeric (or the rightmost character if there are no
  
 alphanumerics) in the string. Incrementing a digit always results in another digit, and
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 Returns a copy of
  str
  with uppercase alphabetic characters converted to lowercase and 
 lowercase characters converted to uppercase.
  
 ""Hello"".swapcase
  
 →
  
 ""hELLO""
  
 ""cYbEr_PuNk11"".swapcase
  
 →
  
 ""CyBeR_pUnK11""
  
 swapcase!
  
 str
 .swapcase!
  →
  str
  or
  nil
  
  
 Equivalent to
  String
 #
 swapcase
 , but modifies
  str
  in place, returning
  str
 . Returns
  nil
  
 if no changes were made.
  
 to_f
  
 str
 .to_f
  →
  float 
 Returns the result of interpreting leading characters in
  str
  as a floating-point number.
  
 Extraneous characters past the end of a valid number are ignored. If there is not a 
 valid number at the start of
  str
 ,
  0.0
  is returned. The method never raises an exception 
 (use 
 Kernel.Float
  to validate numbers).
  
 ""123.45e1"".to_f
  
 →
  
 1234.5
  
 ""45.67 degrees"".to_f
  
 →
  
 45.67
  
 ""thx1138"".to_f
  
 →
  
 0.0
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 convert their arguments to a string. Unlike
  to_s
 , which is supported by almost all
  
 classes,
  to_str
  is normally implemented only by those classes that act like strings. Of
  
 the built-in classes, only
  Exception
  and
  String
  implement
  to_str
 .
  
 to_sy
 m
  
 str
 .to_s
  →
  symbol
  
  
 Returns the symbol for
  str
 . This can create symbols that cannot be represented using
  
 the
  :xxx
  notation.
  
  
 s = 'cat'.to_sym
  
 →
  
 :cat
  
 s == :cat
  
 →
  
 true
  
 s = '@cat'.to_sym
  
 →
  
 :@cat
  
 s == :@cat
  
 →
  
 true
  
 'cat and dog'.to_sym
  
 →
  
 :""cat and dog""
  
 s == :'cat and dog'
  
 →
  
 false
  
 tr
  
 str
 .tr(
  from_string
 ,
  to_string
  )
  →
  string 
 Returns a copy of
  str
  with the characters in
  from_string
  replaced by the 
 corresponding
  
 characters in
  to_string
 . If
  to_string
  is shorter than
  from_string
 , it is padded with its last
  
 character. Both strings may use the
  c
 1
 –
 c
 2
  notation to denote ranges of characters, and 
 from_string
  may start with a
  ^
 , which denotes all characters except those listed.
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
 followed by an underscore (
  _
  ) to use the underlying platform’s native size for the
  
 specified type; otherwise, it uses a platform-independent consistent size. Spaces are
  
  
 ignored in the format string. Comments
  
 starting with
  #
  to the next newline or end of
  
  
 string are also ignored. See also
  Array
 #
 pack
  on page
  415
 .
  
  
 ""abc \0\0abc \0\0"".unpack('A6Z6')
  
 →
  
 [""abc"", ""abc ""]
  
 ""abc \0\0"".unpack('a3a3')
  
 →
  
 [""abc"", "" \000\000""]
  
 ""aa"".unpack('b8B8')
  
 →
  
 [""10000110"", ""01100001""]
  
 ""aaa"".unpack('h2H2c')
  
 →
  
 [""16"", ""61"", 97]
  
 ""\xfe\xff\xfe\xff"".unpack('sS')
  
 →
  
 [-257, 65279]
  
 ""now=20is"".unpack('M*')
  
 →
  
 [""now is""]
  
 ""whole"".unpack('xax2aX2aX1aX2a')
  
 →
  
 [""h"", ""e"", ""l"", ""l"", ""o""]
  
 upcase
  
 str
 .upcase
  →
  string 
 Returns a copy of
  str
  with all lowercase letters replaced with their uppercase counter-
  
 parts. The operation is locale insensitive—only characters
  a
  to
  z
  are affected.
  
 ""hEllO"".upcase
  
 →
  
 ""HELLO""
  
  
 Prepared exclusively for Yeganefar",NA
S,"Q
  
 Treat eight characters as an unsigned quad word (64 bits).
  
 Integer
  
 q
  
 Treat eight characters as a signed quad word (64 bits).
  
 Integer
  
 S
  
 Treat two
 1
 successive characters as an unsigned short in native byte order.
  
 Fixnum
  
 s
  
 Treat two
 1
 successive characters as a signed short in native byte order.
  
 Fixnum
  
 U
  
 Extract UTF-8 characters as unsigned integers.
  
 Integer
  
 u
  
 Extract a UU-encoded string.
  
 String
  
 V
  
 Treat four characters as an unsigned long in little-endian byte order.
  
 Fixnum
  
 v
  
 Treat two characters as an unsigned short in little-endian byte order.
  
 Fixnum
  
 w
  
 BER-compressed integer (see
  Array#pack
  for more information).
  
 Integer
  
 X
  
 Skip backward one character.
  
 —
  
 x
  
 Skip forward one character.
  
 —
  
 Z
  
 String with trailing
  NUL
 s removed.
  
 String
  
 @
  
 Skip to the offset given by the length argument.
  
 —
  
 1
  
 May be modified by appending “_” to the directive.
  
  
  
  
 Prepared exclusively for Yeganefar",NA
S,"tring
  
  
 Prepared exclusively for Yeganefar",NA
Struct,"<
  
 Object
  
 S
 TRUCT
  
 605
  
 Subclasses: Struct::Tms
  
 A
  Struct
  is a convenient way to bundle a number of attributes together, using accessor 
 methods, without having to write an explicit class.
  
 The
  Struct
  class is a generator of specific classes, each one of which is defined to hold 
 a set of variables and their accessors. In these examples, we’ll call the generated class 
 Customer
 , and we’ll show an example instance of that class as
  joe
 .
  
 Also see
  OpenStruct
  on page
  689
 .
  
 In the descriptions that follow, the parameter
  symbol
  refers to a symbol, which is either 
 a quoted string or a
  Symbol
  (such as
  :name
 ).
  
 Mixes in
  
 Enumerable
 :
  
 all?, any?, collect, detect, each_with_index, entries, find, find_all,
  
 grep, include?, inject, map, max, member?, min, partition, reject,
  
 select, sort, sort_by, to_a, zip
  
 Class methods
  
 new
  
 Struct.new(
  ⟨
  string
  ⟩ ⟨
  ,
  symbol
  ⟩
 +
 )
  →
  Customer 
 [1.9]
  
 Struct.new(
  ⟨
  string
  ⟩ ⟨
  ,
  symbol
  ⟩
 +
 ) {
  block
  }
  →
  Customer",NA
S,"truct
  
 Creates a new class, named by
  string
 , containing accessor methods for the given 
 sym-
  
 bols. If the name
  string
  is omitted, an anonymous structure class will be created. Oth-
  
 erwise, the name of this struct will appear as a constant in class
  Struct
 , so it must be
  
 unique for all
  Struct
 s in the system and should start with a capital letter. Assigning a
  
 structure class to a constant effectively gives the class the name of the constant.
  
 Struct.new
  returns a new
  Class
  object, which can then be used to create specific 
 instances of the new structure. The remaining methods listed below (class and 
 instance) are defined for this generated class. See the description that follows for an 
 example.
  
 Ruby 1.9 and later allow you to pass a block to a
  Struct
 ’s constructor. This block is 
 evaluated in the context of the new struct’s class and hence allows you conveniently 
 to add instance methods to the new struct.
  
 # Create a structure with a name in Struct
  
 Struct.new(""Customer"", :name, :address)
  
 →
  
 Struct::Customer
  
 Struct::Customer.new(""Dave"", ""123 Main"")
  
 →
  
 #<struct
  
 Struct::Customer 
  
 name=""Dave"", 
  
 address=""123 Main"">",NA
S,"Customer.members
  
 →
  
 [""name"", ""address"", ""zip""]
  
 Instance methods
  
 ==
  
 joe
  ==
  other_struct
  →
  true
  or
  false 
 Equality—Returns
  true
  if
  other_struct
  is equal to this one: they must be of the same
  
 class as generated by
  Struct.new
 , and the values of all instance variables must be equal 
 (according to
  Object
 #
 ==
 ).
  
 Customer = Struct.new(:name, :address, :zip)
  
 joe 
  
 = Customer.new(""Joe Smith"", ""123 Maple, Anytown NC"", 12345) joejr = 
 Customer.new(""Joe Smith"", ""123 Maple, Anytown NC"", 12345) jane 
  
 = 
 Customer.new(""Jane Doe"", ""456 Elm, Anytown NC"", 12345)
  
 joe == joejr
  
 →
  
 true 
  
 joe == jane
  
 →
  
 false
  
 Prepared exclusively for Yeganefar",NA
S,"truct
  
 Calls
  block
  once for each instance variable, passing the value as a parameter.
  
 Customer = Struct.new(:name, :address, :zip)
  
 joe = Customer.new(""Joe Smith"", ""123 Maple, Anytown NC"", 12345)
  
 joe.each {|x| puts(x) }
  
 produces:
  
 Joe Smith 
  
 123 Maple, Anytown NC 
  
 12345
  
 each_pair
  
  
 1.8 
 Calls
  block
  once for each instance variable, passing the name (as a symbol) and the 
  
  
 joe
 .each_pair {
 | symbol, obj | block
  }
  →
  joe
  
 value as parameters.
  
 Customer = Struct.new(:name, :address, :zip) 
  
 joe = Customer.new(""Joe Smith"", ""123 Maple, Anytown NC"", 12345) joe.each_pair {|name, 
 value| puts(""#{name} => #{value}"") }
  
 produces:
  
 name => Joe Smith 
  
 address => 123 Maple, Anytown NC 
  
 zip => 12345
  
 Prepared exclusively for Yeganefar",NA
S,"truct
  
 Lots = Struct.new(:a, :b, :c, :d, :e, :f) 
  
 l = Lots.new(11, 22, 33, 44, 55, 66)
  
 l.values_at(1, 3, 5)
  
 →
  
 [22, 44, 66]
  
 l.values_at(0, 2, 4)
  
 [11, 33, 55]
  
 →
  
 l.values_at(-1, -3, -5)
  
 →
  
 [66, 44, 22]
  
  
 Prepared exclusively for Yeganefar",NA
Struct::Tms,"<
  
 Struct
  
 S
 TRUCT
 ::T
 MS
  
 609
  
 This structure is returned by
  Process.times
 . It holds information on process times on 
 those platforms that support it. Not all values are valid on all platforms. This structure 
 contains the following instance variables and the corresponding accessors:
  
 utime 
  
 stime 
  
 cutime
  
 Amount of user CPU time, in seconds 
  
 Amount of system CPU time, in seconds 
  
 Total of completed child processes’ user CPU time, in seconds (always 0 
 on
  
  
 Windows) 
  
 cstime 
  
 Total of completed child processes’ system CPU time, in seconds (always 0 
  
 on Windows)
  
 See also
  Struct
  on page
  605
  and
  Process.times
  on page
  566
 .
  
 def eat_cpu 
  
 100_000.times { Math.sin(0.321) } 
  
 end 
  
 3.times { fork { eat_cpu } } 
  
 eat_cpu 
  
 Process.waitall 
  
 t = Process::times
  
 [ t.utime, t.stime]
  
 →
  
 [0.28, 0.03]",NA
S,"truct::Tms
  
 [ t.cutime, t.cstime ]
  
 →
  
 [0.74, 0.01]
  
  
 Prepared exclusively for Yeganefar",NA
Symbol,"<
  
 Object
  
 S
 YMBOL
  
 610
  
 Symbol
  objects represent names inside the Ruby interpreter. They are generated using 
 the
  :name
  literal syntax and by using the various
  to_sym
  methods. The same
  Symbol 
 object will be created for a given name string for the duration of a program’s 
 execution, regardless of the context or meaning of that name. Thus, if
  Fred
  is a 
 constant in one context, a method in another, and a class in a third, the
  Symbol :Fred
  
 will be the same object in all three contexts.
  
 module One 
  
 class Fred 
  
 end 
  
 $f1 = :Fred 
  
 end 
  
 module Two 
  
 Fred = 1 
  
 $f2 = :Fred 
  
 end 
  
 def Fred() 
  
 end 
  
 $f3 = :Fred
  
 $f1.id
  
 →
  
 2526478
  
 $f2.id
  
 →
  
 2526478
  
 $f3.id
  
 2526478
  
 →
  
 Class methods
  
 all_symbols
  
  
 1.8 
 Returns an array of all the symbols currently in Ruby’s symbol table. 
  
  
 Symbol.all_symbols
  →
  array
  
 ymbol
  
 Symbol.all_symbols.size
  
 →
  
 913",NA
S,"Symbol.all_symbols[1,20]
  
 →
  
 [:floor, :ARGV, :Binding, :symlink,
  
 :chown, :EOFError, :$;, :String, 
  
 :LOCK_SH, :""setuid?"", :$<, 
  
 :default_proc, :compact, :extend, :Tms, 
  
 :getwd, :$=, :ThreadGroup, :""success?"", 
  
 :wait2]
  
 Instance methods
  
 id2name
  
 sym
 .id2name
  →
  string 
 Prior to Ruby 1.8, symbols typically repre-
  
 1.8
  
  
 Returns the string representation of
  sym
 .
  
 sented names; now they can be arbitrary strings.
  
 :fred.id2name
  
 →
  
 ""fred""
  
 :""99 red balloons!"".id2name
  
 →
  
 ""99 red balloons!""
  
  
 Prepared exclusively for Yeganefar",NA
S,"ymbol
  
 Symbols are symbol-like!
  
  
 Prepared exclusively for Yeganefar",NA
Thread,"<
  
 Object
  
 T
 HREAD
  
 612
  
 Thread
  encapsulates the behavior of a thread of execution, including the main thread of 
 the Ruby script. See the tutorial in Chapter
  11
 , beginning on page
  127
 .
  
 In the descriptions that follow, the parameter
  symbol
  refers to a symbol, which is either 
 a quoted string or a
  Symbol
  (such as
  :name
 ).
  
 Class methods
  
 abort_on_exception
  
 Thread.abort_on_exception
  →
  true
  or
  false
  
 Returns the status of the global “abort on exception” condition. The default is
  false
 .
  
 When set to
  true
 , or if the global
  $DEBUG
  flag is
  true
  (perhaps because the command 
 line option
  -d
  was specified) all threads will abort (the process will
  exit(0)
 ) if an 
 exception is raised in any thread. See also
  Thread.abort_on_exception=
 .
  
 abort_on_exception=
  
 Thread.abort_on_exception=
  bool
 →
  true
  or
  false
  
 When set to
  true
 , all threads will abort if an exception is raised. Returns the new state.
  
 Thread.abort_on_exception = true 
  
 t1 = Thread.new do 
  
 puts ""In new thread"" 
  
 raise ""Exception from thread"" 
  
 end 
  
 sleep(1) 
  
 puts ""not reached""
  
 produces:
  
 In new thread 
  
 prog.rb:4: Exception from thread (RuntimeError) 
  
 from prog.rb:2:in `initialize'
  
 hread
  
 from prog.rb:2:in `new' 
  
 from prog.rb:2",NA
T,"critical
   
 Thread.critical
  →
  true
  or
  false 
 Returns the status of the global “thread critical” condition.
  
  
 critical= 
 Thread.critical=
  bool
  →
  true
  or
  false
  
 Sets the status of the global “thread critical” condition and returns it. When set to
  true
 ,
  
  
 prohibits scheduling of any existing thread. Does not block new threads from being 
 created and run. Certain thread operations (such as stopping or killing a thread, 
 sleeping in the current thread, and raising an exception) may cause a thread to be 
 scheduled even when in a critical section.
  Thread.critical
  is not intended for daily use: 
 it is primarily there to support folks writing threading libraries.
  
 Prepared exclusively for Yeganefar",NA
T,"#<Thread:0x1c960c sleep> 
  
 #<Thread:0x1c9698 run> 
  
 #<Thread:0x1c96fc sleep> 
  
 #<Thread:0x1d5790 run>
  
 main
  
 Returns the main thread for the process.
  
 Thread.main
  →
  thread
  
  
  
 Thread.main
  
 →
  
 #<Thread:0x1d5790 run>
  
 new
  
 Thread.new(
  ⟨
  arg
  ⟩
 ∗
 ) {
 | args | block
  }
  →
  thread
  
 Creates and runs a new thread to execute the instructions given in
  block
 . Any 
 arguments passed to
  Thread.new
  are passed into the block.
  
 Prepared exclusively for Yeganefar",NA
T,"hread
  
 Instance methods
  
 [ ]
  
 thr
 [
  symbol
  ]
  →
  obj
  or
  nil 
 Attribute Reference—Returns the value of a thread-local variable, using either a 
 symbol
  
 or a string name. If the specified variable does not exist, returns
  nil
 .
  
 a = Thread.new { Thread.current[""name""] = ""A""; Thread.stop } b = Thread.new { 
 Thread.current[:name] = ""B""; Thread.stop } c = Thread.new { Thread.current[""name""] 
 = ""C""; Thread.stop } Thread.list.each {|x| puts ""#{x.inspect}: #{x[:name]}"" }
  
 produces:
  
 #<Thread:0x1c92b0 
 sleep>: 
 C 
  
 #<Thread:0x1c9328 
 sleep>: 
 B 
  
 #<Thread:0x1c93b4 
 sleep>: 
 A 
  
 #<Thread:0x1d5790 run>:
  
 Prepared exclusively for Yeganefar",NA
T,"#<Thread:0x1d5790 run>]
  
 new_group = ThreadGroup.new
  
 thread.group.list
  
 →
  
 [#<Thread:0x1c9418 sleep>,
  
 #<Thread:0x1d5790 run>]
  
 new_group.add(thread)
  
  
 thread.group.list
  
 →
  
 [#<Thread:0x1c9418 sleep>]
  
 Thread.current.group.list
  
 →
  
 [#<Thread:0x1d5790 run>]
  
 join 
 1.8
  
  
 thr
 .join
  →
  thr 
  
 thr
 .join(
  limit
  )
  →
  thr
  
 The calling thread will suspend execution and run
  thr
 . Does not return until
  thr
  exits 
 or
  
 until
  limit
  seconds have passed. If the time limit expires,
  nil
  will be returned; otherwise
  
 thr
  is returned.
  
 Prepared exclusively for Yeganefar",NA
T,"h
  
 Returns
  true
  if the given string (or symbol) exists as a thread-local variable.
  
 me = Thread.current 
  
 me[:oliver] = ""a""
  
 kill
  
 me.key?(:oliver)
  
 →
  
 true
  
 thr
 .kill
  
 me.key?(:stanley)
  
 →
  
 false
  
 Synonym for
  Thread
 #
 exit
 .
  
 priority
  
 thr
 .priority
  →
  int 
 Returns the priority of
  thr
 . Default is zero; higher-priority threads will run before 
 lower-
  
 priority threads.
  
 Thread.current.priority
  
 →
  
 0
  
  
 Prepared exclusively for Yeganefar",NA
T,"hread
  
 from prog.rb:2:in `initialize'
  
 from prog.rb:2:in `new'
  
 from prog.rb:2
  
 run
  
 thr
 .run
  →
  thr 
 Wakes up
  thr
 , making it eligible for scheduling. If not in a critical section, then 
 invokes
  
  
 the scheduler.
  
 a = Thread.new { puts ""a""; Thread.stop; puts ""c"" } 
  
 Thread.pass 
  
 puts ""Got here"" 
  
 a.run 
  
 a.join
  
 produces:
  
 a 
  
 Got here 
  
 c
  
 Prepared exclusively for Yeganefar",NA
T,"hread
  
 a.stop?
  
 →
  
 true
  
 b.stop?
  
 →
  
 false
  
 terminate
  
 thr
 .terminate
   
  
  
 Synonym for
  Thread
 #
 exit
 .
  
 value
  
 Waits for
  thr
  to complete (via
  Thread
 #
 join
 ) and returns its value.
  
 thr
 .value
  →
  obj
  
 a = Thread.new { 2 + 2 }
  
 a.value
  
 →
  
 4
  
  
  
 wakeup
  
 thr
 .wakeup
  →
  thr
  
 Marks
  thr
  as eligible for scheduling (it may still remain blocked on I/O, however). Does
  
 not invoke the scheduler (see
  Thread
 #
 run
 ).
  
 Prepared exclusively for Yeganefar",NA
ThreadGroup,"<
  
 Object
  
 T
 HREAD
 G
 ROUP
  
 619
  
 A
  ThreadGroup
  keeps track of a number of threads. A
  Thread
  can belong to only one 
 ThreadGroup
  at a time; adding a thread to a group will remove it from the its current 
 group. Newly created threads belong to the group of the thread that created them.
  
 ThreadGroup constants
  
 Default
  
 Default thread group.
  
 Class methods
  
 new
  
 ThreadGroup.new
  →
  thgrp
  
 Returns a newly created
  ThreadGroup
 . The group is initially empty.
  
 Instance methods
  
 add
  
 thgrp
 .add(
  thread
  )
  →
  thgrp 
 Adds the given thread to this group, removing it from any other group to which it 
 may
  
 have previously belonged.
  
 puts ""Default group is #{ThreadGroup::Default.list}"" 
  
 tg = ThreadGroup.new 
  
 t1 = Thread.new { sleep } 
  
 t2 = Thread.new { sleep } 
  
 puts ""t1 is #{t1}, t2 is #{t2}""
  
 tg.add(t1) 
  
 puts ""Default group now #{ThreadGroup::Default.list}"" puts ""tg group now 
 #{tg.list}""
  
 produces:
  
 hreadGroup
  
 Default group is #<Thread:0x1d5790>",NA
T,"t1 is #<Thread:0x1c942c>, t2 is #<Thread:0x1c93c8> 
  
 Default group now #<Thread:0x1c93c8>#<Thread:0x1d5790> 
  
 tg group now #<Thread:0x1c942c>
  
 enclose
  
 thgrp
 .enclose
  →
  thgrp
  
 1.8
  
  
 Prevents threads being removed from
  thgrp
 .
  
 thread = Thread.new { sleep 99 } 
  
 group = ThreadGroup.new 
  
 group.add(thread) 
  
 group.enclose 
  
 ThreadGroup::Default.add(thread)
  
 produces:
  
 prog.rb:5:in `add': can't move from the enclosed thread group (ThreadError) from prog.rb:5
  
 Prepared exclusively for Yeganefar",NA
T,"hreadGroup
  
 Returns an array of all existing
  Thread
  objects that belong to this group.
  
 ThreadGroup::Default.list
  
 →
  
 [#<Thread:0x1d5790 run>]
  
  
 Prepared exclusively for Yeganefar",NA
Time,"<
  
 Object
  
 T
 IME
  
 621
  
 Time
  is an abstraction of dates and times. Time is stored internally as the number of 
 seconds and microseconds since the
  epoch
 , January 1, 1970 00:00 UTC. On some 
 oper-ating systems, this offset is allowed to be negative. Also see the library modules
  
 Date 
 and
  ParseDate
 , described on pages
  644
  and
  692
 , respectively.
  
 The
  Time
  class treats GMT (Greenwich Mean Time) and UTC (Coordinated 
 Universal Time)
 3
 as equivalent. GMT is the older way of referring to these baseline 
 times but persists in the names of calls on POSIX systems.
  
 All times are stored with some number of microseconds. Be aware of this fact when 
 comparing times with each other—times that are apparently equal when displayed 
 may be different when compared.
  
 Mixes in
  
 Comparable
 :
  
 <, <=, ==, >=, >, between?
  
 Class methods
  
 at
  
 Time.at(
  time
  )
  →
  time 
  
 Time.at(
  seconds
  ⟨
  ,
  microseconds
  ⟩
  )
  →
  time
  
 Creates a new time object with the value given by
  time
 , or the given number of
  seconds
  
 1.8
  
  
 (and optional
  microseconds
 ) from epoch. A nonportable
  
 feature allows the offset to be
  
 negative on some systems.
  
  
 Time.at(0)
  
 →
  
 Wed Dec 31 18:00:00 CST 1969",NA
T,"ime
  
 Time.at(946702800)
  
 →
  
 Fri Dec 31 23:00:00 CST 1999
  
 Time.at(-284061600)
  
 →
  
 Sat Dec 31 00:00:00 CST 1960
  
 gm
  
 Time.gm(
  year
  ⟨
  , month, day, hour, min, sec, usec
  ⟩
  )
  →
  time 
 Time.gm(
  sec, min, hour, day, month, year, wday, yday, isdst, tz
  )
  →
  
 time
  
  
 Creates a time based on given values, interpreted as UTC (GMT). The year must
  
 be specified. Other values default to the minimum value for that field (and may be 
 nil
  
 or omitted). Months may be specified by numbers from 1 to 12 or by the three-letter 
 English month names. Hours are specified on a 24-hour clock (
 0..23
 ). Raises an 
 ArgumentError
  if any values are out of range. Will also accept ten arguments in the 
 order output by
  Time
 #
 to_a
 .
  
 Time.gm(2000,""jan"",1,20,15,1)
  
 →
  
 Sat Jan 01 20:15:01 UTC 2000
  
 3.
  
 Yes, UTC really does stand for Coordinated Universal Time. There was a committee involved.
  
  
 Prepared exclusively for Yeganefar",NA
T,"ime
  
 1.8
  
  
 Deprecated in favor of
  Process.times
 , documented
  
 on page
  566
 .
  
 utc
  
 Time.utc(
  year
  ⟨
  , month, day, hour, min, sec, usec
  ⟩
  )
  →
  time 
 Time.utc(
  sec, min, hour, day, month, year, wday, yday, isdst, tz
  )
  →
  
 time
  
  
 Synonym for
  Time.gm
 .
  
 Time.utc(2000,""jan"",1,20,15,1)
  
 →
  
 Sat Jan 01 20:15:01 UTC 2000
  
  
 Prepared exclusively for Yeganefar",NA
T,"i
  
 Time.now.asctime
  
 →
  
 ""Thu Aug 26 22:38:02 2004""
  
  
  
 ctime
  
 time
 .ctime
  →
  string
  
  
 Synonym for
  Time
 #
 asctime
 .
  
  
  
 day
  
 time
 .day
  →
  int
  
  
 Returns the day of the month (
 1..n
 ) for
  time
 .
  
  
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:02 CDT 2004
  
 t.day
  
 →
  
 26
  
 dst? 
 1.8
  
  
 Synonym for
  Time
 #
 isdst
 .
  
 time
 .dst?
  →
  true
  or
  false
  
  
  
 Prepared exclusively for Yeganefar",NA
T,"ime
  
 t.gmt?
  
 →
  
 false
  
 t = Time.gm(2000,1,1,20,15,1)
  
 Sat Jan 01 20:15:01 UTC 2000
  
 →
  
 t.gmt?
  
 →
  
 true
  
 gmtim
 e
  
  
  
 time
 .gmtime
  →
  time
  
  
 Converts
  time
  to UTC (GMT), modifying the receiver.
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:02 CDT 2004
  
 t.gmt?
  
 →
  
 false
  
 t.gmtime
  
 →
  
 Fri Aug 27 03:38:02 UTC 2004
  
 t.gmt?
  
 →
  
 true
  
 gmt_offset
  
  
 1.8 
 Returns the offset in seconds between the timezone of
  time
  and UTC. 
  
  
 time
 .gmt_offset
  →
  int
  
 t = Time.gm(2000,1,1,20,15,1)
  
 →
  
 Sat Jan 01 20:15:01 UTC 2000
  
 t.gmt_offset
  
 →
  
 0
  
 l = t.getlocal
  
 →
  
 Sat Jan 01 14:15:01 CST 2000
  
 l.gmt_offset
  
 →
  
 -21600
  
  
 Prepared exclusively for Yeganefar",NA
T,"ime
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:03 CDT 2004
  
 t.min
  
 →
  
 38
  
 mon
  
 Returns the month of the year (
 1..12
 ) for
  time
 .
  
 time
 .mon
  →
  int
  
  
  
  
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:03 CDT 2004
  
 t.mon
  
 →
  
 8
  
 month
  
 Synonym for
  Time
 #
 mon
 .
  
 time
 .month
  →
  int
  
  
  
 Prepared exclusively for Yeganefar",NA
T,"i
  
 t = Time.now
  
  
 ""%10.5f"" % t.to_f
  
 →
  
 ""1093577883.37052""
  
 t.to_i
  
 →
  
 1093577883
  
 to_s
  
 time
 .to_s
  →
  string 
 Returns a string representing
  time
 . Equivalent to calling
  Time
 #
 strftime
  with a format
  
 string of
  %a %b %d %H:%M:%S %Z %Y
 .
  
 Time.now.to_s
  
 →
  
 ""Thu Aug 26 22:38:03 CDT 2004""
  
 4.
  
 Yes, seconds really can range from zero to 60. This allows the system to inject leap seconds every now
  
 and then to correct for the fact that years are not really a convenient number of hours long.
  
 Prepared exclusively for Yeganefar",NA
T,"ime
  
 Synonym for
  Time
 #
 to_i
 .
  
  
  
 tv_usec
  
 time
 .tv_usec
  →
  int
  
  
 Synonym for
  Time
 #
 usec
 .
  
  
  
 usec
  
 time
 .usec
  →
  int
  
  
 Returns just the number of microseconds for
  time
 .
  
  
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:03 CDT 2004
  
 ""%10.6f"" % t.to_f
  
 →
  
 ""1093577883.448204""
  
 t.usec
  
 →
  
 448204
  
  
 Prepared exclusively for Yeganefar",NA
T,"i
  
 Returns the year for
  time
  (including the century).
  
 t = Time.now
  
 →
  
 Thu Aug 26 22:38:03 CDT 2004
  
 t.year
  
 →
  
 2004
  
 zone
  
 Returns the name of the time zone used for
  time
 . As of Ruby 
 1.8,
  
 time
 .zone
  →
  string
  
  
 1.8
  
  
 returns “UTC” rather
  
 than “GMT” for UTC times.
  
 t = Time.gm(2000, ""jan"", 1, 20, 15, 1)
  
 t.zone
  
 →
  
 ""UTC""
  
 t = Time.local(2000, ""jan"", 1, 20, 15, 1)
  
 t.zone
  
 →
  
 ""CST""
  
  
 Prepared exclusively for Yeganefar",NA
TrueClass,"<
  
 Object
  
 T
 RUE
 C
 LASS
  
 629
  
 The global value
  true
  is the only instance of class
  TrueClass
  and represents a logi-cally 
 true value in boolean expressions. The class provides operators allowing
  true
  to be 
 used in logical expressions.
  
 Instance methods
  
 &
  
 true
  &
  obj
  →
  true
  or
  false
  
  
 And—Returns
  false
  if
  obj
  is
  nil
  or
  false
 , and returns
  true
  otherwise.
  
 ^
  
 true
  ^
  obj
  →
  true
  or
  false
  
  
 Exclusive Or—Returns
  true
  if
  obj
  is
  nil
  and returns
  false
  otherwise.
  
 |
  
 true
  |
  obj
  →
  true 
 Or—Returns
  true
 . As
  obj
  is an argument to a method call, it is always evaluated;
  
 short-circuit evaluation is not performed in this case.
  
 true | puts(""or"") 
  
 true || puts(""logical or"")
  
 produces:
  
 or",NA
T,"rueClass
  
  
 Prepared exclusively for Yeganefar",NA
UnboundMethod,"<
  
 Object
  
 U
 NBOUND
 M
 ETHOD
  
 630
  
 1.8
  
  
 Ruby supports two forms of objectified methods.
  
 Class
  Method
  is used to represent
  
 methods that are associated with a particular object: these method objects are bound to 
 that object. Bound method objects for an object can be created using
  Object
 #
 method
 .
  
 Ruby also supports unbound methods, which are methods objects that are not associ-
 ated with a particular object. These can be created either by calling
  unbind
  on a bound 
 method object or by calling
  Module
 #
 instance_method
 .
  
 Unbound methods can be called only after they are bound to an object. That object 
 must be a
  kind_of?
  the method’s original class.
  
 class Square 
  
 def area 
  
   
 @side * @side 
  
 end 
  
 def initialize(side) 
  
   
 @side = side 
  
 end 
  
 end
  
 area_unbound = Square.instance_method(:area)
  
 s = Square.new(12) 
  
 area = area_unbound.bind(s)
  
 area.call
  
 →
  
 144
  
 Unbound methods are a reference to the method at the time it was objectified: subse-
  
 quent changes to the underlying class will not affect the unbound method.
  
 class Test 
  
 def test 
  
   
 :original 
  
 end 
  
 end 
  
 um = Test.instance_method(:test)",NA
U,"nboundMethod
  
 class Test 
  
 def test 
  
   
 :modified 
  
 end 
  
 end 
  
 t = Test.new
  
 t.test
  
 →
  
 :modified
  
 um.bind(t).call
  
 →
  
 :original
  
  
 Prepared exclusively for Yeganefar",NA
U,"nboundMethod
  
  
 Prepared exclusively for Yeganefar",NA
Chapter 28,NA,NA
Standard Library,"The Ruby interpreter comes with a large number of classes, modules, and methods 
 built in—they are available as part of the running program. When you need a facility 
 that isn’t part of the built-in repertoire, you’ll often find it in a library that you can
  
 require 
 into your program.
  
 A large number of Ruby libraries are available on the Internet. Sites such as the Ruby 
 Application Archive
 1
 and RubyForge
 2
 have great indices and a lot of code.
  
 However, Ruby also ships as standard with a large number of libraries. Some of these 
 are written in pure Ruby and will be available on all Ruby platforms. Others are Ruby 
 extensions, and some of these will be present only if your system supports the 
 resources that they need. All can be included into your Ruby program using
  require
 . 
 And, unlike libraries you may find on the Internet, you can pretty much guarantee 
 that all Ruby users will have these libraries already installed on their machines.
  
 In this chapter, we present the standard libraries in a new
  smorgasbord
  format. Rather 
 than go into depth on a few libraries, this chapter presents the entire contents of the 
 standard library, one entry per page. For each library we give some introductory notes 
 and typically give an example or two of use. You won’t find detailed method descrip-
 tions here: for that consult the library’s own documentation.
  
 It’s all very well suggesting that you “consult the library’s own documentation,” but 
 where can you find it? The answer is “it depends.” Some libraries have already been 
 documented using RDoc (see Chapter
  16
 ). That means you can use the ri command to 
 get their documentation. For example, from a command line, you may be able to see 
 the following documentation on the
  decode64
  method in the
  Base64
  standard library 
 member.
  
 1.
  
 http://raa.ruby-lang.org
  
 632
  
 2.
  
 http://rubyforge.org
  
 Prepared exclusively for Yeganefar",NA
A,"bbrev
  
 Library",NA
 Abbrev,"Generate Sets of Unique Abbreviations
  
  
 Given a set of strings, calculate the set of unambiguous abbreviations for those 
 strings,",NA
A,"and return a hash where the keys are all the possible abbreviations and the values are 
 the full strings. Thus, given input of “car” and “cone,” the keys pointing to “car” 
 would be “ca” and “car,” and those pointing to “cone” would be “co,” “con,” and 
 “cone.”
  
 An optional pattern or a string may be specified—only those input strings matching the 
 pattern, or beginning with the string, are considered for inclusion in the output hash.
  
 Including the
  Abbrev
  library also adds an
  abbrev
  method to class
  Array
 .
  
 • Show the abbreviation set of some words.
  
 require 'abbrev'
  
 Abbrev::abbrev(['ruby', 'rules'])
  
 →
  
 {""rules""=>""rules"",
  
 ""ruby""=>""ruby"", 
  
 ""rul""=>""rules"", 
  
 ""rub""=>""ruby"", 
  
 ""rule""=>""rules""}
  
 %w{ car cone }.abbrev
  
 →
  
 {""co""=>""cone"",
  
 ""con""=>""cone"", 
  
 ""cone""=>""cone"", 
  
 ""ca""=>""car"", ""car""=>""car""}
  
 %w{ car cone }.abbrev(""ca"")
  
 →
  
 {""ca""=>""car"",
  
 ""car""=>""car""}
  
 • A trivial command loop using abbreviations.
  
 require 'abbrev'
  
 COMMANDS = %w{ sample send start status stop }.abbrev
  
 while line = gets 
  
 line = line.chomp
  
 case COMMANDS[line] 
  
 when ""sample"": # ...
  
 when ""send"": # ...
  
 # ...
  
 else 
  
  
 STDERR.puts ""Unknown command: #{line}"" 
  
 end 
  
 end",NA
 Base64,"Base64 Conversion Functions
  
  
 Perform encoding and decoding of binary data using a Base64 representation. This 
 allows you to represent any binary data in purely printable characters. The encoding 
 is",NA
B,"as
  
 specified in RFC 2045 (
 http://www.faqs.org/rfcs/rfc2045.html
 ).
  
 1.8
  
  
 Prior to Ruby 1.8.2,
  
 these methods were added to the global namespace. This is now
  
 deprecated; the methods should instead be accessed as members of the
  Base64
  module.
  
 • Decode an encoded string.
  
 require 'base64' 
  
 str = 'VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG' + 
  
  
 'lzIGxpbmUgdHdvClRoaXMgaXMgbGlu' + 
  
  
 'ZSB0aHJlZQpBbmQgc28gb24uLi4K' 
  
 puts Base64.decode64(str)
  
 produces:
  
 This is line one 
  
 This is line two 
  
 This is line three 
  
 And so on...
  
 • Convert and return a string.
  
 require 'base64' 
  
 puts Base64.encode64(""Now is the time\nto learn Ruby"")
  
 produces:
  
 Tm93IGlzIHRoZSB0aW1lCnRvIGxlYXJuIFJ1Ynk=
  
 • Convert a string into Base64 and print it to
  STDOUT
 .
  
 require 'base64' 
  
 Base64.b64encode(""Now is the time\nto learn Ruby"")
  
 produces:
  
 Tm93IGlzIHRoZSB0aW1lCnRvIGxlYXJuIFJ1Ynk=
  
 Prepared exclusively for Yeganefar",NA
 Benchmark,"Time Code Execution
  
  
 Allows code execution to be timed and the results tabulated. The
  Benchmark
  module 
 is easier to use if you include it in your top-level environment.",NA
B,"en
  
 See also:
  Profile
  (page
  696
 )
  
 • Compare the costs of three kinds of method dispatch.
  
 require 'benchmark' 
  
 include Benchmark 
  
 string = ""Stormy Weather"" 
  
 m = string.method(:length) 
  
 bm(6) do |x| 
  
 x.report(""call"") { 10_000.times { m.call } } 
  
 x.report(""send"") { 10_000.times { string.send(:length) } } x.report(""eval"") { 
 10_000.times { eval ""string.length"" } } end
  
 produces:
  
 call
  
 user
  
 system
  
 total
  
 real
  
 0.020000
  
 0.000000
  
 0.020000 (
  
 0.045998)
  
 send
  
 0.040000
  
 0.000000
  
 0.040000 (
  
 0.051318)
  
 eval
  
 0.130000
  
 0.000000
  
 0.130000 (
  
 0.177950)
  
 • Which is better: reading all of a dictionary and splitting it, or splitting it line by 
  
 line? Use
  bmbm
  to run a rehearsal before doing the timing.
  
 require 'benchmark' 
  
 include Benchmark 
  
 bmbm(6) do |x| 
  
 x.report(""all"") do 
  
    
 str = File.read(""/usr/share/dict/words"") 
  
    
 words = str.scan(/[-\w']+/) 
  
 end 
  
 x.report(""lines"") do 
  
  
 words = [] 
  
  
 File.foreach(""/usr/share/dict/words"") do |line| 
  
     
 words << line.chomp 
  
  
 end 
  
 end 
  
 end
  
 produces:
  
 Rehearsal -----------------------------------------
  
 all
  
 0.980000
  
 0.070000
  
 1.050000 (
  
 1.256552)
  
 lines
  
 2.310000
  
 0.120000
  
 2.430000 (
  
 2.720674)
  
 -------------------------------- total: 3.480000sec
  
 all
  
 user
  
 system
  
 total
  
 real
  
 0.870000
  
 0.030000
  
 0.900000 (
  
 0.949623)
  
 lines
  
 1.720000
  
 0.030000
  
 1.750000 (
  
 1.926910)
  
  
 Prepared exclusively for Yeganefar",NA
 BigDecimal,"Large-Precision Decimal Numbers
  
  
 Ruby’s standard
  Bignum
  class supports integers with large numbers of digits. The 
 BigDecimal
  class supports decimal numbers with large numbers of decimal places.",NA
B,"ig
  
 The standard library supports all the normal arithmetic operations.
  BigDecimal
  also 
 comes with some extension libraries.
  
 bigdecimal/ludcmp 
  
  
 Performs an LU decomposition of a matrix.
  
 bigdecimal/math 
  
 Provides the transcendental functions
  sqrt
 ,
  sin
 ,
  cos
 ,
  atan
 ,
  exp
 , and
  log
 , along with 
 functions for computing
  PI
  and
  E
 . All functions take an arbitrary precision 
 argument.
  
 bigdecimal/jacobian 
  
 Constructs the Jacobian (a matrix enumerating the partial derivatives) of a given 
 function. Not dependent on
  BigDecimal
 .
  
 bigdecimal/newton 
  
 Solves the roots of nonlinear function using Newton’s method. Not dependent on 
 BigDecimnal
 .
  
 bigdecimal/nlsolve 
  
  
 Wraps the
  bigdecimal/newton
  library for equations of
  BigDecimals
 .
  
 You can find English-language documentation in the Ruby source distribution in the 
 file
  ext/bigdecimal/bigdecimal_en.html
 .
  
 require 'bigdecimal' 
  
 require 'bigdecimal/math' 
  
 include BigMath
  
 pi = BigMath::PI(20) 
  
 # 20 is the number of decimal digits
  
 radius = BigDecimal(""2.14156987652974674392"")
  
 area = pi * radius**2
  
 area.to_s
  
 →
  
 ""0.14408354044685604417672003380667956168
  
 8599846410445032583215824758780405545861 
  
 780909930190528E2""
  
 # The same with regular floats
  
 radius = 2.14156987652974674392
  
 Math::PI * radius**2
  
 →
  
 14.4083540446856
  
  
 Prepared exclusively for Yeganefar",NA
 CGI,"CGI Programming Support
  
 The
  CGI
  class provides support for programs used as CGI (Common Gateway Interface)
  
 scripts in a Web server. CGI objects are initialized with data from the environment
  
 GI
  
 and from the HTTP request, and they provide convenient accessors to form data and",NA
C,"cookies. They can also manage sessions using a variety of storage mechanisms. Class
  
 CGI
  also provides basic facilities for HTML generation and class methods to escape
  
 and unescape requests and HTML.
  
 1.8
  
  
 Note:
  
 The 1.8 implementation of
  CGI
  introduces a change in the way form data is
  
 accessed. See the
  ri
  documentation of
  CGI
 #
 []
  and
  CGI
 #
 params
  for details.
  
 See also:
  CGI::Session
  (page
  640
 )
  
 • Escape and unescape special characters in URLs and HTML. If the
  $KCODE
  vari-
  
 able is set to
  ""u""
  (for UTF8), the library will convert from HTML’s Unicode to
  
 internal UTF8.
  
 require 'cgi'
  
 CGI.escape('c:\My Files')
  
 →
  
 c%3A%5CMy+Files
  
 CGI.unescape('c%3a%5cMy+Files')
  
 →
  
 c:\My Files
  
 CGI::escapeHTML('""a""<b & c')
  
 →
  
 &quot;a&quot;&lt;b &amp; c
  
 $KCODE = ""u"" 
  
 # Use UTF8
  
 CGI.unescapeHTML('&quot;a&quot;&lt;=&gt;b')
  
 →
 ""a""<=>b
  
 CGI.unescapeHTML('&#65;&#x41;')
  
 →
 AA
  
 CGI.unescapeHTML('&#x3c0;r&#178;')
  
 →πr
 2
  
 • Access information from the incoming request.
  
 require 'cgi'
  
 c = CGI.new
  
 c.auth_type
  
 →
  
 ""basic""
  
 c.user_agent
  
 ""Mozscape Explorari V5.6""
  
 →
  
 • Access form fields from an incoming request. Assume the following script is
  
 installed as
  test.cgi
  and the user linked to it using
  http://mydomain.com/
  
 test.cgi?fred=10&barney=cat
 .
  
 require 'cgi'
  
 c = CGI.new
  
 c['fred']
  
 →
  
 ""10""
  
 c.keys
  
 →
  
 [""barney"", ""fred""]
  
 c.params
  
 →
  
 {""barney""=>[""cat""], ""fred""=>[""10""]}
  
 • If a form contains multiple fields with the same name, the corresponding values
  
 will be returned to the script as an array. The
  [ ]
  accessor returns just the first of
  
 these—index the result of the
  params
  method to get them all. In this example,
  
 assume the form has three fields called “name.”
  
 Prepared exclusively for Yeganefar",NA
C,"→
  
 • Send a response to the browser. (Not many folks use this form of HTML genera-
  
 tion. Consider one of the templating libraries—see page
  226
 .)
  
 require 'cgi' 
  
 cgi = CGI.new(""html4Tr"") 
  
 cgi.header(""type"" => ""text/html"", ""expires"" => Time.now + 30) cgi.out do 
  
 cgi.html do 
  
  
 cgi.head{ cgi.title{""Hello World!""} } + 
  
  
 cgi.body do 
  
    
 cgi.pre do 
  
    
 CGI::escapeHTML( 
  
     
 ""params: "" + cgi.params.inspect + ""\n"" + 
  
     
 ""cookies: "" + cgi.cookies.inspect + ""\n"") 
  
    
 end 
  
  
 end 
  
 end 
  
 end
  
 • Store a cookie in the client browser.
  
 require 'cgi' 
  
 cgi = CGI.new(""html4"") 
  
 cookie = CGI::Cookie.new('name' => 'mycookie', 
  
  
 'value' => 'chocolate chip', 
  
  
 'expires' => Time.now + 3600)
  
 cgi.out('cookie' => cookie) do 
  
 cgi.head + cgi.body { ""Cookie stored"" } 
  
 end
  
 • Retrieve a previously stored cookie.
  
 require 'cgi' 
  
 cgi = CGI.new(""html4"") 
  
 cookie = cgi.cookies['mycookie']
  
 cgi.out('cookie' => cookie) do 
  
 cgi.head + cgi.body { ""Flavor: "" + cookie[0] } 
  
 end
  
 Prepared exclusively for Yeganefar",NA
 CGI::Session,"CGI Sessions
  
  
 A
  CGI::Session
  maintains a persistent state for Web users in a CGI environment. 
 Sessions may be memory resident or may be stored on disk. See the discussion on
  
 GI::Se
 s
  
 page
  233
  for details.",NA
C,"See also:
  CGI
  (page
  638
 )
  
 require 'cgi' 
  
 require 'cgi/session'
  
 cgi = CGI.new(""html3"") 
  
 sess = CGI::Session.new(cgi, 
  
  
 ""session_key"" => ""rubyweb"", 
  
  
 ""prefix"" => ""web-session."" 
  
  
 )
  
 if sess['lastaccess'] 
  
 msg = ""You were last here #{sess['lastaccess']}."" 
  
 else 
  
 msg = ""Looks like you haven't been here for a while"" 
  
 end
  
 count = (sess[""accesscount""] || 0).to_i 
  
 count += 1
  
 msg << ""<p>Number of visits: #{count}""
  
 sess[""accesscount""] = count 
  
 sess[""lastaccess""] 
  
 = Time.now.to_s 
  
 sess.close
  
 cgi.out { 
  
 cgi.html { 
  
   
 cgi.body { 
  
    
 msg 
  
   
 } 
  
 } 
  
 }
  
 Prepared exclusively for Yeganefar",NA
 Complex,"Complex Numbers
  
  
 Class
  Complex
  represents complex numbers. As well as the methods here, including 
 class
  Complex
  in your program alters class
  Numeric
  (and subclasses) in order to give
  
 omplex
  
 the illusion that
  all
  numbers are complex (by giving them the methods
  real
 ,
  image
 ,",NA
C,"arg
 ,
  polar
 ,
  conjugate
 , and
  power!
 ).
  
 require 'complex'
  
 include Math
  
 v1 = Complex(2,3)
  
 →
  
 Complex(2, 3)
  
 v2 = 2.im
  
 Complex(0, 2)
  
 →
  
 v1 + v2
  
 →
  
 Complex(2, 5)
  
 v1 * v2
  
 Complex(-6, 4)
  
 →
  
 v2**2
  
 →
  
 Complex(-4, 0)
  
 Complex(-4.18962569096881, -9.10922789375534)
  
 cos(v1)
  
 →
  
 v1 < v2
  
 →
  
 false
  
 v2**2 == -4
  
 →
  
 true
  
 # Euler's theorem
  
 E**(PI*Complex::I)
  
 →
  
 Complex(-1.0, 1.22464679914735e-16)
  
  
 Prepared exclusively for Yeganefar",NA
 CSV,"Comma-Separated Values
  
  
 Comma-separated data files are often used to transfer tabular information (and are a 
 lingua franca
  for importing and exporting spreadsheet and database information).
  
 SV
  
 Ruby’s CSV library deals with arrays (corresponding to the rows in the CSV file) and",NA
C,"strings (corresponding to the elements in a row). If an element in a row is missing, it 
 will be represented as a
  nil
  in Ruby.
  
 The files used in the following examples are:
  
 csvfile: 
  
 csvfile_hdr: 
  
 12,eggs,2.89, 
  
 Count, Description, Price 2,""shirt, 
 blue"",21.45,special 
  
 12,eggs,2.89, 
  
 1,""""""Hello Kitty"""" bag"",13.99 
  
 2,""shirt, blue"",21.45,special 
  
 1,""""""Hello Kitty"""" bag"",13.99
  
 • Read a file containing CSV data and process line-by-line.
  
 require 'csv' 
  
 CSV.open(""csvfile"", ""r"") do |row| 
  
 qty = row[0].to_i 
  
 price = row[2].to_f 
  
 printf ""%20s: $%5.2f %s\n"", row[1], qty*price, row[3] || ""
  
 ---"" 
 end
  
 produces:
  
  
  
 eggs: $34.68
  
 ---
  
  
 shirt, blue: $42.90 special 
  
 ""Hello Kitty"" bag: $13.99
  
 ---
  
 • Some CSV files have a header line. Read it, and then process the rest of the file.
  
 require 'csv' 
  
 reader = CSV.open(""csvfile_hdr"", ""r"") 
  
 header = reader.shift 
  
 reader.each {|row| process(header, row) }
  
 • Write CSV data to an existing open stream (STDOUT in this case). Use
  |
  as the 
  
 column separator.
  
 require 'csv' 
  
 CSV::Writer.generate(STDOUT, '|') do |csv| 
  
 csv << [ 1, ""line 1"", 27 ] 
  
 csv << [ 2, nil, 123 ] 
  
 csv << [ 3, ""|bar|"", 32.5] 
  
 end
  
 produces:
  
 1|line 1|27 
  
 2||123 
  
 3|""|bar|""|32.5
  
 Prepared exclusively for Yeganefar",NA
 Curses,"CRT Screen Handling
  
  
 Only if:
  curses or
  
 The
  Curses
  library is a fairly thin wrapper around the C
  curses
  or
  ncurses
  libraries,
  
 urses
  
 ncurses installed in 
 target environment
  
 allowing applications a device-independent way of drawing on consoles and other
  
 terminal-like devices. As a nod toward object-orientation, curses windows and mouse",NA
C,"events are represented as Ruby objects. Otherwise, the standard curses calls and con-
 stants are simply defined in the
  Curses
  module.
  
 # Draw the paddle of a simple game of 'pong'. It moves 
  
 # in response to the up and down keys
  
 require 'curses' 
  
 include Curses
  
 class Paddle 
  
 HEIGHT = 4 
  
 PADDLE = "" \n"" + ""|\n""*HEIGHT + "" "" 
  
 def initialize 
  
   
 @top = (Curses::lines - HEIGHT)/2 
  
   
 draw 
  
 end 
  
 def up 
  
   
 @top -= 1 if @top > 1 
  
 end 
  
 def down 
  
   
 @top += 1 if (@top + HEIGHT + 1) < lines 
  
 end 
  
 def draw 
  
   
 setpos(@top-1, 0) 
  
   
 addstr(PADDLE) 
  
   
 refresh 
  
 end 
  
 end
  
 init_screen 
  
 begin 
  
 crmode 
  
 noecho 
  
 stdscr.keypad(true)
  
 paddle = Paddle.new
  
 loop do 
  
   
 case getch 
  
   
 when ?Q, ?q 
  
 : 
  
 break 
  
   
 when Key::UP 
  
 : 
  
 paddle.up 
  
   
 when Key::DOWN : 
  
 paddle.down 
  
   
 else beep 
  
   
 end 
  
   
 paddle.draw 
  
 end 
  
 ensure 
  
 close_screen 
  
 end
  
 Prepared exclusively for Yeganefar",NA
 Date/DateTime,"Date and Time Manipulation
  
  
 The
  date
  library implements classes
  Date
  and
  DateTime
 , which provide a compre-
 hensive set of facilities for storing, manipulating, and converting dates with or 
 without time components. The classes can represent and manipulate civil, ordinal, 
 commercial, Julian, and standard dates, starting January 1, 4713 BCE. The
  DateTime
  
 class extends 
 Date
  with hours, minutes, seconds, and fractional seconds, and it 
 provides some sup-",NA
D,"ate/DateTime
  
 port for time zones. The classes also provide support for parsing and formatting date 
 and datetime strings. The classes have a rich interface—consult the
  ri
  documentation 
 for details. The introductory notes in the file
  lib/date.rb
  are also well worth reading.
  
 See also:
  ParseDate
  (page
  692
 )
  
 • Experiment with various representations
  
 require 'date'
  
 d = Date.new(2000, 3, 31)
  
 →
  
 #<Date:
  
 4903269/2,0,2299161>
  
 [d.year, d.yday, d.wday]
  
 →
  
 [2000, 91, 5]
  
 [d.month, d.mday]
  
 →
  
 [3, 31]
  
 [d.cwyear, d.cweek, d.cwday]
  
 →
  
 [2000, 13, 5]
  
 [d.jd, d.mjd]
  
 →
  
 [2451635, 51634]
  
 d1 = Date.commercial(2000, 13, 7)
  
 #<Date:
  
 →
  
 4903273/2,0,2299161>
  
 d1.to_s
  
 →
  
 ""2000-04-02""
  
 [d1.cwday, d1.wday]
  
 →
  
 [7, 0]
  
 • Essential information about Christmas.
  
 require 'date'
  
 now = DateTime.now 
  
 year = now.year 
  
 year += 1 if now.month == 12 && now.day > 25 
  
 xmas = DateTime.new(year, 12, 25)
  
 diff = xmas - now
  
 puts ""It's #{diff.to_i} days to Christmas""
  
 h,m,s,frac = Date.day_fraction_to_time(diff) 
  
 s += frac.to_f
  
 puts ""That's #{h} hours, #{m} minutes, #{s} seconds"" 
  
 puts ""Christmas falls on a #{xmas.strftime('%A')}""
  
 produces:
  
 It's 119 days to Christmas 
  
 That's 2876 hours, 21 minutes, 28.0000094433912 seconds 
  
 Christmas falls on a Saturday
  
 Prepared exclusively for Yeganefar",NA
 DBM,"Interface to DBM Databases
  
  
 Only if:
  a DBM
  
 DBM files implement simple, hashlike persistent stores. Many DBM implementations",NA
D,"BM
  
 library is 
 installe
 d in 
 target
  
 exist—the Ruby library can be configured to use one of the DBM libraries
  db
 ,
  dbm
  
 environment
  
 (
 ndbm
 ),
  gdbm
 , and
  qdbm
 . The interface to DBM files is similar to class
  Hash
 , except
  
 that DBM keys and values will be strings. This can cause confusion, as the conversion 
 to a string is performed silently when the data is written. The DBM library is a 
 wrapper
  
 around the lower-level access method. For true low-level access, see also the GDBM 
 and SDBM libraries.
  
 See also:
  gdbm
  (page
  661
 ),
  sdbm
  (page
  709
 )
  
 • Create a simple DBM file, then re-open it read-only and read some data. Note the 
  
 conversion of a date object to its string form.
  
 require 'dbm' 
  
 require 'date'
  
 DBM.open(""data.dbm"") do |dbm| 
  
 dbm['name'] = ""Walter Wombat"" 
  
 dbm['dob'] 
  
 = Date.new(1997, 12,25) 
  
 end
  
 DBM.open(""data.dbm"", nil, DBM::READER) do |dbm| 
  
 p dbm.keys 
  
 p dbm['dob'] 
  
 p dbm['dob'].class 
  
 end
  
 produces:
  
 [""name"", ""dob""] 
  
 ""1997-12-25"" 
  
 String
  
 • Read from the system’s
  aliases
  file. Note the trailing null bytes on all strings.
  
 require 'dbm'
  
 DBM.open(""/etc/aliases"", nil) do |dbm| 
  
 p dbm.keys 
  
 p dbm[""postfix\000""] 
  
 end
  
 produces:
  
 [""postmaster\000"", ""daemon\000"", ""ftp-bugs\000"", 
  
 ""operator\000"", ""abuse\000"", ""decode\000"", ""@\000"", 
  
 ""mailer-daemon\000"", ""bin\000"", ""named\000"", ""nobody\ 
  
 000"", ""uucp\000"", ""www\000"", ""postfix\000"", ""manager\ 
  
 000"", ""dumper\000""] 
  
 ""root\000""
  
 Prepared exclusively for Yeganefar",NA
 Delegator,"Delegate Calls to Other Object
  
  
 Object delegation is a way of
  composing
  objects—extending an object with the capa-
 bilities of another—at runtime. The Ruby
  Delegator
  class implements a simple but 
 powerful delegation scheme, where requests are automatically forwarded from a 
 master class to delegates or their ancestors and where the delegate can be changed at 
 runtime with a single method call.",NA
D,"elegator
  
 See also:
  Forwardable
  (page
  659
 )
  
 • For simple cases where the class of the delegate is fixed, make the master class a 
 subclass of
  DelegateClass
 , passing the name of the class to be delegated as a 
 parameter. In the master class’s
  initialize
  method, pass the object to be dele-gated 
 to the superclass.
  
 require 'delegate'
  
 class Words < DelegateClass(Array) 
  
 def initialize(list = ""/usr/share/dict/words"") 
  
  
 words = File.read(list).split 
  
  
 super(words) 
  
 end 
  
 end
  
 words = Words.new
  
 words[9999]
  
 →
  
 ""anticritique""
  
 words.size
  
 →
  
 234937
  
 words.grep(/matz/)
  
 [""matzo"", ""matzoon"", ""matzos"", ""matzoth""]
  
 →
  
 • Use
  SimpleDelegator
  to delegate to a particular object (which can be changed).
  
 require 'delegate'
  
 words = File.read(""/usr/share/dict/words"").split 
  
 names = File.read(""/usr/share/dict/propernames"").split
  
 stats = SimpleDelegator.new(words)
  
 stats.size
  
 →
  
 234937
  
 stats[226]
  
 ""abidingly""
  
 →
  
 stats.__setobj__(names)
  
 stats.size
  
 →
  
 1323
  
 stats[226]
  
 →
  
 ""Dave""
  
  
 Prepared exclusively for Yeganefar",NA
 Digest,"MD5, RIPEMD-160 SHA1, and SHA2 Digests
  
 The
  Digest
  module is the home for a number of classes that implement secure digest
  
 algorithms: MD2, RIPEMD-160, SHA1, and SHA2 (256, 384, and 512 bit). The 
 inter-face to all these classes is identical.
  
 igest
  
 • You can create a binary or hex digest for a given string by calling the class method",NA
D,"digest
  or
  hexdigest
 .
  
 • You can also create an object (optionally passing in an initial string) and 
 determine the object’s hash by calling the
  digest
  or
  hexdigest
  instance methods. In 
 this case you can then append to the string using the
  update
  method and then 
 recover an updated hash value.
  
 • Calculate some MD5 and SHA1 hashes.
  
 require 'digest/md5' 
  
 require 'digest/sha1'
  
 for hash_class in [ Digest::MD5, Digest::SHA1 ]
  
 puts ""Using #{hash_class.name}""
  
 # Calculate directly 
  
 puts hash_class.hexdigest(""hello world"")
  
 # Or by accumulating 
  
 digest = hash_class.new 
  
 digest << ""hello"" 
  
 digest << "" "" 
  
 digest << ""world"" 
  
 puts digest.hexdigest 
  
 puts 
  
 end
  
 produces:
  
 Using Digest::MD5 
  
 5eb63bbbe01eeed093cb22bb8f5acdc3 
  
 5eb63bbbe01eeed093cb22bb8f5acdc3
  
 Using Digest::SHA1 
  
 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed 
  
 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
  
 Prepared exclusively for Yeganefar",NA
 DL,"Access Dynamically Loaded Libraries (.dll and .so)
  
  
 Only if:
  Windows,
  
 The
  DL
  module interfaces to the underlying operating system’s dynamic loading capa-",NA
D,"L
  
 or system 
 supports 
 dl
  library
  
 bilities. On Windows boxes, it can be used to interface with functions in DLLs (replac-
  
 ing the
  Win32API
  class—see
  dl/win32
  for a compatible wrapper library). Under Unix it 
 can load shared libraries. Because Ruby does not have typed method parameters or 
 return values, you must define the types expected by the methods you call by specify-
  
 ing their signatures. This can be done using a C-like syntax (if you use the high-level 
 methods in
  dl/import
 ) or using explicit type specifiers in the lower-level
  DL
  module. 
 Good documentation is provided in the source tree’s
  ext/dl/doc/
  directory.
  
 See also:
  Win32API
  (page
  734
 )
  
 • Here’s a trivial C program that we’ll build as a shared library.
  
 #include <stdio.h> 
  
 int print_msg(text, number) { 
  
 return printf(""Text: %s (%d)\n"", text, number); 
  
 }
  
 • Generate a proxy to access the
  print_msg
  method in the shared library. The way 
 this book is built, the shared library ends up in the subdirectory
  code/dl
 ; this 
 explains the name in the
  dlopen
  call.
  
 require 'dl'
  
 Message = DL.dlopen(""code/dl/lib.so"") 
  
 print_msg = Message[ ""print_msg"", ""ISI"" ] 
  
 msg_size, args = print_msg.call(""Answer"", 42) 
  
 puts ""Just wrote #{msg_size} bytes""
  
 produces:
  
 Text: Answer (42) 
  
 Just wrote 18 bytes
  
 • We can also wrap the method in a module. Here we use an environment variable 
  
 to set the path to the shared object. This is operating system specific.
  
 ENV['DYLD_LIBRARY_PATH'] = "":code/dl"" # Mac OS X 
  
 require 'dl/import'
  
 module Message 
  
 extend DL::Importable 
  
 dlload ""lib.so"" 
  
 extern ""int print_msg(char *, int)"" 
  
 end
  
 msg_size = Message.print_msg(""Answer"", 42) 
  
 puts ""Just wrote #{msg_size} bytes""
  
 produces:
  
 Text: Answer (42) 
  
 Just wrote 18 bytes
  
 Prepared exclusively for Yeganefar",NA
 dRuby,"Distributed Ruby Objects (drb)
  
 dRuby allows Ruby objects to be distributed across a network connection. Although
  
 expressed in terms of clients and servers, once the initial connection is established, 
 the protocol is effectively symmetrical: either side can invoke methods in objects on 
 the other side. Normally, objects passed and returned by remote calls are passed by 
 value; including the
  DRbUndumped
  module in an object forces it to be passed by 
 reference",NA
D,"Ruby
  
 (useful when implementing callbacks).
  
 See also:
  Rinda
  (page
  706
 ),
  XMLRPC
  (page
  736
 )
  
 • This server program is
  observable
 —it notifies all registered listeners of changes 
  
 to a count value.
  
 require 'drb' 
  
 require 'drb/observer'
  
 class Counter 
  
 include DRb::DRbObservable
  
 def run 
  
  
 5.times do |count| 
  
    
 changed 
  
    
 notify_observers(count) 
  
  
 end 
  
 end 
  
 end
  
 counter = Counter.new 
  
 DRb.start_service('druby://localhost:9001', counter) 
  
 DRb.thread.join
  
 • This client program interacts with the server, registering a listener object to receive 
  
 callbacks before invoking the server’s
  run
  method.
  
 require 'drb'
  
 class Listener 
  
 include DRbUndumped
  
 def update(value) 
  
  
 puts value 
  
 end 
  
 end
  
 DRb.start_service 
  
 counter = DRbObject.new(nil, ""druby://localhost:9001"")
  
 listener = Listener.new 
  
 counter.add_observer(listener) 
  
 counter.run
  
 Prepared exclusively for Yeganefar",NA
 English,"English Names For Global Symbols
  
 Include the English library file in a Ruby script, and you can reference the global vari-
 ables such as
  $_
  using less-cryptic names, listed in the following table.
  
 $*
  
 $ARGV
  
 $""
  
 $LOADED_FEATURES
  
 nglish
  
 $CHILD_STATUS
  
 $&
  
 $MATCH
  
 $?
  
 $<
  
 $DEFAULT_INPUT
  
 $.
  
 $NR",NA
E,"$>
  
 $DEFAULT_OUTPUT
  
 $,
  
 $OFS
  
 $!
  
 $ERROR_INFO
  
 $\
  
 $ORS
  
 $@
  
 $ERROR_POSITION
  
 $,
  
 $OUTPUT_FIELD_SEPARATOR
  
 $;
  
 $FIELD_SEPARATOR
  
 $\
  
 $OUTPUT_RECORD_SEPARATO
 R
  
 $;
  
 $FS
  
 $$
  
 $PID
  
 $=
  
 $'
  
 $IGNORECASE
  
 $POSTMATCH
  
 $.
  
 $INPUT_LINE_NUMBER
  
 $`
  
 $PREMATCH
  
 $/
  
 $INPUT_RECORD_SEPARATOR
  
 $$
  
 $PROCESS_ID
  
 $~
  
 $LAST_MATCH_INFO
  
 $0
  
 $PROGRAM_NAME
  
 $+
  
 $LAST_PAREN_MATCH
  
 $/
  
 $RS
  
 $_
  
 $LAST_READ_LINE
  
 require 'English'
  
 $OUTPUT_FIELD_SEPARATOR = ' -- ' 
  
 ""waterbuffalo"" =~ /buff/ 
  
 print $LOADED_FEATURES, $POSTMATCH, $PID, ""\n"" 
  
 print $"", $', $$, ""\n""
  
 produces:
  
 English.rb -- alo -- 28035 --
  
 English.rb -- alo -- 28035 --
  
 Prepared exclusively for Yeganefar",NA
 Enumerator,"Define External Iterators
  
 The Ruby convention is that enumerable objects should define a method called
  each
  
 that returns the contents one item at a time. This
  each
  method is used as the basis of 
 the 
 Enumerable
  module, as well as the built-in
  for
  loop. Even if a class defines 
 multiple enumeration methods,
  Enumerable
  can only use
  each
 .
  
 The
  Enumerator
  module creates a new iterable object based on an existing object, 
 mapping the
  each
  method in the new object to an arbitrary method in the original. This",NA
E,"numerator
  
 allows you to use standard Ruby enumeration techniques on arbitrary methods.
  
 See also:
  Enumerable
  (page
  433
 ),
  Generator
  (page
  662
 )
  
 • Define an external iterator that returns all the keys in a hash.
  
 require 'enumerator'
  
 hash = { ""cow"" => ""bovine"", ""cat"" => ""feline"", ""dog"" => ""canine"" }
  
 key_iter = Enumerable::Enumerator.new(hash, :each_key) 
  
 puts ""Max key is #{key_iter.max}"" 
  
 for key in key_iter 
  
 puts ""Key is #{key}"" 
  
 end
  
 produces:
  
 Max key is dog 
  
 Key is cat 
  
 Key is cow 
  
 Key is dog
  
 • Methods
  to_enum
  and
  enum_for
  also create
  Enumerator
  objects.
  
 require 'enumerator' 
  
 hash = { ""cow"" => ""bovine"", ""cat"" => ""feline"", ""dog"" => ""canine"" } key_iter = 
 hash.enum_for(:each_key)
  
 key_iter.min
  
 →
  
 ""cat""
  
 key_iter.max
  
 →
  
 ""dog""
  
 • Methods
  each_slice
  and
  each_cons
  return elements from an enumeration
  n 
 elements 
 at a time.
  each_slice
  returns disjoint sets, and
  each_cons
  returns a moving window 
 over the collection.
  
 require 'enumerator' 
  
 (1..7).each_slice(3) {|slice| print slice.inspect, "" "" } 
  
 puts
  
 (1..7).each_cons(3)
  
 {|cons|
  
 print cons.inspect, "" "" }
  
 produces:
  
 [1, 2, 3] [4, 5, 6] [7] 
  
 [1, 2, 3] [2, 3, 4] [3, 4, 5] [4, 5, 6] [5, 6, 7]
  
 Prepared exclusively for Yeganefar",NA
 erb,"Lightweight Templating for HTML
  
 ERB is a lightweight templating system, allowing you to intermix Ruby code and 
 plain text. This is sometimes a convenient way to create HTML documents but also is 
 usable in other plain-text situations. For other templating solutions, see
  226
 .
  
 ERB
  breaks its input text into checks of regular text and program fragments. It then 
 builds a Ruby program that, when run, outputs the result text and executes the 
 program fragments. Program fragments are enclosed between
  <%
  and
  %>
  markers. 
 The exact",NA
E,"rb
  
 interpretation of these fragments depends on the character following the opening
  <%
 , as 
 shown in Table
  28.1
  on the next page.
  
 require 'erb' 
  
 input = %{\ 
  
 <% high.downto(low) do |n| 
  
 # set high, low externally %> 
  
 <%= n %> green bottles, hanging on the wall 
  
 <%= n %> green bottles, hanging on the wall 
  
 And if one green bottle should accidentally fall 
  
 There'd be <%= n-1 %> green bottles, hanging on the wall 
  
 <% end %> 
  
 } 
  
 high,low = 10, 8 
  
 erb = ERB.new(input) 
  
 erb.run
  
 produces:
  
 10 green bottles, hanging on the wall 
  
 10 green bottles, hanging on the wall 
  
 And if one green bottle should accidentally fall 
  
 There'd be 9 green bottles, hanging on the wall 
  
 . . .
  
 An optional second parameter to
  ERB.new
  sets the safe level for evaluating expres-
 sions. If
  nil
 , expressions are evaluated in the current thread; otherwise a new thread is 
 created, and its
  $SAFE
  level is set to the parameter value.
  
 The optional third parameter to
  ERB.new
  allows some control of the interpretation of 
 the input and of the way whitespace is added to the output. If the third parameter is a 
 string, and that string contains a percent sign, then ERB treats lines starting with a 
 percent sign specially. Lines starting with a single percent sign are treated as if they 
 were enclosed in
  <%
 ...
  %>
 . Lines starting with a double percent sign are copied to the 
 output with a single leading percent sign.
  
 str = %{\
  
 % 2.times do |i|
  
 ⇒
  
 produces:
  
 This is line <%= i %>
  
 This is line 0
  
 %end
  
 This is line 1
  
 %% done}
  
 % done
  
 ERB.new(str, 0, '%').run
  
 Prepared exclusively for Yeganefar",NA
E,"rb
  
 Comment (ignored).
  
 <%%
  and
  %%>
  
 Replaced in the output by
  <%
  and
 %>
  respectively.
  
  
 If the third parameter contains the string
  < >
  then a newline will not be written if an 
 input line starts with an ERB directive and ends with
  %>
 . If the trim parameter 
 contains 
 >
 , then a newline will not be written if an input line ends
  %>
 .
  
 str1 = %{\ 
  
 * <%= ""cat"" %> 
  
 <%= ""dog"" %> 
  
 } 
  
 ERB.new(str1, 0, "">"").run 
  
 ERB.new(str1, 0, ""<>"").run
  
 produces:
  
 * catdog* cat 
  
 dog
  
 The
  erb
  library also defines the helper module
  ERB::Util
  that contains two methods: 
 html_escape
  (aliased as
  h
 ) and
  url_encode
  (aliased as
  u
 ). These are equivalent to the 
 CGI
  
 methods
  escapeHTML
  and
  escape
 , respectively (except
  escape
  encodes spaces as plus 
 signs, and
  url_encode
  uses
  %20
 ).
  
 include ERB::Util 
  
 str1 = %{\ 
  
 h(a) = <%= h(a) %> 
  
 u(a) = <%= u(a) %> 
  
 } 
  
 a = ""< a & b >"" 
  
 ERB.new(str1).run
  
 produces:
  
 h(a) = &lt; a &amp; b &gt; 
  
 u(a) = %3C%20a%20%26%20b%20%3E
  
 You may find the command-line utility
  erb
  is supplied with your Ruby distribution. 
 This allows you to run
  erb
  substitutions on an input file; see
  erb --help
  for details.",NA
 Etc,"Access User and Group Information in /etc/passwd
  
  
 Only if:
  Unix or
  
 The
  Etc
  module provides a number of methods for querying the
  passwd
  and
  group
  
 Cygwin
  
 facilities on Unix systems.
  
 • Find out information about the currently logged-in user.
  
 require 'etc'
  
 tc
  
 name = Etc.getlogin",NA
E,"info = Etc.getpwnam(name)
  
 info.name
  
 →
  
 ""dave""
  
 info.uid
  
 →
  
 502
  
 info.dir
  
 ""/Users/dave""
  
 →
  
 info.shell
  
 →
  
 ""/bin/bash""
  
 group = Etc.getgrgid(info.gid)
  
 group.name
  
 →
  
 ""dave""
  
 • Return the names of all users and groups on the system used to create this book.
  
 require 'etc'
  
 users = [] 
  
 Etc.passwd {|passwd| users << passwd.name }
  
 users.join("", "")
  
 →
  
 ""nobody, root, daemon, unknown, smmsp, lp,
  
 postfix, www, eppc, mysql, sshd, qtss, 
  
 cyrus, mailman, appserver, dave, testuser""
  
 groups = [] 
  
 Etc.group {|group| groups << group.name }
  
 groups.join("", "")
  
 →
  
 ""nobody, nogroup, wheel, daemon, kmem,
  
 sys, tty, operator, mail, bin, staff, 
  
 smmsp, lp, postfix, postdrop, guest, utmp, 
  
 uucp, dialer, network, www, mysql, sshd, 
  
 qtss, mailman, appserverusr, admin, 
  
 appserveradm, unknown, dave, testuser""
  
 Prepared exclusively for Yeganefar",NA
 expect,"Expect Method for IO Objects
  
 The
  expect
  library adds the method
  expect
  to all
  IO
  objects. This allows you to write 
 code that waits for a particular string or pattern to be available from the I/O stream. 
 The 
 expect
  method is particularly useful with pty objects (see page
  699
 ) and with 
 network
  
 connections to remote servers, where it can be used to coordinate the use of external 
 interactive processes.
  
 If the global variable
  $expect_verbose
  is
  true
 , the
  expect
  method writes all char-",NA
E,"xpect
  
 acters read from the I/O stream to
  STDOUT
 .
  
 See also:
  pty
  (page
  699
 )
  
 • Connect to the local FTP server, log in, and print out the name of the user’s direc-
  
 tory. (Note that it would be a lot easier to do this using the library.)
  
 # This code might be specific to the particular 
  
 # ftp daemon.
  
 require 'expect' 
  
 require 'socket'
  
 $expect_verbose = true
  
 socket = TCPSocket.new('localhost', 'ftp')
  
 socket.expect(""ready"") 
  
 socket.puts(""user testuser"") 
  
 socket.expect(""Password required for testuser"") 
  
 socket.puts(""pass secret"") 
  
 socket.expect(""logged in.\r\n"") 
  
 socket.puts(""pwd"") 
  
 puts(socket.gets) 
  
 socket.puts ""quit""
  
 produces:
  
 220 localhost FTP server (lukemftpd 1.1) ready. 
  
 331 Password required for testuser.
  
 230-
  
 Welcome to Darwin!
  
 230 User testuser logged in.
  
 257 ""/Users/testuser"" is the current directory.",NA
 Fcntl,"Symbolic Names for IO#fcntl Commands
  
 The
  Fcntl
  module provides symbolic names for each of the host system’s available 
 fcntl
  constants (defined in
  fcntl.h
 ). That is, if the host system has a constant named 
 F_GETLK
  defined in
  fcntl.h
 , then the
  Fcntl
  module will have a corresponding con-stant
  
 Fcntl::F_GETLK
  with the same value as the header file’s
  #define
 .
  
 • Different operating system will have different
  Fcntl
  constants available. The value 
 associated with a constant of a given name may also differ across platforms. 
 Here are the values on my Mac OS X system.",NA
F,"cntl
  
 require 'fcntl'
  
 Fcntl.constants.sort.each do |name| 
  
 printf ""%10s: %04x\n"", name, Fcntl.const_get(name) 
  
 end
  
 produces:
  
 FD_CLOEXEC: 0001 
  
 F_DUPFD: 0000 
  
 F_GETFD: 0001 
  
 F_GETFL: 0003 
  
 F_GETLK: 0007 
  
 F_RDLCK: 0001 
  
 F_SETFD: 0002 
  
 F_SETFL: 0004 
  
 F_SETLK: 0008 
  
 F_SETLKW: 0009 
  
 F_UNLCK: 0002 
  
 F_WRLCK: 0003 
  
 O_ACCMODE: 0003 
  
 O_APPEND: 0008 
  
 O_CREAT: 0200 
  
 O_EXCL: 0800 
  
 O_NDELAY: 0004 
  
 O_NOCTTY: 0000 
  
 O_NONBLOCK: 0004 
  
 O_RDONLY: 0000 
  
 O_RDWR: 0002 
  
 O_TRUNC: 0400 
  
 O_WRONLY: 0001
  
 Prepared exclusively for Yeganefar",NA
 FileUtils,"File and Directory Manipulation
  
 FileUtils
  is a collection of methods for manipulating files and directories. Although 
 generally applicable, the model is particularly useful when writing installation scripts.
  
 Many methods take a
  src
  and a
  dest
  parameter. If
  dest
  is a directory, then
  src
  may be a
  
 single filename or an array of filenames. For example, the following copies the files
  a
 , 
 b
 , and
  c
  to
  /tmp
 .
  
 cp( %w{ a b c }, ""/tmp"")",NA
F,"ileUtils
  
 Most functions take a set of options. These may be zero or more of
  
 Option
  
 Meaning
  
 :verbose
  
 Trace execution of each function (by default to
  STDERR
 , although this can
  
 be overridden by setting the class variable
  @fileutils_output
 ).
  
 :noop 
  
 Do not perform the action of the function (useful for testing scripts). :force 
  
 Override some default conservative behavior of the method (for example 
  
 overwriting an existing file).
  
 :preserve 
  
 Attempt to preserve atime, mtime, and mode information from
  src
  in
  dest
 .
  
 (Setuid and setgid flags are always cleared.)
  
 For maximum portability, use forward slashes to separate the directory components of 
 filenames, even on Windows.
  
 FileUtils
  contains three submodules which duplicate the top-level methods but with
  
 1.8
  
  
 different default options: module
  FileUtils::Verbose
  sets the verbose option, mod-
  
 ule
  FileUtils::NoWrite
  sets noop, and
  FileUtils::DryRun
  
 sets verbose and noop.
  
 See also:
  un
  (page
  730
 )
  
 require 'fileutils' 
  
 include FileUtils::Verbose 
  
 cd(""/tmp"") do 
  
 cp(""/etc/passwd"", ""tmp_passwd"") 
  
 chmod(0666, ""tmp_passwd"") 
  
 cp_r(""/usr/include/net/"", ""headers"") 
  
 rm(""tmp_passwd"") 
  
 # Tidy up 
  
 rm_rf(""headers"") 
  
 end
  
 produces:
  
 cd /tmp 
  
 cp /etc/passwd tmp_passwd 
  
 chmod 666 tmp_passwd 
  
 cp -r /usr/include/net/ headers 
  
 rm tmp_passwd 
  
 rm -rf headers 
  
 cd -
  
 Prepared exclusively for Yeganefar",NA
 Find,"Traverse Directory Trees
  
 The
  Find
  module supports the top-down traversal of a set of file paths, given as argu-
 ments to the
  find
  method. If an argument is a file, its name is passed to the block. If 
 it’s a directory, then its name and the name of all its files and subdirectories will be 
 passed in.
  
 Within the block, the method
  prune
  may be called, which skips the current file or 
 directory, restarting the loop with the next directory. If the current file is a directory, 
 that directory will not be recursively entered.",NA
F,"ind
  
 require 'find' 
  
 Find.find(""/etc/passwd"", ""code/cdjukebox"") do |f| 
  
 type = case 
  
  
 when File.file?(f): ""F"" 
  
  
 when File.directory?(f): ""D"" 
  
  
 else ""?"" 
  
  
 end 
  
 puts ""#{type}: #{f}"" 
  
 Find.prune if f =~ /CVS/ 
  
 end
  
 produces:
  
 F: /etc/passwd 
  
 D: code/cdjukebox 
  
 F: code/cdjukebox/Makefile 
  
 F: code/cdjukebox/libcdjukebox.a 
  
 D: code/cdjukebox/CVS 
  
 F: code/cdjukebox/cdjukebox.o 
  
 F: code/cdjukebox/cdjukebox.h 
  
 F: code/cdjukebox/cdjukebox.c
  
 Prepared exclusively for Yeganefar",NA
 Forwardable,"Object Delegation
  
 Forwardable
  provides a mechanism to allow classes to delegate named method calls to 
 other objects.
  
 See also:
  Delegator
  (page
  646
 )
  
  
 • This simple symbol table uses a hash, exposing a subset of the hash’s methods.
  
 require 'forwardable'
  
 orwardable
  
 class SymbolTable",NA
F,"extend Forwardable 
  
 def_delegator(:@hash, :[], 
  
 :lookup) 
  
 def_delegator(:@hash, :[]=, :add) 
  
 def_delegators(:@hash, :size, :has_key?) 
  
 def initialize 
  
  
 @hash = Hash.new 
  
 end 
  
 end
  
 st = SymbolTable.new
  
 st.add('cat', 'feline animal')
  
 →
  
 ""feline animal""
  
 st.add('dog', 'canine animal')
  
 →
  
 ""canine animal""
  
 st.add('cow', 'bovine animal')
  
 ""bovine animal""
  
 →
  
 st.has_key?('cow')
  
 →
  
 true
  
 st.lookup('dog')
  
 →
  
 ""canine animal""
  
 • Forwards can also be defined for individual objects by extending them with the 
 SingleForwardable
  module. It’s hard to think of a good reason to use this fea-ture, 
 so here’s a silly one....
  
 require 'forwardable'
  
 TRICKS = [ ""roll over"", ""play dead"" ]
  
 dog = ""rover""
  
 dog.extend SingleForwardable 
  
 dog.def_delegator(:TRICKS, :each, :can)
  
 dog.can do |trick| 
  
 puts trick 
  
 end
  
 produces:
  
 roll over 
  
 play dead
  
 Prepared exclusively for Yeganefar",NA
 ftools,"Extra Tools for Class File
  
 The
  ftools
  library adds methods to class
  File
 , primarily aimed at programs that move 
 and copy files, such as installers. The
  FileUtils
  library is now recommended over 
 ftools
 .
  
 See also:
  fileutils
  (page
  657
 )
  
 • Install the file
  testfile
  into the
  /tmp
  directory. Don’t bother copying the file if 
  
 the target already exists and is the same as the original.",NA
F,"tools
  
 require 'ftools'
  
 def install_if_different(source, dest) 
  
 if File.exist?(dest) && File.compare(source, dest) 
  
  
 puts ""#{dest} is up to date"" 
  
 else 
  
  
 File.copy(source, dest) 
  
  
 puts ""#{source} copied to #{dest}"" 
  
 end 
  
 end
  
 install_if_different('testfile', '/tmp/testfile') 
  
 puts ""Second time..."" 
  
 install_if_different('testfile', '/tmp/testfile') 
  
 puts ""Done""
  
 produces:
  
 testfile copied to /tmp/testfile 
  
 Second time...
  
 /tmp/testfile is up to date 
  
 Done
  
 • Do the same (with slightly different logging) using FTool’s
  install
  method.
  
 require 'ftools'
  
 File.install('testfile', '/tmp', 0644, true) 
  
 puts ""Second time..."" 
  
 File.install('testfile', '/tmp', 0644, true) 
  
 puts ""Done""
  
 produces:
  
 testfile -> /tmp/testfile 
  
 chmod 0644 /tmp/testfile 
  
 Second time...
  
 Done
  
 Prepared exclusively for Yeganefar",NA
 GDBM,"Interface to GDBM Database
  
  
 Only if:
  gdbm
  
 Interfaces to the gdbm database library.
 3
 Although the
  DBM
  library provides generic
  
 library available
  
 access to gdbm databases, it doesn’t expose some features of the full gdbm inter-
  
 face. The
  GDBM
  library gives you access to underlying gdbm features such as the 
 cache size, synchronization mode, reorganization, and locking. Only one process may 
 have a GDBM database open for writing (unless locking is disabled).
  
 See also:
  DBM
  (page
  645
 ),
  SDBM
  (page
  709
 )
  
  
 • Store some values into a database, and then read them back. The second 
 parameter 
  
  
 to the
  open
  method specifies the file mode, and the next 
 parameter uses two flags",NA
G,"DBM
  
 which (1) create the database if it doesn’t exist, and (2) force all writes to be 
 synced to disk. Create on open is the default Ruby gdbm behavior.
  
 require 'gdbm'
  
 GDBM.open(""data.dbm"", 0644, GDBM::WRCREAT | GDBM::SYNC) do |dbm| dbm['name'] = 
 ""Walter Wombat"" 
  
 dbm['dob'] 
  
 = ""1969-12-25"" 
  
 dbm['uses'] = ""Ruby"" 
  
 end
  
 GDBM.open(""data.dbm"") do |dbm| 
  
 p dbm.keys 
  
 p dbm['dob'] 
  
 dbm.delete('dob') 
  
 p dbm.keys 
  
 end
  
 produces:
  
 [""uses"", ""dob"", ""name""] 
  
 ""1969-12-25"" 
  
 [""uses"", ""name""]
  
 • Open a database read-only. Note that the attempt to delete a key fails.
  
 require 'gdbm'
  
 GDBM.open(""data.dbm"", 0, GDBM::READER) do |dbm| 
  
 p dbm.keys 
  
 dbm.delete('name') 
  
 end
  
 produces:
  
 [""uses"", ""name""] 
  
 prog.rb:4:in `delete': Reader can't delete (GDBMError) 
  
 from prog.rb:4 
  
 from prog.rb:2:in `open'
  
 3.
  
 http://www.gnu.org/software/gdbm/gdbm.html
  
  
 Prepared exclusively for Yeganefar",NA
 Generator,"External Iterators
  
 The
  generator
  library implements external iterators (as in Java and C++) based either 
 on
  Enumerable
  objects or on a block that yields values. The
  Generator
  class is a sim-ple 
 iterator. The library also include
  SyncEnumerator
 , which creates an
  Enumerable 
 object 
 that iterates over several collections at once.
  
 See also:
  Enumerable
  (page
  433
 ),
  Enumerator
  (page
  651
 )
  
  
 • Iterate over an
  Enumerable
  object.
  
 require 'generator' 
  
 gen = Generator.new(1..4)",NA
G,"enerator
  
 while gen.next?
  
 print gen.next, ""--"" 
  
 end
  
 produces:
  
 1--2--3--4--
  
 • Iterate over a block.
  
 require 'generator'
  
 gen = Generator.new do |result| 
  
 result.yield ""Start"" 
  
 3.times {|i| result.yield i} 
  
 result.yield ""done"" 
  
 end 
  
 while gen.next?
  
 print gen.next, ""--"" 
  
 end
  
 produces:
  
 Start--0--1--2--done--
  
 • Iterate over two collections at once.
  
 require 'generator' 
  
 gen = SyncEnumerator.new(1..3, ""a""..""c"") 
  
 gen.each {|num, char| print num, ""("", char, "") "" }
  
 produces:
  
 1(a) 2(b) 3(c)
  
 Prepared exclusively for Yeganefar",NA
 GetoptLong,"Parse Command-Line Options
  
 Class
  GetoptLong
  supports GNU-style command-line option parsing. Options may be a 
 minus sign (–) followed by a single character, or two minus signs (- -) followed by a 
 name (a long option). Long options may be abbreviated to their shortest unambiguous 
 lengths.
  
 A single internal option may have multiple external representations. For example, the 
 option to control verbose output could be any of
  -v
 ,
  --verbose
 , or
  --details
 . Some 
 options may also take an associated value.
  
 etoptLong
  
 Each internal option is passed to
  GetoptLong
  as an array, containing strings repre-",NA
G,"senting the option’s external forms and a flag. The flag specifies how
  GetoptLong 
 is to 
 associate an argument with the option (
 NO_ARGUMENT
 ,
  REQUIRED_ARGUMENT
 , or 
 OPTIONAL_ARGUMENT
 ).
  
 If the environment variable
  POSIXLY_CORRECT
  is set, all options must precede non-
 options on the command line. Otherwise, the default behavior of
  GetoptLong
  is to reor-
 ganize the command line to put the options at the front. This behavior may be 
 changed by setting
  
 GetoptLong
 #
 ordering=
  to one of the constants
  
 PERMUTE
 ,
  
 REQUIRE_ORDER
 , or
  RETURN_IN_ORDER
 .
  POSIXLY_CORRECT
  may not be overridden.
  
 See also:
  OptionParser
  (page
  690
 )
  
 # Call using ""ruby example.rb --size 10k -v -q a.txt b.doc""
  
 require 'getoptlong'
  
 # specify the options we accept and initialize 
  
 # the option parser
  
 opts = GetoptLong.new( 
  
 [ ""--size"", 
  
 ""-s"", 
  
 GetoptLong::REQUIRED_ARGUMENT ], [ ""--
 verbose"", ""-v"", 
  
 GetoptLong::NO_ARGUMENT ], [ ""--query"", 
  
 ""-q"", 
  
  
 GetoptLong::NO_ARGUMENT ], [ ""--check"", 
  
 ""--valid"", ""-c"", GetoptLong::NO_ARGUMENT ] 
  
 )
  
 # process the parsed options
  
 opts.each do |opt, arg| 
  
 puts ""Option: #{opt}, arg #{arg.inspect}"" 
  
 end
  
 puts ""Remaining args: #{ARGV.join(', ')}""
  
 produces:
  
 Option: --size, arg ""10k"" 
  
 Option: --verbose, arg """" 
  
 Option: --query, arg """" 
  
 Remaining args: a.txt, b.doc
  
 Prepared exclusively for Yeganefar",NA
 GServer,"Generic TCP Server
  
 Simple framework for writing TCP servers. Subclass the
  GServer
  class, set the port 
 (and potentially other parameters) in the constructor, and then implement a
  serve 
 method to handle incoming requests.
  
 GServer
  manages a thread pool for incoming connections, so your
  serve
  method may be 
 running in multiple threads in parallel.
  
 You can run multiple
  GServer
  copies on different ports in the same application.
  
 Server
  
 • When a connection is made on port 2000, respond with the current time as a 
 string. 
  
 Terminate after handling three requests.",NA
G,"require 'gserver'
  
 class TimeServer < GServer 
  
 def initialize 
  
  
 super(2000) 
  
  
 @count = 3 
  
 end 
  
 def serve(client) 
  
  
 client.puts Time.now.to_s 
  
  
 @count -= 1 
  
  
 stop if @count.zero?
  
 end 
  
 end
  
 server = TimeServer.new
  
 server.audit = true 
  
 # enable logging 
  
 server.start 
  
 server.join
  
 • You can test this server by telnetting into
  localhost
  on port 2000.
  
 % telnet localhost 2000
  
 produces:
  
 Trying 127.0.0.1...
  
 Connected to localhost.
  
 Escape character is '^]'.
  
 Thu Aug 26 22:38:41 CDT 2004 
  
 Connection closed by foreign host.
  
 Prepared exclusively for Yeganefar",NA
 Iconv,"Character Encoding Conversion
  
 The
  Iconv
  class is an interface to the Open Group’s
  iconv
  library, which supports the
  
 Only if:
  libiconv 
  
 installed
  
 translation of strings between character encodings. For a list of the supported 
 encodings on your platform, see the
  iconv_open
  man pages for your system.
  
 An
  Iconv
  object encapsulates a conversion descriptor, which contains the information 
 needed to convert from one encoding to another. The converter can be used multiple 
 times, until closed.
  
 The conversion method
  iconv
  can be called multiple times to convert input strings. At
  
 the end, it should be called with a
  nil
  argument to flush out any remaining output.
  
 • Convert from ISO-8859-1 to UTF-16.
  
 conv
  
 require 'iconv'",NA
I,"conv = Iconv.new(""UTF-16"", ""ISO-8859-1"") 
  
 result = conv.iconv(""hello"") 
  
 result << conv.iconv(nil)
  
 result
  
 →
  
 ""\376\377\000h\000e\000l\000l\000o""
  
 • Do the same conversion using a class method. Not we use
  Iconv.conv
 , which 
 returns a single string, as opposed to
  Iconv.iconv
 , which returns an array of 
 strings.
  
 require 'iconv' 
  
 result = Iconv.conv(""UTF-16"", ""ISO-8859-1"", ""hello"")
  
 result
  
 →
  
 ""\376\377\000h\000e\000l\000l\000o""
  
 • Convert
  olé
  from UTF-8 to ISO-8859-1.
  
 require 'iconv' 
  
 result = Iconv.conv(""ISO-8859-1"", ""UTF-8"", ""ol\303\251"")
  
 result
  
 →
  
 ""ol\351""
  
 • Convert
  olé
  from UTF-8 to ASCII. This throws an exception, as ASCII doesn’t 
  
 have an
  é
  character.
  
 require 'iconv' 
  
 result = Iconv.conv(""ASCII"", ""UTF-8"", ""ol\303\251"")
  
 produces:
  
 prog.rb:2:in `conv': ""\303\251"" (Iconv::IllegalSequence) 
  
 from prog.rb:2
  
 • This time, convert to ASCII with transliteration, which shows approximations of 
  
 missing characters.
  
 require 'iconv' 
  
 result = Iconv.iconv(""ASCII//TRANSLIT"", ""UTF-8"", ""ol\303\251"")
  
 result
  
 →
  
 [""ol'e""]
  
  
 Prepared exclusively for Yeganefar",NA
 IO/Wait,"Check for Pending Data to Be Read
  
  
 Only if:
  
 Including the library
  io/wait
  adds the methods
  IO
 #
 ready?
  and
  IO
 #
 wait
  to the stan-
  
 FIONREAD feature in 
 ioctl(2)
  
 dard
  IO
  class. These allow an
  IO
  object opened on a stream (not a file) to be queried to
  
 see if data is available to be read without reading it and to wait for a given number of 
 bytes to become available.
  
 • Set up a pipe between two processes, and write ten bytes at a time into it. Periodi-
  
 cally see how much data is available.
  
 require 'io/wait'
  
 reader, writer = IO.pipe 
  
 if (pid = fork) 
  
 writer.close
  
 O/Wait
  
 8.times do",NA
I,"sleep 0.03 
  
 len = reader.ready?
  
  
 puts ""Ready? = #{len.inspect}"" 
  
  
 puts(reader.sysread(len)) if len 
  
 end 
  
 Process.waitpid(pid) 
  
 else 
  
 reader.close 
  
 5.times do |n| 
  
  
 sleep 0.04 
  
  
 writer.write n.to_s * 10 
  
 end 
  
 writer.close 
  
 end
  
 produces:
  
 Ready? = 10 
  
 0000000000 
  
 Ready? = nil 
  
 Ready? = 10 
  
 1111111111 
  
 Ready? = 10 
  
 2222222222 
  
 Ready? = 10 
  
 3333333333 
  
 Ready? = nil 
  
 Ready? = 10 
  
 4444444444 
  
 Ready? = nil
  
 Prepared exclusively for Yeganefar",NA
 IPAddr,"Represent and Manipulate IP Addresses
  
 Class
  IPAddr
  holds and manipulates Internet Protocol (IP) addresses. Each address
  
 contains three parts: an address, a mask, and an address family. The family will typi-
  
 cally be
  AF_INET
  for IPv4 and IPv6 addresses. The class contains methods for extract-
  
 ing parts of an address, checking for IPv4 compatible addresses (and IPv4 mapped IPv6
  
 addresses), testing whether an address falls within a subnet and many other functions.
  
 It is also interesting in that it contains as data its own unit tests.
  
 require 'ipaddr'
  
 v4 = IPAddr.new('192.168.23.0/24')
  
 PAddr
  
 v4
  
 →
  
 #<IPAddr: IPv4:192.168.23.0/ 255.255.255.0>
  
 v4.mask(16)
  
 →
  
 #<IPAddr: IPv4:192.168.0.0/ 255.255.0.0>
  
 v4.reverse
  
 →
  
 ""0.23.168.192.in-addr.arpa""",NA
I,"v6 = IPAddr.new('3ffe:505:2::1')
  
 v6
  
 →
  
 #<IPAddr:
  
 IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/
  
 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>
  
 v6.mask(48)
  
 →
  
 #<IPAddr:
  
 IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/
  
 ffff:ffff:ffff:0000:0000:0000:0000:0000>
  
 # the value for 'family' is OS dependent. This
  
 # value is for OS X
  
 v6.family
  
 →
  
 30
  
 other = IPAddr.new(""192.168.23.56"")
  
 v4.include?(other)
  
 →
  
 true
  
  
 Prepared exclusively for Yeganefar",NA
 jcode,"Encoding Support for Strings
  
 Requiring the
  jcode
  library augments the built-in
  String
  class with additional support 
 for EUC and SJIS Japanese encodings and UTF8. This is effective only if
  $KCODE
  is 
 one of EUC, SJIS, or UTF8. The following methods are updated:
  chop!
 ,
  chop
 ,
  delete!
 , 
 delete
 ,
  squeeze!
 ,
  squeeze
 ,
  succ!
 ,
  succ
 ,
  tr!
 ,
  tr
 ,
  tr_s!
 , and
  tr_s
 .
  
 For example, the string
  ""\342\210\202x/\342\210\202y""
  contains nine 8-bit char-
 acters. However, the sequence
  \343\210\202
  could also be interpreted as a single 
 UTF-8 character (a math delta symbol, making the string
  δx/δy
 ). If we don’t tell 
 Ruby about the encoding, it treats each byte in the string as a separate character:
  
 • Without encoding support, the string contains bytes.
  
 $KCODE = ""NONE"" 
  
 require 'jcode'",NA
J,"code
  
 str = ""\342\210\202x/\342\210\202y"" 
  
 str.length
 →
  
 9 
  
 str.jlength
 →
  
 9 
  
 str.jcount(""\210"")
  
 →
  
 2 str.chop!
 →
  
 ""\342\210\202x/\342\210\202"" 
  
 str.chop!
 →
  
 ""\342\210\202x/\342\210""
  
 str.each_char {|ch| print ch.inspect, "" ""}
  
 produces:
  
 ""\342""
  
 ""\210""
  
 ""\202""
  
 ""x""
  
 ""/""
  
 ""\342""
  
 ""\210""
  
 ""\202""
  
 ""y""
  
 • However, tell Ruby that it is dealing with UTF8 strings and the result changes.
  
 $KCODE = 'UTF8' 
  
 require 'jcode'
  
 str = ""\342\210\202x/\342\210\202y""
  
 str.length
  
 →
  
 9
  
 str.jlength
  
 →
  
 5
  
 str.jcount(""\210"")
  
 →
  
 0
  
 str.chop!
  
 ""
 δ
 x/
 δ
 ""
  
 →
  
 str.chop!
  
 →
  
 ""
 δ
 x/""
  
 str = ""\342\210\202x/\342\210\202y"" 
  
 str.each_char {|ch| print ch.inspect, "" ""}
  
 produces:
  
 ""
 δ
 ""
  
 ""x""
  
 ""/""
  
 ""
 δ
 ""
  
 ""y""",NA
 Logger,"Application Logging
  
 Writes log messages to a file or stream. Supports automatic time- or size-based 
 rolling of log files. Messages can be assigned severities, and only those messages at 
 or above the logger’s current reporting level will be logged.
  
 • During development, you may want to see all messages.
  
 require 'logger' 
  
 log = Logger.new(STDOUT) 
  
 log.level = Logger::DEBUG 
  
 log.datetime_format = ""%H:%H:%S"" 
  
 log.info(""Application starting"") 
  
 3.times do |i| 
  
 log.debug(""Executing loop, i = #{i}"") 
  
 temperature = some_calculation(i) 
  
  
 # defined externally if temperature > 50
  
  
 log.warn(""Possible overheat. i = #{i}"") 
  
 end 
  
 end
  
 ogger
  
 log.info(""Application terminating"")",NA
L,"produces:
  
 I, [22:22:42#28184] 
  
 INFO -- : Application starting 
  
 D, [22:22:42#28184] DEBUG -- : Executing loop, i = 0 
  
 D, [22:22:42#28184] DEBUG -- : Executing loop, i = 1 
  
 D, [22:22:42#28184] DEBUG -- : Executing loop, i = 2 
  
 W, [22:22:42#28184] 
  
 WARN -- : Possible overheat. i = 2 
  
 I, [22:22:42#28184] 
  
 INFO -- : Application terminating
  
 • In deployment, you can turn off anything below INFO.
  
 require 'logger' 
  
 log = Logger.new(STDOUT) 
  
 log.level = Logger::INFO 
  
 log.datetime_format = ""%H:%H:%S""
  
 # as above...
  
 produces:
  
 I, 
 [22:22:42#28186] 
  
 W, 
 [22:22:42#28186] 
  
 I, [22:22:42#28186]
  
 INFO -- : Application starting 
  
 WARN -- : Possible overheat. i = 2 
  
 INFO -- : Application terminating
  
 • Log to a file, which is rotated when it gets to about 10k bytes. Keep up to five old 
  
 files.
  
 require 'logger' 
  
 log = Logger.new(""application.log"", 5, 10*1024) 
  
 log.info(""Application starting"") 
  
 # ...
  
 Prepared exclusively for Yeganefar",NA
 Mail,"Simple E-mail Parsing
  
 Class
  Mail
  provides basic parsing for e-mail messages. It can read an individual mes-
 sage from a named file, or it can be called repeatedly to read messages from a stream 
 on an opened mbox format file. Each
  Mail
  object represents a single e-mail message, 
 which is split into a header and a body. The body is an array of lines, and the header 
 is a hash indexed by the header name.
  Mail
  correctly joins multiline headers.
  
 • Read a single e-mail from a file.
  
 require 'mailread'
  
 MAILBOX = ""/Users/dave/Library/Mail/Mailboxes/Ruby/Talk.mbox/mbox"" msg = 
 Mail.new(MAILBOX)
  
 msg.header.keys
  
 →
  
 [""Status"", ""List-software"", ""Message-id"",
  
 ""Subject"", ""Received"", 
  
 ""X-spambayes-classification"", 
  
 ""List-unsubscribe"", ""Posted"", 
  
 ""X-spam-level"", ""Content-type"", ""From"", 
  
 ""X-virus-scanned"", ""List-post"",
  
 ""X-spam-status"",
  
 ail
  
 ""Content-transfer-encoding"", ""X-mlserver"", 
  
 ""To"", ""In-reply-to"", ""X-ml-info"",",NA
M,"""X-mail-count"", ""Date"", ""List-owner"", 
  
 ""X-ml-name"", ""References"", ""Reply-to"", 
  
 ""Delivered-to"", ""List-help"", ""Lines"", 
  
 ""Mime-version"", ""X-spam-checker-version"", 
  
 ""List-id"", ""Precedence""]
  
 msg.body[0]
  
 →
  
 ""On Sat, 14 Aug 2004 03:02:42 +0900, Curt
  
 Hibbs <curt@hibbs.com> wrote:\n""
  
 msg.body[1]
  
 →
  
 ""> We've change the name of the project from
  
 \""Ruby Installer for Windows\"" to\n""
  
 msg.body[2]
  
 →
  
 ""> the \""One-Click Ruby Installer\"" because
  
 we are branching out more platforms\n""
  
 • Read successive messages from an mbox format file.
  
 require 'mailread'
  
 MAILBOX = ""/Users/dave/Library/Mail/Mailboxes/Ruby/Talk.mbox/mbox"" mbox = 
 File.open(MAILBOX) 
  
 count = 0 
  
 lines = 0 
  
 while !mbox.eof?
  
 msg = Mail.new(mbox) 
  
 count += 1 
  
 lines += msg.header['Lines'].to_i 
  
 end
  
 count
  
 →
  
 180
  
 lines
  
 →
  
 5927
  
  
 Prepared exclusively for Yeganefar",NA
 mathn,"Unified Numbers
  
 The
  mathn
  library attempts to bring some unity to numbers under Ruby, making classes 
 Bignum
 ,
  Complex
 ,
  Fixnum
 ,
  Integer
 , and
  Rational
  work and play better together.
  
 • Types will tend to convert between themselves in a more natural way (so, for 
  
 example,
  Complex::I
  squared will evaluate to
  −1
 , rather than
  Complex[-1,0]
 ).• 
 Division will tend to produce more accurate results. The conventional division 
  
 operator (
 /
 ) is redefined to use
  quo
 , which doesn’t round (
 quo
  is documented on 
  
 page
  545
 ).
  
 • Related to the previous point, rational numbers will be used in preference to 
 floats when possible. Dividing one by two results in the rational number
 1 2
 , 
 rather than 
 0.5
  (or
  0
 , the result of normal integer division).
  
 See also:
  Matrix
  (page
  673
 ),
  Rational
  (page
  700
 ),
  Complex
  (page
  641
 )
  
 • Without
  mathn
  
 require 'matrix'
  
 →
  
 2",NA
M,"athn
  
 require 'complex'
  
 36/16
  
 Math.sqrt(36/16)
  
 1.4142135623731
  
 →
  
 Complex::I * Complex::I
  
 Complex(-1, 0)
  
 →
  
 m = Matrix[[1,2],[3,4]] 
  
 i = m.inv
  
 i*m
  
 →
  
 1
  
 0
  
 −2
  
 −2
  
 (36/16)**-2
  
 →
  
 0.25
  
 (36.0/16.0)**-2
  
 →
  
 0.197530864197531
  
 0.111111111111111
  
 (-36/16)**-2
  
 →
  
 →
  
 1
  
 (36/16)**(1/2)
  
 (-36/16)**(1/2)
  
 →
  
 1
  
 0.5
  
 (36/16)**(-1/2)
  
 →
  
 -0.333333333333333
  
 (-36/16)**(-1/2)
  
 →
  
 →
  
  2
  
 0
  
 0
  
 Matrix.diagonal(6,7,8)/3
  
 0
  
 2
  
 0
  
 0
  
 0
  
 2
  
  
 Prepared exclusively for Yeganefar",NA
M,"(-36/16)**(-1/2)
  
 →
  
 Complex(4.08215599715784e-17,
  
 -0.666666666666667)
  
 Matrix.diagonal(6,7,8)/3
  
 →
  
  2
  
 0
  
 0
  
 0
  
 7/3
  
 0
  
 0
  
 0
  
 8/3
  
 • The
  mathn
  library also extends the number classes to include new functionality 
  
 and adds a new class
  Prime
 .
  
 require 'mathn' 
  
 primes = Prime.new
  
 3.times { puts primes.succ } 
  
 primes.each {|p| puts p; break if p > 20 }
  
 produces:
  
 2 
  
 3 
  
 5 
  
 7 
  
 11 
  
 13 
  
 17 
  
 19 
  
 23
  
 Prepared exclusively for Yeganefar",NA
 Matrix,"Matrix and Vector Manipulation
  
 The
  matrix
  library defines classes
  Matrix
  and
  Vector
 , representing rectangular matri-ces 
 and vectors. As well as the normal arithmetic operations, they provide methods for 
 matrix-specific functions (such as rank, inverse, and determinants) and a number of 
 constructor methods (for creating special-case matrices—zero, identity, diagonal, sin-
 gular, and vector).
  
 Because by default integer arithmetic truncates, the determinant of integer matrices 
 may be incorrectly calculated unless you also require the
  mathn
  library.
  
 See also:
  mathn
  (page
  671
 ),
  Rational
  (page
  700
 )
  
 require 'matrix' 
  
 require 'mathn'
  
 m1 = Matrix[ [2, 1], [-1, 1] ]
  
 →
  
 2
  
 1
  
 atrix
  
 −1
  
 1
  
 m1[0,1]
  
 →
  
 1
  
 m1.inv
  
 →
  
 1/3
  
 −1/3",NA
M,"1/3
  
 2/3
  
 m1 * m1.inv
  
 →
  
  
 1
  
 0
  
 0
  
 1
  
 m1.determinant
  
 →
  
 3
  
 m1.singular?
  
 false
  
 →
  
 m2 = Matrix[ [1,2,3], [4,5,6], [7,8,9] ]
  
  1
  
 2
  
 3
  
 →
  
 4
  
 5
  
 6
  
 m2.minor(1, 2, 1, 2)
  
 7
  
 8
  
 9
  
 →
  
 5
  
 6
  
 8
  
 9
  
 m2.rank
  
 →
  
 2
  
 v1 = Vector[3, 4]
  
 Vector[3, 4]
  
 →
  
 v1.covector
  
 3
  
 4
  
 →
  
 m1 * v1
  
 Vector[10, 1]
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
 Monitor,"Monitor-Based Synchronization
  
 Monitors are a form of mutual-exclusion mechanism first proposed back in 1974. 
 They allow separate threads to define shared resources which will be accessed 
 exclusively, and they provide a mechanism for a thread to wait for resources to 
 become available in a controlled way.
  
 The
  monitor
  library actually defines three separate ways of using monitors: as a parent 
 class, as a mixin, and as a extension to a particular object. Examples of all three (and 
 other code showing monitors in action) starts on page
  134
 . In this section we 
 document the module form of
  Monitor
 . The class form is effectively identical. In both 
 the class form and when including
  MonitorMixin
  in an existing class it is essential to 
 invoke 
 super
  in the class’s
  initialize
  method.
  
 See also:
  Mutex
  (page
  675
 ),
  Sync
  (page
  717
 ),
  Thread
  (page
  612
 )
  
 require 'monitor' 
  
 require 'mathn'
  
 numbers = [] 
  
 numbers.extend(MonitorMixin) 
  
 number_added = numbers.new_cond
  
 # Reporter thread",NA
M,"onitor
  
 Thread.new do 
  
 loop do 
  
   
 numbers.synchronize do 
  
    
 number_added.wait_while { numbers.empty? } 
  
    
 puts numbers.shift 
  
   
 end 
  
 end 
  
 end
  
 # Prime number generator thread 
  
 generator = Thread.new do 
  
 p = Prime.new 
  
 5.times do 
  
   
 numbers.synchronize do 
  
    
 numbers << p.succ 
  
    
 number_added.signal 
  
   
 end 
  
 end 
  
 end
  
 generator.join
  
 produces:
  
 2 
  
 3 
  
 5 
  
 7 
  
 11
  
 Prepared exclusively for Yeganefar",NA
 Mutex,"Thread Synchronization Support
  
 The
  Mutex
  class allows threads to gain exclusive access to some shared resource. That 
 is, only one thread may hold the lock at any given time. Other threads may choose to 
 wait for the lock to become available or may choose to get an immediate error indi-
 cating that the lock is not available. The library also implements condition variables, 
 allowing a thread to give up control while holding a mutex and regain the lock when 
 the resource becomes available, and queues, allowing threads to pass messages 
 safely. We describe threading in Chapter
  11
  on page
  127
 , and discuss
  monitors
 , an 
 alternative synchronization mechanism, starting on page
  134
 .
  
 See also:
  Monitor
  (page
  674
 ),
  Sync
  (page
  717
 ),
  Queue
  (page
  722
 ),
  Thread
  (page
  612
 )
  
 require 'thread' 
  
 class Resource 
  
 attr_reader :left, :times_had_to_wait 
  
 def initialize(count) 
  
   
 @left = count
  
  
 @times_had_to_wait = 0 
  
  
 @mutex = Mutex.new 
  
  
 @empty = ConditionVariable.new 
  
 end",NA
M,"utex
  
 def use 
  
   
 @mutex.synchronize do 
  
    
 while @left <= 0 
  
    
 @times_had_to_wait += 1 
  
    
 @empty.wait(@mutex) 
  
    
 end 
  
    
 @left -= 1 
  
   
 end 
  
 end 
  
 def release 
  
   
 @mutex.synchronize do 
  
    
 @left += 1 
  
    
 @empty.signal if @left == 1 
  
   
 end 
  
 end 
  
 end
  
 def do_something_with(resource) 
  
 resource.use 
  
 sleep 0.001 # to simulate doing something that takes time resource.release 
  
 end
  
 resource = Resource.new(2) 
  
 user1 = Thread.new { 100.times { do_something_with(resource) } } user2 = Thread.new { 
 100.times { do_something_with(resource) } } user3 = Thread.new { 100.times { 
 do_something_with(resource) } } user1.join; user2.join; user3.join
  
 resource.times_had_to_wait
  
 →
  
 152
  
  
 Prepared exclusively for Yeganefar",NA
 Mutex_m,"Mutex Mix-In
  
 mutex_m
  is a variant of class
  Mutex
  (contained in the
  thread
  library documented on the 
 preceding page) that allows mutex facilities to be mixed into any object.
  
 The
  Mutex_m
  module defines methods that correspond to those in
  Mutex
  but with the 
 prefix
  mu_
  (so that
  lock
  is defined as
  mu_lock
  and so on). It then aliases these to the 
 original
  Mutex
  names.
  
 See also:
  Mutex
  (page
  675
 ),
  Sync
  (page
  717
 ),
  Thread
  (page
  612
 )
  
 require 'mutex_m'
  
 class Counter 
  
 include Mutex_m 
  
 attr_reader :count 
  
 def initialize 
  
   
 @count = 0
  
  
 super 
  
 end 
  
 def tick 
  
  
 lock 
  
  
 @count += 1",NA
M,"utex_m
  
   
 unlock 
  
 end 
  
 end
  
 c = Counter.new
  
 t1 = Thread.new { 10000.times { c.tick } } 
  
 t2 = Thread.new { 10000.times { c.tick } }
  
 t1.join 
  
 t2.join
  
 c.count
  
 →
  
 20000
  
  
 Prepared exclusively for Yeganefar",NA
 Net::FTP,"FTP Client
  
 The
  net/ftp
  library implements a File Transfer Protocol (FTP) client. As well as data 
 transfer commands (
 getbinaryfile
 ,
  gettextfile
 ,
  list
 ,
  putbinaryfile
 , and 
 puttextfile
 ), the 
 library supports the full complement of server commands (
 acct
 , 
 chdir
 ,
  delete
 ,
  mdtm
 ,
  
 mkdir
 ,
  nlst
 ,
  rename
 ,
  rmdir
 ,
  pwd
 ,
  size
 ,
  status
 , and
  system
 ). Anonymous and password-
 authenticated sessions are supported. Connections may be active or passive.
  
 See also:
  open-uri
  (page
  686
 )
  
 require 'net/ftp'
  
 ftp = Net::FTP.new('ftp.netlab.co.jp') 
  
 ftp.login 
  
 ftp.chdir('pub/lang/ruby/contrib') 
  
 files = ftp.list('n*') 
  
 ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024) 
  
 ftp.close",NA
N,"et::FTP
  
  
 Prepared exclusively for Yeganefar",NA
 Net::HTTP,"HTTP Client
  
 The
  net/http
  library provides a simple client to fetch headers and Web page contents 
 using the HTTP protocol.
  
 The interface to the
  get
 ,
  post
 , and
  head
  methods has changed between Ruby 1.6 and 
 1.8. Now, a single response object is returned, with the content of the response 
 accessible through the response’s
  body
  method. In addition, these methods no longer 
 raise exceptions on recoverable errors.
  
 See also:
  OpenSSL
  (page
  688
 ),
  open-uri
  (page
  686
 ),
  URI
  (page
  731
 )
  
 • Open a connection and fetch a page, displaying the response code and message, 
  
 header information, and some of the body.
  
 require 'net/http'
  
 Net::HTTP.start('www.pragmaticprogrammer.com') do |http| 
  
 response = http.get('/index.html') 
  
 puts ""Code = #{response.code}""
  
 puts ""Message = #{response.message}"" 
  
 response.each {|key, val| printf ""%-14s = %-40.40s\n"", key, val } p response.body[400, 55] 
  
 end
  
 et::HTTP
  
 produces:",NA
N,"Code = 200 
  
 Message = OK 
  
 last-modified = Fri, 27 Aug 2004 02:25:48 GMT 
  
 content-type = text/html 
  
 etag = ""b00d226-35b4-412e9bac"" 
  
 date = Fri, 27 Aug 2004 03:38:47 GMT 
  
 server = Rapidsite/Apa/1.3.31 (Unix) FrontPage/5.
  
 content-length = 13748 
  
 accept-ranges = bytes 
  
  
  
 "" 
 ""-selling book 'The Pragmatic Programmer' and The\n
  
 • Fetch a single page, displaying the response code and message, header informa-
  
 tion, and some of the body.
  
 require 'net/http'
  
 response = Net::HTTP.get_response('www.pragmaticprogrammer.com', '/index.html') 
  
 puts ""Code = #{response.code}"" 
  
 puts ""Message = #{response.message}"" 
  
 response.each {|key, val| printf ""%-14s = %-40.40s\n"", key, val } p response.body[400, 55]
  
 produces:
  
 Code = 200 
  
 Message = OK 
  
 last-modified = Fri, 27 Aug 2004 02:25:48 GMT
  
 Prepared exclusively for Yeganefar",NA
N,"et::HTTP
  
 end
  
 response = fetch('http://www.ruby-lang.org') 
  
 p response.body[500, 55]
  
 produces:
  
 Trying: http://www.ruby-lang.org 
  
 Trying: http://www.ruby-lang.org/en/ 
  
 ""rg\"">\n\t<link rel=\""start\"" title=\""Top\"" href=\""./\"">\n\t<meta h""
  
 • Search Dave’s blog by posting form data and reading back the response.
  
 require 'net/http'
  
 Net::HTTP.start('pragprog.com') do |query| 
  
 response = query.post(""/pragdave"", ""terms=jolt&handler=searching"") 
 response.body.scan(%r{<span class=""itemtitle"">(.*?)</span>}m) do |title| 
  
  
 puts title 
  
 end 
  
 end
  
 produces:
  
 We're Jolt Finalists! 
  
 We Got a Jolt Award!
  
 Prepared exclusively for Yeganefar",NA
 Net::IMAP,"Access an IMAP Mail Server
  
 The Internet Mail Access Protocol (IMAP) is used to allow mail clients to access mail 
 servers. It supports plain text login and the IMAP login and CRAM-MD5 authentica-
 tion mechanisms. Once connected, the library supports threading, so multiple interac-
 tions with the server may take place at the same time.
  
 The examples that follow are taken with minor modifications from the RDoc documen-
 tation in the library source file.
  
 See also:
  Net::POP
  (page
  681
 )
  
 • List senders and subjects of messages to “dave” in the INBOX.
  
 require 'net/imap'
  
 imap = Net::IMAP.new('my.mailserver.com') 
  
 imap.authenticate('LOGIN', 'dave', 'secret') 
  
 imap.examine('INBOX') 
  
 puts ""Message count: #{ imap.responses[""EXISTS""]}""
  
 imap.search([""TO"", ""dave""]).each do |message_id| 
  
 envelope = imap.fetch(message_id, ""ENVELOPE"")[0].attr[""ENVELOPE""] 
  
  
 puts 
 ""#{envelope.from[0].name}: \t#{envelope.subject}"" 
  
 end
  
 et::IMAP
  
 • Move all messages with a date in April 2003 from the folder
  Mail/sent-mail
  to",NA
N,"Mail/sent-apr03
 .
  
 require 'net/imap' 
  
 imap = Net::IMAP.new('my.mailserver.com') 
  
 imap.authenticate('LOGIN', 'dave', 'secret') 
  
 imap.select('Mail/sent-mail') 
  
 if not imap.list('Mail/', 'sent-apr03') 
  
  
 imap.create('Mail/sent-apr03') 
  
 end 
  
 imap.search([""BEFORE"", ""01-May-2003"", 
  
    
 ""SINCE"", ""1-Apr-2003""]).each do |message_id| 
  
 imap.copy(message_id, ""Mail/sent-apr03"") 
  
  
 imap.store(message_id, ""+FLAGS"", [:Deleted]) 
  
 end 
  
 imap.expunge
  
 Prepared exclusively for Yeganefar",NA
 Net::POP,"Access a POP Mail Server
  
 The
  net/pop
  library provides a simple client to fetch and delete mail on a Post Office 
 Protocol (POP) server.
  
 The class
  Net::POP3
  is used to access a POP server, returning a list of
  Net::POPMail 
 objects, one per message stored on the server. These
  POPMail
  objects are then used to 
 fetch and/or delete individual messages.
  
 The library also provides class
  APOP
 , an alternative to the
  POP3
  class that performs 
 authentication.
  
 require 'net/pop' 
  
 pop = Net::POP3.new('server.ruby-stuff.com') 
  
 pop.start('joe', 'secret') do |server| 
  
 msg = server.mails[0]
  
 # Print the 'From:' header line 
  
 from = msg.header.split(""\r\n"").grep(/^From: /)[0] 
  
 puts from
  
 puts 
  
 puts ""Full message:"" 
  
 text = msg.pop 
  
 puts text
  
 et::POP
  
 end",NA
N,"produces:
  
 From: dave@facet.ruby-stuff.com (Dave Thomas)
  
 Full message: 
  
 Return-Path: <dave@facet.ruby-stuff.com> 
  
 Received: from facet.ruby-stuff.com (facet.ruby-stuff.com [10.96.0.122]) by pragprog.com 
 (8.11.6/8.11.6) with ESMTP id i2PJMW701809 for <joe@carat.ruby-stuff.com>; Thu, 25 Mar 2004 
 13:22:32 -0600 Received: by facet.ruby-stuff.com (Postfix, from userid 502) 
  
 id 4AF228B1BD; Thu, 25 Mar 2004 13:22:36 -0600 (CST) 
  
 To: joe@carat.ruby-stuff.com 
  
 Subject: Try out the new features!
  
 Message-Id: <20040325192236.4AF228B1BD@facet.ruby-stuff.com> Date: Thu, 25 
 Mar 2004 13:22:36 -0600 (CST) 
  
 From: dave@facet.ruby-stuff.com (Dave Thomas) 
  
 Status: RO
  
 Ruby 1.8 has a boatload of new features, both in 
  
 the core language and in the supplied libraries.
  
 Try it out!
  
 Prepared exclusively for Yeganefar",NA
 Net::SMTP,"Simple SMTP Client
  
 The
  net/smtp
  library provides a simple client to send electronic mail using the Sim-
 ple Mail Transfer Protocol (SMTP). It does not assist in the creation of the message 
 payload—it simply delivers messages once an RFC822 message has been 
 constructed.
  
 • Send an e-mail from a string.
  
 require 'net/smtp'
  
 msg = ""Subject: Test\n\nNow is the time\n"" 
  
 Net::SMTP.start('pragprog.com') do |smtp| 
  
 smtp.send_message(msg, 'dave@pragprog.com', ['dave']) 
  
 end
  
 • Send an e-mail using an SMTP object and an adapter.
  
 require 'net/smtp'
  
 Net::SMTP::start('pragprog.com', 25, ""pragprog.com"") do |smtp| 
 smtp.open_message_stream('dave@pragprog.com', # from
  
 [ 'dave' ]
  
 # to",NA
N,"et::SMTP
  
 ) do |stream|
  
 stream.puts ""Subject: Test1""
  
 stream.puts
  
 stream.puts ""And so is this""
  
 end
  
 end
  
 • Send an e-mail to a server requiring CRAM-MD5 authentication.
  
 require 'net/smtp'
  
 msg = ""Subject: Test\n\nNow is the time\n"" 
  
 Net::SMTP.start('pragprog.com', 25, 'pragprog.com', 
  
  
 'user', 'password', :cram_md5) do |smtp| 
  
 smtp.send_message(msg, 'dave@pragprog.com', ['dave']) 
  
 end",NA
 Net::Telnet,"Telnet Client
  
 The
  net/telnet
  library provides a complete implementation of a telnet client and 
 includes features that make it a convenient mechanism for interacting with nontelnet 
 services.
  
 Class
  Net::Telnet
  delegates to class
  Socket
 . As a result, the methods of
  Socket
  and its 
 parent, class
  IO
 , are available through
  Net::Telnet
  objects.
  
 • Connect to a
  localhost
 , run the
  date
  command, and disconnect.
  
 require 'net/telnet' 
  
 tn = Net::Telnet.new({}) 
  
 tn.login ""guest"", ""secret""
  
 tn.cmd ""date""
  
 →
  
 ""date\nThu Aug 26 22:38:56 CDT 2004\n% ""
  
 tn.close
  
 →
  
 nil
  
 • The methods
  new
 ,
  cmd
 ,
  login
 , and
  waitfor
  take an optional block. If present, the 
 block is passed output from the server as it is received by the routine. This can be
  
 used to provide realtime output, rather than waiting (for example) for a login to 
 complete before displaying the server’s response.
  
 require 'net/telnet'",NA
N,"et::Telnet
  
 tn = Net::Telnet.new({})
  
 {|str| print str }
  
 tn.login(""guest"", ""secret"")
  
 {|str| print str }
  
 tn.cmd(""date"")
  
 {|str| print str }
  
  
 tn.close
  
 produces:
  
 Connected to localhost.
  
 Darwin/BSD (wireless_2.local.thomases.com) (ttyp1) 
  
 login: guest 
  
 Password:Last login: Thu Aug 26 22:38:56 from localhost 
  
 Welcome to Darwin!
  
 % date 
  
 Thu Aug 26 22:38:57 CDT 2004 
  
 %
  
 • Get the time from an NTP server.
  
 require 'net/telnet' 
  
 tn = Net::Telnet.new('Host' => 'time.nonexistent.org', 
  
  
 'Port' => 
 'time', 
  
  
  
 'Timeout' => 60, 
  
  
  
 'Telnetmode' => false) 
  
 atomic_time = tn.recv(4).unpack('N')[0] 
  
 puts ""Atomic time: "" + Time.at(atomic_time - 2208988800).to_s puts ""Local time: 
  
 "" + 
 Time.now.to_s
  
 produces:
  
 Atomic time: Thu Aug 26 22:38:56 CDT 2004 
  
 Local time: 
  
 Thu Aug 26 22:38:59 CDT 2004
  
 Prepared exclusively for Yeganefar",NA
 NKF,"Interface to Network Kanji Filter
  
 The
  NKF
  module is a wrapper around Itaru Ichikawa’s Network Kanji Filter (NKF) 
 library (version 1.7). It provides functions to guess at the encoding of JIS, EUC, and 
 SJIS streams, and to convert from one encoding to another.
  
 • Unlike the interpreter, which uses strings to represent the encodings,
  NKF
  uses 
  
 integer constants.
  
 require 'nkf'
  
 NKF::AUTO
  
 →
  
 0
  
 NKF::JIS
  
 →
  
 1
  
 NKF::EUC
  
 →
  
 2
  
 NKF::SJIS
  
 →
  
 3
  
 • Guess at the encoding of a string. (Thanks to Nobu Nakada for the examples on 
  
 this page.)
  
 require 'nkf'
  
 NKF.guess(""Yukihiro Matsumoto"")
  
 →
  
 0",NA
N,"KF
  
 NKF.guess(""\e$B$^$D$b$H$f$-$R$m\e(B"")
  
 →
  
 1
  
 NKF.guess(""\244\336\244\304\244\342\244\310\244\346\244\255\244\322\244\355"")
  
 →
  
 2
  
 NKF.guess(""\202\334\202\302\202\340\202\306\202\344\202\253\202\320\202\353"")
  
 →
  
 3
  
 • The
  NKF.nfk
  method takes two parameters. The first is a set of options, passed on 
 the the NKF library. The second is the string to translate. The following examples
  
 assume that your console is set up to accomdate Japanese characters. The text at 
 the end of the three
  ruby
  commands is Yukihiro Matsumoto.
  
 $ ruby -e ’p *ARGV’
  
  
 ""\244\336\244\304\244\342\244\310\244\346\244\255\244\322\244\355""
  
 $ ruby -rnkf -e ’p NKF.nkf(*ARGV)’ - -Es
  
  
 ""\202\334\202\302\202\340\202\306\202\344\202\253\202\320\202\353""
  
 $ ruby -rnkf -e ’p NKF.nkf(*ARGV)’ - -Ej 
 ""\e$B$^$D$b$H$f$-
 $R$m\e(B""",NA
 Observable,"The Observer Pattern
  
 The Observer pattern, also known as Publish/Subscribe, provides a simple 
 mechanism for one object (the source) to inform a set of interested third-party objects 
 when its state changes (see
  Design Patterns
  [
 GHJV95
 ]). In the Ruby implementation, 
 the notifying class mixes in the module
  Observable
 , which provides the methods for 
 managing the associated observer objects. The observers must implement the
  update
  
 method to receive notifications.
  
 require 'observer'
  
 class CheckWaterTemperature # Periodically check the water 
  
 include Observable
  
 def run 
  
  
 last_temp = nil 
  
  
 loop do 
  
   
 temp = Temperature.fetch 
  
 # external class...
  
 puts ""Current temperature: #{temp}"" 
  
 if temp != last_temp
  
 changed
  
 # notify observers",NA
O,"bservable
  
    
 notify_observers(Time.now, temp) 
  
    
 last_temp = temp 
  
    
 end 
  
   
 end 
  
 end 
  
 end
  
 class Warner 
  
 def initialize(&limit) 
  
   
 @limit = limit 
  
 end 
  
 def update(time, temp) 
  
 # callback for observer 
  
   
 if @limit.call(temp) 
  
    
 puts ""--- #{time.to_s}: Temperature outside range: #{temp}"" 
  
  
 end 
  
 end 
  
 end
  
 checker = CheckWaterTemperature.new 
  
 checker.add_observer(Warner.new {|t| t < 80}) 
  
 checker.add_observer(Warner.new {|t| t > 120}) 
  
 checker.run
  
 produces:
  
 Current temperature: 83 
  
 Current temperature: 75
  
 --- Thu Aug 26 22:38:59 CDT 2004: Temperature outside range: 75 Current temperature: 
 90 
  
 Current temperature: 134
  
 --- Thu Aug 26 22:38:59 CDT 2004: Temperature outside range: 134 Current temperature: 
 134 
  
 Current temperature: 112 
  
 Current temperature: 79
  
 --- Thu Aug 26 22:38:59 CDT 2004: Temperature outside range: 79
  
 Prepared exclusively for Yeganefar",NA
 open-uri,"Treat FTP and HTTP Resources as Files
  
 The
  open-uri
  library extends
  Kernel
 #
 open
 , allowing it to accept URIs for FTP and 
 HTTP as well as local filenames. Once opened, these resources can be treated as if 
 they were local files, accessed using conventional
  IO
  methods. The URI passed to
  
 open 
 is either a string containing an HTTP or FTP URL, or a URI object (described 
 on page
  731
 ). When opening an HTTP resource, the method automatically handles 
 redi-rection and proxies. When using an FTP resource, the method logs in as an 
 anonymous user.
  
 The
  IO
  object returned by
  open
  in these cases is extended to support methods that 
 return meta-information from the request:
  content_type
 ,
  charset
 ,
  content_encoding
 , 
 last_modified
 ,
  status
 ,
  base_uri
 ,
  meta
 .
  
 See also:
  URI
  (page
  731
 )
  
 require 'open-uri' 
  
 require 'pp'
  
 open('http://localhost/index.html') do |f| 
  
 puts ""URI: #{f.base_uri}"" 
  
 puts ""Content-type: #{f.content_type}, charset: #{f.charset}""
  
 puts ""Encoding: #{f.content_encoding}"" puts ""Last 
 modified: #{f.last_modified}"" puts ""Status: 
 #{f.status.inspect}"" 
  
 pp f.meta 
  
 puts ""----""",NA
O,"pen-uri
  
 3.times {|i| puts ""#{i}: #{f.gets}"" } 
  
 end
  
 produces:
  
 URI: http://localhost/index.html 
  
 Content-type: text/html, charset: iso-8859-1 
  
 Encoding: 
  
 Last modified: Wed Jul 18 23:44:21 UTC 2001 
  
 Status: [""200"", ""OK""] 
  
 {""vary""=>""negotiate,accept-language,accept-charset"", 
  
 ""last-modified""=>""Wed, 18 Jul 2001 23:44:21 GMT"", 
  
 ""content-location""=>""index.html.en"", 
  
 ""date""=>""Fri, 27 Aug 2004 03:38:59 GMT"", 
  
 ""etag""=>""\""6657-5b0-3b561f55;411edab5\"""", 
  
 ""content-type""=>""text/html"", 
  
 ""content-language""=>""en"", 
  
 ""server""=>""Apache/1.3.29 (Darwin)"", 
  
 ""content-length""=>""1456"", 
  
 ""tcn""=>""choice"", 
  
 ""accept-ranges""=>""bytes""}
  
 ----
  
 0: <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" 1: 
  
 ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""> 2: <html 
 xmlns=""http://www.w3.org/1999/xhtml"">
  
 Prepared exclusively for Yeganefar",NA
 Open3,"Run Subprocess and Connect to All Streams
  
 Runs a command in a subprocess. Data written to
  stdin
  can be read by the subprocess, 
 and data written to standard output and standard error in the subprocess will be 
 available on the
  stdout
  and
  stderr
  streams. The subprocess is actually run as a 
 grandchild, and as a result
  Process
 #
 waitall
  cannot be used to wait for its termination 
 (hence the sleep in the following example).
  
 require 'open3'
  
 Open3.popen3('bc') do | stdin, stdout, stderr |
  
 Thread.new { loop { puts ""Err stream: 
  
 #{stderr.gets}"" } } 
 Thread.new { loop { puts ""Output stream: #{stdout.gets}"" } }
  
 stdin.puts ""3 * 4"" 
  
 stdin.puts ""1 / 0"" 
  
 stdin.puts ""2 ^ 5"" 
  
 sleep 0.1 
  
 end
  
 produces:
  
 Output stream: 12
  
 Err stream:
  
 Runtime error (func=(main), adr=3): Divide by zero",NA
O,"pen3
  
 Output stream: 32 
  
 Err stream:
  
  
 Prepared exclusively for Yeganefar",NA
 OpenSSL,"SSL Library
  
  
 Only if:
  OpenSSL
  
 The Ruby
  OpenSSL
  extension wraps the freely available OpenSSL library. It provides
  
 library available
  
 Secure Sockets Layer and Transport Layer Security (SSL and TLS) protocols, allowing
  
 for secure communications over networks. The library provides functions for 
 certificate creation and management, message signing, and encryption/decryption.It 
 also provides wrappers to simplify access to
  https
  servers, along with secure FTP. The 
 interface to the library is large (roughly 330 methods), but the average Ruby user will 
 probably only use a small subset of the library’s capabilities.
  
 See also:
  Net::FTP
  (page
  677
 ),
  Net::HTTP
  (page
  678
 ),
  Socket
  (page
  714
 )
  
 • Access a secure Web site using HTTPS. Note that SSL is used to tunnel to the site, 
  
 but the requested page also requires standard HTTP basic authorization.
  
 require 'net/https'
  
 USER = ""xxx"" 
  
 PW 
  
 = ""yyy""
  
 site = Net::HTTP.new(""www.securestuff.com"", 443) 
  
 site.use_ssl = true
  
 response = site.get2(""/cgi-bin/cokerecipe.cgi"", 
  
 'Authorization' => 'Basic ' + 
 [""#{USER}:#{PW}""].pack('m').strip)
  
 penSSL
  
 • Create a socket that uses SSL. This isn’t a good example of accessing a Web site. 
  
 However, it illustrates how a socket can be encrypted.",NA
O,"require 'socket' 
  
 require 'openssl'
  
 socket = TCPSocket.new(""www.secure-stuff.com"", 443)
  
 ssl_context = OpenSSL::SSL::SSLContext.new()
  
 unless ssl_context.verify_mode 
  
 warn ""warning: peer certificate won't be verified this session."" ssl_context.verify_mode = 
 OpenSSL::SSL::VERIFY_NONE 
  
 end 
  
 sslsocket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context) sslsocket.sync_close = true 
  
 sslsocket.connect
  
 sslsocket.puts(""GET /secret-info.shtml"") 
  
 while line = 
  
 sslsocket.gets 
  
 p line 
  
 end
  
 Prepared exclusively for Yeganefar",NA
 OpenStruct,"Open (dynamic) Structure
  
 An open structure is an object whose attributes are created dynamically when first 
 assigned. In other words, if
  obj
  is an instance of an
  OpenStruct
 , then the statement 
 obj.abc=1
  will create the attribute
  abc
  in
  obj
 , and then assign the value 1 to it.
  
 require 'ostruct'
  
 os = OpenStruct.new( ""f1"" => ""one"", :f2 => ""two"" ) 
  
 os.f3 = ""cat"" 
  
 os.f4 = 99
  
 os.f1
  
 →
  
 ""one""",NA
O,"penStruct
  
 os.f2
  
 →
  
 ""two""
  
 os.f3
  
 →
  
 ""cat""
  
 os.f4
  
 →
  
 99
  
  
 Prepared exclusively for Yeganefar",NA
 OptionParser,"Option Parsing
  
 OptionParser
  is a flexible and extensible way to parse command-line arguments. It has a 
 particularly rich abstraction of the concept of an option.
  
 • An option can have multiple short names (options preceded by a single hyphen) 
 and multiple long names (options preceded by two hyphens). Thus, an option 
 that displays help may be available as
  -h
 ,
  -?
 ,
  --help
 , and
  --about
 . Users may abbre-
 viate long option names to the shortest nonambiguous prefix.
  
 • An option may be specified as having no argument, an optional argument, or a 
 required argument. Arguments can be validated against patterns or lists of valid 
 values.
  
 • Arguments may be returned as objects of any type (not just strings). The argument 
  
 type system is extensible (we add
  Date
  handling in the example).
  
 • Arguments can have one or more lines of descriptive text, used when generating 
  
 usage information.
  
 Options are specified using the
  on
  and
  def
  methods. These methods take a variable 
 number of arguments that cumulatively build a definition of each option. The 
 arguments accepted by these methods are listed in Table
  28.2
  on the following page.
  
 ptionParser
  
 See also:
  GetoptLong
  (page
  663
 )",NA
O,"require 'optparse' 
  
 require 'date'
  
 # Add Dates as a new option type 
  
 OptionParser.accept(Date, /(\d+)-(\d+)-(\d+)/) do |d, mon, day, year| Date.new(year.to_i, mon.to_i, 
 day.to_i) 
  
 end
  
 opts = OptionParser.new 
  
 opts.on(""-x"") 
  
 {|val| puts ""-x seen"" } opts.on(""-s"", ""-
 -size VAL"", Integer) {|val| puts ""-s #{val}"" }
  
 opts.on(""-a"", ""--at DATE"",
  
 Date)
  
 {|val| puts ""-a #{val}"" }
  
 my_argv = [ ""--size"", ""1234"", ""-x"", ""-a"", ""12-25-2003"", ""fred"", ""wilma"" ]
  
 rest = opts.parse(*my_argv) 
  
 puts ""Remainder = #{rest.join(', ')}"" 
  
 puts opts.to_s
  
 produces:
  
 -s 1234
  
 -x seen
  
 -a 2003-12-25 
  
 Remainder = fred, wilma 
  
 Usage: myprog [options]
  
  
 -x
  
  
 -s, --size VAL
  
  
 -a, --at DATE
  
 Prepared exclusively for Yeganefar",NA
O,"ptionParser
  
 Any argument must match the given pattern.
  
 array 
  
  
 Argument must be one of the values from
  array
 .
  
 proc or method 
  
 Argument type conversion is performed by the given proc or method (rather than 
 using the block associated with the
  on
  or
  def
  method call).
  
 ClassName 
  
 Argument must match that defined for ClassName, which may be predefined or 
 added using
  OptionParser.accept
 . Built-in argument classes are 
  
 Object
 :
  Any string. No conversion. This is the default.
  
 String
 :
  Any nonempty string. No conversion.
  
 Integer
 :
  Ruby/C-like integer with optional sign (
 0ddd
  is octal,
  0bddd
  binary,
  0xddd
  hex-
  
 adecimal). Converts to
  Integer
 .
  
 Float
 :
  Float number format. Converts to Float.
  
 Numeric
 :
  Generic numeric format. Converts to
  Integer
  for integers,
  Float
  for floats. 
 Array
 :
  Argument must be of list of strings separated by a comma.
  
 OptionParser::DecimalInteger
 :
  Decimal integer. Converted to Integer.
  
 OptionParser::OctalInteger
 :
  Ruby/C-like octal/hexadecimal/binary integer. 
 OptionParser::DecimalNumeric
 :
  Decimal integer/float number. Integers converted to 
  
 Integer
 , 
 floats to
  Float
 .
  
 TrueClass, FalseClass
 :
  Boolean switch.
  
 Prepared exclusively for Yeganefar",NA
 ParseDate,"Parse a Date String
  
 The
  ParseDate
  module defines a single method,
  ParseDate.parsedate
 , which con-verts a 
 date and/or time string into an array of
  Fixnum
  values representing the date and/or 
 time’s constituents (year, month, day, hour, minute, second, time zone, and 
 weekday).
  nil
  is returned for fields that cannot be parsed from the string. If the result 
 contains a year that is less than 100 and the
  guess
  parameter is true,
  parsedate
  will 
 return a year value equal to
  year
  plus 2000 if
  year
  is less than 69, and will return
  year 
 plus 1900 otherwise.
  
 See also:
  Date
  (page
  644
 )
  
 ParseDate::parsedate(string, guess)
  
 string
  
 guess
  
 yy
  
 mm
  
 dd
  
 hh
  
 min
  
 sec
  
 zone wd
   
 1999-09-05 23:55:21+0900
  
 F
  
 1999
  
 9
  
 5
  
 23
  
 55
  
 21
  
 +0900 –
  
 arseDate
  
 1983-12-25
  
 F
  
 1983
  
 12
  
 25
  
 –
  
 –
  
 –
  
 –
  
 –
  
 1965-11-10 T13:45
  
 F
  
 1965
  
 11
  
 10
  
 13
  
 45
  
 –
  
 –
  
 –
  
 10/9/75 1:30pm
  
 F
  
 75
  
 10
  
 9
  
 13
  
 30
  
 –
  
 –
  
 –
  
 10/9/75 1:30pm
  
 T
  
 1975
  
 10
  
 9
  
 13
  
 30
  
 –
  
 –
  
 –
  
 Wed Feb 2 17:15:49 CST 2000
  
 F
  
 2000
  
 2
  
 2
  
 17
  
 15
  
 49
  
 CST
  
 3
  
 Tue, 02-Mar-99 11:20:32 GMT
  
 F
  
 99
  
 3
  
 2
  
 11
  
 20
  
 32
  
 GMT
  
 2
  
 Tue, 02-Mar-99 11:20:32 GMT
  
 T
  
 1999
  
 3
  
 2
  
 11
  
 20
  
 32
  
 GMT
  
 2
  
 12-January-1990, 04:00 WET
  
 F
  
 1990
  
 1
  
 12
  
 4
  
 0
  
 –
  
 WET
  
 –
  
 4/3/99
  
 F
  
 99
  
 4
  
 3
  
 –
  
 –
  
 –
  
 –
  
 –
  
 4/3/99
  
 T
  
 1999
  
 4
  
 3
  
 –
  
 –
  
 –
  
 –
  
 –",NA
P,"10th February, 1976
  
 F
  
 1976
  
 2
  
 10
  
 –
  
 –
  
 –
  
 –
  
 –
  
 March 1st, 84
  
 T
  
 1984
  
 3
  
 1
  
 –
  
 –
  
 –
  
 –
  
 –
  
 Friday
  
 F
  
 –
  
 –
  
 –
  
 –
  
 –
  
 –
  
 –
  
 5",NA
 Pathname,"Representation of File Paths
  
 A
  Pathname
  represents the absolute or relative name of a file. It has two distinct uses. 
 First, it allows manipulation of the parts of a file path (extracting components, 
 building new paths, and so on). Second (and somewhat confusingly), it acts as a 
 façade for some methods in classes
  Dir
 ,
  File
 , and module
  FileTest
 , forwarding on calls 
 for the file named by the
  Pathname
  object.
  
 See also:
  File
  (page
  444
 )
  
 • Path name manipulation:
  
 require 'pathname'
  
 p1 = Pathname.new(""/usr/bin"")
  
 →
  
 #<Pathname:/usr/bin>
  
 athname
  
 p2 = Pathname.new(""ruby"")
  
 →
  
 #<Pathname:ruby>
  
 p3 = p1 + p2
  
 →
  
 #<Pathname:/usr/bin/ruby>
  
 p4 = p2 + p1
  
 →
  
 #<Pathname:/usr/bin>
  
 p3.parent
  
 →
  
 #<Pathname:/usr/bin>
  
 p3.parent.parent
  
 →
  
 #<Pathname:/usr>
  
 p1.absolute?
  
 →
  
 true
  
 p2.absolute?
  
 →
  
 false
  
 p3.split
  
 →
  
 [#<Pathname:/usr/bin>,
  
 #<Pathname:ruby>]
  
 p5 = Pathname.new(""testdir"")
  
 →
  
 #<Pathname:testdir>
  
 p5.realpath
  
 →
  
 #<Pathname:/Users/dave/Work/rubybook/testdir>",NA
P,"p5.children
  
 →
  
 [#<Pathname:testdir/config.h>,
  
 #<Pathname:testdir/main.rb>]
  
 • Pathname as proxy for file and directory status requests.
  
 require 'pathname'
  
 p1 = Pathname.new(""/usr/bin/ruby"")
  
 p1.file?
  
 →
  
 true
  
 p1.directory?
  
 false
  
 →
  
 p1.executable?
  
 →
  
 true
  
 p1.size
  
 1913444
  
 →
  
 p2 = Pathname.new(""testfile"")
  
 →
  
 #<Pathname:testfile>
  
 p2.read
  
 →
  
 ""This is line one\nThis is
  
 line two\nThis is line 
  
 three\nAnd so on...\n""
  
 p2.readlines
  
 →
  
 [""This is line one\n"", ""This
  
 is line two\n"", ""This is line 
  
 three\n"", ""And so on...\n""]
  
 Prepared exclusively for Yeganefar",NA
 PP,"Pretty-print Objects
  
 PP
  uses the
  PrettyPrint
  library to format the results of inspecting Ruby objects. As well 
 as the methods in the class, it defines a global function,
  pp
 , which works like the 
 existing
  p
  method but which formats its output.
  
 PP
  has a default layout for all Ruby objects. However, you can override the way it 
 handles a class by defining the method
  pretty_print
 , which takes a
  PP
  object as a 
 parameter. It should use that
  PP
  object’s methods
  text
 ,
  breakable
 ,
  nest
 ,
  group
 , and 
 pp
  to 
 format its output (see
  PrettyPrint
  for details).
  
 See also:
  PrettyPrint
  (page
  695
 ),
  YAML
  (page
  737
 )
  
 • Compare “p” and “pp.”
  
 require 'pp'
  
 Customer = Struct.new(:name, :sex, :dob, :country)
  
 cust = Customer.new(""Walter Wall"", ""Male"", ""12/25/1960"", ""Niue"")
  
 puts ""Regular print"" 
  
 p cust
  
 puts ""\nPretty print"" 
  
 pp cust
  
 produces:
  
 Regular print
  
 #<struct Customer name=""Walter Wall"", sex=""Male"", dob=""12/25/1960"",
  
 P
  
 country=""Niue"">",NA
P,"Pretty print 
  
 #<struct Customer 
  
 name=""Walter Wall"", 
  
 sex=""Male"", 
  
 dob=""12/25/1960"", 
  
 country=""Niue"">
  
 • You can tell
  PP
  not to display an object if it has already displayed it.
  
 require 'pp'
  
 a = ""string"" 
  
 b = [ a ] 
  
 c = [ b, b ] 
  
 PP.sharing_detection = false 
  
 pp c
  
 PP.sharing_detection = true 
  
 pp c
  
 produces:
  
 [[""string""], [""string""]] 
  
 [[""string""], [...]]
  
 Prepared exclusively for Yeganefar",NA
 PrettyPrint,"General Pretty Printer
  
 PrettyPrint
  implements a pretty printer for structured text. It handles details of wrap-
 ping, grouping, and indentation. The
  PP
  library uses
  PrettyPrint
  to generate more 
 legible dumps of Ruby objects.
  
 See also:
  PP
  (page
  694
 )
  
 • The following program prints a chart of Ruby’s classes, showing subclasses as a 
 bracketed list following the parent. To save some space, we show just the classes 
 in the
  Numeric
  branch of the tree.
  
 require 'prettyprint' 
  
 require 'complex' 
  
 require 'rational' 
  
 @children = Hash.new { |h,k| h[k] = Array.new } 
  
 ObjectSpace.each_object(Class) do |cls| 
  
 @children[cls.superclass] << cls if cls <= Numeric 
  
 end 
  
 def print_children_of(printer, cls) 
  
 printer.text(cls.name) 
  
 kids = @children[cls].sort_by {|k| k.name} 
  
 unless kids.empty?
  
 printer.group(0, "" ["", ""]"") do 
  
  
 printer.nest(3) do 
  
   
 printer.breakable 
  
   
 kids.each_with_index do |k, i| 
  
    
 printer.breakable unless i.zero?",NA
P,"rettyPrint
  
     
 print_children_of(printer, k) 
  
    
 end 
  
    
 end 
  
    
 printer.breakable 
  
  
 end 
  
 end 
  
 end 
  
 printer = PrettyPrint.new($stdout, 30) 
  
 print_children_of(printer, Object) 
  
 printer.flush
  
 produces:
  
 Object [ 
  
 Numeric [ 
  
  
  
 Complex 
  
  
  
 Float 
  
  
  
 Integer [ 
  
  
  
 Bignum 
  
  
  
 Fixnum 
  
  
  
 ] 
  
  
  
 Rational 
  
 ] 
  
 ]
  
 Prepared exclusively for Yeganefar",NA
 Profile,"Profile Execution of a Ruby Program
  
 The
  profile
  library is a trivial wrapper around the
  Profiler
  module, making it easy to 
 profile the execution of an entire program. Profiling can be enabled from the com-
 mand line using the
  -rprofile
  option or from within a source program by requiring the
  
 profile
  module.
  
 See also:
  Benchmark
  (page
  636
 ),
  Profiler_ _
  (page
  697
 )
  
 require 'profile' 
  
 def ackerman(m, n) 
  
 if m == 0 then 
  
 n+1 
  
 elsif n == 0 and m > 0 then ackerman(m-1, 1) 
  
 else ackerman(m-1, ackerman(m, n-1)) 
  
 end 
  
 end 
  
 ackerman(3, 3)
  
 produces:
  
 %
  
 cumulative
  
 self
  
 calls
  
 self
  
 total
  
 name",NA
P,"rofile
  
 time
  
 seconds
  
 seconds
  
 ms/call
  
 ms/call
  
 75.14
  
 2.75
  
 2.75
  
 2432
  
 1.13
  
 46.92
  
 Object#ackerman
  
 13.39
  
 3.24
  
 0.49
  
 3676
  
 0.13
  
 0.13
  
 Fixnum#==
  
 7.65
  
 3.52
  
 0.28
  
 2431
  
 0.12
  
 0.12
  
 Fixnum#-
  
 3.83
  
 3.66
  
 0.14
  
 1188
  
 0.12
  
 0.12
  
 Fixnum#+
  
 0.55
  
 3.68
  
 0.02
  
 1
  
 20.00
  
 20.00
  
 Profiler__.start_profile
  
 0.00
  
 3.68
  
 0.00
  
 1
  
 0.00
  
 0.00
  
 Kernel.puts
  
 0.00
  
 3.68
  
 0.00
  
 1
  
 0.00
  
 0.00
  
 Module#method_added
  
  
 0.00
  
 3.68
  
 0.00
  
 2
  
 0.00
  
 0.00
  
 IO#write
  
 0.00
  
 3.68
  
 0.00
  
 57
  
 0.00
  
 0.00
  
 Fixnum#>
  
 0.00
  
 3.68
  
 0.00
  
 1
  
 0.00
  
 3660.00
  
 #toplevel
  
  
 Prepared exclusively for Yeganefar",NA
 Profiler_ _,"Control Execution Profiling
  
 The
  Profiler_ _
  module can be used to collect a summary of the number of calls to, and 
 the time spent in, methods in a Ruby program. The output is sorted by the total time 
 spent in each method. The
  profile
  library is a convenience wrapper than profiles an 
 entire program.
  
 See also:
  Benchmark
  (page
  636
 ),
  profile
  (page
  696
 )
  
 require 'profiler' 
  
 # Omit definition of connection and fetching methods
  
 def calc_discount(qty, price) 
  
 case qty 
  
 when 0..10 then 0.0 
  
 when 11..99 then price * 0.05 
  
 else price * 0.1 
  
 end 
  
 end
  
 def calc_sales_totals(rows) 
  
  
 total_qty = total_price = total_disc = 0 
  
  
 rows.each do |row|
  
 total_qty
  
 += row.qty
  
 rofiler_ _
  
 total_price += row.price
  
 total_disc
  
 += calc_discount(row.qty, row.price)
  
  
 end 
  
 end
  
 connect_to_database",NA
P,"rows = read_sales_data
  
 Profiler__::start_profile 
  
 calc_sales_totals(rows) 
  
 Profiler__::stop_profile 
  
 Profiler__::print_profile($stdout)
  
 produces:
  
 %
  
 cumulative
  
 self
  
 calls
  
 self
  
 total
  
 name
  
 time
  
 seconds
  
 seconds
  
 ms/call
  
 ms/call
  
 31.19
  
 0.34
  
 0.34
  
 1
  
 340.00
  
 1090.00
  
 Array#each
  
 20.18
  
 0.56
  
 0.22
  
 648
  
 0.34
  
 0.80
  
 Range#===
  
 15.60
  
 0.73
  
 0.17
  
 648
  
 0.26
  
 0.39
  
 Fixnum#<=>
  
 10.09
  
 0.84
  
 0.11
  
 324
  
 0.34
  
 2.01
  
 Object#calc_discount
  
 6.42
  
 0.91
  
 0.07
  
 648
  
 0.11
  
 0.11
  
 Float#coerce
  
 5.50
  
 0.97
  
 0.06
  
 1296
  
 0.05
  
 0.05
  
 Float#<=>
  
 3.67
  
 1.01
  
 0.04
  
 969
  
 0.04
  
 0.04
  
 Float#+
  
 2.75
  
 1.04
  
 0.03
  
 648
  
 0.05
  
 0.05
  
 S#price
  
 2.75
  
 1.07
  
 0.03
  
 648
  
 0.05
  
 0.05
  
 S#qty
  
 1.83
  
 1.09
  
 0.02
  
 324
  
 0.06
  
 0.06
  
 Float#*
  
 0.92
  
 1.10
  
 0.01
  
 1
  
 10.00
  
 10.00
  
 Profiler__.start_profile
  
 0.00
  
 1.10
  
 0.00
  
 1
  
 0.00
  
 1090.00
  
 #toplevel
  
 0.00
  
 1.10
  
 0.00
  
 1
  
 0.00
  
 1090.00
  
 Object#calc_sales_totals
  
 0.00
  
 1.10
  
 0.00
  
 3
  
 0.00
  
 0.00
  
 Fixnum#+
  
  
 Prepared exclusively for Yeganefar",NA
 PStore,"Persistent Object Storage
  
 The
  PStore
  class provides transactional, file-based, persistent storage of Ruby objects. 
 Each
  PStore
  can store several object hierarchies. Each hierarchy has a root, identified 
 by a key (often a string). At the start of a
  PStore
  transaction, these hierarchies are read 
 from a disk file and made available to the Ruby program. At the end of the 
 transaction, the hierarchies are written back to the file. Any changes made to objects 
 in these hier-archies are therefore saved on disk, to be read at the start of the next 
 transaction that uses that file.
  
 In normal use, a
  PStore
  object is created and then is used one or more times to control 
 a transaction. Within the body of the transaction, any object hierarchies that had pre-
 viously been saved are made available, and any changes to object hierarchies, and 
 any new hierarchies, are written back to the file at the end.
  
 • The following example stores two hierarchies in a PStore. The first, identified by 
 the key
  ""names""
 , is an array of strings. The second, identified by
  ""tree""
 , is a 
 simple binary tree.
  
 require 'pstore' 
  
 require 'pp' 
  
 class T 
  
 def initialize(val, left=nil, right=nil)
  
 @val, @left, @right = val, left, right 
  
 end
  
 Store
  
 def to_a 
  
 [ @val, @left.to_a, @right.to_a ]",NA
P,"end 
  
 end
  
 store = PStore.new(""/tmp/store"") 
  
 store.transaction do 
  
 store['names'] = [ 'Douglas', 'Barenberg', 'Meyer' ] 
  
 store['tree'] = T.new('top', 
  
  
  
  
 T.new('A', T.new('B')), 
  
  
  
  
 T.new('C', T.new('D', nil, T.new('E')))) end
  
 # now read it back in
  
 store.transaction do 
  
 puts ""Roots: #{store.roots.join(', ')}"" 
  
 puts store['names'].join(', ') 
  
 pp store['tree'].to_a 
  
 end
  
 produces:
  
 Roots: names, tree 
  
 Douglas, Barenberg, Meyer 
  
 [""top"", 
  
 [""A"", [""B"", [], []], []], 
  
 [""C"", [""D"", [], [""E"", [], []]], []]]
  
 Prepared exclusively for Yeganefar",NA
 PTY,"Pseudo-Terminal Interface: Interact with External Processes
  
  
 Only if:
  Unix with
  
 Many Unix platforms support a
  pseudo-terminal
 —a device pair where one end emu-
  
 pty support
  
 lates a process running on a conventional terminal, and the other end can read and write
  
 that terminal as if it were a user looking at a screen and typing on a keyboard.
  
 The
  PTY
  library provides the method
  spawn
 , which starts the given command (by
  
 default a shell), connecting it to one end of a pseudo-terminal. It then returns the reader
  
 and writer streams connected to that terminal, allowing your process to interact with
  
 the running process.
  
 Working with pseudo-terminals can be tricky. See
  IO
 #
 expect
  on page
  655
  for a con-
  
 venience method that makes life easier. You might also want to track down Ara T. 
 Howard’s
  Session
  module for an even simpler approach to driving subprocesses.
 4
  
 See also:
  expect
  (page
  655
 )
  
 • Run irb in a subshell and ask it to convert the string “cat” to uppercase.
  
 require 'pty'
  
 require 'expect'
  
 $expect_verbose = true
  
 PTY.spawn(""ruby /usr/local/bin/irb"") do |reader, writer, pid|
  
 reader.expect(/irb.*:0> /)
  
 writer.puts ""'cat'.upcase"" 
  
 reader.expect(""=> "")
  
 TY
  
 answer = reader.gets 
  
 puts ""Answer = #{answer}""",NA
P,"end
  
 produces:
  
 irb(main):001:0> 'cat'.upcase
  
 => Answer = ""CAT""
  
 4.
  
 Currently found at
  http://www.codeforpeople.com/lib/ruby/session/
 .
  
  
 Prepared exclusively for Yeganefar",NA
 Rational,"Rational Numbers
  
 Rational numbers are expressed as the ratio of two integers. When the denomina-tor 
 exactly divides the numerator, a rational number is effectively an integer. Ratio-nals 
 allow exact representation of fractional numbers, but some real values cannot be 
 expressed exactly and so cannot be represented as rationals.
  
 Class
  Rational
  is normally relatively independent of the other numeric classes, in that 
 the result of dividing two integers will normally be a (truncated) integer. However, if 
 the
  mathn
  library is loaded into a program, integer division may generate a
  Rational 
 result.
  
 See also:
  mathn
  (page
  671
 ),
  Matrix
  (page
  673
 ),
  Complex
  (page
  641
 )
  
 • Rational as a free-standing class.
  
 require 'rational'
  
 r1 = Rational(3, 4)
  
 →
  
 Rational(3, 4)
  
 r2 = Rational(2, 3)
  
 →
  
 Rational(2, 3)
  
 r1 * 2
  
 Rational(3, 2)
  
 →
  
 r1 * 8
  
 →
  
 Rational(6, 1)
  
 Rational(1, 8)
  
 r1 / 6
  
 →
  
 r1 * r2
  
 →
  
 Rational(1, 2)
  
 Rational(17, 12)
  
 r1 + r2
  
 →
  
 r1 ** r2
  
 →
  
 0.825481812223657
  
 • Rational integrated with integers using
  mathn
 . Notice how
  mathn
  also changes the
  
 string representation of numbers. 
  
 require 'rational' 
  
 require 'mathn'",NA
R,"ational
  
 r1 = Rational(3, 4)
  
 →
  
 3/4
  
 r2 = Rational(2, 3)
  
 →
  
 2/3
  
  
 r1 * 2
  
 →
  
 3/2
  
 r1 * 8
  
 →
  
 6
  
 5/3
  
 →
  
 5/3
  
 5/3 * 6
  
 →
  
 10
  
 5/3 * 6/15
  
 →
  
 2/3
  
 Math::sin(r1)
  
 →
  
 0.681638760023334
  
  
 Prepared exclusively for Yeganefar",NA
 readbytes,"Fixed-Size Read
  
 Adds the method
  readbytes
  to class
  IO
 . This method will guarantee to read exactly the 
 requested number of bytes from a stream, throwing either an
  EOFError
  at end of file or 
 a
  TruncatedDataError
  if fewer than the requested number of bytes remain in the stream.
  
 • Normally,
  readbytes
  would be used with a network connection. Here we illus-
  
 trate its use with a regular file.
  
 require 'readbytes'
  
 File.open(""testfile"") do |f| 
  
 begin 
  
  
 loop do 
  
    
 data = f.readbytes(10) 
  
    
 p data 
  
  
 end 
  
 rescue EOFError 
  
  
 puts ""End of File"" 
  
 rescue TruncatedDataError => td 
  
  
 puts ""Truncated data: read '#{td.data.inspect}'"" 
  
 end 
  
 end
  
 produces:
  
 ""This is li""
  
 ""ne one\nThi"" 
  
 ""s is line "" 
  
 ""two\nThis i"" 
  
 ""s line thr"" 
  
 ""ee\nAnd so """,NA
R,"eadbytes
  
 Truncated data: read '""on...\n""'
  
 Prepared exclusively for Yeganefar",NA
 Readline,"Interface to GNU Readline Library
  
  
 Only if:
  GNU
  
 The
  Readline
  module allows programs to prompt for and receive lines of user input.
  
 readline present
  
 The module allows lines to be edited during entry, and command history allows pre-
  
 vious commands to be recalled and edited. The history can be searched, allowing the 
 user to (for example) recall a previous command containing the text
  ruby
 . Command 
 completion allows context-sensitive shortcuts: tokens can be expanded in the 
 command line under control of the invoking application. In typical GNU fashion, the 
 underlying readline library supports more options than any user could need and 
 emulates both vi and emacs key bindings.
  
 • This meaningless program implements a trivial interpreter that can increment and 
 decrement a value. It uses the
  Abbrev
  module (described on page
  634
 ) to expand 
 abbreviated commands when the tab key is pressed.
  
 require 'readline' 
  
 include Readline
  
 require 'abbrev'
  
 COMMANDS = %w{ exit inc dec }
  
 ABBREV = COMMANDS.abbrev
  
 Readline.completion_proc = proc do |string| 
  
 ABBREV[string] 
  
 end
  
 value = 0
  
 loop do 
  
 cmd = readline(""wibble [#{value}]: "", true) 
  
 break if cmd.nil?
  
 eadline
  
 case cmd.strip",NA
R,"when ""exit"" 
  
 break 
  
 when ""inc"" 
  
 value += 1 
  
 when ""dec"" 
  
 value -= 1 
  
 else 
  
 puts ""Invalid command #{cmd}"" 
  
 end
  
 end
  
 % ruby code/readline.rb 
  
 wibble [0]: inc 
  
 wibble [1]: <up-arrow> 
  
 => inc 
  
 wibble [2]: d<tab> 
  
 => dec 
  
 wibble [1]: ^r i 
  
 => inc 
  
 wibble [2]: exit 
  
 %
  
 Prepared exclusively for Yeganefar",NA
 Resolv,"DNS Client Library
  
 The
  resolv
  library is a pure-Ruby implementation of a DNS client—it can be used to 
 convert domain names into corresponding IP addresses. It also supports reverse 
 lookups and the resolution of names in the local hosts file.
  
 The
  resolv
  library exists to overcome a problem with the interaction of the standard 
 operating system DNS lookup and the Ruby threading mechanism. On most operating 
 system, name resolution is synchronous: you issue the call to look up a name, and the 
 call returns when an address has been fetched. Because this lookup often involves 
 network traffic, and because DNS servers can be slow, this call may take a 
 (relatively) long time. During this time, the thread that issued the call is effectively 
 suspended. Because Ruby does not use operating system threads, this means that the 
 interpreter is effectively suspended while a DNS request is being executed from any 
 running Ruby thread. This is sometimes unacceptable. Enter the
  resolv
  library. 
 Because it is written in Ruby, it automatically participates in Ruby threading, and 
 hence other Ruby threads can run while a DNS lookup is in progress in one thread.
  
 Loading the additional library
  resolv-replace
  insinuates the
  resolv
  library into Ruby’s
  
 socket
  library (see page
  714
 ).
  
 • Use the standard socket library to look up a name. A counter running in a separate 
  
 thread is suspended while this takes place.
  
 require 'socket'
  
 count = 0
  
 count += 1;
  
  
 esolv
  
 Thread.critical = true
  
 thread = Thread.new { Thread.pass; loop {
  
 } }",NA
R,"IPSocket.getaddress(""www.ruby-lang.org"")
  
 →
  
 ""210.251.121.210""
  
 count
  
  
 →
  
 0
  
 • Repeat the experiment, but use the
  resolv
  library to allow Ruby’s threading to 
  
 work in parallel.
  
 require 'socket' 
  
 require 'resolv-replace'
  
 count = 0 
  
 Thread.critical = true 
  
 thread = Thread.new { Thread.pass; loop { 
  
  
 count += 1; 
  
 } } 
 IPSocket.getaddress(""www.ruby-lang.org"")
  
 →
 ""210.251.121.210"" count
  
 →
 39211
  
 Prepared exclusively for Yeganefar",NA
 REXML,"XML Processing Library
  
 REXML is a pure-Ruby XML processing library, including DTD-compliant 
 document parsing, XPath querying, and document generation. It supports both tree-
 based and stream-based document processing. As it is written in Ruby, it is available 
 on all plat-forms supporting Ruby. REXML has a full and complex interface—this 
 section con-tains a few small examples.
  
 • Assume the file
  demo.xml
  contains
  
 <classes language=""ruby""> 
  
 <class name=""Numeric""> 
  
  
 Numeric represents all numbers.
  
 <class name=""Float""> 
  
  
 Floating point numbers have a fraction and a mantissa.
  
 </class> 
  
 <class name=""Integer""> 
  
  
 Integers contain exact integral values.
  
 <class name=""Fixnum""> 
  
 Fixnums are stored as machine ints.
  
 </class> 
  
 <class name=""Bignum""> 
  
 Bignums store arbitraty-sized integers.
  
    
 </class> 
  
  
 </class> 
  
 </class> 
  
 </classes>
  
 • Read and process the XML. 
  
  
 require 'rexml/document'
  
 EXML
  
 xml = REXML::Document.new(File.open(""demo.xml"")) 
  
 puts ""Root element: #{xml.root.name}""",NA
R,"puts ""\nThe names of all classes"" 
  
 xml.elements.each(""//class"") {|c| puts c.attributes[""name""] } puts ""\nThe description 
 of Fixnum"" 
  
 p xml.elements[""//class[@name='Fixnum']""].text
  
 produces:
  
 Root element: classes
  
 The names of all classes 
  
 Numeric 
  
 Float 
  
 Integer 
  
 Fixnum 
  
 Bignum
  
 The description of Fixnum
  
 ""\n
  
 Fixnums are stored as machine ints.\n
  
 ""
  
  
 Prepared exclusively for Yeganefar",NA
R,"</class> 
  
 <class class_name='Integer'> 
  
  
 Integers contain exact integral values.
  
  
 </class> 
  
  
 <class class_name='Rational'>Represents complex numbers</class> </class> 
  
 </classes>
  
 Prepared exclusively for Yeganefar",NA
 Rinda,"Tuplespace Implementation
  
 Tuplespaces are a distributed blackboard system. Processes may add tuples to the 
 black-board, and other processes may remove tuples from the blackboard that match 
 a cer-tain pattern. Originally presented by David Gelernter, tuplespaces offer an 
 interesting scheme for distributed cooperation among heterogeneous processes.
  
 Rinda
 , the Ruby implementation of tuplespaces, offers some interesting additions to 
 the concept. In particular, the
  Rinda
  implementation uses the
  ===
  operator to match 
 tuples. This means that tuples may be matched using regular expressions, the classes 
 of their elements, as well as the element values.
  
 See also:
  DRb
  (page
  649
 )
  
 • The blackboard is a DRb server that offers a shared tuplespace.
  
 require 'drb/drb' 
  
 require 'rinda/tuplespace'
  
 require 'my_uri' 
  
 # Defines the constant MY_URI
  
 DRb.start_service(MY_URI, Rinda::TupleSpace.new) 
  
 DRb.thread.join
  
 • The arithmetic agent accepts messages containing an arithmetic operator and two 
  
 numbers. It stores the result back on the blackboard.
  
 require 'drb/drb' 
  
 require 'rinda/rinda' 
  
 require 'my_uri'
  
 DRb.start_service 
  
 ts = Rinda::TupleSpaceProxy.new(DRbObject.new(nil, MY_URI)) loop do",NA
R,"inda
  
 op, v1, v2 = ts.take([ %r{^[-+/*]$}, Numeric, Numeric]) 
  
 ts.write([""result"", v1.send(op, v2)]) 
  
 end
  
 • The client places a sequence of tuples on the blackboard and reads back the result 
  
 of each.
  
 require 'drb/drb' 
  
 require 'rinda/rinda' 
  
 require 'my_uri'
  
 DRb.start_service 
  
 ts = Rinda::TupleSpaceProxy.new(DRbObject.new(nil, MY_URI))
  
 queries = [[ ""+"", 1, 2 ],
  
 [ ""*"", 3, 4 ],
  
 [ ""/"", 8, 2 ]]
  
 queries.each do |q| 
  
 ts.write(q) 
  
 ans = ts.take([""result"", nil]) 
  
 puts ""#{q[1]} #{q[0]} #{q[2]} = #{ans[1]}"" 
  
 end
  
 Prepared exclusively for Yeganefar",NA
 RSS,"RSS Feed Generation and Parsing
  
 Rich (or RDF) Site Summary, Really Simple Syndication, take your pick. RSS is the 
 protocol of choice for disseminating news on the Internet. The Ruby RSS library sup-
 ports creating and parsing streams compliant with the RSS 0.9, RSS 1.0, and RSS 2.0 
 specifications.
  
 • Read and summarize the latest stories from
  http://ruby-lang.org
 .
  
 require 'rss/1.0' 
  
 require 'open-uri'
  
 open('http://ruby-lang.org/en/index.rdf') do |http| 
  
 response = http.read
  
 result = RSS::Parser.parse(response, false)
  
 puts ""Channel: "" + result.channel.title 
  
 result.items.each_with_index do |item, i| 
  
  
 puts ""#{i+1}. #{item.title}"" if i < 4 
  
 end 
  
 end
  
 produces:
  
 Channel: Ruby Home Page 
  
 1. Brad Cox to keynote RubyConf 2004 
  
 2. Download Ruby 
  
 3. RubyConf 2004 registration now open 
  
 4. ruby 1.8.2 preview1 released
  
 • Generate some RSS information.
  
 require 'rss/0.9'
  
 SS
  
 rss = RSS::Rss.new(""0.9"") 
  
 chan = RSS::Rss::Channel.new",NA
R,"chan.description = ""Dave's Feed"" 
  
 chan.link = ""http://pragprog.com/pragdave"" 
  
 rss.channel = chan
  
 image = RSS::Rss::Channel::Image.new 
  
 image.url = ""http://pragprog.com/pragdave.gif"" 
  
 image.title = ""PragDave"" 
  
 image.link = chan.link 
  
 chan.image = image
  
 3.times do |i| 
  
 item = RSS::Rss::Channel::Item.new 
  
 item.title = ""My News Number #{i}"" 
  
 item.link = ""http://pragprog.com/pragdave/story_#{i}"" 
  
 item.description = ""This is a story about number #{i}"" 
  
 chan.items << item 
  
 end
  
 puts rss.to_s
  
 Prepared exclusively for Yeganefar",NA
 Scanf,"Input Format Conversion
  
 Implements a version of the C library
  scanf
  function, which extracts values from a 
 string under the control of a format specifier.
  
 The Ruby version of the library adds a
  scanf
  method to both class
  IO
  and class
  String
 . 
 The version in
  IO
  applies the format string to the next line read from the receiver. The 
 version in
  String
  applies the format string to the receiver. The library also adds the 
 global method
  Kernel.scanf
 , which uses as its source the next line of standard input.
  
 Scanf has one main advantage over using regular expressions to break apart a string: 
 a regular expression extracts strings whereas
  scanf
  will return objects converted to the 
 correct type.
  
 • Split a date string into its constituents.
  
 require 'scanf'
  
 date = ""2004-12-15"" 
  
 year, month, day = date.scanf(""%4d-%2d-%2d"")
  
 year
  
 →
  
 2004
  
 month
  
 12
  
 →
  
 day
  
 →
  
 15
  
 year.class
  
 Fixnum
  
 →
  
 • The block form of
  scanf
  applies the format multiple times to the input string, 
  
 returning each set of results to the block.
  
 require 'scanf'
  
 data = ""cat:7 dog:9 cow:17 walrus:31""
  
 data.scanf(""%[^:]:%d "") do |animal, value| 
  
 puts ""A #{animal.strip} has #{value*1.4}"" 
  
 end",NA
S,"canf
  
 produces:
  
 A cat has 9.8 
  
 A dog has 12.6 
  
 A cow has 23.8 
  
 A walrus has 43.4
  
 • Extract hex numbers.
  
 require 'scanf'
  
 data = ""decaf bad""
  
 data.scanf(""%3x%2x%x"")
  
 →
  
 [3564, 175, 2989]
  
  
 Prepared exclusively for Yeganefar",NA
 SDBM,"Interface to SDBM Database
  
 The SDBM database implements a simple key/value persistence mechanism. Because 
 the underlying SDBM library itself is provided with Ruby, there are no external 
 depen-dencies, and SDBM should be available on all platforms supported by Ruby. 
 SDBM database keys and values must be strings. SDBM databases are effectively 
 hashlike.
  
 See also:
  DBM
  (page
  645
 ),
  GDBM
  (page
  661
 )
  
 • Store a record in a new database, and then fetch it back. Unlike the DBM library, 
  
 all values to SDBM must be strings (or implement
  to_str
 ).
  
 require 'sdbm' 
  
 require 'date'
  
 SDBM.open(""data.dbm"") do |dbm| 
  
 dbm['name'] = ""Walter Wombat"" 
  
 dbm['dob'] 
  
 = Date.new(1997, 12,25).to_s 
  
 dbm['uses'] = ""Ruby"" 
  
 end
  
 SDBM.open(""data.dbm"", nil) do |dbm| 
  
 p dbm.keys 
  
 p dbm['dob'] 
  
 p dbm['dob'].class 
  
 end
  
 produces:
  
 [""name"", ""dob"", ""uses""] 
  
 ""1997-12-25"" 
  
 String",NA
S,DBM,NA
 Set,"Implement Various Forms of Set
  
 A
  Set
  is a collection of unique values (where uniqueness is determined using
  eql?
  and 
 hash
 ). Convenience methods let you build sets from enumerable objects.
  
 • Basic set operations.
  
 require 'set'
  
 set1 = Set.new([:bear, :cat, :deer])
  
 set1.include?(:bat)
  
 →
  
 false
  
 set1.add(:fox)
  
 →
  
 #<Set: {:cat, :deer, :fox, :bear}>
  
 partition = set1.classify {|element| element.to_s.length }
  
 partition
  
 →
  
 {3=>#<Set: {:cat, :fox}>, 4=>#<Set: {:deer,
  
 :bear}>}
  
 set2 = [ :cat, :dog, :cow ].to_set
  
 set1 | set2
  
 →
  
 #<Set: {:cat, :dog, :deer, :cow, :fox, :bear}>
  
 set1 & set2
  
 →
  
 #<Set: {:cat}>
  
 set1 - set2
  
 #<Set: {:deer, :fox, :bear}>
  
 →
  
 set1 ^ set2
  
 →
  
 #<Set: {:dog, :deer, :cow, :fox, :bear}>
  
 • Partition the users in our
  /etc/passwd
  file into subsets where members of each 
  
 subset have adjacent user IDs.
  
 require 'etc' 
  
 require 'set'
  
 users = []
  
 Etc.passwd {|u| users << u } 
  
 related_users = users.to_set.divide do |u1, u2| 
  
 (u1.uid - u2.uid).abs <= 1",NA
S,"et
  
 end
  
 related_users.each do |relatives| 
  
 relatives.each {|u| print ""#{u.uid}/#{u.name} "" } 
  
 puts 
  
 end
  
 produces:
  
 75/sshd 79/appserver 78/mailman 77/cyrus 76/qtss 74/mysql 
  
 503/testuser 502/dave 
  
 27/postfix 25/smmsp 26/lp 
  
 70/www 71/eppc 
  
 99/unknown
  
 -2/nobody 
  
 1/daemon 0/root
  
 Prepared exclusively for Yeganefar",NA
 Shellwords,"Split Line into Words Using POSIX Semantics
  
 Given a string representative of a shell command line, split it into word tokens accord-
 ing to POSIX semantics.
  
 • Spaces between double or single quotes are treated as part of a word.• 
 Double quotes may be escaped using a backslash.
  
 • Spaces escapes by a backslash are not used to separate words.
  
 • Otherwise tokens separated by whitespace are treated as words.
  
 require 'shellwords' 
  
 include Shellwords
  
 line = %{Code Ruby, Be Happy!}
  
 shellwords(line)
  
 →
  
 [""Code"", ""Ruby,"", ""Be"", ""Happy!""]
  
 line = %{""Code Ruby"", 'Be Happy'!}
  
 shellwords(line)
  
 →
  
 [""Code Ruby,"", ""Be Happy!""]
  
 line = %q{Code\ Ruby, \""Be Happy\""!}
  
 shellwords(line)
  
 →
  
 [""Code Ruby,"", ""\""Be"", ""Happy\""!""]",NA
S,"hellwords
  
  
 Prepared exclusively for Yeganefar",NA
 Singleton,"The Singleton Pattern
  
 The Singleton design pattern ensures that only one instance of a particular class may be 
 created for the lifetime of a program (see
  Design Patterns
  [
 GHJV95
 ]).
  
 The
  singleton
  library makes this simple to implement. Mix the
  Singleton
  module into 
 each class that is to be a singleton, and that class’s
  new
  method will be made private. 
 In its place, users of the class call the method
  instance
 , which returns a singleton 
 instance of that class.
  
 In this example, the two instances of
  MyClass
  are the same object.
  
 require 'singleton'
  
 class MyClass
  
 attr_accessor :data 
  
 include Singleton 
  
 end
  
 a = MyClass.instance
  
 →
  
 #<MyClass:0x1c20dc>",NA
S,"ingleton
  
 b = MyClass.instance
  
 #<MyClass:0x1c20dc>
  
 →
  
 a.data = 123
  
 →
  
 123
  
 b.data
  
 →
  
 123
  
  
 Prepared exclusively for Yeganefar",NA
 SOAP,"Client and Server Implementations of SOAP
  
 The SOAP library implements both the client and server sides of the SOAP protocol, 
 including support for WSDL, the Web Services Description Language.
  
 A fuller discussion of the SOAP library, including some examples of accessing the 
 Google search API, starts on page
  236
 .
  
 • Create a simple SOAP service that returns the current local time as a string.
  
 require 'soap/rpc/standaloneServer'
  
 module TimeServant 
  
 def TimeServant.now 
  
  
 Time.now.to_s 
  
 end 
  
 end
  
 class Server < SOAP::RPC::StandaloneServer 
  
 def on_init 
  
  
 servant = TimeServant 
  
  
 add_method(servant, 'now') 
  
 end 
  
 end
  
 if __FILE__ == $0 
  
 svr = Server.new('Server', 
  
   
 'http://pragprog.com/TimeServer', 
  
   
 '0.0.0.0', 
  
   
 12321) 
  
 trap('INT') { svr.shutdown } 
  
 svr.start
  
  
 end
  
 • Query the server using a simple SOAP client.
  
 require 'soap/rpc/driver'",NA
S,"OAP
  
 proxy = SOAP::RPC::Driver.new(""http://localhost:12321"", 
  
  
 ""http://pragprog.com/TimeServer"")
  
 proxy.add_method(""now"") 
  
 p proxy.now
  
 produces:
  
 ""Thu Aug 26 22:39:14 CDT 2004""
  
 Prepared exclusively for Yeganefar",NA
 Socket,"IP, TCP, Unix, and SOCKS Socket Access
  
  
 The
  socket
  extension defines nine classes
  
 IO
  
  
 BasicSocket
  
 for accessing the socket-level communica-
  
 tions of the underlying system. All of 
 these
  
 IPSocket
  
 classes are (indirect) subclasses of class
  IO
 ,
  
 TCPSocket
  
 meaning that
  IO
 ’s methods can be used 
 with
  
 SOCKSSocket
  
 socket connections.
  
 TCPServer
  
 UDPSocket
  
 The hierarchy of socket classes reflects the
  
 Socket
  
 reality of network programming and hence
  
 UNIXSocket
  
 is somewhat confusing. The
  BasicSocket
  
  
 UNIXServer
  
 class largely contains methods common to
  
 data transfer for all socket-based connections. It is subclassed to provide protocol-
 specific implementations:
  IPSocket
 ,
  UNIXSocket
  (for domain sockets), and (indi-rectly)
  
 TCPSocket
 ,
  UDPSocket
 , and
  SOCKSSocket
 .
  
 BasicSocket
  is also subclassed by class
  Socket
 , which is a more generic interface to 
 socket-oriented networking. While classes such as
  TCPSocket
  are specific to a proto-
 col,
  Socket
  objects can, with some work, be used regardless of protocol.
  
 TCPSocket
 ,
  SOCKSSocket
 , and
  UNIXSocket
  are each connection oriented. Each has a 
 corresponding
  xxxx
 Server
  class, which implements the server end of a connection.
  
 The socket libraries are something that you may never use directly. However, if you do 
 use them, you’ll need to know the details. For that reason, we’ve included a reference
  
 section covering the socket library methods in Appendix
  A
  on page
  740
 .
  
 The following code shows a trivial UDP server and client. For more examples see 
 Appendix
  A
 .",NA
S,"ocket
  
 # Simple logger prints messages
  
 # Exercise the logger
  
  
 # received on UDP port 12121
  
 require 'socket'
  
 require 'socket'
  
 log = UDPSocket.new
  
 socket = UDPSocket.new
  
 log.connect(""127.0.0.1"", 12121)
  
 socket.bind(""127.0.0.1"", 12121)
  
 log.print ""Up and Running!""
  
 loop do
  
 # process ... process ..
  
 msg, sender
  
 = socket.recvfrom(100)
  
 log.print ""Done!""
  
 host = sender[3] 
  
 puts ""#{Time.now}: #{host} '#{msg}'"" 
  
 end
  
 This produces:
  
 Wed Jun 30 17:30:24 CDT 2004: 127.0.0.1 'Up and Running!' 
  
 Wed Jun 30 17:30:24 CDT 2004: 127.0.0.1 'Done!'
  
 Prepared exclusively for Yeganefar",NA
 StringIO,"Treat Strings as IO Objects
  
 In some ways the distinction between strings and file contents is artificial: the 
 contents of a file is basically a string that happens to live on disk, not in memory. The
  
 StringIO 
 library aims to unify the two concepts, making strings act as if they were 
 opened
  IO 
 objects. Once a string is wrapped in a
  StringIO
  object, it can be read from 
 and written to as if it were an open file. This can make unit testing a lot easier. It also 
 lets you pass strings into classes and methods that were originally written to work 
 with files.
  
 • Read and write from a string.
  
 require 'stringio'
  
 sio = StringIO.new(""time flies like an arrow"")
  
 sio.read(5)
  
 →
  
 ""time ""
  
 sio.read(5)
  
 →
  
 ""flies""
  
 sio.pos = 18
  
 sio.read(5)
  
 →
  
 "" arro""
  
 sio.rewind
  
 0
  
 →
  
 sio.write(""fruit"")
  
 →
  
 5
  
 sio.pos = 16
  
 sio.write(""a banana"")
  
 →
  
 8
  
 sio.rewind
  
 0
  
 →
  
 sio.read
  
 →
  
 ""fruitflies like a banana""
  
 • Use
  StringIO
  as a testing aid.
  
 require 'stringio'
  
 require 'csv' 
  
 require 'test/unit' 
  
 class TestCSV < Test::Unit::TestCase 
  
 def test_simple",NA
S,"tringIO
  
  
 StringIO.open do |op| 
  
    
 CSV::Writer.generate(op) do |csv| 
  
    
 csv << [ 1, ""line 1"", 27 ] 
  
    
 csv << [ 2, nil, 123 ] 
  
    
 end 
  
    
 assert_equal(""1,line 1,27\n2,,123\n"", op.string) 
  
  
 end 
  
 end 
  
 end
  
 produces:
  
 Loaded suite -
  
 Started 
  
 .
  
 Finished in 0.001857 seconds.
  
 1 tests, 1 assertions, 0 failures, 0 errors",NA
 StringScanner,"Basic String Tokenizer
  
 StringScanner
  objects progress through a string, matching (and optionally returning) 
 tokens that match a given pattern. Unlike the built-in scan methods,
  StringScanner 
 objects maintain a current position pointer in the string being examined, so each call 
 resumes from the position in the string where the previous call left off. Pattern 
 matches are anchored to this previous point.
  
 • Implement a simple language.
  
 require 'strscan'
  
 # Handle the language: 
  
 # set <var> = <value> 
  
 # get <var>
  
 values = {}
  
 loop do 
  
 line = gets or break
  
 scanner = StringScanner.new(line.chomp)
  
 scanner.scan(/(get|set)\s+/) or fail ""Missing command"" 
  
 cmd = scanner[1]
  
 var_name = scanner.scan(/\w+/) or fail ""Missing variable""
  
 case cmd 
  
 when ""get"" 
  
 puts ""#{var_name} => #{values[var_name].inspect}""
  
 when ""set"" 
  
 scanner.skip(/\s+=\s+/) or fail ""Missing '='"" 
  
 value = scanner.rest 
  
 values[var_name] = value 
  
 else 
  
 fail cmd 
  
 end",NA
S,"tringScanner
  
 end
  
 produces:
  
 % ruby code/strscan.rb 
  
 set a = dave 
  
 set b = hello 
  
 get b 
  
 b => ""hello"" 
  
 get a 
  
 a => ""dave""
  
 Prepared exclusively for Yeganefar",NA
 Sync,"Thread Synchronization with Shared Regions
  
 The
  sync
  library synchronizes the access to shared data across multiple, concurrent 
 threads. Unlike
  Monitor
 , the
  sync
  library supports both exclusive access to data and 
 shared (read-only) access.
  
 See also:
  Monitor
  (page
  674
 ),
  Mutex
  (page
  675
 ),
  Thread
  (page
  612
 )
  
 • Without synchronization, the following code has a race condition: the
  inc
  method 
 can be interrupted between fetching the count and storing the incremented value 
 back, resulting in updates being lost.
  
 require 'thwait'
  
 class Counter 
  
 attr_reader :total_count 
  
 def initialize 
  
  
 @total_count = 0 
  
 end 
  
 def inc 
  
  
 @total_count += 1 
  
 end 
  
 end
  
 count = Counter.new 
  
 waiter = ThreadsWait.new([])
  
 # create 10 threads that each inc() 10,000 times 
  
 10.times do 
  
 waiter.join_nowait(Thread.new { 10000.times { count.inc } })
  
 end
  
  
  
 ync
  
 waiter.all_waits
  
 →
  
 62449",NA
S,"count.total_count
  
 • Add exclusive synchronization to ensure the count is correct.
  
 require 'thwait' 
  
 require 'sync'
  
 class Counter 
  
 attr_reader :total_count 
  
 def initialize 
  
  
 @total_count = 0 
  
  
 @sync = Sync.new 
  
 end 
  
 def inc 
  
  
 @sync.synchronize(:EX) do 
  
    
 @total_count += 1 
  
  
 end 
  
 end 
  
 end
  
 Prepared exclusively for Yeganefar",NA
S,"count = Counter.new 
  
 waiter = ThreadsWait.new([])
  
 # create 10 threads that each inc() 10,000 times 
  
 10.times do 
  
 waiter.join_nowait(Thread.new { 10000.times do 
  
  
 count.inc 
  
  
 count.test_consistent 
  
 end }) 
  
 end
  
 waiter.all_waits
  
 →
  
 nil
  
 count.total_count
  
 100000
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
 Syslog,"Interface to Unix System Logging
  
  
 Only if:
  Unix
  
 The
  Syslog
  class is a simple wrapper around the Unix syslog(3) library. It allows
  
 system with
  syslog
  
 messages to be written at various severity levels to the logging daemon, where they are
  
 disseminated according to the configuration in
  syslog.conf
 . The following examples 
 assume the log file is
  /var/log/system.log
 .
  
 • Add to our local system log. We’ll log all the levels configured for the user facility 
  
 for our system (which is every level except debug messages).
  
 require 'syslog' 
  
 log = Syslog.open(""test"") 
  
 # ""test"" is the app name 
  
 log.debug(""Warm and fuzzy greetings from your program"") 
  
 log.info(""Program starting"") 
  
 log.notice(""I said 'Hello!'"") 
  
 log.warning(""If you don't respond soon, I'm quitting"") 
  
 log.err(""You haven't responded after %d milliseconds"", 7) 
  
 log.alert(""I'm telling your mother..."") 
  
 log.emerg(""I'm feeling totally crushed"") 
  
 log.crit(""Aarrgh...."")
  
 system(""tail -7 /var/log/system.log"") 
  
 produces:
  
 Aug 26 22:39:38 wireless_2 test[28505]: Program starting 
  
 Aug 26 22:39:38 wireless_2 test[28505]: I said 'Hello!' 
  
 Aug 26 22:39:38 wireless_2 test[28505]: If you don't respond soon, I'm quitting Aug 26 22:39:38 wireless_2 
 test[28505]: You haven't responded after 7 milliseconds Aug 26 22:39:38 wireless_2 test[28505]: I'm telling your 
 mother...
  
 Aug 26 22:39:38 wireless_2 test[28505]: I'm feeling totally crushed 
  
 Aug 26 22:39:38 wireless_2 test[28505]: Aarrgh....
  
 • Only log errors and above.
  
 require 'syslog' 
  
 log = Syslog.open(""test"")",NA
S,"yslog
  
 log.mask = Syslog::LOG_UPTO(Syslog::LOG_ERR) 
  
 log.debug(""Warm and fuzzy greetings from your program"") 
  
 log.info(""Program starting"") 
  
 log.notice(""I said 'Hello!'"") 
  
 log.warning(""If you don't respond soon, I'm quitting"") 
  
 log.err(""You haven't responded after %d milliseconds"", 7) 
  
 log.alert(""I'm telling your mother..."") 
  
 log.emerg(""I'm feeling totally crushed"") 
  
 log.crit(""Aarrgh...."")
  
 system(""tail -7 /var/log/system.log"") 
  
 produces:
  
 Aug 26 22:39:38 wireless_2 test[28510]: You haven't responded after 7 milliseconds Aug 26 22:39:38 wireless_2 
 test[28510]: I'm telling your mother... 
  
 Aug 26 22:39:38 wireless_2 test[28510]: I'm feeling totally crushed 
  
 Aug 26 22:39:38 wireless_2 test[28510]: Aarrgh....
  
 Prepared exclusively for Yeganefar",NA
 Tempfile,"Temporary File Support
  
 Class
  Tempfile
  creates managed temporary files. Although they behave the same as 
 any other
  IO
  objects, temporary files are automatically deleted when the Ruby pro-
 gram terminates. Once a
  Tempfile
  object has been created, the underlying file may be 
 opened and closed a number of times in succession.
  
 Tempfile
  does not directly inherit from
  IO
 . Instead, it delegates calls to a
  File
  object. 
 From the programmer’s perspective, apart from the unusual
  new
 ,
  open,
  and
  close 
 semantics, a
  Tempfile
  object behaves as if it were an
  IO
  object.
  
 If you don’t specify a directory to hold temporary files when you create them, the 
 tmpdir
  library will be used to find a system-dependent location.
  
 See also:
  tmpdir
  (page
  727
 )
  
 require 'tempfile'
  
 tf = Tempfile.new(""afile"")
  
 tf.path
  
 →
  
 ""/tmp/afile28519.0""",NA
T,"empfile
  
 tf.puts(""Cosi Fan Tutte"")
  
 →
  
 nil
  
 tf.close
  
 →
  
 nil
  
 tf.open
  
 →
  
 #<File:/tmp/afile28519.0>
  
 tf.gets
  
 →
  
 ""Cosi Fan Tutte\n""
  
 tf.close(true)
  
 #<File:/tmp/afile28519.0 (closed)>
  
 →
  
  
 Prepared exclusively for Yeganefar",NA
 Test::Unit,"Unit Testing Framework
  
 Test::Unit
  is a unit testing framework based on the original SUnit Smalltalk frame-
 work. It provides a structure in which unit tests may be organized, selected, and run. 
 Tests can be run from the command line or using one of several GUI-based 
 interfaces.
  
 Chapter
  12
  on page
  143
  contains a tutorial on
  Test::Unit
 .
  
 We could have a simple playlist class, designed to store and retrieve songs.
  
 require 'code/testunit/song.rb' 
  
 require 'forwardable'
  
 class Playlist 
  
 extend Forwardable 
  
 def_delegator(:@list, :<<, :add_song) 
  
 def_delegator(:@list, :size)
  
 def initialize 
  
  
 @list = [] 
  
 end
  
 def find(title) 
  
   
 @list.find {|song| song.title == title} 
  
 end 
  
 end
  
 We can write unit tests to exercise this class. The
  Test::Unit
  framework is smart enough 
 to run the tests in a test class if no main program is supplied.
  
 require 'test/unit' 
  
 require 'code/testunit/playlist.rb'
  
 class TestPlaylist < Test::Unit::TestCase
  
 def test_adding 
  
 pl = Playlist.new 
  
 assert_equal(0, pl.size)
  
 est::Unit
  
 assert_nil(pl.find(""My Way"")) 
  
 pl.add_song(Song.new(""My Way"", ""Sinatra""))",NA
T,"assert_equal(1, pl.size) 
  
   
 s = pl.find(""My Way"") 
  
   
 assert_not_nil(s) 
  
   
 assert_equal(""Sinatra"", s.artist) 
  
   
 assert_nil(pl.find(""Chicago"")) 
  
   
 # .. and so on 
  
 end 
  
 end
  
 produces:
  
 Loaded suite -
  
 Started 
  
 .
  
 Finished in 0.002046 seconds.
  
 1 tests, 6 assertions, 0 failures, 0 errors",NA
 thread,"Utility Functionality for Threading
  
 The
  thread
  library adds some utility functions and classes for supporting threads. 
 Much of this has been superseded by the
  Monitor
  class, but it contains two classes, 
 Queue
  and
  SizedQueue
 , that are still useful. Both classes implement a thread-safe queue 
 that can be used to pass objects between producers and consumers in multi-ple 
 threads. The
  Queue
  object implements a unbounded queue. A
  SizedQueue
  is told its 
 capacity; any producer who tries to add an object when the queue is at that capacity 
 will block until a consumer has removed an object.
  
 • The following example was provided by Robert Kellner. It has three consumers 
 taking objects from an unsized queue. Those objects are provided by two 
 produc-ers, which each add three items.
  
 require 'thread' 
  
 queue = Queue.new
  
 consumers = (1..3).map do |i| 
  
 Thread.new(""consumer #{i}"") do |name| 
  
  
 begin 
  
    
 obj = queue.deq 
  
    
 print ""#{name}: consumed #{obj.inspect}\n"" 
  
    
 sleep(rand(0.05)) 
  
  
 end until obj == :END_OF_WORK 
  
 end 
  
 end
  
 producers = (1..2).map do |i| 
  
 Thread.new(""producer #{i}"") do |name| 
  
  
 3.times do |j| 
  
    
 sleep(0.1)
  
   
 queue.enq(""Item #{j} from #{name}"") 
  
 end 
  
 end
  
 hread
  
 end",NA
T,"producers.each {|th| th.join} 
  
 consumers.size.times { queue.enq(:END_OF_WORK) } 
  
 consumers.each {|th| th.join}
  
 produces:
  
 consumer 1: consumed ""Item 0 from producer 1"" 
  
 consumer 2: consumed ""Item 0 from producer 2"" 
  
 consumer 3: consumed ""Item 1 from producer 1"" 
  
 consumer 3: consumed ""Item 1 from producer 2"" 
  
 consumer 3: consumed ""Item 2 from producer 2"" 
  
 consumer 2: consumed ""Item 2 from producer 1"" 
  
 consumer 3: consumed :END_OF_WORK 
  
 consumer 2: consumed :END_OF_WORK 
  
 consumer 1: consumed :END_OF_WORK
  
 Prepared exclusively for Yeganefar",NA
 ThreadsWait,"Wait for Multiple Threads to Terminate
  
 Class
  ThreadsWait
  handles the termination of a group of thread objects. It provides 
 methods to allow you to check for termination of any managed thread and to wait for 
 all managed threads to terminate.
  
 The following example kicks off a number of threads that each wait for a slightly 
 shorter length of time before terminating and returning their thread number. Using 
 ThreadsWait
 , we can capture these threads as they terminate, either individually or as 
 a group.
  
 require 'thwait'
  
 group = ThreadsWait.new
  
 # construct 10 threads that wait for 1 second, .9 second, etc. # add each to the group
  
 9.times do |i| 
  
 thread = Thread.new(i) {|index| sleep 1.0 - index/10.0; index } group.join_nowait(thread) 
  
 end
  
 # any threads finished?
  
 group.finished?
  
 →
  
 false
  
 # wait for one to finish
  
 group.next_wait.value
  
 →
  
 8",NA
T,"hreadsWait
  
 # wait for 5 more to finish
  
 →
  
 5
  
 5.times { group.next_wait }
  
 # wait for next one to finish
  
 group.next_wait.value
  
 →
  
 2",NA
T,"# and then wait for all the rest
  
 group.all_waits
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
 Time,"Extended Functionality for Class
  Time
  
 The
  time
  library adds functionality to the built-in class
  Time
 , supporting date and/or 
 time formats used by RFC 2882 (e-mail), RFC 2616 (HTTP), and ISO 8601 (the 
 subset used by XML schema).
  
 require ’time’
  
 Time.rfc2822(""Thu, 1 Apr 2004 16:32:45 CST"")
  
  
 →
  Thu Apr 01 16:32:45 CST 2004
  
 Time.rfc2822(""Thu, 1 Apr 2004 16:32:45 -0600"")
  
  
 →
  Thu Apr 01 16:32:45 CST 2004
  
 Time.now.rfc2822
  
 →
  Thu, 26 Aug 2004 22:39:42 -0500
  
 Time.httpdate(""Thu, 01 Apr 2004 16:32:45 GMT"")
  
  
 →
  Thu Apr 01 16:32:45 UTC 2004
  
 Time.httpdate(""Thursday, 01-Apr-04 16:32:45 GMT"")
  
  
 →
  Thu Apr 01 16:32:45 UTC 2004
  
 Time.httpdate(""Thu Apr 1 16:32:45 2004"")
  
  
 →
  Thu Apr 01 16:32:45 UTC 2004
  
 Time.now.httpdate
  
 →
  Fri, 27 Aug 2004 03:39:42 GMT
  
 Time.xmlschema(""2004-04-01T16:32:45"")
  
  
 →
  Thu Apr 01 16:32:45 CST 2004
  
 Time.xmlschema(""2004-04-01T16:32:45.12-06:00"")
  
  
 →
  Thu Apr 01 22:32:45 UTC 2004",NA
T,"ime
  
 Time.now.xmlschema
  
 →
  2004-08-26T22:39:42-05:00
  
  
 Prepared exclusively for Yeganefar",NA
 Timeout,"Run a Block with Timeout
  
 The
  Timeout.timeout
  method takes a parameter representing a timeout period in sec-
 onds, an optional exception parameter, and a block. The block is executed, and a 
 timer is run concurrently. If the block terminates before the timeout,
  timeout
  returns 
 the value of the block. Otherwise, the exception (default
  Timeout::Error
 ) is raised.
  
 require 'timeout'
  
 for snooze in 1..2 
  
 puts ""About to sleep for #{snooze}"" 
  
 begin 
  
   
 Timeout::timeout(1.5) do |timeout_length| 
  
    
 puts ""Timeout period is #{timeout_length}"" 
  
    
 sleep(snooze) 
  
    
 puts ""That was refreshing"" 
  
   
 end 
  
 rescue Timeout::Error 
  
   
 puts ""Woken up early!!"" 
  
 end 
  
 end
  
 produces:
  
 About to sleep for 1 
  
 Timeout period is 1.5 
  
 That was refreshing 
  
 About to sleep for 2 
  
 Timeout period is 1.5 
  
 Woken up early!!",NA
T,"imeout
  
  
 Prepared exclusively for Yeganefar",NA
 Tk,"Wrapper for Tcl/Tk
  
  
 Only if:
  Tk library
  
 Of all the Ruby options for creating GUIs, the
  Tk
  library is probably the most widely
  
 installed
  
 supported, running on Windows, Linux, Mac OS X, and other Unix-like platforms.
 5
  
 Although it doesn’t produce the prettiest interfaces, Tk is functional and relatively sim-
 ple to program. The Tk extension is documented more fully in Chapter
  19
  on page
  241
 .
  
 TkCanvas.new(root) do |canvas| 
  
 width 400 
  
 height 400 
  
 pack('side'=>'top', 'fill'=>'both', 'expand'=>'yes')
  
 points = [ ]
  
  
 require 'tk' 
  
 include Math
  
 TkRoot.new do |root| 
  
 title ""Curves"" 
  
 geometry ""400x400""
  
 10.upto(30) do |scale| 
  
 (0.0).step(2*PI,0.1) do |i| 
  
  
 new_x = 5*scale*sin(i) + 200 
  
 + 
  
 scale*sin(i*2) 
  
  
 new_y = 5*scale*cos(i) + 200 
  
 + scale*cos(i*6) 
  
  
 points << [ new_x, new_y ]
  
 f = scale/5.0 
  
 r = (Math.sin(f)+1)*127.0 
  
 g = (Math.cos(2*f)+1)*127.0 
  
 b = (Math.sin(3*f)+1)*127.0 
  
 col = sprintf(""#%02x%02x%02x"", r.to_i, g.to_i, b.to_i)
  
 if points.size == 3 
  
 TkcLine.new(canvas, 
  
   
 points[0][0], points[0][1], 
  
   
 points[1][0], points[1][1],
  
 points[2][0], points[2][1], 
  
 'smooth'=>'on',",NA
T,k,NA
 tmpdir,"System-Independent Temporary Directory Location
  
 The
  tmpdir
  library adds the
  tmpdir
  method to class
  Dir
 . This method returns the path to 
 a temporary directory that
  should
  be writable by the current process. (This will not be 
 true if none of the well-known temporary directories is writable, and if the current 
 working directory is also not writable.) Candidate directories include those referenced 
 by the environment variables
  TMPDIR
 ,
  TMP
 ,
  TEMP
 , and
  USERPROFILE
 , the directory
  
 /tmp
 , and (on Windows boxes) the
  temp
  subdirectory of the Windows or System 
 directory.
  
 require 'tmpdir'
  
 Dir.tmpdir
  
 →
  
 ""/tmp""",NA
T,"mpdir
  
 ENV['TMPDIR'] = ""/wibble""
  
 # doesn't exist
  
 ENV['TMP']
  
 = ""/sbin""
  
 # not writable
  
 ENV['TEMP']
  
 = ""/Users/dave/tmp"" # just right
  
 Dir.tmpdir
  
 →
  
 ""/Users/dave/tmp""
  
  
 Prepared exclusively for Yeganefar",NA
 Tracer,"Trace Program Execution
  
 The
  tracer
  library uses
  Kernel.set_trace_func
  to trace all or part of a Ruby pro-gram’s 
 execution. The traced lines show the thread number, file, line number, class, event, 
 and source line. The events shown are “-” for a change of line, “>” for a call, “<”for a 
 return, “C” for a class definition, and “E” for the end of a definition.
  
 • You can trace an entire program by including the
  tracer
  library from the com-
  
 mand line.
  
 class Account 
  
 def initialize(balance) 
  
  
 @balance = balance 
  
 end 
  
 def debit(amt) 
  
  
 if @balance < amt 
  
    
 fail ""Insufficient funds"" 
  
 else 
  
    
 @balance -= amt 
  
  
 end 
  
 end 
  
 end 
  
 acct = Account.new(100) 
  
 acct.debit(40)
  
 % ruby -r tracer account.rb 
  
 #0:account.rb:1::-: class Account 
  
 #0:account.rb:1:Class:>: class Account 
  
 #0:account.rb:1:Class:<: class Account 
  
 #0:account.rb:1::C: class Account
  
 #0:account.rb:2::-:
  
 def initialize(balance)
  
 #0:account.rb:2:Module:>:
  
 def initialize(balance)
  
 #0:account.rb:2:Module:<:
  
 def initialize(balance)
  
 #0:account.rb:5::-:
  
 def debit(amt)
  
 #0:account.rb:5:Module:>:
  
 def debit(amt)
  
 #0:account.rb:5:Module:<:
  
 def debit(amt)
  
 #0:account.rb:1::E: class Account 
  
 #0:account.rb:13::-: acct = Account.new(100) 
  
 #0:account.rb:13:Class:>: acct = Account.new(100)
  
 #0:account.rb:2:Account:>:
  
 def initialize(balance)
  
 #0:account.rb:3:Account:-:
  
 @balance = balance
  
 #0:account.rb:13:Account:<: acct = Account.new(100) 
 #0:account.rb:13:Class:<: acct = Account.new(100) #0:account.rb:14::-: 
 acct.debit(40)
  
 #0:account.rb:5:Account:>:
  
 def debit(amt)
  
 #0:account.rb:6:Account:-:
  
 if @balance < amt
  
 #0:account.rb:6:Account:-:
  
 if @balance < amt
  
 #0:account.rb:6:Fixnum:>:
  
 if @balance < amt
  
 #0:account.rb:6:Fixnum:<:
  
 if @balance < amt
  
 #0:account.rb:9:Account:-:
  
 @balance -= amt
  
 #0:account.rb:9:Fixnum:>:
  
 @balance -= amt
  
 #0:account.rb:9:Fixnum:<:
  
 @balance -= amt
  
 #0:account.rb:9:Account:<:
  
 @balance -= amt
  
 • You can also use tracer objects to trace just a portion of your code and use filters 
  
 to select what to trace.
  
 require 'tracer'
  
 #0:account.rb:20::-:
  
 acct.debit(40)
  
 racer
  
 class Account
  
 #0:account.rb:8:Account:-:
  
 if @balance < amt
  
 #0:account.rb:8:Account:-:
  
 if @balance < amt
  
 #0:account.rb:11:Account:-:
  
 @bance -= amt
  
 def initialize(balance)
  
 @bance -= amt",NA
T,"@balance = balance
  
 end 
  
 def debit(amt) 
  
  
 if @balance < amt 
  
    
 fail ""Insufficient funds"" 
  
  
 else 
  
    
 @balance -= amt 
  
  
 end 
  
 end 
  
 end
  
 tracer = Tracer.new 
  
 tracer.add_filter lambda {|event, *rest| event == ""line"" } 
  
 acct = Account.new(100) 
  
 tracer.on do 
  
 acct.debit(40) 
  
 end
  
 Prepared exclusively for Yeganefar",NA
 TSort,"Topological Sort
  
 Given a set of dependencies between nodes (where each node depends on zero or 
 more other nodes, and there are no cycles in the graph of dependencies), a topological 
 sort will return a list of the nodes ordered such that no node follows a node that 
 depends on it. One use for this is scheduling tasks, where the order means that you 
 will complete the dependencies before you start any task that depends on them. The
  
 make
  program uses a topological sort to order its execution.
  
 In this library’s implementation, you mix in the
  TSort
  module and define two 
 methods: 
 tsort_each_node
 , which yields each node in turn, and
  tsort_each_child
 , which, 
 given a node, yields each of that nodes dependencies.
  
 • Given the set of dependencies among the steps for making a piña colada, what is 
  
 the optimum order for undertaking the steps?
  
 require 'tsort'
  
 class Tasks 
  
 include TSort 
  
 def initialize 
  
  
 @dependencies = {} 
  
 end
  
 def add_dependency(task, *relies_on) 
  
 @dependencies[task] = relies_on 
  
 end
  
 def tsort_each_node(&block) 
  
 @dependencies.each_key(&block) 
  
 end
  
 def tsort_each_child(node, &block) 
  
  
 deps = @dependencies[node] 
  
  
 deps.each(&block) if deps 
  
 end 
  
 end
  
 tasks = Tasks.new
  
 :open_blender)",NA
T,"Sort
  
 tasks.add_dependency(:add_rum,
  
 tasks.add_dependency(:add_pc_mix,
  
 :open_blender)
  
 tasks.add_dependency(:add_ice,
  
 :open_blender)
  
 tasks.add_dependency(:close_blender, :add_rum, :add_pc_mix, :add_ice) 
  
 tasks.add_dependency(:blend_mix, 
  
 :close_blender) 
  
 tasks.add_dependency(:pour_drink, 
  
 :blend_mix) 
  
 tasks.add_dependency(:pour_drink, 
  
 :open_blender) 
  
 puts tasks.tsort
  
 produces:
  
 open_blender 
  
 add_pc_mix 
  
 add_ice 
  
 add_rum 
  
 close_blender 
  
 blend_mix 
  
 pour_drink
  
 Prepared exclusively for Yeganefar",NA
 un,"Command-Line Interface to FileUtils
  
 Why
  un
 ? Because when you invoke it from the command line with the
  -r
  option to 
 Ruby, it spells
  -run
 . This pun gives a hint as to the intent of the library: it lets you run 
 commands (in this case, a subset of the methods in
  FileUtils
 ) from the command line. 
 In theory this gives you an operating system–independent set of file manipulation 
 commands, possibly useful when writing portable Makefiles.
  
 See also:
  FileUtils
  (page
  657
 )
  
 • The available commands are
  
 % ruby -run -e cp --
  <options> source dest 
  
 % ruby -run -e ln --
  <options> target linkname 
  
 % ruby -run -e mv --
  <options> source dest 
  
 % ruby -run -e rm --
  <options> file 
  
 % ruby -run -e mkdir --
  <options> dirs 
  
 % ruby -run -e rmdir --
  <options> dirs 
  
 % ruby -run -e install --
  <options> source dest 
  
 % ruby -run -e chmod --
  <options> octal_mode file 
  
 % ruby -run -e touch --
  <options> file
  
 Note the use of
  --
  to tell the Ruby interpreter that options to the program follow.
  
 You can get a list of all available commands with
  
 % ruby -run -e help
  
 For help on a particular command, append the command’s name.
  
 % ruby -run -e help mkdir",NA
U,"n
  
  
 Prepared exclusively for Yeganefar",NA
 URI,"RFC 2396 Uniform Resource Identifier (URI) Support
  
 URI
  encapsulates the concept of a Uniform Resource Identifier (URI), a way of 
 specify-ing some kind of (potentially networked) resource. URIs are a superset of 
 URLs: URLs (such as the addresses of Web pages) allow specification of addresses 
 by location, and URIs also allow specification by name.
  
 URIs consist of a scheme (such as
  http
 ,
  mailto
 ,
  ftp
 , and so on), followed by struc-tured 
 data identifying the resource within the scheme.
  
 URI
  has factory methods that take a URI string and return a subclass of URI spe-cific 
 to the scheme. The library explicitly supports the
  ftp
 ,
  http
 ,
  https
 ,
  ldap
 , and 
 mailto
  
 schemes; others will be treated as generic URIs. The module also has con-venience 
 methods to escape and unescape URIs. The class
  Net::HTTP
  accepts URI objects 
 where a URL parameter is expected.
  
 See also:
  open-uri
  (page
  686
 ),
  Net::HTTP
  (page
  678
 )
  
 require 'uri'
  
 uri = URI.parse(""http://pragprog.com:1234/mypage.cgi?q=ruby"")
  
 uri.class
  
 →
  
 URI::HTTP
  
 uri.scheme
  
 →
  
 ""http""
  
 uri.host
  
 ""pragprog.com""
  
 →
  
 uri.port
  
 →
  
 1234
  
 uri.path
  
 →
  
 ""/mypage.cgi""
  
 uri.query
  
 →
  
 ""q=ruby""
  
 uri = URI.parse(""mailto:ruby@pragprog.com?Subject=help&body=info"")
  
 uri.class
  
 →
  
 URI::MailTo",NA
U,"RI
  
 uri.scheme
  
 →
  
 ""mailto""
  
 uri.to
  
 →
  
 ""ruby@pragprog.com""
  
 uri.headers
  
 →
  
 [[""Subject"", ""help""], [""body"", ""info""]]
  
 uri = URI.parse(""ftp://dave@anon.com:/pub/ruby;type=i"")
  
 uri.class
  
 →
  
 URI::FTP
  
 uri.scheme
  
 →
  
 ""ftp""
  
  
 uri.host
  
 →
  
 ""anon.com""
  
 uri.port
  
 →
  
 21
  
 uri.path
  
 →
  
 ""/pub/ruby""
  
 uri.typecode
  
 →
  
 ""i""
  
  
 Prepared exclusively for Yeganefar",NA
 WeakRef,"Support for Weak References
  
 In Ruby, objects are not eligible for garbage collection if references still exist to 
 them. Normally, this is a Good Thing—it would be disconcerting to have an object 
 simply evaporate while you were using it. However, sometimes you may need more 
 flexibility. For example, you might want to implement an in-memory cache of 
 commonly used file contents. As you read more files, the cache grows. At some 
 point, you may run low on memory. The garbage collector will be invoked, but the 
 objects in the cache are all referenced by the cache data structures and so will not be 
 deleted.
  
 A weak reference behaves exactly as any normal object reference with one important 
 exception—the referenced object may be garbage collected, even while references to 
 it exist. In the cache example, if the cached files were accessed using weak 
 references, once memory runs low they will be garbage collected, freeing memory for 
 the rest of the application.
  
 • Weak references introduce a slight complexity. As the object referenced can be 
 deleted by garbage collection at any time, code that accesses these objects must 
 take care to ensure that the references are valid. Two techniques can be used. 
 First, the code can reference the objects normally. Any attempt to reference an 
 object that has been garbage collected will raise a
  WeakRef::RefError
  exception.
  
 require 'weakref'
  
 ref = ""fol de rol"" 
  
 puts ""Initial object is #{ref}"" 
  
 ref = WeakRef.new(ref) 
  
 puts ""Weak reference is #{ref}"" 
  
 ObjectSpace.garbage_collect 
  
 puts ""But then it is #{ref}""
  
 produces:
  
 Initial object is fol de rol 
  
 Weak reference is fol de rol
  
  
 prog.rb:8: Illegal Reference - probably recycled (WeakRef::RefError)
 • Alternatively, use the
  
 WeakRef
 #
 weakref_alive?
  method to check that a refer-
  
 ence is valid before using 
 it. Garbage collection must be disabled during the test 
  
 and subsequent reference 
 to the object. In a single-threaded program, you could",NA
W,"eakRef
  
 use something like
  
 ref = WeakRef.new(some_object)
  
 # .. some time later
  
 gc_was_disabled = GC.disable 
  
 if ref.weakref_alive?
  
 # do stuff with 'ref' 
  
 end 
  
 GC.enable unless gc_was_disabled",NA
 WEBrick,"Web Server Toolkit
  
 WEBrick is a pure-Ruby framework for implementing HTTP-based servers. The 
 stan-dard library includes WEBrick services that implement a standard Web server 
 (serving files and directory listings), and servlets supporting CGI,
  erb
 , file download, 
 and the mounting of Ruby lambdas.
  
 More examples of WEBrick start on page
  234
 .
  
 • The following code mounts two Ruby procs on a Web server. Requests to the URI 
  
 http://localhost:2000/hello
  run one proc, and requests to
  http://localhost:2000/bye 
 run the other.
  
 #!/usr/bin/ruby
  
 require 'webrick' 
  
 include WEBrick
  
 hello_proc = lambda do |req, resp| 
  
 resp['Content-Type'] = ""text/html"" 
  
 resp.body = %{ 
  
   
 <html><body> 
  
   
  
 Hello. You're calling from a #{req['User-Agent']} 
  
   
 <p> 
  
   
  
 I see parameters: #{req.query.keys.join(', ')} 
  
   
 </body></html> 
  
 } 
  
 end
  
 bye_proc = lambda do |req, resp| 
  
 resp['Content-Type'] = ""text/html"" 
  
 resp.body = %{ 
  
   
 <html><body> 
  
   
 <h3>Goodbye!</h3> 
  
   
 </body></html> 
  
 } 
  
 end
  
 hello =
  
 HTTPServlet::ProcHandler.new(hello_proc)
  
 EBrick
  
 bye
  
 =
  
 HTTPServlet::ProcHandler.new(bye_proc)
  
 s = HTTPServer.new(:Port => 2000) 
  
 s.mount(""/hello"", hello)",NA
W,"s.mount(""/bye"",
  
 bye)
  
 trap(""INT""){ s.shutdown } 
  
 s.start
  
 Prepared exclusively for Yeganefar",NA
 Win32API,"Access Entry Points in Windows DDLs
  
  
 Only if:
  Windows
  
 The
  Win32API
  module allows access to any arbitrary Windows 32 function. Many of
  
 these functions take or return a
  Pointer
  data type—a region of memory corresponding to 
 a C string or structure type.
  
 In Ruby, these pointers are represented using class
  String
 , which contains a sequence 
 of 8-bit bytes. It is up to you to pack and unpack the bits in the
  String
 . See the refer-
 ence section for
  unpack
  on page
  602
  and
  pack
  on page
  415
  for details.
  
 Parameters 3 and 4 of the
  new
  call specify the parameter and return types of the 
 method to be called. The type specifiers are
  n
  and
  l
  for numbers,
  i
  for integers,
  p
  for 
 pointers to data stored in a string, and
  v
  for the void type (used for export parameters 
 only). These strings are case-insensitive. Method parameters are specified as an array 
 of strings, and the return type is a single string.
  
 The functionality of
  Win32API
  is also provided using the
  dl/win32
  library. As the
  DL 
 library is newer, this may be a sign that the original
  Win32API
  may be phased out over 
 time.
  
 See also:
  DL
  (page
  648
 )
  
 • This example is from the Ruby distribution, in
  ext/Win32API
 .
  
 require 'Win32API'
  
 get_cursor_pos = Win32API.new(""user32"", ""GetCursorPos"", ['P'], 'V')
  
 lpPoint = "" "" * 8 # store two LONGs 
  
 get_cursor_pos.Call(lpPoint) 
  
 x, y = lpPoint.unpack(""LL"") # get the actual values
  
 print ""x: "", x, ""\n"" 
  
 print ""y: "", y, ""\n""
  
 ods = Win32API.new(""kernel32"", ""OutputDebugString"", ['P'], 'V') ods.Call(""Hello, 
 World\n"")
  
 GetDesktopWindow = Win32API.new(""user32"", ""GetDesktopWindow"", [], 'L') GetActiveWindow = 
 Win32API.new(""user32"", ""GetActiveWindow"", [], 'L') SendMessage = Win32API.new(""user32"", 
 ""SendMessage"", ['L'] * 4, 'L') SendMessage.Call(GetDesktopWindow.Call, 274, 0xf140, 0)",NA
W,"in32API
  
  
 Prepared exclusively for Yeganefar",NA
 WIN32OLE,"Windows Automation
  
  
 Only if:
  Windows
  
 Interface to Windows automation, allowing Ruby code to interact with Windows appli-
  
 cations. The Ruby interface to Windows is discussed in more detail in Chapter
  20
  on 
 page
  253
 .
  
 See also:
  Win32API
  (page
  734
 )
  
 • Open Internet Explorer, and ask it to display our home page.
  
 ie = WIN32OLE.new('InternetExplorer.Application') 
  
 ie.visible = true 
  
 ie.navigate(""http://www.pragmaticprogrammer.com"")
  
 • Create a new chart in Microsoft Excel, and then rotate it.
  
 require 'win32ole'
  
 #-4100 is the value for the Excel constant xl3DColumn. 
  
 ChartTypeVal = -4100;
  
 excel = WIN32OLE.new(""excel.application"")
  
 # Create and rotate the chart
  
 excel['Visible'] = TRUE
  
 excel.Workbooks.Add() 
  
 excel.Range(""a1"")['Value'] = 3 
  
 excel.Range(""a2"")['Value'] = 2 
  
 excel.Range(""a3"")['Value'] = 1
  
 excel.Range(""a1:a3"").Select()
  
 excelchart = excel.Charts.Add() 
  
 excelchart['Type'] = ChartTypeVal
  
 30.step(180, 5) do |rot| 
  
 excelchart.rotation = rot 
  
 sleep(0.1) 
  
 end
  
 excel.ActiveWorkbook.Close(0) 
  
 excel.Quit()",NA
W,"IN32OLE
  
  
 Prepared exclusively for Yeganefar",NA
 XMLRPC,"Remote Procedure Calls using XML-RPC
  
 XMLRPC
  allows clients to invoke methods on networked servers using the XML-RPC 
 protocol. Communications take place over HTTP. The server may run in the context 
 of a Web server, in which case ports 80 or 443 (for SSL) will typically be used. The 
 server may also be run stand-alone. The Ruby XML-RPC server implementation 
 supports operation as a CGI script, as a
  mod_ruby
  script, as a WEBrick handler, and as 
 a stand-alone server. Basic authentification is supported, and clients can communicate 
 with servers via proxies. Servers may throw
  FaultException
  errors—these generate the 
 corresponding exception on the client (or optionally may be flagged as a status return 
 to the call).
  
 See also:
  SOAP
  (page
  236
 ),
  dRuby
  (page
  649
 ),
  WEBrick
  (page
  733
 )
  
 • The following simple server accepts a temperature in Celsius and converts it to 
  
 Fahrenheit. It runs within the context of the WEBrick Web server.
  
 require 'webrick' 
  
 require 'xmlrpc/server'
  
 xml_servlet = XMLRPC::WEBrickServlet.new 
  
 xml_servlet.add_handler(""convert_celcius"") do |celcius| 
  
 celcius*1.8 + 32 
  
 end
  
 xml_servlet.add_multicall # Add support for multicall
  
 server = WEBrick::HTTPServer.new(:Port => 2000) 
  
 server.mount(""/RPC2"", xml_servlet) 
  
 trap(""INT""){ server.shutdown } 
  
 server.start
  
 • This client makes calls to the temperature conversion server. Note that in the out-
  
 put we show both the server’s logging and the client program’s output.
  
 require 'xmlrpc/client'
  
 server = XMLRPC::Client.new(""localhost"", ""/RPC2"", 2000)
  
 puts server.call(""convert_celcius"", 0) 
  
 puts server.call(""convert_celcius"", 100)
  
 puts server.multicall(['convert_celcius', -10], 
  
 ['convert_celcius', 200])",NA
X,"MLRPC
  
  
 produces: 
  
 [2004-04-16 06:57:02] INFO [2004-
 04-16 06:57:02] INFO
  
 WEBrick 1.3.1 
  
 WEBrick::HTTPServer#start: pid=11956 port=2000
  
 localhost - - [16/Apr/2004:06:57:13 PDT] ""POST /RPC2 HTTP/1.1"" 200 124 - -> /RPC2 32.0 
  
 localhost - - [16/Apr/2004:06:57:13 PDT] ""POST /RPC2 HTTP/1.1"" 200 125 - -> /RPC2 212.0 
  
 localhost - - [16/Apr/2004:06:57:14 PDT] ""POST /RPC2 HTTP/1.1"" 200 290 - -> /RPC2 14.0 
  
 392.0
  
 Prepared exclusively for Yeganefar",NA
 YAML,"Object Serialization/Deserialization
  
 The
  YAML
  library (also described in the tutorial starting on page
  397
 ) serializes and 
 deserializes Ruby object trees to and from an external, readable, plain-text format. 
 YAML can be used as a portable object marshaling scheme, allowing objects to be 
 passed in plain text between separate Ruby processes. In some cases, objects may 
 also be exchanged between Ruby programs and programs in other languages that also 
 have YAML support.
  
 • YAML can be used to store an object tree in a flat file.
  
 require 'yaml' 
  
 tree = { :name => 'ruby', 
  
  
 :uses => [ 'scripting', 'web', 'testing', 'etc' ] 
  
 }
  
 File.open(""tree.yaml"", ""w"") {|f| YAML.dump(tree, f)}
  
 • Once stored, it can be read by another program.
  
 require 'yaml' 
  
 tree = YAML.load(File.open(""tree.yaml""))
  
 tree[:uses][1]
  
 →
  
 ""web""
  
 • The YAML format is also a convenient way to store configuration information 
 for programs. Because it is readable, it can be maintained by hand using a 
 normal editor, and then read as objects by programs. For example, a 
 configuration file may contain
  
 ---
  
 username: dave 
  
 prefs: 
  
 background: dark 
  
 foreground: cyan 
  
 timeout: 30
  
 We can use this in a program:
  
 require 'yaml'
  
 config = YAML.load(File.open(""code/config.yaml""))
  
 config[""username""]
  
 →
  
 ""dave""",NA
Y,"AML
  
 config[""prefs""][""timeout""] * 10
  
 →
  
 300
  
  
 Prepared exclusively for Yeganefar",NA
 Zlib,"Read and Write Compressed Files
  
  
 Only if:
  zlib library
  
 The
  Zlib
  module is home to a number of classes that can read and write zip- and
  
 available
  
 gzip-format compressed files. They also calculate zip checksums.
  
 • Compress
  /etc/passwd
  as a gzip file, and then read the result back.
  
 require 'zlib'
  
 # These methods can take a filename 
  
 Zlib::GzipWriter.open(""passwd.gz"") do |gz| 
  
 gz.write(File.read(""/etc/passwd"")) 
  
 end
  
 system(""ls -l /etc/passwd passwd.gz"")
  
 # or a stream 
  
 File.open(""passwd.gz"") do |f| 
  
 gzip = Zlib::GzipReader.new(f) 
  
 data = gzip.read.split(/\n/) 
  
 puts data[15,3] 
  
 end
  
 produces:
  
 -rw-r--r--
  
 1 root
  
 wheel
  
 1374 12 Sep
  
 2003 /etc/passwd
  
 -rw-r--r--
  
 1 dave
  
 dave
  
 635 26 Aug 22:39 passwd.gz
  
 daemon:*:1:1:System Services:/var/root:/usr/bin/false 
  
 smmsp:*:25:25:Sendmail User:/private/etc/mail:/usr/bin/false lp:*:26:26:Printing 
 Services:/var/spool/cups:/usr/bin/false
  
 • Compress data sent between two processes.
  
 require 'zlib'
  
 rd, wr = IO.pipe
  
 if fork 
  
 rd.close 
  
 zipper = Zlib::Deflate.new 
  
 zipper << ""This is a string "" 
  
 data = zipper.deflate(""to compress"", Zlib::FINISH) 
  
 wr.write(data) 
  
 wr.close 
  
 Process.wait 
  
 else 
  
 wr.close
  
 unzipper = Zlib::Inflate.new 
  
 unzipper << rd.read 
  
 puts ""We got: #{unzipper.inflate(nil)}""",NA
Z,"lib
  
 end
  
 produces:
  
 We got: This is a string to compress
  
 Prepared exclusively for Yeganefar",NA
Part V,NA,NA
Appendixes,"Prepared exclusively for Yeganefar
  
 739",NA
Appendix A,NA,NA
Socket Library,"Because the socket and network libraries are such important parts of integrating Ruby 
 applications with the ’net, we’ve decided to document them in more detail than the 
 other standard libraries.
  
 The hierarchy of socket classes is shown in the diagram below.
  
 IO
  
 BasicSocket 
  
  
  
 IPSocket 
  
  
  
 TCPSocket 
  
  
  
  
 SOCKSSocket 
  
  
  
  
 TCPServer 
  
  
  
 UDPSocket 
  
  
  
 Socket 
  
  
  
 UNIXSocket
  
 Prepared exclusively for Yeganefar
  
  
 UNIXServer
  
 740",NA
BasicSocket,"<
  
 IO
  
 B
 ASIC
 S
 OCKET
  
 741
  
 BasicSocket
  is an abstract base class for all other socket classes.
  
 This class and its subclasses often manipulate addresses using something called a 
 struct 
 sockaddr
 , which is effectively an opaque binary string.
 1
  
 Class methods
  
 do_not_reverse_lookup
  
 BasicSocket.do_not_reverse_lookup
  →
  true
  or
  false
  
 Returns the value of the global reverse lookup flag.
  
 do_not_reverse_lookup=
  
 BasicSocket.do_not_reverse_lookup =
  true
  or
  false
  
 Sets the global reverse lookup flag. If set to
  true
 , queries on remote addresses will 
 return the numeric address but not the host name.
  
 for_fd
  
 BasicSocket.for_fd(
  fd
  )
  →
  sock
  
 Wraps an already open file descriptor into a socket object.
  
 lookup_order=
  
 BasicSocket.lookup_order =
  int
  
 Sets the global address lookup order.
  
 Instance methods
  
 close_read
  
 sock
 .close_read
  →
  nil
  
 Closes the readable connection on this socket.
  
 close_write
  
 sock
 .close_write
  →
  nil
  
 Closes the writable connection on this socket.
  
 getpeername
  
 sock
 .getpeername
  →
  string
  
 Returns the
  struct sockaddr
  structure associated with the other end of this socket
  
 connection.
  
 getsockname
  
 sock
 .getsockname
  →
  string
  
 Returns the
  struct sockaddr
  structure associated with
  sock
 .
  
 getsockopt
  
 sock
 .getsockopt(
  level
 ,
  optname
  )
  →
  string
  
 Returns the value of the specified option.
  
 1.
  
 In reality, it maps onto the underlying C-language
  struct sockaddr
  set of structures, documented in
  
 the man pages and in the books by Stevens.
  
 Prepared exclusively for Yeganefar",NA
Socket,"<
  
 BasicSocket
  
 S
 OCKET
  
 743
  
 Class
  Socket
  provides access to the underlying operating system socket implementa-
 tion. It can be used to provide more operating system–specific functionality than the 
 protocol-specific socket classes but at the expense of greater complexity. In particu-
 lar, the class handles addresses using
  struct sockaddr
  structures packed into Ruby 
 strings, which can be a joy to manipulate.
  
 Class constants
  
 Class
  Socket
  defines constants for use throughout the socket library. Individual con-
 stants are available only on architectures that support the related facility.
  
 Types: 
  
  
 SOCK_DGRAM
 ,
  SOCK_PACKET
 ,
  SOCK_RAW
 ,
  SOCK_RDM
 ,
  SOCK_SEQPACKET
 ,
  SOCK_STREAM 
 Protocol families: 
  
  
 PF_APPLETALK
 ,
  PF_AX25
 ,
  PF_INET6
 ,
  PF_INET
 ,
  PF_IPX
 ,
  PF_UNIX
 ,
  PF_UNSPEC 
  
 Address families: 
  
  
 AF_APPLETALK
 ,
  AF_AX25
 ,
  AF_INET6
 ,
  AF_INET
 ,
  AF_IPX
 ,
  AF_UNIX
 ,
  AF_UNSPEC 
  
 Lookup-order options: 
  
  
 LOOKUP_INET6
 ,
  LOOKUP_INET
 ,
  LOOKUP_UNSPEC 
  
 Send/receive options: 
  
  
 MSG_DONTROUTE
 ,
  MSG_OOB
 ,
  MSG_PEEK 
  
 Socket-level options: 
  
  
 SOL_ATALK
 ,
  SOL_AX25
 ,
  SOL_IPX
 ,
  SOL_IP
 ,
  SOL_SOCKET
 ,
  SOL_TCP
 ,
  SOL_UDP 
  
 Socket options: 
  
  
 SO_BROADCAST
 ,
  SO_DEBUG
 ,
  SO_DONTROUTE
 ,
  SO_ERROR
 ,
  SO_KEEPALIVE
 ,
  SO_LINGER
 , 
  
 SO_NO_CHECK
 ,
  SO_OOBINLINE
 ,
  SO_PRIORITY
 ,
  SO_RCVBUF
 ,
  SO_REUSEADDR
 ,
  SO_SNDBUF
 , 
  
 SO_TYPE 
  
 QOS options: 
  
  
 SOPRI_BACKGROUND
 ,
  SOPRI_INTERACTIVE
 ,
  SOPRI_NORMAL 
  
 Multicast options: 
  
  
 IP_ADD_MEMBERSHIP
 ,
  IP_DEFAULT_MULTICAST_LOOP
 ,
  IP_DEFAULT_MULTICAST_TTL
 , 
  
 IP_MAX_MEMBERSHIPS
 ,
  IP_MULTICAST_IF
 ,
  IP_MULTICAST_LOOP
 ,
  IP_MULTICAST_TTL 
 TCP 
 options: 
  
  
 TCP_MAXSEG
 ,
  TCP_NODELAY
  
 Prepared exclusively for Yeganefar",NA
IPSocket,"<
  
 BasicSocket
  
 IPS
 OCKET
  
 747
  
 Class
  IPSocket
  is a base class for sockets using IP as their transport.
  TCPSocket
  and
  
 UDPSocket
  are based on this class.
  
 Class methods
  
 getaddress
  
 IPSocket.getaddress(
  hostname
  )
  →
  string
  
 Returns the dotted-quad IP address of
  hostname
 .
  
 a = IPSocket.getaddress('www.ruby-lang.org')
  
 a
  
 →
  
 ""210.251.121.210""
  
 Instance methods
  
 addr
  
 sock
 .addr
  →
  array 
 Returns the domain, port, name, and IP address of
  sock
  as a four-element array. The
  
 name will be returned as an address if the
  do_not_reverse_lookup
  flag is
  true
 .
  
 u = UDPSocket.new
  
 u.bind('localhost', 8765)
  
 u.addr
  
 →
  
 [""AF_INET"", 8765, ""localhost"", ""127.0.0.1""]
  
 BasicSocket.do_not_reverse_lookup = true
  
 u.addr
  
 →
  
 [""AF_INET"", 8765, ""127.0.0.1"", ""127.0.0.1""]
  
  
  
 peeraddr
  
 sock
 .peeraddr
  →
  array
  
 Returns the domain, port, name, and IP address of the peer.
  
 recvfrom
  
 sock
 .recvfrom(
  len
  ⟨
  ,
  flags
  ⟩
  )
  →
  [
  data
 ,
  sender
  ]
  
 Receives up to
  len
  bytes on the connection.
  flags
  is zero or more of the
  MSG_
  options
  
 1.8
  
  
 (listed on page
  743
 ). Returns a two-element array. The first element is the received 
 data, and the second is an array containing information about the peer. On systems
  
 such as my Mac OS X box where the native
  recvfrom()
  method does not return peer
  
 information for TCP connections, the second element of the array is
  nil
 .
  
 require 'socket'
  
 t = TCPSocket.new('localhost', 'ftp')
  
 data = t.recvfrom(40)
  
 data
  
 →
  
 [""220 localhost FTP server (lukemftpd 1.1)"", nil]
  
 t.close
  
 →
  
 nil
  
  
 Prepared exclusively for Yeganefar",NA
TCPSocket,"<
  
 IPSocket
  
 TCPS
 OCKET
  
 748
  
 t = TCPSocket.new('localhost', 'ftp')
  
 t.gets
  
 →
  
 ""220 localhost FTP server (lukemftpd 1.1) ready.\r\n""
  
 t.close
  
 →
  
 nil
  
 Class methods
  
 gethostbyname
  
 TCPSocket.gethostbyname(
  hostname
  )
  →
  array
  
 Looks up
  hostname
  and returns its canonical name, an array containing any aliases, 
 the
  
 address type (
 AF_INET
 ), and the dotted-quad IP address.
  
 a = TCPSocket.gethostbyname('ns.pragprog.com')
  
  
 a
  
 →
  
 [""pragprog.com"", [], 2, ""216.87.136.211""]
  
 new
  
  
 TCPSocket.new(
  hostname
 ,
  port
  )
  →
  sock 
 Opens a TCP connection to
  hostname
  on the
  port
 .
  
  
 open
  
 Synonym for
  TCPSocket.new
 .
  
 TCPSocket.open(
  hostname
 ,
  port
  )
  →
  sock
  
  
  
 Prepared exclusively for Yeganefar",NA
SOCKSSocket,"<
  
 TCPSocket
  
 SOCKSS
 OCKET
  
 749
  
 Class
  SOCKSSocket
  supports connections based on the SOCKS protocol.
  
 Class methods
  
 new
  
 SOCKSSocket.new(
  hostname
 ,
  port
  )
  →
  sock
  
  
 Opens a SOCKS connection to
  port
  on
  hostname
 .
  
 open
  
 Synonym for
  SOCKSSocket.new
 .
  
 SOCKSSocket.open(
  hostname
 ,
  port
  )
  →
  sock
  
  
 Instance methods
  
 close
  
 Closes this SOCKS connection.
  
 sock
 .close
  →
  nil
  
  
 Prepared exclusively for Yeganefar",NA
TCPServer,"<
  
 TCPSocket
  
 TCPS
 ERVER
  
 750
  
 A
  TCPServer
  accepts incoming TCP connections. Here is a Web server that listens on a 
 given port and returns the time.
  
 require 'socket' 
  
 port = (ARGV[0] || 80).to_i 
  
 server = TCPServer.new('localhost', port) 
  
 while (session = server.accept) 
  
 puts ""Request: #{session.gets}"" 
  
 session.print ""HTTP/1.1 200/OK\r\nContent-type: text/html\r\n\r\n"" session.print 
 ""<html><body><h1>#{Time.now}</h1></body></html>\r\n"" session.close 
  
 end
  
 Class methods
  
 new
  
 TCPServer.new(
  ⟨
  hostname
 ,
  ⟩
  port
  )
  →
  sock
  
 Creates a new socket on the given interface (identified by
  hostname
  and port). If
  host-
 name
  is omitted, the server will listen on all interfaces on the current host (equivalent 
 to an address of 0.0.0.0).
  
 open
  
 TCPServer.open(
  ⟨
  hostname
 ,
  ⟩
  port
  )
  →
  sock
  
 Synonym for
  TCPServer.new
 .
  
 Instance methods
  
 accept
  
 sock
 .accept
  →
  tcp_socket 
 Waits for a connection on
  sock
 , and returns a new
  tcp_socket
  connected to the caller.
  
 See the example on the current page.
  
 Prepared exclusively for Yeganefar",NA
UDPSocket,"<
  
 IPSocket
  
 UDPS
 OCKET
  
 751
  
 UDP sockets send and receive datagrams. To receive data, a socket must be bound to 
 a particular port. You have two choices when sending data: you can connect to a 
 remote UDP socket and thereafter send datagrams to that port, or you can specify a 
 host and port for use with every packet you send. This example is a UDP server that 
 prints the message it receives. It is called by both connectionless and connection-
 based clients.
  
 require 'socket'
  
 $port = 4321
  
 server_thread = Thread.start do server = 
 UDPSocket.open 
  
 server.bind(nil, $port)
  
 # run server in a thread
  
 2.times { p server.recvfrom(64) } 
  
 end
  
 # Ad-hoc client 
  
 UDPSocket.open.send(""ad hoc"", 0, 'localhost', $port)
  
 # Connection based client 
  
 sock = UDPSocket.open 
  
 sock.connect('localhost', $port) 
  
 sock.send(""connection-based"", 0) 
  
 server_thread.join
  
 produces:
  
 [""ad hoc"", [""AF_INET"", 52097, ""localhost"", ""127.0.0.1""]] 
  
 [""connection-based"", [""AF_INET"", 52098, ""localhost"", ""127.0.0.1""]]
  
 Class methods
  
 new
  
 UDPSocket.new(
  family
  =
  AF_INET
  )
  →
  sock
  
  
 Creates a UDP endpoint, optionally specifying an address family.
  
 open
  
 UDPSocket.open(
  family
  =
  AF_INET
  )
  →
  sock
  
 Synonym for
  UDPSocket.new
 .
  
 Instance methods
  
 bind
  
 sock
 .bind(
  hostname
 ,
  port
  )
  →
  0 
 Associates the local end of the UDP connection with a given
  hostname
  and
  port
 . 
 Must
  
 be used by servers to establish an accessible endpoint.
  
 connect
  
 sock
 .connect(
  hostname
 ,
  port
  )
  →
  0
  
 Creates a connection to the given
  hostname
  and
  port
 . Subsequent
  UDPSocket
 #
 send
  
 requests that don’t override the recipient will use this connection. Multiple
  connect 
 requests may be issued on
  sock
 : the most recent will be used by
  send
 .",NA
UNIXSocket,"<
  
 BasicSocket
  
 UNIXS
 OCKET
  
 753
  
 Class
  UNIXSocket
  supports interprocess communications using the Unix domain pro-
 tocol. Although the underlying protocol supports both datagram and stream connec-
 tions, the Ruby library provides only a stream-based connection.
  
 require 'socket' 
  
 SOCKET = ""/tmp/sample"" 
  
 server_thread = Thread.start do 
  
 # run server in a thread sock = 
 UNIXServer.open(SOCKET) 
  
 s1 = sock.accept 
  
 p s1.recvfrom(124) 
  
 end 
  
 client = UNIXSocket.open(SOCKET) 
  
 client.send(""hello"", 0) 
  
 client.close 
  
 server_thread.join 
  
 produces: 
  
 [""hello"", [""AF_UNIX"", ""q\240""]]
  
 Class methods
  
 new
  
 UNIXSocket.new(
  path
  )
  →
  sock
  
  
 Opens a new domain socket on
  path
 , which must be a pathname.
  
 open
  
 UNIXSocket.open(
  path
  )
  →
  sock
  
 Synonym for
  UNIXSocket.new
 .
  
 Instance methods
  
 addr
  
 sock
 .addr
  →
  array
  
 Returns the address family and path of this socket.
  
 path
  
 sock
 .path
  →
  string
  
 Returns the path of this domain socket.
  
 peeradd
 r
  
 sock
 .peeraddr
  →
  array
  
 Returns the address family and path of the server end of the connection.
  
  
 sock
 .recvfrom(
  len
  ⟨
  ,
  flags
  ⟩
  )
  →
  array
  
 recvfro
 m
  
 Receives up to
  len
  bytes from
  sock
 .
  flags
  is zero or more of the
  MSG_
  options (listed 
 on page
  743
 ). The first element of the returned array is the received data, and the 
 second contains (minimal) information on the sender.
  
 Prepared exclusively for Yeganefar",NA
UNIXServer,"<
  
 UNIXSocket
  
 UNIXS
 ERVER
  
 754
  
 Class
  UNIXServer
  provides a simple Unix domain socket server. See
  UNIXSocket
  for 
 example code.
  
 Class methods
  
 new
  
 UNIXServer.new(
  path
  )
  →
  sock 
 Creates a server on the given
  path
 . The corresponding file must not exist at the time 
 of
  
 the call.
  
 open
  
 Synonym for
  UNIXServer.new
 .
  
 UNIXServer.open(
  path
  )
  →
  sock
  
 Instance methods
  
 accept
  
 sock
 .accept
  →
  unix_socket 
 Waits for a connection on the server socket and returns a new socket object for that
  
 connection. See the example for
  UNIXSocket
  on the page before.",NA
U,"NIXServer
  
  
 Prepared exclusively for Yeganefar",NA
Appendix B,NA,NA
MKMF Reference,"The
  mkmf
  library is used by Ruby extension modules to help create
  Makefiles
 . Chapter 
 21
 , which starts on page
  261
 , describes how these extensions are created and built. 
 This appendix describes the details of the
  mkmf
  library.
  
 Module",NA
 mkmf,require,NA
" ""mkmf""","When writing an extension, you create a program named
  extconf.rb
 , which may be as 
 simple as
  
 require 'mkmf' 
  
 create_makefile(""Test"")
  
 When run, this script will produce a Makefile suited to the target platform. It also 
 produces a log file,
  mkmf.log
 , which may help in diagnosing build problems.
  
 mkmf
  contains several methods you can use to find libraries and include files and to set 
 compiler flags.
  
 mkmf
  takes configuration information from a variety of sources
  
 • The configuration used when Ruby was built.
  
 • The environment variable
  CONFIGURE_ARGS
 , a list of
  key=value
  pairs.
  
 • Command line arguments of the form
  key=value
  or
  --key=value
 .
  
 You can examine the configuration by dumping the variable
  $configure_args
 .
  
 % export CONFIGURE_ARGS=""ruby=ruby18 --enable-extras"" 
  
 % ruby -rmkmf -rpp -e 'pp $configure_args'
  
 -- --with-cflags=-O3 {""--
 topsrcdir""=>""."", 
  
 ""--topdir""=>""/Users/dave/Work/rubybook/tmp"", 
  
 ""--enable-extras""=>true, 
  
 ""--with-cflags""=>""-O3"", 
  
 ""--ruby""=>""ruby18""}
  
 Prepared exclusively for Yeganefar 
 755",NA
M,"kmf
  
 srcdir 
  
  
 Sets the path to the source directory in the 
 Makefile.
  
 with-cflags 
  
  
 Flags passed to the C compiler. Overrides the
  CFLAGS
  environment variable.
  
 with-cppflags 
  
  
 Flags passed to the C++ compiler. Overrides the
  CPPFLAGS
  environment variable.
  
 with-ldflags 
  
  
 Flags passed to the linker compiler. Overrides the
  LDFLAGS
  environment variable.
  
 with-make-prog 
  
 Sets the name of the make program. If running on Windows, the choice of make 
 program affects the syntax of the generated Makefile (
 nmake
  vs. Borland
  make
 ).
  
 with-xxx-{dir|include|lib} 
  
  
 Controls where the
  dir_config
  method looks.",NA
M,"find_library
  
  
 find_library(
  name
 ,
  function
 ,
  ⟨
  path
  ⟩
 +
 )
  →
  true
  or
  false
  
  
 Same as
  have_library
 , but will also search in the given directory paths.
  
 have_func
  
 have_func(
  function
  )
  →
  true
  or
  false
  
 If the named function exists in the standard compile environment, adds the directive
  
 -D HAVE_
 FUNCTION
  to the compile command in the Makefile and returns
  true
 .
  
 have_header
  
 have_header(
  header
  )
  →
  true
  or
  false
  
 If the given header file can be found in the standard search path, adds the directive
  
 -D HAVE_
 HEADER
  to the compile command in the Makefile and returns
  true
 .
  
 have_library
  
 have_library(
  library
 ,
  function
  )
  →
  true
  or
  false
  
 If the given function exists in the named library, which must exist in the standard 
 search
  
 path or in a directory added with
  dir_config
 , adds the library to the link command in the 
 Makefile and returns
  true
 .
  
 Prepared exclusively for Yeganefar",NA
Appendix C,NA,NA
Support,"One of the major features of open source projects is the technical support. Articles in 
 the mass media often criticize open source efforts for not having the same tech 
 support that a commercial product has. And boy is that a good thing! Instead of 
 dialing up some overworked and understaffed help desk and being treated to Music 
 On Hold for an hour or so
  without
  ever getting the answer you need, we have a better 
 solution: the Ruby community. The author of Ruby, the authors of this book, and 
 many other Ruby users are willing and able to lend you a hand, should you need it.
  
 The syntax of Ruby remains fairly stable, but as with all evolving software, new fea-
 tures are added every now and again. As a result, both printed books and the online 
 documentation can fall behind. All software has bugs, and Ruby is no exception. 
 There aren’t many, but they do crop up.
  
 If you experience a problem with Ruby, feel free to ask in the mailing lists or on the 
 newsgroup (more on those in just a minute). Generally you’ll get timely answers from 
 Matz himself, the author of the language, from other gurus, and from those who’ve 
 solved problems similar to your own.
  
 You may be able to find similar questions in the mailing lists or on the newsgroup, 
 and it is good “netiquette” to read through recent postings before asking. If you can’t 
 find the answer you need, ask, and a correct answer will usually show up with 
 remarkable speed and precision.",NA
Web Sites,"Because the Web changes too fast, we’ve kept this list short. Visit one of the sites here, 
 and you’ll find a wealth of links to other online Ruby resources.
  
 The official Ruby home page is
  http://www.ruby-lang.org
 .
  
 Prepared exclusively for Yeganefar 
 758",NA
Download Sites,"You can download the latest version of Ruby from
  
 http://www.ruby-lang.org/en/
  
 A precompiled Windows distribution is available from
  
 http://rubyinstaller.rubyforge.org/
  
 This project is also planning to release a Mac OS X One-Click Installer, but this was 
 not ready at the time this book went to press.",NA
Usenet Newsgroup,"Ruby has its own newsgroup,
  comp.lang.ruby
 . Traffic on this group is archived and 
 mirrored to the
  ruby-talk
  mailing list.",NA
Mailing Lists,"You’ll find many mailing lists talking about Ruby. The first three below are in English, 
 and the remainder are mostly Japanese, but with some English language posts.
  
 Prepared exclusively for Yeganefar",NA
Appendix D,NA,NA
Bibliography,"[FJN02]
  
 Robert Feldt, Lyle Johnson, and Micheal Neuman.
  The Ruby 
 Developer’s
  
 Guide
 . Syngress Publishing, Inc, Rockland, MA, 2002.
  
 [Fri02] 
  
 Jeffrey E. F. Friedl.
  Mastering Regular Expressions: Powerful 
 Techniques 
  
 for Perl and Other Tools
 . O’Reilly & Associates, Inc., Sebastopol, CA, 
  
 second edition, 2002.
  
 [Ful01] 
  
 Hal Fulton.
  The Ruby Way
 . Sams Publishing, 2001.
  
 [GHJV95] 
  
 Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
  Design 
  
 Patterns: Elements of Reusable Object-Oriented Software
 . Addison-Wes-
  
 ley, Reading, MA, 1995.
  
 [Lid98] 
  
 Stephen Lidie.
  Perl/Tk Pocket Reference
 . O’Reilly & Associates, Inc., 
  
 Sebastopol, CA, 1998.
  
 [Mey97] 
  
 Bertrand Meyer.
  Object-Oriented Software Construction
 . Prentice Hall, 
  
 Englewood Cliffs, NJ, second edition, 1997.
  
 [Wal99] 
  
 Nancy Walsh.
  Learning Perl/Tk: Graphical User Interfaces with Perl
 . 
  
 O’Reilly & Associates, Inc., Sebastopol, CA, 1999.
  
 Prepared exclusively for Yeganefar 
 761",NA
Index,"Order
  
 !
  
 ""
  
 Every built-in and library method described in this book is indexed at least twice, once under 
 the method’s name and again under the name of the class or module that contains it. These 
 entries have the method and class/module names in
  typewriter
  font and have the word method, 
 class, or module appended. If you want to know what methods class
  String
  contains, you can 
 look up“
 String
  class” in the index. If instead you want to know which classes and modules 
 support a method called
  index
 , look under “
 index
  method.” A bold page number for these 
 method listings shows the reference section entry.
  
 When a class or method name corresponds with a broader concept (such as String), we’ve 
 indexed the class separately from the concept.
  
 Symbols are sorted using ASCII collation. The table on the right may help those who haven’t yet 
 memorized the positions of the punctuation characters (shame on you all).
  
 # 
  
 $ 
  
 % 
  
 &
  
 ’
  
 (
  
 )
  
 * 
  
 + 
  
 ,
  
 -",NA
.,NA,NA
Symbols,"$-K
  321
  
 $~
  65, 73, 319, 516, 579–581
  
 /
  
  
  
 $-a
  320
  
 $1 to $9
  319
  
 :
  
 !
  (logical not)
  88
 ,
  326
  
 $-d
  321
  
 $1...$9
  65, 70, 311
  
 ;
  
 !=
  (not equal)
  89
  
 $-i
  321
  
 $0
  170, 320, 322
  
 !~
  (does not match)
  65
 ,
  89
  
 <
  
 $-l
  321
  
 $configure_args
  755
  
 #
  (comment)
  302
  
 =
  
 $-p
  321
  
 $DEBUG
  168, 321, 612, 616
  
 #!
  (shebang)
  6
  
 >
  
 $-v
  321
  
 $deferr
  320
  
 #{...}
  
 $-w
  321
  
 $defout
  320
  
 substitute in pattern
  66
 ,
  311
  
 ?
  
 $.
  319, 489
  
 $expect_verbose
  655
  
 substitute in string
  57
 ,
  306
  
 @
  
 $/
  168, 169, 319, 589
  
 $F
  168, 321
  
 $
  (global variable prefix)
  313
  
 $:
  117, 152, 168, 173, 290,
  
 $FILENAME
  321
  
 [
  
 $
  (in pattern)
  66
 ,
  309
  
 320
  
 $KCODE
  309, 638, 668
  
 $
  variables
  
 \
  
 $;
  168, 319
  
 $LOAD_PATH
  152, 168, 175,
  
 $!
  102, 319, 345, 347
  
 $<
  320
  
 209–211, 213, 216, 321
  
 ]
  
 $""
  117, 320
  
 $=
  309, 319
  
 $SAFE
  169, 299, 321, 380,
  
 $$
  320
  
 $>
  320
  
 554, 652
  
 ^ 
  
 _
  
 $&
  65, 319, 516
  
 $?
  83, 140, 142, 320, 323,
  
 $stderr
  320
  
 $*
  320, 502
  
 495, 510, 566, 570
  
 $stdin
  320
  
 `
  
 $+
  319
  
 $@
  319
  
 $stdout
  320
  
 $,
  319, 415, 505
  
 $\
  169, 319, 490, 505
  
 $'
  65, 319, 517
  
 {
  
 $-0
  319
  
 $_
  22, 89, 95, 168, 320, 327,
  
 $VERBOSE
  168, 169, 321,
  
 |
  
 $-F
  320
  
 489, 502
  
 513
  
 $-I
  321
  
 $`
  65, 319, 517
  
 English names
  318
 ,
  650
  
 }
  
 ~
  
 Prepared exclusively for Yeganefar 
 762",NA
A,"-a
  (Ruby option)
  168
 ,
  320
 ,
  321
  
 class
  Symbol
  610
  
 \B
  (in pattern)
  310
  
 ALLOC
  279
  
 \D
  (in pattern)
  310
  
 ALLOC_N
  279
  
 \G
  (in pattern)
  310
 ,
  311
  
 ALLOCA_N
  280
  
 \S
  (in pattern)
  310
  
 $-a
  variable 320
  
 allocate
  method
  
 \W
  (in pattern)
  310
  
 Abbrev
  module
  634
 ,
  702
  
 class
  Class
  425
  
 \Z
  (in pattern)
  310
  
 Abbreviations, calculating
  
 634
  
 Allocation
  273
  
 \\u2018
  (in substitution)
  71
  
 Abort
  see
  Exception
  
 Amrita
  
 \b
  (in pattern)
  310
  
 abort
  method
  
 templates
  228
  
 \d
  (in pattern)
  310
  
 module
  Kernel
  496
  
 Ancestor
  25
  
 \n
  (newline)
  12
 ,
  306
  
 module
  Process
  562
  
 ancestors
  method
  
 \s
  (in pattern)
  310
  
 abort_on_exception
  method
  
 class
  Module
  365
 ,
  386
 ,
  526
  
 \w
  (in pattern)
  310
  
 class
  Thread
  130
 ,
  612
 ,
  615
  
 and
  (logical and)
  88
 ,
  326
  
 \z
  (in pattern)
  310
  
 abort_on_exception=
  method
  
 Anonymous class
  365
 ,
  424
  
 ^
  (in pattern)
  66
 ,
  67
 ,
  309
  
 class
  Thread
  612
 ,
  615
  
 any?
  method
  
 ^
  method
  
 abs
  method
  
 module
  Enumerable
  433
  
 class
  Bignum
  420
  
 class
  Bignum
  421
  
 Aoki, Minero
  106
  
 class
  FalseClass
  443
  
 class
  Fixnum
  464
  
 Aoyama, Wakou
  72
  
 class
  Fixnum
  463
  
 class
  Float
  467
  
 Apache Web server
  230
  
 class
  NilClass
  540
  
 class
  Numeric
  541
  
 mod_ruby
  234
  
 class
  TrueClass
  629
  
 accept
  method
  
 API
  
 _ _id_ _
  method
  
 class
  Socket
  746
  
 Microsoft Windows
  254
 ,
  734
  
 class
  Object
  546
  
 class
  TCPServer
  750
  
 Ruby
  see
  Extend Ruby
  
 _ _send_ _
  method
  
 class
  UNIXServer
  754
  
 APOP authentification
  681
  
 class
  Object
  546
  
 Access control
  35
 ,
  341
  
 append_features
  method
  
 _id2ref
  method
  
 method
  530
 ,
  532
 ,
  537
 ,
  538
  
 class
  Module
  533
  
 module
  ObjectSpace
  557
  
 overriding in subclass
  376
  
 ARGF
  constant
  170
  
 $`
  variable 65, 319, 517
  
 see also
  File, permission
  
 ARGF
  variable 22, 321
  
 ` (backquote)
  method
  
 Accessor method
  27
 ,
  86
  
 Argument, command-line
  see
  
 module
  Kernel
  83
 ,
  140
 ,
  495
  
 acos
  method
  
 Command line
  
 {...}
  
 module
  Math
  519
  
 Argument, method
  74
 ,
  75
  
 hash literal
  15
 ,
  307
  
 acosh
  method
  
 ARGV
  variable 168–170, 321,
  
 in pattern
  68
 ,
  310
  
 module
  Math
  519
  
 502, 663, 690
  
 see also
  Block
  
 ActiveX
  see
  Microsoft
  
 Arithmetic
  671
 ,
  700
  
 --verbose
  (Ruby option)
  514
  
 Windows, automation
  
 Arithmetic operations
  
 |
  
 Ad hoc testing
  143
  
 method
  
  
 Prepared exclusively for Yeganefar",NA
B ,"Backquote character
  see
  
 delete_at
  411
  
 asin
  method
  
 delete_if
  411
  
 module
  Math
  519
  
 each
  411
  
 asinh
  method
  
 each_index
  411
  
 module
  Math
  519
  
 `(backquote)
  
 empty?
  411
  
 ASP
  see
  eruby
  
 Backtrace
  
 see
  $@
 ,
  caller
  
 eql?
  411
  
 assert_equal
  method
  144
  
 backtrace
  method
  
 fetch
  412
  
 assert_not_nil
  method
  148
  
 class
  Exception
  440
  
 fill
  412
  
 Assertions
  see
  Test::Unit,
  
 Backup files, creating
  168
  
 first
  412
  
 assertions
  
 Base
  
 flatten
  412
  
 Assignment
  84
 ,
  323
  
 number
  422
 ,
  465
 ,
  601
  
 flatten!
  413
  
 attribute
  335
  
 Base (numeric)
  see
  to_s
  
 include?
  413
  
 parallel
  85
 ,
  325
  
 methods,
  
 index
  413
  
 assoc
  method
  
 Kernel.Integer
 ,
  
 indexes
  413
  
 class
  Array
  409
  
 String#to_i
  
 indices
  413
  
 Associative array
  see
  Hash
  
 Base64
  module
  635
  
 insert
  413
  
 Asynchronous I/O
  666
  
 base_uri
  method
  686
  
 join
  415
  
 at
  method
  
 basename
  method
  
 last
  415
  
 class
  Array
  409
  
 class
  File
  444
  
 length
  415
  
 class
  Time
  621
  
 BasicSocket
  class
  119
 ,
  714
 ,
  
 map!
  415
  
 at_exit
  method
  
 741
  
  
 Prepared exclusively for Yeganefar",NA
C,"-c
  (Ruby option)
  168
  
 getsockname
  741
  
 bind
  method
  
 getsockopt
  741
  
 class
  Socket
  746
  
 lookup_order=
  741
  
 class
  UDPSocket
  751
  
 recv
  742
  
 -C
  directory
  (Ruby option)
  
 class
  UnboundMethod
  631
  
 send
  742
  
 168
  
 Binding
  
 setsockopt
  742
  
 C language
  see
  Extend Ruby
  
 in block
  318
  
 shutdown
  742
  
 C language API
  
 GUI events
  246
  
 BEGIN {...}
  303
  
 ALLOC
  279
  
 Binding
  class
  322
 ,
  423
  
 begin
  method
  
 binding
  method
  
 ALLOC_N
  279
  
 class
  MatchData
  516
  
 ALLOCA_N
  280
  
 class
  Proc
  560
  
 class
  Range
  577
  
 Data_Get_Struct
  271
  
 module
  Kernel
  390
 ,
  423
 ,
  
 =begin...=end
  303
  
 497
  
 Data_Make_Struct
  271
  
 begin...end
  95
 ,
  102
 ,
  325
 ,
  346
  
 binmode
  method
  
 Data_Wrap_Struct
  271
  
 Benchmark
  module
  162
 ,
  390
 ,
  
 class
  IO
  486
  
 OBJ_FREEZE
  298
  
 636
  
 Bit operations
  method
  
 OBJ_FROZEN
  299
  
 Berger, Daniel
  259
  
 class
  Bignum
  420
  
 OBJ_TAINT
  298
  
 between?
  method
  
 class
  Fixnum
  463
  
 OBJ_TAINTED
  298
  
 module
  Comparable
  426
  
 blksize
  method
  
 rb_apply
  295
  
 BigDecimal
  class
  637
  
 class
  File::Stat
  456
  
 rb_ary_entry
  300
  
 BigMath
  module
  637
  
 Block
  19
 ,
  46
 ,
  341
  
 rb_ary_new
  299
  
 Bignum
  class
  55
 ,
  420
 ,
  463
 ,
  637
 ,
  
 break
  and
  next
  342
  
 rb_ary_new2
  299
  
 671
  
 as closure
  52
  
 rb_ary_new3
  299
  
 %
  420
  
 and files
  120
  
 rb_ary_new4
  299
  
 &
  420
  
 for busy cursor
  249
  
 rb_ary_pop
  299
  
 *
 420
  
 fork
 ,
  popen
 , and subprocess
  
 rb_ary_push
  299
  
 142
 ,
  485
 ,
  504
 ,
  687
  
 rb_ary_shift
  299
  
 **
 420
  
 with method
  389
  
 rb_ary_store
  299
  
 +
  420
  
 -
  420
  
 as parameter to method
  75
 ,
  
 rb_ary_unshift
  300
  
 -@
  420
  
 333
 ,
  334
  
 rb_block_given_p
  297
  
 /
  420
  
 parameters
  19
 ,
  48
  
 rb_bug
  296
  
 <=>
  420
  
 return from
  344
  
 rb_call_super
  295
  
 <<
  420
  
 as transaction
  50
  
 rb_catch
  297
  
 ==
  420
  
 variable scope
  99
 ,
  128
 ,
  318
  
 rb_create_new_instance
  
 >>
  420
  
 see also
  Iterator
  
 295
  
 [ ]
  421
  
 block_given?
  method
  
 rb_cv_get
  298
  
 ^
  420
  
 module
  Kernel
  51
 ,
  334
 ,
  497
  
 rb_cv_set
  298
  
 |
  420
  
 blockdev?
  method
  
 rb_cvar_defined
  298
  
 ~
  420
  
 class
  File::Stat
  456
  
 rb_cvar_get
  298
  
 abs
  421
  
 class
  File
  445
  
 rb_cvar_set
  298
  
 Arithmetic operations
  
 blocks
  method
  
 rb_define_alias
  293
  
 420
  
 class
  File::Stat
  457
  
 rb_define_alloc_func
  
 Bit operations
  420
  
 BlueCloth
  206
  
 293
  
 div
  421
  
 Boolean expressions
  326
  
 rb_define_attr
  295
  
 divmod
  421
  
 see also
  FalseClass
 ,
  
 rb_define_class
  291
  
 eql?
  421
  
 TrueClass
  
 rb_define_class_under
  
 literal
  55
 ,
  304
  
 Bottlenecks
  162
  
 291
  
  
 Prepared exclusively for Yeganefar",NA
D,"-d
  (Ruby option)
  130
 ,
  321
 ,
  514
  
 Delegator
  class
  646
  
 pwd
  431
  
 delete
  method
  
 read
  432
  
 class
  Array
  410
  
 rewind
  432
  
 -d, --debug
  (Ruby option)
  
 class
  Dir
  429
  
 rmdir
  431
  
 168
  
 class
  File
  445
  
 seek
  432
  
 $-d
  variable 321
  
 class
  Hash
  473
  
 tell
  432
  
 DATA
  constant
  303
 ,
  322
  
 class
  String
  590
 ,
  668
  
 tmpdir
  233
 ,
  727
  
 Data_Get_Struct
  271
  
 delete!
  method
  
 unlink
  431
  
 Data_Make_Struct
  271
  
 class
  String
  591
 ,
  668
  
 see also
  Find
  module
  
 Data_Wrap_Struct
  271
  
 delete_at
  method
  
 dir_config
  method
  
 Database
  see
  dbm, gdbm,
  
 class
  Array
  411
  
 module
  mkmf
  283
 ,
  757
  
 qdbm, sdbm
  
 delete_if
  method
  
 Directories
  
 Datagram
  see
  Network
  
 class
  Array
  411
  
 include and library for
  
 protocols, UDP
  
 class
  Hash
  474
  
 extensions
  283
  
 Date
  class
  644
  
 delete_observer
  method
  
 lib/
  282
  
 parsing
  692
  
 module
  Observable
  685
  
 pathname
  693
  
 see also
  Time
  class
  
 delete_observers
  method
  
 search path
  284
  
 Date
  module
  621
  
 module
  Observable
  685
  
 searched
  173
  
 DateTime
  class
  644
  
 Delimited string
  303
  
 temporary
  727
  
 day
  method
  
 Dependency, RubyGems
  203
  
 working
  168
  
 class
  Time
  623
  
 Design Pattern
  see
  Patterns
  
 directory?
  method
  
 DBM
  class
  645
  
 detach
  method
  
 class
  File::Stat
  457
  
 dbm
  645
  
 module
  Process
  562
  
 class
  File
  446
  
 DCOM
  see
  Microsoft
  
 detect
  method
  
 dirname
  method
  
 Windows, automation
  
 module
  Enumerable
  433
  
 class
  File
  446
  
  
 Prepared exclusively for Yeganefar",NA
E ,"E
  (Math constant)
  519
  
 else
  (exceptions)
  105
 ,
  347
  
 method
  
 see also
  if, case
  
 class
  BasicSocket
  741
  
 Emacs
  157
  
 do_not_reverse_lookup=
  
 tag file
  185
  
 method
  
 -e '
 command
 '
  (Ruby option)
  
 Emacs key binding
  702
  
 class
  BasicSocket
  741
  
 168
  
 E-mail
  
 :doc:
  (RDoc)
  194
  
 E-mail
  
 address for feedback
  xxii
  
 Document Type Definition
  704
  
 date/time formats
  724
  
 fetching with IMAP
  680
  
 Document-class:
  (RDoc)
  197
  
 each
  method
  651
  
 fetching with POP
  681
  
 Document-method:
  (RDoc)
  
 class
  Array
  411
  
 parsing
  670
  
 197
  
 class
  Dir
  431
  
 sending with SMTP
  682
  
 Documentation
  
 class
  Hash
  474
  
 Embed Ruby
  
 doc string example
  372
  
 class
  IO
  487
  
 in HTML etc.
  see
  eruby
  
 embedded
  187
 ,
  303
  
 class
  Range
  577
  
 interpreter in application
  287
  
 modifiers
  193
  
 class
  String
  591
  
 Embedded documentation
  187
 ,
  
 see also
  RDoc
  
 class
  Struct
  607
  
 303
  
 doGoogleSearch
  method
  238
  
 module
  Enumerable
  49
 ,
  433
  
 empty?
  method
  
 Domain Name System
  703
  
 each_byte
  method
  
 class
  Array
  411
  
 Dotted quad
  see
  Network
  
 class
  IO
  122
 ,
  487
  
 class
  Hash
  474
  
 protocols
  
 class
  String
  592
  
 class
  String
  592
  
 Double dispatch
  359
  
 each_cons
  method
  651
  
 enable
  method
  
 Double-quoted string
  57
 ,
  305
  
 each_index
  method
  
 module
  GC
  470
  
 downcase
  method
  
 class
  Array
  411
  
 enable-xxx (mkmf)
  756
  
 class
  String
  591
  
 each_key
  method
  
 enable_config
  method
  
 downcase!
  method
  
 class
  Hash
  474
  
 module
  mkmf
  757
  
 class
  String
  591
  
 each_line
  method
  
 enclose
  method
  
 Download
  
 class
  IO
  122
 ,
  488
  
 class
  ThreadGroup
  619
  
 Ruby
  2
  
 class
  String
  592
  
 enclosed?
  method
  
  
 Prepared exclusively for Yeganefar",NA
F,"693
  
 class
  IO
  655
 ,
  699
  
 atime
  444
 ,
  454
  
 $expect_verbose
  variable 655
  
 basename
  444
  
 Expression
  81
 –
 100
 ,
  323
 –
 330
  
 $F
  variable 168, 321
  
 blockdev?
  445
  
 boolean
  87
 ,
  326
  
 -F
  pattern
  (Ruby option)
  
 chardev?
  445
  
 case
  92
 ,
  328
  
 168
 ,
  319
  
 chmod
  445
 ,
  454
  
 if
  90
 ,
  328
  
 $-F
  variable 320
  
 chown
  445
 ,
  454
  
 range as boolean
  89
  
 Factory method
  34
  
 ctime
  445
 ,
  454
  
 substitution in string
  306
  
 fail
  method
  
 delete
  445
  
 ternary
  91
 ,
  328
  
 module
  Kernel
  106
 ,
  501
  
 directory?
  446
  
 extconf.rb
  263
 ,
  282
  
 FALSE
  constant
  322
  
 dirname
  446
  
 false
  constant
  87
 ,
  321
 ,
  326
  
 see also
  mkmf
  module
  
 executable?
  446
  
 FalseClass
  class
  443
  
 Extend Ruby
  261
 –
 301
 ,
  755
  
 executable_real?
  446
  
 &
  443
  
 allocation
  273
  
 exist?
  446
  
 ^
  443
  
 building extensions
  282
  
 exists?
  446
  
 |
  443
  
 see also
  mkmf
  module
  
 expand_path
  446
  
 Fcntl
  module
  488
 ,
  656
  
 call method API
  295
  
 extname
  446
  
 fcntl
  method
  
 clone and dup
  274
  
 file?
  447
  
 class
  IO
  488
  
 create object
  262
 ,
  273
  
 flock
  454
  
 FD (file descriptor)
  486
  
 data type conversion API
  
 fnmatch
  430
 ,
  447
  
 266
  
 Feedback, e-mail address
  xxii
  
 fnmatch?
  448
  
 data type wrapping API
  271
  
 fetch
  method
  
 ftools extension
  660
  
 define classes API
  291
  
 class
  Array
  412
  
 ftype
  448
  
 define methods API
  292
  
 class
  Hash
  475
  
 grpowned?
  448
  
  
 Prepared exclusively for Yeganefar",NA
G ,"Garbage collection
  353
 ,
  470
 ,
  
 module
  Process
  563
  
 class
  Float
  467
  
 getpgrp
  method
  
 class
  Integer
  480
  
 module
  Process
  563
  
 class
  Numeric
  544
  
 getpriority
  method
  
 557
 ,
  732
  
 flush
  method
  
 module
  Process
  564
  
 internals
  271
  
 class
  IO
  488
  
 gets
  method
  
 garbage_collect
  method
  
 FNM_
 xxx
  
 class
  IO
  489
  
 module
  GC
  470
  
 filename match constants
  
 module
  Kernel
  320
 ,
  502
  
 module
  ObjectSpace
  558
  
 447
  
 getservbyname
  method
  
 GC
  module
  470
  
 fnmatch
  method
  
 class
  Socket
  745
  
 class
  File
  430
 ,
  447
  
 disable
  470
  
 getsockname
  method
  
 fnmatch?
  method
  
 enable
  470
  
 class
  BasicSocket
  741
  
 class
  File
  448
  
 garbage_collect
  470
  
 getsockopt
  method
  
 for...in
  loop
  97
 ,
  329
 ,
  651
  
 start
  470
  
 class
  BasicSocket
  741
  
 for_fd
  method
  
 GDBM
  class
  661
  
 Getter method
  27
  
 class
  BasicSocket
  741
  
 gdbm
  645
 ,
  661
  
 getuid
  method
  
 class
  IO
  483
  
 Gelernter, David
  706
  
 module
  Process::Sys
  573
  
 foreach
  method
  
 Gem
  see
  RubyGems
  
 getutc
  method
  
 class
  Dir
  429
  
 gem_server
  208
  
 class
  Time
  624
  
 class
  IO
  123
 ,
  483
  
 gemspec
  212
 –
 214
  
 getwd
  method
  
 Fork
  see
  Process
  
 General delimited string
  303
  
 class
  Dir
  429
  
 fork
  method
  
 Generator
  class
  662
  
 gid
  method
  
 class
  Thread
  613
  
 Generator library
  50
  
 class
  File::Stat
  458
  
 module
  Kernel
  141
 ,
  142
 ,
  
 Geometry management
  246
  
 module
  Process
  564
  
 501
  
 get
  method
  678
  
 gid=
  method
  
 module
  Process
  563
  
 getaddress
  method
  
 module
  Process
  564
  
 format
  method
  
 class
  IPSocket
  747
  
 GIF
  246
 ,
  250
  
 module
  Kernel
  502
  
 getaddrinfo
  method
  
 Glob
  see
  File, expanding names
  
 Forms
  see
  CGI programming,
  
 class
  Socket
  744
  
 glob
  method
  
 forms
  
 getc
  method
  
 class
  Dir
  430
  
 Forms (Web)
  224
  
 class
  IO
  489
  
 Global variables
  see
  Variables
  
 Fortran, documentation 187n
  
 getegid
  method
  
 global_variables
  method
  
 Forwardable
  module
  659
  
 module
  Process::Sys
  573
  
 module
  Kernel
  502
  
 Forwarding
  646
 ,
  659
  
 geteuid
  method
  
 gm
  method
  
 Fowler, Chad
  xxiii
 ,
  203
  
 module
  Process::Sys
  573
  
 class
  Time
  621
  
 freeze
  method
  
 getgid
  method
  
 GMT
  621
  
 class
  Object
  162
 ,
  377
 ,
  548
  
 module
  Process::Sys
  573
  
 gmt?
  method
  
 class
  ThreadGroup
  620
  
 getgm
  method
  
 class
  Time
  624
  
 frexp
  method
  
 class
  Time
  624
  
 gmt_offset
  method
  
 module
  Math
  520
  
 gethostbyaddr
  method
  
 class
  Time
  624
  
 frozen?
  method
  
 class
  Socket
  744
  
 gmtime
  method
  
 class
  Object
  549
  
 gethostbyname
  method
  
 class
  Time
  624
  
 fsync
  method
  
 class
  Socket
  744
  
 gmtoff
  method
  
 class
  IO
  488
  
 class
  TCPSocket
  748
  
 class
  Time
  625
  
 ftools library
  660
  
 gethostname
  method
  
 GNU readline
  702
  
 FTP
  see
  Network protocols,
  
 class
  Socket
  744
  
 Google
  
 FTP
  
 getlocal
  method
  
 developer key
  238
  
 FTP site for Ruby
  2
  
 class
  Time
  624
  
 Web API
  238
  
 ftype
  method
  
 getnameinfo
  method
  
 WSDL
  239
  
  
 Prepared exclusively for Yeganefar",NA
I,"GServer
  class
  664
  
 gsub
  method
  
 key?
  476
  
 class
  String
  70
 ,
  311
 ,
  592
  
 keys
  476
  
 /i
  regexp option
  309
  
 module
  Kernel
  502
  
 length
  476
  
 -i [
 extension
 ]
  (Ruby option)
  
 gsub!
  method
  
 member?
  476
  
 168
 ,
  321
  
 class
  String
  311
 ,
  593
  
 merge
  476
  
 -I
  directories
  (Ruby option)
  
 module
  Kernel
  502
  
 merge!
  477
  
 168
 ,
  320
  
 GUI programming
  241
 –
 252
 ,
  
 new
  471
  
 $-I
  variable 321
  
 rehash
  308
 ,
  477
  
 726
  
 $-i
  variable 321
  
 callback from widget
  243
  
 reject
  477
  
 Ichikawa, Itaru
  684
  
 reject!
  477
  
 events
  246
  
 Iconv
  class
  665
  
 replace
  357
 ,
  477
  
 geometry management
  246
  
 id
  method
  
 select
  478
  
 scrolling
  249
  
 class
  Object
  549
  
 shift
  478
  
 widgets
  242
 –
 245
  
 id2name
  method
  
 size
  478
  
 GZip compression
  738
  
 class
  Fixnum
  464
  
 sort
  478
  
 class
  Symbol
  610",NA
H,"-h, --help
  (Ruby option)
  168
  
 store
  478
  
 Identifier
  
 to_a
  478
  
 object ID
  10
 ,
  386
  
 to_hash
  478
  
 see also
  Variable
  
 has_key?
  method
  
 to_s
  478
  
 IEEE floating point
  466
  
 class
  CGI
  225
  
 update
  479
  
 -I
 directories
  (Ruby option)
  
 class
  Hash
  475
  
 value?
  479
  
 173
  
 has_value?
  method
  
 values
  479
  
 if
  expression
  90
 ,
  328
  
 class
  Hash
  475
  
 values_at
  479
  
 as modifier
  91
 ,
  328
  
 Hash
  42
  
 Hash functions
  647
  
 IGNORECASE
  (Regexp constant)
  
 creating
  43
  
 hash
  method
  
 579
  
 default value
  16
  
 class
  Object
  549
  
 Igpay atinlay
  see
  Pig latin
  
 indexing
  43
  
 have_func
  method
  
 In-place edit mode
  168
  
 key requirements
  308
  
 module
  mkmf
  286
 ,
  757
  
 :include:
  (RDoc)
  194
  
 literal
  15
 ,
  307
  
 have_header
  method
  
 include
  method
  112
  
 as method parameter
  79
 ,
  333
  
 module
  mkmf
  285
 ,
  757
  
 class
  Module
  340
 ,
  535
  
 Hash
  class
  357
 ,
  471
  
 have_library
  method
  
 include?
  method
  
 ==
  472
  
 module
  mkmf
  285
 ,
  757
  
 class
  Array
  413
  
 [ ]
  471, 472
  
 head
  method
  678
  
 class
  Hash
  475
  
 [ ]=
  472
  
 Heading, RDoc
  193
  
 class
  Module
  528
  
  
 Prepared exclusively for Yeganefar",NA
J ,"JavaSpaces
  see
  Distributed
  
 gsub!
  502
  
 to_i
  494
  
 Integer
  357
 ,
  495
  
 to_io
  494
  
 iterator?
  503
  
 tty?
  494
  
 lambda
  53
 ,
  343
 ,
  345
 ,
  503
 ,
  
 Ruby
  
 ungetc
  494
  
 560
  
 jcode library
  668
  
 wait
  666
  
 load
  172
 ,
  320
 ,
  380
 ,
  503
  
 JINI
  see
  Distributed Ruby
  
 write
  494
  
 local_variables
  503
  
 JIS
  302
 ,
  665
 ,
  668
 ,
  684
  
 I/O
  119
 –
 126
  
 loop
  96
 ,
  503
  
 join
  method
  
 binary data
  123
  
 method_missing
  334
 ,
  362
  
 class
  Array
  415
  
 buffering problems
  161
  
 open
  126
 ,
  504
 ,
  686
  
 class
  File
  448
  
 see also
  classes
  File
 ,
  IO
 ,
  
 p
  505
  
 class
  Thread
  129
 ,
  615
  
 and Network Protocols
  
 pp
  694
  
 JSP
  see
  eruby
  
 io/wait library
  666
  
 print
  320
 ,
  505
  
 Jukebox example
  23
 –
 32
 ,
  52
 –
 54
 ,
  
 ioctl
  method
  
 printf
  320
 ,
  505
  
 270
 –
 279
  
 class
  IO
  489
  
 proc
  343
 ,
  345
 ,
  506
  
 Iowa, Web framework
  226",NA
K,"-K
  kcode
  (Ruby option)
  169
 ,
  
 putc
  506
  
 IP address representation
  667
  
 puts
  506
  
 IP, IPv4, IPv6
  see
  Network
  
 raise
  106
 ,
  345
 ,
  506
  
 protocols
  
 rand
  506
  
 321
  
 IPAddr
  class
  667
  
 $-K
  variable 321
  
 readline
  320
 ,
  506
  
 IPSocket
  class
  714
 ,
  747
  
 readlines
  507
  
 Kanji
  684
  
 addr
  747
  
 $KCODE
  variable 309, 638, 668
  
 require
  172
 ,
  320
 ,
  507
 ,
  526
  
 getaddress
  747
  
 scan
  507
  
 kcode
  method
  
 peeraddr
  747
  
 scanf
  708
  
 class
  Regexp
  581
  
 recvfrom
  747
  
 select
  507
  
 Kellner, Robert
  722
  
 irb
  5
 ,
  156
 ,
  174
 –
 185
  
 set_trace_func
  393
 ,
  423
 ,
  
 Kernel
  module
  495
  
 commands
  183
  
 508
 ,
  728
  
 ` (backquote)
  83
 ,
  140
 ,
  
 configuration
  179
  
 singleton_method_added
  
 495
  
 extending
  180
  
 abort
  496
  
 392
  
 load files into
  176
  
 alias_method
  391
  
 singleton_method_
  
 options 175f
  
 Array
  495
  
 removed
  
 prompt
  179
 ,
  184
  
 at_exit
  496
  
 392
  
 adding ri
  180
  
 autoload
  496
  
 singleton_method_
  
 subsession
  177
  
 autoload?
  497
  
 undefineded
  
 tab completion
  176
  
 binding
  390
 ,
  423
 ,
  497
  
 392
  
 .irbrc
 ,
  _irbrc
 ,
  irb.rc
 ,
  
 block_given?
  51
 ,
  334
 ,
  497
  
 sleep
  508
  
 $irbrc
  179
  
 callcc
  427
 ,
  497
  
 split
  168
 ,
  508
  
 is_a?
  method
  
 caller
  107
 ,
  393
 ,
  394
 ,
  497
  
 sprintf
  508
  
 class
  Object
  550
  
 catch
  99
 ,
  108
 ,
  347
 ,
  498
  
 srand
  509
  
 isatty
  method
  
 chomp
  498
  
 String
  495
  
 class
  IO
  489
  
 chomp!
  498
  
 sub
  509
  
 isdst
  method
  
 chop
  499
  
 sub!
  509
  
 class
  Time
  625
  
 chop!
  499
  
 syscall
  509
  
 ISO 8601 date
  692
 ,
  724
  
 eval
  389
 ,
  423
 ,
  499
  
 system
  140
 ,
  509
  
 issetugid
  method
  
 exec
  141
 ,
  485
 ,
  500
  
 test
  510
  
 module
  Process::Sys
  573
  
 exit
  170
 ,
  441
 ,
  500
  
 throw
  108
 ,
  347
 ,
  510
  
 Iterator
  19
 ,
  46
 ,
  95
  
 exit!
  501
  
 trace_var
  511
  
 on arbitrary method
  651
  
 fail
  106
 ,
  501
  
 trap
  142
 ,
  513
  
  
 Prepared exclusively for Yeganefar",NA
L,"-l
  (Ruby option)
  169
 ,
  321
  
 Fcntl
  656
  
 RSS
  707
  
 FileUtils
  657
  
 scanf
  708
  
 Find
  658
  
 SDBM
  709
  
 Forwardable
  659
  
 Set
  710
  
 $-l
  variable 321
  
 ftools
  660
  
 Shellwords
  711
  
 lambda
  method
  
 GDBM
  661
  
 SimpleDelegator
  646
  
 module
  Kernel
  53
 ,
  343
 ,
  
 Generator
  50
 ,
  662
  
 Singleton
  712
  
 345
 ,
  503
 ,
  560
  
 GetoptLong
  663
  
 SizedQueue
  722
  
 last
  method
  
 GServer
  664
  
 SOAP
  713
  
 class
  Array
  415
  
 Iconv
  665
  
 Socket
  714
  
 class
  Range
  578
  
 io/wait
  666
  
 standard
  632
 –
 738
  
 last_match
  method
  
 IPAddr
  667
  
 StringIO
  715
  
 class
  Regexp
  579
  
 jcode
  668
  
 StringScanner
  716
  
 last_modified
  method
  686
  
 Logger
  669
  
 Sync
  717
  
 Latent types
  see
  Duck typing
  
 Mail
  670
  
 SyncEnumerator
  662
  
 Layout, source code
  302
  
 mathn
  182
 ,
  671
 ,
  700
  
 Syslog
  719
  
 lchmod
  method
  
 Matrix
  673
  
 Tempfile
  720
  
 class
  File
  448
 ,
  454
  
 mkmf
  755
  
 Test::Unit
  721
  
 lchown
  method
  
 Monitor
  674
  
 thread
  133
 ,
  137
  
 class
  File
  449
 ,
  454
  
 monitor
  134
  
 ThreadsWait
  723
  
 ldexp
  method
  
 MonitorMixin
  674
  
 time
  724
  
 module
  Math
  520
  
 Mutex
  675
  
 Timeout
  725
  
 LDFLAGS (mkmf)
  756
  
 Mutex_m
  676
  
 Tk
  726
  
 Leap seconds 626n
  
 net/http
  128
  
 tmpdir
  720
 ,
  727
  
 Leap year
  92
  
 Net::FTP
  677
  
 tracer
  728
  
 length
  method
  
 Net::HTTP
  678
  
 TSort
  729
  
 class
  Array
  415
  
 Net::IMAP
  680
  
 un
  730
  
 class
  Hash
  476
  
 Net::POP3
  681
  
 URI
  731
  
 class
  MatchData
  517
  
 Net::SMTP
  682
  
 Vector
  673
  
 class
  String
  594
  
 Net::Telnet
  683
  
 WeakRef
  732
  
 class
  Struct
  608
  
 NKF
  684
  
 WEBrick
  733
  
 Library
  
 Observable
  685
  
 Win32API
  254
 ,
  734
  
 Abbrev
  634
  
 open-uri
  126
 ,
  686
  
 WIN32OLE
  255
 ,
  735
  
 Base64
  635
  
 Open3
  687
  
 XMLRPC
  736
  
 Benchmark
  636
  
 OpenSSL
  688
  
 YAML
  397
 ,
  514
 ,
  633
 ,
  737
  
 BigDecimal
  637
  
 OpenStruct
  689
  
 Zlib
  738
  
 BigMath
  637
  
 OptionParser
  690
  
 see also
  RubyGems
  
 CGI
  638
  
 ParseDate
  692
  
 lib/
  directory
  282
  
  
 Prepared exclusively for Yeganefar",NA
M ,"/m
  regexp option
  309
  
 Listener
  see
  Observer
  
 asinh
  519
  
 Literal
  
 atan
  519
  
 array
  307
  
 atan2
  519
  
 ASCII
  56
 ,
  305
  
 Macdonald, Ian
  240
  
 atanh
  519
  
 Bignum
  55
 ,
  304
  
 Maeda, Shugo
  229
  
 cos
  519
  
 Fixnum
  55
 ,
  304
  
 Mail
  class
  670
  
 cosh
  519
  
 Float
  56
 ,
  305
  
 Mailing lists
  759
  
 erf
  520
  
 hash
  307
  
 :main:
  (RDoc)
  195
  
 erfc
  520
  
 range
  62
 ,
  307
  
 Main program
  376
  
 exp
  520
  
 regular expression
  64
 ,
  309
  
 main
  method
  
 frexp
  520
  
 String
  57
 ,
  305
  
 class
  Thread
  613
  
 hypot
  520
  
 symbol
  308
  
 MAJOR_VERSION
  (Marshal
  
 ldexp
  520
  
 ljust
  method
  
 constant)
  515
  
 log
  520
  
 class
  String
  594
  
 MANIFEST file
  287
  
 log10
  520
  
 _load
  396
 ,
  514
  
 MANT_DIG
  (Float constant)
  466
  
 sin
  520
  
 load
  method
  112
 ,
  117
  
 map
  method
  
 sinh
  521
  
 module
  Kernel
  172
 ,
  320
 ,
  
 module
  Enumerable
  435
  
 sqrt
  521
  
 380
 ,
  503
  
 map!
  method
  
 tan
  521
  
 module
  Marshal
  395
 ,
  396
 ,
  
 class
  Array
  415
  
 tanh
  521
  
 515
  
 Marshal
  module
  395
 –
 397
 ,
  
 mathn library
  182
 ,
  671
 ,
  700
  
 $LOAD_PATH
  variable 152, 168,
  
 514
 –
 515
  
 Matrix
  class
  673
  
 175, 209–211, 213, 216,
  
 dump
  395
 ,
  515
  
 Matsumoto, Yukihiro
  xviii
 ,
  xix
 ,
  
 321
  
 limitations
  514
  
 xxiii
 ,
  72
  
 Local variable
  see
  Variable
  
 load
  395
 ,
  396
 ,
  515
  
 Matz
  see
  Matsumoto, Yukihiro
  
 local
  method
  
 restore
  515
  
 MAX
  (Float constant)
  466
  
 class
  Time
  622
  
 see also
  YAML
  
 max
  method
  
 local_variables
  method
  
 marshal_dump
  method
  396
 ,
  
 module
  Enumerable
  435
  
 module
  Kernel
  503
  
 514
  
 MAX_10_EXP
  (Float constant)
  
 localtime
  method
  
 marshal_load
  method
  514
  
 466
  
 class
  Time
  625
  
 match
  method
  
 MAX_EXP
  (Float constant)
  466
  
 Locking
  see
  File
  class,
  flock
  
 class
  Regexp
  65
 ,
  73
 ,
  581
  
 maxgroups
  method
  
 Locking (file)
  454
  
 class
  String
  595
  
 module
  Process
  565
  
 log
  method
  
 MatchData
  class
  65
 ,
  73
 ,
  516
 ,
  
 maxgroups=
  method
  
 module
  Math
  520
  
 579
 ,
  581
 ,
  587
  
 module
  Process
  565
  
 log10
  method
  
 [ ]
  516
  
 mbox (e-mail file)
  670
  
 module
  Math
  520
  
 begin
  516
  
 MD5 hash
  647
  
  
 Prepared exclusively for Yeganefar",NA
N,"-n
  (Ruby option)
  169
  
 public_instance_methods
  
 Process::GID
  568
 ,
  573
  
 532
  
 Process::Sys
  573
  
 public_method_defined?
  
 Process::UID
  573
 ,
  575
  
 532
  
 Profiler
  696
  
 Nagai, Hidetoshi
  568
  
 remove_class_variable
  
 Profiler__
  697
  
 Nakada, Nobuyoshi
  684
  
 538
  
 PTY
  699
  
 name
  method
  
 remove_const
  538
  
 Readline
  702
  
 class
  Module
  530
  
 remove_method
  538
  
 REXML
  704
  
 Namespace
  see
  Module
  
 undef_method
  538
  
 Rinda
  706
  
 Naming conventions
  14
 ,
  313
  
 Module
  module
  
 RSS
  707
  
 file pathnames
  482
  
 define_method
  345
  
 Session
  699
  
 method names
  74
  
 module_eval
  method
  
 Shellwords
  711
  
 Test::Unit
  153
  
 class
  Module
  530
  
 Signal
  513
 ,
  583
  
 nan?
  method
  
 module_function
  method
  
 SingleForwardable
  659
  
 class
  Float
  468
  
 class
  Module
  340
 ,
  537
  
 Singleton
  712
  
 Native thread
  see
  Thread
  
 Modules
  
 SOAP
  713
  
 ncurses
  see
  Curses
  
 list of methods
  405
  
 Sync
  133
  
 ndbm
  645
  
 Abbrev
  634
 ,
  702
  
 Timeout
  725
  
 Nested assignment
  86
  
 Base64
  635
  
 TSort
  729
  
 nesting
  method
  
 Benchmark
  162
 ,
  390
 ,
  636
  
 WEBrick
  733
  
 class
  Module
  524
  
 BigMath
  637
  
 XMLRPC
  736
  
 net/http library
  128
  
 Comparable
  112
 ,
  426
  
 Zlib
  738
  
 Net::FTP
  class
  677
  
 Config
  173
  
 modulo
  method
  
 Net::HTTP
  class
  678
 ,
  731
  
 Curses
  643
  
 class
  Bignum
  421
  
 Net::IMAP
  class
  680
  
 Date
  621
  
 class
  Fixnum
  464
  
 Net::POP3
  class
  681
  
 Digest
  647
  
 class
  Float
  468
  
 Net::SMTP
  class
  682
  
  
 Prepared exclusively for Yeganefar",NA
O ,"/o
  regexp option
  309
  
 IP address representation
  
 &
  540
  
 667
  
 ^
  540
  
 IPv4/IPv6
  667
  
 |
  540
  
 nil?
  540
  
 OBJ_FREEZE
  298
  
 LDAP
  731
  
 POP
  681
  
 to_a
  540
  
 OBJ_FROZEN
  299
  
 server
  750
 ,
  754
  
 to_f
  540
  
 OBJ_TAINT
  298
  
 SMTP
  682
  
 to_i
  540
  
 OBJ_TAINTED
  298
  
 socket
  125
 ,
  714
 ,
  741
 ,
  743
  
 to_s
  540
  
 Object
  10
  
 SOCKS
  749
  
 nitems
  method
  
 aliasing
  38
 ,
  161
 ,
  315
  
 TCP
  748
  
 class
  Array
  415
  
 allocation
  273
  
 telnet
  683
  
 NKF
  module
  684
  
 creation
  23
 ,
  338
 ,
  391
  
 UDP
  751
  
 nfk
  684
  
 extending
  365
 ,
  368
  
 new
  method
  
 nlink
  method
  
 finalizer
  557
  
 see also
  Constructor
  
 class
  File::Stat
  459
  
 freezing
  377
  
 new
  method
  
 No-wait mode I/O
  666
  
 ID
  10
 ,
  386
  
 class
  Array
  406
  
 :nodoc:
  (RDoc)
  194
  
 immediate
  265
 ,
  385
 ,
  463
  
 class
  Class
  338
 ,
  424, 425
  
 nonzero?
  method
  
 listing active
  385
  
 class
  Dir
  430
  
 class
  Numeric
  544
  
 listing methods in
  386
  
 class
  Exception
  440
  
 not
  (logical not)
  88
 ,
  326
  
 object_id
  557
  
 class
  File
  120
 ,
  449
  
 Notation
  xxiv
  
 persistence
  698
  
 class
  Hash
  471
  
 binary, decimal, hex, octal
  
 tainting
  381
  
 class
  IO
  483
  
 55
 ,
  304
  
 Object
  class
  27
 ,
  376
 ,
  546
  
 class
  Module
  525
  
 notify_observers
  method
  
 ==
  546
  
 class
  Proc
  503
 ,
  559
  
 module
  Observable
  685
  
 ===
  546
  
 class
  Range
  577
  
 :notnew:
  (RDoc)
  194
  
 =~
  546
  
 class
  Regexp
  579
  
 now
  method
  
 _ _id_ _
  546
  
 class
  Socket
  745
  
 class
  Time
  622
  
 _ _send__
  546
  
 class
  SOCKSSocket
  749
  
 NTP (Network Time Protocol)
  
 class
  354
 ,
  546
  
 class
  String
  585
  
 683
  
 clone
  274
 ,
  547
  
 class
  Struct
  605, 606
  
 Numbers, unifying
  671
  
 display
  547
  
 class
  TCPServer
  750
  
 Numeric
  class
  541
 ,
  641
  
 dup
  274
 ,
  547
  
 class
  TCPSocket
  748
  
 +@
  541
  
 eql?
  547
  
 class
  ThreadGroup
  619
  
 -@
  541
  
 equal?
  548
  
 class
  Thread
  128
 ,
  613
  
 <=>
  541
  
 extend
  366
 ,
  368
 ,
  548
  
 class
  Time
  622
  
 abs
  541
  
 freeze
  162
 ,
  377
 ,
  548
  
 class
  UDPSocket
  751
  
 ceil
  541
  
 frozen?
  549
  
 class
  UNIXServer
  754
  
 coerce
  358
 ,
  541
  
 hash
  549
  
 class
  UNIXSocket
  753
  
 div
  542
  
 id
  549
  
 Newline (
 \n
 )
  12
 ,
  306
  
 divmod
  544
  
 initialize
  554
  
 Newsgroup
  759
  
 eql?
  544
  
 initialize_copy
  275
 ,
  549
  
 next
  98
 ,
  330
 ,
  342
  
 floor
  544
  
 inspect
  549
 ,
  694
  
 next
  method
  
 integer?
  544
  
 instance_eval
  549
  
  
 Prepared exclusively for Yeganefar",NA
P,"-p
  (Ruby option)
  169
 ,
  321
  
 add_observer
  685
  
 profiling
  163
 ,
  696
 ,
  697
  
 changed
  685
  
 windows automation
  258
  
 changed?
  685
  
 Perl/Tk
  see
  GUI programming
  
 count_observers
  685
  
 p
  method
  
 Perlisms
  22
 ,
  72
 ,
  94
  
 delete_observer
  685
  
 module
  Kernel
  505
  
 Permission
  see
  File, permission
  
  
 Prepared exclusively for Yeganefar",NA
Q ,"qdbm
  645
  
 class
  Array
  416
  
 eid
  575
  
 Rational
  class
  671
 ,
  700
  
 eid=
  575
  
 rb_apply
  295
  
 grant_privilege
  575
  
 rb_ary_entry
  300
  
 Queue
  class
  133
 ,
  137
 ,
  722
  
 re_exchange
  575
  
 rb_ary_new
  299
  
 quo
  method
  
 re_exchangeable?
  575
  
 rb_ary_new2
  299
  
 class
  Bignum
  421
  
 rid
  575
  
 rb_ary_new3
  299
  
 class
  Fixnum
  464
  
 sid_available?
  575
  
 rb_ary_new4
  299
  
 class
  Numeric
  545
  
 switch
  575
  
 rb_ary_pop
  299
  
 quote
  method
  
 profile library
  163
 ,
  696
  
 rb_ary_push
  299
  
 class
  Regexp
  580
  
 Profiler
  163
  
 rb_ary_shift
  299
  
 Quoting
  
 Profiler
  module
  696
  
 rb_ary_store
  299
  
 characters in regexp
  66
 ,
  579
  
 Profiler__
  module
  697
  
 rb_ary_unshift
  300
  
 URLs and HTML
  223
  
 Program
  see
  Process
  
 rb_block_given_p
  297
  
 Protected
  see
  Access control",NA
R,"-r
  (Ruby option)
  730
  
 rb_bug
  296
  
 protected
  method
  36
  
 rb_call_super
  295
  
 class
  Module
  538
  
 rb_catch
  297
  
 protected_instance_
  
 -r
  library
  (Ruby option)
  
 rb_create_new_instance
  
 methods
  
 295
  
 169
  
 method
  
 Race condition
  129
  
 rb_cv_get
  298
  
 class
  Module
  531
  
 RADIX
  (Float constant)
  466
  
 rb_cv_set
  298
  
 protected_method_defined?
  
 Radix
  see
  to_s
  methods,
  
 rb_cvar_defined
  298
  
 method
  
 Kernel.Integer
 ,
  
 rb_cvar_get
  298
  
 class
  Module
  531
  
 String#to_i
  
 rb_cvar_set
  298
  
  
 Prepared exclusively for Yeganefar",NA
S,"-S
  (Ruby option)
  169
  
 in class definition
  370
  
 Web sites
  xxii
 ,
  758
  
 Semaphore
  see
  Thread,
  
 ports to Windows
  253
  
 synchronization
  
 ruby (mkmf)
  756
  
 Send message
  10
 ,
  26
  
 -s
  (Ruby option)
  169
  
 Ruby Documentation Project
  8
 ,
  
 send
  method
  
 $SAFE
  variable 169, 299, 321,
  
 759
  
 class
  BasicSocket
  742
  
 380, 554, 652
  
 Ruby mode (emacs)
  157
  
 class
  Object
  553
  
 Safe level
  379
 –
 382
  
 Ruby On Rails
  240
  
 class
  UDPSocket
  752
  
 in extensions
  298
  
 Ruby Production Archive (RPA)
  
 Sequence
  see
  Range
  
 list of constraints 383f
  
 759
  
 Serialization
  see
  Marshal
  
 ruby-doc.org
  8
  
 and proc
  381
  
 Server
  664
  
 ruby-mode.el
  157
  
 setting using
  -T
  169
  
 Session
  see
  CGI programming,
  
 ruby.exe
  and
  rubyw.exe
  254
  
 and tainting
  381
  
 session
  
 ruby_finalize
  290
  
 safe_level
  method
  
 Session
  module
  699
  
 ruby_init
  290
  
 class
  Thread
  618
  
 Session leader
  566
  
 ruby_init_loadpath
  290
  
 SafeStringValue
  299
  
 Session, HTTP
  233
  
 ruby_options
  290
  
 SafeStringValue
  method
  267
  
 Set
  class
  407
 ,
  409
 ,
  710
  
 ruby_run
  290
  
 Sandbox
  380
 ,
  381
 ,
  see
  Safe
  
 Set operations
  see
  Array
  class
  
 ruby_script
  290
  
 level
  
 set_backtrace
  method
  
 RUBY_TCL_DLL
  172
  
 chroot
  429
  
 class
  Exception
  441
  
 RUBY_TK_DLL
  172
  
 scan
  method
  
 set_trace_func
  method
  
 RUBY_PLATFORM
  constant
  322
  
 class
  String
  60
 ,
  61
 ,
  311
 ,
  
 module
  Kernel
  393
 ,
  423
 ,
  
 RUBY_PLATFORM
  variable 216
  
 596
 ,
  716
  
 508
 ,
  728
  
 RUBY_RELEASE_DATE
  constant
  
 module
  Kernel
  507
  
 setegid
  method
  
 322
  
 scanf library
  708
  
 module
  Process::Sys
  573
  
 RUBY_VERSION
  constant
  322
  
 scanf
  method
  
 seteuid
  method
  
 RubyForge
  217
 ,
  759
  
 class
  Array
  708
  
 module
  Process::Sys
  573
  
 RubyGarden
  759
  
 class
  String
  708
  
 setgid, setuid
  380
  
 RubyGems
  203
 –
 221
  
 module
  Kernel
  708
  
 setgid
  method
  
 creating
  211
  
 Scheduler, thread
  132
  
 module
  Process::Sys
  573
  
 documentation
  207
  
 Schneiker, Conrad 78n
  
 setgid?
  method
  
 extensions
  215
  
 Schwartz, Randal
  437
  
 class
  File::Stat
  460
  
 gem_server
  208
  
 Schwartzian transform
  437
  
 class
  File
  451
  
 gemspec
  212
 –
 214
  
 Scope of variables
  99
 ,
  315
  
 setpgid
  method
  
 installing applications
  204
  
 Screen output
  see
  Curses
  
 module
  Process
  565
  
 installing library
  206
  
 SCRIPT_LINES__
  constant
  
 setpgrp
  method
  
 installing RubyGems
  204
  
 322
 ,
  395
 ,
  507
  
 module
  Process
  565
  
 package layout
  211
  
 SDBM
  class
  709
  
 setpriority
  method
  
 repository
  759
  
 sdbm
  709
  
 module
  Process
  566
  
 require_gem
  208
  
 Search path
  173
 ,
  284
  
 setregid
  method
  
 stub
  210
  
 sec
  method
  
 module
  Process::Sys
  573
  
 test on install
  205
  
 class
  Time
  626
  
 setresgid
  method
  
 versioning
  205
 , 206f,
  209
  
 seek
  method
  
 module
  Process::Sys
  574
  
 RUBYLIB
  172
 ,
  173
 ,
  383
  
 class
  Dir
  432
  
 setresuid
  method
  
 RUBYLIB_PREFIX
  172
  
 class
  IO
  492
  
 module
  Process::Sys
  574
  
 RUBYOPT
  172
 ,
  383
  
 Seki, Masatoshi
  398
  
 setreuid
  method
  
 RUBYPATH
  169
 ,
  172
  
 select
  method
  
 module
  Process::Sys
  574
  
 RUBYSHELL
  172
 ,
  500
  
 class
  Hash
  478
  
 setrgid
  method
  
 Rule, RDoc
  193
  
 class
  IO
  357
 ,
  486
  
 module
  Process::Sys
  574
  
 run
  method
  
 class
  MatchData
  517
  
 setruid
  method
  
 class
  Thread
  617
  
 module
  Enumerable
  436
  
 module
  Process::Sys
  574
  
  
 Prepared exclusively for Yeganefar",NA
T,"StringIO
  class
  124
 ,
  715
  
 see also
  Module, mixin
  
 -T[
 level
 ]
  (Ruby option)
  169
  
 StringScanner
  class
  716
  
 superclass
  method
  
 Tab completion
  
 StringValue
  method
  266
  
 class
  Class
  386
 ,
  425
  
 irb
  176
  
 StringValuePtr
  method
  267
  
 swapcase
  method
  
 Tag file
  185
  
 strip
  method
  
 class
  String
  600
  
 taint
  method
  
 class
  String
  599
  
 swapcase!
  method
  
 class
  Object
  554
  
 strip!
  method
  
 class
  String
  600
  
 Tainted objects
  267
 ,
  381
 ,
  554
  
 class
  String
  599
  
 SWIG
  287
  
 see also
  Safe level
  
 Struct
  class
  605
  
 switch
  method
  
 tainted?
  method
  
 ==
  606
  
 module
  Process::GID
  569
  
 class
  Object
  554
  
 [ ]
  606, 607
  
 module
  Process::UID
  575
  
 Talbott, Nathaniel
  143
 ,
  153
  
 [ ]=
  607
  
 Symbol
  
 tan
  method
  
 each
  607
  
 literal
  308
  
 module
  Math
  521
  
 each_pair
  607
  
 Symbol
  class
  29
 ,
  323
 ,
  358
 ,
  594
 ,
  
 tanh
  method
  
 length
  608
  
 610
  
 module
  Math
  521
  
 members
  606
 ,
  608
  
 all_symbols
  610
  
 Tcl/Tk
  see
  GUI programming
  
 new
  605, 606
  
 id2name
  610
  
 TCP
  see
  Network protocols
  
 OpenStruct
  689
  
 inspect
  611
  
 TCPServer
  class
  750
  
 size
  608
  
 to_i
  611
  
 accept
  750
  
 to_a
  608
  
 to_int
  611
  
 new
  750
  
 values
  608
  
 to_s
  611
  
 open
  750
  
 values_at
  608
  
 to_sym
  611
  
 TCPSocket
  class
  714
 ,
  748
  
 struct sockaddr
  741
  
 symlink
  method
  
 gethostbyname
  748
  
 Struct::Tms
  class
  609
  
 class
  File
  452
  
 new
  748
  
 Stub
  
 symlink?
  method
  
 open
  748
  
 RubyGems
  210
  
 class
  File::Stat
  461
  
 teardown
  method
  150
  
 WIN32OLE
  258
  
 class
  File
  452
  
 Technical support
  758
  
 sub
  method
  
 Sync
  class
  717
  
 tell
  method
  
 class
  String
  70
 ,
  599
  
 Sync
  module
  133
  
 class
  Dir
  432
  
 module
  Kernel
  509
  
 sync
  method
  
 class
  IO
  494
  
 sub!
  method
  
 class
  IO
  493
  
 Telnet
  see
  Network protocols,
  
 class
  String
  599
  
 sync=
  method
  
 module
  Kernel
  509
  
 telnet
  
 class
  IO
  493
  
 Subclass
  25
  
 Tempfile
  class
  720
  
 SyncEnumerator
  class
  662
  
 Templates
  226
 –
 231
  
 Subnet, testing address in
  667
  
 Synchronization
  
 see
  Thread,
  
 Amrita
  228
  
 Subprocess
  see
  Process
  
 synchronization
  
 BlueCloth
  206
  
 Subroutine
  see
  Method
  
 Substitution
  see
  Regular
  
 sysaccept
  method
  
 eruby
  229
 ,
  652
  
 expression
  
 class
  Socket
  746
  
 RDoc
  227
  
 succ
  method
  
 syscall.h
  509
  
 Temporary directory
  727
  
 class
  Integer
  481
  
 syscall
  method
  
 Temporary file
  720
  
 module
  Kernel
  509
  
 Terminal
  
 class
  String
  599
 ,
  668
  
 Syslog
  class
  719
  
 pseudo
  699
  
 for generating sequences
  63
  
 sysopen
  method
  
 terminate
  method
  
 succ!
  method
  
 class
  IO
  486
  
 class
  Thread
  618
  
 class
  String
  600
 ,
  668
  
 sysread
  method
  
 termsig
  method
  
 success?
  method
  
 class
  IO
  493
  
 class
  Process::Status
  572
  
 class
  Exception
  442
  
 sysseek
  method
  
 Ternary operator
  91
 ,
  328
  
 class
  Process::Status
  571
  
 class
  IO
  493
  
 Test case
  148
  
 Suites, test
  152
  
 system
  method
  
 Test suites
  152
  
 Suketa, Masaki
  255
  
 module
  Kernel
  140
 ,
  509
  
 test
  method
  
 sum
  method
  
 syswrite
  method
  
 class
  String
  600
  
 module
  Kernel
  510
  
 super
  27
 ,
  335
 ,
  554
  
 class
  IO
  493
  
 Test::Unit
  144
 –
 153
  
  
 Prepared exclusively for Yeganefar",NA
U ,"UDP
  see
  Network protocols
  
 TOPLEVEL_BINDING
  constant
  
 class
  String
  602
  
 322
  
 unpack_sockaddr_in
  method
  
 Topological sort
  729
  
 class
  Socket
  746
  
 tr
  method
  
 UDPSocket
  class
  714
 ,
  751
  
 unpack_sockaddr_un
  method
  
 class
  String
  601
 ,
  668
  
 bind
  751
  
 class
  Socket
  746
  
 tr!
  method
  
 connect
  751
  
 unshift
  method
  
 class
  String
  602
 ,
  668
  
 new
  751
  
 class
  Array
  419
  
  
 Prepared exclusively for Yeganefar",NA
V,"$0
  170, 320, 322
  
 Versions of Ruby
  xx
  
 $1 to $9
  319
  
 vi and vim
  157
  
 -v
  (Ruby option)
  514
  
 $1...$9
  65, 70, 311
  
  
 tag file
  185
  
 -v, --verbose
  (Ruby option)
  
 $:
  117, 152, 168, 173, 290,
  
 vi key binding
  702
  
 169
 ,
  321
  
 320
  
 Virtual
  
 $-v
  variable 321
  
 $;
  168, 319
  
 class
  364
  
 VALUE (C extension)
  264
  
 $<
  320
  
 Virtual attribute
  30
  
 value
  method
  
 $=
  309, 319",NA
W,"class
  Thread
  129
 ,
  618
  
 $>
  320
  
 $?
  83, 140, 142, 320, 323,
  
 value?
  method
  
 class
  Hash
  479
  
 495, 510, 566, 570
  
 -w
  (Ruby option)
  169
 ,
  321
 ,
  514
  
 $@
  319
  
 values
  method
  
 -W
  level
  (Ruby option)
  169
 ,
  
 $DEBUG
  168, 321, 612, 616
  
 class
  Hash
  479
  
 513
  
 $F
  168, 321
  
 class
  Struct
  608
  
 $-w
  variable 321
  
 $FILENAME
  321
  
 values_at
  method
  
 wait
  method
  
 $KCODE
  309, 638, 668
  
 class
  Array
  419
  
 class
  IO
  666
  
 class
  Hash
  479
  
 $LOAD_PATH
  152, 168, 175,
  
 module
  Process
  141
 ,
  566
  
 class
  MatchData
  518
  
 209–211, 213, 216, 321
  
 wait2
  method
  
 class
  Struct
  608
  
 $SAFE
  169, 299, 321, 380,
  
 module
  Process
  567
  
 Variable
  
 554, 652
  
 waitall
  method
  
  
 Prepared exclusively for Yeganefar",NA
X,"waitpid
  method
  
 WEBrick
  module
  733
  
 /x
  regexp option
  309
  
 module
  Process
  567
  
 Weirich, Jim
  204
  
 -x [
 directory
 ]
  (Ruby option)
  
 waitpid2
  method
  
 while
  loop
  94
 ,
  329
  
 170
  
 module
  Process
  567
  
 as modifier
  94
 ,
  330
  
 -X
  directory
  (Ruby option)
  
 wakeup
  method
  
 why the lucky stiff
  633
  
 170
  
 class
  Thread
  618
  
 Widget
  see
  GUI programming
  
 XML
  704
 ,
  736
  
 Walk directory tree
  658
  
 Wildcard
  see
  fnmatch
  and
  
 XMLRPC
  module
  736
  
 warn
  method
  
 glob
  
 xmp
  186
  
 module
  Kernel
  169
 ,
  321
 ,
  
 Win32API
  class
  648
 ,
  734",NA
Y,"513
  
 Win32API library
  254
  
 Warnings
  169
  
 WIN32OLE
  class
  735
  
 ARGV[0]
  is not
  $0
  170
  
 -y, --yydebug
  (Ruby option)
  
 WIN32OLE library
  255
  
 be careful with tainted data
  
 Windows
  see
  Microsoft
  
 170
  
 379
  
 Windows, GUI
  
 YAML library
  397
 ,
  514
 ,
  633
 ,
  
 C functions must return
  
 programming
  
 737
  
 VALUE
  263
  
 with-cflags (mkmf)
  756
  
 yday
  method
  
 strings aren’t numbers
  56
 ,
  
 class
  Time
  628
  
 with-cppflags (mkmf)
  756
  
 161
  
 year
  method
  
 with-ldflags (mkmf)
  756
  
 wday
  method
  
 class
  Time
  628
  
 with-make-prog (mkmf)
  756
  
 class
  Time
  628
  
 yield
  47
 ,
  342
  
 WNOHANG
  (Process constant)
  
 Weak reference
  732
  
 arguments
  19
 ,
  48
  
 562
  
 WeakRef
  class
  732
  
 and RDoc
  193
  
 Words
  
 weakref_alive?
  732
  
 :yields:
  (RDoc)
  194
  
 array of
  14
 ,
  307
  
 weakref_alive?
  method
  
 Yukihiro, Matsumoto
  365
  
 Working directory
  168
 ,
  429
  
 class
  WeakRef
  732
  
 Wrap
  see
  Module, wrap",NA
Z,"Web
  see
  CGI programming
  
 writable?
  method
  
 Web framework
  
  
 class
  File::Stat
  461
  
 zero?
  method
  
 CGIKit
  240
  
 Iowa
  226
  
 class
  File
  453
  
 class
  File::Stat
  461
  
 writable_real?
  method
  
 class
  File
  453
  
 Rails
  240
  
 Web server
  
 class
  File::Stat
  461
  
 class
  Fixnum
  465
  
 class
  File
  453
  
 class
  Float
  469
  
 trivial
  750
  
 write
  method
  
 class
  Numeric
  545
  
 WEBrick
  234
 ,
  733
  
 class
  IO
  494
  
 Zip compression
  738
  
 see also
  Apache
  
 WSDL
  239
 ,
  713
  
 zip
  method
  
 Web services
  236
  
 Google interface
  239
  
 module
  Enumerable
  438
  
 description language
  239
  
 WUNTRACED
  (Process constant)
  
 Zlib
  module
  738
  
 Google
  238
  
 562
  
 zone
  method
  
 Web sites for Ruby
  xxii
 ,
  758
  
 Webcoder, Walter
  379
  
 Wyss, Clemens
  380
  
 class
  Time
  628
  
  
 Prepared exclusively for Yeganefar",NA
Pragmatic Starter Kit,"Version Control
 .
  Unit Testing
 .
  Project Automation
 . Three great titles, one 
 objective. To get you up to speed with the essentials for successful project 
 development. Keep your source under control, your bugs in check, and your process 
 repeatable with these three concise, readable books from The Pragmatic Bookshelf.
  
  
  
 • Keep your project assets safe—never lose a great idea• 
 Know how to UNDO bad decisions—no matter when they 
 were made
  
  
 • Learn how to share code safely, and 
 work in parallel
  
 • See how to avoid costly code freezes• 
 Manage
  3
 rd
 party code
  
 • Understand how to go back 
 in time, and work on previous versions.
  
 Pragmatic Version Control 
  
 Dave Thomas and Andy Hunt 
  
 (176 pages)
  ISBN
 : 0-9745140-0-4. $29.95
  
 • Write better code, faster
  
 • Discover the hiding places
  
  
  
 where bugs breed
  
 • Learn how to think of all the things
  
 that could go 
 wrong
  
 • Test pieces of code without using
  
 the whole project
  
 • Use JUnit to simplify your test code
  
 • Test effectively with the whole team.
  
 Pragmatic Unit Testing 
  
 Andy Hunt and Dave Thomas 
  
 (176 pages)
  ISBN
 : 0-9745140-1-2. $29.95 
 (Also available for C#,
  ISBN
 : 0-9745140-2-0)
  
  
  
 • Common, freely available tools which automate build,
  
 test, and release procedures• Effective ways to keep on
  
 top of problems• Automate to create better code, and
  
 save time and money
  
 • Create and deploy releases eas-
  
 ily and automatically• Have programs to monitor them-
  
 selves and report problems.
  
 Pragmatic Project Automation
  
 Mike Clark
  
 (176 pages)
  ISBN
 : 0-9745140-3-9. $29.95
  
 Visit our secure online store:
  http://pragmaticprogrammer.com/catalog",NA
The Pragmatic Bookshelf,"A new line in books written by developers, published by developers, aimed squarely at the needs of devel-
 opers. Information rich books, designed to be practical and applicable. Available in printed form and PDF. 
 Check us out on the web at
  pragmaticbookshelf.com
 , and have a look on the previous page for information on 
 our
  Pragmatic Starter Kit
 .",NA
Visit Us Online,"Programming Ruby Home Page 
  
 pragmaticprogrammer.com/titles/ruby 
  
 Source code from this book, errata, and other resources. Come give us feedback, 
 too!
  
 Register for Updates 
  
 pragmaticprogrammer.com/updates 
  
 Be notified when updates and new books become available.
  
 Join the Community 
  
 pragmaticprogrammer.com/community 
  
 Read our weblogs, join our online discussions, participate in our mailing list, interact with our wiki, and 
 benefit from the experience of other Pragmatic Programmers.
  
 New and Noteworthy 
  
 pragmaticprogrammer.com/news 
  
 Check out the latest pragmatic developments in the news.",NA
Save on the PDF,"Save 60% on the PDF version of this book. Owning the paper version of this book entitles you to purchase 
 the PDF version for only $10.00 (regularly $25.00). The PDF is great for carrying around on your laptop. 
 It’s hyperlinked, has color, and is fully searchable. Buy it now at
  pragmaticprogrammer.com/coupon",NA
Contact Us ,"Phone Orders: 
  
 1-800-699-PROG (+1 919 847 3884) 
  
 Online Orders: 
  
 www.pragmaticprogrammer.com/catalog 
 Customer Service: 
  
 orders@pragmaticprogrammer.com 
  
 Non-English Versions: 
  
  
 translations@pragmaticprogrammer.com 
 Pragmatic Teaching: 
  
 academic@pragmaticprogrammer.com 
 Author 
 Proposals: 
  
 proposals@pragmaticprogrammer.com",NA
