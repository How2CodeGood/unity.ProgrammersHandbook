Larger Text,Smaller Text,Symbol
PHP,NA,NA
|,NA,NA
ARCHITECT,NA,NA
’,NA,NA
S,NA,NA
 G,NA,NA
UIDETO,NA,NA
PHP S,NA,NA
ECURITY ,"by Ilia Alshanetsky
  
 Download from Wow! eBook <www.wowebook.com>",NA
Contents,"Foreword
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 13
  
 ! eBook <www.wowebook.com>
  
 Introduction 
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 17
  
 om 
 Wow",NA
1,"Input Validation 
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 21 
  
 The Trouble with Input
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 22
  
 Download fr
  
 An Alternative to Register Globals: Superglobals
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 25 
 The Constant Solution
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 25 
 The $_REQUEST Trojan Horse
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 27 
 Validating Input
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 28 Validating Numeric Data
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 28 Locale Troubles
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  
 29 String Validation
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  
 30 Content Size Validation
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  
 34 White List Validation
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  
 36",NA
2,"Cross-Site Scripting Prevention 
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 53 
 The Encoding Solution
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 54 
 Handling Attributes
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 54 
 HTML Entities & Filters
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 56 
 Exclusion Approach
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 60 
 Handling Valid Attributes
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 63 
 URL Attribute Tricks
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 64 
 XSS via Environment Variables
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 66 
 IP Address Information
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 66 
 Referring URL
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 67 Script Location
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 67 More Severe XSS Exploits
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 68 Cookie/Session Theft
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 69
  
 Download from Wow! eBook <www.wowebook.com>
  
 Form Data Theft
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 70 
 Changing Page Content 
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 71",NA
3,"SQL Injection
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 73 
 Magic Quotes
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 74 
 Prepared Statements
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 75 
 No Means of Escape
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 77 
 The LIKE Quandary 
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 78 
 SQL Error Handling
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 79",NA
4,"Preventing Code Injection
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 87 
 Path Validation
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 88 
 Using Full Paths
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 88 
 Avoiding Dynamic Paths
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 89 
 Possible Dangers of Remote File Access
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 89 
 Validating File Names
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 91
  
 Securing Eval
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 94 Dynamic Functions and Variables
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 95 Code Injection via PCRE
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  
 97",NA
5,"Command Injection 
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 101 
 Resource Exhaustion via Command Injection
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 102 
 The PATH Exploit
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 104 
 Hidden Dangers
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 105 
 Application Bugs and Setting Limits
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 106 
 PHP Execution Process
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 108",NA
6,"Session Security
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 113 
  
 Sessions & Cookies
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 114
  
 Download from Wow! eBook <www.wowebook.com>
  
 Man in the Middle Attacks
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 114 
 Encryption to the Rescue!
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 115 Server Side Weakness
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  
 115 URL Sessions
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  
 115 Session Fixation
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  
 117 Surviving Attacks
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  
 117 Native Protection Mechanism
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  
 118 User-land Session Theft
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  
 119 Expiry Time Tricks
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  •  
 119",NA
7,"Securing File Access
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 135 
  
 The Dangers of “Worldwide” Access
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 136
  
 Securing Read Access
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 137 PHP Encoders
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  
 137 Manual Encryption
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  
 138 Open Base Directory
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  
 139 Securing Uploaded Files
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  
 140 Securing Write Access
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  
 140 File Signature
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  
 142 Safe Mode
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  
 143 An Alternate PHP Execution Mechanism
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  
 144 CGI
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  •  
 145 FastCGI
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 145 Shared Hosting Woes 
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 146 File Masking
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 147
  
 Download from Wow! eBook <www.wowebook.com>",NA
8,"Security through Obscurity
   • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 153 
 Words of Caution
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 153 
 Hide Your Files
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 154 
 Obscure Compiled Templates
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 156 
 Transmission Obfuscation
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 158 
 Obscure Field Names
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 158 
 Field Name Randomization
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 159 
 Use POST
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 160 
 Content Compression
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 161",NA
9,"Sandboxes and Tar Pits
   • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 165 
 Misdirect Attacks with Sandboxes 
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 166 
 Building a Sandbox
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 166 
 Tracking Passwords
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 167 
 Identify the Source of the Attack Source 
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 169 
 Find Routing Information
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 170 
 Limitations with IP Addresses 
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 171 
 Smart Cookie Tricks
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 173
  
 Record the Referring URL
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 173 Capture all Input Data
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  
 174 Build a Tar Pit
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 •  •  •  
 176",NA
10,"Securing Your Applications
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 179 
 Enable Verbose Error Reporting
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 180 Replace the Usage of Register Globals
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 180 Avoid $_REQUEST
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 181 Disable Magic Quotes
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 182 Try to Prevent Cross-Site Scripting (XSS) 
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 183 Improve SQL Security
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 183 Prevent Code Injection
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 184 Discontinue use of eval()
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 185
  
 Download from Wow! eBook <www.wowebook.com>
  
 Mind Your Regular Expressions
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 185 Watch Out for Dynamic Names
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 185 Minimize the Use of External Commands 
   •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 186 Obfuscate and Prepare a Sandbox
    •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  •  
 187
  
 Index
  • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 
 189",NA
Foreword,NA,NA
W ,"problems. Over the years, I think we have achieved that. PHP has allowed people with all 
 sorts ing the Web problem by removing barriers and simplifying the interaction between 
  
 the web server and the hundreds of sub-systems required to solve a wide variety of hen I 
 started the PHP project years ago, the goal was to develop a tool for solv-
  
 Download from Wow! eBook <www.wowebook.com>
  
 of different backgrounds to put their ideas on the Web. To me, this is the success of PHP and what 
 keeps me motivated to continue working on it.
  
 With all the success of PHP, I will be the first to admit that there are areas where we haven’t 
 done a very good job of educating and providing people with the tools they need. Security is at the 
 top of that list—we have simplified access to things, provided a language and a set of functions to 
 do anything anybody could want to do, but we have not provided much in the way of tools or 
 guidance aimed at helping people write secure applications. We have been content with being on 
 par with other environments in this respect, while in almost all other areas we have strived to be 
 better.
  
 Security is not easy. People have to understand their systems well to know where security",NA
Introduction ,NA,NA
S ,"evolving capabilities, and its excellent performance. majority of web developers, powering 
 over 22 million domain names running on over 1.3 
  
 million distinct servers. PHP’s rapid growth can be attributed to its simplicity, its ever-ince its 
 inception in 1995, PHP has become the scripting language of choice for a vast 
  
 Download from Wow! eBook <www.wowebook.com>
  
 Unfortunately, the same qualities that have made PHP so popular have also lulled many 
 developers into a sense of complacency, leading them to neglect a very important aspect of 
 development: 
 security
 .
  
 When PHP was still young and used primarily for hobbyist applications, security wasn’t an 
 utmost concern. Back then, a “serious” intrusion might leave some nasty HTML in a guest-book. 
 Now, however, when PHP powers shopping carts, registration systems, and corporate web portals, 
 insecure code can have very serious consequences for a site, the site’s owners, and the site’s users. 
  
 This book has two goals: to explain the common types of security shortcomings that plague PHP 
 applications and to provide simple and efficient remedies to those problems. In general,",NA
1 ,NA,NA
Input Validation ,NA,NA
P ,"First and foremost, you must realize and accept that any user-supplied data is inherently put. 
 This is especially true for web applications, where just about all output depends on 
  
 what the user provides as input. 
  
 ractically all software applications depend on some form of user input to create out-
  
 Download from Wow! eBook <www.wowebook.com>
  
 unreliable and cannot be trusted. By the time input reaches PHP, it’s passed through the user’s 
 browser, any number of proxy servers and firewalls, filtering tools on your server, and possibly 
 other processing modules. Any one of those “hops” have an opportunity—be it intentional or 
 accidental—to corrupt or alter the data in some unexpected manner. And because the data ul-
 timately originates from a user, the input could be coerced or tailored out of curiosity or malice to 
 explore or push the limits of your application. 
 It is absolutely imperative to validate all user input to 
 ensure it matches the expected form.
  
 There’s no “silver bullet” that validates all input, no universal solution. In fact, an attempt to 
 devise a broad solution tends to cause as many problems as it solves—as PHP’s “magic quotes” will 
 soon demonstrate. In a well-written, secure application, each input has its own validation",NA
The Trouble with Input,"Originally, PHP programmers accessed user-supplied data via the “register globals” mecha-nism. 
 Using register globals, any parameter passed to a script is made available as a variable with the 
 same name as the parameter. For example, the URL 
 script.php?foo=bar
  creates a variable 
 $foo
  
 with a value of 
 bar
 . 
  
  
 While register globals is a simple and logical approach to capturing script parameters, it’s 
 vulnerable to a slew of problems and exploits.
  
 One problem is the conflict between incoming parameters. Data supplied to the script can come 
 from several sources, including 
 GET
 , 
 POST
 , cookies, server environment variables,  and system 
 environment variables, none of which are exclusive. Hence, if the same parameter is supplied by 
 more than one of those sources, PHP is forced to merge the data, losing informa-tion in the process. 
 For example, if an 
 id
  parameter is simultaneously provided in a 
 POST
  re-quest and a cookie, one of 
 the values is chosen in favor of the other. This selection process is called a 
 merge
 . 
  
 Two 
 php.ini
  directives control the result of the merge: the older 
 gpc_order
  and the newer 
  
 Download from Wow! eBook <www.wowebook.com>
  
 variables_order
 . Both settings reflect the relative priority of each input source. The default or-
 der for 
 gpc_order
  is 
 GPC
  (for 
 GET
 , 
 POST
 , cookie, respectively), where cookie has the highest prior-
 ity; the default order for 
 variables_order
  is 
 EGPCS
  (system Environment, 
 GET
 , 
 POST
 , cookie, and 
 Server environment, respectively). According to both defaults, if parameter 
 id
  is supplied via a 
 GET
  
 and a cookie, the cookie’s value for 
 id
  is preferred. Perhaps oddly, the data merge occurs outside 
 the milieu of the script itself, which has no indication that any data was lost.
  
 A solution to this problem is to give each parameter a distinct prefix that reflects its origin. For 
 example, parameters sent via 
 POST
  would have a 
 p_
  prefix. But this technique is only reliable in a 
 controlled environment where all applications follow the convention. For distributable ap-",NA
Validating Input ,"Now that you’ve updated your code to access input data in a safer manner, you can proceed with the 
 actual guts of the application, right? 
  
 Wrong! 
  
  
 Just accessing the data in safe manner is hardly enough. If you don’t validate the 
 content
  of the 
 input, you’re just as vulnerable as you were before. 
  
 All input is provided as strings, but validation differs depending on how the data is to be used. 
 For instance, you might expect one parameter to contain numeric values and another to adhere to a 
 certain pattern. 
  
 Validating Numeric Data 
  
 If a parameter is supposed to be numeric, validating it is exceptionally simple: simply cast the 
  
 parameter to the desired numeric type.
  
 $_GET[‘product_id’] = (int) $_GET[‘product_id’]; 
  
 $_GET[‘price’] = (float) $_GET[‘price’];
  
 A cast forces PHP to convert the parameter from a string to a numeric value, ensuring that the input 
 is a valid number.
  
 In the event a datum contains only non-numeric characters, the result of the conversion is 0. 
 On the other hand, if the datum is entirely numeric or begins with a number, the numeric portion of 
 the string is converted to yield a value.  In nearly all cases the value of 0 is undesirable and a simple 
 conditional expression such as 
 if (!$value) {error handling}
  based on type cast variable 
 will be sufficient  to validate the input.
  
 .wowe
  
 book.com>
  
 Download from Wow! eBook 
 <www
  
 When casting, be sure to select the desired type, since casting a floating-point number to an 
 integer loses significant digits after the decimal point. You should always cast to a floating-point 
 number if the potential value of the parameter exceeds the maximum integer value of the system. 
 The maximum value that can be contained in a PHP integer depends on the bit-size of your 
 processor. On 32-bit systems, the largest integer is a mere 2,147,483,647. If the string 
 “1000000000000000000” is cast to integer, it’ll actually overflow the storage container resulting in 
 data loss. Casting huge numbers as floats stores them in scientific notation, avoiding the loss of data.",NA
,"Performance Tip 
  
 Casting is faster than 
 is_numeric()
  because it requires no function calls. Additionally, casting returns a 
  
 numeric value, rather than a “yes” or “no” answer. 
  
 Once you’ve validated each numeric input, there’s one more step: you must replace each input with 
 its validated value. Consider the following example:
  
 # $_GET[‘del’] = “1; /* Muwahaha */ TRUNCATE users;”
  
 if ((int)$_GET[‘del’]) { 
  
 mysql_query(“DELETE FROM users WHERE id=”.$_GET[‘del’]); 
  
 }
  
 While the string 
 $GET[‘del’]
  casts successfully to an integer (
 1
 ), using the original data injects 
 additional SQL into the query, truncating the user table. Oops! 
  
 The proper code is shown below:
  
 if (($_GET[‘del’] = (int)$_GET[‘del’])) { 
  
 mysql_query(“DELETE FROM users WHERE id=”.$_GET[‘del’]); 
  
 } 
  
 # OR 
  
 owebook.com>
  
 d from Wow! eBook <www.w
  
 Downlo
 a
  
 if ((int)$_GET[‘del’]) { 
  
 mysql_query(“DELETE FROM users WHERE id=”.(int)$_GET[‘del’]); 
  
 }
  
 Of the two solutions shown above, the former is arguably slightly safer because it renders fur-ther 
 casts unnecessary—the simpler, the better. 
  
 String Validation 
  
 While integer validation is relatively straightforward, validating strings is a bit trickier because a 
 cast simply doesn’t suffice. Validating a string hinges on what the data is supposed to repre-",NA
,"Convenient? Not Really 
  
 Some systems, like FreeBSD and Windows, include high-ASCII characters used in most European languag-
  
 es in the base English character set. However you shouldn’t rely on this behavior. On various flavors of Linux and 
 several other operating systems, you must set the proper locale.",NA
Being Careful with File Uploads ,"In addition to forms, users may also provide files as input. Files to be uploaded can be found in the 
 $_FILES
  superglobal. 
  
 File upload has been has been somewhat of a thorn in PHP’s side, given the number of serious 
 vulnerabilities found in this chunk of PHP’s internals. In general, if you don’t need the feature, you 
 should disable it in 
 php.ini
  (The feature is enabled by default.)
  
 # php.ini 
  
 file_uploads=Off
  
 # .htaccess or httpd.conf 
  
 php_flag file_uploads 0
  
 ow! eBook <www.wowebook.com>
  
 Download from W
  
 By disabling file uploads, you can also prevent server overloads caused by hand-crafted re-quests 
 that attempt to upload a large number of files. Once disabled, PHP refuses to process any such 
 requests. 
  
  
 However, if your application supports file uploads, you should configure PHP to minimize your 
 risks and perform some validation on the incoming files. 
  
 Configuration Settings 
  
 On the configuration side of things, PHP offers a series of directives to fine-tune file uploads. 
  
 The 
 upload_max_filesize
  directive controls the maximum size (in bytes) of a file upload.",NA
,"Input Validation
  
 The Browser Does Not Know Best
  
 You might assume that the browser determines a file’s MIME type by examining the file’s header and the 
  
 file content, but that’s just not the case. In reality, the browser looks at the file’s extension to assign a MIME type. 
 So, if a nasty_trojan.exe were to be renamed to cute_puppies.jpg, the browser would happily send 
 image/jpeg
  as 
 the MIME type.
  
 For the most common type of uploaded data, images, PHP provides 
 getimagesize()
 . The func-tion 
 checks the headers of the file and either returns image information, such as dimensions and quality, 
 or 
 FALSE
  if the image isn’t valid. 
  
  
 For other file types, validation is a bit more complicated and requires the use of the PECL 
 fileinfo extension. 
  
 # fileinfo installation instructions 
  
 # As root user (only available for *Nix based systems) run 
  
 pear install fileinfo
  
 # this point the built extension can be loaded via PHP.ini 
  
 extension=fileinfo.so
  
 # or loaded at run-time 
  
 dl(“fileinfo.” . PHP_SHLIB_SUFFIX);
  
 fileinfo is very savvy, able to process just about all common file formats. Its 
 finfo_file()
   func-
 tion can either return a textual description of a file or a MIME type. 
  
 dl(‘fileinfo.’ . PHP_SHLIB_SUFFIX);
  
 nload from Wow! eBook
  
 <www.wowebook.com>
  
 Do
 w
  
 # cute_puppies.jpg is really a nasty_trojan.exe 
  
 finfo_file(finfo_open(), “cute_puppies.jpg”); 
  
 // MS-DOS executable (EXE), OS/2 or MS Windows
  
 finfo_file(finfo_open(FILEINFO_MIME), “cute_puppies.jpg”); 
  
 // application/x-dosexec
  
 finfo_open() 
 creates a fileinfo resource that can be used by 
 finfo_file()
  to determine the 
 true nature of the file. If multiple files need to be checked, this resource can be reused as many 
 times as you like. Passing the optional 
 FILEINFO_MIME
  constant parameter to 
 finfo_open()
  re-
 turns the MIME type rather than a description.",NA
,"Access Exemptions 
  
 A security-minded administrator generally doesn’t want users to access the central temporary directory, 
  
 since it can store sessions. To prevent access to 
 /tmp
 , the administrator will enable 
 safe_mode
  and/or ex-clude 
 /tmp
  from 
 open_basedir
 . However, because uploaded files are often owned by the web server user but need to 
 be accessed by a script running as another user, 
 move_uploaded_file()
  and 
 is_uploaded_file()
  are exempt 
 from the restrictions imposed by 
 safe_mode
  and 
 open_basedir
 . 
  
 File Size
  
 The final piece of the uploaded file information array is the 
 size
  element, which contains the byte 
 size of the file. You can consider this information reliable and it should match the size of the 
 temporary file precisely. (If for some reason a file cannot be uploaded completely, perhaps because 
 the temporary directory is out of space, the upload is marked as failed and the error element of the 
 file information array is set.) 
  
  
 Since the size is reliable, you can actually use it to perform another little safety check to ensure 
 that a file is pristine before you begin to work with it:
  
 if (!move_uploaded_file($_FILES[‘file’][‘tmp_name’], $destination)) { 
 exit(“Uh oh…”); 
  
 } 
  
 if (filesize($destination) != $_FILES[‘file’][‘size’]) { 
  
 unlink($destination); 
  
 exit(“System error, run for the hills!”); 
  
 }
  
 ow! eBook <www.wowebook.com>
  
 Download from 
 W
  
 This code moves a file from the temporary directory to a local directory, 
 $destination
 , to avoid 
 open_basedir
  and 
 safe_mode
  restrictions. 
 filesize() 
 returns the size of the file, which is then 
 compared to the size of the uploaded file. If the sizes don’t correlate exactly, there is a problem, the 
 (assumed to be untrustworthy or corrupt) file is removed to prevent accumulation of data in the 
 $destination
  directory, and an error is raised. 
  
 This particular protection mechanism isn’t intended to protect you from attackers, who are 
 probably intelligent enough to ensure that the modified file is the same size as the original. Instead, 
 it ensures that the file has been fully transferred by 
 move_uploaded_file()
  and that",NA
The Dangers of Magic Quotes ,"While some magic tricks like pulling bunnies out of a hat are benign and even entertaining, others—
 like voodoo—skirt the realm of black magic and can be quite troublesome. Despite being designed 
 with the best intentions in mind, PHP’s 
 magic_quotes_gpc
  directive is closer to voodoo than party 
 tricks and a smart developer may want to steer clear of its juju. 
  
 The premise behind 
 magic_quotes_gpc
  is that input may contain all sorts of special char-
 acters, such as quotes (
 ‘
  and 
 “
 ), NUL (
 \0
 ), and backslash (
 \
 ), that left unfiltered could cause 
 problems if passed directly to various functions. Given such an obvious threat, the developers 
  
 of PHP decided to automatically secure all input by escaping it, effectively running 
 addslash-es()
  
 on all data from all input methods and on the original filenames in the 
 $_FILES
  array. 
  
 # magic_quotes_gpc=On & script.php?text=Cthulhu’s Guide to 
 “Necronomicon”echo $_GET[‘text’]; // Cthulhu\\u2019s Guide to \\u201dNecronomicon\\u201d 
  
 But automatic security is like a wool blanket: it protects you from harsh weather, but can also cause 
 irritation and even trigger allergies. Beware of side effects.
  
 The most common problem associated with “magic quotes” is blind reliance on the fea-ture. The 
 fact is that magic quotes can be disabled via 
 php.ini
 , 
 httpd.conf
 , and even 
 .htac-cess
 . If you 
 assume that magic quotes is enabled and eschew manual validation of input, you leave your 
 application open to SQL injection, command injection, and any number of other 
  
 ebook.com>
  
 w.wo
 w
  
 Download from Wow! eBook 
 <ww
  
 exploits. 
  
 Furthermore, assuming that magic quotes always “does the right thing” is erroneous. While 
 magic quotes escapes the most common “special” characters, other characters may have spe-cial 
 meaning as well, depending on where they are being used. Proper protection mechanisms are highly 
 specific. 
  
 # magic_quotes_gpc=On 
  
 # script.php?data=test’ 
  
 echo $_GET[‘data’]; // test\\u2019
  
 # MySQL Specific Escaping, also escapes \n, \t and \x1a",NA
Validating Serialized Data,"Another common type of information that is often passed between requests is serialized data, a 
 special PHP encoding form for complex data types like arrays and objects that can be deserial-ized 
 into the original data types.
  
 The rule of thumb is that serialized data is intended for internal, server-side use only. A user 
 should not be allowed to access or modify this information. An attacker can easily make PHP 
 generate highly complex and memory-intensive data structures that eat up CPU time and waste 
 enormous amounts of memory. In older versions of PHP, hacked serialized data could even be used 
 to devise exploits to execute arbitrary commands on the server.
  
 PHP does next to no validation on serialized data, as it expects the data to be a safe internal 
 format. When some unexpected or undesired data is injected into serialized strings, it opens a big 
 and nasty can of worms. For example when PHP tries to deserialize this seemingly harmless string, 
 it’ll attempt to create an array with 100 million elements.
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 a:100000000:{}
  
 100 million elements requires only about 500 megabytes of memory. Now imagine two or three of 
 those requests sent more or less at the same time and your server is sure to grind to a halt due to 
 lack of memory. A far more creative attacker may use unguarded serialized data to inject val-ues 
 into the application and do all sorts of nastiness. The limit of what can be done ultimately depends 
 on the imagination and skill of the attacker.
  
 The best way to protect your application against such exploits is to never pass serialized data in 
 such a way that a user can access it. Unfortunately, that may not always be possible or",NA
External Resource Validation ,Aside from serialized data there are few other dangerous inputs that should be strictly vali-dated.,NA
2 ,NA,NA
Cross-Site ,NA,NA
Scripting ,NA,NA
Prevention ,NA,NA
C ,"as part of a bulletin board posting—it alters the page or runs some code, often to steal a user’s 
 In such an attack, a hacker stores untoward CSS, HTML, or JavaScript content in the 
  
 application’s database. Later, when that content is displayed by the application—say, ross-
 site scripting (XSS) is one of the most common vulnerabilities of web applications. 
  
 Download from Wow! eBook <www.wowebook.com>
  
 cookies or redirect confidential information to a third-party’s site. 
  
 XSS is a popular and often easy-to-achieve exploit because web applications largely echo user 
 input. Indeed, most web applications cycle repeatedly between showing information, col-lecting 
 input, and showing new information in response. If an attacker can submit nefarious code as input, 
 the application and the web browser do the rest. In general, a successful XSS attack can be traced to 
 careless application design. 
  
 There are primarily two types of XSS vulnerabilities: a 
 direct action
  where the injected in-put is 
 echoed only to the injecting user, and the 
 stored action
 , where any number of future users “see” the 
 injected content. A direct action usually attempts to gain insight about an application or a web site to 
 deduce a more substantial exploit. A stored action, arguably the most danger-",NA
The Encoding Solution ,"So how do you secure your site—ultimately, the input sent to your site—against XSS? Fortu-nately, 
 this is very easy to do inside PHP, which offers a series of functions to remove or encode characters 
 that have special meaning in HTML. 
  
 The first of those functions is 
 htmlspecialchars()
 . It takes a single parameter, presum-ably 
 raw user input, and encodes the characters 
 &
  (ampersand), 
 <
  (less than), 
 >
  (greater than), 
 “
 (double-quote), and optionally, 
 ‘
  (single-quote). All of those “special” characters get converted 
  
 to the equivalent HTML entities, such as 
 &amp;
  for ampersand, which effectively treat the char-acter 
 as a literal instead of part of the underlying page code. 
  
 $raw_input = ‘<a href=”http://bad.site.com”><img src=”click_me.gif”></a>’; 
  
 $encoded_input = htmlspecialchars($raw_input); 
  
 echo $encoded_input; 
  
 //&lt;a href=&quot;http://bad.site.com&quot;&gt;&lt;img src=&quot;click_me.gif&quot;&gt;&lt;/ 
 a&gt;
  
 As another example, 
 <
  gets converted to 
 &lt;
 , useful because 
 <
  typically opens an HTML tag. It’s 
 best to encode even the simplest user input, lest something like 
 <
  or 
 >
  inadvertently corrupt the 
 page structure. 
  
 Handling Attributes
  
 ebook.com>
  
 ok 
 <www.wow
  
 Download from Wow! 
 eBo
  
 While it may be obvious why the HTML tag open/close characters need to be escaped, many people 
 don’t realize the importance of encoding the quoting characters. 
  
 A fair amount of user input finds its way into 
 attributes
 , which style the content of a tag and 
 even perform certain actions using JavaScript. In HTML, each attribute must be quoted using either 
 single or double quotes to ensure proper parsing. For example, if a user submits a URL to point to 
 an interesting page, that input is used to construct the 
 href
  attribute of an 
 <a>
  tag, as in 
 <a 
 href=”http://www.phparch.com”>php|architect</a>
 . 
  
  
  Now consider a situation where the user includes a quote (of the same style as the open-ing 
 quote used to delimit the attribute’s value). As soon as a matching “closing” quote is found,",NA
Exclusion Approach ,"Of course, one way to avoid the problems associated with HTML input is to completely strip HTML 
 from any data that a user provides. 
  
 In PHP, you can strip HTML easily with the 
 strip_tags()
  function. It takes a source string 
 and strips from it anything resembling an HTML tag, where an HTML tag is defined (in this case) to 
 be anything that starts with 
 <
 , is followed by a non-space character, and ends with the first 
 occurrence of the 
 >
  that isn’t part of an attribute or the end of a string. In other words, 
  
 Download from Wow! eBook <www.wowebook.com>
  
 strip_tags()
  uses the loosest possible definition of a tag to ensure that nothing bypasses it. 
  
 However, because of its loose definition of a “tag”, 
 strip_tags()
  can inadvertently remove 
 technically valid data, as this example demonstrates:
  
 $input = ‘<b>some text</b> <img src=”/img.gif” /> 12 is <then 5’; 
  
 echo strip_tags($input); 
  
 // prints: “some text 12 “",NA
,"Limits of 
 strip_tags() 
  
 strip_tags()
  does nothing about ampersands or any type of quotes, so be sure to filter the result 
  
 of 
 strip_tags()
  with 
 htmlspecialchars()
 . Failure to do so can lead to attribute injection or bypass of text 
 filters.
  
 A commonly utilized feature of 
 strip_tags()
  is the ability to exempt certain HTML tags to al-low a 
 user to format input in limited ways. To apply 
 strip_tags()
  conditionally, supply a sec-ond 
 argument that lists the allowed tags. Here, the bold and italics tags are excluded from the stripping 
 process and are present in the returned output. 
  
 $input = ‘<b>some text</b> <span><i>foo</i></span>’; 
  
 echo strip_tags($input, ‘<b><i>’); 
  
 // prints: “<b>some text</b> <i>foo</i>“
  
 However, this feature of 
 strip_tags()
  carries a hidden danger many programmers forget about; 
 the function only looks at 
 tag names
  and neglects all attributes. A tag that seems valid may yet 
 contain attributes that wreak havoc.
  
 w! eBoo
  
 k <www.wowebook.com>
  
 Download from W
  
  
 $input = ‘<b onMouseOver=”alert(\\u2018XSS\\u2019);”>harmless text</b>’; 
  
 echo strip_tags($input, ‘<b>’); 
  
 // prints: <b onMouseOver=”alert(\\u2018XSS\\u2019);”>harmless text</b>
  
 Again, in general, 
 strip_tags()
  should be used with extreme caution, especially when you 
 consider that some browsers support JavaScript events even on simple tags like bold (
 <b>
 ) and 
 italics (
 <i>
 ).",NA
XSS via Environment Variables ,"The validation techniques shown above should not be limited to the values supplied by the user 
 directly via 
 GET
 , 
 POST
 , and cookies. You should also apply the techniques to all server environ-ment 
 variables. Do not assume that 
 $_SERVER
  variables are safe. After all, the values come from the web 
 server, where virtually all values can be set one way or another by the user (although that generally 
 requires tinkering with the browser headers sent to the server). 
  
 IP Address Information
  
 Download from Wow! eBook <www.wowebook.com>
  
 It’s common for PHP scripts to retrieve the user’s IP address to implement access controls and 
 white and black lists. The standard IP field is safe, as it’s provided by the web server and the user 
 has no way to inject values into it. 
  
 However, for users hiding behind proxies, the 
 REMOTE_ADDR
  field that normally holds the 
 user’s true IP address contains the address of the proxy instead, and assuming a non-anony-mous 
 proxy is used, the 
 HTTP_X_FORWARDED_FOR
  header contains the IP address of the user. But the 
 latter header comes from the browser and can be specified by the user. Failure to validate the 
 HTTP_X_FORWARDED_FOR
  field could result in XSS or even SQL injection, depending on how the field 
 is being used.
  
 Fortunately, validating an IPV4 IP address is very easy to do in PHP thanks to 
 ip2long()
 ,",NA
More Severe XSS Exploits ,"Up until this point, the XSS examples demonstrated have been relatively harmless tricks in-tended 
 to show how arbitrary code can be injected into the page. But XSS attacks aren’t always",NA
3 ,NA,NA
SQL Injection,NA,NA
S ,"tion. Unlike cross-site scripting vulnerabilities that are ultimately directed at your site’s 
  
 visitors, SQL injection is an attack on the site itself—in particular its database. 
  
  
 The goal of SQL injection is to insert arbitrary data, most often a database query, into a 
  
 QL injection is yet another common vulnerability that is the result of lax input valida-
  
 Download from Wow! eBook <www.wowebook.com>
  
 string that’s eventually executed by the database. The insidious query may attempt any num-ber of 
 actions, from retrieving alternate data, to modifying or removing information from the database.
  
 To demonstrate the problem, consider this excerpt: 
  
 // supposed input 
  
 $name = “ilia’; DELETE FROM users;”;
  
 mysql_query(“SELECT * FROM users WHERE name=’{$name}’”);",NA
,"MySQL Exception 
  
 Fortunately, if you use MySQL, the 
 mysql_query()
  function does not permit query 
 stacking, or executing 
  
 multiple queries in a single function call.  If you try to stack queries, the call fails. 
  
 However, other PHP database extensions, such as SQLite and PostgreSQL, happily perform stacked que-ries, 
 executing all of the queries provided in one string and creating a serious security problem.",NA
Magic Quotes ,"Given the potential harm that can be caused by SQL injection, PHP’s automatic input escape 
 mechanism, 
 magic_quotes_gpc
 , provides some rudimentary protection. If enabled, 
 magic_ 
 quotes_gpc
 , or  “magic quotes”, adds a backslash in front of single-quotes, double-quotes, and 
 other characters that could be used to break out of a value identifier. But, magic quotes is a generic 
 solution that doesn’t include all of the characters that require escaping, and the fea-ture isn’t always 
 enabled (for reasons outlined in the first chapter). Ultimately, it’s up to you to implement 
 safeguards to protect against SQL injection. 
  
 To help, many of the database extensions available for PHP include dedicated, custom-ized 
 escape mechanisms. For example, the MySQL extension for PHP provides the function 
 mysql_real_escape_string()
  to escape input characters that are special to MySQL: 
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 if (get_magic_quotes_gpc()) { 
  
 $name = stripslashes($name); 
  
 } 
  
 $name = mysql_real_escape_string($name); 
  
 mysql_query(“SELECT * FROM users WHERE name=’{$name}’”);
  
 However, before calling a database’s own escaping mechanism, it’s important to check the state of 
 magic quotes. If magic quotes is enabled, remove any backslashes (
 \
 ) it may have added; otherwise, 
 the input will be doubly-escaped, effectively corrupting it (because it differs from",NA
Prepared Statements ,"While database-specific escape functions are useful, not all databases provide such a feature. In fact, 
 database-specific escape functions are relatively rare. (At the moment) only MySQL, PostgreSQL, 
 SQLite, Sybase, and MaxDB extensions provide them. For other databases, includ-",NA
No Means of Escape ,"Alas, escape functions do not always guarantee data safety. Certain queries can still permit SQL 
 injection, even after escapes are applied. 
  
 Consider the following situation, where a query expects an integer value: 
  
 $id = “0; DELETE FROM users”; 
  
 $id = mysql_real_escape_string($id); // 0; DELETE FROM users 
 mysql_query(“SELECT * FROM users WHERE id={$id}”);
  
 When executing integer expressions, it’s not necessary to enclose the value inside single quotes. 
 Consequently, the semicolon character is sufficient to terminate the query and inject an addi-tional 
 query. Since the semicolon doesn’t have any “special” meaning, it’s left as-is by both the database 
 escape function and 
 addslashes()
 .
  
 There are two possible solutions to the problem. 
  
 The first requires you to quote 
 all
  arguments. Since single quotes are always escaped, this 
 technique prevents SQL injection. However, quoting still passes the user input to the database, 
 which is likely to reject the query. Here is an illustrative example: 
  
 webook.com>
  
 Download from Wow! eBook <www.wo
  
  
 $id = “0; DELETE FROM users”; 
  
 $id = pg_escape_string($id); // 0; DELETE FROM users 
  
 pg_query($conn, “SELECT * FROM users WHERE id=’{$id}’”) 
  
  or die(pg_last_error($conn)); 
  
 // will print invalid input syntax for integer: “0; DELETE FROM users”
  
 But query failures are easily avoided, especially when validation of the query arguments is so 
 simple. Rather than pass bogus values to the database, use a PHP 
 cast
  to ensure each datum",NA
The LIKE Quandary ,"The SQL 
 LIKE
  operator is extremely valuable: its 
 %
  and 
 _
  (underscore) qualifiers match 0 or more 
 characters and any single character, respectively, allowing for flexible partial and sub-string 
 matches. However, both 
 LIKE
  qualifiers are ignored by the database’s own escape func-tions and 
 PHP’s magic quotes. Consequently, user input incorporated into a 
 LIKE
  query pa-rameter can 
 subvert the query, complicate the 
 LIKE
  match, and in many cases, prevent the use of indices, which 
 slows a query substantially. With a few iterations, a compromised 
 LIKE
  query could launch a Denial 
 of Service attack by overloading the database. 
  
 Here’s a simple yet effective attack:
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 $sub = mysql_real_escape_string(“%something”); // still %something 
  
 mysql_query(“SELECT * FROM messages WHERE subject LIKE ‘{$sub}%’”);
  
 The intent of the 
 SELECT
  above is to find those messages that 
 begin
  with the user-specified string, 
 $sub
 . Uncompromised, that 
 SELECT
  query would be quite fast, because the index for 
 subject
  
 facilitates the search. But if 
 $sub
  is altered to include a leading 
 %
  qualifier (for example), the query 
 can’t use the index and the query takes far longer to execute—indeed, the query gets",NA
SQL Error Handling ,"One common way for hackers to spot code vulnerable to SQL injection is by using the develop-er’s 
 own tools against them. For example, to simplify debugging of failed SQL queries, many de-
  
 Download from Wow! eBook <www.wowebook.com>
  
 velopers echo the failed query and the database error to the screen and terminate the script. 
  
 mysql_query($query) or die(“Failed query: {$query}<br />”.mysql_error());
  
 While very convenient for spotting errors, this code can cause several problems when deployed in a 
 production environment. (Yes, errors do occur in production code for any number of rea-sons.) 
 Besides being embarrassing, the code may reveal a great deal of information about the application or 
 the site. For instance, the end-user may be able discern the structure of the table",NA
Authentication Data Storage ,"Perhaps the final issue to consider when working with databases is how to store your applica-tion’s 
 database credentials—the login and password that grant access to the database. Most applications 
 use a small PHP configuration script to assign a login name and password to variables. This 
 configuration file, more often than not (at least on shared hosts), is left world-readable to provide 
 the web server user access to the file. But world-readable means just that: anyone on the same 
 system or an exploited script can read the file and steal the authentication information stored 
 within. Worse, many applications place this file inside web readable direc-",NA
Database Permissions ,"The last database security tip has nothing to do with PHP per se, but is sound advice that can be 
 applied to every component in your system. In general, grant the fewest privileges possible. 
  
 For example, if a user only requires read-access to the database, don’t permit the user to 
 execute 
 UPDATE
  or 
 INSERT
  queries. Or more realistically, limit write access to those tables that are 
 expected to change—perhaps the session table and the user accounts table. 
  
 By limiting what a user can do, you can detect, track, and defang many SQL injection at-tacks. 
 Limiting access at the database level is supplemental: you should use it in addition to all of the 
 database security mechanisms listed in this chapter.",NA
Maintaining Performance ,"Download from Wow! eBook <www.wowebook.com>
  
 Speed isn’t usually considered a security measure, but subverting your application’s perfor-mance is 
 tantamount to any other exploit. As was demonstrated by the 
 LIKE
  attack, where 
 % 
 was injected to 
 make a query very slow, enough costly iterations against the database could saturate the server and 
 prevent further connections. Unoptimized queries present the same risk:  if the attacker spots 
 inefficiencies, your server can be exhausted and rendered useless just the same. 
  
 To prevent database overloading, there are a few simple rules to keep in mind. 
  
 Only retrieve the data you need and nothing more. Many developers take the “*” shortcut and 
 fetch all columns, which may result in a lot of data, especially when joining multiple tables. More 
 data means more information to retrieve, more memory for the database’s temporary",NA
,"Words of Caution 
  
 Persistent connections are not without drawbacks. For example,  in PHP, connection pooling is done on a 
  
 per-process basis rather than per-web server, giving 
 every
  web-server process its own connection pool. So, 50 
 Apache processes result in 50 open database connections. If the database is not configured to allow at least that 
 many connections, further connection requests are rejected, breaking your web pages.
  
 In many cases, the database runs on the same machine as the web server, which allows data",NA
Query Caching ,"In some instances, a query is as fast as it can be, yet still take significant time to execute. If you cannot 
 throw hardware at the problem—which has its limits as well—try to use the 
 query cache
 . A query 
 cache retains a query’s results for some period of time, short-circuiting the need to recreate the 
 results from scratch each time the same query runs. 
  
 Each time there’s a request for a page, the cache is checked; if the cache is empty, if the cache 
 expired the previous results, or if the cache was invalidated (say, by an 
 UPDATE
  or an 
 IN-SERT
 ), the 
 query executes. Otherwise, the results saved in the cache are returned, saving time and effort.
  
 Download from Wow! eBook 
 <www.wowebook.com>",NA
4 ,NA,NA
Preventing ,NA,NA
Code Injection,NA,NA
C ,"script based on the value of a variable. For example, many templating systems utilize 
 GET
 /
 POST 
 Unsurprisingly, it’s also caused all too often by a lack of input validation.
  
 In most cases, code injection can be traced to 
 register_globals
  and including a ode 
 injection is arguably the most dangerous vulnerability that can affect a PHP script. 
  
 Download from Wow! eBook <www.wowebook.com>
  
 parameters to choose what template to load. The parameter may be a filename or even a path, and 
 if the template is a pre-compiled script, as found in Smarty, it may contain PHP code and 
 necessarily be loaded via 
 include
  or 
 require
 . 
  
 You can probably guess where this leads: a clever attacker can hijack this infrastructure 87sand 
 execute an arbitrary local or remote file—in other words, 
 inject
  code to perform virtu-ally any task 
 that can be expressed in PHP. An assailant can capture information, modify a da-tabase, change the 
 contents of local files and scripts, and even compromise an entire system. 
  
 Take every precaution possible to reduce and ideally eliminate the threat of code injec-tion. 
 Thankfully, a fairly limited subset of PHP functions are susceptible to code injection, and a simple 
 code audit using 
 grep
  can turn up most weaknesses.",NA
Path Validation ,"Securing 
 include
  and 
 require
  is a multi-step process. The first step is to better qualify what script 
 you’re including. 
  
 // Bad 
  
 require “foo.inc”; 
  
 // Good 
  
 require “/home/ilia/app/libs/foo.inc”; 
  
 require “./libs/foo.inc”;
  
 If you include a file yet omit its full path or a partial path—as shown on line 2 above—you can-not 
 predict where the file will come from. The file may come from a current directory or it could come 
 from any of the directories listed in the 
 ini
  directive 
 include_path
 . 
  
 Searching for files along the 
 include_path
  isn’t especially fast, but worse, should the 
 in-
 clude_path
  change (because it’s modified by a third-party application, say), a vital script may 
 “disappear” or may be replaced accidentally by another file of the same name.
  
 Whenever possible, provide a full path or at least a partial path to eliminate or reduce am-
  
 wowebook.com>
  
 Download from Wow! eBook <www.
  
 biguity. 
  
 Using Full Paths 
  
 A common way to specify fully-qualified filenames is to store the full path to a specific library 
 directory in a PHP variable and prefix each filename with that variable. 
  
 While this technique prevents ambiguity, it’s not bulletproof. If a logic bug or some other 
 condition affects the variable, the application may not work or may work improperly. Even a typo 
 in the variable name (a bug nonetheless) is a real hazard: if 
 register_globals
  is enabled, a user 
 could inject a value into the errant variable. 
  
 A more secure approach places the path to the library directory in a 
 constant. 
 A constant",NA
,"When setting up access rules, create rules for all of the IP addresses used to access the site, including the 
 loopback interface, 
 127.0.0.1
 . 
  
 Even with these safety checks in place, it’s still possible to create a request loop: simply add a proxy 
 server to relay the request:
  
 $_GET[‘var’] = “http://validator.w3.org/check?uri=URL_TO_CURRENT_PAGE”; 
 require $_GET[‘var’]; // rinse, lather, repeat...
  
 The example above uses the W3C validator to proxy the request to the intended destination. The 
 URL is opened by the W3C server, thus completely masking the originator of the request and easily 
 bypassing the IP-based rules. 
  
 Ultimately, the only sure way to avoid a request loop is by not making requests to remote 
 servers for data, unless you’re requesting a pre-determined URL of a “safe” server, such as an XML 
 feed from Google, Amazon, or your trusted friend’s RSS feed.",NA
Validating File Names ,"The filename component of an included file is somewhat less dangerous than the path, as it can only 
 be used to load existing files from the system. Nonetheless, it can still be used by hack-ers to perform 
 a whole series of untoward operations.
  
 Download from Wow! eBook <www.wowebook.com>
  
 For example, by pre-pending the file name with a series of 
 ../
  strings (referring to the parent 
 directory of the file), it’s possible to make PHP access directories outside of the direc-tory structure 
 specified by the script and display contents of any web server readable file on the system. These can 
 include authentication files such as 
 /etc/passwd
  that contains sensitive system login information:
  
 $_GET[‘t’] = ‘../../../../etc/passwd’; 
  
 // injected value
  
 // open a compiled Smarty template based on user provided string. 
 require “/home/user/app/templates_c/”.$_GET[‘t’];",NA
Securing Eval ,"While securing access of scripts and generic files is relatively simple, securing another possible 
 source of code injection, the 
 eval()
  function, is far trickier.
  
 The best way to secure 
 eval()
  is to avoid using it—it really 
 is
  that bad. The function doesn’t 
 impose any restrictions on what you can execute and there’s no handy validation routine for its 
 parameters. If you mistype the name of the variable that contains the PHP code to execute, 
 eval()
  
 resolves an empty string to 
 NULL
 , giving you no evidence that anything is wrong. At the same time, 
 if register globals is enabled, the user can supply the value for the mistyped variable and have any 
 arbitrary code executed. 
  
 Moreover, the 
 eval()
  process isn’t especially fast, making it a poor choice for high-per-
 formance applications. Even when an opcode cache is utilized, because the input parameter can be a 
 dynamic string and may change on each request, the final 
 eval()
  instructions aren’t 
  
 cached for parsing purposes.
  
 If you absolutely must use 
 eval()
 , there are a few rules to live by. 
  
 Whenever possible, pass a string literal to 
 eval()
  rather than a variable or the result of a 
 function call. Additionally, the literal value should be quoted in single quotes to prevent strings 
 preceded by a dollar sign from being evaluated.
  
 eval(“echo $baz;”); // retrieve value of $baz and use it as code 
 eval(‘echo $baz;’); // print the value of the $baz variable (intended)
  
 If a variable does provide code to be executed, initialize the variable at the start of the script. 
  
 This prevents a logic bug from leaving the variable uninitialized and ripe for exploit. 
  
  
 Alternatively an error handler can be placed around 
 eval()
  to convert notices raised for 
  
 ow! e
  
 ook <www.wowebook.com>
  
 Download from 
 W
  
 uninitialized variables to fatal errors, allowing for quick resolution of a potential vulnerability.
  
 function err_handle($errno, $errstr) { trigger_error($errstr, E_USER_ERROR); } 
 error_reporting(E_ALL); 
  
 set_error_handler(‘err_handle’);
  
 eval( ... );
  
 restore_error_handler();",NA
Dynamic Functions and Variables ,"While included files and 
 eval()
  are the most common code injection vulnerabilities, a few less- 
 known PHP features can also be used to the same affect.
  
 One is dynamic function and/or method calls via the 
 $func()
  syntax or 
 call_user_func-
 tion()
 . Both of these mechanisms execute a function whose name is derived from a variable name. 
 If the user is somehow able to modify or even specify contents of the variable, any arbi-trary 
 function could be executed. 
  
 The scope of the problem is somewhat limited as only an existing function can be called and the 
 parameters to the function remain the same as the ones specified by the script’s writer. 
  
 Nonetheless, this exploit can be abused to make the script perform needless operations. 
  
 For example, by specifying the function name “
 exit()
 ”, the script could be prematurely 
 terminated. Worse yet, the user could try to call 
 apache_child_terminate()
  to try to kill the 
  
 current Apache process, forcing Apache to spend resources recreating the terminated process.
  
 This vulnerability is somewhat difficult to trigger since a call to a non-existent function call 
 always results in a fatal error and consequently is very simple to spot in most situations. But when 
 it comes to security, it’s always better to be safe than sorry, and a basic check reduces the 
 possibility of this problem happening. 
  
 The easiest way to implement such a check is to create an array of all acceptable function 
 names; then, prior to executing the function based on the dynamic name, check to see if the name 
 can be found inside the “white list” array.
  
 $allowed_func = array(‘bbcode’, ‘htmlspecialchars’, ‘raw_html’); 
 if (!in_array($format_style, $allowed_func)) { 
  
 exit(“Invalid formatting function!”); 
  
 } 
  
 $format_style($input);
  
 rom Wow! eBook <www.wowebook.com>
  
 Download f
  
 A similar vulnerability can also be triggered in dynamic variables. One form of dynamic vari-able is 
 $$var
 , where the variable name comes from another variable; another is 
 ${expression}
 , where 
 the value of the expression is used for the variable name. 
  
 Unlike non-existent functions, dynamic variables do not result in a fatal error and conse-
 quently are a bit more difficult to detect. Fortunately, the effect of dynamic variables is fairly limited, 
 although a creative attacker can certainly use them as a prelude to another exploit, such as XSS or 
 SQL injection. In most cases, injection of dynamic variable names allows the attack to output values 
 of existing variables, such as authentication settings stored inside a",NA
Code Injection via PCRE ,"The last, but certainly no less dangerous way to inject code into a PHP script, is via the abuse of the 
 regular expression function, 
 preg_replace()
 .
  
 This particular function allows you to execute PHP code for every sub-pattern matched by the 
 regular expression, if the “e” pattern modifier is specified. The replacement value string is actually a 
 mini-script that is executed via an internal 
 eval()
  operation. If the input is not prop-erly validated, 
 it may be possible for matched pattern to trigger arbitrary code execution. 
  
 To highlight the seriousness of this vulnerability, in December 2004, the first PHP worm ever 
 devised exploited this very weakness. The worm was targeted at the users of phpBB, a commonly 
 used bulletin board where 
 preg_replace()
  with the “e” modifier was being improp-erly used. 
  
 In the end and thanks to the rapid response of Google staff that disabled search results for 
  
 the query used by the worm to find new victims, the spread halted in just over a day. Still,  near-ly 
 50,000 sites were compromised and had their web pages replaced with the worm’s message. 
  
 The cause of the bug? The user input matched by a sub-pattern was placed directly into the 
 evaluated string used to generate the replacement. A URL encoded string was able to bypass the 
 filters utilized by the software, and subsequent decoding resulted in code injection.
  
 The simplest protection against this PCRE code injection is to avoid placing code supplied by 
 the user into the replacement string that gets evaluated as PHP code. To use the phpBB’s 
 highlighting code as an example, a much safer alternative would use a callback function to perform 
 the replacement. 
  
 preg_replace_callback(‘!(\>(((?>([^><]+|(?R)))*)\<))!s’, ‘bb_h’, $msg)
  
 ad from Wow! eBook <www.wowebook.com>
  
 Downl
 o
  
 The purpose of this regular expression is to capture all content found between 
 >
  and 
 <
 , presum-ably 
 data found between two HTML tags. The complexity is partially the result of the need to support 
 embedded tags that may be found inside other tags. To handle this, a recursive regex is used, which 
 allows the data to be either plain-text without 
 >
  and 
 <
  in it, or another tag with its own set of 
 content, which will be captured by a sub-pattern. 
  
 Rather than using the “
 e
 ” modifier, the fix uses the 
 bb_h()
  function for every out-of-tag 
 component of the message body. This means that the regular expression no longer needs to execute 
 any code itself, removing the possibility of code injection. 
  
 As for the 
 bb_h()
  function itself, it secures the user’s list of highlighted words via 
 html-",NA
5 ,NA,NA
Command ,NA,NA
Injection ,NA,NA
I ,"injection is a very close second. Command injections exploit PHP’s dependency on exter-
  
 nal scripts and binaries. 
  
  
 For the most part, PHP scripts work independently, 
 utilizing a myriad of native exten-
  
 f code injection is the most dangerous vulnerability in PHP 
 applications, then command 
  
 Download from Wow! eBook <www.wowebook.com>
  
 sions and functions to perform all kinds of operations. But once in a while, a PHP application must 
 use an external command to complete a specific task. For example, the external com-mand-line 
 utility 
 doc2pdf
  is commonly used to convert an uploaded Microsoft Word document to a PDF 
 document. 
  
 $dest = basename($_FILES[‘upld’][‘name’], ‘.doc’); 
  
 shell_exec(“doc2pdf {$_FILES[‘upld’][‘tmp_name’]} {$dest}.pdf”);",NA
The PATH Exploit ,"In the previous example using 
 doc2pdf
 , no path was provided, so the shell is forced to find the 
 doc2pdf
  command before it can execute it. To find commands, the shell uses the 
 PATH
  environ-
 ment variable—a list of directories that contain binaries—to guide its search. If a command is not 
 built-in to the shell, the shell traverses the list of directories named in 
 PATH
  in the specified order 
 until it finds a match. For example, if 
 PATH
  is set to 
 /usr/bin:/home/joe/bin:/bin:/usr/
  
 Download from Wow! eBook <www.wowebook.com>
  
 local/bin
  and the command is 
 ls
 , the shells looks for the first occurrence of 
 ls
  in 
 /usr/bin
 , 
 /home/joe/bin
 , 
 /bin
 , and 
 /usr/local/bin
 , in that order. 
  
  
 If a command is found in the fifth directory in the list, an attacker can force the execution of a 
 different binary (albeit with the same name) by placing the new program in the first, sec-ond, third, 
 or fourth directory searched along the 
 PATH
 . (A variant of this attack modifies the 
 PATH
  so that 
 searches start in a specific directory.) 
  
  
 While a local user may be the only capable of performing such this exploit (assuming that the 
 entire machine hasn’t been compromised), it nonetheless allows an attacker to run arbi-trary 
 operations instead of what was intended. 
  
 Admittedly, this attack is relatively rare, but 
 PATH
  confusion often occurs nonetheless be-",NA
Hidden Dangers ,"When executing external commands via PHP, there are a few additional hidden dangers, aside from 
 those posed by command injection.
  
 The first involves file system permissions.
  
 On most systems, PHP runs as an Apache module, usually under a specific user ID set aside just 
 for the web server. In this configuration, external commands execute as the web server, implying 
 that if a command requires a filesystem resource, the web server must have access to that resource. 
 For instance, if the web server must write to existing file 
 /home/joe/ data
 , 
 data
  must be world-
 writeable (
 0666
 ). If the web server must instead create 
 /home/joe/ data
 , then 
 /home/joe
  must 
 be world-writeable (
 0777
 ). Read operations are only slightly better: world-readable access is 
 sufficient. Of course, the command executed by the web server must also be accessible. 
  
 Download from Wow! eBook <www.wowebook.com>
  
 An alternative to loose permissions is to make the web server the 
 owner
  of the files and 
 directories your application must access using 
 chown
 —but this something only the system ad-
 ministrator can do. 
  
 # Web Server runs as user/group www 
  
 chown –R www:www /home/user/app 
  
 # Lock permissions 
  
 find /home/user/app –type d | xargs chmod 700 
  
 find /home/user/app –type f | xargs chmod 600",NA
Application Bugs and Setting Limits ,"Aside from the headache of securing permissions on files and directories, external applications can 
 have bugs and exploits, too. For example, conversion utilities are often very complex and bugs are 
 common, including crashes. Repeated requests to a buggy application, say, with a 
  
 Download from Wow! eBook <www.wowebook.com>
  
 specially-crafted file known to exacerbate faults, can fill the system log or fill the filesystem with 
 core files (memory dumps of the running application at the time of the crash).
  
 For example, certain, perfectly-valid Microsoft Word documents cause 
 doc2html
  to loop 
 indefinitely, exhausting the CPU. In some instances, a “runaway” command-line utility may continue 
 to execute even after the script that launched the utility has terminated. Such “or-phaned” runaway 
 processes must then be forcibly terminated by the administrator.
  
  
 You can prevent a runaway process from killing your server by assigning it a low priority, 
 granting other processes more favorable scheduling. 
  
 To change the priority of a process, use the 
 nice
  command (on Linux and Unix) and specify",NA
6 ,NA,NA
Session Security,NA,NA
S ,"expires). end-user. Once an end-user provides his or her credentials to a site, the session 
 mecha-
  
 nism maintains that online identity (until the user leaves the site, signs off, or the session 
 essions are a very helpful tool used by most web applications to identify and track an 
  
 Download from Wow! eBook <www.wowebook.com>
  
 However, a third-party is able to acquire a session, it can assume the user’s identity and 
 subsequently perform any action that the user has rights to execute, such as posting on bul-letin 
 boards, making purchases, or even administering the site. As PHP makes rapid headway into 
 enterprise applications where sensitive data is prevalent, prevention of session theft is absolutely 
 essential. 
  
 To secure sessions, it’s important to understand how session information is stored and how it’s 
 passed between requests. By exploring how sessions work, it’s possible to foresee pos-sible attacks 
 and devise ways that reduce the risk of session compromise.",NA
Sessions & Cookies ,"In most cases, session information, including the session ID string, is stored inside a 
 cookie
 . When a 
 session is created, the web server responds with (among other headers and informa-tion) a 
 Set-
 Cookie
  header that asks the browser to create a cookie. 
 Set-Cookie
  has the form:
  
 Set-Cookie: cookie_name=value; path=/; domain=my.domain.com
  
 If the browser likes the cookie, it writes the cookie data to its internal cookie data store, which is 
 usually a plain text file. (Internet Explorer creates a separate file for each cookie, while Mozilla 
 Firefox keeps all cookies inside a single file.) The cookie store is human-readable, presenting 
  
 the first and often convenient way to steal a user’s session: simply look at the cookie files on the 
 user’s machine. Admittedly, most attackers won’t sneak into your house to steal your ses-sion 
 cookies, but many people use public computers in libraries, internet cafes, and at work, which can 
 be readily accessed by a malefactor. On a networked machine, where a user’s home directory may 
 be served from a remote file server, it may be possible to steal cookies via packet sniffing or by 
 compromising the central server. 
  
 Once a session is accepted, the browser sends a special 
 Cookie
  header containing the 
 name and the value of the cookie with each request. 
 Cookie
  may transmit information about 
 multiple cookies, in which case the (name, value) pairs are separated by a semicolon, like this:
  
 Cookie: cookie_name=value; other_cookie=more text;
  
 ad from Wow! eBook <www.wowebook.com>
  
 Downlo
  
 Once your PHP application receives the request, each cookie name is transformed to a key of a 
 $_COOKIE
  superglobal that contains the value of that particular cookie.",NA
Man in the Middle Attacks ,"During standard HTTP transactions, all request and response information is transmitted as plain-
 text. Anyone capable of intercepting these messages can steal the user’s session. 
  
 Sound implausible? Hardly. The connection between a client and a server is rarely direct, 
 instead passing through a fair number of intermediate servers. A packet capturing utility de-ployed 
 on any one of those servers could record the session. And even if the client-to-server",NA
URL Sessions ,"Backtracking a little bit, a session id isn’t always passed via cookies. Many users disable cookies in 
 their browsers or configure the browser to reject all cookies. However, any site that depends on the 
 notion of a user or a shopping trip must still track the user. If cookies are unavailable, the browser 
 must resort to passing the session id via 
 GET
  or 
 POST
 . 
  
 GET
  requests send the session string as part of the URL; 
 POST
  transmits the session string in a 
 hidden field. Once received by the web server, the session string is processed in the same",NA
,"Self Exploitation
  
 Download from Wow! eBook <www.wowebook.com>
  
 URL sessions are vulnerable to “kidnapping” by attackers, but users themselves can undermine their own 
  
 security. In many instances when a user comes across an interesting comment on a bulletin board or sees 
  
 an interesting product in a store, he or she will want want to share the information with friends. The fastest 
  
 way to do that? Copy the URL, including the 
 GET
  query, from the address bar in the browser and paste it in 
  
 email! Now, anyone that clicks on the link effectively becomes the originating user. 
  
 Session Fixation
  
 One of the main weaknesses of URL sessions is their susceptibility to 
 session fixation
  attacks. 
  
 This form of attack relies on the attacker’s ability to force the user’s session ID to a predictable 
  
 value. If successful, the assailant can then assume the identity of the victim by sending the 
  
 “premeditated” session ID with a request. Although it sounds difficult, performing a session 
  
 fixation attack is rather trivial. 
  
 Consider the following scenario; site xyz.com has a link to site abc.com, but in the link it 
  
 includes the query string 
 ?PHPSESSID=123
 . The 
 PHPSESSID
  is the default name of the parameter 
  
 used by PHP’s session extension to pass session IDs via URLs. If the user who clicks on this link 
 does not yet have a session on site abc.com, the session handler creates a new session, but assigns 
 the session the very same ID provided via 
 GET
 . At this point, anyone can become the victim by 
 simply adding the same session ID string to a URL. 
  
 By comparison, this form of attack is nearly impossible to do via cookies, because only the site 
 that issues the cookie can set the cookie. If site xyz.com tried to set a cookie for abc.com, the 
 browser would dutifully reject the cookie.",NA
Surviving Attacks ,"Now that you’ve seen some of the weaknesses of session handling, let’s examine the techniques",NA
Securing Session Storage ,"While it’s impossible to secure the session ID on the user’s machine, it’s certainly possible to secure 
 the session information on the server. 
  
 One simple change that greatly improves the security of file-based sessions is to set a cus-tom 
 storage directory for your application. 
 session_save_path()
  moves your session data to an 
 inconspicuous location. 
  
 session_save_path(“/home/user/app/sess/”);
  
 In fact, if your PHP configuration properly restricts file access (say, to your own directory and some 
 common directories) using 
 open_basedir
 , other PHP applications will be unable to ac-
  
  W
  
 w! eBook <www.wowebook.com>
  
 Download 
 from
  
 cess your session files. (Of course, this does not prevent access from web applications written in 
 other languages.) 
  
  
 Additionally, using your own temporary directory for session storage improves data reli-
 ability. When PHP must pick a session name, it generates a random number. In most cases, the 
 randomization is good enough that a unique value is chosen, but it’s not impossible for the random 
 value to collide with a previously generated random number, effectively assigning two users the 
 same session ID. If numerous applications use the same session storage directory, the likelihood of a 
 collision is greater. By keeping session directories separated, there is a smaller chance for confusion 
 to occur.
  
 Using your own directory also reduces the chances of a exhausting all of the disk space",NA
Session ID Rotation ,"Even with short expiry times and safe session data storage, it is still possible for the session id to be 
 stolen by a third party. One effective defense is 
 session rotation
 . 
  
  
 The idea is to create a new session ID 
 upon every request
 . In such a dynamic scheme, an 
 attacker could only hijack a session between requests—a very difficult proposition. 
  
 This defense is particularly effective against virtually all types of session compromises and is 
 especially effective against attacks reliant on 
 HTTP_REFERER
  analysis of URL-based sessions. Using 
 session rotation, the session id stored inside the query string of the referring URL is no longer valid, 
 because a new ID was generated when that page was loaded. 
  
 To implement session rotation, you can use the 
 session_regenerate_id()
  function
 . In",NA
IP Based Validation ,"Additional security checks beyond those already described involve analysis of the user’s unique 
 data to see if the person making the request is the true owner of the session. 
  
 One common yet inherently flawed test for ownership is to use the IP address of the user. 
  
 session_start();",NA
Referrer Validation ,"One additional session validation technique checks that the source page shown in 
 HTTP_REF-ERER
  
 is a legitimate “forwarding” page—that is, one that could have led to the current page. If the 
 referring page lay outside the application’s milieu, the session is considered to be invalid. 
  
  
 The most basic type of referrer check simply examines the hostname of the referring site and 
 only allows the session to proceed if it matches that of the current site.
  
 if (!empty($_SERVER[‘HTTP_REFERER’])) { 
  
 $url = parse_url($_SERVER[‘HTTP_REFERER’]); 
  
 if ($url[‘host’] != ‘my.site.com’) { 
  
  
 /* invalidate the session */ 
  
 } 
  
 }
  
 w! eBook <www.wowebook.com>
  
 Download from W
  
  
 If a page has only one direct link leading towards it, the check can be made even stricter to only 
 allow access if the referrer points to that page. 
  
 ini_set(“session.referer_check”, “http://my.site.com/app/pageX.php?abc=123”);
  
 The native session extension allows this particular check to be performed automatically if the 
 referer_check
  setting is enabled and supplied with a value. Unfortunately, the implementa-",NA
User Education ,"The final session security enchantment surprisingly enough doesn’t require any creative code tricks 
 or validation checks. Instead, it depends on smarter users.
  
 Educating users about the possible ways hackers may try to acquire their session is just as 
 important as writing code to reduce this likelihood. For example, encourage your users to logout at 
 the end of each session. 
  
 Another handy tip is to have users pay attention to the links they click on and be wary of URLs 
 with large encoded strings or values resembling session ids leading to the current site from 
 external sites. This tip alone, if followed, could probably prevent at least a third of all XSS",NA
7 ,NA,NA
Securing File ,NA,NA
Access,NA,NA
A ,"No matter the size of your application, it’s vitally important to maintain proper access 
 restric-with files. Running a one-line PHP program requires access to the script, while complex 
  
 PHP applications may use a large number of files loaded via constructs and functions. ll PHP 
 scripts big and small share a common point of failure: all scripts need to work 
  
 Download from Wow! eBook <www.wowebook.com>
  
 tions on all parts of your code. Failing to protect the files that contain your code can allow hack-ers 
 and even other users on your system to compromise your script.
  
 But solving this problem is not an easy task. 
  
 In a vast majority of cases, the PHP interpreter is a web server module that operates with the 
 same user ID as the web server. At the same time, the files that the PHP module accesses—in 
 particular script files uploaded by the developer—are owned by the developer’s user account. Due 
 to the differing users, it’s not possible to set secure file permissions (
 0600
  for files and 
 0700 
 for 
 directories), since those permissions would prevent the web server from accessing the files. 
 Moreover, all files and directories leading up to those files must be world-readable (directories can 
 be just world executable) to allow the web server to serve requests. Unfortunately global",NA
The Dangers of “Worldwide” Access ,"While opening your application files is not particularly dangerous, world-readable application files 
 present a serious problem. Many PHP applications work with a database and keep data-base 
 authentication credentials inside a configuration file that’s parsed by PHP during execu-tion. If a 
 local user or a hacker gains access to that configuration file, the database is rendered defenseless.
  
 For example, here is a short PHP exploitation script that uses the system’s 
 locate
  com-mand 
 to find all files with 
 config.php.inc
  in the filename. The generated list is then iterated through 
 and the content of each file is printed to the screen. 
  
 $file_list = explode(“\n”, shell_exec(“locate config.inc.php”)); 
 foreach ($file_list as $file) { 
  
 echo “----------------------{$file}----------------------<br />\n”; 
 readfile($file); 
  
 }
  
 Running this script on a web server would likely reveal all sorts of authentication details. And this 
 exploit is just the tip of the iceberg. 
  
 A much more serious issue is posed by files 
 created
  by PHP scripts. Since the web server 
 typically executes PHP applications, the web server becomes the owner of all new files. This means 
 that any other PHP script on the same web server could potentially read and write those files. On 
 shared hosting solutions, which are numerically the most common situations by far, 
  
 w.wowebook.com>
  
 Download from Wow! eBook <ww
  
 any number of people can read and modify your data. 
  
 A related problem is the permissions necessary to facilitate the creation or modification of files 
 in the first place. If a new file is to be created inside your home directory hierarchy, the normal 
 permissions of a directory (
 0755
 ) don’t suffice, because the home directory is owned by you and the 
 web server is running as another user. To allow a file to be created in such a scenario, the directory 
 needs to be “unlocked” by changing its permissions to be world-write-able, or mode 
 0777
 . But an 
 “unlocked” directory also grants unlimited access to the data in the directory. 
  
 For files that need only be modified, the situation is only slightly better, as the file needs to be 
 world writable (
 0666
 ), but other files and the enclosing directory need not be “unlocked.”",NA
Securing Read Access ,"Many would discount world-readable files as a problem, especially if the files contain no sensi-tive 
 data. However, it’s important to realize that redable code can be analyzed for logic errors and other 
 vulnerabilities. Exposed code can also reveal specifics about internal protocols—in-valuable 
 information if a hacker wants to devise better packet capturing routines designed to intercept 
 transmissions between the program and it’s users.
  
 PHP Encoders
  
 Download from Wow! eBook <www.wowebook.com>
  
 One possible way to keep code safe is the use of PHP encoders, such as the those offered by Zend, 
 eAccelerator and so on, that hide PHP source code inside a binary file. Even if someone gains the 
 ability to read a binary file, they would not able to able to glean anything useful out of it, aside from 
 a stream of seemingly random ASCII characters. 
  
  
 The encoder’s job is two fold: 
  
  
 First, it provides a tool for converting a human readable script to an internal binary for-mat, 
 which may simply be a binary representation of an opcode array or may be an encrypted variant of 
 the same array. (An opcode array is a series of instructions normally produced by the PHP’s parser 
 based on the script’s contents and then passed along to the executor for interpre-tation.)",NA
,"The limitation imposed by 
 open_basedir
  applies to all means of file access and the directive 
  
 Download from Wow! eBook <www.wowebook.com>
  
 can be set individually for each 
 VirtualHost
 , allowing a specific value to be specified to each 
  
 user. Ideally, this value is set to the user’s home directory and possibly the system-wide PEAR 
  
 repository. 
  
 The example use of 
 open_basedir
  above does just that. The 
 open_basedir
  directive for the 
  
 specified site is set to the home directory of the developer managing the site and the PEAR re-
  
 pository available on the server. 
  
 The forward-slash found at the end of each path is quite important: without it, any directory whose initial 
  
 path matches the specified value is rendered accessible. For example, had the directive specified 
 /home/
  
 user1
  as the limit, the scripts executed under this site would be able to manipulate files found inside 
 /home/
  
 user12
 , 
 /home/user13
 , and so on. The terminating directory separator limits PHP to only those files inside 
  
 the specified directory and its subdirectories.
  
 With this security mechanism in place one may think that the files of each user are now safe from 
 outside intrusion, but that couldn’t be further from the truth. While this directive does restrict 
 PHP
  
 from being able to access data of other users, it doesn’t restrict other scripting lan-guages or utilities 
 that could be running via the CGI wrapper. 
  
 But there is one mitigating factor: a script executed under the CGI wrapper executes as its 
 owner, which allows you to use standard file permissions to protect your PHP application. By 
 setting permissions of all web server directories to 
 0700
  and the permissions of all web server 
 created files to 
 0600
 , you restrict access to those resources to just the web server.",NA
Securing Write Access ,"Writeable files such as compiled Smarty templates owned by the web server pose an even big-ger 
 problem than world-readable files: if modified, the templates could allow an attacker to change the 
 content of your site. Given the ability to execute PHP code, an attacker could also easily access 
 hidden database authentication information or at the very least gain access to the data stored, 
 neither of which is a desireable or welcome prospect.
  
 One possible way to protect web server writable files against unauthorized modification is a 
 checksum validation of the file prior to its usage. Using Smarty as a test case, let’s examine the 
 process of generating and accessing the compiled templates and see how the process can be 
 adjusted to improve security.",NA
Safe Mode,"Download from Wow! eBook <www.wowebook.com>
  
 A slightly different approach to file security is offered through the 
 safe_mode
  INI setting. As its 
 name implies, this particular option tries to make PHP “safe”—the operative word being try. In fact, 
 safe mode is about as strong as a wet paper towel. 
  
 The premise of 
 safe_mode
  is that a script is granted access only to those files and directo-ries 
 owned by the owner of the script itself.  For example, if a script is owned by user “abc”, that script 
 may only access files and directories owned by “abc” or at least reside inside directories owned by 
 that user. 
  
 The problem with 
 safe_mode
  becomes apparent when you consider that many applications 
 create files and directories during the course of operation. And, as you’ve seen, the web server",NA
An Alternate PHP Execution Mechanism ,"While solving the file security issue from within PHP may hold appeal for those seeking a quick 
  
 Download from Wow! eBook <www.wowebook.com>
  
 fix to the problem, it by no means assures file security. Even the 
 open_basedir
  restriction can be 
 bypassed: it’s simply a matter of not accessing the file via PHP directly, but instead executing a 
 third-party program via one of PHP’s command execution functions. 
  
 shell_exec(“rm –rf /tmp/*”);
  
 The 
 shell_exec()
  above executes as the web server user, but unlike PHP, the 
 rm
  command has no 
 restrictions other than those imposed by the system’s file permissions.",NA
Shared Hosting Woes ,"So what options do you have? A high-performance Apache module that’s impossible to secure fully? 
 A secure, but slow and expensive CGI? A FastCGI that has a good mix of performance and security, 
 but suffers from complexity and stability problems? 
  
 Download from Wow! eBook <www.wowebook.com>
  
 The real solution for file security ultimately lies not within the SAPI used to execute PHP, but in 
 the server itself. If the server is a shared host, other users pose a significant threat. Even if the you 
 trust the other users, you cannot trust their applications. Vulnerabilities such as code injection 
 threaten the entire server. 
  
 A possible solution is a dedicated server or a Virtual Private Server (VPS), which offers each 
 user a private environment that they can fully control. For example, a VPS can be configured to run 
 the web server as the owner of the site, thus attaining high security with excellent perfor-mance. If a 
 small number of sites are hosted, it may even be possible to run an individual web server instance 
 for each site, thus ensuring that if one is compromised, the server is still safe.",NA
File Masking,"One last file security issue involves the creation and manipulation of files inside the temporary 
 directory and other world-writable directories. This problem is specific to systems that imple-ment 
 symbolic links, so for once, Windows users can rejoice, as this problem doesn’t affect you. 
  
 A symbolic link (or symlink) is a filesystem entry that refers to another file or directory on the 
 system but otherwise looks like a regular file or directory. Symbolic links are useful because a file can 
 “virtually” exist in multiple locations without having to make distinct physical copies. Even better, 
 modifications to the original (“true”) file are instantly reflected in all of the sym-bolic links—which 
 makes sense, since only true copy of the content exists no matter how many references are created. 
 Of course, modifying a symbolic link modifies the original. 
  
 Another interesting feature of symlinks is that they can be made to “point” at non-exis-tent or 
 non-readable files for the current user. For example, it’s possible to create a symbolic link to point to 
 the Linux password file, 
 /etc/shadow
 , even though only the root user has the ability to read it.
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 ln –s /etc/shadow local_name; 
  
 ls –l local_name; 
  
 lrwxrwxrwx  1 1000 103 11 Jun  3 10:17 local_name -> /etc/shadow
  
 A symbolic link by itself does not grant the creator access to the file that it points to, so file per-
 missions are not bypassed, but it does create a situation that may be exploited. 
  
 Suppose there’s a PHP script running as root that performs a periodic task. This script hap-",NA
,"When checking for symlinks, specifically use the 
 is_link()
  function instead of  
 is_file()
  or 
 is_dir()
 , as the 
 latter two resolve the link and check the source rather then the link itself.
  
 Given that the majority of symlink problems stem from links created inside the world-writable 
 /tmp
  
 directory, it is generally a good idea to prevent PHP scripts from having access to it. Keep-ing 
 /tmp
  
 off-limits prevents PHP scripts from exploiting this problem and keeps other applica-",NA
8 ,NA,NA
Security through ,NA,NA
Obscurity,NA,NA
S ,"tion for security through obscurity, explains when it’s best to apply it, and describes proper 
 and that’s unfortunate, because its poor reputation stems largely from a general misun-
  
 derstanding of its intended purpose and its misuse. This chapter describes the motiva-ecurity 
 through obscurity probably has the worst reputation of any security technique 
  
 Download from Wow! eBook <www.wowebook.com>
  
 usage.",NA
Words of Caution ,"It’s vitally important to understand that security through obscurity is just another tactic to secure 
 your code and, like most security techniques, is best used in combination with other techniques. 
 Security through obscurity is not some ultimate form of protection. Just look at the number of 
 proprietary
  applications that are compromised each month as evidence: closed source—
 implementations hidden by obscurity—can be attacked just as easily as open source. In fact, if 
 anything, closed source tempts attackers to demonstrate just how ineffective obscur-",NA
Hide Your Files ,"Unlike closed source, compiled applications, where the source code can be (or is) hidden to obscure 
 bugs and vulnerabilities, PHP applications are completely transparent, especially if the application 
 is available for the public to purchase or download. Indeed, unless PHP code is encoded using a 
 Zend Encoder (something that is exceptionally rare), virtually anyone can examine the source of an 
 application to search for weaknesses to exploit. In most cases, PHP 
  
 Download from Wow! eBook <www.wowebook.com>
  
 code can only be obscured via an encoder module, but that is quite problematic for reasons covered 
 in the previous chapter.",NA
,"Some people try to simulate encoding by writing unreadable code. However, that practice is self-defeating. 
 Maintaining such code is time-consuming, complex, and prone to errors. 
  
 So what can be safely obscured in PHP? 
  
 Most PHP applications include some form of administrative “control panel”, typically ac-
 cessible from a directory (brazenly) named “admin” or “adm”. An application may even use a simple 
 script named 
 admin.php
  if all of the application’s configuration options can fit on a",NA
,"One approach to uniformly obfuscate db names is to use a sequence with a single letter prefix, such as “f” 
  
 for function, “c” for class”, and “m” for method. Add the position of the entry to the prefix, so the first func-
  
 tion found becomes “f1”, the second function becomes “f2”, and so on. When it comes to parsing other files, 
  
 just increment your entity counter, ensuring that names are unique and that you can restore the code to 
  
 its original form.",NA
Transmission Obfuscation ,"Perhaps the one place obfuscation can be of most benefit is at the time your server communi-cates 
 with your visitors. The majority of web (HTTP) connections are sent unencrypted, which presents 
 an enormous opportunity for anyone with a packer scanner sitting between the send-er and the 
 recipient to usurp information. 
  
 A proper solution for this problem involves the use of secure HTTP (HTTPS), but HTTPS use is 
 relatively rare and cannot be relied upon to be available. Factors such as SSL certificate costs, the 
 need for a dedicated IP address, and your ISP’s support for HTTPS represent a fair number of 
 barriers to entry. Consequently, most applications end up working in environments where 
 transmission interception is quite possible and relatively easy to perform. 
  
  
 In these instances, obfuscation can be tried so as to slip under the radar of various scan-ners 
 looking for specific patterns. Again, obfuscation does not address the core problem, but it 
  
 does make it more difficult for attackers, which may act as a deterrent.
  
 The majority of packet interceptions are generally not aimed at capturing session informa-tion, 
 but instead vie to record authentication information that can be used to gain complete access to the 
 victim’s account. Better yet—for the attacker that is—authentication information (even across 
 multiple applications) typically conforms to a pattern, making it easy (yet again) to write a filter to 
 capture credentials from any number of sites that the victim visits. 
  
 For example, many applications use a field name based on the word “password” (and a few 
 prevalent variants) to send password information. An attacker’s filter would simply need to trigger 
 on requests containing the text “pass” in the URL or 
 POST
  headers. 
  
  
 Once again, commonalities between applications make the hacker’s job that much easi-er—
 something that should trouble every developer. 
  
 Obscure Field Names
  
 Download from Wow! eBook <www.wowebook.com>
  
 Obfuscation to the rescue! 
  
 Rather then sending authentication information via “login” and “password” fields, choose 
 completely random field names. For example, “login” can become 
 fieldA
  and “password” can 
 become 
 fieldB
 . With those small changes, any non-application-tailored packet capturing utility 
 will fail to detect the “trigger” string and allow the data to pass-through “unnoticed”. To any-one 
 without the knowledge of what the two fields really mean, this is just another 
 POST
  request without 
 any valuable data to steal. In a way, this technique allows your authentication informa-tion to hide 
 in plain sight.",NA
9 ,NA,NA
Sandboxes and ,NA,NA
Tar Pits,NA,NA
S ,"However, going on the offensive (albeit in self-defense) is something that must be done 
 watching hackers try to compromise your system, you can actively give them a dose of 
  
 their own medicine. 
  
 omeone once said that the best defense is counter-attack. Rather then stand idly by, 
  
 Download from Wow! eBook <www.wowebook.com>
  
 very carefully to avoid placing 
 yourself
  on the wrong side on the law. While trying to compro-mise 
 systems is illegal in most countries, compromising a hacker’s system in revenge is just as illegal. To 
 complicate matters further, hackers often hide behind and leverage other com-promised but 
 otherwise legitimate systems as a form of disguise. It is possible—perhaps even likely—that 
 retaliation would merely add insult to injury to some hapless, innocent host. 
  
 Legally and ethically, the only proper response to an attack is one that doesn’t “harm” the 
 source of the attack, but instead tries to severely limit the impact of the attack and contain the 
 attacker, preventing additional harm to other systems at your site or to systems at other sites. 
 Additionally, you can also “retaliate” by gathering evidence about the attack and pursuing ac-tion 
 with the attacker’s Internet service provider (ISP) and perhaps the relevant authorities.",NA
Misdirect Attacks with Sandboxes ,"One way to disrupt hack attempts and glean information about the form of attacks is to set up a 
 sandbox
 . A sandbox or honeypot is a special machine or a portion of a site intended specifically to 
 attract hackers. Its goal is to distract attackers from your server or actual site and to waste their 
 time and energy on a mirage. Aside from misdirection, a sandbox can also gather valuable 
 information about commonly tried hacks, which can be helpful in securing your own software. 
  
 In the words of Sun Tzu, “Know your enemy and know thyself.”
  
 Building a Sandbox 
  
 When setting up a sandbox, it’s important to choose a portion of your site that’s likely to be a 
 frequent target of attackers. One good choice is the “admin” directory, since it’s expected to contain 
 various juicy administrative tools. 
  
 If you followed the procedures described in the previous chapter, “admin” has been re-named 
 to obscure it. However, a hacker need not know that—in its place, provide a “fake” di-rectory to 
 serve as a target. Since the sandbox has no real purpose (except as a trap), any activity there 
 probably means mischief. By misdirecting initial attacks to the sandbox, the hacker can be identified 
 and, if necessary, blocked from further access to the site.
  
 To guide hackers to the sandbox, you can make use of your site’s 
 robots.txt
  file. This file is 
 normally used to control search spiders by specifying which portions of your site may and may not 
 be indexed. It’s common, for obvious reasons, to have search engines skip over “admin” and other 
 private pages by listing those locations in 
 robots.txt
 . For example, these two lines tell all spiders 
 to skip 
 /admin/
 . 
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 User-agent: * 
  
 Disallow: /admin/
  
 However, it isn’t wise to enumerate what’s really sensitive on your site. A malcontent can sim-ply 
 download the 
 robots.txt
  file (it has to be public, after all) and concentrate an attack on those 
 directories. For example, in most cases, “secret” pages such as template directories aren’t directly 
 linked from the site, which means that placing the paths to them inside 
 robots.txt
  is",NA
Limitations with IP Addresses ,"When performing IP operations, it’s important to keep in mind that the address found in 
 RE-",NA
Smart Cookie Tricks ,"Similar to banning an attacker based on his or her IP address, you can also ban a user if a certain 
 cookie exists. Your sandbox can attempt to set a long-lived cookie on a hacker’s machine; then, all 
 legitimate and private web pages can check for the cookie and reject access if it exists. 
  
 This “scarlet letter” technique is surprisingly effective, since it only affects the attacker’s own 
 machine, and in most cases goes unnoticed. And given that a cookie is not IP-specific, countering 
 tactics such as changing IPs, using proxies, or evening moving to a completely dif-ferent ISP won’t 
 dislodge it.
  
 setcookie(“uid”, md5(rand()), time() + 86400 * 365, “/”, “.site.com”); 
  
  
 When setting “ban cookies”, it’s a good idea to take a page from the obfuscation chapter and name 
 the cookie in a way that’s undistinguishable from something your site would use nor-mally, such as a 
 session ID. With a little obfuscation, even if the attacker does spot the cookie, they’ll be less inclined 
 to remove it, thinking it to be a regular part of your site’s operations. The duration of the cookie 
 should stick around for a long time. In the 
 setcookie()
  example above, the 
 uid
  cookie’s lifetime is 
 set to one year (
 86400
  is the number of seconds in a day). 
  
  
 Once the cookie is set, your actual application need only check for the presence of the “uid” 
 cookie to differentiate real users from hackers. 
  
 if (!empty($_COOKIE[‘uid’])) exit;
  
 ad from Wow! eBook <www.wowebook.com>
  
 Downlo
  
 The one-liner above simply terminates if the named cookie is found, resulting in a white page. 
 However, you may find that a more creative approach such as dumping an SQL error may prove to 
 be more affective. Most hackers will move on to other targets rather then spending their time trying 
 to compromise an already broken site.",NA
Record the Referring URL ,"Aside from the IP address information mentioned above, you may also have an 
 $_SERVER[‘HTTP_ 
 REFERER’]
  (yes, the spelling is correct) value to analyze. This variable, which you’ve seen many 
 times before in previous chapters, is of a particular interest here. Given that there are no links",NA
Capture all Input Data ,"Beyond tracking IP address and bogus user names and passwords, you can also keep a record of the 
 various values the attacker is trying to supply via 
 GET
 , 
 POST
 , and even cookies. These val-ues often 
 contain various special strings such as SQL injections and cross-site scripts intended to trigger 
 unexpected operations. By logging these values, it’s possible to create a database of commonly 
 attempted attacks and use those to test the security of your own site and applica-tions. 
  
  
 When tracking this information, it’s best to extract the “raw” values, as the per-variable values 
 generated by PHP may already exhibit some consequence of the attack.",NA
Build a Tar Pit ,"Aside from capturing the attacker’s information it may also prove advantageous to slow down the 
 rate of the attack, in particular when an automated script is being used.
  
 Rather than allowing requests to hit the sandbox as fast as the attacker can send them, 
  
 you may be able to slow them down. Instead of replying to each request right away, delay the 
 response using 
 sleep()
 . 
  
 <?php 
  
 sleep(20); 
  
 /* print output */ 
  
 ?>
  
 The 
 sleep()
  function idles the script without adding load to the server. After the script “wakes”, 
 return a response. 
  
 In addition to slowing dictionary attacks and perhaps preventing the server from over-load, 
 a delay tactic is also effective against manual attacks. An attacker is likely to lose patience after 
 waiting twenty seconds between requests and may prompt the mischief-maker to find an 
  
 ebook.com>
  
  
 <www.wo
 Download from Wow! 
 eBook
  
 alternate, less frustrating target. 
  
  
 The downside of imposing a delay is that it takes up a web server process, which could 
 have otherwise been used to deliver content to real users.",NA
,"A more performance friendly solution may involve the use of JavaScript to delay page response, but that would 
 not be affective against an automated script and could be easily spotted by a human attacker.",NA
10 ,NA,NA
Securing ,NA,NA
Your ,NA,NA
Applications,NA,NA
I ,"use. Unfortunately, reality is typically less than ideal, and developers and administrators are of-
 process, included as part of the application’s initial design, coded and audited throughout 
  
 development, tested prior to deployment, and vetted continuously when in production deally, 
 securing an application would be an inherent part of the software development 
  
 Download from Wow! eBook <www.wowebook.com>
  
 ten tasked with maintaining an existing code base. Securing inherited, perhaps legacy (already 
 deployed) code is quite a bit more difficult, since there’s an immediate, large code base to audit and 
 you may not be able to change the behaviors and calling sequences of existing APIs and conventions. 
 Leaving an application insecure is simply not an option, so a logical and consis-tent approach is 
 needed to make the code as safe and secure as possible. 
  
 This chapter presents a series of steps to follow to audit and secure existing code. While no 
 security audit can reveal all possible problems, a proper audit can at least address a major-ity of 
 significant issues and create a framework to detect, analyze, and resolve any problems discovered 
 later.",NA
Enable Verbose Error Reporting ,"The first step to secure a PHP application is to enable those PHP features that track application 
 errors. Application errors often point directly to or provide clues about vulnerabilities. 
  
 For example, many of the register global-related uninitialized variable errors can be de-tected 
 simply by raising the error reporting level within an application. Here’s some code to do just that:
  
 error_reporting(E_ALL); // in PHP 5.0 E_ALL | E_STRICT 
  
 ini_set(“display_errors”, 0); 
  
 ini_set(“log_errors”, 1); 
  
 ini_set(“error_log”, “/home/user/logs/app_xyz.php.log”);
  
  
 The first two lines of code enable the tracking of all errors (
 E_ALL
  in PHP 4.0 or 
 E_ALL | E_ 
 STRICT
  in PHP 5.0 and above), including warnings, fatal errors, and notices about uninitial-ized 
 variables. The second line of code disables the display of errors, so that the code can be deployed in 
 a production environment, while lines three and four specify that errors should be logged to a 
 named file—an easy way to monitor error messages in any pager or editor utility, such as 
 less
  or 
 vim,
  respectively. To use this snippet, just place it at the top of any application, in a header for 
 example.",NA
Replace the Usage of Register Globals ,"If possible, you should change the application to not retrieve user input via PHP’s register glo-bals. 
 If you undertake such modifications, however, it’s best to perform your audit and verify your 
 changes on a separate, test system that does not interfere with your production system. 
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 Before disabling 
 register_globals
 , determine if its 
 alternatives
  are being utilized by  run-
 ning a simple 
 grep
  command across all of the code:
  
 grep –rI “_\(GET\|POST\|COOKIE\|SERVER\|REQUEST\)” /home/user/app/*
  
 This 
 grep
  recursively searches through all non-binary files inside the specified directories, looking 
 for common superglobal names or the equivalent, pre-PHP 4.1 alternatives, such as 
 HTTP_GET_VARS
 .",NA
Avoid $_REQUEST ,"While the 
 $_REQUEST
  superglobal is convenient for accessing input from multiple sources, it 
 obscures the actual source of the data. Such opaqueness can lead to vulnerabilities and bugs caused 
 by unexpected input. For example, a cookie could overwrite the intended input pro-vided via 
 GET
  or 
 POST
 . 
  
 Since it’s better to be safe than sorry, the usage of 
 $_REQUEST
  is something best avoided. 
  
 Fortunately, detection of its usage is downright trivial with 
 grep
 :",NA
Disable Magic Quotes ,"If the 
 php.ini
  option 
 magic_quotes_gpc
  is enabled, all 
 GET
 , 
 POST
 , and cookie variables sent to 
 the application are automatically filtered to “escape” special characters such as backslash 
 \
  and the 
 single and double quote characters. The intent of 
 magic_quotes_gpc
  is to make strings safe for 
 direct use in SQL queries. 
  
 There’s been a great deal of debate about the merits of 
 magic_quotes_gpc
 , but to enhance 
 security, it’s best to disable this feature and add a normalization function to process all input 
 according to the needs of the application. (An example normalization routine can be found in the 
 first chapter of this book.) A normalization function—something you provide—ensures that the 
 input values are consistent, regardless of the PHP’s settings.",NA
Try to Prevent Cross-Site Scripting (XSS) ,"Unfortunately, checking for cross-site scripting (XSS) attacks is hard to automate, because it often 
 requires manual checking of all of the form and input parameters that end up being dis-played to the 
 user. 
  
 There is however something that can simplify the process: the XSS spider. The XSS spider is a 
 special string (like  
 >///\0/\\\<
 ) that contains all of the characters that if left verbatim could 
 cause problems. By filling all of the form fields and 
 GET
  parameters with this “marker”, you can 
 detect places where the content is being mishandled by the application in one fell swoop. In an 
 event of a non-validated input, the “spider” might cause breakage of HTML, identifying an XSS 
 problem. The basic premise the spider works on is that field attributes such as value are normally 
 enclosed inside quotes, be they of single or double varienty. A unencoded quote would result in the 
 premature termination of an attribute and the 
 >
  termination of the tag. The 
  
 subsequent data will then be then displayed to screen, demonstrating a potential XSS. 
  
 Aside from XSS validation the spider contains other special chars that if left as is may trig-ger 
 SQL injections or break JavaScript, such as 
 \
  and
 ‘
  making it a perfect all around validation marker. 
 So, when testing your web forms, rather then placing valid values, try to populate the fields with the 
 spider and see what effect it has on the generated page. The results may be quite surprising.",NA
Improve SQL Security ,"Unlike the previous precautions, securing SQL requires a bit more work, as it’s often difficult to tell if 
 a query is subject to SQL injection or not. The variables placed into the query may come from any 
 part of the code and you’ll have no choice but to track down their origin and deter-mine their 
 contents. There are however a few ideals to follow.
  
 Download from Wow! eBook <www.wowebook.com>
  
 Whenever possible, try to use prepared statements, which not only speed up execution, but 
 also prevent dynamic values placed in the query from being used as anything other than values.
  
 pg_prepare($db, “qry1”, ‘SELECT * FROM users WHERE id=$1’); 
  
 pg_execute($db, “qry1”, array((int)$_GET[‘id’]));
  
 When you cannot create prepared query statements—which holds true for the MySQL and SQLite 
 extensions—careful parameter validation is absolutely essential.",NA
Prevent Code Injection ,"Code injection vulnerabilities are very dangerous. Any operation that potentially exposes your 
 application to this exploit should be audited very carefully. 
  
  
 The first and simplest step to take to avoid code injection is to examine the code loading 
 constructs and functions being used. Once again, 
 grep
  is an invaluable tool for this task.
  
 grep –riI “\(include\|require\|eval\)” /home/user/app/*
  
 Download from Wow! eBook 
 <www.wowebook.com>
  
 D
  
 The 
 grep
  command above performs a case-insensitive search to find all of the mechanisms 
 normally used in PHP to execute code. Once the instances are found, make sure that full paths for 
 include/require
  are used and that such statements (ideally) omit embedded variables. If 
 dynamic components are needed, use constants, which cannot be injected into the script. 
  
  
 If any user input names compiled templates, make sure the names are filtered through the 
 basename()
  function, which removes path components, leaving just the file’s name. 
  
 Finally, make sure that 
 include
  and 
 require
  are only used for actual PHP code. A common 
 mistake is to use 
 include
  or 
 require
  to load plain text data like a header or a footer, something",NA
Discontinue use of eval() ,"As a rule of thumb, it’s also best to avoid 
 eval()
 . In most cases, it is simply too difficult to validate 
 and even the simplest mistake can lead to code injection. If you absolutely must use 
 eval()
 , try to 
 ensure that the content to be evaluated doesn’t contain any variables that origi-nate with or can be 
 modified by user input.",NA
Mind Your Regular Expressions ,"Similar to 
 eval()
 , the function 
 preg_replace()
  with the 
 e
  modifier can also be used to execute 
 code on each found pattern. If an application relies on this use of 
 preg_replace()
 , consider 
  
 changing it to 
 preg_replace_callback()
  or make sure that the replacement string is not af-fected 
 by users input in any way.  The former solution uses a pre-defined function to replace the string, 
 eliminating the possibility of injecting code; the latter mandate ensures that only the specified code is 
 executed and nothing more.",NA
Watch Out for Dynamic Names ,"The most difficult thing to detect during a security audit is the use of dynamic variable, func-tion, 
 method, and property names. In those instances, the entity to execute or evaluate may change 
 depending on the situation. Locating these instances can be done in part by judicious use of 
 grep
 , but 
 some uses require manual code analysis anyway. 
  
  
 To begin, look for dynamic function and method names, as these present the most dan-ger.
  
 Download from Wow! eBook <www.wowebook.com>
  
  
 grep –rI “\$[_a-zA-Z][A-Za-z0-9_]*[:space:]*(“ /home/user/app/*
  
 The regular expression in the 
 grep
  command above searches for a dollar sign followed by a valid 
 PHP identifier (which consists of a underscore or a letter as the first character, followed by any 
 number of letters, numbers and underscores), followed by any number of optional white spaces, 
 and ending with a right parenthesis. This should detect most dynamic function and method calls, 
 except for those where the variable holding the name and the parenthesis are on separate lines, as 
 grep
  works one line at a time.",NA
Minimize the Use of External Commands ,"The last item in the security audit is obscure, but still important. 
  
 A fraction of PHP applications call external applications. Even if it provides nothing else than 
 piece of mind, validate all user input passed to functions such as 
 exec()
 , 
 system()
 , 
 popen()
 , 
 passthru()
 , and 
 proc_open()
  (and others that run external commands).",NA
Obfuscate and Prepare a Sandbox ,"The two very last steps in the security process are optional, but can both slow an attack and detect 
 such provocation. 
  
 Download from Wow! eBook <www.wowebook.com>
  
 First, obfuscate your administrative controls. This provides some small measure of pro-tection 
 against automated vulnerability scanning scripts, which are designed to only check specific locations 
 or look for certain strings.
  
 Next, put a sandbox in place of all displaced panels so an attacker can find “something”. Of 
 course, that something can try to determine the nature of the attack and alert the system 
 administrator that something nefarious may be occurring. A sandbox can also act as a virtual tar pit, 
 delaying the attack by adding delays, recursive URLs to capture spiders, and so on. Hopefully, by 
 the time an crawls out of the tar pit, a fix for the problem—if one does exist—will already have 
 been applied.",NA
Index,"Symbols
  
 See also
  superglobal variables
  
 Download from Wow! eBook <www.wowebook.com>
  
 $_COOKIE  25, 27, 45, 49, 114, 173, 175. 
 See 
  
 avoiding usage  181 
  
 compared to register globals  27
  
 also
  superglobals; 
 See also
  superglobal 
  
 $_SERVER  25, 45, 66, 67, 68, 82, 90, 116, 129, 
  
 variables; 
 See also
  cookies
  
 130, 131, 168, 169, 172, 173, 174, 175, 
  
 $_ENV  25, 45. 
 See also
  superglobals; 
 See also
  su-
  
 176. 
 See also
  superglobals; 
 See also
  super-
  
 perglobal variables
  
 global variables
  
 $_FILES  37, 38, 39, 41, 42, 43, 46, 47, 101, 102, 
  
 and script location  67
  
 103. 
 See also
  file uploads
  
 and XSS  66
  
 array elements  38
  
 $HTTP_GET_VARS  23 
  
 $_GET  25, 27, 28, 30, 43, 44, 45, 91, 92, 93, 
  
 using in place of register globals  23
  
 98, 182, 183. 
 See also
  superglobals; 
 See 
  
 $HTTP_POST_VARS 
  
 also
  superglobal variables
  
 using in place of register globals  23
  
 $_POST  25, 27, 35, 36, 37, 45, 159, 182. 
 See 
  
 .htaccess  27, 37, 43, 81, 175
  
 also
  superglobals; 
 See also
  superglobal 
  
 using to store secure data  82
  
 variables
  
 /etc/passwd  91 
  
  
 $_REQUEST  27, 181, 182. 
 See also
  superglobals; 
  
 /tmp  38, 41, 42, 85, 115, 123, 144, 148, 149, 150",NA
