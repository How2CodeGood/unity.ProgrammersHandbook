Larger Text,Smaller Text,Symbol
Thinking  ,NA,NA
in ,NA,NA
PostScrıpt,NA,NA
Thinking  ,NA,NA
in ,NA,NA
PostScrıpt,NA,NA
Glenn C. Reid,"Addison-Wesley Publishing Company, Inc.
  
 Reading, Massachusetts • Menlo Park, California • New York 
 Don Mills, Ontario • Wokingham, England • Amsterdam • Bonn 
 Sydney • Singapore • Tokyo • Madrid • San Juan",NA
Table of Contents,NA,NA
Preface.........................................................................xi,NA,NA
Chapter 1 ,NA,NA
PostScript as a Programming Language ..................1 ,"DESIGN FEATURES............................................................................2 
  
 STRUCTURED PROGRAMMING TECHNIQUES ...............................3 
  
 PROGRAMMING TASKS.....................................................................4 
  
 WINDOW SYSTEMS, COMMUNICATIONS, AND DISPLAYS............4 
  
 DATA STRUCTURES AND ALGORITHMS.........................................6 
  
 CONCLUDING THOUGHTS ................................................................6 
  
 EXERCISES.............................................................................. 7",NA
Chapter 2 ,NA,NA
PostScript is Not Like C..............................................9 ,"COMPARISON OF LANGUAGE MECHANISMS...............................11 
  
 EXPRESSING AN ALGORITHM AS A PROGRAM...........................12 
  
 THE UNIX SHELL AND OPERATING SYSTEM................................13 
  
 INPUT, OUTPUT, AND THROUGHPUT............................................14
  
 v",NA
Chapter 3 ,NA,NA
Foundations............................................................... 17 ,"POSTSCRIPT LANGUAGE SYNTAX ................................................19 
  
 SIMPLE PROGRAM STRUCTURE....................................................20 
  
 SETTING UP TEMPLATES................................................................24 
  
 DECLARING AND USING VARIABLES.............................................26 
  
 ALLOCATING MEMORY....................................................................29 
  
 GETTING MEMORY BACK................................................................31 
  
 OPENING AND CLOSING FILES ......................................................31 
  
 COMPARISONS AND EQUALITY OF OBJECTS..............................32 
  
 CONCLUDING THOUGHTS ..............................................................34 
  
 EXERCISES.............................................................................34",NA
Chapter 4 ,NA,NA
Some Typical Programs ........................................... 37 ,"A TYPICAL PAGE DESCRIPTION PROGRAM.................................38 
  
 FONT PROGRAMS............................................................................40 
  
 PROGRAMS THAT READ DATA.......................................................42 
  
 QUERY PROGRAMS.........................................................................43 
  
 ENCAPSULATED POSTSCRIPT PROGRAMS.................................43 
  
 PERSISTENTLY RESIDENT PROGRAMS .......................................46 
  
 CONCLUDING THOUGHTS ..............................................................49 
  
 EXERCISES.............................................................................49",NA
Chapter 5 ,NA,NA
Understanding the Stack.......................................... 51 ,"A QUICK OVERVIEW OF DATA TYPES...........................................51
  
 vi
  
 Table of Contents",NA
Chapter 6 ,NA,NA
Trusting the Stack .....................................................67 ,"SAFETY OF DATA ON THE STACK .................................................68 
  
 WHERE ARE THE DATA GOING?....................................................69 
  
 REARRANGING THE STACK............................................................71 
  
 CONDITIONALS AND LOOPS...........................................................73 
  
 RECURSION AND LOCAL VARIABLES............................................76 
  
 CONCLUDING THOUGHTS ..............................................................77 
  
 EXERCISES............................................................................ 78",NA
Chapter 7 ,NA,NA
Building Conditional Statements .............................79 ,"SIMPLE CONDITIONALS ..................................................................80 
  
 SETTING UP THE CONDITION.........................................................81 
  
 CONDITIONALS ARE NOT MAGIC...................................................86 
  
 NESTED CONDITIONALS AND ELSE CLAUSES ............................87 
  
 COMPOUND CONDITIONALS ..........................................................88 
  
 CONCLUDING THOUGHTS ..............................................................90 
  
 EXERCISES............................................................................ 91
  
 Table of Contents
  
 vii",NA
Chapter 8 ,NA,NA
Using Looping Constructs ....................................... 93 ,"LOOP BASICS ...................................................................................94 
  
 USING THE LOOP INDEX.................................................................95 
  
 LOOPS ARE PROCEDURE BODIES ................................................99 
  
 LOOPS OF INSTRUCTIONS ...........................................................101 
  
 EXITING LOOPS PREMATURELY..................................................102 
  
 CONCLUDING THOUGHTS ............................................................103 
  
 EXERCISES...........................................................................103",NA
Chapter 9 ,NA,NA
Procedures .............................................................. 105 ,"WHAT EXACTLY IS A PROCEDURE?............................................106 
  
 PARAMETER PASSING ..................................................................108 
  
 CONSTRUCTING GOOD PROCEDURES ......................................111 
  
 SELF-MODIFYING PROCEDURES.................................................114 
  
 CONCLUDING THOUGHTS ............................................................116 
  
 EXERCISES...........................................................................117",NA
Chapter 10 ,NA,NA
Using Dictionaries................................................... 119 ,"DICTIONARIES FOR NAME SCOPING ..........................................120 
  
 LOCAL DICTIONARIES ...................................................................121 
  
 GLOBAL DICTIONARIES OF PROCEDURES ................................123 
  
 MAINTAINING THE DICTIONARY STACK......................................124 
  
 INTO AND OUT OF DICTIONARIES ...............................................126 
  
 LOOKING INTO DICTIONARIES.....................................................127 
  
 REDEFINING OPERATORS............................................................130 
  
 CONCLUDING THOUGHTS ............................................................132 
  
 EXERCISES...........................................................................133
  
 viii
  
 Table of Contents",NA
Chapter 11 ,NA,NA
Creating and Manipulating Data.............................135 ,"CONSTRUCTING AN ARRAY .........................................................135 
  
 CONSTRUCTING A STRING...........................................................137 
  
 MANIPULATING DATA WITH PUT AND GET.................................137 
  
 CONCATENATING ARRAYS AND STRINGS.................................139 
  
 INPUT AND OUTPUT OF STRING DATA .......................................140 
  
 ARRAYS VERSUS DICTIONARIES ................................................141 
  
 ADVANCED TECHNIQUES.............................................................142 
  
 CONCLUDING THOUGHTS ............................................................143 
  
 EXERCISES.......................................................................... 144",NA
Chapter 12 ,NA,NA
Storing and Using Data...........................................145 ,"CLASSICAL DATA STRUCTURES..................................................151 
  
 CONCLUDING THOUGHTS ............................................................156 
  
 EXERCISES.......................................................................... 156",NA
Chapter 13 ,NA,NA
Program Data and Instructions..............................157 ,"TURNING DATA INTO INSTRUCTIONS.........................................159 
  
 TURNING INSTRUCTIONS INTO DATA.........................................161 
  
 DATA CONVERSIONS ....................................................................163 
  
 CONCLUDING THOUGHTS ............................................................165 
  
 EXERCISES.......................................................................... 165",NA
Chapter 14 ,NA,NA
Using Files and Input/Output Techniques ............167 ,"OPENING AND CLOSING FILES ....................................................170 
  
 READING AND WRITING FILES.....................................................172
  
 Table of Contents
  
 ix",NA
Appendix ,NA,NA
Answers to Exercises ............................................. 185,NA,NA
Index of Example Programs................................... 209,NA,NA
Subject Index........................................................... 217,"x
  
 Table of Contents",NA
Preface,"This book is intended to provide a practical, intriguing, and fresh look at 
 the PostScript programming language. PostScript is a mysterious 
 language, powerful and cryptic. It is expressive and complicated and yet 
 surprisingly simple. In order to master a programming language, you 
 have to learn to think like the compiler or interpreter, and instinctively 
 know how to solve problems. You develop a “tool kit” of useful 
 approaches, proven solutions, and techniques. You reach an 
 understanding that is based on analogy and connections with other things 
 that you know.
  
 This book helps you build a solid foundation of understanding for the 
 PostScript language. It teaches you to become an expert programmer and 
 to have confidence that you have written the best possible PostScript 
 program. It shows you how to combine the elements of the language into 
 a strong, well-designed, modular program that is easy to develop and 
 maintain. It is not a problem-solving book, nor simply a reference to the 
 language; it is a guide to developing programming techniques and to 
 learning how to use the PostScript tool kit, which is filled with hundreds 
 of individual operators.
  
 Comparisons are drawn to other programming languages throughout the 
 book, particularly to C, which is a very common language and one that is 
 often used in the same environments where the PostScript language is 
 found. If you are a competent C or Pascal programmer but you have had 
 limited exposure to PostScript, this book should be exactly what you 
 need. If you are a BASIC, Forth, or Lisp programmer, you should find 
 this book at just the right level for introducing you to the PostScript
  
 xi",NA
Chapter 1,NA,NA
PostScript as a ,NA,NA
Programming Language,"It probably is true that PostScript is not everyone’s first choice as a 
 programming language. But let’s put that premise behind us, and assume 
 that you need (or want) to write a program in the PostScript language. 
 How do you become an expert in this language, and how do you develop 
 the instincts and learn the techniques necessary to tackle challenging 
 problems with confidence?
  
 As a programming language, PostScript is somewhat unusual—and 
 frankly, many of the programming instincts you’ve developed from using 
 other languages may not be directly applicable with the PostScript 
 language. The first few chapters of this book help you put PostScript into 
 perspective by comparing it to languages you probably already know, 
 such as C. There are stronger similarities between PostScript and, say, 
 Forth or Lisp, but if you are expert in either of those languages you 
 probably won’t have much trouble mastering PostScript.
  
 1",NA
DESIGN FEATURES,"PostScript’s most obvious language features are that it is an interpreted 
 language, it is stack-based, and it is heavily oriented toward graphics and 
 typography. These design choices were all made in order to make it 
 useful as a device-independent page description language for imaging on 
 raster devices. These language features also make it a fairly unusual 
 language in which to write programs.
  
 The PostScript language is stack-based (resulting in “backwards” syntax) 
 primarily so that a program can be evaluated with very low overhead in 
 processing and storage. Each instruction can be acted upon immediately, 
 without the need to buffer large amounts of the program.
  
 PostScript is interpreted (rather than compiled) for a couple of reasons. 
 The most obvious one is device independence. If the program remains in 
 source form until it reaches its final destination, it is extremely portable 
 to new computer environments, processors, etc. It is an interpreted 
 language also because documents are often transmitted long distances, 
 archived, or saved and printed many times, and this enables the 
 documents to remain in ASCII text source form for better life expectancy 
 and resiliency in a device-independent environment. 
  
 And finally, PostScript is heavily biased toward graphic imaging and 
 typography because it was originally conceived as a mechanism to 
 control raster imaging devices like laser printers and display screens.
  
 The design choices made in the PostScript language have quite an impact 
 on the programmer’s experiences in mastering the language, but they
  
 2
  
 Chapter 1:   POSTSCRIPT AS A PROGRAMMING LANGUAGE",NA
STRUCTURED PROGRAMMING TECHNIQUES,"If you have had any formal training in programming, you are familiar 
 with the various structured programming techniques, up through and 
 including object-oriented programming. These techniques vary, but are 
 largely based on the concept of a procedure, or a modular functional unit 
 (sometimes called a 
 black box 
 ). A black box is typically any set of 
 operations that has a specific input and output and performs a single task. 
 The mechanics of the operation are hidden from one who uses the black 
 box. This is the notion behind writing procedures, creating software 
 libraries, object-oriented programming, block-structured code; it is a 
 widely recognized technique in computer science.
  
 To start out, PostScript simply isn’t well suited to structured 
 programming, and if you try too hard to formalize the interfaces, declare 
 local variables, and observe many tried and true programming practices, 
 you may end up with a complicated, inefficient, and ill-designed 
 program. On the other hand, if you ignore structured programming 
 techniques and write code off the top of your head, you will probably 
 have something worse. The trick is to borrow enough of the useful 
 concepts from structured programming to make programs readable, easy 
 to maintain, easily debugged, and efficient, while using the expressive 
 power of the language to your advantage.
  
 There is no concept of 
 goto
  in the PostScript language, or even explicit 
 control transfer, so you don’t have to worry about that particular 
 dogmatic concern. You do have to be careful about procedure-calling 
 interfaces, where they exist, since all program checking is done at run-
 time.
  
 Many of the concepts in structured programming can be used quite 
 effectively in PostScript. You can define procedures to help you share 
 similar code across parts of your program. You can use the operand stack 
 for your temporary data rather than having many global variables. You 
 can design interfaces between components of your program and pass 
 parametric information on the stack. You can even define functions that 
 return results onto the stack for use by other procedures.
  
 Chapter 1:   POSTSCRIPT AS A PROGRAMMING LANGUAGE
  
 3",NA
PROGRAMMING TASKS,"There are many different kinds of tasks associated with programming. 
 There are data-crunching tasks, user interface tasks, communication with 
 other computers or programs, file operations, graphics, and various 
 others. In some tasks, such as numerical computation, the algorithm by 
 which the task is carried out is of the utmost importance, both for 
 accuracy and for performance. Other tasks, such as user interfaces and 
 graphics, are much more results oriented: what is important is whether it 
 looks good and/or works well. In file operations, arguably the accuracy 
 with which the operations are carried out is the most important aspect of 
 the task, and the algorithm and performance of the task are secondary.
  
 The nature of the task has a strong influence on the programming style 
 and technique. If your purpose is to draw graphics, your programming 
 efforts should be minimal, clear, and used only to streamline the process 
 of drawing. In the PostScript language in particular, graphics 
 programming is the means to the end, not the end in itself. The 
 PostScript
  
 Language Reference Manual
  mentions that any marks made on the page 
 are a side effect of the execution of the program, but from your 
 perspective as a programmer, it is the other way around. The fact that you 
 have to write PostScript programs is a side effect of the fact that you are 
 trying to draw pictures on a PostScript-based system.",NA
"WINDOW SYSTEMS, COMMUNICATIONS, AND DISPLAYS","Recently, the PostScript language has evolved from a printer control 
 language into a communications medium on host computers. There are 
 window systems and networks based on the PostScript language. In light 
 of this, there are many new kinds of programming tasks that must be (or 
 can be) carried out in the PostScript language.
  
 One of the more interesting aspects of a window system or 
 communications environment based on a programming language is that 
 you can send an algorithmic description of the picture you want drawn 
 (or of the operation you want carried out) instead of the individual bits or 
 instructions. For instance, if you wanted to draw a grid of parallel lines, 
 both horizontally and vertically, you might express this graphic operation
  
 4
  
 Chapter 1:   POSTSCRIPT AS A PROGRAMMING LANGUAGE",NA
DATA STRUCTURES AND ALGORITHMS,"The classic view of a computer program is a synthesis of data structures 
 and algorithms. Books often have titles that contain these two words, and 
 every program probably has one or the other in it somewhere. If you use 
 PostScript to describe pages and to drive laser printers, your need for real 
 data storage and computation should be minimal. However, if you use 
 PostScript in a windowing environment to arbitrate input events from the 
 keyboard (as an extreme example), you will definitely need to create data 
 structures and implement some potentially difficult algorithms.",NA
CONCLUDING THOUGHTS,"The next several chapters help you build some solid approaches to 
 PostScript data structures and help you master the language elements 
 thoroughly so that you will feel comfortable implementing your favorite 
 algorithms. In particular, the data types unique to PostScript are explored 
 (dictionaries and names) as well as traditional data types such as strings, 
 arrays, and numbers. Other chapters are devoted entirely to seemingly 
 simple things like the 
 ifelse
  
  operator or looping. However, since PostScript was not originally 
 designed for heavy programming, these traditional programming 
 techniques have never been thoroughly addressed. And you simply can’t 
 write a serious PostScript program without using 
 ifelse
  or writing a 
 procedure or two.
  
 6
  
 Chapter 1:   POSTSCRIPT AS A PROGRAMMING LANGUAGE",NA
EXERCISES,"Each chapter in this book comes with some exercises at the end of it, to 
 help you to test your understanding of the concepts presented. Since this 
 first chapter has taken a philosophical overview of PostScript as a 
 programming language, the exercises are more like essay questions than 
 problems.
  
 1.
  
 Why do you want to write a PostScript program? (This is a serious 
 question, and one which should be given some thought; reflection on
  
 why
  may provide you with good horse sense throughout your pro-
 gramming experience.)
  
 2.
  
 Why is PostScript a “backwards” language, in which the operators 
 come 
 after
  the operands?
  
 3.
  
 Why is PostScript an interpreted language?
  
 4.
  
 Why is it silly to write fractal programs in PostScript?
  
 Chapter 1:   POSTSCRIPT AS A PROGRAMMING LANGUAGE
  
 7",NA
Chapter 2,NA,NA
PostScript is Not Like C,"Many programmers try to treat a new language as if it were an old 
 language with which they are already familiar. “If you know one 
 programming language, you know them all.” That is somewhat true with 
 procedural languages like C, Pascal, Modula 3, or maybe FORTRAN. 
 There are only so many ways to say 
 if
  ... 
 then
  ... 
 else 
 , and once you learn 
 one language, you can learn the others without too much difficulty. These 
 languages typically only have a dozen or so language elements; if you 
 were to name all the “reserved words” in Pascal or C, how many would 
 you come up with? If you named the built-in features of the language, 
 you wouldn’t get much past control structures, procedure definitions, 
 data types, and input/output capabilities. These languages are general-
 purpose procedural languages.
  
 But PostScript has over 300 individual special-purpose operators, it is 
 interpreted rather than compiled, it uses post-fix notation, and is quite 
 different from C. This is good, to a large extent, but again, you need to
  
 9",NA
COMPARISON OF LANGUAGE MECHANISMS,"One of the first skills a programmer develops is the ability to 
 conceptualize the procedures that will be needed for a program to be 
 implemented effectively. These procedures are designed by deciding 
 what data are needed, how that data ought to be passed through the 
 control sequence of the program, and how the naming of the procedures 
 will contribute to the readability and flow of the program. Procedures 
 should not be too big and complex, nor too small and inefficient.
  
 There is a major difference between PostScript and C that makes 
 program design completely different. In C, you basically have no built-in 
 language elements. There are a few control structures, loop constructs, 
 some input/output operations, and the inherent procedure call 
 mechanism, but there aren’t a lot of individual operators as there are in 
 PostScript. In a sense, the entire program design is based on the 
 implementation of procedures or modules.
  
 In PostScript program design, almost the opposite is true. There are well 
 over 300 individual PostScript operators. Very efficient, well-designed 
 programs can be constructed without ever writing a single procedure, just 
 by using the built-in operators. Then, when the functionality of the 
 program fully emerges, the ability to define procedures can help you to 
 organize the code or to make it more efficient, but usually it is not a good 
 approach to begin by designing the procedures themselves, since the 
 work is ultimately carried out by the individual operators anyway.
  
 TIP
  
 A PostScript procedure is simply a set of operations that are grouped 
 together and that can be invoked by a single instruction. They do not 
 replace the individual operations, they merely provide another way to 
 cause them to be executed. The principle advantages to defining 
 procedures is to collect sequences of operations that may be performed 
 repeatedly.
  
 Furthermore, the operand stack is the communication area between 
 procedures; it is the only place where you can pass data between 
 procedures. But, since this is also the way data are passed to individual 
 PostScript operators, the distinction between a sequence of PostScript
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C
  
 11",NA
EXPRESSING AN ALGORITHM AS A PROGRAM,"If you start with a flowchart to represent an algorithm, the components of 
 the flowchart are somewhat abstract. They represent actions and objects 
 that are traditionally found in programming languages, and the structure 
 and control flow of the program are represented symbolically. The use of 
 a flowchart is predicated on the notion that the program’s algorithm can 
 be embodied in a diagram showing the steps required to carry out the 
 task.
  
 Each program’s implementation is affected strongly by the language 
 itself. Design decisions must be made based on the inherent strengths and 
 weaknesses of the language, and the details of the implementation must 
 ultimately be expressed using the native language constructs.
  
 In order to represent your flowcharted algorithm as a program in some 
 programming language, you must apply the language elements 
 appropriately, within a structure you design. To do this, the language you 
 are using must be fully general and must allow conditional expressions 
 and be able to transfer control to other parts of the program. Yet each 
 programming language was created with a particular purpose in mind, 
 and each programming task is bent and shaped by the language in which 
 it is implemented. The language provides the foundation. Beyond that, it 
 is your skill as a programmer that creates a working program from the 
 building blocks of the language. This is the art of programming.
  
 Although it is possible to start with an abstract algorithm and then 
 implement it in whatever programming language is handy, it is probably 
 more realistic to assume that algorithms are developed in light of a 
 particular language, and in such a way as to take advantage of that 
 language’s features. For example, the kinds of data structures that exist 
 (or are easy to implement) in a language can greatly affect the approach 
 to solving the programming problem. PostScript has a specialized 
 dictionary data structure that can provide entirely new approaches to 
 problems
  
 12
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C",NA
THE UNIX SHELL AND OPERATING SYSTEM,"There are some interesting similarities between the PostScript language 
 and the command-line interface to the UNIX operating system. At first 
 glance, they are quite dissimilar; one is a programming language, the 
 other is an operating system. But consider that the shell program at which 
 the user types UNIX commands is in fact an interpreter. The shell 
 supports a very simple programming framework, with loops and 
 conditionals, and has a few real operators built in. It is intended only as a 
 skeletal environment, and the UNIX programs themselves provide most 
 of the language elements for shell programs.
  
  
 The PostScript language has an extensible set of operators, each of which 
 is invoked by name (for example, 
 moveto 
 ). The names are looked up, at 
 run-time, in the dictionary stack of the interpreter. This is exactly 
 analogous to the UNIX shell, which has an extensible command set and a 
 name lookup mechanism through which all commands are invoked. The 
 name lookup is controlled by the concept of a 
  
 search path 
 , or an ordered set of directories in which to look for the 
 named program. Either language can be extended simply by adding 
 another name into the search path, and using it in the same way that the 
 existing names are used.
  
 TIP
  
 Here’s a trick that you may find very helpful in assimilating the large 
 space of operators in the PostScript language. (It evolved from my mech-
 anism for learning about UNIX.) If you are having a difficult time with a 
 particular part of your program or you think to yourself that there must 
 be a better way, the chances are that the designers of the language 
 encoun-tered the same situation, and designed an operator that exactly 
 solves the problem. Quickly review a summary list of operators (see the 
 Appendix) to see if there is some other operator that could make short 
 work of your task.
  
 Furthermore, both the PostScript language and the UNIX operating 
 system offer a very large and relatively flat set of operators or commands,
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C
  
 13",NA
"INPUT, OUTPUT, AND THROUGHPUT","A program is usually only as good as the data you put through it. Most 
 programs do not come with data already in them, you have to provide the 
 data, and wait for the program to provide output based on the input. This 
 is also true with PostScript, although the input and output may depend on 
 the environment in which the program operates. For example, a 
 PostScript program is often just a vehicle for printing or displaying 
 information. In this sense, the data are provided 
 en masse
  
  from a document, and the output of the program is simply the display or 
 printing of the data in the document.
  
 The input and output of a program depend greatly upon the environment 
 in which the program is running. If your PostScript program is running 
 on an interpreter built into your laser printer, there are few choices for 
 input and output. The input can either come from the cable leading into 
 the laser printer (which is also where the program comes from, typically) 
 or it can come from an internal disk system built into the printer. The 
 choices of output are the same, although the output can also be the 
 printed page itself
  
 14
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C",NA
CONCLUDING THOUGHTS,"This chapter positions PostScript alongside popular conventional 
 languages such as C, to point out the similarities and differences in a 
 slightly abstract sense. The ideas presented may raise more questions 
 than they provide answers, but they should arm you with a sense of 
 perspective on the PostScript language that will help you approach 
 challenging programming tasks with some imagination, confidence, and 
 with open eyes. The comparison with C, in particular, might help by 
 convincing you to revisit some old habits of programming as you 
 implement the guts of your program. Writing loops, making simple 
 ifelse
  
 statements, and inventing variables should be done with a full 
 appreciation of the language and understanding of its strengths and 
 weaknesses.
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C
  
 15",NA
EXERCISES,"1. 
  
 Rewrite the following C program segment in PostScript:
  
 factorial = 1; 
  
 for ( index = 10; index > 0; index-- ) 
  
 { 
  
  
 factorial = factorial * index; 
  
 } 
  
 printf ( “10 factorial is %d\n”, factorial );
  
  
 2.
  
 What would you say are PostScript’s greatest strengths as a general-
 purpose programming language? What are its greatest weakness?
  
 3.
  
 Name four basic language constructs that are available in both the C 
 and PostScript languages (or, if you don’t know C, pick any language 
 of your choice).
  
 4.
  
 Name three things provided in the PostScript language that are not 
 provided as a standard part of any other language.
  
 16
  
 Chapter 2:   POSTSCRIPT IS NOT LIKE C",NA
Chapter 3,NA,NA
Foundations,"This chapter presents some fundamental concepts for programming in 
 PostScript. Some of the information may seem extremely introductory 
 and perhaps carried over from other languages, but there are many tips 
 and techniques presented that should benefit even the seasoned 
 PostScript programmer.
  
 The chapter starts with a basic paradigm of program development that 
 will serve as a foundation for developing PostScript programming skills. 
 This paradigm is certainly not the best or the only approach to 
 constructing programs, but it may help even to contrast the steps with 
 your own thoughts on software development.
  
 There is a cyclic pattern to all kinds of program development, although it 
 varies considerably based on the tools and the environment in which you 
 are working. To build the PostScript programming paradigm, we will 
 look at the sequence of steps involved in learning to develop software in 
 a new language or on an unfamiliar system (see Example 3.1). The list 
 may
  
 17",NA
POSTSCRIPT LANGUAGE SYNTAX,"One of the first problems that beginning programmers encounter when 
 learning a new language is how to get the basic syntax right. It seems 
 trivial once you get past it, but the first step always is learning how to 
 represent strings, how to divide two numbers, how to find mismatched 
 brackets, or any of the other details involved in getting a simple program 
 to work.
  
 In order to write good, solid programs, it is important to understand the 
 syntax of the language well enough that you can write legal, working 
 code instinctively, without hesitating about whether you need a slash, a 
 backslash, parentheses, or curly braces. Luckily, the rules for PostScript 
 syntax are pretty straightforward and easily remembered. Rather than 
 providing an exhaustive review of the language syntax and 
 representation, the following section presents some “seat of the pants” 
 rules that should
  
 Chapter 3:   FOUNDATIONS
  
 19",NA
SIMPLE PROGRAM STRUCTURE,"There is no enforced structure to a PostScript program. You don’t need to 
 start the program with a magic word like 
 Begin
 , nor end it with anything 
 special. You don’t have to declare variables at the beginning of the file,
  
 20
  
 Chapter 3:   FOUNDATIONS",NA
Make Definitions First,"Typically, a PostScript program contains a fair number of definitions, 
 either procedure definitions or variables of some kind. In general, you 
 should define these up front in the PostScript program. A good approach 
 is to set up all the named objects you will need at the beginning of the 
 program, then set up all the procedures, then begin to call them by name 
 at the appropriate time. This is in fact very similar to the traditional 
 structure found in other programming languages, where the definitions 
 must come before the procedures. Example 3.2 shows some definitions 
 of objects that can then be referenced by name later in the program.
  
 Example 3.2: Defining and Using Named Objects
  
 % an often-used font stored as a named object 
  
 /headerfont /Times-Bold findfont 24 scalefont def
  
 % using the named font object 
  
 headerfont setfont 
  
 72 600 moveto 
  
 (Section 1.1) show
  
 For PostScript page descriptions (documents), Adobe Systems has 
 defined 
 PostScript Document Structuring Conventions
  that break a 
 document file down into several components. The first component, the 
 prologue
 , consists only of definitions that may be referenced by the rest 
 of the document. The rest of the document is composed of 
 pages
 , with an 
 optional 
 setup
  section before the pages. These structuring conventions 
 make it easier for post-processing programs such as print spoolers to 
 manipulate the files in helpful ways.
  
 In a PostScript program that is not a page description, these delineations 
 don’t make quite as much sense, but it is still helpful to make the
  
 Chapter 3:   FOUNDATIONS
  
 21",NA
Indentation Style,"The single most important step you can take to make your program 
 readable is to adopt a good indentation style. The PostScript language is 
 very unstructured, and without proper indentation, it can be made quite 
 impossible to read or maintain.
  
 There are a few basic rules of indentation that you should observe, based 
 on the structure of your program:
  
  
 •
  
 Wherever one part of your program is contained within some 
 clear beginning and ending constructs (such as 
 gsave
  and 
 grestore
 , 
 begin
  and 
 end
 , or curly braces), you should indent all 
 of the included program text an equal amount.
  
 22
  
 Chapter 3:   FOUNDATIONS",NA
SETTING UP TEMPLATES,"A very strong technique for building a structured PostScript program is to 
 create an empty template for each construct in your program and then to 
 go back and fill in the body of the template. This keeps you from having 
 to remember to close all your delimiters and lets you perform your 
 housekeeping all at once, so you can concentrate on other things. 
 Anything that inherently has a beginning and an end will benefit from 
 this technique, including making entries in a dictionary, creating an array, 
 a procedure, a string, a loop, or a conditional.
  
 The advantage to the template approach for 
 ifelse
  statements, procedure 
 definitions, loops, or other structural components is that you never have a 
 partially written program with mismatched braces, which can be difficult 
 to debug. The procedure body will already “work” when you finish with 
 the template, although it may not do anything very interesting. At least 
 you won’t have a break in the structure of your program, even for the 
 time it takes you to finish writing the procedure. Even if you are 
 interrupted in the middle of building your 
 true
  clause, the braces will still 
 be balanced. It is also highly readable this way.
  
 Example 3.6 shows how to lay out a template for a procedure definition, a 
 dictionary, an array, an 
 ifelse
  statement, and a loop. Once the template is
  
 24
  
 Chapter 3:   FOUNDATIONS",NA
DECLARING AND USING VARIABLES,"Variables serve two distinct purposes in a computer program. They 
 provide a place to put data, especially data that might change, and they 
 make the program much more readable than if you filled it up with 
 numbers or string data. In PostScript, it is especially important to 
 consider for which of these two purposes your variables were designed. 
 In an interpreted language, you can pay a fairly high premium in 
 execution time for only a little more readability.
  
 There really is no such thing as a variable in PostScript, at least not in the 
 sense that other languages have them. In C, for example, if you declare a 
 variable of type 
 int
 , the compiler will actually set aside a portion of 
 memory big enough to hold an integer, and whenever you refer to that 
 variable, the program knows to look in that location in memory. 
 PostScript has no mechanism for declaring variables before they are 
 used. It also does not require you to give names to any data structures. 
 You can use data directly from the operand stack without ever storing the 
 data into a variable, which you typically cannot do in other languages.
  
 A variable in PostScript is just a name in a dictionary; what you really 
 mean by “variable” probably is just a named bit of data. You refer to it by 
 name instead of explicitly referring to the number or its location in 
 memory. In that sense, any object can be a variable in a PostScript 
 program, if you choose to define it in a dictionary. Let’s look at a simple 
 example (see Example 3.7).
  
 26
  
 Chapter 3:   FOUNDATIONS",NA
Arithmetic with Numeric Variables,"In most programming languages, you can easily perform arithmetic with 
 variables, as in Example 3.9. But in the PostScript language, you have to 
 do all your arithmetic on the operand stack, perhaps calling up the values 
 of some variables to do so, then use the 
 def
  operator to put the new value 
 back into your variable. There is no operator that performs assignment 
 like the 
 =
  notation does in C. Example 3.10 shows the same arithmetic 
 problems from Example 3.9 carried out in PostScript. Assume, of course, 
 that in both examples all of the variables have been set up to contain 
 reasonable values.
  
 Example 3.9: Arithmetic in C
  
 grade = (test1 + test2 + test3 + final ) / 4; 
  
 counter = counter + 1;
  
 Chapter 3:   FOUNDATIONS
  
 27",NA
Using the // Notation for Constants,"PostScript has a special syntax for immediate name lookup and 
 evaluation: the double slash. Any name that is preceded by a double slash 
 ( 
 //
  ) is looked up immediately when encountered in the program, even if 
 it is inside a procedure body, where names are not normally looked up 
 until the procedure is executed.
  
 One excellent use of this notation is to set up constants that you want to 
 work like variables but will never change. That way you can obtain the 
 readability of having named variables, but when the program executes, 
 they will actually be replaced by their constant value and the name 
 lookup at run-time will be avoided. For a simple illustration of this 
 technique, see Example 3.11.
  
 Example 3.11: Evaluation of Constants with //
  
  
 /LeftMargin 108 def 
   
  
 % constant definitions 
 /TopMargin 792 72 sub def 
  
 /RightMargin 612 72 sub def 
  
 /BottomMargin 72 def 
  
 /Leading 12 def 
  
 /space 
  
  
  
  
 % - space -
  
 { %def 
  
  
 currentpoint exch //RightMargin gt { %ifelse 
  
  
  
 //Leading sub dup //BottomMargin lt { %ifelse 
  
  
  
 pop showpage 
  
  
  
  
 //LeftMargin //TopMargin moveto 
  
  
 }{ %else 
  
  
  
  
 //LeftMargin exch moveto 
  
  
  
 } ifelse 
  
  
 }{ pop } ifelse 
  
 } bind def
  
 28
  
 Chapter 3:   FOUNDATIONS",NA
ALLOCATING MEMORY,"There are two ways that memory gets allocated in a PostScript program. 
 It is either allocated implicitly when an object is created or it is allocated 
 explicitly by using one of a handful of operators that create empty data 
 structures of a particular size. See Table 3.1 for a list of operators that 
 explicitly allocate memory for data storage.
  
 Chapter 3:   FOUNDATIONS
  
 29",NA
GETTING MEMORY BACK,"Once you have allocated memory in your program, either by creating 
 data structures or by executing some code that uses memory, there are 
 only two ways to reclaim that space:
  
 •
  
 •
  
 Use the 
 save
  and 
 restore
  operators to reclaim all memory used 
 since the last 
 save
  was executed.
  
 Use the 
 undef
 , 
 undefinefont
 , and 
 vmreclaim
  operators 
 available in the Display PostScript extensions to the PostScript 
 language (
 not available in all products
 ).
  
 When using 
 save
  and 
 restore
 , you have to plan carefully where you want 
 to restore the contents of memory, because the 
 save
 /
 restore
  mechanism 
 also affects other aspects of the interpreter, including the current graphic 
 state, the current device, and so on. In a typical page description, 
 save
  
 and 
 restore
  may be done at each page boundary or around each page 
 element (like a block of text or a photographic image).",NA
OPENING AND CLOSING FILES,"Opening and closing files is a fundamental operation in any program, 
 which is why this section is included in this chapter on the basics. The 
 quick overview is that there are a lot of file-related PostScript operators 
 for reading and writing files; there is one for opening files (the 
 file 
 operator) and one for closing files (the 
 closefile
  operator). The 
 file 
 operator returns a 
 file object
  that you must retain for all subsequent file 
 operations (including 
 closefile
 ). Please see Chapter 14 for a complete 
 discussion of file operations.
  
 Chapter 3:   FOUNDATIONS
  
 31",NA
COMPARISONS AND EQUALITY OF OBJECTS,"PostScript has several distinct data types and is fairly strict about type-
 checking. However, you can easily convert one type to another, assuming 
 that the type conversion makes some sense, and you can then compare 
 them. (See Data Conversions in Chapter 13 for a discussion of type 
 conversions.) In many instances, the PostScript comparison operators 
 will even do this for you as a convenience. Strings and names, for 
 example, are both simply composed of bytes, so they can easily be 
 compared, as shown in Example 3.13.
  
 Example 3.13: Comparison of Different Types of Objects
  
  
 % comparing reals with integers: 
  
 103.0 103 eq 
  
 % true 
  
 103.0 103 ge 
  
 % true 
  
 103.0 103 gt 
  
 % false
  
 % comparing mark objects: 
  
 mark [ eq 
  
 % true
  
 % comparing null objects to integers and booleans: 
 null 0 eq 
  
 % false 
  
 null false eq 
  
 % false
  
 % comparing strings and name objects: 
  
 (Palatino-Roman) 
  
 /Palatino-Roman eq 
  
 % true 
  
 (abc) 
  
 (defabc) 
  
 3 3 getinterval eq 
  
 % true 
  
 (abc) (abc) eq 
  
 % true (an exception)
  
 % comparing array objects: 
  
 [ 1 2 3 ] dup eq 
  
 % true 
  
 [ 1 2 3 ] 
  
 [ 1 2 3 ] eq 
  
 % false (arrays created independently) 
 matrix matrix eq 
  
 % false 
  
 { 1 exch sub } 
  
 { 1 exch sub } eq 
  
 % false
  
 % comparing dictionary objects: 
  
 5 dict dup begin 
  
 currentdict eq 
  
 % true
  
 32
  
 Chapter 3:   FOUNDATIONS",NA
CONCLUDING THOUGHTS,"If you build a solid foundation of PostScript programming skills, you 
 should be able to write programs that work the very first time. There isn’t 
 much to forget, really. You don’t have to declare variables, the syntax is 
 very free, and you cannot get compile-time errors. It helps to get the 
 indentation right, so that all of the parentheses and curly braces balance 
 correctly, and if you develop the skill of always laying out a template for 
 a structure before you go back and fill it in, you should never run into 
 that problem.
  
 The next chapter provides a few examples of typical PostScript programs 
 to help you adopt a style and structure that is appropriate for the task you 
 are faced with. A program to render a graph on a laser printer may be 
 quite different from a program that constructs a downloadable font, for 
 example, and the programming techniques you use should reflect the 
 task.",NA
EXERCISES,"1.
  
 Syntax errors arise very infrequently in PostScript, but when they do, 
 it can be difficult to track them down.
  
 a.Find the syntax error in the following program segment:
  
 0 1 20 { ( Hello world (part 1) == flush } for
  
 b.Find the syntax error in the following program segment:
  
 currentpoint exch 32 gt { 
  
  
 72 lt { showpage 36 500 moveto 
  
 } if { %else 
  
  
 (hello world \(part 2) show 
  
 } ifelse
  
 34
  
 Chapter 3:   FOUNDATIONS",NA
Chapter 4,NA,NA
Some Typical Programs,"This chapter presents some of the most common variations in PostScript 
 programs. It provides you with a glimpse of different programming styles 
 and lets you know when they might be appropriate. Not all PostScript 
 programs draw pictures or print pages. Some of them are purely 
 utilitarian, some are exploratory, some may delete files from your desk, 
 download a font, or query a printer for a list of built-in typefaces.
  
 A lot has been written about PostScript page descriptions, since that was 
 the original purpose of the language. Many of the recommended 
 techniques and program structural rules were intended mostly for page 
 descriptions. Part of the purpose of showing some other kinds of 
 programs is to address squarely the issue of creating PostScript programs 
 that are not simply documents.
  
 The samples in this chapter are not necessarily intended for you to copy 
 as great programming examples. The idea is to present several different 
 classes of programs, to point out that the programming style and the
  
 37",NA
A TYPICAL PAGE DESCRIPTION PROGRAM,"Although PostScript is a full-featured programming language, its primary 
 purpose was originally for page description. In this sense, the program is 
 only the means to an end. The point of a page description is purely 
 graphical, and the marks on the page or on the screen are the intent; the 
 program’s role is to facilitate the rendering of graphics.
  
 Let’s look at a very simplistic page description from a programming 
 point of view. Typically page descriptions are produced by a document 
 processing application, and are not generally written by hand. Machine-
 generated PostScript programs always have some amount of hand-tuned 
 code, especially in the procedure definitions, but the body of the 
 document is usually generated directly by the document production 
 system.
  
 For instance, if you wrote a drawing program that allows the user to draw 
 boxes, you might create a PostScript procedure to help you draw boxes 
 efficiently, but this procedure would be very general, and would require 
 information about where to draw the box and how big it should be. This 
 data would be supplied by the drawing program itself, based on the boxes 
 drawn by the user. The box procedure would then be invoked as many 
 times as necessary to render all the boxes drawn by the user.
  
 Since documents can be composed of many, many elements, and since 
 the set of possible graphic elements is normally fixed, it makes sense to 
 make the representation for each individual object as compact and 
 efficient as possible, using the ability to define procedures as a 
 mechanism. Example 4.1 shows the output of a fictitious text-setting 
 application, with a typical blend of procedure definitions and invocations 
 in the body of the document; Figure 4.1 shows the text generated by the 
 code.
  
 38
  
 Chapter 4:   SOME TYPICAL PROGRAMS",NA
FONT PROGRAMS,"A font program is simply a PostScript program that creates a font 
 dictionary and registers it as a font. Since it is a program, there is no 
 required font file format to adhere to. The dictionary structure of the font
  
 40
  
 Chapter 4:   SOME TYPICAL PROGRAMS",NA
PostScript error (invalidfon,NA,NA
PROGRAMS THAT READ DATA,"One of the most common operations in a computer program is to read 
 and write data from a file. In the past, most PostScript programs have not 
 had access to a file system anywhere other than on the printer, if the 
 printer happened to have a hard disk attached. In window system 
 environments based on PostScript, it is much more likely that a file 
 system is available.
  
 Example 4.3: Sample Program that Reads Data
  
  
 %!PS-Adobe-2.0 
  
 %%Title: data reading example 
  
 /infile (input.ps) (r) file def 
  
 /outfile (output.ps) (w) file def 
  
 /buffer 128 string def 
  
 { %loop 
  
  
 infile buffer readstring { %ifelse 
  
  
  
 outfile exch writestring 
  
  
 } { 
  
 outfile exch writestring exit } ifelse } 
 bind loop 
  
 infile closefile outfile closefile
  
 42
  
 Chapter 4:   SOME TYPICAL PROGRAMS",NA
QUERY PROGRAMS,"Sometimes you need to retrieve some information about a printer or 
 network server, like a list of the currently installed fonts. This is an 
 example of a 
 query program
 . Query programs always generate a 
 response of some kind as part of their execution. Example 4.4 is a query 
 program that returns a list of the fonts currently defined in the 
 FontDirectory 
 dictionary in a PostScript interpreter.
  
 Example 4.4: Sample Query Program
  
 %!PS-Adobe-2.0 Query 
  
 %%EndComments 
  
 %?BeginFontListQuery 
  
 FontDirectory { pop == } forall flush 
  
 (*) = flush 
  
 %?EndFontListQuery: *
  
 Since query programs are intended to write results to the 
 standard output 
 communications channel (terminology borrowed from UNIX and C), 
 their behavior depends to a great degree upon the environment in which 
 they are executed. Some printers do not have two-way communications 
 channels; in such cases the results will be lost. Some operating 
 environments think that anything coming back from a printer must be an 
 error message, so the results may be written to an error log file 
 somewhere, and they may even have extra text added to them by the 
 printer control program.",NA
ENCAPSULATED POSTSCRIPT PROGRAMS,"Encapsulated PostScript files (EPS files) are illustrations or other self-
 contained programs that can be included into another document. They are 
 restricted in a few ways to keep them from disturbing the environment in 
 which they are included, but generally can use the entire expressive 
 power of the PostScript language (see Example 4.5).
  
 Chapter 4:   SOME TYPICAL PROGRAMS
  
 43",NA
PERSISTENTLY RESIDENT PROGRAMS,"Yet another type of PostScript program is one that makes some persistent 
 definitions that are visible to all subsequent programs. This provides a 
 mechanism for redefining operators, making fonts semipermanent in the 
 interpreter, or defining some procedure definitions once in such a way 
 that they are usable to all subsequent programs.
  
 On most printer implementations, this can be accomplished using the 
 exitserver
  operator. This operator permits the program to exit the job 
 server loop’s 
 save/restore
  context, causing any definitions made to stay 
 resident until the printer is rebooted. Example 4.6 shows the use of 
 exitserver
 , in this case to make a font definition semipermanent.
  
 Example 4.6: Sample Printer-Resident Program
  
  
 %!PS-Adobe-2.0 ExitServer 
  
 %%EndComments 
  
 %%BeginExitServer: 0 
  
  
 serverdict begin 0 exitserver 
  
 %%EndExitServer 
  
 %%BeginFont: UserFont
  
  13 dict begin 
  
  
 /FontName /UserFont def /FontType 3 def 
  
  
 /FontMatrix [ .001 0 0 .001 0 0 ] def 
  
  
 /FontBoundingBox [ 0 0 1000 1000 ] def 
  
  
 /Encoding /StandardEncoding load def 
  
  
 /BuildChar 
   
  
 % fontdict charcode BuildChar -
  
  
 { %def 
  
  
  
 exch begin 
  
  
  
  
 Encoding exch get 500 0 setcharwidth 
  
  
  
  
 CharDefs exch get exec 
  
  
  
 end 
  
  
 } bind def 
  
  
 /CharDefs 256 dict def CharDefs begin 
  
  
  
 Encoding { %forall 
  
  
  
  
 { %def 
  
  
  
  
  
 4 { rand 1000 mod } repeat moveto lineto stroke 
  
  
  
 } def 
  
  
  
 } bind forall 
  
  
 end
  
  currentdict end dup /FontName get exch definefont pop 
  
 %%EndFont 
  
 %%EOF
  
 46
  
 Chapter 4:   SOME TYPICAL PROGRAMS",NA
CONCLUDING THOUGHTS,"The examples in this chapter should provide a feeling for the different 
 kinds of programs that can be written, and the different techniques that 
 might be required for each. As you learn more about the details of 
 writing PostScript programs, it is helpful to keep a bit of perspective 
 about the kind of program you are constructing, so you can make your 
 code readable where it should be, efficient where it counts, and well-
 behaved. The next two chapters take a hard look at the operand stack, 
 since it is the principle mechanism for all program execution.",NA
EXERCISES,"1.
  
 In a page description program, is it more important to write code that 
 is easily readable or code that is efficient? What kinds of procedures 
 would you define, and why?
  
 2.
  
 What kinds of PostScript programs would you expect to consume 
 memory?
  
 3.
  
 What do you think is a reasonable way to use a query program in an 
 environment where there is only one-way communication (or in a 
 batch system, which is essentially the same thing) ?
  
 Chapter 4:   SOME TYPICAL PROGRAMS
  
 49",NA
Chapter 5,NA,NA
Understanding the Stack,"The operand stack is the central mechanism in the PostScript language. 
 All data are placed on the operand stack at one time or another during the 
 execution of your program. The operand stack holds PostScript language 
 objects
 , which are the basic representation for all data types in a 
 PostScript program, including procedures and instructions.",NA
A QUICK OVERVIEW OF DATA TYPES,"All PostScript data types are represented by a single object. There are 
 three varieties: 
 simple
  objects like integers, reals, marks, and booleans; 
 composite
  objects (like arrays and strings) that will not fit into an object; 
 and some 
 special
  types that behave like simple objects but which have 
 some internal structure that you can’t see (these include save objects and 
 FontID
  objects). For the purpose of this discussion, only simple and 
 composite objects will be covered.
  
 51",NA
NAME LOOKUP,"The standard method for retrieving something that has been stored into a 
 dictionary is to use the 
 name lookup
  mechanism. An executable name 
 encountered by the interpreter is looked up in the context of the current 
 dictionary stack, and if there is an entry corresponding to that name, the 
 value will be placed on the operand stack—with one notable exception. If 
 you happen to retrieve a procedure body (an executable array object) 
 under the name you look up, that procedure will be placed on the 
 execution stack and immediately executed, rather than being placed on 
 the operand stack and treated as data.
  
 TIP
  
 If you need to retrieve a procedure body that you have stored into a 
 dictio-nary, but don’t want to execute it just yet, you can get a copy of it 
 onto the operand stack using the 
 load
  operator, using the name of your 
 procedure (with the leading slash, to make it a literal name) as the 
 argument to 
 load
 .
  
 When a name is looked up, the dictionary stack is searched from the top 
 down, and the first instance of the key that is encountered is the one that 
 is used. That enables you to redefine a name that is already built into the 
 PostScript language, although you should do so with great care (see 
 Redefining Operators in Chapter 10 for further discussion of this topic).",NA
HOW OPERATORS USE THE STACK,"The 
 operand stack
  is a global communication area for all PostScript 
 programs. All operators look for their operands on the stack and produce 
 results there, although they may also produce side effects such as marks 
 on the page, changes to the graphics state, or changes to the contents of 
 memory.
  
 Let’s look at a very simple program to follow the use of the operand stack 
 (See Example 5.1).
  
 Chapter 5:   UNDERSTANDING THE STACK
  
 53",NA
GROUPING AND VISUAL CHUNKING,"One of the best ways to learn to read and write PostScript programs is to 
 be able to “chunk” together sequences of instructions into a block that 
 has a well-understood input and output. In many programming 
 languages, you can usually read a single line of the source code and make 
 sense of it. In fact, usually one line of the program represents a single 
 statement
  in that language, which may be an assignment statement or a 
 procedure call. But in the PostScript language, the statements can get 
 fairly complex, and each operator and its arguments represents one 
 phrase of the statement. The programs that are the most difficult to read 
 are those that use one operator to manufacture the arguments for the next 
 operator.
  
 Let’s look quickly at two examples that illustrate the concept of one 
 operator leaving behind results that become arguments for the subsequent 
 operation. The first case (Example 5.2) shows a series of code samples of 
 gradually increasing complexity, culminating in some that may look a 
 little bit confusing at first glance. Take a moment to mentally execute the 
 program to see what it does.
  
 Example 5.2: Each Operator Uses the Operand Stack
  
 % currentgray leaves result for setgray 
  
 currentgray 1 exch sub setgray
  
 % save leaves a value for restore (“3 exch” is just there to confuse you) 
 save 3 exch restore
  
 % search leaves three strings and a boolean 
  
 (ABCD) (B) search { = pop = flush }{ = flush } ifelse
  
 56
  
 Chapter 5:   UNDERSTANDING THE STACK",NA
THINKING BACKWARD AND SIDEWAYS,"A stack-based language such as PostScript makes you think differently 
 than most programming languages. It seems, at first, as though you have 
 to think backwards, since all the operators come after their operands. 
 However, if you think of the entire expression at once, it is only slightly 
 different than thinking in prefix or infix notation (see Example 5.4 
 through Example 5.6).
  
 Example 5.4: Operator Prefix Notation in C
  
 /* In a function call, the operands come in parentheses after the function name */ 
 value = currentpoint(Y); 
  
 value = sqrt(X);
  
 Example 5.5: Operator Infix Notation in C
  
 /* Arithmetic operators typically come between their operands */ 
 value = value - 12; 
  
 if ( value <= 72 ) showpage();
  
 58
  
 Chapter 5:   UNDERSTANDING THE STACK",NA
COMPOSITE OBJECTS,"The values associated with composite objects do not exist on the operand 
 stack. There is an object on the stack that represents the composite object 
 data, and it behaves, for the most part, as though the whole object were 
 on the stack. The only time it is confusing is during copying and 
 manipulation of the internal structure of a composite object, when you 
 have to realize that you really have a pointer to the object, not a self-
 contained object. For example, if you 
 dup
  a string object and then 
 change one of the letters in the copied object, the original string changes, 
 too, since there really is only one string and you have only copied the 
 pointer to it, not the string itself.",NA
THE OTHER STACKS,"There are three other stacks used by the interpreter during the execution 
 of your program in addition to the operand stack, which you have been 
 studying: the 
 dictionary stack
 , which helps with name lookup and in 
 making definitions; the 
 execution stack
 , which holds partially executed 
 procedure bodies, file objects, and other executable objects; and the 
 graphics state stack
 , which keeps track of your 
 gsave
  and 
 grestore 
 operations.
  
 These stacks will be described briefly so that you’ll know about them. 
 For more detailed information, refer to the books 
 PostScript Language 
 Reference Manual
  and 
 PostScript Language Program Design
 , both by 
 Adobe Systems, available from Addison-Wesley Publishing Company.
  
 62
  
 Chapter 5:   UNDERSTANDING THE STACK",NA
The Dictionary Stack,"The dictionary stack controls name lookup and dictates where an entry is 
 made when you use the 
 def
  operator. You can only place dictionary 
 objects onto this stack, and only with the 
 begin
  operator. You must use 
 the 
 end
  operator to remove entries from the dictionary stack. There is 
 also a discussion of these operations in the section entitled Maintaining 
 the Dictionary Stack in Chapter 10.",NA
The Execution Stack,"The execution stack is used only internally by the interpreter, to keep 
 track of your program’s execution. It contains any portion of the program 
 that has not yet been executed, including the input file stream, any 
 partially-executed procedure bodies, and loops. There are very few ways 
 to take advantage of the execution stack in a user program, but it can help 
 in complicated debugging situations.",NA
The Graphics State Stack,"The graphics state stack is used only by the 
 gsave
  and 
 grestore
  operators 
 to maintain the graphics state. The gsave operator effectively pushes the 
 current graphics state onto the graphics state stack, making it available 
 later for 
 grestore
 . The stack-based nature of the graphics state stack 
 makes 
 gsave
  and 
 grestore
  nestable up to the limits of the graphics state 
 stack, which is typically about 20 levels or more.
  
 In the Display PostScript extensions to the PostScript language, the 
 notion of a 
 graphics state object
  has been introduced, which allows you 
 to capture the current graphics state into an object that can be treated like 
 any other object. There are companion operators like 
 setgstate
  that will 
 take a graphics state object and set all the current graphics state 
 parameters according to its contents. This is much more flexible than the 
 graphics state stack, since instantaneous changes can be made to the 
 graphics state without having to push and pop the current state.",NA
CONCLUDING THOUGHTS,"This chapter provided you with a brief overview of data types and some 
 examples of how operators use the operand stack. The stack and its
  
 Chapter 5:   UNDERSTANDING THE STACK
  
 63",NA
EXERCISES,"1. 
  
 What is left on the operand stack after the following code is executed?
  
 /Times-Roman 24 selectfont 
  
 100 dup moveto 
  
 (Vocabulary) stringwidth 2 div neg rmoveto (Vocabulary) show
  
 2.
  
 For each of the following code segments, determine what error, if 
 any, would arise (not all of the code segments raise errors):
  
 a.
  
 (string one) (string2) copy
  
 b.
  12 /Times-Roman findfont scalefont setfont
  
 c.
  
 % center some text 
  
 306 500 moveto /Times-Bold 14 selectfont 
 (Report Title) dup stringwidth 2 div 0 rmoveto 
 show
  
 d.
  save 
  
  
  
 /Optima 12 selectfont 20 40 moveto 
  
  
  
 (Save me!) dup show 
  
  
 restore
  
  
 3.
  
 Rewrite the following code using just stack operators, without storing 
 anything into a dictionary.
  
 64
  
 Chapter 5:   UNDERSTANDING THE STACK",NA
Chapter 6,NA,NA
Trusting the Stack,"Most beginning PostScript programmers don’t trust the operand stack. It 
 seems like just a vehicle for transporting data to their procedures, and the 
 sooner the data can be retrieved from the stack and put safely into a 
 variable, the happier the programmer is.
  
 There is a vague truth to this feeling, but it has only to do with the 
 programmer, and not the PostScript language itself. It is a bit more 
 difficult to think like a stack-based interpreter, so you can get confused 
 about what is on the stack, how it got there, and what you should do with 
 it, and this confusion can lead to bugs and lost data. However, since you 
 cannot avoid the operand stack when writing PostScript programs, it is 
 best just to master it, rather than to mistrust it.
  
 67",NA
SAFETY OF DATA ON THE STACK,"In truth, the safest place for a piece of data is on the operand stack, with a 
 few small caveats.
  
 •
  
 •
  
 •
  
 If your program has bugs, you may inadvertently remove 
 something from the operand stack that you needed, or leave 
 something extra that will cause some later operation to trip over 
 it. Sometimes these stack alignment programs persist for a long 
 time, unless you consistently test all the paths through your 
 program.
  
 Stack-based manipulations of more than a few operations or 
 more than a few operands can be tricky to read and maintain, 
 leading to the bugs just mentioned.
  
 If you transfer control temporarily to some other program, as you 
 might do with an embedded illustration, for example, you should 
 not be surprised if something you left on the operand stack is no 
 longer there.
  
 In general, the cleanest, fastest and best programs are those that make 
 judicious use of the operand stack. As a rough rule of thumb, in 
 designing a PostScript program you should spend 65 percent of your time 
 thinking about the order of operands on the stack, whether or not you 
 should divide all of your coordinate numbers by 1,000 before sending 
 them to the interpreter, and whether you can get away without sending 
 the X coordinate every time you plot a vertical line. You should spend 20 
 percent of your time adjusting the procedures you have defined to match 
 the decisions you have made about operand order and use. (The 
 remaining 15 percent is for debugging and getting distracted.)
  
 Of course, these principles of careful use of the operand stack are derived 
 primarily from printer drivers, which are inherently batch programs. If 
 you are writing an interactive application in PostScript, or if you are 
 writing a utility program that is entirely self-contained, you may have 
 different goals—but the basic ideas still apply. The data must be on the 
 operand stack in order for any PostScript operator to use it, so you might 
 as well take advantage of that premise and try not to take things off the 
 stack and put them on too many times unnecessarily.
  
 68
  
 Chapter 6:   TRUSTING THE STACK",NA
WHERE ARE THE DATA GOING?,"One of the important things to consider when you’re designing a 
 PostScript program is what you’re using the stack for at any given 
 moment. Are you passing parameters to a function? Is the information on 
 the stack raw data? Will the information be used once or many times? If 
 you only need the data once, it is best to arrange it in such a way that you 
 can use the data directly from the operand stack and never think about it 
 again.
  
 A common approach to dealing with data on the operand stack is to store 
 the data under some name in a dictionary, rather than leaving the values 
 on the operand stack. This has a few advantages.
  
 •
  
 •
  
 •
  
 The data can be recalled onto the stack many times.
  
 Debugging can be easier with named data.
  
 Storing the data helps to minimize nasty stack manipulations.
  
 The first few times you try to read or write PostScript programs, it may 
 be difficult to understand what is going on in a statement like the one in 
 Example 6.1. What is 
 exch
  doing exactly where you would expect to see 
 the value part of the definition?
  
 As you know, the 
 def
  operator requires its key and value in a particular 
 order on the stack. If the 
 value
 —the object you want to store—got put on 
 the operand stack before you had a chance to put the 
 key
 —the name 
 under which you store that value—on the stack, then you would have 
 them in the wrong order for 
 def
 . In this case, you need to call 
 exch
  to get 
 them in
  
 Chapter 6:   TRUSTING THE STACK
  
 69",NA
REARRANGING THE STACK,"If you want to use the operand stack directly in your program, the 
 chances are you will need to perform some stack manipulation. It’s 
 almost unavoidable. There are a few operators that you will find 
 indispensable for stack manipulation. There are also some techniques 
 worth learning to help you keep bugs out of your stack exercises. Table 
 6.1 contains a summary of the stack operators in the PostScript language 
 for quick reference. Don’t worry if you don’t understand how to use all 
 the operators in the table; it will become more clear as you read on.
  
 Table 6.1: PostScript Stack Manipulation Operators
  
 Arguments Operator
  
 
 | any
 1
  ... any
 n
  clear 
  
 mark obj
 1
  ... obj
 n
  cleartomark 
  
   
 A B C 3
  copy
    B C A B C
  
 
 | any
 1
  ... any
 n
  count
  any
 1
  ... any
 n
  n 
 mark any_objects
  counttomark
  mark
  
  
 any 
  
  
 n 
  
 any
  dup
  any any
  
 any
 1
  any
 2
  exch
  any
 2
  any
 1 
  
 D E F G 2
  index
  D E F G E
  
 
  mark
  mark
  
 any
  pop
 
  
 a b c d e f 3 -2
  roll
   a b c f d e
  
 Action 
  
 discard all elements 
  
 discard everything through mark 
 duplicate top three elements 
  
 count elements on stack 
  
 count elements down to mark
  
 duplicate top element 
  
 exchange top two elements 
  
 duplicate second element from top 
 (where top is 0th element) 
  
 push mark on stack 
  
 discard top element 
  
 take top three elements and roll 
 negative two times
  
 The most important operators for stack manipulation are 
 dup
 , 
 exch
 , 
 index
 , and 
 roll
 . Of these four operators, 
 dup
  and 
 exch
  are fairly easy to 
 understand, since they apply only to the topmost item or items on the 
 stack, but 
 index
  and 
 roll
  can be a bit more confusing.",NA
Using the ,NA,NA
dup,NA,NA
 and ,NA,NA
index,NA,NA
 Operators,"Although the 
 dup
  operator is very simple in its operation, knowing when 
 and how to use it effectively requires some skill in manipulating the 
 operand stack. The 
 index
  operator has almost exactly the same function 
 as 
 dup
 , except it will let you duplicate an object further down on the 
 operand stack (
 dup
  duplicates only the topmost object). There are two or 
 three places where these operators are used most commonly.
  
 Chapter 6:   TRUSTING THE STACK
  
 71",NA
Using the ,NA,NA
roll,NA,NA
 Operator,"The 
 roll
  operator is one of the most useful stack operators, and one of the 
 most confusing. Its purpose is to rearrange several of the topmost 
 operands on the stack by rolling them. It takes two operands: one to 
 supply the total number of elements to participate in the 
 roll
  operation 
 (this total is called the 
 roll group
  in the following discussion) and the 
 other to indicate how many elements within that total should actually be 
 rolled (called the 
 roll amount
 ).
  
 Let’s look at the anatomy of the 
 roll
  operator (Figure 6.1).
  
 72
  
 Chapter 6:   TRUSTING THE STACK",NA
CONDITIONALS AND LOOPS,"One of the most difficult things to do in PostScript programming is to 
 make sure you don’t inadvertently leave something on the stack or 
 consume something from the stack that you weren’t supposed to. 
 Keeping track is easy enough when there is only a single path through the 
 code, but if there are lots of 
 ifelse
  statements and 
 loop
  constructs, it gets 
 more difficult to trace through all the possibilities to make sure you’ve 
 not forgotten anything.
  
 One of the most common instances of this problem is caused by 
 operators that return different numbers of arguments depending on 
 whether they succeed or fail. Example 6.3 shows a conditional that 
 accidentally leaves
  
 Chapter 6:   TRUSTING THE STACK
  
 73",NA
RECURSION AND LOCAL VARIABLES,"If you create a procedure that calls itself recursively, you have to be 
 careful about the names you use. Recursion is inherently stack-based. To 
 make recursion work correctly in PostScript, you need either to use the 
 dictionary stack or the operand stack to store intermediate results until 
 your recursion is unwound back to the original invocation level.
  
 Let’s look at a recursive function that has an integer passed to it as an 
 argument, and that will ultimately return an integer as its result (Example 
 6.5). If the argument is even, the function calls itself recursively and adds 
 one to the argument. If the argument is odd, the function returns. The 
 result of this function is always an odd number.
  
 Example 6.5: Recursion Using the Dictionary Stack
  
 /recurse_proc 
  
  
 % int recurse_proc int { 
 %def 
  
  
 save 
  
  
 2 dict begin 
  
  
  
 /save_obj exch def 
  
  
  
 /arg exch def 
  
  
  
 arg 2 div truncate 
  
  
  
 2 mul cvi 
  
  
  
 arg eq { %ifelse 
  
  
  
  
 % even number 
  
  
  
  
 arg 1 add recurse_proc 
  
  
  
 }{ %else 
  
  
  
  
 arg 
  
  
  
 } ifelse 
  
  
  
 save_obj 
  
  
 % leave on stack 
  
 end 
  
  
 restore 
  
  
 % to save_obj on stack } 
 bind def 
  
 2 recurse_proc
  
 If you want to store the function’s argument in a dictionary, you have to 
 create a new dictionary and push it onto the dictionary stack each time 
 the function is called, to maintain the name local to that instance of the 
 function. In this example, the memory allocated by the dictionary is 
 reclaimed by 
 save
  and 
 restore
 , putting each save object into the 
 recursion dictionary until it is needed. If the function is called 
 recursively, more
  
 76
  
 Chapter 6:   TRUSTING THE STACK",NA
CONCLUDING THOUGHTS,"The operand stack is an integral part of the PostScript language, and you 
 cannot avoid using it. Once you start to understand it and to trust it, you 
 will be able to write programs that make very effective use of the stack. 
 A stack-based language seems to make you think backward and upside-
 down, but in fact it only makes you think in chunks, where each chunk is 
 the result of one operation. Every operator is grouped with its operands,
  
 Chapter 6:   TRUSTING THE STACK
  
 77",NA
EXERCISES,"1. 
  
 What is the result of the following short piece of PostScript code?
  
  0 0 10 100 { add } for
  
 2.
  
 What are the contents of the operand stack after executing the follow-
 ing program segment?
  
 clear 
  
 /A /B /C /D /E /a /b /c /d /e 
  
 2 copy 6 index 6 index 12 -4 roll exch 5 3 roll
  
  
 3.
  
 Write a procedure called 
 reversestack
  that will reverse the contents 
 of the operand stack (the topmost element becomes the bottom 
 element).
  
 4.
  
 Write a procedure called 
 standardfonts
  that finds all fonts defined in 
 FontDirectory
  that have a standard encoding. You can assume the 
 presence of the built-in name 
 StandardEncoding
  and use it to com-
 pare to the 
 Encoding
  in each font. This procedure should not define 
 any variables. Leave the names of the fonts on the operand stack.
  
 78
  
 Chapter 6:   TRUSTING THE STACK",NA
Chapter 7,NA,NA
Building Conditional Statements,"A conditional is what most people call an 
 if
  statement. It provides a 
 mechanism for executing one piece of code or another based on a 
 condition that is evaluated while the program is running. In the 
 PostScript language, there are two operators for building conditional 
 statements: 
 if 
 and 
 ifelse
 . The only difference between them is that the 
 if
  
 statement has only one clause and the 
 ifelse
  statement has two. There is 
 no built-in 
 case 
 statement in the PostScript language, but in this chapter 
 we will discuss how to fabricate one.
  
 Conditionals are the most fundamental and most useful construction in 
 any programming language. A conditional belongs to a family of notions 
 known as 
 control structures
 , which are program mechanisms for letting 
 you execute different parts of a program discontinuously, rather than 
 having the whole program be one long piece of string. Other control 
 structures are 
 while
  loops, 
 case
  statements, 
 goto
  instructions, and 
 subroutines. The ability to 
 branch
  to a different part of your program 
 when certain conditions are met is absolutely crucial to any moderately
  
 79",NA
SIMPLE CONDITIONALS,"The simplest way to build a conditional statement in your program is to 
 use the template technique, as in Example 7.1.
  
 Example 7.1: Constructing a Conditional
  
 % the conditional expression comes first 
  
 myvariable 3 gt { %ifelse
  
 }{ %else
  
 } ifelse
  
 This creates an empty conditional statement with the conditional 
 expression in place. The 
 if
  and 
 else
  clauses can then be filled in after the 
 template is in place as shown in Example 7.2. (For more information, 
 refer back to Setting up Templates in Chapter 3.)
  
 Example 7.2: Filling in the Conditional Template
  
 /myvariable 0 def 
  
 myvariable 3 gt { %ifelse 
  
  
 (my variable got to 3; resetting to 0) == flush 
  
  
 /myvariable 0 store 
  
 }{ %else 
  
  
 /myvariable myvariable 1 add store 
  
  
 (my variable is now ) print 
  
  
 myvariable == flush 
  
 } ifelse
  
 A standard way of thinking about a conditional statement is to state the 
 expression out loud, and to imagine first the 
 true
  clause, then the 
 false 
 clause. That is the way the 
 ifelse
  statement is laid out in the PostScript 
 language. You have to remember that the 
 ifelse
  operator itself goes at the 
 end of the construction (as in the examples given). But you can still think 
 of the conditional in much the same way you think in any other 
 programming language (Example 7.3).
  
 80
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS",NA
SETTING UP THE CONDITION,"All conditional statements depend on something being true or false. 
 There are many PostScript operators that return a boolean value 
 (remember, this just means that it can only be 
 true
  or 
 false
 ). The purpose 
 of this boolean returned on the operand stack is so that you can use it 
 with an 
 ifelse 
 statement. The simplest of these is the 
 eq
  operator (see 
 Example 7.4).
  
 Example 7.4: Setting Up the Conditional
  
 dup type /stringtype eq { %ifelse 
  
  
 % topmost element on stack is a string 
  
 }{ %else 
  
  
 % it is not a string 
  
 } ifelse
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS
  
 81",NA
CONDITIONALS ARE NOT MAGIC,"A conditional statement is not magic. There is no operator in the 
 PostScript language that is different from the others. Even though you 
 will learn to think of the entire conditional as a single construction, it is 
 not. Only the execution of the 
 if
  and 
 ifelse
  operators make something into 
 a conditional. Otherwise, and until you execute one of those operators, 
 the rest of the code is just a couple of procedures and a boolean on the 
 operand stack.
  
 Just to confuse you and to reinforce this point, let’s look at a simple 
 conditional rearranged in a perfectly legal, although somewhat unusual, 
 configuration. 
 The 
 first 
 conditional 
 (Example 
 7.9) 
 is 
 very 
 straightforward. The second program (Example 7.10) has the same result, 
 but is constructed very differently. The procedures for the 
 true
  and 
 false
  
 clauses are defined like any other procedure, then brought up on the 
 operand with the 
 load
  operator, ready for the final execution of 
 ifelse
 . As 
 an added twist, a random string is put on the stack in between, and then 
 moved out of the way.
  
 Example 7.9: Basic Conditional Statement
  
 currentpoint exch pop 72 le { %ifelse 
  
  
 showpage 72 650 moveto 
  
 }{ 
  
  
 0 -12 rmoveto 
  
 } ifelse
  
 Example 7.10: The Same Conditional Built on the Fly
  
 % set up procedures to generate a boolean and to act as the % 
 “true” and “false” procedure bodies for “ifelse”
  
 /off_bottom_of_page 
  
 % off_bottom_of_page bool 
  
 { %def 
  
  
 currentpoint exch pop 72 le 
  
 % boolean is on stack 
 } bind def 
  
 /off_bottom_proc { showpage 72 650 moveto } bind def 
  
 /regular_proc { 0 -12 rmoveto } bind def
  
 % now invoke the conditional by loading the boolean and % 
 the two procedures onto the stack and rearranging them a % 
 little bit to show there is no magic:
  
 86
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS",NA
NESTED CONDITIONALS AND,NA,NA
 ELSE,NA,NA
 CLAUSES,"Fairly often, in a complicated program, you need to have conditionals 
 that have more conditionals on each of the two result clauses. When these 
 nest more than one level deep, it can become tricky to maintain them 
 without leaving things on the operand stack or introducing bugs of some 
 sort.
  
 The first issue is simply balancing the curly braces correctly, so that there 
 are no basic syntactic errors in the program. Using the template technique 
 for this is a good approach, and one that can be expanded as necessary 
 later (see Example 7.12).
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS
  
 87",NA
COMPOUND CONDITIONALS,"Compound conditionals are found wherever there is a single condition 
 but many possible 
 else
  clauses. In other languages, this might be handled 
 by a 
 case
  statement, but—as you’ve already learned—there is no 
 case
  
 operator in the PostScript language.
  
 First, let’s look at an example of a compound conditional implemented in 
 the most straightforward manner, as a series of 
 else
  clauses. Remember 
 that PostScript is not a compiled language. Therefore, you should try to 
 put the most likely conditions first, since they will be tested in order. 
 Since there is no way to choose from a parallel set of procedure bodies, 
 the only way to implement a compound conditional with 
 ifelse
  is to nest 
 the conditionals, adding a new test for each 
 else
  clause. This can get very 
 tricky to maintain, since it may nest very deep to supply all of the 
 required clauses (see Example 7.13).
  
 88
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS",NA
CONCLUDING THOUGHTS,"The most important thing to remember about conditionals and the 
 ifelse 
 operator is that the whole construction is interpreted each time it is 
 encountered. The condition (
 true
  or 
 false
 ) is computed each time, the 
 two procedure bodies are loaded onto the operand stack, and the 
 ifelse 
 operator pushes one or the other of them onto the operand stack. There’s 
 nothing really magical about the way it works, and the procedure bodies 
 it uses are interchangeable with all other procedures in the PostScript 
 language.
  
 90
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS",NA
EXERCISES,"1.
  
 2.
  
 Design a 
 case
  operator for the PostScript language, and design a pro-
 cedure that will implement it. Think about the design trade-offs be-
 tween ease of use (once your 
 case
  operator exists) versus ease of 
 implementation for you. Supply some simple documentation (com-
 ments in your program are good enough) explaining how to use your 
 new 
 case
  operator.
  
 The following procedure emulates the 
 setcmykcolor
  language exten-
 sion by using 
 setrgbcolor
  and doing a simple conversion. Design a 
 conditional statement with the 
 where
  operator that will define this 
 procedure 
 only
  if the 
 setcmykcolor
  operator does not already exist.
  
 /setcmykcolor { %def 
  
  
 1 sub 4 1 roll 
  
  
 3 { %repeat 
  
  
  
 3 index add neg dup 0 lt {pop 0} if 3 1 roll 
  
  
 } repeat setrgbcolor pop 
  
 } bind def
  
 3.
  
 The “standard” procedure used with the 
 image
  operator uses the 
 readhexstring
  operator to get a line of data from the input file. The 
 trouble is, it 
 ignores
  the boolean returned by 
 readhexstring
 , which is 
 not really a good idea. Please rewrite this procedure body to check 
 for the end-of-file condition reported by the 
 readhexstring
  operator. 
 (The second line of hex data is incomplete in this example, causing 
 an error in the execution of the program as it stands. Fill out the line 
 of data to see what the program is supposed to do.)
  
 /picstr 16 string def 
  
 100 100 translate 100 900 scale 
  
 16 2 8 [ 16 0 0 16 0 0 ] 
  
 { currentfile picstr readhexstring pop } image 
  
 00FF00FF00FF00FF00FF00FF00FF00FF 
  
 00FF00FF00FF00FF
  
 Chapter 7:   BUILDING CONDITIONAL STATEMENTS
  
 91",NA
Chapter 8,NA,NA
Using Looping Constructs,"Loops are useful for repeating a sequence of steps in a quantized manner. 
 There are various conditions under which looping is appropriate. One of 
 the most common is to iterate over data structures of known size, such as 
 arrays. Another use is to repeat a set of commands more than once.
  
 If you want to perform a repetitive task that uses some fixed parameters, 
 you generally think of loops in most programming languages. For 
 example, you could create a grid of lines or a spiral of text by setting up a 
 for
  loop and using the loop increment to set up the next line or the next 
 rotation of characters.
  
 One fairly common use of loops is to generate “synthetic” graphics. The 
 data for a grid of lines or a spiral actually can be manufactured within the 
 loop rather than being supplied as a large body of individual 
 x
 ,
  y 
 coordinates and sequences of 
 moveto
  and 
 lineto
  instructions. However, 
 using one of the loop operators can be an extremely useful technique 
 even with real data that are not synthetically generated within the loop 
 itself (as
  
 93",NA
LOOP BASICS,"There are several different looping operators in the PostScript language 
 (see Table 8.1). Each of them has a particular purpose and a style of use 
 that is worth considering.
  
 Table 8.1: Looping Operators
  
   
 Arguments Operator
  
   
   
  
 –
  exit –
  
  
 pattern proc buffer
  filenameforall 
 start index end proc
  for –
  
 composite_obj proc
  forall –
  
   
   
 proc
  loop –
  
   
  
 count proc
  repeat
  
 Action 
  
 jump out of loop body immediately 
 execute proc for each file that 
  
 matches pattern string 
  
 execute proc as many times as 
 (end-start) / index dictates.
  
 execute proc for each element of 
 composite_obj 
  
 execute proc indefinitely 
  
 execute proc exactly count times
  
 If you want to execute a sequence of instructions a precise number of 
 times, you should use either the 
 repeat
  operator or the 
 for
  operator. Use 
 repeat
  if you don’t need to use the loop index within the body of the loop 
 (as discussed in the next section). If you want to keep executing a loop 
 until some condition is met, you should use the 
 loop
  operator, and use 
 exit
  to pop out of the loop when the condition is satisfied. If you want to 
 execute some instructions on each element of an array, a string, or a 
 dictionary, you can use the 
 forall
  operator, which supplies each element 
 of a composite object to the loop as it is executing. This is useful for 
 searching through arrays and sometimes for processing each character in 
 a string, although it is a fairly labor-intensive operation compared to 
 other string operators.
  
 To construct a simple program loop, first start with a template for the 
 loop body and make sure to supply the correct arguments for the looping 
 operator you have chosen. Example 8.1 shows a simple 
 repeat
  loop that 
 draws an octagon; its result is displayed in Figure 8.1.
  
 94
  
 Chapter 8:   USING LOOPING CONSTRUCTS",NA
USING THE LOOP INDEX,"Looping operators are useful because they let a task be performed more 
 than once. They can be even more useful when you keep track of the loop 
 index and use it effectively.
  
 Chapter 8:   USING LOOPING CONSTRUCTS
  
 95",NA
LOOPS ARE PROCEDURE BODIES,"Since the 
 proc
  passed to all of the looping operators is just an ordinary 
 procedure body, you can perform any of the standard operations on it. 
 One often-overlooked but very important detail is to apply 
 bind
  to the 
 procedure body before executing the loop instruction, so that the loop 
 will execute more quickly (see Example 8.5). Be careful, however, not to 
 apply 
 bind
  to a loop that is inside a procedure body that has also been 
 bound; it doesn’t accomplish anything further (since 
 bind
  applies to all 
 nested procedure bodies recursively) and may degrade performance 
 slightly if 
 bind
  is executed each time the procedure is called.
  
 Example 8.5: Using 
 bind
  on Loop Bodies
  
 0 1 1000 { %for 
  
  
 0 moveto 0 400 rlineto stroke 
  
 } bind for
  
 You can also take advantage of the fact that a loop body is an array (all 
 procedures are arrays) and actually 
 put
  objects directly into it to save 
 time. Example 8.6 shows this technique applied to creating an 
 Encoding 
 array for a font, where you have to supply the array object itself 255 
 times during the execution of the loop. This saves the interpreter name 
 lookup overhead each time around the loop.
  
 Example 8.6: Putting Objects into Loop Bodies
  
 /encoding currentfont /Encoding get def 
  
 0 1 255 { %for 
  
  
 ENCODING_HERE exch /.notdef put 
  
 } dup 0 encoding put bind for
  
 This example is a bit tricky, but it has a simple underlying concept. The 
 trick is to put a dummy object into the procedure body (in this case, the 
 executable name 
 ENCODING_HERE
 , but it could be any object), then, 
 before the procedure is ever executed, to replace that dummy object with 
 the actual encoding array itself, instead of a name. The advantage to this 
 approach is that you don’t have to look up the name all 256 times around 
 the loop; the array object itself is in the procedure body, which saves you 
 256 name lookups and a lot of time.
  
 Chapter 8:   USING LOOPING CONSTRUCTS
  
 99",NA
LOOPS OF INSTRUCTIONS,"One very powerful use of looping operators is to perform repeated 
 instructions, such as a series of 
 lineto
  or 
 curveto
  operators. This can be 
 particularly effective in a printer driver or any situation in which you 
 might want to avoid repeating the names of the operators many times. 
 Example 8.8 has a large number of repetitive instructions; the program 
 sets several lines of text sequentially down the page. It can be written to 
 minimize the number of individual instructions issued, as seen in 
 Example 8.9.
  
 Example 8.8: A Program with Repeated Instructions
  
 72 750 moveto 
  
 /Times-Roman findfont 10 scalefont setfont 
  
 gsave 
  
 (Sometimes you have to construct a loop that may run for an indeterminate) show 
 grestore 
  
 0 -12 rmoveto 
  
 gsave 
  
 (length of time. For example, you might loop until an EOF condition is) show 
 grestore 
  
 0 -12 rmoveto 
  
 gsave 
  
 (met, or until no more spaces are found in a string, etc.) show 
  
 grestore 
  
 0 -12 rmoveto
  
 Example 8.9: Using 
 repeat
  for Instructions
  
 72 750 moveto 
  
 /Times-Roman findfont 10 scalefont setfont 
  
 (met, or until no more spaces are found in a string, etc.) 
  
 (length of time. For example, you might loop until an EOF condition is) 
 (Sometimes you have to construct a loop that may run for an indeterminate) 
 3 { %repeat 
  
  
 gsave show grestore 0 -12 rmoveto 
  
 } bind repeat
  
 Chapter 8:   USING LOOPING CONSTRUCTS
  
 101",NA
EXITING LOOPS PREMATURELY,"Sometimes you have to construct a loop that may run for an 
 indeterminate amount of time. For example, you might loop until an end-
 of-file condition is met, or until no more spaces are found in a string. The 
 best way to construct a loop of this type is to use the 
 loop
  and 
 exit
  
 operators. The 
 exit
  operator will simply cause the innermost looping 
 context to be broken, allowing exit from the loop at any point.
  
 Here is the basic loop construct:
  
 { %loop 
  
  
 exit_condition { exit } if 
  
 } loop
  
 The 
 exit_condition
  is some test that decides whether or not it is time to 
 exit the loop. For example, in the program in Example 8.10, the exit 
 condition is provided by the 
 readline
  operator, which returns 
 false
  if the 
 end of the file is reached, 
 true
  otherwise.
  
 102
  
 Chapter 8:   USING LOOPING CONSTRUCTS",NA
CONCLUDING THOUGHTS,"In this chapter you have seen many different situations for loops, some of 
 which use data, some of which use instructions, and some of which are 
 simply executed until it is determined that they are done. It is up to you 
 to decide which of the looping operators is best suited for your needs, 
 and to use it appropriately. In the next chapter you will see how to 
 construct and use procedures in your programs.",NA
EXERCISES,"1. 
  
 Rewrite the following C program segment in PostScript.
  
 main () 
  
 { 
  
  
 long factorial; 
  
  
 int index; 
  
  
 factorial = 1; 
  
  
 for ( index = 10; index > 0; index-- ) 
  
  
 { 
  
  
  
 factorial = factorial * index; 
  
  
 } 
  
  
 printf ( “10 factorial is %d\n”, factorial ); 
  
 }
  
 2.
  
 Rewrite the following PostScript code fragment using a 
 repeat
  loop. 
 Don’t worry about manufacturing the data inside the loop, just use 
 the data directly from the operand stack.
  
 Chapter 8:   USING LOOPING CONSTRUCTS
  
 103",NA
Chapter 9,NA,NA
Procedures,"In most programming languages, 
 procedures
  are used to group together a 
 set of instructions into a package that can be given a name and invoked 
 by that name. The PostScript language provides a similar mechanism, 
 although it is not as formal as many other languages. In particular, there 
 are no local variables or specific parameter-passing conventions. It is up 
 to you to decide what resources the procedure will use and how it will 
 interact with its environment.
  
 A PostScript procedure does not have to take its “traditional” form as a 
 parcel of instructions to be called as a sort of subroutine. In fact, 
 procedure bodies are used in many places without having names at all. 
 For example, an 
 ifelse
  statement requires two procedure bodies among its 
 arguments, although only one of them is used each time 
 ifelse
  is invoked.
  
 In traditional procedural programming languages, a distinction is made 
 between a procedure and a 
 function
 . A function is simply a set of 
 instructions that returns a value or values to the caller. For example, if 
 you wanted to compute the average of three numbers, you might use a
  
 105",NA
WHAT EXACTLY IS A PROCEDURE?,"In formal PostScript language terms, a 
 procedure body
  is just an 
 executable array, which is an array of PostScript objects that has its 
 executable flag set. There are no further requirements of a procedure 
 from the language’s point of view. In fact, the procedure does not even 
 have to be composed of legal language elements for you to declare it. 
 Since PostScript is an interpreted language, it is not until you try to run 
 the program that the procedure will be interpreted (and that you will find 
 out if it is written reasonably).
  
 There are several places where procedure bodies are often found (or are 
 required).
  
 •
  
 •
  
 •
  
 •
  
 Procedure bodies are used with operators like 
 loop
 , 
 for
 , 
 forall
 , 
 and 
 filenameforall
 .
  
 Procedure bodies are used in 
 ifelse
  statements to provide the 
 true 
 and 
 false
  clauses of the conditional.
  
 Some operators—including 
 image
 , 
 kshow
 , 
 forall
 , 
 settransfer
 , 
 and others related to these—require procedure bodies as 
 operands.
  
 User-defined procedures can behave just like built-in operators, 
 and are a useful way to extend the language.
  
 Let’s look at a typical procedure definition and its use (Example 9.1).
  
 106
  
 Chapter 9:   PROCEDURES",NA
PARAMETER PASSING,"The best way to pass specific information to a procedure is to place it on 
 the operand stack. There is, however, no procedure declaration to give 
 names to the parameters. In fact, no rule says you must use the 
 parameters. The cooperation between the definition of the procedure and 
 its invocation is entirely up to you. In general, though, a procedure 
 should consume all of its operands from the stack, unless it returns a 
 value of some kind.
  
 108
  
 Chapter 9:   PROCEDURES",NA
CONSTRUCTING GOOD PROCEDURES,"Simplicity, readability, efficiency, and correctness are the most important 
 aspects of your PostScript procedure, although not necessarily in that 
 order. The overall size of a procedure body should be maintained as 
 small as possible, but it is not more efficient to break a big procedure up 
 into smaller ones to call by name from within the larger one, due to the 
 additional name lookup and overhead on the execution stack.",NA
What to Name Your Procedure,"Assuming that you will create a procedure to be used by the rest of your 
 program, you will typically give it a name and invoke it by that name. Of 
 course, as with any programming language, the name should reflect the 
 functionality of the procedure as much as possible. Select poor names for 
 your smaller procedures and you may in fact make the program much 
 less readable.
  
 In choosing a name, it is important to consider just how the procedure 
 will be used. If the procedure will be used in the “script” of a document 
 and be invoked hundreds of times, its name should be short, to save space 
 and time in the execution of the program. However, if the procedure is 
 called only from other procedures that you have defined, you gain very 
 little by giving it a short name, since the name is represented by a 
 name 
 object
  of fixed size once the procedure body has been constructed.
  
 Let’s consider some examples. Can you guess what the procedure called 
 p 
 does in Example 9.8?
  
 Example 9.8: Disorganized and Inefficient Use of Procedures
  
 /b { bind def } bind def 
  
 /d { def } b /x { 
 exch } b 
  
 /m { moveto } b 
  
 /r { rlineto } b 
  
 /c { closepath } b 
  
 /f { fill } b 
  
 /p { %def 
  
  
 /#4 x d /#3 x d /#2 x d /#1 x d 
  
  
 #3 #4 m #1 0 r 0 #2 r #1 neg 0 r c f } 
 b 
  
 100 100 400 50 p
  
  
 Chapter 9:   PROCEDURES
  
 111",NA
A Useful Naming Convention,"To cement the ideas behind good naming of procedures and variables, 
 following is an example of a naming convention that can help keep it all 
 straight. You may adopt your own naming conventions, of course.
  
 •
  
 Use lower-case letters only for procedure names, since they 
 behave more or less like the PostScript built-in operators, which 
 are all lower-case.
  
 •
  
 Use mixed-case for variables, like 
 /LeftMargin
  or 
 /FontSize
 .
  
 •
  
 If the procedure names are never transmitted in quantity (as they 
 might be in the body of a document), there is no reason to make 
 them short. The interpreter will make them into tokens anyway.
  
 •
  
 Use single-letter names for the most commonly called 
 procedures in the body (or script) of a document, keeping them 
 as mnemonic as possible. For example, use 
 /s
  for show, 
 /f
  for 
 setting the font, 
 /c 
 for curves, and so on.
  
 •
  
 For procedures that are called frequently in the script of a 
 document but which are not the “workhorses,” use two-letter 
 names rather than using one-letter names that are not mnemonic. 
 For example, it is better to use 
 /ml
  for 
 { moveto lineto }
  than to 
 use, say, 
 /q
 .
  
 •
  
 For procedures that are called from within other procedures, use 
 descriptive names like 
 /newline
  or 
 /reencodefont
 .
  
 Chapter 9:   PROCEDURES
  
 113",NA
SELF-MODIFYING PROCEDURES,"This is a pretty fancy concept, “self-modifying procedures.” It invites 
 thoughts either of artificial intelligence or of assembly language 
 techniques that are usually discouraged. However, in a simpler form, 
 self-modifying procedures can be extremely useful—without being 
 dangerously difficult.
  
 Since a PostScript procedure is just an array, it is relatively easy to 
 change the contents. It is just a matter of using array operations. Let’s 
 look at a practical example. When using the 
 settransfer
  operator to set 
 up a gray-level transfer function, it is correct to add your function to the 
 end of the transfer function that is already in place, rather than to replace 
 it. Let’s assume that the existing transfer function exchanges black for 
 white, as in Example 9.11.
  
 Example 9.11: Existing Transfer Function
  
 {1 exch sub } 
  
 This is a simple function that inverts the sense of black and white. Let’s 
 imagine that you want to set another transfer function that makes a single 
 exception of black and makes it 50 percent gray instead (see Example 
 9.12).
  
 Example 9.12: New Transfer Function to be Set
  
 { dup 0 eq { pop 0.5 } if }
  
 To concatenate the two procedures, you would want a result in which both 
 procedures are executed in order (see Example 9.13).
  
 114
  
 Chapter 9:   PROCEDURES",NA
CONCLUDING THOUGHTS,"Procedures are executable arrays. This gives you the power to execute 
 array operations on them occasionally, to copy them, to add elements, or 
 to replace dummy objects with real ones. Procedure bodies are also used 
 as arguments to many PostScript operators. Since the procedure bodies 
 used by the 
 ifelse
  operator are no different than ones you might define for
  
 116
  
 Chapter 9:   PROCEDURES",NA
EXERCISES,"1.
  
 Replace the following PostScript sequence with an equivalent one 
 that makes use of a single procedure call named 
 TEXT
  instead of the 
 in-line PostScript operators. 
  
 100 100 moveto 
  
 /Times-Bold findfont 24 scalefont setfont 
  
 (This is an example of Times-Bold) show
  
 2.
  
 Write a procedure that takes two procedure bodies and concatenates 
 them into a third procedure body, which it leaves on the stack. Call 
 your procedure 
 concatprocs
 .
  
 3.
  
 Rewrite the 
 def
  operator as a procedure that has the same functional-
 ity, but don’t use 
 def
  within your procedure. (HINT: You must use 
 another PostScript operator to accomplish the same thing.) It’s okay 
 to use 
 def
  to define your procedure, but it should not contain the 
 def 
 operator.
  
 4.
  
 Redefine the 
 moveto
  operator to check for operands that are off the 
 page, and to report these errant coordinates with the 
 ==
  operator. Use 
 a page size of 612 by 792 points, and don’t worry about a scaled 
 coor-dinate system.
  
 Chapter 9:   PROCEDURES
  
 117",NA
Chapter 10,NA,NA
Using Dictionaries,"Dictionaries are the basic form of storage in the PostScript language. 
 Whenever you use the 
 def
  operator, you are storing something into a 
 dictionary. Each time you use a name like 
 moveto
  or call up one of your 
 procedures named 
 L
 , you are retrieving data out of a dictionary.
  
 To fully understand how dictionaries store data, it is necessary to realize 
 that all PostScript data types are represented by objects. These objects are 
 all the same size, even if the data that they represent are too big to fit 
 inside the object. A dictionary is a place to make key–value pairs of 
 objects. (Remember: the value is the object you want to store, and the 
 key is the name under which you store it.) To get the value back, you 
 need the key again. If your value is a composite object (such as a string, 
 an array, or another dictionary) the data will actually be in memory that 
 has been previously allocated to hold it, and the object stored in the 
 dictionary points to it. Example 10.1 is a simple example of a dictionary 
 entry.
  
 119",NA
DICTIONARIES FOR NAME SCOPING,"Name scoping involves making names context-sensitive, depending on 
 the dictionaries currently on the dictionary stack. To understand its 
 usefulness, you must know that the most common method for retrieving 
 data that have been stored into a dictionary is to use the 
 name lookup 
 mechanism. With this mechanism, an executable name encountered by 
 the interpreter is looked up in the context of the current dictionary stack. 
 You can use a key more than once and it can have different values 
 associated with it in different dictionaries. When the name is looked up, 
 the dictionary stack is searched from the top down, and the first instance 
 of the key that is encountered is the one that is used.
  
 This provides a simple mechanism for changing name scoping. As an 
 example, consider the problem of underlining text. You may want to 
 have a simple text-setting procedure that you use when you’re not 
 underlining
  
 120
  
 Chapter 10:   USING DICTIONARIES",NA
LOCAL DICTIONARIES,"A 
 local dictionary
  is a dictionary that is visible only under certain 
 circumstances. If a procedure body references a particular dictionary, it is 
 said to be local to that procedure body.
  
 Local dictionaries are very useful. One of the most common uses of a 
 local dictionary is to store local definitions that might be used by a 
 procedure. This is especially important if you use the 
 def
  operator, which 
 writes into the current dictionary. It is best to make sure you know where 
 all of the definitions are being made, to prevent errors like 
 dictfull
  or 
 invalidaccess
 .
  
 Chapter 10:   USING DICTIONARIES
  
 121",NA
GLOBAL DICTIONARIES OF PROCEDURES,"The only time you really need local dictionaries is for re-entrant code or 
 recursion. For most other situations, a good approach is to create one 
 larger dictionary to hold both procedures and their data, as long as you 
 are careful about name conflicts (Example 10.3). They are not really 
 “local variables,” but if you need to be careful about storage space but 
 are not worried about recursion or name conflict within your own code, 
 this is much simpler and more efficient. This technique also relieves each 
 procedure of having to 
 begin
  and 
 end
  the dictionary, which makes it 
 easier to maintain and faster at the same time.
  
 TIP
  
 Most PostScript drivers and any program with more than a small handful 
 of procedures should make sure to build its own dictionary for storing the 
 procedures, to avoid the 
 dictfull
  error that might result if you trust the 
 exe-cution environment to have enough room in, say, the 
 userdict
  
 dictionary for all your definitions.
  
 Example 10.3 shows the use of a single dictionary for all definitions 
 made by the program. This technique can be a little bit riskier, since there 
 is still a chance that another dictionary might be left on top of 
 ProductDict 
 (perhaps by an included illustration); this would make all 
 subsequent instances of 
 def
  write into the wrong dictionary. However, 
 you can make sure to check the dictionary stack whenever you include an 
 illustration. This technique is the best general approach for storing 
 definitions in a private dictionary.
  
 Example 10.4: All Procedures within One Global Dictionary
  
 /ProductDict 7 dict def
  
 ProductDict begin 
  
  
 /Text 
   
 % (string) Xloc Yloc Text -
  
 { %def 
  
  
  
 /X exch def 
  
  
  
 /Y exch def 
  
  
  
 /text exch def 
  
  
  
 X Y moveto text show 
  
 } bind def
  
  
 Chapter 10:   USING DICTIONARIES
  
 123",NA
MAINTAINING THE DICTIONARY STACK,"The dictionary stack in a PostScript interpreter is not as readily 
 manipulated as the operand stack. There are no equivalent operators for 
 the dictionary stack operators such as 
 exch
 , 
 roll
 , and
  dup
 . The only way 
 to rearrange dictionaries is to place them temporarily on the operand 
 stack, rearrange them there, then replace them on the dictionary stack.
  
 For the most part, it should not be necessary to rearrange the dictionaries 
 on the dictionary stack, but it is occasionally important to make sure your 
 dictionary is the topmost one. In these circumstances, it might be best to 
 simply use 
 begin
  to explicitly place your dictionary on the top, even if it 
 might already be present further down on the dictionary stack.
  
 Example 10.5 presents a procedure to implement 
 dictexch
 , the equivalent 
 of the 
 exch
  operator for the dictionary stack. This example is intended to 
 give you the flavor of the necessary dictionary manipulation; to see how 
 it works, see Example 10.5. The procedure shown is not necessarily a 
 recommended approach for using the dictionary stack.
  
 124
  
 Chapter 10:   USING DICTIONARIES",NA
INTO AND OUT OF DICTIONARIES,"The dictionary stack holds dictionary objects. There are built-in operators 
 in the PostScript language for putting things into or retrieving things 
 from the current dictionary. There are also several other ways to 
 manipulate the contents of dictionaries directly.
  
 A dictionary is a normal PostScript object and can exist on the operand 
 stack as well as on the dictionary stack. The 
 put
  operator lets you put an 
 entry directly into a dictionary that is on the operand stack, and 
 get
  lets 
 you retrieve from it. (See Example 10.6.)
  
 Example 10.6: Using 
 put
  and 
 get
  for Dictionary Entries
  
 /MyFont 
  
 % leave on operand stack 
  
 15 dict 
  
  
 % leave on operand stack 
  
  
 dup /FontName /MyFont put 
  
  
 dup /Encoding StandardEncoding put 
  
 dup /BuildChar { whatever } put 
  
  
 dup /CharStrings 100 dict put 
  
 definefont pop
  
 % This is not the recommended way to call an operator: 
  
 statusdict /ledgertray get exec 
  
 systemdict /showpage get exec
  
 If your needs are simple, you may be able to avoid having to place a local 
 dictionary on the operand stack at all. You can use the 
 get
  and 
 put 
 operators to explicitly reference a dictionary without ever placing it on 
 the dictionary stack. In Example 10.7, the save object that results from 
 executing 
 save
  is stored away into a dictionary, and is retrieved later for 
 restore. Since there is only a single entry to be written into the dictionary, 
 it is a little bit simpler (although perhaps no clearer) to use 
 put
  rather 
 than 
 begin
 , 
 def
 , and 
 end
 .
  
 Example 10.7: Scoping with 
 put
  and 
 get
  
 userdict /mysaveobj save put
  
  
  % embedded illustration here 
  
 userdict /mysaveobj get restore
  
 126
  
 Chapter 10:   USING DICTIONARIES",NA
LOOKING INTO DICTIONARIES,"Dictionaries contain key–value pairs. In addition to being able to retrieve 
 specific entries from a dictionary with the 
 get
  or 
 load
  operator, you can 
 see what entries already exist in the dictionary with the 
 forall
  operator. 
 This can be useful for various purposes, such as finding out what fonts 
 are currently defined in the interpreter (looking in the 
 FontDirectory
  or 
 SharedFontDirectory
  dictionaries) or in debugging, to figure out which 
 dictionary is currently on top of the dictionary stack.",NA
Using the ,NA,NA
forall,NA,NA
 Operator,"Looking through existing dictionaries can be instructive, even if it isn’t 
 part of any production code you are writing. One of the most useful 
 operators for this purpose is the 
 forall
  operator. This operator loops 
 through the contents of a dictionary and executes your procedure for each 
 key–value pair found in the dictionary. Example 10.8 shows a simple 
 way to enumerate a dictionary with the 
 forall
  operator.
  
 Example 10.8: Browsing a Dictionary with 
 forall
  
 /browse-dict 
   
  
 % dictionary browse-dict –{ 
 %def 
  
  
 { %forall 
  
  
  
 exch 
  
 % name first 
  
  
  
 (key: ) print == 
  
  
  
 (val: ) print == 
  
  
 } forall 
  
 } bind def 
  
 userdict browse-dict
  
 The entries will not come out in a particularly sensible order. Instead, 
 they are in 
 hash table
  order, in which the location in the dictionary is 
 determined by deriving an index directly from the key you used. (To 
 digress slightly, an example hash function might be to add up the byte 
 values of all the characters in a name object and use that number as an 
 index into an array.) To make the 
 forall
  operator a little more useful, you 
 can use the 
 type
  operator to take a look at each value in the dictionary, 
 and take different measures depending on the data type. This will help to 
 look into other dictionaries and arrays that might be lurking inside the
  
 Chapter 10:   USING DICTIONARIES
  
 127",NA
Using the ,NA,NA
where,NA,NA
 and ,NA,NA
known,NA,NA
 Operators,"A very good way to make sure your code is portable if you are using 
 features that may or may not be present on all implementations is to use 
 either the 
 known
  or the 
 where
  operators. These operators allow you to 
 check for the existence of names in dictionaries, and execute some 
 conditional code based on whether or not you find them.
  
 For example, let’s say you want to use four-color operations in the 
 CMYK color space (cyan, magenta, yellow, and black). As a point of 
 interest, the reason K is used by convention—rather than B—to represent 
 black is that B is already used to represent the color blue in the RGB 
 color model (red, green, blue).
  
 You want to use the 
 setcmykcolor
  operator, but if it isn’t available, you 
 can simulate it using 
 setrgbcolor
 . Using the 
 where
  operator, you can 
 define a simulation only if the name 
 setcmykcolor
  is not defined already 
 in the interpreter (see Example 10.10).
  
 Example 10.10: Conditionally Defining a Procedure
  
 % /C points to “setcmykcolor” if it exists, else it emulates it with 
 “setrgbcolor”/C 
  
  
 /setcmykcolor where { %ifelse 
  
  
  
 /setcmykcolor get 
  
  
 }{ %ifelse 
  
  
  
 { %def 
  
  
  
  
 1 sub 3 { %repeat 
  
  
  
  
  
 3 index add neg dup 0 lt { pop 0 } if 3 1 roll 
  
  
  
 } repeat 
  
  
  
  
 setrgbcolor 
  
  
  
 } bind 
  
  
 } ifelse 
  
 def
  
 In this case the 
 /C
  is left on the operand stack while 
 where
  is executed to 
 determine whether or not the simulation is needed for 
 setcmykcolor
 . If 
 the name 
 setcmykcolor
  is found, the current definition of it is loaded 
 onto the operand stack. In either case, the name 
 /C
  will have equivalent 
 functionality to the 
 setcmykcolor
  operator, and can be used throughout 
 the program with the same arguments that 
 setcmykcolor
  requires, 
 without having to adjust the rest of the program according to the color 
 model or the interpreter used.
  
 Chapter 10:   USING DICTIONARIES
  
 129",NA
REDEFINING OPERATORS,"There are very often instances in which you want to change the behavior 
 of your program, even just temporarily, by redefining some of the names 
 in it before the program executes. This has many possible uses, for 
 debugging, page accounting, distilling documents into another form, or 
 adding to the functionality of an existing program.
  
 As you have learned, name lookup is done in the context of the 
 dictionary stack. There are correspondingly two basic ways to redefine a 
 name non-destructively.
  
 •
  
 •
  
 Make a simple redefinition in the current dictionary with 
 def
 . 
 Push a special dictionary onto the dictionary stack into which the 
 redefinitions are placed.
  
 If you put the redefinitions in a separate dictionary, then it is easy to put 
 them in place or remove them temporarily, simply by pushing or popping 
 the dictionary from the dictionary stack. However, this method is a little 
 bit more subject to problems, since the program may inadvertently 
 remove your special dictionary from the dictionary stack, or try to write 
 into it as if it were its own dictionary.",NA
Changing the Behavior of Operators,"When you redefine an operator to have some other behavior beyond or 
 instead of its default, you must take care to preserve at least the way in 
 which the operator interacts with the operand stack, and you probably 
 need to simulate some of the side effects, as well. For example, the 
 moveto
  operator pops two numbers off the stack and installs a current 
 point into the graphics state. If you redefine 
 moveto
 , you should at least 
 make sure to pop exactly two numbers from the stack, and you probably 
 ought to establish a current point while you’re at it, if you want the 
 program to continue to execute beyond the next instruction or so (without 
 generating a 
 nocurrentpoint
  error). One very good way to accomplish 
 this is simply to invoke the original definition of the name when you are 
 finished with your extensions. Example 10.11 shows a redefinition of 
 showpage
  that adds a “draft” notice onto the edge of the document as it 
 is being printed. The original (or previous, to be more accurate) 
 definition of
  
 130
  
 Chapter 10:   USING DICTIONARIES",NA
Debugging with Redefined Names,"A very good way to track the execution of your program is to redefine 
 one of the operations in it to produce some extra tracking information as 
 it is being called. For instance, you could redefine the 
 show
  operator to 
 echo each string back to the standard output file as it is being printed, or 
 you could redefine the 
 moveto
  operator to watch for coordinates that are 
 off the page and to warn you. Then, once you get the program working, 
 you can simply remove your redefinitions, and the program should work 
 without further modification.
  
 Example 10.12 contains a simple redefinition of the 
 show
  operator that 
 will track each string as it is being printed.
  
 Example 10.12: Redefining 
 show
  to Help Debugging
  
 /old_show /show load def 
 /show 
  
 { %def 
  
  
 dup == flush 
  
  
 old_show 
  
 } bind def
  
 % (string) show -
  
  
 Chapter 10:   USING DICTIONARIES
  
 131",NA
Proper Nesting of Redefinitions,"It is important to redefine names carefully so that they can be nested 
 reasonably. It is always good to use the 
 load
  operator when you pick up 
 the old definition of a name. This is much better than, say, looking up the 
 name directly in 
 systemdict
 . However, it is also useful to keep your own 
 name (like 
 /old_show
 ) from clobbering itself if you install your 
 procedures a second time. One good way to accomplish that is to push a 
 special dictionary onto the dictionary stack, but to avoid giving it a name 
 (or your name will conflict with itself the second time you install the 
 procedure). Example 10.13 illustrates this technique by loading the 
 existing value stored under the name 
 show
 , storing it away under the 
 name 
 old_show
 .
  
 Example 10.13: Using 
 load
  to Get Previous Definitions
  
 /old_show /show load def 
  
 /show { %def 
  
  
 dup == flush 
  
  
 old_show 
  
 } bind def",NA
CONCLUDING THOUGHTS,"Dictionaries are flexible and powerful. The main uses for them are as 
 storage for items that you don’t want to leave on the operand stack and as 
 a name lookup mechanism for scoping program execution or local 
 variables. You have learned several ways to manipulate dictionaries, 
 store and retrieve entries from dictionaries, and look at their contents. 
 Dictionaries are not heavily used in most PostScript programs other than 
 to store simple definitions, but they can be exploited for some interesting 
 purposes when the need arises, as you have seen. In the next chapter, 
 dictionaries are contrasted to arrays and various methods of creating and 
 manipulating data are presented.
  
 132
  
 Chapter 10:   USING DICTIONARIES",NA
EXERCISES,"1.
  
 What value is left on the operand stack after executing the following 
 short program segment?
  
 /variable 7 def 
  
 5 dict dup begin 
  
  
 /variable 9 def 
  
 end 
  
 /variable dup load 3 1 roll get add
  
 2.
  
 Replace the dictionary named 
 LOCALDICT
  in the following proce-
 dure with an anonymous dictionary. (The dictionary itself should 
 have no name, and the only instance of the dictionary object should 
 be inside the procedure body.)
  
 /LOCALDICT 12 dict def 
  
 /boxproc 
  
  
 % Xloc Yloc Width Height 
 boxproc -{ %def 
  
  
 LOCALDICT begin 
  
  
  
 /height exch def 
  
  
  
 /width exch def 
  
  
  
 /Y exch def 
  
  
  
 /X exch def 
  
  
  
 X Y moveto 
  
  
  
 0 height rlineto 
  
  
  
 width 0 rlineto 
  
  
  
 0 height neg rlineto 
  
  
  
 closepath 
  
  
  
 fill 
  
  
 end 
  
 } bind def
  
 3.
  
 Name three operators in the PostScript language that use the dictio-
 nary stack in some way.
  
 4.
  
 Write a program that shows (with the 
 ==
  operator) the names of all 
 the fonts stored in the dictionary called 
 FontDirectory
 .
  
 Chapter 10:   USING DICTIONARIES
  
 133",NA
Chapter 11,NA,NA
Creating and Manipulating Data,"The two most basic types of data structures are arrays and strings. 
 PostScript arrays can contain any other type of PostScript objects, 
 including composite objects. Strings contain individual characters, as in 
 most languages.",NA
CONSTRUCTING AN ARRAY,"To construct an array, the simplest thing to do is to use the 
 [
  and 
 ] 
 operators. These operators create an array on the fly, during the execution 
 of your program, and put into that array anything that is on the operand 
 stack down through the matching 
 [
  at the time the 
 ]
  operator is executed. 
 A simple example is seen in Example 11.1.
  
 Example 11.1: Sample Constructed Array
  
 [ /one dup dup (four) /five 3 3 add /seven { 8 (the whole procedure) } 9 10 ]
  
 135",NA
CONSTRUCTING A STRING,"Strings can be constructed in much the same way as arrays. You can 
 create one at run-time in the original input program by using the notation 
 found in Example 11.4 for simple strings or hexadecimal strings (also 
 called hex strings).
  
 Example 11.4: Creating Strings with the Scanner
  
 (This is a string created at run-time; following is a hex string:) 
 <a32989e4ff>
  
 Hexadecimal strings are scanned two bytes at a time to create the single 
 byte represented by the 8-bit number. (One byte of hexadecimal, since it 
 is base 16, provides only 4 bits of data; it requires two bytes of 
 hexadecimal to represent a full 8 bits.) Hex strings are generally used 
 only for image data, strings for Kanji character sets, or other places 
 where full 8-bit string data must be used. The 
 string
  operator can also be 
 used to create an empty string body, and you can use 
 put
  or 
 putinterval
  
 to put bytes into the string.",NA
MANIPULATING DATA WITH ,NA,NA
PUT,NA,NA
 AND ,NA,NA
GET,"Strings and arrays are composite data structures. They are both 
 represented by single objects, but really they are composed of collections 
 of objects. There are a few different ways to read and write the contents 
 of these composite data structures, included in Table 11.1. The 
 fundamental mechanism is the family of 
 put
  and 
 get
  operators. We’ll 
 start with the simplest ones.
  
 Chapter 11:   CREATING AND MANIPULATING DATA
  
 137",NA
CONCATENATING ARRAYS AND STRINGS,"Arrays and strings have a fixed length. You cannot dynamically extend 
 them. In order to tack two of them together, you must allocate a third 
 array or string that is big enough to hold the other two, then copy them 
 both into it. There is no easier way to do it, unfortunately.
  
 Example 11.7 sets forth a procedure called 
 concatenate
 . This 
 concatenate
  procedure tacks together two string bodies into a third string 
 that is left on the operand stack as the result of the procedure call. The 
 procedure works with arrays in precisely the same way. If you copy this 
 example, be careful not to call it 
 concat
 , since that is the name of another 
 PostScript operator for concatenating matrices.
  
 The 
 roll
  operator is used in the body of this procedure to avoid having to 
 make any dictionary entries. This is intentional, since a procedure used as 
 an operator-equivalent (as 
 concatenate
  is) should have as few side 
 effects as possible.
  
 Note the use of 
 putinterval
  in this procedure. It is called once to copy 
 the body of the first argument into the destination at position 0, then it is 
 called a second time with the position in the destination equal to the 
 length of the first argument, so the second argument lands exactly where 
 the first part left off. Note the use of 
 length
  to determine this position, 
 and the careful use of 
 dup
  and 
 index
  to keep copies of the various strings 
 or arrays until we are done with them. The 
 length
 , 
 putinterval
 , and 
 type 
 operators all consume their operands, so you must take care to operate on 
 a copy of the original arguments until they are no longer needed.
  
 Chapter 11:   CREATING AND MANIPULATING DATA
  
 139",NA
INPUT AND OUTPUT OF STRING DATA,"A string is basically a chunk of memory in which characters are stored. 
 The string body is created first, then characters may be added to it with 
 the 
 copy
 , 
 put
 , 
 putinterval
 , 
 read
 , 
 readstring
 , or 
 readhexstring 
 operators.
  
 There are two primary sources for string data. The most commonly used 
 one is to supply the data as a literal string (using the familiar 
 parentheses), as shown in Example 11.8.
  
 Example 11.8: Creating a Literal String
  
 % normal “show” string: 
  
 (This is a string) show 
  
 % exactly the same result using a hex string: 
  
 <54686973206973206120737472696e67> show
  
 140
  
 Chapter 11:   CREATING AND MANIPULATING DATA",NA
ARRAYS VERSUS DICTIONARIES,"There are several differences between arrays and dictionaries that make 
 them more (or less) appropriate for a given task. The most important 
 differences are:
  
 •
  
 Arrays can be accessed sequentially, but dictionaries cannot be 
 accessed sequentially (the 
 forall
  operator uses hash table order).
  
 Chapter 11:   CREATING AND MANIPULATING DATA
  
 141",NA
ADVANCED TECHNIQUES,"PostScript programs that read data directly from a file sometimes have to 
 perform extensive string manipulation to use the data. An interesting 
 trick for parsing data is to use the 
 token
  operator. If your data are ASCII 
 and can be interpreted somehow as PostScript-like objects, your parsing 
 task can be greatly simplified.
  
 Consider the program in Example 11.10 that reads pairs of points from 
 the input file and constructs line segments from them. The output of this 
 example is shown in Figure 11.1.
  
 Example 11.10: Reading and Executing Data from a File
  
 %!PS-Adobe-2.0 EPSF-2.0 
  
 %%BoundingBox: 0 0 150 150 
  
 %%EndComments 
  
 100 300 translate
  
 142
  
 Chapter 11:   CREATING AND MANIPULATING DATA",NA
CONCLUDING THOUGHTS,"In this chapter, you’ve seen how to construct arrays and strings and how 
 to manipulate them with 
 put
  and 
 get
 . You have also seen how to
  
 Chapter 11:   CREATING AND MANIPULATING DATA
  
 143",NA
EXERCISES,"1. 
  
 What are the contents of the array constructed by the following code?
  
 [ 0 0 moveto 100 100 lineto currentpoint ]
  
  
 2.
  
 Show the PostScript code to create a two-dimensional array five ele-
 ments wide and ten elements deep.
  
 3.
  
 The 
 filenameforall
  operator is very useful in obtaining a list of font 
 files written to the disk on a printer. However, the file names that the 
 operator returns are of the form 
 (fonts/Palatino-Roman)
  rather than 
 simply 
 (Palatino-Roman)
 . Write a procedure called 
 extractfont-
 name
  that will take a string like 
 (fonts/Palatino-Roman)
  as input 
 and strip off the 
 (fonts/)
  part of the name, leaving just 
 (Palatino-Ro-
 man)
 .
  
 144
  
 Chapter 11:   CREATING AND MANIPULATING DATA",NA
Chapter 12,NA,NA
Storing and Using Data,"There are various kinds of data that get used by computer programs. 
 Some programs “crunch” data, bent on achieving a particular result based 
 on its input. Other programs allow users to create, edit, or rearrange data; 
 the result is up to the user’s imagination. Still others use input data only 
 to guide them through labyrinthine paths, producing no results at all.
  
 When writing your own program, it is worth considering just what the 
 numbers and text will be used for before you decide on your data 
 structures. For example, if your program takes a sequence of numbers 
 and plots them, you probably don’t want to store the numbers in a 
 permanent place. In fact, the sooner you get rid of them (plot them), the 
 better. However, many bits of data are in fact used internally by the 
 program itself, to establish state, and are never intended as part of any 
 output. (These bits of data may include, for example, the current page 
 margins, the point size of the font you are using, or maybe a string buffer 
 needed for reading from a file object.)
  
 145",NA
Data and the Operand Stack,"Remember that all PostScript operators require their operands to be on 
 the stack. Even if you store something into a dictionary, it must 
 eventually get put back on the operand stack before it can be used for 
 anything.
  
 Of course, the operand stack is also the first place any data land on the 
 way into your program. Assembling these ideas in our minds, we realize 
 that maybe, under some circumstances, the data should just stay on the 
 operand stack until they are used. That is the first principle of data 
 storage and use in PostScript programming.
  
 The exaggerated instance shown in Example 12.1 is a procedure that 
 requires several operands, all of which are eventually used by some 
 PostScript operators internally. In this example, these operands are given 
 names within the procedure body, ostensibly so that the procedure will be 
 easier to maintain. But notice that the values are no sooner stored into a 
 dictionary than they are recalled onto the operand stack, which is 
 unnecessarily slow.
  
 Example 12.1: Using Too Many Variables
  
 % This program draws a shaded, outlined box 
  
 /BX 
   
 % X Y Bwidth Bheight fillgray linewidth linegray BX 
 { %def 
  
  
 /linegray exch def 
  
  
 /linewidth exch def 
  
  
 /boxgray exch def 
  
  
 /Bheight exch def 
  
  
 /Bwidth exch def 
  
  
 /Y exch def 
  
  
 /X exch def 
  
  
 fillgray setgray 
  
  
 X Y Bwidth Bheight rectfill 
  
  
 linegray setgray 
  
  
 linewidth setlinewidth 
  
  
 X Y Bwidth Bheight rectstroke 
  
 } bind def
  
 In this example, variables are created to hold data that are inherently 
 transitory. The data really represent the box itself, and are not used by the 
 program in any other way. To give them names and make them into 
 variables has no purpose other than to make the program a bit more
  
 146
  
 Chapter 12:   STORING AND USING DATA",NA
Data and Algorithms for Underlining,"Let’s look at a slightly more involved example, one that is not quite so 
 easy a choice. We need to underline some text on the page, and must 
 keep track of the location and thickness that the underline should be. This 
 is a typical situation that comes up when writing the PostScript printer 
 driver for a word processor. We know where the underline for the text 
 will start, since it is very closely related to the place where the text starts 
 that you want to underline. It is a little more trouble to determine where 
 the underlining should end, since you have to calculate exactly where the 
 end of the text is, taking the font and point size into account as well as 
 any kerning or other positioning decisions you may have made. Very 
 likely, your word processor already has this information on hand, since it 
 had to set the text. You also have to decide how far below the text the 
 line should be, and how thick a line to use.
  
 It is a simple matter to draw a horizontal line. In fact, all you need to 
 know are its end points and how thick it should be. But the data that 
 represent that line are actually derived from something else, namely the 
 text being underlined.
  
 A common model for underlining in a word processor is to have what 
 amounts to “underline ON” and “underline OFF” commands, and have 
 the program automatically underline whatever you type while the 
 underlining is turned on. Let’s suppose our PostScript driver models that 
 behavior exactly (see Example 12.2).
  
 Example 12.2: Simple Model for Underlining Text
  
 /underlineON { /underline true def } def 
  
 /underlineOFF { /underline false def } def
  
 These procedures simply set an internal variable in the program, called 
 underline
 , to either 
 true
  or 
 false
 . But this variable must be noticed by 
 the text-setting routines. First, let’s look at the way we would like to use 
 these procedures. We’ll assume that a simple text-setting procedure 
 definition is in place (see Example 12.3).
  
 Chapter 12:   STORING AND USING DATA
  
 147",NA
CLASSICAL DATA STRUCTURES,"There are some classic data structures in the field of computer science 
 that you might want to construct in your PostScript program. For 
 instance, you might want to make use of doubly-linked lists, queues, 
 stacks, trees, and so forth. (Stacks are generally free in PostScript 
 because of the inherent stack-based model, but sometimes you need to 
 create your own.)",NA
Linked Lists,"Linked lists can be very useful data structures. A linked list is basically a 
 sequential list of chunks of data that you can traverse either forward or 
 backward (if it is doubly-linked). The main advantage to linked lists in 
 traditional programming languages is that you can allocate memory as 
 you need it, and it doesn’t have to be contiguous. In each data block, you 
 store a pointer to the next block, wherever it may be. In PostScript, the 
 need for these lists diminishes greatly, since you don’t need to worry 
 about the way memory is allocated in order to access data. PostScript 
 language arrays are arrays of other PostScript objects, each of which is 
 self-contained (and very likely occupies some memory that is not 
 adjacent to the next element in the array). But, readjusting the 
 terminology very slightly, lists are still extremely useful, even if you 
 don’t have to spend much time worrying about the links between the 
 elements.
  
 Chapter 12:   STORING AND USING DATA
  
 151",NA
Using Arrays to Form Lists,"Let’s look at an array that contains everything that the C 
 struct
  does, but 
 which does not have the links to the next item in the list (see Example 
 12.8).
  
 152
  
 Chapter 12:   STORING AND USING DATA",NA
Using Dictionaries to Form Lists,"Let’s try the same idea using a dictionary to store the elements of the 
 structure (see Example 12.10).
  
 Example 12.10: List Element as a PostScript Dictionary
  
 /head 9 dict def 
  
 /tail head def 
  
 head begin 
  
  
 /X 72 def 
  
  
 /Y 470 def 
  
  
 /font /Times-Roman def 
  
  
 /ptsize 16 def 
  
  
 % red, green, and blue stored as R,G,B: 
  
  
 /R 1 def 
  
  
 /G 0 def 
  
  
 /B 0 def 
  
  
 /text (Act One) def 
  
  
 /next null def% points to nothing 
  
 end
  
 154
  
 Chapter 12:   STORING AND USING DATA",NA
"Queues, Trees, and Other Data Structures","The concepts that have just been introduced for creating lists can easily 
 be extended to create queues, stacks, or even trees of all sorts, since 
 pointers are so easily created and assigned in PostScript.
  
 For example, a queue can be implemented as a linked list of items that 
 are always accessed in a first-in, first-out basis (FIFO). A stack could be 
 built the same way, accessing the data on a last-in, first-out basis (LIFO), 
 but it makes much more sense to use the PostScript operand stack to 
 collect the objects if you need them in that order anyway. For more 
 complicated structures like binary trees, you need only extend the basic 
 “structure”model of a dictionary or an array to contain references to the 
 appropriate elements of the tree. The structure of these classic data 
 structures is beyond the scope of this book, but is discussed at great 
 length in other volumes.
  
 Chapter 12:   STORING AND USING DATA
  
 155",NA
CONCLUDING THOUGHTS,"Although the data structures we have discussed in this chapter are very 
 sound principles in computer science, they may not be the most 
 appropriate storage paradigm in your PostScript program. Think very 
 carefully about the relationships between your data elements and the way 
 that they will be created, used, and destroyed. Consider the benefits and 
 drawbacks of arrays, dictionaries, and the operand stack before deciding 
 on the final representation for your data structures. Keep these points in 
 mind as you read about program data and instructions in the next chapter.",NA
EXERCISES,"1.
  
 2.
  
 When drawing a vertical line, you only need the 
 x
  coordinate once, 
 since it is the same for both endpoints of the line. Design a procedure 
 called 
 V
  that draws only vertical lines. Your procedure should be 
 able to draw a line at any thickness, at any 
 x,y
  location, and of any 
 length.
  
 In order to underline some text, you must determine the position and 
 thickness to draw the line.
  
 a.What are the disadvantages to performing this calculation in your 
 PostScript code?
  
 b.What are the disadvantages to performing the underlining calcula-
 tion in your word processor application?
  
  
 3.
  
 Create a data structure that could serve as a stack (you can restrict its 
 size to 50 elements). Write two procedures called 
 stackpush
  and 
 stackget
  that will let you place objects on your stack and then 
 retrieve them back again. The 
 stackpush
  procedure should take just 
 one argu-ment—the object to be pushed onto the stack data structure. 
 The 
 stackget
  procedure should return one value onto the operand 
 stack—the value retrieved from the stack data structure. Don’t worry 
 about stack overflow or underflow error conditions.
  
 156
  
 Chapter 12:   STORING AND USING DATA",NA
Chapter 13,NA,NA
Program Data and Instructions,"Programs generally consist of instructions and data in the same sense that 
 an arithmetic problem does: there are operations (such as addition or 
 multiplication) and there are numbers or other data that are fed to those 
 operations. However, in the same sense that you can’t add without 
 having a few numbers, many PostScript programs require data just to 
 make them programs. Example 13.1 presents a very simple program to 
 show the distinction between data and instructions in some typical code.
  
 Example 13.1: Identifying Data and Instructions
  
 /Times-Roman 
  
  
 findfont 
  
 24 
  
  
 scalefont setfont 
 100 300 
  
  
 moveto 
  
 (Data and Instructions) 
  
 show
  
 % data 
  
  
 % instruction 
  
 % data 
  
  
 % instructions 
  
 % data 
  
  
 % instruction 
  
 % data 
  
  
 % instruction
  
 157",NA
TURNING DATA INTO INSTRUCTIONS,"The instructions in your program are the fixed part, and the data are the 
 elements that can be different each time you run the program. But there 
 are circumstances in which data may actually be executed as instructions.
  
 Let’s look at an example. If you were to write an 
 emulator
  in PostScript 
 that made your printer pretend to be a line printer, then you may want to 
 make it recognize some simple line printer commands among the lines of 
 text to be printed. To simplify this somewhat, let’s say that you want to 
 recognize the 
 form feed 
 primitive that is often used in line printers. In 
 particular, the ASCII character for form feed is octal 013. Example 13.4 
 is a very simple line printer emulator, written in PostScript, that will print 
 any lines of text it gets, and will eject the page to start a new one 
 whenever it encounters the form feed character. The form feed character 
 has been changed to (X) instead of (\013) in this example so you can see 
 the form feeds.
  
 Chapter 13:   PROGRAM DATA AND INSTRUCTIONS
  
 159",NA
TURNING INSTRUCTIONS INTO DATA,"A good example of turning program instructions into data is the task of 
 listing
  (or printing out) a PostScript program so you can look at it on 
 paper. You may have already run into this situation if you have worked 
 much with the PostScript language. The previous example program that 
 works as a simple line printer emulator actually does convert PostScript 
 program code into data for typesetting if you should happen to feed it a 
 file that contains PostScript. Example 13.6 shows this same emulator 
 with slightly different data at the end. You might have to look closely to 
 see that last ten lines of the program are not executed, but are printed on 
 the page.
  
 Figure 13.1 shows what the top of the output page would look like when 
 the program in Example 13.6 is executed.
  
 Chapter 13:   PROGRAM DATA AND INSTRUCTIONS
  
 161",NA
DATA CONVERSIONS,"Quite a few PostScript operators convert one data type to another. Once 
 you know that they exist, they are easy enough to use. There are also 
 some fancy ways to accomplish data conversion in the next few sections. 
 But first, some examples of common data conversions using the 
 appropriate PostScript operators (see Example 13.7).
  
 Example 13.7: Converting Strings to Numbers
  
 (12456) cvi 
  
 (2898.87) cvi 
  
 (117.5) cvr 
  
 (120) cvr 
  
 (5837.9) cvx exec 
  
 (612.0) token pop exch pop 
  
 (612.0 792.0 moveto) token pop 
 exch token pop exch pop
  
 % 12456 
  
 % 2899 
  
 % 117.5 
  
 % 120.0 
  
 % 5837.9 
  
 % 612.0
  
 % 612.0 792.0
  
 Example 13.8 shows the conversion of decimal numbers to an octal or 
 hexadecimal representation (the result is a string, since octal numbers do 
 not exist in the interpreter except as notation).
  
 Chapter 13:   PROGRAM DATA AND INSTRUCTIONS
  
 163",NA
CONCLUDING THOUGHTS,"In this chapter, you’ve learned about data and instructions and how they 
 can be converted from one to the other. You’ve also seen how various 
 data types can be converted into other data types. These techniques will 
 come in handy in the next chapter as you begin using files.",NA
EXERCISES,"1.
  
 Take the following code segment and rewrite it so that all the data 
 are on the operand stack and all the instructions are inside a 
 procedure. Since the example has two sets of data, please call your 
 procedure twice, once with each set of data.
  
 100 200 moveto 0.5 setgray 
  
 /Times-Roman findfont 96 scalefont setfont 
  
 (G) show 
  
 143 171 moveto 0.7 setgray 
  
 /Times-Roman findfont 96 scalefont setfont 
  
 (R) show
  
 2.
  
 Write a procedure called 
 cvhex
  that will turn an integer into a hexa-
 decimal string and leave that string on the operand stack.
  
 3.
  
 Write a procedure called 
 tabshow 
 that shows a string of text in the 
 current font, but treats tab characters specially by moving the current 
 point to the right by some fixed amount. (HINT: the ASCII code for 
 a tab is 9.)
  
 Chapter 13:   PROGRAM DATA AND INSTRUCTIONS
  
 165",NA
Chapter 14,NA,NA
Using Files and ,NA,NA
Input/Output ,NA,NA
Techniques,"Opening a file to read or write data is one of the most fundamental 
 operations a program can perform. The PostScript language has good 
 support for file operations, although some conceptual understanding of 
 files is required to understand how to use these operators effectively.",NA
File Objects,"A file is always represented by a file object in a program. This is even 
 true in other languages, such as C, where a file descriptor is used in all 
 file references once you have opened the file. There is a 
 bona fide
  
 PostScript object for file objects, and all of the file-related PostScript 
 operators require the use of it. The 
 file
  operator and the 
 currentfile
  
 operator provide the two standard ways to obtain a file object.
  
 167",NA
Streams and Files,"A 
 stream
  is a special case of a file object that can only be accessed 
 sequentially. You have no real way to know, given an arbitrary file 
 object, whether or not you can read or write arbitrary parts of the file. It 
 is best always to assume that the file is a stream, and only to read 
 sequentially from it (or write sequentially to it). For example, the 
 currentfile
  operator will often return the file stream representing the 
 serial port on the printer, although it might represent a real disk file in an 
 environment where there is a file system available to the interpreter. As 
 long as you use the 
 setfileposition
  operator with some care, the 
 distinction between a stream and a file probably won’t matter.
  
 TIP
  
 Some file operations will work on virtually any PostScript interpreter, 
 such as reading from the current file or writing to the standard output 
 stream. Other file operations, such as explicitly opening a file by name, 
 checking the status of a file, or using a very specific operator like 
 set-
 fileposition
 , depend heavily on the existence of a file system supported 
 by the interpreter. It is very important to make sure that the interpreter 
 supports these operations before attempting them, or you may get an er-
 ror. You can use the 
 known
  or 
 where
  operators to check for the 
 existence of certain operators, or you can consult the manual for your 
 interpreter to find out how to test for the presence of a file system.
  
 As a rule of thumb, any printer equipped with a hard disk or any worksta-
 tion running a PostScript interpreter will have access to the full range of 
 disk operations described in this chapter.",NA
PostScript File Operators,"Many PostScript operators read to, write from, or administer files. They 
 differ quite a bit in the details, but they all work in pretty much the same 
 way. Remember that you almost always need either a file object or a file 
 name with each of these operators. Also, keep in mind that the reading 
 and writing operators are analogous to the 
 get
  and 
 put
  operators. This 
 will help you to conceptualize the file operations somewhat; they both 
 require
  
 168
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
OPENING AND CLOSING FILES,"To open a file in PostScript, you use the 
 file
  operator (which you can 
 think of as an “
 open
 ” operator, for all practical purposes). Opening a file 
 gives you a file object that you can then use for reading from or writing 
 to that file. The only tricky part is to make sure that there really is a file 
 to open.
  
 The file operator requires a file name and a mode or permission string. 
 The file name is obvious. The 
 mode
  is how you specify that you want to 
 open the file for reading, writing, or (in some implementations) 
 appending. If you open a file for writing (not appending), it will instantly 
 create a file of zero length, destroying any other file that might have 
 existed with that name. Because of this you should be especially careful 
 when you open files for writing the first few times.
  
 Let’s look at the syntax of the 
 file
  operator a little more closely.
  
 filename mode 
 file
   file_object
  
 The exact syntax of the 
 filename
  operand depends, to some extent, on the 
 environment in which the interpreter is running (see Table 14.2).
  
 170
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
READING AND WRITING FILES,"Once you have a valid file object, either from the 
 file
  operator or the 
 currentfile
  operator, you can read from it or write to it any number of 
 times (or at least until you run out of data to read or until you fill up the 
 file system).
  
 The 
 read
  operator (and its variants) returns an exit status boolean to let 
 you know whether or not it succeeded. This lends itself nicely to an 
 ifelse 
 statement for error checking, unless you are very sure that the operation 
 will succeed and you want the code to execute as fast as it can (which is, 
 actually, fairly often the case).",NA
Reading from a File,"There are several PostScript operators that you can use to read from a file 
 object. All but one require you to provide a buffer into which the 
 operator can place the bytes read from the file. The exception is the 
 read
  
 operator; it just reads a single byte from a file, and therefore it doesn’t 
 need a buffer. The size of the buffer is up to you. Most of the read 
 operations in PostScript will simply read until they fill up your buffer. In 
 contrast, the 
 readline
  operator reads until it sees a specific end-of-line 
 condition. This can create two possible error conditions.
  
 1. 
  
 2.
  
 You might run out of data to read before you fill your buffer. 
 You might run out of buffer space before you get to an end-of-
 line condition.
  
 If you run out of data before the buffer is full, the operator you were 
 using to read from the file will tell you (by leaving 
 false
  on the stack). 
 There is no general way to make sure that your use of 
 readline
  won’t 
 overflow your buffer. If you’re worried about it, you can certainly use a 
 very large buffer (some implementations limit string sizes to about 64 
 kilobytes).
  
 Example 14.4 illustrates use of the 
 readstring
  operator to read data from a 
 file and write it to a new file.",NA
Writing to a File,"Writing to a file is very similar to reading from a file, with a couple of 
 exceptions. First of all, the writing operators do not return a boolean
  
 172
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
Copying and Renaming Files,"In order to copy a file, you need to open it with mode 
 (r)
 , open the 
 destination file with mode 
 (w)
 , and use the 
 loop
  operator to read from 
 one file and write to the other until you reach the end of the input file. 
 Example 14.4 copies the file 
 (/etc/passwd)
  to a new file named 
 (/etc/passwd.BAK)
 . It assumes that the original file already exists and 
 can be opened for reading.
  
 Remember to write out the last partial buffer. When the 
 readstring 
 operator returns 
 false
 , there may be a few bytes in the substring that were 
 read before the end-of-file indication was encountered. This can be seen 
 in the 
 else
  clause of the conditional in Example 14.4. The contents of the 
 string are written before the files are closed and before the loop is finally 
 exited.
  
 Example 14.4: Copying a File
  
 /infile (/etc/passwd) (r) file def 
  
 /outfile (/etc/passwd.BAK) (w) file def 
 /buff 128 string def 
  
 { % loop 
  
  
 infile buff readstring { %ifelse 
  
  
 outfile exch writestring 
  
 }{ %else 
  
  
  
 outfile exch writestring 
  
  
 infile closefile 
  
  
  
 outfile closefile 
  
  
  
 exit 
  
 % exit the loop 
  
 } ifelse 
  
 } bind loop
  
 % open files and save file objects % 
 your buffer for reading operations
  
 To rename a file, simply use the 
 renamefile
  PostScript operator if it 
 exists. The program in Example 14.5 checks for the existence of 
 renamefile
  and if it is not found, it defines a procedure called 
 renamefile 
 that emulates the behavior of the operator by copying the file to the new 
 name and then deleting the original file.
  
 174
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
WRITING FORMATTED DATA TO FILES,"If you need to write out a data file or create a file with formatted data in 
 it, you’ll need to become very familiar with the whole family of file 
 writing operators, as well as the data conversion operators (discussed in 
 Chapter 13). Let’s look at some useful techniques.",NA
Writing Out Various Data Types,"There are many different PostScript data types. Some of them are easy to 
 write to a file; others present some challenges. To overgeneralize, simple 
 data types (including integer, real, boolean, and mark) are relatively easy 
 to convert into strings and write to a file, whereas composite objects such 
 as dictionaries and arrays require some extra steps.
  
 Let’s look at a few procedures that will help you write out some data 
 types to a file. Example 14.6 and Example 14.7 provide some code that 
 you can draw from. The basic idea is to turn your data into a string, then 
 write that string to the output file with the 
 writestring
  operator. Example
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES
  
 175",NA
"Spaces, Tabs, Returns, and Special Characters","If you intend to do any serious formatting of the output file, you will 
 need to create white space, and you may need to write out some special 
 characters. For the most part, the backslash syntax used for special 
 characters will do this for you (see Table 14.4). To get them into your 
 output file, just put them into a string body and write that string to the file 
 with the 
 writestring
  operator. You may find it convenient to use some 
 procedures to do this for you, such as those found in Example 14.7.
  
 Example 14.7: White Space and Special Characters
  
 /fd (outputfile.ps) (w) file def 
  
 /scratch 1024 string def
  
 % these procedures all depend on “fd” being a valid output file descriptor 
 /Wname 
  
  
 % /name Wname -
  
 { %def 
  
  
 dup type /nametype ne { %ifelse 
  
  
  
 fd (% invalid name\n) writestring pop 
  
  
 }{ %else 
  
  
  
 dup xcheck not { fd (/) writestring } if 
  
  
  
 scratch cvs fd exch writestring 
  
  
 } ifelse 
  
 } bind def 
  
 /Wstring { fd exch writestring } bind def 
  
 /Wline 
  
  
  
 % (string) Wline -
  
 { %def 
  
  
 fd exch writestring return 
  
 } bind def 
  
 /space 
  
  
  
 % - space -
  
 { %def 
  
  
 fd ( ) writestring 
  
 } bind def 
  
 /return 
  
  
  
 % - return -
  
 { %def 
  
  
 fd (\n) writestring 
  
 } bind def 
  
 /tab 
   
  
 % - tab -
  
 { %def 
  
  
 fd (\t) writestring 
  
 } bind def
  
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES
  
 177",NA
FILE STATUS INFORMATION,"One of the most useful bits of information about a file is the number of 
 bytes it contains. On most PostScript interpreters with file systems 
 (including printers with a hard disk), there are two ways to determine 
 this. The first is the 
 status
  operator, to which you pass a file name. The 
 status 
 operator actually provides several kinds of information about the 
 file, including how many 
 pages
  of disk space it occupies (a page is 
 typically 1,024 bytes), when it was last accessed, when it was written, 
 and how many bytes it contains. Here is the syntax of the 
 status
  operator.
  
 filename_string
  status 
  
 or
  
  pages bytes referenced created true 
 false
  
 The 
 status
  operator returns a boolean which is 
 false
  if the file exists, 
 true 
 otherwise. If the file exists, the 
 status
  operator also returns the other 
 fields shown in the syntax of the 
 status
  operator. Example 14.8 shows 
 the 
 status
  operator in use.
  
 Example 14.8: Using 
 status
  to Check a File
  
  
 % this code opens a file for reading if it exists, else error message 
 (/etc/passwd) dup status { %ifelse 
  
  
 4 { pop } repeat 
  
 % get rid of interesting file data 
  
  
 (r) open 
  
 }{ %else 
  
  
 print ( is not a valid file name. Cannot open.\n) print flush 
  
 stop 
  
 } ifelse
  
 178
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
RANDOM VERSUS SEQUENTIAL ACCESS,"Under normal circumstances, you should treat a file as though it were 
 only readable sequentially. That way, your program will not break if it is 
 transported into another environment where files may be implemented 
 differently. If you really need to perform random access on a file object, 
 the 
 setfileposition
  operator will help you. You need to open the file 
 either for read 
 (r)
  or write 
 (w)
  to use the 
 setfileposition
  operator (see 
 Example 14.9).
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES
  
 179",NA
CONCLUDING THOUGHTS,"This chapter presented a broad overview of file operations in PostScript 
 and how to use them effectively. PostScript supports file I/O operations 
 in much the same way that other languages do, assuming that you have 
 an interpreter with full support for a file system. Remember, these and 
 other language extensions must be used somewhat carefully to make your 
 code truly portable across all implementations of the PostScript 
 interpreter.
  
 You should now have a pretty solid understanding of the PostScript 
 language and how it relates to other languages that you already know. 
 Hopefully by now you have even started to enjoy the fact that PostScript 
 works backwards and upside down, and you have learned to appreciate 
 its strengths and unique language characteristics—in short, you have 
 learned how to think in PostScript.
  
 The simplicity and power of PostScript makes it a very good language to 
 write programs quickly and confidently that work the very first time, like 
 many of the examples in this book. By now you will have developed a 
 strong programming style and technique that lets you rough out a 
 program, look up the syntax of an occasional PostScript operator, and 
 proceed quickly with the knowledge that you are doing the right thing—
 and in one of the world’s most interesting programming languages.",NA
EXERCISES,"1.
  
 Write a procedure that finds all the fonts on the local hard disk speci-
 fied as 
 (fonts/FontName)
  and write just the font names to the stan-
 dard output file. (HINT: use the 
 filenameforall
  operator.)
  
 2.
  
 Adapt the program from Exercise 1 to write both the font names and 
 the byte sizes of the font files to the standard output file.
  
 3.
  
 Write a program that will open a file called 
 prog.ps
  and execute the 
 file one token at a time (using the 
 token
  and 
 exec
  operators), writing
  
 180
  
 Chapter 14:   USING FILES AND INPUT/OUTPUT TECHNIQUES",NA
Appendix ,NA,NA
Appendi,NA,NA
x,"APPENDIX
  
 183",NA
Appendix ,NA,NA
Answers to Exercises,NA,NA
CHAPTER 1,"1.
  
 Your answers to the question 
 Why do you want to write a PostScript 
 program?
  will be varied, and there is no answer to this exercise, of 
 course. Here are some potential responses that might stimulate some 
 thought.
  
 •
  
 You want to write a driver to control a laser printer.
  
 •
  
 You are writing a graphics application for a computer system that 
 uses PostScript for display graphics.
  
 •
  
 You want to modify the behavior of an existing PostScript 
 program, or to add functionality to (or fix bugs in) an existing 
 piece of application software you have been using.
  
 •
  
 You want to include graphics in a text document you are 
 preparing.
  
 •
  
 You are interested in PostScript as a programming language, and 
 want to write any program you can.
  
 •
  
 You want to write fractal programs to draw fancy pictures on 
 your display or on your printer.
  
 Appendix:   ANSWERS TO EXERCISES
  
 185",NA
CHAPTER 2,"1.
  
 Notice that no variables or names are required to implement this fac-
 torial algorithm. There are, of course, many other ways to 
 accomplish this task.
  
 1 
  
 % leave on stack 
  
 10 -1 0 { mul } for 
  
 (10 factorial is ) print ==
  
 2.
  
 Here are some possibilities for PostScript’s greatest strengths as a 
 programming language.
  
 •
  
 It is extensible and flexible.
  
 •
  
 It is standard, extremely portable, and machine-independent.
  
 •
  
 It is an interpreted language, making it easy to debug.
  
 •
  
 It has many powerful “convenience” operators.
  
 186
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 3,"1. 
  
 The only syntax errors you can get arise from mismatched delimiters.
  
 a)
  The parentheses are not nested correctly. The interpreter will read 
 past the (part 1) looking for the closing parenthesis. The corrected 
 code should be either of the following.
  
  
 0 1 20 { ( Hello world (part 1)) == flush } for 
  
 0 1 20 { ( Hello world \(part 1) == flush } for
  
  
 b)
  The syntax error in this program is the incorrect nesting of { } 
 brackets in the 
 ifelse
  statement. The first clause does not have a 
 closing bracket. Better indentation shows this problem much more 
 clearly.
  
  
 missing 
 }
  
  
 currentpoint exch 32 gt { %ifelse 
  
  
 72 lt { %if 
  
  
  
 showpage 36 500 moveto 
  
  
 } if 
  
 { %else 
  
  
 (hello world \(part 2) show 
  
 } ifelse
  
 2.
  
 Here is a simple procedure named 
 line
  that takes four operands, the 
 x, y
  location for the beginning of the line and the 
 x, y
  location for the 
 end of the line.
  
 /line 
  
 { %def 
  
  
 4 -2 roll moveto 
  
 lineto stroke 
  
 } bind def 
  
 100 150 300 600 line 
 650 75 50 500 line
  
 % X1 Y1 X2 Y2 line -
  
 188
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 4,"1.
  
 In a page description, the prologue of procedure definitions should be 
 made as readable as possible, but the script that is generated by the 
 application should be made compact and efficient, since the prologue 
 is only executed once per document, but each procedure may be 
 called many times in the script.
  
 2.
  
 Here are the kinds of PostScript programs that you might expect to 
 consume memory.
  
 •
  
 downloaded font programs
  
 •
  
 programs that load procedures into memory
  
 •
  
 documents with string data in the body
  
 •
  
 any program that stores data.
  
 3.
  
 There is no reasonable way to use query programs in an environment 
 with one-way or batch communications.
  
 Appendix:   ANSWERS TO EXERCISES
  
 189",NA
CHAPTER 5,"1.
  
 2.
  
 The 
 stringwidth
  operator returns a value for both 
 x
  and 
 y
 , a fact that 
 is often overlooked. The value 
 0
  is left on the operand stack, since 
 only the 
 y
  value is consumed from the call to 
 stringwidth
 .
  
 Here are the errors found in the various program segments.
  
 a.
  This code segment raises no errors.
  
 b.
  There is a 
 typecheck
  error on command 
 scalefont
 . Remember that 
 the 
 findfont
  operator returns a dictionary on the operand stack that 
 is used by 
 scalefont
 , but the scale factor is in the wrong position 
 on the stack. This could be fixed simply by changing 
 scalefont
  to 
 exch scalefont
  in the exercise.
  
 c.
  There is a 
 typecheck
  error on command 
 show
 . The trick in this 
 ex-ercise is to remember that 
 stringwidth
  returns two values, one 
 for 
 y
  and one for 
 x
 . The 0 
 y
  component is used inadvertently 
 instead of the value for 
 x
 , resulting in 
 0 0 rmoveto
 , then the 
 x
  
 value is on the stack when 
 show
  is called, resulting in 
 typecheck
 .
  
 d.
  There is a 
 typecheck
  error on command 
 restore
 . Remember that 
 the 
 restore
  operator leaves an object on the operand stack, and 
 this object is required by 
 restore
 . In the exercise, the string body 
 is du-plicated with 
 dup
  before 
 show
 , leaving a copy on the stack 
 when 
 restore
  executes. If you came up with 
 invalidrestore
 , you 
 were close. If the code had been 
 exch restore
  instead of just 
 restore
 , an 
 invalidrestore
  error would have occurred, since the 
 string object that was still on the stack was created more recently 
 than the last 
 save
 , making it illegal to 
 restore
  as long as an 
 instance of the string is still on the operand stack. To fix this, you 
 would need 
 pop restore
  instead of 
 restore
 , or simply to remove 
 the 
 dup
 .
  
 190
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 6,"1.
  
 Each time around the 
 for
  loop, the loop index is pushed onto the 
 oper-and stack and is added to the number that is already on the stack 
 (which starts out as 
 0
 ). The program is equivalent to the following 
 arithmetic expression.
  
 0 + 10 + 20 + 30 + 40 + 50 + 60 + 70 + 80 + 90 + 100
  
 The result of this expression (and of the exercise) is 550.
  
 2.
  
 Here is the program segment again. The results left on the operand 
 stack after its execution follow.
  
 clear 
  
 /A /B /C /D /E /a /b /c /d /e 
  
 2 copy 6 index 6 index 12 -4 roll exch 5 3 roll
  
 % results on operand stack.
  
 /A /B /b /c /d /e /d /e /a /D /a /E /b
  
  
 3.
  
 This is a pretty tricky task. Here is a procedure called 
 reversestack 
 that will reverse the contents of the operand stack (the topmost 
 element becomes the bottom element). Notice the clever use of the 
 for
  operator and the loop variable it provides. Notice also that the 
 loop begins at 
 2
  to avoid a 
 1 -1 roll
 .
  
 /reversestack 
  
 % any
 0
  ... any
 n
  reversestack any
 n
  ... any
 0 
 { %def 
  
  
 2 1 count 2 sub { %for 
  
  
  
 % use the loop counter as argument to “roll”
  
  
  
 -1 roll 
  
  
 } for 
  
 } bind def 
  
 /a /b /c /d /e /f /g reversestack
  
 192
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 7,"1.
  
 Here is a sample program that implements a 
 case
  operator. It is cer-
 tainly not the best nor the only way to implement it. Compare this 
 version to the one you came up with.
  
 /case 
  
 % mark proc bool
 0
  proc
 0
  ... bool
 n
  proc
 n
  case -{ 
 %def 
  
  
 % requires a pair of operands on 
  
  
 % the stack for each option: the 
  
  
 % matching case item and a procedure. 
  
  
 % You must have a mark at the bottom 
  
  
 % of your case pairs, and you must 
  
  
 % supply the thing to be tested on 
  
  
 % the top of the operand stack: 
  
  
 % mark { default } 
  
  
 % case3 { proc3 } 
  
  
 % case2 { proc2 } 
  
  
 % case1 { proc1 } 
  
  
 % item_to_test case
  
 Appendix:   ANSWERS TO EXERCISES
  
 193",NA
CHAPTER 8,"1.
  
 2.
  
 The loop index is used directly as provided by the 
 for
  operator on the 
 operand stack. Notice that neither the loop index nor the factorial 
 variable are stored into a dictionary. They are used directly from the 
 operand stack.
  
 1 
  
 % leave 1 on stack 
  
 10 -1 1 { mul } for 
  
 (10 factorial is ) print ==
  
 The only trick to this is to rearrange the data in the opposite order on 
 the operand stack and to provide the correct number for the loop 
 constraint.
  
 0 0 moveto 
  
 600 600 
  
 500 600 
  
 400 400 
  
 300 400 
  
 200 200 
  
 100 200 
  
 6 { lineto } repeat closepath fill
  
 3.
  
 Notice the way the loop in the following segment of code takes 
 advantage of the way the 
 search
  operator works, and uses the 
 arguments in a very natural way.
  
 Appendix:   ANSWERS TO EXERCISES
  
 195",NA
CHAPTER 9,"1.
  
 The secret is to rearrange the order in which the data are provided on 
 the operand stack to suit the order in which the operators in the 
 proce-dure require data.
  
 /TEXT 
  
 % (string) ptsize /fontname X Y TEXT -{ 
 %def 
  
  
 moveto 
  
  
 findfont exch scalefont setfont 
  
  
 show 
  
 } bind def 
  
 (This is an example of Times-Bold) 
  
 24 /Times-Bold 100 100 TEXT
  
 2.
  
 This requires copying one of the procedures.
  
 /concatprocs 
  
 % proc
 1
  proc
 2
  concatprocs proc
 3 
 { 
 %def 
  
  
 dup length 2 add array 
  
  
 exch 1 index 2 exch putinterval 
  
  
 dup 1 /exec cvx put 
  
  
 dup 3 1 roll 0 exch put 
  
  
 cvx 
  
 } bind def
  
 Appendix:   ANSWERS TO EXERCISES
  
 197",NA
CHAPTER 10,"1.
  
 The value left on the operand stack after executing the following 
 short program segments is 
 16
 . The following walk-through of the 
 program segment shows how that answer was derived.
  
 /variable 7 def 
  
 5 dict dup begin 
  
  
 /variable 9 def 
  
 end 
  
 /variable dup load 
  
 3 1 roll get 
  
 add
  
 % define /variable in current dict 
  
 % new dict on op-stack and dict-stack 
  
 % /variable is 9 in new dict (both places) 
  
 % remove one copy of new dict from dict-stack 
 % loads from original (current) dict => 7 
  
 % “get” from new dict copy still on op-stack (9) 
 % 7 + 9 = 16
  
 Appendix:   ANSWERS TO EXERCISES
  
 199",NA
CHAPTER 11 ,"1. 
 The contents of the array constructed by the code
  
 [ 0 0 moveto 100 100 lineto currentpoint ]
  
 are simply [ 100 100 ]. The code in between [ and ] is actually 
 executed, and only the final 
 currentpoint
  operator leaves anything 
 on the operand stack.
  
 200
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 12,"1.
  
 To create a procedure that draws a vertical line, you will need to get 
 some data from somewhere, but you can generate some of the data 
 in-ternally within the procedure. In particular, you only need the 
 x
  
 loca-tion of one of the endpoints, and need not duplicate that data. 
 Here is a procedure called 
 V
  that does this.
  
 /V 
  
 { %def 
  
  
 gsave 
  
  
  
 moveto 
  
  
  
 0 exch rlineto 
  
  
 setlinewidth 
  
  
 stroke 
  
  
 grestore 
  
 } bind def
  
 % linewidth Height Xloc Yloc V
  
 % Xloc and Yloc from stack 
  
 % use Height from stack 
  
 % use linewidth from stack
  
 3.5 150 200 200 V 
  
 1.0 125 300 200 V
  
 2.
  
 The calculation of where to put the underline and how thick to make 
 it depends on several things. First of all, the position of the underline 
 depends on the text being underlined—both its position on the page 
 and its point size (the underline should be further away from the text 
 baseline for larger text). This font information is available in the 
 PostScript interpreter as well as in Font Metric files or other tables in 
 the host environment.
  
 a.
  The main disadvantage of performing this calculation in your 
 Post-Script program is performance; it will take some time to 
 execute in PostScript. Also, it will increase the complexity of your 
 PostScript code a fair amount. The other disadvantage is that you 
 don’t know anything else about the page on which you’re 
 underlining text. For example, if you underline three words in a 
 row, each of which is in a different font, you would prefer not to 
 have the underline change thickness beneath the second or third 
 word, and there is no reason-able way to know about this at the 
 PostScript level.
  
 202
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 13,"1.
  
 Here are the two sets of data separated from the instructions.
  
 /myproc 
  
 % (string) /FontName ptsize gray Xloc Yloc myproc 
 { %def 
  
  
 moveto setgray 
  
  
 exch findfont exch scalefont setfont 
  
  
 show 
  
 } bind def
  
 (G) /Times-Roman 96 0.5 100 200 myproc 
  
 (R) /Times-Roman 96 0.7 143 171 myproc
  
 2.
  
 Here is a procedure called 
 cvhex
  that takes an integer and turns it into 
 a hexadecimal string. It just uses the 
 cvrs
  operator.
  
 /scratch 128 string def 
 /cvhex 
  
 { 
  
  
 16 scratch cvrs 
  
 } bind def
  
 % int cvhex <hex_string>
  
 1245 cvhex
  
 3.
  
 Here is a procedure called 
 tabshow
  that shows a string of characters, 
 moving 24 points to the right for each tab character encountered.
  
 /tabshow 
  
  
 % (string) tabshow 
  
 { %def 
  
  
 { %loop 
  
  
  
 (\t) search { %ifelse 
  
  
  
  
 show 
   
 % show pre string 
  
  
  
 pop 
  
  
  
 % get rid of tab 
  
  
  
 24 0 
 rmoveto 
  
 % move current point 
  
  
 } { %else 
  
  
  
  
 show exit 
  
  
  
 } ifelse 
  
  
 } loop 
  
 } bind def
  
 /Times-Roman findfont 24 scalefont setfont 
  
 100 100 moveto (abc\tdef\tghi) tabshow
  
 204
  
 Appendix:   ANSWERS TO EXERCISES",NA
CHAPTER 14,"1.
  
 Here is a program that will write all the font names from the hard 
 disk to the standard output file.
  
 (fonts/*) { %filenameforall 
  
  
 dup length 6 sub 6 exch getinterval 
  
  
 print (\n) print flush 
  
 } 128 string filenameforall
  
 2.
  
 Here is an adaptation of Exercise 1 that includes the byte sizes of the 
 font files, too.
  
 (fonts/*) { %filenameforall 
  
  
 dup dup length 6 sub 6 exch getinterval 
  
  
 print ( ) print 
  
  
 status { %if 
  
  
  
 % status returns: pages bytes referenced created 
  
  
  
 pop pop exch pop (XXXXXXX) cvs print 
  
  
 } if 
  
  
 (\n) print flush 
  
 } 128 string filenameforall
  
 3.
  
 Here is a program that will open a file called 
 prog.ps
  and execute the 
 file one token at a time, writing each token to an output file.
  
 % open prog.ps and execute one token at a time, writing each token 
 % to trace.ps as you go
  
 /infile (prog.ps) (r) file def 
 /outfile (trace.ps) (w) file def 
 /buff 65535 string def
  
 % very large buffer
  
  
 Appendix:   ANSWERS TO EXERCISES
  
 205",NA
Indexes,209,NA
Index of ,NA,NA
Example Programs,NA,NA
Chapter 1:  PostScript as a ,NA,NA
Programming Language ............................................ 1,Example 1.1: Repetitive Algorithms ........................................................ 5,NA
Chapter 2:  PostScript is Not Like C ......................... 9,NA,NA
Chapter 3:  Foundations .......................................... 17,"Example 3.1: The Programming Cycle .................................................. 18 
 Example 3.2: Defining and Using Named Objects................................. 21 
 Example 3.3: Keeping Variables with Procedure Definitions................ 22 
 Example 3.4: Alternative Indentation Style for Procedures................... 23 
 Example 3.5: Indentation Style for Dictionaries and Structure.............. 24 
 Example 3.6: Setting Up Templates....................................................... 25 
 Example 3.7: Declaring Variables.......................................................... 27 
 Example 3.8: Using Variables................................................................ 27 
 Example 3.9: Arithmetic in C................................................................. 27 
 Example 3.10: Arithmetic in PostScript................................................. 28 
 Example 3.11: Evaluation of Constants with // ...................................... 
 28 Example 3.12: After Immediate Name Lookup with //.......................... 
 29
  
 211",NA
Chapter 4:  Some Typical Programs.......................  37,"Example 4.1: Sample Page Description Program................................... 39 
 Example 4.2: Sample Font Program....................................................... 41 
 Example 4.3: Sample Program that Reads Data..................................... 42 
 Example 4.4: Sample Query Program .................................................... 
 43 Example 4.5: Sample Encapsulated PostScript Program........................ 
 44 Example 4.6: Sample Printer-Resident Program.................................... 
 46 Example 4.7: Sample Display-Server-Resident Program....................... 
 47",NA
Chapter 5:  Understanding the Stack .....................  51,"Example 5.1: Simple Use of the Operand Stack..................................... 54 
 Example 5.2: Each Operator Uses the Operand Stack............................ 56 
 Example 5.3: The 
 findfont
  Operator Returns a Dictionary .................... 
 57 
 Example 
 5.4: 
 Operator 
 Prefix 
 Notation 
 in 
 C 
 .......................................... 58 Example 5.5: Operator Infix Notation in C 
 ............................................ 58 Example 5.6: Postfix Notation in 
 PostScript .......................................... 59 Example 5.7: Programming One 
 Token at a Time ................................. 59 Example 5.8: Procedure 
 Arguments on the Stack .................................. 59",NA
Chapter 6:  Trusting the Stack ................................  67,"Example 6.1: Using 
 exch def
  in a Procedure.......................................... 70 
 Example 6.2: Using 
 index
  in a Loop Body ............................................ 72 
 Example 6.3: Accidentally Leaving Dictionary on Stack....................... 75 
 Example 6.4: Correctly Maintaining Dictionary Stack .......................... 75 
 Example 6.5: Recursion Using the Dictionary Stack ............................. 76 
 Example 6.6: Recursion Using the Operand Stack................................. 77",NA
Chapter 7:  Building Conditional Statements........  79,"Example 7.1: Constructing a Conditional............................................... 80 
 Example 7.2: Filling in the Conditional Template ................................. 80
  
 212
  
 Index of Example Programs",NA
Chapter 8:  Using Looping Constructs................... 93,"Example 8.1: Simple Loop to Draw an Octagon.................................... 95 
 Example 8.2: Ignoring Loop Index......................................................... 96 
 Example 8.3: Using Loop Index for Line Weight.................................. 97 
 Example 8.4: Finding Font Names with Looping Operators.................. 98 
 Example 8.5: Using 
 bind
  on Loop Bodies.............................................. 99 
 Example 8.6: Putting Objects into Loop Bodies .................................... 99 
 Example 8.7: Optimizing the Image Procedure.................................... 100 
 Example 8.8: A Program with Repeated Instructions .......................... 101 
 Example 8.9: Using 
 repeat
  for Instructions.......................................... 101 
 Example 8.10: Exiting a Loop.............................................................. 103",NA
Chapter 9:  Procedures .......................................... 105,"Example 9.1: Typical Procedure Definition......................................... 107 
 Example 9.2: Alternative Ways to Define a Procedure........................ 107 
 Example 9.3: Procedure 
 S
  of 
 Example 9.1
 .......................................... 109 
 Example 9.4: Procedure 
 S
  and Data Rearranged.................................. 109 
 Example 9.5: Code without the Procedure ........................................... 
 109 
 Example 
 9.6: 
 Data 
 in 
 a 
 More 
 Familiar 
 Arrangement 
 ........................... 109 Example 9.7: Data Arrangement for Use by a 
 Procedure .................... 110 Example 9.8: Disorganized and Inefficient 
 Use 
 of 
 Procedures............ 
 111 
 Example 
 9.9: 
 Efficient 
 Procedure......................................................... 112
  
 Index of Example Programs
  
 213",NA
Chapter 10:  Using Dictionaries............................  119,"Example 10.1: Sample Dictionary Entry.............................................. 120 
 Example 10.2: Using Dictionary to Control Name Scoping ................ 121 
 Example 10.3: Dictionary as Local Storage for a Procedure................ 122 
 Example 10.4: All Procedures within One Global Dictionary ............. 
 123 Example 10.5 Exchanging Topmost Dictionaries with 
 dictexch
  ......... 
 125 Example 10.6: Using 
 put
  and 
 get
  for Dictionary Entries ..................... 
 126 Example 10.7: Scoping with 
 put
  and 
 get
 .............................................. 
 126 Example 10.8: Browsing a Dictionary with 
 forall
  ............................... 
 127 Example 10.9: Using 
 type
  on each Element in a Dictionary 
 ................ 
 128 
 Example 
 10.10: 
 Conditionally 
 Defining 
 a 
 Procedure........................... 129 Example 10.11: Redefining 
 showpage
  to 
 Print Draft Notice............... 131 Example 10.12: Redefining 
 show
  to 
 Help Debugging ......................... 131 Example 10.13: Using 
 load
  to Get 
 Previous Definitions...................... 132",NA
Chapter 11:  Creating and Manipulating Data......  135,"Example 11.1: Sample Constructed Array ........................................... 135 
 Example 11.2: Making a Procedure into a Literal Array...................... 136 
 Example 11.3: Creating and Filling an Empty Array........................... 137 
 Example 11.4: Creating Strings with the Scanner................................ 137 
 Example 11.5: Anatomy of the 
 put
  Operator ....................................... 138 
 Example 11.6: Anatomy of the 
 putinterval
  Operator........................... 139 
 Example 11.7: Concatenating Two Strings Together........................... 140 
 Example 11.8: Creating a Literal String............................................... 140 
 Example 11.9: Reading String Data from a File................................... 141 
 Example 11.10: Reading and Executing Data from a File ................... 142",NA
Chapter 12:  Storing and Using Data....................  145,"214
  
 Index of Example Programs",NA
Chapter 13:  Program Data and Instructions ....... 157,"Example 13.1: Identifying Data and Instructions................................. 157 
 Example 13.2: Separating Data and Instructions.................................. 158 
 Example 13.3: Data as Part of the Algorithm....................................... 158 
 Example 13.4: Treating Carriage Return as an Instruction .................. 
 160 Example 13.5: Executing Data Found in a File.................................... 
 161 Example 13.6: Instructions as Data (to be Line Printed)...................... 
 162 Example 13.7: Converting Strings to Numbers.................................... 
 163 Example 13.8: Converting Decimal Numbers to Octal or Hex............ 
 164 Example 13.9: Converting between Names and Strings ...................... 
 164 
 Example 
 13.10: 
 Converting 
 Arrays 
 to 
 Procedures 
 ............................... 164 Example 13.11: Converting Arbitrary Data to 
 Strings......................... 165",NA
Chapter 14:  Using Files and ,NA,NA
Input/Output Techniques ....................................... 167,"Example 14.1: Sample Use of the 
 file
  Operator................................... 171 
 Example 14.2: Closing a File................................................................ 171 
 Example 14.3: Writing an Array Out to a File ..................................... 
 173 
 Example 
 14.4: 
 Copying 
 a 
 File 
 .............................................................. 174 Example 14.5: Renaming a 
 File............................................................ 175 Example 14.6: Writing 
 Numbers and Names to a File......................... 176 Example 14.7: White 
 Space and Special Characters............................ 177 Example 14.8: Using 
 status
  to Check a File......................................... 178 Example 14.9: 
 Random File Access with 
 setfileposition
 ..................... 179
  
 Index of Example Programs
  
 215",NA
Chapter 1:  PostScript as a ,NA,NA
Programming Language 1,NA,NA
Chapter 2:  POSTSCRIPT IS NOT LIKE C 9,NA,NA
Chapter 3:  FOUNDATIONS 17,NA,NA
Chapter 4:  Some Typical Programs 37,"Figure 4.1: Output from Example 4.2 43 
  
 Figure 4.2: Output from Example 4.5 47 
  
 Figure 4.3: Shared Memory Configuration 
 51",NA
Chapter 5:  Understanding the Stack 53,"Figure 5.1: Tracing the Execution of Example 5.1 57 
  
 Figure 5.2: Visual Chunking for Example 5.3 60 
  
 Figure 5.3: Output of Example 5.8 63 
  
 Figure 5.4: Last Object In is the First Out 63 
  
 Figure 5.5: Duplicating a Composite Object 65 
  
 Figure 5.6: Changing a Composite Object 65",NA
Chapter 6:  Trusting the Stack 69,"Figure 6.1: Positive Rolling 76 
  
 Figure 6.2: Negative Rolling 76",NA
Chapter 7:  Building Conditional Statements 83,NA,NA
Chapter 8:  Using Looping Constructs 97,"Figure 8.1:Output of Example 8.2 100 
  
 Figure 8.2: Output of Example 8.3 101 
  
 Figure 8.3: Output of Example 8.9 106
  
 Thinking in PostScript:   Index of Figures
  
 253",NA
Chapter 9:  Procedures 109 ,Figure 9.1: Object Pointer in a Procedure Body 120,NA
Chapter 10:  Using Dictionaries 123 ,"Figure 10.1: Mechanics of the 
 dictexch
  Procedure 129",NA
Chapter 11:  Creating and Manipulating Data 139 ,Figure 11.1: Output of Example 11.11 148,NA
Chapter 12:  Storing and Using Data 151 ,Figure 12.1: Structure of the PostScript Linked List 160,NA
Chapter 13:  Program Data and Instructions 163 ,Figure 13.1: Output of Example 13.6 169,NA
Chapter 14:  Using Files and ,NA,NA
Input/Output Techniques 173,"254
  
 Thinking in PostScript:   Index of Figures",NA
Subject Index,NA,NA
A ,"algorithms
  6, 12, 158 
  
 allocating memory
  29 
  
 argument passing
  76 
  
 arithmetic
  27 
  
 array object
  51 
  
 arrays
  135 
  
  
 concatenating
  139 
  
  
 construction
  135 
  
  
 converting to procedures
  164 
  
 for linked lists
  152 
  
  
 versus dictionaries
  141 
  
 ASCII
  2",NA
B ,"backslash
  20 
  
 backspace
  173 
  
 basic skills
  17 
  
 begin
  22 
  
 begin operator
  126 
  
 booleans
  82 
  
 braces
  20, 22 
  
 bytesavailable operator
  169, 179",NA
C ,"C programming language
  9
  
 C structures
  152 
  
 carriage return
  160, 173, 177 
  
 case statement
  79 
  
 closefile operator
  31, 169 
  
 closing a file
  170 
  
 comments
  20 
  
 comparison of objects
  32 
  
 composite objects
  30, 51, 61 
  
 concatenating arrays
  139 
  
 concatenating strings
  139 
  
 conditionals
  73, 79 
  
  
 compound
  88 
  
  
 constructing
  80 
  
  
 nesting
  87 
  
  
 templates for
  80 
  
  
 true and false
  81 
  
 currentfile operator
  167, 168, 169, 172 
 cvs operator
  164",NA
D,"data 
  
  
 converting types
  163 
  
  
 storing and using
  145 
  
  
 versus instructions
  157 
  
 data on operand stack
  69 
  
 data storage in dictionaries
  119
  
 217",NA
E ,"emulator, line printer
  159, 161 
 Encapsulated PostScript
  43 
  
 end
  operator
  126 
  
 EPSF
  43 
  
 equality
  32
  
 error, syntax 19 
  
 /etc/passwd
  174 
  
 example programs
  37 
 exch def
  61, 70 
  
 exch
  operator
  71 
  
 executable names
  60 
 execution model
  54 
  
 execution stack
  62, 63 
 exitserver
  operator
  46",NA
F ,"file objects
  167 
  
 file
  operator
  167, 169 
  
 filenameforall
  operator
  169
  
 files 
  
  
 copying and renaming
  174 
  
  
 file naming
  171 
  
  
 open modes
  171 
  
  
 opening and closing
  31, 167, 170 
  
 random access
  179 
  
  
 reading and writing
  168 
  
  
 reading instructions from
  160 
  
  
 sequential access
  179 
  
 findfont
  operator
  57 
  
 flow charts
  12 
  
 font names
  98 
  
 font programs
  40 
  
 for
  loops
  93 
  
 forall
  operator
  127 
  
 form feed
  159 
  
 functions
  76, 105",NA
G ,"get
  operator
  126 
  
 goto
  3 
  
 graphics state stack
  62, 63 
 grouping
  56",NA
H ,"hard disk (
 see
  files)
  167 
  
 hard disk status
  178",NA
I,"ifelse
  operator (
 see also 
 conditionals) 79 
 image
  operator
  100 
  
 immediate name lookup
  29 
  
 indentation
  20, 22 
  
 index
  operator
  71 
  
 input/output
  14 
  
 instructions versus data
  157 
  
 intuition
  56 
  
 ioerror
  180",NA
K ,"known
  operator
  129
  
 218
  
 Subject Index",NA
L,"language 
  
  
 // notation
  28 
  
  
 arrays versus dictionaries
  141 
  
 dictionaries
  119 
  
  
 extensibility
  13 
  
  
 indentation
  22 
  
  
 name lookup
  53 
  
  
 name scoping
  120 
  
  
 names
  26 
  
  
 syntax
  19 
  
  
 thinking backward
  58 
  
 last-in, first-out
  60 
  
 line printer
  161 
  
 linked lists
  151 
  
 local dictionaries
  121 
  
 local variables
  76 
  
 loop
  operator
  174 
  
 loops
  73, 93 
  
  
 as procedure bodies
  99 
  
  
 exiting
  102 
  
  
 finding font names
  98 
  
  
 image
  operator
  100 
  
  
 loop index
  95 
  
  
 table of arguments
  98 
  
  
 table of operators
  94 
  
  
 template for
  94 
  
  
 using 
 bind
  99",NA
M ,"memory
  29",NA
N ,"name lookup
  29, 53, 60 
  
 name scoping
  120 
  
 names
  26, 60 
  
  
 converting to strings
  164 
  
 writing to a file
  176 
  
 naming conventions
  111, 113 
 naming procedures
  111 
  
 newline
  173
  
 numbers 
  
 converting from strings
  163 
 converting to octal or hex
  163 
 writing to a file
  176",NA
O ,"object types
  32
  
 objects 
  
  
 composite
  51, 61 
  
  
 converting to strings for printing
  164, 
  
  
 175 
  
  
 simple
  51 
  
 octal characters
  173 
  
 opening a file
  170 
  
 operand stack
  53, 56, 67, 146 
  
 operands
  60 
  
 operators, redefining
  130",NA
P ,"page description
  37 
  
 parameter passing
  108 
  
 parentheses
  20 
  
 persistently resident programs
  46 
 postfix
  58 
  
 prefix
  58 
  
 preview
  45 
  
 procedures
  105 
  
  
 arguments
  59 
  
  
 concatenating
  114 
  
  
 constructing good
  111 
  
  
 converting to arrays
  164 
  
  
 defining
  21, 107 
  
  
 efficiency
  111 
  
  
 interleaving data
  109 
  
  
 naming
  111 
  
  
 organization
  111 
  
  
 overview
  106 
  
  
 parameter passing
  108 
  
  
 perspective on
  11 
  
  
 self-modifying
  114 
  
 program development cycle
  17 
 program structure
  20
  
  
 Subject Index
  
 219",NA
Q ,"query programs
  43 
  
 queues
  155",NA
R ,"read
  operator
  169 
  
 readhexstring
  operator
  82, 169 
 reading data
  42 
  
 reading data from a file
  142 
  
 readline
  operator
  169, 172 
  
 readstring
  operator
  172, 174 
 recursion
  76 
  
 redefining operators
  130 
  
 renamefile
  operator
  169, 174 
 repetitive algorithms
  5 
  
 roll
  operator
  71, 72 
  
 run
  operator
  161, 169",NA
S ,"save object
  51 
  
 search path
  13 
  
 self-modifying procedures
  114 
  
 setfileposition
  operator
  168, 169, 179 
 shared memory
  47 
  
 showpage
  operator
  131 
  
 simple object
  51 
  
 software cycle
  19
  
 stack 
  
  
 dictionary
  62 
  
  
 looping
  73 
  
  
 overview
  53 
  
  
 rearranging
  71 
  
  
 rolling
  72 
  
  
 trusting the
  67 
  
 StandardEncoding
  173 
 status
  operator
  169, 178 
 stream (
 see
  file)
  168
  
 string object
  51 
  
 strings
  135 
  
  
 concatenating
  139 
  
  
 construction
  137 
  
  
 converting to names
  164 
  
 converting to numbers
  163 
  
 I/O
  140 
  
  
 put
  and 
 get
  137 
  
  
 scanner syntax
  137 
  
 structured programming
  3
  
 style 
  
  
 ifelse
  statements
  24 
  
  
 indentation
  22 
  
  
 local dictionaries
  121 
  
  
 naming conventions
  113 
  
 templates
  24 
  
 syntax
  19 
  
  
 // name lookup
  28",NA
T ,"tab character
  173, 177 
  
 templates
  24 
  
 token
  operator
  169 
  
 transfer function
  114 
  
 trees
  155 
  
 trusting the stack
  67 
  
 type
  operator
  127 
  
 typecheck
  operator
  75 
  
 types
  32 
  
 typical programs
  37",NA
U ,"underlining
  147 
  
 UNIX
  13 
  
 UNIX files
  171, 179 
  
 /usr/dict/words
  179",NA
V ,"variables
  22, 26, 146 
  
 visual chunking
  56
  
 220
  
 Subject Index",NA
W ,"where
  operator
  75, 129 
  
 while
  loops
  93 
  
 while
  operator
  79 
  
 window systems
  4 
  
 write
  operator
  169 
  
 writestring
  operator
  169, 173
  
 Subject Index
  
 221",NA
