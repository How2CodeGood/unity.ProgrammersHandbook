Larger Text,Smaller Text,Symbol
PostScript ,NA,NA
LANGUAGE ,NA,NA
REFERENCE,NA,NA
®,NA,NA
third edition,NA,NA
Adobe Systems Incorporated,"Addison-Wesley Publishing Company 
  
 Reading, Massachusetts • Menlo Park, California • New York • Don Mills, 
 Ontario Harlow, England • Amsterdam • Bonn • Sydney • Singapore • Tokyo 
  
 Madrid • San Juan • Paris • Seoul • Milan • Mexico City • Taipei",NA
Contents,"1.1
  
 Preface
  
 xiii
  
 182
  
 Chapter  1: Introduction
  
 1
  
 About This 
 Book
  
 3
  
 1.2
  
 Evolution of the PostScript Language
  
 5
  
 1.3
  
 LanguageLevel 3 Overview
  
 6
  
 1.4
  
 Related Publications
  
 7
  
 1.5
  
 Copyrights and Trademarks
  
 9
  
 2.1
  
 Chapter  2: Basic Ideas
  
 11
  
 Raster Output Devices
  
 11
  
 2.2
  
 Scan 
 Conversion
  
 12
  
 2.3
  
 Page Description Languages
  
 13
  
 2.4
  
 Using the PostScript Language
  
 15
  
 3.1
  
 Chapter  3: Language
  
 23
  
 Interprete
 r
  
 24
  
 3.2
  
 Syntax
  
 25
  
 3.3
  
 Data Types and Objects
  
 34
  
 3.4
  
 Stacks
  
 45
  
 3.5
  
 Execution
  
 46
  
 3.6
  
 Overview of Basic 
 Operators
  
 51
  
 3.7
  
 Memory Management
  
 56
  
 3.8
  
 File Input and Output
  
 73
  
 3.9
  
 Named Resources
  
 87
  
 3.10
  
 Functions
  
 106
  
 3.11
  
 Errors
  
 114
  
 3.12
  
 Early Name 
 Binding
  
 117
  
 3.13
  
 Filtered Files 
 Details
  
 123
  
 3.14
  
 Binary Encoding 
 Details
  
 156
  
 4.1
  
 Chapter  4: Graphics
  
 175
  
 Imaging Model
  
 176
  
 4.2
  
 Graphics State
  
 178
  
 4.3
  
 Coordinate Systems and Transformations",NA
Figures,"2.1
  
 How the PostScript interpreter and an application interact
  
 16
  
 272
  
 3.1
  
 Mapping with the 
  
 Decode array
  
 112
  
 3.2
  
 Homogeneous number 
 array
  
 161
  
 3.3
  
 Binary object 
 sequence
  
 164
  
 4.1
  
 The two squares produced by Example 
 4.1
  
 186
  
 4.2
  
 Effects of coordinate 
 transformations
  
 188
  
 4.3
  
 Nonzero winding number rule
  
 195
  
 4.4
  
 Even-odd rule
  
 196
  
 4.5
  
 Color 
 specification
  
 212
  
 4.6
  
 Color rendering
  
 213
  
 4.7
  
 Component transformations in the 
  
 CIEBasedAB
 C
  
  color space
  
 222
  
 4.8
  
 Component transformations in the 
  
 CIEBasedA color space
  
 229
  
 4.9
  
 CIEBasedDEF
 G
  
  pre-extension to the 
  
 CIEBasedAB
 C
  
  color space
  
 232
  
 4.10
  
 Output from Example 4.21
  
 256
  
 4.11
  
 Output from Example 4.23
  
 259
  
 4.12
  
 Starting a new triangle in a free-form Gouraud-shaded triangle 
 mesh
  
 4.13
  
 Connecting triangles in a free-form Gouraud-shaded triangle mesh
  
 272
  
 4.14
  
 Varying the value of the edge flag to create different 
 shapes
  
 273
  
 277
  
 4.15
  
 Lattice-form triangular meshes
  
 275
  
 4.16
  
 Coordinate mapping from a unit square to a four-sided Coons patch
  
 4.17
  
 Painted area and boundary of a Coons patch
  
 279
  
 4.18
  
 Color values and edge flags in Coons patch meshes
  
 281
  
 4.19
  
 Edge connections in a Coons patch mesh
  
 282
  
 4.20
  
 Control points in a tensor-product mesh
  
 284
  
 4.21
  
 Typical sampled 
 image
  
 288
  
 4.22
  
 Image data organization and processing
  
 293
  
 4.23
  
 Source image coordinate 
 system
  
 294
  
 4.24
  
 Mapping the source image
  
 295",NA
Tables,"2.1
  
 Control characters for the interactive 
 executive
  
 21
  
 141
  
 3.1
  
 White-space characters
  
 27
  
 3.2
  
 Types of 
 objects
  
 34
  
 3.3
  
 Standard local dictionaries
  
 65
  
 3.4
  
 Standard global 
 dictionaries
  
 66
  
 3.5
  
 Access strings
  
 79
  
 3.6
  
 Standard filters
  
 85
  
 3.7
  
 Regular resources
  
 91
  
 3.8
  
 Resources whose instances are implicit
  
 91
  
 3.9
  
 Resources used in defining new resource categories
  
 92
  
 3.10
  
 Standard procedure sets in LanguageLevel 
 3
  
 96
  
 3.11
  
 Entries in a category implementation 
 dictionary
  
 101
  
 3.12
  
 Entries common to all function dictionaries
  
 108
  
 3.13
  
 Additional entries specific to a type 0 function dictionary
  
 109
  
 3.14
  
 Additional entries specific to a type 2 function dictionary
  
 113
  
 3.15
  
 Additional entries specific to a type 3 function dictionary
  
 114
  
 3.16
  
 Entries in 
 the 
  
 $error dictionary
  
 116
  
 3.17
  
 Entries in an LZWEncode or LZWDecode parameter 
 dictionary
  
 13
 3
  
 3.18
  
 Typical LZW encoding 
 sequence
  
 135
  
 3.19
  
 Entries in 
 a 
  
 FlateEncode or FlateDecode parameter 
 dictionary
  
 138
  
 3.20
  
 Predictor-related entries in an LZW or Flate filter parameter 
 dictionary
  
 3.21
  
 Entries in 
 a 
  
 CCITTFaxEncode or CCITTFaxDecode parameter 
  
 152
  
 dictionary
  
 144
  
 3.22
  
 Entries in a DCTEncode parameter dictionary
  
 148
  
 3.23
  
 Entries in a SubFileDecode parameter 
 dictionary 
  
 (LanguageLevel 3)
  
 3.24
  
 Entries in 
 a 
  
 ReusableStreamDecode parameter dictionary
  
 155
  
 162
  
 3.25
  
 Binary token interpretation
  
 158
  
 3.26
  
 Number representation in header for a homogeneous number 
 array
  
 3.27
  
 Object type, length, and value 
 fields
  
 166
  
 4.1
  
 Device-independent parameters of the graphics 
 state
  
 179
  
 4.2
  
 Device-dependent parameters of the graphics state
  
 180
  
 4.3
  
 Operation codes for encoded user paths
  
 201
  
 4.4
  
 Entries in a type 1 form dictionary
  
 208
  
 4.5
  
 Entries in a CIEBasedABC color space 
 dictionary
  
 223",NA
Preface,"IN THE 
 1980
 S, ADOBE DEVISED a powerful graphics imaging model that 
 over time has formed the basis for the Adobe PostScript technologies. 
 These technolo-gies—a combination of the PostScript language and 
 PostScript language–based graphics and text-formatting applications, 
 drivers, and imaging systems—have forever changed the printing and 
 publishing world by sparking the desktop and digital publishing 
 revolutions. Since their inception, PostScript technologies have enabled 
 unprecedented control of the look and feel of printed documents and have 
 changed the overall process for designing and printing them as well. The 
 capabilities PostScript makes possible have established it as the industry 
 page de-scription language standard. 
  
 Today, as never before, application developers and imaging systems 
 vendors support the PostScript language as the industry standard. We at 
 Adobe accept our responsibility as stewards of this standard to continually 
 advance the standard in response to the creative needs of the industry. 
  
 With this third advance of the language, which we call LanguageLevel 3, 
 Adobe has greatly expanded the boundaries of imaging capabilities made 
 possible through the PostScript language. This most recent advance has 
 yielded significant improvements in the efficiency and performance of the 
 language as well as in the quality of final output. 
  
 To complement the strengths of LanguageLevel 3, Adobe PostScript 3 
 imaging system technologies have been engineered to exploit the new 
 LanguageLevel 3 constructs to the fullest extent, fulfilling the Adobe 
 commitment to provide printing solutions for the broad spectrum of users. 
  
 No significant change comes without the concerted effort of many 
 individuals. The work to advance the PostScript language and to create 
 Adobe PostScript 3 imaging system technologies is no exception. Our goal 
 since the introduction of the first Adobe imaging model has been nothing 
 less than to provide the most in-novative, meaningful imaging solutions in 
 the industry. Dedicated Adobe em-ployees and many industry partners 
 have striven to make that goal a reality. We take this opportunity to thank 
 all those who contributed to this effort. 
  
 John Warnock and Chuck 
 Geschke 
  
 February 1999",NA
Introduction,"THE POSTSCRIPT
 ®
  LANGUAGE is a simple interpretive programming lan-
 guage with powerful graphics capabilities. Its primary application is to 
 describe the appearance of text, graphical shapes, and sampled images on 
 printed or dis-played pages, according to the Adobe imaging model. A 
 program in this language can communicate a description of a document 
 from a composition system to a printing system or control the appearance 
 of text and graphics on a display. The description is high-level and device-
 independent. 
  
 The page description and interactive graphics capabilities of the PostScript 
 lan-guage include the following features, which can be used in any 
 combination:",NA
•,"Arbitrary shapes made of straight lines, arcs, rectangles, and cubic curves. 
 Such 
  
 shapes may self-intersect and have disconnected sections and 
 holes.",NA
•,"Painting operators that permit a shape to be outlined with lines of any 
 thick-ness, filled with any color, or used as a clipping path to crop any 
 other graphic. Colors can be specified in a variety of ways: grayscale, RGB, 
 CMYK, and CIE-based. Certain other features are also modeled as special 
 kinds of colors: re-peating patterns, smooth shading, color mapping, and 
 spot colors.",NA
•,"Text fully integrated with graphics. In the Adobe imaging model, text 
 charac-ters in both built-in and user-defined fonts are treated as 
 graphical shapes that may be operated on by any of the normal graphics 
 operators.",NA
•,"Sampled images derived from natural sources (such as scanned 
 photographs) or generated synthetically. The PostScript language can 
 describe images sam-pled at any resolution and according to a variety of 
 color models. It provides a number of ways to reproduce images on an 
 output device.",NA
•,"A general coordinate system that supports all combinations of linear 
 transfor-mations, including translation, scaling, rotation, reflection, and 
 skewing. These transformations apply uniformly to all elements of a page, 
 including text, graphical shapes, and sampled images. 
  
 A PostScript page description can be rendered on a printer, display, or 
 other out-put device by presenting it to a PostScript interpreter controlling 
 that device. As the interpreter executes commands to paint characters, 
 graphical shapes, and sampled images, it converts the high-level PostScript 
 description into the low-level raster data format for that particular device. 
  
 Normally, application programs such as document composition systems, 
 illustra-tors, and computer-aided design systems generate PostScript page 
 descriptions automatically. Programmers generally write PostScript 
 programs only when cre-ating new applications. However, in special 
 situations a programmer can write PostScript programs to take advantage 
 of capabilities of the PostScript language that are not accessible through an 
 application program. 
  
 The extensive graphics capabilities of the PostScript language are 
 embedded in the framework of a general-purpose programming language. 
 The language includes a conventional set of data types, such as numbers, 
 arrays, and strings; control primitives, such as conditionals, loops, and 
 procedures; and some unusu-al features, such as dictionaries. These 
 features enable application programmers to define higher-level operations 
 that closely match the needs of the application and then to generate 
 commands that invoke those higher-level operations. Such a description is 
 more compact and easier to generate than one written entirely in terms of a 
 fixed set of basic operations. 
  
 PostScript programs can be created, transmitted, and interpreted in the 
 form of ASCII source text as defined in this book. The entire language can be 
 described in terms of printable characters and white space. This 
 representation is convenient for programmers to create, manipulate, and 
 understand. It also facilitates storage and transmission of files among 
 diverse 
 computers 
 and 
 operating 
 systems, 
 en-hancing 
 machine 
 independence. 
  
 There are also binary encoded forms of the language for use in suitably 
 controlled environments—for example, when the program is assured of a 
 fully transparent communications path to the PostScript interpreter. Adobe 
 recommends strict ad-herence to the ASCII representation of PostScript 
 programs for document inter-change or archival storage.",NA
1.1 About This Book,"This is the programmer’s reference for the PostScript language. It is the 
 definitive documentation for the syntax and semantics of the language, the 
 imaging model, and the effects of the graphics operators.",NA
•,"Chapter 2, “Basic Ideas,” is an informal presentation of some basic ideas 
 under-lying the more formal descriptions and definitions to come in later 
 chapters. These include the properties and capabilities of raster output 
 devices, require-ments for a language that effectively uses those 
 capabilities, and some pragmat-ic information about the environments in 
 which the PostScript interpreter operates and the kinds of PostScript 
 programs it typically executes.",NA
•,"Chapter 3, “Language,” introduces the fundamentals of the PostScript lan-
 guage: its syntax, semantics, data types, execution model, and 
 interactions with application programs. This chapter concentrates on the 
 conventional program-ming aspects of the language, ignoring its 
 graphical capabilities and use as a page description language.",NA
•,"Chapter 4, “Graphics,” introduces the Adobe imaging model at a device-
 independent level. It describes how to define and manipulate graphical 
 enti-ties—lines, curves, filled areas, sampled images, and higher-level 
 structures such as patterns and forms. It includes complete information 
 on the color models that the PostScript language supports.",NA
•,"Chapter 5, “Fonts,” describes how the PostScript language deals with text. 
 Characters are defined as graphical shapes, whose behavior conforms to 
 the imaging model presented in Chapter 4. Because of the importance of 
 text in most applications, the PostScript language provides special 
 capabilities for or-ganizing sets of characters as fonts and for painting 
 characters efficiently.",NA
•,"Chapter 6, “Device Control,” describes how a page description 
 communicates its document processing requirements to the output 
 device. These include page size, media selection, finishing options, and in-
 RIP trapping.",NA
•,"Chapter 7, “Rendering,” details the device-dependent aspects of rendering 
 page descriptions on raster output devices (printers and displays). These 
 include color rendering, transfer functions, halftoning, and scan 
 conversion, each of which is device-dependent in some way.",NA
•,"Chapter 8, “Operators,” describes all PostScript operators and 
 procedures. The chapter begins by categorizing operators into functional 
 groups. Then the operators appear in alphabetical order, with complete 
 descriptions of their op-erands, results, side effects, and possible errors. 
  
 The appendices contain useful tables and other auxiliary information.",NA
•,"Appendix A, “LanguageLevel Feature Summary,” summarizes the ways 
 the PostScript language has been extended with new operators and other 
 features over time.",NA
•,"Appendix B, “Implementation Limits,” describes typical limits imposed by 
 im-plementations of the PostScript interpreter—for example, maximum 
 integer value and maximum stack depth.",NA
•,"Appendix C, “Interpreter Parameters,” specifies various parameters to 
 control the operation and behavior of the PostScript interpreter. Most of 
 these parame-ters have to do with allocation of memory and other 
 resources for specific pur-poses.",NA
•,"Appendix D, “Compatibility Strategies,” helps PostScript programmers 
 take advantage of newer PostScript language features while maintaining 
 compatibil-ity with the installed base of older PostScript interpreter 
 products.",NA
•,"Appendix E, “Character Sets and Encoding Vectors,” describes the 
 organization of common fonts that are built into interpreters or are 
 available as separate software products.",NA
•,"Appendix F, “System Name Encodings,” assigns numeric codes to standard 
  
 names, for use in binary-encoded PostScript programs.",NA
•,"Appendix G, “Operator Usage Guidelines,” provides guidelines for 
 PostScript operators whose use can cause unintended side effects, make a 
 document device-dependent, or inhibit postprocessing of a document by 
 other programs. 
  
 The book concludes with a Bibliography and an Index.
  
 The enclosed CD-ROM contains the entire text of this book in Portable Docu-
 ment Format (PDF).",NA
1.2 Evolution of the PostScript Language,"Since its introduction in 1985, the PostScript language has been 
 considerably ex-tended for greater programming power, efficiency, and 
 flexibility. Typically, these language extensions have been designed to adapt 
 the PostScript language to new imaging technologies or system 
 environments. While these extensions have intro-duced significant new 
 functionality and flexibility to the language, the basic imaging model 
 remains unchanged. 
  
 Extensions are organized into major groups, called 
 LanguageLevels
 . Three 
 LanguageLevels have been defined, numbered 1, 2, and 3. Each 
 LanguageLevel encompasses all features of previous LanguageLevels as 
 well as a significant num-ber of new features. A PostScript interpreter 
 claiming to support a given LanguageLevel must implement all features 
 defined in that LanguageLevel and lower. Thus, for example, a feature 
 identified in this book as “LanguageLevel 2” is understood to be available in 
 all LanguageLevel 3 implementations as well. 
  
 This book documents the entire PostScript language, which consists of 
 three dis-tinct groups of features. Features that are part of the 
 LanguageLevel 2 or LanguageLevel 3 additions are clearly identified as 
 such. Features that are not otherwise identified are LanguageLevel 1. 
  
 A PostScript interpreter can also support extensions that are not part of its 
 base LanguageLevel. Some such extensions are specialized to particular 
 applications, while others are of general utility and are candidates for 
 inclusion in a future LanguageLevel. 
  
 The most significant special-purpose extension is the set of features for the 
 Display 
 PostScript
 ®
  
 system. 
 Those 
 features 
 enable 
 workstation 
 applications to use the PostScript language and the Adobe imaging model 
 for managing the appear-ance of the display and for interacting with the 
 workstation’s windowing system. The Display PostScript extensions were 
 documented in the second edition of this book but have been removed for 
 this edition. Further information is available in the 
 Display PostScript 
 System
  manuals. 
  
 Appendix D describes strategies for writing PostScript programs that can 
 run compatibly on interpreters supporting different LanguageLevels. With 
 some care, a program can take advantage of features in a higher 
 LanguageLevel when avail-able but will still run acceptably when those 
 features are not available.",NA
1.3 LanguageLevel 3 Overview,"In addition to unifying many previous PostScript language extensions, 
 Language-Level 3 introduces a number of new features. This section 
 summarizes those fea-tures, for the benefit of readers who are already 
 familiar with LanguageLevel 2.",NA
•,"Functions
 . A PostScript function is a self-contained, static description of a 
 mathematical function having one or more arguments and one or more 
 results.",NA
•,"Filters
 . Three filters have been added, named 
 FlateDecode
 , 
 FlateEncode
 , 
 and 
 ReusableStreamDecode
 . Some existing filters accept additional 
 optional parameters.",NA
•,"Idiom recognition
 . The 
 bind
  operator can find and replace certain 
 commonly occurring procedures, called 
 idioms
 , typically appearing in 
 application prologs. The substituted procedure achieves equivalent 
 results with significantly im-proved performance or quality. This enables 
 LanguageLevel 3 features to work in applications that have not yet been 
 modified to use those features directly.",NA
•,"Clipping path stack
 . The 
 clipsave
  and 
 cliprestore
  operators save and restore 
 just 
  
 the clipping path without affecting the rest of the graphics state.",NA
•,"Color spaces
 . Three color spaces have been added: 
 CIEBasedDEF 
 and 
 CIEBased–DEFG
  provide increased flexibility for specifying device-
 independent colors; 
 DeviceN
  provides a means of specifying high-fidelity 
 and multitone colors.",NA
•,"Color space substitution
 . Colors that have been specified in 
 DeviceGray
 , 
 DeviceRGB
 , or 
 DeviceCMYK
  color spaces can be remapped into CIE-based 
 color spaces. This capability can be useful in a variety of circumstances, 
 such as for redirecting output intended for one device to a different one 
 or for pro-ducing CIE-based colors from an application that generates 
 LanguageLevel 1 output only (and thus is unable to specify them 
 directly).",NA
•,"Smooth shading
 . It is now possible to paint with a color that varies 
 smoothly 
  
 over the object or region being painted.",NA
•,"Masked images
 . A sampled image can be clipped by a mask as it is painted. 
 The mask can be represented explicitly or encoded with a color key in the 
 image data. This enables the background to show through parts of the 
 image.",NA
•,"CID-keyed fonts
 . This font organization provides a convenient and efficient 
 means for defining multiple-byte character encodings and for creating 
 base fonts containing a very large number of character descriptions.",NA
•,"Font formats
 . Support has been added for additional types of base fonts, 
 includ-ing CFF (Compact Font Format), Chameleon
 ®
 , TrueType™, and 
 bitmap fonts.",NA
•,"Device setup
 . There are many additional page device parameters to 
 control col-orant selection, finishing options, and other features. Any 
 device can now pro-duce arbitrary separations, even in a monochrome 
 printing system (which can mark only one colorant at a time).",NA
•,"In-RIP trapping
 . Certain products support 
 trapping
 , which is the 
 automatic generation of overlaps to correct for colorant misregistration 
 during the print-ing process.",NA
•,"Color rendering intent
 . A PostScript program can specify a 
 rendering 
 intent
  for color reproduction, causing automatic selection of an 
 appropriate CIE-based color rendering dictionary.",NA
•,"Halftones
 . Several standard halftone types have been added. They include 
 16-bit threshold arrays and more flexible tiling organizations for 
 improved color accuracy on high-resolution devices. Halftone supercells 
 increase the number of gray levels achievable on low-resolution devices.",NA
1.4 Related Publications,"A number of publications related to this book are listed in the Bibliography; 
 some notable ones are mentioned here. For more details, see the 
 Bibliography. 
  
 1.4.1 The Supplement
  
 The 
 PostScript Language Reference Supplement
  documents PostScript 
 language extensions that are available in certain releases of Adobe 
 PostScript
 ®
  software. A new edition of the 
 Supplement
  is published along 
 with each major release of Adobe PostScript software. 
  
 The 
 Supplement
  documents three major classes of extensions:",NA
•,"New PostScript language features that have been introduced since the 
 most re-cent LanguageLevel and that are candidates for inclusion in the 
 next Language-Level.",NA
•,"Extensions for controlling unique features of products, such as 
 communication parameters, print engine options, and so on. Certain 
 PostScript language fea-tures, such as 
 setdevparams
 , 
 setpagedevice
 , and the 
 named resource facility,",NA
•,"LanguageLevel 1 compatibility operators, principally in the 
 statusdict
  
 diction-ary. Those features were the LanguageLevel 1 means for 
 controlling unique fea-tures of products, but they have been superseded. 
 They are not formally a part of the PostScript language, but many of them 
 are still supported in Adobe Post-Script interpreters as a concession to 
 existing applications that depend on them. 
  
 1.4.2 Font Formats
  
 PostScript interpreters support several standard formats for font programs, 
 in-cluding Adobe Type 1, CFF (Compact Font Format), TrueType, and CID-
 keyed fonts. The PostScript language manifestations of those fonts are 
 documented in this book. However, the specifications for the font files 
 themselves are published separately, because they are highly specialized 
 and are of interest to a different user community. A variety of Adobe 
 publications are available on the subject of font formats, most notably the 
 following:",NA
•,"Adobe Type 1 Font Format
  and AdobeTechnical Note #5015, 
 Type 1 Font 
 Format 
  
 Supplement",NA
•,"AdobeTechnical Note #5176, 
 The Compact Font Format Specification",NA
•,"AdobeTechnical Note #5012, 
 The Type 42 Font Format Specification",NA
•,"Adobe Technical Note #5014, 
 Adobe CMap and CID Font Files Specification 
  
 1.4.3 Document Structure
  
 Some conventions have been established for the structure of PostScript 
 programs that are to be treated as documents. Those conventions, while 
 not formally part of the PostScript language, are highly recommended, since 
 they enable interoper-ability with applications that pay attention to them.",NA
•,"Adobe Technical Note #5001, 
 PostScript Language Document Structuring 
 Con-ventions Specification
 , describes a convention for structuring 
 PostScript page descriptions to facilitate their handling and processing by 
 other programs.",NA
•,"Adobe Technical Note #5002, 
 Encapsulated PostScript File Format 
 Specification
 , describes a format that enables applications to treat each 
 other’s output as in-cluded illustrations. 
  
 1.4.4 Portable Document Format (PDF)
  
 Adobe has specified another format, PDF, for portable representation of 
 electron-ic documents. PDF is documented in the 
 Portable Document 
 Format Reference Manual. 
  
 PDF and the PostScript language share the same underlying Adobe imaging 
 model. A document can be converted straightforwardly between PDF and 
 the PostScript language; the two representations produce the same output 
 when printed. However, PDF lacks the general-purpose programming 
 language frame-work of the PostScript language. A PDF document is a static 
 data structure that is designed for efficient random access and includes 
 navigational information suit-able for interactive viewing.",NA
1.5 Copyrights and Trademarks,"The general 
 idea
  of using a page description language is in the public 
 domain. Anyone is free to devise his or her own set of unique commands 
 that constitute a page description language. However, Adobe Systems 
 Incorporated owns the copyright for the list of operators and the written 
 specification for Adobe’s Post-Script language. Thus, these elements of the 
 PostScript language may not be cop-ied without Adobe’s permission. 
 Additionally, Adobe owns the trademark“PostScript,” which is used to 
 identify both the PostScript language and Adobe’s PostScript software. 
  
 Adobe will enforce its copyright and trademark rights. Adobe’s intentions are to:",NA
•,"Maintain the integrity of the PostScript language standard. This enables 
 the public to distinguish between the PostScript language and other page 
 descrip-tion languages.",NA
•,"Maintain the integrity of “PostScript” as a trademark. This enables the 
 public to distinguish between Adobe’s PostScript interpreter and other 
 interpreters that can execute PostScript language programs.",NA
•,Write programs in the PostScript language.,NA
•,Write drivers to generate output consisting of PostScript language commands.,NA
•,Write software to interpret programs written in the PostScript language.,NA
•,"Copy Adobe’s copyrighted list of commands to the extent necessary to use 
 the 
  
 PostScript language for the above purposes. 
  
 The only condition of such permission is that anyone who uses the 
 copyrighted list of commands in this way must include an appropriate 
 copyright notice. This limited right to use the copyrighted list of commands 
 does not include a right to copy this book, other copyrighted publications 
 from Adobe, or the software in Adobe’s PostScript interpreter, in whole or 
 in part. 
  
 The trademark PostScript
 ®
  (or a derivative trademark, such as PostScript
 ®
  
 3™) may not be used to identify any product not originating from or 
 licensed by Adobe. However, it is acceptable for a non-Adobe product to be 
 described as be-ing PostScript-compatible and supporting a specific 
 LanguageLevel, assuming that the claim is true.",NA
Basic Ideas,"OBTAINING A COMPLETE UNDERSTANDING of the PostScript language 
 requires considering it from several points of view:",NA
•,"As a general-purpose programming language with powerful built-in 
 graphics 
  
 primitives",NA
•,As a page description language that includes programming features,NA
•,"As an interactive system for controlling raster output devices (printers and 
  
 displays)",NA
•,"As an application- and device-independent interchange format for page de-
  
 scriptions 
  
 This chapter presents some basic ideas that are essential to understanding 
 the problems the PostScript language is designed to solve and the 
 environments in which it is designed to operate. Terminology introduced 
 here appears throughout the manual.",NA
2.1 Raster Output Devices,"Much of the power of the PostScript language derives from its ability to deal 
 with the general class of 
 raster output devices.
  This class encompasses such 
 technology as laser, dot-matrix, and ink-jet printers, digital imagesetters, 
 and raster scan displays. 
  
 The defining property of a raster output device is that a printed or 
 displayed im-age consists of a rectangular array of dots, called 
 pixels
  
 (picture elements), that can be addressed individually. On a typical black-
 and-white output device, each pixel can be made either black or white. On 
 certain devices, each pixel can be set",NA
•,"Computer displays have relatively low resolution, typically 75 to 110 pixels 
 per 
  
 inch.",NA
•,Dot-matrix printers generally range from 100 to 250 pixels per inch.,NA
•,"Ink-jet and laser-scanned xerographic printing technologies are capable of 
  
 medium-resolution output of 300 to 1400 pixels per inch.",NA
•,"Photographic technology permits high resolutions of 2400 pixels per inch 
 or 
  
 more. 
  
 Higher resolution yields better quality and fidelity of the resulting output, 
 but is achieved at greater cost. As the technology improves and computing 
 costs de-crease, products evolve to higher resolutions.",NA
2.2 Scan Conversion,"An abstract graphical element (for example, a line, a circle, a text character, 
 or a sampled image) is rendered on a raster output device by a process 
 known as 
 scan conversion
 . Given a mathematical description of the 
 graphical element, this pro-cess determines which pixels to adjust and what 
 values to assign those pixels to achieve the most faithful rendition possible 
 at the device resolution. 
  
 The pixels on the page can be represented by a two-dimensional array of 
 pixel values in computer memory. For an output device whose pixels can be 
 only black or white, a single bit suffices to represent each pixel. For a device 
 whose pixels can reproduce gray shades or colors, multiple bits per pixel 
 are required. 
  
 Note: 
 Although the ultimate representation of a printed or displayed page is 
 logically a complete array of pixels, its actual representation in computer 
 memory need not",NA
2.3 Page Description Languages,"Theoretically, an application program could describe any page as a full-
 page pixel array. But this would be unsatisfactory, because the description 
 would be bulky, the pixel array would be device-dependent, and memory 
 requirements would be beyond the capacity of many personal computers. 
  
 A page description language should enable applications to produce files 
 that are relatively compact for storage and transmission, and independent 
 of any particu-lar output device.",NA
•,"A 
 static format
  provides some fixed set of operations and a syntax for 
 specifying the operations and their arguments. Static formats have been 
 in existence since computers first used printers; classic examples are 
 format control codes for line printers and “format effector” codes in 
 standard character sets. Historically, static formats have been designed to 
 capture the capabilities of a specific class of printing device and have 
 evolved to include new features as needed.",NA
•,"A 
 dynamic format
  allows more flexibility than a static format. The 
 operator set may be extensible and the exact meaning of an operator may 
 not be known un-til it is actually encountered. A page described in a 
 dynamic format is a pro-",NA
2.4 Using the PostScript Language,"It is important to understand the PostScript interpreter and how it interacts 
 with applications using it. 
  
 2.4.1 The Interpreter
  
 The PostScript 
 interpreter
  controls the actions of the output device 
 according to the instructions provided in a PostScript program generated 
 by an application. The interpreter executes the program and produces 
 output on a printer, display, or other raster device. 
  
 There are three ways the PostScript interpreter and the application interact 
 (Figure 2.1 illustrates these scenarios):",NA
•,"In the conventional output-only printing model, the application creates a 
 page description
 —a self-contained PostScript language description of a 
 document. The page description can be sent to the PostScript interpreter 
 immediately or stored for transmission at some other time (via an 
 intermediate print manager or spooler, for example). The interpreter 
 consumes a sequence of page descrip-tions as “print jobs” and produces 
 the requested output. The output device is typically a printer, but it can 
 be a preview window on a workstation’s display. The PostScript 
 interpreter is often implemented on a dedicated processor that has direct 
 control over the raster output device.",NA
•,"In the integrated display model, an application interacts with the 
 PostScript interpreter controlling a display or windowing system. Instead 
 of a one-way transmission of a page description, a two-way 
 interactive 
 session 
 takes place between the application and the interpreter. In 
 response to user actions, the",NA
•,"In the interactive programming language model, an interactive session 
 takes place directly between a programmer and the PostScript 
 interpreter; the pro-grammer issues PostScript commands for immediate 
 execution. Many Post-Script interpreters (for both printers and displays) 
 have a rudimentary interactive executive to support this mode of use; see 
 Section 2.4.4, “Using the Interpreter Interactively.” 
  
 Conventional output-only printing model
  
 Application
  
 Page
  
 PostScript
  
 Printer or
  
 description
  
 interpreter
  
 preview device
  
 Integrated display model
  
 Application
  
 PostScript
  
 Interactive
  
 interpreter
  
 display
  
  
 Interactive session
  
 Interactive programming language model
  
  
 Human 
  
 programmer
  
  
 PostScript
  
 Any
  
 interpreter
  
 device
  
  
 Interactive session
  
 FIGURE 2.1 
 How the PostScript interpreter and an application interact
  
 Even when a PostScript interpreter is being used noninteractively to 
 execute page descriptions prepared previously, there may be some 
 dynamic interactions be-tween the print manager or spooler and the 
 PostScript interpreter. For example, the sender may ask the PostScript 
 interpreter whether certain fonts referenced by a document are available. 
 This is accomplished by sending the interpreter a short program to read 
 and return the information. The PostScript interpreter makes no distinction 
 between a page description and a program that makes environmental 
 queries or performs other arbitrary computations.",NA
•,"The 
 prolog
  is a set of application-specific procedure definitions that an 
 applica-tion may use in the execution of its script. It is included as the 
 first part of every PostScript file generated by the application. It contains 
 definitions that match the output functions of the application with the 
 capabilities supported by the PostScript language.",NA
•,"The 
 script
  is generated automatically by the application program to 
 describe the specific elements of the pages being produced. It consists of 
 references to PostScript operators and to procedure definitions in the 
 prolog, together with operands and data. The script, unlike the prolog, is 
 usually very stylized, repet-itive, and simple. 
  
 Dividing a PostScript program into a prolog and a script reduces the size of 
 each page description and minimizes data communication and disk storage. 
 An exam-ple may help explain the purpose of a separate prolog and script. 
 One of the most common tasks in a PostScript program is placing text at a 
 particular location on the current page. This is really 
 two
  operations: 
 “moving” the current point to a specific location and “showing” the text. A 
 program is likely to do this often, so it is useful for the prolog to define a 
 procedure that combines the operations: 
  
 /ms {moveto show} bind def
  
 Later, the script can call the 
 ms
  procedure instead of restating the individual 
 op-erations: 
  
 (some text)  100  200  ms",NA
•,"Utility programs can operate on structured documents in various ways: 
 change the order of pages, extract subsets of pages, embed individual 
 pages within oth-er pages, and so on. This is possible only if the original 
 document maintains page independence.",NA
•,"Print managers and spoolers can obtain useful information from a properly 
  
 structured document to determine how the document should be handled.",NA
•,"The structuring conventions serve as a good basis for organizing printing 
 from 
  
 an application. 
  
 An application has its own model of the appearance of printable output that 
 it generates. Some parts of this model are fixed for an entire document or 
 for all documents; the application should incorporate their descriptions 
 into the prolog. Other parts vary from one page to another; the application 
 should produce the necessary descriptions of these as they appear. At page 
 boundaries, the applica-tion should generate commands to restore the 
 standard environment defined by the prolog and then explicitly reestablish 
 nonstandard portions of the environ-ment for the next page. This technique 
 ensures that each page is independent of any other. 
  
 The structuring conventions also include standard methods for performing 
 envi-ronmental queries. These conventions ensure consistent and reliable 
 behavior in a variety of system environments, including those with print 
 spoolers. 
  
 2.4.3 Translating from Other Print Formats
  
 Many existing applications generate printable documents in some other print 
 file format or in some intermediate representation. It is possible to print such 
 docu-",NA
•,"An application describes its printable output by making calls to an 
 application programming interface, such as GDI in Microsoft Windows
 ®
  
 or QuickDraw™in the Apple Mac
 ®
  OS. A software component called a 
 printer driver
  interprets these calls and produces a PostScript page 
 description.",NA
•,"An application produces printable output directly in some other file 
 format, such as PCL, HPGL, or DVI. A separate program must then 
 translate this file into a PostScript page description. 
  
 Implementing a driver or translator is often the least expensive way to 
 interface an existing application to a PostScript printer. Unfortunately, 
 while such transla-tion is usually straightforward, a translator may not be 
 able to generate page descriptions that make the best use of the high-level 
 Adobe imaging model. This is because the information being translated 
 often describes the desired results at a level that is too low; any higher-
 level information maintained by the original ap-plication has been lost and 
 is not available to the translator. 
  
 While direct PostScript output from applications is most desirable, 
 translation from another print format may be the only choice available for 
 some applica-tions. A translator should do the best it can to produce output 
 that conforms to the document structuring conventions (see Technical Note 
 #5001). This ensures that such output is compatible with the tools for 
 manipulating PostScript page descriptions. 
  
 2.4.4 Using the Interpreter Interactively
  
 Normally, the interpreter executes PostScript programs generated by 
 application programs; a user does not interact with the PostScript 
 interpreter directly. How-ever, many PostScript interpreters provide an 
 interactive executive
  that enables a user to control the interpreter directly. 
 That is, from a terminal or terminal emu-lator connected directly to the 
 PostScript interpreter, you can issue commands for immediate execution 
 and control the operation of the interpreter in limited ways. This is useful 
 for experimentation and debugging. 
  
 To use the interpreter this way, you must first connect your keyboard and 
 display directly to the standard input and output channels of the PostScript 
 interpreter, so that characters you type are sent directly to the interpreter 
 and characters the",NA
•,"It is intended solely for direct interaction with the user; an application 
 that is generating PostScript programs should never invoke
  executive
 . In 
 general, a PostScript program will behave differently when sent through 
 the interactive executive than when executed directly by the PostScript 
 interpreter. For exam-ple, the executive produces extraneous output such 
 as echoes of the input char-acters and 
 PS>
  prompts. Furthermore, a 
 program that explicitly reads data embedded in the program file will 
 malfunction if invoked via the executive, since the executive itself is 
 interpreting the file.",NA
•,"The user amenities are intentionally minimal. The executive is not a full-
 scale programming environment; it lacks a text editor and other tools 
 required for program development and it does not keep a record of your 
 interactive session. The executive is useful mainly for experimentation 
 and debugging.",NA
•,"The 
 executive
  operator is not necessarily available in all PostScript 
 interpreters. 
  
 Its behavior may vary among different products.",NA
Language,"SYNTAX, DATA TYPES, AND EXECUTION SEMANTICS are essential aspects 
 of any PostScript program. Later chapters document the graphics and font 
 capa-bilities that specialize PostScript programs to the task of controlling 
 the appear-ance of a printed page. This chapter explains the PostScript 
 language as a 
 programming
  language. 
  
 Like all programming languages, the PostScript language builds on 
 elements and ideas from several of the great programming languages. The 
 syntax most closely resembles that of the programming language FORTH. It 
 incorporates a 
 postfix 
 notation in which operators are preceded by their 
 operands. The number of spe-cial characters is small and there are no 
 reserved words. 
  
 Note: 
 Although the number of built-in operators is large, the names that 
 represent operators are not reserved by the language. A PostScript program 
 may change the meanings of operator names. 
  
 The data model includes elements, such as numbers, strings, and arrays, 
 that are found in many modern programming languages. It also includes 
 the ability to treat programs as data and to monitor and control many 
 aspects of the language’s execution state; these notions are derived from 
 programming languages such as LISP. 
  
 The PostScript language is relatively simple. It derives its power from the 
 ability to combine these features in unlimited ways without arbitrary 
 restrictions. Though you may seldom fully exploit this power, you can 
 design sophisticated graphical applications that would otherwise be 
 difficult or impossible. 
  
 Because this is a reference book and not a tutorial, this chapter describes each 
 as-pect of the language systematically and thoroughly before moving on to the 
 next.",NA
3.1 Interpreter,"The PostScript interpreter executes the PostScript language according to 
 the rules in this chapter. These rules determine the order in which 
 operations are carried out and how the pieces of a PostScript program fit 
 together to produce the de-sired results. 
  
 The interpreter manipulates entities called PostScript 
 objects
 . Some objects 
 are data, such as numbers, boolean values, strings, and arrays. Other 
 objects are ele-ments of programs to be executed, such as names, 
 operators, and procedures. However, there is not a distinction between 
 data and programs; any PostScript object may be treated as data or be 
 executed as part of a program. 
  
 The interpreter operates by executing a sequence of objects. The effect of 
 exe-cuting a particular object depends on that object’s 
 type
 , 
 attributes
 , and 
 value
 . For example, executing a number object causes the interpreter to 
 push a copy of that object on the operand stack (to be described shortly). 
 Executing a name object causes the interpreter to look up the name in a 
 dictionary, fetch the associated value, and execute it. Executing an operator 
 object causes the interpreter to perform a built-in action, such as adding 
 two numbers or painting characters in raster memory. 
  
 The objects to be executed by the interpreter come from two principal sources:",NA
•,"A character stream may be scanned according to the syntax rules of the 
 Post-Script language, producing a sequence of new objects. As each object 
 is scanned, it is immediately executed. The character stream may come 
 from an external source, such as a file or a communication channel, or it 
 may come from a string object previously stored in the PostScript 
 interpreter’s memory.",NA
•,"Objects previously stored in an array in memory may be executed in 
 sequence. 
  
 Such an array is known as a 
 procedure
 .",NA
3.2 Syntax,"As the interpreter scans the text of a PostScript program, it creates various 
 types of PostScript objects, such as numbers, strings, and procedures. This 
 section dis-cusses only the 
 syntactic
  representation of such objects. Their 
 internal representa-tion and behavior are covered in Section 3.3, “Data 
 Types and Objects.” 
  
 There are three encodings for the PostScript language: 
 ASCII
 , 
 binary token
 , 
 and 
 binary object sequence
 . The ASCII encoding is preferred for expository 
 purposes (such as this book), for archiving documents, and for 
 transmission via communi-cations facilities, because it is easy to read and 
 does not rely on any special charac-ters that might be reserved for 
 communications use. The two binary encodings are usable in controlled 
 environments to improve the efficiency of representation or execution; 
 they are intended exclusively for machine generation. Detailed in-formation 
 on the binary encodings is provided in Section 3.14, “Binary Encoding 
 Details.” 
  
 3.2.1 Scanner
  
 The PostScript language differs from most other programming languages in 
 that it does not have any syntactic entity for a “program,” nor is it necessary 
 for an en-tire “program” to exist in one place at one time. There is no notion 
 of “reading in”a program before executing it. Instead, the PostScript 
 interpreter 
 consumes
  a pro-gram by reading and executing one syntactic 
 entity at a time. From the interpret-er’s point of view, the program has no 
 permanent existence. Execution of the program may have side effects in the 
 interpreter’s memory or elsewhere. These side effects may include the 
 creation of procedure objects in memory that are in-tended to be invoked 
 later in the program; their execution is 
 deferred
 .",NA
•,"Signed integers, such as 
  
 123  
  
 98  43445  0  
 +
 17",NA
•,"Real numbers, such as 
  
  
 .002  34.5  
  
 3.62  123.6e10  1.0E
  
 5  1E6  
  
 1.   0.0",NA
•,"Radix numbers, such as 
  
 8#1777  16#FFFE  2#1000
  
 An integer consists of an optional sign followed by one or more decimal 
 digits. The number is interpreted as a signed decimal integer and is 
 converted to an inte-ger object. If it exceeds the implementation limit for 
 integers, it is converted to a real object. (See Appendix B for 
 implementation limits.) 
  
 A real number consists of an optional sign and one or more decimal digits, 
 with an embedded period (decimal point), a trailing exponent, or both. The 
 exponent, if present, consists of the letter 
 E
  or 
 e
  followed by an optional 
 sign and one or more decimal digits. The number is interpreted as a real 
 number and is converted to a real (floating-point) object. If it exceeds the 
 implementation limit for real numbers, a 
 limitcheck
  error occurs. 
  
 A radix number takes the form 
 base
 #
 number
 , where 
 base
  is a decimal integer 
 in the range 
 2
  through 
 36
 . 
 number
  is interpreted in this base; it must consist 
 of digits ranging from 0 to 
 base
  
  1. Digits greater than 9 are represented by 
 the letters 
 A 
 through 
 Z 
 (or 
 a
  through
  z
 ). The number is treated as an 
 unsigned integer and is converted to an integer object having the same 
 twos-complement binary repre-sentation. This notation is intended for 
 specifying integers in a nondecimal radix, such as binary, octal, or 
 hexadecimal. If the number exceeds the implementation limit for integers, a 
 limitcheck
  error occurs.",NA
•,"As literal text, enclosed in
  (
  and 
 )",NA
•,"As hexadecimal data, enclosed in 
 <
  and 
 >",NA
•,"As ASCII base-85 data, enclosed in 
 <~
  and 
 ~>
 (LanguageLevel 2) 
  
 Literal Text Strings
  
 A literal text string consists of an arbitrary number of characters enclosed in
  
 (
  and 
 )
 . Any characters may appear in the string other than 
 (
 , 
 )
 , and
  \
 , which must
  
 be treated specially. Balanced pairs of parentheses in the string require no special
  
 treatment. 
  
 The following lines show several valid strings: 
  
 (This is a string)
  
 (Strings may contain newlines
  
 and such.)
  
 (Strings may contain special characters *!&}^% and
  
 balanced parentheses ( ) (and so on).)
  
 (The following is an empty string.)
  
 ()
  
 (It has 0 (zero) length.)
  
 Within a text string, the
 \
  (backslash) character is treated as an “escape” for vari-
  
 ous purposes, such as including newline characters, unbalanced parentheses, and
  
 the 
 \
  character itself in the string. The character immediately following the 
 \
  de-
  
 termines its precise interpretation. 
  
 \n 
  
 line feed (LF)
  
 \r 
  
 carriage return (CR)
  
 \t 
  
 horizontal tab
  
 \b 
  
 backspace
  
 \f 
  
 form feed
  
 \\ 
  
 backslash
  
 \( 
  
 left parenthesis
  
 \) 
  
 right parenthesis
  
 \
 ddd 
  
 character code 
 ddd
  (octal)",NA
•,"The name object 
 [",NA
•,"The integer object 
 123",NA
•,"The literal name object 
 abc",NA
•,"The string object 
 xyz",NA
•,"The name object 
 ] 
  
 When the example is executed, a sixth object (the array) results from 
 executing the
 [
  and
 ] 
 name objects. 
  
 Procedures
  
 The special characters 
 {
  and 
 } 
 delimit an 
 executable array
 , otherwise known 
 as a 
 procedure
 . The syntax is superficially similar to that for the array 
 construction op-erators
 [ 
 and
 ]
 ; however, the semantics are entirely different 
 and arise as a result of 
 scanning
  the procedure rather than 
 executing
  it. 
  
 Scanning the program fragment 
  
 {add 2 div}",NA
3.3 Data Types and Objects,"All data accessible to PostScript programs, including procedures that are 
 part of the programs themselves, exists in the form of 
 objects
 . Objects are 
 produced, ma-nipulated, and consumed by the PostScript operators. They 
 are also created by the scanner and executed by the interpreter. 
  
 Each object has a 
 type,
  some
  attributes,
  and a 
 value
 . Objects contain their 
 own dy-namic types; that is, an object’s type is a property of the object 
 itself, not of where it is stored or what it is called. Table 3.2 lists all the 
 object types supported by the PostScript language. Extensions to the 
 language may introduce additional object types. The distinction between 
 simple and composite objects is explained below. 
  
 TABLE 3.2 Types of objects
  
 SIMPLE OBJECTS
  
 COMPOSITE OBJECTS
  
 boolean 
  
 fontID 
  
 integer 
  
 mark 
  
 name 
  
 null 
  
 operato
 r
  
 array 
  
 dictionary 
  
 file 
  
 gstate 
 (LanguageLevel 2) 
  
 packedarray 
 (LanguageLevel 
 2) 
  
 save 
  
 string
  
 real
  
 3.3.1 Simple and Composite Objects
  
 Objects of most types are simple, atomic entities. An atomic object is always 
 con-stant—a 
 2
  is always a 
 2.
  There is no visible substructure in the object; 
 the type, at-tributes, and value are irrevocably bound together and cannot 
 be changed. 
  
 However, objects of certain types indicated in Table 3.2 are 
 composite
 . 
 Their values are separate from the objects themselves; for some types of 
 composite ob-ject, the values have internal substructure that is visible and 
 can sometimes be",NA
•,"If the object is 
 literal
 , the interpreter treats it strictly as data and pushes it 
 on 
  
 the operand stack for use as an operand of some subsequent 
 operator.",NA
•,"If the object is 
 executable
 , the interpreter executes it. 
  
 What it means to execute an object depends on the object’s type; this is 
 described in Section 3.5, “Execution.” For some object types, such as 
 integers, execution consists of pushing the object on the operand stack; the 
 distinction between lit-eral and executable integers is meaningless. But for 
 other types, such as names, operators, and arrays, execution consists of 
 performing a different action.",NA
•,"Executing an 
 executable name
  causes it to be looked up in the current 
 diction-
  
 ary context and the associated value to be executed.",NA
•,"Executing an 
 executable operator
  causes some built-in action to be performed.",NA
•,"Executing an 
 executable array
  (otherwise known as a procedure) causes 
 the ele-
  
 ments of the array to be executed in turn. 
  
 As described in Section 3.2, “Syntax,” some tokens produce literal objects and 
 some produce executable ones.",NA
•,"Integer, real, and string constants are always literal objects.",NA
•,"Names are literal if they are preceded by
  / 
 and executable if they are not.",NA
•,"The
 [
  and 
 ]
  operators, when executed, produce a literal array object with 
 the en-closed objects as elements. Likewise, 
 <<
  and 
 >>
 (LanguageLevel 2)
  
 produce a literal dictionary object.",NA
•,"{
  and 
 } 
 enclose an executable array or procedure. 
  
 Note: 
 As mentioned above, it does not matter whether an object is literal or 
 execut-able when it is accessed as data, only when it is executed. However, 
 referring to an executable object by name often causes that object to be 
 executed automatically; see Section 3.5.5, “Execution of Specific Types.” To 
 avoid unintended behavior, it is best to use the executable attribute only for 
 objects that are meant to be executed, such as procedures.",NA
•,Operators exist to access a specific dictionary supplied as an operand.,NA
•,"There is a 
 current dictionary
  and a set of operators to access it implicitly.",NA
•,"The interpreter automatically looks up executable names it encounters in 
 the 
  
 program being executed.",NA
•,"systemdict
  is a read-only dictionary that associates the names of all the 
 Post-Script operators (those defined in this book) with their values (the 
 built-in ac-tions that implement them). It also contains other definitions, 
 including the standard local and global dictionaries listed in Section 3.7.5, 
 “Standard and User-Defined Dictionaries,” as well as various named 
 constants such as 
 true 
 and 
 false
 .",NA
•,"globaldict
 (LanguageLevel 2)
  is a writeable dictionary in 
 global VM
 . This is 
 ex-
  
 plained in Section 3.7.2, “Local and Global VM.”",NA
•,"userdict 
 is a writeable dictionary in 
 local VM
 . It is the default modifiable 
 nam-
  
 ing environment normally used by PostScript programs. 
  
 userdict
  is the topmost of the permanent dictionaries on the dictionary 
 stack. The 
 def
  operator puts definitions there unless the program has 
 pushed some oth-er dictionary on the dictionary stack. Applications can 
 and should create their own dictionaries rather than put things in 
 userdict
 . 
  
 A dictionary is a composite object. Copying a dictionary object does not copy 
 the dictionary’s contents. Instead, the contents are shared. 
  
 3.3.10 Operator Objects
  
 An 
 operator
  object represents one of the PostScript language’s built-in 
 actions. When the object is executed, its built-in action is invoked. Much of 
 this book is devoted to describing the semantics of the various operators.",NA
3.4 Stacks,"The PostScript interpreter manages five stacks representing the execution 
 state of a PostScript program. Three of them—the operand, dictionary, and 
 execution stacks—are described here; the other two—the graphics state 
 stack and clipping path stack—are presented in Chapter 4. Stacks are “last 
 in, first out” (LIFO) data structures. In this book, “the stack” with no 
 qualifier always means the operand stack.",NA
•,"The 
 operand stack
  holds arbitrary PostScript objects that are the 
 operands and results of PostScript operators being executed. The 
 interpreter pushes objects on the operand stack when it encounters them 
 as literal data in a program be-ing executed. When an operator requires 
 one or more operands, it obtains them by popping them off the top of the 
 operand stack. When an operator re-turns one or more results, it does so 
 by pushing them on the operand stack.",NA
•,"The 
 dictionary stack
  holds only dictionary objects. The current set of 
 dictionar-ies on the dictionary stack defines the environment for all 
 implicit name searches, such as those that occur when the interpreter 
 encounters an execut-able name. The role of the dictionary stack is 
 introduced in Section 3.3, “Data Types and Objects,” and is further 
 explained in Section 3.5, “Execution.”",NA
•,"The 
 execution stack
  holds executable objects (mainly procedures and 
 files) that are in intermediate stages of execution. At any point in the 
 execution of a Post-Script program, this stack represents the program’s 
 call stack. Whenever the in-terpreter suspends execution of an object to 
 execute some other object, it pushes the 
 new
  object on the execution 
 stack. When the interpreter finishes ex-ecuting an object, it pops that 
 object off the execution stack and resumes exe-cuting the suspended 
 object beneath it.",NA
•,"The operand stack is directly under the control of the PostScript program 
 being 
  
 executed. Objects may be pushed and popped arbitrarily by various 
 operators.",NA
•,"The dictionary stack is also under PostScript program control, but it can 
 hold only dictionaries. The bottom three dictionaries on the stack—
 systemdict
 , 
 globaldict
 , and 
 userdict
 —(or the bottom two, in LanguageLevel 
 1) cannot be popped off. The only operators that can alter the dictionary 
 stack are 
 begin
 , 
 end
 , and 
 cleardictstack
 .",NA
•,"The execution stack is under the control of the PostScript interpreter. It can 
 be 
  
 read but not directly modified by a PostScript program. 
  
 When an object is pushed on a stack, the 
 object
  is copied onto the stack 
 from wherever it was obtained; however, in the case of a composite object 
 (such as an array, a string, or a dictionary), the object’s 
 value
  is not copied 
 onto the stack, but rather is shared with the original object. Similarly, when 
 a composite object is popped off a stack and put somewhere, only the object 
 itself is moved, not its value. See Section 3.3, “Data Types and Objects,” for 
 more details. 
  
 The maximum capacity of stacks may be limited; see Appendices B and C.",NA
3.5 Execution,"Execution semantics are different for each of the various object types. Also, 
 exe-cution can be either 
 immediate
 , occurring as soon as the object is 
 created by the scanner, or 
 deferred
  to some later time. 
  
 3.5.1 Immediate Execution
  
 Some example PostScript program fragments will help clarify the concept 
 of exe-cution. Example 3.1 illustrates the immediate execution of a few 
 operators and operands to perform some simple arithmetic. 
  
 Example 3.1
  
 40 60 add 2 div",NA
•,"An 
 executable array
  or 
 executable packed array
  (procedure) object is 
 pushed on the operand stack if it is encountered directly by the 
 interpreter. If it is invoked 
 indirectly
  as a result of executing some other 
 object (a name or an operator), it is 
 called
  instead. The interpreter calls a 
 procedure by pushing it on the execu-tion stack and then executing the 
 array elements in turn. When the interpreter reaches the end of the 
 procedure, it pops the procedure object off the execution stack. (Actually, 
 it pops the procedure object when there is one element remaining and 
 then pushes that element; this permits unlimited depth of “tail recursion” 
 without overflowing the execution stack.)",NA
•,"An 
 executable string
  object is pushed on the execution stack. The 
 interpreter then uses the string as a source of characters to be converted 
 to tokens and interpreted according to the PostScript syntax rules. This 
 continues until the interpreter reaches the end of the string. Then it pops 
 the string object from the execution stack.",NA
•,"An 
 executable file
  object is treated much the same as a string: The 
 interpreter pushes it on the execution stack. It reads the characters of the 
 file and interprets them as PostScript tokens until it encounters end-of-
 file. Then it closes the file and pops the file object from the execution 
 stack. See Section 3.8, “File Input and Output.”",NA
•,"An 
 executable name
  object is looked up in the environment of the current 
 dic-tionary stack and its associated value is executed. The interpreter 
 looks first in the top dictionary on the dictionary stack and then in other 
 dictionaries suc-",NA
•,"An 
 executable operator
  object causes the interpreter to perform one of the 
 built-
  
 in operations described in this book.",NA
•,"An 
 executable null
  object causes the interpreter to perform no action. In 
 partic-
  
 ular, it does 
 not
  push the object on the operand stack.",NA
3.6 Overview of Basic Operators,"This is an overview of the general-purpose PostScript operators, excluding 
 all op-erators that deal with graphics and fonts, which are described in later 
 chapters. The information here is insufficient for actual programming; it is 
 intended only to acquaint you with the available facilities. For complete 
 information about any particular operator, you should refer to the 
 operator’s detailed description in Chapter 8. 
  
 3.6.1 Stack Operators
  
 The operand stack is the PostScript interpreter’s mechanism for passing 
 argu-ments to operators and for gathering results from operators. It is 
 introduced in Section 3.4, “Stacks.” 
  
 There are various operators that rearrange or manipulate the objects on 
 the oper-and stack. Such rearrangement is often required when the results 
 of some opera-tors are to be used as arguments to other operators that 
 require their operands in a different order. These operators manipulate 
 only the objects themselves; they do not copy the values of composite 
 objects.",NA
•,"dup
  duplicates an object.",NA
•,"exch
  exchanges the top two elements of the stack.",NA
•,"pop 
 removes the top element from the stack.",NA
•,"copy
  duplicates portions of the operand stack.",NA
•,"roll
  treats a portion of the stack as a circular queue.",NA
•,"index
  accesses the stack as if it were an indexable array.",NA
•,"mark
  marks a position on the stack.",NA
•,"clear 
 clears the stack.",NA
•,"count 
 counts the number of elements on the stack.",NA
•,"counttomark
  counts the elements above the highest mark. This is used 
 prima-
  
 rily for array construction (described later), but has other 
 applications as well.",NA
•,"cleartomark
  removes all elements above the highest mark and then removes 
  
 the mark itself. 
  
 3.6.2 Arithmetic and Mathematical Operators
  
 The PostScript language includes a conventional complement of arithmetic 
 and mathematical operators. In general, these operators accept either 
 integer or real number objects as operands. They produce either integers or 
 real numbers as results, depending on the types of the operands and the 
 magnitude of the results. If the result of an operation is mathematically 
 meaningless or cannot be repre-sented as a real number, an 
 undefinedresult
  
 error occurs.",NA
•,"add
 , 
 sub
 , 
 mul
 , 
 div
 , 
 idiv
 , and 
 mod
  are arithmetic operators that take two argu-
  
 ments.",NA
•,"abs
 , 
 neg
 , 
 ceiling
 , 
 floor
 , 
 round
 , and 
 truncate
  are arithmetic operators that take 
  
 one argument.",NA
•,"sqrt
 , 
 exp
 , 
 ln
 , 
 log
 , 
 sin
 , 
 cos
 , and 
 atan
  are mathematical and trigonometric func-
  
 tions.",NA
•,"rand
 , 
 srand
 , and 
 rrand
  access a pseudo-random number generator. 
  
 3.6.3 Array, Packed Array, Dictionary, and String Operators
  
 A number of operators are 
 polymorphic
 : they may be applied to operands of 
 sev-eral different types and their precise functions depend on the types of 
 the oper-ands. Except where indicated otherwise, the operators listed 
 below apply to any of the following types of composite objects: arrays, 
 packed arrays, dictionaries, and strings.",NA
•,"get
  takes a composite object and an index (or a key, in the case of a 
 dictionary) 
  
 and returns a single element of the object.",NA
•,"put
  stores a single element in an array, dictionary, or string. This operator 
 does not apply to packed array objects, because they always have read-
 only (or even more restrictive) access.",NA
•,"copy
  copies the 
 value
  of a composite object to another composite object of 
 the same type, replacing the second object’s former value. This is 
 different from merely copying the object. See Section 3.3.1, “Simple and 
 Composite Objects”for a discussion of copying objects.",NA
•,"length
  returns the number of elements in a composite object.",NA
•,"forall
  accesses all of the elements of a composite object in sequence, calling 
 a 
  
 procedure for each one.",NA
•,"getinterval
  creates a new object that shares a subinterval of an array, a 
 packed 
  
 array, or a string. This operator does not apply to dictionary 
 objects.",NA
•,"putinterval
  overwrites a subinterval of one array or string with the 
 contents of another. This operator does not apply to dictionary or packed 
 array objects, al-though it can overwrite a subinterval of an array with 
 the contents of a packed array. 
  
 In addition to the polymorphic operators, there are operators that apply to 
 only one of the array, packed array, dictionary, and string types. For each 
 type, there is an operator (
 array
 , 
 packedarray
 , 
 dict
 , 
 string
 ) that creates a new 
 object of that type and a specified length. These four operators explicitly 
 create new composite object values, consuming virtual memory (VM) 
 resources (see Section 3.7.1,“Virtual Memory”). Most other operators read 
 and write the values of composite objects but do not create new ones. 
 Operators that return composite results usu-ally require an operand that is 
 the composite object into which the result values are to be stored. The 
 operators are organized this way to give programmers maxi-mum control 
 over consumption of VM. 
  
 Array, packed array, and string objects have a fixed length that is specified 
 when the object is created. In LanguageLevel 1, dictionary objects also have 
 this proper-ty. In LanguageLevels 2 and 3, a dictionary’s capacity can grow 
 beyond its initial allocation.",NA
•,"aload
  and 
 astore
  transfer all the elements of an array to or from the operand 
  
 stack in a single operation. 
 aload
  may also be applied to a packed array.",NA
•,"The array construction operators
 [
 and
 ]
 combine to produce a new array 
 object whose elements are the objects appearing between the brackets. 
 The
 [
 operator, which is a synonym for 
 mark
 , pushes a mark object on the 
 operand stack. Exe-cution of the program fragment between the
 [
  and the
 ]
  
 causes zero or more ob-jects to be pushed on the operand stack. Finally, 
 the 
 ]
  operator counts the number of objects above the mark on the stack, 
 creates an array of that length, stores the elements from the stack in the 
 array, removes the mark from the stack, and pushes the array on the 
 stack.",NA
•,"setpacking
  and 
 currentpacking
 (both LanguageLevel 2)
  control a mode 
 setting that determines the type of procedure objects the scanner 
 generates when it en-counters a sequence of tokens enclosed in 
 {
  and 
 }
 . If 
 the array packing mode is 
 true
 , the scanner produces packed arrays; if 
 the mode is 
 false
 , it produces ordi-nary arrays. The default value is 
 false
 .",NA
•,"Packed array objects always have read-only (or even more restricted) 
 access, so the 
 put
 , 
 putinterval
 , and 
 astore
  operations are not allowed on 
 them. Accessing arbitrary elements of a packed array object can be quite 
 slow; however, access-ing the elements sequentially, as the PostScript 
 interpreter and the 
 forall
  opera-tor do, is efficient. 
  
 The following operators apply only to dictionaries:",NA
•,"begin
  and 
 end
  push new dictionaries on the dictionary stack and pop them off.",NA
•,"def
  and 
 store
  associate keys with values in dictionaries on the dictionary 
 stack; 
  
 load
  and 
 where
  search for keys there.",NA
•,"countdictstack
 , 
 cleardictstack
 , and 
 dictstack
  operate on the dictionary stack.",NA
•,"known
  queries whether a key is present in a specific dictionary.",NA
•,"maxlength
  obtains a dictionary’s maximum capacity.",NA
•,"undef
 (LanguageLevel 2) 
 removes an individual key from a dictionary.",NA
•,"<<
  and 
 >>
 (LanguageLevel 2) 
 construct a dictionary consisting of the 
 bracketed 
  
 objects interpreted as key-value pairs.",NA
•,"search
  and 
 anchorsearch
  perform textual string searching and matching.",NA
•,"token
  scans the characters of a string according to the PostScript language 
 syn-
  
 tax rules, without executing the resulting objects. 
  
 There are many additional operators that use array, dictionary, or string 
 operands for special purposes—for instance, as transformation matrices, 
 font dictionaries, or text. 
  
 3.6.4 Relational, Boolean, and Bitwise Operators
  
 The relational operators compare two operands and produce a boolean 
 result in-dicating whether the relation holds. Any two objects may be 
 compared for equal-ity (
 eq
  and 
 ne
 —equal and not equal); numbers and 
 strings may be compared by the inequality operators (
 gt
 , 
 ge
 , 
 lt
 , and 
 le
 —
 greater than, greater than or equal to, less than, and less than or equal to). 
  
 The boolean and bitwise operators (
 and
 , 
 or
 , 
 xor
 , 
 true
 , 
 false
 , and 
 not
 ) compute 
 logical combinations of boolean operands or bitwise combinations of 
 integer op-erands. The bitwise shift operator 
 bitshift
  applies only to 
 integers. 
  
 3.6.5 Control Operators
  
 The control operators modify the interpreter’s usual sequential execution 
 of ob-jects. Most of them take a procedure operand that they execute 
 conditionally or repeatedly.",NA
•,"if
  and 
 ifelse
  execute a procedure conditionally depending on the value of a 
  
 boolean operand. (
 ifelse
  is introduced in Section 3.5, “Execution.”)",NA
•,"exec
  executes an arbitrary object unconditionally.",NA
•,"for
 , 
 repeat
 , 
 loop
 , and 
 forall
  execute a procedure repeatedly. Several 
 specialized graphics and font operators, such as 
 pathforall
  and 
 kshow
 , behave 
 similarly.",NA
•,"exit
  transfers control out of the scope of any of these looping operators.",NA
•,"countexecstack
  and 
 execstack
  are used to read the execution stack.",NA
•,"type
  returns the type of any operand as a name object (
 integertype
 , 
 realtype
 , 
  
 and so on).",NA
•,"xcheck
 , 
 rcheck
 , and 
 wcheck
  query the literal/executable and access 
 attributes of 
  
 an object.",NA
•,"cvlit
  and 
 cvx
  change the literal/executable attribute of an object.",NA
•,"readonly
 , 
 executeonly
 , and 
 noaccess
  reduce an object’s access attribute. 
 Access 
  
 can only be reduced, never increased.",NA
•,"cvi
  and 
 cvr
  convert between integer and real types, and interpret a numeric 
  
 string as an integer or real number.",NA
•,"cvn
  converts a string to a name object defined by the characters of the string.",NA
•,"cvs
  and 
 cvrs
  convert objects of several types to a printable string 
 representa-
  
 tion.",NA
3.7 Memory Management,"A PostScript program executes in an environment with these major 
 components: stacks, virtual memory, standard input and output files, and the 
 graphics state.",NA
•,"The 
 operand stack
  is working storage for objects that are the operands and 
 re-sults of operators. The 
 dictionary stack
  contains dictionary objects that 
 define",NA
•,"Virtual memory
  (VM) is a storage pool for the values of all composite 
 objects. The adjective “virtual” emphasizes the behavior of this memory 
 visible at the PostScript language level, not its implementation in 
 computer storage.",NA
•,"The 
 standard input file
  is the normal source of program text to be 
 executed by the PostScript interpreter. The 
 standard output file
  is the 
 normal destination of output from the 
 print
  operator and of error 
 messages. Other files can exist as well. See Section 3.8, “File Input and 
 Output.”",NA
•,"The 
 graphics state
  is a collection of parameters that control the production of 
 text and graphics on a raster output device. See Section 4.2, “Graphics State.” 
  
 This section describes the behavior of VM and its interactions with other 
 compo-nents of the PostScript execution environment. It describes facilities 
 for control-ling the environment as a whole. The PostScript interpreter can 
 execute a sequence of self-contained PostScript programs as independent 
 “jobs”; similarly, each job can have internal structure whose components 
 are independent of each other. 
  
 Some PostScript interpreters can support 
 multiple execution contexts
 —the 
 execu-tion of multiple independent PostScript programs at the same time. 
 Each context has an environment consisting of stacks, VM, graphics state, 
 and certain other data. Under suitable conditions, objects in VM can be 
 shared among contexts; there are means to regulate concurrent access to 
 the shared objects. 
  
 This edition of this book does not document the multiple contexts 
 extension, although it does indicate which components of a PostScript 
 program’s environ-ment are maintained on a per-context basis. Further 
 information about multiple contexts can be found in the second edition of 
 this book and in the 
 Display Post-Script System
  manuals. 
  
 3.7.1 Virtual Memory
  
 As described in Section 3.3, “Data Types and Objects,” objects may be either 
 sim-ple or composite. A simple object’s value is contained in the object 
 itself. A com-posite object’s value is stored separately; the object contains a 
 reference to it. Virtual memory (VM) is the storage in which the values of 
 composite objects reside.",NA
•,"The scanner allocates storage for each composite literal object that it 
 encoun-ters. Composite literals are delimited by
  (…)
 ,
  <…>
 ,
  <~…~>
 , and 
 {…}.
  The first three produce strings; the fourth produces an executable 
 array or packed array. There also are binary encodings for composite 
 objects.",NA
•,"Some operators explicitly create new composite objects and allocate 
 storage for them. The 
 array
 , 
 packedarray
 , 
 dict
 , 
 string
 , and 
 gstate
  operators 
 create new array, packed array, dictionary, string, and gstate objects, 
 respectively. Also, the bracketing constructs
  […]
  and 
 <<…>>
  create new 
 array and dictionary ob-",NA
•,"Discards all objects in local VM that were created since the corresponding 
 save
 , 
  
 and reclaims the memory they occupied",NA
•,"Resets the values of all composite objects in local VM, except strings, to 
 their 
  
 state at the time of the 
 save",NA
•,"Performs an implicit 
 grestoreall
  operation, which resets the graphics state 
 to its 
  
 value at the time of the 
 save
  (see Section 4.2, “Graphics State”)",NA
•,"Closes files that were opened since the corresponding 
 save
 , so long as 
 those files were opened while local VM allocation mode was in effect (see 
 Section 3.8,“File Input and Output”) 
  
 The effects of 
 restore
  are limited to the ones described above. In particular, 
 restore 
 does not:",NA
•,"Affect the contents of the operand, dictionary, and execution stacks. If a 
 stack contains a reference to a composite object in local VM that would be 
 discarded by the 
 restore
  operation, the 
 restore
  is not allowed; an 
 invalidrestore
  error oc-curs.",NA
•,"Affect any objects that reside in global VM, except as described in Section 
 3.7.7,
  
 “Job Execution Environment.”",NA
•,"Undo side effects outside VM, such as writing data to files or rendering 
 graph-ics on the raster output device. (However, the implicit 
 grestoreall
  
 may deacti-vate the current device, thereby erasing the current page; see 
 Section 6.2.6,“Device Initialization and Page Setup,” for details.)
  
 The
  save
  and 
 restore
  operators can be nested to a limited depth (see 
 Appendix B for implementation limits). A PostScript program can use 
 save
  
 and 
 restore
  to en-capsulate the execution of an embedded program that also 
 uses 
 save
  and 
 restore
 . 
  
 save
  and 
 restore
  are intended for use in structured programs such as page 
 de-scriptions. The conventions for structuring programs are introduced in 
 Section 2.4.2, “Program Structure,” and described in detail in Adobe 
 Technical Note #5001, 
 PostScript Language Document Structuring 
 Conventions Specification
 .
  
 In such programs, 
 save
  and 
 restore
  serve the following functions:",NA
•,"A document consists of a prolog and a script. The prolog contains 
 definitions that are used throughout the document. The script consists of 
 a sequence of in-dependent pages. Each page has a 
 save
  at the beginning 
 and a 
 restore
  at the end, immediately before the 
 showpage
  operator. Each 
 page begins execution with the initial conditions established in local VM 
 by the prolog. There are no unwanted legacies from previous pages.",NA
•,"A page sometimes contains additional substructure, such as embedded 
 illustra-tions, whose execution needs to be encapsulated. The 
 encapsulated program can make wholesale changes to the contents of 
 local VM to serve its own pur-poses. By bracketing the program with 
 save
  
 and 
 restore
 , the enclosing program can isolate the effects of the embedded 
 program.",NA
•,"As a PostScript program executes, new composite objects accumulate in 
 local VM. These include objects created by the scanner, such as literal 
 string tokens, and objects allocated explicitly by operators. The 
 restore
  
 operator reclaims all local VM storage allocated since the corresponding 
 save
 ; executing 
 save
  and 
 restore
  periodically ensures that unreclaimed 
 objects will not exhaust available VM resources. In LanguageLevel 1, 
 save
  
 and 
 restore
  are the 
 only
  way to reclaim VM storage. Even in higher 
 LanguageLevels, explicit reclamation by 
 save
  and 
 restore
  is much more 
 efficient than automatic reclamation (described in Section 3.7.4, “Garbage 
 Collection”).",NA
•,"The PostScript interpreter uses 
 save
  and 
 restore
  to encapsulate the execution 
 of individual jobs, as described in Section 3.7.7, “Job Execution Environment.”",NA
•,"systemdict
 , a global dictionary that is permanently read-only and contains 
  
 mainly operators",NA
•,"globaldict
 (LanguageLevel 2)
 , a global dictionary that is writeable",NA
•,"userdict
 , a local dictionary that is writeable 
  
 There are other standard dictionaries that are the values of permanent 
 named en-tries in 
 systemdict
 . Some of these are in local VM and some in 
 global VM, as shown in Tables 3.3 and 3.4. 
  
 A PostScript program can also create new dictionaries in either local or 
 global VM, then push them on the dictionary stack or store them as entries 
 in 
 userdict 
 or 
 globaldict
 . 
  
 TABLE 3.3 
 Standard local dictionaries
  
 DICTIONARY
  
 DESCRIPTION
  
 userdict
  
 Standard writeable local dictionary. Initially, it is the top dictionary
  
 on the dictionary stack, making it the current dictionary. 
  
 errordict 
  
 Error dictionary. See Section 3.11, “Errors.” 
  
 $error 
  
 Dictionary accessed by the built-in error-handling procedures to 
  
 store stack snapshots and other information. See Section 3.11,
  
 “Errors.” 
  
 statusdict 
  
 Dictionary for product-specific operators and other definitions. 
 See 
  
 Chapter 8. 
  
 FontDirectory 
  
 Dictionary for font definitions. It is normally read-only, but is 
  
 updated by 
 definefont
  and consulted by 
 findfont
 . See Sections 3.9,
  
 “Named Resources,” and 5.2, “Font Dictionaries.”",NA
•,"Objects that are created during the prolog can be in either local or global 
 VM; in either case, they will exist throughout the job, since they are 
 defined outside the 
 save
  and 
 restore
  that enclose individual pages of the 
 script. A dictionary in local VM reverts to the initial state defined by the 
 prolog at the end of each page. This is usually the desirable behavior. A 
 dictionary in global VM accumu-",NA
•,"When using a writeable dictionary in global VM, you must be careful 
 about what objects you store in it. Attempting to store a local composite 
 object in a global dictionary will cause an 
 invalidaccess
  error. For this 
 reason, it is advis-able to segregate local and global data and to use global 
 VM only for those ob-jects that must persist through executions of 
 save
  
 and 
 restore
 .",NA
•,"In general, the prologs for most existing PostScript programs do not work 
 cor-rectly if they are simply loaded into global VM. The same is true of 
 some fonts, particularly Type 3 fonts. These programs must be altered to 
 define global and local information separately. Typically, global VM 
 should be used to hold pro-cedure definitions and constant data; local VM 
 should be used to hold tempo-rary data needed during execution of the 
 procedures.",NA
•,"Creating gstate (graphics state) objects in global VM is particularly risky. 
 This is because the graphics state almost always contains one or more 
 local objects, which cannot be stored in a global gstate object (see the 
 currentgstate
  operator in Chapter 8). 
  
 3.7.6 User Objects
  
 Some applications require a convenient and efficient way to refer to 
 PostScript objects previously constructed in VM. The conventional way to 
 accomplish this is to store such objects as named entries in dictionaries and 
 later refer to them by name. In a PostScript program written by a 
 programmer, this approach is natural and straightforward. When the 
 program is generated mechanically by another program, however, it is 
 more convenient to number the objects with small inte-gers and later refer 
 to them by number. This technique simplifies the bookkeep-ing the 
 application program must do. 
  
 LanguageLevel 2 provides built-in support for a single space of numbered 
 objects, called 
 user objects
 . There are three operators, 
 defineuserobject
 , 
 undefineuserobject
 , and 
 execuserobject
 , that manipulate an array named 
 UserObjects
 . These operators do not introduce any fundamental capability, 
 but merely provide convenient and efficient notation for accessing the 
 elements of a special array.",NA
•,An empty operand stack,NA
•,"A dictionary stack containing the standard dictionaries—
 systemdict
 , 
  
 globaldict
 (LanguageLevel 2)
 , and 
 userdict",NA
•,"Execution and graphics state stacks reset to their standard initial state, 
 with no 
  
 vestiges of previous jobs",NA
•,The contents of VM (local and global),NA
•,"Miscellaneous interpreter parameters 
  
 During execution, the job may alter its environment. Ordinarily, when a job 
 fin-ishes, the environment reverts to its initial state to prepare for the next 
 job. That is, the job is 
 encapsulated
 . The server accomplishes this 
 encapsulation by execut-ing 
 save
  and 
 restore
  and by explicitly resetting 
 stacks and parameters between jobs. 
  
 With suitable authorization, a job can make persistent alterations to objects 
 in VM. That is, the job is not encapsulated. Instead, its alterations appear as 
 part of the initial state of the next and all subsequent jobs. This is 
 accomplished by means of the 
 startjob
  and 
 exitserver
  facilities, described 
 below. 
  
 Server Operation
  
 A job server is presented with a sequence of files via one or more 
 communication channels. For each file, the server performs the following 
 sequence of steps: 
  
 1. Establish standard input and output file objects for the channel from 
 which the file is to be obtained. The means by which this is done is 
 implementation-dependent. 
  
 2. Execute 
 save
 . This is the outermost 
 save
 , which unlike a normal 
 save
  
 obtains a 
  
 snapshot of the initial state of objects in both local and global VM. 
  
 3. Establish the default initial state for the interpreter: empty operand 
 stack, local VM allocation mode, default user space for the raster output 
 device, and so on. 
  
 4. Execute the standard input file until it reaches end-of-file or an error 
 occurs. If 
  
 an error occurs, report it and flush input to end-of-file.",NA
3.8 File Input and Output,"A 
 file
  is a finite sequence of characters bounded by an end-of-file indication. 
 These characters may be stored permanently in some place (for instance, a 
 disk file) or they may be generated on the fly and transmitted over some 
 communica-tion channel. Files are the means by which the PostScript 
 interpreter receives exe-cutable programs and exchanges data with the 
 external environment. 
  
 There are two kinds of file: input and output. An 
 input file
  is a source from 
 which a PostScript program can read a sequence of characters; an 
 output 
 file
  is a destina-tion to which a PostScript program can write characters. 
 Some files can be both read and written. 
  
 The contents of a file are treated as a sequence of 8-bit bytes. In some cases, 
 those bytes can be interpreted as text characters, such as the ASCII text 
 representing a PostScript program. In other cases, they can be interpreted 
 as arbitrary binary data. In the descriptions of files and file operators, the 
 terms 
 character
  and 
 byte 
 are synonymous. 
  
 3.8.1 Basic File Operators
  
 A PostScript 
 file object
  represents a file. The file operators take a file object 
 as an operand to read or write characters. Ignoring for the moment 
 how
  a 
 file object comes into existence, the file operators include the following:",NA
•,"read
  reads the next character from an input file.",NA
•,"write
  appends a character to an output file.",NA
•,"readstring
 , 
 readline
 , and 
 writestring
  transfer the contents of strings to and 
  
 from files.",NA
•,"readhexstring
  and 
 writehexstring
  read and write binary data represented in 
 the 
  
 file by hexadecimal notation.",NA
•,"token
  scans characters from an input file according to the PostScript 
 language 
  
 syntax rules.",NA
•,"exec
 , applied to an input file, causes the PostScript interpreter to execute a 
  
 PostScript program from that file. 
  
 The operators that write to a file do not necessarily deliver the characters 
 to their destination immediately. They may leave some characters in 
 buffers for reasons of implementation or efficiency. The 
 flush
  and 
 flushfile
  
 operators deliver these buffered characters immediately. These operators 
 are useful in certain situations, such as during two-way interactions with 
 another computer or with a human user, when such data must be 
 transmitted immediately. 
  
 Standard Input and Output Files
  
 All PostScript interpreters provide a 
 standard input file
  and a 
 standard 
 output file
 , which usually represent a real-time communication channel to 
 and from another computer. The standard input and output files are always 
 present; it is not neces-sary for a program to create or close them. 
  
 The PostScript interpreter reads and interprets the standard input file as 
 Post-Script program text. It sends error and status messages to the 
 standard output file. Also, a PostScript program may execute the 
 print
  
 operator to send arbitrary data to the standard output file. Note that 
 print
  is 
 a 
 file
  operator; it has nothing to do with placing text on a page or causing 
 pages to emerge from a printer. 
  
 It is seldom necessary for a PostScript program to deal explicitly with file 
 objects for the standard files, because the PostScript interpreter reads the 
 standard input file by default and the 
 print
  operator references the 
 standard output file implicit-ly. Additionally, the file currently being read 
 by the PostScript interpreter is avail-able via the 
 currentfile
  operator; this 
 file need not be the standard input file. However, when necessary, a 
 program may apply the 
 file
  operator to the identify-ing strings 
 %stdin 
 or 
 %stdout 
 to obtain file objects for the standard input and output files; see 
 Section 3.8.3, “Special Files.” 
  
 End-of-Line Conventions
  
 The PostScript language scanner and the 
 readline
  operator recognize all 
 three ex-ternal forms of end-of-line (EOL)—CR alone, LF alone, and the CR-
 LF pair—and treat them uniformly, translating them as described below. 
 The PostScript interpreter does not perform any such translation when 
 reading data by other means or when writing data by any means.",NA
•,"Any of the three forms of EOL appearing in a literal string is converted to 
 a sin-gle LF character in the resulting string object. These three examples 
 produce identical string objects, each with an LF character following the 
 second word in the string: 
  
 (any text
 )
 CR
 
 some more text) 
  
 (any text
 )
 LF
 
 some more text) 
  
 (any text
 )
 CR
 )
 LF
 
 some more 
 text)",NA
•,"Any of the three forms of EOL appearing immediately after
  \ 
 in a string is 
 treated as a line continuation; both the
  \ 
 and the EOL are discarded. 
 These four examples produce identical string objects: 
  
 (any text \
 )
 CR
 
 some more text) 
  
 (any text \
 )
 LF
 
 some more text) 
  
 (any text \
 )
 CR
 )
 LF
 
 some more 
 text)
  
 (any text some more text)",NA
•,"Any of the three forms of EOL appearing outside a string is treated as a 
 single white-space character. Since the language treats multiple white-
 space charac-ters as a single white-space character, the treatment of EOL 
 is interesting only when a PostScript token is followed by data to be read 
 explicitly by one of the file operators. The following three examples 
 produce identical results: the oper-ator reads the character
  x 
 from the 
 current input file and leaves its character code (the integer 120) on the 
 stack. 
  
 currentfile read
 )
 CR
 
 x 
  
 currentfile read
 )
 LF
 
 x 
  
 currentfile 
 read
 )
 CR
 )
 LF
 
 x",NA
•,"The 
 readline
  operator treats any of the three forms of EOL as the 
 termination 
  
 condition.",NA
•,"Data read by 
 read
  and 
 readstring
  does not undergo EOL translation: the 
 Post-Script interpreter reads whatever characters were received from 
 the channel. The same is true of data written by 
 write
  and 
 writestring
 : 
 whatever characters the interpreter provides are sent to the channel. 
 However, in either case the channel itself may perform some EOL 
 translation, as discussed below.",NA
•,"Communicate with the interpreter via binary channels exclusively. Some 
 chan-nels, such as LocalTalk and Ethernet, are binary by nature. They do 
 not pre-empt any character codes, but instead communicate control 
 information separately from the data. Other channels, such as serial 
 channels, may support a binary communication protocol that allows 
 control characters to be quoted. This approach presupposes a well-
 controlled environment. PostScript pro-grams produced in that 
 environment may not be portable to other environ-ments.",NA
•,"Take advantage of filters for encoding binary data as ASCII text. Filters 
 are a LanguageLevel 2 feature, described in Section 3.8.4, “Filters.” 
 Programs repre-sented in this way do not include any control codes and 
 are therefore portable to any LanguageLevel 2 or 3 interpreter in any 
 environment.",NA
•,"%
 device
 %
 file
  identifies a named file on a specific device, as described above.",NA
•,"file
  (first character not
  %
 ) identifies a named file on an unspecified device, 
 which is selected by an environment-specific search rule, as described above.",NA
•,"%
 device 
 or
 %
 device
 %
  identifies an unnamed file on the device. Certain 
 devices, such as cartridges, support a single unnamed file as opposed to a 
 collection of named files. Other devices represent communication 
 channels rather than per-manent storage media. There are also special 
 files named
  %stdin
 , 
 %stdout
 , 
 %stderr
 ,
  %statementedit
 , and 
 %lineedit
 , 
 described in Section 3.8.3, “Special Files.” The 
 deletefile
 , 
 renamefile
 , and 
 filenameforall
  operators do not apply to file names of this form. 
  
 “Wildcard” file names are recognized by the 
 filenameforall
  operator; see 
 filenameforall
  in Chapter 8 for more information.",NA
•,"%stdin
 , the standard input file.",NA
•,"%stdout
 , the standard output file.",NA
•,"%stderr
 , the standard error file. This file is for reporting low-level errors. In 
  
 many configurations, it is the same as the standard output file.",NA
•,"%statementedit
 , the statement editor filter file, described below.",NA
•,"%lineedit
 , the line editor filter file, described below.",NA
•,"The 
 file
  operator begins reading characters from the standard input file 
 and storing them in a temporary buffer. While doing so, it echoes the 
 characters to the standard output file. It also interprets certain control 
 characters as editing functions for making corrections, as described in 
 Section 2.4.4.",NA
•,"When a complete statement has been entered, the 
 file
  operator returns. A 
 state-ment consists of one or more lines terminated by a newline that 
 together form one or more complete PostScript tokens, with no opening 
 brackets (
 {
 ,
  (
 , 
 <
 , or 
 <~
 ) left unmatched. A statement is also considered 
 complete if it con-tains a syntax error.",NA
•,"The returned file object represents a temporary file containing the 
 statement that was entered, including the terminating end-of-line 
 character. Reading from this file obtains the characters of the statement 
 in turn; end-of-file is re-ported when the end of the statement is reached. 
 Normally, this file is used as an operand to the 
 exec
  operator, causing the 
 statement to be executed as a PostScript program. 
  
 The 
 %lineedit
  special file is similar to
  %statementedit
 , except that when 
 reading from 
 %lineedit
 , the 
 file
  operator returns after a single line has been 
 entered, whether or not it constitutes a complete statement. For both the 
 special files 
 %statementedit
  and 
 %lineedit
 , if the standard input file reaches 
 end-of-file before",NA
•,"ASCII encoding and decoding filters
  enable arbitrary 8-bit binary data to 
 be rep-resented in the printable subset of the ASCII character set. This 
 improves the portability of the resulting data, since it avoids the problem 
 of interference by operating systems or communication channels that 
 preempt the use of control characters, represent text as 7-bit bytes, or 
 impose line-length restrictions.",NA
•,"Compression and decompression filters
  enable data to be represented in a 
 com-pressed form. Compression is particularly valuable for large 
 sampled images, since it reduces storage requirements and transmission 
 time. There are several compression filters, each of which is best suited 
 for particular kinds of data. Note that the compressed data is in 8-bit 
 binary format, even if the original data happens to be ASCII text. For 
 maximum portability of the encoded data,",NA
•,"Subfile filters
  pass data through without modification. These filters permit 
 the creation of file objects that access arbitrary user-defined data sources 
 or data targets. Input filters also can read data from an underlying file up 
 to a specified end-of-data marker. 
  
 Table 3.6 summarizes the available filters. A program can determine the 
 complete set of filters that the PostScript interpreter supports by applying 
 the 
 resourceforall
  operator to the 
 Filter
  resource category; see Section 3.9, 
 “Named Resources.” 
  
 TABLE 3.6 Standard filters
  
 FILTER NAME
  
 REQUIRED
  
 DESCRIPTION
  
 PARAMETERS
  
 ASCIIHexEncode
  
 (none)
  
 Encodes binary data in an ASCII hexadecimal representation. 
 Each
  
 binary data byte is converted to two hexadecimal digits, 
 resulting in an expansion factor of 1:2 in the size of the encoded 
 data. 
  
 ASCIIHexDecode
  
 (none)
  
 Decodes ASCII hexadecimal-encoded data, producing the original
  
 binary data. 
  
 ASCII85Encode
  
 (none)
  
 Encodes binary data in an ASCII base-85 representation. This 
 encod-
  
 ing uses nearly all of the printable ASCII character set. The 
 resulting expansion factor is 4:5, making this encoding much 
 more efficient than hexadecimal. 
  
 ASCII85Decode
  
 (none)
  
 Decodes ASCII base-85 data, producing the original binary data. 
  
 LZWEncode
  
 (none)
  
 Compresses data using the LZW (Lempel-Ziv-Welch) adaptive 
 com-
  
 pression method, optionally after pretransformation by a 
 predictor function. This is a good general-purpose encoding that 
 is especially well suited for natural-language and PostScript-
 language text, but it is also useful for image data. 
  
 LZWDecode
  
 (none)
  
 Decompresses LZW-encoded data, producing the original data. 
  
 FlateEncode
  
 (none)
  
 (LanguageLevel 3) 
 Compresses data using the public-domain 
 zlib/de-
  
 flate compression method, optionally after pretransformation 
 by a predictor function. This is a variable-length Lempel-Ziv 
 adaptive compression method cascaded with adaptive Huffman 
 coding. It is a good general-purpose encoding that is especially 
 well suited for natural-language and PostScript-language text, 
 but it is also useful for image data.",NA
•,"status
  and 
 bytesavailable
  return status information about a file.",NA
•,"currentfile
  returns the file object from which the interpreter is currently 
 read-
  
 ing.",NA
•,"run
  is a convenience operator that combines the functions of 
 file
  and 
 exec
 . 
  
 Several built-in procedures print the values of objects on the operand stack, 
 send-ing a readable representation of those values to the standard output 
 file:",NA
•,"=
  pops one object from the operand stack and writes a text 
 representation of its 
  
 value to the standard output file, followed by a 
 newline.",NA
•,"==
  is similar to
  =
 , but produces results closer to full PostScript language 
 syntax 
  
 and expands the values of arrays.",NA
•,"stack
  prints the entire contents of the operand stack with 
 =
 , but leaves the 
 stack 
  
 unchanged.",NA
•,"pstack
  performs a similar operation to 
 stack
 , but uses
  ==
 . 
  
 Input/output and storage devices can be manipulated individually by 
 LanguageLevel 2 operators. In particular:",NA
•,"setdevparams
  and 
 currentdevparams
  access device-dependent parameters 
 (see 
  
 Appendix C).",NA
•,"resourceforall
 , applied to the 
 IODevice
  resource category, enumerates all 
 avail-
  
 able device parameter sets (see the next section).",NA
3.9 Named Resources,"Some features of the PostScript language involve the use of open-ended col-
 lections of objects to control their operation. For example, the font 
 machinery uses font dictionaries that describe the appearance of 
 characters. The number of possible font dictionaries is unlimited. In 
 LanguageLevels 2 and 3, this same idea",NA
•,"The application or print spooler embeds the objects’ definitions directly in 
 the 
  
 job stream.",NA
•,"During execution, the PostScript program requests the objects by name. 
 The interpreter loads them into VM automatically from an external 
 source, such as a disk file, a ROM cartridge, or a network file server. 
  
 The notion of 
 named resources(LanguageLevel 2)
  supports the second 
 method. A 
 resource
  is a collection of named objects that either reside in VM 
 or can be located and brought into VM on demand. There are separate 
 categories of resources with independent name spaces; for example, fonts 
 and forms are distinct resource cat-egories. Within each category, there is a 
 collection of named resource instances. Each category can have its own 
 policy for locating instances that are not in VM and for managing the 
 instances that are in VM. 
  
 3.9.1 Resource Operators
  
 There are five LanguageLevel 2 operators that apply to resources: 
 findresource
 , 
 resourcestatus
 , 
 resourceforall
 , 
 defineresource
 , 
 and 
 undefineresource
 . A more limited pair of operators applicable only to fonts, 
 findfont
  and 
 definefont
 , are available in LanguageLevel 1.",NA
•,"findfont
 , equivalent to
 /Font findresource",NA
•,"definefont
 ,
  equivalent to 
 /Font defineresource",NA
•,"undefinefont
 , equivalent to
 /Font undefineresource
  
 The 
 definefont
  and 
 undefinefont
  operators have additional font-specific 
 seman-tics, which are described under those operators in Chapter 8. Those 
 semantics also apply to 
 defineresource
  and 
 undefineresource
  when applied to 
 the
 Font
  cat-egory. 
 findfont
  and 
 definefont
  are available in LanguageLevel 1, 
 even though the general facility for named resources is a LanguageLevel 2 
 feature. 
  
 The font operators also maintain dictionaries of font names and 
 Font
  
 resource instances that are defined in VM. Those dictionaries are 
 FontDirectory
  (all 
 Font 
 resources in VM) and 
 GlobalFontDirectory
  (only 
 Font
  
 resources in global VM). They are obsolete, but are provided for 
 compatibility with existing applications.
  
 The preferred method of enumerating all available 
 Font
  resources is 
  
 (*) 
 procscratch
  /Font resourceforall
  
 where 
 proc
  is a procedure and 
 scratch
  is a string used repeatedly to hold 
 font names. This method works for all available 
 Font
  resources, whether or 
 not they are in VM. Normally, it is preferable to use 
 resourcestatus
  to 
 determine the avail-ability of specific resources rather than enumerate all 
 resources and check wheth-er those of interest are in the list. 
  
 When 
 findresource
  or 
 findfont
  loads a font from an external source into VM, 
 it may choose to use global VM rather than the current VM allocation mode. 
 This choice depends on memory management algorithms used by the 
 interpreter. It also depends on the font type, since certain Type 3 fonts do 
 not work correctly when loaded into global VM. The details of this policy 
 are implementation-dependent; a PostScript program should not depend 
 on knowing what they are.",NA
•,"StandardEncoding
 , whose value is the same as the array returned by 
  
 /StandardEncoding /Encoding findresource",NA
•,"ISOLatin1Encoding
 , whose value is the same as the array returned by 
  
 /ISOLatin1Encoding /Encoding findresource
  
 If any other encodings exist, they are available only through 
 findresource
 . The 
 convenience operator 
 findencoding
  is equivalent to 
 /Encoding findresource. 
  
 Form
  
 Instances of the 
 Form
  resource category are form dictionaries, described in 
 Section 4.7, “Forms.” A form dictionary is suitable as the operand to the 
 execform
  operator to render the form on the page. 
  
 Pattern
  
 Instances of the 
 Pattern
  resource category are prototype pattern 
 dictionaries, de-scribed in Section 4.9, “Patterns.” A prototype pattern 
 dictionary is suitable as the operand to the 
 makepattern
  operator, which 
 produces a transformed pattern dictionary; a PostScript program can then 
 use the resulting dictionary in painting operations by establishing a 
 Pattern
  
 color space or by invoking the 
 setpattern
  op-erator. 
  
 ProcSet
  
 Instances of the 
 ProcSet
  resource category are 
 procedure sets
 . A procedure 
 set is a dictionary containing named procedures or operators. Application 
 prologs can be organized as one or more procedure sets that are available 
 from a library instead of being included in-line in every document that uses 
 them. The 
 ProcSet 
 resource category provides a way to organize such a 
 library. 
  
 In LanguageLevel 3, there are several standard instances of the 
 ProcSet
  
 category that are associated with specific features of the PostScript 
 language. These proce-dure sets, listed in Table 3.10, contain procedures, 
 operators, and other objects that a PostScript program can access as part of 
 using those features.",NA
•,"Instances of 
 ControlLanguage
  are dictionaries that describe the control 
 lan-guages available in a product. A control language is a means for 
 controlling product features, such as default configuration and status 
 reporting.",NA
•,"Instances of 
 PDL
  are dictionaries that describe the page description 
 language interpreters available in a product. This category supersedes 
 the 
 Emulator
  im-plicit resource category, because its instances provide a 
 more complete descrip-tion of each interpreter (or emulator).",NA
•,"Instances of 
 Localization
  are dictionaries that describe the natural 
 languages 
  
 (for example, English, Japanese, or German) supported by a 
 product.",NA
•,"Instances of 
 HWOptions
  are strings that indicate the special hardware 
 options 
  
 that are present in this product. 
  
 Implicit Resources
  
 For all implicit resources, the 
 findresource
  operator returns the instance’s 
 key if the instance is defined. The 
 resourcestatus
  and 
 resourceforall
  operators 
 have their normal behavior, although the 
 status
  and 
 size
  values returned by 
 resourcestatus
  are meaningless. The 
 defineresource
  and 
 undefineresource 
 operators are ordinarily not allowed, but the ability to define new instances 
 of implicit resources may exist in some implementations. The mechanisms 
 are implementation-dependent. 
  
 The instances of the 
 Filter
  category are filter names, such as 
 ASCII85Decode
  
 and 
 RunLengthEncode
 , which are used as an operand of the 
 filter
  operator to 
 deter-mine its behavior. Filters are described in Section 3.8.4, “Filters.” 
  
 The instances of the 
 ColorSpaceFamily
  category are color space family 
 names, which appear as the first element of a color space array object. 
 Some color spaces, such as 
 DeviceRGB
 , are completely determined by their 
 family name; others, such as
 CIEBasedABC
 , require additional parameters to 
 describe them. Color spaces are described in Section 4.8, “Color Spaces.” 
  
 The instances of the
 Emulator
  category are names of emulators for 
 languages other than PostScript that may be built into a particular 
 implementation. Those emulators are not a standard part of the PostScript 
 language, but one or more of them may be present in some products. This 
 category has been superseded by the 
 PDL
  resource category in 
 LanguageLevel 3. 
  
 The instances of the 
 IODevice
  category are names of device parameter sets. 
 Some parameter sets are associated with input/output devices, from which 
 the category name 
 IODevice
  originates. However, there are also some 
 parameter sets that do not correspond to physical devices. The keys for all 
 instances of this category are expressed as strings of the form 
 %
 device
 %
 . 
 See Section C.4, “Device Parameters.” 
  
 The instances of the 
 ColorRenderingType
 , 
 FMapType
 , 
 FontType
 , 
 FormType
 , 
 HalftoneType
 , 
 ImageType
 , 
 PatternType
 , 
 FunctionType
 , 
 ShadingType
 , and 
 TrappingType 
 categories are integers that are the acceptable values for the 
 corre-spondingly named entries in various classes of special dictionaries. 
 For example, in LanguageLevel 3 the 
 FMapType
  category includes the 
 integers 1 through 9 as",NA
•,The category does not maintain all of its instances as named files.,NA
•,The operator tried to delete a file from a read-only file system.,NA
•,"The operator tried to write to a file system with insufficient space. 
  
 There may be a limit on the length of a resource file name, which in turn 
 imposes a length limit on the instance name. The inherent limit on resource 
 instance names is the same as that on name objects in general (see 
 Appendix B). By con-vention, font names are restricted to fewer than 40 
 characters. This convention is recommended for other resource categories 
 as well. Note that the resource file name may be longer or shorter than the 
 resource instance name, depending on details of the name-mapping 
 algorithm. When calling 
 ResourceFileName
 , it is prudent to provide a scratch 
 string at least 100 characters long. 
  
 Some implementations provide additional control over the behavior of 
 ResourceFileName
 ; see Section C.3.6, “Resource File Location.” 
  
 A resource file contains a PostScript program that can be executed to load 
 the re-source instance into VM. The last action the program should take is 
 to execute 
 defineresource
  or an equivalent operator, such as 
 definefont
 , to 
 associate the resource instance with a category and a name. In other words, 
 each resource file must be self-identifying and self-defining. The resource 
 file must be well behaved: it must leave the stacks in their original state and 
 it must not execute any opera-tors (graphics operators, for instance) that 
 are not directly related to creating the resource instance.",NA
•,"Some implementations of the 
 Font
  category’s 
 FindResource
  procedure 
 omit ex-ecuting 
 truesetglobal
  before executing the font file. This causes 
 fonts to be defined in the VM allocation mode in effect when 
 findresource
  
 is invoked, rather than always in global VM. Details of this policy are 
 implementation-dependent.",NA
•,"If a particular resource instance is known not to work in global VM, the re-
  
 source file should begin with an explicit 
 falsesetglobal
 . 
  
 A resource file can contain header comments, as specified in Adobe Technical 
 Note #5001, 
 PostScript Language Document Structuring Conventions 
 Specification
 .
  
 If there is a header comment of the form 
  
 %%VMusage: 
 intint
  
 then the 
 resourcestatus
  operator returns the larger of the two integers as its 
 size 
 result. If the 
 %%VMusage:
  comment is not present, 
 resourcestatus
  may 
 not be able to determine the VM consumption for the resource instance, in 
 which case it will return a size of 
  
 1. 
  
 The definition of an entire resource category—that is, an instance of the 
 Category
  category—can come from a resource file in the normal way. If any 
 re-source operator is presented with an unknown category name, it 
 automatically executes 
  
 category
  /Category findresource
  
 in an attempt to cause the resource category to become defined. Only if that 
 fails will the resource operator generate an 
 undefined
  error to report that 
 the resource category is unknown.",NA
3.10 Functions,"The PostScript language includes operators and procedures that take 
 arguments off the operand stack and put their results back on the stack. 
 The 
 add
  operator, for example, pops two arguments, which must be 
 numbers, and pushes the sum of those numbers back on the stack. 
 add
  
 could be viewed as a function with two input values and one output value: 
  
 f x
 0
  x
 1 
 ( 
  
 )
  
 =
  
 x
 0
  
 + 
 x
 1
  
 Similarly, the following procedure computes the average and the square root 
 of the product of two numbers: 
  
 { 
  
 2 copy add 
  
  
 2 div 
  
  
 3 1 roll 
 mul 
  
  
 sqrt 
  
 }
  
 This could be viewed as a function of two input values and two output values: 
  
 f x
 0
  x
 1 
 ( 
  
 )
  
 =
  
 x
 0
 -----
 --------
 ----+ 
 x
 1
  
 2
  
 
  
 x
 0
  
  
 x
 1
  
 In general, a function can take any number (
 m
 ) of input values and produce 
 any number (
 n
 ) of output values: 
  
 f x
 0
  
  x
 m
  
 –
 1
  
 )
  
 =
  
 y
 0
  
  y
 n
  
 –
 1
  
 LanguageLevel 3 supports an explicit, static representation for functions, 
 known as 
 function dictionaries
 . Functions are less general than PostScript 
 procedures: all the input values and all the output values are numbers, and 
 functions have no side effects. On the other hand, functions can be 
 considerably more efficient than procedures, since they entail no PostScript 
 operator execution. 
  
 At present, there is only one use for functions in the PostScript language: 
 they are used to define the color values in a shading pattern (see Section 
 4.9.3, “Shading Patterns,” and the 
 shfill
  operator in Chapter 8). There is no 
 operator like 
 exec 
 that explicitly calls a function. Functions are also used 
 extensively in PDF, where there are no procedures; for more information, 
 see the 
 Portable Document Format Reference Manual.",NA
•,"A sampled function
  (type 0) uses a table of 
 sample values
  to represent the 
 func-tion. Various techniques are used to interpolate values between the 
 sample values.",NA
•,"An 
 exponential interpolation function
  (type 2) defines a set of coefficients 
 for an 
  
 exponential function.",NA
•,"A 
 stitching function
  (type 3) is a combination of other functions, partitioned 
  
 across a domain. 
  
 All function dictionaries share the entries listed in Table 3.12. In addition, 
 each type of function dictionary must include attributes appropriate to the 
 particular function type. The number of output values can usually be 
 inferred from other attributes of the function; if not (as is always the case 
 for type 0 functions), the 
 Range
  attribute is required. The dimensionality of 
 the function implied by the 
 Domain
  and 
 Range
  attributes must be consistent 
 with the dimensionality implied by other attributes of the function; 
 otherwise, a 
 rangecheck
  error will occur.",NA
3.11 Errors,"Various sorts of errors can occur during execution of a PostScript program. 
 Some errors are detected by the PostScript interpreter, such as overflow of 
 one of the in-terpreter’s stacks. Others are detected during execution of the 
 built-in operators, such as occurrence of the wrong type of operand.",NA
•,"It can change the way errors are 
 reported
  simply by redefining 
 handleerror
  in 
 errordict
 . For example, a revised error handler might report 
 more information about the context of the error, or it might produce a 
 printed page containing the error information instead of reporting it to 
 the standard output file.",NA
•,"It can change the way errors are 
 invoked
  by redefining the individual 
 error names in 
 errordict
 . There is no restriction on what an error-
 handling proce-dure can do. For example, in an interactive environment, 
 an error handler might invoke a debugging facility that would enable the 
 user to examine or alter the execution environment and perhaps resume 
 execution.",NA
3.12 Early Name Binding,"Normally, when the PostScript language scanner encounters an executable 
 name in the program being scanned, it simply produces an executable name 
 object; it does not look up the value of the name. It looks up the name only 
 when the name object is 
 executed
  by the interpreter. The lookup occurs in 
 the dictionaries that are on the dictionary stack at the time of execution. 
  
 A name object contained in a procedure is looked up each time the procedure 
 is executed. For example, given the definition 
  
 /average {add 2 div} def
  
 the names 
 add
  and 
 div
  are looked up, yielding operators to be executed, every 
 time the 
 average
  procedure is invoked. 
  
 This so-called 
 late binding
  of names is an important feature of the PostScript 
 lan-guage. However, there are situations in which 
 early binding
  is 
 advantageous.",NA
•,"A procedure that has been bound will execute the sequence of operators 
 that were intended when the procedure was defined, even if one or more 
 of the operator names have been redefined in the meantime. This benefit 
 is mainly of interest in procedures that are part of the PostScript 
 implementation, such as 
 findfont
  and 
 =
 . Those procedures are expected to 
 behave correctly and uni-formly, regardless of how a user program may 
 have altered its name environ-ment.",NA
•,"A bound procedure executes somewhat faster than one that has not been 
 bound, since the interpreter need not look up the operator names each 
 time,",NA
3.13 Filtered Files Details,"LanguageLevels 2 and 3 define a special kind of file called a 
 filter
 , which 
 reads or writes an underlying file and transforms the data in some way. 
 Filters are intro-duced in Section 3.8.4, “Filters.” This section describes the 
 semantics of filters in more detail. It includes information about:",NA
•,"The use of files, procedures, and strings as data sources and targets",NA
•,End-of-data conventions,NA
•,Details of individual filters,NA
•,"Specifications of encoding algorithms for some filters 
  
 All features described in this section are LanguageLevel 2 features except for 
 those labeled as LanguageLevel 3. 
  
 3.13.1 Data Sources and Targets
  
 As stated in Section 3.8.4, “Filters,” there are two kinds of filters: 
 decoding
  
 filters and 
 encoding
  filters. A decoding filter is an input file that reads from 
 an underly-ing 
 data source
  and produces transformed data as it is read. An 
 encoding filter is an output file that takes the data written to it and writes 
 transformed data to an underlying 
 data target
 . Data sources and data 
 targets may be files, procedures, or strings.",NA
•,"On the first write to the filter after the 
 filter
  operator creates it, the filter 
 calls the data target procedure with an empty string and the boolean 
 value 
 true
 . The procedure must return a writeable string of nonzero 
 length, into which the fil-ter can write filtered data.",NA
•,"Whenever the filter needs to dispose of accumulated output data, it calls 
 the procedure again, passing it a string containing the data and the 
 boolean value 
 true
 . This string is either the same string that was returned 
 from the previous call or a substring of that string. The procedure must 
 now do whatever is ap-propriate with the data, then return either the 
 same string or another string into which the filter can write additional 
 filtered data.",NA
•,"When the filter file is closed, it calls the procedure a final time, passing it a 
 string or substring containing the remaining output data, if any, and the 
 bool-ean value 
 false
 . The procedure must now do whatever is appropriate 
 with the data and perform any required end-of-data actions, then return 
 a string. Any string (including one of length 0) is acceptable. The filter 
 does not use this string, but merely pops it off the stack. 
  
 It is normal for the data source or target procedure to return the same 
 string each time. The string is allocated once at the beginning and serves 
 simply as a buffer that is used repeatedly. Each time a data source 
 procedure is called, it fills the string with one buffer’s worth of data and 
 returns it. Similarly, each time a data target procedure is called, it first 
 disposes of any buffered data passed to it, then returns the original string 
 for reuse. 
  
 Between successive calls to the data source or target procedure, a program 
 should not do anything that would alter the contents of the string returned 
 by that pro-cedure. The filter reads or writes the string at unpredictable 
 times, so altering it could disrupt the operation of the filter. If the string 
 returned by the procedure is reclaimed by a 
 restore
  operation before the 
 filter becomes closed, the results are unpredictable. Typically, an 
 ioerror
  
 occurs.",NA
•,"The value represented by a 5-tuple is greater than 2 
 32
  
  1.",NA
•,"A 
 z 
 character occurs in the middle of a 5-tuple.",NA
•,"A final partial 5-tuple contains only one character. 
  
 These conditions never occur in the output produced by the 
 ASCII85Encode 
 filter. Their occurrence in the input to the 
 ASCII85Decode
  filter causes an 
 ioerror 
 . 
  
 The ASCII base-85 encoding is similar to one used by the public domain 
 utilities 
 btoa
  and 
 atob 
 , which are widely available on workstations. 
 However, it is not ex-actly the same; in particular, it omits the begin-data 
 and end-data marker lines, and it uses a different convention for marking 
 end-of-data. 
  
 The parameter dictionary can be used to specify the 
  
 (LanguageLevel 3) 
 . 
  
 LZWDecode Filter
  
 source
  /LZWDecode  filter
  
 source dictionary
  /LZWDecode  filter
  
 CloseTarget
  parameter
  
 The 
 LZWDecode
  filter decodes data that is encoded in a Lempel-Ziv-Welch com-
  
 pressed format. See the description of the 
 LZWEncode
  filter for details of the for-
  
 mat and a description of the filter parameters.",NA
•,"If 
 LowBitFirst
  is 
 false
  (the default), codes are packed into bytes high-order 
 bit first. That is, bits of a code are stored into the available bits of a byte 
 starting with the highest-order bit. When a code straddles a byte 
 boundary, the high-order portion of the code appears in the low-order 
 bits of one byte; the low-",NA
•,"If 
 LowBitFirst
  is 
 true
 , codes are packed into bytes low-order bit first. That 
 is, bits of a code are stored into the available bits of a byte starting with 
 the lowest-order bit. When a code straddles a byte boundary, the low-
 order portion of the code appears in the high-order bits of one byte; the 
 high-order portion of the code appears in the low-order bits of the next 
 byte. For example, the sequence of 9-bit output codes in Table 3.18 would 
 be encoded as 
  
 00 5B 08 14 18 64 60 40
  
 FlateDecode Filter
  
 source
   /FlateDecode  filter 
  
 sourcedictionary
   /FlateDecode  filter
  
 The 
 FlateDecode
  filter
  (LanguageLevel 3)
  decodes data encoded in 
 zlib/deflate compressed format. See the description of the 
 FlateEncode
  filter 
 for details of the format. 
  
 FlateEncode Filter
  
 target
   /FlateEncode  filter 
  
 targetdictionary
   /FlateEncode  filter
  
 The 
 FlateEncode
  filter
  (LanguageLevel 3)
  encodes ASCII or binary data. 
 Encoding is based on the public-domain zlib/deflate compression method, 
 which is a variable-length Lempel-Ziv adaptive compression method 
 cascaded with adap-tive Huffman coding. This method is referred to below 
 as the Flate method. It is fully defined in Internet Engineering Task Force 
 Requests for Comments (IETF RFCs) 1950 and 1951. The output produced 
 by the 
 FlateEncode
  filter is always bi-nary, even if the input is ASCII text. 
  
 Flate compression can discover and exploit many patterns in its input data. 
 In its basic form, it is especially well suited to natural-language and 
 PostScript-language 
 text. 
 The 
 filter 
 also 
 supports 
 optional 
 pretransformation by a predictor function, as described in the section 
 “Predictor Functions” on page 139; this im-proves compression of sampled 
 image data.",NA
•,"Data is presented in order, from the top row to the bottom row and from 
 left to 
  
 right within a row.",NA
•,"A row occupies a whole number of bytes, rounded up if necessary.",NA
•,"Samples and their components are packed into bytes from high- to low-
 order 
  
 bits.",NA
•,"All color components of samples outside the image (which are necessary 
 for 
  
 predictions near the boundaries) are 0. 
  
 The two groups differ in the following ways:",NA
•,"With PNG predictors, the encoded data explicitly identifies the predictor 
 func-tion used for each row, so different rows can be predicted with 
 different algo-rithms to improve compression. The TIFF predictor has no 
 such identifier; the same algorithm applies to all rows.",NA
•,"The TIFF function group predicts each color component from the prior in-
 stance of that color component, taking into account the bits per 
 component and the number of components per sample. In contrast, the 
 PNG function group predicts each byte of data as a function of the 
 corresponding byte of one or more previous image samples, regardless of 
 whether there are multiple color components in a byte, or whether a 
 single color component spans multiple bytes. This can yield significantly 
 better speed but with somewhat worse com-pression. 
  
 Table 3.20 describes the predictor-related entries in a parameter dictionary 
 for an LZW or Flate filter.",NA
•,"Unencoded data is treated as complete scan lines, with unused bits 
 inserted at the end of each scan line to fill out the last byte. This is 
 compatible with the convention the 
 image
  operator uses.",NA
•,"Encoded data is ordinarily treated as a continuous, unbroken bit stream. 
 The 
 EncodedByteAlign
  parameter can be used to cause each encoded scan 
 line to be filled to a byte boundary; this method is not prescribed by the 
 CCITT standard, and fax machines never do this, but some software 
 packages find it convenient to encode data this way.",NA
•,"When a filter reaches EOD, it always skips to the next byte boundary 
 following 
  
 the encoded data. 
  
 DCTDecode Filter
  
 source
   /DCTDecode  filter 
  
 sourcedictionary
   /DCTDecode  filter
  
 The 
 DCTDecode
  filter decodes grayscale or color image data in JPEG baseline 
 encoded format. The description of the 
 DCTEncode
  filter provides details of 
 the format and the related filter parameters. All of the 
 DCTEncode
  
 parameters (except 
 CloseTarget
 ) are allowed for 
 DCTDecode
 ; however, 
 usually no parameters are needed except 
 ColorTransform
  (and possibly 
 CloseSource
 , in LanguageLevel 3), because all information required for 
 decoding an image is normally contained in the JPEG signalling parameters, 
 which accompany the encoded data in the com-pressed data stream.
  
 The decoded data is a stream of image samples, each of which consists of 1, 
 2, 3, or 4 color components, interleaved on a per-sample basis. Each 
 component value occupies one 8-bit byte. The dimensions of the image and 
 the number of com-ponents per sample depend on parameters that were 
 specified when the image was encoded. Given suitable parameters, the 
 image
  operator can consume data directly from a 
 DCTDecode
  filter.",NA
•,"A subfile can contain data that should be read or executed conditionally, 
 de-pending on information that is not known until execution. If a 
 program decides to ignore the information in a subfile, it can easily skip 
 to the end of the subfile by invoking 
 flushfile
  on the filter file.",NA
•,"Subfiles can help recover from errors that occur in encapsulated 
 programs. If the encapsulated program is treated as a subfile, the 
 enclosing program can re-gain control if an error occurs, flush to the end 
 of the subfile, and resume exe-cution from the underlying data source. 
 The application, not the PostScript interpreter, must provide such error 
 handling; it is not the default error han-dling provided by the PostScript 
 interpreter.",NA
•,"The 
 SubFileDecode
  filter enables an arbitrary data source (procedure or 
 string) to be treated as an input file. This use of subfiles does not require 
 detection of an EOD marker. 
  
 The 
 SubFileDecode
  filter requires two parameters, 
 EODCount
  and 
 EODString
 , 
 which specify the condition under which the filter is to recognize EOD. 
 Thefilter will allow data to pass through the filter until it has encountered 
 exactly 
 EODCount
  instances of the
 EODString
 ; then it will reach EOD. 
  
 In LanguageLevel 2, 
 EODCount
  and 
 EODString
  are specified as operands on 
 the stack. In LanguageLevel 3, they may alternatively be specified in the 
 SubFileDecode
  parameter dictionary (as shown in Table 3.23). They 
 must
  be 
 specified in the parameter dictionary if the 
 SubFileDecode
  filter is used as 
 one of the filters in a 
 ReusableStreamDecode
  filter (described in the next 
 section).",NA
•,"Data for a sampled function (see Section 3.10, “Functions”)",NA
•,"Image data or encapsulated PostScript (EPS) referenced from the 
 PaintProc 
  
 procedure of a form dictionary (see Section 4.7, “Forms”)",NA
•,"Mesh data for shading dictionaries (see Section 4.9.3, “Shading Patterns”) 
  
 Such data can be stored in strings, but only if the amount of data is less than 
 the implementation limit imposed on string objects. (See Appendix B for 
 implemen-tation limits.) To overcome this limit, LanguageLevel 3 defines 
 reusable streams
 . 
  
 A reusable stream is a file object produced by a 
 ReusableStreamDecode
  filter. 
 Conceptually, this filter consumes all of its source data at the time the 
 filter
  
 oper-ator is invoked and then makes the data available as if it were 
 contained in a tem-porary file. The filter file can be positioned as if it were a 
 random-access disk file; its capacity is limited only by the amount of 
 storage available. 
  
 Except for 
 ReusableStreamDecode
  filters, a decoding filter is an input file that 
 can be read only once. When it reaches EOF, it is automatically closed, and 
 no further data can be read from it. No data is read from the filter’s source 
 during the execution of the 
 filter
  operator. 
  
 In contrast, a 
 ReusableStreamDecode
  filter is an input file that can be read 
 many times. When it reaches EOF, it does 
 not
  automatically close, but 
 merely stays at EOF. It can be repositioned, when it reaches EOF or at any 
 other time, for further reading. In some cases, 
 all
  of the data is read from 
 the filter’s source during the execution of the 
 filter
  operator. 
  
 A reusable stream has a 
 length
 , which is the total number of bytes in its 
 data source. The stream can be positioned anywhere from 0, which denotes 
 the begin-ning of the stream, to 
 length
 , which denotes the EOF.",NA
•,"closefile 
 closes the file. This occurs implicitly when the file is reclaimed by 
 the 
 restore
  operator or garbage collection. Closing the file reclaims any 
 temporary memory or disk space that was used to buffer the file’s 
 contents.",NA
•,"fileposition
  returns the current file position. The result is always in the 
 range 0 
  
 to 
 length
 .",NA
•,"setfileposition
  sets the file position to a value in the range 0 to 
 length
 .",NA
•,"resetfile
  sets the file position to 0.",NA
•,"flushfile
  sets the file position to 
 length
 .",NA
•,"bytesavailable
  returns 
 length
  minus the current file position. 
  
 Table 3.24 lists the entries in the 
 ReusableStreamDecode 
 parameter dictionary.",NA
3.14 Binary Encoding Details,"In LanguageLevels 2 and 3, the scanner recognizes two encoded forms of 
 the PostScript language in addition to ASCII. These are 
 binary token
  
 encoding and 
 binary object sequence
  encoding. All three encoding formats 
 can be mixed in any program. 
  
 The 
 binary token
  encoding represents elements of the PostScript language 
 as indi-vidual syntactic entities. This encoding emphasizes compactness 
 over efficiency of generation or interpretation. Still, the binary token 
 encoding is usually more efficient than ASCII. Most elements of the 
 language, such as integers, real num-bers, and operator names, are 
 represented by fewer characters in the binary en-coding than in the ASCII 
 encoding. Binary encoding is most suitable for environments in which 
 communication bandwidth or storage space is the scarce resource. 
  
 The 
 binary object sequence
  encoding represents a sequence of one or more 
 Post-Script objects as a single syntactic entity. This encoding is not 
 compact, but it can be generated and interpreted very efficiently. In this 
 encoding, most elements of the language are in a natural machine 
 representation or something very close to one. Also, this encoding is 
 oriented toward sending fully or partially precompiled sequences of 
 objects, as opposed to sequences generated “on the fly.” Binary ob-ject 
 sequence encoding is most suitable for environments in which execution 
 costs dominate communication costs.",NA
•,An object type that is undefined,NA
•,An “unused” field that is not 0,NA
•,"Lengths and offsets that, combined, would refer outside the bounds of the 
 bi-
  
 nary object sequence",NA
•,"An array offset that is not a multiple of 8 or that refers beyond the earliest 
  
 string offset",NA
•,"High-order byte firstin a multiple-byte integer or fixed-point number. The 
  
 high-order byte comes first, followed by successively lower-order bytes.",NA
•,"Low-order byte firstin a multiple-byte integer or fixed-point number. The 
 low-
  
 order byte comes first, followed by successively higher-order bytes. 
  
 The real format choices are:",NA
•,"IEEE standard. 
 A real number is represented in the 32-bit floating-point 
 format defined in the IEEE 
 Standard 754-1985 for Binary Floating-Point 
 Arithmetic
 . The order of bytes is the same as the integer byte order. For 
 example, if the high-order byte of an integer comes first, then the byte 
 containing the sign and first 7 exponent bits of an IEEE standard real 
 number comes first.",NA
•,"Native.
  A real number is represented in the native format for the machine 
 on which the PostScript interpreter is running. This may be a standard 
 format or something completely different. The choice of byte order is not 
 relevant. The application program is responsible for finding out the 
 correct format. In gener-al, this choice is useful only in environments 
 where the application and the PostScript interpreter are running on the 
 same machine or on machines with compatible architectures. PostScript 
 programs that use this real number repre-sentation are not portable. 
  
 Because each binary token or binary object sequence specifies its own 
 number representation, binary encoded programs with different number 
 representations can be mixed. This is a convenience for applications that 
 obtain portions of Post-Script programs from different sources. 
  
 The 
 ByteOrder
  and 
 RealFormat
  system parameters indicate the native byte 
 order and real number representation of the machine on which the 
 PostScript inter-preter is running (see Appendix C). An interactive 
 application can query 
 RealFormat
  to determine whether the interpreter’s 
 native real number format is the same as that of the application. If so, 
 translation to and from IEEE format can be avoided.",NA
•,As an array object whose elements are numbers to be used successively,NA
•,"As a string object to be interpreted as an 
 encoded number string
  
 An encoded number string is a string that contains a single 
 homogeneous 
 number array
  according to the binary token encoding. That is, the first 4 
 bytes are treated as a header. The remaining bytes are treated as a 
 sequence of numbers encoded as described in the header. (See Figure 3.2 
 on page 161.) 
  
 An encoded number string is a compact representation of a number 
 sequence both in its external form 
 and in VM
 . Syntactically, it is simply a 
 string object. It remains in that form after being scanned and placed in VM. 
 It is interpreted as a sequence of numbers only when it is used as an 
 operand of an operator that is ex-pecting a number array. Furthermore, 
 even then it is neither processed by the scanner nor expanded into an array 
 object; instead, the numbers are consumed directly by the operator. This 
 arrangement is compact and efficient, particularly for large number 
 sequences. 
  
 Example 3.11 shows equivalent ways of invoking 
 rectfill
 , which is one of the 
 LanguageLevel 2 operators that expect number sequences as operands. 
  
 Example 3.11
  
 [100  200  40  50] rectfill 
  
 <95  200004  0064  00c8  0028  0032> 
 rectfill
  
 The first line constructs an ordinary PostScript array object containing the 
 num-bers and passes it to 
 rectfill
 . This is the most general form, because the 
 [
 and 
 ]",NA
Graphics,"THE POSTSCRIPT GRAPHICS OPERATORS describe the appearance of pages 
 that are to be reproduced on a raster output device. The facilities described 
 here are intended for both printer and display applications. 
  
 The graphics operators form seven main groups:",NA
•,"Graphics state operators.
  These operators manipulate the data structure 
 called the 
 graphics state
 , which is the global framework within which the 
 other graph-ics operators execute.",NA
•,"Coordinate system and matrix operators.
  The graphics state includes the 
 current transformation matrix
  (CTM), which maps coordinates specified 
 by the Post-Script program into output device coordinates. The operators 
 in this group manipulate the CTM to achieve any combination of 
 translation, scaling, rota-tion, reflection, and skewing of user coordinates 
 onto device coordinates.",NA
•,"Path construction operators.
  The graphics state includes the 
 current path
 , 
 which defines shapes and line trajectories. Path construction operators 
 begin a new path, add line segments and curves to the current path, and 
 close the current path. All of these operators implicitly reference the CTM 
 parameter in the graphics state.",NA
•,"Painting operators.
  The operators in this group paint graphical elements, 
 such as lines, filled areas, and sampled images, into the raster memory of 
 the output device. These operators are controlled by the current path, 
 current color, and many other parameters in the graphics state.",NA
•,"Glyph and font operators.
  These operators select and paint character
  
 glyphs 
 from 
 fonts
  (descriptions of typefaces for representing text 
 characters). Because the PostScript language treats glyphs as general 
 graphical shapes, many of the font operators should be grouped with the 
 path construction or painting oper-",NA
•,"Device setup operators.
  These operators establish the association between 
 raster memory and a physical output device, such as a printer or a 
 display. They are discussed in detail in Chapter 6.",NA
•,"Output operators.
  Once a page has been completely described, executing an 
  
 output operator transmits the page to the output device. 
  
 This chapter presents general information about device-independent 
 graphics in the PostScript language: how a program describes the abstract 
 appearance of a page. 
 Rendering
 —the device-dependent part of graphics—
 is covered in Chapter 7.",NA
4.1 Imaging Model,"The Adobe imaging model is a simple and unified view of two-dimensional 
 graphics borrowed from the graphic arts. A PostScript program builds an 
 image by placing “paint” on a “page” in selected areas.",NA
•,"The painted figures may be in the form of letter shapes, general filled 
 shapes, 
  
 lines, or digitally sampled representations of photographs.",NA
•,"The paint may be in color or in black, white, or any shade of gray.",NA
•,"The paint may take the form of a repeating pattern 
 (LanguageLevel 2)
  or a 
  
 smooth transition between colors 
 (LanguageLevel 3)
 .",NA
•,"Any of these elements may be clipped to appear within other shapes as 
 they are 
  
 placed onto the page.",NA
•,"Once a page has been built up to the desired form, it may be transmitted to 
 an 
  
 output device. 
  
 The PostScript interpreter maintains an implicit 
 current page
  that 
 accumulates the marks made by the 
 painting operators
 . When a program 
 begins, the current page is completely blank. As each painting operator 
 executes, it places marks on the current page. Each new mark completely 
 obscures any marks it may overlay (subject to the effects of the overprint 
 parameter in the graphics state; see Section 4.8.5). This method is known as 
 a 
 painting model
 : no matter what color a mark has—white, black, gray, or 
 color—it is put onto the current page as if it were applied with opaque 
 paint. Once the page has been completely composed,",NA
•,"fill
  paints an area.",NA
•,"stroke
  paints lines.",NA
•,"image
  paints a sampled image.",NA
•,"show
  paints glyphs representing character shapes. 
  
 The painting operators require various parameters, some explicit and 
 others im-plicit. Chief among the implicit parameters is the 
 current path
  
 used by 
 fill
 , 
 stroke
 , and 
 show
 . A path consists of a sequence of connected and 
 disconnected points, lines, and curves that together describe shapes and 
 their positions. It is built up through the sequential application of the
  path 
 construction operators
 , each of which modifies the current path in some 
 way, usually by appending one new ele-ment. 
  
 Path construction operators include 
 newpath
 , 
 moveto
 , 
 lineto
 , 
 curveto
 , 
 arc
 , and 
 closepath
 . None of the path construction operators places marks on the 
 current page; the painting operators do that. Path construction operators 
 create the shapes that the painting operators paint. Some operators, such as 
 ufill
  and 
 ustroke
 , combine path construction and painting in a single 
 operation for effi-ciency. 
  
 Implicit parameters to the painting operators include the current color, 
 current line width, current font (typeface and size), and many others. There 
 are operators that examine and set each implicit parameter in the graphics 
 state. The values used for implicit parameters are those in effect at the time 
 an operator is invoked. 
  
 PostScript programs contain many instances of the following typical 
 sequence of steps: 
  
 1. Build a path using path construction operators. 
  
 2. Set any implicit parameters if their values need to change. 
  
 3. Perform a painting operation.",NA
4.2 Graphics State,"The PostScript interpreter maintains an internal data structure called the 
 graphics state
  that holds current graphics control parameters. These 
 parameters define the global framework within which the graphics 
 operators execute. For example, the 
 stroke 
 operator implicitly uses the 
 current line width
  parameter from the graphics state, and the 
 fill
  operator 
 implicitly uses the 
 current color
  parameter. 
  
 Most graphics state parameters are ordinary PostScript objects that can be 
 read and altered by the appropriate graphics state operators. For example, 
 the opera-tor 
 setlinewidth
  changes the current line width parameter, and 
 currentlinewidth 
 reads that parameter from the graphics state. In general, 
 the operators that set graphics state parameters simply store them 
 unchanged for later use by other graphics operators. However, certain 
 parameters have special properties or be-havior:",NA
•,"Most parameters must be of the correct type or have values that fall into a 
 cer-
  
 tain range.",NA
•,"Parameters that are numeric values, such as color, line width, and miter 
 limit, are forced into legal range, if necessary, and stored as real numbers. 
 If they are later read out, they are always real, regardless of how they 
 were originally speci-fied. However, they are 
 not
  adjusted to reflect 
 capabilities of the raster output device, such as resolution or number of 
 distinguishable colors. Graphics ren-dering operators perform such 
 adjustments, but the adjusted values are not stored back into the graphics 
 state.",NA
•,"Certain parameters are composite objects, such as arrays or dictionaries. 
 Graphics operators consult the values of these objects at unpredictable 
 times and may cache them for later use, so altering them can have 
 unpredictable re-sults. A PostScript program should treat the values of 
 graphics state parameters (including those in saved graphics states) as if 
 they were read-only.",NA
•,"The current path, clipping path, and device parameters are internal objects 
 that 
  
 are not directly accessible to a PostScript program. 
  
 Table 4.1 lists those graphics state parameters that are device-independent 
 and are appropriate to specify in page descriptions. The parameters listed 
 in Table 4.2 control details of the rendering (scan conversion) process and 
 are device-dependent. A page description that is intended to be device-
 independent should not alter these parameters. 
  
 TABLE 4.1 Device-independent parameters of the graphics state
  
 PARAMETER
  
 TYPE
  
 VALUE
  
 CTM
  
 array
  
 The current transformation matrix, which maps positions from 
 user
  
 coordinates to device coordinates. This matrix is modified by 
 each ap-plication of the coordinate system operators. Initial 
 value: a matrix that transforms default user coordinates to device 
 coordinates. 
  
 position
  
 two numbers
  
 The coordinates of the 
 current point
  in user space, the last element of
  
 the current path. Initial value: undefined. 
  
 path
  
 (internal)
  
 The current path as built up by the path construction operators. 
 Used
  
 as an implicit argument by operators such as 
 fill
 , 
 stroke
 , and 
 clip
 . 
 Ini-tial value: empty. 
  
 clipping path
  
 (internal)
  
 A path defining the current boundary against which all output is to 
 be
  
 cropped. Initial value: the boundary of the entire imageable 
 portion of the output page. 
  
 clipping path stack
  
 (internal)
  
 (LanguageLevel 3)
  A stack holding clipping paths that have been 
 saved
  
 with the 
 clipsave
  operator and not yet restored with 
 cliprestore
 . 
  
 color space
  
 array
  
 (LanguageLevel 2)
  The color space in which color values are to be 
 in-
  
 terpreted. Initial value: 
 DeviceGray
 . 
  
 color
  
 (various)
  
 The color to use during painting operations. The type and 
 interpreta-
  
 tion of this parameter depends on the current color space. For 
 most color spaces, a color value consists of one to four numbers. 
 Initial value: black. 
  
 font
  
 dictionary
  
 The set of graphic shapes (glyphs) that represent characters in the cur-
  
 rent typeface. Initial value: an invalid font dictionary. 
  
 line width
  
 number
  
 The thickness (in user coordinate units) of lines to be drawn by the
  
 stroke
  operator. Initial value: 1.0.",NA
•,"gsave
  pushes a copy of the entire graphics state onto the stack.",NA
•,"grestore
  restores the entire graphics state to its former value by popping it 
 from 
  
 the stack. 
  
 The graphics state stack, with its LIFO (last in, first out) organization, 
 serves the needs of PostScript programs that are page descriptions. A well-
 structured docu-ment typically contains many graphical elements that are 
 essentially independent of each other and sometimes nested to multiple 
 levels. The 
 gsave
  and 
 grestore 
 operators can be used to encapsulate these 
 elements so that they can make local changes to the graphics state without 
 disturbing the graphics state of the sur-rounding environment. 
  
 In some interactive applications, however, a program must switch its 
 attention among multiple, more-or-less independent imaging contexts in an 
 unpredictable order. The second mechanism, available in LanguageLevels 2 
 and 3, uses 
 gstate",NA
•,"gstate
  creates a new gstate object.",NA
•,"currentgstate
  copies the entire current graphics state into a gstate object.",NA
•,"setgstate
  replaces the entire current graphics state by the value of a gstate 
 ob-
  
 ject. 
  
 Interactive programs can use these operators to create a separate gstate 
 object for each imaging context and switch among them dynamically as 
 needed. 
  
 Note: 
 Saving a graphics state, with either 
 gsave
  or 
 currentgstate
 , captures 
 every parameter, including such things as the current path and current 
 clipping path. For example, if a nonempty current path exists at the time that 
 gsave
 , 
 gstate
 , or 
 currentgstate
  is executed, that path will be reinstated by the 
 corresponding 
 grestore 
 or 
 setgstate
 . Unless this effect is specifically desired, it 
 is best to minimize storage de-mands by saving a graphics state only when 
 the current path is empty and the cur-rent clipping path is in its default state.",NA
4.3 Coordinate Systems and Transformations,"Paths and shapes are defined in terms of pairs of 
 coordinates
  on the 
 Cartesian plane. A coordinate pair is a pair of real numbers 
 x
  and 
 y
  that 
 locate a point hori-zontally and vertically within a Cartesian (two-axis) 
 coordinate system superim-posed on the current page. The PostScript 
 language defines a default coordinate system that PostScript programs can 
 use to locate any point on the page. 
  
 4.3.1 User Space and Device Space
  
 Coordinates specified in a PostScript program refer to locations within a 
 coordi-nate system that always bears the same relationship to the current 
 page, regardless of the output device on which printing or displaying will 
 be done. This coordi-nate system is called 
 user space.
  
 Output devices vary greatly in the built-in coordinate systems they use to 
 address pixels within their imageable areas. A particular device’s 
 coordinate system is a 
 device space.
  A device space 
 origin
  can be anywhere 
 on the output page. This is because the paper moves through different 
 printers and imagesetters in different",NA
•,The location of the origin,NA
•,"The orientation of the 
 x
  and 
 y
  axes",NA
•,"The lengths of the units along each axis
  
 Initially, the user space origin is located at the lower-left corner of the 
 output page or display window, with the positive 
 x
  axis extending 
 horizontally to the right and the positive 
 y
  axis extending vertically upward, 
 as in standard mathe-matical practice. The length of a unit along both the 
 x
  
 and 
 y
  axes is 1⁄72 inch. This coordinate system is the 
 default user space.
  In 
 default user space, all points within the current page have positive 
 x
  and 
 y
  
 coordinate values. 
  
 Note: 
 The default unit size (1⁄72 inch) is approximately the same as a “point,” 
 a unit widely used in the printing industry. It is not exactly the same as a 
 point, however; there is no universal definition of a point. 
  
 The default user space origin coincides with the lower-left corner of the 
 physical 
 page. Portions of the physical page may not be imageable on 
 certain output de-vices. For example, many laser printers cannot place 
 marks at the extreme edges of their physical page areas. It may not be 
 possible to place marks at or near the default user space origin. The 
 physical correspondence of page corner to default origin ensures that 
 marks within the imageable portion of the output page will be consistently 
 positioned with respect to the edges of the page.",NA
•,"translate
  moves the user space origin to a new position with respect to the 
 cur-rent page, leaving the orientation of the axes and the unit lengths 
 unchanged.",NA
•,"rotate
  turns the user space axes about the current user space origin by 
 some 
  
 angle, leaving the origin location and unit lengths unchanged.",NA
•,"scale
  modifies the unit lengths independently along the current 
 x
  and 
 y
  
 axes, 
  
 leaving the origin location and the orientation of the axes 
 unchanged.",NA
•,"concat
  applies an arbitrary linear transformation to the user coordinate 
 sys-
  
 tem. 
  
 Such modifications have a variety of uses:",NA
•,"Changing the user coordinate system conventions for an entire page.
  For 
 example, in some applications it might be convenient to express user 
 coordinates in cen-timeters rather than in 72nds of an inch, or it might be 
 convenient to have the origin in the center of the page rather than in the 
 lower-left corner.",NA
•,"Defining each graphical element of a page in its own coordinate system
 , 
 indepen-dent of any other element. The program can then position, 
 orient, and scale each element to the desired location on the page by 
 temporarily modifying the user coordinate system. This allows the 
 description of an element to be de-coupled from its placement on the 
 page. 
  
 Example 4.1 may aid in understanding the second type of modification. Com-
 ments explain what each operator does. 
  
 Example 4.1
  
 /box
  
 newpath 
  
 % Define a procedure to construct a unit-square path in the
  
 {
  
 % current user coordinate system, with its lower-left corner at
  
 0  0  moveto
  
 % the origin. 
  
  
  
 0  1  lineto 
  
  
  
 1  1  lineto 
  
  
  
 1  0  lineto 
  
  
 closepath 
  
 } def",NA
4.4 Path Construction,"In the PostScript language, 
 paths
  define shapes, trajectories, and regions of 
 all sorts. Programs use paths to draw lines, define the shapes of filled areas, 
 and specify boundaries for clipping other graphics. 
  
 A path is composed of straight and curved line segments, which may 
 connect to one another or may be disconnected. A pair of segments are said 
 to 
 connect
  only if they are defined consecutively, with the second segment 
 starting where the first one ends. Thus the order in which the segments of a 
 path are defined is signifi-",NA
•,"moveto
  establishes a new current point without adding a segment to the 
 cur-
  
 rent path, thereby beginning a new subpath.",NA
•,"lineto
  adds a straight line segment to the current path, connecting the 
 previous 
  
 current point to the new one.",NA
•,"arc
 , 
 arcn
 , 
 arct
 , and 
 arcto
  add an arc of a circle to the current path.",NA
•,"curveto
  adds a section of a cubic Bézier curve to the current path.",NA
•,"rmoveto
 , 
 rlineto
 , and 
 rcurveto
  perform the 
 moveto
 , 
 lineto
 , and 
 curveto
  
 opera-tions, but specify new points via displacements in user space 
 relative to the cur-rent point, rather than by absolute coordinates.",NA
•,"closepath
  adds a straight line segment connecting the current point to the 
 starting point of the current subpath (usually the point most recently 
 specified by 
 moveto
 ), thereby 
 closing
  the current subpath. 
  
 Note: 
 Remember that the path construction operators do not place any 
 marks on the page; only the painting operators do that. The usual procedure 
 for painting a graph-ical element on the page is to define that element as a 
 path and then invoke one of the painting operators. This is repeated for each 
 element on the page. 
  
 All of the points used to describe the path are specified in user space. All 
 coordi-nates are transformed by the CTM into device space at the time the 
 program adds the point to the current path. Changing the CTM does not 
 affect the coordinates of existing points in device space.",NA
•,"clip
  computes a new clipping path from the intersection of the current path 
  
 with the existing clipping path.",NA
•,"clippath
  replaces the current path with a copy of the current clipping path.",NA
•,"clipsave
 (LanguageLevel 3)
  pushes a copy of the current clipping path onto 
 the 
  
 clipping path stack.",NA
•,"cliprestore
 (LanguageLevel 3)
  pops the topmost element off the clipping 
 path 
  
 stack and makes it the current clipping path.",NA
4.5 Painting,"The painting operators mark graphical shapes on the current page. This 
 section describes the principal, general-purpose painting operators, 
 stroke
  
 and 
 fill
 . Vari-ants of these operators combine path construction and 
 painting in a single oper-ation; see Section 4.6, “User Paths.” More 
 specialized operators include 
 shfill
 , described in Section 4.9.3, “Shading 
 Patterns”; 
 image
 , described in Section 4.10,“Images”; and the glyph and font 
 operators, described in Chapter 5. 
  
 The operators and graphics state parameters described here control the 
 abstract appearance of graphical shapes and are device-independent. 
 Additional, device-dependent facilities for controlling the rendering of 
 graphics in raster memory are described in Chapter 7. 
  
 4.5.1 Stroking
  
 The 
 stroke
  operator draws a line along the current path. For each straight 
 or curved segment in the path, the stroked line is centered on the segment 
 with sides parallel to the segment. Each of the path’s subpaths is treated 
 separately. 
  
 The results of the 
 stroke
  operator depend on the current settings of various 
 parameters in the graphics state. See Section 4.2, “Graphics State,” for 
 further in-formation on these parameters, and Chapter 8 for detailed 
 descriptions of the operators that set them.",NA
•,"The width of the stroked line is determined by the 
 line width
  parameter 
 (see 
  
 setlinewidth
 ).",NA
•,"The color or pattern of the line is determined by the 
 color
  parameter (see 
 setgray
 , 
 setrgbcolor
 , 
 sethsbcolor
 , 
 setcmykcolor
 , 
 setcolor
 , and 
 setpattern
 ; the 
 last three are LanguageLevel 2 operators).",NA
•,"The line can be drawn either solid or with a program-specified dash 
 pattern, 
  
 depending on the 
 dash pattern
  parameter (see 
 setdash
 ).",NA
•,"If the subpath is open, the unconnected ends are treated according to the 
 line 
  
 cap
  parameter, which may be butt, rounded, or square (see 
 setlinecap
 ).",NA
•,"Wherever two consecutive segments are connected, the joint between 
 them is treated according to the 
 line join
  parameter, which may be 
 mitered, rounded, or beveled (see 
 setlinejoin
 ). Mitered joins are also 
 subject to the 
 miter limit 
 parameter (see 
 setmiterlimit
 ). 
  
 Note: 
 Points at which unconnected segments happen to meet or intersect 
 receive no special treatment. In particular, “closing” a subpath with an 
 explicit 
 lineto
  rather than with 
 closepath
  may result in a messy corner, 
 because line caps will be applied instead of a line join.",NA
•,"The 
 stroke adjustment
  parameter 
 (LanguageLevel 2)
  requests that 
 coordinates and line widths be adjusted automatically to produce strokes 
 of uniform thick-ness despite rasterization effects (see 
 setstrokeadjust
  and 
 Section 7.5.2, “Auto-matic Stroke Adjustment”). 
  
 4.5.2 Filling
  
 The 
 fill
  operator uses the current color or pattern to paint the entire region 
 en-closed by the current path. If the path consists of several disconnected 
 subpaths, 
 fill
  paints the insides of all subpaths, considered together. Any 
 subpaths that are open are implicitly closed before being filled. 
  
 For a simple path, it is intuitively clear what region lies inside. However, for 
 a more complex path—for example, a path that intersects itself or has one 
 subpath that encloses another—the interpretation of “inside” is not always 
 obvious. The path machinery uses one of two rules for determining which 
 points lie inside a path: the 
 nonzero winding number rule
  and the 
 even-odd 
 rule
 , both discussed in detail below. 
  
 The nonzero winding number rule is more versatile than the even-odd rule 
 and is the standard rule the 
 fill
  operator uses. Similarly, the 
 clip
  operator 
 uses this rule to determine the inside of the current clipping path. The 
 even-odd rule is occa-",NA
•,"infill
  tests the current path in the graphics state. There are two forms of 
 this op-erator. One returns 
 true
  if painting the current path with the 
 fill
  
 operator would result in marking the device pixel corresponding to a 
 specific point in user space. The second tests whether any pixels within a 
 specified 
 aperture 
 would be marked. The aperture is specified by a user 
 path supplied as an oper-and (see Section 4.6, “User Paths”).",NA
•,"instroke
  is similar to 
 infill
 , but it tests pixels that would be marked by 
 applying the 
 stroke
  operator to the current path, using the current 
 settings of the stroke-related parameters in the graphics state (line width, 
 dash pattern, and so forth).",NA
•,"inufill
  and 
 inustroke
  are similar to 
 infill
  and 
 instroke
 , but they test a user 
 path supplied as a separate operand, rather than the current path in the 
 graphics state.",NA
•,"ineofill
  and 
 inueofill
  are similar to 
 infill
  and 
 inufill
 , but they use the even-
 odd rule instead of the nonzero winding number rule for insideness 
 testing; see Section 4.5.2, “Filling,” for more information.",NA
4.6 User Paths ,"A 
 user path
  is a procedure that is a completely self-contained description of 
 a path in user space. It consists entirely of path construction operators and 
 their coordi-nate operands expressed as literal numbers. User paths are a 
 LanguageLevel 2 fea-ture. 
  
 Special user path painting operators, such as 
 ustroke
  and 
 ufill
 , combine the 
 ex-ecution of a user path description with painting operations such as 
 stroking or filling the resulting path. Although these operators can be fully 
 expressed in terms of other path construction and painting operators, they 
 offer a number of advan-tages in efficiency and convenience:",NA
•,They closely match the needs of many application programs.,NA
•,"Because a user path consists solely of path construction operators and 
 numeric operands, rather than arbitrary computations, it is entirely self-
 contained: its behavior is guaranteed not to depend on an unpredictable 
 execution environ-ment.",NA
•,"Every user path carries information about its own bounding box, ensuring 
 that 
  
 its coordinates will fall within predictable bounds.",NA
•,"Most of the user path painting operators have no effect on the graphics 
 state. The absence of side effects is a significant reason for the efficiency 
 of the opera-tions. There is no need to build up an explicit current path 
 only to discard it after one use. Although the operators behave as if the 
 path were built up, paint-ed, and discarded in the usual way, their actual 
 implementation is optimized to avoid unnecessary work.",NA
•,"Because a user path is represented as a self-contained procedure object, 
 the PostScript interpreter can save its output in a cache. This eliminates 
 redundant interpretation of paths that are used repeatedly. 
  
 As a result of all these factors, interpreting a user path may be much more 
 effi-cient than executing an arbitrary PostScript procedure. 
  
 4.6.1 User Path Construction
  
 A user path is an array or packed array object consisting of only the following 
 op-erators and their operands: 
  
 ucache
  
 ll
 x
   ll
 y
   ur
 x
   ur
 y 
  
 setbbox
  
 x  y 
 moveto
  
 dx  dy 
  
 rmoveto
  
 x  y 
 lineto
  
 dx  dy 
  
 rlineto
  
 x
 1
   y
 1
   x
 2
   y
 2
   x
 3
   y
 3 
  
 curveto
  
 dx
 1
   dy
 1
   dx
 2
   dy
 2
   dx
 3
   dy
 3 
  
 rcurveto
  
 x  y  r  angle
 1
   angle
 2 
  
 arc
  
 x  y  r  angle
 1
   angle
 2 
  
 arcn
  
 x
 1
   y
 1
   x
 2
   y
 2
   r 
  
 arct
  
 closepath
  
 In addition to the special operators 
 ucache
  and 
 setbbox
 , which are used only 
 in constructing user paths, this list includes all standard PostScript 
 operators that append to the current path, with two exceptions: 
 arcto
  is not 
 allowed because it would push results onto the operand stack, and 
 charpath
  
 is not allowed because the resulting user path would depend on the current 
 font and so would not be self-contained.",NA
•,"A 
 data string
  or 
 data array
  containing numeric operands. If a string, it is 
 inter-preted 
 as 
 an 
 encoded 
 number 
 string 
 according 
 to 
 the 
 representation described in Section 3.14.5, “Encoded Number Strings”; if 
 an array, its elements must all be numbers and are simply used in 
 sequence.",NA
•,"An 
 operator string
  containing a sequence of encoded path construction 
 opera-tors, one operation code (opcode) per character. Table 4.3 shows 
 the allowed opcode values. 
  
 This two-part organization is for the convenience of application programs 
 that generate encoded user paths. In particular, operands always fall on 
 natural addressing boundaries. All characters in both the data and operator 
 strings are interpreted as binary numbers, rather than as ASCII character 
 codes.",NA
•,"The user path object is explicitly saved for later use (as the value of 
 Circle1
  in this example). This is done in anticipation of painting the same 
 path multiple times.",NA
•,"The 
 cvlit
  operator is applied to the user path object to remove its 
 executable at-tribute. This ensures that the subsequent reference to 
 Circle1
  pushes the object on the operand stack rather than 
 inappropriately executing it as a procedure. It is unnecessary to do this if 
 the user path is to be consumed immediately by a user path painting 
 operator and not saved for later use. 
  
 Note: 
 It is necessary to build the user path as an executable array with 
 {
  and 
 }
 , rather than as a literal array with 
 [
  and 
 ]
 , so that the user path construction 
 operators are not executed while the array is being built. Executable arrays 
 have deferred execu-tion. 
  
 4.6.4 User Path Operators
  
 There are three categories of user path operator:",NA
•,"User path painting operators such as 
 ustroke
 , 
 ufill
 , and 
 ueofill
 , which 
 combine interpretation of a user path with a standard painting operation 
 (
 stroke
  or 
 fill
 )",NA
•,"Some of the insideness-testing operators (see Section 4.5.3, “Insideness 
 Test-
  
 ing”)",NA
•,"Miscellaneous operators involving user paths, such as 
 uappend
 , 
 upath
 , and 
  
 ustrokepath
  
 The 
 userpath
  operand to any of these operators is one of the following:",NA
•,"For an ordinary user path, an array (not necessarily executable) whose 
 length is 
  
 at least 5.",NA
•,"For an encoded user path, an array of two elements. The first element is 
 either an array whose elements are all numbers or a string that can be 
 interpreted as an encoded number string (see Section 3.14.5, “Encoded 
 Number Strings”). The second element is a string that encodes a sequence 
 of operators, as de-scribed in Table 4.3 on page 201. 
  
 In either case, the value of the object must conform to the rules for 
 constructing user paths, as detailed in preceding sections. If the user path is 
 malformed, a 
 typecheck
  error will occur. 
  
 The user path painting operators 
 ustroke
 , 
 ufill
 , and 
 ueofill
  interpret a user 
 path as if it were an ordinary PostScript procedure being executed with 
 systemdict
  as the current dictionary; they then perform the corresponding 
 standard painting oper-",NA
•,"Four numbers 
 x
 , 
 y
 , 
 width
 , and 
 height
 , describing a single rectangle. The 
 rectan-gle’s sides are parallel to the axes in user space. It has corners 
 located at coordi-nates (
 x
 ,
 y
 ), (
 x
 +
 width
 ,
 y
 ), (
 x
 +
 width
 ,
 y
 +
 height
 ), and 
 (
 x
 ,
 y
 +
 height
 ). Note that 
 width
  and 
 height
  can be negative.",NA
•,An arbitrarily long sequence of numbers represented as an array.,NA
•,"An arbitrarily long sequence of numbers represented as an encoded 
 number 
  
 string, as described in Section 3.14.5, “Encoded Number Strings.” 
  
 The sequence in the latter two operand forms must contain a multiple of 
 four numbers. Each group of four consecutive numbers is interpreted as the 
 x
 , 
 y
 , 
 width
 , and 
 height
  values defining a single rectangle. The effect produced 
 is equiv-alent to specifying all the rectangles as separate subpaths of a 
 single combined path, which is then operated on by a single 
 stroke
 , 
 fill
 , or 
 clip
  operator. 
  
 The PostScript interpreter draws all rectangles in a counterclockwise 
 direction in user space, regardless of the signs of the 
 width
  and 
 height
  
 operands. This ensures that when multiple rectangles overlap, all of their 
 interiors are considered to be inside the path according to the nonzero 
 winding number rule.",NA
4.7 Forms,"A 
 form
  is a self-contained description of any arbitrary graphics, text, or 
 sampled images that are to be painted multiple times, either on several 
 pages or at several locations on the same page. The appearance of a form is 
 described by a PostScript procedure that invokes graphics operators. 
 Language support for forms is a LanguageLevel 2 feature. 
  
 What distinguishes a form from an ordinary procedure is that it is self-
 contained and behaves according to certain rules. By defining a form, a 
 program declares that each execution of the form will produce the same 
 output, which depends only on the graphics state at the time the form is 
 executed. The form’s definition does not refer to variable information in 
 virtual memory, and its execution has no side effects in VM.",NA
•,"As its name suggests, a form can serve as the template for an entire page. 
 For example, a program that prints filled-in tax forms can first paint the 
 fixed tem-plate as a form, then paint the variable information on top of it.",NA
•,"A form can also be any graphical element that is to be used repeatedly. 
 For ex-ample, in output from computer-aided design systems, it is 
 common for cer-tain standard components to appear many times. A 
 company’s logo can be treated as a form. 
  
 4.7.1 Using Forms
  
 The use of forms requires two steps: 
  
 1.
  Describe the appearance of the form
 . Create a 
 form dictionary
  containing 
 de-scriptive information about the form. A crucial element of the 
 dictionary is the 
 PaintProc
  procedure
 , a PostScript procedure that can be 
 executed to paint the form. 
  
 2.
  Invoke the form
 . Invoke the 
 execform
  operator with the form dictionary as 
 the operand. Before doing so, a program should set appropriate 
 parameters in the graphics state; in particular, it should alter the current 
 transformation matrix to control the position, size, and orientation of the 
 form in user space. 
  
 Every form dictionary must contain a 
 FormType
  entry, which identifies the 
 par-ticular 
 form type
  that the dictionary describes and determines the 
 format and meaning of its remaining entries. At the time of publication, 
 only one form type, type 1, has been defined. Table 4.4 shows the contents 
 of the form dictionary for this form type. (The dictionary can also contain 
 any additional entries that its 
 PaintProc
  procedure may require.)",NA
•,"It should not invoke any of the operators listed in Appendix G as unsuitable 
 for 
  
 use in encapsulated PostScript files.",NA
•,"It should not invoke 
 showpage
 , 
 copypage
 , or any device setup operator.",NA
•,"Except for removing its dictionary operand, it should leave the stacks un-
  
 changed.",NA
•,"It should have no side effects beyond painting the form. It should not alter 
 ob-jects in virtual memory or anywhere else. Because of the effects of 
 caching, the 
 PaintProc
  procedure is called at unpredictable times and in 
 unpredictable envi-ronments. It should depend only on information in 
 the form dictionary and should produce the same effect every time it is 
 called. 
  
 Form caching is most effective when the graphics state does not change 
 between successive invocations of 
 execform
  for a given form. Changes to the 
 translation components of the CTM usually do not influence caching 
 behavior; other chang-es may require the interpreter to reexecute the 
 PaintProc
  procedure.",NA
4.8 Color Spaces ,"The PostScript language includes powerful facilities for specifying the 
 colors of graphical objects to be marked on the current page. The color 
 facilities are divid-ed into two parts:",NA
•,"Color specification
 . A PostScript program can specify abstract colors in a 
 device-independent way. Colors can be described in any of a variety of 
 color systems, or 
 color spaces.
  Some color spaces are related to device 
 color representation (grayscale, RGB, CMYK), others to human visual 
 perception (CIE-based). Cer-tain special features are also modeled as 
 color spaces: patterns, color mapping, separations, and high-fidelity and 
 multitone color.",NA
•,"Color rendering
 . The PostScript interpreter reproduces colors on the 
 raster out-put device by a multiple-step process that includes color 
 conversion, gamma correction, halftoning, and scan conversion. Certain 
 aspects of this process are under PostScript language control. However, 
 unlike the facilities for color spec-ification, the color rendering facilities 
 are device-dependent and ordinarily should not be accessed from a page 
 description. 
  
 This section describes the color specification facilities of the PostScript 
 language. It covers everything that most PostScript programs need in order 
 to specify col-ors. Chapter 7 describes the facilities for controlling color 
 rendering; a program should use those facilities only to configure or 
 calibrate an output device or to achieve special device-dependent effects. 
  
 Figures 4.5 and 4.6 on pages 212 and 213 illustrate the organization of the 
 Post-Script language features for dealing with color, showing the division 
 between (device-independent) color specification and (device-dependent) 
 color render-ing. 
  
 4.8.1 Types of Color Space
  
 As described in Section 4.5, “Painting,” marks placed on the page by 
 operators such as 
 fill
  and 
 stroke
  have a color that is determined by the 
 current color
  parame-ter of the graphics state. A color value consists of one 
 or more 
 color components
 , which are usually numbers. For example, a gray 
 level can be specified by a single number ranging from 0.0 (black) to 1.0 
 (white). Full color values can be specified in any of several ways; a common 
 method uses three numbers to specify red, green, and blue components.",NA
•,"Device color spaces
  directly specify colors or shades of gray that the 
 output de-vice is to produce. They provide a variety of color specification 
 methods, including gray level, RGB (red-green-blue), HSB (hue-
 saturation-brightness), 
 and 
 CMYK 
 (cyan-magenta-yellow-black), 
 corresponding to the color space families 
 DeviceGray
 , 
 DeviceRGB
 , and 
 DeviceCMYK
 . (HSB is merely an alternate convention for specifying RGB 
 colors.) Since each of these families consists of just a single color space 
 with no parameters, they are sometimes loosely re-ferred to as the 
 DeviceGray
 , 
 DeviceRGB
 , and 
 DeviceCMYK
  color spaces.",NA
•,"CIE-based color spaces 
 are based on an international standard for color 
 specifi-cation created by the Commission Internationale de l’Éclairage 
 (International Commission on Illumination). These spaces allow colors to 
 be specified in a way that is independent of the characteristics of any 
 particular output device. Color space families in this category include 
 CIEBasedABC
 , 
 CIEBasedA
 , 
 CIEBasedDEF
 , and 
 CIEBasedDEFG
 . Individual color 
 spaces within these families are specified by means of dictionaries 
 containing the parameter values needed to define the space.",NA
•,"Special color spaces
  add features or properties to an underlying color 
 space. They include facilities for patterns, color mapping, separations, 
 and high-fidelity and multitone color. The corresponding color space 
 families are 
 Pattern
 , 
 Indexed
 , 
 Separation
 , and 
 DeviceN
 . Individual color 
 spaces within these families are specified by means of additional 
 parameters. 
  
 Whatever type of color space a PostScript program uses to 
 specify
  a color, 
 the pro-cess of 
 rendering
  that color on a particular output device is under 
 separate con-trol. Color rendering is discussed in Chapter 7. 
  
 The following operators control the selection of color spaces and color values:",NA
•,"setcolorspace
  sets the color space parameter in the graphics state; 
 currentcolor-
  
 space
  returns the current color space parameter. 
  
 The operand to 
 setcolorspace
  is an array object containing as its first 
 element a name object identifying the desired color space. The remaining 
 array elements, if any, are parameters that further characterize the color 
 space; their number and types vary according to the particular color 
 space selected. For color spaces that do not require parameters, the 
 operand to 
 setcolorspace
  can simply be the color space name itself instead 
 of an array; 
 currentcolorspace
  always returns an array. 
  
 The following color space families are standard in LanguageLevel 2: 
  
 DeviceGray
  
 CIEBasedABC
  
 Pattern
  
 DeviceRGB
  
 CIEBasedA
  
 Indexed
  
 DeviceCMYK
  
 Separation
  
 LanguageLevel 3 supports the following additional families: 
  
 CIEBasedDEF 
  
 DeviceN
  
 CIEBasedDEFG",NA
•,"setcolor
  sets the current color parameter in the graphics state; 
 currentcolor
  re-turns the current color parameter. Depending on the color 
 space, 
 setcolor 
 requires one or more operands, each specifying one 
 component of the color value.",NA
•,"setgray
 , 
 setrgbcolor
 , 
 sethsbcolor
 , 
 setcmykcolor
 , and 
 setpattern
  set the color 
 space implicitly and the current color value as specified by the operands. 
 currentgray
 , 
 currentrgbcolor
 ,
  currenthsbcolor
 , and 
 currentcmykcolor
  return 
 the current color according to an implicit color space; in certain limited 
 cases, the latter operators also perform conversions if the current color 
 space differs from the implicit one. 
  
 Note: 
 Color specification operators such as 
 setcolorspace
 , 
 setcolor
 , and 
 setpattern 
 sometimes install composite objects, such as arrays or dictionaries, 
 as parameters in the graphics state. To ensure predictable behavior, a 
 PostScript program should thereafter treat all such objects as if they were 
 read-only. 
  
 In certain circumstances, it is illegal to invoke operators that specify colors 
 or other color-related parameters in the graphics state. This restriction 
 occurs when defining graphical figures whose colors are to be specified 
 separately each time they are used. Specifically, the restriction applies:",NA
•,"After execution of 
 setcachedevice
  or 
 setcachedevice2
  in a 
 BuildGlyph
 , 
 BuildChar
 , or 
 CharStrings
  procedure of a font dictionary (see Sections 
 5.7,“Type 3 Fonts”; “Type 1 CIDFonts” on page 376; and 5.9.3, “Replacing 
 or Add-ing Individual Glyphs”)",NA
•,"In the 
 PaintProc
  procedure of an uncolored tiling pattern (see Section 4.9,
  
 “Patterns”) 
  
 In these circumstances, invoking any of the following operators will cause an 
 undefined
  error: 
  
 colorimage
  
 setcolorscreen
  
 setpattern
  
 image
  
 setcolorspace
  
 setrgbcolor
  
 setblackgeneration
  
 setcolortransfer
  
 setscreen
  
 setcmykcolor
  
 setgray
  
 settransfer
  
 setcolor
  
 sethalftone
  
 setundercolorremoval
  
 setcolorrendering
  
 sethsbcolor
  
 shfill",NA
•,"DeviceRGB
  controls the intensities of red, green, and blue light, the three 
 addi-tive primary colors used in displays. Colors in this space can 
 alternatively be specified by hue, saturation, and brightness values.",NA
•,"DeviceCMYK
  controls the concentrations of cyan, magenta, yellow, and black 
  
 inks, the four subtractive process colors used in printing.",NA
•,"DeviceGray
  controls the intensity of achromatic light, on a scale from black 
 to 
  
 white. 
  
 Although the notion of explicit color spaces is a LanguageLevel 2 feature, 
 the op-erators for specifying colors in the 
 DeviceRGB
  and 
 DeviceGray
  color 
 spaces—
 setrgbcolor
 , 
 sethsbcolor
 , 
 and 
 setgray
 —are 
 available 
 in 
 all 
 LanguageLevels. The 
 setcmykcolor
  operator is also supported by some (but 
 not all) LanguageLevel 1 implementations.",NA
•,"Hue
  corresponds to the property that is intuitively meant by the term 
 “color,”
  
 such as yellow or blue-green.",NA
•,"Saturation
  indicates how pure the color is. A saturation of 0.0 means that 
 none of the color’s hue is visible; the result is a shade of gray. A saturation 
 of 1.0 de-notes a pure color, consisting entirely of the specified hue. 
 Intermediate values represent a mixture between pure hue and pure 
 gray.",NA
•,"Brightness
  determines how light the color determined by the hue and 
 satura-tion will be. A brightness of 0.0 is always black. A brightness of 1.0 
 denotes the lightest color that the given combination of hue and 
 saturation can allow. (For example, pure red can never be as light as the 
 brightest white, because it is missing two components.)",NA
•,"X
 ,
  Y
 , and 
 Z
  in the CIE 1931 XYZ space",NA
•,"R
 ,
  G
 , and 
 B
  in a calibrated RGB space",NA
•,"L
 *, 
 a
 *, and 
 b
 * in the CIE 1976 L*a*b* space",NA
•,"Y
 ,
  I
 , and 
 Q
  in the NTSC television space",NA
•,"Y
 ,
  U
 , and 
 V
  in the SECAM and PAL television spaces 
  
 The initial values of 
 A
 ,
  B
 , and 
 C
  are 0.0 unless the range of valid values for a 
 color component does not include 0.0, in which case the nearest valid value 
 is substi-tuted. 
  
 The parameters for a 
 CIEBasedABC
  color space must be provided in a 
 dictionary that is the second element of the array operand to the 
 setcolorspace
  operator. Table 4.5 describes the contents of this dictionary; 
 Figure 4.7 illustrates the trans-formations involved. 
  
  
 A
  
 DecodeABC
  
 MatrixABC
  
  
 L
  
 DecodeLMN
  
 MatrixLMN
  
  
  
  
  
  
  
 B
  
  
  
  
  
 M
  
  
  
  
 C
  
  
  
  
  
 N
  
  
  
  
  
 FIGURE 4.7 
 Component transformations in the 
 CIEBasedABC
  color space",NA
•,"The luminance 
 Y
  component of the CIE 1931 XYZ space",NA
•,The gray component of a calibrated gray space,NA
•,"The CIE 1976 psychometric lightness 
 L
 * component of the CIE 1976 L*a*b* 
  
 space",NA
•,"The luminance 
 Y
  component of the NTSC, SECAM, and PAL television spaces 
  
 The initial value of 
 A
  is 0.0 unless the range of valid values does not include 
 0.0, in which case the nearest valid value is substituted. 
  
 The parameters for a 
 CIEBasedA
  color space must be provided in a 
 dictionary that is the second element of the array operand to the 
 setcolorspace
  operator. Table 4.6 describes the contents of this dictionary; 
 Figure 4.8 illustrates the trans-formations involved.",NA
•,The CIE 1976 L*u*v space,NA
•,Calibrated RGB from scanners,NA
•,"Calibrated CMYK 
  
 The first two of these are three-component spaces and can be represented 
 by 
 CIEBasedDEF
  color spaces; the last has four components and can be 
 represented by a 
 CIEBasedDEFG
  space. 
  
 Both 
 CIEBasedDEF
  and 
 CIEBasedDEFG
  are simple pre-extensions to the 
 CIEBasedABC
  color space family. Figure 4.9 illustrates the relationship 
 between 
 CIEBasedDEFG
  and 
 CIEBasedABC
 . The components (
 D
 ,
  E
 ,
  F
 ,
  G
 ) of a 
 color in a 
 CIEBasedDEFG
  space are first transformed by applying a 
 PostScript decoding pro-cedure, 
 DecodeDEFG
 ; the resulting values are then 
 used to look up and interpo-late in a four-dimensional mapping table. The 
 table lookup yields a color value with components 
 A
 ,
  B
 , and 
 C
 , which is then 
 mapped into the CIE 1931 XYZ space in the same way as for a 
 CIEBasedABC
  
 color space; see “CIEBasedABC Col-or Spaces” on page 221. (The equivalent 
 diagram for a three-component 
 CIEBasedDEF
  space would look the same as 
 Figure 4.9, except that the lookup table would have three inputs instead of 
 four and the initial decoding procedure would be named 
 DecodeDEF
  instead 
 of 
 DecodeDEFG
 .) 
  
 D
  
 DecodeDEFG
  
 H
  
 Table
  
 A
  
 DecodeABC
  
 MatrixABC
  
 L
  
 DecodeLMN
  
 MatrixLMN
  
 E
  
 I
  
 B
  
 M
  
 F
  
 J
  
 C
  
 N
  
 G
  
 K
  
 FIGURE 4.9 
 CIEBasedDEFG
  pre-extension to the 
 CIEBasedABC
  color space",NA
•,"A page description originally intended for one device is redirected to a 
 different 
  
 device.",NA
•,"An application generates LanguageLevel 1 output only, and thus is unable 
 to specify CIE-based colors directly. This is especially common for 
 encapsulated PostScript (EPS) files.",NA
•,"Color corrections or rendering intents need to be applied to device colors. 
 (Rendering intents allow the application to set priorities regarding which 
 color properties to preserve and which to compromise in order to 
 compensate for the limitations of a particular output device; see Section 
 7.1.3, “Rendering In-tents,” for details.) 
  
 When 
 UseCIEColor
  is 
 true
 , all colors specified in the 
 DeviceGray
 , 
 DeviceRGB
 , 
 or 
 DeviceCMYK
  color space are remapped into a corresponding target color 
 space, which must previously have been defined as a resource in the 
 ColorSpace
  re-source category. This substitution occurs at the moment a 
 device color space is selected by 
 setcolorspace
  (or implicitly by 
 setgray
 , 
 setrgbcolor
 , or 
 setcmykcolor
 ); it is unaffected by subsequent changes to the 
 ColorSpace
  resource category. The resources specifying the target spaces for 
 the three device color spaces are named",NA
•,"DefaultGray
  must be a 
 CIEBasedA
  color space or 
 [/DeviceGray]
  (for no remap-
  
 ping).",NA
•,"DefaultRGB
  must be a 
 CIEBasedABC
  color space, a 
 CIEBasedDEF
  color space, 
 or 
  
 [/DeviceRGB]
  (for no remapping).",NA
•,"DefaultCMYK
  must be a 
 CIEBasedDEFG
  color space or 
 [/DeviceCMYK]
  (for no 
  
 remapping). 
  
 If the color space in use is a special color space based on an underlying 
 device color space, 
 UseCIEColor
  will remap the underlying space. This 
 applies to the fol-lowing:",NA
•,"The base color space of an 
 Indexed
  color space",NA
•,"The underlying color space of a 
 Pattern
  color space",NA
•,"The alternative color space of a 
 Separation
  or 
 DeviceN
  color space (but only 
 if 
  
 the alternative color space is actually selected) 
  
 See Section 4.8.4, “Special Color Spaces,” for details on these color spaces. 
  
 Enabling 
 UseCIEColor
  does not alter the current color space or current color 
 values in the graphics state. The remapping of device colors into CIE-based 
 col-ors is entirely internal to the implementation of the PostScript color 
 operators. Once transformed, the colors are then processed according to 
 the current color rendering dictionary, as is normally done for CIE-based 
 colors. See Section 7.1,“CIE-Based Color to Device Color,” for more 
 information. 
  
 4.8.4 Special Color Spaces
  
 Special color spaces add features or properties to an underlying color 
 space. There are four special color space families: 
 Pattern
 , 
 Indexed
 , 
 Separation
 , and 
 DeviceN
 . 
  
 Pattern Color Space
  
 A 
 Pattern
  color space 
 (LanguageLevel 2)
  enables PostScript programs to paint 
 an area with a “color” defined as a 
 pattern
 , which may be either a graphical 
 figure re-",NA
•,"The 
 alternativeSpace
  parameter must be an array or name object that 
 identifies the alternative color space. This can be any device or CIE-based 
 color space, but not another special color space (
 Pattern
 , 
 Indexed
 , 
 Separation
 , or 
 DeviceN
 ). The 
 alternativeSpace
  parameter should be specified 
 in the same way as if it were being used directly as an operand to the 
 setcolorspace
  operator.",NA
•,"The 
 tintTransform
  parameter must be a PostScript procedure. During 
 subse-quent painting operations, the PostScript interpreter will call this 
 procedure to transform a tint value into color component values in the 
 alternative color space. The procedure is called with the tint value on the 
 operand stack and must return the corresponding color component 
 values in a form acceptable to the 
 setcolor
  operator in the alternative 
 color space. The number of compo-nents and the interpretation of their 
 values depend on the alternative color space. Because the 
 tintTransform
  
 procedure is called by the 
 setcolor
  and 
 image 
 operators at unpredictable 
 times, it must operate as a pure function without side effects. 
  
 Example 4.17 illustrates the specification of a 
 Separation
  color space that is 
 in-tended to produce a color named 
 LogoGreen
 . If the output device has no 
 colorant corresponding to this color, 
 DeviceCMYK
  will be used as the 
 alternative color",NA
•,"Color values in a 
 DeviceN
  color space consist of multiple tint components, 
  
 rather than only one.",NA
•,"The 
 names
  parameter in the color space array passed to 
 setcolorspace
  is an 
 array of colorant names, specified as name or string objects. (The special 
 colo-rant names 
 All
  and 
 None
  are not allowed.) The length of the array 
 determines the number of components, and hence the number of 
 operands required by the 
 setcolor
  operator when this space is the current 
 color space. Operand values supplied to 
 setcolor
  are interpreted as color 
 component values in the order in which the colors are given in the 
 names
  
 array.",NA
•,"The 
 setcolorspace
  operator will select the requested set of colorants only if 
 all of them are available on the device; otherwise, it will select the 
 alternative color space designated by the 
 alternativeSpace
  parameter.",NA
•,"The 
 tintTransform
  procedure is called with 
 n
  tint values on the operand 
 stack and must return the corresponding 
 m
  color component values, 
 where 
 n
  is the number of components needed to specify a color in the 
 DeviceN
  color space and 
 m
  is the number required by the alternative color 
 space. 
  
 The following PostScript program fragments illustrate various interesting 
 and useful special cases of 
 DeviceN
 . Example 4.18 shows the specification of 
 an 
 Indexed
  color space that maps 8-bit index values to a duotone 
 DeviceN
  
 space in cyan and black.",NA
4.9 Patterns,"When operators such as 
 fill
 , 
 stroke
 , and 
 show
  paint an area of the page with 
 the current color, they ordinarily apply a single color that covers the area 
 uniformly. Sometimes, however, it is desirable to apply “paint” that consists 
 of a repeating figure or a smoothly varying color gradient instead of a 
 simple color. Such a re-peating figure or smooth gradient is called a 
 pattern.
  
 Patterns are quite general, and have many uses. They can be used to create 
 various graphical textures, such as weaves, brick walls, sunbursts, and 
 similar geometrical and chromatic effects. 
  
 PostScript patterns come in two varieties:",NA
•,"Tiling patterns
  consist of a small graphical figure (called a 
 pattern cell
 ) that 
 is replicated at fixed horizontal and vertical intervals to fill the area to be 
 painted.",NA
•,"Shading patterns
  define a 
 gradient fill
  that produces a smooth transition be-
  
 tween colors across the area.",NA
•,"It should not invoke any of the operators listed in Appendix G as unsuitable 
 for 
  
 use in encapsulated PostScript files.",NA
•,"It should not invoke 
 showpage
 , 
 copypage
 , or any device setup operator.",NA
•,"Except for removing its dictionary operand, it should leave the stacks un-
  
 changed.",NA
•,"It should have no side effects beyond painting the pattern cell. It should 
 not alter objects in virtual memory or anywhere else. Because of the 
 effects of cach-ing, the 
 PaintProc
  procedure is called at unpredictable 
 times and in unpredictable environments. It should depend only on 
 information in the pat-tern dictionary and should produce the same effect 
 every time it is called.",NA
A,"CHAPTER 4
  
 Graphics",NA
•,"After constructing the prototype pattern dictionary, the program 
 immediately invokes 
 makepattern
  on it. The value assigned to 
 Star4
  is the 
 instantiated
  pat-tern returned by 
 makepattern
 . There is no need to save 
 the prototype pattern unless it is to be instantiated in multiple ways, 
 perhaps with different sizes or orientations.",NA
•,"The program illustrates both methods of selecting a pattern for painting. 
 The first time, it invokes the 
 setcolorspace
  and 
 setcolor
  operators 
 separately. The second time, it uses the convenience operator 
 setpattern
 . 
 Note that the calls to 
 setgray
  also change the color space to 
 DeviceGray
 .",NA
•,"The rectangle and the glyph representing the letter 
 A
  are painted with the 
 same instantiated pattern (the pattern dictionary returned by a single 
 execution of 
 makepattern
 ). The pattern cells align, even though the 
 current transformation matrix is altered between the two uses of the 
 pattern.",NA
•,"The pattern cell does not completely cover the tile: it leaves the spaces 
 between the stars unpainted. When the tiling pattern is used as a color, the 
 existing",NA
•,"The program paints the rectangle twice, first with gray, then with the tiling pat-
  
 tern. To paint with the pattern, it supplies two operands to 
 setcolor
 : the num-
  
 ber 1.0, denoting white in the underlying 
 DeviceGray
  color space, and the
  
 pattern dictionary.",NA
•,"The program paints the circle with the same pattern, but with the color 
 set to 0.0 (black). Note that in this instance, 
 setpattern
  inherits parameters 
 from the existing color space (see the description of the 
 setpattern
  
 operator in Chapter 8 for details). 
  
 4.9.3 Shading Patterns
  
 Shading patterns 
 (LanguageLevel 3)
  provide a smooth transition between 
 colors across an area to be painted, independent of the resolution of any 
 particular out-put device and without specifying the number of steps in the 
 color transition. Patterns of this type are described by pattern dictionaries 
 with a pattern type of 2. Table 4.10 shows the contents of this type of 
 dictionary, most of whose entries are identical to corresponding entries in 
 the type 1 pattern dictionary (Table 4.9). The most significant entry is 
 Shading
 , whose value is a 
 shading dictionary
  de-fining the properties of the 
 shading pattern’s 
 gradient fill.
  This is a complex“paint” that determines the 
 type of color transition the shading pattern produces when painted across 
 an area.",NA
•,"Function-based shadings
  (type 1) define the color of every point in the 
 domain 
  
 using a mathematical function (not necessarily smooth or 
 continuous).",NA
•,"Axial shadings
  (type 2) define a color blend along a line between two 
 points, optionally extended beyond the boundary points by continuing 
 the boundary colors.",NA
•,"Radial shadings
  (type 3) define a blend between two circles, optionally ex-
 tended beyond the boundary circles by continuing the boundary colors. 
 This type of shading is commonly used to represent three-dimensional 
 spheres and cones.",NA
•,"Free-form Gouraud-shaded triangle meshes
  (type 4) define a common 
 construct used by many three-dimensional applications to represent 
 complex colored and shaded shapes. Vertices are specified in free-form 
 geometry.",NA
•,"Lattice-form Gouraud-shaded triangle meshes
  (type 5) are based on the 
 same geometrical construct as type 4, but with vertices specified as a 
 pseudorectan-gular lattice.",NA
•,"Coons patch meshes
  (type 6) construct a shading from one or more color 
  
 patches, each bounded by four Bézier curves.",NA
•,"Tensor-product patch meshes
  (type 7) are similar to type 6, but with 16 
 control 
  
 points in each patch instead of 12. 
  
 Table 4.11 shows the entries that all shading dictionaries share in common; 
 entries specific to particular shading types are described in the relevant 
 sections below. 
  
 Note: 
 Many of the following descriptions refer to “the coordinate space into 
 which the shading is painted.” For shadings used with a type 2 pattern 
 dictionary, this is the",NA
•,"If 
 ColorSpace
  is a device color space different from the native color space 
 of the output device, color values in the shading will be converted to the 
 native color space using the standard conversion formulas described in 
 Section 7.2, “Con-versions among Device Color Spaces.” To optimize 
 performance, these conver-sions may take place at any time (either 
 before or after any interpolation on the color values in the shading). Thus, 
 shadings defined with device color spaces may have color gradient fills 
 that are less accurate and somewhat device-dependent. (This does not 
 apply to axial and radial shadings—shading types 2 and 3—because 
 those shading types perform gradient fill calculations on a single variable 
 and then convert to parametric colors.)",NA
•,"If 
 ColorSpace
  is a CIE-based color space, all gradient fill calculations will be 
 performed in that space. Conversion to device colors will occur only after 
 all interpolation calculations are performed. Thus, the color gradients will 
 be device-independent for the colors generated at each point.",NA
•,"If 
 ColorSpace
  is a 
 Separation
  or 
 DeviceN
  color space and the specified colo-
 rants are supported, no color conversion calculations are needed. If the 
 speci-fied colorants are not supported (so that the color space’s 
 alternativeSpace 
 parameter must be used), gradient fill calculations will be 
 performed in the designated 
 Separation
  or 
 DeviceN
  color space before 
 conversion to the alterna-tive space. Thus, nonlinear 
 tintTransform
  
 functions will be accommodated for the best possible representation of 
 the shading.",NA
•,"If 
 ColorSpace
  is an 
 Indexed
  color space, all color values specified in the 
 shading will be immediately converted to the base color space. 
 Depending on whether the base color space is a device or CIE-based 
 space, gradient fill calculations will be performed as stated above. 
 Interpolation never occurs in an 
 Indexed 
 color space, which is quantized 
 and inappropriate for calculations that assume a continuous range of 
 colors. For similar reasons, an 
 Indexed
  color space is not allowed in any 
 shading whose color values are generated by a function; this ap-plies to 
 any shading dictionary that contains a 
 Function
  entry.",NA
•,"For 0 
 
 x
 
  1, 
 t
 =
 t
 0
 +
  (
 t
 1
  
 t
 0
 )
 x
 
 .",NA
•,"For 
 x
 
  0, if the first value in the 
 Extend
  array is 
 true
 , then 
 t
 =
 t
 0
 ; otherwise, 
 t
  
 is 
  
 undefined and the point is left unpainted.",NA
•,"For 
 x
 
  1, if the second value in the 
 Extend
  array is 
 true
 , then 
 t
 =
 t
 1
 ; 
 otherwise, 
  
 t
  is undefined and the point is left unpainted. 
  
 The value of 
 t
  is then passed as the input argument to the function(s) 
 defined by the shading dictionary’s 
 Function
  entry, yielding the component 
 values of the color with which to paint the point (
 x
 , 
 y
 ). 
  
 Type 3 (Radial) Shadings
  
 Type 3 (radial) shadings define a color blend that varies between two 
 circles. They are commonly used to depict three-dimensional spheres and 
 cones. In addition to the entries in Table 4.11 on page 262, a type 3 shading 
 dictionary includes the entries listed in Table 4.14.",NA
•,"If one of the starting and ending circles entirely contains the other, the 
 shading 
  
 will depict a sphere.",NA
•,"If neither circle contains the other, the shading will depict a cone. If the 
 starting circle is larger, the cone will appear to point out of the page; if 
 the ending circle is larger, the cone will appear to point into the page. 
  
 Type 4 Shadings (Free-Form Gouraud-Shaded Triangle Meshes)
  
 Type 4 shadings (free-form Gouraud-shaded triangle meshes) are 
 commonly used to represent complex colored and shaded three-
 dimensional shapes. The area to be shaded is defined by a path composed 
 entirely of triangles. The color at each vertex of the triangles is specified, 
 and a technique known as Gouraud inter-polation is used to color the 
 interiors. The interpolation functions defining the shading may be linear or 
 nonlinear. In addition to the entries in Table 4.11 on page 262, a type 4 
 shading dictionary includes the entries listed in Table 4.15. 
  
 TABLE 4.15 Additional entries specific to a type 4 shading dictionary
  
 KEY
  
 TYPE
  
 VALUE
  
 DataSource
  
 array, string,
  
 (Required) 
 The sequence of vertex coordinates and colors defining 
 the
  
 BitsPerCoordinate
  
 or file
  
 free-form triangle mesh. 
  
 integer
  
 (Required, unless 
 DataSource
  is an array) 
 The number of bits used to
  
 represent each vertex coordinate. Allowed values are 1, 2, 4, 8, 12, 
 16, 24, and 32. 
  
 BitsPerComponent
  
 integer
  
 (Required, unless 
 DataSource
  is an array) 
 The number of bits used to 
 rep-
  
 resent each color component. Allowed values are 1, 2, 4, 8, 12, and 16. 
  
 BitsPerFlag
  
 integer
  
 (Required, unless 
 DataSource
  is an array) 
 The number of bits used to 
 rep-
  
 resent the edge flag for each vertex (see below). Allowed values of 
 BitsPerFlag
  are 2, 4, and 8, but only the least significant 2 bits in each 
 flag value are used. Allowed values for the edge flag itself are 0, 1, 
 and 2. 
  
 Decode
  
 array
  
 (Required, unless 
 DataSource
  is an array) 
 An array of numbers 
 describing
  
 how to map vertex coordinates and color components into the 
 appropri-ate ranges of values. The decoding method is similar to 
 that used in image dictionaries (see “Sample Decoding” on page 
 299). The ranges are speci-fied as follows: 
  
 [
 x
 min
 x
 max
 y
 min
 y
 max
 c
 1,min
 c
 1,max
  … 
 c
 n
 ,min
 c
 n
 ,max
 ]
  
 Note that only one pair of 
 c
  values should be specified if a 
 Function
  
 entry is present.",NA
•,"An edge flag, expressed in 
 BitsPerFlag
  bits",NA
•,"A pair of horizontal and vertical coordinates, each expressed in 
 BitsPer-
  
 Coordinate
  bits",NA
•,"A set of 
 n
  color components (where 
 n
  is the number of components in the 
 shading’s color space), each expressed in 
 BitsPerComponent
  bits, in the 
 order expected by the 
 setcolor
  operator 
  
 Each set of vertex data must occupy a whole number of bytes; if the total 
 number of bits required is not divisible by 8, the last data byte for each 
 vertex is padded at the end with extra bits, which are ignored. The 
 coordinates and color values are decoded according to the 
 Decode
  array in 
 the same way as in an image diction-ary; see “Sample Decoding” on page 
 299 for details. 
  
 If the shading dictionary contains a 
 Function
  entry, the color data for each 
 vertex must be specified by a single parametric value 
 t
 , rather than by 
 n
  
 separate color components. All linear interpolation within the triangle 
 mesh is done using the 
 t 
 values; after interpolation, the results are passed 
 to the function(s) specified in the 
 Function
  entry to determine the color of 
 each point. 
  
 Type 5 Shadings (Lattice-Form Gouraud-Shaded Triangle Meshes)
  
 Type 5 shadings (lattice-form Gouraud-shaded triangle meshes) are similar 
 to type 4, but instead of using free-form geometry, their vertices are 
 arranged in a 
 pseudorectangular lattice
 , which is topologically equivalent to 
 a rectangular grid. The vertices are organized into rows, which need not be 
 geometrically linear (see Figure 4.15). In addition to the entries in Table 
 4.11 on page 262, a type 5 shading dictionary includes the entries listed in 
 Table 4.16.",NA
•,"Colors are specified for each corner of the unit square, and bilinear 
 interpola-
  
 tion is used to fill in colors over the entire unit square.",NA
•,"Coordinates are mapped from the unit square into a four-sided patch 
 whose sides are not necessarily linear. The mapping is continuous: the 
 corners of the unit square map to corners of the patch, and the sides of 
 the unit square map to sides of the patch, as shown in Figure 4.16.
  
 C
 2
  
 D
 2
  
 v
  
 D
 1
  
 C
 1
  
 u
  
 FIGURE 4.16 
 Coordinate mapping from a unit square to a four-sided Coons patch
  
 The sides of the patch are given by four cubic Bézier curves, 
 C
 1
 , 
 C
 2
 , 
 D
 1
 , and 
 D
 2
 , 
 defined over a pair of parametric variables 
 u
  and 
 v
  that vary horizontally and 
 ver-",NA
 ,"i 
 = 
 0
  
 j
  
 3",NA
 ,"= 
 0
  
 p
 ij
  
 
  
 B
 i
  u 
 ( 
 )
  
  
 B
 j
  v
 ( )",NA
 ,"i 
 = 
 0
  
 j
  
 3",NA
 ,"= 
 0
  
 x
 ij
  
 
  
 B
 i
  u 
 ( )
  
 
  
 B
 j
  v 
 ( )
  
 y u v 
 ( 
  
 )
  
  
 3 
  
 =",NA
 ,"i 
 = 
 0
  
 j
  
 3",NA
 ,"= 
 0
  
 y
 ij
  
 
  
 B
 i
  u 
 ( )
  
 
  
 B
 j
  v 
 ( )
  
 The geometry of the tensor-product patch can be visualized in terms of a 
 cubic Bézier curve moving from the top boundary of the patch to the 
 bottom. At the top and bottom, the control points of this curve coincide 
 with those of the patch’s top (
 p
 00
  … 
 p
 03
 ) and bottom (
 p
 30
  … 
 p
 33
 ) boundary 
 curves, respectively. As the curve moves from the top edge of the patch to 
 the bottom, each of its four control points follows a trajectory that is in turn 
 a cubic Bézier curve defined by the four control points in the corresponding 
 column of the array. That is, the starting point of the moving curve follows 
 the trajectory defined by control points 
 p
 00
  … 
 p
 30
 , the trajectory of the 
 ending point is defined by points 
 p
 03
  … 
 p
 33
 , and those of the two 
 intermediate control points by 
 p
 01
  … 
 p
 31
  and 
 p
 02
  … 
 p
 32
 . Equiva-lently, the 
 patch can be considered to be traced by a Bézier curve moving from the left 
 edge to the right, with its control points following the trajectories defined 
 by the rows of the coordinate array instead of the columns. 
  
 The Coons patch (type 6) is actually a special case of the tensor-product patch 
 (type 7) in which the four internal control points (
 p
 11
 , 
 p
 12
 , 
 p
 21
 , 
 p
 22
 ) are 
 implicit-",NA
4.10 Images,"The PostScript language’s painting operators include general facilities for 
 dealing with sampled images. A 
 sampled image
  (or just “image” for short) is 
 a rectangular array of 
 sample values
 , each representing a color. The image 
 may approximate the appearance of some natural scene obtained through 
 an input scanner or a video camera, or it may be generated synthetically. 
  
  
 FIGURE 4.21 
 Typical sampled image
  
 An image is defined by a sequence of samples obtained by scanning the 
 image array in row or column order. Each sample in the array consists of as 
 many color components as are needed for the color space in which they are 
 specified—for example, one component for 
 DeviceGray
 , three for 
 DeviceRGB
 , 
 four for 
 DeviceCMYK
 , or whatever number is required by a particular 
 DeviceN
  space. Each component consists of a 1-, 2-, 4-, 8-, or 12-bit integer, 
 permitting the rep-resentation of 2, 4, 16, 256, or 4096 different values for 
 each component. 
  
 Depending on LanguageLevel, PostScript implementations differ in the 
 facilities they offer for images:",NA
•,"Most LanguageLevel 1 implementations support only grayscale images—
 that is, ones whose image samples consist of a single gray component. 
 These can be painted by means of the five-operand form of the 
 image
  
 operator. Image sam-ples must consist of 1, 2, 4, or 8 bits per component; 
 12-bit components are not supported. The image’s source data must be 
 provided by a procedure and not directly by a file or string.",NA
•,"A few LanguageLevel 1 implementations have been extended to support 
 color images containing three or four components per sample, 
 interpreted as RGB or CMYK. These can be painted by means of the 
 colorimage
  operator. LanguageLevel 1 products containing this feature 
 are primarily color printers, and also support the 
 setcmykcolor
  operator 
 and 4-color rendering features.",NA
•,"LanguageLevel 2 includes all features of LanguageLevel 1. Additionally, it 
 sup-ports a one-operand form of the 
 image
  operator in which the operand 
 is an 
 image dictionary
 , providing a more general means for specifying the 
 image’s characteristics. Other LanguageLevel 2 features include 12-bit 
 component val-ues, direct use of files or strings as data sources, 
 interpretation of sample values in arbitrary color spaces (such as CIE-
 based), and additional decoding and rendering options.",NA
•,"All implementations support the 
 imagemask
  operator, which paints the 
 cur-rent color through a 
 stencil mask
  specified as a bitmap (see “Stencil 
 Masking”on page 302). However, specification of the operands using an 
 image diction-ary is a LanguageLevel 2 feature.",NA
•,"LanguageLevel 3 supports two additional forms of masking, using 
 explicit 
 masks
  and 
 color key masks.
  These features are described in the sections 
 “Explicit Masking” on page 303 and “Color Key Masking” on page 307. 
  
 There are often several ways to paint a given image, depending on the level 
 of lan-guage features to be used. Fortunately, most properties of images do 
 not depend on how painting is invoked or how operands are represented. 
 The sections that follow frequently refer to specific features, such as 
 colorimage
  or image diction-aries; see the summary above to determine 
 which features are available in a par-ticular PostScript implementation. 
  
 4.10.1 Image Parameters
  
 The properties of an image—resolution, orientation, scanning order, and so 
 forth—are entirely independent of the characteristics of the raster output 
 device on which the image is to be rendered. The PostScript interpreter 
 usually renders images by a sampling and halftoning technique that 
 attempts to approximate the color values of the source as accurately as 
 possible. The actual accuracy achieved depends on the resolution and other 
 properties of the output device.",NA
•,"The format of the source image: number of columns (width), number of 
 rows (height), number of color components per sample, and number of 
 bits per color component",NA
•,"A data source capable of providing the image’s sample data, which consists 
 of 
  
 height
 
 width
 
 components
 
 bits
 
 component 
 bits of information",NA
•,"The correspondence between coordinates in user space and coordinates in 
 the source image space, defining the region of user space that will receive 
 the image",NA
•,"The mapping from component values in the source image to component 
 values 
  
 in the current color space
  
 The PostScript program entirely controls these four aspects of image 
 specifica-tion. 
  
 4.10.2 Sample Representation
  
 The source format for an image can be described by four parameters: 
 width
 , 
 height
 ,
  components
 , and
  bits
 
 component.
  A PostScript program specifies 
 width
 , 
 height
 , and 
 bits
 
 component
  explicitly. The interpreter infers the 
 components 
 parameter as follows:",NA
•,"With the five-operand form of the 
 image
  operator and with 
 imagemask
 , 
  
 components
  is always 1.",NA
•,"With the one-operand (image dictionary) form of the 
 image
  operator, 
 components
  is the number of components in the current color space (see 
 Section 4.8, “Color Spaces”).",NA
•,"With the 
 colorimage
  operator, 
 components
  is specified explicitly as the 
 ncomp 
  
 operand. 
  
 Sample data is represented as a stream of bytes, interpreted as 8-bit 
 integers in the range 0 to 255, obtained from some data source (either 
 returned from a proce-dure or read from a file or string). The bytes 
 constitute a continuous bit stream, with the high-order bit of each byte first. 
 This bit stream is in turn divided into units of 
 bits
 
 component
  bits each, 
 ignoring byte boundaries. Sample values of 12 bits straddle byte 
 boundaries; other sizes never do. Each unit encodes a color component 
 value, given with the high-order bit first.",NA
•,"With the five-operand form of 
 image
 , and with all forms of 
 colorimage
 , the 
 in-teger 0 maps to the number 0.0, the integer 2
 n
  
  1 maps to the number 
 1.0, and intermediate values map linearly to numbers between 0.0 to 1.0.",NA
•,"With the one-operand (dictionary) form of 
 image
 , the mapping is specified 
 ex-
  
 plicitly by the 
 Decode
  entry in the image dictionary.",NA
•,"With 
 imagemask
 , image samples do not represent color values, so mapping 
 is 
  
 not relevant (see Section 4.10.6, “Masked Images”). 
  
 The imaging operators (
 image
 , 
 colorimage
 , and 
 imagemask
 ) can obtain sample 
 data from any of three types of object:",NA
•,"Procedure.
  Whenever the interpreter requires additional sample data, it 
 calls the procedure, which is expected to return a string containing some 
 more data. The amount of data returned by each call is arbitrary. 
 However, returning one or more complete rows at a time simplifies 
 programming, especially when reading image data that appears in-line in 
 a PostScript program. This is the only type of data source permitted in 
 LanguageLevel 1.",NA
•,"File.
  The interpreter simply reads data from the file as necessary. Note 
 that the file can be filtered to perform some kind of decoding or 
 decompression (see Section 3.8.4, “Filters”). This type of data source is a 
 LanguageLevel 2 feature.",NA
•,"String.
  The interpreter simply reads data from the string, reusing the 
 string as many times as necessary to satisfy the needs of the imaging 
 operation. This type of data source is a LanguageLevel 2 feature, though 
 equivalent behavior can be obtained in LanguageLevel 1 by providing a 
 procedure that simply re-turns the same string each time it is called. 
  
 Data sources for images are much the same as those for filters; for further 
 elabo-ration on their semantics, see Section 3.13.1, “Data Sources and 
 Targets.” When reading from a data source causes a PostScript procedure 
 to be invoked, that pro-",NA
•,"Single data source.
  All color components are obtained from the same 
 source, interleaved sample by sample. For example, in a three-component 
 RGB image, the red, green, and blue components for one sample are 
 followed by the red, green, and blue components for the next sample.",NA
•,"Multiple data sources.
  Each color component is obtained from a separate 
 source—for example, all red components from one source, all green 
 compo-nents from a second, and all blue components from a third. If the 
 data sources are strings, they must all be of the same length. If they are 
 procedures, they must all return strings of the same length on any given 
 call. The interpreter calls each procedure in turn, in the order in which 
 they are specified as oper-ands to the 
 colorimage
  operator or in which 
 they appear in the image diction-ary’s 
 DataSource
  array. The procedures 
 may read data from the same file, but they must return their results in 
 separate strings, since the interpreter does not copy this data elsewhere 
 in the course of assembling the values for a single sequence of samples. If 
 the data sources are files, the interpreter may read un-predictable 
 amounts of data from them in unpredictable orders, so they must be 
 completely independent of each other—that is, they must not be the same 
 file, nor filters that ultimately read from the same file. 
  
 A PostScript program specifies which organization to use by means of the 
 multi 
 operand of the 
 colorimage
  operator or the 
 MultipleDataSources
  entry in 
 the image dictionary. Figure 4.22 illustrates some typical organizations for 
 data sources. It also shows the image sample decoding operation.",NA
•,"In the five-operand forms of 
 image
  and 
 imagemask
  and in all forms of 
  
 colorimage
 , there is a separate 
 matrix
  operand.",NA
•,"In image dictionaries, there is a required 
 ImageMatrix
  entry.",NA
•,"The five-operand form of the 
 image
  operator ignores the current color 
 space and always interprets color samples according to the 
 DeviceGray
  
 color space. It does not alter the current color space parameter in the 
 graphics state.",NA
•,"The 
 colorimage
  operator always interprets color samples according to the 
 DeviceGray
 , 
 DeviceRGB
 , or 
 DeviceCMYK
  color space, depending on whether 
 its 
 ncomp
  operand is 1, 3, or 4. It neither reads nor alters the current color 
 space parameter in the graphics state.",NA
•,"The one-operand (dictionary) form of the 
 image
  operator interprets color 
 samples according to the current color space. The number of components 
 per",NA
•,"The 
 imagemask
  operator always interprets its source data as a stencil 
 mask for applying the current color in the current color space (see 
 “Stencil Masking” on page 302). This works for any color space. 
  
 4.10.5 Image Dictionaries
  
 The 
 image
  and 
 imagemask
  operators (but not 
 colorimage
 ) have a one-
 operand form 
 (LanguageLevel 2)
  in which all imaging parameters are 
 bundled together in an 
 image dictionary.
  This arrangement provides more 
 flexibility than the five-operand form of 
 image
  or any form of 
 colorimage
 . 
 The following features are available only by means of image dictionaries:",NA
•,"Use of arbitrary color spaces, such as 
 CIEBasedABC
  or 
 Separation
  spaces",NA
•,User-defined decoding of image sample values,NA
•,Interpolation between samples,NA
•,"Explicit masking and color key masking 
 (LanguageLevel 3)
  
 Every image dictionary contains an entry named 
 ImageType
 , which 
 indicates the general organization of the dictionary and the type of image it 
 represents. 
 The 
 most 
 straightforward 
 are 
 type 
 1 
 dictionaries 
 (LanguageLevel 2)
 . When used with the 
 image
  operator, type 1 defines an 
 opaque rectangular image to be painted in its entirety, completely 
 overlaying any previous marks already existing on the page. Two more 
 image types, 3 and 4 
 (LanguageLevel 3)
 , represent 
 masked images. 
 Images 
 of these types may include transparent areas, allowing previously existing 
 marks to show through. Type 3 and 4 image dictionaries are discussed in 
 Section 4.10.6, “Masked Images.” 
  
 Note: 
 Type 1 dictionaries can be used with the 
 imagemask
  operator to achieve 
 a form of transparent masking known as 
 stencil masking.
  They are subject to 
 certain restrictions when used in this way, however, as detailed below. 
  
 Type 1 Image Dictionaries
  
 Table 4.20 lists the entries in a type 1 image dictionary, some of which are re-
 quired and some optional. There are many relationships among these entries,",NA
•,"The 
 imagemask
  operator, available in all LanguageLevels, uses a 
 monochrome 
  
 (black-and-white) image as a 
 stencil mask
  for painting in 
 the current color.",NA
•,"Type 3 image dictionaries 
 (LanguageLevel 3)
  include an 
 explicit mask
  
 specifying 
  
 which areas of the image to paint and which to mask out.",NA
•,"Type 4 image dictionaries 
 (LanguageLevel 3)
  specify a color or range of 
 colors to be masked out wherever they occur within the image; this 
 technique is known as 
 color key masking.
  
 Note: 
 Although type 3 and 4 image dictionaries are a LanguageLevel 3 
 feature, their effects are commonly simulated in lower LanguageLevels by 
 defining a clipping path enclosing only those of an image’s samples that are 
 to be painted. However, imple-mentation limits can cause 
 limitcheck
  errors if 
 the clipping path is very complex (or if there is more than one clipping path). 
 An alternative way to achieve the effect of a type 3 image dictionary in 
 LanguageLevel 2 is to define the image being clipped as a pattern, make it the 
 current color, and then paint it with the 
 imagemask
  operator. In any case, the 
 LanguageLevel 3 features allow masked images to be placed on the page 
 without regard to the complexity of the clipping path. 
  
 Stencil Masking
  
 The 
 imagemask
  operator operates on a monochrome image, in which each 
 sam-ple is specified by a single bit. However, instead of painting the image 
 in opaque black and white, 
 imagemask
  treats it as a 
 stencil mask
  that is 
 partly opaque and partly transparent. Sample values in the image do not 
 represent black and white pixels; rather, they designate places on the page 
 that should either be marked with the current color or masked out (not 
 marked at all). Areas that are masked out re-tain their former contents. The 
 effect is like applying paint in the current color through a cut-out stencil: a 
 sample value of 1 in the image permits the paint to reach the page and a 0 
 masks it out, or vice versa. 
  
 A program invokes 
 imagemask
  in much the same way as 
 image
 ; most of the 
 parameters have equivalent meanings. As with 
 image
 , there is a five-
 operand form available in all LanguageLevels and a one-operand image 
 dictionary form that is a LanguageLevel 2 feature. 
 imagemask
  differs from 
 image
  in the following significant ways:",NA
•,"The number of components per sample is always 1, regardless of the 
 current color space, because sample values represent masking properties 
 rather than colors.",NA
•,"The number of bits per component is always 1. In its five-operand form, 
 imagemask
  has no 
 bits/sample
  operand; in the one-operand (image 
 dictionary) form, the dictionary’s 
 BitsPerComponent
  value must be 1.",NA
•,"The five-operand form of 
 imagemask
  includes a 
 polarity
  operand that 
 deter-mines how the source samples are to be interpreted. If 
 polarity
  is 
 true
 , a sample value of 1 designates a painted sample and 0 designates a 
 masked (unpainted) sample; if 
 false
 , these meanings are reversed. The 
 one-operand form of 
 imagemask
  uses the 
 Decode
  entry in the image 
 dictionary for the same pur-pose: 
 Decode
  arrays of 
 [1  0]
  and 
 [0  1]
  
 correspond to 
 polarity
  values of 
 true
  and 
 false
 , respectively. 
  
 One of the most important uses of stencil masking is for painting character 
 glyphs represented as bitmaps. Using such a glyph as a stencil mask 
 transfers only its “black” bits to the page, while leaving the “white” bits 
 (which are really just background) unchanged. For reasons discussed in 
 Section 5.5, “Font Cache,”
 imagemask
  rather than 
 image
  should almost 
 always be used to paint glyph bit-maps. 
  
 Note: 
 If image interpolation is requested during stencil masking, the effect is 
 to smooth the edges of the mask, not to interpolate the painted color values 
 (see “Image Interpolation” on page 301). This can minimize the “jaggy” 
 appearance of a low-resolution stencil mask. 
  
 Explicit Masking
  
 Type 3 image dictionaries combine a sampled image with an 
 explicit mask.
  
 The image and mask need not have the same resolution, but their positions 
 on the page must coincide; that is, they must overlay each other. The mask 
 is treated essentially the same as the stencil mask supplied to the 
 imagemask
  operator: it indicates which places on the page are to be painted 
 and which are to be masked out (left unchanged). Unmasked areas are 
 painted with the corresponding por-tions of the sampled image; masked 
 areas are not. 
  
 Table 4.22 lists the entries in a type 3 image dictionary. The properties of 
 the image and the mask are defined by two subsidiary dictionaries, an 
 image data dic-tionary
  (
 DataDict
 ) and a 
 mask dictionary
  (
 MaskDict
 ). Both are 
 ordinary type 1 image dictionaries with a few additional restrictions on 
 their contents, as detailed in Tables 4.23 and 4.24. The only other 
 significant entry is 
 InterleaveType
 , which specifies the format in which the 
 image and mask data are organized: the mask samples may be included in 
 the same data source with the image samples or pro-vided separately, 
 depending on the interleave type. In general, any inconsistency among the 
 three dictionaries or violation of the stated restrictions will result in a 
 typecheck
  error.",NA
Fonts,"THIS CHAPTER DESCRIBES the special facilities in the PostScript language 
 for dealing with text—more generally, for representing characters with 
 glyphs
  from 
 fonts
 . A glyph is a graphical shape and is subject to all graphical 
 manipulations, such as coordinate transformation. Because of the 
 importance of text in most page descriptions, the PostScript language 
 provides higher-level facilities that permit a program to describe, select, 
 and render glyphs conveniently and effi-ciently. 
  
 The first section is a general description of how fonts are organized and 
 accessed. This description covers all normal uses of fonts that are already 
 installed. 
  
 The information in subsequent sections is somewhat more complex, but is 
 re-quired only by programs with sophisticated needs. These sections 
 discuss the or-ganization of font dictionaries, the encoding scheme that 
 maps character codes to character names and glyph descriptions, the 
 metric information available for fonts,  the operation of the font cache, and 
 the construction of new fonts. 
  
 Details of the individual PostScript operators are given in Chapter 8. All 
 facilities are supported by LanguageLevel 1 except those specifically 
 documented as LanguageLevel 2 or LanguageLevel 3 features. Some of the 
 LanguageLevel 2 fea-tures are also available as part of composite font 
 extensions; see Appendix A for details.",NA
5.1 Organization and Use of Fonts,"A 
 character
  is an abstract symbol, whereas a 
 glyph
  is a specific rendering of 
 a char-acter. For example, the glyphs 
 A
 ,
 A
 , and 
 A
  are renderings of the 
 abstract “A” char-acter. Historically these two terms have often been used 
 interchangeably in",NA
•,"FSD
  takes a variable name, a scale factor, and a font name. It generates a 
 font dictionary described by the font name and scale factor, then executes 
 def
  to as-sociate the font dictionary with the variable name. This assists in 
 setting up fonts.",NA
•,"SMS
  takes a string, a pair of coordinates, and a font dictionary; it shows the 
  
 glyphs for the string starting at those coordinates, using the specified font.",NA
•,"MS
  takes a string and a pair of coordinates; it shows the glyphs for the 
 string at 
  
 those coordinates, using the current font. 
  
 At the beginning of the document script, the program sets up font 
 dictionaries and associates them with the names 
 F1
 , 
 F2
 , and 
 F3
 . The body of 
 the script shows text using the procedures and font dictionaries defined 
 earlier. This example avoids switching fonts when it is unnecessary to do 
 so; taking care in this respect is important for efficient execution. 
  
 Many applications must switch frequently among arbitrarily named fonts, 
 where the names and sizes are not known in advance. To facilitate this, the 
 operator 
 selectfont
 (LanguageLevel 2) 
 combines the actions of the 
 findfont
 , 
 scalefont
  (or",NA
ABC,"FIGURE 5.2 
 Glyphs painted in 50% gray",NA
ABC,"FIGURE 5.3 
 Glyph outlines treated as a path
  
 Example 5.5 obtains the glyphs’ path as before, then establishes it as the 
 current clipping path. All subsequent painting operations will mark the 
 page only within this path, as illustrated in Figure 5.4. This state persists 
 until some other clipping path is established—for example, by the 
 grestore
  
 operator.",NA
ABC,"FIGURE 5.4 
 Graphics clipped by a glyph path
  
 5.1.4 Glyph Positioning
  
 A glyph’s 
 width
  is the amount of space the glyph occupies along the baseline 
 of a line of text. In other words, it is the distance the current point moves 
 when the glyph is shown. Note that the width is distinct from the 
 dimensions of the glyph outline (see Section 5.4, “Glyph Metric 
 Information”). 
  
 In some fonts, the width is constant; it does not vary from glyph to glyph. 
 Such fonts are called 
 fixed-pitch
  or 
 monospaced
 . They are used mainly for 
 typewriter-style printing. However, most fonts used for high-quality 
 typography associate a different width with each glyph. Such fonts are 
 called 
 proportional
  fonts or 
 variable-pitch
  fonts. In either case, the 
 show
  
 operator positions the glyphs for consecutive characters of a string 
 according to their widths. 
  
 The width information for each glyph is stored in the font dictionary. A 
 PostScript program can use any of several glyph-painting operators—
 show
 , 
 xshow
 , 
 yshow
 , 
 xyshow
 , 
 widthshow
 , 
 ashow
 , 
 awidthshow
 —to obtain a variety of 
 width modification effects. If necessary, it can execute 
 stringwidth
  to obtain 
 the width information itself.",NA
5.2 Font Dictionaries,"Font dictionaries are ordinary dictionary objects, but with certain special 
 entries. The PostScript language has several operators that deal with font 
 dictionaries (see Chapter 8). Some of the contents of a font dictionary are 
 optional and user-definable, while other entries 
 must
  be present and have 
 the correct semantics in order for the PostScript interpreter’s font 
 machinery to operate properly. 
  
 In addition to fonts, LanguageLevel 3 supports two classes of font-related 
 objects, called 
 CIDFonts
  and 
 CMaps
 , described in Section 5.11, “CID-Keyed 
 Fonts.” 
  
 There are several kinds of fonts, distinguished by the 
 FontType
  entry in the 
 font dictionary. Each type of font has its own conventions for organizing 
 and repre-senting the information within it. Fonts of type 1, 2, 3, 14, and 42 
 are called 
 base fonts
 . The standard font types defined at present are listed 
 in Table 5.1.",NA
•,"Execution of the 
 findfont
  operator causes the interpreter to locate a font file 
 in 
  
 external storage and to load its definition into VM on demand.",NA
•,"The PostScript program defines the font explicitly, by including a copy of 
 the font file embedded directly within the job. (To facilitate document 
 manage-ment, a PostScript program containing an embedded font 
 program should use appropriate document structuring comments; see 
 Adobe Technical Note #5001, 
 PostScript Language Document Structuring 
 Conventions Specification
 .) 
  
 In either case, the PostScript interpreter executes the font program. For 
 some font types, a font program consists entirely of ordinary operators, 
 such as 
 dict
 , 
 begin
 , 
 end
 , and 
 def
 , that construct the font dictionary directly. 
 For other font types, a font program invokes a special-purpose operator, 
 such as 
 StartData
 , that inter-prets binary-encoded font data appearing in-
 line and constructs a font dictionary using material extracted from that 
 data. 
  
 The font program makes the new font dictionary known to the interpreter 
 by ex-ecuting the 
 definefont
  operator. 
 definefont
  takes a name and a 
 dictionary, checks that the dictionary is a well-formed font dictionary, 
 makes the dictionary’s access read-only, and associates the font name with 
 the dictionary in the font directory. It performs additional modifications 
 that are documented in the 
 definefont
  op-erator description in Chapter 8. 
 Successful execution of 
 definefont
  makes the font dictionary 
 valid
  for use by 
 other font operators (an 
 invalidfont
  error will oc-cur otherwise). 
  
 The operator 
 undefinefont
 (LanguageLevel 2)
  removes a named font from 
 the font directory. A font dictionary that has been removed in this fashion is 
 still a valid font (assuming it is still accessible), but it can no longer be 
 returned by 
 findfont
 . 
  
 In LanguageLevels 2 and 3, fonts are actually a special case of 
 named 
 resources
 : a font is an instance of the 
 Font
  resource category. The 
 findfont
 , 
 definefont
 , and 
 undefinefont
  operators are merely conveniences for invoking 
 findresource
 , 
 defineresource
 , and 
 undefineresource
 . Other classes of font-
 related objects, CIDFonts and CMaps, are ordinarily defined as instances of 
 separate resource",NA
•,"Some applications use 
 FamilyName
  as part of a hierarchical font-selection 
 user interface. This divides a very large set of individual fonts into a 
 smaller, more manageable set of “font families.” The 
 FamilyName
  
 parameter should be suit-able for use in a font selection menu.",NA
•,"Typically, 
 FullName
  begins with 
 FamilyName
  and continues with various 
 style descriptors separated by spaces—for example,
  Adobe Garamond Bold 
 Italic
 . In some designs, a numbering system replaces or augments verbal 
 descriptors—for example, 
 Univers 55 Medium
 .",NA
•,"Weight
  is derived from the 
 FullName
  parameter by dropping everything 
 from 
 FullName
  that does not explicitly relate to weight. For example, the 
 FullName 
 entry 
 ITC Franklin Gothic Condensed Extra Bold Oblique
  reduces to 
 a 
 Weight
  en-try of 
 Extra Bold
 .",NA
•,"The font dictionary’s 
 FontName
  parameter, which is also usually used as 
 the key passed to 
 definefont
 , is a condensation of 
 FullName
 . It is customary 
 to re-move spaces and to limit its length to fewer than 40 characters. The 
 resulting name should be unique.",NA
5.3 Character Encoding,"Font definitions use a flexible 
 encoding
  scheme by which character codes 
 select glyph descriptions. The association between character codes and 
 glyph descrip-tions is not part of the glyph descriptions themselves, but 
 instead is described by a separate 
 encoding vector
 . A PostScript program 
 can change a font’s encoding vector to match the requirements of the 
 application generating the description. 
  
 This section describes the character encoding scheme used with base fonts. 
 Com-posite fonts (Type 0) use a more complicated character mapping 
 algorithm, as discussed in Section 5.10, “Composite Fonts.” 
  
 Note: 
 Every base font must have an 
 Encoding
  entry, which the PostScript font 
 ma-chinery accesses automatically as described below. A Type 3 font’s 
 BuildChar
  proce-dure should use this entry in the standard way; see Section 
 5.7, “Type 3 Fonts.” 
  
 In a font dictionary, the descriptions of the individual glyphs are keyed by 
 char-acter 
 names
 , not by character 
 codes
 . Character names are ordinary 
 PostScript name objects. Descriptions of Latin alphabetic characters are 
 normally associated with names consisting of single letters, such as 
 A
  or 
 a
 . 
 Other characters are associ-ated with names composed of words, such as 
 three
 , 
 ampersand
 , or 
 parenleft
 .",NA
•,"It permits showing text that is encoded according to any of the various 
 existing conventions. For example, the Microsoft Windows and Apple Mac 
 OS operat-ing systems use different standard encodings for Latin text, 
 and many applica-tions use their own special-purpose encodings.",NA
•,"It allows applications to specify how characters selected from a large 
 character set are to be encoded. Some character sets consist of more than 
 256 characters, including ligatures, accented characters, and other 
 symbols required for high-quality typography or non-Latin writing 
 systems. Different encodings can se-lect different subsets of the same 
 character set. 
  
 Latin-text font programs produced by Adobe Systems use the “Adobe 
 standard”encoding 
 vector, 
 which 
 is 
 associated 
 with 
 the 
 name 
 StandardEncoding
  in 
 systemdict
 . An alternate encoding vector called ISO 
 Latin-1 is associated with the name 
 ISOLatin1Encoding
 . Complete details of 
 these encodings and of the charac-ters present in typical fonts are provided 
 in Appendix E. 
  
 All unused positions in an encoding vector must be filled with the character 
 name
 .notdef
 . Like any other character name, the name 
 .notdef
  is defined in 
 the 
 CharStrings 
 dictionary. If an encoding maps to a character name that 
 does not exist in the font, the name 
 .notdef
 is substituted. Every font must 
 contain a glyph description for the 
 .notdef
  character. The effect produced by 
 showing the 
 .notdef 
 character is at the discretion of the font designer. In 
 Type 1 font programs pro-duced by Adobe, it is the same as the space 
 character. 
  
 The 
 glyphshow
  operator 
 (LanguageLevel 2)
  shows the glyph for a single 
 character specified by name instead of by character code. This allows direct 
 access to any character in the font regardless of the font’s 
 Encoding 
 array. 
 The principal use of 
 glyphshow
  is in defining fonts whose glyph descriptions 
 refer to other characters in the same or a different font. Referring to such 
 characters by name ensures proper behavior if the font is subsequently 
 reencoded.",NA
5.4 Glyph Metric Information,"The
  glyph coordinate system
  is the space in which an individual character’s 
 glyph is defined. All path coordinates and metrics are interpreted in glyph 
 space. Figure 5.6 shows a typical glyph outline and its metrics. 
  
 Glyph
  
 bounding
  
     
  
 box
  
  
   
 Next 
 Glyph 
  
 glyph 
 origin 
  
 origin
  
 Left sidebearing
  
 Glyph width
  
 FIGURE 5.6 
 Glyph metrics
  
 The 
 glyphorigin
 , or 
 reference point
 , is the point (0, 0) in the glyph 
 coordinate sys-tem. 
 show
  and other glyph-painting operators position the 
 origin of the first glyph to be shown at the current point in user space. For 
 example, 
  
 40  50  moveto 
  
 (ABC) show
  
 places the origin of the 
 A
  at coordinate (40, 50) in the user coordinate system. 
  
 The 
 glyph width
  is the distance from the glyph’s origin to the point at which 
 the origin of the 
 next
  glyph should normally be placed when painting the 
 consecutive glyphs of a word. This distance is a vector in the glyph 
 coordinate system; it has 
 x 
 and 
 y
  components. Most Indo-European 
 alphabets, including the Latin alphabet, have a positive 
 x
  width and a zero 
 y
  
 width. Semitic alphabets have a negative 
 x 
 width, and some Asian writing 
 systems have a nonzero
  y
  width. 
  
 The 
 glyph bounding box
  is the smallest rectangle (oriented with the axes of the 
 glyph coordinate system) that will just enclose the entire glyph shape. The",NA
5.5 Font Cache,"The PostScript interpreter includes an internal data structure called the 
 font cache 
 whose purpose is to make the process of painting glyphs very 
 efficient. For the most part, font cache operation is automatic. However, 
 fonts whose glyph de-scriptions are PostScript procedures, such as Type 3 
 fonts, must adhere to certain",NA
•,"The original base font or CIDFont dictionary from which the glyph 
 description 
  
 was obtained.",NA
•,"The 
 character selector
 , which is a character name in a base font or a CID 
 (char-
  
 acter identifier) in a CIDFont; see Section 5.11, “CID-Keyed Fonts.”",NA
•,"The current transformation matrix (CTM) at the time the glyph is shown. 
  
 To ensure predictable behavior despite font caching, a given combination of 
 font and character selector must always produce the same appearance 
 when rendered. Means exist to provide reliable identification of a font 
 definition; see the next sec-tion. Note that a character code is 
 not
  part of the 
 glyph identification in the font cache, since a given glyph may be selected in 
 more than one way.",NA
5.6 Unique ID Generation,"A 
 unique ID
  is an optional entry in a font dictionary that helps identify the 
 font to the interpreter. Its primary purpose is to identify cached glyphs 
 built from that font. The PostScript interpreter can retain glyphs in the font 
 cache even for a font that is not permanently in virtual memory. Some 
 implementations can save cached glyphs on disk. This can have a beneficial 
 effect on performance when us-ing fonts that are loaded into VM 
 dynamically, either by explicit downloading or automatically via the 
 resource facility. 
  
 If a font has a unique ID, the interpreter can recognize that the cached 
 glyphs be-long to that font, even if the font dictionary itself is removed from 
 VM and is later reloaded (by a subsequent job, for instance). If a font does 
 not have a unique ID, the interpreter can recognize cached glyphs for that 
 font only while it remains in VM. When the font is removed, the cached 
 glyphs must be discarded. 
  
 Correct management of unique IDs is essential to ensure predictable 
 behavior. If two fonts have the same unique ID but produce glyphs with 
 different appearanc-es when executed, it is unpredictable which glyphs will 
 appear when those fonts are used. Therefore, unique IDs must be assigned 
 systematically from some cen-tral registry. 
  
 The reason that font caching is based on a special unique ID entry rather 
 than on the font’s name or other identifying information is that font names 
 are not neces-sarily unique. A font with a particular name, such as 
 Garamond-Bold, may be",NA
•,The organization ID of the originator of the program,NA
•,"The 
 XUID
  array elements from the original font",NA
•,"Additional elements indicating exactly what modifications have been per-
  
 formed 
  
 PostScript interpreters that recognize the 
 XUID
  array ignore 
 UniqueID
  
 whenever an 
 XUID
  entry is present. For backward compatibility with the 
 installed base of interpreters, font creator and font modifier software 
 should continue to use and maintain appropriate 
 UniqueID
  numbers for the 
 foreseeable future.",NA
5.7 Type 3 Fonts,"A Type 3 font is one whose behavior is determined entirely by PostScript 
 proce-dures. In contrast, most other types of base fonts originate as font 
 programs that conform to an external specification, such as 
 Adobe Type 1 
 Font Format
 , that has",NA
•,"setcachedevice
  establishes a single set of metrics for both writing modes, 
 and 
  
 requests that the interpreter save the results in the font cache if 
 possible.",NA
•,"setcachedevice2
 (LanguageLevel 2)
  establishes separate sets of metrics for 
 writ-ing modes 0 and 1, and requests that the interpreter save the results 
 in the font cache.",NA
•,"setcharwidth
  passes just the glyph’s width (to be used only once), and 
 requests that the glyph 
 not
  be cached. This operator is typically used only 
 if the glyph description includes operators to set the color explicitly. 
  
 See the descriptions of 
 setcachedevice
 , 
 setcachedevice2
 , and 
 setcharwidth
  in 
 Chapter 8 for more information. 
  
 After executing one of these operators, 
 BuildGlyph
  should execute a 
 sequence of graphics operators to perform path construction and painting. 
 The PostScript in-terpreter transfers the results into the font cache, if 
 appropriate, and onto the page at the correct position. It also uses the width 
 information to control the spacing between this glyph and the next. The 
 final position of the current point in the glyph coordinate system does not 
 influence glyph spacing. 
  
 5.7.2 BuildChar
  
 In LanguageLevel 2 or 3, if there is no 
 BuildGlyph
  procedure for the font, the 
 in-terpreter calls the 
 BuildChar
  procedure instead. In LanguageLevel 1, 
 BuildChar
  is always called, whether or not a 
 BuildGlyph
  procedure is present. 
  
 The semantics of 
 BuildChar
  are essentially the same as for 
 BuildGlyph
 . The 
 only difference is that 
 BuildChar
  is called with the font dictionary and the 
 character code
  on the operand stack, instead of the font dictionary and the 
 character name
 . The 
 BuildChar
  procedure must then perform its own 
 lookup to determine what glyph description corresponds to the given 
 character code. 
  
 For backward compatibility with the installed base of LanguageLevel 1 
 interpret-ers, all new Type 3 fonts should contain the following 
 BuildChar
  
 procedure: 
  
 /BuildChar 
  
  
 { 
  
 1 index /Encoding get exch get 
  
  
  
 1 index /BuildGlyph get exec 
  
  
 } bind def",NA
5.8 Additional Base Font Types,"This section describes additional base font types besides Type 1 and Type 
 3: Type 2 (CFF), Type 14 (Chameleon), and Type 42 (TrueType). These 
 three addi-tional font formats are LanguageLevel 3 features. 
  
 5.8.1 Type 2 and Type 14 Fonts (CFF and Chameleon)
  
 The Type 2 (Compact Font Format, or CFF) and Type 14 (Chameleon) font 
 for-mats are compact representations that enable multiple fonts to be 
 stored in a unit called a 
 font set
 . A font set is an instance of a resource 
 category named 
 FontSet
 . This category is distinct from the 
 Font
  category; 
 however, the constituent fonts in a font set are also available as instances of 
 the 
 Font
  category and can be accessed by 
 findfont
  or 
 findresource
 . 
  
 These formats are not expressed in PostScript language syntax, but as 
 binary-encoded data structures that are decoded by specialized 
 interpreters. The binary font data is enclosed, or “wrapped,” in a minimal 
 amount of PostScript syntax, yielding a file that can be treated as an 
 external resource in the 
 FontSet
  category. When a constituent font is 
 accessed by 
 findfont
 , the resulting PostScript font dic-tionary has a 
 FontType
  
 value of 2 for CFF or 14 for Chameleon. 
  
 CFF is a representation of one or more fonts based on the Type 1 charstring 
 for-mat. It retains full fidelity to the original fonts, while achieving 
 significant space reduction due to a compact binary representation and 
 sharing of data that is common to multiple fonts. For more information on 
 this format, see Adobe Technical Note #5176, 
 Compact Font Format 
 Specification. 
  
 The Chameleon font format is an implementation of a “shape library” that 
 allows compact representations of Latin-text fonts. This format consists of a 
 master font and its 
 font descriptor
  database: the master font is tailored to 
 address the needs of a particular product, while the font descriptors define 
 how to extract fonts of in-terest from the master. The details of the 
 Chameleon font format are not docu-mented. 
  
 Typically, for a product’s built-in fonts, there is one font set for all CFF fonts 
 and one each for a Chameleon master font and its descriptor database. 
 Additional font sets can be installed on disk or embedded in a PostScript 
 page description.",NA
•,"An entry in its 
 CharStrings
  dictionary is ordinarily a 
 glyph index
 —an 
 integer used as an index into the binary data for the font. (The 
 interpretation of a glyph index is internal to the font; it has no external 
 significance and, in partic-ular, has nothing to do with a character code.) 
 A PostScript program can re-place this integer with a procedure; see 
 Section 5.9.3, “Replacing or Adding Individual Glyphs.”",NA
•,"It does not contain a 
 Private
  entry.",NA
•,"It has additional entries that are undocumented and subject to change. 
  
 A PostScript program can copy the font dictionary and insert or modify 
 entries as specified in the aforementioned tables. These modifications have 
 the same effects as for Type 1 fonts. 
  
 In Adobe PostScript implementations, there exists a fictitious file system 
 named 
 %fontset%
 , whose “files” are the constituent fonts in all available 
 FontSet
  resource",NA
•,"The value of 
 StrokeWidth
  (when 
 PaintType
  has been set to 2)",NA
•,"The contents of the 
 Metrics
  and 
 Metrics2
  dictionaries",NA
•,"The operands and result of the 
 CDevProc
  procedure",NA
•,"The values of 
 UnderlinePosition
  and 
 UnderlineThickness
  in the 
 FontInfo
  dic-
  
 tionary",NA
5.9 Font Derivation and Modification,"A PostScript program can perform various useful manipulations on existing 
 font dictionaries. These manipulations fall into two categories:",NA
•,"Derive a new font by copying an existing one and modifying certain things 
 in the copy, such as the encoding vector, character set, glyph metrics, or 
 other en-tries affecting the font’s behavior.",NA
•,"Alter an existing font in place, without copying it. This is permitted only 
 under certain circumstances; it is useful mainly for incremental definition 
 of glyph descriptions. 
  
 When such modifications are performed, considerable care must be taken 
 to en-sure predictable behavior despite font caching. When creating a new 
 font derived from an existing one, a PostScript program must manage the 
 unique ID properly to ensure that the interpreter can distinguish between 
 the fonts; see Section 5.6,“Unique ID Generation.” Alterations to an existing 
 font must be limited to the cases described below; the font machinery 
 consults the font dictionary at unpre-dictable times and will not necessarily 
 detect modifications made in violation of these guidelines. 
  
 All of the facilities described in this section are PostScript language 
 features, which are intended to be applied to font dictionaries already 
 existing in Post-Script VM. They are 
 not
  part of the external font format 
 specifications, such as 
 Adobe Type 1 Font Format
 . It is inappropriate to 
 create external font programs that use these features, since they will not 
 work with font interpreters (such as the Adobe Type Manager
 ®
  software) 
 that lack a PostScript interpreter.",NA
•,"A single number, specifying a new 
 x
  width only (the 
 y
  value is 0)",NA
•,"An array of two numbers, specifying the 
 x
  components of a new left 
 sidebear-
  
 ing and new width (the 
 y
  values are 0)",NA
•,"An array of four numbers, specifying the 
 x
  and 
 y
  components of the left 
 side-
  
 bearing followed by 
 x
  and 
 y
  components of the width 
  
 These forms can be intermixed in one 
 Metrics
  dictionary. All of the numeric 
 val-ues are expressed in the glyph coordinate system of the font.",NA
•,"Before executing a 
 CharStrings
  procedure, the PostScript interpreter first 
 push-es 
 systemdict
  and then the font dictionary on the dictionary stack, 
 and pushes either the character code or the character name on the 
 operand stack. The op-erand is a character code if the interpreter is in the 
 midst of an ordinary 
 show 
 operation or any 
 show
  variant that takes a 
 string operand; it is a character name if the interpreter is executing the 
 glyphshow
  operator 
 (LanguageLevel 2)
 .",NA
•,"After executing the procedure, the PostScript interpreter pops the two 
 dictio-naries that it pushed on the dictionary stack. It expects the 
 procedure to have consumed the character code or character name 
 operand. 
  
 Because a 
 CharStrings
  procedure must be able to accept either a character 
 code or a character name as an operand, it is strongly recommended that 
 every 
 CharStrings
  procedure begin as follows: 
  
 dup type /integertype eq 
  
  
  
 {/Encoding load exch get} 
  
  
 if
  
 This ensures that the object on the stack is a name object, which the 
 procedure can now use to look up the glyph description. If the glyph 
 description is con-tained in the 
 CharStrings
  procedure itself, the procedure 
 can simply discard its operand. 
  
 Note that when executing a 
 CharStrings
  procedure, the PostScript interpreter 
 does not consult the value of 
 Metrics
 , 
 Metrics2
 , or 
 CDevProc
 . 
  
 5.9.4 Subsetting and Incremental Definition of Glyphs
  
 When an application or driver must embed a font definition in a PostScript 
 page description, it may choose not to embed the entire font. Instead, it can 
 create and embed a 
 subset
  font that contains only the glyph descriptions 
 that are actually ref-erenced from 
 show
  strings in the document. This 
 practice reduces communica-tion costs and VM use, but at the expense of 
 considerable effort by the application to analyze the use of glyphs in the 
 document and reconstruct the font program.",NA
•,"A glyph description may only be 
 added
  to a font. It may not replace an 
 existing 
  
 glyph description with a different value.",NA
•,"The glyph description for a particular character name must be defined 
 before 
  
 the first 
 show
  operation that selects this character.",NA
•,"If a glyph description is added to a font in local VM between 
 save
  and 
 restore 
 operations (such as the ones that usually bracket each page of a 
 document), the 
 restore
  operation will remove the glyph description. The 
 application or driver that is embedding incremental glyph descriptions in 
 the document must be aware of this behavior; it must define the glyph 
 description again (with the same value) before the next use of that glyph. 
  
 These rules ensure predictable behavior despite font caching. A 
 show
  
 operation may obtain a previously rendered glyph from the font cache, 
 without consulting the glyph description at all. For consistent results, a 
 given character name must always map to the same glyph description any 
 time a 
 show
  operation might refer-ence it. 
  
 In font types that support overriding of glyph metrics, the contents of the 
 Metrics 
 and 
 Metrics2
  dictionaries may be defined incrementally, subject to 
 the same rules that apply to the glyph descriptions themselves. 
  
 Additionally, the contents of the 
 Encoding
  array in a base font may be 
 defined in-crementally. This is a convenience in the situation where the 
 application invents not only the character set but also the character 
 encoding as it goes along. Similar rules apply to incremental definition of 
 the 
 Encoding
  array:",NA
•,"A character name may replace only the name 
 .notdef
 , thereby defining a 
 char-acter name for a previously unused character code. It may not 
 replace an exist-ing array element whose value is any name other than 
 .notdef
 .",NA
•,"The 
 Encoding
  array entry for a particular character code must be defined 
 be-
  
 fore the first 
 show
  operation that selects this code.",NA
•,"The same considerations about 
 save
  and 
 restore
  operations apply to the 
  
 Encoding
  array as to glyph descriptions.",NA
•,The TrueType “loca” and “glyf” tables must not be present.,NA
•,"There must be a TrueType “gdir” table whose size and offset are 0. This is 
 sim-ply an indication that the TrueType font was constructed for 
 incremental downloading; the “gdir” table contains no useful information. 
  
 A TrueType glyph description can contain references to one or more other 
 glyphs in the same font—for example, to produce accented characters. 
 These references are by glyph index. An incrementally downloaded font 
 containing such glyphs must also contain all component glyphs that they 
 reference. 
  
 A TrueType glyph’s metrics are not part of the glyph description itself; 
 rather, they come from a parallel table, “hmtx,” which is also indexed by 
 glyph index. No provision is made for downloading the contents of the 
 “hmtx” table incremental-ly; this information must be present at the time 
 the font is defined. The metrics may be overridden, if desired, by entries in 
 the 
 Metrics
  and 
 Metrics2
  dictionaries, which may be defined incrementally.",NA
5.10 Composite Fonts,"This section describes how to build 
 composite fonts
 —fonts with a 
 FontType
  
 of 0. Base fonts (fonts of type 1, 2, 3, 14, or 42) contain individual glyph 
 descriptions; composite fonts are combinations of base fonts, with Type 0 
 font dictionaries ty-ing them together. 
  
 The ability to use composite fonts is supported by LanguageLevels 2 and 3 
 and by LanguageLevel 1 implementations that have the composite font 
 extensions. Addi-tionally, LanguageLevel 3 introduces support for a special 
 class of composite fonts called 
 CID-keyed fonts
 , described in Section 5.11, 
 “CID-Keyed Fonts”; these fonts can combine CIDFonts as well as base fonts. 
  
 A composite font, then, is a collection of base fonts, CIDFonts, and even 
 other composite fonts, organized hierarchically. The Type 0 font at the top 
 level of the hierarchy is the 
 root font
 . Fonts and CIDFonts immediately 
 below a Type 0 font are called its 
 descendant fonts. 
 The Type 0 font 
 immediately above a descendant font is called its 
 parent font
 . 
  
 When the current font is composite, the 
 show
  operator and its variants 
 behave differently than with base fonts: they use a mapping algorithm that 
 decodes 
 show 
 strings to select characters from any of the descendant base 
 fonts or CIDFonts. This facility supports the use of very large character sets, 
 such as those for the Japanese and Chinese languages. It also simplifies the 
 organization of fonts that have complex encoding requirements. 
  
 In addition to the entries common to all font dictionaries (Table 5.2 on page 
 324), a Type 0 font dictionary includes the entries listed in Table 5.8. 
  
 TABLE 5.8 Additional entries specific to Type 0 fonts
  
 KEY
  
 TYPE
  
 VALUE
  
 FMapType
  
 integer
  
 (Required)
  A code indicating which mapping algorithm to use when 
 inter-
  
 preting the sequence of bytes in a string. See Table 5.9 on page 360. 
  
 Encoding
  
 array
  
 (Required)
  An array of integers, each used as an index to extract a font dic-
  
 tionary from the 
 FDepVector
  array. Note that this is different from the 
 use of 
 Encoding
  in base fonts. 
  
 FDepVector
  
 array
  
 (Required)
  An array of font or CIDFont dictionaries that are the 
 descendants
  
 of this Type 0 font. It is recommended that this array contain no more than",NA
•,"1/7 mapping: 
 <00 80>
  
 The code length is 1 byte. There are two code ranges. The first is explicitly 
 of length 80 hexadecimal; it contains character codes 0 to 127 decimal. 
 The sec-ond code range implicitly contains all remaining characters that 
 can be coded in 1 byte—that is, character codes in the range 128 to 255.",NA
•,"9/7 mapping: 
 <01 0080 0080 … 0080>
  
 The code length is 2 bytes. There are up to 512 code ranges, each 80 
 hexadeci-mal (128 decimal) in size. The 
 SubsVector
  string that describes 
 all 512 code ranges would be 1023 bytes long. Remember that the last 
 code range is speci-fied implicitly.",NA
•,"8/8 mapping: 
 <01 0100 0100 … 0100>
  
 The code length is 2 bytes. There are up to 256 code ranges, each 100 
 hexadeci-mal (256 decimal) in size. The 
 SubsVector
  string that describes 
 all 256 code ranges would be 511 bytes long. The last code range is 
 specified implicitly. 
  
 5.10.2 Other Dictionary Entries for Type 0 Fonts
  
 FontMatrix
  plays the same role in a Type 0 font as it does in a base font. 
 When a glyph is shown, both the font matrix of the Type 0 font and the font 
 matrix of the descendant base font or CIDFont are concatenated to the CTM. 
 (Special consid-erations apply if the descendant of a Type 0 font is itself a 
 Type 0 font; see Section 
 5.10.3, “Nested Composite Fonts
 .”) 
  
 WMode
  is an integer with value 0 or 1, indicating which of two sets of glyph 
 met-rics will be used when glyphs from the base fonts are shown (see 
 Section 5.4,“Glyph Metric Information”). If it is omitted, writing mode 0 will 
 be used. The writing mode of the root font overrides the writing modes of 
 all its descendants. This allows a given base font to be used as part of many 
 composite fonts, some of which use writing mode 0 while some use writing 
 mode 1. 
  
 PrefEnc
  (preferred encoding) is an array that should be the same as the 
 Encoding 
 array of one or more of the descendant base fonts. Characters 
 from descendant fonts whose 
 Encoding
  array is the same as the 
 PrefEnc 
 array of the Type 0 font will be processed more efficiently than characters 
 from other descendant fonts.
  
 The 
 definefont
  operator may insert one or more additional entries in a Type 
 0 font dictionary if they are needed but are not present. 
 FID
  is always 
 inserted; see Table 5.2 on page 324. 
 EscChar
 , 
 ShiftIn
 , and 
 ShiftOut
  are 
 inserted if they are required by the mapping algorithm indicated by the 
 FMapType
  entry. 
 PrefEnc
 , 
 MIDVector
 , and 
 CurMID
  are inserted by some 
 implementations. In a Language-Level 1 implementation that supports the 
 composite font extensions, the font dictionary must be sufficiently large to 
 allow these entries to be inserted.",NA
•,"The parent of an 
 FMapType
  3 font must be of 
 FMapType
  3 or 7. The 
 EscChar 
 entry of the root font overrides the 
 EscChar
  entry of descendant escape-
 mapped fonts.",NA
•,"Fonts with 
 FMapType
  7 and 8 may not be used as descendant fonts.",NA
•,"The occurrence of an escape or shift code in the 
 show
  string causes the 
 map-ping algorithm to ascend the font hierarchy from the currently 
 selected descen-dant font to the nearest parent modal font. If that font’s 
 FMapType
  is 8, the algorithm selects the new descendant according to the 
 shift code. If 
 FMapType 
 is 3 or 7, the algorithm extracts another byte from 
 the 
 show
  string. If the byte is not an escape code, the algorithm uses it as a 
 font number to select a descen-dant of that font. But if the byte is an 
 escape code and 
 FMapType
  is 3, the algo-rithm ascends to the parent of 
 that font, extracts yet another byte from the 
 show
  string, and repeats the 
 selection process.",NA
•,"When a modal font is first encountered, if the next byte of the 
 show
  string 
 is not an escape code, descendant font 0 of the modal font is chosen and 
 the byte is passed down to that font. This also occurs if an escape code is 
 followed by an-other escape code but the currently selected font has no 
 parent. 
  
 Type 0 fonts with the other 
 FMapType
  values (2, 4, 5, 6, 9) are 
 nonmodal,
  in 
 that their mapping algorithm restarts for each new character. Nonmodal 
 fonts follow these rules:",NA
•,"The parent of a nonmodal font may be any Type 0 font, including a modal font.",NA
•,"If the parent of a nonmodal font is a modal font, the modal font’s escape 
 or shift code is recognized only when it appears as the 
 first
  byte of a 
 multiple-byte mapping sequence for the nonmodal font.",NA
•,"If the descendant of a nonmodal Type 0 font is itself a nonmodal Type 0 
 font, the second part (character code) of the value extracted from the 
 show
  string is used in place of the first byte that would be extracted by 
 the descendant font’s mapping algorithm. This rule is independent of the 
 number of bits actually contained in the code contributed by the parent 
 font. 
  
 The 
 FontMatrix
  entries of nested composite fonts are treated in a 
 nonobvious way. When a glyph is shown, the interpreter consults the 
 FontMatrix
  entries of only the selected base font and the immediate parent 
 of the base font. The imme-diate parent’s 
 FontMatrix
  entry contains the 
 concatenation of the 
 FontMatrix
  en-tries of all ancestor fonts. To achieve 
 this, the 
 definefont
 , 
 makefont
 , 
 scalefont
 , and 
 selectfont
  operators give special 
 treatment to any Type 0 font that has at least one descendant Type 0 font:",NA
•,"If the 
 FontMatrix
  value is not the identity matrix, 
 definefont
  constructs a 
 new 
 FDepVector
  array in which each descendant Type 0 font is replaced 
 by the re-sult of performing 
 makefont
  on it using this font matrix. It does 
 not perform 
 makefont
  on descendant base fonts or CIDFonts.",NA
•,"makefont
 , 
 scalefont
 , and 
 selectfont
  apply their transformations recursively to 
  
 all descendant Type 0 fonts but not to base fonts or CIDFonts.",NA
5.11 CID-Keyed Fonts,"CID-keyed fonts provide a convenient and efficient method for defining 
 multi-ple-byte character encodings, base fonts with a large number of 
 glyphs, and com-posite fonts that use these base fonts and character 
 encodings. Additionally, they provide straightforward methods for creating 
 a 
 rearranged font
 , which selects glyphs from one or more existing fonts by 
 means of a revised encoding. These ca-pabilities provide great flexibility for 
 representing text in writing systems for lan-guages with large character 
 sets, such as Chinese, Japanese, and Korean. 
  
 The CID-keyed font architecture specifies the external representation of 
 certain font programs, called 
 CMap
  and 
 CIDFont
  files, along with some 
 conventions for combining and using those files. This architecture is 
 independent of the Post-Script language; CID-keyed fonts can be used in 
 environments where no Post-Script interpreter is present. For complete 
 documentation on the architecture and the file formats, see Adobe 
 Technical Notes #5092, 
 CID-Keyed Font Technolo-gy Overview
 , and #5014, 
 Adobe CMap and CIDFont Files Specification
 .",NA
•,"It enables CID-keyed fonts to be used with PostScript interpreters that do 
 not 
  
 have built-in support for them.",NA
•,"It provides compatibility with applications that access Chinese, Japanese, 
 and Korean fonts according to older conventions for identifying and 
 organizing them. Under this 
 compatibility mode
 , accessing a CID-keyed 
 font sometimes results in a composite font hierarchy in VM that bears 
 little resemblance to the structure of the CMap and CIDFont programs. 
  
 The CSL is not further documented in this book. For information, see Adobe 
 Technical Note #5092, 
 CID-Keyed Font Technology Overview
 . The CSL, 
 certain CMap files, and other related software are available from the Adobe 
 Developers Association. 
  
 5.11.1 The Basics of CID-Keyed Fonts
  
 The term 
 CID-keyed font
  reflects the fact that 
 CID
  (character identifier) 
 numbers are used to index and access the glyph descriptions in the font. 
 This method is more efficient for large fonts than the method of accessing 
 by character name, as is used for base fonts. CIDs range from 0 to a 
 maximum value that is subject to an implementation limit (see Appendix 
 B). 
  
 A 
 character collection
  is an ordered set of all characters needed to support 
 one or more popular character sets for a particular language. The order of 
 the characters in the character collection determines the CID number for 
 each character. Each CID-keyed font must explicitly reference the character 
 collection on which its CID numbers are based; see Section 5.11.2, 
 “CIDSystemInfo Dictionaries.”",NA
•,"The 
 glyphshow
  operator can be used, but it accepts only an integer operand 
  
 specifying a CID as the character selector.",NA
•,"The 
 show
  operator, any 
 show
  variant except 
 glyphshow
 , and the 
 stringwidth 
 and 
 charpath
  operators cannot be used. (Some exceptions to 
 this rule are de-scribed in the section “CMap Mapping” on page 388 and 
 in the 
 cshow
  operator description in Chapter 8.) 
  
 Having a CIDFont as a descendant in a composite font raises certain 
 compatibili-ty issues. Applications that manipulate composite font 
 hierarchies expect all de-scendants to have a 
 FontType
  entry. Furthermore, 
 applications 
 sometimes 
 produce 
 modified 
 descendants 
 (changing 
 PaintType
 , for example) and invoke 
 definefont
  on those fonts. For these 
 reasons, a CIDFont is treated as if it were a font in the following respects:",NA
•,"Every CIDFont dictionary also includes a 
 FontType
  entry (inserted by 
  
 definefont
  or 
 defineresource
 ).",NA
•,"A CIDFont dictionary can be treated as an instance of either the 
 CIDFont
  
 re-source category or the 
 Font
  resource category, with no difference in 
 structure or behavior except the resource category in which the instance 
 gets defined.",NA
•,"All font operators are prepared to recognize either a CIDFont dictionary 
 or a font dictionary. These operators distinguish between a CIDFont and a 
 font by the presence or absence of a 
 CIDFontType
  entry in the dictionary. 
  
 Table 5.11 lists the 
 CIDFontType
  and 
 FontType
  values corresponding to the 
 differ-ent types of CIDFont. Note that references to a CIDFont by type, as in 
 “Type 0 CIDFont,” indicate the font’s 
 CIDFontType
 , not its 
 FontType
 .",NA
•,"A 
 PostScript section
  that defines the CIDFont dictionary, as described below",NA
•,"A 
 binary data section
  that contains all the charstrings and any subroutines 
 that 
  
 they call 
  
 The two sections are separated by an invocation of the 
 StartData
  operator 
 defined in the 
 CIDInit
  procedure set. The binary data section begins 
 immediately follow-ing the white-space character that delimits the 
 StartData
  token. The length of the binary data section is given as an operand 
 to 
 StartData
 . 
 StartData
  processes the binary data, completes the construction 
 of the CIDFont dictionary, and automat-ically invokes 
 defineresource
  to 
 define it as an instance of the 
 CIDFont
  category, using the value of the 
 CIDFontName
  entry as its key. For further information on the construction 
 of a Type 0 CIDFont, see Adobe Technical Note #5014, 
 Adobe CMap and CID 
 Font Files Specification
 . 
  
 The PostScript section defines the CIDFont dictionary, which contains many of 
 the entries found in Type 1 font dictionaries, as well as various other data 
 struc-",NA
•,"defineresource
  inserts a 
 FontMatrix
  entry in the CIDFont dictionary with a 
 value of 
 [.001  0  0  .001  0  0]
  (since Type 0 CIDFonts, like Type 1 fonts, are 
 usu-ally defined in terms of a 1000-unit glyph coordinate system).",NA
•,"In each 
 FDArray
  dictionary, 
 defineresource
  replaces its 
 FontMatrix
  value with 
  
 one scaled by a factor of 1000. 
  
 The 
 Private
  dictionary in the 
 FDArray
  subdictionary of a Type 0 CIDFont 
 serves the same purpose as a 
 Private
  dictionary in a Type 1 font (see 
 Adobe 
 Type 1 Font Format
 ); however, in a Type 0 CIDFont it applies only to those 
 glyphs in the CIDFont that specify its 
 FDArray
  index. Normally an array 
 named 
 Subrs 
 in the 
 Private
  dictionary contains the subroutines, but there is 
 an alternative that is use-ful with CIDFonts: the subroutines can instead be 
 contained in the binary data section of the CIDFont. In this case, the 
 Subrs
  
 array is replaced by the 
 Private
  dic-tionary entries listed in Table 5.15. 
  
 TABLE 5.15 Entries replacing Subrs in the Private dictionary of an FDArray dictionary
  
 KEY
  
 TYPE
  
 VALUE
  
 SubrCount
  
 integer
  
 (Required if 
 Subrs
  is absent)
  The number of subroutines, which are 
 numbered
  
 from 0 to (
 SubrCount
  
  1). If there are no subroutines, 
 SubrCount
  is 0, but
  
 the other two entries must be present nonetheless. 
  
 SDBytes
  
 integer
  
 (Required if 
 Subrs
  is absent)
  The length in bytes of each offset in the 
 subrou-
  
 tine offset table for glyphs referencing this 
 FDArray 
 dictionary. If the 
 length is greater than 1, the bytes within an offset are interpreted high-
 order byte first. 
  
 SubrMapOffset
  
 integer
  
 (Required if 
 Subrs
  is absent)
  The offset in bytes to the subroutine offset 
 table
  
 in the binary data section of the CIDFont. The offset is relative to the 
 begin-ning of the binary data section. The table is indexed by 
 subroutine number. Each entry in the table is 
 SDBytes
  long and is 
 interpreted as the offset to the subroutine relative to the beginning of 
 the binary data section. 
  
 GlyphDirectory for Type 0 CIDFonts
  
 GlyphDirectory
  is a mechanism for the subsetting or incremental definition of 
 glyphs in the CIDFont. Section 5.9.4, “Subsetting and Incremental Definition of",NA
•,"A Type 4 CIDFont requires only a small amount of VM for the font 
 dictionary, in addition to the font cache memory for the glyph bitmaps. In 
 contrast, the equivalent Type 3 font or Type 1 CIDFont requires VM for 
 strings containing all the glyph bitmaps; when the font’s 
 BuildGlyph
  or 
 BuildChar
  procedure is in-voked, those bitmaps are then replicated in the 
 font cache, effectively doubling the storage required.",NA
•,"Installing a glyph directly into the font cache is much more efficient than 
 first defining it in VM and then invoking 
 BuildGlyph
  and 
 imagemask
  to 
 cause the glyph to be installed in the font cache. 
  
 A Type 4 CIDFont is compatible with any PostScript interpreter that 
 supports this feature. Nevertheless, ideal results are obtained only when 
 the font is used with the device for which the prerendered glyphs were 
 intended—in particular, one having the proper resolution and orientation 
 of device space. Some usage re-strictions apply to Type 4 CIDFonts:",NA
•,"They should not be used within encapsulated PostScript (EPS) files or in 
 appli-cation-generated PostScript code that drivers pass through, 
 because there is no guarantee that the interpreter that eventually 
 processes this code is capable of supporting these fonts or that the 
 prerendered bitmaps will be appropriate for the device.",NA
•,"Since they do not contain glyph descriptions, they cannot be used in any 
 oper-ation that requires obtaining the glyph outline as a path, such as 
 clipping. The 
 charpath
  operator has no effect when used with a Type 4 
 CIDFont.",NA
•,"They do not support any of the effects that can be produced in most types 
 of fonts and CIDFonts by modifying entries such as 
 PaintType
 , 
 StrokeWidth
 , 
 Metrics
 , 
 Metrics2
 , and 
 CDevProc
 .",NA
•,"The 
 CIDFontName
  and 
 CIDSystemInfo
  entries, which are required in other 
 types of CIDFonts, are optional in a Type 4 CIDFont. (Typically, a Type 4 
 CIDFont does not contain a standard character collection but is used with 
 a special-purpose, custom CMap.)",NA
•,"FontMatrix
  must be the inverse of the transformation from default user 
 space to device space of the device for which the bitmap is designed to be 
 used.Ini-tially, the translation components of the font matrix should be 0 
 (although a subsequent 
 makefont
  operation may impose a translation). 
 Defining the font matrix this way ensures that when glyphs are shown at 
 their intended size and orientation, the glyph coordinate system will be 
 the same as the device coordi-nate system except for translation. 
  
 Operators for Type 4 CIDFonts
  
 Once a Type 4 CIDFont has been defined by invoking 
 defineresource
 , the 
 follow-ing three operators may be used to manage the CIDFont’s glyph 
 bitmaps in the font cache. Because of their specialized use, these operators 
 are defined in the 
 BitmapFontInit
  procedure set rather than in 
 systemdict
 .",NA
•,"addglyph
  loads the glyph bitmap (and metrics) associated with a CID in a 
  
 Type 4 CIDFont.",NA
•,"removeglyphs
  removes the bitmaps for specified CIDs associated with a 
 Type 4 
  
 CIDFont.",NA
•,"removeall
  removes all bitmaps associated with a Type 4 CIDFont. 
  
 Unlike most glyphs in the font cache, glyphs loaded by 
 addglyph
  cannot be 
 re-moved automatically to make room for other glyphs (except in the case 
 that the Type 4 CIDFont itself is removed from VM). The PostScript 
 program must man-age the font cache properly to avoid exhausting it. As 
 indicated earlier, this re-quires it to know device-dependent details about 
 the memory consumed by cached glyphs and about the total capacity of the 
 font cache. 
  
 The 
 removeglyphs
  and 
 removeall
  operators logically remove glyphs from the 
 font cache at the moment the operators are executed; the glyphs are no 
 longer ac-cessible during subsequent 
 show
  operations. However, glyphs 
 that have been re-",NA
•,"No glyph for the requested CID has been loaded into the font cache by 
 addglyph
 . This case is handled by performing a glyph substitution, just as 
 in any other type of CIDFont; see “Handling Undefined Characters” on 
 page 389.",NA
•,"The glyph exists in the font cache, but the concatenation of the 
 FontMatrix
  
 en-try and the CTM is not the identity matrix (because one or the other 
 has been scaled or otherwise transformed). In this case, the glyph bitmap 
 is treated as if it were image source data and is painted as if by the 
 imagemask
  operator, using the transformed coordinate system. 
  
 Note: 
 Such a transformation degrades the quality of prerendered glyphs for 
 Type 4 CIDFonts in the same way as for Type 3 base fonts or Type 1 CIDFonts 
 that describe glyphs as bitmaps. 
  
 5.11.4 CMap Dictionaries
  
 As stated earlier, a CMap dictionary specifies the mapping from character 
 codes to character selectors (CIDs, character names, or character codes) in 
 one or more associated fonts or CIDFonts. The CMap does not refer directly 
 to specific fonts or CIDFonts; instead, it is combined with them as part of a 
 Type 0 font whose 
 FMapType
  value is 9.",NA
•,"begincmap
  and 
 endcmap
  enclose the CMap definition.",NA
•,"usecmap
  incorporates the code mappings from another 
 CMap
  resource in-
  
 stance.",NA
•,"beginrearrangedfont
  and 
 endrearrangedfont
 , in the CMap for a rearranged CID-
 keyed font, specify an array of component fonts for the rearranged font.",NA
•,"begincodespacerange
  and 
 endcodespacerange
  define 
 codespace ranges
 —the 
 valid input character code ranges—by specifying a pair of codes of some 
 partic-ular length giving the lower and upper bounds of each range; see 
 “CMap Map-ping” on page 388.",NA
•,"usefont
  specifies a font number that is an implicit operand of all the 
 character 
  
 code mapping operations that follow.",NA
•,"beginbfchar
  and
  endbfchar
  define mappings of individual input character 
 codes to character codes or character names in the associated font.
  
 beginbfrange
  and
  endbfrange
  do the same, but for ranges of input codes.",NA
•,"begincidchar
  and
  endcidchar
  define mappings of individual input character 
 codes to CIDs in the associated CIDFont. 
 begincidrange
  and
  endcidrange
  do 
 the same, but for ranges of input codes.",NA
•,"beginnotdefchar,endnotdefchar
 , 
 beginnotdefrange,
  and 
 endnotdefrange
  de-
 fine notdef mappings from character codes to CIDs. As described in the 
 section“Handling Undefined Characters” on page 389, a notdef mapping is 
 used if the normal mapping produces a CID for which no glyph is present 
 in the associat-ed CIDFont.",NA
•,"beginusematrix
  and 
 endusematrix
  define a transformation matrix to be ap-
  
 plied to an associated font or CIDFont. 
  
 In addition to the operators listed above, the
 CIDInit
 procedure set also 
 includes the 
 StartData
  operator, which is used in defining Type 0 CIDFonts 
 (as described in the section “Type 0 CIDFonts” on page 371). Other entries 
 in the 
 CIDInit
  pro-cedure set are private and should not be accessed by a 
 PostScript program. 
  
 Note: 
 Although the contents of the 
 CIDInit
  procedure set are documented as 
 “opera-tors,” they may actually be implemented as procedures rather than as 
 operator ob-jects. Since they are always directly executed by name, there is no 
 difference in behavior between procedures and operators. 
  
 CMap Example
  
 The following example (with paragraphs of comments interspersed) 
 creates a simple CMap dictionary. It demonstrates the use of several of the 
 operators in the 
 CIDInit 
 procedure set to define mappings from character 
 codes to a character se-lector and font number. The example is contrived 
 and is not entirely explained by the comments; its purpose is to provide 
 background for subsequent descriptions. 
  
 /CIDInit /ProcSet findresource 
 begin 
  
  
 8 dict begin 
  
  
  
 begincmap
  
 The CMap definition begins here. It maps character codes to a CIDFont and 
 a base font; therefore, the 
 CIDSystemInfo
  entry must be an array with two 
 ele-ments. Font 0 is a CIDFont that references the Adobe-Japan1-1 
 character collec-tion, and font 1 is a base font (represented by the 
 null
  
 element of the array).",NA
•,"If the character selector is a character name, the descendant must be a 
 base font. The equivalent of a 
 glyphshow
  operation is performed on the 
 name, us-ing the descendant font as the current font. If the descendant 
 font contains no glyph for that name, the 
 .notdef
  character is used instead.",NA
•,"If the character selector is a character code, the descendant may be either 
 a base font or another composite font, but not a CIDFont. In the case of a 
 base font, the code must be only one byte long; the 
 Encoding
  entry in the 
 base font is con-sulted in the usual manner to determine which glyph to 
 render. In the case of a composite font, the code may be multiple bytes 
 long; it is interpreted according to the mapping algorithm specified by the 
 FMapType
  value for that font. Dur-ing this interpretation, no additional 
 bytes will be consumed from the 
 show 
 string.",NA
•,"If the character selector is a CID, the descendant must be a CIDFont 
 (except in a special case described below). The equivalent of a 
 glyphshow
  
 operation is performed on the CID, using the descendant CIDFont as the 
 current font. If the CIDFont contains no glyph for that CID, the notdef 
 mappings are consult-ed, as described in the next section. 
  
 Under special conditions, a CID can be used when the descendant is a 
 Type 3 base font. The font’s 
 BuildGlyph
  or 
 BuildChar
  procedure is invoked 
 to render a character whose code is the last byte originally extracted 
 from the 
 show
  string. If this procedure executes 
 setfont
  to establish a 
 CIDFont as the current font and then executes a 
 show
  operation on a 
 string consisting of just that character code, the code is ignored; instead, 
 the CID determined by the earlier CMap mapping is used to look up the 
 glyph in the CIDFont. This special case exists for compatibility with 
 applications that substitute Type 3 fonts for base fonts in a composite 
 font hierarchy to achieve certain special effects. 
  
 Handling Undefined Characters
  
 A CMap mapping operation can fail to select a glyph for any of a variety of 
 rea-sons. This section describes what happens when that occurs.",NA
Device Control,"THIS CHAPTER DESCRIBES the PostScript language’s facilities for 
 configuring a 
 page device
 : a raster output device capable of realizing 
 PostScript page descrip-tions on a physical medium. The term 
 medium
  
 (plural 
 media
 ) refers to the physi-cal material on which the device 
 generates its results, such as paper, film, transparency material, or a virtual 
 page on a display. Most of the processing op-tions discussed in this chapter 
 are oriented toward printers that produce output on paper, so paper is a 
 good universal material to envision when you read the term 
 medium
 . 
  
 Note: 
 A page device is only one of several kinds of raster output device. Other 
 kinds include the 
 cache device
  to put characters into the font cache and the 
 null device
  to discard output entirely. These are set, usually temporarily, by 
 the 
 setcachedevice
  and 
 nulldevice
  operators. 
  
 The state of any device, including a page device, is represented as an 
 internal ob-ject that is an element of the graphics state. Each execution of a 
 device setup op-erator, such as 
 setpagedevice
  (described below), 
 setcachedevice
 , or 
 nulldevice
 , creates a new instance of an internal device 
 object (referred to hereafter simply as a “device”). Multiple devices can 
 refer to the same physical resource, such as a printing engine, perhaps with 
 different values of configuration options such as page sizes or feature 
 settings. 
  
 Only one device—the current device in the graphics state—is active at any 
 given time. However, there can be multiple inactive devices belonging to 
 copies of the graphics state that have been saved by 
 save
 , 
 gsave
 , 
 gstate
 , or 
 currentgstate
 . An inactive device can be reactivated when a saved graphics 
 state is reinstated with 
 restore
 , 
 grestore
 , 
 grestoreall
 , or 
 setgstate
 . When a 
 device is reactivated, it brings its device parameters with it. (In an 
 interpreter that supports multiple execution contexts, each context can 
 have an independent active device.)",NA
•,Selecting the proper medium,NA
•,"Establishing a default transformation matrix from user space to device 
 space, along with other device-dependent rendering parameters for 
 producing output on the medium",NA
•,"Selecting processing options such as multiple copies, or special features of 
 the 
  
 output device such as duplex (two-sided) printing 
  
 Once a device has been configured, a PostScript program can proceed to 
 describe a sequence of pages. The program paints the contents of each page 
 in turn in ras-ter memory, with everything that is to appear on that page: 
 text, graphics, and sampled images. It then invokes the 
 showpage
  operator 
 to cause the page to be rendered on the physical output device. 
 showpage
  
 transmits the contents of ras-ter memory to the device, then erases the 
 page and partially resets the graphics state in preparation for the next page. 
 (Another operator, 
 copypage
 , is similar to 
 showpage
 , but its behavior varies 
 by LanguageLevel and its use is not recom-mended.) 
  
 The facilities for configuring a page device differ by LanguageLevel:",NA
•,"LanguageLevel 1 provides a collection of device control operators, 
 defined in a special dictionary named 
 statusdict
 . The contents of 
 statusdict
  
 are device-dependent (although an attempt has been made to maintain a 
 consistent speci-fication for features common to multiple devices). They 
 are not described in this book, but rather in the 
 PostScript Language 
 ReferenceSupplement
 . Applica-tion programs wishing to use 
 statusdict
  
 features can extract information from 
 PostScript printer description
  (PPD) 
 files; for the format of these files, see Adobe Technical Note #5003, 
 PostScript Printer Description File Format Specification.",NA
•,"LanguageLevels 2 and 3 support a page device setup operator named 
 setpage-device
 . This operator provides a standard framework for 
 specifying the re-quirements of a page description and for controlling 
 both standard and optional features of a page device.",NA
•,"LanguageLevel 3 includes an optional feature, 
 in-RIP trapping
 , whose 
 purpose is to compensate for misregistration between colorants. This 
 feature is sup-ported primarily in devices (such as imagesetters) that are 
 used in the produc-tion of plates for printing presses. It is controlled 
 partially by 
 setpagedevice",NA
6.1 Using Page Devices,"Many output devices have special hardware features, such as multiple 
 paper trays with different sizes of paper, duplex (two-sided) printing, 
 collation, finishing op-tions, and so forth. Not all such features are available 
 on all devices, however. The PostScript interpreter knows what features a 
 device supports and which are cur-rently available and ready for use. 
  
 A document’s device configuration requirements may limit the set of 
 devices on which the document can be printed. Specifying such 
 configuration information within a PostScript page description allows the 
 interpreter to match the docu-ment’s requirements with the features and 
 options available on a given output device. The 
 setpagedevice
  operator 
 provides a uniform framework for specifying configuration requirements 
 and options. It uses a standard format to request fea-tures supported by all 
 devices (such as selecting a page size) and those supported only by some 
 devices (such as duplex printing). In addition, 
 setpagedevice 
 allows a user or 
 system administrator to establish default device configuration parameters 
 to be used when a page description does not specify them explicitly. It also 
 provides a standard mechanism for determining what to do when a page 
 de-scription makes feature requests that the device cannot fulfill. 
  
 It is useful, at least in concept, to envision two separate tasks when printing 
 from an application: 
  
 1. Generate a device-independent page description. 
  
 2. Request that the page description be rendered on a particular device. At 
 this point, the user should have an opportunity to add processing 
 options, includ-ing device-dependent ones, to the page description.",NA
•,"When an application generates a page description, it can include a call to 
 setpagedevice
  specifying parameters that reflect assumptions the 
 application has made in formatting the document, such as the page size 
 and bounding box.",NA
•,"When a user requests printing, an additional call to 
 setpagedevice
  can be 
 prepended to the page description to specify print-time options such as 
 two-sided printing or the number of copies.",NA
•,"The person operating the device can invoke 
 setpagedevice
 , as part of an 
 unen-capsulated job, to specify the available media, establish recovery 
 policies for dealing with unsatisfied requests, and establish default values 
 for other device options. (Jobs and encapsulation are discussed in Section 
 3.7.7, “Job Execution Environment.”) 
  
 For certain parameters, there is a null value that indicates the absence of 
 any spe-cific request or preference. In all cases, the null object (that is, the 
 value of 
 null
  in 
 systemdict
 ) is used for this purpose. For example, a null value 
 for the 
 MediaColor 
 parameter indicates that no specific paper color has been 
 requested. Null values",NA
•,"Ignore the request (for example, print simplex on a device that cannot 
 honor a 
  
 request for duplex printing).",NA
•,"Generate a 
 configurationerror
  (reject the job).",NA
•,"Notify the human operator or the print management software to determine 
  
 what to do. 
  
 The choice is based on information in the 
 Policies
  subdictionary of the page 
 de-vice dictionary, which in turn can be altered by 
 setpagedevice
 ; see 
 Section 6.2.7,“Unsatisfied Parameter Requests,” for further details. 
  
 Note: 
 In the descriptions of individual page device parameters in this chapter, 
 the statement “a configuration error will occur” actually means that the 
 PostScript inter-preter will take one of the three possible actions listed above, 
 according to specified policy. Thus a “configuration error” is not necessarily 
 the same thing as a PostScript 
 configurationerror
 .",NA
6.2 Page Device Parameters,"This section describes specific page device parameters that have been 
 defined at the time of publication of this book. Table 6.1 classifies them into 
 general cate-gories for easier understanding. (This classification is not 
 rigid, however; param-eters in different categories can sometimes interact 
 with each other.) In the future, other parameters may be defined as needed 
 to cover new processing op-tions or device features. Once defined for any 
 device, a given parameter name will always be used for the same feature in 
 any subsequent devices that support it. 
  
 Note: 
 Excluded from the table (and from this chapter) are parameters that 
 are device-specific, controlling features unique to a particular device or 
 limited to only a few devices; for information on these, see the PostScript 
 Language Reference Supple-ment and individual product documentation. 
 Note also that not all parameters de-scribed here are supported by all 
 devices; consult the product documentation for each device to see exactly 
 which parameters it supports. 
  
 6.2.1 Media Selection
  
 A given output device may support one or more physical sources for the 
 media on which PostScript page descriptions are rendered. These 
 media 
 sources
  (often called 
 trays
  or 
 positions
 ) are arbitrarily numbered by small 
 integer 
 position num-bers
 . A position number usually designates a specific 
 physical location in the hardware, though it may refer instead to some 
 logical capability such as a pair of trays that contain the same medium and 
 are used alternately. The correspon-dence between position numbers and 
 media sources is device-dependent; it is not described in this book, but 
 rather in individual product documentation. 
  
 The page device parameters shown in Table 6.2 control the selection of an 
 input media source. Some of these parameters (
 PageSize
 , 
 MediaColor
 , 
 MediaWeight
 , 
 MediaType
 , 
 MediaClass
 , 
 InsertSheet
 ) are used by a page 
 description to specify its media requirements. The 
 InputAttributes
  
 parameter describes the properties of the physical media currently 
 available on the device. The 
 setpagedevice
  operator uses this information to 
 match a page’s requirements with the available media and decide which 
 physical media source to use for that page. The remaining parameters in 
 Table 6.2 specify additional requirements for input media handling that 
 may also influence the media selection process.",NA
•,"Immediate media selection
 . All information about the available media is 
 present in the 
 InputAttributes
  and other page device parameters at the 
 time 
 setpagedevice
  is invoked. 
 setpagedevice
  uses this information, along 
 with the policies established for handling unsatisfied parameter requests, 
 to select a media source. The outcome of this decision is immediately 
 visible to the Post-Script program.",NA
•,"Deferred media selection
 . Information about the available media is not 
 known at the time 
 setpagedevice
  is invoked. Instead of selecting the media 
 source im-mediately, 
 setpagedevice
  merely collects the selection requests 
 and saves them for use at some later time when the page image is actually 
 applied to the medi-um. 
  
 Most of this section is devoted to describing the immediate media selection 
 pro-cess in detail. Deferred media selection is discussed in “Deferred Media 
 Selec-tion” on page 411. 
  
 TABLE 6.2 Page device parameters related to media selection
  
 KEY
  
 TYPE
  
 VALUE
  
 InputAttributes
  
 dictionary
  
 A dictionary specifying the attributes of all input media currently 
 available
  
 or null
  
 for use by this output device. The dictionary contains an entry for 
 each
  
 available media source on the device—for example, each input paper 
 tray on a printer. The key for each entry is an arbitrary integer 
 position number; the value is a subdictionary describing the medium 
 currently available from that source. Entries in these subdictionaries 
 include 
 PageSize
 , 
 MediaColor
 , 
 MediaWeight
 , 
 MediaType
 , 
 MediaClass
 , and 
 InsertSheet
 , with the same meanings as the corresponding page device 
 parameters described in this table. Two other optional entries, 
 Priority
  
 and 
 MatchAll
 , control details of the matching algorithm; see “Matching 
 Requests with Attributes” on page 403. 
  
 Changes to the contents of the 
 InputAttributes
  dictionary are 
 cumulative; that is, the 
 setpagedevice
  operator merges the contents of 
 InputAttributes 
 from the request dictionary with those of the existing 
 InputAttributes
  dic-tionary for the current device. However, this 
 cumulative merging is not re-cursive: the contents of subdictionaries 
 representing individual media sources within the 
 InputAttributes
  
 dictionary are replaced outright rather than merged.",NA
•,"If 
 MatchAll
  is present in an 
 InputAttributes
  subdictionary and its value is 
 true
 , an input media request will match that media source only if it 
 specifies match-ing (nonnull) values for 
 all
  attributes present in the 
 subdictionary (except the 
 MatchAll
  attribute itself).",NA
•,"If 
 MatchAll
  is 
 false
  or absent, an input media request will match the media 
 source if it specifies 
 any subset
  of the subdictionary’s attributes and 
 leaves the others 
 null
  (meaning “don’t care”). 
  
 Some devices support media sources that insert a sheet of medium directly 
 into the output bin, bypassing the normal printing mechanism. This can be 
 useful for special media that require no imaging, such as divider pages 
 made of heavy card stock, or for delicate, preprinted media such as 
 photographic materials, which might be damaged if passed through a laser 
 printer’s high-temperature toner sta-tion. The boolean page device 
 parameter 
 InsertSheet
  provides support for media sources of this type. 
 Setting 
 InsertSheet
  to 
 true
  in a source’s 
 InputAttributes
  entry signifies that it 
 bypasses the printing mechanism and feeds media directly to the output 
 bin; the source can then be selected by an input media request with 
 InsertSheet
  equal to 
 true
 . For example, the following PostScript code 
 fragment inserts a sheet of special media as page 
 n
 +
  1 of a document: 
  
 … 
 PostScript code for page n
  …
  
 gsave 
  
 % Save previous media attributes 
  
 << /InsertSheet true >> setpagedevice 
  
 % Select InsertSheet media source 
  
 showpage 
  
 % Send to output bin 
  
 grestore 
  
  
 % Restore previous media attributes… 
 PostScript code for page n + 2
  …
  
 Managing the InputAttributes Dictionary
  
 Although the 
 InputAttributes
  dictionary is an ordinary page device 
 parameter and can be altered with the 
 setpagedevice
  operator, a page 
 description should never do this. This dictionary is intended to describe the 
 attributes of the avail-able media sources; it should be changed only by a 
 human operator or by system management software in control of the 
 physical device.",NA
•,"At the beginning of a job (see Section 3.7.7, “Job Execution Environment”), 
 the job server senses the attributes of all available media sources. It then 
 invokes 
 setpagedevice
  to update the 
 InputAttributes
  dictionary accordingly.",NA
•,"Additionally, the job server selects a default media source. This default is 
 used if a page description fails to specify any media requirements. 
 (Nonnull attributes of the default medium will be inherited during a 
 setpagedevice
  request that does not explicitly override those attributes.) 
 How defaults are selected is device-dependent; a common method is to 
 use the first element of the 
 Priority 
 array if one is present.",NA
•,"Execution of 
 setpagedevice
  at other times may also result in 
 InputAttributes 
 being updated to reflect the state of the hardware. In particular, this 
 occurs if a 
 Policies
  recovery policy specifies interaction with a human 
 operator and the operator installs different media (see Section 6.2.7, 
 “Unsatisfied Parameter Re-quests”). It can occur at other times as well. 
  
 Some devices cannot sense media attributes automatically, or they can 
 sense page size but not other attributes. For such devices, 
 setpagedevice
  
 must be invoked explicitly to update the 
 InputAttributes
  dictionary 
 whenever media are changed. This is usually done by a system 
 management program submitted by a human operator and executed as an 
 unencapsulated job. Some devices provide a “front panel” user interface to 
 accomplish this. 
  
 Changes to the contents of the 
 InputAttributes
  dictionary are cumulative. 
 setpagedevice
  combines the entries supplied to it with those in the existing 
 page device dictionary, replacing or adding entries as appropriate. 
 However, this cu-mulative behavior does not extend to the contents of the 
 subdictionaries that are",NA
•,The size and location of the image’s outer boundary,NA
•,"The size of the margins, if any",NA
•,"Whether and how far to shift right-hand and left-hand pages to allow extra 
  
 space for binding or stapling",NA
•,"Whether to reflect the page image, either horizontally or vertically, for 
 photo-
  
 graphic reproduction",NA
•,Whether to generate photographic negatives,NA
•,"Whether to print on one side (simplex) or both sides (duplex) of the 
 medium",NA
•,"When 
 Collate
  is 
 true
 , each page set consists of one complete copy of the 
 entire document—one copy of each page, arranged in their correct order. 
 The num-ber of page sets delivered is equal to the number of copies 
 requested.",NA
•,"When 
 Collate
  is 
 false
 , each page set consists of the requested number of 
 copies of a single page of the document. The number of page sets 
 delivered is equal to the number of pages in the document. 
  
 This notion of a page set is important because it affects the behavior of 
 several other page device parameters, such as 
 Jog
  in Table 6.5 and 
 AdvanceMedia
  and 
 CutMedia
  in Table 6.3. 
  
 6.2.5 Color Support
  
 The page device parameters discussed in this section control various aspects 
 of color output on devices capable of producing it. These include:",NA
•,"The basic model used for rendering process colors on the device, such as 
  
 CMYK (cyan-magenta-yellow-black)",NA
•,"Whether the device produces multiple separations (one for each colorant) 
 or 
  
 composite output (all colorants combined)",NA
•,The number and names of the available colorants,NA
•,"The subset of colorants that are applied or the order in which separations 
 are 
  
 generated 
  
 Table 6.6 shows the page device parameters related to color. See Section 
 4.8, “Col-or Spaces,” and Chapter 7, “Rendering,” for more information on 
 the subject of color in general. 
  
 TABLE 6.6 Page device parameters related to color support
  
 KEY
  
 TYPE
  
 VALUE
  
 PageDeviceName
  
 string, name,
  
 (LanguageLevel 3)
  The name of the device configuration 
 represented
  
 or null
  
 by this page device dictionary. The 
 GetPageDeviceName
  
 procedure
  
 in the 
 ColorRendering
  procedure set returns this value, which is 
 used by the 
 findcolorrendering
  operator to construct the name of 
 a color rendering dictionary for a requested rendering intent. 
 See Section 7.1.3, “Rendering Intents,” and “Customizing CRD 
 Selec-tion” on page 472 for information on 
 findcolorrendering
  
 and 
 GetPageDeviceName
 , respectively. See also the 
 MediaClass
  
 page device parameter in Table 6.2 on page 400, which can 
 affect CRD se-lection. 
  
 ProcessColorModel
  
 name or string
  
 (LanguageLevel 3)
  The model used for rendering process colors on
  
 the device (see “Process Color Model” on page 422). This 
 parameter controls the rendering process only; it does not affect 
 the interpreta-tion of color values in any color space. 
  
 The 
 ProcessColorModel
  entry in the output device dictionary (see 
 Section 6.4, “Output Device Dictionary”) defines the allowable 
 values for this parameter on a given device; attempting to set it 
 to an unsupported value will cause a configuration error. Valid 
 values are 
 DeviceGray
 , 
 DeviceRGB
 , 
 DeviceCMYK
 , 
 DeviceCMY
 , 
 DeviceRGBK
 , and (in LanguageLevel 3) 
 DeviceN
 . 
  
 Separations
  
 boolean
  
 A flag specifying whether the device should produce separations 
 or
  
 composite output. If this flag is 
 true
 , multiple color separations 
 will be generated for each page of output; that is, a separate 
 sheet of phys-ical medium will be produced for each individual 
 device colorant (primary or spot color) specified by the 
 SeparationOrder
  parameter. If the flag is 
 false
 , all colorants will 
 be combined into a single com-",NA
•,"DeviceCMYK
  specifies 
 Cyan
 , 
 Magenta
 , 
 Yellow
 , and 
 Black
  as process colorants, 
  
 with 
 DeviceCMYK
  as the native color space.",NA
•,"DeviceCMY
  specifies 
 Cyan
 , 
 Magenta
 , and 
 Yellow
  as process colorants, with 
 DeviceRGB
  as the native color space. Additive (RGB) color values will be 
 ren-dered 
 into 
 equivalent 
 combinations 
 of 
 the 
 complementary 
 subtractive (CMY) process colorants.",NA
•,"DeviceRGB
  specifies 
 Red
 , 
 Green
 , and 
 Blue
  as process colorants, with 
  
 DeviceRGB
  as the native color space.",NA
•,"DeviceRGBK
  specifies 
 Red
 , 
 Green
 , 
 Blue
 , and 
 Gray
  as process colorants, with 
 DeviceRGB
  as the native color space. RGB color values representing pure 
 shades of gray (that is, with all three color components equal) will be 
 rendered into equivalent levels of the gray colorant.",NA
•,"DeviceGray
  specifies 
 Gray
  as the only process colorant, with 
 DeviceGray
  as 
 the 
  
 native color space.",NA
•,"DeviceN
 (LanguageLevel 3)
  specifies 
 DeviceN
  as the native color space. No 
 stan-dard process colorants are defined; all colorants must be explicitly 
 declared via the 
 SeparationColorNames
  page device parameter (see 
 “Separations and De-vice Colorants,” below). This model is used for 
 devices whose available process colorants do not correspond to one of 
 the standard device color spaces. 
  
 The standard colorant names implied by the process color model are 
 automati-cally assumed to be available on the output device. These names 
 can be used to produce separations or isolate the control of individual color 
 components in a 
 Separation
  color space (see “Separation Color Spaces” on 
 page 241) or to select halftones in a type 5 halftone dictionary (see “Type 5 
 Halftone Dictionaries” on page 498). Additional colorant names can be 
 specified with the 
 Separation-ColorNames
  and 
 SeparationOrder
  page device 
 parameters, as described in “Sepa-rations and Device Colorants,” below. 
  
 Note that the process color model applies only to color 
 rendering
 , not to 
 color 
 specification.
  A PostScript program can use any convenient color 
 space to specify colors in a page description; in particular, colors can be 
 specified in a 
 DeviceN 
 color space in LanguageLevel 3 implementations, 
 even on devices that do not support the 
 DeviceN
  process color model.",NA
•,"If 
 Separations
  is 
 true
 , each single page of a document will generate 
 multiple pieces of physical output medium, or 
 separations
 —one for each 
 individual de-vice colorant to be applied during the final printing run. 
 These separations can then be used to create a separate printing plate for 
 each colorant. Because out-put is generated for only one colorant at a 
 time, the 
 ProcessColorModel
  param-eter may be set to models other than 
 the one normally used to render process colors on the device. For 
 example, a monochrome device can use the 
 DeviceCMYK
  color model to 
 produce separations for 
 Cyan
 , 
 Magenta
 , 
 Yellow
 , and 
 Black
  colorants (or 
 some subset of these colorants, subject to the 
 MaxSeparations
  limit 
 discussed below).",NA
•,"If 
 Separations
  is 
 false
 , the device will combine all colorants to form a single 
 sheet of 
 composite
  output for each page. Any value of 
 ProcessColorModel
  
 other than the one native to the device will result in a configuration error. 
  
 As noted in the section “Process Color Model” above, the standard process 
 colo-rants implied by a device’s process color model (such as 
 Cyan
 , 
 Magenta
 , 
 Yellow
 , and 
 Black
  in the 
 DeviceCMYK
  model) are always available for use in 
 Separation
  or 
 DeviceN
  color spaces, as well as for selecting halftones in a 
 type 
 5 
 halftone 
 dic-tionary. 
 The 
 page 
 device 
 parameter 
 SeparationColorNames
  declares the names of additional 
 spot colorants
  to be 
 used for these purposes. (
 All
  colorants used in the 
 DeviceN
  process color 
 model must be declared in 
 SeparationColorNames
 , since",NA
•,"Set 
 ProcessColorModel
  to 
 DeviceCMYK
  and name orange and green as spot 
 col-orants in the 
 SeparationColorNames
  array. Any colors specified in one 
 of the other device color spaces (
 DeviceRGB
  or 
 DeviceGray
 ) or in a CIE-
 based color space will be transformed into 
 DeviceCMYK
  using the normal 
 color conversion rules (see Section 7.2, “Conversions among Device Color 
 Spaces”). The orange and green colorants are not considered process 
 colorants in this case; they will be used only if they are named explicitly 
 in a 
 Separation
  or 
 DeviceN
  color space.",NA
•,"Set 
 ProcessColorModel
  to 
 DeviceN
  and name all six colorants explicitly in 
 SeparationColorNames
 . Colors specified in any device or CIE-based color 
 space will be converted to the six 
 DeviceN
  colorants in a device-specific 
 man-ner. 
  
 Because these two models differ in their definition of the process colorants, 
 source colors that are rendered using process colorants will produce 
 different re-sults in the two models. On the other hand, source colors 
 specified in a 
 DeviceN 
 color space will produce the same results in both 
 models, 
 so 
 long 
 as 
 they 
 use 
 only 
 colorants 
 named 
 in 
 the 
 SeparationColorNames
  array. 
  
 The page device parameter 
 SeparationOrder
  is an array of colorant names 
 speci-fying which colorants should be applied in the final output and in 
 what order. This parameter can be used to limit the set of separations 
 generated or colorants applied to a subset of those available (either implied 
 by 
 ProcessColorModel
  
 or 
 de-clared 
 in 
 SeparationColorNames
 ). 
 The 
 MaxSeparations
  parameter specifies the maximum number of separations 
 that a device is capable of producing for each page. When 
 Separations
  is 
 true
 , the number of uniquely named colorants in the",NA
•,"Cause multiple virtual pages within a document to be printed on a single 
 phys-
  
 ical page (“2-up” or “
 n
 -up” printing)",NA
•,Shift the positions of even- and odd-page images differently for binding,NA
•,"Add marks to each page that either underlie or overprint the material 
 provided 
  
 by the page description 
  
 Note: 
 The use of 
 BeginPage
  and 
 EndPage
  to achieve effects spanning multiple 
 pages sacrifices any page independence the document may have. In general, a 
 page descrip-",NA
•,"setpagedevice
  normally calls 
 BeginPage
  as its last action before returning 
 (ex-cept for a possible call to the 
 PolicyReport
  procedure, if needed; see 
 Section 6.2.7, “Unsatisfied Parameter Requests”). This indicates the 
 beginning of the 
 first
  page to be rendered on the device.",NA
•,"showpage
  and 
 copypage
  call 
 BeginPage
  as their last action before returning. 
 This indicates the beginning of the 
 next
  page, following the one that 
 showpage 
 or 
 copypage
  has just ended.",NA
•,"Operators that reactivate an existing page device call 
 BeginPage
  as their last 
 ac-
  
 tion before returning. 
  
 When 
 BeginPage
  is called, the graphics state has been initialized and the 
 current page erased, if appropriate, in preparation for beginning the 
 execution of the PostScript commands describing a page. The operand stack 
 contains an integer stating the number of executions of 
 showpage
  (but not 
 copypage
 ) that have oc-curred since the current device was activated; that 
 is, the operand is 0 at the first call to 
 BeginPage
 , 1 at the call that occurs 
 during the first execution of 
 showpage
 , and so on. The 
 BeginPage
  procedure 
 is expected to consume this op-erand. The procedure is permitted to alter 
 the graphics state and to paint marks on the current page. 
  
 The 
 EndPage
  procedure is called at the end of each page:",NA
•,"showpage
  and 
 copypage
  call 
 EndPage
  as their first action. This indicates the 
  
 end of the preceding page.",NA
•,"Operators that deactivate the page device call 
 EndPage
  as their first action. 
  
 When 
 EndPage
  is called, the PostScript commands describing the preceding 
 page have been completely executed, but the contents of raster memory have 
 not yet",NA
•,"The number of executions of 
 showpage
  (but not 
 copypage
 ) that have oc-
 curred since the device was activated, 
 not
  including this one. That is, the 
 oper-and is 0 at the call to 
 EndPage
  during the first execution of 
 showpage
 , 
 1 during the second execution of 
 showpage
 , and so on.",NA
•,"A 
 reason code
  indicating the circumstances under which 
 EndPage
  is being 
 called: 0 during 
 showpage
 , 1 during 
 copypage
 , 2 during device deactivation. 
  
 The 
 EndPage
  procedure is expected to consume these operands. The 
 procedure is permitted to alter the graphics state and to paint marks on the 
 current page; such marks are added to the page just completed. 
  
 EndPage
  must return a boolean result specifying the disposition of the 
 current page:",NA
•,"The value 
 true
  means transfer the contents of raster memory to the 
 medium. Then, if 
 showpage
  is being executed, execute the equivalent of 
 initgraphics
  and 
 erasepage
  in preparation for the next page. (The latter 
 actions are not per-formed during 
 copypage
 .)",NA
•,"The value 
 false
  means do not transfer the contents of raster memory to 
 the medium or erase the current page. (If 
 showpage
  is being executed, 
 initgraphics 
 is still performed; if the device is being deactivated, the page 
 is still erased.) 
  
 The normal definition of 
 EndPage
  returns 
 true
  during 
 showpage
  or 
 copypage 
 (reason code 0 or 1) but 
 false
  during device deactivation (reason code 2). 
 That is, normally every 
 showpage
  or 
 copypage
  operation causes a physical 
 page to be produced, but an incomplete last page (not ended by 
 showpage
  
 or 
 copypage
 ) produces no output. Other behavior can be obtained by 
 defining 
 EndPage
  differ-ently. 
  
 When 
 setpagedevice
  is executed or when 
 restore
 , 
 grestore
 , 
 grestoreall
  or 
 setgstate
  causes a page device to be deactivated and a 
 different
  page device 
 to be activated, the interpreter takes the following actions: 
  
 1. Calls the 
 EndPage
  procedure of the device being deactivated, passing it a 
 rea-son code of 2. At the time this call is made, the current device in the 
 graphics",NA
•,"The device does not support the requested parameter at all; the 
 PostScript in-terpreter has no idea what it means. For example, if the 
 page description attempts to set a value for the 
 Duplex
  parameter but that 
 parameter is not de-fined in the page device dictionary, 
 setpagedevice
  
 treats it as a request for an unknown feature—even if the requested value 
 is 
 false.",NA
•,"The device supports the requested parameter but cannot achieve the 
 requested value at the moment—for example, an A4-size page is 
 requested when the A4 paper tray is not currently installed. 
  
 The interpreter can respond to such an unsatisfied parameter request in a 
 variety of ways, such as by ignoring it, raising a PostScript error, or 
 displaying a message on the front panel of the device requesting 
 intervention by the human operator. The 
 Policies
  page device parameter 
 (Table 6.8) is a dictionary specifying which of these actions to take, 
 depending on the particular page device parameter involved in the request.",NA
•,"Replaced by 
 null
  if it is a media selection request",NA
•,"Unchanged from its former value if the parameter (other than 
 a 
  
 media selection request) is known to the device",NA
•,"Absent if the parameter is unknown to the device
  
 2 
  
 Interact with a human operator or print management software 
 to de-
  
 termine what to do. The precise effects of this policy 
 vary among dif-
  
 ferent output devices and environments. Some 
 devices may issue a 
  
 message (on a front panel, for instance) 
 indicating an operator action 
  
 that is required, then wait for 
 confirmation. Other devices have no 
  
 ability to interact with an 
 operator and may generate a 
  
 configurationerror
  in this case. 
  
 PageSize
  
 integer
  
 A code specifying the recovery policy to use when a requested value for 
 the
  
 PageSize
  parameter cannot be matched (within a tolerance of 
 
 5 units) by
  
 any available medium: 
  
 0 
  
 Generate a 
 configurationerror
 , as described above for 
 PolicyNot-
  
 Found
 . This is the usual default policy on most devices. 
  
 1 
  
 Do not consider the 
 PageSize
  parameter in media selection. 
 Subse-
  
 quent calls to 
 currentpagedevice
  will return a dictionary 
 whose 
  
 PageSize
  entry describes the medium that was actually 
 selected. 
  
 2 
  
 Interact with a human operator or print management software, 
 as 
  
 described above for 
 PolicyNotFound
 . 
  
 3 
  
 Select the nearest available medium and adjust the page to fit, as 
 de-
  
 scribed below under “Recovery Policies and Media Selection.” 
  
 4 
  
 Select the next larger available medium and adjust the page to fit. 
  
 5 
  
 Select the nearest available medium but do not adjust the page. 
  
 6 
  
 Select the next larger available medium but do not adjust the page. 
  
 7 
  
 (LanguageLevel 3)
  If the requested page size is within 
 
 5 units of 
 any 
  
 page size supported by the device, disable media selection 
 altogether 
  
 and impose the requested page size on the previously 
 selected medi-
  
 um without adjustment; otherwise, generate a 
 configurationerror
 . In 
  
 the former case, the page device is set up as if 
 the selected medium 
  
 were of the requested size, ignoring 
 the actual size of the medium. 
  
 Positioning of the page image 
 on the medium is device-dependent 
  
 and unpredictable. 
  
 This policy exists solely for use in the emulations of certain 
 LanguageLevel 1 compatibility operators that perform media 
 selec-tion and page device setup separately. Unlike all other 
 policies (which",NA
•,"Select an alternative medium that is either nearest in size or the next larger 
 size 
  
 to the one requested.",NA
•,"Either adjust the page (by scaling and centering) to fit the alternative 
 medium 
  
 or perform no adjustment. 
  
 The 
 nearest size
  is the one closest in area to the requested size. The 
 next 
 larger size 
 is the one smallest in area that is at least as large as the 
 requested size in both width and height. If the specified policy is to select 
 the next larger size but no larger size is available, the nearest size is used. 
  
 Once an alternative medium has been selected, the adjustment option 
 determines how the page image is to be placed on the medium—in other 
 words, how the transformation matrix defining the device’s default user 
 space is to be computed. To 
 adjust
  the page means to scale the page image 
 (if necessary) to fit the medium, then center the image on the medium. 
 More precisely, adjustment consists of the following two steps: 
  
 1. If the selected medium is smaller than the requested page size in either 
 dimen-sion, scale the page image to fit the medium in the more 
 restrictive dimension. Use the same scale factor in both dimensions, so 
 as to preserve the page’s as-",NA
•,"It can transmit a notification to the human operator or print management 
 soft-ware, warning that one or more parameter requests were unsatisfied 
 and that substitute actions have been taken.",NA
•,"It can inspect the resulting page device dictionary and perhaps make 
 additional alterations. This provides additional flexibility when the 
 standard set of policy choices is inadequate. 
  
 At the time 
 setpagedevice
  calls the 
 PolicyReport
  procedure, it has completed 
 set-ting up the new page device and installing it as the current device in the 
 graphics state. It has also called the device’s 
 BeginPage
  procedure (see 
 Section 6.2.6, “De-vice Initialization and Page Setup”). Thus, invoking 
 currentpagedevice
  within the 
 PolicyReport
  procedure will return the page 
 device dictionary for the newly installed device. It is permissible for the 
 PolicyReport
  procedure to invoke 
 setpagedevice
  recursively.",NA
6.3 In-RIP Trapping,"On devices such as offset printing presses, which mark multiple colorants 
 on a single sheet of physical medium, mechanical limitations of the device 
 can cause imprecise alignment, or 
 misregistration
 , between colorants. This 
 can produce un-wanted visual artifacts such as brightly colored gaps or 
 bands around the edges of printed objects. In high-quality reproduction of 
 color documents, such artifacts are commonly avoided by creating an 
 overlap, called a 
 trap
 , between areas of ad-jacent color.",NA
•,The final set of colorants to be used is not known to the application.,NA
•,"There may be mismatches with the resources (including fonts) available on 
 the 
  
 final output device.",NA
•,"The trapping computations are inherently device-dependent. 
  
 In LanguageLevel 3, the optional 
 in-RIP trapping 
 feature allows trapping to 
 take place in the raster image processor (RIP) of the output device itself, 
 rather than in the application. This has the advantage of applying consistent 
 trapping tech-niques to the entire page as late in the output process as 
 possible, when the exact colorants and resources available on the device 
 are known.",NA
•,"The 
 Trapping
  page device parameter (see Table 6.6 on page 420) enables or 
 dis-
  
 ables trapping as a whole.",NA
•,"The 
 TrappingDetails
  page device parameter consists of a 
 trapping details 
 dic-tionary
  (described in the next section) containing additional device-
 level parameters related to the operation of the trapping facility.",NA
•,"Independent of the page device dictionary, there is a 
 Trapping
  procedure 
 set containing 
 settrapzone
  and 
 settrapparams
  operators, which specify 
 trapping zones
  and their associated 
 trapping parameters
  to control how 
 trapping is per-formed in various regions of a page (see Sections 6.3.2, 
 “Trapping Zones,”and 6.3.3, “Trapping Parameters”).",NA
•,"Instances of the predefined resource category 
 InkParams
  are colorant 
 details dictionaries (see Table 6.11 on page 443); instances of the 
 TrapParams
  resource category are trapping parameter dictionaries (see 
 Table 6.13 on page 447). These categories ordinarily do not have any 
 predefined instances; they are for the convenience of PostScript 
 programs in managing commonly used sets of colorant details and 
 trapping parameters.
  
 Note: 
 The set of process color models to which in-RIP trapping applies is 
 implementation-dependent. In general, trapping makes sense only for 
 subtractive color models such as 
 DeviceCMYK
 , 
 DeviceCMY
 , or 
 DeviceN
 ; at the 
 time of publica-tion, it is implemented only for 
 DeviceCMYK
 . 
  
 6.3.1 Trapping Details Dictionary
  
 The 
 TrappingDetails
  page device parameter holds a 
 trapping details 
 dictionary 
 containing information about the operation of trapping on a 
 particular output device. The entries in this dictionary apply globally to all 
 trapping operations on the device. Section 6.3.3, “Trapping Parameters,” 
 describes additional trapping parameters that provide finer control over 
 the details of trapping in specific re-gions of specific pages in a document.",NA
•,"settrapparams
  takes a single operand, a 
 request dictionary
  whose entries 
 specify desired settings or values for one or more trapping parameters. 
 The operator uses the contents of the request dictionary to alter the 
 current trapping param-eters, but it does not retain the request 
 dictionary itself.",NA
•,"The effects of 
 settrapparams
  are cumulative over multiple executions: it 
 merg-es new parameter requests into the existing trapping parameter 
 dictionary. (However, this cumulative behavior does not apply 
 recursively to the contents of any subsidiary dictionaries contained as 
 entries within the trapping parame-ter dictionary.)",NA
•,"Omitting a parameter key from the request dictionary has a different 
 meaning than including the key with a null value. Omitting the key leaves 
 the parame-ter’s previous value unchanged; specifying a null value sets it 
 to the null object, canceling any previous value it may have had.",NA
•,"The PostScript language does not prescribe a default value for any 
 trapping pa-rameter; all default values are device-specific. A PostScript 
 program can change the defaults by invoking 
 settrapparams
  as part of an 
 unencapsulated job.",NA
•,"currenttrapparams
  returns a dictionary whose entries reflect the current 
 con-
  
 tents of the trapping parameter dictionary. 
  
 The structure and meaning of the entries in the trapping parameter 
 dictionary are determined by the particular trapping type to which they 
 refer, as specified by the 
 Type
  entry in the trapping details dictionary (see 
 Section 6.3.1, “Trapping Details Dictionary”). Table 6.13 shows the trapping 
 parameters for trapping type 1001, the only type defined at the time of 
 publication. 
  
 TABLE 6.13 Entries in a trapping parameter dictionary
  
 KEY
  
 TYPE
  
 VALUE
  
 TrapSetName
  
 name, string, The name of the 
 TrapParams
  resource instance from which the
  
 or null
  
 contents of this dictionary were most recently updated, or 
 null
  if 
 the
  
 dictionary does not correspond to such a resource instance. This 
 en-try is strictly for information; it is ignored by the PostScript 
 trapping machinery. 
  
 Enabled
  
 boolean
  
 A flag that enables or disables trapping for this zone. 
  
 StepLimit
  
 number
  
 The step limit governing the creation of traps by the normal 
 trapping
  
 rule (see “Normal Trapping Rule” on page 449). The value of this 
 parameter must be greater than 0. 
  
 The step limit can be overridden for an individual colorant by 
 in-cluding a 
 StepLimit
  entry for that colorant in the 
 ColorantZone-
 Details
  dictionary (see “Zone-Specific Colorant Details” on page 
 454).",NA
•,"The magnitude of the 
 absolute difference
  between the two concentrations is 
  
 greater than 0.05.",NA
•,"The magnitude of the 
 relative difference
  between the two concentrations, in 
  
 proportion to the lower of the two, is greater than a specified 
 step limit.
  
 These two conditions can be expressed mathematically as follows: 
  
 highLevel
  
 –
 lowLevel
  
 
  
 0.05
  
 highLevel
 -------------------------
 ----------------------------–
  
 lowLevel
  
 lowLevel
  
  
 stepLimit
  
 where 
 highLevel
  and 
 lowLevel
  are the higher and lower of the 
 concentrations of the given colorant on either side of the boundary. The 
 StepLimit
  trapping param-eter establishes a general step limit for a given 
 trapping zone, but this value can be overridden for any individual colorant 
 by including a 
 StepLimit
  entry for that colorant in the 
 ColorantZoneDetails
  
 dictionary (see “Zone-Specific Colorant De-tails” on page 454). 
  
 For example, suppose two adjacent objects within a trapping zone have the 
 color values shown in Table 6.14, on an output device that uses the 
 DeviceCMYK
  pro-cess color model. Because both objects have the same 
 concentration of magenta, that colorant is not a candidate for trapping by 
 the normal trapping rule. The black colorant also is not eligible for trapping, 
 because, although the concentra-tions of black differ between the two 
 objects, the magnitude of the absolute dif-ference is below the threshold 
 value of 0.05. Both cyan and yellow do meet the first condition for trapping. 
 however, because their concentrations differ by more than 0.05 and in 
 opposite directions. Dividing each of the absolute differences by the smaller 
 of the two concentrations for that colorant yields relative differences of 
 0.90 in one direction for cyan and 0.75 in the other direction for yellow. If 
 the",NA
•,"Follow the normal trapping rule, placing the trap on the side of the 
 boundary where the color is darker. This option is vulnerable to the 
 uneven trap place-ment described above.",NA
•,"Always spread from the image toward the other object, placing the trap 
 within the object. This is useful when dark text is painted on top of a light 
 image, since it avoids enlarging the character shapes.",NA
•,"Always choke the image data, spreading the other object and placing the 
 trap within the image. This is useful when light text is painted on top of a 
 dark image, since it avoids shrinking the character shapes.",NA
•,"Center the trap on the boundary between the image and the other object. 
 This 
  
 is the most generally useful option. 
  
 In addition, depending on the nature of the image, it may or may not be 
 appro-priate to create traps between individual colorants within the image 
 itself. The 
 ImageInternalTrapping
  parameter enables or disables such 
 internal image trap-ping. This is not ordinarily done; it is useful for 
 unusually high-contrast images, such as screen shots, where internal color 
 abutments occur along sharp edges. 
  
 Note that all of these parameters apply only to true sampled images; images 
 used as stencil masks (see “Stencil Masking” on page 302) are trapped 
 according to the normal trapping rule. 
  
 Zone-Specific Colorant Details
  
 The 
 ColorantZoneDetails
  trapping parameter allows certain settings to be 
 speci-fied independently for individual colorants, providing greater control 
 over trap-ping behavior than the zone-level settings in the main trapping 
 parameter dictionary. The value of 
 ColorantZoneDetails
  is a dictionary that 
 can contain zero or more entries, each keyed by the name of a single device 
 colorant. The value of each entry is in turn a subdictionary containing 
 either or both of the entries shown in Table 6.15. These specify the step 
 limit and the color scaling factor for that individual colorant, overriding the 
 zone-level settings specified by the 
 StepLimit
  and 
 TrapColorScaling
  trapping 
 parameters. If no subdictionary is de-fined for a given colorant, the zone-
 level values are used instead. 
  
 TABLE 6.15 Entries in a ColorantZoneDetails dictionary
  
 KEY
  
 TYPE
  
 VALUE
  
 StepLimit
  
 number
  
 (Optional)
  The step limit governing the creation of traps for this colorant 
 by
  
 the normal trapping rule (see “Normal Trapping Rule” on page 449 and 
 the 
 StepLimit
  entry in Table 6.13 on page 447). 
  
 TrapColorScaling
  
 number
  
 (Optional)
  A scaling factor for reducing the total amount of this colorant
  
 applied to a trap (see “Normal Trapping Rule” on page 449 and the 
 TrapColorScaling
  entry in Table 6.13 on page 447).",NA
6.4 Output Device Dictionary,"In LanguageLevel 3, certain capabilities of a page device, such as the 
 possible page sizes or resolutions, can be summarized in an 
 output device 
 dictionary
  that is stored as an instance of the 
 OutputDevice
  resource 
 category. This enables appli-cations to query device capabilities directly 
 and also maintains functional equiva-lence with LanguageLevel 1 (where 
 information on page size capabilities is indicated by the presence of 
 userdict
  
 entries such as 
 letter
 , 
 legal
 , and 
 a4
 ). 
  
 Most PostScript interpreters support only a single page device; the 
 OutputDevice 
 resource category contains a single instance (whose key is 
 arbitrary) describing that device. However, some interpreters support 
 multiple devices, which can be selected by the 
 OutputDevice
  parameter in 
 the page device dictionary (see Table 6.5 on page 417). In that case, the 
 OutputDevice
  resource category contains multiple instances, whose keys are 
 the same as the allowed values of the 
 OutputDevice
  page device parameter.
  
 An output device dictionary does not represent the current state of the 
 page de-vice; it simply provides a static list of some of its capabilities. Table 
 6.16 shows the entries in an output device dictionary as of the time of 
 publication; additional entries may exist in some products. 
  
 TABLE 6.16 Entries in an output device dictionary
  
 KEY
  
 TYPE
  
 VALUE
  
 MediaClass
  
 array
  
 (Optional)
  An array of names or strings specifying the values supported 
 by
  
 this device for the 
 MediaClass
  page device parameter (see Table 6.2 on 
 page 400). 
  
 PageSize
  
 array
  
 (Required)
  An array specifying page sizes that can be fed automatically on
  
 this device. Page dimensions are expressed in units of the default user 
 space (72nds of an inch). Each array element is in turn a subarray, 
 which may con-sist of two numbers 
 [
 widthheight
 ]
 , denoting the width 
 and height of a sup-ported page size, or of four numbers 
 [
 width
 1
 height
 1
 width
 2
 height
 2
 ]
 , indicating that page sizes in the range 
 [
 width
 1
 height
 1
 ] 
 to 
 [
 width
 2
 height
 2
 ]
  are supported. Page sizes may be 
 specified redundantly within the array. 
  
 ManualSize
  
 array
  
 (Optional)
  An array specifying page sizes that can be fed manually on this de-
  
 vice. Array elements are in the same format as for 
 PageSize
  (see above). 
 On devices that do not support the 
 ManualFeed
  page device parameter 
 (see Table 6.2 on page 400), the 
 ManualSize
  array should be empty or 
 absent.",NA
Rendering,"THE POSTSCRIPT LANGUAGE separates 
 graphics
  (the specification of 
 shapes and colors) from 
 rendering
  (controlling a raster output device). 
 Figures 4.5 and 4.6 on pages 212 and 213 illustrate this division. Chapter 4 
 describes the fa-cilities for specifying the appearance of pages in a device-
 independent way. This chapter describes the facilities for controlling how 
 shapes and colors are rendered on the raster output device. All of the 
 facilities discussed here depend on the spe-cific characteristics of the 
 output device; PostScript programs that are intended to be device-
 independent should limit themselves to the general graphics facilities 
 described in Chapter 4. 
  
 Nearly all of the rendering facilities that are under program control have to 
 do with the reproduction of color. The interpreter renders colors by a 
 multiple-step process outlined below. (Depending on the current color 
 space and on the char-acteristics of the device, it is not always necessary to 
 perform every step.) 
  
 1. If a color has been specified in a CIE-based color space (as described in 
 Section 4.8.3, “CIE-Based Color Spaces”), the interpreter must first 
 transform it to the native color space of the raster output device. For 
 devices using the standard device color spaces (
 DeviceRGB
 , 
 DeviceCMYK
 , 
 or
  DeviceGray
 ), this transformation is controlled by a CIE-based 
 color 
 rendering dictionary.
  
 2. If a color has been specified in a device color space that is inappropriate 
 for the output device (for example, RGB color with a CMYK or grayscale 
 device), the interpreter invokes a 
 color conversion function.
  A PostScript 
 program can also request explicit conversions between device color 
 spaces. 
  
 3. The interpreter now maps the device color values through 
 transfer 
 functions
 , one for each color component. The transfer functions 
 compensate for pecu-liarities of the output device, such as nonlinear 
 gray-level response. This step is sometimes called 
 gamma correction.",NA
•,"LanguageLevel 2 supports CIE-based color rendering dictionaries to 
 control 
  
 the conversion of CIE-based colors to a device color space.",NA
•,"LanguageLevel 3 supports the selection of color rendering dictionaries 
 based on a 
 rendering intent
  that expresses the program’s priorities in 
 rendering colors for a given output device.",NA
•,"LanguageLevel 3 also supports the 
 UseCIEColor
  page device parameter, 
 which systematically remaps colors originally specified in a device color 
 space into a corresponding CIE-based color space; see “Remapping 
 Device Colors to CIE”on page 237.",NA
•,"LanguageLevel 3 introduces an explicit 
 process color model
  parameter 
 that de-termines the device’s native color space, and it includes a new 
 family of native color spaces, 
 DeviceN
  (see Section 6.2.5, “Color Support”).",NA
•,"Most LanguageLevel 1 implementations support only a single transfer 
 func-tion, controlled by the 
 settransfer
  operator, and a single halftone 
 function, controlled by the 
 setscreen
  operator.",NA
•,"LanguageLevel 1 implementations with the color extensions support 
 multiple transfer functions controlled by 
 setcolortransfer
 , multiple 
 halftone functions controlled by 
 setcolorscreen
 , and various color 
 conversion facilities. These op-erators provide independent rendering 
 control for each individual color com-ponent. LanguageLevel 1 products 
 containing this feature also support the 
 setcmykcolor
  and 
 colorimage
  
 operators.",NA
•,"LanguageLevel 2 also supports 
 halftone dictionaries
  as a means of 
 specifying halftone screen thresholds, transfer functions, and many other 
 rendering de-tails. Halftone dictionaries are more general and more 
 flexible than the LanguageLevel 1 facilities, and they override those 
 facilities when used. LanguageLevel 3 offers several additional types of 
 halftone dictionary beyond those available in LanguageLevel 2. Of course, 
 LanguageLevels 2 and 3 support all LanguageLevel 1 facilities.",NA
7.1 CIE-Based Color to Device Color ,"To render CIE-based colors on a device, the PostScript interpreter must 
 convert from the specified CIE-based color space to the device’s native 
 color space, taking into account the known properties of the device. As 
 discussed in Section 4.8.3,“CIE-Based Color Spaces,” CIE-based color is 
 based on a model of human color perception. The goal of CIE-based color 
 rendering is to produce output in the de-vice’s native color space that 
 accurately reproduces the requested CIE-based color values as perceived 
 by a human observer. Typically, the native color space is one of the 
 standard PostScript device color spaces (
 DeviceGray
 , 
 DeviceRGB
 , or 
 DeviceCMYK
 ) and the conversion is performed by means of a CIE-based 
 color rendering dictionary. CIE-based color specification and rendering are 
 a feature of LanguageLevel 2 (
 CIEBasedABC
 , 
 CIEBasedA
 ) and LanguageLevel 
 3 (
 CIEBasedDEF
 , 
 CIEBasedDEFG
 ). 
  
 The conversion from CIE-based color to device color is complex, and the 
 theory on which it is based is beyond the scope of this book; see the 
 Bibliography for sources of further information. The algorithm has many 
 parameters, including an optional, full three-dimensional color lookup 
 table. The color fidelity of the output depends on having these parameters 
 properly set, usually by a method that includes some form of calibration. 
 Each product includes a default set of col-or rendering parameters that 
 have been chosen to produce reasonable output based on the nominal 
 characteristics of the device. The PostScript language does not prescribe 
 methods for calibrating the device or for computing a proper set of color 
 rendering parameters. 
  
 Conversion from a CIE-based color value to a device color value requires two 
 main operations: 
  
 1. Adjust the CIE-based color value according to a 
 CIE-based gamut mapping 
 function.
  A 
 gamut
  is a subset of all possible colors in some color space. A 
 page description has a 
 source gamut
  consisting of all the colors it uses. A 
 device has a 
 device gamut
  consisting of all the colors it can reproduce. 
 This step transforms colors from the source gamut to the device gamut 
 in a way that attempts to",NA
•,"Used directly as color values in the 
 DeviceRGB
  or 
 DeviceGray
  color space",NA
•,"Used to index a three-dimensional lookup table, which in turn contains 
 color 
  
 values to be interpreted in the 
 DeviceRGB
  or 
 DeviceCMYK
  color 
 space 
  
 The first method usually works well with additive, linear color devices, 
 which in-clude many black-and-white and color displays. The second 
 method is required for high-fidelity reproductions with most color printers, 
 whose color rendition cannot be described by a simple formula. 
  
 Conceptually, conversion of a color value from a CIE-based color space to a 
 de-vice color space involves the following steps. In practice, the 
 implementation does not perform these steps in sequence, but in 
 combination. Furthermore, there are important special cases in which the 
 effects of two or more of the steps cancel out. The implementation detects 
 these cases and omits the unnecessary transformations. 
  
 1. Transform the CIE-based color value from its original color space 
 (
 CIEBased-ABC
 , 
 CIEBasedA
 , 
 CIEBasedDEF
 , or 
 CIEBasedDEFG
 ) to the CIE 
 1931 XYZ space. This transformation depends on various parameters of 
 the color space, as de-scribed in Section 4.8.3, “CIE-Based Color Spaces.”",NA
•,Use the alternate CRD name that is returned.,NA
•,Select a different CRD using your own method.,NA
•,Leave the graphics state’s current CRD installed.,NA
7.2 Conversions among Device Color Spaces,"Each raster output device has a 
 native color space
 , which typically is one of 
 the standard device color spaces (
 DeviceGray
 , 
 DeviceRGB
 , or 
 DeviceCMYK
 ). In 
 other words, most devices support reproduction of colors according to a 
 grayscale (monochrome), red-green-blue, or cyan-magenta-yellow-black 
 model. If the de-vice supports continuous-tone output, reproduction occurs 
 directly. Otherwise, it is accomplished by means of halftoning. 
  
 Note: 
 In LanguageLevel 3, a device’s native color space may be a 
 DeviceN
  
 space rath-er than one of the standard device color spaces. See Section 7.2.5, 
 “Conversion to DeviceN Spaces,” for details on the color conversion process in 
 this case. 
  
 A device’s native color space is determined by the 
 ProcessColorModel
  entry 
 in its page device dictionary (see Section 6.2.5, “Color Support”). Knowing 
 the native color space and other output capabilities of the device, the 
 PostScript interpreter can automatically convert the color values specified 
 in a PostScript program to those appropriate for the device’s native color 
 space. For example, if a PostScript program specifies colors in the 
 DeviceRGB
  color space, but the device supports grayscale (such as a 
 monochrome display) or CMYK (such as a color printer), the interpreter 
 performs the necessary conversions. If the program specifies colors di-
 rectly in the device’s native color space, no conversions are necessary. 
  
 A program can also request explicit conversions among device color spaces 
 by in-voking the operators 
 currentgray
 , 
 currentrgbcolor
 , 
 currenthsbcolor
 , or 
 current-cmykcolor
 , which return color values according to specific color 
 spaces. These operators are described in Section 4.8.2, “Device Color 
 Spaces.” All PostScript implementations support conversions between 
 DeviceRGB
  and 
 DeviceGray
 ; con-versions to and from 
 DeviceCMYK
  are a 
 LanguageLevel 
 2 
 feature 
 (also 
 available 
 in 
 LanguageLevel 
 1 
 implementations with the color extensions).",NA
7.3 Transfer Functions,"A 
 transfer function
  adjusts the values of color components to compensate 
 for nonlinear response in an output device and in the human eye. Each 
 component of a device color space—for example, the red component of the 
 DeviceRGB 
 space—is intended to represent the perceived lightness or 
 intensity of that color component in proportion to the component’s 
 numeric value. Many devices do not actually behave this way, however; the 
 purpose of a transfer function is to compensate for the device’s actual 
 behavior. This operation is sometimes called 
 gamma correction
  (not to be 
 confused with the 
 CIE-based gamut mapping function 
 performed as part of 
 CIE-based color rendering). 
  
 In the sequence of steps for processing colors, the PostScript interpreter 
 applies the transfer function 
 after
  performing any needed conversions 
 between color spaces, but 
 before
  applying a halftone function, if necessary. 
 Each color compo-nent has its own separate transfer function; there is no 
 interaction between com-ponents.",NA
•,"The 
 settransfer
  operator establishes a single transfer function to be 
 applied to all color components. Most LanguageLevel 1 implementations 
 support only a single transfer function.",NA
•,"The 
 setcolortransfer
  operator establishes four separate transfer functions, 
 one each for red, green, blue, and gray or their complements cyan, 
 magenta, yellow, and black. An RGB device uses the first three; a 
 monochrome device uses the gray transfer function only; and a CMYK 
 device uses all four. 
 setcolortransfer 
 is supported in LanguageLevel 2 and 
 in some LanguageLevel 1 implementa-tions, primarily those in color 
 printers.",NA
•,"The 
 sethalftone
  operator can establish transfer functions as optional 
 entries in 
 halftone dictionaries
  (see Section 7.4.3, “Halftone Dictionaries”). 
 This is the only way to set transfer functions for nonprimary color 
 components, or for any component in devices whose native color space is 
 a 
 DeviceN
  space. Transfer functions specified in halftone dictionaries 
 override those specified by 
 settransfer
  or 
 setcolortransfer
 . Halftone 
 dictionaries are a LanguageLevel 2 fea-ture. 
  
 A transfer function is a PostScript procedure that can be called with a 
 numeric operand in the range 0.0 to 1.0 on the operand stack and returns a 
 number in the same range. The operand is the value of a color component 
 in the output device’s native color space, either specified directly or 
 produced by conversion from some other color space. The procedure’s 
 result is the transformed component value to be transmitted to the device 
 (after halftoning, if necessary). Both the operand and the result are always 
 interpreted as if the color component were additive (red, green, blue, or 
 gray): the greater the numeric value, the lighter the color. If the component 
 is subtractive (cyan, magenta, yellow, black, or a spot color), the PostScript 
 interpreter converts the operand to additive form by subtracting it from 1.0 
 before passing it to the transfer function. The result returned by the 
 transfer function is always in additive form, and is passed on to the halftone 
 func-tion in that form.",NA
7.4 Halftones,"Halftoning
  is a process by which continuous-tone colors are approximated 
 on an output device that can achieve only a limited number of discrete 
 colors. Colors that the device cannot produce directly are simulated by 
 using patterns of pixels in the colors available. Perhaps the most familiar 
 example is the rendering of gray tones with black and white pixels, as in a 
 newspaper photograph. 
  
 Some output devices can reproduce continuous-tone colors directly. 
 Halftoning is not required for such devices; after gamma correction by the 
 transfer functions, the color components are transmitted directly to the 
 device. On devices that do require halftoning, it occurs after all color 
 components have been transformed by the applicable transfer functions. 
 The input to the halftone function consists of continuous-tone, gamma-
 corrected color components in the device’s native color space. Its output 
 consists of pixels in colors the device can reproduce.",NA
•,"The 
 setscreen
  operator establishes a single halftone screen to be applied 
 to all color components. The halftone screen can be specified in only one 
 way: by its frequency, angle, and spot function. (These operands have the 
 same meanings as the 
 Frequency
 , 
 Angle
 , and 
 SpotFunction
  entries in a type 
 1 halftone diction-ary, described in Section 7.4.4, “Spot Functions.”) Most 
 LanguageLevel 1 im-plementations support only a single halftone screen.",NA
•,"The 
 setcolorscreen
  operator establishes four separate halftone screens, 
 one each for red, green, blue, and gray or their complements cyan, 
 magenta, yellow, and black. An RGB device uses the first three; a 
 monochrome device uses the gray screen only; and a CMYK device uses 
 all four. 
 setcolorscreen
  is supported in LanguageLevel 2 and in some 
 LanguageLevel 1 implementations, primarily those in color printers.",NA
•,"The 
 sethalftone
  operator installs a 
 halftone dictionary
 , which can describe 
 any of several types of halftones. The dictionary contains the parameters 
 of the halftoning algorithm, either for all color components together or 
 for each com-ponent separately. It may optionally contain other 
 rendering controls as well, such as transfer functions. 
  
 sethalftone
  is the most general way to specify halftones. Any halftone that 
 can be defined in the other two ways can also be defined as a halftone 
 dictionary. Addi-tionally, 
 sethalftone
 is the only way to establish a halftone 
 for a nonprimary color component, or for any color component on a device 
 whose native device space is a 
 DeviceN
  space. However, halftone 
 dictionaries are a LanguageLevel 2 feature, whereas 
 setscreen
  (and 
 sometimes 
 setcolorscreen
 ) is available in all Language-Levels. 
  
 For compatibility between LanguageLevels, the 
 setscreen
 , 
 setcolorscreen
 , 
 sethalftone
 , 
 currentscreen
 , 
 currentcolorscreen
 , and 
 currenthalftone
  operators 
 interact in various ways to ensure reasonable behavior when a halftone 
 that has been defined in one way is read out in a different way. Details of 
 these interac-tions are given in the descriptions of the six operators in 
 Chapter 8. Additionally, three user parameters affect the behavior of the 
 halftone-setting operators:",NA
•,"AccurateScreens
 (LanguageLevel 2)
  enables the accurate halftoning feature 
 for halftones defined by 
 setscreen
  and 
 colorscreen
 . The effect is equivalent 
 to that of setting the 
 AccurateScreens
  flag in a type 1 halftone dictionary 
 (see “Type 1 Halftone Dictionaries” on page 487).",NA
•,"HalftoneMode
 (LanguageLevel 3)
  allows requested halftones to be 
 overridden by a built-in device-specific halftone (see Section C.3.4, 
 “Halftone Screens,” on page 756).",NA
•,"MaxSuperScreen
 (LanguageLevel 3)
  controls the maximum size of a 
 supercell, which can increase the number of achievable gray levels (see 
 Section 7.4.8, “Su-percells.”) 
  
 7.4.2 Halftone Screens
  
 As noted above, PostScript halftone functions are based on the use of a 
 halftone screen.
  A screen is defined by conceptually laying a uniform 
 rectangular grid of 
 halftone cells 
 over the device pixel array. Each pixel 
 belongs to one cell of the grid; a single cell usually contains many pixels. 
 The screen grid is defined entirely in device space, and is unaffected by 
 modifications to the current transformation",NA
•,"Primary color components for the standard native device color spaces, as 
 indi-cated by the 
 ProcessColorModel
  entry in the page device dictionary 
 (
 Red
 ,",NA
•,"Nonstandard color components listed in the 
 SeparationColorNames
  entry 
 in the page device dictionary. These color components are available for 
 use as spot colorants in 
 Separation
  and 
 DeviceN
  color spaces. Some of 
 them may also be used as process colorants if the native color space is a 
 DeviceN
  space. (Note that a type 5 halftone dictionary is the only way to 
 specify independent halftones for colorants on a device whose native 
 color space is a 
 DeviceN
  space.) 
  
 The dictionary must also contain an entry whose key is 
 Default
  and whose 
 value is a halftone dictionary to be used for any color component that does 
 not have an entry of its own. In LanguageLevel 3, there may optionally be 
 an additional entry named 
 HalftoneName
 , a name or string object specifying 
 the name of the type 5 dictionary. If present, this value is returned by the 
 GetHalftoneName
  procedure and used by the 
 findcolorrendering
  operator in 
 constructing the name of a color rendering dictionary (see “Customizing 
 CRD Selection” on page 472). 
  
 When a halftone dictionary of some other type appears as the value of an 
 entry in a type 5 halftone dictionary, it applies only to the single color 
 component named by that entry’s key. This is in contrast to such a 
 dictionary being used as the main halftone dictionary (set with the 
 sethalftone
  operator), which applies to all color components. If nonprimary 
 color components are requested when the current halftone is defined by 
 any means other than a type 5 halftone dictionary, the gray halftone screen 
 and transfer function are used for all such components. 
  
 7.4.7 Proprietary Halftone Dictionaries
  
 Some output devices support special halftone techniques in addition to the 
 stan-dard ones built into the PostScript language itself. Some of these 
 techniques work well only with certain types of device technology or 
 require special hardware to work efficiently. These device-specific 
 halftoning techniques are not described in this book, but rather in the 
 manufacturer’s product documentation for individ-ual devices. 
  
 Two special types of halftone dictionary, types 9 and 100 
 (both 
 LanguageLevel 3)
 , support such device-dependent technologies. Both 
 represent halftoning methods whose data is proprietary to a specific 
 product. It is not possible for a PostScript program to gain any information 
 about the contents or appearance of a type 9 or type 100 halftone.",NA
•,"The number of pixels in the supercell must be less than or equal to 
  
 MaxSuperScreen
 .",NA
•,"The supercell must be within the limits of the 
 MaxScreenItem
  user 
 parameter 
  
 and the 
 MaxScreenStorage
  system parameter.",NA
•,"The number of pixels in the original halftone cell must be less than the 
 number 
  
 of distinct colorant values that the device supports. 
  
 If any of these conditions is not met, the supercell is not created and the 
 original halftone cell is used.",NA
7.5 Scan Conversion Details,"The final step of rendering is 
 scan conversion.
  As discussed in Section 2.2, 
 “Scan Conversion,” the PostScript interpreter executes a scan conversion 
 algorithm to paint graphics, text, and images in the raster memory of the 
 output device. 
  
 The specifics of the scan conversion algorithm are not defined as part of the 
 Post-Script language. Different implementations can perform scan 
 conversion in dif-ferent ways; techniques that are appropriate for one 
 device may be inappropriate for another. Most scan conversion details are 
 not under program control.",NA
Operators,"THIS CHAPTER CONTAINS detailed information about all the standard 
 opera-tors in the PostScript language. It is divided into two sections:",NA
•,"Section 8.1 gives a summary of the operators, organized into groups of 
 related functions. The summary is intended to help locate the operators 
 needed to per-form specific tasks. Less commonly used operators, such as 
 those defined in procedure sets, are not included in this summary.",NA
•,"Section 8.2 provides detailed descriptions of all operators, organized 
 alphabeti-
  
 cally by operator name. 
  
 Each operator description is presented in the following format: 
  
 operator 
  
 operand
 1
   …  operand
 n
 operator
   result
 1
   …  result
 m
  
 A detailed explanation of the operator. 
  
 Example
  
 An example of the use of this operator. 
  
 The symbol
   
 designates the values left on the operand stack by the example. 
  
 Errors: 
  
 A list of errors that this operator might execute 
  
 See Also: A list of related operators
  
 At the head of an operator description, 
 operand
 1
  through 
 operand
 n
  are the 
 oper-ands that the operator requires, with 
 operand
 n
  being the topmost 
 element on the operand stack. The operator pops these objects from the 
 operand stack and con-sumes them; then it executes. After executing, the 
 operator leaves the objects 
 result
 1
  through 
 result
 m
  on the stack, with 
 result
 m
  
 being the topmost element.",NA
8.1 Operator Summary,"Operand Stack Manipulation Operators
  
 any
  
 any
 1
   any
 2 
  
 any
  
 any
 1
   …  any
 n
   n 
  
 any
 n
 …  any
 0
   n 
  
 any
 n
  
 1
  …  any
 0
   n  j
  
 any
 1
   …  any
 n 
 any
 1
   …  any
 n
 –
  
 mark  obj
 1
  …  obj
 n 
 mark  obj
 1
  …  obj
 n
  
 pop
  
 –
  
 Discard top element
  
 exch
  
 any
 2
   any
 1
  
 Exchange top two elements
  
 dup
  
 any  any
  
 Duplicate top element
  
 cop
 y
  
 any
 1
  …  any
 n
   any
 1
  …  any
 n
  
 Duplicate top 
 n
  elements
  
 index
  
 any
 n
  …  any
 0
   any
 n
  
 Duplicate arbitrary element
  
 roll
  
 any
 (
 j
  
 1
 ) mod 
 n
  …  any
 0
   any
 n
  
 1
  …  any
 j
  mod 
 n
  
 Roll 
 n
  elements up 
 j
  times
  
 clear
  
 Discard all elements
  
 count
  
 any
 1
   …  any
 n
   n
  
 Count elements on stack
  
 mark
  
 mark
  
 Push mark on stack
  
 cleartomark
  
 –
  
 Discard elements down through 
 mark
  
 counttomark
  
 mark  obj
 1
  …  obj
 n
   n
  
 Count elements down to 
 mark
  
  
  
 rato 
 add
  
 rs 
  
 sum
  
  
 thmetic and Math Ope 
  
 num
 1
   num
 2
  
 Return 
 num
 1
  plus 
 num
 2
  
 num
 1
   num
 2
  
 div
  
 quotient
  
 Return 
 num
 1
  divided by 
 num
 2
  
 idiv
  
 quotient
  
 int
 1
   int
 2
  
 Return 
 int
 1
  divided by 
 int
 2
  
 mo
 d
  
 remainder
  
 int
 1
   int
 2
  
 Return remainder after dividing 
 int
 1
  by 
 int
 2
  
 mul
  
 product
  
 num
 1
   num
 2
  
 Return 
 num
 1
  times 
 num
 2
  
 sub
  
 difference
  
 num
 1
   num
 2
  
 Return 
 num
 1
  minus 
 num
 2
  
 abs
  
 num
 2
  
 num
 1
  
 Return absolute value of 
 num
 1
  
 num
 1
  
 neg
  
 num
 2
  
 Return negative of 
 num
 1
  
 num
 1
  
 ceiling
  
 num
 2
  
 Return ceiling of 
 num
 1
  
 num
 1
  
 floor
  
 num
 2
  
 Return floor of 
 num
 1
  
 num
 1
  
 round
  
 num
 2
  
 Round 
 num
 1
  to nearest integer
  
 num
 1
  
 truncate
  
 num
 2
  
 Remove fractional part of 
 num
 1
  
 num
  
 sqrt
  
 real
  
 Return square root of 
 num
  
 num  den
  
 atan
  
 angle
  
 Return arctangent of 
 num
 /
 den
  in degrees
  
 angle
  
 cos
  
 real
  
 Return cosine of 
 angle
  degrees
  
 angle
  
 sin
  
 real
  
 Return sine of 
 angle
  degrees
  
 base  exponent
  
 exp
  
 real
  
 Raise 
 base
  to 
 exponent
  power
  
 num
  
 ln
  
 real
  
 Return natural logarithm (base 
 e
 )
  
 num
  
 log
  
 real
  
 Return common logarithm (base 10)",NA
8.2 Operator Details,"[
  
 –  
 [
   mark
  
 pushes a mark object on the operand stack (the same as the 
 mark
  and 
 << 
 opera-tors). The customary use of the 
 [
  operator is to mark the beginning of 
 an indefi-nitely long sequence of objects that will eventually be formed into 
 a new array object by a matching 
 ]
  operator. See the discussion of array 
 syntax in Section 3.2,“Syntax,” and of array construction in Section 3.6, 
 “Overview of Basic Opera-tors.” 
  
 Errors: 
  
 stackoverflow 
  
 See Also: ], <<, mark, array, astore
  
 ] 
  
 mark  obj
 0
  …  obj
 n
  
 1
 ]
   array
  
 creates a new array of 
 n
  elements (where 
 n
  is the number of elements above 
 the topmost mark on the operand stack), stores those elements into the 
 array, and re-turns the array on the operand stack. The 
 ]
  operator stores the 
 topmost object from the stack into element 
 n 
  
  1 of 
 array
  and the 
 bottommost one (the one im-mediately above the mark) into element 0 of 
 array
 . It removes all the array ele-ments from the stack, as well as the mark 
 object. 
  
 The array is allocated in local or global VM according to the current VM 
 alloca-tion mode. An 
 invalidaccess
  error occurs if the array is in global VM 
 and any of the objects 
 obj
 0 
 …obj
 n
  
 1
  are in local VM. See Section 3.7.2, “Local 
 and Global VM.” 
  
 Examples
  
 [5  4  3]
  
 
 % A three-element array, with elements 5, 4, 3 
  
 mark 5 4 3 counttomark array astore exch pop
  
 
 % Same as above
  
 [1  2  add]
  
 
 % A one-element array, with element 3
  
 The first two lines of code above have the same effect, but the second line 
 uses lower-level array and stack manipulation primitives instead of
  [
  and 
 ]
 . 
  
 In the last example, note that the PostScript interpreter acts on all of the 
 array ele-ments as it encounters them (unlike its behavior with the 
 { … }
  
 syntax for execut-able array construction), so the 
 add
  operator is executed 
 before the array is constructed. 
  
 Errors: 
  
 stackoverflow, unmatchedmark, VMerror 
  
 See Also: [, mark, array, astore",NA
•,"showpage
  usually performs the equivalent of an 
 erasepage
  operation after 
  
 transmitting the page, clearing the contents of raster memory in 
 preparation 
  
 for the next page. 
 copypage
  performs this step only in 
 LanguageLevel 3; in 
  
 LanguageLevels 1 and 2, it does not erase the 
 page after transmission.",NA
•,"showpage
  then always performs the equivalent of an 
 initgraphics
  
 operation, 
  
 reinitializing the graphics state for the next page. 
 copypage
  never does this.",NA
•,"If an 
 EndPage
  procedure is defined in the page device dictionary, 
 showpage 
  
 passes it a reason code of 0 on the operand stack, indicating that 
 it is being 
  
 called from 
 showpage
 . In LanguageLevels 1 and 2, 
 copypage
  passes 
 a reason 
  
 code of 1 to inform the 
 EndPage
  procedure that it is being called 
 from 
  
 copypage
  rather than 
 showpage
 ; in LanguageLevel 3, 
 copypage
  
 passes a rea-
  
 son code of 0, as if the call were coming from 
 showpage
  
 instead. See 
  
 Section 6.2.6, “Device Initialization and Page Setup,” for 
 more information on 
  
 EndPage
  procedures and reason codes. 
  
 If a device’s 
 BeginPage
  or 
 EndPage
  procedure invokes 
 copypage
 , an 
 undefined 
 error occurs. 
  
 Note that because 
 copypage
  behaves differently in LanguageLevel 3 than in 
 LanguageLevels 1 and 2, some uses of this operator will produce different 
 results depending on LanguageLevel. For example, some old applications 
 used the code 
  
 n
   {copypage} repeat 
  
 erasepage
  
 to produce 
 n
  copies of the current page; in LanguageLevel 3, this will instead 
 pro-duce one copy followed by 
 n
  
  1 blank pages. Similarly, applications that 
 used 
 copypage
  to implement forms in LanguageLevels 1 and 2 can no longer 
 do so in LanguageLevel 3; the first page will be printed correctly, showing 
 both fixed and",NA
•,"If the current color space is 
 DeviceCMYK
 , 
 currentcmykcolor
  returns the 
 value 
  
 of the current color directly.",NA
•,"If the current color space is 
 DeviceGray
  or 
 DeviceRGB
 , 
 currentcmykcolor
  
 con-
  
 verts the current color to equivalent CMYK components by the 
 formulas dis-
  
 cussed in Section 7.2, “Conversions among Device Color 
 Spaces.”",NA
•,"If the current color space is an 
 Indexed
  space or is a 
 Separation
  or 
 DeviceN 
  
 space with its alternative color space selected, 
 currentcmykcolor
  applies 
 the 
  
 methods above to the underlying color space.",NA
•,"For any other color space, 
 currentcmykcolor
  returns 
 0.0
  for all four CMYK 
  
 components. 
  
 Errors: 
  
 stackoverflow 
  
 See Also: setcmykcolor, currentcolorspace, currentcolor, currentgray, 
  
 currentrgbcolor, currenthsbcolor
  
 currentcolor
  
  
 – 
  currentcolor
   comp
 1
   …  comp
 n 
  
 returns the components of the current color in the graphics state, expressed 
 in the current color space. The number of components returned, 
 n
 , is 
 determined by the
  
 color space. 
  
 Errors: 
  
 stackoverflow 
  
 See Also: setcolor, setcolorspace
  
 currentcolorrendering
  
  
  –  
 currentcolorrendering  
 dict
  
 returns the current CIE-based color rendering dictionary parameter in the 
 graph-ics state. 
  
 Errors:
  
 stackoverflow
  
 See Also: setcolorrendering, findcolorrendering",NA
•,"If the current color space is 
 DeviceGray
 , 
 currentgray
  returns the value of 
 the 
  
 current color directly.",NA
•,"If the current color space is 
 DeviceRGB
  or 
 DeviceCMYK
 , 
 currentgray
  
 converts 
  
 the current color to an equivalent gray level by the formulas 
 discussed in 
  
 Section 7.2, “Conversions among Device Color Spaces.”",NA
•,"If the current color space is an 
 Indexed
  space or is a 
 Separation
  space with 
 its 
  
 alternative color space selected, 
 currentgray
  applies the methods 
 above to the 
  
 underlying color space.",NA
•,"For any other color space, 
 currentgray
  returns 
 0.0
 . 
  
 Errors: 
  
 stackoverflow 
  
 See Also: setgray, currentcolorspace, currentcolor, currenthsbcolor, 
  
 currentrgbcolor, currentcmykcolor",NA
•,"If the current color space is 
 DeviceRGB
 , 
 currentrgbcolor
  returns the value 
 of 
  
 the current color directly.",NA
•,"If the current color space is 
 DeviceGray
  or 
 DeviceCMYK
 , 
 currentrgbcolor
  con-
  
 verts the current color to equivalent RGB components by the formulas 
 dis-cussed in Section 7.2, “Conversions among Device Color Spaces.”",NA
•,"If the current color space is an 
 Indexed
  space or is a 
 Separation
  or 
 DeviceN 
  
 space with its alternative color space selected, 
 currentrgbcolor
  applies the 
  
 methods above to the underlying color space.",NA
•,"For any other color space, 
 currentrgbcolor
  returns 
 0.0
  for all three RGB 
 com-
  
 ponents. 
  
 Errors: 
  
 stackoverflow 
  
 See Also: setrgbcolor, currentcolorspace, currentcolor, currentgray, 
  
 currenthsbcolor, currentcmykcolor
  
 currentscreen
  
 –  currentscreen
   frequency  angle  proc
  
 (LanguageLevel 2)
  
 –  currentscreen
   frequency  angle  halftone
  
 returns the frequency, angle, and spot function of the current halftone 
 screen pa-rameter in the graphics state (see Section 7.4, “Halftones”), 
 assuming that the halftone was established via the 
 setscreen
  operator. If 
 setcolorscreen
  was used in-stead, the values returned describe the screen for 
 the gray color component only. 
  
 If the current halftone was defined via the 
 sethalftone
  operator, 
 currentscreen
  
 re-turns a halftone dictionary describing its properties in place of the spot 
 function. For type 1 halftone dictionaries, the values returned for 
 frequency
  
 and 
 angle 
 are taken from the dictionary’s 
 Frequency
  and 
 Angle
  entries; for all 
 other halftone types, 
 currentscreen
  returns a frequency of 60 and an angle of 
 0.
  
 Errors: 
  
 stackoverflow 
  
 See Also: setscreen, setcolorscreen, sethalftone, currentcolorscreen, 
  
 currenthalftone
  
 currentshared
  
  
 – 
  currentshared
   bool
  
 performs the same operation as 
 currentglobal
 . This operator is defined for 
 com-patibility with earlier PostScript interpreter implementations. 
  
 Errors:
  
 stackoverflow
  
 See Also: setglobal, setshared",NA
•,"The new definition is local.
 defineresource
  installs the new local definition, 
  
 replacing an existing local definition if there is one. If there is an existing 
 global 
  
 definition, 
 defineresource
  does not disturb it. However, the global 
 definition is 
  
 obscured by the local one. If the local definition is later 
 removed, the global 
  
 definition reappears.",NA
•,"The new definition is global.
 defineresource
  first removes an existing local 
 defi-
  
 nition if there is one. It then installs the new global definition, 
 replacing an 
  
 existing global definition if there is one. 
  
 defineresource
  can be used multiple times to associate a given resource 
 instance with more than one key. 
  
 If the category name is unknown, an 
 undefined
  error occurs. If the instance is 
 of the wrong type for the specified category, a 
 typecheck
  error occurs. If the 
 instance is in local VM but the current VM allocation mode is global, an 
 invalidaccess 
 error occurs; this is analogous to storing a local object into a 
 global dictionary. Other errors can occur for specific categories; for 
 example, when dealing with the 
 Font
  or 
 CIDFont
  category, 
 defineresource
  may 
 execute an 
 invalidfont
  error. 
  
 Errors: 
  
 invalidaccess, stackunderflow, typecheck, undefined 
  
 See Also: undefineresource, findresource, resourcestatus, resourceforall
  
 defineuserobject
  
  
 index  any 
  defineuserobject
   –
  
 establishes an association between the nonnegative integer 
 index
  and the 
 object 
 any 
 in the 
 UserObjects
  array (see Section 3.7.6, “User Objects”). First, it 
 creates a
  
 UserObjects
  array in
  userdict
  if one is not already present, or extends an 
 existing 
 UserObjects
  array if necessary. It then executes the equivalent of 
  
 userdict /UserObjects get 
  
 3  1  roll  put
  
 In other words, it simply stores 
 any
  into the array at the position specified 
 by 
 index
 .",NA
•,"Accessing the value of a composite object in violation of its access 
 attribute (for 
  
 example, storing into a read-only array or reading an 
 execute-only string)",NA
•,"Storing a composite object in local VM as an element of a composite 
 object in 
  
 global VM",NA
•,"Executing 
 pathforall
  if the current path contains an outline for a protected font 
  
 See Also: rcheck, wcheck, gcheck, readonly, executeonly, noaccess",NA
•,"Concatenates
  matrix
  with the saved copy of the current transformation matrix",NA
•,"Adjusts the resulting matrix to ensure that the device space can be tiled 
 prop-
  
 erly with a pattern cell of the given size in accordance with the 
 pattern’s tiling 
  
 type",NA
•,Resets the current path to empty,NA
•,"Replaces the clipping path with the pattern cell bounding box specified 
 by the 
  
 pattern dictionary’s 
 BBox
  entry",NA
•,"Replaces the current device with a special one provided by the PostScript 
  
 implementation 
  
 Finally, 
 makepattern
  makes the new dictionary read-only and returns it on 
 the operand stack. The resulting pattern dictionary is suitable for use as an 
 operand to 
 setpattern
  or as a color value in a 
 Pattern
  color space. 
  
 Errors: 
  
 limitcheck, rangecheck, stackunderflow, typecheck, undefined, VMerror 
 See Also: setpattern
  
 mark
 – 
  mark
   mark
  
 pushes a mark object on the operand stack. All marks are identical, and the 
 oper-and stack may contain any number of them at once. 
  
 The primary use of marks is to indicate the stack position of the beginning 
 of an indefinitely long list of operands being passed to an operator or 
 procedure. The
  ] 
 operator (array construction) is the most common 
 operator that works this way; it treats as operands all elements of the stack 
 down to a mark that was pushed by the
  [
  operator (
 [
  is a synonym for 
 mark
 ). 
 It is possible to define procedures that",NA
•,"Array packing mode (see 
 setpacking
 )",NA
•,"VM allocation mode (see 
 setglobal
 )",NA
•,"Object output format (see 
 setobjectformat
 )",NA
•,"All user interpreter parameters (see 
 setuserparams
 ) 
  
 Errors: 
  
 invalidrestore, stackunderflow, typecheck 
  
 See Also: save, grestoreall, vmstatus, startjob
  
 reversepath
  
 –  
 reversepath
   –
  
 replaces the current path with an equivalent one whose segments are 
 defined in the reverse order. The operation reverses the directions and 
 order of segments within each subpath of the current path; the relative 
 order of subpaths within the path as a whole is unspecified and 
 unpredictable. 
  
 If a subpath ends with a 
 closepath
  operation, the reversed subpath begins at 
 the point that was the beginning of the original 
 closepath
  segment. The 
 segment added by 
 closepath
  thus remains at the end of the subpath, though 
 it is traversed in the opposite direction. 
  
 Errors: 
  
 limitcheck 
  
 See Also: closepath
  
 revision
  
  
 – 
  revision
   int
  
 is an integer designating the current revision level of the product in which the 
 PostScript interpreter is running. Each product has its own numbering system 
 for
  
 revisions, independent of those of any other product. This is distinct from 
 the value of 
 version
  in 
 systemdict
 , which is the revision level of the PostScript 
 inter-preter, without regard to the product in which it is running. 
  
 Errors: 
  
 stackoverflow 
  
 See Also: languagelevel, product, serialnumber, version",NA
•,"Shading patterns (
 PatternType
  2) or colored tiling patterns (
 PatternType
  1, 
  
 PaintType
  1) use the second form of the operator, in which the pattern 
 diction-
  
 ary is the only operand.",NA
•,"Uncolored tiling patterns (
 PatternType
  1, 
 PaintType
  2) use the third form, in
  
 which the dictionary is accompanied by one or more component values 
 in the pattern’s underlying color space, defining the color in which the 
 pattern is to be painted. 
  
 The 
 setcolorspace
  operator initializes the current color to a value that 
 depends on the specific color space selected. 
  
 Execution of this operator is not permitted in certain circumstances; see 
 Section 4.8.1, “Types of Color Space.” 
  
 Errors: 
  
 stackunderflow, typecheck, undefined 
  
 See Also: currentcolor, setcolorspace, setgray, setrgbcolor, sethsbcolor, 
  
 setcmykcolor
  
 setcolorrendering
  
  
 dict 
  setcolorrendering
   –
  
 sets the current CIE-based color rendering dictionary (CRD) in the graphics 
 state to 
 dict
 . The default CRD is device-dependent (see Section 7.1, “CIE-Based 
 Color
  
 to Device Color”).
  
 Because the effect of the CRD is device-dependent, this operator ordinarily 
 should not be used in a page description that is intended to be device-
 independent. However, it is acceptable to use it to establish a CRD that has 
 been obtained by means of the 
 findcolorrendering
  operator; this does not 
 compromise the device independence of the page description, even though 
 the CRD itself is device-dependent. 
  
 Execution of this operator is not permitted in certain circumstances; see 
 Section 4.8.1, “Types of Color Space.” 
  
 Errors: 
  
 limitcheck, rangecheck, stackunderflow, typecheck, undefined 
 See Also: currentcolorrendering, findcolorrendering",NA
•,"If a parameter name is not known to the implementation, an 
 undefined
  
 error 
  
 occurs.",NA
•,"If a parameter value is of the wrong type, a 
 typecheck
  error occurs.",NA
•,"If a numeric parameter value is unreasonable—for instance, a negative 
 integer 
  
 for a parameter that must be positive—a 
 rangecheck
  error occurs.",NA
•,"If a numeric parameter value is reasonable but cannot be achieved by the 
  
 implementation, either the nearest achievable value is substituted or a 
  
 configurationerror
  occurs, depending on the device and the parameter.",NA
•,"If a string parameter value exceeds either the general implementation 
 limit on 
  
 strings (noted in Appendix B) or an implementation-dependent 
 limit specific 
  
 to that parameter, a 
 limitcheck
  error occurs. 
  
 Errors: 
  
 configurationerror, invalidaccess, limitcheck, rangecheck, 
  
 stackunderflow, typecheck, undefined 
  
 See Also: currentdevparams, setsystemparams, setuserparams
  
 setfileposition
  
  
 file  position  
 setfileposition
   –
  
 repositions an existing open file to a new position so that the next read or 
 write operation will commence at that position. The 
 position
  operand is a 
 nonnegative
  
 integer interpreted as number of bytes from the beginning of the file. For an 
 out-put file, 
 setfileposition
  first performs an implicit 
 flushfile
  operation (see 
 Section 3.8, “File Input and Output”). 
  
 The result of positioning beyond end-of-file for both reading and writing 
 depends on the behavior of the underlying file system. Typically, positioning 
 beyond the existing end-of-file will lengthen the file if it is open for writing 
 and the file’s ac-cess permits this. The storage appended to the file has 
 unspecified contents. If",NA
•,"1.414 cuts off miters (converts them to bevels) at angles less than 90 
 degrees.",NA
•,2.0 cuts off miters at angles less than 60 degrees.,NA
•,10.0 cuts off miters at angles less than 11 degrees.,NA
•,"1.0 cuts off miters at all angles, so that bevels are always produced even 
 when 
  
 miters are specified. 
  
 The default value of the miter limit is 10.0. 
  
 Errors: 
  
 rangecheck, stackunderflow, typecheck 
  
 See Also: currentmiterlimit, stroke, setlinejoin",NA
•,"Shading patterns (
 PatternType
  2) and colored tiling patterns (
 PatternType
  
 1, 
  
 PaintType
  1) define their own colors as part of the pattern itself; there is 
 no 
  
 underlying color space. Therefore, the operands 
 comp
 1
  through 
 comp
 n
  should 
  
 not be specified.",NA
•,"Uncolored tiling patterns (
 PatternType
  1, 
 PaintType
  2) have no inherent 
 color; 
  
 the color must be specified explicitly by the components 
 comp
 1
  
 through 
 comp
 n 
  
 in the underlying color space of the 
 Pattern
  space. If the 
 Pattern
  color space 
  
 does not have an underlying color space, a 
 rangecheck
  
 error occurs.",NA
•,"The current execution context supports job encapsulation—in other 
 words, is 
  
 under the control of a job server.",NA
•,"password
  is correct—in other words, matches the 
 StartJobPassword
  or 
  
 SystemParamsPassword 
 system parameter.",NA
•,"The current level of 
 save 
 nesting is no deeper than it was at the time the 
 cur-
  
 rent job started. 
  
 If all three conditions are satisfied, 
 startjob
  performs the following actions: 
  
 1. Ends the current job—in other words, resets the stacks and, if the current 
 job 
  
 was encapsulated, performs a 
 restore 
 operation. 
  
 2. Begins a new job. If 
 bool
 1
  is 
 true
 , the usual 
 save
  operation at the beginning 
 of the job is omitted, enabling the new job to make persistent alterations 
 to the initial VM. If 
 bool
 1
  is 
 false
 , the usual 
 save 
 operation is performed, 
 encapsulat-ing the new job. 
  
 3. Returns 
 true
  on the operand stack. 
  
 If any of the three conditions is not satisfied, 
 startjob
  pushes 
 false
  on the 
 operand stack and has no other effect. 
  
 password
  is a string that authorizes switching between encapsulated and 
 unencap-sulated jobs, as well as between an ordinary encapsulated job and 
 a system admin-istrator job. If 
 password
  is an integer, it is first converted to a 
 string, as if by the 
 cvs",NA
•,"An opening string or procedure bracket—
 (
 , 
 <
 , 
 <~
 , or
  {
 —is not matched by 
 a 
  
 corresponding closing bracket before the end of the file or string being 
 inter-
  
 preted.",NA
•,"A closing string or procedure bracket—
 )
 , 
 >
 , 
 ~>
 , or 
 }
 —is not matched by a 
 cor-
  
 responding previous opening bracket.",NA
•,"A character other than a hexadecimal digit or white-space character 
 appears 
  
 within a hexadecimal string literal bracketed by 
 < … >
 .",NA
•,"An encoding violation occurs in an ASCII base-85 string literal bracketed 
 by 
  
 <~ … ~>
 .",NA
•,"A binary token or binary object sequence has incorrect structure (see 
  
 Section 3.14, “Binary Encoding Details”). 
  
 Erroneous tokens, such as malformed numbers, do not produce a 
 syntaxerror
 ; such tokens are instead treated as name objects (often 
 producing an 
 undefined 
 error when executed). Tokens that exceed 
 implementation limits, such as names that are too long or numbers whose 
 values are too large, produce a 
 limitcheck 
 error (see Appendix B).",NA
•,"In local VM allocation mode, 
 undefineresource
  removes a local definition if 
  
 there is one. If there is a global definition with the same key, 
 undefineresource 
  
 does not disturb it; the global definition, formerly 
 obscured by the local one, 
  
 now reappears.",NA
•,"In global VM allocation mode,
  undefineresource
  removes a local definition, 
 a 
  
 global definition, or both. 
  
 Depending on the resource category, 
 undefineresource
  may have other side 
 ef-fects (see Section 3.9.2, “Resource Categories”); these side effects are 
 determined 
 by 
 the 
 UndefineResource
  
 procedure 
 in 
 the 
 category 
 implementation dictionary. However, 
 undefineresource
  does not alter the 
 resource instance in any way. If the instance is still accessible (say, stored 
 directly in some dictionary or defined as a resource under another name), it 
 can still be used in whatever ways are appropri-ate. The object becomes a 
 candidate for garbage collection only if it is no longer accessible.",NA
•,"An attempt to create a new composite object (string, array, dictionary, or 
  
 packed array) would exhaust VM resources. Either the program’s 
 requirements 
  
 exceed available capacity or, more likely, the program 
 has failed to use the 
  
 save
 -
 restore
  facility appropriately (see Section 
 3.7, “Memory Management”).",NA
•,"The interpreter has attempted to perform an operation that should be 
 impossi-
  
 ble due to access restrictions (for example, storing into 
 systemdict
 , 
 which is 
  
 read-only). This represents an internal error in the interpreter. 
  
 The default handler for this error, unlike those for all other errors, does not 
 snap-shot the stacks. 
  
 vmreclaim
  
  
 int  
 vmreclaim
   –
  
 controls the garbage collection machinery as specified by 
 int
 : 
  
  
 2
  
 Disables automatic collection in both local and global VM 
  
  
 1
  
 Disables automatic collection in local VM 
  
 0
  
 Enables automatic collection 
  
 1
  
 Performs immediate collection in local VM 
  
 2
  
 Performs immediate collection in local and global VM 
  
 Garbage collection causes the memory occupied by the values of 
 inaccessible ob-jects to be reclaimed and made available for reuse. It does 
 not have any effects that are visible to the PostScript program. There is 
 normally no need to execute the 
 vmreclaim
  operator, because garbage 
 collection is invoked automatically when",NA
•,"In an interactive application that is temporarily idle, an immediate 
 garbage 
  
 collection can be invoked to put the idle time to good use. This 
 defers the need 
  
 to perform an automatic collection subsequently. In a 
 context that is under the 
  
 control of a job server (described in Section 
 3.7.7, “Job Execution Environ-
  
 ment”), garbage collection is invoked 
 automatically between jobs.",NA
•,"For meaningful results when monitoring the VM consumption of a 
 program, 
  
 garbage collection must be invoked before 
 vmstatus
  is executed.",NA
•,"For repeatable results when measuring a program’s execution time, 
 automatic 
  
 garbage collection must be disabled. 
  
 The negative values that disable garbage collection apply only to the current 
 exe-cution context; they do not prevent collection from occurring during 
 execution of other contexts. Note that disabling garbage collection for too 
 long may eventually cause a program to run out of memory and fail with a 
 VMerror
 . 
  
 Executing 
 vmreclaim
  with an operand of 0, 
  
 1, or 
  
 2 has the same effect as 
 setting the 
 VMReclaim
  user parameter to the same value by means of 
 setuserparams
  (see Appendix C). 
  
 Errors: 
  
 rangecheck, stackunderflow, typecheck 
  
 See Also: setvmthreshold, setuserparams
  
 vmstatus
  – 
  vmstatus
   level  used  maximum
  
 returns three integers describing the state of the PostScript interpreter’s 
 virtual memory (VM). 
 level
  is the current depth of 
 save
  nesting—in other 
 words, the number of 
 save
  operations that have not been matched by a 
 restore
  operation. 
 used
  and 
 maximum
  measure VM resources in units of 8-bit 
 bytes; 
 used
  is the num-ber of bytes currently in use and 
 maximum
  is the 
 maximum available capacity. 
  
 VM consumption is monitored separately for local and global VM. The 
 used
  
 and 
 maximum
  values apply to either local or global VM according to the 
 current VM allocation mode (see 
 setglobal
 ). 
  
 The 
 used
  value is meaningful only immediately after a garbage collection has 
 taken place (see 
 vmreclaim
 ). At other times, it may be too large because it 
 includes memory occupied by objects that have become inaccessible, but 
 have not yet been reclaimed. 
  
 The 
 maximum
  value is an estimate of the maximum size to which the current 
 VM (local or global) could grow, assuming that all other uses of available 
 memory re-",NA
LanguageLevel ,NA,NA
Feature Summary,"SINCE ITS INTRODUCTION IN
  1985
 , the PostScript language has been ex-
 tended several times to incorporate new operators and other features. This 
 ap-pendix summarizes these changes. 
  
 Extensions are organized into major groups called 
 LanguageLevels
 , 
 numbered 1, 2, and 3. A PostScript interpreter that is based on a particular 
 LanguageLevel supports all features of that LanguageLevel and lower. It 
 may also support some additional features that are not a standard part of 
 its base LanguageLevel. 
  
 For an introduction to the LanguageLevel concept, see Section 1.2, 
 “Evolution of the PostScript Language.” For guidelines about dealing 
 compatibly with different LanguageLevels and extensions, see Appendix D. 
  
 The grouping of features by LanguageLevel is definitive. On the other hand, 
 the grouping of features by other criteria, such as product version numbers, 
 describes only how those features have been introduced as extensions in 
 Adobe PostScript implementations. Such grouping, while of historical 
 significance, is not part of the PostScript language definition and does not 
 necessarily apply to all products.",NA
A.1 LanguageLevel 3 Features,"The LanguageLevel 3 features listed in this section, along with the features 
 docu-mented in the second edition of this book, are present in all 
 LanguageLevel 3 in-terpreters.",NA
•,"bind
  performs idiom recognition.",NA
•,"copypage
  no longer preserves page contents.",NA
•,"All filters have a 
 CloseSource
  or 
 CloseTarget
  parameter, and the 
 LZWEncode 
  
 and 
 LZWDecode
  filters have additional new parameters.",NA
•,"Halftone dictionaries have a 
 HalftoneName
  entry.",NA
•,"The base for an 
 Indexed
  color space can be 
 Separation
  or 
 DeviceN
 .",NA
•,"Overprinting is applied to colorants of a composite page, not just to 
 separa-
  
 tions.",NA
•,"glyphshow
  accepts an integer operand. 
  
 A number of LanguageLevel 3 features were first introduced as extensions 
 to LanguageLevel 2. The following sections list the features introduced by 
 each of these extensions and, when possible, indicate which versions of 
 Adobe PostScript implementations support them. 
  
 A.1.1 Version 2017 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2017 and greater:",NA
•,"HalftoneType
  category instances: 9, 100 (note that these halftone types are 
  
 product-dependent)",NA
•,"Page device parameters: 
 LeadingEdge
 , 
 MediaClass
 , 
 RollFedMedia
 , 
 UseCIEColor",NA
•,"Overprinting applied to colorants of a composite page, not just separations 
  
 A.1.2 Version 2016 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2016 and greater:",NA
•,"BitmapFontInit
  procedure set operators: 
 addglyph
 , 
 removeall
 , 
 removeglyphs",NA
•,"ColorSpaceFamily
  category instances: 
 CIEBasedDEF
 , 
 CIEBasedDEFG",NA
•,"FontType
  category instance: 32 
  
 A.1.3 Version 2015 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2015 and greater:",NA
•,"Operators: 
 composefont
 , 
 findcolorrendering",NA
•,"CIDInit
  and 
 ColorRendering
  procedure set operators (see Table A.1 on page 726)",NA
•,"Regular resource categories: 
 CIDFont
 , 
 CMap
 , 
 ControlLanguage
 , 
 Localization
 , 
  
 PDL",NA
•,"FMapType
  category instance: 9",NA
•,"FontType
  category instances: 9, 10, 11",NA
•,"HalftoneType
  category instance: 10",NA
•,"HalftoneName
  entry in halftone dictionary",NA
•,"Page device parameter: 
 PageDeviceName",NA
•,"glyphshow
  integer operand",NA
•,"GlyphDirectory
  entry in Type 42 font 
  
 A.1.4 Version 2014 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2014 and greater:",NA
•,"Page device parameters: 
 DeferredMediaSelection
 , 
 ImageShift
 , 
 MediaPosition
  
 A.1.5 Version 2013 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2013 and greater:",NA
•,"FontType
  category instance: 42",NA
•,"Page device parameter: 
 PageOffset
  
 A.1.6 Version 2012 Extensions
  
 The following LanguageLevel 3 features are present in LanguageLevel 2 
 imple-mentations version 2012 and greater:",NA
•,"Page 
  
 device 
  
 parameters: 
  
 ProcessColorModel
 , 
  
 SeparationColorNames
 ,
  
 SeparationOrder",NA
•,"Regular resource categories: 
 HWOptions
 , 
 OutputDevice",NA
•,"HalftoneType
  category instance: 6",NA
•,"Page device parameters: 
 InsertSheet
 , 
 OutputDevice
 , 
 TraySwitch",NA
•,"Policies
  subdictionary, 
 PageSize
  value: 7",NA
•,"User parameters: 
 AccurateScreens
 , 
 JobName",NA
•,"System parameters: 
  
 CurSourceList 
  
 MaxImageBuffer 
  
 CurStoredScreenCache 
  
 MaxSourceList 
  
 FactoryDefaults 
  
 MaxStoredScreenCache 
 FontResourceDir 
  
 PageCount 
  
 GenericResourceDir 
  
 PrinterName 
  
 GenericResourcePathSep 
  
 StartupMode 
  
 LicenseID",NA
A.2 LanguageLevel 2 Features,"The following LanguageLevel 2 features, along with the LanguageLevel 1 
 features documented in the original edition of this book, are present in all 
 LanguageLevel 2 interpreters:",NA
•,"<< … >> syntax for constructing dictionary 
 objects",NA
•,<~ … ~> syntax for ASCII base-85 string literals,NA
•,// syntax for immediately evaluated names,NA
•,Binary encodings,NA
•,Object type packedarray,NA
•,"Operators:
  
 << 
  
 glyphshow
  
 >> 
  
 gstate
  
 arct 
  
 ineofill
  
 colorimage 
  
 infill
  
 cshow 
  
 instroke
  
 currentblackgeneration 
  
 inueofill
  
 currentcacheparams 
  
 inufill
  
 currentcmykcolor 
  
 inustroke
  
 currentcolor 
  
 ISOLatin1Encoding
  
 currentcolorrendering 
  
 languagelevel
  
 currentcolorscreen 
  
 makepattern
  
 currentcolorspace 
  
 packedarray
  
 currentcolortransfer 
  
 printobject
  
 currentdevparams 
  
 product
  
 currentglobal 
  
 realtime
  
 currentgstate 
  
 rectclip
  
 currenthalftone 
  
 rectfill
  
 currentobjectformat 
  
 rectstroke
  
 currentoverprint 
  
 renamefile
  
 currentpacking 
  
 resourceforall
  
 currentpagedevice 
  
 resourcestatus
  
 currentshared 
  
 revision
  
 currentstrokeadjust rootfont
  
 currentsystemparams 
  
 scheck
  
 currentundercolorremoval 
  
 selectfont
  
 currentuserparams 
  
 serialnumber
  
 defineresource 
  
 setbbox
  
 defineuserobject 
  
 setblackgeneration
  
 deletefile 
  
 setcachedevice2
  
 execform 
  
 setcacheparams
  
 execuserobject 
  
 setcmykcolor
  
 filenameforall 
  
 setcolor
  
 fileposition 
  
 setcolorrendering
  
 filter 
  
 setcolorscreen
  
 findencoding 
  
 setcolorspace
  
 findresource 
  
 setcolortranfer
  
 gcheck 
  
 setdevparams
  
 globaldict 
  
 setfileposition
  
 GlobalFontDirectory 
  
 setglobal",NA
•,// syntax for immediately evaluated names,NA
•,Object type packedarray,NA
•,"Operators: 
  
 currentcacheparams 
  
 currentpacking 
  
 packedarray 
  
 setcacheparams 
  
 setpacking",NA
A.3 Incompatibilities,"In a few instances, changes have been introduced that, strictly speaking, are 
 not forward-compatible from one LanguageLevel to the next. This section 
 summa-rizes those changes.",NA
•,"If the source of text is a string instead of a file, an occurrence of a string 
 literal enclosed in parentheses is treated specially in LanguageLevel 1: 
 the scanner re-turns a substring of the original string instead of allocating 
 a new string, and it does not recognize 
 \
  escape sequences within the 
 string literal. In Language-Levels 2 and 3, the scanner operates in a 
 consistent way for all sources of text.",NA
•,"The 
 copy
  operator, when applied to dictionaries, copies the source 
 dictionary’s attribute to the destination dictionary in LanguageLevel 1; it 
 does not do so in LanguageLevels 2 and 3.",NA
•,"The 
 copypage
  operator preserves page contents in LanguageLevels 1 and 
 2, but erases the page in LanguageLevel 3. The use of 
 copypage
  was 
 discouraged even in LanguageLevel 2.",NA
•,"The encoding filters that are a standard part of LanguageLevel 2, with the 
 ex-ception of 
 NullEncode
 , have become optional in LanguageLevel 3 and 
 may not be supported in some products.",NA
Implementation Limits,"THE POSTSCRIPT LANGUAGE does not inherently restrict the sizes or 
 quanti-ties of things described in the language, such as numbers, arrays, 
 stacks, paths, and so forth. However, a PostScript interpreter running on a 
 particular processor in a particular operating environment does have such 
 limits, and cannot execute PostScript programs that exceed those limits. 
 Attempting to perform an opera-tion that would exceed one of the limits 
 causes the error 
 limitcheck
  (or 
 VMerror
  if the operation exhausts virtual 
 memory resources). 
  
 Because the PostScript interpreter has been designed to handle very 
 complex page descriptions, all implementation limits are large enough that 
 most Post-Script page descriptions should never come close to exceeding 
 them. On the other hand, the interpreter is 
 not
  designed for unlimited 
 general programming. Although the PostScript language makes no formal 
 distinction between page de-scriptions and general programs, a PostScript 
 interpreter residing in a printer is specifically optimized for its intended 
 use: to produce raster output according to a fully specified graphical 
 description generated by some external application program. For this 
 reason, programs that are not page descriptions may well en-counter some 
 of the implementation limits. 
  
 Occurrence of a 
 limitcheck
  error during the execution of a page description 
 often points to an error in the PostScript program itself, such as unbounded 
 recursion on one of the stacks. A 
 VMerror
  typically indicates that the 
 program is not using the 
 save
  and 
 restore
  operators properly.",NA
B.1 Typical Limits,"This section describes limits that are typical of PostScript implementations 
 from Adobe Systems. These limits fall into two main classes:",NA
•,"Architectural limits
 . The hardware on which the PostScript interpreter 
 executes imposes certain constraints; for example, integers are usually 
 represented in 32 bits, limiting the range of integer values that are 
 allowed. Additionally, the de-sign of the software imposes other 
 constraints, such as a limit of 65,535 ele-ments in an array or string.",NA
•,"Memory limits
 . The amount of memory available to the PostScript 
 interpreter limits the number of memory-consuming objects that the 
 interpreter can hold simultaneously. Memory management is discussed 
 below. 
  
 Table B.1 shows the typical architectural limits for most PostScript 
 interpreters running on 32-bit machines. Although these limits are likely to 
 remain constant across a wide variety of platforms, they do not necessarily 
 apply to all PostScript implementations. In particular, the limits for real 
 numbers in any implementa-tion are those imposed by the native floating-
 point representation of the underly-ing hardware platform. The real-
 number limits shown in the table are based on the IEEE 754 standard for 
 normalized single-precision floating-point arithmetic. (See the Bibliography 
 for a reference to this document.) Not all implementations adhere to this 
 standard, however; see product documentation for the exact limits in a 
 particular implementation. 
  
 Memory limits cannot be characterized so precisely, because the amount of 
 avail-able memory and the ways in which it is allocated vary from one 
 product to an-other. Nevertheless, it is possible to give some general 
 information about memory limits that a complex page description is likely 
 to encounter. 
  
 The PostScript interpreter requires memory for a variety of purposes, including:",NA
•,Virtual memory for the values of composite objects,NA
•,Stacks and other objects visible to a PostScript program,NA
•,"Paths in the graphics state, including those saved by the 
 save
 , 
 gsave
 , 
 gstate
 , 
  
 and 
 currentgstate
  operators",NA
•,"Frame buffer or other internal representation of the raster memory for the 
 cur-
  
 rent page",NA
•,"Font cache, user path cache, form cache, pattern cache, and other internal 
 data structures that save the results of expensive computations in order 
 to avoid re-dundant work
  
 TABLE B.1 Architectural limits
  
 QUANTITY
  
 LIMIT
  
 DESCRIPTION
  
 integer
  
 2,147,483,647
  
 Largest integer value. This value is equal to 2
 31
  
  1, and its internal repre-
  
 sentation is 
 16#7FFFFFFF
 . In most situations, an integer that would 
 exceed this limit is automatically converted to a real value. 
  
  
 2,147,483,648
  
 Smallest integer value. This value is equal to 
  
 2
 31
 , and its internal 
 repre-sentation is 
 16#80000000
 . 
  
 real
  
 
 10
 38
  
 Largest and smallest real values (approximate). 
  
 Nonzero real values closest to 0 (approximate). Values closer than 
 these
  
 
 10
  
 38
  
 are automatically converted to 0. 
  
 array
  
 8
  
 Significant decimal digits of precision (approximate). 
  
 65,535
  
 Maximum length of an array, in elements. 
  
 dictionary
  
 65,535
  
 Maximum capacity of a dictionary, in entries. 
  
 string
  
 65,535
  
 Maximum length of a string, in characters. 
  
 name
  
 127
  
 Maximum length of a name, in characters. 
  
 file name
  
 100
  
 Maximum length of a file name, including the 
 %
 device
 %
  prefix. 
  
 save
  level
  
 15
  
 Maximum number of active 
 save
  operations that have not yet been
  
 matched by a corresponding 
 restore
 . 
  
 gsave
  level
  
 31
  
 Maximum number of active 
 gsave
  operations. Each 
 save
  operation also
  
 performs an implicit 
 gsave
 . 
  
 clipsave
  level
  
 31
  
 Maximum number of active 
 clipsave
  operations within a graphics state
  
 that have not yet been matched by a corresponding 
 cliprestore
 . 
  
 XUID
  array
  
 16
  
 Maximum number of elements in an 
 XUID
  (extended unique ID) array. 
  
 CID
  
 65,535
  
 Maximum value of a CID (character identifier). 
  
 separations
  
 250
  
 Maximum number of separations, colorants, or color components in
  
 DeviceN
  color space.",NA
•,"Rendering extremely complex paths requires a substantial amount of 
 memory, 
  
 particularly when the 
 clip
  operator is invoked.",NA
•,"Halftone screens occupy an amount of memory that depends on the 
 screen angle, frequency, and device resolution. Screens saved by 
 gsave
  
 may occupy additional memory.",NA
•,"High-resolution devices, such as imagesetters, represent the current page 
 as a display list on the disk instead of a full pixel array in memory. If disk 
 space is exhausted, a 
 limitcheck
  error occurs. 
  
 TABLE B.2 Typical memory limits in LanguageLevel 1
  
 QUANTITY
  
 LIMIT
  
 DESCRIPTION
  
 userdict
  
 200
  
 Capacity of 
 userdict
 . Note that 
 userdict
  starts out with a few entries 
 already
  
 defined. 
  
 FontDirectory
  
 100
  
 Capacity of 
 FontDirectory
 , determining the maximum number of fonts that
  
 may be defined simultaneously. 
  
 operand stack
  
 500
  
 Maximum depth of the operand stack: number of elements that may be
  
 pushed on and not yet popped off. This also establishes a limit on the 
 num-ber of elements contained in all unfinished procedure definitions 
 being pro-cessed by the PostScript language scanner, since the scanner 
 uses the operand stack to accumulate them. 
  
 dictionary stack
  
 20
  
 Maximum depth of the dictionary stack. 
  
 execution stack
  
 250
  
 Maximum depth of the execution stack. Each procedure, file, or string 
 whose
  
 execution has been suspended occupies one element of this stack. Also, 
 con-trol operators such as 
 for
 , 
 repeat
 , and 
 stopped
  push a few additional 
 ele-ments on the stack to control their execution. 
  
 interpreter 
 level
  
 10
  
 Maximum number of recursive invocations of the PostScript interpreter.
  
 Graphics operators that call PostScript procedures, such as 
 pathforall
 , 
 show
 , and 
 image
 , invoke the interpreter recursively. 
  
 path
  
 1500
  
 Maximum number of points specified in all active path descriptions, 
 includ-
  
 ing the current path, the clipping path, and paths saved by 
 save
  and 
 gsave
 .",NA
B.2 Virtual Memory Use,"It is impossible to predict accurately how much virtual memory a program 
 will consume, but it is possible to make a rough estimate. VM is occupied 
 primarily by the values of composite objects. Simple objects do not 
 consume VM, nor do composite objects that share the values of other 
 objects. Some typical memory re-quirements are as follows:",NA
•,"Array values are created and VM consumed when a program executes the 
 array
 , 
  
 ]
 , and 
 matrix
  operators. An array value occupies 8 bytes per 
 element.",NA
•,"When the PostScript language scanner encounters a procedure delimited 
 by 
 { … }
 , it creates either an array or a packed array, according to the 
 current pack-ing mode (see the description of the 
 setpacking
  operator in 
 Chapter 8). An array value occupies 8 bytes per element. A packed array 
 value occupies 1 to 9 bytes per element, depending on each element’s 
 type and value; a typical aver-age is 2.5 bytes per element.",NA
•,"String values are created and VM consumed when a program executes the 
 string
  operator and when the scanner encounters string literals delimited 
 by 
 ( … )
 , 
 < … >
 , and 
 <~ … ~>
 . A string value occupies 1 byte per element.",NA
•,"Dictionary values are created by the 
 dict
  and 
 >>
  operators and by certain 
 other operators that return collections of parameters as dictionaries. VM 
 consump-tion is based on the dictionary’s capacity (its 
 maxlength
 ), 
 regardless of how full it currently is. A dictionary value occupies about 20 
 bytes per entry.",NA
•,"Name objects consume VM at the time the scanner first encounters each 
 dis-tinct name. Computed names (generated by the 
 cvn
  operator, for 
 instance) consume VM on their first use as names. Repeated occurrences 
 of a particular name require no additional storage. Each distinct name 
 occupies about 40 bytes plus the number of characters in the name.",NA
•,"The 
 save
 -
 restore
  machinery consumes VM in proportion to the magnitude 
 of the changes that must be undone by 
 restore
 , but independently of the 
 total size of VM. 
 restore
  reclaims all local VM resources consumed since 
 the correspond-ing 
 save
 .",NA
•,"Loading a Type 1 font program typically consumes 20,000 to 30,000 
 bytes of VM, depending on the size of the character set and the 
 complexity of the glyphs. VM consumption of a font remains essentially 
 constant, regardless of the number of ways in which its glyphs are scaled, 
 rotated, or otherwise trans-formed.",NA
Interpreter Parameters,"IN GENERAL, THE FACILITIES described in this appendix are available only 
 in LanguageLevels 2 and 3. A few special-purpose operators are explicitly 
 identified as LanguageLevel 1 operators, and some features are unique to 
 LanguageLevel 3. 
  
 There are various parameters to control the operation and behavior of the 
 Post-Script interpreter. Most of these have to do with allocation of memory 
 and other resources for specific purposes; for example, there are 
 parameters to control the maximum amount of memory to be used for 
 virtual memory, the font cache, and halftone screens. Some parameters 
 control the behavior of specific input/output and other devices. 
  
 A PostScript product is initially configured with interpreter parameter 
 values that are appropriate for most applications. However, with suitable 
 authorization, a PostScript program can alter the interpreter parameters to 
 favor certain applica-tions or to adapt the product to special requirements. 
  
  The interpreter parameters are divided into three categories:",NA
•,"User parameters
  can be altered at will (within reasonable limits) by any 
 Post-Script program without special authorization. The 
 setuserparams
  and 
 currentuserparams
  operators manipulate user parameters. Alterations to 
 user parameters are subject to 
 save
  and 
 restore
 .",NA
•,"System parameters
 , in general, can be altered only by a program that 
 presents a valid password. The 
 setsystemparams
  and 
 currentsystemparams
  
 operators manipulate system parameters. Alterations to system 
 parameters have a perma-nent, systemwide effect, which may persist 
 through restarts of the PostScript interpreter.",NA
•,"Device parameters
  are similar to system parameters but apply to 
 individual input/output or other devices. The 
 setdevparams
  and 
 currentdevparams
  oper-ators manipulate device parameters. Alterations 
 to device parameters are per-manent and systemwide, and may persist 
 through interpreter restarts. 
  
 The operators that manipulate interpreter parameters are described in 
 Chapter 8; this appendix describes the individual parameters. Although 
 these operators are a standard LanguageLevel 2 feature, the exact set of 
 interpreter parameters recog-nized may vary from product to product. Not 
 all products support all parame-ters, and some products may support 
 additional parameters beyond those discussed here; in addition, the set of 
 parameters supported by a given product may be subject to change over 
 time. The parameters described here are typical of those supported by 
 current PostScript products from Adobe. 
  
 Most of the user parameters establish temporary policies on matters such 
 as whether to insert new items into caches. It is reasonable for a user (or a 
 spooler program acting on the user’s behalf) to alter user parameters when 
 submitting jobs with unusual requirements. The system parameters, on the 
 other hand, per-manently alter the overall configuration of the product. A 
 user application should never attempt to alter system or device 
 parameters; only system management software should do so.",NA
C.1 Properties of User and System Parameters,"A program alters user or system parameters by invoking the 
 setuserparams
  
 or 
 setsystemparams
  operator, passing it a dictionary containing the names 
 and new values of the parameters to be changed. Each user or system 
 parameter is identi-fied by a key, which is always a name object. The 
 dictionary may also contain ad-ditional information; in particular, there can 
 be an entry named 
 Password
 , as discussed in Section C.1.2, “System 
 Parameters.” 
  
 The dictionary passed to 
 setuserparams
  or 
 setsystemparams 
 is similar to the 
 re-quest dictionary used with the 
 setpagedevice
  operator (see Section 6.1.1, 
 “Page Device Dictionary”). It contains entries for one or more parameters 
 whose values are to be changed; parameters not included in the dictionary 
 are left undisturbed. The effects of such changes are cumulative over 
 multiple invocations of 
 setuserparams
  or 
 setsystemparams
 ; that is, the effect 
 of setting a particular pa-rameter persists through subsequent invocations 
 of the operators until explicitly overridden or until the parameters are 
 restored to some previous state by a",NA
•,"If 
 FactoryDefaults
  is the only entry in the dictionary (or if a password is the 
  
 only other entry)",NA
•,If the system parameter password has been set to the empty string,NA
•,"During a system administrator job (as described in Section C.3.1, “Passwords”) 
  
 Some system parameters can be set permanently—that is, in nonvolatile 
 storage that survives restarts of the PostScript interpreter. This capability 
 is implementa-tion-dependent. No error occurs if parameters cannot be 
 stored permanently. In some implementations, permanent parameter 
 changes do not take effect until the next restart of the PostScript 
 interpreter. 
  
 System parameters are global to the PostScript environment and are not 
 main-tained separately for each context in an interpreter that support 
 multiple con-texts. The initial value of system parameters when the device 
 is turned on for the first time depends on the product implementation. 
  
 In general, the cache size parameters (for example, 
 MaxFontCache
 ) are 
 simply limits; they do not represent memory dedicated to a specific use. 
 Caches compete with each other for available memory. The main purpose 
 of the limits is to pre-vent excessive memory from being devoted to one 
 use, to the exclusion of other uses. Under some circumstances, memory in 
 use by a cache may be unavailable for satisfying the needs of a PostScript 
 program—for instance, to allocate new objects in virtual memory or to 
 enlarge a stack.",NA
C.2 Defined User and System Parameters,"The following tables summarize the commonly defined user and system 
 parame-ters; for more details, see Section C.3, “Details of User and System 
 Parameters.”Additional parameters are described in the 
 PostScript 
 Language ReferenceSupple-ment 
 and in product-specific documentation
 . 
  
 TABLE C.1 User parameters
  
 KEY
  
 TYPE
  
 VALUE
  
 AccurateScreens
  
 boolean
  
 A flag specifying whether to invoke an extremely precise (but 
 compu-
  
 tationally expensive) halftone algorithm during subsequent 
 execu-tions of 
 setscreen
  and 
 setcolorscreen
 . 
  
 HalftoneMode
  
 integer
  
 (LanguageLevel 3) 
 A code controlling the behavior of subsequent
  
 halftone-setting operators: 
  
 0 
  
 Operators will behave as usual. 
  
 1 
  
 Operators may substitute a product-specific halftone. 
  
 2 
  
 Same as 1; in addition, if a product-specific halftone is 
 substi-
  
 tuted, further optimization may occur. 
  
 IdiomRecognition
  
 boolean
  
 (LanguageLevel 3) 
 A flag specifying whether to enable procedure 
 sub-
  
 stitution during execution of the 
 bind
  operator (see Section 
 3.12.1,“bind Operator”).",NA
C.3 Details of User and System Parameters,The following sections give further details about user and system parameters.,NA
•,"A 
 HalftoneMode
  of 1 may cause the operator to ignore its halftone operand 
 and substitute a product-specific halftone. Whether this substitution 
 actually",NA
•,"A 
 HalftoneMode
  of 2 has the same effect as a 
 HalftoneMode
  of 1; in addition, 
 if a product-specific halftone is substituted, further optimization may 
 occur dur-ing image rendering. This optimization, which results in 
 additional speed im-provement at the expense of some degradation in 
 image quality, is disabled for masked images, image masks, and images 
 rotated at angles other than multi-ples of 90 degrees. 
  
 Halftone substitution is strictly internal to the interpreter; its effects are not 
 visi-ble at the PostScript language level. If halftone substitution occurs 
 during a 
 sethalftone
  operation, for example, a subsequent 
 currenthalftone
  
 operation will return the halftone dictionary that was originally supplied as 
 an operand to 
 sethalftone
 , not the substituted halftone. 
  
 Note that 
 HalftoneMode
  has no effect on the current halftone. 
  
 C.3.5 Virtual Memory and Stacks
  
 The 
 MaxLocalVM
  user parameter imposes a limit on the total amount of 
 local vir-tual memory in use. Attempting to create a new composite object 
 in local VM will fail (with a 
 VMerror
 ) if the VM would exceed its limit. There 
 is no corresponding limit for global VM. The method for sharing global VM 
 among multiple execu-tion contexts does not provide a way to attribute VM 
 consumption to a particular context. 
  
 Three other user parameters, 
 MaxOpStack
 , 
 MaxDictStack
 , and 
 MaxExecStack
 , 
 impose limits on the number of elements that can be pushed onto the 
 operand, dictionary, and execution stacks. Attempting to exceed one of 
 these limits will re-sult in a 
 stackoverflow
 , 
 dictstackoverflow
 , or 
 execstackoverflow 
 error, respec-tively. 
  
 Normally, there are no effective limits on VM or stack allocation; that is, the 
 de-fault values of these user parameters are extremely large. VM and stacks 
 can grow without limit, subject only to the total amount of memory 
 available in the ma-chine on which the PostScript interpreter is running. As 
 VM and stack consump-tion increases, less memory is available for the font 
 cache and other uses; this can degrade performance. The main use of the 
 VM and stack limit parameters is to test the behavior of applications in 
 limited memory.",NA
C.4 Device Parameters,"Each PostScript interpreter supports a collection of input/output and other 
 de-vices, such as communication channels, disks, and cartridges. The 
 standard file operators, described in Section 3.8, “File Input and Output,” 
 access these devices as files. Some devices have device-dependent 
 parameters. In addition, there are some named sets of parameters that do 
 not correspond to physical devices. Given a string identifying a device or 
 other named parameter set, the 
 setdevparams
  and 
 currentdevparams
  
 operators access these parameters. 
  
 A device is identified by a string of the form 
 %
 device
 , or 
 %
 device
 %
 , which is a 
 pre-fix of the 
 %
 device
 %
 file
  syntax for named files in storage devices (see 
 Section 3.8.2,“Named Files”). The available devices can be enumerated by 
 invoking the 
 resourceforall
  operator for the 
 IODevice
  category (see Section 
 3.9, “Named Re-sources”). 
  
 setdevparams
  is very similar to 
 setsystemparams
 ; the same restrictions 
 apply. The names of parameter sets and the names and semantics of the 
 parameters are product-dependent. They are not documented in this book, 
 but rather in the 
 PostScript Language Reference Supplement
  and in product-
 specific documenta-tion.",NA
Compatibility Strategies,"AS DISCUSSED IN SECTION 1.2, “Evolution of the PostScript Language,” the 
 PostScript language has undergone several significant extensions in order 
 to adapt to new technology and to incorporate new functionality and 
 flexibility. While the PostScript language is designed to be a universal 
 standard for device-independent page description, the reality is that there 
 are different PostScript lan-guage implementations that have different sets 
 of features. This appendix pre-sents guidelines for taking advantage of 
 language extensions while maintaining compatibility with all PostScript 
 interpreters.",NA
D.1 The LanguageLevel Approach,"PostScript implementations are organized into 
 LanguageLevels
 , of which 
 three have been defined:",NA
•,"LanguageLevel 1 interpreters implement all LanguageLevel 1 features, 
 These features are documented in the first edition of this book
 .
  In the 
 present (third) edition, LanguageLevel 1 consists of all features except 
 those explicitly desig-nated as LanguageLevel 2 or LanguageLevel 3.",NA
•,"LanguageLevel 2 interpreters implement all LanguageLevel 1 and 
 Language-Level 2 features. These features are documented in the second 
 edition of this book
 .
  In the present edition, LanguageLevel 2 consists of all 
 features except those explicitly designated as LanguageLevel 3.",NA
•,"LanguageLevel 
 3 
 interpreters 
 implement 
 all 
 features 
 of 
 all 
 LanguageLevels. Those features that are available only in LanguageLevel 
 3 are summarized in Section 1.2, “Evolution of the PostScript Language.”",NA
D.2 When to Provide Compatibility,"An application (or driver) must know what PostScript operators are 
 available to it. Essentially, there are two different scenarios:",NA
•,"The application is sending output to a specific PostScript interpreter, in 
 which 
  
 case it knows what the target interpreter is.",NA
•,"The application is printing through a spooler or saving to a file, in which 
 case it 
  
 does not know what the target interpreter is. 
  
 In the first case, the application can generate a PostScript program 
 appropriate for the target interpreter. The application simply needs to 
 determine the LanguageLevel that the interpreter supports 
 before
  
 generating the PostScript page description. There are two ways to do this:",NA
•,Consult a PPD file.,NA
•,"Query the interpreter directly. 
  
 A 
 PostScript printer description
  (PPD) file is a text file that can be read by an 
 appli-cation to obtain information about a specific printer product. In the 
 PPD file, the 
 *LanguageLevel
  entry specifies the PostScript LanguageLevel 
 that the product supports. (If the entry is absent, the product supports 
 LanguageLevel 1.) For in-formation on PPD files, refer to Adobe Technical 
 Note #5003, 
 PostScript Printer Description File Format Specification
 . 
  
 If there is a bidirectional communication channel between the application 
 and the PostScript interpreter, the application can determine the 
 interpreter’s capabil-ities by sending it a query job. The following program 
 queries the LanguageLevel of the interpreter: 
  
 %!PS-Adobe-3.0 Query 
  
 %%?BeginFeatureQuery: 
 *LanguageLevel 
  
  
 /languagelevel where 
  
  
  
  
 {pop languagelevel} 
  
  
  
  
 {1} 
  
  
  
 ifelse
  
  
  ("") print 3 string cvs print ("") = flush 
  
 %%?EndFeatureQuery: Unknown",NA
•,"Generate a page description using LanguageLevel 1 features only. The 
 resulting 
  
 program can be sent to any interpreter. 
  
 This is the simplest method for producing fully portable output, and is 
 entirely adequate for many applications. However, it sacrifices any 
 improvements 
 in 
 functionality, 
 performance, 
 or 
 programming 
 convenience available through the use of LanguageLevel 2 or 
 LanguageLevel 3 features.",NA
•,"Generate a page description that uses LanguageLevel 2 or LanguageLevel 
 3 fea-tures unconditionally. The resulting program will execute correctly 
 only when sent to an interpreter that supports the highest LanguageLevel 
 of the features that the program uses.",NA
•,"Generate a page description that uses higher-LanguageLevel features but 
 pro-vides for compatibility with lower-LanguageLevel interpreters. The 
 resulting program can be sent to any interpreter that supports at least 
 the lower LanguageLevel. 
  
 This is the most desirable option, because the resulting page description 
 is por-table yet takes advantage of higher-LanguageLevel features when 
 they are avail-able. The idea behind this strategy is for the application to 
 provide PostScript emulations, using lower-LanguageLevel features, of 
 the higher-LanguageLevel features that the page description actually 
 uses. When the program is executed, it determines which features the 
 interpreter supports and installs the emula-tions only if necessary (see 
 Section D.4, “Installing Emulations”). This strategy may not be the 
 simplest or most efficient, but it takes best advantage of the fea-tures 
 available in different interpreters.",NA
D.3 Compatibility Techniques,"It is not possible to emulate every feature of higher LanguageLevels in 
 terms of lower-LanguageLevel features, but many features can be at least 
 partially emu-lated. For example, LanguageLevel 2 user path operators 
 with ordinary user paths as operands can be emulated easily in 
 LanguageLevel 1, but those with encoded user paths as operands can be 
 emulated only with great difficulty and probably with unacceptable cost in 
 performance. The application must determine an ap-propriate tradeoff 
 between the benefit of using a feature and the cost of providing emulation 
 for that feature. 
  
 The following sections outline three compatibility techniques: complete 
 emula-tion, partial emulation, and emulation in the application’s PostScript 
 driver.",NA
•,"When running on a LanguageLevel 2 or LanguageLevel 3 interpreter, all 
 that is necessary is to invoke the LanguageLevel 2 operator 
 setstrokeadjust
  to enable automatic adjustment before drawing any 
 strokes.",NA
•,"When running on a LanguageLevel 1 interpreter, a similar effect can be 
 achieved by using the 
 transform
 , 
 round
 , and 
 itransform
  operators to “snap” 
 all",NA
•,"The 
 <<
  … 
 >>
  notation for constructing dictionary objects",NA
•,"The 
 <~
  … 
 ~>
  notation for ASCII base-85 string literals",NA
•,"The 
 //
  notation for immediately evaluated names",NA
•,"Binary encodings 
  
 Since these constructs are part of the syntax, they are parsed by the 
 scanner, whether or not they are ever executed. If a program containing 
 these constructs is sent to a LanguageLevel 1 interpreter, a 
 syntaxerror
  will 
 occur, even if the con-structs appear only inside procedures that are to be 
 executed conditionally ac-cording to LanguageLevel. 
  
 Consequently, a program that is intended to be compatible with 
 LanguageLevel 1 interpreters must avoid using any of the constructs listed 
 above. There are straightforward alternative methods for constructing 
 dictionaries and strings, but none for indicating an immediately evaluated 
 name. 
  
 LanguageLevel 3 introduces no additional syntax to the language.",NA
D.4 Installing Emulations,"When defining a PostScript emulation of an operator, it is important 
 not
  to 
 give the emulation the same name as the actual operator unless it is a 
 complete emula-tion. This is because another page description included in 
 the same job (an en-capsulated file, for instance) may require a particular 
 form of the operator that is",NA
•,"Use the 
 languagelevel
  operator to determine whether to install emulations 
 of 
  
 all required features for a given LanguageLevel as a group.",NA
•,"Use the 
 where
  operator to determine whether to install emulations of 
 individu-al operators. This is appropriate for those operators that are 
 available as exten-sions to a lower LanguageLevel in some products (see 
 Appendix A). 
  
 Example D.2 uses the first method to provide conditional emulation of the 
 LanguageLevel 2 
 selectfont
  and 
 rectfill
  operators. This example makes use of 
 the 
 *RF
  procedure defined in Example D.1. 
  
 Example D.2
  
 /*SF
  
 exch findfont exch
  
 % Complete selectfont emulation
  
 {
  
  
 dup type /arraytype eq 
  
  
  
  
 {makefont} 
  
  
  
  
 {scalefont} 
  
  
  
 ifelse 
  
  
 setfont 
  
 } bind def
  
 /languagelevel where 
  
 % Determine LanguageLevel of implementation 
  
  
 {pop languagelevel} 
  
  
  
 {1} 
  
  
 ifelse 
  
 2 lt
  
 {
  
 /SF /*SF load def
  
 % Interpreter is LanguageLevel 1,
  
 /RF /*RF load def
  
 % so use emulations defined above
  
 }
  
 {
  
 /SF /selectfont load def
  
 % Interpreter is LanguageLevel 2 or 3,
  
  
 }
  
 /RF /rectfill load def 
  
 % so use LanguageLevel 2 operators
  
 ifelse",NA
•,"An actual operator will always be used, if available, in preference to an 
 emula-
  
 tion.",NA
•,"An emulation is never given the same name as an operator. Thus, 
 embedded programs will not be fooled into believing that an operator is 
 defined when it is not.",NA
•,"The script of the page description can invoke operations using short 
 names, such as 
 SF
  and 
 RF
 , without regard to whether those operations are 
 performed by operators or by emulations. 
  
 In general, PostScript programs should not use the 
 version
  operator to test 
 for the availability of specific features. When a feature is introduced as an 
 extension (rather than as part of a LanguageLevel), it may not be present in 
 all products. To determine whether a feature is supported, it is usually best 
 to use the 
 where
  oper-ator to check for the presence of an operator 
 associated with the feature. For some features, it is better to use 
 resourcestatus
  to query an implicit resource cat-egory, such as 
 FontType
  or 
 HalftoneType
 . 
  
 Although using the 
 where
  operator to test for PostScript operators is 
 appropriate, using it to test for application-defined procedures is not. Doing 
 so can lead to trouble in the future if an operator of the same name happens 
 to come into exist-ence. The correct way to test for application-defined 
 procedures is to look them up in the application’s own dictionary with the 
 known
  operator instead of the 
 where
  operator.",NA
Character Sets and ,NA,NA
Encoding Vectors,"THIS APPENDIX DESCRIBES the character sets and encoding vectors of font 
 programs that are found in a typical PostScript interpreter or that are 
 available for downloading. While there is not a standard set of fonts that is 
 required by the PostScript language, most PostScript products include 
 software for 13 standard fonts from the Times
 *
 , Helvetica
 *
 , Courier, and 
 Symbol families. Samples of these fonts appear in the first few sections 
 below. 
  
 Following the font samples are tables documenting the entire character set 
 for Adobe’s standard Latin text fonts, expert fonts, and the Symbol font. For 
 each character set, every character is shown along with its full name and 
 octal charac-ter code (unencoded characters are indicated by —). This is 
 followed by detailed tables of the encoding vectors normally associated 
 with a font program using that character set. Table E.1 lists these encoding 
 vectors. 
  
 TABLE E.1 Encoding vectors
  
 ENCODING VECTOR
  
 DESCRIPTION
  
 StandardEncoding
  
 Built-in standard encoding vector. The default encoding used in
  
 most regular Latin text fonts. 
  
 ISOLatin1Encoding 
  
 Built-in encoding vector that closely matches the ISO 8859-1 
  
 (Latin 1) standard. Encodes the characters used in most 
 Western 
  
 European languages. 
  
 CE 
  
 Central European encoding vector, matching Microsoft Windows 
  
 code page 1250. Encodes the characters used in some Central 
  
 European languages.",NA
E.1 Times Family,"In 1931, 
 The Times
  of London commissioned Monotype corporation, under 
 the direction of Stanley Morison, to design a newspaper typeface. Times 
 New Roman
 ®
  was the result. The Linotype version shown here is called 
 Times Roman. It continues to be popular for both newspaper and business 
 applications, such as reports and correspondence. 
  
 Times-Roman
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 
 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š þ 
 ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ 
 … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Times-Italic 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 8 9
  
 Æ 
 Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š þ ß
  
 ú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ … ' 
 ""
  
 ‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Times-Bold
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 8 
 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š þ 
 ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ 
 … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Times-BoldItalic 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 8 9
  
 Æ 
 Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à 
 å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š þ ß
  
 ú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § 
 ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ … ' ""
  
 ‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³",NA
E.2 Helvetica Family,"One of the most popular typefaces of all time, Helvetica was designed by 
 Max Miedinger in 1957 for the Hass foundry in Switzerland. The name is 
 derived from 
 Helvetia,
  the Swiss name for Switzerland. Helvetica’s range of 
 styles allows a vari-ety of uses, including headlines, packaging, posters, and 
 short text blocks such as captions. 
  
 Helvetica
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 
 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø 
 š þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” 
 ‚ „ … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Helvetica-Oblique
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 
 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š 
 þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ 
 … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Helvetica-Bold
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 
 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø 
 š þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” 
 ‚ „ … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Helvetica-BoldOblique
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 2 3 4 5 6 7 
 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł ñ œ ó ô ö ò õ ø š 
 þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ 
 „ … ' ""‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³",NA
E.3 Courier Family,"Courier was originally designed as a typewriter face for IBM in 1952 by 
 Howard Kettler. It is a monospaced, or fixed-pitch, font suitable for use in 
 tabular materi-al, program listings, or word processing. 
  
 Courier 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 
 1 2 3 4 5 6 7 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ 
 Ú
  
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ 
 ł ñ œ ó ô ö ò õ ø š þ ß
  
 ú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! 
 ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ … ' ""
  
 ‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ 
 ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Courier-Oblique 
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z & 0 1 
 2 3 4 5 6 7 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł 
 ñ œ ó ô ö ò õ ø š þ ß
  
 ú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª º † ‡ § ¶ * ! ¡ ? ¿ . 
 , ; : ‘ ’ “ ” ‚ „ … ' ""
  
 ‹ › « » ( ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ 
 ¯ ˘ ˙ ˇ ˝ •
  
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Courier-Bold
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y 
 Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y 
 z & 0 1 2 3 4 5 6 7 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ 
 Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ 
 ł ñ œ ó ô ö ò õ ø š þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ 
 ª º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ … ' ""‹ › « » ( 
 ) [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³
  
 Courier-BoldOblique
  
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  
 a b c d e f g h i j k l m n o p q r s t u v w x y z 
 & 0 1 2 3 4 5 6 7 8 9
  
 Æ Á Â Ä À Å Ã Ç Ð É Ê Ë È Í Î Ï Ì Ł Ñ Œ Ó Ô Ö Ò Õ Ø Š Þ Ú
  
 Û Ü Ù Ÿ Ý Ž æ á â ä à å ã ç é ê ë è ð fi fl í î ï ì ı µ ł 
 ñ œ ó ô ö ò õ ø š þ ßú û ü ù ÿ ý ž £ ¥ ƒ $ ¢ ¤ ™ © ® @ ª 
 º † ‡ § ¶ * ! ¡ ? ¿ . , ; : ‘ ’ “ ” ‚ „ … ' ""‹ › « » ( ) 
 [ ] { } | / \ - – — _ ˛ ¸ ´ ˆ ¨ ` ˚ ˜ ¯ ˘ ˙ ˇ ˝ •
  
 # % ‰ ¼ ¾ ½ = − + × ~ < ± > ÷ ¬ ° ^ ⁄ · ¦ ¹ ² ³",NA
E.4 Symbol,"©
  ©
 =          (    +      
  
 +           (   )
  
 
  
  
  
  
  
  
  
 
  
  
  
  
  
  
  
          )                 
  
           ©           
  
  )                     
  
                             
  
 Sample Uses
  
  = 
 min 
 x > 0
  (x | (1 + x) 
  )
  
  
 m 
  
 w (
    ) =    
 C
 i
   )       
 C
 i
   )      
 if  
     
 L and 
   
 i  = 1
  
 n 
  
 i = 1
   Z
 i
   (t) 
  
 M 
  
 Z
 i
   (t) 
 ) 
 Z
 j
   (t) = 
   
   (i 
 
  j)
  
 proposition
  
 true if and only if
  
 ( 
 u) s (p)
  
 S 
 ) 
 T
 
 p
   =  
  
 ( 
 u) s (p)
  
 S 
 ) 
 T
 p
     
  
 ( 
 u) s (~ p)
  
 S 
 ) 
 T
 p
   =  
  
 ( 
 u) s (~ p)
  
 S 
 ) 
 T
 
 p
     
  
 (( 
 u) s (p))
  
 S 
 ) 
 T
 
 p
     
  
 (( 
 u) s 
 (p))
  
 S 
 ) 
 T
 p
   =  
  
 k ⁄ 2 
  
 s + 
  
 s
 2
     
  
  –k
  
 kp t
 – 1
    I
 k
   (at) 
    
  
 ",NA
E.5 Standard Latin Character Set,"CHAR
  
 CHAR CODE (OCTAL)
  
 CHAR
  
 CHAR CODE (OCTAL)
  
 NAME
  
 STD
  
 ISO
  
 CE
  
 NAME
  
 STD
  
 ISO
  
 CE
  
 A
  
 A
  
 101
  
 101
  
 101
  
 I
  
 I
  
 111
  
 111
  
 111
  
 Æ
  
 AE
  
 341
  
 306
  
  —
  
 Í
  
 Iacute
  
  —
  
 315
  
 315
  
 Á
  
 Aacute
  
  —
  
 301
  
 301
  
 Î
  
 Icircumflex
  
  —
  
 316
  
 316
  
 Ă
  
 Abreve
 1
  
  —
  
  —
  
 303
  
 Ï
  
 Idieresis
  
  —
  
 317
  
  —
  
 Â
  
 Acircumflex
  
  —
  
 302
  
 302
  
 İ
  
 Idotaccent
 1
  
  —
  
  —
  
  —
  
 Ä
  
 Adieresis
  
  —
  
 304
  
 304
  
 Ì
  
 Igrave
  
  —
  
 314
  
  —
  
 À
  
 Agrave
  
  —
  
 300
  
  —
  
 Ī
  
 Imacron
 1
  
  —
  
  —
  
  —
  
 Ā
  
 Amacron
 1
  
  —
  
  —
  
  —
  
 Į
  
 Iogonek
 1
  
  —
  
  —
  
  —
  
 Ą
  
 Aogonek
 1
  
  —
  
  —
  
 245
  
 J
  
 J
  
 112
  
 112
  
 112
  
 Å
  
 Aring
  
  —
  
 305
  
  —
  
 K
  
 K
  
 113
  
 113
  
 113
  
 Ã
  
 Atilde
  
  —
  
 303
  
  —
  
 Ķ
  
 Kcommaaccent
 1
  —
  
  —
  
  —
  
 B
  
 B
  
 102
  
 102
  
 102
  
 L
  
 L
  
 114
  
 114
  
 114
  
 C
  
 C
  
 103
  
 103
  
 103
  
 Ĺ
  
 Lacute
 1
  
  —
  
  —
  
 305
  
 Ć
  
 Cacute
 1
  
  —
  
  —
  
 306
  
 Ľ
  
 Lcaron
 1
  
  —
  
  —
  
 274
  
 Č
  
 Ccaron
 1
  
  —
  
  —
  
 310
  
 Ļ
  
 Lcommaaccent
 1
  
  —
  
  —
  
  —
  
 Ç
  
 Ccedilla
  
  —
  
 307
  
 307
  
 Ł
  
 Lslash
  
 350
  
  —
  
 243
  
 D
  
 D
  
 104
  
 104
  
 104
  
 M
  
 M
  
 115
  
 115
  
 115
  
 Ď
  
 Dcaron
 1
  
  —
  
  —
  
 317
  
 N
  
 N
  
 116
  
 116
  
 116
  
 Đ
  
 Dcroat
 1
  
  —
  
  —
  
 320
  
 Ń
  
 Nacute
 1
  
  —
  
  —
  
 321
  
 ∆
  
 Delta
 1
  
  —
  
  —
  
  —
  
 Ň
  
 Ncaron
 1
  
  —
  
  —
  
 322
  
 E
  
 E
  
 105
  
 105
  
 105
  
 Ņ
  
 Ncommaaccent
 1
  —
  
  —
  
  —
  
 É
  
 Eacute
  
  —
  
 311
  
 311
  
 Ñ
  
 Ntilde
  
  —
  
 321
  
  —
  
 Ě
  
 Ecaron
 1
  
  —
  
  —
  
 314
  
 O
  
 O
  
 117
  
 117
  
 117
  
 Ê
  
 Ecircumfle
 x
  
  —
  
 312
  
  —
  
 Œ
  
 OE
  
 352
  
  —
  
  —
  
 Ë
  
 Edieresis
  
  —
  
 313
  
 313
  
 Ó
  
 Oacute
  
  —
  
 323
  
 323
  
 Ė
  
 Edotaccent
 1
  
  —
  
  —
  
  —
  
 Ô
  
 Ocircumflex
  
  —
  
 324
  
 324
  
 È
  
 Egrave
  
  —
  
 310
  
  —
  
 Ö
  
 Odieresis
  
  —
  
 326
  
 326
  
 Ē
  
 Emacron
 1
  
  —
  
  —
  
  —
  
 Ò
  
 Ograve
  
  —
  
 322
  
  —
  
 Ę
  
 Eogonek
 1
  
  —
  
  —
  
 312
  
 Ő
  
 Ohungarumlaut
 1
  —
  
  —
  
 325
  
 Ð
  
 Eth
  
  —
  
 320
  
  —
  
 Ō
  
 Omacron
 1
  
  —
  
  —
  
  —
  
 F
  
 F
  
 106
  
 106
  
 106
  
 Ø
  
 Oslash
  
 351
  
 330
  
  —
  
 G
  
 G
  
 107
  
 107
  
 107
  
 Õ
  
 Otilde
  
  —
  
 325
  
  —
  
 Ğ
  
 Gbreve
 1
  
  —
  
  —
  
  —
  
 P
  
 P
  
 120
  
 120
  
 120
  
 Ģ
  
 Gcommaaccent
 1
  —
  
  —
  
  —
  
 Q
  
 Q
  
 121
  
 121
  
 121
  
 H
  
 H
  
 110
  
 110
  
 110
  
 R
  
 R
  
 122
  
 122
  
 122",NA
E.6 StandardEncoding Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
 !
  
 ""
  
 #
  
 $
  
 %
  
 &
  
 ’
  
 \05x
  
 (
  
 )
  
 *
  
 +
  
 ,
  
 -
  
 .
  
 /
  
 \06x
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \07x
  
 8
  
 9
  
 :
  
 ;
  
 <
  
 =
  
 >
  
 ?
  
 \10x
  
 @
  
 A
  
 B
  
 C
  
 D
  
 E
  
 F
  
 G
  
 \11x
  
 H
  
 I
  
 J
  
 K
  
 L
  
 M
  
 N
  
 O
  
 \12x
  
 P
  
 Q
  
 R
  
 S
  
 T
  
 U
  
 V
  
 W
  
 \13x
  
 X
  
 Y
  
 Z
  
 [
  
 \
  
 ]
  
 ^
  
 _
  
 \14x
  
 ‘
  
 a
  
 b
  
 c
  
 d
  
 e
  
 f
  
 g
  
 \15x
  
 h
  
 i
  
 j
  
 k
  
 l
  
 m
  
 n
  
 o
  
 \16x
  
 p
  
 q
  
 r
  
 s
  
 t
  
 u
  
 v
  
 w
  
 \17x
  
 x
  
 y
  
 z
  
 {
  
 |
  
 }
  
 ~
  
  
 \20x
   
  
  
  
  
  
  
  
 \21x
   
  
  
  
  
  
  
  
 \22x
   
  
  
  
  
  
  
  
 \23x
   
  
  
  
  
  
  
  
 \24x
   
 ¡
  
 ¢
  
 £
  
 ⁄
  
 ¥
  
 ƒ
  
 §
  
 \25x
  
 ¤
  
 '
  
 “
  
 «
  
 ‹
  
 ›
  
 fi
  
 fl
  
 \26x
   
 –
  
 †
  
 ‡
  
 ·
  
  
 ¶
  
 •
  
 \27x
  
 ‚
  
 „
  
 ”
  
 »
  
 …
  
 ‰
   
 ¿
  
 \30x
   
 `
  
 ´
  
 ˆ
  
 ˜
  
 ¯
  
 ˘
  
 ˙
  
 \31x
  
 ¨
  
  
 ˚
  
 ¸
  
  
 ˝
  
 ˛
  
 ˇ
  
 \32x
  
 —
  
  
  
  
  
  
  
  
 \33x
   
  
  
  
  
  
  
  
 \34x
   
 Æ
  
  
 ª
  
  
  
  
  
 \35x
  
 Ł
  
 Ø
  
 Œ
  
 º
  
  
  
  
  
 \36x
   
 æ
  
  
  
  
 ı
  
  
  
 \37x
  
 ł
  
 ø
  
 œ
  
 ß",NA
E.7 ISOLatin1Encoding Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
 !
  
 ""
  
 #
  
 $
  
 %
  
 &
  
 ’
  
 \05x
  
 (
  
 )
  
 *
  
 +
  
 ,
  
 −
  
 .
  
 /
  
 \06x
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \07x
  
 8
  
 9
  
 :
  
 ;
  
 <
  
 =
  
 >
  
 ?
  
 \10x
  
 @
  
 A
  
 B
  
 C
  
 D
  
 E
  
 F
  
 G
  
 \11x
  
 H
  
 I
  
 J
  
 K
  
 L
  
 M
  
 N
  
 O
  
 \12x
  
 P
  
 Q
  
 R
  
 S
  
 T
  
 U
  
 V
  
 W
  
 \13x
  
 X
  
 Y
  
 Z
  
 [
  
 \
  
 ]
  
 ^
  
 _
  
 \14x
  
 ‘
  
 a
  
 b
  
 c
  
 d
  
 e
  
 f
  
 g
  
 \15x
  
 h
  
 i
  
 j
  
 k
  
 l
  
 m
  
 n
  
 o
  
 \16x
  
 p
  
 q
  
 r
  
 s
  
 t
  
 u
  
 v
  
 w
  
 \17x
  
 x
  
 y
  
 z
  
 {
  
 |
  
 }
  
 ~
  
  
 \20x
   
  
  
  
  
  
  
  
 \21x
   
  
  
  
  
  
  
  
 \22x
  
 ı
  
 `
  
 ´
  
 ˆ
  
 ˜
  
 ¯
  
 ˘
  
 ˙
  
 \23x
  
 ¨
  
  
 ˚
  
 ¸
  
  
 ˝
  
 ˛
  
 ˇ
  
 \24x
   
 ¡
  
 ¢
  
 £
  
 ¤
  
 ¥
  
 ¦
  
 §
  
 \25x
  
 ¨
  
 ©
  
 ª
  
 «
  
 ¬
  
 -
  
 ®
  
 ¯
  
 \26x
  
 °
  
 ±
  
 ²
  
 ³
  
 ´
  
 µ
  
 ¶
  
 ·
  
 \27x
  
 ¸
  
 ¹
  
 º
  
 »
  
 ¼
  
 ½
  
 ¾
  
 ¿
  
 \30x
  
 À
  
 Á
  
 Â
  
 Ã
  
 Ä
  
 Å
  
 Æ
  
 Ç
  
 \31x
  
 È
  
 É
  
 Ê
  
 Ë
  
 Ì
  
 Í
  
 Î
  
 Ï
  
 \32x
  
 Ð
  
 Ñ
  
 Ò
  
 Ó
  
 Ô
  
 Õ
  
 Ö
  
 ×
  
 \33x
  
 Ø
  
 Ù
  
 Ú
  
 Û
  
 Ü
  
 Ý
  
 Þ
  
 ß
  
 \34x
  
 à
  
 á
  
 â
  
 ã
  
 ä
  
 å
  
 æ
  
 ç
  
 \35x
  
 è
  
 é
  
 ê
  
 ë
  
 ì
  
 í
  
 î
  
 ï
  
 \36x
  
 ð
  
 ñ
  
 ò
  
 ó
  
 ô
  
 õ
  
 ö
  
 ÷
  
 \37x
  
 ø
  
 ù
  
 ú
  
 û
  
 ü
  
 ý
  
 þ
  
 ÿ",NA
E.8 CE Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
 !
  
 ""
  
 #
  
 $
  
 %
  
 &
  
 '
  
 \05x
  
 (
  
 )
  
 *
  
 +
  
 ,
  
 -
  
 .
  
 /
  
 \06x
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \07x
  
 8
  
 9
  
 :
  
 ;
  
 <
  
 =
  
 >
  
 ?
  
 \10x
  
 @
  
 A
  
 B
  
 C
  
 D
  
 E
  
 F
  
 G
  
 \11x
  
 H
  
 I
  
 J
  
 K
  
 L
  
 M
  
 N
  
 O
  
 \12x
  
 P
  
 Q
  
 R
  
 S
  
 T
  
 U
  
 V
  
 W
  
 \13x
  
 X
  
 Y
  
 Z
  
 [
  
 \
  
 ]
  
 ^
  
 _
  
 \14x
  
 `
  
 a
  
 b
  
 c
  
 d
  
 e
  
 f
  
 g
  
 \15x
  
 h
  
 i
  
 j
  
 k
  
 l
  
 m
  
 n
  
 o
  
 \16x
  
 p
  
 q
  
 r
  
 s
  
 t
  
 u
  
 v
  
 w
  
 \17x
  
 x
  
 y
  
 z
  
 {
  
 |
  
 }
  
 ~
  
  
 \20x
   
  
 ‚
  
  
 „
  
 …
  
 †
  
 ‡
  
 \21x
   
 ‰
  
 Š
  
 ‹
  
 Ś
  
 Ť
  
 Ž
  
 Ź
  
 \22x
   
 ‘
  
 ’
  
 “
  
 ”
  
 •
  
 –
  
 —
  
 \23x
   
 ™
  
 š
  
 ›
  
 ś
  
 ť
  
 ž
  
 ź
  
 \24x
   
 ˇ
  
 ˘
  
 Ł
  
 ¤
  
 Ą
  
 ¦
  
 §
  
 \25x
  
 ¨
  
 ©
  
 Ș
  
 «
  
 ¬
  
 -
  
 ®
  
 Ż
  
 \26x
  
 °
  
 ±
  
 ˛
  
 ł
  
 ´
  
 µ
  
 ¶
  
 ·
  
 \27x
  
 ¸
  
 ą
  
 ș
  
 »
  
 Ľ
  
 ˝
  
 ľ
  
 ż
  
 \30x
  
 Ŕ
  
 Á
  
 Â
  
 Ă
  
 Ä
  
 Ĺ
  
 Ć
  
 Ç
  
 \31x
  
 Č
  
 É
  
 Ę
  
 Ë
  
 Ě
  
 Í
  
 Î
  
 Ď
  
 \32x
  
 Đ
  
 Ń
  
 Ň
  
 Ó
  
 Ô
  
 Ő
  
 Ö
  
 ×
  
 \33x
  
 Ř
  
 Ů
  
 Ú
  
 Ű
  
 Ü
  
 Ý
  
 Ţ
  
 ß
  
 \34x
  
 ŕ
  
 á
  
 â
  
 ă
  
 ä
  
 ĺ
  
 ć
  
 ç
  
 \35x
  
 č
  
 é
  
 ę
  
 ë
  
 ě
  
 í
  
 î
  
 ď
  
 \36x
  
 đ
  
 ń
  
 ň
  
 ó
  
 ô
  
 ő
  
 ö
  
 ÷
  
 \37x
  
 ř
  
 ů
  
 ú
  
 ű
  
 ü
  
 ý
  
 ţ
  
 ˙",NA
E.9 Expert Character Set,"CHAR
  
 NAME
  
 CODE
  
 CHAR
  
 NAME
  
 CODE
  
  
 AEsmall
  
 346
  
  
 Jsmall
  
 152
  
  
 Aacutesmall
  
 341
  
  
 Ksmall
  
 153
  
  
 Acircumflexsmall
  
 342
  
  
 Lslashsmall
  
 243
  
  
 Acutesmall
  
 047
  
  
 Lsmall
  
 154
  
  
 Adieresissmall
  
 344
  
  
 Macronsmall
  
 257
  
  
 Agravesmall
  
 340
  
  
 Msmall
  
 155
  
  
 Aringsmall
  
 345
  
  
 Nsmall
  
 156
  
  
 Asmall
  
 141
  
  
 Ntildesmall
  
 361
  
  
 Atildesmall
  
 343
  
  
 OEsmall
  
 367
  
  
 Brevesmall
  
 251
  
  
 Oacutesmall
  
 363
  
  
 Bsmall
  
 142
  
  
 Ocircumflexsmall
  
 364
  
  
 Caronsmall
  
 252
  
  
 Odieresissmall
  
 366
  
  
 Ccedillasmall
  
 347
  
  
 Ogoneksmall
  
 266
  
  
 Cedillasmall
  
 270
  
  
 Ogravesmall
  
 362
  
  
 Circumflexsmall
  
 136
  
  
 Oslashsmall
  
 370
  
  
 Csmall
  
 143
  
  
 Osmall
  
 157
  
  
 Dieresissmall
  
 250
  
  
 Otildesmall
  
 365
  
  
 Dotaccentsmall
  
 254
  
  
 Psmall
  
 160
  
  
 Dsmall
  
 144
  
  
 Qsmall
  
 161
  
  
 Eacutesmall
  
 351
  
  
 Ringsmall
  
 267
  
  
 Ecircumflexsmall
  
 352
  
  
 Rsmall
  
 162
  
  
 Edieresissmall
  
 353
  
  
 Scaronsmall
  
 246
  
  
 Egravesmall
  
 350
  
  
 Ssmall
  
 163
  
  
 Esmall
  
 145
  
  
 Thornsmall
  
 376
  
  
 Ethsmall
  
 360
  
  
 Tildesmall
  
 176
  
  
 Fsmall
  
 146
  
  
 Tsmall
  
 164
  
  
 Gravesmall
  
 140
  
  
 Uacutesmall
  
 372
  
  
 Gsmall
  
 147
  
  
 Ucircumflexsmall
  
 373
  
  
 Hsmall
  
 150
  
  
 Udieresissmall
  
 374
  
  
 Hungarumlautsmall
  
 042
  
  
 Ugravesmall
  
 371
  
  
 Iacutesmall
  
 355
  
  
 Usmall
  
 165
  
  
 Icircumflexsmall
  
 356
  
  
 Vsmall
  
 166
  
  
 Idieresissmall
  
 357
  
  
 Wsmall
  
 167
  
  
 Igravesmall
  
 354
  
  
 Xsmall
  
 170
  
  
 Ismall
  
 151
  
  
 Yacutesmall
  
 375",NA
E.10 Expert Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
  
  
  
  
  
  
  
 \05x
  
 ⁽
  
 ⁾
  
 ‥
  
 ․
  
 ,
  
 -
  
 .
  
 ⁄
  
 \06x
  
  
  
  
  
  
  
  
  
 \07x
  
  
  
 :
  
 ;
  
  
  
  
  
 \10x
   
  
  
  
  
  
  
  
 \11x
   
  
  
  
  
  
 ⁿ
  
  
 \12x
   
  
  
  
  
  
 ff
  
 fi
  
 \13x
  
 fl
  
 ffi
  
 ffl
  
 ₍
  
  
 ₎
  
  
  
 \14x
  
  
  
  
  
  
  
  
  
 \15x
  
  
  
  
  
  
  
  
  
 \16x
  
  
  
  
  
  
  
  
  
 \17x
  
  
  
  
 ₡
  
  
  
  
  
 \20x
   
  
  
  
  
  
  
  
 \21x
   
  
  
  
  
  
  
  
 \22x
   
  
  
  
  
  
  
  
 \23x
   
  
  
  
  
  
  
  
 \24x
   
  
  
  
  
  
  
  
 \25x
  
  
  
  
  
  
  
  
  
 \26x
   
  
 ‒
  
  
  
  
  
  
 \27x
  
  
  
  
  
 ¼
  
 ½
  
 ¾
  
  
 \30x
  
 ⅛
  
 ⅜
  
 ⅝
  
 ⅞
  
 ⅓
  
 ⅔
  
  
  
 \31x
  
 ⁰
  
 ¹
  
 ²
  
 ³
  
 ⁴
  
 ⁵
  
 ⁶
  
 ⁷
  
 \32x
  
 ⁸
  
 ⁹
  
 ₀
  
 ₁
  
 ₂
  
 ₃
  
 ₄
  
 ₅
  
 \33x
  
 ₆
  
 ₇
  
 ₈
  
 ₉
  
  
  
  
  
 \34x
  
  
  
  
  
  
  
  
  
 \35x
  
  
  
  
  
  
  
  
  
 \36x
  
  
  
  
  
  
  
  
  
 \37x",NA
E.11 ExpertSubset Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
  
  
  
  
  
  
  
 \05x
  
 ⁽
  
 ⁾
  
 ‥
  
 ․
  
 ,
  
 -
  
 .
  
 ⁄
  
 \06x
  
  
  
  
  
  
  
  
  
 \07x
  
  
  
 :
  
 ;
  
  
  
  
  
 \10x
   
  
  
  
  
  
  
  
 \11x
   
  
  
  
  
  
 ⁿ
  
  
 \12x
   
  
  
  
  
  
 ff
  
 fi
  
 \13x
  
 fl
  
 ffi
  
 ffl
  
 ₍
  
  
 ₎
  
  
  
 \14x
   
  
  
  
  
  
  
  
 \15x
   
  
  
  
  
  
  
  
 \16x
   
  
  
  
  
  
  
  
 \17x
   
  
  
 ₡
  
  
  
  
  
 \20x
   
  
  
  
  
  
  
  
 \21x
   
  
  
  
  
  
  
  
 \22x
   
  
  
  
  
  
  
  
 \23x
   
  
  
  
  
  
  
  
 \24x
   
  
  
  
  
  
  
  
 \25x
   
  
  
  
  
  
  
  
 \26x
   
  
 ‒
  
  
  
  
  
  
 \27x
   
  
  
  
 ¼
  
 ½
  
 ¾
  
  
 \30x
  
 ⅛
  
 ⅜
  
 ⅝
  
 ⅞
  
 ⅓
  
 ⅔
  
  
  
 \31x
  
 ⁰
  
 ¹
  
 ²
  
 ³
  
 ⁴
  
 ⁵
  
 ⁶
  
 ⁷
  
 \32x
  
 ⁸
  
 ⁹
  
 ₀
  
 ₁
  
 ₂
  
 ₃
  
 ₄
  
 ₅
  
 \33x
  
 ₆
  
 ₇
  
 ₈
  
 ₉
  
  
  
  
  
 \34x
   
  
  
  
  
  
  
  
 \35x
   
  
  
  
  
  
  
  
 \36x
   
  
  
  
  
  
  
  
 \37x",NA
E.12 Symbol Character Set,"CHAR
  
 NAME
  
 CODE
  
 CHAR
  
 NAME
  
 CODE
  
 CHAR
  
 NAME
  
 CODE
  
 
  
 Alpha
  
 101
  
 
  
 arrowboth
  
 253
  
 
  
 circlemultiply
  
 304
  
 
  
 Beta
  
 102
  
 
  
 arrowdblboth
  
 333
  
 
  
 circleplus
  
 305
  
 
  
 Chi
  
 103
  
 ©
  
 arrowdbldown
  
 337
  
 
  
 club
  
 247
  
  
  
 Delta
  
 104
  
 
  
 arrowdblleft
  
 334
  
 
  
 colon
  
 072
  
 
  
 Epsilon
  
 105
  
 
  
 arrowdblright
  
 336
  
 
  
 comma
  
 054
  
 
  
 Eta
  
 110
  
 
  
 arrowdblup
  
 335
  
 
  
 congruent
  
 100
  
 €
  
 Euro
  
 240
  
 
  
 arrowdown
  
 257
  
 
  
 copyrightsans
  
 343
  
 
  
 Gamma
  
 107
  
 
  
 arrowhorizex
  
 276
  
 
  
 copyrightserif
  
 323
  
  
  
 Ifraktur
  
 301
  
 
  
 arrowleft
  
 254
  
 
  
 degree
  
 260
  
 
  
 Iota
  
 111
  
 
  
 arrowright
  
 256
  
 
  
 delta
  
 144
  
 
  
 Kappa
  
 113
  
 
  
 arrowup
  
 255
  
 
  
 diamond
  
 250
  
 
  
 Lambda
  
 114
  
 
  
 arrowvertex
  
 275
  
 
  
 divide
  
 270
  
 
  
 Mu
  
 115
  
  
  
 asteriskmath
  
 052
  
 
  
 dotmath
  
 327
  
 
  
 Nu
  
 116
  
 
  
 bar
  
 174
  
 
  
 eight
  
 070
  
 
  
 Omega
  
 127
  
 
  
 beta
  
 142
  
  
  
 element
  
 316
  
 
  
 Omicron
  
 117
  
 
  
 braceleft
  
 173
  
 
  
 ellipsis
  
 274
  
 
  
 Phi
  
 106
  
 
  
 braceright
  
 175
  
  
  
 emptyset
  
 306
  
 
  
 Pi
  
 120
  
 
  
 bracelefttp
  
 354
  
 
  
 epsilon
  
 145
  
 
  
 Psi
  
 131
  
 
  
 braceleftmid
  
 355
  
 =
  
 equal
  
 075
  
  
  
 Rfraktur
  
 302
  
 
  
 braceleftbt
  
 356
  
 
  
 equivalence
  
 272
  
 
  
 Rho
  
 122
  
 
  
 bracerighttp
  
 374
  
 
  
 eta
  
 150
  
 ©
  
 Sigma
  
 123
  
 
  
 bracerightmid
  
 375
  
 
  
 exclam
  
 041
  
 
  
 Tau
  
 124
  
 
  
 bracerightbt
  
 376
  
  
  
 existential
  
 044
  
 
  
 Theta
  
 121
  
 
  
 braceex
  
 357
  
 
  
 five
  
 065
  
 
  
 Upsilon
  
 125
  
 
  
 bracketleft
  
 133
  
 
  
 florin
  
 246
  
 
  
 Upsilon1
  
 241
  
 
  
 bracketright
  
 135
  
 
  
 four
  
 064
  
 
  
 Xi
  
 130
  
 
  
 bracketlefttp
  
 351
  
 
  
 fraction
  
 244
  
 
  
 Zeta
  
 132
  
 
  
 bracketleftex
  
 352
  
 ©
  
 gamma
  
 147
  
 
  
 aleph
  
 300
  
 
  
 bracketleftbt
  
 353
  
  
  
 gradient
  
 321
  
 
  
 alpha
  
 141
  
 
  
 bracketrighttp
  
 371
  
 
  
 greater
  
 076
  
 
  
 ampersand
  
 046
  
 
  
 bracketrightex
  
 372
  
 
  
 greaterequal
  
 263
  
  
  
 angle
  
 320
  
 
  
 bracketrightbt
  
 373
  
 
  
 heart
  
 251
  
 )
  
 angleleft
  
 341
  
 
  
 bullet
  
 267
  
  
  
 infinity
  
 245
  
 
  
 angleright
  
 361
  
 
  
 carriagereturn
  
 277
  
 +
  
 integral
  
 362
  
 
  
 approxequal
  
 273
  
 
  
 chi
  
 143
  
  
  
 integraltp
  
 363",NA
E.13 Symbol Encoding Vector,"octal
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 \00x
   
  
  
  
  
  
  
  
 \01x
   
  
  
  
  
  
  
  
 \02x
   
  
  
  
  
  
  
  
 \03x
   
  
  
  
  
  
  
  
 \04x
   
 
  
  
  
 
  
  
  
 
  
 
  
  
  
 \05x
  
 (
  
 )
  
  
  
 +
  
 
  
  
  
 
  
 
  
 \06x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \07x
  
 
  
 
  
 
  
 
  
 
  
 =
  
 
  
 
  
 \10x
  
 
  
 
  
 
  
 
  
  
  
 
  
 
  
 
  
 \11x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \12x
  
 
  
 
  
 
  
 ©
  
 
  
 
  
 
  
 
  
 \13x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \14x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 ©
  
 \15x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \16x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \17x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
  
 \20x
   
  
  
  
  
  
  
  
 \21x
   
  
  
  
  
  
  
  
 \22x
   
  
  
  
  
  
  
  
 \23x
   
  
  
  
  
  
  
  
 \24x
  
 €
  
 
  
 
  
 
  
 
  
  
  
 
  
 
  
 \25x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \26x
  
 
  
 
  
 
  
 
  
 
  
  
  
  
  
 
  
 \27x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \30x
  
 
  
  
  
  
  
  
  
 
  
 
  
  
  
 )
  
 \31x
  
 
  
 
  
 
  
 
  
 
  
 
  
  
  
 
  
 \32x
  
  
  
  
  
 
  
 
  
 
  
  
  
  
  
 
  
 \33x
  
 
  
 
  
 (
  
 
  
 
  
 
  
 
  
 ©
  
 \34x
  
 
  
 )
  
 
  
 
  
 
  
  
  
 
  
 
  
 \35x
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 \36x
   
 
  
 +
  
  
  
 
  
 
  
 
  
 
  
 \37x
  
 
  
 
  
 
  
 
  
 
  
 
  
 ",NA
System Name Encodings,"INDEX
  
 NAME
  
 INDEX
  
 NAME
  
 INDEX
  
 NAME
  
 0
  
 abs
  
 23
  
 concat
  
 46
  
 cvn
  
 1
  
 add
  
 24
  
 concatmatrix
  
 47
  
 cvr
  
 2
  
 aload
  
 25
  
 copy
  
 48
  
 cvrs
  
 3
  
 anchorsearch
  
 26
  
 count
  
 49
  
 cvs
  
 4
  
 and
  
 27
  
 counttomark
  
 50
  
 cvx
  
 5
  
 arc
  
 28
  
 currentcmykcolor
  
 51
  
 def
  
 6
  
 arcn
  
 29
  
 currentdash
  
 52
  
 defineusername
  
 7
  
 arct
  
 30
  
 currentdict
  
 53
  
 dict
  
 8
  
 arcto
  
 31
  
 currentfile
  
 54
  
 div
  
 9
  
 array
  
 32
  
 currentfont
  
 55
  
 dtransform
  
 10
  
 ashow
  
 33
  
 currentgray
  
 56
  
 dup
  
 11
  
 astore
  
 34
  
 currentgstate
  
 57
  
 end
  
 12
  
 awidthshow
  
 35
  
 currenthsbcolor
  
 58
  
 eoclip
  
 13
  
 begin
  
 36
  
 currentlinecap
  
 59
  
 eofill
  
 14
  
 bind
  
 37
  
 currentlinejoin
  
 60
  
 eoviewclip
  
 15
  
 bitshift
  
 38
  
 currentlinewidth
  
 61
  
 eq
  
 16
  
 ceiling
  
 39
  
 currentmatrix
  
 62
  
 exch
  
 17
  
 charpath
  
 40
  
 currentpoint
  
 63
  
 exec
  
 18
  
 clear
  
 41
  
 currentrgbcolor
  
 64
  
 exit
  
 19
  
 cleartomark
  
 42
  
 currentshared
  
 65
  
 file
  
 20
  
 clip
  
 43
  
 curveto
  
 66
  
 fill
  
 21
  
 clippath
  
 44
  
 cvi
  
 67
  
 findfont
  
 22
  
 closepath
  
 45
  
 cvlit
  
 68
  
 flattenpath",NA
Operator Usage ,NA,NA
Guidelines,"IF NOT USED PROPERLY, some PostScript operators can cause unintended 
 side 
 effects, 
 render 
 a 
 document 
 device-dependent, 
 or 
 inhibit 
 postprocessing of a doc-ument. The guidelines in this appendix will help 
 ensure the proper use of those operators. These guidelines apply to regular 
 page descriptions and encapsulated PostScript (EPS) files, as described 
 below. In addition, most of the EPS guidelines also apply to the definition of 
 a 
 PaintProc
  procedure in a form or pattern diction-ary, a 
 BuildGlyph
  
 procedure in a Type 3 base font or Type 1 CIDFont, and a 
 CharStrings
  
 procedure in any font format that allows glyph descriptions to be re-placed 
 by PostScript procedures. 
  
 As discussed in Section 2.4, “Using the PostScript Language,” the primary 
 use of the PostScript language is to represent a page description, which is a 
 device-independent representation of the appearance of pages that are to 
 be viewed or printed. A page description not only is a valid PostScript 
 program but also con-forms to certain structuring conventions and usage 
 guidelines. These guidelines help to ensure device independence and 
 facilitate postprocessing of a page de-scription by other applications. 
  
 There are two main classes of page description:",NA
•,"A 
 regular page description
  is a PostScript program produced by a 
 document composition program—for example, a word processor or page-
 layout pro-gram. Typically, the PostScript program produces several 
 pages, uses a number of fonts and other resources, and activates some 
 printer-specific features such as paper trays or other physical 
 requirements. A regular page description does not normally query the 
 printer, perform calibration functions, cause VM to be permanently 
 modified, or produce color separations.",NA
•,"An 
 encapsulated PostScript (EPS) file
  is a PostScript program describing at 
 most a single page in a form that can be imported by other applications to 
 embed within a containing document. EPS files follow specific guidelines 
 and have a particular structure that is further described in Adobe 
 Technical Note #5002, 
 Encapsulated PostScript File Format Specification
 . 
 In particular, they must be device-independent and must not invoke 
 printer-specific operators. 
  
 Table G.1 summarizes the use of specific operators in either a regular page 
 de-scription or an EPS file; further details are provided for each of these 
 operators following the table. “No” in the table indicates that the operator 
 should not be used; alternate suggestions, if any, are given in the details for 
 that operator.“Careful” indicates that the operator can be used if 
 appropriate precautions are taken. The rationale for the guidelines and the 
 precautions that should be taken are provided in the details for each 
 operator. Note that the guidelines are not en-forced; however, failing to 
 observe the guidelines may result in incorrect output. 
  
 OPERATOR
  
 TABLE G.1 Guidelines summary 
 REGULAR PAGE DESCRIPTION
  
 EPS FILE
  
 banddevice
  
 No
  
 No
  
 clear
  
 Careful
  
 No
  
 cleardictstack
  
 No
  
 No
  
 copypage
  
 No
  
 No
  
 erasepage
  
 Careful
  
 No
  
 executive
  
 No
  
 No
  
 exitserver
  
 No
  
 No
  
 framedevice
  
 No
  
 No
  
 grestoreall
  
 Careful
  
 Careful
  
 initclip
  
 Careful
  
 No",NA
Bibliography,"SOME DOCUMENTS LISTED IN THIS BIBLIOGRAPHY are indicated as being 
 available on the Adobe Developer Relations site on the World Wide Web. 
 This site is located at 
  
 <http://www.adobe.com/supportservice/devrelations/>
  
 Document version numbers and dates given in this Bibliography are the 
 latest at the time of publication; more recent versions may be found on the 
 Web site. 
  
 Other documents are indicated here as being available through the Adobe 
 Developers Association. Developers registered with the ADA receive 
 software development kits, regular electronic mailings, e-mail and 
 telephone support, dis-counted Adobe software products, and a “members 
 only” Web site containing documentation and sample code not available 
 publicly. For information about joining the ADA, visit the Adobe Developer 
 Relations Web site, send e-mail to ada@adobe.com, or write to 
  
 Printing Technologies Developer 
 Support 
  
 c/o Adobe Developers Association 
  
 345 Park Avenue 
  
 San Jose, CA 95110-2704
  
 Resources from Adobe Systems Incorporated
  
 Adobe Type 1 Font Format
 , Addison-Wesley, Reading, MA, 1990. Explains 
 the in-ternal organization of a PostScript language Type 1 font program. 
 This document is available on the Adobe Developer Relations Web site. Also 
 see Adobe Technical Note #5015, 
 Type 1 Font Format Supplement
 . 
  
 Display PostScript System
 . A suite of manuals containing reference 
 documenta-tion for the Display PostScript system. These documents are 
 available on the Adobe Developer Relations Web site.",NA
•,"Adobe CMap and CID Font Files Specification Version 1.0
 , Technical Note #5014",NA
•,"Adobe Communications Protocols Specification
 , Technical Note #5009",NA
•,"Adobe Font Metrics File Format Specification Version 4.1
 , Technical Note #5004",NA
•,"CID-Keyed Font Technology Overview
 , Technical Note #5092",NA
•,"Color Separation Conventions for PostScript Language Programs
 , Technical 
 Note 
  
 #5044",NA
•,"The Compact Font Format Specification
 , Technical Note #5176",NA
•,"Encapsulated PostScript File Format Specification Version 3.0
 , Technical 
 Note 
  
 #5002",NA
•,"PostScript Language Document Structuring Conventions Specification 
 Version 
  
 3.0
 , Technical Note #5001",NA
•,"PostScript Printer Description File Format Specification
 , Technical Note #5003",NA
•,"Type 1 Font Format Supplement, 
 Technical Note #5015",NA
•,"The Type 2 Charstring Format
 , Technical Note #5177",NA
•,"The Type 42 Font Format Specification
 , Technical Note #5012",NA
•,"Updates to the PostScript Language Reference Manual, Second Edition
 , 
 Technical 
  
 Note #5085 
  
 Other Resources
  
 Fairchild, M., 
 Color Appearance Models
 , Addison-Wesley, Reading, MA, 1997. 
 Covers color vision, basic colorimetry, color appearance models, cross-
 media color reproduction, and the current CIE standards activities. 
 Updates, software, and color appearance data are available at 
 <http://www.cis.rit.edu/people/ faculty/fairchild/CAM.html>. 
  
 Farin, G., 
 Curves and Surfaces for Computer Aided Geometric Design: A 
 Practical Guide,
  4th ed., Academic Press, San Diego, 1997. Includes chapters 
 on Coons patches. 
  
 Field, G. G., 
 Color and its Reproduction
 , Graphic Arts Technical Foundation, 
 Pittsburgh, 1988. Includes information on trapping algorithms and 
 techniques. 
  
 Foley, J. et al., 
 Computer Graphics: Principles and Practice,
  Addison-Wesley, 
 Read-ing, MA, 1996. (First edition was Foley, J. and van Dam, A., 
 Fundamentals of Interactive Computer Graphics
 , Addison-Wesley, Reading, 
 MA, 1982.) Covers many graphics-related topics, including a thorough 
 treatment of the mathemat-ics of Bézier cubics and Gouraud shadings.",NA
INDEX,">
  (angle bracket, right) 
  
  
 as EOD indication (
 ASCIIHexDecode
 ) 130
  
 <>
  (angle brackets) 
  
 as hexadecimal string delimiter 
 30 special syntactic treatment of 
 27
  
 <<>>
  (angle brackets, double) 
  
 compared with other uses of angle brackets 
 33 literal dictionary object created by 36
  
 <<
  (angle brackets, double left) 
 operator dictionary constructor 
 role 33, 54 mark objects created by 
 44, 525
  
 >>
  (angle brackets, double right) 
 operator as dictionary constructor 
 33, 525 
  
 dictionary constructor role 54
  
 @
  (at sign) 
  
  
 as internal PostScript operator prefix 
 43
  
 \
  (backslash) 
  
  
 as escape character in text strings 
 29
  
 \\
  (backslash, double) 
  
  
 as ASCII encoding for backslash character 
 (list)
  
 29
  
 \b
  (backslash b) 
  
  
 as ASCII encoding for backspace character 
 (list)
  
 29
  
 \f
  (backslash f) 
  
  
 as ASCII encoding for form feed 
 (list)
  29
  
 \(
  (backslash left parenthesis) 
  
  
 as ASCII encoding for left parenthesis character 
 (list) 
  
  
 29
  
 \n
  (backslash n) 
  
  
 as ASCII encoding for line feed 
 (list)
  
 29
  
 \)
  (backslash right parenthesis) 
  
  
 as ASCII encoding for right parenthesis character 
 (list) 
  
  
 29
  
 \r
  (backslash r) 
  
  
 as ASCII encoding for carriage return 
 (list)
  
 29
  
 \t
  (backslash t) 
  
  
 as ASCII encoding for tab character 
 (list)
  
 29
  
 {}
  (curly brackets) 
  
 executable arrays enclosed by 
 36 as procedure delimiter 32 
  
 special syntactic treatment of 
 27
  
 =
  (equals) operator 87, 526
  
 ==
  (equals, double) operator 87, 526 
  
 =
  operator compared with 87 
  
 printing operand stack contents using 
 pstack
  
 87
  
 ()
  (parentheses) 
  
 ASCII encoding 
 (list)
  29 
  
 as literal text string delimiters 
 29
  
 (
  (parenthesis, left) 
  
  
 special syntactic treatment of 
 27
  
 )
  (parenthesis, right) 
  
  
 special syntactic treatment of 
 27
  
 %
  (percent sign) 
  
 comments initiated by 27 
  
 special syntactic treatment of 
 27
  
 /
  (slash) 
  
 as literal name delimiter 31 
  
 special syntactic treatment of 
 27 as valid literal name 31
  
 //
  (slash, double) 
  
  
 as immediately evaluated name delimiter 
 31
  
 //name
  syntax 
  
  
 immediately evaluated name 121–123, 167 
  
  
 specifying in a binary object sequence 
 169
  
 []
  (square brackets) operator 
  
 creating arrays with 54 
  
 literal array object created by 
 36
  
 [
  (square bracket, left) operator 
  
 array construction role 32 
  
 mark objects created by 44, 
 524 special syntactic treatment 
 of 27
  
 ]
  (square bracket. right) operator 
 See also array(s) 
  
 as array constructor 32, 524 
  
 special syntactic treatment of 
 27
  
 ~
  (tilde) 
  
  
 as ASCII base-85 string delimiter 
 31
  
 ~>
  (tilde angle bracket) 
  
  
 as EOD indication 
  
  
  
 ASCII85Decode
  131 
  
  
  
 ASCII85Encode
  131
  
 <~~>
  (tilde angle brackets) 
  
  
 as ASCII base-85 strings delimiter 
 31
  
 ==
  operator compared with 87
  
 printing operand stack contents using 
 stack
  87",NA
A,"abs
  operator 52, 527
  
 absolute value 
 calculation 
  
  
 See 
 abs
  operator
  
 AbsoluteColorimetric
  rendering intent 470
  
 accents 
  
  
 See 
 character(s)
  
 access 
  
  
 attributes 37 
  
  
  
 setting (
 executeonly
 ) 584 
  
  
  
 setting (
 noaccess
 ) 628 
  
  
  
 setting (
 readonly
 ) 640 
  
  
  
 testing read (
 rcheck
 ) 638 
  
  
  
 testing write (
 wcheck
 ) 718 
  
  
 conventions, for files 79 
  
  
 execute-only, as object attribute 
 37 
  
 invalid 
  
  
  
 errors (
 invalidaccess
 ) 60, 80, 
 616 
   
 errors (
 invalidfileaccess
 ) 80, 617 
  
 as object attribute, categories of 
 37 
  
 read-only, as object attribute 37 
  
  
 strings, for files 
 (table)
  79 
  
  
 unlimited, as object attribute 37
  
 accessing 
  
  
 See also retrieving 
  
  
 dictionaries, methods for 41 
  
  
 fonts 
  
  
  
 CFF and Chameleon, in a PostScript program 
 345–
   
  
 346 
  
  
  
 findfont
  315, 323 
  
  
  
 metrics 332 
  
  
 stacks 
  
  
  
 dictionary 46 
  
  
  
 execution 46 
  
  
  
 operand 46 
  
  
  
 operand, as if it were an array (
 index
 ) 52, 610
  
 AccurateScreens
  user parameter 
  
 as halftone setting user parameter 757 
  
 halftone-setting operator impact 482 
  
 as type 1 halftone dictionary entry 
 (table)
  
 487 value 
 (table)
  749
  
 ACFM (Adobe composite font metrics) files 333
  
 achromatic color spaces 228–231
  
 ActualAngle
  entry 
  
  
 as type 1 halftone dictionary entry 
 (table)
  
 488
  
 ActualFrequency
  entry 
  
  
 as type 1 halftone dictionary entry 
 (table)
  
 487
  
 add
  operator 52, 527 
  
 as a function 
 (example)
  
 106 
  
 immediate execution use 
 47
  
 addglyph
  operator 528
  
 adding 
  
 glyphs 351–352 
  
 numbers (
 add
 ) 527
  
 additive color 
  
 devices, render color space use 
 461 models (RGB and HSB) 217
  
 adjusting 
  
 pages 437 
  
 strokes, automatically 503–
 504
  
 AdvanceDistance
  page device parameter 413
  
 AdvanceMedia
  page device parameter 412
  
 AFM (Adobe font metrics) files 333
  
 algorithms 
  
  
 See also guidelines; rules 
  
  
 ASCII base-85 131 
  
  
 bit-oriented encoding 
  
  
  
 See 
 CCITTFaxEncode
  filter 
  
  
 CIE-based color conversion to device color 459 
  
  
 device color space conversion 474 
  
  
 font mapping 
  
  
  
 composite fonts 358–362 
  
  
  
 FMapType
  selection of 358–360 
  
  
  
 FMapType
 (table)
  92 
  
  
  
 nesting rules 363–364 
  
  
  
 (table)
  360 
  
  
 image compression 
  
  
  
 See DCT (discrete cosine transform) 
  
  
 image interpolation 301 
  
  
 LZW (Lempel-Ziv-Welch) adaptive compression 
  
  
  
 method 
  
  
  
 See
  FlateDecode
  filter; 
 FlateEncode
  filter; 
 LZWDecode 
  
  
  
 filter; 
 LZWEncode
  filter 
  
  
 mapping, CMap 388–389 
  
  
 PNG predictor 139 
  
  
 run-length encodin 
  
  
  
 See 
 RunLengthDecode
  filter; 
 RunLengthEncode
  filter 
  
 scan conversion 501, 503
  
 aliasing 
  
 causes, in color transitions 263 
  
 preventing, in shading patterns, 
 AntiAlias
 (table)
  
 262
  
 All
  colorant name 
  
  
 Separation
  color space use 243
  
 allocation 
  
  
 VM 
  
  
  
 by composite object constructors 
 58 
   
 policies (
 Font
 ) 105 
  
  
  
 retrieving (
 currentglobal
 ) 557 
  
  
  
 setglobal
  control of 60 
  
  
  
 setting (
 setvmthreshold
 ) 688
  
 aload
  operator 54, 528
  
 anchorsearch
  operator 55, 529
  
 and
  operator 55, 529
  
 Type 4 CIDFont use 381",NA
B,"Background
  array 
  
  
 as shading dictionary entry 
 (table)
  
 262
  
 backing up 
  
  
 characters, control characters for interactive 
 executive 
  
  
 use 
 (table)
  21
  
 backslash (
 \
 ) 
  
  
 as escape character in text strings 
 29
  
 backslash, double (
 \\
 ) 
  
  
 as ASCII encoding for backslash character 
 (list)
  
 29
  
 backslash b (
 \b
 ) 
  
  
 as ASCII encoding for backspace character 
 (list)
  
 29
  
 backslash f (
 \f
 ) 
  
  
 as ASCII encoding for form feed 
 (list)
  29
  
 backslash left parenthesis (
 \(
 ) 
  
  
 as ASCII encoding for left parenthesis character 
 (list) 
  
  
 29
  
 backslash n (
 \n
 ) 
  
  
 as ASCII encoding for line feed 
 (list)
  
 29
  
 backslash r (
 \r
 ) 
  
  
 as ASCII encoding for carriage return 
 (list)
  
 29
  
 backslash right parenthesis (
 \)
 ) 
  
  
 as ASCII encoding for right parenthesis character 
 (list) 
  
  
 29
  
 backslash t (
 \t
 ) 
  
  
 as ASCII encoding for tab character 
 (list)
  
 29
  
 backspace (BS) 
  
  
 interactive executive use 
 (table)
  
 21
  
 backspace character 
  
  
 \b
  as ASCII encoding 
 (list)
  
 29
  
 banddevice
  operator 
  
  
 usage guidelines 
 804
  
 bandwidth 
  
  
 as scarce resource, binary tokens suitable for 
 156
  
 base fonts 321, 357 
  
 See also font(s) 
  
 character encoding scheme 328–330 
  
 dictionary entries common to all 
 (table)
  
 325
  
 defineresource
  use of 100 
  
 dictionary, stack modifiable by 
 46
  
 beginbfchar
  operator 384, 537
  
 beginbfrange
  operator 384, 537
  
 begincidchar
  operator 385, 537
  
 begincidrange
  operator 385, 537
  
 begincmap
  operator 384, 537
  
 begincodespacerange
  operator 384, 537
  
 beginnotdefchar
  operator 385, 538
  
 beginnotdefrange
  operator 385, 538
  
 BeginPage
  page device parameter 
 device initialization 
 (table)
  
 427 operations 427–428
  
 beginrearrangedfont
  operator 384, 538
  
 beginusematrix
  operator 385, 538
  
 behavior 
  
 communication channels 76 
  
 of objects, attributes impact on 
 35
  
 Bernstein polynomials 285
  
 Bézier 
  
  
 control points, type 6 shading pattern data source 
 use 
   
  
 280 
  
  
 curves 
  
  
  
 adding segment to current path (
 arcto
 ) 191 
  
  
  
 appending to current path (
 curveto
 ) 564 
  
  
  
 appending to current path (
 rcurveto
 ) 638 
  
  
  
 in Coons patch meshes 277 
  
  
  
 in tensor-product patch meshes 284
  
 bilevel picture encoding 145
  
 bilinear interpolation 111
  
 binary 
  
  
 encoding, details 156–174 
  
  
 object sequences 163–168 
  
  
  
 binary tokens compared with 158, 169 
  
  
  
 encoded system names in 168–169 
  
  
  
 setting format (
 setobjectformat
 ) 677 
  
  
  
 writing to standard output (
 printobject
 ) 634 
  
  
  
 writing (
 writeobject
 ) 721 
  
  
 radix number representation of 28 
  
  
 representation of integers, shifting bits in (
 bitshift
 ) 
 539",NA
C,"C0
  array 113
  
 C1
  array 113
  
 cache 
  
  
 font 333–335 
  
  
  
 currentcacheparams
  552 
  
  
  
 incremental definition of font impact 
 354 
   
 loading glyphs into (
 addglyph
 ) 
 528 
  
  
  
 setting parameters (
 setcacheparams
 ) 661 
  
  
 setting (
 setcachedevice
 ) 659
  
 setting (
 setcachedevice2
 ) 659",NA
D,"DamagedRowsBeforeError
  entry 
  
  
 as 
 CCITTFaxEncode
 /
 CCITTFaxDecode
  dictionary 
 entry 
  
  
 (table)
  145
  
 dangling references 
  
  
 potential for, as reason for 
 invalidaccess
  error 
 60
  
 dash 
  
  
 See also line(s) 
  
  
 as graphics state parameter 
 (table)
  
 180 
  
 pattern 
  
  
  
 currentdash
  555 
  
  
  
 setdash
  194, 666
  
 data 
  
  
 compression 
  
  
  
 CCITTFaxEncode
 (table)
  86 
  
  
  
 FlateEncode
 (overview table)
  85 
  
  
  
 image data (
 DCTEncode
 ) 
 (table)
  86 
  
  
  
 LZW method 133–137 
  
  
  
 LZWEncode
 (overview table)
  85 
  
  
  
 RunLengthEncode
 (overview table)
  86 
  
  
  
 zlib/deflate compressed format, Flate 
 encoding of 
  
  
  
 137–142 
  
  
 decompression 
  
  
  
 CCITTFaxDecode
 (table)
  86 
  
  
  
 FlateDecode
 (overview table)
  86 
  
  
  
 image data (
 DCTDecode
 ) 
 (table)
  86 
  
  
  
 LZWDecode
 (overview table)
  85 
  
  
  
 RunLengthDecode
 (overview table)
  86 
  
  
 pass-through 
  
  
  
 NullEncode
 (table)
  86 
  
  
  
 ReusableStreamDecode
  153–156 
  
  
  
 subfile filters use for, overview 85 
  
  
  
 SubFileDecode
 (table)
  86 
  
  
 sample, decoding 299–301 
  
  
 sources 123–127 
  
  
 targets 123–127 
  
  
 transformation, filters use for 82 
  
  
 types and objects 34–45
  
 DataDict
  dictionary 
  
  
 as type 3 image dictionary entry 
 (table)
  
 304
  
 compression of image data (
 DCTEncode
 ) 
 (table)
  86 
 decompression of image data (
 DCTDecode
 ) 
 (table)
  
 86 as JPEG encoding technique, used by 
 DCTEncode
 / 
  
 DCTDecode
  filters 147
  
 DCTDecode
  filter 86, 146–150 
  
  
 not recommended as source of type 4 image 
 dictionary 
  
  
 308
  
 DCTEncode
  filter 86, 147–150 
  
 data requirements 128 
  
 dictionary, entries 
 (table)
  
 148
  
 deallocation 
  
  
 issues, in VM management 
 60
  
 debugging 
  
 See also errors 
  
 ==
  (double equals) operator use 
 526
  
 Decode
  array 
  
 as image data dictionary entry 
 (table)
  306 
  
 as image mask dictionary entry 
 (table)
  307 
  
 increasing the accuracy of encoded samples with 
 111 mapping with 
 (figure)
  112 
  
 as type 0 function dictionary entry 
 (table)
  109 
  
 as type 1 image dictionary entry 
 (table)
  298 
  
 as type 4 image dictionary entry 
 (table)
  308 
  
 as type 4 shading dictionary entry 
 (table)
  270 
  
 as type 5 shading dictionary entry 
 (table)
  275 
  
 as type 6 shading dictionary entry 
 (table)
  280
  
 DecodeA
  procedure 
  
  
 as 
 CIEBasedA
  dictionary entry 
 (table)
  
 229
  
 DecodeABC
  array 
  
  
 as 
 CIEBasedABC
  dictionary entry 
 (table)
  
 223
  
 DecodeDEF
  array 
  
 as 
 CIEBasedDEF
  dictionary entry 
 (table)
  233 
 as 
 CIEBasedDEFG
  dictionary entry 
 (table)
  235
  
 DecodeLMN
  array 
  
 as 
 CIEBasedA
  dictionary entry 
 (table)
  230 
 as 
 CIEBasedABC
  dictionary entry 
 (table)
  
 223
  
 DecodeParms
  entry 
  
  
 as 
 ReusableStreamDecode
  dictionary entry 
 (table)
  155
  
 decoding 
  
 See also encoding; filters 
  
 ASCII, filters, overview 84",NA
E,"E 
  
  
 as real number exponent indicator 
 28
  
 early binding 117 
  
  
 names (
 bind
 ) 117–123, 118–121, 538–
 539
  
 EarlyChange
  entry 
  
  
 as LZW dictionary entry 
 (table)
  
 133
  
 echo
  operator 575
  
 echoing 
  
  
 characters, enabling/disabling (
 echo
 ) 
 575
  
 edge flags 
  
  
 in type 4 shading dictionaries, vertex specification 
 use 
  
  
 271–273 
  
  
 in type 6 shading dictionaries, vertex specification 
 use 
  
  
 281
  
 eexec
  operator 576
  
 efficiency 
  
 LZW vs. Flate filters 138–139 
  
 user paths, lack of side effects contribution to 
 198
  
 Effort
  entry 
  
  
 as 
 FlateEncode
 /
 FlateDecode
  dictionary entry 
 (table) 
   
 138
  
 elements 
  
  
 of array 
  
  
  
 loading onto the operand stack (
 aload
 ) 54, 528 
  
  
 storing objects into (
 astore
 ) 54, 535 
  
  
 of composite objects 
  
  
  
 retrieving (
 get
 ) 53, 598 
  
  
  
 retrieving the number of (
 length
 ) 53, 621 
  
  
  
 storing (
 put
 ) 53, 635 
  
  
 of packed array, loading onto the operand stack 
 (
 aload
 ) 
   
  
 54, 528
  
 embedded 
  
  
 programs, encapsulation of, 
 save
  and 
 restore
  
 functions 
   
 62
  
 Emulator
  resource category 98 
  
 superseded by 
 PDL
  resource category 
 97 
 (table)
  91
  
 Enabled
  entry 
  
  
 Trapping
  dictionary, entries 
 (table)
  447
  
 encapsulation 69 
  
  
 of 
 BuildGlyph
  procedure 339 
  
  
 of embedded programs, 
 save
  and 
 restore
  functions 62 
  
 forms 206 
  
  
 job 
  
  
  
 overriding 70–72 
  
  
  
 overriding, LanguageLevel 1 (
 exitserver
 ) 70, 72–
 73 
   
 overriding, LanguageLevel 2 (
 startjob
 ) 70 
  
  
 of 
 PaintProc
  tiling pattern procedure 253 
  
  
 of paths 192 
  
  
 of programs, subfile use for error recovery in 151
  
 encapsulation 
 (continued) 
  
  
 of user path 
  
  
  
 gsave
  and 
 grestore
  use for 205 
  
  
 predictability advantage 197 
  
 of VM 68–72
  
 Encode
  array 
  
 as type 0 function dictionary entry 
 (table)
  
 109 as type 3 function dictionary entry 
 (table)
  114
  
 EncodeABC
  array 
  
  
 as type 1 CIE-based CRD entry 
 (table)
  464
  
 encoded 
  
  
 number strings 
  
  
  
 as binary tokens 171–172 
  
  
  
 homogeneous number array use 162, 
 171 
   
 operators that use 172 
  
  
 system names 160, 168–169 
  
  
  
 as binary tokens 160 
  
  
 user path 200–202 
  
  
  
 (example)
  202
  
 EncodedByteAlign
  entry 
  
  
 as 
 CCITTFaxEncode
 /
 CCITTFaxDecode
  dictionary entry 
  
  
 (table)
  144
  
 EncodeLMN
  array 
  
  
 as type 1 CIE-based CRD entry 
 (table)
  463
  
 encoding 
  
  
 See also filters 
  
  
 arrays 94 
  
  
 ASCII 
  
  
  
 arrays 32 
  
  
  
 comments 27 
  
  
  
 dictionaries 33 
  
  
  
 filters, overview 84 
  
  
  
 names 31 
  
  
  
 numbers 28 
  
  
  
 procedures 32–33 
  
  
  
 standard character set use 26–34 
  
  
  
 strings, ASCII base-85 31 
  
  
  
 strings, hexadecimal 30–31 
  
  
  
 strings, hexadecimal, reading from an input 
 file 
   
  
 (
 readhexstring
 ) 73 
  
  
  
 strings, hexadecimal, writing to an output 
 file 
   
  
 (
 writehexstring
 ) 73 
  
  
  
 strings, literal text 29–30 
  
  
 binary data 
  
  
  
 ASCII85Encode
 (overview table)
  85, 131 
  
  
  
 ASCIIHexEncode
 (overview table)
  85 
  
  
  
 details 156–174 
  
  
  
 of font sets 343 
  
  
 bit-oriented 
  
  
  
 CCITT fax standard as (
 LowBitFirst
 ) 146 
  
  
  
 CCITTFaxDecode
 (table)
  86 
  
  
  
 CCITTFaxEncode
 (table)
  86 
  
  
  
 LZW as (
 LowBitFirst
 ) 136
  
 of 
 stop
  effects (
 stopped
 ) 697",NA
F,"facsimile-encoding 
  
 CCITTFaxDecode
  filter 143–146 
  
 CCITTFaxEncode
  filter 143–146 
  
 data compression with (
 CCITTFaxEncode
 ) 
 (table)
  86 
 data decompression from (
 CCITTFaxDecode
 ) 
 (table)
  
 86
  
 FactoryDefaults
  system 
 parameter 
  
 value 
 (table)
  
 751
  
 false
  55, 587 
  
 bind
  not usable with 119 
  
 as boolean value 38
  
 FamilyName
  entry 
  
  
 as entry in 
 FontInfo
  dictionary 
 (table)
  
 327
  
 FDArray
  array 
  
 entries in dictionary 
 (table)
  374 
  
 as Type 0 CIDFont dictionary entry 
 (table)
  
 373
  
 FDBytes
  entry 
  
  
 as Type 0 CIDFont dictionary entry 
 (table)
  
 373
  
 FDepVector
  array 
  
  
 as Type 0 font dictionary entry 
 (table)
  
 357
  
 FF (form feed) 
  
 \f
  as ASCII encoding 
 (list)
  29 
 numeric values 
 (table)
  27
  
 FID
  entry 
  
 as 
 CIDFont
  dictionary entry 
 (table)
  371 
 as font dictionary entry 
 (table)
  325
  
 file
  operator 587 
  
  
 file 
  
  
  
 object creation by 79 
  
  
  
 system access by 77 
  
  
 %lineedit
  file handling 81 
  
  
 obtaining file objects for standard input and 
 standard 
   
  
 output files 74 
  
  
 operand formats 78 
  
  
 run
  as combination of 
 exec
  and 87 
  
  
 special file handling 80–82 
  
  
 %statementedit
  file handling 81
  
 file(s) 
  
  
 access conventions 
 (table)
  79 
  
 closing 79–80 
  
  
  
 closefile
  80, 544 
  
  
  
 restore
  80 
  
  
 as composite object 
 (table)
  34 
  
 copying 44 
  
  
 creating (
 file
 ) 79–80, 587 
  
  
 as data sources and targets 
 124 
  
 deleting (
 deletefile
 ) 572 
  
  
 errors (
 undefinedfilename
 ) 709 
  
 executing 50 
  
  
  
 run
  87 
  
  
 filtered 
  
  
  
 semantics of 123–156",NA
G,"gamma correction 457 
  
  
 CIE-based gamut mapping function contrasted 
 with 
  
  
 478
  
 gamut 245, 459–460 
  
  
 See also CIE-based color spaces 
  
  
 mapping functions 
  
  
  
 color rendering dictionary component 
 460 
   
 gamma correction contrasted 
 with 478 
  
  
 WhitePoint
  and 
 BlackPoint
  use 224
  
 garbage collection 
  
  
 See also memory; VM (virtual memory) 
  
  
 CloseTarget
  and 
 CloseSource
  use by 129 
  
  
 closing files with 80 
  
  
 filter pipeline impact 129 
  
  
 managing (
 vmreclaim
 ) 716 
  
  
 save
  and 
 restore
  compared with 63–64 
  
  
 setting VM allocation threshold for 
 (
 setvmthreshold
 ) 
  
  
 688
  
 gcheck
  operator 598 
  
 See also VM (virtual memory) 
  
 VM storage management role 
 61
  
 GDBytes
  entry 
  
 as Type 0 CIDFont dictionary entry 
 (table)
  
 373 as Type 2 CIDFont dictionary entry 
 (table)
  378
  
 ge
  operator 55, 598
  
 generating 
  
  
 random numbers 
  
  
  
 rand
  637 
  
  
  
 retrieving current state (
 rrand
 ) 
 652 
   
 srand
  692
  
 generation 
  
  
 black 
  
  
  
 retrieving function (
 currentblackgeneration
 ) 
 552 
   
 setting function (
 setblackgeneration
 ) 658 
  
  
  
 setting function usage guidelines 
  
  
  
  
 (
 setblackgeneration
 ) 806",NA
H,"Halftone
  resource category 
 96 
  
  
 (table)
  91
  
 halftone(s) 480–501 
  
  
 See also color; gray; monochrome 
  
  
 defining 481–482 
  
  
  
 screens with spot functions 484–489 
  
  
 dictionaries 483–484 
  
  
  
 installation (
 sethalftone
 ) 482 
  
  
  
 proprietary 499–500 
  
  
  
 proprietary 
 (table)
  500 
  
  
  
 type 1 487–489 
  
  
  
 type 1 
 (table)
  487 
  
  
  
 type 2 498 
  
  
  
 type 3 490 
  
  
  
 type 3 
 (table)
  490 
  
  
  
 type 4 498 
  
  
  
 type 5 498–499 
  
  
  
 type 6 491–492 
  
  
  
 type 6 
 (table)
  491 
  
  
  
 type 9 499 
  
  
  
 type 10 492–495 
  
  
  
 type 10 
 (table)
  495 
  
  
  
 type 16 495 
  
  
  
 type 16 
 (table)
  496 
  
  
  
 type 100 499 
  
  
  
 types of 
 (table)
  485 
  
  
  
 with multiple color components 497–499 
  
 functions, use, as rendering step 458 
  
  
 as graphics state parameter 
 (table)
  180 
  
  
 name, retrieving (
 GetHalftoneName
 ) 599 
  
  
 resource categories 
  
  
  
 Halftone
  96 
  
  
  
 Halftone
 (table)
  91 
  
  
  
 HalftoneType
  98 
  
  
  
 HalftoneType
 (table)
  92 
  
  
 screens 481, 482–483 
  
  
  
 defining patterns as, deprecated practice 
 249 
   
 definition (
 setcolorscreen
 ) 481 
  
  
  
 definition (
 setscreen
 ) 481 
  
  
  
 retrieving (
 currenthalftone
 ) 558 
  
  
  
 retrieving (
 currentscreen
 ) 562 
  
  
  
 setting (
 setcolorscreen
 ) 664 
  
  
  
 setting (
 sethalftone
 ) 671 
  
  
  
 setting (
 setscreen
 ) 681 
  
  
  
 threshold array definition of 489–497
  
 MaxSuperScreen
  482
  
 HalftoneMode
  user parameter 
  
 halftone-setting operator impact 
 482 value 
 (table)
  749
  
 HalftoneName
  entry 
  
 as proprietary halftone dictionary entry 
 (table)
  
 500 as type 1 halftone dictionary entry 
 (table)
  
 487 as type 3 halftone dictionary entry 
 (table)
  
 490 as type 6 halftone dictionary entry 
 (table)
  
 491 as type 10 halftone dictionary entry 
 (table)
  
 495 as type 16 halftone dictionary entry 
 (table)
  
 496
  
 HalftoneType
  entry 
  
 as proprietary halftone dictionary entry 
 (table)
  
 500 as type 1 halftone dictionary entry 
 (table)
  
 487 as type 3 halftone dictionary entry 
 (table)
  
 490 as type 6 halftone dictionary entry 
 (table)
  
 491 as type 10 halftone dictionary entry 
 (table)
  
 495 as type 16 halftone dictionary entry 
 (table)
  
 496
  
 HalftoneType
  resource category 
 98 
  
 (table)
  92
  
 handleerror
  error 605
  
 handleerror
  operator 
  
  
 binary
  key use 
 (table)
  117 
  
  
 default error handling use 116 
  
  
 errorinfo
  array use 
 (table)
  116 
  
  
 newerror
  entry use 
 (table)
  116 
  
  
 redefining, as user error handling modification 
 mech-
  
  
 anism 117 
  
  
 structured output error handling 173–174
  
 handling errors 115–117 
  
 default procedures 115–116 
  
 $error
  527 
  
 handleerror
  605 
  
 unsatisfied parameter requests 432–
 439 user modification mechanisms 
 117
  
 hardware 
  
 See also devices; input; output; product-
 dependent 
 HWOptions
  resource category 98 
  
 options (
 HWOptions
 ) 
 (table)
  91 
  
 output, raster 11–12
  
 headers 
  
 binary object sequences 
 163 
  
 resource file 105
  
 Height
  entry 
  
 as image data dictionary entry 
 (table)
  305 
 as image mask dictionary entry 
 (table)
  
 306",NA
I,"ID (identifier) 
  
  
 extended unique ID 
 (table)
  
 251 
  
 unique 
  
  
  
 extended 
  
  
  
  
 See 
 XUID
  array 
  
  
  
 generation of 335–337 
  
  
  
 numbers 336 
  
  
  
 numbers, extended 337
  
 identifiers 
  
  
 name objects use for 40
  
 identifying 
  
  
 glyphs in font cache 335
  
 identity 
  
  
 matrix (
 identmatrix
 ) 605 
  
  
 transform 
  
  
  
 matrix
  626 
  
  
  
 Type 2 CIDFont defined in terms of 
 379 
   
 Type 42 fonts defined in 
 terms of 347
  
 identmatrix
  operator 605
  
 idiom recognition 119–121
  
 IdiomRecognition
  user 
 parameter 
 bind
  operator 
 use 119–121 value 
 (table)
  
 749
  
 IdiomSet
  resource category 97 
  
  
 creating an instance of 
 (example)
  120 
  
  
 idiom recognition use of 119–121 
  
  
 matching procedures different from other 
 resource 
   
 categories 121
  
 IdiomSet
  resource category 
 description 
  
 (table)
  91
  
 idiv
  operator 52, 605
  
 idtransform
  operator 606
  
 IEEE 754 standard 
  
  
 real number representation 
 170
  
 if
  operator 55, 606 
  
  
 boolean object use with 
 38
  
 ifelse
  operator 55, 607 
  
 boolean object use with 
 38 
  
 (example)
  49
  
 image
  operator 177, 607 
  
  
 bilevel picture encoding convention, 
 CCITTFaxEncode
 / 
  
  
 CCITTFaxDecode
  
 filter use 145 
  
  
 CIE-based color space use 221 
  
  
 color space conflicts with 
 Pattern
  color space 254 
  
 color space use 296 
  
  
 DCTDecode
  filter output 146",NA
J,"JFIF (JPEG File Interchange Format) 
  
  
 See JPEG (Joint Photographic Experts Group) 
 standard
  
 JIS Japanese encoding 
  
  
 CMap use for encoding 366
  
 job 57 
  
  
 components of 69 
  
  
 encapsulation 70–72 
  
  
  
 LanguageLevel 1 (
 exitserver
 ) 72–
 73 
   
 LanguageLevel 2 (
 startjob
 ) 695 
  
  
 execution environment 68–72 
  
  
 initiating (
 exitserver
 ) 586 
  
  
 server 68 
  
  
  
 dictionary (
 serverdict
 ) 72, 657 
  
  
  
 operations (step sequence) 69 
  
  
 starting (
 startjob
 ) 695
  
 JobName
  user parameter 
  
 value 
 (table)
  750
  
 Jog
  page device parameter 418
  
 join between line segments (
 setlinejoin
 ) 194
  
 JPEG (Joint Photographic Experts Group) standard 
  
 compression of image data (
 DCTEncode
 ) 
 (table)
  86 
 DCTDecode
 /
 DCTEncode
  filter use 146 
  
 decompression of image data (
 DCTDecode
 ) 
 (table)
  
 86 ISO/IEC 10918-1, bibliographic reference 814 
  
 PostScript relationship to 150",NA
K,"K
  entry 
  
  
 as 
 CCITTFaxEncode
 /
 CCITTFaxDecode
  dictionary entry 
  
  
 (table)
  144
  
 kerning 
  
 See also font(s) 
  
 information available in AFM and ACRM files 
 333
  
 keys 
  
  
 associating with values, in dictionaries on the 
 diction-
   
  
 ary stack (
 def
 ) 54, 568 
  
  
 dictionary 41 
  
  
  
 searching for (
 known
 ) 54, 619 
  
  
 pattern cell 252 
  
  
 as resource identifiers (
 defineresource
 ) 90",NA
L,"language 
  
  
 control 97 
  
  
  
 support (
 ControlLanguage
 ) 
 (table)
  91 
  
  
 Emulator
  resource category 98 
  
  
  
 (table)
  91 
  
  
 natural 
  
  
  
 Localization
  resource category 97 
  
  
  
 LZW method suited to 133 
  
  
  
 Asian character sets, CID-keyed font use 364–
 390 
   
 support (
 Localization
 ) 
 (table)
  91 
  
  
 page description 13–15 
  
  
  
 PDL
  resource category 97 
  
  
 PostScript 
  
  
  
 introduction 
 (chapter)
  1–10 
  
  
  
 programming language structure and 
 components 
  
  
  
 (chapter)
  23–174
  
 LanguageLevel 1 
  
 accessing external font resources 346 
  
 clipping as simulation of masking 302 
  
 color space restrictions 211 
  
 definefont
  88 
  
 deletefile
  77 
  
 dictfull
  error 41 
  
 dictionary capacity, fixed 53 
  
 encapsulation overriding (
 exitserver
 ) 72–73 
  
 exitserver
  70, 72–73 
  
 file
  77 
  
 file system access (
 file
 ) 77 
  
 filenameforall
  77 
  
 fileposition
  77 
  
 findfont
  88 
  
 image facilities 288–289 
  
 path storage limits 190 
  
 renamefile
  77 
  
 rendering support 458 
  
 save
  and 
 restore
  as VM reclamation mechanisms 62 
 setfileposition
  77 
  
 status
  77 
  
 virtual memory, local 59
  
 LanguageLevel 2 
  
 feature summary 731–735 
  
 LanguageLevel 3 
  
 feature summary 725–731 
  
 overview 5–7
  
 LanguageLevel
  entry 
  
  
 as font dictionary entry 
 (table)
  
 325
  
 languagelevel
  operator 620
  
 LanguageLevels
  
 Latin-text 
  
 See also font(s) 
  
 Chamelion font format as implementation of 
 343 encoding schemes 330 
  
 standard Latin character set 
 (table)
  779–783
  
 Latin-text fonts 
  
 ISOLatin1Encoding
  618 
  
 ISOLatin1Encoding
  resource 95
  
 lattice-form 
  
  
 Gouraud-shaded triangle meshes 261, 274–
 276
  
 le
  operator 55, 620
  
 LeadingEdge
  page device parameter 402
  
 left parenthesis (
 (
 ) 
  
  
 special syntactic treatment of 27
  
 left sidebearing 
  
  
 glyph 332
  
 length 
  
 See also size; width 
  
 of composite object, retrieving (
 length
 ) 53, 
 621 dictionary 41 
  
 of names 40
  
 length
  operator 621 
  
  
 retrieving the number of elements in a 
 composite 
  
  
 object 53
  
 less-than-or-equal relation 
  
  
 comparing objects for (
 le
 ) 620
  
 less-than relation 
  
  
 comparing objects for (
 lt
 ) 623
  
 LF (line feed) 
  
 as EOL, scanner handling of 74–75 
 \n
  as ASCII encoding 
 (list)
  29 
  
 numeric values 
 (table)
  27
  
 libraries, procedure 
  
  
 See procedure(s), 
 sets
  
 LicenseID
  system 
 parameter 
  
  
 value 
 (table)
  752
  
 lifetime 
  
 of global virtual memory 60 
 of local virtual memory 59
  
 limitcheck
  error 621 
  
 available storage exhausted by a path 
 190 clipping simulation of masking 302 
  
 font cache 382 
  
 halftone cell memory size 488 
  
 radix number cause 28 
  
 real number cause 28
  
 limits 
  
  
 architectural 
 (table)
  739",NA
M,"machine 
  
  
 generation, binary encodings used for 
 25 
  
 representation 
  
  
  
 ByteOrder
  and 
 RealFormat
  use 170 
  
  
 of numeric objects, accessibility of 
 38
  
 makefont
  operator 624 
  
 composite font handling 364 
  
 Font
  resource category instances as operands to 
 93 scaling fonts with 315
  
 makepattern
  operator 625 
  
 creating patterns with 249 
  
 Pattern
  resource category use 95
  
 management 
  
  
 of memory 56–72
  
 manipulation 
  
  
 of matrices 187–189
  
 ManualFeed
  page device parameter 402
  
 ManualSize
  array 
  
  
 as 
 OutputDevice
  dictionary entry 
 (table)
  
 455
  
 mapping 
  
  
 algorithm, CMap 388–389 
  
  
 algorithms 
  
  
  
 FMapType
  selection of 358–360 
  
  
  
 FMapType
 (table)
  360 
  
  
 characters 358–362 
  
  
 color, functions, as CIE-based color rendering 
 diction-
   
  
 ary component 460 
  
  
 colors, to device color, as rendering step 457 
  
  
 control for Type 0 fonts with 360–362 
  
  
 with the 
 Decode
  array 
 (figure)
  112 
  
  
 fonts, 
 FMapType
  resource category 
 (table)
  92 
  
  
 image space, into user space 294–296 
  
  
 a procedure over a composite object (
 forall
 ) 53, 597
  
 MaskDict
  dictionary 
  
  
 as type 3 image dictionary entry 
 (table)
  
 304
  
 masking 
  
  
 image, LanguageLevel 1 and 2 mechanisms for 
 302 
  
 image dictionary 
 (table)
  306 
  
  
 of images 301–308 
  
  
  
 color key masking 307–308 
  
  
  
 explicit masking 303–307 
  
  
 stencil 301 
  
  
  
 imagemask
  608 
  
  
 of stencil 302–303
  
 matching 
  
  
 requests with attributes, in media selection 403–
 407
  
 mathematics 
  
  
 arithmetic 
  
  
  
 add
  527 
  
  
  
 idiv
  605 
  
  
  
 mul
  627 
  
  
  
 neg
  628 
  
  
  
 sqrt
  692 
  
  
  
 sub
  701 
  
  
 ceiling
  540 
  
  
 common logarithms (
 log
 ) 623 
  
  
 errors (
 undefinedresult
 ) 709 
  
  
 exponentiation (
 exp
 ) 586 
  
  
 floor
  594 
  
  
 natural logarithms (
 ln
 ) 622 
  
  
 operators 
  
  
  
 (list)
  508 
  
  
  
 overview 52 
  
  
 random number generation 
  
  
  
 rand
  637 
  
  
  
 retrieving current state (
 rrand
 ) 
 652 
   
 srand
  692 
  
  
 remainder (
 mod
 ) 627 
  
  
 rounding integers (
 round
 ) 652",NA
N,"N
  entry 
  
  
 as type 2 function dictionary entry 
 (table)
  
 113
  
 name(s) 
  
  
 arrays, binary object sequence encoding 166 
  
  
 binary object sequence encoding 166 
  
  
 binding, early binding of (
 bind
 ) 117–123, 118–
 121, 
   
  
 538–539 
  
  
 booleans, binary object sequence encoding 166 
  
 converting strings to (
 cvn
 ) 566 
  
  
 creating 40 
  
  
 encoded system 168–169 
  
  
  
 as binary tokens 160 
  
  
 equality, testing for 40 
  
  
 errors (
 undefined
 ) 709 
  
  
 evaluation, immediate, syntax of 31 
  
  
 executable 
  
  
  
 effects of executing 24 
  
  
  
 execution handling 50–51 
  
  
  
 handling 
 (example)
  49 
  
  
  
 semantics of 36 
  
  
 as first-class data objects 40 
  
  
 halftone, retrieving (
 GetHalftoneName
 ) 599 
  
  
 immediately evaluated 121–123 
  
  
  
 ASCII encoding compared with binary object 
 se-
   
  
 quence encoding 167 
  
  
  
 binary object sequence encoding 166 
  
  
  
 specifying in a binary object sequence 169 
  
  
 integers, binary object sequence encoding 166 
  
  
 length of 40 
  
  
 literal vs. executable 36 
  
  
 marks, binary object sequence encoding 166 
  
  
 names, binary object sequence encoding 166 
  
  
 nulls, binary object sequence encoding 166 
  
  
 numbers, binary object sequence encoding 166 
  
 objects 40–41 
  
  
 operator 
  
  
  
 as 
 systemdict
  dictionary keys 43 
  
  
  
 not reserved in PostScript 23 
  
  
 PostScript product, retrieving (
 product
 ) 634 
  
  
 real numbers, binary object sequence encoding 
 166 
  
 searches, environment for 45 
  
  
 as simple object 
 (table)
  34 
  
  
 strings, binary object sequence encoding 166 
  
  
 strings and, interchangeable in an dictionary 41 
  
 syntax 31 
  
  
 system name 168 
  
  
  
 encodings 
 (appendix)
  795–799 
  
  
 translation of, by 
 ResourceFileName
  key 103–104
  
 named 
  
 files 77–80 
  
 resources 87–
 105
  
 naming 
 conventions 
  
 devices 78 
  
 file system 78 
  
 font 328
  
 native color space 473 
  
  
 process color model, specifying 422–
 424
  
 natural language 
  
 Asian character sets, CID-keyed font use 364–
 390 
 Localization
  resource category 97 
  
 LZW method suited to 133 
  
 support (
 Localization
 ) 
 (table)
  91
  
 natural 
 logarithms 
  
  
 ln
  622
  
 ne
  operator 55, 628
  
 neg
  operator 52, 628
  
 negation 
  
  
 of numbers (
 neg
 ) 628
  
 NegativePrint
  page device parameter 415
  
 nesting 
  
 of composite fonts 363–364 
  
 of 
 save
  and 
 restore
  62
  
 neutral density 444
  
 newerror
  entry 
  
  
 as 
 $error
  dictionary entry 
 (table)
  
 116
  
 newline characters 
 26 
  
  
 handling 30
  
 newpath
  operator 177, 628 
  
 beginning paths with 191 
  
 execform
  invocation of 
 209 
  
 user path invocation of 
 205
  
 no-op 
  
  
 executable null object use for 
 51
  
 noaccess
  operator 56, 628
  
 nocurrentpoint
  error 629 
  
  
 undefined current point 
 191
  
 None
  colorant name 
  
  
 Separation
  color space use 243
  
 nonzero winding number rule 195 
  
  
 See also clipping; even-odd rule; insideness 
 testing 
  
 even-odd rule compared with 194 
  
  
 insideness testing 
  
  
  
 infill
  610 
  
  
  
 inufill
  615 
  
  
 painting, user paths (
 ufill
 ) 708
  
 not equals relation 
  
  
 comparing objects for (
 ne
 ) 
 628
  
 not
  operator 55, 629
  
 .notdef
  character name 
  
 beginnotdefrange
  operator 385 
 CIDFont equivalent for 369 
  
 encoding vector use 330",NA
O,"object(s) 24 
  
  
 array 38 
  
  
 attributes of 35–37 
  
  
 binary object sequences 156, 163–168 
  
  
  
 binary tokens compared with 158, 169 
  
  
  
 encoded system names in 168–169 
  
  
  
 setting format (
 setobjectformat
 ) 677 
  
  
  
 writing to standard output (
 printobject
 ) 634 
  
  
  
 writing (
 writeobject
 ) 721 
  
  
 boolean 38 
  
  
 comparing 
  
  
  
 for equality (
 eq
 ) 580 
  
  
  
 for greater-than-or-equal relation (
 ge
 ) 598 
  
  
  
 for greater-than relation (
 gt
 ) 604 
  
  
  
 for inequality (
 ne
 ) 628 
  
  
  
 for less-than-or-equal relation (
 le
 ) 620 
  
  
  
 for less-than relation (
 lt
 ) 623 
  
  
 composite 34–35, 34 
  
  
  
 access attributes 37 
  
  
  
 as graphics state parameters, handling of 178 
  
  
  
 binary object sequence structure 
 recommendations 
   
  
 167 
  
  
  
 copying (
 copy
 ) 53 
  
  
  
 graphics state restrictions 215 
  
  
  
 pushing/popping effects 46 
  
  
  
 retrieving elements of (
 get
 ) 53, 598 
  
  
  
 retrieving the number of elements in (
 get
 ) 53 
  
  
 storing elements of (
 put
 ) 53, 635 
  
  
  
 VM as pool for values of 57 
  
  
 converting to strings (
 cvs
 ) 568 
  
  
 copying 
  
  
  
 on the operand stack (
 dup
 ) 51, 575 
  
  
  
 simple vs. composite 35 
  
  
 creating, in VM 
 (example)
  60 
  
  
 data 34–45 
  
  
 dictionary 41–42 
  
  
 exchanging, on the operand stack (
 exch
 ) 51, 581 
  
  
 executable 
  
  
  
 effects of executing 24 
  
  
  
 exec
  582 
  
  
  
 files, execution handling 50 
  
  
  
 names, execution handling 50–51",NA
P,"PackBits (Apple Macintosh) 
  
  
 RunLengthEncode
  filter similar to 142
  
 packed arrays 39
  
 See also array(s) 
  
 as composite object 
 (table)
  34 
  
 copying (
 copy
 ) 53, 548 
  
 creating (
 packedarray
 ) 53, 631 
  
 elements 
  
  
 loading onto the operand stack (
 aload
 ) 54, 528 
  
 retrieving (
 get
 ) 53, 598 
  
  
 retrieving the number of (
 length
 ) 53, 621 
  
  
 storing (
 put
 ) 53, 635 
  
 mapping a procedure over (
 forall
 ) 53, 597 
  
 mode 
  
  
 retrieving the setting (
 currentpacking
 ) 54, 560 
  
 setting (
 setpacking
 ) 54, 678 
  
 operators 
  
  
 (list)
  509 
  
  
 overview 52–55 
  
 procedure objects as 33 
  
 subintervals of, creating objects that share 
 (
 getinterval
 ) 
   
 53
  
 packedarray
  operator 631 
  
 as composite object constructor 
 58 creating packed arrays with 53
  
 page 
  
  
 See also 
 PDL
  resource category 
  
  
 adjusting 437 
  
  
 delivery specification 416–419 
  
  
  
 parameters 
 (table)
  417–419 
  
  
 descriptions 
  
  
  
 decoding filters use in 82 
  
  
  
 graphics state parameters appropriate for 
 (table) 
   
  
 179 
  
  
  
 graphics state stack management of 181 
  
  
  
 language interpreters, 
 PDL
  resource category 
 97 
   
 languages 13–15 
  
  
  
 PostScript program structure 17–18 
  
  
  
 resource access restrictions 103 
  
  
 devices 
  
  
  
 See page devices 
  
  
 device parameters 
  
  
  
 See page device parameters 
  
  
 erasing (
 erasepage
 ) 581 
  
  
 image placement 413–416 
  
  
  
 parameters 
 (table)
  414–416 
  
  
 outputting (
 showpage
 ) 549–550 
  
  
 physical, default user space origin relationship to 
 183 
  
 rendering (
 showpage
 ) 177, 690 
  
  
 sets 419 
  
  
 setup, device initialization and 426–432
  
 page devices 
  
  
 capabilities (
 OutputDevice
 ) 
 (table)
  91 
  
 controlling 
 (chapter)
  391–456 
  
  
 details dictionaries 397 
  
  
 dictionary 394–397 
  
  
  
 retrieving (
 currentpagedevice
 ) 
 560",NA
Q,"QFactor
  entry 
  
  
 as 
 DCTEncode
  dictionary entry 
 (table)
  149
  
 QuantTables
  entry 
  
  
 as 
 DCTEncode
  dictionary entry 
 (table)
  148
  
 queue 
  
  
 circular, treating as stack portion as (
 roll
 ) 52, 
 650
  
 quit
  operator 637 
  
  
 usage guidelines 
 806
  
 ControlLanguage
  resource category 97
  
 HWOptions
  resource category 97 
 Localization
  resource category 97 
 PDL
  resource category 97
  
 programming style 
  
  
 garbage collection impact on 
 63
  
 programs 
  
  
 control constructs 
  
  
  
 See control, operators 
  
  
 encapsulated, subfile use for error recovery in 
 151",NA
R,"radial shading pattern 261, 267–270
  
 radix numbers 28 
  
 See also mathematics; 
 numbers 
 converting to strings 
 (
 cvrs
 ) 567
  
 rand
  operator 637 
  
  
 as pseudo-random number generator 
 52",NA
S,"sampled image 
  
  
 See image(s)
  
 sampling 
  
  
 data 
  
  
  
 decoding of 299–301 
  
  
  
 functions, 
 ReusableStreamDecode
  filter 153 
  
  
  
 functions, 
 ReusableStreamDecode
  filter use 153 
  
 functions 
  
  
  
 (example)
  111 
  
  
  
 type 0 function dictionary 108–112 
  
  
 horizontal, 
 DCTEncode
  dictionary entry 
 (table)
  148 
  
 images, LZW support of predictor functions for 133 
  
 representation 290–293 
  
  
  
 type 0 function dictionary use 108 
  
  
 size of sample, type 0 function dictionary 
 specification 
   
  
 (table)
  109 
  
  
 vertical, 
 DCTEncode
  dictionary entry 
 (table)
  148
  
 saturation 217
  
 Saturation
  rendering intent 
  
  
 characteristics 
 (table)
  
 470
  
 save objects 44 
  
 as composite object 
 (table)
  
 34 execution handling 50
  
 save
  operator 653 
  
 encapsulation by 69 
  
 errordict
  changes subject to 115 
  
 garbage collection compared with 63–
 64 global virtual memory unaffected by 
 59 incremental definition of font impact 
 354 local VM operations 61–62 
  
 nesting impact on 
 startjob
  operations 71 
 outermost execution by job server 69 
  
 save objects created by 44 
  
 VM impact 72",NA
T,"tab (tab) character 
  
 numeric values 
 (table)
  27 
  
 \t
  as ASCII encoding 
 (list)
  
 29
  
 Table
  array 
  
 as 
 CIEBasedDEF
  dictionary entry 
 (table)
  234 
 as 
 CIEBasedDEFG
  dictionary entry 
 (table)
  
 235
  
 tail recursion 
  
  
 interpreter facilitation of 50
  
 targets 
  
 arbitrary, treating as output file, 
 NullEncode
  filter 
 156 data 123–127
  
 templates 
  
 forms use as 207 
  
 resource category, 
 Generic
  use as 102–
 103
  
 tensor-product patch meshes 
  
  
 as type 7 shading 261, 283–
 287
  
 terminating 
  
  
 execution 
  
  
  
 quit
  637 
  
  
  
 stop
  697 
  
  
 files, with EOF 126–129 
  
  
 filters, with EOD 126–129 
  
  
 iteration execution (
 exit
 ) 
 585 
  
  
 VM alterations 71",NA
U,"uappend
  operator 204, 706 
  
 clipping user paths with 205 
 encoded number string use 
 172
  
 ucache
  operator 198, 707 
  
  
 operation code for encoded user paths 
 (table)
  
 201 
  
 user path 
  
  
  
 caching with 202–203 
  
  
  
 structuring 199
  
 ucachestatus
  operator 707
  
 ueofill
  operator 204, 708
  
 ufill
  operator 177, 204, 708 
  
 encoded user path handling 200 
  
 garbage collection benefits for management of 
 63 treating a user object as a user path 
 (example)
  68 user path construction and 
 painting 197
  
 UIDBase
  entry 
  
  
 as 
 CIDFont
  dictionary entry 
 (table)
  
 371
  
 UIDOffset
  entry 
  
  
 as CMap dictionary entry 
 (table)
  
 384
  
 Uncompressed
  entry 
  
  
 as 
 CCITTFaxEncode
 /
 CCITTFaxDecode
  dictionary entry 
  
  
 (table)
  144
  
 undef
  operator 54, 708
  
 undefined 
  
  
 characters, 
 handling
  
 undefined
  error 709 
  
  
 image dictionary 298 
  
  
 immediate evaluation of names 122 
  
  
 immediately evaluated names 167 
  
  
 LanguageLevel 2, 
 Separation
  or 
 DeviceN
  use with 
 In-
  
  
 dexed
  color space 239 
  
  
 name search failure cause 51 
  
  
 operators that cause, due to graphics state 
 restrictions 
  
  
 215 
  
  
 resource file loading 105 
  
  
 system name index 168 
  
  
 tiling pattern colors 
 (table)
  252",NA
V,"values 
  
  
 associating keys with, in dictionaries on the 
 dictionary 
  
  
  
 stack (
 def
 ) 54, 568 
  
  
 associating with names 41 
  
  
 color 210 
  
  
  
 in 
 CIEBasedABC
  color spaces 222 
  
  
  
 operators 214–216 
  
  
  
 semantics of 211–248 
  
  
 of composite objects, not copied by stack operators 
 51 
  
 composite objects 
  
  
  
 sharing between copies 35 
  
  
  
 VM as pool for 57
  
 See also garbage collection 
  
 allocation 
  
  
 policies, resource loading issues 105 
  
  
 retrieving (
 currentglobal
 ) 557 
  
  
 setglobal
  control of 60 
  
  
 setting (
 setvmthreshold
 ) 688 
  
 alterations, termination of 71 
  
 composite object 
  
  
 creation impact on 58 
  
  
 values contained in 35 
  
 consumption of, by composite object creation 
 opera-
   
 tors 53 
  
 creating objects in 
 (example)
  60 
  
 encapsulation of 68–72 
  
 encoded number string use in 171",NA
W,"W3C (WWW Consortium) 
  
  
 PNG standard 139
  
 wcheck
  operator 56, 718
  
 weight 
  
  
 media (
 MediaWeight
 ) 
 401
  
 Weight
  entry 
  
  
 as entry in 
 FontInfo
  dictionary 
 (table)
  
 327
  
 WeightVector
  array 
  
  
 as Type 1 font dictionary entry 
 (table)
  
 327
  
 where
  operator 43, 54, 718
  
 white-space 
  
  
 characters 26 
  
  
  
 numeric values 
 (table)
  
 27
  
 WhitePoint
  array 
  
 calculation of 226 
  
 as 
 CIEBasedA
  dictionary entry 
 (table)
  230 as 
 CIEBasedABC
  dictionary entry 
 (table)
  224 as 
 type 1 CIE-based CRD entry 
 (table)
  464
  
 width 
  
  
 See also length; size 
  
  
 glyph 320, 331 
  
  
  
 adjusting (
 widthshow
 ) 718 
  
  
  
 retrieving (
 stringwidth
 ) 699 
  
  
  
 setting (
 setcharwidth
 ) 661 
  
  
 line 
  
  
  
 retrieving (
 currentlinewidth
 ) 559 
  
  
 setting (
 setlinewidth
 ) 193, 674
  
 Width
  entry 
  
 as image data dictionary entry 
 (table)
  305 
  
 as image mask dictionary entry 
 (table)
  306 as 
 type 1 image dictionary entry 
 (table)
  298 as 
 type 3 halftone dictionary entry 
 (table)
  490 
 as type 4 image dictionary entry 
 (table)
  307 
 as type 6 halftone dictionary entry 
 (table)
  
 491 as type 16 halftone dictionary entry 
 (table)
  496
  
 Width2
  entry 
  
  
 as type 16 halftone dictionary entry 
 (table)
  
 496
  
 widthshow
  operator 320, 718
  
 wildcards 
  
 filenameforall
  use 78 
  
 resourceforall
  use 646
  
 winding number 
  
  
 nonzero, rule 195
  
 WMode
  entry 
  
 as 
 CIDFont
  dictionary entry 
 (table)
  
 371 as CMap dictionary entry 
 (table)
  
 384 as font dictionary entry 
 (table)
  
 325 as Type 0 font dictionary entry 
 362
  
 write access attribute 
  
  
 testing (
 wcheck
 ) 718
  
 write
  operator 720 
  
 EOL transparent to 75 
  
 writing, characters to an output file 
 73
  
 writehexstring
  operator 720 
  
  
 writing, hexadecimal strings to an output file 
 73
  
 writeobject
  operator 721
  
 binary object sequence writing 173",NA
Y,"yshow
  operator 320, 321, 723 
  
  
 encoded number string use 
 172
  
 Ysquare
  entry 
  
  
 as type 10 halftone dictionary entry 
 (table)
  
 495
  
 YStep
  entry 
  
  
 as type 1 pattern dictionary entry 
 (table)
  
 251",NA
Z,"zlib/deflate compressed format 
  
 Flate encoding of 137–142 
  
 FlateDecode
  filter use, overview 
 (overview table)
  
 86 
 FlateEncode
  filter use, overview 
 (overview 
 table)
  85
  
 zone theory 
  
  
 of color vision, 
 CIEBasedABC
  as model of 
 221
  
 zones
  
  
 -specific colorant details 454 
  
 trapping 445–446 
  
  
  
 setting (
 settrapzone
 ) 68
  
 text representation of an 
 object 
  
  
 to standard output (
 ==
 ) 87 
  
  
 to standard output (
 =
 ) 87 
  
 vertical, font metrics for 332",NA
X,"xcheck
  operator 56, 721
  
 xor
  (exclusive or) operator 55, 722
  
 xshow
  operator 320, 321, 722 
  
  
 encoded number string use 
 172
  
 Xsquare
  entry 
  
  
 as type 10 halftone dictionary entry 
 (table)
  
 495
  
 XStep
  entry 
  
  
 as type 1 pattern dictionary entry 
 (table)
  
 251
  
 XUID
  array 
  
 as base font dictionary entry 
 (table)
  326 
  
 as 
 CIDFont
  dictionary entry 
 (table)
  371 
  
 as CMap dictionary entry 
 (table)
  383 
  
 components of 337 
  
 as form dictionary entry 
 (table)
  208 
  
 as LanguageLevel 2 font feature 336 
  
 as type 1 pattern dictionary entry 
 (table)
  
 251 
  
 as type 2 pattern dictionary entry 
 (table)
  
 260
  
 XUID
  entry 
  
  
 as form dictionary entry 
 (table)
  
 208
  
 xyshow
  operator 321, 722",NA
Colophon,"THIS BOOK WAS PRODUCED using Adobe FrameMaker
 ®
 , Adobe 
 Illustrator
 ®
 , Adobe Photoshop
 ®
 , and other application software packages 
 that support the PostScript language and Type 1 fonts. The type used is 
 from the Minion
 ®
  and Myriad
 ®
  families. Heads are set in Myriad MM 565 
 Semibold, 600 Normal, and the body text is set in 10.5-on-13-point Minion. 
  
 Authors
 —Ed Taft, Steve Chernicoff, Caroline Rose 
  
 Key Contributors
 —Steven Kelley Amerige, Rob Babcock, Doug Brotz, Jo 
 Davies, Richard Dermer, Matt Foley, Linda Gass, Ron Gentile, Peter Hibbard, 
 Jim King, Ken Lent, Deborah MacKay, Jim Meehan, Carl Orthlieb, Paul 
 Rovner, Mike Schuster, Scott Seltz, Andy Shore, John Warnock 
  
 Reviewers
 —Ken Anderson, Rob Babcock, Ned Batchelder, Perry Caro, 
 Holly Cochran, L. Peter Deutsch, David Gelphman, Deborah MacKay, Henry 
 Mc-Gilton, John Nash, Jim Sandman, Norin Saxe, Lydia Stang, and numerous 
 others at Adobe Systems and elsewhere. 
  
 Editing and Book Production
 —Steve Chernicoff, Caroline Rose
  
 Index
 —Rosemary Simpson
  
 Illustrations
 —Carl Yoshihara, Wendy Bell, Dayna Porterfield, Lisa 
 Ferdinandsen, Carol Keller
  
 Book Design
 —Sharon Anderson
  
 Publication Management
 —Robin Sterling, Richard Compeau, Sholom 
 Surges, Joan Delfino 
  
 Project Management
 —Caroline Rose, Ed Taft",NA
