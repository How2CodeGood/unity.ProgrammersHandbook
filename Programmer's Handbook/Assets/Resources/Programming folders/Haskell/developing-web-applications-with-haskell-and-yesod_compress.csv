Larger Text,Smaller Text,Symbol
Developing Web ,NA,NA
Applications ,NA,NA
with Haskell ,NA,NA
and Yesod,"D
 ownload from Wow! eBook <www.wowebook.com>",NA
Michael Snoyman,"Beijing
  •
  Cambridge
  •
  Farnham
  •
  Köln
  •
  Sebastopol
  •
  Tokyo",NA
Table of Contents,"Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . .  ix",NA
Part I. Basics ,"1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . .  3
  
 Type Safety 
  
 3
  
 Concise 
  
 4
  
 Performance 
  
 4
  
 Modular 
  
 4
  
 A Solid Foundation 
  
 5
  
 Introduction to Haskell 
  
 5
  
 2. Haskell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . .  7
  
 Terminology 
  
 7
  
 Tools 
  
 8
  
 Language Pragmas 
  
 9
  
 Overloaded Strings 
  
 10
  
 Type Families 
  
 11
  
 Template Haskell 
  
 11
  
 QuasiQuotes 
  
 13
  
 Summary 
  
 13
  
 3. Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .  15",NA
Part II. Advanced ,"12. RESTful Content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .  127
  
 Request Methods 
  
 Representations 
  
  
 RepHtmlJson 
  
  
 News Feeds 
  
 Other Request Headers 
  
 Stateless
  
 12
 7 
  
 12
 8 
  
 12
 9 
  
 13
 1 
  
 13
 1 
  
 13",NA
Part III. Examples ,"18. Blog: i18n, Authentication, Authorization, and Database . . . . . 
 . . . . . . . . . . . . . . . 175 19. Wiki: Markdown, Chat Subsite, Event 
 Source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  185 20. JSON Web Service . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  193 
  
 Server 
  
 193 
  
 Client 
  
 194 
 21. Case Study: Sphinx-Based Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . .  197
  
 Sphinx Setup 
  
 Basic Yesod Setup 
  
 Searching 
  
 Streaming xmlpipe Output 
  
 Full Code
  
 19
 7 
  
 19
 8 
  
 20
 0 
  
 20
 3 
  
 20
 6",NA
Part IV. Appendices ,"A. monad-control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .  213 B. Conduit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . .  223 C. Web Application Interface . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255 D. Settings Types . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259 E. http-
 conduit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
 261 F. xml-conduit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . 267",NA
Preface,"It’s fair to say that dynamic languages currently dominate the web development 
 scene. Ruby, Python, and PHP are common choices for quickly creating a powerful 
 web application. They give a much faster and more comfortable development 
 setting than standard static languages in the C family, like Java.
  
 But some of us are looking for something more in our development toolbox. We 
 want a language that gives us guarantees that our code is doing what it should. 
 Instead of writing up a unit test to cover every bit of functionality in our 
 application, wouldn’t it be wonderful if the compiler could 
 automatically
  ensure 
 that our code is correct? And as an added bonus, wouldn’t it be nice if our code ran 
 quickly too?
  
 These are the goals of Yesod. Yesod is a web framework bringing the strengths of 
 the Haskell programming language to the web development world. Yesod not only 
 uses a pure language to interact with an impure world, it allows safe interactions 
 with the outside world by automatically sanitizing incoming and outgoing data. Not 
 only do we avoid basic mistakes such as mixing up integers and strings, it even 
 allows us to statically prevent many cases of security holes like cross-site scripting 
 (XSS) attacks.",NA
Who This Book Is For,"In general, there are two groups of people coming to Yesod. The first group is long 
 time Haskell users—already convinced of the advantages of Haskell—who are 
 looking for a powerful framework for creating web applications. The second is web 
 developers who are either dissatisfied with their existing tools, or are looking to 
 expand their horizons into the functional world.
  
 This book assumes a basic familiarity with both web development and Haskell. We 
 don’t use many complicated Haskell concepts, and those we do use are introduced 
 separately. For the most part, understanding the basics of the syntax of the 
 language should be sufficient.
  
 If you want to come up to speed on Haskell, I recommend another wonderful 
 O’Reilly book: 
 Real World Haskell
 .",NA
Conventions Used in This Book,"The following typographical conventions are used in this book:
  
 Italic 
  
  
 Indicates new terms, URLs, email addresses, filenames, and file extensions.
  
 Constant width 
  
 Used for program listings, as well as within paragraphs to refer to program 
 elements such as variable or function names, databases, data types, 
 environment variables, statements, and keywords.
  
 Constant width bold 
  
  
 Shows commands or other text that should be typed literally by the 
 user.
  
 Constant width italic 
  
 Shows text that should be replaced with user-supplied values or by values 
 deter-mined by context.
  
  
  
 This icon signifies a tip, suggestion, or general note.
  
 This icon indicates a warning or caution.",NA
Using Code Examples,"This book is here to help you get your job done. In general, you may use the code in 
 this book in your programs and documentation. You do not need to contact us for 
 permission unless you’re reproducing a significant portion of the code. For 
 example, writing a program that uses several chunks of code from this book does 
 not require permission. Selling or distributing a CD-ROM of examples from O’Reilly 
 books does require permission. Answering a question by citing this book and 
 quoting example code does not require permission. Incorporating a significant 
 amount of example code from this book into your product’s documentation does 
 require permission.
  
 We appreciate, but do not require, attribution. An attribution usually includes the 
 title, author, publisher, and ISBN. For example: “
 Developing Web Applications with 
 Haskell and Yesod
  by Michael Snoyman (O’Reilly). Copyright 2012 Michael 
 Snoyman, 978-1-449-31697-6.”
  
 If you feel your use of code examples falls outside fair use or the permission given 
 above, feel free to contact us at 
 permissions@oreilly.com
 .",NA
Safari® Books Online,"Safari Books Online (
 www.safaribooksonline.com
 ) is an on-demand 
 digital library that delivers expert 
 content
  in both book and video form 
 from the
  
 world’s leading authors in technology and business.
  
 Technology professionals, software developers, web designers, and business and 
 cre-ative professionals use Safari Books Online as their primary resource for 
 research, problem solving, learning, and certification training.
  
 Safari Books Online offers a range of 
 product mixes
  and pricing programs for 
 organi-zations
 , 
 government agencies
 , and 
 individuals
 . Subscribers have access to 
 thousands of books, training videos, and prepublication manuscripts in one fully 
 searchable da-tabase from publishers like O’Reilly Media, Prentice Hall 
 Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit 
 Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, 
 IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, 
 McGraw-Hill, Jones & Bartlett, Course Tech-nology, and dozens 
 more
 . For more 
 information about Safari Books Online, please visit us 
 online
 .",NA
How to Contact Us,"Please address comments and questions concerning this book to the publisher:
  
 O’Reilly Media, Inc.
  
 1005 Gravenstein Highway North 
  
 Sebastopol, CA 95472 
  
 800-998-9938 (in the United States or 
 Canada) 707-829-0515 (international or 
 local) 
  
 707-829-0104 (fax)
  
 We have a web page for this book, where we list errata, examples, and any 
 additional information. You can access this page at:
  
 http://shop.oreilly.com/product/0636920023142.do
  
 To comment or ask technical questions about this book, send email to:
  
 bookquestions@oreilly.com
  
 For more information about our books, courses, conferences, and news, see our 
 website at 
 http://www.oreilly.com
 .
  
 Find us on Facebook: 
 http://facebook.com/oreilly
  
 Follow us on Twitter: 
 http://twitter.com/oreillymedia
  
 Watch us on YouTube: 
 http://www.youtube.com/oreillymedia
  
 Preface | xi",NA
Acknowledgements,"Yesod has been created by an entire community of developers, all of whom have 
 put in significant effort to make sure that the final product is as polished and user-
 friendly as possible. Everyone from the core development team to the person 
 making an API request on the mailing list has had an impact on bringing Yesod to 
 where it is today.
  
 In particular, I’d like to thank Greg Weber, who has shared the maintenance burden 
 of the project; Kazu Yamamoto and Matt Brown, who transformed Warp from a 
 simple testing server to one of the fastest application servers available today; and 
 Felipe Lessa, Patrick Brisbin, and Luite Stegeman for their numerous contributions 
 across the board.
  
 A big thank you to my editor, Simon St. Laurent, for all of his guidance and support. 
 Mark Lentczner, Johan Tibell, and Adam Turoff provided incredibly thorough 
 reviews of this book, cleaning up many of my mistakes. Additionally, there have 
 been dozens of readers who have looked over the content of this book online, and 
 provided feedback on where either the prose or the message was not coming 
 through clearly—not to mention numerous spelling errors.
  
 But finally, and most importantly, I’d like to thank my wife, Miriam, for enduring all 
 of the time spent on both this book and Yesod in general. She has been my editor 
 and sounding-board, though I’m sure the intricacies of Template Haskell sometimes 
 worked more as a sedative than any meaningful conversation. Without her support, 
 neither the Yesod project nor this book would have been able to happen.
  
 Also, you’ll notice that I use my kids’ names (Eliezer and Gavriella) in some 
 examples throughout the book. They deserve special mention in a Haskell text, 
 since I think they’re the youngest people to ever use the word “monad” in a 
 sentence with their“Transformers: Monads in Disguise.”",NA
PAR,NA,NA
T I ,NA,NA
Basi,NA,NA
cs,"D
 ownload from Wow! eBook <www.wowebook.com>",NA
CHAPTER 1,NA,NA
Introduction,"Since web programming began, people have been trying to make the development 
 pro-cess a more pleasant one. As a community, we have continually pushed new 
 techniques to try and solve some of the lingering difficulties of security threats, the 
 stateless nature of HTTP, the multiple languages (HTML, CSS, JavaScript) necessary 
 to create a pow-erful web application, and more.
  
 Yesod attempts to ease the web development process by playing to the strengths of 
 the Haskell programming language. Haskell’s strong compile-time guarantees of 
 correct-ness not only encompass types; referential transparency ensures that we 
 don’t have any unintended side effects. Pattern matching on algebraic data types 
 can help guarantee we’ve accounted for every possible case. By building upon 
 Haskell, entire classes of bugs disappear.
  
 Unfortunately, using Haskell isn’t enough. The Web, by its very nature, is 
 not
  type 
 safe. Even the simplest case of distinguishing between an integer and string is 
 impossible: all data on the Web is transferred as raw bytes, evading our best efforts 
 at type safety. Every app writer is left with the task of validating all input. I call this 
 problem 
 the boundary issue
 : as much as your application is type safe on the inside, 
 every boundary with the outside world still needs to be sanitized.",NA
Type Safety,"This is where Yesod comes in. By using high-level declarative techniques, you can 
 specify the exact input types you are expecting. And the process works the other 
 way as well: using a process of type-safe URLs, you can make sure that the data you 
 send out is also guaranteed to be well formed.
  
 The boundary issue is not just a problem when dealing with the client: the same 
 prob-lem exists when persisting and loading data. Once again, Yesod saves you on 
 the boundary by performing the marshaling of data for you. You can specify your 
 entities in a high-level definition and remain blissfully ignorant of the details.
  
 3",NA
Concise,"We all know that there is a lot of boilerplate coding involved in web applications. 
 Wherever possible, Yesod tries to use Haskell’s features to save your fingers the 
 work:
  
 • The forms library reduces the amount of code used for common cases by 
 leveraging 
  
 the Applicative type class.
  
 • Routes are declared in a very terse format, without sacrificing type safety.
  
 • Serializing your data to and from a database is handled automatically via code 
  
 generation.
  
 In Yesod, we have two kinds of code generation. To get your project started, we 
 provide a scaffolding tool to set up your file and folder structure. However, most 
 code genera-tion is done at compile time via meta programming. This means your 
 generated code will never get stale, as a simple library upgrade will bring all your 
 generated code up-to-date.
  
 But for those who like to stay in control, and know exactly what their code is doing, 
 you can always run closer to the compiler and write all your code yourself.",NA
Performance,"Haskell’s main compiler, the GHC, has amazing performance characteristics, and is 
 improving all the time. This choice of language by itself gives Yesod a large 
 performance advantage over other offerings. But that’s not enough: we need an 
 architecture designed for performance.
  
 Our approach to templates is one example: by allowing HTML, CSS, and JavaScript 
 to be analyzed at compile time, Yesod both avoids costly disk I/O at runtime and 
 can optimize the rendering of this code. But the architectural decisions go deeper: 
 we use advanced techniques such as conduits and builders in the underlying 
 libraries to make sure our code runs in constant memory, without exhausting 
 precious file handles and other resources. By offering high-level abstractions, you 
 can get highly compressed and properly cached CSS and JavaScript.
  
 Yesod’s flagship web server, Warp, is the fastest Haskell web server around. When 
 these two pieces of technology are combined, it produces one of the fastest web 
 application deployment solutions available.",NA
Modular,"Yesod has spawned the creation of dozens of packages, most of which are usable in 
 a context outside of Yesod itself. One of the goals of the project is to contribute back 
 to the community as much as possible; as such, even if you are not planning on 
 using",NA
A Solid Foundation,"I remember once seeing a PHP framework advertising support for UTF-8. This 
 struck me as surprising: you mean having UTF-8 support isn’t automatic? In the 
 Haskell world, issues like character encoding are already well addressed and fully 
 supported. In fact, we usually have the opposite problem: there are a number of 
 packages providing powerful and well-designed support for the problem. The 
 Haskell community is con-stantly pushing the boundaries finding the cleanest, most 
 efficient solutions for each challenge.
  
 The downside of such a powerful ecosystem is the complexity of choice. By using 
 Yesod, you will already have most of the tools chosen for you, and you can be 
 guaranteed they work together. Of course, you always have the option of pulling in 
 your own solution.
  
 As a real-life example, Yesod and Hamlet (the default templating language) use 
 blaze-builder
  for textual content generation. This choice was made because blaze 
 provides the fastest interface for generating UTF-8 data. Anyone who wants to use 
 one of the other great libraries out there, such as 
 text
 , should have no problem 
 dropping it in.",NA
Introduction to Haskell,"Haskell is a powerful, fast, type-safe, functional programming language. This book 
 takes as an assumption that you are already familiar with most of the basics of 
 Haskell. There are two wonderful books for learning Haskell, both of which are 
 available for reading online:
  
 •
  Learn You a Haskell for Great Good!
  
 •
  Real World Haskell
  
 Yesod relies on a few features in Haskell that most introductory tutorials do not 
 cover. Though you will rarely need to understand how these work, it’s always best 
 to start off with a good appreciation for what your tools are doing. These are 
 covered in the next chapter.
  
 Introduction to Haskell | 5",NA
CHAPTER 2,NA,NA
Haskell,"In order to use Yesod, you’re going to have to know at least the basics of Haskell. 
 Additionally, Yesod uses some features of Haskell that aren’t covered in most intro-
 ductory texts. While this book assumes the reader has a basic familiarity with 
 Haskell, this chapter is intended to fill in the gaps.
  
 If you are already fluent in Haskell, feel free to completely skip this chapter. Also, if 
 you would prefer to start off by getting your feet wet with Yesod, you can always 
 come back to this chapter later as a reference.
  
 If you are looking for a more thorough introduction to Haskell, I would recommend 
 either 
 Real World Haskell
  or 
 Learn You a Haskell
 .",NA
Terminology,"Even for those familiar with Haskell as a language, there can sometimes be some 
 con-fusion about terminology. Let’s establish some base terms that we can use 
 throughout this book.
  
 Data type 
  
 This is one of the core building blocks for a strongly typed language like 
 Haskell. Some data types, like 
 Int
 , can be treated as primitive values, while other 
 data types will build on top of these to create more complicated values. For 
 example, you might represent a person with:
  
 data Person = Person Text Int
  
 Here, the 
 Text
  would give the person’s name, and the 
 Int
  would give the 
 person’s age. Due to its simplicity, this specific example type will recur 
 throughout the book.
  
 There are essentially three ways you can create a new data type:
  
 • A 
 type
  declaration such as 
 type GearCount = Int
  merely creates a synonym for 
 an existing type. The type system will do nothing to prevent you from using 
 an 
 Int
  where you asked for a 
 GearCount
 . Using this can make your code 
 more self-documenting.
  
 7",NA
Tools,"There are two main tools you’ll need to develop in Haskell. The Glasgow Haskell 
 Compiler (GHC) is the standard Haskell compiler, and the only one officially 
 supported by Yesod. You’ll also need Cabal, which is the standard Haskell build tool. 
 Not only do we use Cabal for building our local code, but it can automatically 
 download and install dependencies from Hackage, the Haskell package repository.
  
 If you’re on Windows or Mac, it is strongly recommended that you download the 
 Haskell Platform
 . On Linux, many distributions include the Haskell Platform in their 
 repositories. On Debian-based systems, for example, you can get started by running 
 sudo apt-get install haskell-platform
 . If your distribution does not include the Has-kell 
 Platform, you can install it manually by following the instructions on the Haskell 
 Platform page.
  
 One important tool you’ll need to update is 
 alex
 . The Haskell Platform includes 
 version
  
 2, while the JavaScript minifier Yesod uses, 
 hjsmin
 , requires version three. Be sure 
 to 
 cabal install alex
  after getting set up with the Haskell Platform, or you’ll run into 
 error messages about the 
 language-javascript
  package.
  
 8 | Chapter 2:Haskell",NA
Language Pragmas,"GHC will run by default in something very close to Haskell98 mode. It also ships 
 with a large number of language extensions, allowing more powerful type classes, 
 syntax changes, and more. There are multiple ways to tell GHC to turn on these 
 extensions. For most of the code snippets in this book, you’ll see 
 language pragmas
 , 
 which look like this:
  
 {-# LANGUAGE MyLanguageExtension #-}
  
 These should always appear at the top of your source file. Additionally, there are 
 two other common approaches:
  
 • On the GHC command line, pass an extra argument 
 -XMyLanguageExtension
 .
  
 • In your 
 cabal
  file, add an 
 extensions
  block.
  
 I personally never use the GHC command line argument approach. It’s a personal 
 preference, but I like to have my settings clearly stated in a file. In general it’s
  
 Language Pragmas | 9",NA
Overloaded Strings,"What’s the type of 
 ""hello""
 ? Traditionally, it’s 
 String
 , which is defined as 
 type String = 
 [Char]
 . Unfortunately, there are a number of limitations with this:
  
 • It’s a very inefficient implementation of textual data. We need to allocate extra 
 memory for each cons cell, plus the characters themselves each take up a full 
 ma-chine word.
  
 • Sometimes we have string-like data that’s not actually text, such as 
 ByteString
 s 
  
 and HTML.
  
 To work around these limitations, GHC has a language extension called 
 Overloaded 
 Strings
 . When enabled, literal strings no longer have the monomorphic type 
 String
 ; 
 instead, they have the type 
 IsString a => a
 , where 
 IsString
  is defined as:
  
 class IsString a where
  
  
  fromString :: String -> a
  
 There are 
 IsString
  instances available for a number of types in Haskell, such as 
 Text 
 (a much more efficient packed 
 String
  type), 
 ByteString
 , and 
 Html
 . Virtually every 
 example in this book will assume that this language extension is turned on.
  
 Unfortunately, there is one drawback to this extension: it can sometimes confuse 
 GHC’s type checker. Imagine we have:
  
 {-# LANGUAGE OverloadedStrings, TypeSynonymInstances, FlexibleInstances #-} 
 import Data.Text (Text)
  
 class DoSomething a where
  
  
  something :: a -> IO ()
  
 instance DoSomething String where
  
  
  something _ = putStrLn ""String""
  
 instance DoSomething Text where
  
  
  something _ = putStrLn ""Text""
  
 myFunc :: IO () 
  
 myFunc = something ""hello""
  
 Will the program print out 
 String
  or 
 Text
 ? It’s not clear. So instead, you’ll need to 
 give an explicit type annotation to specify whether 
 ""hello""
  should be treated as a 
 String
  or 
 Text
 .
  
 10 | Chapter 2:Haskell",NA
Type Families,"The basic idea of a type family is to state some association between two different 
 types. Suppose we want to write a function that will safely take the first element of 
 a list. But we don’t want it to work just on lists; we’d like it to treat a 
 ByteString
  like 
 a list of 
 Word8
 s. To do so, we need to introduce some 
 associated type
  to specify 
 what the contents of a certain type are.
  
 {-# LANGUAGE TypeFamilies, OverloadedStrings #-} 
  
 import Data.Word (Word8) 
  
 import qualified Data.ByteString as S 
  
 import Data.ByteString.Char8 () -- get an orphan IsString instance
  
 class SafeHead a where
  
  type Content a
  
  safeHead :: a -> Maybe (Content a)
  
 instance SafeHead [a] where
  
  type Content [a] = a
  
  safeHead [] = Nothing
  
  safeHead (x:_) = Just x
  
 instance SafeHead S.ByteString where
  
  
  type Content S.ByteString = Word8
  
  
  safeHead bs
  
  
  
  | S.null bs = Nothing
  
  
  
  | otherwise = Just $ S.head bs
  
 main :: IO () 
  
 main = do
  
  
  print $ safeHead ("""" :: String)
  
  
  print $ safeHead (""hello"" :: String)
  
  print $ safeHead ("""" :: S.ByteString)
  
  print $ safeHead (""hello"" :: S.ByteString)
  
 The new syntax is the ability to place a 
 type
  inside of a 
 class
  and 
 instance
 . We can 
 also use 
 data
  instead, which will create a new data type instead of reference an 
 existing one.
  
  
 There are other ways to use associated types outside the context of 
 a typeclass. However, in Yesod, all of our associated types are in fact 
 part of a type class. For more information on type families, see 
 the 
 Haskell wiki page
 .",NA
Template Haskell,"Template Haskell (TH) is an approach to 
 code generation
 . We use it in Yesod in a 
 number of places to reduce boilerplate, and to ensure that the generated code is 
 correct.
  
 Template Haskell | 11",NA
QuasiQuotes,"QuasiQuotes (QQ) are a minor extension of Template Haskell that let us embed 
 arbi-trary content within our Haskell source files. For example, we mentioned 
 previously the 
 hamletFile
  TH function, which reads the template contents from an 
 external file.
  
 We also have a quasi-quoter named 
 hamlet
  that takes the content inline:
  
 {-# LANGUAGE QuasiQuotes #-}
  
 [hamlet|<p>This is quasi-quoted Hamlet.|]
  
 The syntax is set off using square brackets and pipes. The name of the quasi-quoter 
 is given between the opening bracket and the first pipe, and the content is given 
 between the pipes.
  
 Throughout the book, we will often use the QQ approach over a TH-powered 
 external file since the former is simpler to copy and paste. However, in production, 
 external files are recommended for all but the shortest of inputs as it gives a nice 
 separation of the non-Haskell syntax from your Haskell code.",NA
Summary,"You don’t need to be an expert in Haskell to use Yesod, a basic familiarity will 
 suffice. This chapter hopefully gave you just enough extra information to feel more 
 comfortable following the rest of the book.
  
 Summary | 13",NA
CHAPTER 3,NA,NA
Basics,"The first step with any new technology is getting it to run. The goal of this chapter 
 is to get you started with a simple Yesod application, and cover some of the basic 
 concepts and terminology.",NA
Hello World,"Let’s get this book started properly: a simple web page that says Hello World:
  
 {-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
  
  
 TemplateHaskell, OverloadedStrings #-} 
  
 import Yesod
  
 data HelloWorld = HelloWorld
  
 mkYesod ""HelloWorld"" [parseRoutes| 
  
 / HomeR GET 
  
 |]
  
 instance Yesod HelloWorld
  
 getHomeR :: Handler RepHtml 
  
 getHomeR = defaultLayout [whamlet|Hello World!|]
  
 main :: IO () 
  
 main = warpDebug 3000 HelloWorld
  
 If you save that code in 
 helloworld.hs
  and run it with 
 runhaskell helloworld.hs
 , you’ll 
 get a web server running on port 3000. If you point your browser to 
 http://localhost: 3000
 , you’ll get the following HTML:
  
 <!DOCTYPE html> 
  
 <html><head><title></title></head><body>Hello World!</body></html>
  
 We’ll refer back to this example through the rest of the chapter.
  
 15",NA
Routing,"Like most modern web frameworks, Yesod follows a 
 front controller pattern
 . This 
 means that every request to a Yesod application enters at the same point and is 
 routed from there. As a contrast, in systems like PHP and ASP you usually create a 
 number of different files, and the web server automatically directs requests to the 
 relevant file.
  
 In addition, Yesod uses a declarative style for specifying routes. In our example 
 above, this looked like:
  
 mkYesod ""HelloWorld"" [parseRoutes| 
  
 / HomeR GET 
  
 |]
  
  
 mkYesod
  is a Template Haskell function, and 
 parseRoutes
  is a Quasi-
 Quoter.
  
 In English, all this means is: “In the HelloWorld application, create one route. I’d 
 like to call it 
 HomeR
 , it should listen for requests to 
 /
  (the root of the application), 
 and should answer 
 GET
  requests.” We call 
 HomeR
  a 
 resource
 , which is where the “R” 
 suffix comes from.
  
  
 The R suffix on resource names is simply convention, but it’s a fairly 
 universally followed convention. It makes it just a bit easier to read 
 and understand code.
  
 The 
 mkYesod
  TH function generates quite a bit of code here: a route data type, a 
 dispatch function, and a render function. We’ll look at this in more detail in the 
 routing chapter. But by using the 
 -ddump-splices
  GHC option, we can get an 
 immediate look at the generated code. A much cleaned up version of it is:
  
 instance RenderRoute HelloWorld where
  
  data Route HelloWorld = HomeR
  
   
  deriving (Show, Eq, Read)
  
  renderRoute HomeR = ([], [])
  
 instance YesodDispatch HelloWorld HelloWorld where
  
  
  yesodDispatch master sub toMaster app404 app405 method pieces =
  
  
  case dispatch pieces of
  
  
  
  
  Just f -> f
  
  
  
  
  
  master
  
  
  
  
  
  sub
  
  
  
  
  
  toMaster
  
  
  
  
  
  app404
  
  
  
  
  
  app405
  
  
  
  
  
  method
  
 16 | Chapter 3:Basics",NA
Handler Function,"So we have a route named 
 HomeR
 , and it responds to 
 GET
  requests. How do you 
 define your response? You write a 
 handler function
 . Yesod follows a standard 
 naming scheme for these functions: it’s the lower case method name (e.g., 
 GET
  
 becomes 
 get
 ) followed by the route name. In this case, the function name would be 
 getHomeR
 .
  
 Most of the code you write in Yesod lives in handler functions. This is where you 
 process user input, perform database queries, and create responses. In our simple 
 example, we create a response using the 
 defaultLayout
  function. This function wraps 
 up the content it’s given in your site’s template. By default, it produces an HTML file 
 with a doctype and 
 html
 , 
 head
 , and 
 body
  tags. As we’ll see in the Yesod typeclass 
 chapter, this function can be overridden to do much more.
  
 In our example, we pass 
 [whamlet|Hello World!|]
  to 
 defaultLayout
 . 
 whamlet
  is another 
 quasi-quoter. In this case, it converts Hamlet syntax into a Widget. Hamlet is the 
 default HTML templating engine in Yesod. Together with its siblings Cassius, 
 Lucius, and Julius, you can create HTML, CSS, and JavaScript in a fully type-safe and 
 compile-time-checked manner. We’ll see much more about this in the Shakespeare 
 chapter.
  
 Widgets are another cornerstone of Yesod. They allow you to create modular 
 compo-nents of a site consisting of HTML, CSS, and JavaScript and reuse them 
 throughout your site. We’ll get into more detail on them in the widgets chapter.",NA
The Foundation,"The word “HelloWorld” shows up a number of times in our example. Every Yesod 
 application has a 
 foundation
  data type. This data type must be an instance of the 
 Yesod typeclass, which provides a central place for declaring a number of different 
 settings controlling the execution of our application.
  
 In our case, this data type is pretty boring: it doesn’t contain any information. 
 Nonetheless, the foundation is central to how our example runs: it ties together the 
 routes with the instance declaration and lets it all be run. We’ll see throughout this 
 book that the foundation pops up in a whole bunch of places.
  
 But foundations don’t have to be boring: they can be used to store lots of useful 
 information, usually stuff that needs to be initialized at program launch and used 
 throughout. Some very common examples are:
  
 • A database connection pool
  
 • Settings loaded from a config file
  
 • An HTTP connection manager
  
  
 By the way, the word Yesod (
 יסוד
 ) means 
 foundation
  in Hebrew.",NA
Running,"Once again we mention 
 HelloWorld
  in our main function. Our foundation contains all 
 the information we need to route and respond to requests in our application; now 
 we just need to convert it into something that can run. A useful function for this in 
 Yesod is 
 warpDebug
 , which runs the Warp web server with debug output enabled on 
 the specified port (here, it’s 3000).
  
 One of the features of Yesod is that you aren’t tied down to a single deployment 
 strategy. Yesod is built on top of the Web Application Interface (WAI), allowing it to 
 run on FastCGI, SCGI, Warp, or even as a desktop application using the Webkit 
 library. We’ll discuss some of these options in the deployment chapter. And at the 
 end of this chapter, we will explain the development server.
  
 Warp is the premiere deployment option for Yesod. It is a lightweight, highly 
 efficient web server developed specifically for hosting Yesod. It is also used outside 
 of Yesod for other Haskell development (both framework and non-framework 
 applications), as well as a standard file server in a number of production 
 environments.
  
 18 | Chapter 3:Basics",NA
Resources and Type-Safe URLs,"In our hello world, we defined just a single resource (
 HomeR
 ). A web application is 
 usually much more exciting with more than one page on it. Let’s take a look:
  
 {-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
  
  
 TemplateHaskell, OverloadedStrings #-} 
  
 import Yesod
  
 data Links = Links
  
 mkYesod ""Links"" [parseRoutes| 
  
 / HomeR GET 
  
 /page1 Page1R GET 
  
 /page2 Page2R GET 
  
 |]
  
 instance Yesod Links
  
 getHomeR  = defaultLayout [whamlet|<a href=@{Page1R}>Go to page 1!|] 
 getPage1R = defaultLayout [whamlet|<a href=@{Page2R}>Go to page 2!|] 
 getPage2R = defaultLayout [whamlet|<a href=@{HomeR}>Go home!|]
  
 main = warpDebug 3000 Links
  
 Overall, this is very similar to Hello World. Our foundation is now 
 Links
  instead of 
 HelloWorld
 , and in addition to the 
 HomeR
  resource, we’ve added 
 Page1R
  and 
 Page2R
 . 
 As such, we’ve also added two more handler functions: 
 getPage1R
  and 
 getPage2R
 .
  
 The only truly new feature is inside the 
 whamlet
  quasi-quotation. We’ll delve into 
 syntax in the Shakespeare chapter, but we can see that:
  
 <a href=@{Page1R}>Go to page 1!
  
 creates a link to the 
 Page1R
  resource. The important thing to note here is that 
 Page1R
  is a data constructor. By making each resource a data constructor, we have a 
 feature called 
 type-safe URLs
 . Instead of splicing together strings to create URLs, we 
 simply create a plain old Haskell value. By using at-sign interpolation (
 @{...}
 ), Yesod 
 automatically renders those values to textual URLs before sending things off to the 
 user. We can see how this is implemented by looking again at the 
 -ddump-splices
  
 output:
  
 instance RenderRoute Links where
  
  
  data Route Links = HomeR | Page1R | Page2R
  
  
  deriving (Show, Eq, Read)
  
  renderRoute HomeR  = ([], [])
  
  renderRoute Page1R = ([""page1""], [])
  
  renderRoute Page2R = ([""page2""], [])
  
 In the 
 Route
  associated type for 
 Links
 , we have additional constructors for 
 Page1R
  
 and 
 Page2R
 . We also now have a better glimpse of the return values for 
 returnRoute
 . 
 The first part of the tuple gives the 
 path pieces
  for the given route. The second part 
 gives the query string parameters; for almost all use cases, this will be an empty 
 list.",NA
The Scaffolded Site,"Installing Yesod will give you both the Yesod library, as well as a 
 yesod
  executable. 
 This executable accepts a few commands, but the first one you’ll want to be 
 acquainted with is 
 yesod init
 . It will ask you some questions, and then generate a 
 folder containing the default 
 scaffolded site
 . Inside that folder, you can run 
 cabal 
 install --only-dependen cies
  to build any extra dependencies (such as your database 
 backends), and then 
 yesod devel
  to run your site.
  
 The scaffolded site gives you a lot of best practices out of the box, setting up files 
 and dependencies in a time-tested approach used by most production Yesod sites. 
 However, all this convenience can get in the way of actually learning Yesod. 
 Therefore, most of this book will avoid the scaffolding tool, and instead deal 
 directly with Yesod as a library.
  
 We will cover the structure of the scaffolded site in more detail later.",NA
Development Server,"One of the advantages interpreted languages have over compiled languages is fast 
 prototyping: you save changes to a file and hit refresh. If we want to make any 
 changes to our Yesod apps above, we’ll need to call 
 runhaskell
  from scratch, which 
 can be a bit tedious.
  
 Fortunately, there’s a solution to this: 
 yesod devel
  automatically rebuilds and 
 reloads your code for you. This can be a great way to develop your Yesod projects, 
 and when you’re ready to move to production, you still get to compile down to 
 incredibly efficient code. The Yesod scaffolding automatically sets things up for you. 
 This gives you the best of both worlds: rapid prototyping 
 and
  fast production code.
  
 It’s a little bit more involved to set up your code to be used by 
 yesod devel
 , so our 
 examples will just use 
 warpDebug
 . But when you’re ready to make your real world 
 information, 
 yesod devel
  will be waiting for you.
  
 20 | Chapter 3:Basics",NA
Summary,"Every Yesod application is built around a foundation data type. We associate some 
 resources with that data type and define some handler functions, and Yesod 
 handles all of the routing. These resources are also data constructors, which lets us 
 have type-safe URLs.
  
 By being built on top of WAI, Yesod applications can run with a number of different 
 backends. 
 warpDebug
  is an easy way to get started, as it’s included with Yesod. For 
 rapid development, you can use 
 yesod devel
 . And when you’re ready to move to 
 production, you have Warp as a high-performance option.
  
 When developing in Yesod, we get a number of choices for coding style: quasi-
 quota-tion or external files, 
 warpDebug
  or 
 yesod devel
 , and so on. The examples in 
 this book will tend toward using the choices that are easiest to copy and paste, but 
 the more powerful options will be available when you start building real Yesod 
 applications.
  
 Summary | 21",NA
CHAPTER 4,NA,NA
Shakespearean Templates,"Yesod uses the Shakespearean family of template languages as its standard 
 approach to HTML, CSS, and JavaScript creation. This language family shares some 
 common syntax, as well as overarching principles:
  
 • As little interference to the underlying language as possible, while providing 
 con-
  
 veniences where unobtrusive
  
 • Compile-time guarantees on well-formed content
  
 • Static type safety, greatly helping the prevention of 
 XSS (cross-site scripting)
  
 attacks
  
 • Automated checking of valid URLs, whenever possible, through 
 type-safe URLs
  
 There is nothing inherently tying Yesod to these languages, or the other way 
 around: each can be used independently of the other. This chapter will address 
 these template languages on their own, while the remainder of the book will use 
 them to enhance Yesod application development.",NA
Synopsis,"There are four main languages at play: Hamlet is an HTML templating language, 
 Julius is for JavaScript, and Cassius and Lucius are both for CSS. Hamlet and Cassius 
 are both whitespace-sensitive formats, using indentation to denote nesting. By 
 contrast, Lucius is a superset of CSS, keeping CSS’s braces for denoting nesting. 
 Julius is a simple pass-through language for producing JavaScript; the only added 
 feature is variable interpo-lation.",NA
Hamlet (HTML),"$doctype 5 
  
 <html>
  
  
  <head>
  
  
  
  <title>#{pageTitle} - My Site
  
  
  
  <link rel=stylesheet href=@{Stylesheet}>
  
  
 <body>
  
 23",NA
Cassius (CSS),"#myid
  
  
  color: #{red}
  
  
  font-size: #{bodyFontSize} 
  
 foo bar baz
  
  
  background-image: url(@{MyBackgroundR})",NA
Lucius (CSS),"section.blog {
  
  
  padding: 1em;
  
  
  border: 1px solid #000;
  
  
  h1 {
  
  
  
  color: #{headingColor};
  
  
  } 
  
 }",NA
Julius (JavaScript),"$(function(){
  
  
  $(""section.#{sectionClass}"").hide();
  
  
  $(""#mybutton"").click(function(){document.location = ""@{SomeRouteR}"";});
  
  ^{addBling} 
  
 });",NA
Types,"Before we jump into syntax, let’s take a look at the various types involved. We 
 mentioned in the introduction that types help protect us from XSS attacks. For 
 example, let’s say that we have an HTML template that should display someone’s 
 name; it might look like this:
  
 <p>Hello, my name is #{name}
  
  
 #{...}
  is how we do variable interpolation in Shakespeare.
  
 24 | Chapter 4:Shakespearean Templates",NA
Type-Safe URLs,"Possibly the most unique feature in Yesod is type-safe URLs, and the ability to use 
 them conveniently is provided directly by Shakespeare. Usage is nearly identical to 
 variable interpolation, we just use the at-sign (@) instead of the hash (#). We’ll 
 cover the syntax later; first, let’s clarify the intuition.
  
 Suppose we have an application with two routes: 
 http://example.com/profile/home
  
 is the homepage, and 
 http://example.com/display/time
  displays the current time. 
 And let’s",NA
Syntax,"All Shakespearean languages share the same interpolation syntax, and are able to 
 utilize type-safe URLs. They differ in the syntax specific for their target language 
 (HTML, CSS, or JavaScript).",NA
Hamlet Syntax,"Hamlet is the most sophisticated of the languages. Not only does it provide syntax 
 for generating HTML, it also allows for basic control structures: conditionals, 
 looping, and maybes.
  
 Tags
  
 Obviously tags will play an important part of any HTML template language. In 
 Hamlet, we try to stick very close to existing HTML syntax to make the language 
 more comfortable. However, instead of using closing tags to denote nesting, we use 
 inden-tation. So something like this in HTML:
  
 <body> 
  
 <p>Some paragraph.</p> 
  
 <ul> 
  
 <li>Item 1</li> 
  
 <li>Item 2</li> 
  
 </ul> 
  
 </body>
  
 would be
  
 <body>
  
  
  <p>Some paragraph.
  
  <ul>
  
  <li>Item 1
  
  <li>Item 2
  
 In general, we find this to be easier to follow than HTML once you get accustomed 
 to it. The only tricky part comes with dealing with whitespace before and after tags. 
 For example, let’s say you want to create the HTML
  
 Syntax | 27",NA
Cassius Syntax,"Cassius is the original CSS template language. It uses simple whitespace rules to 
 delimit blocks, making braces and semicolons unnecessary. It supports both 
 variable and URL interpolation, but not embedding. The syntax is very 
 straightforward:
  
 Syntax | 31",NA
Lucius Syntax,"While Cassius uses a modified, whitespace-sensitive syntax for CSS, Lucius is true to 
 the original. You can take any CSS file out there and it will be a valid Lucius file. 
 There are, however, a few additions to Lucius:
  
 • Like Cassius, we allow both variable and URL interpolation.
  
 • CSS blocks are allowed to nest.
  
 • You can declare variables in your templates.
  
 Starting with the second point: let’s say you want to have some special styling for 
 some tags within your 
 article
 . In plain ol’ CSS, you’d have to write:
  
 article code { background-color: grey; } 
  
 article p { text-indent: 2em; } 
  
 article a { text-decoration: none; }
  
 In this case, there aren’t that many clauses, but having to type out article each time 
 is still a bit of a nuisance. Imagine if you had a dozen or so of these. Not the worst 
 thing in the world, but a bit of an annoyance. Lucius helps you out here:
  
 article {
  
  
  code { background-color: grey; }
  
  
  p { text-indent: 2em; }
  
  
  a { text-decoration: none; } 
  
 }
  
 Having Lucius variables allows you to avoid repeating yourself. A simple example 
 would be to define a commonly used color:
  
 @textcolor: #ccc; /* just because we hate our users */ body { 
 color: #{textcolor} } 
  
 a:link, a:visited { color: #{textcolor} }
  
 Other than that, Lucius is identical to CSS.",NA
Julius Syntax,"Julius is the simplest of the languages discussed here. In fact, some might even say 
 it’s really just JavaScript. Julius allows the three forms of interpolation we’ve 
 mentioned so far, and otherwise applies no transformations to your content.
  
  
 If you use Julius with the scaffolded Yesod site, you may notice that 
 your JavaScript is automatically minified. This is not a feature of 
 Julius; in-stead, Yesod uses the 
 hjsmin
  package to minify Julius 
 output.
  
 32 | Chapter 4:Shakespearean Templates",NA
Calling Shakespeare,"The question of course arises at some point: how do I actually use this stuff? There 
 are three different ways to call out to Shakespeare from your Haskell code:
  
 Quasiquotes 
  
 Quasiquotes allow you to embed arbitrary content within your Haskell, and for 
 it to be converted into Haskell code at compile time.
  
 External file 
  
 In this case, the template code is in a separate file which is referenced via 
 Template Haskell.
  
 Reload mode 
  
 Both of the above modes require a full recompile to see any changes. In reload 
 mode, your template is kept in a separate file and referenced via Template 
 Haskell. But at runtime, the external file is reparsed from scratch each time.
  
  
 Reload mode is not available for Hamlet, only for Cassius, 
 Lucius, and Julius. There are too many sophisticated features in 
 Hamlet that rely directly on the Haskell compiler and could not 
 feasibly be reimplemented at runtime.
  
 One of the first two approaches should be used in production. They both embed the 
 entirety of the template in the final executable, simplifying deployment and 
 increasing performance. The advantage of the quasiquoter is the simplicity: 
 everything stays in a single file. For short templates, this can be a very good fit. 
 However, in general, the external file approach is recommended because:
  
 • It follows nicely in the tradition of separate logic from presentation.
  
 • You can easily switch between external file and debug mode with some simple 
 CPP macros, meaning you can keep rapid development and still achieve high 
 perfor-mance in production.
  
 Since these are special QuasiQuoters and Template Haskell functions, you need to 
 be sure to enable the appropriate language extensions and use correct syntax. You 
 can see a simple example of each in the examples.
  
 Example 4-1. Quasiquoter
  
 {-# LANGUAGE OverloadedStrings #-} -- we're using Text below {-# 
 LANGUAGE QuasiQuotes #-} 
  
 import Text.Hamlet (HtmlUrl, hamlet) 
  
 import Data.Text (Text) 
  
 import Text.Blaze.Renderer.String (renderHtml)
  
 data MyRoute = Home | Time | Stylesheet
  
 Calling Shakespeare | 33",NA
Alternate Hamlet Types,"So far, we’ve seen how to generate an 
 HtmlUrl
  value from Hamlet, which is a piece of 
 HTML with embedded type-safe URLs. There are currently three other values we 
 can generate using Hamlet: plain HTML, HTML with URLs 
 and
  internationalized 
 messages, and widgets. That last one will be covered in the widgets chapter.
  
 To generate plain HTML without any embedded URLs, we use “simplified Hamlet”. 
 There are a few changes:
  
 • We use a different set of functions, prefixed with an “s”. So the quasiquoter is 
 shamlet
  and the external file function is 
 shamletFile
 . How we pronounce those is 
 still up for debate.
  
 • No URL interpolation is allowed. Doing so will result in a compile-time error.
  
 • Embedding (the caret-interpolator) no longer allows arbitrary 
 HtmlUrl
  values. 
 The rule is that the embedded value must have the same type as the template 
 itself, so in this case it must be 
 Html
 . That means that for 
 shamlet
 , embedding 
 can be com-pletely replaced with normal variable interpolation (with a hash).
  
 Dealing with internationalization (i18n) in Hamlet is a bit complicated. Hamlet 
 supports i18n via a message data type, very similar in concept and implementation 
 to a type-safe URL. As a motivating example, let’s say we want to have an 
 application that tells you hello and how many apples you have eaten. We could 
 represent those messages with a data type.
  
 data Msg = Hello | Apples Int
  
 Next, we would want to be able to convert that into something human-readable, so 
 we define some render functions:
  
 renderEnglish :: Msg -> Text 
  
 renderEnglish Hello = ""Hello"" 
  
 renderEnglish (Apples 0) = ""You did not buy any apples."" 
  
 renderEnglish (Apples 1) = ""You bought 1 apple."" 
  
 renderEnglish (Apples i) = T.concat [""You bought "", T.pack $ show i, "" apples.""]
  
 Now we want to interpolate those Msg values directly in the template. For that, we 
 use underscore interpolation.
  
 $doctype 5 
  
 <html>
  
  
  <head>
  
  
  
  <title>i18n
  
  
  <body>
  
  
  
  <h1>_{Hello}
  
  
  
  <p>_{Apples count}
  
 Calling Shakespeare | 35",NA
Other Shakespeare,"In addition to HTML, CSS, and JavaScript helpers, there is also some more general-
 purpose Shakespeare available. 
 shakespeare-text
  provides a simple way to create 
 interpolated strings, much like people are accustomed to in scripting languages like 
 Ruby and Python. This package’s utility is definitely not limited to Yesod.
  
 {-# LANGUAGE QuasiQuotes, OverloadedStrings #-} 
 import Text.Shakespeare.Text 
  
 import qualified Data.Text.Lazy.IO as TLIO 
  
 import Data.Text (Text) 
  
 import Control.Monad (forM_)
  
 data Item = Item
  
  { itemName :: Text
  
  , itemQty :: Int
  
  }
  
 items :: [Item] 
  
 items =
  
  
  [ Item ""apples"" 5
  
  
  , Item ""bananas"" 10
  
  
  ]
  
 main :: IO () 
  
 main = forM_ items $ \item -> TLIO.putStrLn
  
  
  [lt|You have #{show $ itemQty item} #{itemName item}.|]
  
 Some quick points about this simple example:
  
 • Notice that we have three different textual data types involved (
 String
 , strict 
  
 Text
  and lazy 
 Text
 ). They all play together well.
  
 • We use a quasiquoter named 
 lt
 , which generates lazy text. There is also 
 st
 .
  
 • Also, there are longer names for these quasiquoters (
 ltext
  and 
 stext
 ).",NA
General Recommendations,"Here are some general hints from the Yesod community on how to get the most out 
 of Shakespeare.
  
 • For actual sites, use external files. For libraries, it’s OK to use quasiquoters, 
  
 assuming they aren’t too long.
  
 • Patrick Brisbin has put together a 
 Vim code highlighter
  that can help out im-
  
 mensely.
  
 • You should almost always start Hamlet tags on their own line instead of 
 embedding start/end tags after an existing tag. The only exception to this is the 
 occasional 
 <i>
  or 
 <b>
  tag inside a large block of text.
  
 General Recommendations | 37",NA
CHAPTER 5,NA,NA
Widgets,"One of the challenges in web development is that we have to coordinate three 
 different client-side technologies: HTML, CSS, and JavaScript. Worse still, we have 
 to place these components in different locations on the page: CSS in a style tag in 
 the head, JavaScript in a script tag in the head, and HTML in the body. And never 
 mind if you want to put your CSS and JavaScript in separate files!
  
 In practice, this works out fairly nicely when building a single page, because we can 
 separate our structure (HTML), style (CSS), and logic (JavaScript). But when we 
 want to build modular pieces of code that can be easily composed, it can be a 
 headache to coordinate all three pieces separately. Widgets are Yesod’s solution to 
 the problem.
  
 They also help with the issue of including libraries, such as jQuery, one time only.
  
 Our four template languages—Hamlet, Cassius, Lucius and Julius—provide the raw 
 tools for constructing your output. Widgets provide the glue that allows them to 
 work together seamlessly.",NA
Synopsis,"getRootR = defaultLayout $ do
  
   
  setTitle ""My Page Title""
  
   
  toWidget [lucius| h1 { color: green; } |]
  
  
  addScriptRemote ""https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js""
   
  
 toWidget [julius| 
  
 $(function() {
  
   
  $(""h1"").click(function(){ alert(""You clicked on the heading!""); }); 
  
 }); 
  
 |]
  
   
  toWidgetHead [hamlet| <meta name=keywords content=""some sample keywords"">|]
   
  
 toWidget [hamlet| <h1>Here's one way of including content |]
  
   
  [whamlet| <h2>Here's another |]
  
   
  toWidgetBody [julius| alert(""This is included in the body itself""); |]
  
 This produces the following HTML (indentation added):
  
 <!DOCTYPE html> 
  
 <html>
  
 39",NA
What’s in a Widget?,"At a very superficial level, an HTML document is just a bunch of nested tags. This is 
 the approach most HTML generation tools take: you simply define hierarchies of 
 tags and are done with it. But let’s imagine that I want to write a component of a 
 page for displaying the navbar. I want this to be “plug and play”: I simply call the 
 function at the right time, and the navbar is inserted at the correct point in the 
 hierarchy.
  
 This is where our superficial HTML generation breaks down. Our navbar likely 
 consists of some CSS and JavaScript in addition to HTML. By the time we call the 
 navbar func-tion, we have already rendered the 
 <head>
  tag, so it is too late to add a 
 new 
 <style>
  tag for our CSS declarations. Under normal strategies, we would need 
 to break up our navbar function into three parts: HTML, CSS, and JavaScript, and 
 make sure that we always call all three pieces.
  
 Widgets take a different approach. Instead of viewing an HTML document as a
  
 monolithic tree of tags, widgets see a number of distinct components in the page. In 
 particular:
  
 • The title
  
 • External stylesheets
  
 • External JavaScript
  
 • CSS declarations
  
 • JavaScript code
  
 • Arbitrary 
 <head>
  content
  
 • Arbitrary 
 <body>
  content
  
 Different components have different semantics. For example, there can only be one 
 title, but there can be multiple external scripts and stylesheets. However, those 
 external
  
 40 | Chapter 5:Widgets",NA
Constructing Widgets,"In order to use widgets, you’ll obviously need to be able to get your hands on them. 
 The most common way will be via the 
 ToWidget
  typeclass, and its 
 toWidget
  method. 
 This allows you to convert your Shakespearean templates directly to a 
 Widget
 : 
 Hamlet code will appear in the body, Julius scripts inside a 
 <script>
  tag in the head, 
 and Cassius and Lucius in a 
 <style>
  tag.
  
  
 You can actually override the default behavior and have the script 
 and style code appear in a separate file. The scaffolded site provides 
 this for you automatically. Additionally, we’ll see in the Yesod 
 typeclass chapter how to turn on asynchronous script loading, 
 which will place your script
  
 content at the end of the body.
  
 But what if you want to add some 
 <meta>
  tags, which need to appear in the head? 
 Or if you want some JavaScript to appear in the body instead of the head? For these 
 pur-poses, Yesod provides two additional type classes: 
 ToWidgetHead
  and 
 ToWidgetBody
 . These work exactly as they seem they should.
  
 In addition, there are a number of other functions for creating specific kinds of 
 Widgets:
  
 setTitle 
  
  
 Turns some HTML into the page title.
  
 addCassiusMedia, addLuciusMedia 
  
 Works the same as toWidget, but takes an additional parameter to indicate 
 what kind of media this applies to. Useful for creating print stylesheets, for 
 instance.
  
 addStylesheet 
  
  
 Adds a reference, via a 
 <link>
  tag, to an external stylesheet. Takes a type-safe 
 URL.
  
 addStylesheetRemote 
  
 Same as 
 addStylesheet
 , but takes a normal URL. Useful for referring to files 
 hosted on a CDN, like Google’s jQuery UI CSS files.
  
 addScript 
  
  
 Adds a reference, via a 
 <script>
  tag, to an external script. Takes a type-safe URL.",NA
Combining Widgets,"The whole idea of widgets is to increase composability. You can take these 
 individual pieces of HTML, CSS, and JavaScript, combine them together into 
 something more complicated, and then combine these larger entities into complete 
 pages. This all works naturally through the 
 Monad
  instance of 
 Widget
 , meaning you 
 can use do-notation to compose pieces together.
  
 Example 5-1. Combining Widgets
  
 myWidget1 = do
  
  toWidget [hamlet|<h1>My Title|]
  
  toWidget [lucius|h1 { color: green } |]
  
 myWidget2 = do
  
  setTitle ""My Page Title""
  
  addScriptRemote ""http://www.example.com/script.js""
  
 myWidget = do
  
  
 myWidget1
  
  
 myWidget2
  
 -- or, if you want 
  
 myWidget' = myWidget1 >> myWidget2
  
  
 If you’re so inclined, there’s also a 
 Monoid
  instance of 
 Widget
 , 
 meaning you can use 
 mconcat
  or a 
 Writer
  monad to build things up. 
 In my expe-rience, it’s easiest and most natural to just use do-
 notation.",NA
Generate IDs,"If we’re really going for true code reuse here, we’re eventually going to run into 
 name conflicts. Let’s say that there are two helper libraries that both use the class 
 name “foo”to affect styling. We want to avoid such a possibility. Therefore, we have 
 the 
 newI dent
  function. This function automatically generates a word that is unique 
 for this handler.
  
 Example 5-2. Using newIdent
  
 getRootR = defaultLayout $ do
  
  headerClass <- lift newIdent
  
  toWidget [hamlet|<h1 .#{headerClass}>My Header|]
  
  toWidget [lucius| .#{headerClass} { color: green; } |]
  
 42 | Chapter 5:Widgets",NA
whamlet,"Let’s say you’ve got a fairly standard Hamlet template that embeds another Hamlet 
 template to represent the footer:
  
 page = [hamlet| 
  
 <p>This is my page. I hope you enjoyed it.
  
 ^{footer} 
  
 |]
  
 footer = [hamlet| 
  
 <footer>
  
  
  <p>That's all folks!
  
 |]
  
 That works fine if the footer is plain old HTML, but what if we want to add some 
 style? Well, we can easily spice up the footer by turning it into a Widget:
  
 footer = do
  
  
  toWidget [lucius| footer { font-weight: bold; text-align: center } |]
  
  
 toWidget [hamlet| 
  
 <footer>
  
  
  <p>That's all folks!
  
 |]
  
 But now we’ve got a problem: a Hamlet template can only embed another Hamlet 
 template; it knows nothing about a Widget. This is where 
 whamlet
  comes in. It takes 
 exactly the same syntax as normal Hamlet, and variable (#{...}) and URL (@{...}) 
 interpolation are unchanged. But embedding (^{...}) takes a 
 Widget
 , and the final 
 result is a 
 Widget
 . To use it, we can just do:
  
 page = [whamlet| 
  
 <p>This is my page. I hope you enjoyed it.
  
 ^{footer} 
  
 |]
  
 There is also 
 whamletFile
 , if you would prefer to keep your template in a separate 
 file.
  
  
 The scaffolded site has an even more convenient function, 
 widgetFile
 , 
 which will also include your Lucius, Cassius, and Julius files 
 automat-ically. We’ll cover that in the scaffolding chapter.
  
 whamlet | 43",NA
Types,"You may have noticed that I’ve been avoiding type signatures so far. That’s because 
 there’s a little bit of a complication involved here. At the most basic level, all you 
 need to know is that there’s a type synonym called 
 Widget
  which you will almost 
 always use. The technical details follow, but don’t worry if it’s a little hazy.
  
 There isn’t actually a 
 Widget
  type defined in the Yesod libraries, since the exact 
 meaning of it changes between sites. Instead, we have a more general type 
 GWidget 
 sub master a
 . The first two parameters give the sub and master foundation types, 
 respectively. The final parameter is the contained value, just like any 
 Monad
  has.
  
 So what’s the deal with that sub/master stuff? Well, when you’re writing some 
 reusable code, such as a CRUD application, you can write it as a subsite that can be 
 embedded within any other Yesod application. In such a case, we need to keep 
 track of information for both the sub and master sites. The simplest example is for 
 the type-safe URLs: Yesod needs to know how to take a route for your CRUD subsite 
 and turn it into a route for the master site so that it can be properly rendered.
  
 However, that sub/master distinction only ever matters when you’re interacting 
 with subsites. When you’re writing your standard response code, you’re dealing 
 with just your application, and so the sub and master sites will be the same. Since 
 this is the most common case, the scaffolded site declares a type synonym to help 
 you out. Let’s say your foundation type is MyCoolApp, it will define 
 type Widget = 
 GWidget MyCoolApp MyCoolApp ()
 . Therefore, we can get some very user-friendly 
 type signatures on our widgets:
  
 footer :: Widget 
  
 footer = do
  
  
  toWidget [lucius| footer { font-weight: bold; text-align: center } |]
  
  
 toWidget [hamlet| 
  
 <footer>
  
  
  <p>That's all folks!
  
 |]
  
 page :: Widget 
  
 page = [whamlet| 
  
 <p>This is my page. I hope you enjoyed it.
  
 ^{footer} 
  
 |]
  
 If you’ve been paying close attention, you might be confused. We used 
 lift
  on 
 Widget
  
 in the ID generation example above, but 
 GWidget
  isn’t actually a monad trans-
 former. What’s going on here? Well, in older versions of Yesod, it 
 was
  a transformer 
 around the 
 Handler
  type. Unfortunately, this led to difficult-to-parse error 
 messages. As a result, 
 GWidget
  is now a 
 newtype
  wrapper that hides away its 
 monad-transformer essence. But we still want to be able to 
 lift
  functions from the 
 inner 
 Handler
  monad.
  
 To solve this, Yesod provides an alternate, more general 
 lift
  function that works for 
 both standard 
 MonadTrans
  instances, and special 
 newtype
  wrappers like 
 GWidget
 . As 
 a",NA
Using Widgets,"It’s all well and good that we have these beautiful Widget data types, but how 
 exactly do we turn them into something the user can interact with? The most 
 commonly used function is 
 defaultLayout
 , which essentially has the type signature 
 Widget -> Handler RepHtml
 . (I say “essentially” because of the whole 
 GHandler
  issue.) 
 RepHtml
  is a data type containing some raw HTML output ready to be sent over the 
 wire.
  
 defaultLayout
  is actually a typeclass method, which can be overridden for each 
 application. This is how Yesod apps are themed. So we’re still left with the question: 
 when we’re inside 
 defaultLayout
 , how do we unwrap a 
 Widget
 ? The answer is 
 widget 
 ToPageContent
 . Let’s look at some (simplified) types:
  
 widgetToPageContent :: Widget -> Handler (PageContent url) data 
 PageContent url = PageContent
  
  
  { pageTitle :: Html
  
  
  , pageHead :: HtmlUrl url
  
  
  , pageBody :: HtmlUrl url
  
  
  }
  
 This is getting closer to what we need. We now have direct access to the HTML 
 making up the head and body, as well as the title. At this point, we can use Hamlet 
 to combine them all together into a single document, along with our site layout, and 
 we use 
 ham letToRepHtml
  to render that Hamlet result into actual HTML that’s ready 
 to be shown to the user. The next figure demonstrates this process.
  
 Example 5-3. Using widgetToPageContent
  
 myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml 
 myLayout widget = do
  
  
  pc <- widgetToPageContent widget
  
  
  hamletToRepHtml [hamlet| 
  
 $doctype 5 
  
 <html>
  
  
  <head>
  
  
  
  <title>#{pageTitle pc}
  
  
  
  <meta charset=utf-8>
  
  
  
  <style>body { font-family: verdana }
  
  
  
  ^{pageHead pc}
  
  
  <body>
  
  
  
  <article>
  
  
  
  
  ^{pageBody pc} 
  
 |]
  
 Using Widgets | 45",NA
Summary,"The basic building block of each page is a widget. Individual snippets of HTML, CSS, 
 and JavaScript can be turned into widgets via the polymorphic 
 toWidget
  function. 
 Using do-notation, you can combine these individual widgets into larger widgets, 
 eventually containing all the content of your page.
  
 46 | Chapter 5:Widgets",NA
CHAPTER 6,NA,NA
Yesod Typeclass,"Every one of our Yesod applications requires an instance of the 
 Yesod
  typeclass. So 
 far, we’ve only seen 
 defaultLayout
 . In this chapter, we’ll explore the meaning of 
 many of the methods of the 
 Yesod
  typeclass.
  
 The 
 Yesod
  typeclass gives us a central place for defining settings for our application. 
 Everything else has a default definition that is usually the right thing. But in order 
 to build a powerful, customized application, you’ll usually end up wanting to 
 override at least a few of these methods.",NA
Rendering and Parsing URLs,"We’ve already mentioned how Yesod is able to automatically render type-safe URLs 
 into a textual URL that can be inserted into an HTML page. Let’s say we have a route 
 definition that looks like:
  
 mkYesod ""MyApp"" [parseRoutes| 
  
 /some/path SomePathR GET 
  
 ]
  
 If we place 
 SomePathR
  into a hamlet template, how does Yesod render it? Yesod 
 always tries to construct 
 absolute
  URLs. This is especially useful once we start 
 creating XML sitemaps and Atom feeds, or sending emails. But in order to construct 
 an absolute URL, we need to know the domain name of the application.
  
 You might think we could get that information from the user’s request, but we still 
 need to deal with ports. And even if we get the port number from the request, are 
 we using HTTP or HTTPS? And even if you know 
 that
 , such an approach would 
 mean that different URLs would be generated depending on how the user 
 submitted a re-quest. For example, we would generate different URLs depending on 
 whether the user connected to “example.com” or “www.example.com”. For Search 
 Engine Optimization, we want to be able to consolidate on a single canonical URL.
  
 And finally, Yesod doesn’t make any assumption about 
 where
  you host your 
 application. For example, I may have a mostly static site 
 (http://static.example.com/),
  
 49",NA
joinPath,"In order to convert a type-safe URL into a text value, Yesod uses two helper 
 functions. The first is the 
 renderRoute
  method of the 
 RenderRoute
  typeclass. Every 
 type-safe URL is an instance of this typeclass. 
 renderRoute
  converts a value into a 
 list of path pieces. For example, our 
 SomePathR
  from above would be converted into 
 [""some"", ""path""]
 .
  
  
 Actually, 
 renderRoute
  produces both the path pieces and a list of 
 query-string parameters. The default instances of 
 renderRoute
  
 always provide an empty list of query string parameters. However, 
 it is possible to over-ride this. One notable case is the static subsite, 
 which puts a hash of the
  
 file contents in the query string for caching purposes.
  
 The other function is the 
 joinPath
  method of the Yesod typeclass. This function takes 
 four arguments: the foundation value, the application root, a list of path segments, 
 and a list of query string parameters, and returns a textual URL. The default 
 implementation",NA
cleanPath,"The flip side to 
 joinPath
  is 
 cleanPath
 . Let’s look at how it gets used in the dispatch 
 process:
  
 1. The path info requested by the user is split into a series of path pieces.
  
 2. We pass the path pieces to the 
 cleanPath
  function.
  
 3. If 
 cleanPath
  indicates a redirect (a 
 Left
  response), then a 301 response is sent to 
 the client. This is used to force canonical URLs (e.g., remove extra slashes).
  
 4. Otherwise, we try to dispatch using the response from 
 cleanPath
  (a 
 Right
 ). If this 
 works, we return a response. Otherwise, we return a 404.
  
 This combination allows subsites to retain full control of how their URLs appear, 
 yet allows master sites to have modified URLs. As a simple example, let’s see how 
 we could modify Yesod to always produce trailing slashes on URLs:
  
 {-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses, TemplateHaskell, 
 OverloadedStrings #-} 
  
 import Yesod 
  
 import Network.HTTP.Types (encodePath) 
  
 import Blaze.ByteString.Builder.Char.Utf8 (fromText) 
  
 import qualified Data.Text as T 
  
 import qualified Data.Text.Encoding as TE 
  
 import Control.Arrow ((***)) 
  
 import Data.Monoid (mappend)
  
 data Slash = Slash
  
 mkYesod ""Slash"" [parseRoutes| 
  
 / RootR GET 
  
 /foo FooR GET 
  
 |]
  
 instance Yesod Slash where
  
  
  joinPath _ ar pieces' qs' =
  
  
   
  fromText ar `mappend` encodePath pieces qs
  
  
  where
  
  
   
  qs = map (TE.encodeUtf8 *** go) qs'
  
  
   
  go """" = Nothing
  
  
   
  go x = Just $ TE.encodeUtf8 x
  
  
   
  pieces = pieces' ++ [""""]
  
  -- We want to keep canonical URLs. Therefore, if the URL is missing a -- trailing slash, 
 redirect. But the empty set of pieces always stays the
  
 Rendering and Parsing URLs | 51",NA
defaultLayout,"Most websites like to apply some general template to all of their pages. 
 defaultLay 
 out
  is the recommended approach for this. While you could just as easily define 
 your own function and call that instead, when you override 
 defaultLayout
  all of the 
 Yesod-generated pages (error pages, authentication pages) automatically get this 
 style.
  
 Overriding is very straightforward: we use 
 widgetToPageContent
  to convert a 
 Widget
  
 to a title, head tags, and body tags, and then use 
 hamletToRepHtml
  to convert a 
 Hamlet template into a 
 RepHtml
 . We can even add extra widget components, like a 
 Lucius template, from within 
 defaultLayout
 . An example should make this all clear:
  
 52 | Chapter 6:Yesod Typeclass",NA
getMessage,"Even though we haven’t covered sessions yet, I’d like to mention 
 getMessage
  here. A 
 common pattern in web development is setting a message in one handler and 
 displaying it in another. For example, if a user 
 POST
 s a form, you may want to 
 redirect him/her to another page along with a “Form submission complete” 
 message.
  
  
 This is commonly known as 
 Post/Redirect/Get
 .
  
 To facilitate this, Yesod comes built in with a pair of functions: 
 setMessage
  sets a
  
 message in the user session, and 
 getMessage
  retrieves the message (and clears it, so 
 it doesn’t appear a second time). It’s recommended that you put the result of 
 getMes 
 sage
  into your 
 defaultLayout
 . For example:
  
  
  defaultLayout contents = do
  
  
  
  PageContent title headTags bodyTags <- widgetToPageContent contents
  
  
  mmsg <- getMessage
  
  
  
  hamletToRepHtml [hamlet| 
  
 $doctype 5
  
 <html>
  
  
  <head>
  
  
  
  <title>#{title}
  
  
  
  ^{headTags}
  
  
  <body>
  
  
  
  $maybe msg <- mmsg
  
 defaultLayout | 53",NA
Custom Error Pages,"One of the marks of a professional website is a properly designed error page. Yesod 
 gets you a long way there by automatically using your 
 defaultLayout
  for displaying 
 error pages. But sometimes, you’ll want to go even further. For this, you’ll want to 
 override the 
 errorHandler
  method:
  
  
  errorHandler NotFound = fmap chooseRep $ defaultLayout $ do
  
  
  
  setTitle ""Request page not located""
  
  
  
  toWidget [hamlet| 
  
 <h1>Not Found 
  
 <p>We apologize for the inconvenience, but the requested page could not be located.
  
 |]
  
  
  errorHandler other = defaultErrorHandler other
  
 Here we specify a custom 404 error page. We can also use the 
 defaultErrorHandler 
 when we don’t want to write a custom handler for each error type. Due to type 
 constraints, we need to start off our methods with 
 fmap chooseRep
 , but otherwise 
 you can write a typical handler function.
  
 In fact, you could even use special responses like redirects:
  
  errorHandler NotFound = redirect RootR
  
  errorHandler other = defaultErrorHandler other
  
  
 Even though you 
 can
  do this, I don’t actually recommend such 
 practices. A 404 should be a 404.",NA
External CSS and JavaScript,"The functionality described here is automatically included in the 
 scaf-folded site, so you don’t need to worry about implementing this 
 your-self.
  
 One of the most powerful, and most intimidating, methods in the Yesod typeclass is 
 addStaticContent
 . Remember that a Widget consists of multiple components, 
 including CSS and JavaScript. How exactly does that CSS/JS arrive in the user’s 
 browser? By default, they are served in the 
 <head>
  of the page, inside 
 <style>
  and 
 <script>
  tags, respectively.
  
 54 | Chapter 6:Yesod Typeclass",NA
Smarter Static Files,"Google recommends an important optimization: 
 serve static files from a separate 
 do-main
 . The advantage to this approach is that cookies set on your main domain 
 are not sent when retrieving static files, thus saving on a bit of bandwidth.
  
 Smarter Static Files | 55",NA
Authentication/Authorization,"For simple applications, checking permissions inside each handler function can be a 
 simple, convenient approach. However, it doesn’t scale well. Eventually, you’re 
 going to want to have a more declarative approach. Many systems out there define 
 ACLs, special config files, and a lot of other hocus-pocus. In Yesod, it’s just plain old 
 Haskell.
  
 There are three methods involved:
  
 isWriteRequest 
  
 Determine if the current request is a “read” or “write” operations. By default, 
 Yesod follows RESTful principles, and assumes 
 GET
 , 
 HEAD
 , 
 OPTIONS
 , and 
 TRACE
  
 requests are read-only, while all others are can write.
  
 isAuthorized 
  
 Takes a route (i.e., type-safe URL) and a boolean indicating whether or not the 
 request is a write request. It returns an 
 AuthResult
 , which can have one of three 
 values:
  
 •
  Authorized
  
 •
  AuthenticationRequired
  
  
 •
  Unauthorized 
  
 By default, it returns 
 Authorized
  for all requests.
  
 authRoute 
  
 If 
 isAuthorized
  returns 
 AuthenticationRequired
 , then redirect to the given route. If 
 no route is provided (the default), return a 403 “Permission Denied” message.
  
 These methods tie in nicely with the 
 yesod-auth
  package, which is used by the 
 scaffolded site to provide a number of authentication options, such as OpenID, 
 Brows-erID, email, username, and Twitter. We’ll cover more concrete examples in 
 the auth chapter.
  
 56 | Chapter 6:Yesod Typeclass",NA
Some Simple Settings,"Not everything in the Yesod typeclass is complicated. Some methods are simple 
 func-tions. Let’s just go through the list:
  
 encryptKey 
  
 Yesod uses client-side sessions, which are stored in encrypted, 
 cryptographically-hashed cookies. Well, as long as you provide an encryption 
 key. If this function returns Nothing, then sessions are disabled. This can be a 
 useful optimization on sites that don’t need session facilities, as it avoids an 
 encrypt/decrypt pair on each request.
  
  
 The combination of encryption and hashing guarantees two 
 prop-erties: the session payload is tamper-proof, and is 
 opaque. Encryp-tion without hashing would allow a user to 
 randomly change the cookie data and still have it accepted by 
 the server, while hashing
  
 without encryption would allow inspection of the data.
  
 clientSessionDuration 
  
  
 How long a session should last for. By default, this is two 
 hours.
  
 sessionIpAddress 
  
 By default, sessions are tied to an individual IP address. If your users are sitting 
 behind a proxy server, this can cause trouble when their IP suddenly changes. 
 This setting lets you disable this security feature.
  
 cookiePath 
  
 What paths within your current domain to set cookies for. The default is “/”, 
 and will almost always be correct. One exception might be when you’re serving 
 from a subpath within a domain (like our wiki example above).
  
 maximumContentLength 
  
 To prevent Denial of Server (DoS) attacks, Yesod will limit the size of request 
 bodies. Some of the time, you’ll want to bump that limit for some routes (e.g., a 
 file upload page). This is where you’d do that.
  
 yepnopeJs 
  
 You can specify the location of the 
 yepnope
  JavaScript library. If this is given, 
 then yepnope will be used to asynchronously load all of the JavaScript on your 
 page.",NA
Summary,"The Yesod typeclass has a number of overrideable methods that allow you to 
 configure your application. They are all optional, and provide sensible defaults. By 
 using built-in Yesod constructs like 
 defaultLayout
  and 
 getMessage
 , you’ll get a 
 consistent look-",NA
CHAPTER 7,NA,NA
Routing and Handlers,"If we look at Yesod as a Model-View-Controller framework, routing and handlers 
 make up the controller. For contrast, let’s describe two other routing approaches 
 used in other web development environments:
  
 • Dispatch based on file name. This is how PHP and ASP work, for example.
  
 • Have a centralized routing function that parses routes based on regular 
  
 expressions. Django and Rails follow this approach.
  
 Yesod is closer in principle to the latter technique. Even so, there are significant 
 differences. Instead of using regular expressions, Yesod matches on pieces of a 
 route. Instead of having a one-way route-to-handler mapping, Yesod has an 
 intermediate data type (called the route data type, or a type-safe URL) and creates 
 two-way conversion functions.
  
 Coding this more advanced system manually is tedious and error prone. Therefore, 
 Yesod defines a Domain Specific Language (DSL) for specifying routes, and provides 
 Template Haskell functions to convert this DSL to Haskell code. This chapter will 
 explain the syntax of the routing declarations, give you a glimpse of what code is 
 generated for you, and explain the interaction between routing and handler 
 functions.",NA
Route Syntax,"Instead of trying to shoe-horn route declarations into an existing syntax, Yesod’s 
 approach is to use a simplified syntax designed just for routes. This has the 
 advantage of making the code not only easy to write, but simple enough for 
 someone with no Yesod experience to read and understand the sitemap of your 
 application.
  
 A basic example of this syntax is:
  
 /             RootR     GET 
  
 /blog         BlogR     GET POST 
  
 /blog/#BlogId BlogPostR GET POST
  
 /static       StaticR   Static getStatic",NA
Pieces,"One of the first thing Yesod does when it gets a request is to split up the requested 
 path into pieces. The pieces are tokenized at all forward slashes. For example:
  
 toPieces ""/"" = [] 
  
 toPieces ""/foo/bar/baz/"" = [""foo"", ""bar"", ""baz"", """"]
  
 You may notice that there are some funny things going on with trailing slashes, or 
 double slashes (“/foo//bar//”), or a few other things. Yesod believes in having 
 canonical URLs
 ; if someone requests a URL with a trailing slash, or with a double 
 slash, they automatically get a redirect to the canonical version. This ensures you 
 have one URL for one resource, and can help with your search rankings.
  
 What this means for you is that you needn’t concern yourself with the exact 
 structure of your URLs: you can safely think about pieces of a path, and Yesod 
 automatically handles intercalating the slashes and escaping problematic 
 characters.
  
 If, by the way, you want more fine-tuned control of how paths are split into pieces 
 and joined together again, you’ll want to look at the 
 cleanPath
  and 
 joinPath
  methods 
 in the Yesod typeclass chapter.
  
 Types of Pieces
  
 When you are declaring your routes, you have three types of pieces at your 
 disposal:
  
 Static 
  
  
 This is a plain string that must be matched against precisely in the URL.
  
 Dynamic single 
  
 This is a single piece (i.e., between two forward slashes), but can be a user-sub-
 mitted value. This is the primary method of receiving extra user input on a page 
 request. These pieces begin with a hash (#) and are followed by a data type. 
 The data type must be an instance of 
 PathPiece
 .
  
 Dynamic multi 
  
 The same as before, but can receive multiple pieces of the URL. This must 
 always be the last piece in a resource pattern. It is specified by an asterisk (*) 
 followed by a data type, which must be an instance of 
 PathMultiPiece
 . Multi 
 pieces are not as common as the other two, though they are very important for 
 implementing fea-tures like static trees representing file structure or wikis 
 with arbitrary hierarchies.
  
 Let us take a look at some standard kinds of resource patterns you may want to 
 write. Starting simply, the root of an application will just be 
 /
 . Similarly, you may 
 want to place your FAQ at 
 /page/faq
 .",NA
Resource Name,"Each resource pattern also has a name associated with it. That name will become 
 the constructor for the 
 type safe URL
  data type associated with your application. 
 Therefore, it has to start with a capital letter. By convention, these resource names 
 all end with a capital R. There is nothing forcing you to do this, it is just common 
 practice.
  
 The exact definition of our constructor depends upon the resource pattern it is 
 attached to. Whatever data types are included in single and multi pieces of the 
 pattern become arguments to the data type. This gives us a 1-to-1 correspondence 
 between our type-safe URL values and valid URLs in our application.
  
 Route Syntax | 61",NA
Handler Specification,"The last piece of the puzzle when declaring your resources is how they will be 
 handled. There are three options in Yesod:
  
 • A single handler function for all request methods on a given route.
  
 • A separate handler function for each request method on a given route. Any other 
  
 request method will generate a 405 Bad Method response.
  
 • You want to pass off to a 
 subsite
 .
  
 The first two can be easily specified. A single handler function will be a line with 
 just a resource pattern and the resource name, such as 
 /page/faq FaqR
 . In this case, 
 the handler function must be named 
 handleFaqR
 .
  
 A separate handler for each request method will be the same, plus a list of request 
 methods. The request methods must be all capital letters. For example, 
 /person/ 
 #String PersonR GET POST DELETE
 . In this case, you would need to define three 
 handler functions: 
 getPersonR
 , 
 postPersonR
 , and 
 deletePersonR
 .
  
 Subsites are a very useful—but complicated—topic in Yesod. We will cover writing 
 subsites later, but using them is not too difficult. The most commonly used subsite 
 is the static subsite, which serves static files for your application. In order to serve 
 static files from 
 /static
 , you would need a resource line like:
  
 /static StaticR Static getStatic
  
 In this line, 
 /static
  just says where in your URL structure to serve the static files 
 from. There is nothing magical about the word static, you could easily replace it 
 with 
 /my/ non-dynamic/files
 .
  
 62 | Chapter 7:Routing and Handlers",NA
Dispatch,"Once you have specified your routes, Yesod will take care of all the pesky details of 
 URL dispatch for you. You just need to make sure to provide the appropriate 
 handler functions
 . For subsite routes, you do not need to write any handler 
 functions, but you do for the other two. We mentioned the naming rules above 
 (
 MyHandlerR 
 GET
  
 becomes 
 getMyHandlerR
 , 
 MyOtherHandlerR
  
 becomes 
 handleMyOtherHandlerR
 ). Now we need the type signature.",NA
Return Type,"Let’s look at a simple handler function:
  
 mkYesod ""Simple"" [parseRoutes| 
  
 / HomeR GET 
  
 |]
  
 getHomeR :: Handler RepHtml 
  
 getHomeR = defaultLayout [whamlet|<h1>This is simple |]
  
 Look at the type signature of 
 getHomeR
 . The first component is 
 Handler
 . 
 Handler
  is a 
 special monad that all handler functions live in. It provides access to request 
 information, lets you send redirects, and lots of other stuff we’ll get to soon.
  
 Next we have 
 RepHtml
 . When we discuss representations we will explore the 
 why
  of 
 things more; for now, we are just interested in the 
 how
 .
  
 As you might guess, 
 RepHtml
  is a data type for HTML responses. And as you also 
 may guess, websites need to return responses besides HTML. CSS, JavaScript, 
 images, XML are all necessities of a website. Therefore, the return value of a 
 handler function can be any instance of 
 HasReps
 .
  
 HasReps
  is a powerful concept that allows Yesod to automatically choose the correct 
 representation of your data based on the client request. For now, we will focus just 
 on simple instances such as 
 RepHtml
 , which only provide one representation.
  
 Dispatch | 63",NA
Arguments,"Not every route is as simple as the 
 HomeR
  we just defined. Take for instance our 
 Per 
 sonR
  route from earlier. The name of the person needs to be passed to the handler 
 function. This translation is very straightforward, and hopefully intuitive. For 
 example:
  
 mkYesod ""Args"" [parseRoutes| 
  
 /person/#Text PersonR GET 
  
 /year/#Integer/month/#Text/day/#Int DateR 
  
 /wiki/*Texts WikiR GET 
  
 |]
  
 getPersonR :: Text -> Handler RepHtml 
  
 getPersonR name = defaultLayout [whamlet|<h1>Hello #{name}!|]
  
 D
 ownload from Wow! eBook <www.wowebook.com>
  
 handleDateR :: Integer -> Text -> Int -> Handler RepPlain -- text/plain handleDateR 
 year month day =
  
  
  return $ RepPlain $ toContent $
  
  
  
  T.concat [month, "" "", T.pack $ show day, "", "", T.pack $ show year]
  
 getWikiR :: [Text] -> Handler RepPlain 
  
 getWikiR = return . RepPlain . toContent . T.unwords
  
 The arguments have the types of the dynamic pieces for each route, in the order 
 speci-fied. Also, notice how we are able to use both 
 RepHtml
  and 
 RepPlain
 .",NA
The Handler Monad,"The vast majority of code you write in Yesod sits in the 
 Handler
  monad. If you are 
 approaching this from an MVC (Model-View-Controller) background, your 
 Handler 
 code is the Controller. Some important points to know about 
 Handler
 :
  
 • It is an instance of 
 MonadIO
 , so you can run any IO action in your handlers with 
 liftIO
 . By the way, 
 liftIO
  is exported by the 
 Yesod
  module for your convenience.
  
 • Like 
 Widget
 , 
 Handler
  is a fake-monad-transformer. It wraps around a 
 ResourceT
  
 IO
  monad. We discuss this type at length in the conduits appendix, but for now, 
 we’ll just say it let’s you safely allocate resources.
  
 • By “fake,” I mean you can’t use the standard 
 lift
  function provided by the 
 transformers
  package, you must use the Yesod-supplied one (just like with 
 widgets).
  
 •
  Handler
  is just a type synonym around 
 GHandler
 . 
 GHandler
  let’s you specify 
 exactly which subsite and master site you’re using. The 
 Handler
  synonym says 
 that the sub and master sites are your application’s type.
  
 •
  Handler
  provides a lot of different functionality, such as:
  
 —Providing request information.
  
 —Keeping a list of the extra response headers you’ve added.
  
 —Allowing you to modify the user’s session.
  
 64 | Chapter 7:Routing and Handlers",NA
Application Information,"There are a number of functions that return information about your application as a 
 whole, and give no information about individual requests. Some of these are:
  
 getYesod 
  
 Returns your application foundation value. If you store configuration values in 
 your foundation, you will probably end up using this function a lot.
  
 getYesodSub 
  
 Get the subsite foundation value. Unless you are working in a subsite, this will 
 return the same value as 
 getYesod
 .
  
 getUrlRender 
  
 Returns the 
 URL rendering function
 , which converts a type-safe URL into a 
 Text
 . 
 Most of the time—like with Hamlet—Yesod calls this function for you, but you 
 may occasionally need to call it directly.
  
 getUrlRenderParams 
  
 A variant of 
 getUrlRender
  that converts both a type-safe URL and a list of query-
 string parameters. This function handles all percent-encoding necessary.",NA
Request Information,"The most common information you will want to get about the current request is the 
 requested path, the query string parameters and POSTed form data. The first of 
 those is dealt with in the routing, as described above. The other two are best dealt 
 with using the forms module.
  
 That said, you will sometimes need to get the data in a more raw format. For this 
 purpose, Yesod exposes the 
 Request
  data type along with the 
 getRequest
  function to 
 retrieve it. This gives you access to the full list of GET parameters, cookies, and pre-
 ferred languages. There are some convenient functions to make these lookups 
 easier, such as 
 lookupGetParam
 , 
 lookupCookie
 , and 
 languages
 . For raw access to the 
 POST pa-rameters, you should use 
 runRequest
 .
  
 If you need even more raw data, like request headers, you can use 
 waiRequest
  to 
 access the Web Application Interface (WAI) request value. See the WAI appendix 
 for more details.
  
 The Handler Monad | 65",NA
Short Circuiting,"The following functions immediately end execution of a handler function and return 
 a result to the user.
  
 redirect 
  
 Sends a redirect response to the user (a 303 response). If you want to use a 
 different response code (e.g., a permanent 301 redirect), you can use 
 redirectWith
 .
  
  
 Yesod uses a 303 response for HTTP/1.1 clients, and a 302 re-
 sponse for HTTP/1.0 clients. You can read up on this sordid 
 saga in the HTTP spec.
  
 notFound 
  
 Return a 404 response. This can be useful if a user requests a database value 
 that doesn’t exist.
  
 permissionDenied 
  
  
 Return a 403 response with a specific error 
 message.
  
 invalidArgs 
  
  
 A 400 response with a list of invalid arguments.
  
 sendFile 
  
 Sends a file from the filesystem with a specified content type. This is the 
 preferred way to send static files, since the underlying WAI handler may be 
 able to optimize this to a 
 sendfile
  system call. Using 
 readFile
  for sending static 
 files should not be necessary.
  
 sendResponse 
  
 Send a normal 
 HasReps
  response with a 200 status code. This is really just a 
 con-venience for when you need to break out of some deeply nested code with 
 an immediate response.
  
 sendWaiResponse 
  
 When you need to get low-level and send out a raw WAI response. This can be 
 especially useful for creating streaming responses or a technique like server-
 sent events.",NA
Response Headers,"setCookie 
  
 Set a cookie on the client. Instead of taking an expiration date, this function 
 takes a cookie duration in minutes. Remember, you won’t see this cookie using 
 lookup Cookie
  until the 
 following
  request.",NA
Summary,"Routing and dispatch is arguably the core of Yesod: it is from here that our type-
 safe URLs are defined, and the majority of our code is written within the 
 Handler
  
 monad. This chapter covered some of the most important and central concepts of 
 Yesod, so it is important that you properly digest it.
  
 This chapter also hinted at a number of more complex Yesod topics that we will be 
 covering later. But you should be able to write some very sophisticated web 
 applications with just the knowledge you have learned up until here.",NA
CHAPTER 8,NA,NA
Forms,"I’ve mentioned the boundary issue already: whenever data enters or leaves an 
 application, we need to validate it. Probably the most difficult place this occurs is 
 forms. Coding forms is complex; in an ideal world, we’d like a solution that 
 addresses the following problems:
  
 • Ensure data is valid.
  
 • Marshal string data in the form submission to Haskell data types.
  
 • Generate HTML code for displaying the form.
  
 • Generate JavaScript to do clientside validation and provide more user-friendly 
  
 widgets, such as date pickers.
  
 • Build up more complex forms by combining together simpler forms.
  
 • Automatically assign names to our fields that are guaranteed to be unique.
  
 The 
 yesod-form
  package provides all these features in a simple, declarative API. It 
 builds on top of Yesod’s widgets to simplify styling of forms and applying JavaScript 
 appro-priately. And like the rest of Yesod, it uses Haskell’s type system to make 
 sure everything is working correctly.",NA
Synopsis,"{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
  
  OverloadedStrings, TypeFamilies #-} 
  
 import Yesod 
  
 import Yesod.Form.Jquery 
  
 import Data.Time (Day) 
  
 import Data.Text (Text) 
  
 import Control.Applicative ((<$>), (<*>))
  
 data Synopsis = Synopsis
  
 mkYesod ""Synopsis"" [parseRoutes| 
  
 / RootR GET 
  
 /person PersonR POST
  
 69",NA
Kinds of Forms,"Before jumping into the types themselves, we should begin with an overview of the 
 different kinds of forms. There are three categories:
  
 Applicative 
  
 These are the most commonly used (it’s what appeared in the synopsis). 
 Applica-tive gives us some nice properties of letting error messages coalesce 
 together and keep a very high-level, declarative approach. (For more 
 information on applicative code, see 
 the Haskell wiki
 .)
  
 Monadic 
  
 A more powerful alternative to applicative. While this allows you more 
 flexibility, it does so at the cost of being more verbose. Useful if you want to 
 create forms that don’t fit into the standard two-column look.
  
 Input 
  
 Used only for receiving input. Does not generate any HTML for receiving the 
 user input. Useful for interacting with existing forms.
  
 In addition, there are a number of different variables that come into play for each 
 form and field you will want to set up:
  
 Kinds of Forms | 71",NA
Types,"The 
 Yesod.Form.Types
  module declares a few types. Let’s start off with some simple 
 helpers:
  
 Enctype 
  
 The encoding type, either 
 UrlEncoded
  or 
 Multipart
 . This data type declares an 
 instance of 
 ToHtml
 , so you can use the enctype directly in Hamlet.
  
 Env 
  
  
 Maps a parameter name to a list of values.
  
 FileEnv 
  
  
 Maps a parameter name to the associated uploaded 
 file.
  
 Ints 
  
 As mentioned in the introduction, 
 yesod-form
  automatically assigns a unique 
 name to each field. 
 Ints
  is used to keep track of the next number to assign.
  
 FormResult 
  
 Has one of three possible states: 
 FormMissing
  if no data was submitted, 
 FormFai 
 lure
  if there was an error parsing the form (e.g., missing a required field, invalid 
 content), or 
 FormSuccess
  if everything went smoothly.
  
 Next we have three data types used for defining individual fields.
  
  
 A field is a single piece of information, such as a number, a string, or 
 an email address. Fields are combined together to build forms.
  
 72 | Chapter 8:Forms",NA
Converting,"“But wait a minute,” you say. “You said the synopsis uses applicative forms, but I’m 
 sure the type signature said 
 MForm
 . Shouldn’t it be Monadic?” That’s true, the final 
 form we produced was monadic. But what really happened is that we converted an 
 applica-tive form to a monadic one.
  
 Again, our goal is to reuse code as much as possible, and minimize the number of 
 functions in the API. And Monadic forms are more powerful than Applicative, if 
 more clumsy, so anything that can be expressed in an Applicative form could also 
 be ex-pressed in a Monadic form. There are two core functions that help out with 
 this: 
 aformToForm
  converts any applicative form to a monadic one, and 
 formToAForm
  converts certain kinds of monadic forms to applicative forms.
  
 “But wait 
 another
  minute,” you insist. “I didn’t see any 
 aformToForm
 !” Also true. 
 The 
 renderDivs
  function takes care of that for us.",NA
Create AForms,"Now that I’ve (hopefully) convinced you that in our synopsis we were really dealing 
 with applicative forms, let’s have a look and try to understand how these things get 
 created. Let’s take a simple example:
  
 data Car = Car
  
   
  { carModel :: Text
  
   
  , carYear :: Int
  
   
  }
  
  deriving Show
  
 carAForm :: AForm Synopsis Synopsis Car 
  
 carAForm = Car
  
  
  <$> areq textField ""Model"" Nothing
  
  
  <*> areq intField ""Year"" Nothing
  
 carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget) 
 carForm = renderTable carAForm
  
 Here, we’ve explicitly split up applicative and monadic forms. In 
 carAForm
 , we use 
 the 
 <$>
  and 
 <*>
  operators. This should not be surprising; these are almost always 
 used in applicative-style code. And we have one line for each record in our 
 Car
  data 
 type. Per-haps unsurprisingly, we have a 
 textField
  for the 
 Text
  record, and an 
 intField
  
 for the 
 Int
  record.
  
 Let’s look a bit more closely at the 
 areq
  function. Its (simplified) type signature is 
 Field a -> FieldSettings -> Maybe a -> AForm a
 . So that first argument is going to 
 determine the data type of this field, how to parse it, and how to render it. The next 
 argument, 
 FieldSettings
 , tells us the label, tooltip, name, and ID of the field. In this 
 case, we’re using the previously mentioned 
 IsString
  instance of 
 FieldSettings
 .
  
 74 | Chapter 8:Forms",NA
Optional Fields,"Suppose we wanted to have an optional field (like the car color). All we do instead 
 is
  
 D
 ownload from Wow! eBook <www.wowebook.com>
  
 use the 
 aopt
  function.
  
 Example 8-2. Optional fields
  
 data Car = Car
  
   
  { carModel :: Text
  
   
  , carYear :: Int
  
   
  , carColor :: Maybe Text
  
   
  }
  
  deriving Show
  
 carAForm :: AForm Synopsis Synopsis Car 
  
 carAForm = Car
  
  
  <$> areq textField ""Model"" Nothing
  
  
  <*> areq intField ""Year"" Nothing
  
  
  <*> aopt textField ""Color"" Nothing
  
 And like required fields, the last argument is the optional default value. However, 
 this has two layers of Maybe wrapping. This may seem redundant (and it is), but it 
 makes it much easier to write code that takes an optional default form parameter, 
 such as in the next example.
  
 Example 8-3. Default optional fields
  
 data Car = Car
  
   
  { carModel :: Text
  
   
  , carYear :: Int
  
   
  , carColor :: Maybe Text
  
   
  }
  
  deriving Show
  
 carAForm :: Maybe Car -> AForm Synopsis Synopsis Car 
  
 carAForm mcar = Car
  
  
  <$> areq textField ""Model"" (carModel <$> mcar)
  
  
  <*> areq intField  ""Year""  (carYear  <$> mcar)
  
  
  <*> aopt textField ""Color"" (carColor <$> mcar)
  
 Create AForms | 75",NA
Validation,"How would we make our form only accept cars created after 1990? If you 
 remember, we said above that the 
 Field
  itself contained the information on what is a 
 valid entry. So all we need to do is write a new 
 Field
 , right? Well, that would be a bit 
 tedious.
  
 Instead, let’s just modify an existing one:
  
 carAForm :: Maybe Car -> AForm Synopsis Synopsis Car carAForm 
 mcar = Car
  
   
  <$> areq textField    ""Model"" (carModel <$> mcar)
  
  
  <*> areq carYearField ""Year""  (carYear  <$> mcar)
  
  
  <*> aopt textField    ""Color"" (carColor <$> mcar) where
  
   
  errorMessage :: Text
  
   
  errorMessage = ""Your car is too old, get a new one!""
  
  carYearField = check validateYear intField
  
  validateYear y
  
  | y < 1990 = Left errorMessage
  
  | otherwise = Right y
  
 The trick here is the 
 check
  function. It takes a function (
 validateYear
 ) that returns 
 either an error message or a modified field value. In this example, we haven’t 
 modified the value at all. That is usually going to be the case. This kind of checking 
 is very common, so we have a shortcut:
  
  carYearField = checkBool (>= 1990) errorMessage intField
  
 checkBool
  takes two parameters: a condition that must be fulfilled, and an error 
 message to be displayed if it was not.
  
  
 You may have noticed the explicit 
 Text
  type signature on 
 errorMes 
 sage
 . In the presence of 
 OverloadedStrings
 , this is necessary. In order 
 to support i18n, messages can have many different data types, and 
 GHC has no way of determining which instance of 
 IsString
  you 
 intended to
  
 use.
  
 It’s great to make sure the car isn’t too old. But what if we want to make sure that 
 the year specified is not from the future? In order to look up the current year, we’ll 
 need to run some 
 IO
 . For such circumstances, we’ll need 
 checkM
 :
  
  carYearField = checkM inPast $ checkBool (>= 1990) errorMessage intField
  
  inPast y = do
  
  thisYear <- liftIO getCurrentYear
  
  return $ if y <= thisYear
  
 76 | Chapter 8:Forms",NA
More Sophisticated Fields,"Our color entry field is nice, but it’s not exactly user-friendly. What we really want 
 is a drop-down list.
  
 Example 8-4. Drop-down lists
  
 data Car = Car
  
   
  { carModel :: Text
  
   
  , carYear :: Int
  
   
  , carColor :: Maybe Color
  
   
  }
  
  deriving Show
  
 data Color = Red | Blue | Gray | Black
  
  deriving (Show, Eq, Enum, Bounded)
  
 carAForm :: Maybe Car -> AForm Synopsis Synopsis Car 
  
 carAForm mcar = Car
  
   
  <$> areq textField ""Model"" (carModel <$> mcar)
  
   
  <*> areq carYearField ""Year"" (carYear <$> mcar)
  
   
  <*> aopt (selectFieldList colors) ""Color"" (carColor <$> mcar)
  
  where
  
   
  colors :: [(Text, Color)]
  
   
  colors = [(""Red"", Red), (""Blue"", Blue), (""Gray"", Gray), (""Black"", Black)]
  
 selectFieldList
  takes a list of pairs. The first item in the pair is the text displayed to 
 the user in the drop-down list, and the second item is the actual Haskell value. Of 
 course, the code above looks really repetitive; we can get the same result using the 
 Enum and Bounded instance GHC automatically derives for us.
  
 More Sophisticated Fields | 77",NA
Running Forms,"At some point, we’re going to need to take our beautiful forms and produce some 
 results. There are a number of different functions available for this, each with its 
 own purpose. I’ll go through them, starting with the most common.
  
 78 | Chapter 8:Forms",NA
i18n,"There have been a few references to i18n in this chapter. The topic will get more 
 thor-ough coverage in its own chapter, but since it has such a profound effect on 
 yesod-form
 , I wanted to give a brief overview. The idea behind i18n in Yesod is to 
 have data types represent messages. Each site can have an instance of 
 RenderMessage
  for a given data type which will translate that message based on a 
 list of languages the user accepts.
  
 As a result of all this, there are a few things you should be aware of:
  
 • There is an automatic instance of 
 RenderMessage
  for 
 Text
  in every site, so you can 
 just use plain strings if you don’t care about i18n support. However, you may 
 need to use explicit type signatures occasionally.
  
 •
  yesod-form
  expresses all of its messages in terms of the 
 FormMessage
  data type. 
 Therefore, to use 
 yesod-form
 , you’ll need to have an appropriate 
 RenderMessage 
 instance. A simple one that uses the default English translations would be:
  
 instance RenderMessage MyApp FormMessage where 
 renderMessage _ _ = defaultFormMessage
  
 This is provided automatically by the scaffolded site.",NA
Monadic Forms,"Oftentimes, a simple form layout is adequate, and applicative forms excel at this 
 approach. Sometimes, however, you’ll want to have a more customized look to your 
 form.
  
 For these use cases, monadic forms fit the bill. They are a bit more verbose than 
 their applicative cousins, but this verbosity allows you to have complete control 
 over what the form will look like. In order to generate the form above, we could 
 code something like this.
  
 {-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
  
  
 TemplateHaskell, MultiParamTypeClasses #-} import Yesod 
  
 import Control.Applicative 
  
 import Data.Text (Text)
  
 data MFormExample = MFormExample
  
 mkYesod ""MFormExample"" [parseRoutes| 
  
 / RootR GET 
  
 |]
  
 instance Yesod MFormExample
  
 instance RenderMessage MFormExample FormMessage where
  
  renderMessage _ _ = defaultFormMessage
  
 data Person = Person { personName :: Text, personAge :: Int }
  
  
 deriving Show
  
 personForm :: Html -> MForm MFormExample MFormExample (FormResult Person, Widget) 
 personForm extra = do
  
  
  (nameRes, nameView) <- mreq textField ""this is not used"" Nothing
  
  
  (ageRes, ageView) <- mreq intField ""neither is this"" Nothing
  
  
  let personRes = Person <$> nameRes <*> ageRes
  
  
  let widget = do
  
  
  
  toWidget [lucius| 
  
 ##{fvId ageView} {
  
  
  width: 3em; 
  
 } 
  
 |]
  
  
  
  [whamlet| 
  
 #{extra} 
  
 <p>
  
  
  Hello, my name is #
  
  
  ^{fvInput nameView}
  
  
  \ and I am #
  
  
  ^{fvInput ageView}
  
 80 | Chapter 8:Forms",NA
Input Forms,"Applicative and monadic forms handle both the generation of your HTML code and 
 the parsing of user input. Sometimes, you only want to do the latter, such as when 
 there’s an already-existing form in HTML somewhere, or if you want to generate a 
 form dynamically using JavaScript. In such a case, you’ll want input forms.
  
 These work mostly the same as applicative and monadic forms, with some 
 differences:
  
 • You use 
 runInputPost
  and 
 runInputGet
 .
  
 • You use 
 ireq
  and 
 iopt
 . These functions now only take two arguments: the field 
  
 type and the name (i.e., HTML 
 name
  attribute) of the field in question.
  
 • After running a form, it returns the value. It doesn’t return a widget or an 
 encoding 
  
 type.
  
 • If there are any validation errors, the page returns an “invalid arguments” error 
  
 page.
  
 You can use input forms to recreate the previous example. Note, however, that the 
 input version is less user friendly. If you make a mistake in an applicative or 
 monadic form, you will be brought back to the same page, with your previously 
 entered values in the form, and an error message explaining what you need to 
 correct. With input forms, the user simply gets an error message.
  
 {-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
  
  
 TemplateHaskell, MultiParamTypeClasses #-} import Yesod 
  
 import Control.Applicative 
  
 import Data.Text (Text)
  
 data Input = Input
  
 mkYesod ""Input"" [parseRoutes| 
  
 / RootR GET 
  
 /input InputR GET 
  
 |]
  
 instance Yesod Input
  
 instance RenderMessage Input FormMessage where 
 renderMessage _ _ = defaultFormMessage
  
 data Person = Person { personName :: Text, personAge :: Int }
  
  
 deriving Show
  
 getRootR :: Handler RepHtml 
  
 getRootR = defaultLayout [whamlet| 
  
 <form action=@{InputR}>
  
 82 | Chapter 8:Forms",NA
Custom Fields,"The fields that come built-in with Yesod will likely cover the vast majority of your 
 form needs. But occasionally, you’ll need something more specialized. Fortunately, 
 you can create new forms in Yesod yourself. The 
 Field
  data type has two records: 
 fieldParse 
 takes a list of values submitted by the user and returns one of three 
 results:
  
 • An error message saying validation failed
  
 • The parsed value
  
 • Nothing, indicating that no data was supplied
  
 That last case might sound surprising: shouldn’t Yesod automatically know that no 
 information is supplied when the input list is empty? Well, no, actually. Checkboxes, 
 for instance, indicate an unchecked state by sending in an empty list.
  
 Also, what’s up with the list? Shouldn’t it be a 
 Maybe
 ? Well, that’s also not the case.
  
 With grouped checkboxes and multi-select lists, you’ll have multiple widgets with 
 the same name. We also use this trick in our example below.
  
 The second record is 
 fieldView
 , and it renders a widget to display to the user. This 
 function has four arguments: the 
 id
  attribute, the 
 name
  attribute, the result, and a 
 Bool
  indicating whether the field is required.
  
 What did I mean by result? It’s actually an 
 Either
 , giving either the unparsed input 
 (when parsing failed) or the successfully parsed value. 
 intField
  is a great example of 
 how this works. If you type in 
 42
 , the value of result will be 
 Right 42
 . But if you type 
 in 
 turtle
 , the result will be 
 Left ""turtle""
 . This lets you put in a value attribute on your 
 input tag that will give the user a consistent experience.
  
 As a small example, we’ll create a new field type that is a password confirm field. 
 This field has two text inputs—both with the same name attribute—and returns an 
 error
  
 Custom Fields | 83",NA
Summary,"Forms in Yesod are broken up into three groups. Applicative is the most common, 
 as it provides a nice user interface with an easy-to-use API. Monadic forms give you 
 more power, but are harder to use. Input forms are intended when you just want to 
 read data from the user, not generate the input widgets.
  
 There are a number of different 
 Field
 s provided by Yesod out-of-the-box. In order to 
 use these in your forms, you need to indicate the kind of form and whether the field 
 is required or optional. The result is six helper functions: 
 areq
 , 
 aopt
 , 
 mreq
 , 
 mopt
 , 
 ireq
 , 
 and 
 iopt
 .
  
 Forms have significant power available. They can automatically insert JavaScript to 
 help you leverage nicer UI controls, such as a jQuery UI date picker. Forms are also 
 fully i18n-ready, so you can support a global community of users. And when you 
 have more specific needs, you can slap on some validation functions to an existing 
 field, or write a new one from scratch.
  
 84 | Chapter 8:Forms",NA
CHAPTER 9,NA,NA
Sessions,"HTTP is a stateless protocol. While some view this as a disadvantage, advocates of 
 RESTful web development laud this as a plus. When state is removed from the 
 picture, it is easier to scale applications, caching can happen automatically, and 
 many other nice side effects occur. You can draw many parallels with the non-
 mutable nature of Haskell in general.
  
 As much as possible, RESTful applications should avoid storing state about an inter-
 action with a client. However, it is sometimes unavoidable. Features like shopping 
 carts are the classic example, but other more mundane interactions like proper 
 login handling can be greatly enhanced by proper usage of sessions.
  
 This chapter will describe how Yesod stores session data, how you can access this 
 data, and some special functions to help you make the most of sessions.",NA
Clientsession,"One of the earliest packages spun off from Yesod was 
 clientsession
 . This package 
 uses encryption and signatures to store data in a client-side cookie. The encryption 
 prevents the user from inspecting the data, and the signature ensures that the 
 session can be neither hijacked nor tampered with.
  
 It might sound like a bad idea from an efficiency standpoint to store data in a 
 cookie: after all, this means that the data must be sent on every request. However, 
 in practice, clientsession can be a great boon for performance.
  
 • No server side database lookup is required to service a request.
  
 • We can easily scale horizontally: each request contains all the information we 
 need 
  
 to send a response.
  
 • To avoid undue bandwidth overhead, production sites can serve their static 
 content from a separate domain name to avoid the overhead of transmitting 
 the session cookie for each request.
  
 85",NA
Controlling Sessions,"There are three functions in the Yesod typeclass that control how sessions work. 
 encryptKey
  returns the encryption key used. By default, it will take this from a local 
 file, so that sessions can persist between database shutdowns. This file will be 
 automatically created and filled with random data if it does not exist. And if you 
 override this function to return 
 Nothing
 , sessions will be disabled.
  
  
 Why disable sessions? They 
 do
  introduce a performance overhead. 
 Un-der normal circumstances, this overhead is minimal, especially 
 com-pared to database access. However, when dealing with very 
 basic tasks, the overhead can become noticeable. But be careful 
 about disabling
  
 sessions: this will also disable such features as CSRF (Cross-Site 
 Request Forgery) protection.
  
 The next function is 
 clientSessionDuration
 . This function gives the number of minutes 
 that a session should be active. The default is 120 (2 hours).
  
 This value ends up affecting the session cookie in two ways: first, it determines the 
 expiration date for the cookie itself. More importantly, however, the session 
 expiration timestamp is encoded inside the session signature. When Yesod decodes 
 the signature, it checks whether the date is in the past; if so, it ignores the session 
 values.
  
  
 Every time Yesod sends a response to the client, it sends an updated 
 session cookie with a new expire date. This way, even if you do not 
 change the session values themselves, a session will not time out if 
 the user continues to browse your site.
  
 And this leads very nicely to the last function: 
 sessionIpAddress
 . By default, Yesod 
 also encodes the client’s IP address inside the cookie to prevent session hijacking. 
 In general, this is a good thing. However, some ISPs are known for putting their 
 users behind proxies that rewrite their IP addresses, sometimes changing the 
 source IP in the middle of the session. If this happens, and you have 
 sessionIpAddress
  enabled, the user’s session will be reset. Turning this setting to 
 False
  will allow a session to continue under such circumstances, at the cost of 
 exposing a user to session hijacking.",NA
Session Operations,"Like most frameworks, a session in Yesod is a key-value store. The base session API 
 boils down to four functions: 
 lookupSession
  gets a value for a key (if available), 
 getSes sion
  returns all of the key/value pairs, 
 setSession
  sets a value for a key, and 
 deleteSes sion
  clears a value for a key.
  
 {-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, 
 OverloadedStrings #-} 
  
 import Yesod 
  
 import Control.Applicative ((<$>), (<*>))
  
 data SessionExample = SessionExample
  
 mkYesod ""SessionExample"" [parseRoutes| 
  
 / Root GET POST 
  
 |]
  
 getRoot :: Handler RepHtml 
  
 getRoot = do
  
  
  sess <- getSession
  
  
  hamletToRepHtml [hamlet| 
  
 <form method=post>
  
  
  <input type=text name=key>
  
  
  <input type=text name=val>
  
  
  <input type=submit> 
  
 <h1>#{show sess} 
  
 |]
  
 postRoot :: Handler () 
  
 postRoot = do
  
  
  (key, mval) <- runInputPost $ (,) <$> ireq textField ""key"" <*> iopt textField ""val""
  
  
  
 case mval of
  
    
  Nothing -> deleteSession key
  
    
  Just val -> setSession key val
  
   
  liftIO $ print (key, mval)
  
   
  redirect Root
  
 instance Yesod SessionExample where
  
  clientSessionDuration _ = 1
  
 instance RenderMessage SessionExample FormMessage where
  
  renderMessage _ _ = defaultFormMessage
  
 main :: IO () 
  
 main = warpDebug 3000 SessionExample",NA
Messages,"One usage of sessions previously alluded to is messages. They come to solve a 
 common problem in web development: the user performs a 
 POST
  request, the web 
 app makes a
  
 Messages | 87",NA
Ultimate Destination,"Not to be confused with a horror film, this concept is used internally in 
 yesod-auth
 . 
 Suppose a user requests a page that requires authentication. If the user is not yet 
 logged in, you need to send him/her to the login page. A well-designed web app will 
 then 
 send them back to the first page they requested
 . That’s what we call the 
 ultimate destination.
  
 redirectUltDest
  sends the user to the ultimate destination set in his/her session, 
 clear-ing that value from the session. It takes a default destination as well, in case 
 there is no destination set. For setting the session, there are three options:
  
 •
  setUltDest
  sets the destination to the given URL.
  
 •
  setUltDestCurrent
  sets the destination to the currently requested URL.
  
 •
  setUltDestReferer
  sets the destination based on the 
 Referer
  header (the page that 
  
 led the user to the current page).
  
 Let’s look at a small sample app. It will allow the user to set his/her name in the 
 session, and then tell the user his/her name from another route. If the name hasn’t 
 been set yet, the user will be redirected to the set name page, with an ultimate 
 destination set to come back to the current page.
  
 Ultimate Destination | 89",NA
Summary,"Sessions are the number one way we bypass the statelessness imposed by HTTP. 
 We shouldn’t consider this an escape hatch to perform whatever actions we want: 
 state-lessness in web applications is a virtue, and we should respect it whenever 
 possible. However, there are specific cases where it is vital to retain some state.
  
 The session API in Yesod is very simple. It provides a key-value store, and a few 
 con-venience functions built on top for common use cases. If used properly, with 
 small payloads, sessions should be an unobtrusive part of your web development.
  
 Summary | 91",NA
CHAPTER 10,NA,NA
Persistent,"Forms deal with the boundary between the user and the application. Another 
 boundary we need to deal with is between the application and the storage layer. 
 Whether it be a SQL database, a YAML file, or a binary blob, odds are you have to 
 work to get your storage layer to accept your application data types. Persistent is 
 Yesod’s answer to data storage—a type-safe, universal data store interface for 
 Haskell.
  
 Haskell has many different database bindings available. However, most of these 
 have little knowledge of a schema and therefore do not provide useful static 
 guarantees. They also force database-dependent APIs and data types on the 
 programmer. Haskellers have attempted a more revolutionary route of creating 
 Haskell-specific data stores to get around these flaws that allow one to easily store 
 any Haskell type. These options are great for certain use cases, but they constrain 
 one to the storage techniques provided by the library, do not interface well with 
 other languages, and the flexibility can also mean one must write reams of code for 
 querying data. In contrast, Persistent allows us to choose among existing databases 
 that are highly tuned for different data storage use cases, interoperate with other 
 programming languages, and to use a safe and productive query interface.
  
 Persistent follows the guiding principles of type safety and concise, declarative 
 syntax. Some other nice features are:
  
 • Database-agnostic. There is first-class support for PostgreSQL, SQLite, and 
  
 MongoDB, with experimental CouchDB and MySQL support in the works.
  
 • By being non-relational in nature, we simultaneously are able to support a wider 
 number of storage layers and are not constrained by some of the performance 
 bottlenecks incurred through joins.
  
 • A major source of frustration in dealing with SQL databases is changes to the 
  
 schema. Persistent can automatically perform database migrations.
  
 93",NA
Synopsis,"{-# LANGUAGE QuasiQuotes, TemplateHaskell, TypeFamilies, OverloadedStrings #-} {-# 
 LANGUAGE GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Control.Monad.IO.Class (liftIO)
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  name String
  
  
  age Int Maybe 
  
 BlogPost
  
  
  title String
  
  
  authorId PersonId 
  
 |]
  
 main :: IO () 
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do
  
  
 runMigration migrateAll
  
  johnId <- insert $ Person ""John Doe"" $ Just 35 janeId <- 
 insert $ Person ""Jane Doe"" Nothing
  
  insert $ BlogPost ""My fr1st p0st"" johnId
  
  insert $ BlogPost ""One more for good measure"" johnId
  
  oneJohnPost <- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1] liftIO $ 
 print (oneJohnPost :: [Entity BlogPost])
  
  john <- get johnId
  
  liftIO $ print (john :: Maybe Person)
  
  delete janeId
  
  deleteWhere [BlogPostAuthorId ==. johnId]",NA
Solving the Boundary Issue,"Suppose you are storing information on people in a SQL database. Your table might 
 look something like:
  
 CREATE TABLE Person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)
  
 And if you are using a database like PostgreSQL, you can be guaranteed that the 
 data-base will never store some arbitrary text in your age field. (The same cannot 
 be said of SQLite, but let’s forget about that for now.) To mirror this database table, 
 you would likely create a Haskell data type that looks something like:
  
 data Person = Person
  
  { personName :: Text
  
  , personAge :: Int
  
  }
  
 94 | Chapter 10:Persistent",NA
Types,"Like routing, there is nothing intrinsically difficult about type-safe data access. It 
 just requires a lot of monotonous, error prone, boiler plate code. As usual, this 
 means we can use the type system to keep us honest. And to avoid some of the 
 drudgery, we’ll use a sprinkling of Template Haskell.
  
  
 Earlier versions of Persistent made much heavier usage of Template 
 Haskell. Starting with 0.6, there is a new architecture inspired by 
 the 
 groundhog
  package. This approach uses phantom types to carry a 
 lot of the burden.
  
 PersistValue
  is the basic building block of Persistent. It is a sum type that can 
 represent data that gets sent to and from a database. Its definition is:
  
 data PersistValue = PersistText Text
  
  
  
  | PersistByteString ByteString
  
  
  
  | PersistInt64 Int64
  
  
  
  | PersistDouble Double
  
  
  
  | PersistBool Bool
  
  
  
  | PersistDay Day
  
  
  
  | PersistTimeOfDay TimeOfDay
  
  
  
  | PersistUTCTime UTCTime
  
  
  
  | PersistNull
  
  
  
  | PersistList [PersistValue]
  
  
  
  | PersistMap [(T.Text, PersistValue)]
  
  
  | PersistForeignKey ByteString -- ^ intended especially for MongoDB backend
  
 Solving the Boundary Issue | 95",NA
Code Generation,"In order to ensure that the PersistEntity instances match up properly with your 
 Haskell data types, Persistent takes responsibility for both. This is also good from a 
 DRY (don’t repeat yourself) perspective: you only need to define your entities once. 
 Let’s see a quick example:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, 
 OverloadedStrings, GADTs #-} 
  
 import Database.Persist 
  
 import Database.Persist.TH 
  
 import Database.Persist.Sqlite 
  
 import Control.Monad.IO.Class (liftIO)
  
 mkPersist sqlSettings [persist| 
  
 Person
  
  
  name String
  
  
  age Int 
  
 |]
  
 We use a combination of Template Haskell and Quasi-Quotation (like when defining 
 routes): 
 persist
  is a quasi-quoter that converts a whitespace-sensitive syntax into a 
 list of entity definitions. (You can also declare your entities in a separate file using 
 persistFile
 .) 
 mkPersist
  takes that list of entities and declares:
  
 • One Haskell data type for each entity.
  
 • A 
 PersistEntity
  instance for each data type defined.
  
 The example above generates code that looks like the following:
  
 {-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-} import 
 Database.Persist
  
 96 | Chapter 10:Persistent",NA
PersistStore,"One last detail is left unexplained from the previous example: what are those 
 withSqli teConn
  and 
 runSqlConn
  functions doing, and what is that monad that our 
 database actions are running in?
  
 All database actions need to occur within an instance of 
 PersistStore
 . As its name 
 implies, every data store (PostgreSQL, SQLite, MongoDB) has an instance of 
 Persist 
 Store
 . This is where all the translations from 
 PersistValue
  to database-specific values 
 occur, where SQL query generation happens, and so on.
  
  
 As you can imagine, even though 
 PersistStore
  provides a safe, well-
 typed interface to the outside world, there are a lot of database 
 interac-tions that could go wrong. However, by testing this code 
 automatically and thoroughly in a single location, we can centralize 
 our error-prone
  
 code and make sure it is as bug-free as possible.
  
 withSqliteConn
  creates a single connection to a database using its supplied 
 connection string. For our test cases, we will use 
 :memory:
 , which uses an in-
 memory database. 
 runSqlConn
  uses that connection to run the inner action. Both 
 SQLite and PostgreSQL share the same instance of 
 PersistStore
 : 
 SqlPersist
 .
  
 98 | Chapter 10:Persistent",NA
Migrations,"I’m sorry to tell you, but so far I have lied to you a bit: the example from the 
 previous section does not actually work. If you try to run it, you will get an error 
 message about a missing table.
  
 For SQL databases, one of the major pains can be managing schema changes. 
 Instead of leaving this to the user, Persistent steps in to help, but you have to 
 ask
  it 
 to help.
  
 Let’s see what this looks like:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.TH 
  
 import Database.Persist.Sqlite 
  
 import Control.Monad.IO.Class (liftIO)
  
 share [mkPersist sqlSettings, mkSave ""entityDefs""] [persist| Person
  
  
  name String
  
  
  age Int 
  
 |]
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do
  
  
  runMigration $ migrate entityDefs (undefined :: Person) -- this line added: that's it!
  
  michaelId <- insert $ Person ""Michael"" 26
  
  michael <- get michaelId
  
  liftIO $ print michael
  
 With this one little code change, Persistent will automatically create your 
 Person
  
 table for you. This split between 
 runMigration
  and 
 migrate
  allows you to migrate 
 multiple tables simultaneously.
  
 Migrations | 99",NA
Uniqueness,"In addition to declaring fields within an entity, you can also declare uniqueness 
 constraints. A typical example would be requiring that a username be unique.
  
 Example 10-1. Unique Username
  
 User
  
  username Text
  
  UniqueUsername username
  
 While each field name must begin with a lowercase letter, the uniqueness 
 constraints must begin with an uppercase letter.
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Data.Time 
  
 import Control.Monad.IO.Class (liftIO)
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  firstName String
  
  
  lastName String
  
  
  age Int
  
  
  PersonName firstName lastName 
  
 |]
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do 
 runMigration migrateAll
  
  insert $ Person ""Michael"" ""Snoyman"" 26
  
  michael <- getBy $ PersonName ""Michael"" ""Snoyman"" 
 liftIO $ print michael
  
 Uniqueness | 101",NA
Queries,"Depending on what your goal is, there are different approaches to querying the 
 data-base. Some commands query based on a numeric ID, while others will filter. 
 Queries also differ in the number of results they return: some lookups should 
 return no more than one result (if the lookup key is unique) while others can 
 return many results.
  
 Persistent therefore provides a few different query functions. As usual, we try to 
 encode as many invariants in the types as possible. For example, a query that can 
 return only 0 or 1 results will use a 
 Maybe
  wrapper, whereas a query returning 
 many results will return a list.",NA
Fetching by ID,"The simplest query you can perform in Persistent is getting based on an ID. Since 
 this value may or may not exist, its return type is wrapped in a 
 Maybe
 .
  
 Example 10-2. Using get
  
  personId <- insert $ Person ""Michael"" ""Snoyman"" 26
  
  maybePerson <- get personId
  
  case maybePerson of
  
  
  Nothing -> liftIO $ putStrLn ""Just kidding, not really there""
  
  Just 
 person -> liftIO $ print person
  
 This can be very useful for sites that provide URLs like 
 /person/5
 . However, in such 
 a case, we don’t usually care about the 
 Maybe
  wrapper, and just want the value, 
 returning a 404 message if it is not found. Fortunately, the 
 get404
  function helps us 
 out here. We’ll go into more details when we see integration with Yesod.",NA
Fetching by Unique Constraint,"getBy
  is almost identical to 
 get
 , except it takes a uniqueness constraint instead of an 
 ID it takes a Unique value.
  
 Example 10-3. Using getBy
  
  personId <- insert $ Person ""Michael"" ""Snoyman"" 26
  
  maybePerson <- getBy $ UniqueName ""Michael"" ""Snoyman""
  
  case maybePerson of
  
  
  Nothing -> liftIO $ putStrLn ""Just kidding, not really there""
  
  Just 
 person -> liftIO $ print person
  
 Like 
 get404
 , there is also a 
 getBy404
  function.",NA
Select Functions,"Most likely, you’re going to want more powerful queries. You’ll want to find 
 everyone over a certain age; all cars available in blue; all users without a registered 
 email address. For this, you need one of the select functions.
  
 All the select functions use a similar interface, with slightly different outputs:
  
 Function
  
 Returns
  
 selec
 t-
  
 Sour
 ce
  
 selectList
  
 selectFirst
  
 selec
 t-
  
 Keys
  
 A 
 Source
  containing all the IDs and values from the database. This allows you to 
 write streaming code.
  
  
 We cover 
 Source
 s in detail in the conduits appendix. 
 Additionally, there’s another function called 
 selectSourceConn
  that allows you more control of 
 connection allocation. We use this in the Sphinx case 
 study.
  
 A list containing all the IDs and values from the database. All records 
 will be loaded into memory. Takes just the first ID and value from the 
 database, if available 
  
 Returns only the keys, without the values, as a 
 Source
 .
  
 selectList
  is the most commonly used, so we will cover it specifically. Understanding 
 the others should be trivial after that.
  
 selectList
  takes two arguments: a list of 
 Filter
 s, and a list of 
 SelectOpt
 s. The former is 
 what limits your results based on characteristics; it allows for equals, less than, is 
 member of, and such. 
 SelectOpt
 s provides for three different features: sorting, 
 limiting output to a certain number of rows, and offsetting results by a certain 
 number of rows.
  
  
 The combination of limits and offsets is very important; it allows for 
 efficient pagination in your webapps.
  
 Queries | 103",NA
Manipulation,"Querying is only half the battle. We also need to be able to add data to and modify 
 existing data in the database.",NA
Insert,"It’s all well and good to be able to play with data in the database, but how does it 
 get there in the first place? The answer is the 
 insert
  function. You just give it a value, 
 and it gives back an ID.
  
 At this point, it makes sense to explain a bit of the philosophy behind Persistent. In 
 many other ORM solutions, the data types used to hold data are opaque: you need 
 to go through their defined interfaces to get at and modify the data. That’s not the 
 case with Persistent: we’re using plain old Algebraic Data Types for the whole 
 thing. This means you still get all the great benefits of pattern matching, currying, 
 and everything else you’re used to.
  
 However, there are a few things we 
 can’t
  do. For one, there’s no way to 
 automatically update values in the database every time the record is updated in 
 Haskell. Of course, with Haskell’s normal stance of purity and immutability, this 
 wouldn’t make much sense anyway, so I don’t shed any tears over it.
  
 However, there is one issue that newcomers are often bothered by: why are IDs and 
 values completely separate? It seems like it would be very logical to embed the ID 
 inside the value. In other words, instead of having:
  
 data Person = Person { name :: String }
  
 have
  
 Manipulation | 105",NA
Update,"Now, in the context of that discussion, let’s think about updating. The simplest way 
 to update is:
  
 let michael = Person ""Michael"" 26
  
  
  michaelAfterBirthday = michael { personAge = 27 }
  
 106 | Chapter 10:Persistent",NA
Delete,"As much as it pains us, sometimes we must part with our data. To do so, we have 
 three functions:
  
 delete 
  
  
 Delete based on an ID
  
 deleteBy 
  
  
 Delete based on a unique constraint
  
 deleteWhere 
  
  
 Delete based on a set of 
 filters
  
  personId <- insert $ Person ""Michael"" ""Snoyman"" 26
  
  delete personId",NA
Attributes,"So far, we have seen a basic syntax for our 
 persist
  blocks: a line for the name of our 
 entities, and then an indented line for each field with two words: the name of the 
 field and the data type of the field. Persistent handles more than this: you can 
 assign an arbitrary list of attributes after the first two words on a line.
  
 Suppose we want to have a 
 Person
  entity with an (optional) age and the timestamp 
 of when he/she was added to the system. For entities already in the database, we 
 want to just use the current date-time for that timestamp.
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Data.Time 
  
 import Control.Monad.IO.Class
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  name String
  
  
  age Int Maybe
  
  
  created UTCTime default=now() 
  
 |]
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do time 
 <- liftIO getCurrentTime
  
  runMigration migrateAll
  
  insert $ Person ""Michael"" (Just 26) time
  
  insert $ Person ""Greg"" Nothing time
  
 Maybe
  is a built-in, single-word attribute. It makes the field optional. In Haskell, this 
 means it is wrapped in a 
 Maybe
 . In SQL, it makes the column nullable.
  
 The 
 default
  attribute is backend specific, and uses whatever syntax is understood by 
 the database. In this case, it uses the database’s built-in 
 now()
  function. Suppose 
 that we now want to add a field for a person’s favorite programming language:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Data.Time
  
 108 | Chapter 10:Persistent",NA
Relations,"Persistent allows references between your data types in a manner that is consistent 
 with supporting non-SQL databases. We do this by embedding an ID in the related 
 entity.
  
 So if a person has many cars:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Control.Monad.IO.Class (liftIO) 
  
 import Data.Time
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  name String 
  
 Car
  
  
  ownerId PersonId Eq
  
  
  name String 
  
 |]
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do 
 runMigration migrateAll
  
  bruce <- insert $ Person ""Bruce Wayne""
  
  insert $ Car bruce ""Bat Mobile""
  
  insert $ Car bruce ""Porsche""
  
  -- this could go on a while
  
  cars <- selectList [CarOwnerId ==. bruce] [] liftIO $ print 
 cars
  
 Using this technique, you can define one-to-many relationships. To define many-to-
 many relationships, we need a join entity, which has a one-to-many relationship 
 with each of the original tables. It is also a good idea to use uniqueness constraints 
 on these. For example, to model a situation where we want to track which people 
 have shopped in which stores:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH 
  
 import Data.Time
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  name String 
  
 Store
  
  
  name String 
  
 PersonStore
  
  
  personId PersonId
  
  
  storeId StoreId
  
  
  UniquePersonStore personId storeId 
  
 |]
  
 110 | Chapter 10:Persistent",NA
Closer Look at Types,"So far, we’ve spoken about 
 Person
  and 
 PersonId
  without really explaining what they 
 are. In the simplest sense, for a SQL-only system, the 
 PersonId
  could just be 
 type Per 
 sonId = Int64
 . However, that means there is nothing binding a 
 PersonId
  at the type 
 level to the 
 Person
  entity. As a result, you could accidentally use a 
 PersonId
  and get a 
 Car
 . In order to model this relationship, we use phantom types. So, our next naive 
 step would be:
  
 newtype Key entity = Key Int64 
  
 type PersonId = Key Person
  
  
 Prior to Persistent 0.6, we used associated types instead of phantom 
 types. You could solve the problem in that direction as well, but 
 phan-toms worked out better.
  
 And that works out really well, until you get to a backend that doesn’t use Int64 for 
 its IDs. And that’s not just a theoretical question; MongoDB uses 
 ByteString
 s instead. 
 So what we need is a key value that can contain an 
 Int
  and a 
 ByteString
 . Seems like a 
 great time for a sum type:
  
 data Key entity = KeyInt Int64 | KeyByteString ByteString
  
 But that’s just asking for trouble. Next we’ll have a backend that uses timestamps, 
 so we’ll need to add another constructor to 
 Key
 . This could go on for a while. 
 Fortunately, we already have a sum type intended for representing arbitrary data: 
 PersistValue
 :
  
 newtype Key entity = Key PersistValue
  
 But this has another problem. Let’s say we have a web application that takes an ID 
 as a parameter from the user. It will need to receive that parameter as 
 Text
  and then 
 try",NA
Custom Fields,"Occassionally, you will want to define a custom field to be used in your datastore. 
 The most common case is an enumeration, such as employment status. For this, 
 Persistent provides a helper Template Haskell function:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
  
  OverloadedStrings, GADTs, FlexibleContexts #-} 
  
 import Database.Persist 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.TH
  
 data Employment = Employed | Unemployed | Retired
  
  
 deriving (Show, Read, Eq) 
  
 derivePersistField ""Employment""
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Person
  
  
  name String
  
  
  employment Employment 
  
 |]
  
 main = withSqliteConn "":memory:"" $ runSqlConn $ do
  
  
 runMigration migrateAll
  
  insert $ Person ""Bruce Wayne"" Retired
  
  insert $ Person ""Peter Parker"" Unemployed
  
  insert $ Person ""Michael"" Employed
  
 derivePersistField
  stores the data in the database using a string field, and performs 
 marshaling using the 
 Show
  and 
 Read
  instances of the data type. This may not be as 
 efficient as storing via an integer, but it is much more future proof: even if you add 
 extra constructors in the future, your data will still be valid.",NA
Persistent: Raw SQL,"The Persistent package provides a type-safe interface to data stores. It tries to be 
 back-end-agnostic, such as not relying on relational features of SQL. My experience 
 has been that you can easily perform 95% of what you need to do with the high-
 level interface.
  
 (In fact, most of my web apps use the high-level interface exclusively.)
  
 But occassionally you’ll want to use a feature that’s specific to a backend. One 
 feature I’ve used in the past is full text search. In this case, we’ll use the SQL “LIKE” 
 operator,
  
 Persistent: Raw SQL | 113",NA
Integration with Yesod,"So you’ve been convinced of the power of Persistent. How do you integrate it with 
 your Yesod application? If you use the scaffolding, most of the work is done for you 
 already. But as we normally do, we’ll build up everything manually here to point 
 out how it works under the surface.
  
 114 | Chapter 10:Persistent",NA
Summary,"Persistent brings the type safety of Haskell to your data access layer. Instead of 
 writing error-prone, untyped data access, or manually writing boilerplate marshal 
 code, you can rely on Persistent to automate the process for you.
  
 The goal is to provide everything you need, 
 most
  of the time. For the times when 
 you need something a bit more powerful, Persistent gives you direct access to the 
 underlying data store, so you can write whatever five-way joins you want.
  
 Persistent integrates directly into the general Yesod workflow. Not only do helper 
 packages like 
 yesod-persistent
  provide a nice layer, but packages like 
 yesod-form
  and 
 yesod-auth
  also leverage Persistent’s features as well.",NA
CHAPTER 11,NA,NA
Deploying Your Webapp,"I can’t speak for others, but I personally prefer programming to system 
 administration. But the fact is that, eventually, you need to serve your app 
 somehow, and odds are that you’ll need to be the one to set it up.
  
 There are some promising initiatives in the Haskell web community towards 
 making deployment easier. In the future, we may even have a service that allows 
 you to deploy your app with a single command.
  
 But we’re not there yet. And even if we were, such a solution will never work for 
 everyone. This chapter covers the different options you have for deployment, and 
 gives some general recommendations on what you should choose in different 
 situations.",NA
Compiling,"First things first: how do you build your production application? If you’re using the 
 scaffolded site, it’s as simple as 
 cabal build
 . I also recommend cleaning beforehand 
 to make sure there is no cached information, so a simple combination to build your 
 executable is:
  
 cabal clean && cabal configure && cabal build",NA
Warp,"As we have mentioned before, Yesod is built on the Web Application Interface 
 (WAI), allowing it to run on any WAI backend. At the time of writing, the following 
 backends are available:
  
 • Warp
  
 • FastCGI
  
 • SCGI
  
 • CGI
  
 117",NA
Configuration,"In general, Nginx will listen on port 80 and your Yesod/Warp app will listen on 
 some unprivileged port (lets say 4321). You will then need to provide a 
 nginx.conf
  
 file, such as:
  
 daemon off; # Don't run nginx in the background, good for monitoring apps events {
  
  
  worker_connections 4096; 
  
 }
  
 http {
  
  
  server {
  
 118 | Chapter 11:Deploying Your Webapp",NA
Server Process,"Many people are familiar with an Apache/mod_php or Lighttpd/FastCGI kind of 
 setup, where the web server automatically spawns the web application. With nginx, 
 either for reverse proxying or FastCGI, this is not the case: you are responsible for 
 running your own process. I strongly recommend a monitoring utility that will 
 automatically restart your application in case it crashes. There are many great 
 options out there, such as 
 angel
  or daemontools.
  
 To give a concrete example, here is an Upstart config file. The file must be placed in 
 / etc/init/mysite.conf
 :
  
 description ""My awesome Yesod application"" 
  
 start on runlevel [2345]; 
  
 stop on runlevel [!2345]; 
  
 respawn 
  
 chdir /home/michael/sites/mysite 
  
 exec /home/michael/sites/mysite/dist/build/mysite/mysite
  
 Once this is in place, bringing up your application is as simple as 
 sudo start mysite
 .",NA
FastCGI,"Some people may prefer using FastCGI for deployment. In this case, you’ll need to 
 add an extra tool to the mix. FastCGI works by receiving new connections from a 
 file descriptor. The C library assumes that this file descriptor will be 0 (standard 
 input), so you need to use the spawn-fcgi program to bind your application’s 
 standard input to the correct socket.
  
 It can be very convenient to use Unix named sockets for this instead of binding to a 
 port, especially when hosting multiple applications on a single host. A possible 
 script to load up your app could be:
  
 spawn-fcgi \
  
  -d /home/michael/sites/mysite \
  
  -s /tmp/mysite.socket \
  
  -n \
  
  -M 511 \
  
  -u michael \
  
  -- /home/michael/sites/mysite/dist/build/mysite-fastcgi/mysite-fastcgi
  
 You will also need to configure your frontend server to speak to your app over 
 FastCGI. This is relatively painless in Nginx:
  
 server {
  
  
  listen 80;
  
  
  server_name www.myserver.com;
  
  
  location / {
  
  
  
  fastcgi_pass unix:/tmp/mysite.socket;
  
  
  } 
  
 }
  
 120 | Chapter 11:Deploying Your Webapp",NA
Desktop,"Another nifty backend is 
 wai-handler-webkit
 . This backend combines Warp and 
 QtWebkit to create an executable that a user simply double-clicks. This can be a 
 con-venient way to provide an offline version of your application.
  
 One of the very nice conveniences of Yesod for this is that your templates are all 
 com-piled into the executable, and thus do not need to be distributed with your 
 application. Static files do, however.
  
  
 There’s actually support for embedding your static files directly in the 
 executable as well; see the 
 yesod-static
  docs for more details.
  
 A similar approach, without requiring the QtWebkit library, is 
 wai-handler-launch
 , 
 which launches a Warp server and then opens up the user’s default web browser. 
 There’s a little trickery involved here: in order to know that the user is still using 
 the site, 
 wai-handler-launch
  inserts a “ping” JavaScript snippet to every HTML page it 
 serves. If 
 wai-handler-launch
  doesn’t receive a ping for two minutes, it shuts down.",NA
CGI on Apache,"CGI and FastCGI work almost identically on Apache, so it should be fairly straight-
 forward to port this configuration. You essentially need to accomplish two goals:
  
 1. Get the server to serve your file as (Fast)CGI.
  
 2. Rewrite all requests to your site to go through the (Fast)CGI executable.
  
 CGI on Apache | 121",NA
FastCGI on lighttpd,"For this example, I’ve left off some of the basic FastCGI settings like mime-types. I 
 also have a more complex file in production that prepends “www.” when absent 
 and serves static files from a separate domain. However, this should serve to show 
 the basics.
  
 Here, “/home/michael/fastcgi” is the fastcgi application. The idea is to rewrite all 
 re-quests to start with “/app,” and then serve everything beginning with “/app” via 
 the FastCGI executable.
  
 server.port = 3000 
  
 server.document-root = ""/home/michael"" 
  
 server.modules = (""mod_fastcgi"", ""mod_rewrite"")
  
 url.rewrite-once = (
  
  ""(.*)"" => ""/app/$1"" 
  
 )
  
 fastcgi.server = (
  
  
  ""/app"" => ((
  
  
  
  ""socket"" => ""/tmp/test.fastcgi.socket"",
  
  
  
  ""check-local"" => ""disable"",
  
  
  
  ""bin-path"" => ""/home/michael/fastcgi"", # full path to executable
  
  
  ""min-procs"" => 1,
  
  
  
  ""max-procs"" => 30,
  
  
  
  ""idle-timeout"" => 30
  
  
  )) 
  
 )
  
 122 | Chapter 11:Deploying Your Webapp",NA
CGI on lighttpd,"This is basically the same as the FastCGI version, but tells lighttpd to run a file 
 ending in “.cgi” as a CGI executable. In this case, the file lives at 
 “/home/michael/myapp.cgi”.
  
 server.port = 3000 
  
 server.document-root = ""/home/michael"" 
  
 server.modules = (""mod_cgi"", ""mod_rewrite"")
  
 url.rewrite-once = (
  
  
  ""(.*)"" => ""/myapp.cgi/$1"" 
  
 )
  
 cgi.assign = ("".cgi"" => """")
  
 CGI on lighttpd | 123",NA
PART ,NA,NA
II ,NA,NA
Advanc,NA,NA
ed,NA,NA
CHAPTER 12,NA,NA
RESTful Content,"One of the stories from the early days of the Web is how search engines wiped out 
 entire websites. When dynamic web sites were still a new concept, developers 
 didn’t appreciate the difference between a 
 GET
  and 
 POST
  request. As a result, they 
 created pages—accessed with the 
 GET
  method—that would delete pages. When 
 search engines started crawling these sites, they could wipe out all the content.
  
 If these web developers had followed the HTTP spec properly, this would not have 
 happened. A 
 GET
  request is supposed to cause no side effects (you know, like 
 wiping out a site). Recently, there has been a move in web development to properly 
 embrace Representational State Transfer, also known as REST. This chapter 
 describes the RESTful features in Yesod and how you can use them to create more 
 robust web ap-plications.",NA
Request Methods,"In many web frameworks, you write one handler function per resource. In Yesod, 
 the default is to have a separate handler function for each 
 request method
 . The two 
 most common request methods you will deal with in creating websites are GET and 
 POST. These are the most well-supported methods in HTML, since they are the only 
 ones supported by web forms. However, when creating RESTful APIs, the other 
 methods are very useful.
  
 Technically speaking, you can create whichever request methods you like, but it is 
 strongly recommended to stick to the ones spelled out in the HTTP spec. The most 
 common of these are:
  
 GET 
  
 Read-only requests. Assuming no other changes occur on the server, calling a 
 GET 
 request multiple times should result in the same response, barring such 
 things as“current time” or randomly assigned results.
  
 127",NA
Representations,"Suppose we have a Haskell data type and value:
  
 data Person = Person { name :: String, age :: Int } michael = 
 Person ""Michael"" 25
  
 We could represent that data as HTML:
  
 <table>
  
  
  <tr>
  
  
  
  <th>Name</th>
  
  
  
  <td>Michael</td>
  
  
  </tr>
  
  
  <tr>
  
  
  
  <th>Age</th>
  
  
  
  <td>25</td>
  
  
  </tr> 
  
 </table>
  
 or we could represent it as JSON:
  
 {""name"":""Michael"",""age"":25}
  
 or as XML:
  
 <person>
  
  
  
 <name>Michael</name>
  
  
  <age>25</age> 
  
 </person>
  
 Oftentimes, web applications will use a different URL to get each of these 
 representations; perhaps 
 /person/michael.html
 , 
 /person/michael.json
 , etc. Yesod fol-
  
 128 | Chapter 12:RESTful Content",NA
RepHtmlJson,"An example to the contrary is 
 RepHtmlJson
 , which provides either an HTML or JSON 
 representation. This instance helps greatly in programming AJAX applications that 
 degrade nicely. Here is an example that returns either HTML or JSON data, 
 depending on what the client wants.
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, OverloadedStrings #-} {-# 
 LANGUAGE MultiParamTypeClasses, TemplateHaskell #-} import Yesod 
  
 data R = R 
  
 mkYesod ""R"" [parseRoutes| 
  
 / RootR GET 
  
 /#String NameR GET 
  
 |] 
  
 instance Yesod R
  
 Representations | 129",NA
News Feeds,"A great, practical example of multiple representations is the 
 yesod-newsfeed
  
 package. There are two major formats for news feeds on the Web: RSS and Atom. 
 They contain almost exactly the same information, but are just packaged 
 differently.
  
 The 
 yesod-newsfeed
  package defines a 
 Feed
  data type that contains information like 
 title, description, and last updated time. It then provides two separate sets of 
 functions for displaying this data: one for RSS, one for Atom. They each define their 
 own representation data types:
  
 newtype RepAtom = RepAtom Content 
  
 instance HasReps RepAtom where
  
  
  chooseRep (RepAtom c) _ = return (typeAtom, c) 
 newtype RepRss = RepRss Content 
  
 instance HasReps RepRss where
  
  
  chooseRep (RepRss c) _ = return (typeRss, c)
  
 But there’s a third module that defines another data type:
  
 data RepAtomRss = RepAtomRss RepAtom RepRss 
  
 instance HasReps RepAtomRss where
  
  
  chooseRep (RepAtomRss (RepAtom a) (RepRss r)) = chooseRep
  
  
  [ (typeAtom, a)
  
  
  
  , (typeRss, r)
  
  
  
  ]
  
 This data type will automatically serve whichever representation the client prefers, 
 de-faulting to Atom. If a client connects that only understands RSS, assuming it 
 provides the correct HTTP headers, Yesod will provide RSS output.",NA
Other Request Headers,"There are a great deal of other request headers available. Some of them only affect 
 the transfer of data between the server and client, and should not affect the 
 application at all. For example, 
 Accept-Encoding
  informs the server which 
 compression schemes the client understands, and 
 Host
  informs the server which 
 virtual host to serve up.",NA
Stateless,"I’ve saved this section for the last, not because it is less important, but rather 
 because there are no specific features in Yesod to enforce this.
  
 HTTP is a stateless protocol: each request is to be seen as the beginning of a 
 conver-sation. This means, for instance, it doesn’t matter to the server if you 
 requested five pages previously, it will treat your sixth request as if it’s your first 
 one.
  
 D
 ownload from Wow! eBook <www.wowebook.com>
  
 On the other hand, some features on websites won’t work without some kind of 
 state. For example, how can you implement a shopping cart without saving 
 information about items in between requests?
  
 The solution to this is cookies, and built on top of this, sessions. We have a whole 
 section addressing the sessions features in Yesod. However, I cannot stress enough 
 that this should be used sparingly.
  
 Let me give you an example. There’s a popular bug-tracking system that I deal with 
 on a daily basis that horribly abuses sessions. There’s a little drop-down on every 
 page to select the current project. Seems harmless, right? What that dropdown does 
 is set the current project in your session.
  
 The result of all this is that clicking on the “view issues” link is entirely dependent 
 on the last project you selected. There’s no way to create a bookmark to your 
 “Yesod”issues and a separate link for your “Hamlet” issues.
  
 The proper RESTful approach to this is to have one resource for all of the Yesod 
 issues and a separate one for all the Hamlet issues. In Yesod, this is easily done with 
 a route
  
 definition like:
  
 / ProjectsR GET 
  
 /projects/#ProjectID ProjectIssuesR GET 
  
 /issues/#IssueID IssueR GET
  
 Be nice to your users: proper stateless architecture means that basic features like 
 book-marks, permalinks, and the back/forward button will always work.",NA
Summary,"Yesod adheres to the following tenets of REST:
  
 • Use the correct request method.
  
 • Each resource should have precisely one URL.
  
 132 | Chapter 12:RESTful Content",NA
CHAPTER 13,NA,NA
Yesod’s Monads,"As you’ve read through this book, there have been a number of monads that have 
 appeared: 
 Handler
 , 
 Widget
 , and 
 YesodDB
  (for Persistent). As with most monads, each 
 one provides some specific functionality: 
 Handler
  gives access to the request and 
 allows you to send responses, a 
 Widget
  contains HTML, CSS, and JavaScript, and 
 YesodDB
  let’s you make database queries. In Model-View-Controller (MVC) terms, 
 we could con-sider 
 YesodDB
  to be the model, 
 Widget
  to be the view, and 
 Handler
  to 
 be the controller.
  
 So far, we’ve presented some very straightforward ways to use these monads: your 
 main handler will run in 
 Handler
 , using 
 runDB
  to execute a 
 YesodDB
  query, and 
 defaultLay out
  to return a 
 Widget
 , which in turn was created by calls to 
 toWidget
 .
  
 However, if we have a deeper understanding of these types, we can achieve some 
 fancier results.",NA
Monad Transformers,"Monads are like onions. Monads are 
 not
  like cakes. [Shrek, more or less]
  
 Before we get into the heart of Yesod’s monads, we need to understand a bit about 
 monad transformers. (If you already know all about monad transformers, you can 
 likely skip this section.) Different monads provide different functionality: 
 Reader
  
 allows read-only access to some piece of data throughout a computation, 
 Error
  
 allows you to short-circuit computations, and so on.
  
 Oftentimes, however, you would like to be able to combine a few of these features 
 together. After all, why not have a computation with read-only access to some 
 settings variable, which could error out at any time? One approach to this would be 
 to write a new monad like 
 ReaderError
 , but this has the obvious downside of 
 exponential com-plexity: you’ll need to write a new monad for every single possible 
 combination.
  
 Instead, we have monad transformers. In addition to 
 Reader
 , we have 
 ReaderT
 , 
 which adds reader functionality to any other monad. So we could represent our 
 ReaderError 
 as (conceptually):",NA
The Three Transformers,"We’ve already discussed two of our transformers previously: 
 Handler
  and 
 Widget
 . 
 Just to recap, there are two special things about these transformers:
  
 1. In order to simplify error messages, they are not actual transformers. Instead, 
 they are newtypes that hard-code their inner monads.
  
  
 Remember, this is why Yesod provides a specialized 
 lift
  function, 
 which works for 
 Handler
  and 
 Widget
 .
  
 2. In reality they have extra type parameters for the sub and master site. As a 
 result, the Yesod libraries provide 
 GHandler sub master a
  and 
 GWidget sub master 
 a
 , and each site gets a pair of type synonyms 
 type Handler = GHandler MyApp 
 MyApp
  and 
 type Widget = GWidget MyApp My App ()
 .
  
 In 
 persistent
 , we have a typeclass called 
 PersistStore
 . This typeclass defines all of the 
 primitive operations you can perform on a database, like 
 get
 . This typeclass 
 essentially looks like 
 class (Monad (b m)) => PersistStore b m
 . 
 b
  is the backend itself, 
 and is in fact a monad transformer, while 
 m
  is the inner monad that 
 b
  wraps 
 around. Both SQL and MongoDB have their own instances; in the case of SQL, it 
 looks like:
  
 instance MonadBaseControl IO m => PersistBackend SqlPersist m
  
 This means that you can run a SQL database with any underlying monad, so long as 
 that underlying monad supports 
 MonadBaseControl IO
 , which allows you to properly
  
 136 | Chapter 13:Yesod’s Monads",NA
Example: Database-Driven Navbar,"Let’s put some of this new knowledge into action. We want to create a 
 Widget
  that 
 generates its output based on the contents of the database. Previously, our 
 approach would have been to load up the data in a 
 Handler
 , and then pass that data 
 into a 
 Widget
 . Now, we’ll do the loading of data in the 
 Widget
  itself. This is a boon for 
 modularity, as this 
 Widget
  can be used in any 
 Handler
  we want, without any need to 
 pass in the database contents.
  
 {-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell, FlexibleContexts,
  
  
 QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-} 
  
 import Yesod 
  
 import Database.Persist.Sqlite 
  
 import Data.Text (Text) 
  
 import Data.Time
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Link
  
 Example: Database-Driven Navbar | 137",NA
Example: Request Information,"Likewise, you can get request information inside a 
 Widget
 . Here we can determine 
 the sort order of a list based on a GET parameter.
  
 {-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
  
  
  QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-} import 
 Yesod 
  
 import Data.Text (Text) 
  
 import Data.List (sortBy) 
  
 import Data.Ord (comparing)
  
 data Person = Person
  
  { personName :: Text
  
  , personAge :: Int
  
  }
  
 people :: [Person] 
  
 people =
  
  
  [ Person ""Miriam"" 25
  
  
  , Person ""Eliezer"" 3
  
  
  , Person ""Michael"" 26
  
  
  , Person ""Gavriella"" 1
  
  
  ]
  
 data People = People
  
 Example: Request Information | 139",NA
Summary,"If you completely ignore this chapter, you’ll still be able to use Yesod to great 
 benefit. The advantage of understanding how Yesod’s monads interact is to be able 
 to produce cleaner, more modular code. Being able to perform arbitrary actions in a 
 Widget
  can be a powerful tool, and understanding how Persistent and your 
 Handler
  
 code interact can help you make more informed design decisions in your app.
  
 140 | Chapter 13:Yesod’s Monads",NA
CHAPTER 14,NA,NA
Authentication and ,NA,NA
Authorization,"Authentication and authorization are two very related, and yet separate, concepts. 
 While the former deals with identifying a user, the latter determines what a user is 
 allowed to do. Unfortunately, since both terms are often abbreviated as “auth,” the 
 concepts are often conflated.
  
 Yesod provides built-in support for a number of third-party authentication 
 systems, such as OpenID, BrowserID, and OAuth. These are systems where your 
 application trusts some external system for validating a user’s credentials. 
 Additionally, there is support for more commonly used username/password and 
 email/password systems. The former route ensures simplicity for users (no new 
 passwords to remember) and implementors (no need to deal with an entire 
 security architecture), while the latter gives the developer more control.
  
 On the authorization side, we are able to take advantage of REST and type-safe 
 URLs to create simple, declarative systems. Additionally, since all authorization 
 code is writ-ten in Haskell, you have the full flexibility of the language at your 
 disposal.
  
 This chapter will cover how to set up an “auth” solution in Yesod and discuss some 
 trade-offs in the different authentication options.",NA
Overview,"The 
 yesod-auth
  package provides a unified interface for a number of different 
 authen-tication plug-ins. The only real requirement for these backends is that they 
 identify a user based on some unique string. In OpenID, for instance, this would be 
 the actual OpenID value. In BrowserID, it’s the email address. For HashD, which 
 uses a database of hashed passwords, it’s the username.
  
 Each authentication plug-in provides its own system for logging in, whether it be 
 via passing tokens with an external site or a email/password form. After a 
 successful login, the plug-in sets a value in the user’s session to indicate his/her 
 AuthId
 . This 
 AuthId
  is usually a Persistent ID from a table used for keeping track of 
 users.",NA
Authenticate Me,"Let’s jump right in with an example of authentication.
  
 {-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
  
  
 MultiParamTypeClasses, QuasiQuotes #-} 
  
 import Yesod 
  
 import Yesod.Auth 
  
 import Yesod.Auth.BrowserId 
  
 import Yesod.Auth.GoogleEmail 
  
 import Data.Text (Text) 
  
 import Network.HTTP.Conduit (Manager, newManager, def)
  
 data MyAuthSite = MyAuthSite
  
  { httpManager :: Manager
  
  }
  
 mkYesod ""MyAuthSite"" [parseRoutes| 
  
 / RootR GET 
  
 /auth AuthR Auth getAuth 
  
 |]
  
 instance Yesod MyAuthSite where
  
  
  -- Note: In order to log in with BrowserID, you must correctly
  
 142 | Chapter 14:Authentication and Authorization",NA
Email,"For many use cases, third-party authentication of email will be sufficient. 
 Occasionally, you’ll want users to actually create passwords on your site. The 
 scaffolded site does not include this setup, because:
  
 • In order to securely accept passwords, you need to be running over SSL. Many 
  
 users are not serving their sites over SSL.
  
 Email | 145",NA
Authorization,"Once you can authenticate your users, you can use their credentials to 
 authorize
  re-
 quests. Authorization in Yesod is simple and declarative: most of the time, you just 
 need to add the 
 authRoute
  and 
 isAuthorized
  methods to your Yesod typeclass 
 instance. Let’s see an example.
  
 {-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
  
  
  MultiParamTypeClasses, QuasiQuotes #-} 
  
 import Yesod 
  
 import Yesod.Auth 
  
 import Yesod.Auth.Dummy -- just for testing, don't use in real life!!!
  
 import Data.Text (Text) 
  
 import Network.HTTP.Conduit (Manager, newManager, def)
  
 data MyAuthSite = MyAuthSite
  
  { httpManager :: Manager
  
  }
  
 mkYesod ""MyAuthSite"" [parseRoutes| 
  
 / RootR GET POST 
  
 /admin AdminR GET 
  
 /auth AuthR Auth getAuth 
  
 |]
  
 instance Yesod MyAuthSite where
  
  
  authRoute _ = Just $ AuthR LoginR
  
  -- route name, then a boolean indicating if it's a write request isAuthorized 
 RootR True = isAdmin
  
  isAuthorized AdminR _ = isAdmin
  
  -- anyone can access other pages
  
  isAuthorized _ _ = return Authorized
  
 isAdmin = do
  
  
  mu <- maybeAuthId
  
  
  return $ case mu of
  
  
  
  Nothing -> AuthenticationRequired
  
  
  
  Just ""admin"" -> Authorized
  
  
  
  Just _ -> Unauthorized ""You must be an admin""
  
 instance YesodAuth MyAuthSite where
  
  type AuthId MyAuthSite = Text
  
  getAuthId = return . Just . credsIdent
  
 Authorization | 149",NA
Conclusion,"This chapter covered the basics of setting up user authentication, as well as how 
 the built-in authorization functions provide a simple, declarative approach for 
 users. While these are complicated concepts with many approaches, Yesod should 
 provide you with the building blocks you need to create your own customized auth 
 solution.
  
 Conclusion | 151",NA
CHAPTER 15,NA,NA
Scaffolding and the Site ,NA,NA
Template,"So you’re tired of running small examples, and ready to write a real site? Then 
 you’re at the right chapter. Even with the entire Yesod library at your fingertips, 
 there are still a lot of steps you need to go through to get a production-quality site 
 setup:
  
 • Config file parsing
  
 • Signal handling (*nix)
  
 • More efficient static file serving
  
 • A good file layout
  
 The scaffolded site is a combination of many Yesoders’ best practices brought 
 together into a ready-to-use skeleton for your sites. It is highly recommended for 
 all sites. This chapter will explain the overall structure of the scaffolding, how to 
 use it, and some of its less-than-obvious features.
  
 For the most part, this chapter will not contain code samples. It is recommended 
 that you follow along with an actual scaffolded site.
  
  
 Due to the nature of the scaffolded site, it is the most fluid 
 component of Yesod, and can change from version to version. It is 
 possible that the information in this chapter is slightly outdated.",NA
How to Scaffold,"The 
 yesod
  package installs both a library and an executable (conveniently named 
 yesod
  as well). This executable provides a few commands (run 
 yesod
  by itself to get 
 a list). In order to generate a scaffolding, the command is 
 yesod init
 . This will start a 
 question-and-answer process where you get to provide basic details (your name, 
 the project name, etc). After answering the questions, you will have a site template 
 in a subfolder with the name of your project.",NA
File Structure,"The scaffolded site is built as a fully cabalized Haskell package. In addition to source 
 files, config files, templates, and static files are produced as well.",NA
Cabal File,"Whether directly using 
 cabal
 , or indirectly using 
 yesod devel
 , building your code 
 will always go through the cabal file. If you open the file, you’ll see there are both 
 library and executable blocks. Only one of these is built at a time, depending on the 
 value of the 
 library-only
  flag. If 
 library-only
  is turned on, then the library is built, 
 which is how 
 yesod devel
  calls your app. Otherwise, the executable is built.
  
 The 
 library-only
  flag should only be used by 
 yesod devel
 ; you should never be 
 explicitly passing it into 
 cabal
 . There is an additional flag, 
 dev
 , that allows cabal to 
 build an executable, but turns on some of the same features as the library-only flag, 
 i.e., no optimizations and reload versions of the Shakespearean template functions.
  
 In general, you will build as follows:
  
 • When developing, use 
 yesod devel
  exclusively.
  
 • When building a production build, perform 
 cabal clean && cabal configure && 
  
 cabal build
 . This will produce an optimized executable in your 
 dist
  folder.
  
 154 | Chapter 15:Scaffolding and the Site Template",NA
Routes and Entities,"Multiple times in this book, you’ve seen a comment like “We’re declaring our 
 routes/ entities with quasiquotes for convenience. In a production site, you should 
 use an ex-ternal file.” The scaffolding uses such an external file.
  
 Routes are defined in 
 config/routes
 , and entities in 
 config/models
 . They have the 
 exact same syntax as the quasiquoting you’ve seen throughout the book, and 
 yesod 
 devel 
 knows to automatically recompile the appropriate modules when these files 
 change.
  
 The 
 models
  files is referenced by 
 Model.hs
 . You are free to declare whatever you like 
 in this file, but here are some guidelines:
  
 • Any data types used in 
 entities
 must
  be imported/declared in 
 Model.hs
 , above the 
  
 persistFile
  call.
  
 • Helper utilities should either be declared in 
 Import.hs
  or, if very model-centric, in 
  
 a file within the 
 Model
  folder and imported into 
 Import.hs
 .",NA
Foundation and Application Modules,"The 
 mkYesod
  function, which we have used throughout the book, declares a few 
 things:
  
 • Route type
  
 • Route render function",NA
Import,"The 
 Import
  module was born out of a few commonly recurring patterns.
  
 • I want to define some helper functions (maybe the 
 <> = mappend
  operator) to be 
  
 used by all handlers.
  
 • I’m always adding the same five import statements (
 Data.Text
 , 
 Control.Applica 
  
 tive
 , etc) to every handler module.
  
 • I want to make sure I never use some evil function (
 head
 , 
 readFile
 , ...) from 
 Prelude
 .
  
 156 | Chapter 15:Scaffolding and the Site Template",NA
Handler Modules,"Handler modules should go inside the 
 Handler
  folder. The site template includes 
 one module: 
 Handler/Root.hs
 . How you split up your handler functions into 
 individual modules is your decision, but a good rule of thumb is:
  
 • Different methods for the same route should go in the same file, e.g., 
 getBlogR
  and 
  
 postBlogR
 .
  
 • Related routes can also usually go in the same file, e.g., 
 getPeopleR
  and 
 getPersonR
 .
  
 Of course, it’s entirely up to you. When you add a new handler file, make sure you 
 do the following:
  
 • Add it to version control (you 
 are
  using version control, right?).
  
 • Add it to the cabal file.
  
 • Add it to the 
 Application.hs
  file.
  
 • Put a module statement at the top, and an 
 import Import
  line below it.
  
  
 One of the planned improvements to the 
 yesod
  executable is to 
 automate these four steps.",NA
widgetFile,"It’s very common to want to include CSS and JavaScript specific to a page. You don’t 
 want to have to remember to include those Lucius and Julius files manually every 
 time you refer to a Hamlet file. For this, the site template provides the 
 widgetFile
  
 function.
  
 If you have a handler function:
  
 getRootR = defaultLayout $(widgetFile ""homepage"")
  
 , Yesod will look for the following files:
  
 •
  templates/homepage.hamlet
  
 •
  templates/homepage.lucius
  
 widgetFile | 157",NA
defaultLayout,"One of the first things you’re going to want to customize is the look of your site. The 
 layout is actually broken up into two files:
  
 •
  templates/default-layout-wrapper.hamlet
  contains just the basic shell of a page. 
 This file is interpreted as plain Hamlet, not as a Widget, and therefore cannot 
 refer to other widgets, embed i18n strings, or add extra CSS/JS.
  
 •
  templates/default-layout.hamlet
  is where you would put the bulk of your page. 
 You 
 must
  remember to include the 
 widget
  value in the page, as that contains 
 the per-page contents. This file is interpreted as a Widget.
  
 Also, since default-layout is included via the 
 widgetFile
  function, any Lucius, Cassius, 
 or Julius files named 
 default-layout.*
  will automatically be included as well.",NA
Static Files,"The scaffolded site automatically includes the static file subsite, optimized for 
 serving files that will not change over the lifetime of the current build. What this 
 means is that:
  
 • When your static file identifiers are generated (e.g., 
 static/mylogo.png
  becomes 
 mylogo_png
 ), a query-string parameter is added to it with a hash of the contents 
 of the file. All of this happens at compile time.
  
 • When 
 yesod-static
  serves your static files, it sets expiration headers far in the 
  
 future, and includes an etag based on a hash of your content.
  
 • Whenever you embed a link to 
 mylogo_png
 , the rendering includes the query-
 string parameter. If you change the logo, recompile, and launch your new app, 
 the query string will have changed, causing users to ignore the cached copy and 
 download a new version.
  
 Additionally, you can set a specific static root in your 
 Settings.hs
  file to serve from a 
 different domain name. This has the advantage of not requiring transmission of 
 cookies",NA
Conclusion,"The purpose of this chapter was not to explain every line that exists in the 
 scaffolded site, but instead to give a general overview of how it works. The best 
 way to become more familiar with it is to jump right in and start writing a Yesod 
 site with it.
  
 Conclusion | 159",NA
CHAPTER 16,NA,NA
Internationalization,"Users expect our software to speak their language. Unfortunately for us, there will 
 likely be more than one language involved. While doing simple string replacement 
 isn’t too involved, correctly dealing with all the grammar issues can be tricky. After 
 all, who wants to see “List 1 file(s)” from a program output?
  
 But a real i18n solution needs to do more than just provide a means of achieving 
 the correct output. It needs to make this process easy for both the programmer and 
 the translator, and be relatively error-proof. Yesod’s answer to the problem gives 
 you:
  
 • Intelligent guessing of the user’s desired language based on request headers, 
 with 
  
 the ability to override.
  
 • A simple syntax for giving translations, which requires no Haskell knowledge. 
  
 (After all, most translators aren’t programmers.)
  
 • The ability to bring in the full power of Haskell for tricky grammar issues as 
  
 necessary, along with a default selection of helper functions to cover most 
 needs.
  
 • Absolutely no issues at all with word order.",NA
Synopsis,"-- @messages/en.msg 
  
 Hello: Hello 
  
 EnterItemCount: I would like to buy: 
  
 Purchase: Purchase 
  
 ItemCount count@Int: You have purchased #{showInt count} #{plural count ""item"" ""items""}.
  
 SwitchLanguage: Switch language to: 
  
 Switch: Switch
  
 -- @messages/he.msg 
  
 Hello: 
  שלום
  
 EnterItemCount: 
 אני רוצה לקנות: 
  
 Purchase: 
  קנה
  
 ItemCount count: 
 קנית
  #{showInt count} #{plural count ""
 דבר"" ""דברים""}.
  
 161",NA
Overview,"Most existing i18n solutions out there, like gettext or Java message bundles, work 
 on the principle of string lookups. Usually some form of printf-interpolation is used 
 to interpolate variables into the strings. In Yesod, as you might guess, we instead 
 rely on types. This gives us all of our normal advantages, such as the compiler 
 automatically catching mistakes.
  
 Let’s take a concrete example. Suppose our application has two things it wants to 
 say to a user: say hello, and state how many users are logged into the system. This 
 can be modeled with a sum type:
  
 data MyMessage = MsgHello | MsgUsersLoggedIn Int
  
 I can also write a function to turn this data type into an English representation:
  
 toEnglish :: MyMessage -> String 
  
 toEnglish MsgHello = ""Hello there!"" 
  
 toEnglish (MsgUsersLoggedIn 1) = ""There is 1 user logged in."" 
  
 toEnglish (MsgUsersLoggedIn i) = ""There are "" ++ show i ++ "" users logged in.""
  
 We can also write similar functions for other languages. The advantage to this 
 inside-Haskell approach is that we have the full power of Haskell for addressing 
 tricky grammar issues, especially pluralization.
  
  
 You may think pluralization isn’t so complicated: you have one 
 version for 1 item, and another for any other count. That might be 
 true in English, but it’s not true for every language. Russian, for 
 example, has six different forms, and you need to use some modulus 
 logic to deter-
  
 mine which one to use.
  
 The downside, however, is that you have to write all of this inside of Haskell, which 
 won’t be very translator-friendly. To solve this, Yesod introduces the concept of 
 message files. We’ll cover that in a little bit.
  
 Assuming we have this full set of translation functions, how do we go about using 
 them? What we need is a new function to wrap them all up together, and then 
 choose the appropriate translation function based on the user’s selected language. 
 Once we have that, Yesod can automatically choose the most relevant render 
 function and call it on the values you provide.
  
 Overview | 163",NA
Message Files,"The simplest approach to creating translations is via 
 message files
 . The setup is 
 simple: there is a single folder containing all of your translation files, with a single 
 file for each language. Each file is named based on its language code, e.g., 
 en.msg
 . 
 And each line in a file handles one phrase, which correlates to a single constructor 
 in your message data type.
  
 D
 ownload from Wow! eBook <www.wowebook.com>
  
  
 The scaffolded site already includes a fully configured message folder.
  
 So firstly, a word about language codes. There are really two choices available: 
 using a two-letter language code, or a language-LOCALE code. For example, when I 
 load up a page in my web browser, it sends two language codes: en-US and en. 
 What my browser is saying is “if you have American English, I like that the most. If 
 you have English, I’ll take that instead.”
  
 So which format should you use in your application? Most likely two-letter codes, 
 unless you are actually creating separate translations by locale. This ensures that 
 some-one asking for Canadian English will still see your English. Behind the scenes, 
 Yesod will add the two-letter codes where relevant. For example, suppose a user 
 has the following language list:
  
 pt-BR, es, he
  
 What this means is “I like Brazilian Portuguese, then Spanish, and then 
 Hebrew.”Suppose your application provides the languages pt (general Portuguese) 
 and English, with English as the default. Strictly following the user’s language list 
 would result in the user being served English. Instead, Yesod translates that list 
 into:
  
 pt-BR, es, he, pt
  
 In other words: unless you’re giving different translations based on locale, just stick 
 to the two-letter language codes.
  
 Now what about these message files? The syntax should be very familiar after your 
 work with Hamlet and Persistent. The line starts off with the name of the message. 
 Since this is a data constructor, it must start with a capital letter. Next, you can have 
 individual parameters, which must be given in lowercase. These will be arguments 
 to the data constructor.
  
 164 | Chapter 16:Internationalization",NA
Specifying Types,"Since we will be creating a data type out of our message specifications, each 
 parameter to a data constructor must be given a data type. We use a @-syntax for 
 this. For example, to create the data type 
 data MyMessage = MsgHello | MsgSayAge Int
 , 
 we would write:
  
 Hello: Hi there!
  
 SayAge age@Int: Your age is: #{show age}
  
 But there are two problems with this:
  
 1. It’s not very DRY (don’t repeat yourself) to have to specify this data type in 
 every file.
  
 2. Translators will be confused having to specify these data types.
  
 So instead, the type specification is only required in the main language file. This is 
 specified as the third argument in the 
 mkMessage
  function. This also specifies what 
 the backup language will be, to be used when none of the languages provided by 
 your application match the user’s language list.",NA
RenderMessage Typeclass,"Your call to 
 mkMessage
  creates an instance of the 
 RenderMessage
  typeclass, which is 
 the core of Yesod’s i18n. It is defined as:
  
 class RenderMessage master message where
  
  
  renderMessage :: master
  
  
  
  -> [Text] -- ^ languages
  
  
  
  -> message
  
  
  
  -> Text
  
 Notice that there are two parameters to the 
 RenderMessage
  class: the master site 
 and the message type. In theory, we could skip the master type here, but that would 
 mean that every site would need to have the same set of translations for each 
 message type. When it comes to shared libraries like forms, that would not be a 
 workable solution.
  
 The 
 renderMessage
  function takes a parameter for each of the class’s type 
 parameters: master and message. The extra parameter is a list of languages the 
 user will accept, in descending order of priority. The method then returns a user-
 ready 
 Text
  that can be displayed.",NA
Interpolation,"One way to use your new 
 RenderMessage
  instance would be to directly call the 
 render Message
  function. This would work, but it’s a bit tedious: you need to pass in 
 the foun-dation value and the language list manually. Instead, Hamlet provides a 
 specialized i18n interpolation, which looks like 
 _{...}
 .
  
  
 Why the underscore? Underscore is already a well-established 
 character for i18n, as it is used in the gettext library.
  
 Hamlet will then automatically translate that to a call to 
 renderMessage
 . Once 
 Hamlet gets the output 
 Text
  value, it uses the 
 toHtml
  function to produce an 
 Html
  
 value, meaning that any special characters (<, &, >) will be automatically escaped.
  
 166 | Chapter 16:Internationalization",NA
"Phrases, Not Words","As a final note, I’d just like to give some general i18n advice. Let’s say you have an 
 application for selling turtles. You’re going to use the word “turtle” in multiple 
 places, like “You have added 4 turtles to your cart.” and “You have purchased 4 
 turtles, congratulations!” As a programmer, you’ll immediately notice the code 
 reuse potential: we have the phrase “4 turtles” twice. So you might structure your 
 message file as:
  
 AddStart: You have added 
  
 AddEnd: to your cart.
  
 PurchaseStart: You have purchased 
  
 PurchaseEnd: , congratulations!
  
 Turtles count@Int: #{show count} #{plural ""turtle"" ""turtles""}
  
 STOP RIGHT THERE! This is all well and good from a programming perspective, but 
 translations are 
 not
  programming. There are a many things that could go wrong 
 with this, such as:
  
 • Some languages might put “to your cart” before “You have added.”
  
 • Maybe “added” will be constructed differently depending whether you added 1 
 or 
  
 more turtles.
  
 • There are a bunch of whitespace issues as well.
  
 So the general rule is: translate entire phrases, not just words.
  
 Phrases, Not Words | 167",NA
CHAPTER 17,NA,NA
Creating a Subsite,"How many sites provide authentication systems? Or need to provide Create, Read, 
 Update, Delete (CRUD) management of some objects? Or a blog? Or a wiki?
  
 The theme here is that many websites include common components that can be 
 reused throughout multiple sites. However, it is often quite difficult to get code to 
 be modular enough to be truly plug-and-play: a component will require hooks into 
 the routing system, usually for multiple routes, and will need some way of sharing 
 styling infor-mation with the master site.
  
 In Yesod, the solution is subsites. A subsite is a collection of routes and their 
 handlers that can be easily inserted into a master site. By using type classes, it is 
 easy to ensure that the master site provides certain capabilities, and to access the 
 default site layout. And with type-safe URLs, it’s easy to link from the master site to 
 subsites.",NA
Hello World,"Writing subsites is a little bit tricky, involving a number of different types. Let’s 
 start off with a simple Hello World subsite:
  
 {-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-} {-# 
 LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-} import 
 Yesod
  
 -- Subsites have foundations just like master sites. data 
 HelloSub = HelloSub
  
 -- We have a familiar analogue from mkYesod, with just one extra parameter.-- We'll 
 discuss that later.
  
 mkYesodSub ""HelloSub"" [] [parseRoutes| 
  
 / SubRootR GET 
  
 |]
  
 -- And we'll spell out the handler type signature.
  
 getSubRootR :: Yesod master => GHandler HelloSub master RepHtml 
 getSubRootR = defaultLayout [whamlet|Welcome to the subsite!|]
  
 169",NA
PART ,NA,NA
III ,NA,NA
Exampl,NA,NA
es,NA,NA
CHAPTER 18,NA,NA
"Blog: i18n, ",NA,NA
"Authentication, ",NA,NA
"Authorization, and ",NA,NA
Database,"This is a simple blog app. It allows an admin to add blog posts via a rich-text editor (nicedit), 
 allows logged-in users to comment, and has full i18n support.
  
 It is also a good example of using a Persistent database, leveraging Yesod's authorization 
 system, and templates.
  
 While in general we recommend placing templates, Persistent entity definitions, and routing 
 in separate files, we'll keep it all in one file here for 
  
 convenience. The one exception you'll see below will be i18n messages.
  
 We'll start off with our language extensions. In scaffolded code, the language extensions are 
 specified in the cabal file, so you won't need to put this in your individual Haskell files.
  
 > {-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes, >              
 TemplateHaskell, GADTs, FlexibleContexts, >              
 MultiParamTypeClasses #-}
  
 Now our imports.
  
 > import Yesod 
  
 > import Yesod.Auth 
  
 > import Yesod.Form.Nic (YesodNic, nicHtmlField) 
  
 > import Yesod.Auth.BrowserId (authBrowserId) 
  
 > import Data.Text (Text) 
  
 > import Network.HTTP.Conduit (Manager, newManager, def) > 
 import Database.Persist.Sqlite 
  
 >     ( ConnectionPool, SqlPersist, runSqlPool, runMigration >     , 
 createSqlitePool 
  
 >     ) 
  
 > import Data.Time (UTCTime, getCurrentTime) 
  
 > import Control.Applicative ((<$>), (<*>), pure)
  
 First we'll set up our Persistent entities. We're going to create both our data types (via 
 mkPersist) and a migration function, which will automatically create and update our SQL 
 schema. If you were using the MongoDB backend, migration would not be needed.",NA
CHAPTER 19,NA,NA
"Wiki: Markdown, Chat ",NA,NA
Subs,NA,NA
"ite, ",NA,NA
Even,NA,NA
t ,NA,NA
Sour,NA,NA
ce,"This example will tie together a few different ideas. We’ll start with a chat subsite, 
 which allows us to embed a chat widget on any page. We’ll use the HTML5 event 
 source API to handle sending events from the server to the client.
  
 -- @Chat.hs 
  
 {-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
  
   
  TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
  
  
  FlexibleContexts
  
  #-}
  
 -- | This module defines a subsite that allows you to insert a chat box on-- any page of 
 your site. It uses eventsource for sending the messages from-- the server to the 
 browser.
  
 module Chat where
  
 import Yesod 
  
 import Control.Concurrent.Chan (Chan, dupChan, writeChan) 
  
 import Data.Text (Text) 
  
 import Network.Wai.EventSource (ServerEvent (..), eventSourceAppChan) import 
 Language.Haskell.TH.Syntax (Type (VarT), Pred (ClassP), mkName) import 
 Blaze.ByteString.Builder.Char.Utf8 (fromText) 
  
 import Data.Monoid (mappend)
  
 -- | Our subsite foundation. We keep a channel of events that all connections-- will share.
  
 data Chat = Chat (Chan ServerEvent)",NA
CHAPTER 20,NA,NA
JSON Web Service,"Let’s create a very simple web service: it takes a JSON request and returns a JSON 
 response. We’re going to write the server in WAI/Warp, and the client in 
 http-
 conduit
 . We’ll be using 
 aeson
  for JSON parsing and rendering. We could also write 
 the server in Yesod itself, but for such a simple example, the extra features of Yesod 
 don’t add much.",NA
Server,"WAI uses the 
 conduit
  package to handle streaming request bodies, and efficiently 
 generates responses using 
 blaze-builder
 . 
 aeson
  uses 
 attoparsec
  for parsing; by using 
 attoparsec-conduit
  we get easy interoperability with WAI. This plays out as:
  
 {-# LANGUAGE OverloadedStrings #-} 
  
 import Network.Wai (Response, responseLBS, Application, requestBody) import 
 Network.HTTP.Types (status200, status400) 
  
 import Network.Wai.Handler.Warp (run) 
  
 import Data.Aeson.Parser (json) 
  
 import Data.Conduit.Attoparsec (sinkParser) 
  
 import Control.Monad.IO.Class (liftIO) 
  
 import Data.Aeson (Value, encode, object, (.=)) 
  
 import Control.Exception (SomeException) 
  
 import Data.ByteString (ByteString) 
  
 import Data.Conduit (ResourceT, ($$)) 
  
 import Control.Exception.Lifted (handle)
  
 main :: IO () 
  
 main = run 3000 app
  
 app :: Application 
  
 app req = handle invalidJson $ do
  
  
  value <- requestBody req $$ sinkParser json
  
  newValue <- liftIO $ modValue value
  
  
  return $ responseLBS
  
  
  
  status200
  
  
  
  [(""Content-Type"", ""application/json"")]
  
 193",NA
Client,"http-conduit
  was written as a companion to WAI. It too uses 
 conduit
  and 
 blaze-builder
  
 pervasively, meaning we once again get easy interop with 
 aeson
 . A few extra 
 comments for those not familiar with 
 http-conduit
 :
  
 • A 
 Manager
  is present to keep track of open connections, so that multiple requests 
 to the same server use the same connection. You usually want to use the 
 withMan ager
  function to create and clean up this 
 Manager
 , since it is exception 
 safe.
  
 • We need to know the size of our request body, which can’t be determined 
 directly from a 
 Builder
 . Instead, we convert the 
 Builder
  into a lazy 
 ByteString
  and 
 take the size from there.
  
 • There are a number of different functions for initiating a request. We use 
 http
 , 
 which allows us to directly access the data stream. There are other higher level 
 functions (such as 
 httpLbs
 ) that let you ignore the issues of sources and get the 
 entire body directly.
  
 {-# LANGUAGE OverloadedStrings #-} 
  
 import Network.HTTP.Conduit
  
  
  ( http, parseUrl, withManager, RequestBody (RequestBodyLBS)
  
  , 
 requestBody, method, Response (..)
  
  
  ) 
  
 import Data.Aeson (Value (Object, String)) 
  
 import Data.Aeson.Parser (json) 
  
 import Data.Conduit (($$)) 
  
 import Data.Conduit.Attoparsec (sinkParser) 
  
 import Control.Monad.IO.Class (liftIO) 
  
 import Data.Aeson (encode, (.=), object)
  
 main :: IO () 
  
 main = withManager $ \manager -> do
  
  
  value <- liftIO makeValue
  
  
  -- We need to know the size of the request body, so we convert to a
  
  -- 
 ByteString
  
  
  let valueBS = encode value
  
  
  req' <- liftIO $ parseUrl ""http://localhost:3000/""
  
 194 | Chapter 20:JSON Web Service",NA
CHAPTER 21,NA,NA
Case Study: Sphinx-Based ,NA,NA
Search,"Sphinx
  is a search server, and powers the search feature on many sites, including 
 Yesod’s own site. While the actual code necessary to integrate Yesod with Sphinx is 
 relatively short, it touches on a number of complicated topics, and is therefore a 
 great case study in how to play with some of the under-the-surface details of Yesod.
  
 There are essentially three different pieces at play here:
  
 • Storing the content we wish to search. This is fairly straightforward Persistent 
 code, 
  
 and we won’t dwell on it much in this chapter.
  
 • Accessing Sphinx search results from inside Yesod. Thanks to the 
 sphinx
  package, 
  
 this is actually very easy.
  
 • Providing the document content to Sphinx. This is where the interesting stuff 
 happens, and will show how to deal with streaming content from a database di-
 rectly to XML, which gets sent directly over the wire to the client.",NA
Sphinx Setup,"Unlike many of our other examples, to start with here we’ll need to actually 
 configure and run our external Sphinx server. I’m not going to go into all the details 
 of Sphinx, partly because it’s not relevant to our point here, and mostly because I’m 
 not an expert on Sphinx.
  
 Sphinx provides three main command-line utilities: 
 searchd
  is the actual search 
 daemon that receives requests from the client (in this case, our web app) and 
 returns the search results. 
 indexer
  parses the set of documents and creates the 
 search index. 
 search
  is a debugging utility that will run simple queries against 
 Sphinx.
  
 There are two important settings: the source and the index. The source tells Sphinx 
 where to read document information from. It has direct support for MySQL and 
 PostgreSQL, as well as a more general XML format known as xmlpipe2. We’re going",NA
Basic Yesod Setup,"Let’s get our basic Yesod setup going. We’re going to have a single table in the 
 database for holding documents, which consist of a title and content. We’ll store 
 this in a SQLite database, and provide routes for searching, adding documents, 
 viewing documents, and providing the xmlpipe file to Sphinx.
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Doc
  
  
  title Text
  
  
  content Textarea 
  
 |]
  
 data Searcher = Searcher ConnectionPool
  
 mkYesod ""Searcher"" [parseRoutes| 
  
 / RootR GET 
  
 /doc/#DocId DocR GET 
  
 /add-doc AddDocR POST 
  
 /search SearchR GET 
  
 /search/xmlpipe XmlpipeR GET 
  
 |]
  
 198 | Chapter 21:Case Study: Sphinx-Based Search",NA
Searching,"Now that we’ve got the boring stuff out of the way, let’s jump into the actual 
 searching. We’re going to need three pieces of information for displaying a result: 
 the document ID it comes from, the title of that document, and the 
 excerpts
 . 
 Excerpts are the high-lighted portions of the document which contain the search 
 term.
  
 So let’s start off by defining a Result data type:
  
 data Result = Result
  
  { resultId :: DocId
  
  , resultTitle :: Text
  
  , resultExcerpt :: Html
  
  }
  
 200 | Chapter 21:Case Study: Sphinx-Based Search",NA
Streaming xmlpipe Output,"We’ve saved the best for last. For the majority of Yesod handlers, the recommended 
 approach is to load up the database results into memory and then produce the 
 output document based on that. It’s simpler to work with, but more importantly it’s 
 more resilient to exceptions. If there’s a problem loading the data from the 
 database, the user will get a proper 500 response code.
  
  
 What do I mean by “proper 500 response code”? If you start 
 streaming a response to a client, and encounter an exception 
 halfway through, there’s no way to change the status code; the user 
 will see a 200 response that simply stops in the middle. Not only can 
 this partial content be
  
 confusing, but it’s an invalid usage of the HTTP spec.
  
 However, generating the xmlpipe output is a perfect example of the alternative. 
 There are potentially a huge number of documents (the yesodweb.com code 
 handles tens of thousands of these), and documents could easily be several 
 hundred kilobytes. If we take a non-streaming approach, this can lead to huge 
 memory usage and slow response times.
  
 So how exactly do we create a streaming response? As we cover in the WAI chapter, 
 we have a 
 ResponseSource
  constructor that uses a stream of blaze-builder 
 Builder
 s. 
 From the Yesod side, we can avoid the normal Yesod response procedure and send 
 a WAI response directly using the 
 sendWaiResponse
  function. So there are at least 
 two of the pieces of this puzzle.
  
 Now we know we want to create a stream of 
 Builder
 s from some XML content. 
 Fortunately, the 
 xml-conduit
  package provides this interface directly. 
 xml-conduit
  
 pro-vides some high-level interfaces for dealing with documents as a whole, but in 
 our case, we’re going to need to use the low-level Event interface to ensure minimal 
 memory impact. So the function we’re interested in is:
  
 Streaming xmlpipe Output | 203",NA
Full Code,"{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
  
  
  QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts #-} 
  
 import Yesod 
  
 import Data.Text (Text, unpack) 
  
 import Control.Applicative ((<$>), (<*>)) 
  
 import Database.Persist.Sqlite 
  
 import Database.Persist.Query.GenericSql (selectSourceConn) import 
 Database.Persist.Store (PersistValue (PersistInt64)) import qualified 
 Text.Search.Sphinx as S 
  
 import qualified Text.Search.Sphinx.Types as ST 
  
 import qualified Text.Search.Sphinx.ExcerptConfiguration as E import 
 qualified Data.ByteString.Lazy as L 
  
 import Data.Text.Lazy.Encoding (decodeUtf8With) 
  
 import Data.Text.Encoding.Error (ignore) 
  
 import Data.Maybe (catMaybes) 
  
 import Control.Monad (forM) 
  
 import qualified Data.Text as T 
  
 import Text.Blaze (preEscapedLazyText) 
  
 import qualified Data.Conduit as C 
  
 import qualified Data.Conduit.List as CL 
  
 import qualified Data.XML.Types as X 
  
 import Network.Wai (Response (ResponseSource)) 
  
 import Network.HTTP.Types (status200) 
  
 import Text.XML.Stream.Render (renderBuilder, def) 
  
 import Data.Monoid (mconcat) 
  
 import Data.Conduit.Pool (takeResource, mrValue, mrReuse)
  
 share [mkPersist sqlSettings, mkMigrate ""migrateAll""] [persist| Doc
  
  
  title Text
  
  
  content Textarea 
  
 |]
  
 data Searcher = Searcher ConnectionPool
  
 mkYesod ""Searcher"" [parseRoutes|
  
 206 | Chapter 21:Case Study: Sphinx-Based Search",NA
PART ,NA,NA
IV ,NA,NA
Appendi,NA,NA
ces,NA,NA
APPENDIX A,NA,NA
monad-control,"monad-control
  is used in a few places within Yesod, most notably to ensure proper 
 exception handling within Persistent. It is a general purpose package to extend 
 standard functionality in monad transformers.",NA
Overview,"One of the powerful, and sometimes confusing, features in Haskell is monad trans-
 formers. They allow you to take different pieces of functionality—such as mutable 
 state, error handling, or logging—and compose them together easily. Though I 
 swore I’d never write a monad tutorial, I’m going to employ a painful analogy here: 
 monads are like onions. (Monads are not like cakes.) By that, I mean 
 layers
 .
  
 We have the core monad, also known as the innermost or bottom monad. On top of 
 this core, we add layers, each adding a new feature and spreading 
 outward/upward. As a motivating example, let’s consider an Error monad stacked 
 on top of the IO monad:
  
 newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) } type 
 MyStack = ErrorT MyError IO
  
 Now pay close attention here: ErrorT is just a simple newtype around an Either 
 wrapped in a monad. Getting rid of the newtype, we have:
  
 type ErrorTUnwrapped e m a = m (Either e a)
  
 At some point, we’ll need to actually perform some IO inside our MyStack. If we 
 went with the unwrapped approach, it would be trivial, since there would be no 
 ErrorT constructor in the way. However, we need that newtype wrapper for a 
 whole bunch of type reasons I won’t go into here (this isn’t a monad transformer 
 tutorial, after all). So the solution is the MonadTrans typeclass:
  
 class MonadTrans t where
  
  
  lift :: Monad m => m a -> t m a
  
 213",NA
Intuition,"Let’s try and develop an external intuition of what’s happening here. The ErrorT 
 monad transformer adds extra functionality to the IO monad. We’ve defined a way 
 to “tack",NA
Types,"I purposely started with the ErrorT transformer, as it is one of the simplest for this 
 inversion mechanism. Unfortunately, others are a bit more complicated. Take for 
 instance, ReaderT. It is defined as 
 newtype ReaderT r m a = ReaderT { runReaderT :: r -> 
 m a }
 . If we apply 
 runReaderT
  to it, we get a function that returns a monadic value. So 
 we’re going to need some extra machinery to deal with all that stuff. And this is 
 when we leave Kansas behind.
  
 There are a few approaches to solving these problems. In the past, I implemented a 
 solution using type families in the 
 neither
  package. Anders Kaseorg implemented a 
 much more straightforward solution in 
 monad-peel
 . And for efficiency, in 
 monad-
 control
 , Bas van Dijk uses CPS (continuation passing style) and existential types.
  
  
 The code taken from monad-control actually applies to version 
 0.2.0.3 changed things just a bit, by making the state explicit with an 
 associated 
 type, 
 and 
 generalizing 
 MonadControlIO
  
 to 
 MonadBaseControl
 , but the con-cepts are still the same.
  
 The first type we’re going to look at is:
  
 type Run t = forall n o b. (Monad n, Monad o, Monad (t o)) => t n b -> n (t o b)
  
 That’s incredibly dense, so let’s talk it out. The only “input” data type to this thing is 
 t, a monad transformer. A Run is a function that will then work with 
 any
  
 combination of types n, o, and b (that’s what the forall means). n and o are both 
 monads, while b is a simple value contained by them.
  
 The lefthand side of the Run function, 
 t n b
 , is our monad transformer wrapped 
 around the n monad and holding a b value. So for example, that could be a 
 MyTrans 
 FirstMonad MyValue
 . It then returns a value with the transformer “popped” inside, 
 with a brand new monad at its core. In other words, 
 FirstMonad (MyTrans NewMonad 
 MyValue)
 .
  
 That might sound pretty scary at first, but it actually isn’t as foreign as you’d think: 
 this is essentially what we did with ErrorT. We started with ErrorT on the outside, 
 wrapping around IO, and ended up with an IO by itself containing an Either. Well, 
 guess what: another way to represent an Either is 
 ErrorT MyError Identity
 . So essen-
 tially, we pulled the IO to the outside and plunked an Identity in its place. We’re 
 doing the same thing in a Run: pulling the FirstMonad outside and replacing it with 
 a New-Monad.
  
 216 | Appendix A:monad-control",NA
MonadTransControl,"Obviously, in the specific case we have before us, we could use our knowledge of 
 the ErrorT transformer to beat the types into submission and create our Run 
 function manually. But what we 
 really
  want is a general solution for many 
 transformers. At this point, you know we need a typeclass.
  
 So let’s review what we need: access to a Run function, and some way to 
 restructure our original transformer after the fact. And thus was born 
 MonadTransControl, with its single method liftControl:
  
 class MonadTrans t => MonadTransControl t where
  
  
  liftControl :: Monad m => (Run t -> m a) -> t m a
  
 Let’s look at this closely. liftControl takes a function (the one we’ll be writing). That 
 function is provided with a Run function, and must return a value in some monad 
 (m). liftControl will then take the result of that function and reinstate the original 
 trans-former on top of everything.
  
 useMyFileError3 :: Monad m => ErrorT MyError IO (ErrorT MyError m ()) 
 useMyFileError3 =
  
   
  liftControl inside
  
  where
  
   
  inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
  
  
  inside run = withMyFile $ helper run
  
 Types | 217",NA
MonadControlIO,"The MonadTrans class provides the lift method, which allows you to lift an action 
 one level in the stack. There is also the MonadIO class that provides liftIO, which 
 lifts an IO action as far in the stack as desired. We have the same breakdown in 
 monad-control.
  
 But first, we need a corollary to Run:
  
 type RunInBase m base = forall b. m b -> base (m b)
  
 Instead of dealing with a transformer, we’re dealing with two monads. base is the 
 underlying monad, and m is a stack built on top of it. RunInBase is a function that 
 takes a value of the entire stack, pops out that base, and puts in on the outside. 
 Unlike in the Run type, we don’t replace it with an arbitrary monad, but with the 
 original one. To use some more concrete types:
  
 RunInBase (ErrorT MyError IO) IO = forall b. ErrorT MyError IO b -> IO (ErrorT MyError IO b)
  
 This should look fairly similar to what we’ve been looking at so far, the only 
 difference is that we want to deal with a specific inner monad. Our MonadControlIO 
 class is really just an extension of MonadControlTrans using this RunInBase.
  
 class MonadIO m => MonadControlIO m where
  
  
  liftControlIO :: (RunInBase m IO -> IO a) -> m a
  
 Simply put, liftControlIO takes a function, which receives a RunInBase. That RunIn-
 Base can be used to strip down our monad to just an IO, and then liftControlIO 
 builds everything back up again. And like MonadControlTrans, it comes with a 
 helper func-tion:
  
 controlIO :: MonadControlIO m => (RunInBase m IO -> IO (m a)) -> m a controlIO 
 = join . liftControlIO
  
 We can easily rewrite our previous example with it:
  
 useMyFileError7 :: ErrorT MyError IO () 
  
 useMyFileError7 = controlIO $ \run -> withMyFile $ run . sayHiError
  
 And as an advantage, it easily scales to multiple transformers:
  
 sayHiCrazy :: Handle -> ReaderT Int (StateT Double (ErrorT MyError IO)) () sayHiCrazy 
 handle = liftIO $ hPutStrLn handle ""Madness!""
  
 useMyFileCrazy :: ReaderT Int (StateT Double (ErrorT MyError IO)) () 
 useMyFileCrazy = controlIO $ \run -> withMyFile $ run . sayHiCrazy",NA
Real Life Examples,"Let’s solve some real-life problems with this code. Probably the biggest motivating 
 use case is exception handling in a transformer stack. For example, let’s say that we 
 want
  
 Real Life Examples | 219",NA
Lost State,"Let’s rewind a bit to our onExceptionError. It uses onException under the surface, 
 which has a type signature: 
 IO a -> IO b -> IO a
 . Let me ask you something: what 
 happened to the b in the output? Well, it was thoroughly ignored. But that seems to 
 cause us a bit of a problem. After all, we store our transformer state information in 
 the value of the inner monad. If we ignore it, we’re essentially ignoring the monadic 
 side effects as well!
  
 And the answer is that, yes, this does happen with monad-control. Certain functions 
 will drop some of the monadic side effects. This is put best by Bas, in the comments 
 on the relevant functions: 
  
  
 Note, any monadic side effects in m of the “release” computation will be discarded; it is 
  
 run only for its side effects in IO.
  
 In practice, monad-control will usually be doing the right thing for you, but you 
 need to be aware that some side effects may disappear.",NA
More Complicated Cases,"In order to make our tricks work so far, we’ve needed to have functions that give us 
 full access to play around with their values. Sometimes, this isn’t the case. Take, for 
 instance:
  
 addMVarFinalizer :: MVar a -> IO () -> IO ()
  
 In this case, we are required to have no value inside our finalizer function. 
 Intuitively, the first thing we should notice is that there will be no way to capture 
 our monadic side
  
 220 | Appendix A:monad-control",NA
APPENDIX B,NA,NA
Conduit,"Conduits are a solution to the streaming data problem. Oftentimes, laziness allows 
 us to process large amounts of data without pulling all values into memory. 
 However, doing so in the presence of I/O requires us to use 
 lazy I/O
 . The main 
 downside to lazy I/O is non-determinism: we have no guarantees of when our 
 resource finalizers will be run. For small application, this may be acceptable, but for 
 a high-load server, we could quickly run out of scarce resources, such as file 
 handles.
  
 Conduits allow us to process large streams of data while still retaining 
 deterministic resource handling. They provide a unified interface for data streams, 
 whether they come from files, sockets, or memory. And when combined with 
 ResourceT
 , we can safely allocate resources, knowing that they will always be 
 reclaimed—even in the presence of exceptions.
  
 This appendix covers version 0.2 of the 
 conduit
  package.",NA
Conduits in Five Minutes,"While a good understanding of the lower-level mechanics of conduits is advisable, 
 you can get very far without it. Let’s start off with some high-level examples. Don’t 
 worry if some of the details seem a bit magical right now. We’ll cover everything in 
 the course of this appendix. Let’s start with the terminology, and then some sample 
 code.
  
 Source 
  
 A producer of data. The data could be in a file, coming from a socket, or in 
 memory as a list. To access this data, we 
 pull
  from the source.
  
 Sink 
  
 A consumer of data. Basic examples would be a sum function (adding up a 
 stream of numbers fed in), a file sink (which writes all incoming bytes to a file), 
 or a socket. We 
 push
  data into a sink. When the sink finishes processing (we’ll 
 explain that later), it returns some value.",NA
Structure of This Chapter,"The remainder of this chapter covers five major topics in conduits:
  
 •
  ResourceT
 , the underlying technique that allows us to have guaranteed resource 
  
 deallocation
  
 • Sources, our data producers
  
 • Sinks, our data consumers
  
 • Conduits, our data transformers
  
 • Buffering, which allows us to avoid inversion of control",NA
The Resource Monad Transformer,"The Resource transformer (
 ResourceT
 ) plays a vital role in proper resource 
 management in the conduit project. It is included within the 
 conduit
  package itself. 
 We’ll explain 
 ResourceT
  as its own entity. While some of the design decisions clearly 
 are biased toward conduits, 
 ResourceT
  should remain a usable tool in its own right.",NA
Goals,"What’s wrong with the following code?
  
 import System.IO
  
 main = do
  
  output <- openFile ""output.txt"" WriteMode
  
  input  <- openFile ""input.txt""  ReadMode
  
  hGetContents input >>= hPutStr output
  
  hClose input
  
  hClose output
  
 If the file 
 input.txt
  does not exist, then an exception will be thrown when trying to 
 open it. As a result, 
 hClose output
  will never be called, and we’ll have leaked a scarce 
 resource (a file descriptor). In our tiny program, this isn’t a big deal, but clearly we 
 can’t afford such waste in a long running, highly active server process.
  
 Fortunately, solving the problem is easy:
  
 import System.IO
  
 main =
  
  withFile ""output.txt"" WriteMode $ \output -> withFile 
 ""input.txt"" ReadMode $ \input -> hGetContents input 
 >>= hPutStr output
  
 The Resource Monad Transformer | 227",NA
How It Works,"There are essentially three base functions on 
 ResourceT
 , and then a bunch of 
 conven-iences thrown on top. The first function is:
  
 register :: IO () -> ResourceT IO ReleaseKey
  
  
 This function, and the others below, are actually more polymorphic 
 than implied here, allowing other monads besides 
 IO
 . In fact, almost 
 any transformer on top of 
 IO
 , as well as any 
 ST
  stacks, work. We’ll 
 cover the details of that later.
  
 228 | Appendix B:Conduit",NA
Some Type Magic,"As alluded to, there’s a bit more to 
 ResourceT
  than simply running in 
 IO
 . Let’s cover 
 some of the things we need from this underlying 
 Monad
 .
  
 The Resource Monad Transformer | 229",NA
Definition of ResourceT,"We now have enough information to understand the definition of 
 ResourceT
 :
  
 newtype ReleaseKey = ReleaseKey Int
  
 The Resource Monad Transformer | 231",NA
Other Typeclasses,"There are three other typeclasses provided by the module:
  
 ResourceUnsafeIO 
  
 Any monad which can lift 
 IO
  actions into it, but that this may be considered 
 unsafe. The prime candidate here is 
 ST
 . Care should be taken to only lift actions 
 that do not acquire scarce resources and which don’t “fire the missiles.” In 
 other words, all the normal warnings of 
 unsafeIOToST
  apply.
  
 ResourceThrow 
  
 For actions that can throw exceptions. This automatically applies to all 
 IO
 -based 
 monads. For 
 ST
 -based monads, you can use the supplied 
 ExceptionT
  transformer 
 to provide exception-throwing capabilities. Some functions in conduit, for 
 exam-ple, will require this (e.g., text decoding).
  
 ResourceIO 
  
 A convenience class tying together a bunch of other classes, included the two 
 men-tioned above. This is purely for convenience; you could achieve the same 
 effect without this type class, you’d just have to do a lot more typing.
  
 232 | Appendix B:Conduit",NA
Forking,"It would seem that forking a thread would be inherently unsafe with 
 ResourceT
 , 
 since the parent thread may call 
 runResourceT
  while the child thread is still 
 accessing some of the allocated resources. This is indeed true, 
 if
  you use the normal 
 forkIO
  function.
  
  
 You can’t actually use the standard 
 forkIO
 , since it only operates in 
 the 
 IO
  monad, but you could use the 
 fork
  function from 
 lifted-base
 . In 
 fact, due to this issue, the 
 regions
  package does not provide a 
 MonadBa seControl
  instance for its transformer (which is very similar 
 to 
 Resour
  
 ceT
 ). However, our goal in 
 ResourceT
  is not to make it impossible for 
 programmers to mess up, only to make it easier to do the right 
 thing. Therefore, we still provide the instance, even though it could 
 be abused.
  
 In order to solve this, 
 ResourceT
  includes reference counting. When you fork a new 
 thread via 
 resourceForkIO
 , the 
 RefCount
  value of the 
 ReleaseMap
  is incremented. 
 Every time 
 runResourceT
  is called, the value is decremented. Only when the value 
 hits 0 are all the release actions called.",NA
Convenience Exports,"In addition to what’s been listed so far, there are a few extra functions exported 
 (mostly) for convenience.
  
 •
  newRef
 , 
 writeRef
 , and 
 readRef
  wrap up the 
 HasRef
  versions of the functions and 
  
 allow them to run in any 
 ResourceT
 .
  
 •
  withIO
  is essentially a type-restricted version of 
 with
 , but working around some 
 of the nastiness with types you would otherwise run into. In general: you’ll 
 want to use 
 withIO
  when writing 
 IO
  code.
  
 •
  transResourceT
  lets you modify which monad your ResourceT is running in, 
  
 assuming it keeps the same base.
  
 transResourceT :: (Base m ~ Base n)
  
  
  => (m a -> n a)
  
  
  -> ResourceT m a
  
  
  -> ResourceT n a 
  
 transResourceT f (ResourceT mx) = ResourceT (\r -> f (mx r))",NA
Source,"I think it’s simplest to understand sources by looking at the types:
  
 data SourceResult m a = Open (Source m a) a | Closed data 
 Source m a = Source
  
  
  { sourcePull :: ResourceT m (SourceResult m a)",NA
State,"There is something similar about the two sources mentioned above: they never 
 change. They 
 always
  return the same value. In other words, they have no state. For 
 almost all serious sources, we’ll need some kind of state.
  
  
 The state might actually be defined outside of our program. For 
 example, if we write a source that reads data from a 
 Handle
 , we don’t 
 need to manually specify any state, since the 
 Handle
  itself already 
 has.
  
 234 | Appendix B:Conduit",NA
sourceState and sourceIO,"In addition to being able to manually create 
 Source
 s, we also have a few 
 convenience functions that allow us to create most sources in a more high-level 
 fashion. 
 sourceS tate
  lets you write code similar to how you would use the 
 State
  
 monad. You provide an initial state, your pull function is provided with the current 
 state, and it returns a new state and a return value. Let’s use this to reimplement 
 sourceList.
  
 import Data.Conduit 
  
 import Control.Monad.Trans.Resource
  
 -- | Provide data from the list, one element at a time. sourceList :: 
 Resource m => [a] -> Source m a 
  
 sourceList state0 = sourceState
  
   
  state0
  
   
  pull
  
  where
  
   
  pull [] = return StateClosed
  
   
  pull (x:xs) = return $ StateOpen xs x
  
 Notice the usage of the 
 StateClosed
  and 
 StateOpen
  constructors. These are very 
 similar to 
 Closed
  and 
 Open
 , except that instead of specifying the next 
 Source
  to be 
 used, you provide the next state (here, the remainder of the list).
  
 The other common activity is to perform some I/O allocation (like opening a file), 
 registering some cleanup action (closing that file), and having a function for pulling 
 data from that resource. 
 conduit
  comes built-in with a 
 sourceFile
  function that gives
  
 Source | 235",NA
Sinks,"A sink consumes a stream of data, and produces a result. A sink must always 
 produce a result, and must always produce a single result. This is encoded in the 
 types them-selves.
  
 There is a 
 Monad
  instance for sink, making it simple to compose multiple sinks 
 together into a larger sink. You can also use the built-in sink functions to perform 
 most of your work. Like sources, you’ll rarely need to dive into the inner workings. 
 Let’s start off with an example: getting lines from a stream of 
 Char
 s (we’ll assume 
 Unix line endings for simplicity).
  
 import Data.Conduit 
  
 import qualified Data.Conduit.List as CL
  
 -- Get a single line from the stream.
  
 sinkLine :: Resource m => Sink Char m String 
  
 sinkLine = sinkState
  
   
  id -- initial state, nothing at the beginning of the line
   
  
 push
  
   
  close
  
  where
  
   
  -- On a new line, return the contents up until here
  
  
  
 push front '\n' =
  
    
  return $ StateDone Nothing $ front []
  
 236 | Appendix B:Conduit",NA
Types,"The types for sinks are just a bit more involved than sources. Let’s have a look:
  
 type SinkPush input m output = input -> ResourceT m (SinkResult input m output) type 
 SinkClose m output = ResourceT m output
  
 data SinkResult input m output =
  
   
  Processing (SinkPush input m output) (SinkClose m output) | Done 
 (Maybe input) output
  
 data Sink input m output =
  
   
  SinkNoData output
  
  | SinkData
  
    
  { sinkPush :: SinkPush input m output
   
  
  , sinkClose :: SinkClose m output
  
    
  }
  
  | SinkLift (ResourceT m (Sink input m output))
  
 Whenever a sink is pushed to, it can either say it needs more data (
 Processing
 ) or 
 say it’s all done. When still processing, it must provide updated push and close 
 functions; when done, it returns any leftover input and the output. Fairly 
 straightforward.
  
 The first real “gotcha” is the three constructors for 
 Sink
 . Why do we need 
 SinkNo 
 Data
 : aren’t sinks all about consuming data? The answer is that we need it to 
 efficiently implement our 
 Monad
  instance. When we use 
 return
 , we’re giving back a 
 value that requires no data in order to compute it. We could model this with the 
 SinkData
  con-structor, with something like:
  
 myReturn a = SinkData (\input -> return (Done (Just input) a)) (return a)
  
 But doing so would force reading in an extra bit of input that we don’t need right 
 now, and possibly will never need. (Have a look again at the 
 sinkLines
  example.) So 
 instead, we have an extra constructor to indicate that no input is required. 
 Likewise, 
 SinkLift 
 is provided in order to implement an efficient 
 MonadTrans
  
 instance.",NA
Sinks: no helpers,"Let’s try to implement some sinks on the “bare metal,” without any helper 
 functions.
  
 import Data.Conduit 
  
 import System.IO 
  
 import Control.Monad.Trans.Resource 
  
 import Control.Monad.IO.Class (liftIO)
  
 -- Consume all input and discard it.
  
 sinkNull :: Resource m => Sink a m () 
  
 sinkNull =
  
   
  SinkData push close
  
  where
  
   
  push _ignored = return $ Processing push close
  
  
  close = return ()",NA
Sinks: with Helpers,"Let’s rewrite 
 sinkFile
  and 
 count
  to take advantage of the helper functions 
 sinkIO
  and 
 sinkState
 , respectively.
  
 import Data.Conduit 
  
 import System.IO 
  
 import Control.Monad.IO.Class (liftIO)
  
 -- We never have to touch the release key directly; sinkIO automatically-- releases our 
 resource as soon as we return IODone from our push function,
  
 Sinks | 239",NA
List Functions,"As easy as it is to write your own sinks, you’ll likely want to take advantage of the 
 built-in sinks available in the 
 Data.Conduit.List
  module. These provide analogues to 
 com-mon list functions, like folding. (The module also has some 
 Conduit
 s, like 
 map
 .)
  
 If you’re looking for some way to practice with conduits, reimplementing the 
 functions in the 
 List
  module—both with and without the helper functions—would 
 be a good start.
  
 Let’s look at some simple things we can make out of the built-in sinks.
  
 import Data.Conduit 
  
 import qualified Data.Conduit.List as CL 
  
 import Control.Monad.IO.Class (liftIO)
  
 -- A sum function.
  
 sum' :: Resource m => Sink Int m Int 
  
 sum' = CL.fold (+) 0
  
 -- Print every input value to standard output. printer :: 
 (Show a, ResourceIO m) => Sink a m () printer = 
 CL.mapM_ (liftIO . print)
  
 -- Sum up all the values in a stream after the first five. sumSkipFive :: 
 Resource m => Sink Int m Int
  
 240 | Appendix B:Conduit",NA
Connecting,"At the end of the day, we’re actually going to want to use our sinks. While we could 
 manually call 
 sinkPush
  and 
 sinkClose
 , it’s tedious. For example:
  
 main :: IO () 
  
 main = runResourceT $ do
  
   
  res <-
  
    
  case printSum of
  
    
  
  SinkData push close -> loop [1..10] push close
  
    
  SinkNoData res -> return res
  
   
  liftIO $ putStrLn $ ""Got a result: "" ++ show res
  
  where
  
   
  start (SinkData push close) = loop [1..10] push close
   
  
 start (SinkNoData res) = return res
  
   
  start (SinkLift msink) = msink >>= start
  
  loop [] _push close = close
  
  loop (x:xs) push close = do
  
  
  mres <- push x
  
  
  case mres of
  
  
  
  Done _leftover res -> return res
  
  
  
  Processing push' close' -> loop xs push' close'
  
 Instead, the recommended approach is to connect your sink to a source. Not only is 
 this simpler, it’s less error prone, and means you have a lot of flexibility in where 
 your data is coming from. To rewrite the example above:
  
 main :: IO () 
  
 main = runResourceT $ do
  
  
  res <- CL.sourceList [1..10] $$ printSum
  
  
  liftIO $ putStrLn $ ""Got a result: "" ++ show res
  
 Connecting takes care of testing for the sink constructor (
 SinkData
  versus 
 SinkNoData 
 versus 
 SinkLift
 ), pulling from the source, and pushing to/closing the sink.
  
 However, there is one thing I wanted to point out from the long-winded example. 
 On the second to last line, we ignore the leftover value of 
 Done
 . This brings up the 
 issue of 
 data loss
 . This is an important topic that has had a lot of thought put into it.
  
 Sinks | 241",NA
Conduit,"This section covers the final major data type in our package: conduits. While 
 sources produce a stream of data and sinks consume a stream, conduits transform a 
 stream.",NA
Types,"As we did previously, let’s start off by looking at the types involved.
  
 data ConduitResult input m output =
  
   
  Producing (Conduit input m output) [output] | 
 Finished (Maybe input) [output]
  
 data Conduit input m output = Conduit
  
  { conduitPush :: input -> ResourceT m (ConduitResult input m output) , 
 conduitClose :: ResourceT m [output]
  
  }
  
 This should look very similar to what we’ve seen with sinks. A conduit can be 
 pushed to, in which case it returns a result. A result either indicates that it is still 
 producing data, or that it is finished. When a conduit is closed, it returns some more 
 output.
  
 But let’s examine the idiosyncrasies a bit. Like sinks, we can only push one piece of 
 input at a time, and leftover data may be 0 or 1 pieces. However, there are a few 
 changes:
  
 • When producing (the equivalent of processing for a sink), we can return output. 
 This is because a conduit will product a new stream of output instead of 
 producing a single output value at the end of processing.
  
 • A sink always returns a single output value, while a conduit returns 0 or more 
 outputs (a list). To understand why, consider conduits such as 
 concatMap
  
 (produces multiple outputs for one input) and 
 filter
  (returns 0 or 1 output for 
 each input).
  
 • We have no special constructor like 
 SinkNoData
 . That’s because we provide no 
 Monad
  instance for conduits. We’ll see later how you can still use a familiar 
 Monadic approach to creating conduits.
  
 Overall conduits should seem very similar to what we’ve covered so far.",NA
Simple Conduits,"We’ll start off by defining some simple conduits that don’t have any state.
  
 import Prelude hiding (map, concatMap) 
  
 import Data.Conduit
  
 -- A simple conduit that just passes on the data as is.
  
 passThrough :: Monad m => Conduit input m input 
  
 passThrough = Conduit
  
  
  { conduitPush = \input -> return $ Producing passThrough [input]
  
  , 
 conduitClose = return []
  
  
  }
  
 -- map values in a stream 
  
 map :: Monad m => (input -> output) -> Conduit input m output map f = 
 Conduit
  
  
  { conduitPush = \input -> return $ Producing (map f) [f input]
  
  , 
 conduitClose = return []
  
  
  }
  
 -- map and concatenate 
  
 concatMap :: Monad m => (input -> [output]) -> Conduit input m output concatMap f 
 = Conduit
  
  
  { conduitPush = \input -> return $ Producing (concatMap f) $ f input
  
  , 
 conduitClose = return []
  
  
  }",NA
Stateful Conduits,"Of course, not all conduits can be declared without state. Doing so on the bare metal 
 is not too difficult.
  
 import Prelude hiding (reverse) 
  
 import qualified Data.List 
  
 import Data.Conduit 
  
 import Control.Monad.Trans.Resource
  
 -- Reverse the elements in the stream. Note that this has the same downside as-- the 
 standard reverse function: you have to read the entire stream into-- memory before 
 producing any output.
  
 reverse :: Resource m => Conduit input m input 
  
 reverse =
  
   
  mkConduit []
  
  where
  
   
  mkConduit state = Conduit (push state) (close state)
  
   
  push state input = return $ Producing (mkConduit $ input : state) []
  
  
  close state = return state
  
 -- Same thing with sort: it will pull everything into memory sort :: (Ord 
 input, Resource m) => Conduit input m input sort =
  
   
  mkConduit []
  
  where
  
 Conduit | 243",NA
Using Conduits,"The way 
 Conduit
 s interact with the rest of the package is via 
 fusing
 . A conduit can be 
 fused into a source, producing a new source, fused into a sink to produce a new 
 sink, or fused with another conduit to produce a new conduit. It’s best to just look 
 at the fusion operators.
  
 -- Left fusion: source + conduit = source 
  
 ($=) :: (Resource m, IsSource src) => src m a -> Conduit a m b -> Source m b
  
 -- Right fusion: conduit + sink = sink 
  
 (=$) :: Resource m => Conduit a m b -> Sink b m c -> Sink a m c
  
 -- Middle fusion: conduit + conduit = conduit 
  
 (=$=) :: Resource m => Conduit a m b -> Conduit b m c -> Conduit a m c
  
 Using these operators is straightforward.
  
 useConduits = do
  
  
  runResourceT
  
  
  
  $  CL.sourceList [1..10]
  
  
  
  $= reverse
  
  
  
  $= CL.map show
  
  
  
  $$ CL.consume
  
 244 | Appendix B:Conduit",NA
Data Loss,"Let’s forget about conduits for a moment. Instead, suppose we want to write a 
 program—using plain old lists—that will take a list of numbers, apply some kind of 
 transfor-mation to them, take the first five transformed values and do something 
 with them, and then do something else with the remaining 
 non-transformed
  
 values. For example,
  
 we want something like:
  
 main = do
  
  
  let list = [1..10]
  
  
  
  transformed = map show list
  
  
  
  (begin, end) = splitAt 5 transformed
  
  
  
  untransformed = map read end
  
  
  mapM_ putStrLn begin
  
  
  print $ sum untransformed
  
 But clearly this isn’t a good general solution, since we don’t want to have to 
 transform and then untransform every element in the list. For one thing, we may 
 not always have an inverse function. Another issue is efficiency. In this case, we can 
 write something more efficient:
  
 Conduit | 245",NA
SequencedSink,"Suppose we want to be able to combine up existing conduits and sinks to produce a 
 new, more powerful conduit. For example, we want to write a conduit that takes a 
 stream of numbers and sums up every five. In other words, for the input 
 [1..50]
 , it 
 should result in the sequence 
 [15,40,65,90,115,140,165,190,215,240]
 . We can 
 definitely do this with the low-level conduit interface.
  
 sum5Raw :: Resource m => Conduit Int m Int 
  
 sum5Raw =
  
   
  conduitState (0, 0) push close
  
  where
  
   
  push (total, count) input
  
     
  | newCount == 5 = return $ StateProducing (0, 0) [newTotal]
  
    
  | otherwise     = return $ StateProducing (newTotal, newCount) []
  
   
  where
  
     
  newTotal = total + input
  
     
  newCount = count + 1
  
   
  close (total, count)
  
     
  | count == 0 = return []
  
     
  | otherwise  = return [total]
  
 But this is frustrating, since we already have all the tools we need to do this at a 
 high level! There’s the 
 fold
  sink for adding up the numbers, and the 
 isolate
  conduit, 
 which will only allow up to a certain number of elements to be passed to a sink. 
 Can’t we combine these somehow?
  
 The answer is a 
 SequencedSink
 . The idea is to create a normal 
 Sink
 , except it returns 
 a special output called a 
 SequencedSinkResponse
 . This value can emit new output, 
 stop processing data, or transfer control to a new conduit. (See the Haddocks for 
 more",NA
Buffering,"Buffering is one of the unique features of conduits. With buffering, conduits no 
 longer need to control the flow of your application. In some cases, this can lead to 
 simpler code.",NA
Inversion of Control,"Buffering was actually one of the main motivations in the creation of the 
 conduit 
 package. To see its importance, we need to consider the approach we’ve seen so far, 
 which we’ll call inversion of control, or IoC.
  
  
 Inversion of control can mean different things in different circles. If 
 you object to its usage here, go ahead replace it with some other 
 phrase like“warm, fuzzy thing.” I won’t be offended.
  
 248 | Appendix B:Conduit",NA
BufferedSource,"And so we finally get to introduce the last data type in conduits: 
 BufferedSource
 . This 
 is an abstract data type, but all it really does is keep a mutable reference to a buffer 
 and an underlying 
 Source
 . In order to create one of these, you use the 
 bufferSource
  
 function.
  
 bufferSource ::Resource m => Source m a -> ResourceT m (BufferedSource m a)
  
 This one little change is what allows us to easily solve our web server dilemma. 
 Instead of connecting a 
 Source
  to our parsing 
 Sink
 s, we use a 
 BufferedSource
 . At the 
 end of each connection, any leftover data is put back on the buffer. For our web 
 server case, we can now create a 
 BufferedSource
 , use that to read the request line 
 and headers, and then pass that same 
 BufferedSource
  to the application for reading 
 the request body.",NA
Typeclass,"We want to be able to connect a buffered source to a sink, just like we would a 
 regular source. We would also like to be able to fuse it to a conduit. In order to 
 make this convenient, conduit has a typeclass, 
 IsSource
 . There are instances 
 provided for both 
 Source
  and 
 BufferedSource
 . Both the connect (
 $$
 ) and left-fuse (
 $=
 ) 
 operators use this typeclass.
  
 There’s one “gotcha” in the 
 BufferedSource
  instance of this typeclass, so let’s explain 
 it. Suppose we want to write a file copy function, without any buffering. This is a 
 fairly standard usage of conduits:",NA
Recapping the Web Server,"So what exactly does our web server look like now?
  
 import Data.ByteString (ByteString) 
  
 import Data.Conduit 
  
 import Data.Conduit.Network (sourceSocket) 
  
 import Control.Monad.IO.Class (liftIO) 
  
 import Network.Socket (Socket)
  
 data RequestLine = RequestLine ByteString ByteString ByteString 
  
 type Headers = [(ByteString, ByteString)] 
  
 data Request = Request RequestLine Headers (BufferedSource IO ByteString) data 
 Response = Response 
  
 type Application = Request -> ResourceT IO Response
  
 parseRequestHeaders :: Sink ByteString IO Headers 
 parseRequestHeaders = undefined
  
 parseRequestLine :: Sink ByteString IO RequestLine 
 parseRequestLine = undefined
  
 Buffering | 253",NA
APPENDIX C,NA,NA
Web Application Interface,"It is a problem almost every language used for web development has dealt with: the 
 low-level interface between the web server and the application. The earliest 
 example of a solution is the venerable and battle-worn Common Gateway Interface 
 (CGI), pro-viding a language-agnostic interface using only standard input, standard 
 output, and environment variables.
  
 Back when Perl was becoming the de facto web programming language, a major 
 short-coming of CGI became apparent: the process needed to be started anew for 
 each re-quest. When dealing with an interpreted language and application 
 requiring database connection, this overhead became unbearable. FastCGI (and 
 later SCGI) arose as a successor to CGI, but it seems that much of the programming 
 world went in a different direction.
  
 Each language began creating its own standard for interfacing with servers: 
 mod_perl, mod_python, mod_php, mod_ruby. Within the same language, multiple 
 interfaces arose. In some cases, we even had interfaces on top of interfaces. And all 
 of this led to much duplicated effort: a Python application designed to work with 
 FastCGI wouldn’t work with mod_python—mod_python only exists for certain web 
 servers—and these programming language specific web server extensions need to 
 be written for each pro-gramming language.
  
 Haskell has its own history. We originally had the 
 cgi
  package, which provided a 
 mo-nadic interface. The 
 fastcgi
  package then provided the same interface. 
 Meanwhile, it seemed that the majority of Haskell web development focused on the 
 standalone server. The problem is that each server comes with its own interface, 
 meaning that you need to target a specific backend. This means that it is impossible 
 to share common features, like GZIP encoding, development servers, and testing 
 frameworks.
  
 WAI attempts to solve this, by providing a generic and efficient interface between 
 web servers and applications. Any 
 handler
  supporting the interface can serve any 
 WAI application, while any application using the interface can run on any handler.
  
 255",NA
The Interface,"The interface itself is very straightforward: an application takes a request and 
 returns a response. A response is an HTTP status, a list of headers and a response 
 body. A request contains various information: the requested path, query string, 
 request body, HTTP version, and so on.",NA
Response Body,"Haskell has a data type known as a lazy bytestring. By utilizing laziness, you can 
 create large values without exhausting memory. Using lazy I/O, you can do such 
 tricks as having a value which represents the entire contents of a file, yet only 
 occupies a small memory footprint. In theory, a lazy bytestring is the only 
 representation necessary for a response body.
  
 In practice, while lazy byte strings are wonderful for generating “pure” values, the 
 lazy I/O necessary to read a file introduces some non-determinism into our 
 programs. When serving thousands of small files a second, the limiting factor is not 
 memory, but file handles. Using lazy I/O, file handles may not be freed immediately, 
 leading to resource exhaustion. To deal with this, WAI uses 
 conduits
 .
  
  
 Versions of WAI before 1.0 used enumerators in place of conduits. 
 While both conduits and enumerators solve the same basic 
 problem, 
 experience 
 showed 
 that 
 enumerators 
 were 
 too 
 constricting in their in-version of control approach, making it 
 difficult to structure more com-
  
 plicated systems like a streaming proxy server. Conduits were 
 designed with the express purpose of making a better WAI.
  
 256 | Appendix C:Web Application Interface",NA
Request Body,"In order to avoid the need to load the entire request body into memory, we use 
 sources here as well. Since the purpose of these values are for reading (not 
 writing), we use 
 ByteString
 s in place of 
 Builder
 s. There is a record inside 
 Request
  
 called 
 requestBody
 , with type 
 BufferedSource IO ByteString
 . We can use all of the 
 standard conduit func-tions to interact with this source.
  
 The request body could in theory contain any type of data, but the most common 
 are URL encoded and multipart form data. The 
 wai-extra
  package contains built-in 
 support for parsing these in a memory-efficient manner.",NA
Hello World,"To demonstrate the simplicity of WAI, let’s look at a hello world example. In this 
 example, we’re going to use the OverloadedStrings language extension to avoid ex-
 plicitly packing string values into bytestrings.
  
 {-# LANGUAGE OverloadedStrings #-} 
  
 import Network.Wai 
  
 import Network.HTTP.Types (status200) 
  
 import Network.Wai.Handler.Warp (run)
  
 application _ = return $
  
  responseLBS status200 [(""Content-Type"", ""text/plain"")] ""Hello World""
  
 main = run 3000 application
  
 Lines 2 through 4 perform our imports. Warp is provided by the 
 warp
  package, and 
 is the premiere WAI backend. WAI is also built on top of the 
 http-types
  package, 
 which provides a number of data types and convenience values, including 
 status200
 .
  
 First we define our application. Since we don’t care about the specific request 
 param-eters, we ignore the argument to the function. For any request, we are 
 returning a
  
 Hello World | 257",NA
Middleware,"In addition to allowing our applications to run on multiple backends without code 
 changes, the WAI allows us another benefit: middleware. Middleware is essentially 
 an 
 application transformer
 , taking one application and returning another one.
  
 Middleware components can be used to provide lots of services: cleaning up URLs, 
 authentication, caching, JSON-P requests. But perhaps the most useful and most in-
 tuitive middleware is gzip compression. The middleware works very simply: it 
 parses the request headers to determine if a client supports compression, and if so 
 compresses the response body and adds the appropriate response header.
  
 The great thing about middlewares is that they are unobtrusive. Let’s see how we 
 would apply the gzip middleware to our hello world application.
  
 {-# LANGUAGE OverloadedStrings #-} 
  
 import Network.Wai 
  
 import Network.Wai.Handler.Warp (run) 
  
 import Network.Wai.Middleware.Gzip (gzip, def) 
 import Network.HTTP.Types (status200)
  
 application _ = return $ responseLBS status200 [(""Content-Type"", ""text/plain"")]
  
  
 ""Hello World""
  
 main = run 3000 $ gzip def application
  
 We added an import line to actually have access to the middleware, and then 
 simply applied gzip to our application. You can also 
 chain together
  multiple 
 middlewares: a line such as 
 gzip False $ jsonp $ othermiddleware $ myapplication
  is 
 perfectly valid. One word of warning: the order the middleware is applied can be 
 important. For example, jsonp needs to work on uncompressed data, so if you apply 
 it after you apply gzip, you’ll have trouble.
  
 258 | Appendix C:Web Application Interface",NA
APPENDIX D,NA,NA
Settings Types,"Let’s say you’re writing a web server. You want the server to take a port to listen on, 
 and an application to run. So you create the following function:
  
 run :: Int -> Application -> IO ()
  
 But suddenly you realize that some people will want to customize their timeout 
 durations. So you modify your API:
  
 run :: Int -> Int -> Application -> IO ()
  
 So, which 
 Int
  is the timeout, and which is the port? Well, you could create some type 
 aliases, or comment your code. But there’s another problem creeping into our code: 
 this 
 run
  function is getting unmanageable. Soon we’ll need to take an extra 
 parameter to indicate how exceptions should be handled, and then another one to 
 control which host to bind to, and so on.
  
 So a more extensible solution is to introduce a settings data type:
  
 data Settings = Settings
  
  { settingsPort :: Int
  
  , settingsHost :: String
  
  , settingsTimeout :: Int
  
  }
  
 And this makes the calling code almost self-documenting:
  
 run Settings
  
  { settingsPort = 8080
  
  , settingsHost = ""127.0.0.1""
  
  , settingsTimeout = 30
  
  } myApp
  
 Great, couldn’t be clearer, right? True, but what happens when you have 50 settings 
 to your web server? Do you really want to have to specify all of those each time? Of 
 course not. So instead, the web server should provide a set of defaults:
  
 defaultSettings = Settings 3000 ""127.0.0.1"" 30
  
 And now, instead of needing to write that long bit of code above, we can get away 
 with:
  
 259",NA
APPENDIX E,NA,NA
http-conduit,"Most of Yesod is about serving content over HTTP. But that’s only half the story: 
 someone has to receive it. And even when you’re writing a web app, sometimes that 
 someone will be you. If you want to consume content from other services or 
 interact with RESTful APIs, you’ll need to write client code. And the recommended 
 approach for that is 
 http-conduit
 .
  
 This chapter is not directly connected to Yesod, and will be generally useful for 
 anyone wanting to make HTTP requests.",NA
Synopsis,"{-# LANGUAGE OverloadedStrings #-} 
  
 import Network.HTTP.Conduit -- the main module
  
 -- The streaming interface uses conduits 
  
 import Data.Conduit 
  
 import Data.Conduit.Binary (sinkFile)
  
 import qualified Data.ByteString.Lazy as L 
  
 import Control.Monad.IO.Class (liftIO)
  
 main :: IO () 
  
 main = do
  
  
  -- Simplest query: just download the information from the given URL as a
  
  -- lazy 
 ByteString.
  
  simpleHttp ""http://www.example.com/foo.txt"" >>= L.writeFile ""foo.txt""
  
  -- Use the streaming interface instead. We need to run all of this inside a -- ResourceT, to 
 ensure that all our connections get properly cleaned up in -- the case of an exception.
  
  runResourceT $ do
  
  -- We need a Manager, which keeps track of open connections. simpleHttp -- creates a 
 new manager on each run (i.e., it never reuses
  
  -- connections).
  
  manager <- liftIO $ newManager def
  
 261",NA
Concepts,"The simplest way to make a request in 
 http-conduit
  is with the 
 simpleHttp
  function. 
 This function takes a 
 String
  giving a URL and returns a 
 ByteString
  with the contents 
 of that URL. But under the surface, there are a few more steps:
  
 • A new connection 
 Manager
  is allocated.
  
 • The URL is parsed to a 
 Request
 . If the URL is invalid, then an exception is thrown.
  
 • The HTTP request is made, following any redirects from the server.
  
 • If the response has a status code outside the 200-range, an exception is thrown.
  
 • The response body is read into memory and returned.
  
 •
  runResourceT
  is called, which will free up any resources (e.g., the open socket to 
  
 the server).
  
 If you want more control of what’s going on, then you can configure any of the steps 
 above (plus a few more) by explicitly creating a 
 Request
  value, allocating your 
 Man 
 ager
  manually, and using the 
 http
  and 
 httpLbs
  functions.",NA
Request,"The easiest way to create a 
 Request
  is with the 
 parseUrl
  function. This function will 
 return a value in any 
 Failure
  monad, such as 
 Maybe
  or 
 IO
 . The last of those is the 
 most commonly used, and results in a runtime exception whenever an invalid URL 
 is pro-vided. However, you can use a different monad if, for example, you want to 
 validate user input.
  
 262 | Appendix E:http-conduit",NA
Manager,"The connection manager allows you to reuse connections. When making multiple 
 queries to a single server (e.g., accessing Amazon S3), this can be critical for 
 creating efficient code. A manager will keep track of multiple connections to a given 
 server (taking into account port and SSL as well), automatically reaping unused 
 connections as needed. When you make a request, 
 http-conduit
  first tries to check 
 out an existing connection. When you’re finished with the connection (if the server 
 allows keep-alive), the connection is returned to the manager. If anything goes 
 wrong, the connection is closed.
  
 To keep our code exception-safe, we use the 
 ResourceT
  monad transformer. All this 
 means for you is that your code needs to be wrapped inside a call to 
 runResourceT
 , 
 either implicitly or explicitly, and that code inside that block will need to 
 liftIO
  to 
 perform normal IO actions.
  
 There are two ways you can get ahold of a manager. 
 newManager
  will return a 
 manager that will not be automatically closed (you can use 
 closeManager
  to do so 
 manually), while 
 withManager
  will start a new 
 ResourceT
  block, allow you to use the 
 manager, and then automatically close the 
 ResourceT
  when you’re done. If you want 
 to use a 
 Resour ceT
  for an entire application, and have no need to close it, you should 
 probably use 
 newManager
 .
  
 One other thing to point out: you obviously don’t want to create a new manager for 
 each and every request; that would defeat the whole purpose. You should create 
 your 
 Manager
  early and then share it.",NA
Response,"The 
 Response
  data type has three pieces of information: the status code, the 
 response headers, and the response body. The first two are straightforward; let’s 
 discuss the body.
  
 The 
 Response
  type has a type variable to allow the response body to be of multiple 
 types. If you want to use 
 http-conduit
 ’s streaming interface, you want this to be a 
 Source
 . For the simple interface, it will be a lazy 
 ByteString
 . One thing to note is that, 
 even though
  
 264 | Appendix E:http-conduit",NA
http and httpLbs,"So let’s tie it together. The 
 http
  function gives you access to the streaming interface 
 (i.e., it returns a 
 Response
  using a 
 BufferedSource
 ) while 
 httpLbs
  returns a lazy 
 Byte 
 String
 . Both of these return values in the 
 ResourceT
  transformer so that they can 
 access the 
 Manager
  and have connections handled properly in the case of 
 exceptions.
  
  
 If you want to ignore the remainder of a large response body, you 
 can connect to the 
 sinkNull
  sink. The underlying connection will 
 automat-ically be closed, preventing you from having to read a large 
 response body over the network.
  
 http and httpLbs | 265",NA
APPENDIX F,NA,NA
xml-conduit,"Many developers cringe at the thought of dealing with XML files. XML has the repu-
 tation of having a complicated data model, with obfuscated libraries and huge 
 layers of complexity sitting between you and your goal. I’d like to posit that a lot of 
 that pain is actually a language and library issue, not inherent to XML.
  
 Once again, Haskell’s type system allows us to easily break down the problem to its 
 most basic form. The 
 xml-types
  package neatly deconstructs the XML data model 
 (both a streaming and DOM-based approach) into some simple ADTs. Haskell’s 
 standard immutable data structures make it easier to apply transforms to 
 documents, and a simple set of functions makes parsing and rendering a breeze.
  
 We’re going to be covering the 
 xml-conduit
  package. Under the surface, this package 
 uses a lot of the approaches Yesod in general utilizes for high performance: 
 blaze-
 builder
 , 
 text
 , 
 conduit
 , and 
 attoparsec
 . But from a user perspective, it provides 
 everything from the simplest APIs (
 readFile
 /
 writeFile
 ) through full control of XML 
 event streams.
  
 In addition to 
 xml-conduit
 , there are a few related packages that come into play, like 
 xml-hamlet
  and 
 xml2html
 . We’ll cover both how to use all these packages, and when 
 they should be used.",NA
Synopsis,"Example F-1. Input XML file
  
 <document title=""My Title"">
  
  
  <para>This is a paragraph. It has <em>emphasized</em> and <strong>strong</strong> 
 words.</para>
  
  
  <image href=""myimage.png""/> 
  
 </document>
  
 267",NA
Types,"Let’s take a bottom-up approach to analyzing types. This section will also serve as a 
 primer on the XML data model itself, so don’t worry if you’re not completely 
 familiar with it.
  
 I think the first place where Haskell really shows its strength is with the 
 Name
  data 
 type. Many languages (like Java) struggle with properly expressing names. The 
 issue is that
  
 there are in fact three components to a name: its local name, its namespace 
 (optional), and its prefix (also optional). Let’s look at some XML to explain:
  
 <no-namespace/> 
  
 <no-prefix xmlns=""first-namespace"" first-attr=""value1""/> 
  
 <foo:with-prefix xmlns:foo=""second-namespace"" foo:second-attr=""value2""/>
  
 The first tag has a local name of 
 no-namespace
 , and no namespace or prefix. The 
 second tag (local name: 
 no-prefix
 ) 
 also
  has no prefix, but it does have a namespace 
 (
 first-namespace
 ). 
 first-attr
 , however, does 
 not
  inherit that namespace: attribute 
 namespa-ces must always be explicitly set with a prefix.
  
 Types | 269",NA
The Four Types of Nodes,"XML documents are a tree of nested nodes. There are in fact four different types of 
 nodes allowed: elements, content (i.e., text), comments, and processing instructions.
  
 270 | Appendix F:xml-conduit",NA
Documents,"So now we have elements and nodes, but what about an entire document? Let’s just 
 lay out the data types:
  
 data Document = Document
  
  { documentPrologue :: Prologue
  
  , documentRoot :: Element
  
  , documentEpilogue :: [Miscellaneous]
  
  }
  
 data Prologue = Prologue
  
  { prologueBefore :: [Miscellaneous]
  
  , prologueDoctype :: Maybe Doctype
  
  , prologueAfter :: [Miscellaneous]
  
  }
  
 data Miscellaneous
  
  = MiscInstruction Instruction
  
  | MiscComment Text
  
 data Doctype = Doctype
  
  { doctypeName :: Text
  
  , doctypeID :: Maybe ExternalID
  
  }
  
 data ExternalID
  
  = SystemID Text
  
  | PublicID Text Text
  
 The XML spec says that a document has a single root element (
 documentRoot
 ). It 
 also has an optional doctype statement. Before and after both the doctype and the 
 root element, you are allowed to have comments and processing instructions. (You 
 can also have whitespace, but that is ignored in the parsing.)
  
 So what’s up with the doctype? Well, it specifies the root element of the document, 
 and then optional public and system identifiers. These are used to refer to DTD 
 files, which give more information about the file (e.g., validation rules, default 
 attributes, entity resolution). Let’s see some examples:
  
 <!DOCTYPE root> <!-- no external identifier --> 
  
 <!DOCTYPE root SYSTEM ""root.dtd""> <!-- a system identifier --> 
  
 <!DOCTYPE root PUBLIC ""My Root Public Identifier"" ""root.dtd""> <!-- public identifiers have a system 
 ID as well -->
  
 272 | Appendix F:xml-conduit",NA
Events,"In addition to the document API, 
 xml-types
  defines an 
 Event
  data type. This can be 
 used for constructing streaming tools, which can be much more memory efficient 
 for certain kinds of processing (e.g., adding an extra attribute to all elements). We 
 will not be covering the streaming API currently, though it should look very 
 familiar after analyzingthe document API.
  
  
 You can see an example of the streaming API in the Sphinx case study.",NA
Text.XML,"The recommended entry point to xml-conduit is the 
 Text.XML
  module. This module 
 exports all of the data types you’ll need to manipulate XML in a DOM fashion, as 
 well as a number of different approaches for parsing and rendering XML content. 
 Let’s start with the simple ones:
  
 readFile  :: ParseSettings  -> FilePath -> IO Document 
  
 writeFile :: RenderSettings -> FilePath -> Document -> IO ()
  
 This introduces the 
 ParseSettings
  and 
 RenderSettings
  data types. You can use these to 
 modify the behavior of the parser and renderer, such as adding character entities 
 and turning on pretty (i.e., indented) output. Both these types are instances of the 
 Default
  typeclass, so you can simply use 
 def
  when these need to be supplied. That is 
 how we will supply these values through the rest of the chapter; please see the API 
 docs for more information.
  
 It’s worth pointing out that in addition to the file-based API, there is also a text- and 
 bytestring-based API. The bytestring-powered functions all perform intelligent 
 encoding detections, and support UTF-8, UTF-16, and UTF-32, in either big or little 
 endian, with and without a Byte-Order Marker (BOM). All output is generated in 
 UTF-8.
  
 For complex data lookups, we recommend using the higher-level cursors API. The 
 standard 
 Text.XML
  API not only forms the basis for that higher level, but is also a 
 great API for simple XML transformations and for XML generation. See the synopsis 
 for an example.
  
 Text.XML | 273",NA
A Note About File Paths,"In the type signature above, we have a type 
 FilePath
 . However, 
 this isn’t 
 Prelude.Fil 
 ePath
 . The standard 
 Prelude
  defines a type synonym 
 type FilePath = [Char]
 . 
 Unfortunately, there are many limitations to using such an approach, including con-
 fusion of filename character encodings and differences in path separators.
  
 Instead, 
 xml-conduit
  uses the 
 system-filepath
  package, which defines an abstract 
 Fil 
 ePath
  type. I’ve personally found this to be a much nicer approach to work with. The 
 package is fairly easy to follow, so I won’t go into details here. But I do want to give 
 a few quick explanations of how to use it:
  
 • Since a 
 FilePath
  is an instance of 
 IsString
 , you can type in regular strings and they 
 will be treated properly, as long as the 
 OverloadedStrings
  extension is enabled. (I 
 highly recommend enabling it anyway, as it makes dealing with 
 Text
  values 
 much more pleasant.)
  
 • If you need to explicitly convert to or from 
 Prelude
 ’s 
 FilePath
 , you should use the 
 encodeString
  and 
 decodeString
 , respectively. This takes into account file path 
 encodings.
  
 • Instead of manually splicing together directory names and file names with 
 exten-sions, use the operators in the 
 Filesystem.Path.CurrentOS
  module, e.g., 
 myfolder </> filename <.> extension
 .",NA
Cursor,"Suppose you want to pull the title out of an XHTML document. You could do so with 
 the 
 Text.XML
  interface we just described, using standard pattern matching on the 
 chil-dren of elements. But that would get very tedious, very quickly. Probably the 
 gold standard for these kinds of lookups is XPath, where you would be able to write 
 /html/ head/title
 . And that’s exactly what inspired the design of the 
 Text.XML.Cursor
  
 com-binators.
  
 A cursor is an XML node that knows its location in the tree; it’s able to traverse 
 upwards, sideways, and downwards. (Under the surface, this is achieved by 
 tying 
 the knot
 .) There are two functions available for creating cursors from 
 Text.XML
  
 types: 
 fromDocument
  and 
 fromNode
 .
  
 We also have the concept of an 
 Axis
 , defined as 
 type Axis = Cursor -> [Cursor]
 . It’s 
 easiest to get started by looking at example axes: child returns zero or more 
 cursors that are the child of the current one, parent returns the single parent cursor 
 of the input, or an empty list if the input is the root element, and so on.
  
 In addition, there are some axes that take predicates. 
 element
  is a commonly used 
 function that filters down to only elements that match the given name. For example,
  
 274 | Appendix F:xml-conduit",NA
xml-hamlet,"Thanks to the simplicity of Haskell’s data type system, creating XML content with 
 the 
 Text.XML API
  is easy, if a bit verbose. The following code:
  
 {-# LANGUAGE OverloadedStrings #-} 
  
 import Text.XML 
  
 import Prelude hiding (writeFile)
  
 main :: IO () 
  
 main =
  
   
  writeFile def ""test3.xml"" $ Document (Prologue [] Nothing []) root [] where
  
   
  root = Element ""html"" []
  
    
  [ NodeElement $ Element ""head"" []
  
    
  
  [ NodeElement $ Element ""title"" []
  
    
  
  
  [ NodeContent ""My ""
  
    
  
  
  , NodeElement $ Element ""b"" []
  
    
  
  
  
  [ NodeContent ""Title""
  
    
  
  
  
  ]
  
    
  
  
  ]
  
    
  
  ]
  
    
  , NodeElement $ Element ""body"" []
  
    
  
  [ NodeElement $ Element ""p"" []
  
    
  
  
  [ NodeContent ""foo bar baz""
  
    
  
  
  ]
  
    
  
  ]
  
    
  ]
  
 produces
  
 <?xml version=""1.0"" encoding=""UTF-8""?> 
  
 <html><head><title>My <b>Title</b></title></head><body><p>foo bar baz</p></body></ 
 html>
  
 xml-hamlet | 277",NA
xml2html,"So far in this chapter, our examples have revolved around XHTML. I’ve done that so 
 far simply because it is likely to be the most familiar form of XML for most of our 
 readers. But there’s an ugly side to all this that we must acknowledge: not all 
 XHTML will be correct HTML. The following discrepancies exist:
  
 • There are some void tags (e.g., 
 img
 , 
 br
 ) in HTML which do not need to have close 
  
 tags, and in fact are not allowed to.
  
 • HTML does not understand self-closing tags, so 
 <script></script>
  and 
 <script/ 
  
 >
  mean very different things.
  
 xml2html | 279",NA
About the Author,"Michael Snoyman, creator of Yesod, has been programming for about 15 years, 
 using Haskell for the past five. He brings ten years of web development experience 
 in a wide variety of environments as well as time spent creating documentation.",NA
