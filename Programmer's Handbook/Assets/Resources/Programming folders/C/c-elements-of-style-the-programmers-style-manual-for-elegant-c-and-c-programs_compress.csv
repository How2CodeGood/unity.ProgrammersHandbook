Larger Text,Smaller Text,Symbol
Chapter 1: Style and Program Organization. . . . . . . . . . . . . 1,"Program Organization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 
 Automatic Generation of Program Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 
 Module Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 
 Libraries and Other Module Groupings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 
 Multiple header files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 One 
 header does all. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 Mixed 
 approach  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Program 
 Aesthetics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Code 
 paragraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Statements. 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8",NA
"Chapter 2: File Basics, Comments, and Program Headings11","File Basics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 
 The Comment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 
 Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 
 Packing bits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 
 Letting the Editor Help You . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 17 Beginning Comment Block  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 18 The sections of a heading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 
 Other sections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 
 Module Headings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 
 Function Headings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 22 When to Write Comments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 23 Some Comments on Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 24",NA
Chapter 3: Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . 25,"A Brief History of the Variable  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 25 Capitalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 27 Names You Must Never Use  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 28",NA
Chapter 4: Statement Formatting. . . . . . . . . . . . . . . . . . . . . 46,"Formatting the Body of the Program  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 46 Simplifying complex statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 
 Splitting long statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 
 Splitting and parentheses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 
  
 Splitting a for statement.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
  
 styleTOC.fm
  
 - 2 -
  
  Modified: January 9, 1999 12:04 am",NA
Chapter 5: Statement Details. . . . . . . . . . . . . . . . . . . . . . . . . 66,"Doing Nothing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 66 Arithmetic Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 66 Function Headings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 67 K&R style parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 
 Return type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 
 Number of parameters. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 
 Passing parameters in globals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 
 XView style parameter passing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 The if 
 Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 if/else 
 chains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 if and the 
 comma operator  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 The while 
 Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 The 
 do/while Statement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 
 The for Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 
 Missing parts of for loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 
 Overstuffed for loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 The 
 printf Statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 
 goto and Labels. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
  
 styleTOC.fm
  
 - 3 -
  
  Modified: January 9, 1999 12:04 am",NA
Chapter 6: Preprocessor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87,"Simple Define Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 
 Constant expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 
 #define constants vs. consts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 
 #define vs. typedef . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89 Abuse 
 of #define directives  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 Keywords 
 and standard functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 Parameterized 
 Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 Multi-line 
 Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 Macros 
 and Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 The 
 #include Directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 
 Style for #Includes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 
 Protecting against double #Includes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 
 Conditional Compilation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 
 Where to define the control symbols  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 
 Commenting out code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99",NA
Chapter 7: Directory Organization and Makefile Style . . 102,"Organizing Your Directories. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 
 The make Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 
 Heading Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 
 Customization Information. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 
 Standard targets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 Macro 
 Definitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 Common 
 macro definitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 Configurable 
 variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 Major 
 Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 Other 
 Targets  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
  
 styleTOC.fm
  
 - 4 -
  
  Modified: January 9, 1999 12:04 am",NA
Chapter 8: User-Friendly Programming . . . . . . . . . . . . . . 114,"What Does User-Friendly Mean? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 114 Law of Least Astonishment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 114 Modeling the User. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 115 Error Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . 115 The Command Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . 116 Help. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . 117 Safety Nets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . 117 Accelerators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . 118",NA
Chapter 9: Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119,NA,NA
Chapter 1: Style and Program Organization,"A program is a detailed set of instructions read by both a human and a machine. The 
 computer reads only the code, while the human concentrates on the comments. Good style 
 pertains to both parts of a program. Well-designed, well-written code not only makes effective 
 use of the com-puter, it also contains careful constructed comments to help humans understand 
 it. Well-designed, well-written code is a joy to debug, maintain, and enhance.
  
 Good programming style begins with the effective organization of code. using a clear and 
 con-sistent organization of the components of your program you make them more efficient, 
 readable, and maintainable.",NA
Program Organization,"Good computer programs are organized much like good books. This can seen especially well 
 with technical books, in which the structure is very clear.
  
 People have been writing books for hundreds of years, and during that time they have discov-
 ered how to organize the material to efficiently present their ideas. Standards have emerged. For 
 example, if I asked you when this book was copyrighted, you would turn to the title page. That's 
 where the copyright notice is always located.
  
 The same goes for code. In fact, we can make the parallels quite explicit.
  
  
 Any technical book can be analyzed into standard components. So can program. These com-
 ponents correspond quite closely as the following table shows.
  
 Book
  
 Program
  
  
  
 Title Page
  
 Heading
  
 Table of Contents
  
 Table of Contents
  
 Chapter
  
 Module
  
 Section
  
 Function
  
 Paragraph
  
 Conceptual Block
  
 Sentence
  
 Statement
  
 Word
  
 Variable
  
 Index
  
 Cross Reference
  
 Glossary
  
 Variable Declaration Comments
  
 These components really do serve the same purposes.
  
 •
  
 Title Page
  
 A book's title page contains the name of the book, the author, and the publisher. On the 
 reverse of the title page is the copyright page, where you find things like the printing his-
 tory and Library of Congress information.
  
 c01.doc
  
 - 1 -
  
  Modified: January 9, 1999 12:16 am",NA
Automatic Generation of Program Documentation,"Some of the program components described above can be generated automatically. Consider 
 the table of contents, for example. On UNIX systems, the
  ctags
  program will create such a table.
  
 Also, there is a public domain program, called
  cpr
 , that does the job for both DOS and UNIX.
  
 A cross reference can also be generated automatically by one of the many cross reference 
 tools, such as
  xref
 ,
  cref
 , etc. However, you can also generate a cross reference one symbol at a 
 time. Suppose you want to find out where total-count is located. The command grep searches 
 files for a string, so typing:
  
 grep -n total_count *.c
  
  
 produces a list of every use of
  total_count
  in all the C files. (The
  -n
  tells grep to print line 
 numbers.)
  
  
 The command
  grep
  is available both on UNIX systems and in MS-Windows with Borland 
 C++ and Borland’s Turbo-C.
  
 Also in UNIX, the command:
  
 vi ‘grep -l total_count *.c‘
  
 invokes the
  vi
  editor to list the files that contain the word
  total_count
 . Then you can 
 use the
  vi
  search command to locate
  total_count
  within a file. The commands next (
 :next
 ) and 
 rewind (
 :rew
 ) will flip through the files. See your
  vi
  and UNIX manuals for more details.
  
 Borland C++ and Borland’s Turbo-C++ have a version of
  grep
  built in to the Integrated 
 Develop Environment (IDE). By using the command Alt-Space you can bring up the tools menu, 
 then select
  grep
  and give it a command line, and the program will generate a list of references in 
 the message window. The file corresponding to the current message window line is displayed in 
 the edit window. Going up or down in the message changes the edit window. With these com-
 mands, you can quickly locate every place a variable is used.
  
 You can also partially automate the process of building a glossary, which is a time-
 consuming task if performed entirely by hand. The trick is to put a descriptive comment after 
 each variable declaration. That way, when the maintenance programmer wants to know what
  
 total_count 
 means, all he or she has to do is look up the first time
  total_count
  in 
 mentioned in the cross reference, locate that line in the program, and read:
  
 c01.doc
  
 - 3 -
  
  Modified: January 9, 1999 12:16 am",NA
Module Design,"A module is a set of functions that perform related operations. A simple program consists of 
 one file; i.e., one module. More complex programs are built of several modules.
  
  
 Modules have two parts: the public interface, which gives a user all the information 
 necessary to use the module; and the private section, which actually does the work.
  
 Another analogy to books is helpful here. Consider the documentation for a piece of equip-
 ment like a laser printer. This typically consists of two manuals: the Operator's Guide and the 
 Technical Reference Manual.
  
 The Operator's Guide describes how to use the laser printer. It includes information like what 
 the control panel looks like, how to put in paper, and how to change the toner. It does not cover 
 how
  the printer works.
  
 A user does not need to know what goes on under the covers. As long as the printer does its 
 job, it doesn't matter how it does it. When the printer stops working, the operator calls in a 
 techni-cian, who uses the information in the Technical Reference Manual to make repairs. This 
 manual describes how to disassemble the machine, test the internal components, and replace 
 broken parts.
  
 The public interface of a module is like an Operator's Guide. It tells the programmer and the 
 computer how to use the module. The public interface of a module is called the “header file.” It 
 contains data structures, function definitions, and
  #define
  constants, which are needed by anyone 
 using the module. The header file also contains a set of comments that tells a programmer how to 
 use the module.
  
 The private section, the actual code for the module, resides in the
  c
  file. A programmer who 
 uses the module never needs to look into this file. Some commercial products even distribute 
 their modules in object form only, so
  nobody
  can look in the private section.
  
 Rule 1-2:
  
 Divide each module up into a public part (what's needed to use the module) and a private
  
 part (what's needed to get the job done). The public part goes into a .h file while the pri-
  
 vate part goes into a .c file.",NA
Libraries and Other Module Groupings,"A library is a collection of generally useful modules combined into a special object file.
  
 Libraries present a special problem: How do you present the public information for a library? 
 Do you use a single header file, multiple header files for the individual modules, or some other 
 method?
  
 There is no one answer. Each method has its advantages and disadvantages.
  
 c01.doc
  
 - 4 -
  
  Modified: January 9, 1999 12:16 am",NA
Multiple header files,"Because a library is a collection of modules, you could use a collection of header files to 
 inter-face with the outside world. The advantage to this is that a program brings in only the 
 function and data definitions it needs, and leaves out what it doesn't use.
  
  
 The X Windows system, for example, has a different header file for each module (called a 
 tool kit in X-language).
  
 A typical X Windows program contains code that looks like this:
  
 #include <Xll/Intrinsic.h>
  
 #include <Xll/Shell.h>
  
 #include <Xm/Xm.h>
  
 #include <Xm/Label.h>
  
 #include <Xm/RowColumn.h>
  
 #include <Xm/PushB.h>
  
 #include <Xm/Separator.h>
  
 #include <Xm/BulletinB.h>
  
 #include <Xm/CascadeB.h>
  
 As you can see, this can result in a lot of
  #include
 s
 .
  One of the problems with this system is 
 that it is very easy to forget one of the
  #include
  statements. Also, it is possible to have redundant 
 #include
 s. For example, suppose the header file
  XmILabel.h
  requires
  XmISeparator.h
  and con-
 tains an internal
  #include
  for it, but the program itself also includes it. In this case, the file is 
 included twice, which makes extra, unnecessary work for the compiler.
  
 Also, it is very easy to forget which include files are needed and which to leave out. I've 
 often had to go through a cycle of compile and get errors, figure out which include file is 
 missing, and compile again.
  
  
 Therefore, the advantages of being compact must be balanced against the disadvantages of 
 being complex and difficult to use.",NA
One header does all,"One way of avoiding the problems of multiple header files is to throw everything into a 
 single, big header file. Microsoft Windows uses this approach. A typical Windows program 
 contains the line:
  
 #include <windows.h>
  
 This is much simpler than the multiple include file approach taken by X Windows System. 
 Also, there is no problem with loading a header file twice because there is only one file and only 
 one
  #include
  statement.
  
 The problem is that this file is 3,500 lines long, so even short 10-line modules bring in 3,500 
 lines of include file. This make compilation slower. Borland and Microsoft have tried to get 
 around this problem by introducing “precompiled” headers, but it still takes time to compile 
 Win-dows programs.
  
 c01.doc
  
 - 5 -
  
  Modified: January 9, 1999 12:16 am",NA
Mixed approach,"Borland's Turbo Vision library (TV) uses a different method. The programmer puts
  #define 
 statements in the code to tell the TV header which functions will be used. This is followed by 
 one 
 #include
  directive.
  
 #define Uses_TRect
  
 #define Uses_TStatusLine
  
 #define Uses_TStatusDef
  
 #define Uses_TStatusItem
  
 #include <tv.h>
  
 The file
  tv.h
  brings in additional include files as needed. (The
  #define
 s determine what is 
 needed.) One advantage over multiple include files is that the files are included in the proper 
 order, which eliminates redundant includes.
  
 This system has another advantage in that only the data that's needed is brought in, so compi-
 lation is faster. The disadvantage is that if you forget to put in the correct
  #define
  statements, 
 your program won't compile. So while being faster than the all-in-one strategy, it is somewhat 
 more complex.",NA
Program Aesthetics,"A properly designed program is easy to read and understand.
  
 Part of what makes books readable is good paragraphing. Books are broken up into para-
 graphs and sentences. A sentence forms one complete thought, and multiple sentences on a 
 single subject form a paragraph.",NA
Code paragraphs,"Similarly, a C program consists of statements, and multiple statements on the same subject 
 form a conceptual block. Since “conceptual block” is not a recognized technical term, you may 
 just as well call them paragraphs. In this book, paragraphs are separated from each other by a 
 blank line. You can separate paragraphs in C in the same way.
  
 Omitting paragraphs in code creates ugly, hard-to-read programs. If you’ve ever tried reading 
 a paper without paragraphing, you realize how easy it is to get lost. Paragraph-less programming 
 tends to cause the program to get lost:
  
 c01.doc
  
 - 6 -
  
  Modified: January 9, 1999 12:16 am",NA
Statements,"Good paragraphing improves the aesthetics, hence the readability, of a program. But there are 
 also aesthetic issues at the level of the sentence; or in C, the statement. A statement expresses a 
 single thought, idea, or operation. Putting each statement on a line by itself makes the statement 
 stand out and reserves the use of indentations for showing program structure.",NA
"Chapter 2: File Basics, Comments, and Pro-",NA,NA
gram Headings,"To program some of the very early computers, programmers had to rewire the machine. The 
 programers got a large circuit board called a plug board, which was filled with little holes where 
 they plugged in wires to create the program. Once they had programmed the board, they slid it 
 into the computer and ran the program.
  
 Computers soon evolved to the point where programmers could program them in text. They 
 typed their program on a machine that output punched cards, dropped the thick deck of cards into 
 the card reader, and the computer did the rest. Editing the program was as simple as replacing 
 cards, but woe be to the programmer who dropped the program and scattered the cards.
  
 Today we use text editors, which are certainly an improvement over punched cards and plug 
 boards, but they do have their limitations. Knowing these limitations can help you to write code 
 that will always be readable.",NA
File Basics,"C can accept files of almost any size, but there are some practical limitations. The longer a 
 file, the more time and effort it takes to edit and print it. Most editors tend to get a bit slow when 
 the file size gets to be more than about 3,000 lines. Keep yours within this limit.
  
 Rule 2-1:
  
 Keep programs files to no longer than about 2,000 to 3,000 lines.
  
 Not only are there length limitations, but width limits as well. The old punch cards contained 
 80 columns. Because of that, most terminals and printers at the time were limited to 80 columns. 
 This limitation has carried over to present-day computers. For example, the PC screen is only 80 
 columns wide.
  
  
 Long lines can be a problem in programming. Many printers truncate lines that are too long, 
 resulting in listings that look like this:
  
 result = draw_line(last_x, last_y, next_x, next_y, line_style, end_style,
  
 The code that fell off the right side is referred to as mystery code. So you need to limit the 
 width of your program files to 80 characters. Actually, you need a slightly smaller limit. Program 
 printers such as
  cpr
  print line numbered listings. Line numbers take up space, so a better limit, 
 and one with enough history to be taken seriously, is 72 characters.
  
 Rule 2-2:
  
 Keep all lines in your program files down to 72 characters or fewer.
  
 c02.doc
  
 - 11 -
  
  Modified: January 9, 1999 12:16 am",NA
The Comment,"Well-written code can help a programmer understand what is going on, but the best form of 
 communication is the comment. Comments are used to explain everything. Without comments, a 
 programmer has to go through the long and painful process of decrypting the program to figure 
 out what the heck it does.
  
 The comment can convey a variety of information, including program design, coding details, 
 tricks, traps, and sometimes even jokes. There are many types of comments, from important ones 
 that you want make sure the programmer doesn't miss to explanations of the tiniest details.
  
  
 The author of a book has the advantage of typesetting devices. Important information can be 
 set in
  BIG BOLD LETTERS,
  or words can be
  emphasized
  with italics.
  
 The programmer, on the other hand, is limited to a single size, single face, monospaced font 
 and personal imagination. Over the years a lot of imagination has been used to make up for the 
 limitations of the medium.
  
 Rule 2-5:
  
 Include a heading comment at the beginning of each file that explains the file.
  
  
 The following program illustrates a variety of commenting styles collected over the years 
 from many different sources.
  
 c02.doc
  
 - 13 -
  
  Modified: January 9, 1999 12:16 am",NA
Graphics,"Computers are becoming more and more graphically oriented. Screen layouts, windowing 
 systems, and games all require sophisticated graphics. It's not possible to put graphic comments 
 into a program yet, but you can make a good attempt by using ASCII line art.
  
 A typical screen layout comment might look like this:
  
 /**************************************************
  
 * Format of address menu 
  
 *
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
 *
  
 <----- MENU_WIDTH ------>
  
 MENU_HEIGHT
  
 *
  
 +-----------------------+
  
 ^
  
 *
  
 | Name: _______________ | <-- NAME_LINE
  
 |
  
 *
  
 | Address: ____________ | <-- ADDRESS_LINE |
  
 *
  
 | City: _______________ | <-- CITY_LINE
  
 |
  
 *
  
 | State: __ Zip: ______ | <-- STATE_LINE
  
 |
  
 *
  
 +-----------------------+
  
 v
  
 *
  
 ^
  
 ^
  
 *
  
 |
  
 |
  
 *
  
 |
  
 +--- ZIP_X
  
 *
  
 +--- BLANK_X
  
 **************************************************/
  
 Even with the crude drawing tools in the 95 standard ASCII characters, you can produce a 
 rec-ognizable picture. This type of comment actually conveys graphically the relationships 
 among the constants shown.",NA
Packing bits,"If you do 1/0 programming, you know that hardware designers like to pack a lot of functions 
 into a single byte. For example, the serial 1/0 chip that controls the COM ports on a PC contains 
 a variety of packed registers.
  
 Mode
  
 Break
  
 Parity
  
 Stop
  
 Stop Bits
  
 Parity: 
  
 000 - No parity 
  
 001 - Odd Parity / No Check 
  
 010 - Even Parity / No Check 
  
 011 - High Bit always set 
  
 100 - Odd Party / Check Incoming characters 
 101 - Even Parity / Check Incoming characters 
 110 - Undefined 
  
 111 - Parity Clear
  
 Stop Bits:
  
 00 - 1 Stop Bit 
  
 01 - 1.5 Stop Bits 
  
 10 - 2 Stop Bits 
  
 11 - Undefined
  
 These registers are documented in the chip's data sheet. Unfortunately, most programmers 
 don't carry around a complete set of data sheets, so it is very useful to copy the register specifica-
 tion into the
  
  
 This can be turned into a nice comment and a few defines. (How to write the
  #define
  state-
 ments is discussed in Chapter 6.)
  
 c02.doc
  
 - 16 -
  
  Modified: January 9, 1999 12:16 
 am",NA
Letting the Editor Help You,"Most editors have a macro of abbreviation features that make it quick and easy to create 
 boxed comments.",NA
Beginning Comment Block,"The first two questions a programmer should ask when confronting a strange program 
 are“What is it?” and “What does it do?” Heading comments should answer both questions.
  
  
 The top of a program serves as a sort of title page and abstract. It briefly describes the 
 program and provides vital information about it.
  
 Here, the heading comments are boxed. This not only makes them stand out, but it easily 
 iden-tifies them as containing important and generally useful information. The first line of the 
 heading block contains the name of the program and a short description of what it does.",NA
The sections of a heading,"The following is a list of heading sections, but not all sections apply to all programs. Use 
 only those that are useful to your program.
  
 •
  
 Purpose
  
 Why was this program written? What does it do?
  
 •
  
 Author
  
 it took you a great deal of time and trouble to create this program. Sign your work. Also, 
 when someone else has to modify this program, they can come to you and ask you to 
 explain what you did.
  
 •
  
 Copyright or License
  
 Most commercial programs are protected by copyright or trade secret laws. Generally, 
 this is some boilerplate text devised by lawyers. You don't have to understand it, but you 
 should put it in.
  
 •
  
 Warning
  
 Sometimes a programmer discovers the hard way that his program contains traps or pit-
 falls. This section should warn about potential problems. For example: “Don't compile 
 with stack checking on. This is a clever program, and it does strange things with the 
 stack.”
  
 c02.doc
  
 - 18 -
  
  Modified: January 9, 1999 12:16 am",NA
Other sections,"We've listed a general set of heading sections. You may need additional sections, depending 
 on your environment. For example, a student may be required to put in an assignment number, 
 social security number, and teacher's name. Professional programs may require a part number. 
 Shareware must include a paragraph that asks the user to pay a license fee, along with an address 
 to which users can send money.",NA
Module Headings,"Modules are similar to program files, except that there is no
  main
  function. Their heading 
 comments are also structured similarly, except that there is no “Usage” section.
  
 c02.doc
  
 - 21 -
  
  Modified: January 9, 1999 12:16 am",NA
Function Headings,"C functions serve much the same purpose as sections of a chapter in a book. They deal with a 
 single subject or operation that the reader can easily absorb.
  
  
 In this book, each section starts with a section heading in bold letters. This allows the user to 
 scan down a page to locate a section.
  
  
 A function needs a similar heading. The comment box for a function should contain the fol-
 lowing sections:
  
 •
  
 Name
  
 The name of the function and a brief comment describing it.
  
 •
  
 Parameters
  
 A list of parameters (one per line) and a brief description of each of them. Sometimes the 
 words (returned) or (updated) are added.
  
 •
  
 Return value
  
 Describes what value the function returns. In addition to these standard sections, any 
 other useful information about the function can be added. Here's an example:
  
 c02.doc
  
 - 22 -
  
  Modified: January 9, 1999 12:16 am",NA
When to Write Comments,"It is best to put your comments in the program as you are writing it. If you start your program 
 with a set of heading comments, then you should have a pretty good idea what you are planning 
 to do. It helps focus your thoughts.
  
 Avoid the two-step process of coding and later going back and adding comments. This 
 method has several problems. First, you are likely to forget what you did. What may be obvious 
 when you write it may not be so obvious when you re-read it.
  
 Another good reason to write comments while you're writing the code is psychological. 
 When the code is done, you're probably going to feel that the program is done. Adding 
 comments then becomes a chore to be completed as quickly as possible. Generally, this means 
 you'll put in too few comments.
  
  
 It is especially helpful to do things like screen layouts in comments before you start coding. 
 That way you have a model to work from.
  
 Rule 2-7:
  
 Comment your code as you write it.
  
 c02.doc
  
 - 23 -
  
  Modified: January 9, 1999 12:16 am",NA
Some Comments on Comments,"The heading comments always seem a bit long to the person creating the program. To the 
 per-son trying to maintain it, they always seem far too short. Balance is the key to good 
 commenting. Make your comments short enough so they aren't bothersome to put in, yet long 
 enough to give other programmers a good idea of what's going on.
  
  
 Overly commented programs are rare. Usually they turn up in the work of eager first-year 
 pro-gramming students.
  
  
 Under-commented programs are far too frequent. Too many programmers think that their 
 code is obvious. It is not.
  
 There is a reason it is called “code.”
  
 c02.doc
  
 - 24 -
  
  Modified: January 9, 1999 12:16 am",NA
Chapter 3: Variable Names,"In English, we put words together to make up sentences. The language is fairly easy to under-
 stand when you know what most of the words mean. Even if you don't know some words, you 
 can look them up in the dictionary.
  
 Variables are the “words” for the C language. In a program, variables have a precise 
 definition and usage, but that definition and usage are different for each program. What's worse, 
 some pro-grammers tend to use abbreviations, even for simple things. Shakespeare wrote, “That 
 which we call a rose by any other name would smell as sweet.” (Romeo and Juliet, Act II, Scene 
 2). But calling a rose an “RZ” creates needless confusion.
  
 Bureaucratize is a prime example of how things get mixed up when people start using their 
 own unique languages. Government agencies don't fire people, they “dehire” them. That 
 probably wouldn't be confusing to the person being dehired, but consider this example: The 
 Army files“Zipper” under “I.” why? Zipper used to be a trade name, making it illegal for Army 
 filing, so they use the generic name “Interlocking cloth fastener.” These are the same people who 
 file furry teddy bears under the label “Bears, fur, Edward.”
  
  
 Call a spade a spade. Don't call it “spa”, “s1”, or “pronged digging implement.” Simplicity 
 and a firm grasp of the obvious are necessary for good C programming.
  
 Rule 3-1:
  
 Use simple, descriptive variable names.",NA
A Brief History of the Variable,"Early computers were initially used for solving complex and repetitive mathematical equa-
 tions. Not surprisingly, early programming languages looked a lot like algebra. Mathematicians 
 generally use single character variable names because they don't care what the variables stand 
 for.
  
 (They're not supposed to; that's what it means to be a mathematician.)
  
 For example, the equation for the area of a triangle is:
  
 a 
  
 = 2---
 bh 
  
  
 1
  
 where
  a
  is the area of the triangle,
  b
  is the base, and
  h
  is the height.
  
 c03.doc
  
 - 25 -
  
  Modified: January 9, 1999 12:07 am",NA
1 ,NA,NA
n,NA,NA
---,NA,NA
 ,NA,NA
U,f,NA
 U,k,NA
+–,NA,NA
 ,NA,NA
 ,NA,NA
U,f,NA
1,NA,NA
 ,NA,NA
 ,NA,NA
U,f,NA
+1,NA,NA
,NA,NA
,NA,NA
------------------------------------------------------------------------------,NA,NA
----------------------------------------------------------------------------,"lim
  
 n
 ",NA
 ,NA,NA
 ,NA,NA
1 ,NA,NA
U,"j 
  
  
   
   
 2",NA
–,NA,NA
 ,NA,NA
 ,NA,NA
U,f,NA
1,NA,NA
,2,NA
,NA,NA
 ,NA,NA
 ,NA,NA
U,"f 
  
  
  
  
   
  
   
  
     
 2",NA
+–,NA,NA
 ,NA,NA
 ,NA,NA
1 ,NA,NA
U,f,NA
+,NA,NA
k,NA,NA
,2,NA
,NA,NA
,NA,NA
,"However, it isn't very clear. Even the simple triangle example requires a somewhat longer 
 line of explanation so we know the meaning of
  a
 ,
  b
 , and
  h
 .
  
 In mathematics, you can append notes when you need to break out of the sea of symbols to 
 explain what the symbols stand for. In programming, where code can easily run 10 or more 
 pages and where you care a little more what the symbols stand for, variable names should be 
 more meaningful.
  
 As people discovered that they needed longer variable names, computer languages improved. 
 The first BASIC interpreter limited variables to a single letter and an optional digit (
 A
 ,
  B2
 ,
  C3
 , 
 etc.)
  
 FORTRAN gave the programmer six characters to play with—really 5 1/2, since the first 
 char-acter denoted the default type. That meant that instead of using I for an index, you could use 
 a name like
  INDEX
 . This was progress. (One problem with FORTRAN was that it used the first 
 let-ter of the variable name for type information. So people would use
  KOUNT
  for “count” so 
 that the type would be integer.)
  
  
 In C the length of a variable name is unlimited (although the first 31 characters must be 
 unique). So variable names like these:
  
 disk_name
  
 total_count
  
 last_entry
  
 are legal.
  
 If long is better, then very long must be much better, right? Consider this example:
  
 total_number_of_entries_with_mangled_or_out_of_range_dates
  
 This is an extremely descriptive name; you know exactly what this variable is used for. But 
 there are problems with names like this. First, they are difficult to type. Second, remembering the",NA
Capitalization,"Shortly after the invention of moveable type, printers began to arrange their letters in 
 specially designed boxes, or cases. Soon a standard arrangement emerged: two drawers were 
 used for each typeface, the top one holding the capital letters, and the bottom for all the others. 
 Thus the terms uppercase and lowercase.
  
 In many programming languages case is ignored, but in C, uppercase is distinguished from 
 lowercase. This means, for example, that Count, count and COUNT are three different names. 
 This can lead to problems, but it also gives you another tool for making variable names meaning-
 ful.
  
  
 Over the years programmers have devised special naming and capitalization conventions for 
 variables, functions, and constants.
  
 System A
  
 total_count
  
 Variable and 
  
 function names
  
 All lowercase words separated by 
 underscores
  
 NAME_MAX
  
 Constants
  
 All uppercase words separated by 
 underscores
  
  
 One of the advantages of this system is that all the component words (total, count, name, 
 max) are separated from each other. This allows you to run the program through a spelling 
 checker.
  
 System B
  
 TotalCount
  
 Variable and 
  
 function names
  
 Upper/Lower case with no separa-
 tors.
  
 NAME_MAX
  
 Constants
  
 All uppercase words separated by 
 underscores
  
  
 c03.doc
  
 - 27 -
  
  Modified: January 9, 1999 12:07 am",NA
Names You Must Never Use,"A programmer once came up with a brilliant way to avoid ever getting a traffic ticket. He 
 sub-mitted a request for a personalized license plate with the choices “
 0O0O0O
 ”, “
 1l1l1l
 ”, 
 and“
 ll0O11
 ”. He figured that if his license plate read “
 0O0O0O
 ”, the police would find it 
 difficult to tell the difference between the letter “
 O
 ” and the digit “
 O
 ”. The problem was, the 
 DMV clerk had the same problem, so he got a personalized license plate that read “
 000000
 ”.
  
  
 The uppercase letter “
 O
 ” and the digit “
 O
 ” can easily be confused. So can the lowercase 
 letter“
 1
 ” and the digit “
 1
 ”.
  
 Rule 3-3:
  
 Never use
  I
  (lowercase
  L
 ) or
  O
  (uppercase
  O
 ) as variable or constant names.",NA
Other Names Not To Use,"Don't use names already in the C library. You'll never know who calls them. I recently ported 
 a program that defined its own version of
  getdate
 . The program worked under UNIX because 
 although the C library has a
  getdate
  function, the program never expected to use it.
  
 When the application was ported to the PC, I discovered that
  getdate
  called the library func-
 tion
  time
 . This function had an internal call to
  getdate
 . It expected to call the system
  getdate
 , not 
 a local function defined in the program. But the program overrode the library's
  getdate
 , which 
 resulted in
  getdate
  calling
  time
  calling
  getdate
  calling
  time
 —until the stack overflowed.
  
 A quick global rename was done to turn
  getdate
  into
  get_current_date
 , and the 
 porting problem went away. But it would have never occurred in the first place if the 
 programmer hadn't used an existing C library function:
  
 c03.doc
  
 - 28 -
  
  Modified: January 9, 1999 12:07 am",NA
Avoid Similar Names,"Subtle differences in variable names should be avoided. For example, the variable names 
 total and totals can be easily confused. Differences between variables should be blatant, such as 
 entry_total
  and
  all_total
 .
  
 Rule 3-5:
  
 Don't use variable names that differ by only one or two characters. Make every name
  
 obviously different from every other name.",NA
Consistency in Naming,"Consistency and repetition are extremely powerful programming tools. Use similar names for 
 similar functions. In the following example, you can easily guess the name of the missing vari-
 able:
  
 int start_hour; 
  
 /* Hour when the program began */
  
 int start_minute; 
  
 /* Minute when the program began */
  
 int ??????; 
  
 /* Second when the program began */
  
 If
  start_hour
  is the hour when the program began and
  start_minute
  is the minute, 
 you can easily figure out the name of the variable that holds the seconds. Think how confusing it 
 would be if the programmer had written this:
  
 int start_hour; 
  
 /* Hour when the program began */
  
 int begin_minute; 
  
 /* Program start time. minutes only */
  
 /* Seconds on the clock at program commencement */
  
 int commence_seconds;
  
 Rule 3-6:
  
 Use similar names for variables that perform similar functions.",NA
Which Word First,"Suppose you have a variable that denotes the maximum entry in a series of numbers. You 
 could call it
  max_entry
  or
  entry_max
 . How do you decide which name to use?
  
 Picking one at random is does not work, because you might at one time pick
  max_entry
  
 for one program and
  entry_max
  for another. Experience shows that too often we forget which 
 one we picked for a particular program, which results in confusion. More often than I care to 
 mention, I've had to do a global search and replace to change
  max_entry
  to
  entry_max
 .
  
 c03.doc
  
 - 29 -
  
  Modified: January 9, 1999 12:07 am",NA
Standard Prefixes and Suffixes ,"Over the years a few standard prefixes and suffixes have developed for variable names. 
 These include the following: 
  
 _ptr 
  
 Suffix for pointer 
  
  
  
 Examples: 
  
  
  
  
 int *entry_ptr; /* Pointer to current entry */
  
 _p
  
 char *last_ptr; /* Pointer to last char in str */ 
 Another suffix for pointer. This can be a little confusing to people who are not 
 familiar with it, so the suffix
  _ptr
  is preferred.
  
 Examples: 
  
  
 event *next_p;/* Pointer to next event in queue 
 */
  
 _file
  
  
 char *word_p; /* Pointer to start of next word */ 
 A variable of type FILE *, or a C++ I/O stream.
  
 Examples: 
  
  
 FILE *in_file; /* Input data file 
 */
  
 _fd
  
  
 FILE *database_file;/*Where we put the database 
 */ 
 File descriptor (returned by the open function.)
  
 Examples: 
  
 /* The dictionary file descriptor 
 */ 
  
 int dictionary_fd;
  
 /* File where we put the memory dump */
  
 n_
  
 int dump_fd; 
  
 Number of. For example, if you store a set of events in the array events, the 
 n_events
  is the number of entries in the events array. Does this violate the rule 
 about putting the most important word first? Yes, but it's established usage.
  
 Examples:",NA
Module Prefixes,"When creating large modules or libraries (more than 10 functions), a prefix is sometimes 
 added to each variable and function in the library. For example, everything in a database library 
 might start with the prefix
  Db
 .
  
 Example:
  
 int DbErrorNumber;
  
 extern int DbOpen(char *name);
  
 extern int DbClose(int handle);
  
 This serves two purposes: first, it identifies the module containing the name; and second, it 
 limits name conflicts. A symbol table module and a database both might have a lookup function, 
 but the names
  SymLookup
  and
  DbLookup
  do not conflict.
  
 The X Windows system uses this naming convention extensively. All X Windows functions 
 begin with the letter X. However, the system is so complex that it has been further divided 
 into“tool kits,” each of which has its own prefix. For example, Xt is the Andrew Tool kit, Xv is 
 the X-view tool kit, etc.",NA
Special Prefixes and Suffixes,"Sometimes you need to use special names, names that you can be sure don't conflict with a 
 large body of existing code. Such cases call for unusual naming conventions.
  
 For example, the C preprocessor had been around a number of years before the ANSI Com-
 mittee decided on a standard set of predefined symbols. In order to avoid conflict, they decided 
 that each symbol would look like this: (
 __SYMBOL__
 ).
  
 Some of the predefined symbols include:
  
 c03.doc
  
 - 31 -
  
  Modified: January 9, 1999 12:07 am",NA
When You Can Use Short Names,"In some cases you can use short variable names. For example, when dealing with a graphic 
 position, the variables
  x
  and
  y
  are descriptive.
  
 Also, the variable named “
 i
 ” is frequently used as a general purpose, handy dandy, local 
 index. Its popularity makes it acceptable as a variable name, even though the name index is more 
 descriptive.
  
 Rule 3-9:
  
 Short names such as
  x
 ,
  y
 , and
  i
  are acceptable when their meaning is clear and 
 when a longer name would not add information or clarity.",NA
"argv, argc","The main function of a C program takes two arguments. In 99 percent of the programs, the 
 arguments are named
  argv
  and
  argc
 . In the other 1 percent, we wish the programmer had 
 used 
 argc
  and
  argv
  instead of
  ac
  and
  av
 .
  
 A lot of history has gone into these names. When programmers see them, they immediately 
 think “command line arguments.” Don't confuse the issue by using these names for anything 
 else.
  
 Rule 3-10:
  
 Use
  argc
  for the number of command line arguments and
  argv
  for the argument list. 
 Do not use these names for anything else.",NA
Microsoft Notation,"When Microsoft introduced Windows, it also introduced a new variable naming notation 
 called Hungarian Notation. (There are two reasons why it's called that. First, Charles Simonyi, 
 the man who invented it, is Hungarian. Second, most people looking at it for the first time think 
 that it might as well be written in Hungarian.) It's also known as Microsoft Notation.
  
 The idea is simple: prefix each variable name with a letter denoting its type; for example,
  w
  
 for a 16-byte integer (
 word
 ), and
  l
  for a 32-byte integer (
 long
 ). That way, you can easily 
 prevent pro-gramming problems caused by type conflicts. For example:
  
 c03.doc
  
 - 32 -
  
  Modified: January 9, 1999 12:07 am",NA
Imaginative Solutions,"PC class machines come with a line drawing character set that allows the programmer to con-
 struct things like single and double lined boxes. One of the problems PC programmers face is 
 what to name these curious characters when they are referred to in a program. One solution is to 
 begin every single line character with S. followed by the character type: C for corner, L for line, 
 T for T and X for cross, followed by a name. The result is:
  
 Character
  
  
  
  
  
  
  
  
     
 Name 
  
 S_C_UR
  (Single, Corner, Upper Right) 
 S_C_UL
  (Single, Corner, Upper Left) 
 S_C_LR
  (Single, Corner, Lower Right) 
 S_C_LL
  (Single, Corner, Lower Left)
  
 S_L_A
  (Single, Line, Across)
  
 S_C_UR
  (Single, Line Down)
  
 SD_X_DA
  (Single Down, crossing Double Across)
  
 After a while this system tends to make you sick. The problem with this system is that it's 
 complex and somewhat error prone. At the time it was the best we could come up with, but that 
 didn't stop us from trying something new.
  
  
 Then someone figured out a system where you started at the top and worked your way 
 around, counting the number of lines (0, 1, or 2).
  
 0
  
 1
  
 c03.doc
  
 - 34 -
  
  Modified: January 9, 1999 12:07 am",NA
Case studies,"Over the years different groups have developed their own standard naming conventions. 
 Each has its own advantages and disadvantages. This section will look at some of the standard 
 pro-grams and how they use their names.",NA
The C runtime library,"The C runtime library traces its roots back to the first C compiler. It evolved over the years, 
 and the ANSI Committee standardized it.
  
 Naming conventions:
  
 Private variable names 
  
 All lowercase
  
 Public variable names 
  
 All lowercase
  
 Constant names 
  
 Uppercase only
  
 The C library is full of short, cryptic names like these:
  
 creat
  
 stdin
  
 stdout
  
 open
  
 strcpy
  
 printf
  
 memcmp
  
 malloc
  
 Initially names were restricted because of severe limitations in the compiler, which ran on 
 some extremely small machines. Also, the early programmers didn't place any value on long 
 names.
  
 These names are somewhat cryptic. For example, the function
  strcpy
  copies a string. A 
 much better name would have been
  string_copy
 . And using
  creat
  instead of
  create
  is 
 pretty silly.
  
  
 The language does not make good use of prefix and suffix letters. For example, here is the 
 printf
  family of functions:
  
 printf 
  
 fprintf
  
 c03.doc
  
 Print to standard output 
  
 Print to a file
  
 - 35 -
  
  Modified: January 9, 1999 12:07 am",NA
The UNIX kernel,"The UNIX operating system was one of the very first to be written in a high level language. 
 It was the first to be widely ported. Today, almost every computer that’s not a PC clone runs 
 UNIX.
  
 Naming Conventions
  
 Private variable names 
  
 All lowercase
  
 Public variable names 
  
 All lowercase
  
 Constant names 
  
 Uppercase only
  
 UNIX is the king of the 1 to 3 character variable names. Some typical names are:
  
 u
  
 bp
  
 i
  
 bn
  
 pid
  
 uid
  
 gid
  
 fd
  
 After a while, UNIX operating system programmers learn the meaning of most of the 
 abbrevi-ations. The know that
  pid
  stands for process
  id
  and
  bp
  is a buffer pointer. But it 
 takes time and effort to learn this code. In fact, UNIX internal programming is not for the 
 inexperience or the faint of hear.t Most programmers must be introduced into the world of UNIX 
 internals by an experience guru.
  
 c03.doc
  
 - 36 -
  
  Modified: January 9, 1999 12:07 am",NA
The Microsoft library,"dispatch 
  
 tty_select
  
 Microsoft Windows provides PC programmers with a graphics programming environment. It 
 also allows programmers to better use the power of the more advanced 80386 and 80486 proces-
 sors.
  
 Naming conventions:
  
 Private variable names 
  
 Up to the application programmer
  
 Public variable names 
  
 Upper and lowercase
  
 Constant names 
  
 Uppercase only
  
  
 Function names in Microsoft Windows are nicely done, consisting of several words put 
 together. Examples:
  
 GetFreeSpace
  
 UnlockSegment
  
 CreateBitmap
  
 CloseClipboard
  
 GetWindow
  
 AppendMenu
  
  
 However, there is no special prefix or suffix for Windows functions, so it's impossible to tell 
 at a glance whether or not
  OpenFile
  is a Windows function. Constants are all Uppercase.
  
 Examples:
  
 LB_SETSEL
  
 WM_MOUSE
  
 WM_MOVE
  
 WM_CLOSE
  
 EN_UPDATE
  
 LB_MSGMAX
  
 Each constant contains a short group prefix. For example, all “List box” related constants 
 begin with
  LB_
 . Almost all Windows constants contain only one “_”, which is used to separated 
 the prefix from the rest of the constant. Multiple words are run together, making it difficult to 
 read. Therefore a constant like
  WM_WINDOWPOSCHANGED
  would be much more readable if it 
 was written as
  WM_WINDOW_POS_CHANGED
 .
  
  
 In general, the Windows naming convention makes programs more readable than the UNIX 
 code or C library. Although not perfect, it is a step forward.",NA
The X Windows System,"The X Windows is a popular UNIX windowing system available from MIT. Its low cost and 
 relative availability make it the windowing system of choice for most UNIX systems.
  
 Naming conventions:
  
 Private variable names 
  
 Up to the application programmer
  
 Public variable names 
  
 Uppercase and lowercase
  
 Constant names 
  
 Most Uppercase only, some upper and lowercase
  
  
 One of the most refreshing things about X Windows programming is that it actually looks 
 like someone thought about the design and style of the system before beginning the coding.
  
 c03.doc
  
 - 37 -
  
  Modified: January 9, 1999 12:07 am",NA
Variable Declaration Comments,"Choosing good variable names helps create programs that are easy to read and maintain. But 
 names can't do the job alone. The programmer needs a definition for each variable. Technical 
 books have glossaries that explain all the special terms. We also need a glossary for our 
 programs.
  
  
 Writing a glossary is a lot of work. Maintaining it and keeping it up to date is even more 
 work. A better solution is to follow each variable with a comment that describes it.
  
 Examples:
  
 int window; 
  
 /* Current window index */
  
 int words; 
  
 /* Number of words in the document */
  
 int line_number; 
  
 /* Current input file line number */
  
 char *in_name; 
  
 /* Current input file name */
  
  
 Now, if you want to know the definition of line_number, go to your cross reference and look 
 for the first reference to the variable, thus locating the line:
  
 int line_number; /* Current input file line number */
  
 Using this method, you can quickly determine the type and definition of any variable.
  
 Rule 3-11:
  
 Follow every variable declaration with a comment that defines it.",NA
Units,"Weather services generally measure rainfall in hundredths of inches, referring to half an inch 
 of rain as 50. However, one night the weather service computer used inches as input. Someone 
 forgot a decimal point and entered 50 instead of 0.50.
  
 c03.doc
  
 - 38 -
  
  Modified: January 9, 1999 12:07 am",NA
Structures and unions,"A structure is simply a group of related variables tied together to form a convenient package. 
 Each field in a structure should be treated like a variable, with a carefully chosen name. A 
 descrip-tive comment is necessary as well.
  
 Example:
  
 c03.doc
  
 - 39 -
  
  Modified: January 9, 1999 12:07 am",NA
Long declarations and comments,"Sometimes a variable declaration and its initializer leave little room for a comment. In the 
 fol-lowing example, we need to describe
  last_entry,
  but where do we put the comment?
  
 int first_entry; 
  
 /* First entry to process */ 
 int last_entry = (GOOD-ENTRIES + BAD-ENTRIES + FUDGE); 
 int current_entry; 
  
 /* Entry we are working on 
 */
  
  
 There's no room at the end of the line. The solution is to put the description on a separate line 
 in front of the variable:
  
 int first_entry; 
  
 /* First entry to process */ /* 
 Last entry number to process */ 
  
 int last_entry = (GOOD-ENTRIES + BAD-ENTRIES + 
 FUDGE); int current_entry;       /* Entry we are 
 working on */
  
 But this is still not good enough. This section of code looks like a big gray blob. It's not easy 
 to locate the description for
  last_entry.
  Adding white space not only breaks up the blob, it also 
 helps group
  last_entry's
  comment and declaration as shown here:",NA
Group similar declarations,"Repetition and consistency are powerful organizing tools. When declaring variables, group 
 similar variables together and use similar names.
  
 int errors_out; 
 int errors_in;
  
 int max_out; 
  
 int max_in;
  
 int min_out; 
  
 int min_in;
  
 /* Total number of output errors 
 */ /* Total number of input errors 
 */
  
 /* Max output error rate (errors/hour) 
 */ /* Max input error rate (errors/hour) 
 */
  
 /* Min output error rate (errors/hour) 
 */ /* Min input error rate (errors/hour) 
 */
  
 This example uses the prefix
  errors_
  for the counters that accumulate a running total of the 
 input/output errors. The variables that hold the limits start with the fixes
  max
 _ and
  min
 _. 
 Common suffixes are also used. All output-related variables end with _
 out,
  and input variables 
 with
  _in
 .
  
  
 Notice that each group of variables consists of two declarations, the first one for the output 
 and the second one for the input.
  
 This example shows only one of several possible groupings. Another possible method is this:
  
 int errors_out; 
 int errors_in;
  
 int max_out; 
  
 int max_in;
  
 int min_out; 
  
 int min_in;
  
 /* Total number of output errors 
 */ /* Total number of input errors 
 */
  
 /* Max output error rate (errors/hour) 
 */ /* Max input error rate (errors/hour) 
 */
  
 /* Min output error rate (errors/hour) 
 */ /* Min input error rate (errors/hour) 
 */
  
 Rule 3-17:
  
 Group similar variables together. When possible, use the same structure for each group.
  
 c03.doc
  
 - 41 -
  
  Modified: January 9, 1999 12:07 am",NA
Hidden Variables,"Hidden variables occur when a variable is declared in a global scope and is then declared 
 again in a local scope. The second declaration “hides” the first.
  
 In the following example, the second declaration of location hides the first.
  
 /* Bad programming practice */
  
 /* Distance traveled by the car in miles 
 */ float location;
  
 /*..... */ 
  
 void display_location(void) 
  
 { 
  
  
 /* Location of current cursor */ 
  
  
 int location;   /* *** Hides previous declaration *** 
 */
  
 The problem is that we've now used the same word for two different things. Is location a glo-
 bal or a local? Is it a
  float
  or an
  int
 ? Without knowing which version of the variable is being 
 referred to, we can't answer these questions.
  
  
 There are enough variable names in the universe that there's no reason to use the same name 
 twice. We could just as easily have used a different name for the second declaration:
  
 /* Good programming practice
  
 /* Distance traveled by the car in 
 miles 
  
 float car_location;
  
 /*..... */
  
 void display_location(void) 
  
 { 
  
  
 /* Location of current cursor 
 */ 
  
  
 int cursor_location;
  
 Rule 3-18:
  
 Don't use hidden variables.",NA
Portable Types,"The C compiler runs on many different machines. Making portable programs that can run on all these 
 machines is an art. One trick used to define portable types. For example, Novell uses the type WORD
  and 
 DWORD
  in all its header files. But
  what is a
  WORD?
  Is it 8, 16, or 32 bits? Is it signed or unsigned? 
 You can't tell from the name.",NA
Numbers ,"C uses a wide variety of numbers, and it's easy to get them confused. Be careful to make 
 num-bers clear and unambiguous.",NA
Floating-point numbers ,"Here are some examples of floating-point numbers:
  
 0.5
  
 .3
  
 6.2
  
 10.
  
 32E4
  
 1e+10
  
 0.333331
  
 5E-5
  
 A zero in front of the decimal point is optional. For example, C treats
  0.8
  and
  .8
  same. 
 But there is a difference.
  .8
  looks a lot like the integer
  8
 , while the number
  0.8
  is obviously 
 floating-point. Similarly, you should write numbers like
  5.
  as
  5.0
 .
  
 Rule 3-20: 
  
  
 Floating-point numbers must have at least one digit on either side f the decimal point.
  
 Large floating-point numbers are written using exponent format. The exponent's “E” can be 
 written in upper or lowercase. Which is better? Well, all digits are full-height characters. The 
 uppercase E is also a full-height character and can easily get lost in a string of digits.
  
  
 32141831235432lEl32809932 
  
 The E is important and shouldn't get lost. The lowercase is easier to spot: 
  
 32141831235432lel32809932 
  
 It's even easier if you always include the sign.
  
  
  
 321418312354321e+132809932 
  
  
 So a lowercase
  e
  and a sign make these important elements of a floating-point number stand 
 out.
  
 Rule 3-21: 
  
 The exponent in a floating-point number must be a lowercase
  e
 . This is always followed 
 by a sign.
  
 Here are some examples of good floating-point numbers:
  
 c03.doc
  
 - 43 -
  
  Modified: January 9, 1999 12:07 am",NA
Hex numbers,"1.0e-333.
  
 33.0
  
 1230.0
  
  
 C uses the prefix Ox for hexadecimal numbers. A uppercase or lowercase
  x
  may be used, 
 but as discussed, lowercase letters stand out better.
  
 Rule 3-22:
  
 Start hexadecimal numbers with
  Ox
 . (Lowercase
  x
  only.)
  
 Hexadecimal digits include the letters A through F. Again, uppercase or lowercase may be 
 used, so
  OXACE
  is the same as
  OXace
 . Lowercase digits create numbers that are easily 
 confused with variable names. Uppercase digits create numbers that look like constants.
  
 0xacde
  
 ace
  
 face
  
 0Xdead
  
 0xACE
  
 X_ACE
  
 BEEF
  
 0xBEEF
  
  
 Numbers are a type of constant, so confusing a number and a constant is not too problematic. 
 Mistaking a number for a variable is worse, so it is preferable to use uppercase digits.
  
 Rule 3-23:
  
 Use uppercase A through F when constructing hexadecimal constants.",NA
Long integers,"Long integers end with the letter
  L
 . Again, C is case insensitive, so lowercase can be used. 
 But lowercase
  l
  looks a lot like the number
  1
  and should be avoided. For example, the 
 following two constants look very much alike:
  
 34l 
  
 341
  
 But when the long integer is written using an uppercase
  L
 , the confusion clears up:
  
 34L 
  
 34l
  
 Rule 3-24:
  
 Long constants should end with an uppercase
  L
 .
  
 c03.doc
  
 - 44 -
  
  Modified: January 9, 1999 12:07 am",NA
Chapter 4: Statement Formatting ,"Organization is the key to a well-written program. Good programming style helps present the 
 detail and logic of your program in a clear and easy-to-un stand manner.
  
 Programming style and aesthetics are related. A well-written program pleasing to look at, 
 read, and understand. Your goal in formatting a program is to make it look neat, well-organized, 
 and beautiful.",NA
Formatting the Body of the Program,"The sentence is a basic unit of writing. A sentence ends with a terminator question mark, 
 exclamation point, or period. In C, the basic coding unit is statement. C statements do not have 
 terminators, like sentences; rather. they separated from each other by semicolons (
 ;
 ).
  
 Well laid-out programs allow the programmer to quickly and easily pick the statement within 
 the program. Running the code together, as shown in following example, hurts readability and 
 clarity:
  
 /* Poor programming practice */ 
  
 biggest=-l;first=0;count=57;init_key_words(); 
  
 if(debug)open_log_files();table_size=parse_size+lex_size;
  
  
 How many statements are in this program fragment? It's hard to tell. programmer has tried to 
 compact the program by putting as much on each line possible. It's much like the old limerick:
  
 There was a young man from Iran
  
 Whose verses just would not quite scan.
  
 When someone asked why,
  
 He gave this reply:
  
 I like to put as many words on the last line as I possibly can.
  
 It's easier to pick out the statements when there is only one statement per line
  
 /* Better programming practice (still needs work) 
 */ biggest=-l; 
  
 first=0; 
  
 count=57; 
  
 init_key_words(); 
  
 if(debug) 
  
  
 open_log_files(); 
  
 table_size=parse_size+lex_size;
  
 Rule 4-1:
  
 Write one statement per line.
  
 c04.doc
  
 - 46 -
  
  Modified: January 9, 1999 12:16 am",NA
Simplifying complex statements,"Sometimes a statement such as an assignment statement grows so long complex that it can't 
 fit on one line. In such cases, consider turning a complex statement into several smaller, simpler 
 statements.
  
 For example, this is syntactically correct, but
  
 /* This is a big mess */ 
  
 gain = (old_value - new_value) / 
  
  
 (total_old - total_new) * 100.0;
  
 It can be rewritten as three smaller statements:
  
 /* Good practice */ 
  
 delta_value = (old_value - new_value); 
  
 delta_total = (total_old - total_new); 
  
 gain = delta_value / delta_total * 
 100.0;
  
 Rule 4-3:
  
 Change a long, complex statement into several smaller, simpler statements.",NA
Splitting long statements,"An alternative to turning one statement into two is to split long statements into multiple lines.
  
 Splitting is an art. The idea is to split the line in a way that does confusion. There is a rule: 
 One statement per line. A two-line statement that rule, so always indent the second line to 
 indicate that it is a continuation.
  
 Rule 4-4:
  
 In a statement that consists of two or more lines, every line except the first must 
 be indented an extra level to indicate that it is a continuation of the first line.
  
 For example:
  
 c04.doc
  
 - 48 -
  
  Modified: January 9, 1999 12:16 am",NA
Splitting and parentheses.,"Complex statements in C can contain several levels of parentheses. The following example 
 shows a complex statement that contains many parentheses. The comment below it indicates the 
 nesting level.
  
 result = (((x1 + 1) * (x1 + 1)) - ((y1 + 1) * (y1 + 1)));
  
 /* nest 
  
 12333333322223333333321112333333322223333333321 */
  
  
 The best place to break the line is where the nesting level is lowest; in this case at the
  -
  
 opera-tor in the middle:
  
 result =(((x1 + 1) * (x1 + 1)) -
  
 ((y1 + 1) * (y1 + 1)));
  
 Rule 4-6:
  
 When breaking up a line, the preferred split point is where the parenthetic nesting is low-
  
 est.
  
  
 The second line of the example is carefully indented so that the parenthesis line up. Why not 
 align it with the first parenthesis?
  
 /* Don't program like this */
  
 result =(((x1 + 1) * (x1 + 1)) -
  
 ((y1 + 1) * (y1 + 1)));
  
  
 Notice that the lines seem to be a little off. That's because the first line's Level I parenthesis is 
 in the same column as the second line's Level 2 parenthesis.
  
 c04.doc
  
 - 49 -
  
  Modified: January 9, 1999 12:16 am",NA
Splitting a for statement.,"A
  for
  statement is unique, since it is three statement
  
 for (<initialization>; <condition>; <increment>)
  
 The
  <initialization>, <condition>, and <increment>
  are three complete C statements. If 
 these statements have any complexity at all, the entire
  for
  statement is likely to overflow the line. 
 Whenever a
  for
  grows too long for one line, split it first at the component statement boundaries.
  
 For example, this line:
  
  
 for (index = start; data[index] != 0; 
 ++index) 
 splits like this:
  
 c04.doc
  
 - 50 -
  
  Modified: January 9, 1999 12:16 am",NA
Splitting a switch statement.,"The
  switch
  statement is the most complex statement in the C language. The rule for splitting 
 it is very simple: Don't. If the index expression for a
  switch
  statement grows too big for one line, 
 split it into two different statements: an assignment and a
  switch.",NA
Conditional operators (? :).,"When splitting an expression containing a conditional operation (
 ? :
 ), try to put the entire 
 con-ditional clause on a line by itself
  
 /* Good practice (preferred) */ 
  
 result = past-due + 
  
  
 (total-owed > 0) ? total-owed : 
 0;
  
 Rule 4-11:
  
 Keep conditionals on a single line if possible.
  
  
 If the conditional clause itself is too long for one line, it can be split into three lines. The for-
 mat is this:
  
 (condition) ? 
  
 (true-value) : 
  
 (false-value)
  
  
 Each line contains one component of the expression. Since the true-value and false-value are 
 sub-sections of the conditional, their lines are indented.
  
 Rule 4-12:
  
 When splitting a conditional clause (
 ? :
 ), write it on three lines: the condition line, the 
 true-value line, and the false-value line. Indent the second and third line an extra 
 level.",NA
Side effects,"When writing a children's story, you must keep the sentence structure simple and avoid com-
 pound sentences. Well, a computer is not a child; it doesn't have that much intelligence. But in C 
 coding, you should do anything you can to simply the program. That means avoiding side 
 effects.
  
  
 A side effect is an operation that is performed in addition the main operation of a statement. 
 For example, the statement:
  
 current = count[index++]
  
 assigns current a value and increments index. Look out. Any time you start using “and” to 
 describe what a statement does, you're in trouble. The same statement could just as easily have 
 been written this way:
  
 current = count[index]
  
 index++;
  
 This way, there are no side effects.
  
  
 C allows very free use of the ++ and -- operators within other statements. Taking advantage 
 of this freedom can create all sorts of problems. Consider the statement:
  
 i = 0
  
 out[i++] = in[i++];
  
 In fact, consider it a test. Exactly what does this program do?
  
 A) 
  
 B) 
  
 C) 
  
 D) 
  
 E)
  
 Evaluate
  out[i]
  as
  out[0]
 , increment
  i
  (
 i
  is now 1), evaluate
  
 in[i]
  as 
 in[1]
 , increment
  i
  (
 i
  is now 2), do the assignment (
 out[0] 
 = in[1]
 ).
  
 Evaluate
  in[i]
  as
  in[0]
 , increment
  i
  (
 i
  is now 1), evaluate
  out[i]
  as 
 out[1]
 , increment
  i
  (
 i
  is now 2), do the assignment (
 out[1] = in[0]
 ).
  
 Evaluate
  in[i]
  as
  in[0]
 , evaluate
  out[i]
  as
  out[0]
 , increment
  i
  (
 i
  is 
 now 1), increment
  i
  (
 i
  is now 2), do the assignment (
 out[0] = in[0]
 ).
  
 The code is compiler dependent, so the compiler carefully computes the best 
 possi-ble answer and then does something else.
  
 If you don't write code like this, you won't have to worry about questions like this.
  
 This code is ambiguous, and the actual code generated can change from compiler to 
 compiler. Sometimes the same compiler will generate different code depending on the state of 
 the optimize switch.
  
 The answer, of course, is E.
  
  
 Ambiguous code is not the only problem that can occur when ++ and -- are used within other 
 statements. The statements
  
 c04.doc
  
 - 53 -
  
  Modified: January 9, 1999 12:16 am",NA
Assignments in other statements,"C also allows the programmer to put assignment statements inside other statements. For 
 example:
  
 /* Poor practice */ 
  
 if ((result = do_it()) == 5) 
  
  
 printf(“It worked\n”);
  
  
 This is another example of a side effect that needs to be avoided. You could just as easily 
 have written this:
  
 /* Good practice */ 
  
 result = do_it(); 
  
 if (result == 5) 
  
  
 printf(""It 
 worked\n"");
  
  
 The second form not only avoids the side effect, but it is simple and clear. The first form is 
 compact, but remember — your goals are readability and reliability.
  
  
 Unintentional assignments inside other statements can quickly cause trouble. Consider this 
 example.
  
 if (result = 5) 
  
  
 printf(""It 
 worked\n"");
  
 This fragment should print “It worked” only when result is 5. But the code contains a bug. 
 What it actually does is to assign 5 to result, check against (humm... no, 5 is not 0 this time) and 
 print unconditionally.",NA
When to use two statements per line,"Although there is a rule — one statement per line — don't be fanatical about it. The purpose 
 of the rule is to make the program clear and easy to understand. In some cases, putting two or 
 more statements on one line improves clarity. For example, consider the following code:
  
 /* Not as clear as it can be */
  
 token[Ol.word = ""if""; 
  
 token[Ol.value = 
 TOKEN_IF;
  
 token[l].word = ""while""; 
  
 token[l].value = 
 TOKEN_WHILE;
  
 token[2].word = ""switch""; 
  
 token[2].value = 
 TOKEN_SWITCH;
  
 token[3].word = ""case""; 
  
 token[3].value = TOKEN_CASE;
  
 This can easily be rewritten as:
  
 /* Clearer */ 
  
 token[O].word = ""if""; 
  
 token[O].value = TOKEN_IF; 
 token[l].word = ""while""; 
  
 token[l].value = TOKEN_WHILE; 
 token[2].word = ""switch""; token[2].value = 
 TOKEN_SWITCH; token[3].word = ""case""; 
  
 token[3].value 
 = TOKEN_CASE;
  
 There is a pattern to this code. The first example obscures the pattern. You can still see it, but 
 it's not as clear as in the second case, which is coded in two statement per line. To make the pat-
 tern clearer, the statements are organized in columns.",NA
Logic and Indentation,"Over the years many people have tried to develop a way to create a document makes the 
 logic and execution flow of a program easy to understand.
  
 Flowcharts were an early attempt. They presented the program visually using special 
 symbols to denote things like branch statements, input/output, termination. Figure 4-1 on the 
 following page shows a sample flowchart. charts were excellent for small programs, but for 
 programs of nominal size grew too big and bulky. (I remember seeing one that consisted of 
 hundred boxes spread across a 6x5 foot grid of 11x13 inch paper. It took up whole wall of a 
 conference room.
  
 Although it was impressive, no one could understand the whole thing.)
  
 Another problem with early flowcharts was that at the time very I computers could do graph-
 ics. (Most couldn't even do lowercase text.) result, all flow charts had to be done by hand, and 
 redone if the program changed.
  
 c04.doc
  
 - 57 -
  
  Modified: January 9, 1999 12:16 am",NA
Indentation styles,"There are many different styles of indentation, and a vast religious war being waged in the 
 programming community as to which is best. I won't t take sides, but I will present the 
 advantages and disadvantages of each style (Incidentally, the style used throughout this book is 
 the Short Form, chosen only because I’m used to it.)",NA
Short form,"In the Short Form, the open brace ({) is put at the end of a line. The text within the braces is 
 indented one level. The close brace (}) is aligned with the beginning of the corresponding state-
 ment.
  
 Example:
  
 c04.doc
  
 - 59 -
  
  Modified: January 9, 1999 12:16 am",NA
Braces stand alone.,"In the Braces Stand Alone method, all braces are placed on separate lines:
  
 /* Braces stand alone */ 
  
 while (! done) 
  
 { 
  
  
 printf(""Processing\n""); 
  
  
 next_entry(); 
  
 } 
  
 if (total <= 0) 
  
 { 
  
  
 printf(""You owe nothing\n""); 
  
  
 total = 0; 
  
 } 
  
 else 
  
 { 
  
  
 printf(""You owe %d dollars\n"", 
 total); 
  
  
 all_totals = all_totals + total; 
  
 } 
  
 if (total > 1000) 
  
  
 printf(“You owe a lot\n”);
  
  
 The advantage of this is that the braces are aligned. The disadvantage is that it takes up more 
 vertical space and tends to spread out the code.
  
 c04.doc
  
 - 60 -
  
  Modified: January 9, 1999 12:16 am",NA
Braces indented too.,"This variation on the Braces Stand Alone method indents not only the statement within the 
 braces, but also the braces themselves:
  
 /* Braces stand alone */ 
  
 while (! done) 
  
  
 { 
  
  
 printf(""Processing\n""); 
  
  
 next_entry(); 
  
  
 } 
  
 if (total <= 0) 
  
  
 { 
  
  
 printf(""You owe nothing\n""); 
  
  
 total = 0; 
  
  
 } 
  
 else 
  
  
 { 
  
  
 printf(""You owe %d dollars\n"", 
 total); 
  
  
 all_totals = all_totals + total; 
  
  
 } 
  
 if (total > 1000) 
  
  
 printf(“You owe a lot\n”);
  
  
 This form of indentation is not as common as the other two. It also has the problem of 
 spacing out the code somewhat.",NA
Variations.,"One variation on the standard indentation styles concerns if statements that affect a single 
 line. For example:
  
 if (total > 1000) 
  
  
 printf(""You owe a 
 lot\n"");
  
 This style of indentation can create confusion, as illustrated by the following
  
 example:
  
 /* Problem code */ 
  
 if (index < 0) 
  
  
 fprintf(stderr,""Error: Index out of 
 range\n""); 
  
 exit (8);
  
 At first glance, it looks like the program will print an error message only if
  index
  is out of 
 range. (That's what the programmer intended.) But on closer inspection, you'll notice that there 
 are no braces enclosing the two statements under the if. In fact, the code is indented incorrectly.",NA
How much to indent,"In this book I indent four spaces for each logic level. Why four? Here are some examples of 
 various indentations.
  
 c04.doc
  
 - 62 -
  
  Modified: January 9, 1999 12:16 am",NA
Two Spaces:,"/* Short form indentation */ 
  
  
 while (! done) { 
  
  
  
 printf(“Processing\n”); 
  
  
  
 next_entry(); 
  
  
 } 
  
  
 if (total <= 0) { 
  
  
  
 printf(""You owe nothing\n""); 
  
  
  
 total = 0; 
  
  
 } else { 
  
  
  
 printf(""You owe %d dollars\n"", 
 total); 
   
 all_totals = all_totals + total; 
  
  
 } 
  
  
  
 if (total > 1000) 
  
  
  
  
 printf(""You owe a lot\n"");",NA
Four Spaces:,"/* Short form indentation */ 
  
 while (! done) { 
  
  
 printf(“Processing\n”); 
  
  
 next_entry(); 
  
 } 
  
 if (total <= 0) { 
  
  
 printf(""You owe nothing\n""); 
  
  
 total = 0; 
  
 } else { 
  
  
 printf(""You owe %d dollars\n"", 
 total); 
  
  
 all_totals = all_totals + total; 
  
 } 
  
  
 if (total > 1000)",NA
Eight Spaces:,"printf(""You owe a lot\n"");
  
 /* Short form indentation */ 
  
 while (! done) { 
  
 printf(“Processing\n”); 
  
 next_entry(); 
  
 } 
  
 if (total <= 0) { 
  
 printf(""You owe nothing\n""); 
  
 total = 0; 
  
 } else {
  
 c04.doc
  
 - 63 -
  
  Modified: January 9, 1999 12:16 am",NA
Chapter 5: Statement Details,"Statements are basic building blocks of a C program, very much as sentences are basic build-
 ing blocks of English writing. C provides programmers with a rich set of operations, allowing 
 them to easily construct complex and powerful statements. This power must be used judiciously, 
 however. It is far too easy to create complex, unreadable, sometimes indecipherable and unreli-
 able C code. The rules discussed this chapter will help you create simple, readable, reliable code.",NA
Doing Nothing,"One of the most overlooked statements is the “do nothing”, or null, statement. The syntax for 
 this statement is extremely simple:
  
 Because it's so tiny, the null statement can easily be missed. For example, the code:
  
 for (i = 0; string[i] != 'x'; ++i);
  
  
 actually contains two statements: a for statement and a null statement. Most people must look 
 closely at this code to find the null statement.
  
 That's bad style. The structure of a well-constructed program is obvious; it does not require 
 close inspection. We need to do something to the null statement to make it obvious, and 
 comment lines easily provide the answer:
  
 /* Do nothing */;
  
 Now the code fragment looks like this:
  
 for (i = 0; string[i] != 'x'; ++i)
  
 /* Do nothing */;
  
 With this construction, it is obvious that there are two statements.
  
 Rule 5-1:
  
 Always put a comment in the null statement, even if it is only
  
 /* Do Nothing */;",NA
Arithmetic Statements,"C provides the programmer with a rich set of operators. There are 15 precedence rules in C 
 (
 &&
  comes before
  ||
 , etc.). For example, in this statement:
  
 result = 1 << 5 + 1;
  
  
 does the compiler perform the << or the + first? In other words, is the statement equivalent to 
 this:
  
 result = (1 << 5) + 1;
  
 or to this:
  
 result = 1 << (5 + 1);
  
 it turns out that
  +
  comes before
  <<
 , so the second version is correct.
  
 c05.doc
  
 - 66 -
  
  Modified: January 9, 1999 12:10 am",NA
Function Headings,"All C code is contained in functions. The function heading defines its return type and the 
 parameters.
  
 Example:
  
 float average(float total, int n_items)
  
  
 There are actually two styles of function declarations. Throughout this book I've been using 
 the newer ANSI-C style. Older compilers allow only the traditional K&R style:
  
 float average(total, n_items)
  
 float total;
  
 int n_items;
  
 The ANSI-C style is preferred because it is more modem, less error prone, and compatible 
 with C++. Reserve the use of the K&R style for old compilers that don't allow ANSI style decla-
 rations.
  
 Rule 5-3:
  
 Use ANSI style function declarations whenever possible.",NA
K&R style parameters,"Some of the older C compilers force you to use K&R style parameters. This format does not 
 allow types in the function declaration. The types immediately follow the function declaration.
  
 int total(values, n_values)
  
 int values[];
  
 int n_values;
  
  
 Strictly speaking, the declaration
  int n_values
  is redundant. The type of all parameters 
 defaults to
  int
 . So you could have written this function as:
  
 c05.doc
  
 - 67 -
  
  Modified: January 9, 1999 12:10 am",NA
Return type,"In C, defining the function type is optional. If the type is not specified defaults to
  int.
  For 
 example:
  
 int do_it(void);
  
 and
  
 do_it(void);
  
 are equivalent in C. However, they are not the same to the programmer because I second 
 form is ambiguous. There can be two reasons for not specifying a function type: the return type 
 really should be
  int,
  or the programmer forgot to define correct return type.
  
  
 The explicit declaration of an
  int
  function type tells the reader of the program, “Yes, this 
 func-tion really does return an
  int.
 ”
  
 Rule 5-6:
  
 Always declare a function type
  
 It is possible to have an integer function that doesn't return anything. For example",NA
Number of parameters,"In theory, functions can have any number of parameters. In practice, not quite true. That's 
 because while the compilers may be able to han function with 100 parameters, programmers can-
 not.
  
 Long parameter lists remind me of a passage from the UNIX mag tape manual page: 
 “Devices /dev/rmt0, /dev/rmt4, /dev/rmt8, /dev/nrmt0, /dev /dev/nrmt8 are the rewinding low 
 density, rewinding medium density, rewinding high density, non-rewinding low density, non-
 rewinding medium density, non-rewinding high density devices, respectively.” The problem with 
 long list that you tend to lose track of things.
  
  
 What's the device name of the “non-rewinding medium density” tape Try to figure it out 
 with-out counting on your fingers
 .
  
 c05.doc
  
 - 69 -
  
  Modified: January 9, 1999 12:10 am",NA
Passing parameters in globals,"Another way of passing parameters to and from a function is to not use parameters at all. 
 Instead, values are passed through global variables. For example, consider the following 
 function:
  
 /********************************************************
  
 * GetTocken - read the next token 
 * 
  
 * Globals used
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
 *
  
 in_file -- file to get token from
  
 *
  
 token -- the token we just got
  
 *
  
 error -- 0 = no error
  
 *
  
 non-zero = error code
  
 ********************************************************/
  
 There are many problems with this type of parameter passing. First, obscures the interface 
 between the function and the outside world. What's type of token? You can't tell. Also, suppose 
 you want to handle multiple files Then your main code must keep reassigning in-file so that it 
 points to what file you are using. For example:
  
 in_file = main_file
  
 GetToken();
  
 main_token = token;
  
 in_file = include_file;
  
 GetToken();
  
 include_token = token;
  
 It's much easier to write:
  
 c05.doc
  
 - 72 -
  
  Modified: January 9, 1999 12:10 am",NA
XView style parameter passing,"XView programming uses a nearly unique parameter passing style. (It shares this style with 
 the Suntools system from Sun.) For example, the function
  XvSet
  is defined as:
  
 XvSet(handle, 
  
 item, [value], [value], [value], 
 .... 
  
 item, [value], [value], [value], 
 ....
  
 NULL);
  
  
 The unique feature of this calling sequence is the use of variable parameter lists. “Item” is a 
 XView attribute. The number of parameters that follow arc defined by the attribute.
  
 For example, a typical XvSet function looks like this:
  
 XvSet(popup, 
  
  
 PANEL_CHOICE_NROWS, 
 5, 
  
  
 PANEL_CHOICE_STRINGS, 
  
  
 ""Start"", 
  
  
 ""Run"", 
  
  
 ""Abort"", 
  
  
 ""Pause"", 
  
  
 ""Continue"", 
  
  
 NULL, 
  
  
 NULL);
  
  
 The 
  
 parameter 
  
 PANEL_CHOICE_NROWS 
 is 
  
 followed 
  
 by 
  
 a 
  
 single 
  
 number, 
  
 and 
 PANEL_CHOICE_STRINGS
  is followed by a list of names. This list is terminated by a
  
 NULL
 . The entire parameter list is terminated by a
  NULL
 .
  
  
 Programmers at Sun went to a lot of work devising this parameter-passing mechanism. It's 
 too bad they came up with something so poor. There are many problems with this style.
  
 First, since the parameter list is variable length and the types of the variables are not fixed, it 
 is impossible to check the type and number of parameters. This defeats any type-checking built 
 into C or
  lint
 .",NA
The if Statement,"The
  if/else
  statement presents the programmer with some special problems. The first is ambi-
 guity. There is a small “hole” in the syntax, as illustrated in the following example:
  
 if (a) 
  
  
  
 if (b) 
  
  
  
  
 printf(""First\n""); 
  
  
 else /* Indentation is off 
 */ 
  
  
  
 printf(""Second\n"");
  
 The question is, which if does the else go with?
  
 A) 
  
 B) 
  
 C)
  
 It goes with
  if (a) 
  
 It goes with
  if (b) 
  
 The answer doesn't matter if I don't write code like this.",NA
if/else chains,"Frequently programmers need to implement a decision tree. This usually results in a chain of 
 if/else
  statements. Using our current indentation rules, this results in code that looks like this:
  
 if (code == ALPHA) { 
  
  
 do_alpha(); 
  
 } else { 
  
  
 if (code == BETA) { 
  
  
 do_beta(); 
  
  
 }else { 
  
  
 if (code ==GAMMA) { 
  
  
  
  
 do_gamma(); 
  
  
 } else { 
  
  
  
  
 do_error(); 
  
 }
  
  
 This format adds needless complexity to your program, but how do you simplify it? The 
 solu-tion is to treat the word pair
  else if
  as a single keyword.
  
 Rewriting the code using this rule results in this:
  
 if (code == ALPHA) { 
  
  
  
 do_alpha(); 
  
 } else if (code == BETA) 
 { 
  
  
  
 do_beta(); 
  
 }else if (code ==GAMMA) { 
  
 do_gamma(); 
  
 } else 
  
  
  
 do_error();
  
 This is at once simpler and easier to understand.
  
 c05.doc
  
 - 75 -
  
  Modified: January 9, 1999 12:10 am",NA
if and the comma operator ,"The comma operator is used to combine statements. For example, the statements: 
  
  
  
 x = 1; 
  
  
  
 y = 2; 
  
  
 are treated as a single statement when written as: 
  
  
  
 x = 1, y = 1; 
  
  
 With simple statements, the comma operator is not very useful. However it can be used in 
 con-junction with
  if
  to provide the programmer with a unique shorthand.
  
  
  
 if (flag) 
  
  
  
  
 x =1, y = 1; 
  
  
 This example is syntactically equivalent to: 
  
  
  
 if (flag) { 
  
  
  
  
  
 x = 1; 
  
  
  
  
  
 y = 1; 
  
  
  
 } 
  
  
 The problem with the comma operator is that when you use it you break the rule of one state-
 ment per line, which obscures the structure of the program.
  
 Rule 5-13: 
  
  
 Never use the comma operator when you can use braces instead.",NA
The while Statement ,"Sometimes you want to have a loop go on forever (or until you hit a
  break).
  There are two 
 common ways of specifying an infinite loop.
  
  
  
 while (1) 
  
  
 and 
  
  
  
 for (;;) 
  
  
 The first (
 while
 ) is preferred because it is more obvious and causes I confusion than 
 for(;;)
 . The
  while
  statement gives the programmer a simple looping mechanism, and 
 because it is so simple there are not a lot of style rule go with it.
  
 Rule 5-14: 
  
  
 When looping forever, use
  while (1)
  instead of
  
 for(;;)
 .
  
 c05.doc
  
 - 76 -
  
  Modified: January 9, 1999 12:10 am",NA
The do/while Statement,"The
  do/while
  statement is rarely seen in practical C programs. That s because it's redundant-
 there's nothing that you can do with a
  do/while
  that can't be done with
  while
  and
  break
 .
  
  
 Because it is so rare, many programmers are surprised when they see it. Some don't even 
 know what to do with it. For these reasons, it is better to simply not use it.
  
 Rule 5-15:
  
 Avoid using
  do/while
 .
  Use
  while
  and
  break
  instead.",NA
The for Statement,"There are two common problems with use of the
  for
  statement. They can have too little con-
 tent, or too much.",NA
Missing parts of for loops,"The
  for
  statement is actually three statements in one. Sometimes all three parts are not 
 needed, so one or more is left blank:",NA
Overstuffed for loops,"So far we've discussed what happens when you put too little information for loop. It's also 
 possible to put in too much. As mentioned before, the c operator can be used to combine state-
 ments in an
  if.
  This also works for statement. For example, the statement:
  
 for (two = 2, three = 3, two < 50; two +=2, three += 3)
  
  
 is perfectly legal. This statement causes the variable two to increment by 2 and the variable 
 three
  to increment by 3, all in one loop.
  
 The notation is complex and confusing. However spreading out the loop clarifies the logic:
  
 two = 2; 
  
 three = 3; 
  
 while (two < 50) {
  
  
 /*.... */ 
  
  
 two += 2; 
  
  
 three += 
 3; 
  
 }
  
  
 You'll note that we have also changed the
  for
  loop to a
  while.
  It could be I as a
  for,
  but here 
 the 
 while
  shows the structure of the code more clearly.
  
  
 Stringing together two statements using the comma operator is sometimes useful in a
  for
  
 loop, but such cases are rare.",NA
The printf Statement,"The
  printf
  function and its cousins are used for outputting the data. The function can be used 
 to print one or more lines. For example:
  
 printf(""Beginning = %d\ncurrent = %d\n End=%d\n"",
  
 beginning, current, end);
  
  
 Although compact, this obscures what is being output. You are writing three lines, so why 
 not use three
  printf
  statements?
  
 printf(""Beginning = %d\n"", beginning);
  
 printf(“Current = %d\n"", current);
  
 printf(""End = %d\n"", end);
  
 Using this style, You can easily see the structure of the output.
  
 Rule 5-17:
  
 Use one printf per line of output.
  
 Some people might argue that it take more time to do things this way since there are three 
 function calls instead of one. The
  printf
  function is relatively slow. The amount of overhead in a 
 function call takes 1/1000 of the time it takes to execute even a simple
  printf,
  so the overhead of 
 the two extra calls in negligible.
  
 Another problem occurs with the use of the
  printf, puts,
  and
  putc
  function, If you always use 
 printf
 , you have consistency. If you use a mixture of
  printf,
  and
  putc,
  then you increase 
 efficiency at the expense of consistency.
  
 For example:
  
 c05.doc
  
 - 79 -
  
  Modified: January 9, 1999 12:10 am",NA
goto and Labels,"Good programmers avoid the
  goto
  statement because it breaks the structure of the program. 
 But every once in a while, even the best programmer needs to use a
  goto
 .
  
 The
  goto
  label doesn't fit anywhere in the indentation rules. It's not part of the regular struc-
 ture, so in order to give it a home, make it stand out, and generally get out of the way, put it up 
 against the left margin.
  
  
 for (x = 0; x < 10; ++x) { 
  
  
 for (y = 0; y < 10; ++y) { 
  
  
  
  
 if (data[x][y] == look_for) 
 { 
  
  
  
  
 goto found_it; 
  
  
  
  
 } 
  
  
 } 
  
  
 } 
  
 found_it:
  
 Rule 5-19:
  
 Start
  goto
  labels in the first column.",NA
The switch Statement,"The
  switch
  statement is the most complex statement in C. It allows the programmer to per-
 form a complex branching operation with a single statement, but sometimes it can be confusing.",NA
Debug Printing,"In spite of all the interactive debuggers, there are still times a programmer needs to use a 
 debugging
  printf.
  The problem is how to separate the debugging output from the real stuff. One 
 trick is to begin all debug printouts with “##”:
  
 printf(""## state = %d\n"", state);
  
 This not only makes it easy to identify the debug statements in the log, it also makes it easy 
 to remove them after the program is debugged. All you have to do is search for each line 
 containing“##” and delete it.",NA
Shut up Statements,"Always compile your programs will all possible warning enabled. If you are running under 
 UNIX, run your program through the program lint. You want the compiler to find as many 
 poten-tial problems in your code as possible, so you don't have to do it in the debugging stage.
  
 Sometimes you get warning about things you know about. For example, you might define a 
 variable copyright and never use it. Sometimes the compiler or
  lint
  will allow you to turn off a 
 warning for a single statement or variable. But sometimes it won't.
  
  
 For example, there is no way to turn off the “Variable defined but not used” message in the 
 Borland C compiler for a single variable. It's either the whole program or nothing.
  
 c05.doc
  
 - 84 -
  
  Modified: January 9, 1999 12:10 am",NA
Chapter 6: Preprocessor ,"The C preprocessor provides many additional features not found in the language itself. You 
 can use these to create constants, to include data from other files, to shoot yourself in the foot.
  
 Problems with preprocessors are difficult to spot because they are not obvious Even the com-
 piler may misreport preprocessor errors. For example, the following program generates an error 
 on Line 5 when the problem is really a bad
  #define
  statement on Line 1.
  
 1 #define VALUE_MAX 300 ++ 5 
  
 /* Problem is here */ 
 2 
  
 3 void check(int value) 
  
 4 { 
  
 5 
  
 if (value > VALUE_MAX) { 
  
 6 
  
  
  
 printf(""Value %d is out of range\n"", value); 7 
  
 abort(); 
  
 8 
  
 } 
  
 9 }
  
 Good style is the best defense against preprocessor efforts. It is extreme important. By reli-
 giously following the rules discussed here, you can catch errors before they happen.
 1",NA
Simple Define Statements,"One of the uses of the
  #define
  statement is to define simple constant format is this:
  
 #define SYMBOL value     /* comment */
  
  
 The
  SYMBOL
  is any valid C symbol name (by convention,
  #define
  names are all uppercase). 
 The
  value
  can be a simple number or an expression.
  
  
 Like variable declarations, a constant declaration needs a comment explains it. This comment 
 helps create a dictionary of constants.
  
 Some examples:
  
 /* Max number of symbols in a procedure 
 */ 
  
 #define SYMBOL_MAX 500
  
 /* The longest name handled by this system 
 */ #define NAME_LENGTH 50
  
 Rule 6-1:
  
 #define
  constants are declared like variables. Always put a comment describes the con-
 stant after each declaration.
  
 1. Religion, noun. Something a programmer gets after working until two in the morning only find a bug that 
 wouldn't have been there had he or she religiously followed the rules.",NA
Constant expressions,"If the
  value
  of a
  #define
  statement is a compound expression, you can run problems. The fol-
 lowing code looks correct, but it hides a fatal flaw.
  
 /* Length of the object (inches) (partl=10, part2=20) 
 */ #define LENGTH 10 + 20 /* Bad practice */
  
 #define WIDTH 30
  
  /* Width of table (in inches) */
  
 /*..... */ 
  
 /* Prints out an incorrect width */ 
  
 printf(""The area is %d\n"", LENGTH * 
 WIDTH);
  
 Expanding the
  printf
  line, you get:
  
 printf(""The area is %d\n"", LENGTH * WIDTH); 
 printf(""The area is %d\n"", 10 + 20 * WIDTH); 
 printf(""The area is %d\n"", 10 + 20 * 30);
  
  
 This another example of how the C preprocessor can hide problems. Clearly
  LENGTH
  is 10
  
 +
  20, which is 30.
  S
 o
  LENGTH
  is 30, right? Wrong.
  LENGTH
  literally
  10 + 20
 , and:
  
 10 + 20 * 30
  
 is vastly different from:
  
 30 * 30
  
  
 To avoid problems like this, always surround all
  #define
  expressions with parenthesis (
  ()
  
 ). Thus, the statement:
  
 /*
  Length of the object (inches) (partl=10, part2=20) */ 
 #define LENGTH 10 + 20 
  
 /* Bad Practice */
  
 Becomes:
  
 /*
  Length of the object (inches) (partl=10, part2=20) */ 
 #define LENGTH (10 + 20) 
  
 /* Good Practice */
  
 Rule 6-3:
  
 If the value of a constant is anything other than a single number, enclose it in parentheses.",NA
#define constants vs. consts,"In ANSI C constants can be defined two ways: through the
  #define
  statement and through 
 use of the
  const
  modifier. For example, the following two statement, are equivalent:
  
 c06.doc
  
 - 88 -
  
  Modified: January 9, 1999 12:15 am",NA
#define vs. typedef,"The
  #define
  directive can be used to define types, such as:
  
 #define INT32 long int /* 32 bit signed integer type */
  
 The
  typedef
  clause can be used in a similar manner.
  
 typedef long int int32; /* 32 bit signed integer */
  
  
 The typedef is preferred over the
  #define
  because is better integrated into the C language, 
 and it can create more kinds of variable types than a mere define.
  
 Consider the following:
  
 #define INT_PTR int 
  
 /* Define a pointer to integer */
  
 typedef int *int_ptr; 
  
 /* Define a pointer to an integer */
  
 INT_PTR ptr1, ptr2; 
  
 /* This contains a subtle problem */
  
 int_ptr ptr3, ptr4; 
  
 /* This does not */
  
  
 What's the problem with the line
  INT_PTR ptr1, ptr2
 ?
  The problem is that
  ptr2
  of 
 type integer, not a pointer to integer. If you expand this line, the problem, comes apparent:
  
 c06.doc
  
 - 89 -
  
  Modified: January 9, 1999 12:15 am",NA
Abuse of #define directives,"It is possible to use #define directives for things other than constants. For example, the macro:
  
 #define FOR_EACH_ITEM for (i = first; i < last; ++i)
  
 can define a standard for loop. This can be used in place of a regular for.
  
 FOR_EACH_ITEM 
  
  
 process_item(i)
 ;
  
 You can even go so far as to create macros that make your C code look like Pascal.
  
 #define BEGIN 
 I 
  
 #define END I
  
 /*...    */ 
  
 if (x == Y) 
  
  
 BEGIN 
  
  
  
 / *...   * 
 / 
  
  
 END;
  
  
 The problem with this approach is that you are obscuring the C language itself. The mainte-
 nance programmer who comes after you will know C, not a half-Pascal half-C mongrel.
  
 Even the simple
  FOR_EACH_ITEM
  macro hides vital C code. Someone else reading the 
 pro-gram would have to go back to the definition of
  FOR_EACH_ITEM
  to figure out what the 
 code does. By using the code instead of a macro, no lookup is necessary,
  
 You can easily understand the C code that goes into this:
  
 for (i - first; i < last; 
 ++i) 
  
  
 process_item(i);
  
 Rule 6-6:
  
 Don't use
  #define
  to define new language elements.",NA
Keywords and standard functions,"Defining new language elements is one problem. A far more difficult problem occurs when a 
 programmer redefines existing keywords or standard routines. For example, in one program, the 
 author decided to create a safer version of the string copy routine:",NA
Parameterized Macros,"The
  #define
  may have arguments. For example, the following macro doubles a number:
  
 /* Double a number */
  
 #define DOUBLE_IT(number) (2 * (number))
  
  
 Enclosing the entire macro in parenthesis avoids a lot of trouble similar to the problems with 
 simple
  #define
 s.
  
 Rule 6-8:
  
 Enclose parameterized macros in parentheses.
  
 In the next example, the macro
  SQUARE
  is supposed to square a number:
  
 /* Square a number */
  
 #define SQUARE(X) (x * x)
  
 /* Bad practice, no () around parameter */
  
 The invocation of the macro:
  
 a = SQUARE(1 + 3);
  
 expands to:
  
 a = (1 + 3 * 1 + 3);
  
 which is not what was expected. If the macro is defined as:
  
 c06.doc
  
 - 91 -
  
  Modified: January 9, 1999 12:15 am",NA
Multi-line Macros,"The
  #define
  statement can be used to define code as well as constants. For example:
  
 /* Print current values of registers (for debugging) */ 
 #define PRINT_REGS printf(“Registers AX=%x BX=%x\n”, 
 AX,BX);
  
 This is fine as long as the target of the
  #define
  is a single C statement. Problems occur when 
 multiple statements are defined. The following example defines a macro
  ABORT
  that will print a 
 message and exit the system. But it doesn’t work when put inside an
  if
  statement.
  
 /* Fatal error found, get out of here 
 */ 
  
 #define ABORT print(“Abort\n”); 
 exit(8);
  
 /*....   */ 
  
 if (value > 
 LIM) 
  
  
 ABORT;
  
 problem can easily be seen when we expand the macro:
  
 if (value > LIM) 
  
  
 printf(“Abort\n”); 
 exit(8);
  
 Properly indented, this is:
  
 if (value > LIM) 
  
  
 printf(“Abort\n”)
 ; 
  
 exit(8);
  
  
 This is obviously not what the programmer intended. A solution is to enclose multiple state-
 ments in braces.
  
 /* Fatal error found, get out of here */ 
  
 #define ABORT { printf(""Abort\n""); exit(8); 
 ) 
  
 /* Better, but not good */
  
 This allows you to use the ABORT macro in an
  if,
  like this:",NA
Macros and Subroutines,"Complex macros can easily resemble subroutines. It is entirely possible to create a macro that 
 looks and codes exactly like a subroutine. The standard functions
  getc
  and
  getchar
  are 
 actu-ally not functions at all, but macros. These types of macros frequently use lower-case 
 names, copying the function-naming convention.
  
  
 If a macro mimics a subroutine, it should be documented as a function. That involves putting 
 a function-type comment block at the head of the macro:
  
 /********************************************************
  
 * next_char -- move a buffer pointer up one 
 char * 
  
 * Parameters
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
  
 *
  
 *
  
 ch_ptr -- pointer to the current character
  
 * 
  
 * 
 Returns
  
 *
  
 pointer to the next character or NULL if none.
  
  
 ********************************************************
 / #define next_char(ch_ptr) \ 
  
   
 /* ... definition ... */
  
 Rule 6-13:
  
 Always comment any parameterized macros that look like functions.
  
 c06.doc
  
 - 94 -
  
  Modified: January 9, 1999 12:15 am",NA
The #include Directive,"Include files are used to define data structures, constants, and function prototypes for items 
 used by multiple modules. it is possible to put code in an include file, but this is rarely done.",NA
Style for #Includes,",Most programs put the
  #include
  directives in a group just after the heading comments. That 
 way they are all together in a known place. System includes are enclosed in <>) come first, fol-
 lowed by any local includes (enclosed in
  """"
 ).
  
 Example:
  
 /********************************************************
  
 *
  
 ... heading comments ....
  
 *
  
 ********************************************************
 / /* System includes */ 
  
 #include <stdio.h> 
  
 #include <alloc.h> 
  
 #include <string.h>
  
 /* Local includes 
 */ 
  
 #include ""key.h"" 
  
 #include ""table.h"" 
  
 #include ""blank.h""
  
 Rule 6-14:
  
 #include
  directives come just after the heading comments. Put system includes first, fol-
 lowed by local includes.
  
 #include
  directives that use absolute file names, that is specify path and name, such as
  /user/ 
 sam/program/data.h
  and
  Y:\DEVELOP\PROGRAM\DEFS.H
  make your program non-portable. 
 If the program is moved to another machine, even one using the same operating system, the 
 source will have to be changed.
  
 The solution is to never use absolute paths. The compiler can be pointed to the correct direc-
 tory by using the
  -I
  option. That way you need to change only one Makefile instead of a bunch 
 of source files.
  
 /* Non portable */ 
  
 #include 
 “/user/sam/program/data.h”
  
 /* Portable, compile with “-I/user/sam/program” 
 */ #include “data.h”
  
 Rule 6-15:
  
 Do not use absolute paths in
  #include
  directives. Let the -I compile opt",NA
Protecting against double #Includes,"Include files can contain
  #include
  directives. This means that you can easily include the 
 same file twice. For example, suppose
  database.h
  and
  symbol.h
  both need the file
  defs.h
 . Then, 
 putting these lines:
  
 #include “database.h”
  
 #include “symbol.h”
  
 in your program brings in two copies of
  defs.h.
  Defining a structure or type twice can cause 
 errors. So how do you avoid this problem? The solution is t conditional compilation to prevent 
 the double include from causing trouble.
  
 #ifndef _DEFS_H_INCLUDED_
  
 #define _DEFS_H_INCLUDED_
  
 And at the end, insert this line:
  
 #endif /* _DEFS_H_INCLUDED_ */
  
 The first time through, _
 DEFS_H_INCLUDED
 _ is not defined.
  
 The
  #ifndef
  causes the entire body of the file to be included and
  _DEFS_H_INCLUDED_
  to 
 be defined. Therefore, when the file is include the
  #ifndef
  kicks in, and the entire body of the file 
 is now
  #ifdef
 'ed out.",NA
Conditional Compilation,"The preprocessor allows you conditionally to compile sections o through the use of
  #ifdef
 , 
 #else
 , and
  #endif
  directives.
  
 For example:
  
 #ifdef DOS
  
 #define NAME ""C:\ETC\DATA”
  
 #else /* DOS */
  
 #define NAME ""/etc/data”
  
 #endif /* DOS */
  
 Actually, the
  #else
  and
  #endif
  directives take no arguments. The following them is entirely a 
 comment, but a necessary one. It serves to match
  #else
  and
  #endif
  directive with the initial
  
 #ifdef
 .
  
  
 Note:
  Some strict ANSI compilers don't allow symbols after
  #else
  or
  #endif
  directives. In 
 these cases, the comment DOS must be formally written as
  /* DOS */
 .
  
 Rule 6-16:
  
 Comment
  #else
  and
  #endif
  directives with the symbol used in the initial
  #ifdef
  or
  #endif
  
 directive.
  
 Use conditional compilation sparingly. It easily confuse the code.
  
 c06.doc
  
 - 96 -
  
  Modified: January 9, 1999 12:15 am",NA
Where to define the control symbols,"The control symbols for conditional compilation can be defined through
  #define
  statements 
 in the code or the -D compiler option.
  
 If the compiler option is used, the programmer must know how the program was compiled in 
 order to understand its function. If the control symbol is defined in the code, the programmer 
 needs no outside help. Therefore, avoid the compiler option as much as possible.
  
 Rule 6-18:
  
 Define (or undefine) conditional compilation control symbols in the code rather than 
 using the
  -D
  option to the compiler.",NA
Commenting out code,"Sometimes a programmer wants to get rid of a section of code. This may be because of an 
 unimplemented feature, or some other reason. One trick is to comment it out, but this can lead to 
 problems:
  
 /*-------Begin commented out section ------
  
 open_database(); 
  
 update_symbol_table();     /* Add our new symbols 
 */ close_database(); 
  
 /*-------End commented out section------*/
  
 Unless your compiler has been extended for nested comments, this code will not compile. 
 The commented-out section ends at the line
  /* Add our new symbols */,
  not at the bottom of the 
 exam-ple.
  
 Conditional compilation can accomplish the same thing, with much less hassle.
  
 #ifdef UNDEF 
  
 open_database(); 
  
 update_symbol_table();     /* Add our new symbols 
 */ close_database(); 
  
 #endif /* UNDEF */
  
  
 Note:
  This will not work if the programmer defines the symbol (However, any programmer 
 who defines this symbol should be shot.)
  
 Rule 6-20:
  
 Do not comment out code. Use conditional compilation (
 #ifdef UNDEF
 ) to get rid of 
 unwanted code.
  
  
 Sometimes the programmer wants to take out a section of code for a minutes for debugging. 
 This can be done in a similar way:
  
 c06.doc
  
 - 99 -
  
  Modified: January 9, 1999 12:15 am",NA
Chapter 7: Directory Organization and ,NA,NA
Makefile Style,"So far we've only discussed the C program itself. This chapter explores the programming 
 envi-ronment, which includes organizing your program files, and the
  make
  utility, which turns 
 source programs into a finished work.",NA
Organizing Your Directories,"Small programs consisting of only a few files are easy to organize: just stick everything in 
 one directory. But suppose you're an adventurous programmer and decide to write two programs. 
 Do you stick them both in the same directory? No.
  
 Put each program's files in a separate directory. That way you won't have to figure out which 
 file goes with which program. It also keeps the number of files per directory down to a manage-
 able level
  
 Rule 7-1:
  
 Whenever possible, put all the files for one program or library in one directory.
  
 Someday you will probably work on a series of programs, like a set of programs to manage a 
 mailing list. There are programs to enter data, check for duplicates, print labels, and generate 
 reports. All of these programs use a common set of low level list functions. You can't put each of 
 these functions in each program directory. Duplicate files are very difficult to maintain. You 
 need some way to share files.
  
  
 The solution is to turn the list functions into a library. The library goes in one subdirectory 
 while other subdirectories hold the various programs.
  
 Suppose you have all four programs all going to the Library directory for their subroutines. 
 But the Library directory contains both the source and the library file (
 MAIL.LIB)
  and headers 
 (
 MAIL.H
 ) used by these programs. Having access to all that data can easily confuse things. You 
 need to limit what they can see.
  
 The solution is to have a special directory for libraries and header files as illustrated by 
 Figure 4-2. When a library is built it is “released” by placing it in this directory. The header files 
 are put here as well. This directory contains the public part of the library, while the private part 
 stays behind in the source directory.
  
 c07.doc
  
 - 102 -
  
  Modified: January 9, 1999 12:17 am",NA
The make Program,"Almost all C compilers come with a program building utility called
  make.
  It is designed to 
 perform the compilation and other commands necessary to turn source files into a program.
  
  
 To use
  make,
  you provide it with a description of your program in a file named
  Makefile.
  
 This file also contains the transformation rules that tell it how to turn source into objects.
  
 The
  Makefile is
  divided into six major sections:
  
 1. 
  
 Heading comments
  
 2. 
  
 Macro definitions
  
 3. 
  
 Major targets
  
 4. 
  
 Other targets
  
 5. 
  
 Special compilation rules
  
 6. 
  
 Dependencies",NA
Heading Comments,"The first things a programmer needs to know when confronting a strange
  Makefile
  are “What 
 does it do?” and “How do I use it?” The heading comments of your
  Makefile
  should answer 
 those questions.
  
 The first paragraph of the heading comments explains what the
  Makefile
  creates. For 
 example:
  
 c07.doc
  
 - 103 -
  
  Modified: January 9, 1999 12:17 
 am",NA
Customization Information,"Programmers use the preprocessor
  #ifdef
  to allow for compile time configuration of their 
 pro-gram. For example, there might be a debug version and a production version. Or there might 
 be several different flavors, one for each of the various operating systems the program is 
 designed to run on.
  
 The effect of these conditional compilation directives filter up to the
  Makefile
 . For example, 
 defining the macro
  CFLAGS
  as
  -DDEBUG
  may produce a test program, while the definition
 -
 DPRODUCTION
  may produce the production version.
  
 Any configuration information should be listed in the heading comments. This way a pro-
 grammer can immediately see what customization must be performed on the
  Makefile
  before he 
 starts to build the program.
  
 For example:
  
 # 
  
 # Set the variable SYSTEM to the appropriate value for 
 your # operating system.
  
 #
  
 #
  
 SYSTEM=-DBSD4_3
  
 For Berkeley UNIX Ver. 4.3
  
 #
  
 SYSTEM=-DSYSV
  
 For AT&T System V UNIX
  
 #
  
 SYSTEM=-DSCO
  
 For SCO UNIX
  
 #
  
 SYSTEM=-DDOS
  
 For DOS (Borland Turbo C)
  
  
 #",NA
Standard targets,"The standard form of the
  make
  command is:
  
 make target
  
 Here,
  target
  selects what you want to make. (Microsoft's
  make is
  a notable exception to this 
 standard.) The programmer needs to know which targets are valid and what they do. Putting a list 
 of targets in the heading provides this information.
  
 For example:
  
 c07.doc
  
 - 104 -
  
  Modified: January 9, 1999 12:17 am",NA
Macro Definitions ,"The
  make
  utility allows the user to define simple text macros, such as:
  
 SAMPLE=sample.c
  
  
 The macros are used to define a variety of items, such as the source files to be compiled, the 
 compiler name, compilation flags, and other items.
  
 c07.doc
  
 - 105 -
  
  Modified: January 9, 1999 12:17 am",NA
Common macro definitions,"There are no standard macro definitions; however, the following is a list of the most common:
  
 CC 
  
 The C compiler
  
 CFLAGS 
  
 Flags supplied to the C compiler for compiling a single module.
  
 LDFLAGS 
  
 Flags supplied to the C compiler for loading all the objects into a single program.
  
 SRCS
  or
  SOURCES
  
 The list of source files.
  
 OBJS
  or
  OBJECTS
  
 The list of object files. Some of the newer versions of
  make
  have an extension that 
 allows you to automatically generate this macro from the
  SRCS
  macro. For exam-
 ple, the following line tells Sun's
  make
  that
  OBJS
  is the same as
  SRCS,
  except 
 change all the
  .c
  extensions to
  .o
 .
  
 0BJS = $(SRCS:.c=.o)
  
 HDRS
  or
  HEADER
  
 The list of header files.
  
 DESTDIR 
  
 The destination directory, where the
  install
  target puts the files.",NA
Configurable variables,"As mentioned earlier, macros are frequently used for configuration information. When it 
 comes to actually defining the variable, it is useful to list all the definitions and then comment all 
 but the selected one. For example:
  
 c07.doc
  
 - 106 -
  
  Modified: January 9, 1999 12:17 am",NA
Major Targets,"So far, we've just been defining things. At this point it's time to tell
  make
  to actually do 
 some-thing. This section contains the rules for all the major targets listed in the comment header. 
 These targets are grouped just after the macros so they can be easily located.
  
 For example:
  
 all: hello
  
 install: hello 
  
  
 install -c hello 
 /usr/local/bin
  
 clean: 
  
  
 rm -f 
 hello.o
  
 clobber: clean",NA
Other Targets,"Often a
  Makefile
  contains several intermediate or minor targets. These are to help build 
 things for the major targets. For example, the major target
  all
  calls upon the minor target
  hello.
  
 Minor targets follow the major ones.
  
 Example:
  
 hello: $(OBJECTS) 
  
 $(CC) $(CFLAGS) -o hello $(OBJECTS)",NA
Special Rules,"The
  make
  program knows about all or most standard compilers, such as the C compiler. 
 Sometimes you need to define a rule for a special compiler, such as the parser generator
  yacc
 . 
 This program takes grammars (
 y
  files) and turns them to C code
  
 The
  Makefile
  rule for this program is:",NA
Dependencies,"The dependencies section shows the relationship between each of the binary files and their 
 source. For example:
  
  
 hello.o: hello.c banner.h 
  
 tells
  make
  that hello.o is created from
  hello.c
  and
  banner.h.
  
 Dependency checking is the weakest point in the
  make
  command. Frequently this section is 
 out of date or missing entirely. Advanced
  make
  programs have an automatic dependency check-
 ing, thus eliminating the need for this section.
  
 Other solutions have also sprung up. The public domain utility
  maketd
  and other similar pro-
 grams automatically generate dependency lists. They all depend on this section being at the end 
 of the
  Makefile.",NA
Example,"The full
  Makefile
  for the
  hello
  program is:
  
 c07.doc
  
 - 108 -
  
  Modified: January 9, 1999 12:17 am",NA
Common Expressions,"Whenever possible, use macros for common directories or other text. For example:
  
 c07.doc
  
 - 110 -
  
  Modified: January 9, 1999 12:17 am",NA
Complexity,"Installing a program can be tricky. I've seen a shell script with more than 100 lines created 
 just to install a single program. There is a temptation to put long, complex command sets into the 
 Makefile.
  Because of the difficulties of both shell program and
  Makefile
  format, this results in a 
 large, complex, and impossible to maintain piece of code.",NA
Portability Considerations,"Makefile
 s have a standard format that is portable across most systems. However, compile 
 time options differ from system to system. For example, a program written to work on both 
 UNIX and DOS will require two entirely different commands sets to create it. Stuffing two sets 
 of compila-tion instructions in a single
  Makefile
  can get messy. When this happens, it is best to 
 create a sepa-rate
  Makefile
  for each system. The standard method for naming these various
  
 Makefiles
  is 
 <system>.mak.
  Some standard names are:
  
 bsd.mak 
  
 att.mak 
  
 sun.mak 
  
 turboc.mak 
 msc.mak 
  
 sco.mak
  
 BSD4.3 UNIX Makefile 
  
 AT&T System V 
  
 SUNOS UNIX system 
  
 DOS using Borland's Turbo C 
  
 DOS using Microsoft's C compiler 
 SCO UNIX
  
  
 This list can grow quite long as programs are ported to more and more systems. A
  read.me
  
 file must be distributed with the software to describe how to select the proper
  Makefile.",NA
Generic Makefiles,"Some of the more advanced
  make
  commands have an include facility that allows the 
 inclusion of other files in the
  Makefile.
  Some programmers have tried to create generic
  
 Makefile
 s
 ,
  to be used like this:
  
 #
  
 # Define some macro names to be
  
 # used by the generic Makefile
  
 #
  
 SRCS=hello.c
  
 OBJS=hello.o
  
 PROGRAM=hello
  
 include(Makefile.generic)
  
  
 In theory, this should work nicely. There is one generic
  Makefile
  that does everything, then 
 all you have to do is set things up properly.
  
 In practice, though, it's not so simple. Creating a program is never a standard process and far 
 too many have their little peculiarities. Trying to program around them in a generic
  Makefile
  is 
 extremely tricky.
  
 One approach is to create a generic
  Makefile
  to be used as a template for making custom 
 Makefiles
  The problem with this approach is that when you want to add a new target to every
  
 c07.doc
  
 - 112 -
  
  Modified: January 9, 1999 12:17 am",NA
Conclusion,"Makefile
 s are as important to the programming process as the program itself. A well designed 
 Makefile
  makes it easy to create a program. Comments are necessary to tell programmers the 
 vital information that lets them create future versions of your program
 .
  
 c07.doc
  
 - 113 -
  
  Modified: January 9, 1999 12:17 am",NA
Chapter 8: User-Friendly Programming,"So far we've discussed the use of style to make your code clear and easy to read. But style 
 doesn't stop at the printed page. A program is not only edited, debugged, and compiled; it is also 
 used. In this chapter we extend our discussion of style to include how the program appears when 
 it is in use.",NA
What Does User-Friendly Mean?,"As programmers, we encounter a large number of tools, utilities, and other programs. Some 
 are a joy to use, letting us get our work done with a minimum of fuss. Others are a nightmare, 
 with obscure and complex command sets.
  
  
 What is a user-friendly program? Simply a program that the user considers a friend instead of 
 an enemy.
  
 In the early days of computing, machines cost millions of dollars and programmers cost only 
 a few thousand. Companies could afford to keep several specialists around to translate 
 management requests into language the computer could understand.
  
 For the programmers, the early computers were very user-unfriendly. IBM's OS/360 required 
 the programmer to interface with it using a particularly brutal language called JCL. The com-
 mands were cryptic; for example, “copy” was “IEBGENER”, and specifying a file could easily 
 take up three to five lines of JCL code.
  
 Over the years, computers have dropped in price, and the cost of programmers has increased. 
 Low prices have meant that more and more people can buy computers. High salaries have meant 
 that fewer and fewer people can afford to pay a full-time programmer to run them.
  
  
 Software has had to evolve with the times, too. Programs have had to become easier to use in 
 order to accommodate newer, less computer-literate clients.
  
 Today, people with no computer training at all can go into Radio Shack, plunk down $1000 
 and walk out with a computer that is faster and more powerful than an early IBM that cost mil-
 lions of dollars.",NA
Law of Least Astonishment,"For years, people have tried to come up with a set of laws to define what is user-friendly and 
 what is not. Many of them involve complex standards and lots of rules; but the best law that I've 
 seen governing program design is the Law of Least Astonishment: the program should act in a 
 way that least astonishes the user.
  
 Rule 8-1:
  
 Law of Least Astonishment: The program should act in a way that least astonishes the
  
 user.
  
 c08.doc
  
 - 114 -
  
  Modified: January 9, 1999 12:12 am",NA
Modeling the User,"Computers intimidate many people. (Those who aren't intimidated tend to become program-
 mers.) Your first step in writing a user-friendly program is to put yourself in the shoes of the 
 user. What does a user want from the system?
  
  
 Always remember that users have a job to do. They want the computer to do that job their 
 way, with a minimum of effort.
  
 Almost all tasks done by computer were at one time done by hand. Before word processing, 
 there was the typewriter. Before databases, there was the card file. A good program should be 
 designed to emulate a manual task that the user knows. For example, a good word processor lets 
 the user treat it like a typewriter. True, it adds a great many features not found on a typewriter, 
 but at heart it still can be used like a typewriter.
  
 A good example of a program imitating a manual procedure occurred when a business school 
 graduate student was attending a financial analysis class. He noticed that the professor had a set 
 of figures arranged in a neat set of rows and columns on the blackboard. Every time the teacher 
 changed one number, he had to recalculate and write a new set of numbers.
  
 The student figured that a computer could perform the work automatically, so he invented 
 VisiCalc, the first spreadsheet program. Successful modeling brought this observant programmer 
 a million-dollar idea.",NA
Error Messages,"Sooner or later, every user makes a mistake. When that happens, an error message usually 
 appears. Writing a good error message is an art. Care and thought need to go into the creation of 
 these messages.
  
  
 Examples of poor error messages abound. I once ran a FORTRAN program and was 
 surprised to see the following message at the end of my run:
  
 JOB KILLED BY IEH240I
  
 So I consulted the book called Messages and Codes (aka The Joke Book), which was sup-
 posed to contain a complete list of errors, and it did—for all the codes except the IEH series, 
 which was in the FORTRAN manual. Going to the FORTRAN book, I discovered that IEH240I 
 meant “Job killed by fatal error.” Of course, I knew it was a fatal error the moment it killed my 
 job.
  
  
 It turns out that the program tried to do a divide by 0, which resulted in a “Divide by 0"" mes-
 sage followed by the IEH240I.
  
  
 Error messages should not be cryptic. The IEH240I code sent me on a wild goose chase 
 through two books, only to wind up where I started.
  
 You cannot expect the user to know computer terminology. For example, a message like this:
  
 FAT table full
  
 means nothing to most users. “What do I do? Put the computer on a diet?”
  
 c08.doc
  
 - 115 -
  
  Modified: January 9, 1999 12:12 am",NA
The Command Interface,"MS/DOS has a very strange command interface. It appears to be built out of bits and pieces 
 stolen from other operating systems, which results in a command language that is far from 
 consis-tent.
  
 c08.doc
  
 - 116 -
  
  Modified: January 9, 1999 12:12 am",NA
Help,"Early programs were designed to save disk and memory space, not to be user-friendly. It was 
 difficult to get more than code out of them, much less a help screen.
  
 As user-friendly programming has gained acceptance, help systems has improved as well. 
 Today there are help compilers to aid the programmer produce context-sensitive help screens. 
 The compiler also allows the programmer to embed cross-references in the text that let the user 
 jump immediately to a related subject. Finally, there is an index of all topics that the user can 
 search.
  
 Help compilers are available for Borland's compiler and Microsoft's Windows development 
 system. But even without a help compiler, every program needs to provide some help. More 
 com-plex programs need context-sensitive help. Far too often, help systems are not designed into 
 pro-grams from the start, but instead as “if we have time” projects. This makes programs very 
 unfriendly.",NA
Safety Nets,"Occasionally a user will try to do something that causes permanent damage and loss of data 
 to their system. A user-friendly program provides users with a safety net preventing them from 
 doing something stupid unless they really want to.
  
 For example, if the user tries to write over an existing file, the message:
  
 c08.doc
  
 - 117 -
  
  Modified: January 9, 1999 12:12 am",NA
Accelerators,"Some users eventually develop into power users. You know the type—they know every com-
 mand in the program, have an amazing set of tricks for getting around program limitations, and 
 can quote long passages from the reference manual.
  
 The user interface for the power user is different from that needed by the novice. Many pro-
 grams provide accelerator keys, which allow the user to perform common commands with a sin-
 gle keystroke. For example, to run a program in the Borland C compiler you must type Alt-R to 
 bring up the run menu, and then R to run the program. Power users can hit Control-F9.
  
 c08.doc
  
 - 118 -
  
  Modified: January 9, 1999 12:12 am",NA
Chapter 9: Rules ,NA,NA
Chapter 1:Style and Program Organization,"Rule 1-1: 
  
 Organize programs for readability, just as you would expect an author to 
 organize a book.
  
 Rule 1-2: 
  
 Divide each module up into a public part (what's needed to use the module) and a 
 private part (what's needed to get the job done). The public part goes into a .h file 
 while the private part goes into a .c file.
  
 Rule 1-3: 
  
  
 Use white space to break a function into paragraphs.
  
 Rule 1-4: 
  
  
 Put each statement on a line by itself
  
 Rule 1-5: 
  
  
 Avoid very long statements. Use multiple shorter statements instead.",NA
"Chapter 2:File Basics, Comments, and Program Headings","Rule 2-1: 
  
  
 Keep programs files to no longer than about 2,000 to 3,000 lines.
  
 Rule 2-2: 
  
  
 Keep all lines in your program files down to 72 characters or fewer.
  
 Rule 2-3: 
  
  
 Use 8-character tab stops.
  
 Rule 2-4: 
  
 Use only the 95 standard ASCII characters in your programs. Avoid exotic 
 charac-ters. (Foreign characters may be used if you are writing comments in a 
 foreign lan-guage.)
  
 Rule 2-5: 
  
  
 Include a heading comment at the beginning of each file that explains the file.
  
 styleRULE.fm
  
 - 119 -
  
  Modified: January 9, 1999 12:14 am",NA
Chapter 3:Variable Names,"Rule 3-1: 
  
  
 Use simple, descriptive variable names.
  
 Rule 3-2: 
  
 Good variable names are created by using one word or by putting two or three 
 words together, separated by “_”. For example:
  
 Rule 3-3: 
  
  
 Never use
  I
  (lowercase
  L
 ) or
  O
  (uppercase
  O
 ) as variable or constant 
 names.
  
 Rule 3-4: 
  
  
 Don't use the names of existing C library functions or constants.
  
 Rule 3-5: 
  
 Don't use variable names that differ by only one or two characters. Make every 
 name obviously different from every other name.
  
 Rule 3-6: 
  
  
 Use similar names for variables that perform similar functions.
  
 Rule 3-7: 
  
 When creating a two word variable name where the words can be put in any 
 order, always put the more important word first.
  
 Rule 3-8: 
  
  
 Standard prefixes and suffixes are
  _ptr
 ,
  _p
 ,
  _file
 ,
  _fd
 , and
  
 n_
 .
  
 Rule 3-9: 
  
 Short names such as
  x
 ,
  y
 , and
  i
  are acceptable when their meaning is clear 
 and when a longer name would not add information or clarity.",NA
Chapter 4:Statement Formatting,"Rule 4-1: 
  
  
 Write one statement per line.
  
 Rule 4-2: 
  
 Put spaces before and after each arithmetic operator, just like you put spaces 
 between words when you write.
  
 Rule 4-3: 
  
  
 Change a long, complex statement into several smaller, simpler statements.
  
 Rule 4-4: 
  
 In a statement that consists of two or more lines, every line except the first must 
 be indented an extra level to indicate that it is a continuation of the first line.
  
 Rule 4-5: 
  
 When writing multi-line statements, put the arithmetic and logical operators at 
 the end of each line.
  
 Rule 4-6: 
  
 When breaking up a line, the preferred split point is where the parenthetic nesting 
 is lowest.
  
 Rule 4-7: 
  
  
 Align like level parentheses vertically.
  
 Rule 4-8: 
  
  
 Split long
  for
  statements along statement boundaries.
  
 Rule 4-9: 
  
  
 Always split a
  for
  statement into three lines.",NA
Chapter 5:Statement Details,"Rule 5-1: 
  
  
 Always put a comment in the null statement, even if it is only",NA
Chapter 6:Preprocessor,"Rule 6-1: 
  
 #define
  constants are declared like variables. Always put a comment describes 
 the constant after each declaration.
  
 Rule 6-2: 
  
  
 Constant names are all upper-case.
  
 Rule 6-3: 
  
 If the value of a constant is anything other than a single number, enclose it in 
 parentheses.",NA
Chapter 7:Directory Organization and Makefile Style,"Rule 7-1: 
  
  
 Whenever possible, put all the files for one program or library in one 
 directory.",NA
Chapter 8:User-Friendly Programming,"Rule 8-1: 
  
 Law of Least Astonishment: The program should act in a way that least 
 astonishes the user.
  
 Rule 8-2: 
  
 Begin each error message with Error:. Begin each warning message with Warn-
 ing:.
  
 Rule 8-3: 
  
  
 Don't let users do something stupid without warning them.",NA
Chapter 9:Rules,NA,NA
