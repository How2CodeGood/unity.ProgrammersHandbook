Larger Text,Smaller Text,Symbol
Objective-C,NA,NA
®,NA,NA
Programming For Dummies,NA,NA
®,"Visit
  www.dummies.com/cheatsheet/objectivecprogramming
  to view this book's cheat sheet.
  
 Table of Contents
  
 Introduction
  
 About This Book 
  
 Conventions Used in This Book 
  
 Foolish Assumptions 
  
 How This Book Is Organized
  
 Part I: Getting to the Starting Line 
  
 Part II: Speaking the Language of Objective-C 
 Part III: Walking the Object-Oriented Walk Part 
 IV: Moving from Language to Application Part 
 V: The Part of Tens
  
 Icons Used in This Book 
  
 On the Web 
  
 Where to Go from Here
  
 Part I: Getting to the Starting Line
  
 Chapter 1: Computer Programming Exposed!
  
 Why a Computer Program Is Like a Recipe
  
 Examining a simple computer program
  
 Understanding How Computer Languages Work
  
 Creating a computer program 
  
 Running a computer program
  
 What Is Objective-C, Anyway?",NA
Objective-C,®,NA
 Programming ,NA,NA
For,NA,NA
Dummies,®,NA
by Neal Goldstein and Karl G. Kowalski,NA,NA
About the Authors,"Neal Goldstein
  is a recognized leader in making state-of-the-art and cutting-edge techno-
 logies practical for commercial and enterprise development. He was one of the first 
 technologists to work with commercial developers at firms such as Apple Computer, Lu-
 casfilm, and Microsoft to develop commercial applications using object-based program-ming 
 technologies. He was a pioneer in moving that approach into the corporate world for 
 developers at Liberty Mutual Insurance, USWest (now Verizon), National Car Rental, EDS, and 
 Continental Airlines, showing them how object-oriented programming could solve enterprise-
 wide problems. His book (with Jeff Alger) on object-oriented develop-ment,
  Developing Object-
 Oriented Software for the Macintosh
  (Addison Wesley, 1992), in-troduced the idea of scenarios 
 and patterns to developers. He was an early advocate of the Microsoft .NET framework, and he 
 successfully introduced it into many enterprises, including Charles Schwab. He was one of the 
 earliest developers of Service Oriented Ar-chitecture (SOA), and as Senior Vice President of 
 Advanced Technology and the Chief Architect at Charles Schwab, he built an integrated SOA 
 solution that spanned the enter-prise, from desktop PCs to servers to complex network 
 mainframes. (He holds four pat-ents as a result.) As one of IBM’s largest customers, he 
 introduced the folks at IBM to SOA at the enterprise level and encouraged them to head in that 
 direction.
  
 Since the release of the iPhone SDK in March 2008, he has been focusing on mobile ap-
 plications. He has had eight applications in the App Store. These include a series of Travel 
 Photo Guides (developed with his partners at mobilefortytwo), and a Digital Field Guides series 
 (
 http://lp.wileypub.com/DestinationDFGiPhoneApp
 ), developed in partnership with 
 John Wiley & Sons. He also has a free app called Expense Diary that al-lows you to keep track of 
 things like expenses, mileage, and time by adding them to your calendar.
  
 He has developed mobile strategies for a number of businesses, ranging from National 
 Cinemedia to the American Automobile Association (AAA). His strategies focus on Mobile 2.0 
 — integrating mobile across the enterprise, creating a consistent user experi-ence across 
 devices and applications in an application ecosystem, and developing a user experience 
 architecture that both leverages — and is constrained by — the device.
  
 He has spent the last three years working with mobile device users and developers to 
 determine what makes mobile devices so appealing, what users want from an applica-tion on a 
 phone or tablet, and what makes an app compelling. These efforts have resul-ted in the 
 Application Ecosystem model for mobile applications and an underlying Model Application 
 Controller Architecture based on web services that has become a key element in his client work 
 and his books.",NA
Dedication,"To my friends and family, and especially my children Sarah and Evan and my wife, Linda. She 
 deserves special recognition for her support and patience and for maintaining her (and my) 
 sense of humor. Without her support I never would have been able to write 12 books in 3.5 
 years. Thank you so much.
  
 This is for you 
  
 As day follows night 
  
 The tunnel ends in the light 
  
 Finally time to play
  
 — Neal Goldstein
  
 To my incredible family: Connie, Stanley, Lee Anne, David, Rosemarie, Joseph, Candi, 
 Reeseling the Nieceling, and Mason — thank you for all your love and support.
  
 — Karl Kowalski",NA
Author’s Acknowledgments,"Acquisitions Editor Kyle Looper for extending the vision of this book and keeping this project 
 on track. Thanks to Project Editor Charlotte Kughen for guiding us through the process and 
 keeping everything on track and Copy Editor John Edwards for helping us make things clear. 
 Tech Editor Jesse Feiler kept us on our toes, and his comments made this a better book. Great 
 job, team, and I deeply appreciate all of your work.
  
 Thanks again to my agent Carole Jelen for her continued work and support in putting and 
 keeping these projects together.
  
 — Neal Goldstein",NA
Introduction,"When the folks at John Wiley & Sons approached me about writing
  Objective-C Program-ming For 
 Dummies,
  I thought long and hard about it. Within 480 pages, I wanted to be sure that I could 
 explain to someone with no programming experience how to actually create useful programs.
  
 So I started to think about what makes programming so difficult.
  
 It isn’t the concept of how programs work, which I cover easily in Part I. And it isn’t really the 
 language itself (or the instruction set — I cover that in Chapter 4). It isn’t even the user interface 
 — all that code needed to open and close windows, process menus and the mouse and user 
 touches, draw graphics, and play audio and video (did I leave anything out?). No, while all that 
 used to be really hard, now it’s made much easier by using the frameworks available with Mac 
 OS X and iOS.
  
 What is really hard, after you understand the language and framework, is how you struc-ture 
 your program — how you actually go about taking your idea for an application and turning it 
 into a robust Objective-C application.
  
 Finding out how to use the tools is (relatively) easy; knowing how to use them to create a useful 
 application is the real challenge.
  
 So, besides explaining the instruction set and everything else involved with coding, what I do 
 along the way is explain the other things you need to know (things like application architecture 
 and design) — those things that will make it possible for you, when you are done with this 
 book, to go out and start developing your first application. Nothing less.
  
 So instead of a book that only shows you
  how
  to use all the features (instructions and 
 frameworks) available to you, I decided to write a book that shows you both
  how
  and 
 why.
  I do 
 that by having you start to develop an application in Chapter 5 (after I go over the instruction 
 set) and add to that same application until you end up with it running on both the iPhone and 
 Mac in Chapters 17 and 18. Granted, this application isn’t the most exciting one in the world, 
 but it gives you the opportunity to use every feature of Objective-C that you’ll need to know to 
 go out and build your own killer app. What’s more, you build the application incrementally, just 
 as a professional develops a commer-cial application. Occasionally, you will enter some code 
 only to delete it later, which may seem annoying at times. However, you will get a flavor for 
 how you’ll work when you are out on your own.
  
 And while some development will be annoying and tedious, in general it is fun. So go en-joy 
 yourself while you’re finding out about Objective-C. I know I do.",NA
About This Book,"Objective-C Programming For Dummies
  is a beginner’s guide to developing applications for both 
 iOS devices and the Mac. You don’t need any programming experience to get started. I expect 
 you to come as a blank slate, ready to be filled with useful information and new ways to do 
 things. In some ways, the less you know, the easier it will be for you because you won’t have 
 any preconceived notions about programming.
  
 This book distills the hundreds (or even thousands) of pages of Apple documentation, not to 
 mention my own development experience, into only what’s necessary to start you developing 
 real applications. I explain not only the language, but also along the way, I ex-plicitly talk about 
 object-oriented principles and how doing things in a certain way (that is, following those 
 principles) leads to more extensible and enhanceable programs, which you will discover is the 
 holy grail of programming.",NA
Conventions Used in This Book,"This book guides you through the process of building applications by using Objective-C.
  
 Code examples in this book appear in a monospaced font so that they stand out a bit better. 
 This means that the code you see will look like this:
  
 NSLog(@”I am an Objective-C statement.”);
  
 Objective-C is based on C, which (I want to remind you)
  is
  case sensitive, so please enter the 
 code that appears in this book
  exactly
  as it appears in the text. I also use the stand-ard 
 Objective-C naming conventions — for example, class names always start with a capital letter, 
 and the names of methods and instance variables always start with a lowercase letter.
  
 All URLs in this book appear in a monospaced font as well:
  
 www.dummies.com
  
 If you’re ever uncertain about anything in the code, you can always look at the source code at 
 the website associated with this book:
  www.dummies.com/go/objcprogram-mingfd
 . And 
 from time to time, I provide updates for the code and post other things you might find useful on 
 my website,
  www.nealgoldstein.com
 .",NA
Foolish Assumptions,NA,NA
How This Book Is Organized,"Objective-C Programming For Dummies
  has five main parts.",NA
Part I: Getting to the Starting Line,"Part I introduces you to the world of application development. You find out how pro-grams 
 work and what you have to do to take an idea and turn it into a computer pro-gram. I explain 
 the tools that are available to you and describe how to use them, and I lead you through 
 downloading the Software Development Kit (SDK), which includes Xcode (Apple’s 
 development environment for the OS X and iOS operating systems). You get up and running on 
 your first application, which gives you a taste for what words like 
 compiling
  and
  building
  mean. 
 You also find out how to become a registered Apple Developer, both for the Mac and the iPhone 
 (and if you are an iPhone developer, what you are required to do to distribute your 
 applications through Apple’s App Store).",NA
Part II: Speaking the Language of Objective-C,"As with any other skill, you have to pay your dues, and that means understanding the in-
 struction set of the language and knowing how to use some of the languagelike features made 
 available to you in the frameworks. You start by building an application that you will add to as 
 you discover more and more about Objective-C.
  
 Think of this as getting down the vocabulary of a new language, but without the pain and all 
 that memorization.",NA
Part III: Walking the Object-Oriented Walk,"After you understand the basic instruction set and the other Objective-C and framework 
 features, it’s time to put those instructions together to create a program. In this part, I focus on 
 the right way to structure your program — what’s known as the
  program archi-tecture.
  Having 
 the right architecture results in a program that not only works but also can be extended to add 
 new functionality easily. And not only that, it enables you to eas-ily track down and fix those 
 pesky bugs that make their home in everyone’s programs. I also show you how to deal with the 
 mundane, but necessary, plumbing issues such as memory management and object 
 initialization.
  
 Whereas Part II is about getting down the vocabulary, Part III is about using the vocabu-lary to 
 create sentences and paragraphs and even entire books.",NA
Part IV: Moving from Language to Application,"With an architecture in place, you can begin to add more and more functionality to your 
 program. You start to work with data and discover some of the tricks that framework de-
 velopers use to make their frameworks so extensible.
  
 After you have your application doing what you want it to do, you need to take all that 
 functionality and make it available to the user. So, in this part, I show you how your ap-
 plication fits into the user SDK-supplied frameworks that do all the user interface heavy lifting 
 on Mac OS X and iOS. And because you design the application the right way from the start, 
 you’ll be able to plug it into the user interface with minimal effort. You just do some building of 
 the user interface in Interface Builder (part of the SDK), add a few lines of code, and you are 
 there. No sweat, no bother. And yes, because you did it the right way from the start, the same 
 application code will run on both the Mac and iOS devices (using the frameworks for Mac OS X 
 and iOS).",NA
Part V: The Part of Tens,"Part V consists of voices from the trenches. I also show you some tips on debugging (yes, your 
 application will, upon occasion, have bugs) that might shorten those late, into-the-night 
 debugging sessions that are (unfortunately) part and parcel of being a de-veloper. Although 
 they may not always be fun, solved bugs are often a great source of conversation among 
 developers. I also offer some tips about approaching application development that will lead to 
 good health and happiness as a developer.",NA
Icons Used in This Book,NA,NA
On the Web,NA,NA
Where to Go from Here,"Occasionally, we have updates to our technology books. If this book does have technical 
 updates, they will be posted at
  www.dummies.com/go/objcprogrammingfdupdates
 .
  
 Please note that some special symbols used in this eBook may not display properly on all 
 eReader devices. If you have trouble determining any symbol, please call Wiley Product 
 Technical Support at 800-762-2974. Outside of the United States, please call 317-572-3993. 
 You can also contact Wiley Product Technical Support at
  www.wiley.com/ techsupport
 .",NA
Part I ,NA,NA
Getting to the Starting ,NA,NA
Line,NA,NA
In this part . . .,NA,NA
Chapter 1,NA,NA
Computer Programming ,NA,NA
Ex-posed!,"In This Chapter
  
  
  
  
 Understanding the basics of computer programming 
 Getting how computer languages work 
  
 Knowing how Objective-C works
  
 Looking at it from the outside, computer programming can appear complicated and a bit 
 mysterious. But once I let you in on a few of the secrets, you’ll realize that when you write a 
 computer program, whether it is a small program that’s just a few lines or one that is tens or 
 even hundreds of thousands of lines, you are generally doing the same thing:
  
 1. Getting input — from a keyboard or touch screen, or even something stored on 
 your computer.
  
 The input might be instructions to the program itself — for example, to display the web 
 page
  https://developer.apple.com
 , to print a document such as Chapter 1, to 
 process data like “Enter your Apple ID and Password” when you log on to the Mac Dev 
 Center (the browser is just another program), or even to process a list of credit card 
 transactions stored on a computer.
  
 2. Doing something based on, or with, the input.
  
 Your browser may go on the Internet and access the page corresponding to
  ht-
 tps://developer.apple.com
 , or your word processing program may display a Print 
 dialog box and print the chapter (at least that is what mine does). Based on your input, the 
 program may also go out and use data it has stored or even has ac-cess to over the 
 Internet. For example, when you enter your Apple ID and password, eventually a 
 computer accesses a database to see whether your Apple ID and pass-word are both valid 
 and, if so, allows you access to the site and displays the site for you.
  
 3. Displaying the results of your adroitness on a monitor (or storing it away for fu-
 ture use).
  
 Computers are no doubt engineering marvels. But what will make you a good program-mer is 
 not your understanding of all that wizardry. No, what will make you a good pro-",NA
Why a Computer Program Is Like a Re-,NA,NA
cipe,"At its heart (yes, it does have one), computer programming is actually not that alien to most 
 people. If you don’t believe me, take the following programming test. Now, don’t peek ahead 
 for the answer. Okay?
  
 The Never-Fail Programming Test:
  
 Write down the recipe for making a peanut butter and jelly sandwich.
  
 Answer:
  
 If what you wrote down looks anything like
  
 Recipe: Peanut Butter and Jelly Sandwich
  
  
 Ingredients
  
  
 Peanut Butter
  
  
 Jelly
  
  
 2 slices of bread
  
  
 Directions
  
  
 Place the two slices of bread close to each other.
  
  
 Spread peanut butter on one slice of bread.
  
  
 Spread jelly on the other slice of bread.
  
  
 Put one slice of bread on top of the other.
  
 you’re ready to go.",NA
Examining a simple computer program,"Is there really any difference between a chef reading a recipe to create a peanut butter and 
 jelly sandwich and a computer following some instructions to display something on a 
 monitor? Quite frankly, no.
  
 Here is the simple Objective-C program that displays
  I hate peanut butter and 
 jelly
  on the computer screen:
  
 int main(int argc, char *argv[]) {
  
  
 char* theSandwich = “I hate peanut butter and jelly”;
  
  
 printf (theSandwich);
  
  
 return 0;
  
  
 }
  
 This program shows you how to display a line of text on your computer screen. The best 
 way to understand programming code is to take it apart line by line:
  
 int main(int argc, char *argv[]) {
  
 Ignore the first line; it’s not important now. It just provides your program with some in-
 formation it can use. I explain exactly what that line means in the next few chapters.
  
 char* theSandwich = “I hate peanut butter and jelly”;
  
 theSandwich
  is what is known as a
  variable.
  The best way to think of it for now is as a bucket 
 that holds some kind of data (I get more precise in Chapter 4).
  char*
  tells you what kind of 
 variable it is. In this case,
  theSandwich
  is a bunch of characters (text) known as a
  string
  
 (technically a string is more than that, but for now, that description is good enough for our 
 purposes).
  I hate peanut butter and jelly
  is the data that the variable contains.
  
 printf (theSandwich);
  
 printf
  is an instruction (called an
  operation
 ) that tells the computer to display 
 whatever data is in the
  theSandwich
  bucket.
  
 return 0;
  
  
 }
  
 You can also safely ignore the last two lines for the time being.",NA
Understanding How Computer Languages,NA,NA
Work,"While conceptually it is pretty easy to understand computer programming — all you are doing 
 is giving the computer a set of instructions and some data on which to perform those 
 instructions — one of the challenges, as I mention previously, is that it’s not that easy to tell a 
 computer what to do.
  
 Computers don’t speak English, although computer scientists have been working on that 
 for years (think of trying to do that as the Computer Scientist Full Employment",NA
Creating a computer program,"To create a computer program by using a computer language, follow these steps (see Figure 
 1-3):
  
 1. Decide what you want the computer to do.
  
 You can have the computer write a line of text on the monitor or create an online 
 multiplayer game that will take two years to complete. It really doesn’t matter.
  
 2. Break the task you want the computer to complete into a series of modules that 
 contain the instructions the computer follows to do what you want, and then provide 
 the data it needs to do that.
  
 The series of modules is often referred to as your
  application architecture.
  The data you 
 provide to the computer can be some text, graphics, where the hidden treasure is, or the 
 euro-U.S. dollar exchange rate.
  
 3. Run the instructions through the compiler.
  
 A compiler is actually just another program, albeit one that uses your instructions as 
 data for its instructions on how to turn Objective-C into computer code.
  
 4. Link the result to other precompiled modules.
  
 As you will see, the code you write is a relatively small part of what makes up your 
 program. The rest is made up of all the plumbing you need to run the program, open and 
 close windows, and do all that user interface stuff. Fortunately, that code is provided for 
 you in a form that is easy to attach (link) to your program. A linker program takes your 
 code, identifies all the things it needs, collects all pieces (from the disk), and combines 
 them into the executable program you see in your applica-tions or utilities folder.
  
 5. Store that output somewhere.
  
 You usually store the output on a hard drive, but it can be anything the computer can 
 access, like punch cards.
  
 6. Run the program.
  
 When you want to run the program (say, the user double-clicks the program icon), the 
 operating system (Mac OS X, for example, which is also just another program) gets the 
 program from where it’s stored and loads it into memory, and then the CPU (central 
 processing unit) executes the instructions.",NA
Running a computer program,"Just as you don’t need to be a weatherman to know which way the wind blows, you don’t 
 need to be an engineer who understands the intimate details of a computer to write a 
 world-class application.
  
 Most people don’t find it that difficult to learn to drive a car. Although you don’t have to know 
 everything about internal combustion engines, fuel injection, drivetrains and transmissions, 
 you do need to know a little bit about how a car works. That means you need to know how to 
 start it, make it go forward, make it go backward, make it stop (generally a very valuable piece 
 of information), make it turn left or right, and so on.
  
 In the same way, you do need to know
  a little bit
  about how computers work to have what 
 you do to write a computer program make sense.
  
 Figure 1-3:
  
 How 
  
 programming 
  
 works.",NA
"What Is Objective-C, Anyway?","Objective-C
  is an object-oriented programming language, which means that it was cre-ated to 
 support a certain style of programming. Yes, I know it is hard to believe, but even things like 
 programming have different styles, in fact a lot of them, although the two heavyweights are 
 object-oriented and procedural. Unless you’re a dyed-in-the-wool member of a particular camp, 
 it is really unnecessary to get into that discussion here (or probably ever). But you will, I 
 promise, intimately understand what object-oriented pro-",NA
Understanding programming languages,"When you write a program, you write it as series of
  statements.
  Some of these statements are 
 about data. You may allocate areas of memory to use for data in your program, as well as 
 describe how data is structured. Other statements are really instructions for the computer to 
 do something.
  
 Here is an example of an Objective-C statement that adds together
  b
  and
  c
  and assigns the 
 result to
  a
  (and you thought you’d never use all that algebra you picked up in school):
  
 a = b + c;
  
 Statements like these use operators (like + or –) or tell
  modules
  (functions or objects) to do 
 something to, or with, the data. For now, think of functions or objects as simply a packaged 
 series of statements that perform a task. It might help to think of operators and modules as 
 words you use to create sentences (the statements) that tell the com-puter what to do. 
 Chapters 4, 5, 6, and 7 cover operators, functions, objects, and mod-ules in detail.
  
 When most people want to learn how to program, they usually focus on the language. I want 
 to program in C++, for example. Or C++ is a real dog; give me Java any day. People really do 
 become passionate about languages, and believe me, it is best to keep out of the way when an 
 unstoppable force meets an immovable object.",NA
Running your program in a runtime environment,"One of the features of Objective-C is its runtime system. This is one of those things that gets 
 linked into your program in Step 4 in the section “Creating a computer program,”earlier in 
 this chapter. It acts as a kind of operating system (like the Mac OS or iOS) for an individual 
 Objective-C program. It is this runtime system that is responsible for mak-ing some of the 
 very powerful features of Objective-C work.
  
 Objective-C’s runtime environment also makes it possible to use tools like Interface Builder (I 
 explain Interface Builder in Chapters 17 and 18) to create user interfaces with a minimum of 
 work (I’m all for that, and after you find out about Interface Builder, you will be, too).",NA
Using frameworks and libraries,"The framework you will use is called
  Cocoa.
  It came along with Objective-C when Apple 
 acquired NeXT in 1996 (when it was called NeXTSTEP). I have worked in many develop-ment 
 environments in my life, and Objective-C and Cocoa are hands down my favorites.
  
 Cocoa enables you to write applications for Mac OS X, and a version of it enables you to write 
 applications for iOS devices, such as the iPhone, iPad, and iPod. If the operating system does the 
 heavy lifting vis-à-vis the hardware, the framework provides all the stuff you need to make 
 your application an application. It provides support for windows and other user-interface 
 items as well as many of the other things that are needed in most applications. When you use 
 Cocoa to develop your application, all you need to do is add the application’s specific 
 functionality — the content as well as the controls and views that enable the user to access and 
 use that content — to the Cocoa framework.",NA
Framework or library?,"What is the difference between a library and a framework? A library is a set of reusable 
 functions or data structures that are yours to use. A framework, on the other hand, has an 
 architecture or pro-",NA
Your suite of development tools,"The main development tool you will use is Xcode. I explain Xcode in Chapter 2, and you use it 
 throughout this book. In addition, when it’s time to add a user-interface front end to your 
 application, you’ll make use of a tool within Xcode called Interface Builder. I talk a little about 
 Interface Builder in Chapters 17 and 18, but again, pick up copies of
  iPhone Application 
 Development For Dummies
  and
  Mac Application Development For Dummies
  to really understand 
 the frameworks.",NA
Using Xcode 4.4,"You will use the Xcode 4.4 developer tools package that is available at the Mac App Store. 
 This version of Xcode requires Mac OS X 10.7.3 (Lion) or later, and it is a major 
 improvement over previous versions of Xcode.",NA
Using Objective-C Version 2.0,"You will find out about Version 2.0 of the Objective-C language, which was released with Mac 
 OS X 10.5, and yes, you should care. I provide you examples of some of the very useful features 
 of Objective-C 2.0, such as declared properties, fast enumeration, and Automatic Reference 
 Counting, which greatly simplify memory management. All these features are available in the 
 latest versions of Mac OS X and iOS. If possible, I’ll also in-dicate some work-arounds if you 
 need to write applications that run under earlier ver-sions of the OS, but in general, writing 
 applications that run under earlier versions of the OS will be up to you.",NA
Chapter 2,NA,NA
Creating Your First ,NA,NA
Program,"In This Chapter
  
  
  
  
  
  
  
 Becoming familiar with the Software Development Kit 
  
 Setting up your first project 
  
 Building and running your first program 
  
 Getting up and running with the Xcode Development Environment 
 Becoming familiar with the Xcode text editor 
  
 Getting help with Xcode
  
 In Chapter 1, I provide some of the background context you need to know to write com-puter 
 programs, and I complete that discussion in Chapter 3. Although you still need to know more to 
 write
  good
  programs, it’s time for a break. In this chapter, you get a taste of what programming is 
 all about.
  
 But before you do that, you need to go through some administrative matters, such as 
 downloading the Software Development Kit (SDK) that you use to write programs.",NA
Getting Started with the Software Develop-,NA,NA
ment Kit,"Everything you need to program in Objective-C for the Mac or iOS devices is included in 
 something known as a
  Software Development Kit,
  or
  SDK
 . It contains Xcode (and some tools), 
 frameworks and libraries, and iOS, Mac OS X, and Xcode documentation — in short, everything 
 you need to develop applications for the Mac and iOS devices. After you have it installed on 
 your computer, you are ready to begin developing that killer app you have been thinking of.",NA
To register or not to register,NA,NA
Downloading Xcode,"It’s now time to download Xcode, which contains everything you need to develop for iOS 
 (which you do in Chapter 17) and Mac OS X (which you do in Chapter 18), or even both.
  
 To get the complete set of tools to start mastering Objective-C, follow these steps:
  
 1. Go back to the iOS Dev Center, and under Resources for iOS 5, click Downloads 
 (shown in Figure 2-1).
  
 Figure 2-1:
  Re-
  
 sources for iOS 
 5.",NA
Creating Your Xcode Project,NA,NA
Exploring your project,"To develop an Objective-C application, you have to work within the context of an Xcode project. 
 It turns out that you do most of your work on projects by using a Workspace window very 
 much like the one shown in Figure 2-10. This is the primary interface for developing your 
 application; it displays and organizes your source files and the other re-sources needed to build 
 your application.",NA
Workspace areas,"The Workspace is divided into four
  areas,
  as follows:
  
 Editor area (always shown)
  
 Navigator area
  
 Utility area
  
 Debug area",NA
Displaying an area’s content,"Each area displays certain content, and each area has its own way of displaying its con-tent:
  
 The Navigator area
  has navigators.
  
 The Editor area
  has content editors.
  
 The Utility area
  has
  
 • Quick Help
  or
  Inspectors
  in the Inspector/Quick Help pane
  
 • Libraries
  in the Library pane
  
 The Debug area
  has
  
 • Debugger variables
  in the Variables pane
  
 • Debugger output
  in the Console pane
  
 The following sections tell you about these areas in more detail.
  
 Navigator area navigators
  
 The Navigator area contains a host of navigators that organize the tasks and compon-ents you 
 use within your Xcode project. You use a Navigator selector bar to select the navigator you 
 need. Figure 2-14 shows the various navigators you can choose from, and the following bullet 
 list explains what each navigator does:
  
  
 Figure 2-14:
  The 
  
 Navigator selector.
  
 Project navigator:
  Here’s where you manage all the files in your project. You 
 can add files, delete files, and even organize your files by placing them into groups. 
 Selecting a file in the Project navigator launches the appropriate editor in the Editor 
 area.
  
 Symbol navigator:
  Lets you zero in on a particular
  symbol
  — an element such as a 
 variable, method, or function name — in your project. Selecting a symbol highlights it 
 in the editor.
  
 Search navigator:
  Finds any string within your projects and frameworks.",NA
The toolbar and Tab bar,"The
  toolbar
  (see Figure 2-15) includes Workspace-level tools for managing and running 
 schemes
  (instructions on how to build your application), viewing the progress of (ex-ecuting) 
 tasks, and configuring the Workspace window. That’s a lot of tools, so to keep things straight, 
 it’s best to think of the toolbar as actually having three parts: a flow con-trol part, an activity 
 viewer part, and a workspace configuration part.
  
 Flow controls
  are for defining, choosing, running, and stopping projects. A 
 scheme
  
 defines characteristics such as build targets, build configurations, and the executable 
 environment for which the product will be built.
  
 The Flow controls are as follows:
  
 Run button:
  Clicking the Run button builds and runs the targets. (A
  target,
  in this 
 context, is the product you want to build, as well as the instructions for building that 
 product from a set of files in a project or Workspace for the currently selec-ted 
 scheme.) Pressing and holding the mouse button opens a menu (which is also available 
 on the Product menu) that enables you to run, test, profile, or ana-lyze your 
 application.
  
 Stop button:
  Terminates your executing application in either the Simulator or the 
  
  
 device.
  
 Scheme menu:
  Lets you select the scheme and build destination to use.
  
 Breakpoints button:
  Activates or deactivates all breakpoints.",NA
The First Program Project,"When your project is launched in Xcode, the Navigator area appears on the left side of the 
 Workspace window. If this is the first project you’ve created, the following options are 
 selected for you by default:
  
 The Utility and Debug areas are hidden.
  
 The Navigator area is shown, with the Project navigator selected by default in the 
  
  
 Navigator selector.
  
 The project (First Program, in this case) is selected in the Project navigator.",NA
The Project editor,"Having your First Program project selected in the Navigator area’s Project navigator (refer to 
 Figure 2-8) sets a couple of balls rolling. In the first column of the Project editor, under the 
 Project heading, you see the project itself. (It turns out that a workspace can actually have more 
 than one project, but you won’t be doing that in this book.) A bit be-low the Project heading, 
 you see the Targets heading. (Yes, there’s room for more than one target here as well.) Any 
 project you create defines the default build settings for all the targets in that particular project. 
 (Note that each target can also specify its own build settings, which could potentially override 
 the project build settings.)
  
 A
  target
  is really just the
  app
  (the product you are building) and includes the information that 
 Xcode requires to build the product from a set of files in a project or workspace —stuff like the 
 build settings and build phases that you can see and edit in the Xcode Pro-ject editor. A target 
 inherits the build settings for the project, but you can override one or more of them by 
 specifying different settings at the target level. You can have one act-ive target at a time, with 
 the Xcode scheme (My Mac 64-bit, for example) specifying the target.
  
 The Project editor shows tabs across the top; clicking these tabs opens panes that en-able you 
 to examine and change project settings. The default settings will work for your needs for the 
 example code in this book. The tabs for the Project settings are as follows:
  
 Info:
  The Info tab contains basic information used by Xcode when building the code 
 within the project. Figure 2-16 shows what Xcode displays for First Pro-gram.
  
 Build Settings:
  Most developers can get by with the default build settings, but if you 
 have special requirements — ones that require anything from tweaking a set-ting or 
 two to creating an entirely new build configuration — you’ll take care of them on this 
 tab. Figure 2-17 shows the beginning of the Build Settings for the First Program project 
 (you find over a hundred different settings).",NA
The Project navigator,"After your project is created, the Xcode workspace displays the Project navigator. I cov-er the 
 important points of the Project navigator here, because you’ll be using it a lot in the coding 
 examples in the rest of the book.",NA
Building and Running Your Application,NA,NA
Building an app,"Building
  an app in Xcode means compiling all the source code files in the project. It’s really 
 exciting (well, I exaggerate a bit) to see what you get when you build and run a project that 
 you created from a template. Building and running an app is relatively simple; just follow 
 these steps:
  
 1. In the Flow Controls section of the toolbar, choose a scheme from the Scheme 
 pop-up menu.
  
 A
  scheme
  tells Xcode the purpose of the built product. The schemes in the Scheme pop-up 
 menu specify which targets (actual products) to build, what build configura-tion to use 
 when building them, which debugger to use when testing them, and which executable to 
 launch when running them on the device or Simulator. For this simple command-line 
 application, you only see one scheme: My Mac 64-bit.
  
 2. Choose Product
 ⇒
 Run to build and run the application.
  
 You can also click the Run button in the upper-left corner of the Workspace window. The 
 Activity viewer (shown previously in Figure 2-21) tells you all about the build progress, 
 flags any build errors (such as compiler errors) or warnings, and (oh, yeah) tells you 
 whether the build was successful.
  
 Figure 2-22 shows the results of a successful build and run.
  
 You may have noticed that not very much happened when you ran the app — Xcode’s Activity 
 viewer tells you it finished running First Program, but how do you know? In the lower-right 
 corner of the display is the
  Console
  pane, as mentioned earlier and visible in Figure 2-22.
  
 Figure 2-22:
  A 
 suc-
  
 cessful build and 
  
 run.",NA
All that stuff in main.m,"You can see the code that Xcode writes for you when it creates your Project by looking at the 
 contents of the
  main.m
  file.
  
 In the Project navigator, click the main.m item under the First Program folder. The Stand-ard 
 editor will display the contents.
  
 The Objective-C code you just built and ran is shown in Listing 2-1. It displayed
  Hello 
 World!
  in the Console pane and connected you with generations of C programmers who have 
 created and run this as their first application. Over the next few chapters, I dissect each and 
 very element in this program, but for now, the real point is to get you comfort-able with Xcode 
 and the compiler, although I point out a few highlights.
  
 Listing 2-1: Your First Program
  
  
 #import <Foundation/Foundation.h>",NA
Customizing Xcode to Your Liking,"Xcode has options galore, many of which won’t make any sense until you have quite a bit of 
 programming experience, but a few are worth thinking about now. So I go through how you 
 can set preferences in Xcode:
  
 1. With Xcode open, choose Xcode
 ⇒
 Preferences.
  
 2. Click the Behaviors tab at the top of the Preferences window to show the Behavi-ors 
 pane.
  
 The Xcode Preferences window refreshes to show the Behaviors pane.
  
 The right side of the pane shows the Events pane (the check marks indicate events for 
 which settings are set), whereas the left side shows the possible actions for an event.
  
 3. Select Run Generates Output in the left column and then choose the Show, Hide, or 
 If No Output Hide option from the Debug area pop-up menu to the left of the de-
 bugger in the right pane.
  
 This step controls what appears while you run your app. By default, you’ll find that the 
 check box for showing the debugger in the Debug area is selected. (See Chapter 8 for more 
 about debugging.)
  
 4. Select other options from the left column (perhaps Build Starts, Build Generates 
 New Issues, Build Succeeds, or Build Fails) and experiment with the options avail-
 able.
  
 You can link an event with playing a sound (something I like to do) or have an event 
 trigger the Xcode icon bouncing up and down in the Dock. You can change many options 
 in the Behaviors pane — too many to cover in this chapter! But take a look through them 
 and experiment — they can make your life much easier.",NA
Getting to Know the Xcode Text Editor,"The main tool that you use to write code for an iOS or Mac OS application is the Xcode Text 
 Editor. The Text Editor has a lot of great features, such as these:",NA
Accessing Documentation,"Like many developers, you may find yourself wanting to dig deeper when it comes to a 
 particular bit of code. That’s when you really appreciate Xcode’s Quick Help, header file access, 
 documentation window, Help menu, and Find tools. With these tools, you can quickly access 
 the documentation for a particular class, method, or property.
  
 For example, what if you had a burning desire to find out more about
  NSLog
 ?",NA
Quick Help,"Quick Help is an unobtrusive window that provides the documentation for a single sym-bol. It 
 pops up inline, although you can use Quick Help as a symbol inspector (which stays open) by 
 moving the window after it opens. You can also customize the display in Documentation 
 preferences in Xcode preferences.
  
 To get Quick Help for a symbol, press the Option key and click the symbol in the Text Editor 
 (in this case,
  NSLog
 ; see Figure 2-26).",NA
The header file for a symbol,NA,NA
Accessing Quick Help,"You can quickly get summary information about any item in your source code by follow-ing this 
 procedure:
  
 1. Click the Hide or Show Utilities view button to display the Utilities view.
  
 2. Click the Show Quick Help inspector to display the Quick Help available for se-
 lections in the Text Editor.",NA
Help menu,"The Help menu search field also lets you search Xcode documentation, as well as open the 
 Documentation window and Quick Help.
  
 You can also right-click a symbol and get a pop-up menu that gives you similar options to 
 what you see in the Help menu. This is shown in Figure 2-30.
  
 Figure 2-29:
  
 The 
  
 Docu- mentation 
  
 window.",NA
Find,NA,NA
On the Web,"The website URL that accompanies this book has a folder for each chapter, starting with 
 Chapter 4. Each of these folders has another folder that contains the Xcode project that 
 provides the starting point for each chapter — labeled (cleverly enough) Chapter
  XX 
 Start Here.
  
 That same chapter folder has a folder that contains the final version of the project for each 
 chapter labeled Example
  XX
  (except for Chapters 4 and 8, where a final version isn’t applicable) 
 or, in those chapters with more than one exercise, you see the exercises are labeled Example
  XX
  
 A, Example
  XX
  B, and so on. I explain what is in each of the folders in the appropriate chapter.",NA
Working with the Examples,"My experience, both personally and in teaching, is that the more you type — that is, the more 
 code you actually write — the more you discover and the faster you discover it.
  
 You work on a single application starting in Chapter 5 that finally ends up as an applica-tion for 
 both the iOS and Mac OS X. This application illustrates all the things you need to know to 
 program in Objective-C. I help you build it step by step, much like a developer creates a “real” 
 application. At times, you enter some code only to delete it later. Go with the flow. A method is 
 behind all of this, one that has been developed to get you going as quickly as possible and to 
 know as much as you need to, without being overwhelmed.
  
 More important, you see not only how to do something but also why you should do it that 
 way.
  
 The best way to work through this book is to complete Chapter 4, and then follow along with 
 me and add to that project as you go from chapter to chapter (and create the new project along 
 the way). If you are not the linear sort, or you want a fresh, up-to-date copy of the project, you 
 can always use the Start Here copy from the website for each chapter. I do think adding to what 
 you have already done is better and more in tune with how you (and other developers) really 
 work — often two steps forward and a quarter step back.
  
 Finally, experiment as much as you can. Don’t always take my word for it; test things out, see 
 what happens when you change something, and play with it until you really un-derstand how 
 something works. That’s how I learned Objective-C, and I’m sure it will work for you as well.",NA
Chapter 3,NA,NA
The Object in Objective-C,"In This Chapter
  
  
  
  
  
 Recognizing the importance of modules 
  
 Getting a handle on objects 
  
 Seeing encapsulation and polymorphism in action 
 Refining the idea of “reusable code”
  
 In Chapter 2, you get your first taste of programming (all right, enough with the food), and 
 throughout the next 15 chapters, I show you everything you need to know to write computer 
 programs. Although you may think that’s pretty cool, you shouldn’t be satisfied with that alone. 
 Your goal shouldn’t be to simply be able to write programs by using Objective-C; your goal 
 should be to write
  good
  programs by using Objective-C.
  
 So what makes a good program? Well, a blinding flash of the obvious answer is one that meets 
 the needs of the user. While that is true, it is only part of the answer. What also makes a 
 program good is how easy it is to make changes to it.
  
 I want to use the example I give you in Chapter 1 — a computer program that tracks my 
 expenses when I travel. It keeps track of my budget and converts foreign currency charges into 
 dollars.
  
 As I develop this program, I am going to have to make changes to it for three reasons.
  
 I’ll want to add new functionality.
  For example, starting out, the program will work with 
 cash and credit card transactions. I’ll get that up and running, and then eventually I’ll 
 want to be able to add ATM transactions, and also track my hotel and plane reservations. 
 I will want to be able to do this without having to com-pletely rewrite the program. In 
 fact, I would like to be able to add a new feature without changing anything at all in the 
 existing program and have that feature transparently incorporated into the program. The 
 term for this is
  extensible,
  and that means adding functionality to an existing program or 
 module.
  
 I’ll want to improve or change functionality.
  To start with, I’m willing to enter the 
 exchange rate by hand. Eventually, I’ll want the program to go out and find the current 
 exchange rate for me. Again, I want to be able to do this without having to make any 
 changes in the program except to code the new functionality. The term",NA
Not All Modules Are Created Equal,"The idea of dividing your program into modules is as old as programming itself, and you know 
 how old that is. The programming style (or
  paradigm
 ) I mention in Chapter 1 dic-tates the way 
 you do that.
  
 You need to be concerned with two paradigms at this point, although with more experi-ence, 
 you’ll probably explore others.
  
 Functions (or things like that), and groups of functions, have historically been the basis of 
 modularization. This way of dividing things into modules is used in the programming style or 
 paradigm known as
  procedural programming.
  Going back to the example I star-ted with — a 
 program that helps me track my expenses — you will find functions like 
 spend dollars
  or
  charge 
 foreign currency,
  which will operate on
  transaction
  and
  budget data.
  
 In the twenty-first century, however, the procedural paradigm has pretty much been 
 supplanted, at least for commercial applications, by
  object-oriented programming
 . In Objective-
 C (and other object-oriented languages) objects (and as you will see, their cor-",NA
Understanding How Objects Behave,"An object-oriented program consists of a network of interconnected objects, essentially 
 modules that call upon each other to solve a part of the puzzle. The objects work like a team. 
 Each object has a specific role to play in the overall design of the program and is able to 
 communicate with other objects. Objects communicate requests to other objects to do 
 something by using
  messages.
  
 Object-oriented programmers (including yours truly) think about objects as actors and talk 
 about them that way. Objects have responsibilities. You
  ask
  them to do things, they 
 decide
  what 
 to do, and they
  behave
  in a certain way. You do this even with objects like sandwiches. You 
 could, for example, tell a sandwich in an object-oriented program to go cut itself in half (ouch!) 
 or tell a shape to draw itself.
  
 It’s this resemblance to real things that gives objects much of their power and appeal. You can 
 use them not only to represent things in the real world — a person, an airplane reservation, a 
 credit card transaction — but also to represent things in a computer, such as a window, button, 
 or slider.",NA
Inventing Objective-C ,"Brad Cox (a computer scientist among other things) invented Objective-C in the early 1980s. He 
 took SmallTalk — one of the favorite object-oriented programming languages at the time — and 
 used it as",NA
Seeing the Concepts in Action,"Reading about concepts can keep me entertained for only a short time, a very short time, 
 before I need some concrete examples. I want to tell you a story about how encap-sulation and 
 polymorphism became real for me.",NA
Encapsulation,"I lived (briefly) in Minneapolis, Minnesota, where it can be not just cold, but
  really
  cold.
  
 During that time, I invented a device (in my head at least) called the uPhone — which was a 
 hand-held device (it looked something like Figure 3-1) that enabled me to start my car and 
 turn on the heater before I left the house in the morning.
  
 Figure 3-1:
  
 The uPhone.",NA
Polymorphism,"After my device worked so well for me, my wife decided she wanted one, too. The prob-lem is 
 she had a different kind of car with a different heater control, and my old compon-ent interface 
 wouldn’t work. Well, this time I did have to make some changes, but all I had to do was change 
 the component interface to the heater. I kept the uPhone interface the same, which also meant 
 no changes to the uPhone, as shown in Figure 3-3.
  
 Figure 3-3:
  The 
 ex-tensible 
 uPhone.
  
  
 What you are looking for is a situation in which the requestor doesn’t even care who re-ceives 
 the message, as long as it can get what it wants.",NA
Reusable Code,"When people talk about object-oriented programming, they tend to talk about two things. The 
 first is all that cool encapsulation and polymorphism stuff, which makes it easy to modify 
 programs. Then they talk about reuse, and that you can create reusable objects that save time 
 and money. Years ago, you always heard talk about object stores, where you could buy objects 
 that would do what you needed them to do.
  
 Will this book teach you how to write reusable code? Well, it depends on what you mean by
  
 reusable.
  If you really think about it, when you enhance or extend your program, what you are 
 doing is
  reusing
  the existing code to essentially create a “new” program. And in that respect, the 
 answer is yes.
  
 As you will see, the best models for reusability are found in the frameworks you’ll use to 
 develop applications for the iPhone and Mac. You reuse the frameworks by adding your own 
 application functionality to the framework that already includes the code that can display 
 windows and controls and menus — the whole kit and caboodle of the user in-terface, and then 
 some.
  
 I explain some of the things that the framework designers did to make reusing their 
 frameworks as easy as it is. You’ll find that when you use those same principles and",NA
Part II ,NA,NA
Speaking the Language ,NA,NA
of Objective-C,NA,NA
In this part . . .,"Now that you have the tools downloaded, it’s time to start programming. I help you do that in 
 this part by first covering most of the Objective-C instruction set, which you need",NA
Chapter 4,NA,NA
Language and ,NA,NA
Programming Basics,"In This Chapter
  
  
  
  
  
  
  
  
 Getting a handle on statements 
  
 Working with variables 
  
 Performing actions with operators 
  
 Knowing how to make logical decisions in your code 
 Using pointers to access data 
  
 Getting the hang of using constants 
  
 Being aware of the Objective-C reserved words
  
 As I mention in Chapter 3, Objective-C is a set of extensions to standard ANSI C. This means that 
 at some point (that is, this chapter), you’ll have to sit down and understand the basics of the C 
 instruction set, along with some less-than-inspiring examples and de-tailed explanations on the 
 basics of the language — kind of like mastering the alphabet. I know that all this can be tedious 
 and excruciatingly boring, although when you’re just starting out, you don’t have any other way 
 (we all have to pay our dues at some point). But after you are done with this chapter, you will 
 switch to finding out about Objective-C by developing a “real world” application, which I 
 promise is (for the most part) much more interesting. So hang in there.",NA
It All Comes Down to Your Statements,"At the end of the day, it’s all about the instructions you give the computer. Those instruc-tions 
 are called
  statements.
  You can easily recognize a statement because it ends with a semicolon, as 
 shown here:
  
 NSLog(@”This is a statement”);",NA
Syntax,"Syntax
  refers to the ways that symbols may be combined to create well-formed state-ments 
 in a given language. Think of all the grammar you had to master in school, and you have a 
 good idea of what syntax is. Syntax errors are what the compiler gives you when it can’t 
 understand the code you have written.",NA
Semantics,"But even though your code may be syntactically (grammatically) correct, it still may be 
 meaningless. For example, Noam Chomsky’s
  
 Colorless green ideas sleep furiously
  
 is syntactically correct but has no meaning (at least to most of us).
  Semantics
  is about meaning, 
 and it describes the behavior of a computer when executing a program in the language. It 
 describes what you get as the result of an operation:
  
 a = b + c;
  
 For example,
  a = b + c
  means that the value of
  b
  is added to the value of
  c
 , without 
 modifying either of their values, and the result is assigned to
  a
 . The previous value for
  a 
 is 
 gone and replaced with the new value. (I bet you never thought high school algebra would 
 come in this handy.)
  
 Semantics also describes the results of a series of operations or statements as well. For 
 example, a function named
  computeZimbabweanValue
  (I explain what functions are in 
 Chapter 5) computes the number of Zimbabwean dollars you can get for one U.S. dollar at the 
 current exchange rate.
  
 You have semantic errors when the program doesn’t do what you expect it to do.",NA
Understanding How Variables Work,"The memory in a computer is organized in
  bytes.
  A byte is the minimum amount of memory 
 that you can address. A byte can store a relatively small amount of data — one single character 
 or a small integer (generally an integer between 0 and 255). But the computer actually groups 
 bytes together to create and manipulate more complex data, such as integers and floating-
 point numbers.
  
 Variables
  are nothing more than convenient names that refer to a specific piece of data, such 
 as a number, that is stored in memory.",NA
Data types,"When you ask some memory to store data, the compiler has to know what kind of data you 
 want to store. The compiler needs to know that to determine how much memory you need 
 and how that variable can be used (how to do math with it is one example). The kind of data 
 you are requesting memory for is called a
  data type,
  and this concept will become important 
 because not only can you use what are known as
  built-in
  types, which I explain in this section, 
 but you can also create your own types, which I explain in Chapters 5 and 6.
  
 While the minimum amount of memory that your computer can manage is 1 byte, the data 
 types you will be working with will range from that 1 byte up to 8 bytes (or more for your 
 own types or some of the types defined in the frameworks you will be using).
  
 Table 4-1 shows the basic data types.
  
  
 Figure 4-1 illustrates an example of the amount of memory allocated to a
  char
  and an 
 int
 , 
 respectively. Each numbered box represents one byte, with each number represent-ing the 
 unique position of that byte in memory.
  
 Figure 4-1:
  
 char 
  
 and
  int
 .",NA
Identifier,"As I said, when you declare a variable in Objective-C, not only do you specify the data type, but 
 you also give it a name — called an
  identifier
  — that you can use to refer to the variable. 
 Consider the declaration I started with:
  
 int anInteger = 42;
  
 In this case, the name or identifier is
  anInteger
 . I can then use
  anInteger
  whenever I 
 want to refer to the variable.
  
 You do have to follow some rules when it comes to the identifier:
  
 Use only letters from the alphabet.
  For your purposes, even though you have other 
 choices, name your identifiers by using one or more of the 26 letters of the alphabet.
  
  
 Use uppercase to help readability.
  Start by using lowercase, but as I did with
  an-
 Integer
 , if it helps readability and describes the variable better, use uppercase inside 
 the name. Be sure to give your variables a name that describes them so
  
 that your code is more readable.
  
 Avoid using words used by Apple or Objective-C.
  Also be aware that names can-not 
 match any of the words used by Apple (in the frameworks) or Objective-C. I include a 
 list of reserved words at the end of this chapter, but don’t worry, if you make a 
 mistake, the compiler will let you know. Naming is generally not one of",NA
Initialization,"In a declaration, not only do you specify a type and a name, but you also
  may
  specify an initial 
 value — as in the declaration
  
 int anInteger = 42;
  
 Take a look at the equal sign; it’s not what you may think. Most people recognize the equal 
 sign by, oh, about first grade, but the equal sign here is a little more than that. In fact, the 
 equal sign is an
  operator,
  more specifically the
  assignment operator.
  It is an in-struction that 
 tells the computer to set that portion of memory that I am calling
  anIn-teger
  to the value 
 of
  42
 .
  
 Specifying an initial value is called
  initialization,
  and it’s not required
 .
  For example,
  
 int anInteger;
  
 works just fine. Memory will be reserved, but you can’t count on what the value will be. Of 
 course, sometimes you don’t care, such as when you are going to use that variable to hold the 
 result of a subsequent operation.
  
 I could also declare two variables by doing the following:
  
 int anInteger1, anInteger2;
  
 In this case, I reserved space for two
  int
 s:
  anInteger1
  and
  anInteger2
 .
  
 Finally, note the semicolon at the end of the statement. A semicolon is required at the end of 
 every statement. Because an
  instruction
  can span multiple lines, the semicolon is the way to tell 
 the compiler that you are done with your instruction.
  
 To summarize, the
  declaration
  I have been explaining is a request for memory to hold a data 
 type of
  int
  that I can refer to using the name
  anInteger
 , which has an initial value of
  42
 , as 
 illustrated in Figure 4-2. The memory location 32 is for illustrative purposes only. But I will 
 return and use this example again when I discuss pointers later in this chapter in the section 
 “Accessing Data with Pointers.”",NA
Giving Instructions with Operators,"Operators
  perform operations on (do things to) data, which enables you to actually do 
 something with those pesky variables. As I explain in Chapter 1, operators are one of the basic 
 building blocks that you’ll work with.
  
 In this chapter, I cover the operators you’ll need to use. Quite a few operators are avail-able 
 to you, but if you made it through grammar school, most of them will be familiar.",NA
Really learning how operators (and everything,NA,NA
else) work in Objective-C,"Before you start coding, I want to help you understand the best way to go through this chapter 
 and the rest of the book. Entering the code is not meant to be a typing exercise. As you enter 
 each line, you should be thinking about what will happen as a result of that line of code being 
 executed. Then after you build the project, you should look to see whether you were correct in 
 your expectation. If you were, great; you can continue. If not, you should reread the explanation 
 until you are sure that you understand it. In most of this chapter (with a few exceptions), this 
 issue won’t be a problem. At times, 
  
 however, the results of executing your code are not so obvious, or you may not be sure that you 
 completely understood what you just read. I encourage you (I’ll actually do a bit of nagging as 
 well) to write code that uses what I am explaining, even if I do not have you do it in a formal 
 exercise, to make sure that you understand it.
  
 In fact, one of the themes running through this book is code, code, code. My experience, both 
 personally and in teaching, is that the more you type (that is, the more code you actually write), 
 the more you understand and the faster you understand it. (I know I have said this before, but 
 just in case you thought I wasn’t serious about it, I say it again.)",NA
Using arithmetic operators,NA,NA
Back to variables — floats,"Floats and doubles are the types you will use if you want to see decimal places in the 
 results of your arithmetic calculations:
  
 1. Delete the previous example and type the following into your project:
  
 float a;
  
  
 float b;
  
  
 float c;
  
  
 a = 2;
  
  
 b = 3;
  
  
 NSLog (@” a + b = %i”, a + b);
  
  
 NSLog (@” a - b = %i”, a - b);
  
 NSLog (@” b - a = %i”, b - a); 
  
 NSLog (@” a * b = %i”, a * b);",NA
Bitwise operators,"On the computer, your data is actually stored as 1s and 0s, which corresponds to something 
 called a
  bit.
  In fact, the basic computations you do are in something called 
 binary arithmetic.
  
 I’m going to leave binary arithmetic as an exercise for you, the reader. Although I find it 
 fascinating, you probably don’t, and it is not usually necessary for most programmers to know. 
 If you need to understand it, understand it when you need to; that’s what I always say.
  
 If you do understand it, however, several operators are available to you that work on the bit 
 level. Table 4-4 describes these bitwise operators.
  
 Table 4-4 Bitwise Operators
  
  
 Operato
 r
  
  What It Does
  
 &
  
 Bitwise AND
  
 |
  
 Bitwise Inclusive OR
  
 ^
  
 Bitwise Exclusive OR
  
 ~
  
 Unary complement (bit 
 inversion)
  
 <<
  
 Shift Left
  
 >> 
  
 Shift Right",NA
Compound assignment operators,"I love this feature. It enables you to compute and assign a value to a variable. Table 4-5 
 describes the compound assignment operators.
  
 Table 4-5 Compound Assignment Operators",NA
Increment and decrement operators,"These operators are also some of my favorites because they provide another way to avoid 
 typing. They are called the
  increment operator
  (
 ++
 ) and the
  decrement operator
  (
 --
 ). They 
 increase or reduce by 1 the value stored in a variable. They are equivalent to +=1 and to –=1, 
 respectively. They can be a little tricky to use, however.",NA
Comma operator,"The comma operator (
 ,
 ) enables you to use two or more expressions where only one ex-
 pression is expected. It evaluates the first operand (usually an expression) and then dis-cards 
 the results. It then evaluates the second operand and returns that value. Obvi-ously, the only 
 time you’ll want to use this is when the evaluation of the first operand changes something in 
 the second operand.
  
 For example, the code
  
 int a;
  
  
 int b;
  
  
 a = (b = 3, b + 2);
  
  
 NSLog (@” a = (b = 3, b + 2) = %i”, a);
  
  
 NSLog (@” b = %i”, b );
  
 produces the output
  
 a = (b = 3, b + 2) = 5
  
  
 b = 3
  
 The comma operator, in the expression
  (b = 3, b + 2)
  will first evaluate
  b = 3
 , res-
 ulting in the value of
  b
  becoming 3. The second operand is then evaluated, adding 2 to
  b
 , 
 which results in the comma operator returning 5. Finally
  a
  is assigned that result, or 5.
  
 So, at the end, variable
  a
  will contain the value 5, whereas variable
  b
  will contain the 
 value 3.",NA
Cast operator,"The cast operator (
 ()
 ) enables you to convert one type to another:",NA
sizeof operator,"If you are curious about how much memory variables really use (and don’t necessarily 
 distrust me, but like to prove things for yourself), you can use the
  sizeof
  operator to 
 determine sizes.
  
 You can discover for yourself how much memory a variable uses by doing the following:
  
 1. Start with an empty
  main
  function and enter the following code:
  
 As I have said previously, in some cases in the book, you’ll see statements on 
 two lines. I have to do that to fit the code on the page; you should use only one line where 
 you can. This is especially important for strings, which will give you an error if they are on 
 two lines, unless you tell the compiler that’s what you want to do. This is especially 
 relevant in the following code. As I said, I show you a way to have a single string on 
 multiple lines in the section “Using Constants,” later in this chapter.
  
 // %lu tells the compiler to expect an unsigned long
  
  
 NSLog(@” A char = %lu bytes”, sizeof(char));
  
  
 NSLog(@” An unsigned char = %lu bytes”,
  
  
 sizeof(unsigned char));
  
  
 NSLog(@” A short = %lu bytes”, sizeof(short));
  
  
 NSLog(@” An unsigned short =
  
  
 %lu bytes”, sizeof(unsigned short));
  
  
 NSLog(@” An int = %lu bytes”, sizeof(int));
  
  
 NSLog(@” An unsigned int =",NA
Making Logical Decisions in Your Code,"When you are programming, you may need to make some decisions within your code. If the 
 user just clicked a button, does that mean I should play Pink Floyd’s “The Wall” or a selection 
 from Barry Manilow’s greatest hits? A number of control structures are avail-able that enable 
 you to make these kinds of decisions. In the following sections, I cover one, the
  if
  statement. 
 (I cover the balance in Chapter 9; it’s amazing how far you can ac-tually get without ever 
 making a decision.)
  
 In general, control structures use
  relational
  and
  equality operators
  to compare variables. The 
 result is a Boolean value that is either
  YES
  or
  NO
 , or
  true
  or
  false
 . To start, I will explain 
 what a Boolean type is.",NA
Boolean types,"A
  Boolean type
  is a variable whose value is either
  true
  or
  false
 . In Objective-C, you are 
 lucky; you actually have two Boolean types. Objective-C provides a type,
  BOOL
 , that can have 
 the values
  YES
  and
  NO
  (corresponding to
  true
  and
  false
 , respectively). In C, you find a 
 Boolean data type,
  bool
 , that can take on the values
  true
  and
  false
 . (You would normally 
 use the Objective-C version when writing Objective-C code.) Unfortunately, they do not always 
 behave the same way. (A historic Mac OS type
  Boolean
  exists that you shouldn’t use.)
  
 The
  BOOL
  type in Objective-C is actually a
  typedef
  (you find out about
  typed-
  
 ef
 s in Chapter 5):
  
 typedef signed char BOOL;
  
 And because the type of
  BOOL
  is actually
  char
 , it does not behave in the same way as a 
 bool
  in C (I’ll leave exactly why as an exercise for you).
  
 Sometimes programmers actually assign a value to the
  BOOL
 , and that can get you 
 into trouble. To avoid that problem, assign only
  YES
  or
  NO
  to an Objective-C 
 BOOL
 .
  
 Several operators return a Boolean type, and I give you a list of them shortly. Of course, 
 determining whether something is true or false is kind of pointless, unless you can do 
 something based on that information, and that is where the
  if
  statement comes into play.
  
 Take a look at how
  if
  statements, logical and equality operators, and Boolean types work 
 to enable you to implement logic into your program:
  
 1. Start with an empty
  main
  function and enter the following code:
  
 int a = 5;
  
  
 int b = 6;
  
  
 if (a == b) NSLog(@” a is equal to b”);
  
  
 if (a != b) NSLog(@” a is not equal to b”);",NA
Relational and equality operators,"In the section on Boolean types, you used a number of operators that enabled you to compare 
 two expressions. They allowed you to determine, for example, whether two ex-pressions were 
 equal, or if one was greater than the other. When you use one of these operators, the result is 
 the Boolean value, as you saw in the previous section.",NA
Logical operators,"Logical operators are similar to the relational operators in that they return Boolean val-ues. In 
 this case, rather than comparing two
  expressions,
  you are comparing the results of two
  
 comparisons
  (except for the NOT operator). Table 4-7 describes the logical oper-ators.
  
 Table 4-7 Logical Operators
  
  
 Operato
 r
  
  What It 
 Does
  
 !
  
 NOT
  
 &&
  
 Logical AND
  
 || 
  
 Logical OR
  
  
 !
  (NOT) evaluates a single expression and returns the opposite Boolean value. For ex-ample,
  
 !( a < b)
  returns
  NO
  if
  a
  is less than
  b
  and
  YES
  if
  a
  is greater than or equal to
  b
 .
  
 &&
  (logical AND) evaluates two expressions and returns
  YES
  when both expressions res-ult in
  
 YES
 . For example,
  (a < b) && (a < c)
  returns
  YES
  when
  a
  is less than both
  b 
 and
  c
 . 
 Otherwise, it returns
  NO
 .
  
 ||
  (logical OR) evaluates two expressions and returns
  YES
  when either one or both ex-
 pressions result in
  YES
 . For example,
  (a < b) && (a < c)
  returns
  YES
  when X is less 
 than either
  b
  or
  c
 . It returns
  NO
  when
  a
  is greater than or equal to both
  b
  and
  c
 .",NA
Conditional operator,NA,NA
Accessing Data with Pointers,"As I explain earlier, memory in your computer can be imagined as a series of mailboxes, each 
 one the smallest size (a byte) that a computer manages. These mailboxes are numbered 
 sequentially, so to get the next address, you add 1 to the current address. Th-ings are located in 
 memory by these addresses.
  
 For example, take the following declaration:
  
 int anInteger = 42;
  
 Assume that
  anInteger
  (with the value
  42
 ) is located at
  memory address
  32, as shown 
 earlier in Figure 4-2. In other words, memory address 32, which I have named
  anIn-teger
 , 
 contains the value
  42
 . With me so far?
  
 Until now, variable names have held some kind of value, an
  int
  or
  float
  for example, as you 
 just saw with
  anInteger
 . But they also can hold a pointer, which is an address in memory.
  
 Now look at this declaration:
  
 int *anIntPointer = &anInteger",NA
Using Constants,"Constants, as you might expect, are expressions that have a fixed value. You had some 
 experience with them when you did the following:
  
 int a = 5;
  
  
 a = 5;
  
 When you code
  a = 5
 , you are using a
  literal.
  
 Literals are not just numbers, however. The following expression is called a string literal:
  
 @”Hello World”;
  
 You have used string literals quite a bit already, and you will continue to use them throughout 
 the rest of this book. But what if you want to include a double quote (
 “
 ) in the string literal 
 itself? (A problem also exists with
  special characters
  such as newline or tab, which you won’t be 
 using.) To include a double quote, all you have to do is place a backslash (
 \
 ) in front of the
  “
  
 (or any other special character) you want to use. For ex-ample:
  
 \\u2019
  will display as a single quote (‘).
  
 \\u201d
  will display as a double quote (“).
  
 \\
  will display as a backslash (\).
  
 As I have been warning you (more than once), string literals need to be on a single line of 
 code. However, you can extend string literals to more than a single line of code by putting a 
 backslash sign (
 \
 ) at the end of each unfinished line:
  
 @”string expressed on \
  
  
 two lines”
  
  
 You can express any character by using its numerical ASCII code by writing a
  
 backslash character (
 \
 ) followed by the ASCII code as an octal (for example,
  \23 
 or
  
 \40
 ) or hexadecimal number (for example,
  \x20
  or
  \x4A
 ).",NA
Declared constants (const),"With the
  const
  prefix, you can declare constants of a specific type in the same way as you 
 do with a variable:
  
 const int aConstInt = 42;
  
  
 const float aConstFloat = 42.00;
  
 Here,
  aConstInt
  and
  aConstFloat
  are two typed constants. They are treated just like 
 regular variables except that their values cannot be modified after they have been de-clared 
 and initialized (obviously, you have to initialize them).
  const
  variables have the benefit that 
 the Objective-C compiler enforces their usage just as if they were regular variables; for 
 instance, when using a
  const
  variable as a parameter passed into a func-tion, the compiler 
 warns you if its type is different from what is expected. Using
  const 
 variables enables you 
 to use the same value in multiple places, and so you only have to change it where it’s defined 
 should you decide its value needs to change.",NA
Defined constants (#define),"Defined constants are a better solution to your need for certainty, although they are best placed 
 in a single file where you can easily find all of them. But because I haven’t ex-plained how to 
 use more than one file in your program, (although it is coming up in Chapter 6), I just go 
 through the mechanics of creating them.
  
 #define
  enables you to define names for the constants you use:
  
 #define
  identifier value
  
 For example, you can define two new constants:
  aDefineInt
  and
  aDefineFloat
  by do-ing 
 the following:
  
 #define aDefineInt 42
  
  
 #define aDefineFloat 42.00
  
 After you have defined
  aDefineInt
  and
  aDefineFloat
 , you can use them throughout 
 your code as you would a literal or declared constant.",NA
Knowing the Objective-C Reserved ,NA,NA
Words,"As I mention, your names or identifiers cannot match any keyword of the Objective-C 
 language. Some of those reserved keywords are as follows: 
  
  
 asm 
  
  
 auto 
  
  
 bool 
  
  
 BOOL 
  
  
 break 
  
  
 case 
  
  
 char 
  
  
 Class 
  
  
 const 
  
  
 continue 
  
  
 default 
  
  
 do 
  
  
 double 
  
  
 else 
  
  
 enum 
  
  
 extern 
  
  
 false 
  
  
 float 
  
  
 for",NA
Congratulations,"Congratulations! You’ve gotten through the most tedious part of understanding a com-puter 
 language.
  
 Some of the things I didn’t cover in this chapter are certain kinds of control structures, like
  
 switch
  statements, and things called loops, which allow you to repeat a block of statements 
 while a condition is true or until a condition is met. I will show you those, I promise, when you 
 are going to need to use them in Chapter 9.",NA
Chapter 5,NA,NA
Functions and Data ,NA,NA
Structures,"In This Chapter
  
  
  
  
  
  
  
 Looking at an application 
  
 Creating data structures 
  
 Working with defined data types 
  
 Collecting statements into functions 
  
 Understanding function prototypes 
  
 Knowing what happens when you want to extend the functionality of a program
  
 As I mention in Chapter 1, discovering how to program in Objective-C involves more than the 
 instruction set and data types you read about in the last chapter. In fact, you’ve re-ceived a 
 considerable amount of the instruction set covered by now. So it’s time to get on with the more 
 interesting aspects of the language, the ones you’ll need to know to create the kinds of 
 applications you are probably interested in.
  
 One of the most important features of Objective-C is its support for object-oriented pro-
 gramming. Although Objective-C is about objects, before I take you there in Chapter 6, I 
 introduce you to two features of C that are important to understand along the way —data 
 structures and functions. Data structures and functions are fundamental parts of the language, 
 and understanding them will make it easier for you to understand what objects are really about.",NA
Thinking about an Application,"In Chapter 1, I mention that when I travel, I often zone out on that fact that even though it looks 
 like Monopoly money, foreign currency actually does amount to something in dol-lars. I said it 
 would be helpful if I could use a computer to let me know when I charged something on a credit 
 card in a foreign currency, how much that was in dollars. It would also be helpful if I could use 
 that same program to generally keep track of my spending (I do tend to get carried away when I 
 am on vacation) against a budget I set at the beginning of a trip. Although this is not the most",NA
Defining and Declaring Data Structures,"The budget-tracking system covered in the preceding section gives you a starting point for 
 writing a program that does something more or less useful. In this section, I cover 
 data 
 structures,
  which are data elements grouped together under one name, and show you how to 
 use them in your program.
  
 You can declare the built-in data types as variables. But what about those situations when the 
 data you need to work with, or on, is really more than one variable — it is a lo-gical collection 
 of variables that hang out together because they have some relationship to each other. For 
 example, the data I used in the preceding example is all related to each other and provides the 
 data needed for this whole idea of budgeting:
  
 float
  
 exchangeRate;
  
  
 double budget;
  
  
 double euroTransaction;
  
 Another example is an address book, where you would want all the information about a person 
 grouped in a single entity. You can easily do that by using a data structure (
 struct
 ). Data 
 structures are defined in Objective-C, using the following syntax:
  
 struct
  structName
  {
  
  
 type member1Name
 ;
  
  
 type member2Name
 ;
  
  
 ...
  
  
 };
  
 A
  struct
  tells the compiler that this is a data structure.
  structName
  is a name for the 
 structure type
  — when you define a
  struct
 , you are actually defining a new data type that 
 can be used just like the built-in types such as
  int
  and
  double
 . Within the braces { } is a list 
 of the variables that are included in this
  struct
 , which are called
  members, 
 each one specified 
 with a type and a valid identifier as its name. And, yes, structures can have other structures as 
 members, although a structure can’t be a member of itself.",NA
Using Defined Data Types,"When you define a
  struct
 , you are creating a new data type, but it can be a bit awkward to 
 use. Every time I use it I have to use
  
 struct budget someBudget;
  
 Because I hate having to type more than absolutely necessary, I’m going to show you a way to 
 avoid using
  struct
  in a declaration. This also makes a
  struct
  look more like a built-in 
 data type. All you need to do is use the keyword
  typedef
  (this is another ex-ample of a 
 statement in Objective-C that describes how data is structured):
  
 typedef
  type typeName
 ;
  
 Here,
  type
  is a built-in type, or one that you created by using a
  struct
  (
 struct budget
 , for 
 example), and
  typeName
  is the name for the new type you are defining. For example:
  
 typedef struct budget budget;
  
 You can also create a new type name for a built-in type:
  
 typedef int theTypeAlsoKnownAsInt;
  
 You could then use that type name rather than
  int
  in the following:
  
 theTypeAlsoKnownAsInt anInt;
  
 To define the
  budget typedef
  in my program, all I have to do is add one line of code (in 
 bold):
  
 struct budget {
  
 float
  
 exchangeRate;
  
  
 double budget;
  
  
 double euroTransaction;
  
  
 };
  
  
 typedef struct budget budget;",NA
Writing Functions,"In this section, you collect the statements previously coded in
  main
  that display the res-ults of 
 a transaction into functions that do the same thing. One of the advantages of us-ing a module 
 like a function is that after you check that this set of statements works, you don’t have to worry 
 about that function anymore.
  
 The set of statements called a
  function
  has a
  name,
  and you can
  call
  that set of state-ments by 
 this name to have its code executed. This concept of using functions is as fun-damental to 
 programming as any of the instructions in Chapter 4. It is so fundamental, in fact, that you can 
 never hide from functions — it is in a function,
  main
 , after all, where you have been doing all 
 your work so far. The
  main
  function is required in your program because when you run your 
 application,
  main
  is where execution of the code starts.
  
 Take a look at the example of
  main
  again:
  
 int main (int argc, const char * argv[]) {
  
  
 NSLog(@”Hello, World!”);
  
  
 return 0;
  
  
 }
  
 You see a return type (
 int
 ), a name (
 main
 ), some arguments inside parentheses, and then 
 some instructions inside braces ({}). This structure is the basic structure of a func-tion. Now 
 you will see how to create your very own function. I explain the
  main
  function a bit more in 
 Chapter 7.
  
 For now, you’ll modify the program you just wrote to use functions. You start by adding code to
  
 main
 , something that is old hat to you by now, and then you move the code you wrote into a 
 function.",NA
Scope of variables,NA,NA
Unions,"Unions
  allow the same portion of memory to be accessed by using different variable names and 
 as (potentially) different types. I explain a little about them because you may come across 
 them in other people’s code, but I won’t get into the topic too deeply be-cause you are not 
 likely to use them yourself.
  
 While a
  union
  looks a lot like a
  struct
 , it is very different:",NA
Enumerations (enum),"Enumerations enable you to create new data types in a similar way that you did earlier with 
 the
  struct
 :
  
 typedef enum {
  
  
 value1,
  
  
 value2,",NA
Declaring Function Prototypes,"Up until now, you have had to
  define
  your functions (provide the code for the function) 
 before they were called. You may have wondered about the order I had you enter code, or 
 even experimented with the order and found yourself chastised by the compiler.
  
 With a
  function prototype,
  you inform the compiler that it will eventually see a
  definition 
 of the 
 function — so trust me, and let me use it before you get to it. As a result, the com-piler will let 
 you use it before it is defined, but if you double-cross the compiler, it won’t be a happy camper, 
 and neither will you.
  
 To declare a function prototype, all you do is this:
  
 void spendDollars (double dollars);
  
 Doing so means that you can move the definition — the implementation of the code —of
  
 spendDollars
  to after
  main
 . The value of this will become obvious in the next chapter.",NA
Extending the Functionality of a Program,"Because I am flying all the way to Europe from San Francisco, I decided that I might as well 
 visit London. To me, there’s nothing like a spring shower with the wind blowing hard enough 
 to make the rain go sideways. But before I go, I am going to have to make some additions to 
 my program.
  
 Obviously, the first thing that I will need to do is create a new
  budget
  for my trip to Eng-land. 
 Doing that is pretty easy:
  
 budget vacationBudgetEngland;
  
 I need this new
  budget
  because England has a different currency — and a different ex-
 change rate — than Europe, and I want to keep the two budgets separate. I’ll also change the 
 name of the old
  budget
 ,
  vacationBudget
 , to
  vacationBudgetEurope
  to make things 
 clearer. You can see that in Listing 5-3.
  
 The problem I face, though, is how do I update the
  vacationBudgetEngland
  variable? Right 
 now, with a single
  budget
 , I updated the
  vacationBudget
  from each of the func-tions. But 
 if I have two budgets,
  vacationBudgetEurope
  and
  vacationBudgetEngland
 , I need a 
 way to let the function know which budget it should update.
  
 One way would be to have a set of functions for each country. I could create
  spendDol-
 larsInEurope
  and
  spendDollarsInEngland
  functions (and corresponding 
  
 chargeForeignCurrencyEurope
  and
  chargeForeignCurrencyEngland
  functions that 
 would convert euros and pounds into dollars, respectively), and each one them would update 
 the corresponding
  budget
 . For example:",NA
Thinking about Extensibility and Enhance-,NA,NA
ability,"Although making the changes you just made does make it easier to add new countries (all you 
 need to do is declare another
  budget
  for New Zealand, for example, and call the 
 spendDollars
  and
  chargeForeignCurrency
  functions as needed), this approach is 
 fraught with danger.
  
 For example, one problem with this kind of module design is that the data itself is ac-
 cessible to all functions, and an errant function could think it was updating
  vaca-
 tionBudgetEngland
 . Because of a typing or copy-and-paste error (easily done on my 
 part), it could end up updating
  vacationBudget Europe
  instead.
  
 Perhaps you think that this is one of those theoretical issues that won’t usually happen if 
 you’re doing your job right. Well, when I was doing the code for this example, I actu-ally did 
 that — I typed
  vacationBudgetEurope
  when I meant to type
  vaca-
  
 tionBudgetEngland
 .
  
 But more important, if you ever want to change the
  struct
 , you have to go out and find all the 
 functions that used it and change them. For example, what if I decided I wanted to change the
  
 budget
  member so that it continued to hold the starting budget, and I wanted to add a new 
 variable
  whatsLeft
  to let me know what my remaining balance was? In this program, that’s 
 not a problem because I only have to change two functions. But in a more complex program, I 
 could have functions all over the place that are using 
 budget
  that I would have to find and 
 change.
  
 In addition, this program is not very extensible. If you wanted to have a different kind of budget 
 for New Zealand, for example, one where you tracked your wool purchases, you would either 
 have to add that to all the countries you visited (even though you didn’t use it anywhere except 
 New Zealand) or you would have to create a special
  struct
  for",NA
Chapter 6,NA,NA
Adding a Little More ,NA,NA
Class to Your Program,"In This Chapter
  
  
  
  
  
  
  
  
  
 Understanding objects and classes 
  
 Dissecting an object-oriented program 
  
 Defining the program interface 
  
 Implementing the interface 
  
 Examining the program logic 
  
 Using more than one source file 
  
 Getting the naming conventions 
  
 Using id and nil
  
 This chapter covers objects and classes and messages, and the difference between a pro-gram 
 based on functions and global data and one based on objects. I show you quite a bit about the 
 mechanics of using objects and classes in your program.
  
 I also introduce you to some basic ideas about encapsulation. Encapsulation involves more 
 than simply hiding instance variables behind the object’s wall, as you see as you read this 
 chapter and the rest of this book.
  
 I also explain and illustrate some of the advantages of using objects, but to be frank, I only 
 scratch the surface when it comes to that. As you continue through this book, I illus-trate, and 
 you discover on your own, many more.",NA
Grasping Objects and Their Classes,"In Chapter 5, I show you what you have to do to make your program easier to extend. You 
 created two functions,
  spendDollars:
  and
  chargeForeignCurrency:
 , that used a point-er 
 to a budget variable. You could then pass in the pointer to
  vacationBudgetEurope
  or",NA
Moving from Functions and Global Data to,NA,NA
Objects and Classes,"As you might guess, object-oriented programs are built around
  objects
  — no surprises here. 
 An object packages data with the particular operations that can use or affect that data. A class 
 that provides the same functionality as the
  budget struct
  and the func-tions that use it 
 looks like this:
  
 @interface
  
  
 Budget : NSObject {
  
 float
  
 exchangeRate;
  
  
 double budget;
  
  
 double exchangeTransaction;
  
  
 }
  
  
 - (void) spendDollars: (double) dollars ;
  
  
 - (void) chargeForeignCurrency: (double) foreignCurrency;",NA
Creating the Interface,NA,NA
Declaring the class interface,"The purpose of the class interface is to give users of a class the information they need to work 
 with the class. The declaration of a class interface begins with the compiler direct-ive
  
 @interface
  and ends with the directive
  @end
 . (All Objective-C compiler directives begin 
 with
  @
 .) You can see this here:
  
 @interface
  ClassName
  :
  ItsSuperclass
  {
  
  
 instance variable declarations
  
  
 }",NA
Scoping instance variables,"As you saw in Chapter 5, instance variables are scoped to (accessible within) the code block 
 they’re in. This can be a function, a code block within a function, or in this case, a class. It is this 
 built-in scoping mechanism that allows an object to hide its data. But to provide flexibility, 
 when it comes to a class (here come the Objective-C extensions to C again), you can actually 
 explicitly set the scope to three different levels through the use of a compiler directive:
  
  
  
  
 @private
 : The instance variable is accessible only within the class that declares it.
  
 @protected
 : The instance variable is accessible within the class that declares it and 
 within classes that inherit it. This is the default if you don’t specify anything.
  
 @public
 : The instance variable is accessible everywhere.
  
 There’s also another approach you can use to achieve the same result of using 
 @private
  to 
 deny access to a class’s data, through the use of
  categories
 . I explain cat-egories in Chapter 
 16, and cover this aspect in that chapter.
  
 Don’t use
  @public
 ! If you do — go directly to jail, do not pass Go, and do not collect $200. If 
 you have to ask why, reread the first part of this chapter, the last part of the pre-vious chapter, 
 and Chapter 3.
  
 Another level also exists:
  @package
 : On 64-bit machines, an instance variable acts 
 like
  @public
  inside the framework that defines the class, but like
  @private 
 outside. 
 I mention it because you may see it in some of the Cocoa header files, but it’s beyond the 
 scope of this book.",NA
The Implementation — Coding the Meth-,NA,NA
ods,"The
  @interface
  directive, which I discuss earlier in this chapter, declares a class’s in-terface. 
 This is where another developer (or even you) can go to understand the class’s capabilities and 
 behavior. But it’s here in the implementation that the real work is de-scribed and done.
  
 Just as with the interface, I break the implementation down into a number of steps and 
 explain what you are doing as you go along. Here are the steps:
  
 1. Add the implementation compiler directive.
  
 2. Define the
  createBudget:
  method.
  
 3. Define the rest of the methods.",NA
Adding the implementation compiler directive,"Type the following line of code after the
  @end
  statement into
  main.m
  and before
  main
 :
  
 @implementation Budget
  
 @implementation
  (like
  @interface
 ) is a compiler directive that says you’re about to 
 present the code that implements a class. The name of the class appears after
  @imple-
 mentation
 . Here is where you code the definitions of the individual methods. (Here, or-der is 
 unimportant — the methods don’t have to appear in the same order as they do in the
  
 @interface
 .) Once again, Xcode adds
  @end
  to be helpful and save you some typing.
  
 In fact, you can add methods in an
  @implementation
  that have not been de-clared 
 in the
  @interface
 . In other languages, these might be considered private methods. 
 Not so in Objective-C, which doesn’t have private methods — those you add to the 
 implementation that are not in the interface are still accessible to other objects.",NA
Defining the createBudget: method,"Type the following lines of code after
  @implementation Budget
 :
  
 - (void) createBudget: (double) aBudget
  
  
 withExchangeRate: (float) anExchangeRate {
  
  
 exchangeRate = anExchangeRate;
  
  
 budget = aBudget;
  
  
 }
  
 This is your brand-spanking-new initialization function. The first line of the definition of 
 createBudget:withExchangeRate:
  looks a lot like the declaration in the
  @interface 
 section (one would hope), except that rather than a semicolon at the end, you find a brace. 
 Notice that you have an argument named
  aBudget
  and an instance variable 
 budget
 . If you 
 had named that argument
  budget
 , the compiler would have needed to de-cide which one you 
 meant when you tried to access the budget variable. You will find that the compiler will tell you 
 in no uncertain terms that it was going to hide the in-stance variable from your method code. I 
 mutilated my beautiful code to illustrate that in Figure 6-2.
  
 You want to use a name like
  aBudget
  in the method declaration because it tells the read-er 
 exactly what the argument is for. In general, though, as you will see, I don’t want the user to 
 know that this is initializing an instance variable. I explain why, and more about encapsulation, 
 in Chapter 14 when I explain properties.
  
 The body of the method, as you might expect, contains these instructions:
  
 exchangeRate = anExchangeRate;
  
  
 budget = aBudget;
  
 Figure 6-2:
  
 The 
  
 compiler’s re-
  
 venge.",NA
Defining the rest of the methods,"Enter the following lines of code after the
  createBudget:withExchangeRate:
  method:
  
 - (void) spendDollars: (double) dollars {
  
  
 budget -= dollars;
  
  
 NSLog(@”Converting %.2f US dollars into foreign currency
  
  
 leaves $%.2f”, dollars, budget);
  
  
 }",NA
Exploring the Program Logic,"Now that you have declared your objects, it’s about time to do something with them. Al-though 
 it seems as though I’ve been working backward, which is true, it’s time to get to the real meat 
 (or tofu, if you prefer) of the program. Just remember, I have been working backward because 
 in programming, and in life, and in cooking (and in painting), most of the work is in the 
 preparation. After you have everything ready, the execution should be easy, and as you will see, 
 it is.",NA
Coding the functionality in the main function,"I now take you through coding the
  main
  function. I break this down into a series of 
 steps:
  
 1. Declaring the local variables
  
 2. Instantiating an object
  
 3. Sending messages to your objects
  
 4. Adding the code for England
  
 Declaring the local variables
  
 The first thing you do in your program is to declare some local variables, just as you did in 
 Chapter 5.
  
 Type the following lines of code into
  main
  after the first brace and before the
  return 0; 
 statement:
  
 double numberDollarsInEuroland = 100;
  
  
 double numberEuros = 100;
  
  
 double numberDollarsInPoundland = 100;
  
  
 double numberPounds = 100;
  
  
 Xcode displays a warning indicator — a yellow triangle — to the left of the
  
 lines you just entered and also in the Activity viewer. Don’t panic! Xcode is letting you 
 know that these variables are being initialized but Xcode hasn’t seen them get used — 
 yet. These warnings vanish after you enter more code later in this section.
  
 Instantiating an object
  
 The next thing you do is instantiate an object.
  
 Type the following line of code after the variables you just declared:
  
 Budget
  
 *europeBudget = [Budget new];
  
 Congratulations! You have instantiated (created) your first object, and you have sent it a 
 message.",NA
Building and running the application,NA,NA
Extending the program,"In Chapter 4, I raise two concerns about being able to extend my program. The first one, the 
 vulnerability that you face when all your functions have access to all the data, and are 
 dependent on that data’s structure, is mostly solved by encapsulating the data in an object. The 
 data becomes an internal implementation detail; all the users of that data outside the object 
 know about is the behavior it can expect from an object.
  
 But what if another object needs to know the amount left in your budget for England, for 
 example? This requires that you add a method that provides that information. Notice I said 
 information, not the instance variable. It becomes the responsibility of an object to supply the 
 budget information to any object that needs it. It does not mean, however, that an instance 
 variable has to hold that information. That makes it possible to change how you represent that 
 data, and also makes it possible to change what instance vari-ables you choose for the object. 
 In the preceding chapter, I brought up the problems that I would run into if I wanted to change 
 the
  struct
  that the functions used. Making that change now, using classes and objects in the 
 way you should, would have no effect on the objects that were using that information!
  
 So although its internal data structure is part of the class interface, in reality, an object’s 
 functionality should be defined only by its methods. As a user of a class, you shouldn’t count on 
 a one-to-one correspondence between a method that returns some data and an instance 
 variable. Some methods might return information not stored in instance vari-ables, and some 
 instance variables might have data that will never see the light of day outside the object.
  
 This allows your classes to evolve over time (remember Chapter 3, where I spoke about the 
 inevitability of change). As long as messages are the way you interact with a class,",NA
Spreading the Wealth across Files,"So far, everything you have done has been added to a single source file. All your projects have 
 created one file,
  main.m
 , where you wrote all your code. While this works for what you have 
 been doing thus far, it won’t scale when you start to develop your own applica-tions. As your 
 program gets larger, scrolling through a single file becomes more difficult.
  
 (Other issues, which are beyond the scope of this book, should not concern you for a while.) 
 But a well-thought-out solution exists for that problem that just about everyone uses.
  
 When I write even the simplest programs for iOS or Mac OS, I divide things into multiple files.
  
 As you’ve seen, the source code for Objective-C classes is divided into two parts. One part is 
 the interface, which provides the public view of the class. The
  @interface
  dir-ective 
 contains all the information necessary for someone to use the class.
  
 The other part of a class’s source is the implementation. The
  @implementation
  direct-ive 
 contains the method definitions.
  
 Because of the natural split in the definition of a class into interface and imple-
 mentation, a class’s code is often split into two files along the same lines. One part holds 
 the interface components: the
  @interface
  directive for the class and any 
 enum
 ,
  
 constants
 ,
  #defines
 , and so on. Because of Objective-C’s C heritage, this typically",NA
Knowing the Naming Conventions,"It is helpful to have some idea about how to name things to avoid having the compiler 
 scream at you. Here are some areas you need to pay attention to:
  
  
 The names of files that contain Objective-C source code have the
  .m
  extension. Files 
 that declare class and category (a category is used to extend a class; I ex-
  
 plain that in Chapter 16) interfaces or that declare protocols (I explain that in 
 Chapter 16 as well) have the
  .h
  extension typical of header files.",NA
Using id and nil,"As part of its extensions to C, Objective-C adds two built-in types that you will use.
  
 id
  is a generic type that’s used to refer to any kind of object regardless of class —
  id
  is 
 defined as a pointer to an object data structure. All objects, regardless of their instance 
 variables or methods, are of type
  id
 . You use
  id
  when I explain protocols in Chapter 16. For 
 now, just keep this in mind.
  
 Similarly, the keyword
  nil
  is defined as a null object, an
  id
  with a value of 0. You use it 
 starting in Chapter 7.
  
 id
 ,
  nil
 , and the other basic types of Objective-C are defined in the header file 
  
 objc/objc.h
 .",NA
Chapter 7,NA,NA
Objects Objects ,NA,NA
Everywhere,"In This Chapter
  
  
  
  
  
 Turning numbers into objects 
  
 Working with mutable arrays 
  
 Using each object in an array in a message 
  
 Getting to know C arrays
  
 Now that you know how to create classes and send messages to your objects, I want to expand 
 your ideas about what you can do with objects. In Chapter 6, what you did was create objects and 
 then you sent messages from
  main
  to the objects you created. What you will soon find out is 
 that your objects will be sending messages to other objects to as-sist them in carrying out their 
 responsibilities as well. You also discover that you don’t have to write all the objects you need to 
 use in your program. The frameworks I mention in Chapter 1 supply many of them for you. So 
 you not only create your own objects but also use the objects in Cocoa’s Foundation classes that 
 provide some of the “utility” func-tionality you need.
  
 In this chapter, I introduce you to two of those objects. The first is
  NSNumber
 , one of the 
 hundred or so classes in the Foundation Framework. All the data types I explain in Chapter 4 —
  
 signed
  or
  unsigned char
 ,
  short int
 ,
  int
 ,
  long int
 ,
  long long int
 , 
 float
 ,
  
 double
 , and
  BOOL
  — can be represented by using the
  NSNumber
  class.
  
 The second will be
  NSMutableArray
 . Arrays are what you will use to manage lists of ob-jects. 
 Right now, you don’t have that many objects to manage, but as you develop your application 
 you’ll begin to see how useful they can be. In this chapter, I show you how to take the
  
 NSNumber
  objects that you create and manage them by using an
  NSMutableAr-ray
 .",NA
Replacing Numbers with Objects,"As you discover more about object-oriented programming and the Cocoa frameworks, you’ll 
 discover that virtually everything you’ll work with will be an object. Many of these objects are",NA
Revisiting the documentation,"I can’t possibly go through all the possibilities of every class with you, and that is why in 
 Chapter 2 I show you how to access the documentation. Until now, you haven’t used the 
 documentation all that much because what you were doing didn’t involve the Cocoa classes 
 that you find in the documentation. But all that has changed, and now is a good time to review 
 how to access the documentation for the various classes that you will use.
  
 In Figure 7-1, I typed
  NSNumber
  into the Search field of the Organizer - Documentation 
 window.
  
 This brings up the
  NSNumber
  Class Reference in the Organizer - Documentation window. I 
 clicked the rightmost button on the Documentation navigator bar to display a number of 
 methods to create
  NSNumber
 s from quite a few types of inputs. You can see the hier-archical 
 menu leading to the
  NSNumber
  method names in Figure 7-2.
  
 For example:
  
 initWithChar: (char) value;
  
  
 initWithInt: (int) value;
  
  
 initWithFloat: (float) value;
  
  
 initWithBool: (BOOL) value;
  
 Figure 7-1:
  Ac-
  
 cessing document-
  
 ation.",NA
Using an NSNumber as an argument,"Although I’m not going to have you do any coding, I go through how you could use an 
 NSNumber
  object rather than a
  double
  as an argument in the
  spendDollars:
  method, 
 because it does illustrate some important things about using an
  NSNumber
  object. To re-place 
 the
  double
  with an
  NSNumber
 , you do the following:",NA
Taking Advantage of Array Objects,"Although using a number as an object is an interesting exercise in using objects (that is, 
 replacing a double with an
  NSNumber
 ), it doesn’t really buy you anything. But it turns out that 
 a similar use exists for an
  NSNumber
  object that can help you as you develop your program.
  
 As you examine the program you have developed so far, you’ll realize that as you add more 
 and more transactions, the code is going to get a bit unwieldy.
  
 Currently, for every transaction I create, I have to code a
  spendDollars:
  statement. For 
 example, for every transaction where I spend dollars in Europe I need
  
 [europeBudget spendDollars:numberDollarsInEuroland];
  
 For example, if I want to process 50 transactions, I end up with
  
 [europeBudget spendDollars:numberDollarsInEuroland1];
  
  
 ...
  
  
 [europeBudget spendDollars:numberDollarsInEuroland50];",NA
Container classes,"In object-oriented programming, a container class is a class that is capable of storing other 
 objects. In Cocoa, several kinds are available, and I explain the two most widely used. One is a
  
 dictionary,
  which I cover in Chapter 15, and the other is an
  array,
  which you use in this chapter. 
 You also continue to use this array in Chapter 9 and beyond, and in no time (or at least by the 
 end of this book), using arrays will become second nature to you.
  
 Two kinds of arrays are available to you in Cocoa. The first is an
  NSMutableArray
 , 
 which enables you to add objects to the array as needed — that is, the amount of memory 
 allocated to the class is dynamically adjusted as you add more objects. An 
 NSMutableArray
  also enables you to remove or rearrange objects it contains.
  
 Of course, you aren’t really storing the object in an array any more than you stored 
 an
  NSNumber
  object in the
  europeDollarTransaction
  variable when you created 
 it:
  
 NSNumber *europeDollarTransaction = @100.00;
  
 In both cases, you are storing a pointer to the object.
  
 The second kind of array is an
  NSArray
 , which enables you to store a fixed number of objects 
 that are specified when you initialize the array. Because in this case you need the dynamic 
 aspect of an
  NSMutableArray
 , I start my explanation there. I explain
  NSAr-ray
 s later in 
 this chapter, and you actually use an
  NSArray
  in Chapter 15.",NA
Tiptoeing through an array,"Objective-C 2.0 provides a language feature that enables you to enumerate over the con-tents 
 of a collection. This is called
  fast enumeration,
  and it became available in Mac OS X 10.5 
 (Leopard) with version 2.0 of Objective-C. As I mention, this book is based on Mac OS X 10.7 — 
 and iOS 5.0 on the iPhone. (If you need to program for OS X 10.4, you need to use an
  
 NSEnumerator
 , which I leave as an exercise for you.) Fast Enumeration uses the
  for in
  
 feature (a variation on a
  for
  loop, which I explain in Chapter 9).
  
 What enumeration effectively does is sequentially march though an array, starting at the first 
 element and returning each element for you to do “something with.” The
  
 “something with” you will want to do in this case is use that element as an argument in the
  
 spendDollars:
  message.
  
 For example, this code marches through the array and sends the
  spendDollars:
  mes-sage 
 by using each element in the array (an
  NSNumber
  “transaction”), eliminating the need for a 
 separate line of code for each
  spendDollars:
  message statement sent for each transaction:
  
 for (NSNumber *aTransaction in europeTransactions) {",NA
Adding mutable arrays,"If you have been following along with me, I extend what you did in Chapter 6. If you 
 want to start with a clean copy of the project from where you left off, you can use the 
 project found in the Chapter 7 Start Here folder, which is in the Chapter 7 folder.",NA
Working with fixed arrays,"Actually,
  NSMutableArray
  is a subclass (I explain that in Chapter 10) of
  NSArray
 , which 
 manages a static array — after you have created it, you cannot add objects to it or re-",NA
Using C Arrays,"Arrays are also a part of the C language. Although most of the time you’ll use array ob-jects, 
 you’ll also find uses for C arrays, not to mention seeing them used in Apple docu-mentation 
 and code samples.
  
 Arrays in C store elements just as an
  NSArray
  does (although they must be of the same 
 type), and you can think about them as an ordered list as well.",NA
Expanding to multidimensional arrays,"One useful aspect of arrays is multidimensional arrays. For example
  
 int twoDArray[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
  
 declares and initializes an array that has two dimensions, like a tic-tac-toe board. You can 
 make three-dimensional arrays, and even more.
  
 Although no multidimensional array objects exist, in Objective C you could have an ar-ray of 
 arrays that accomplish the same thing. Arrays of arrays are used extensively in Mac OS X and 
 iOS programming, and you can find them used in some of the samples on their respective Dev 
 Center sites.
  
 The following code shows a two-dimensional array in C, and the way to simulate that two-
 dimensional array in Objective-C. No applause — I leave you to figure this out on your 
 own:
  
 int main() {
  
  
 int twoDArray[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
  
  
 NSLog (@”twoDArray[2][2] is %i”, twoDArray[2][2]);",NA
Finishing up with the main function,"Arrays can be passed as a parameter in C. To accept arrays as parameters, the only thing that 
 you have to do when declaring the function is to specify that its argument is an array by using 
 its identifier and a pair of void brackets [ ]. For example, the function
  
 void someFunction (int arg[])
  
 accepts a parameter that is an array of
  int
 s.
  
 Now that you understand arrays, I can finally explain the argument list in the
  main
  func-tion:
  
 int main (int argc, const char * argv[]) {
  
 The name of the variable
  argc
  stands for
  argument count
  and contains the number of ar-
 guments passed to the program. The name of the variable
  argv
  stands for
  argument vec-tor
  
 and is a one-dimensional array of strings; that’s what a
  char*
  is in C (but because you won’t 
 be using them, I won’t be going any farther into C strings in this book).
  
 This finally (and thankfully) closes the chapter on
  main
 .",NA
Chapter 8,NA,NA
Using the Debugger,"In This Chapter
  
  
  
  
 Knowing how things can go wrong 
  
 Using Xcode’s Debugger 
  
 Finding and fixing logic errors with the Debugger
  
 Now that things have gotten a little more interesting, so will the errors.
  
 Let’s face it. You are always going to have errors. No matter how good you are, how much 
 experience you have, how careful you are, or even how smart you are, they are a pro-gramming 
 fact of life.
  
 You’ll come up against three kinds of errors. Each one has a unique personality and asso-ciated 
 techniques for finding and correcting. Here is a list of the three types you’ll find:
  
 Syntax errors
  
 Runtime errors
  
 Logic errors
  
 The last two types, runtime and logic errors, are what are commonly referred to 
 as“bugs.”",NA
Identifying the Usual Suspects,"Although no exercise is in this chapter, you can follow along with me if you like by 
 using the project in the Chapter 8 Start Here folder in the Chapter 8 folder at the website. 
 Or, you can use the project that you used at the end of Chapter 7.",NA
Catching syntax errors,NA,NA
Fixing it with Live Issues and Fix-It,"Xcode comes with built-in features to help you find and fix errors like these in your code.
  Live 
 Issues
  is part of the Apple LLVM compiler, and it continuously evaluates your code in the 
 background and alerts you to coding mistakes. Before this feature came along, you had to build 
 your app first, and trust me, this new way saves lots of time and effort.
  
 But not only is Live Issues happy to point out your mistakes,
  Fix-it
  will also offer (when it can) 
 to fix the problem for you. Clicking the error displays the available Fix-its, such as correcting an 
 assignment to a comparison, repairing a misspelled symbol, or appending a missing semicolon. 
 With a single keyboard shortcut, you can instantly have the error repaired and you can 
 continue coding. Fix-it marks syntax errors with a red underline or a caret at the position of the 
 error and with a symbol in the gutter — the space to the left of the line numbers.
  
 For example, in Figure 8-4, the semicolon is missing after the
  NSNumber *englandDol-
 larTransaction = @100.00
  statement. (Notice the error indicator — the red circle with 
 exclamation point — in the Activity viewer, your Go To place for showing status messages, 
 build progress, and errors). Pressing Return will automatically fix this prob-",NA
Crashing with runtime errors,"Runtime errors cause your program to stop executing — this is commonly known as a“crash.” 
 You are probably familiar with that happening to programs you are using, and it’s quite 
 annoying. But it’s a little different when it happens to a program you have writ-ten. You can see 
 the result of that at line 36 in Figure 8-5 for a Foundation Command Line Tool, although when 
 you are running on a Mac as an application or on an iPhone simu-lator, or an iOS device itself, 
 you get other kinds of messages. Don’t worry; while a mes-sage may not tell you why, the fact 
 that it is a runtime error is usually obvious.
  
 Runtime errors can be created in all sorts of ways. However, you can rule out one way; at least 
 it wasn’t a syntax error (although it could be a warning that you ignored). You might have had 
 data that you hadn’t expected (a division-by-zero error, for example), or you had a problem 
 with an argument you used in a message. Sometimes you even get some build warnings for 
 these errors; sometimes you’re blindsided by a crash. At other times, instead of crashing, the 
 program may “hang” and become incommunicado.",NA
Dealing with logic errors,"When a program doesn’t do what it is supposed to, people tend to blame the problem on the 
 computer. “The computer gave me the wrong answer.” Well, computers are actu-ally blameless 
 creatures; they do what they are told to do, and they do that with a ven-geance. If you were to 
 tell a computer to go jump off a cliff, it would. It does exactly, and I mean exactly, what you tell 
 it to do — over and over and over again. When you have a logic error, the problem is not that 
 the computer didn’t do what you told it to; the prob-lem is that it did. You just told it to do the 
 wrong thing. Another possibility is that you may have forgotten to tell it to do something, like 
 initialize an object for example. In Fig-ure 8-6, everything looks fine — not a compiler error in 
 sight (ignore the highlighted line for a second).
  
 The problem is that the output looks a little screwy:
  
 Converting 100.00 US dollars into foreign currency leaves $1100.00
  
  
 Converting 200.00 US dollars into foreign currency leaves $1300.00
  
  
 Charging 100.00 in foreign currency leaves $1175.00
  
  
 Converting 100.00 US dollars into foreign currency leaves $2100.00
  
  
 Charging 100.00 in foreign currency leaves $1950.00",NA
Using the Debugger,"In Figure 8-7, I deliberately created a situation that gives me a runtime error. (Intention-ally 
 creating a runtime error may seem a bit bizarre, but this is for teaching purposes.)
  
 As you can see from the highlighted code — lines 26 and 27 — I am going to divide by 0.
  
 If I had done something like i/0, I would have gotten a compiler warning (which I could choose 
 to ignore for teaching purposes). In this case, I fooled the compiler (it’s generally not a good 
 idea to try to fool the compiler; it really has your best interests at heart). So the compiler thinks 
 everything is fine, but at runtime, the processor is chugging along, executing its instructions, 
 only to result in the unexpected program halt you see in Fig-ure 8-8.
  
 In Figure 8-8 the Debug Console shows a warning with some text that looks like this:
  
 __NSCFNumber autoreleased with no pool in place
 . Don’t panic —this is a 
 result of using the
  NSNumber
  initializer I introduced in Chapter 7, com-bined with the 
 use of Automatic Reference Counting and the removal of some code in
  main
  in Chapter 
 4, which involved the Objective-C directive
  @autore-leasepool
 . This warning has to 
 do with memory management, something I ex-plain in Chapter 13.
  
 How can the Debugger help me determine the source of a runtime error like this one? The 
 next section gives you the details.",NA
Using Breakpoints,"A
  breakpoint
  is an instruction to the Debugger to pause execution at that instruction and wait 
 for further instructions (no pun intended). If you have a logic error, a breakpoint can help by 
 allowing you to step your way through your code (refer to the earlier sec-tion, “Dealing with 
 logic errors”). By setting breakpoints at various places in your pro-gram, you can step through 
 its execution, at the instruction level, to see exactly what it is doing. You can also examine the 
 variables that the program is setting and using, which allows you to determine whether that is 
 where the problem lies.
  
 Returning to the logic error introduced in Figure 8-6, I’m going to set a breakpoint at the entry 
 of the method I think is causing the problem —
  spend Dollars:
  — to see wheth-er I can",NA
Using the Static Analyzer,"Xcode has an Analyze feature (the Static Analyzer) that analyzes your code.
  
 The results show up like warnings and errors, with explanations of where and what the issue 
 is. You can also see the flow of control of the (potential) problem. I say
  potential 
 because the 
 Static Analyzer can give you false positives.
  
 In Figure 8-13, I chose Analyze from the Product menu (choose Product
 ⇒
 Analyze).
  
 Figure 8-13:
  
 Run-
  
 ning the Static 
  
 Analyzer.",NA
Chapter 9,NA,NA
Using Control Statements ,NA,NA
and Loops,"In This Chapter
  
  
  
  
  
  
 Understanding how control statements and loops work 
 Knowing when to use — and not use —
  switch
  statements 
 Getting a handle on loop statements 
  
 Building your application 
  
 Using jump statements
  
 In Chapter 7, I introduce you to
  NSMutableArray
 s to help you manage lists of objects. You see 
 how you can use an array of objects and then iterate through the array, passing each object as an 
 argument in a message. In Chapter 7, you use an array for only one transaction type,
  
 spendDollars:
  using one country’s budget,
  europeBudget
 . If you want to extend that to
  
 chargeForeignCurrency:
 , you need another array. And if you want to extend that to use
  
 englandBudget
 , you need to add two additional arrays — one each for the
  spendDollars:
  
 and
  chargeForeignCurrency:
  messages.
  
 This may seem pretty awkward, and it is. To manage my objects, what I really want is a single 
 array that I can iterate through, one that holds all the different transaction types for all the 
 countries I will be visiting.
  
 And that’s what you will be doing in this and the next chapter.
  
 Along the way, I also complete your knowledge of the C functionality that is part of Objective-C 
 — showing you how to use loops and control statements to determine the ex-ecution sequence 
 of instructions.",NA
Creating Transaction Objects,"To start the journey to a single array that manages all my transactions for the countries I visit, I 
 want to review how the program works currently.",NA
Managing all those objects,"This particular situation is not unique — managing a list of similar objects is the kind of thing 
 you’ll need to do in many of your applications.",NA
Adding the Transaction class,"I start by having you change the current
  NSNumber
 -based transaction object from a 
 wrapper (an object that is there mostly to turn something into an object) into a real 
 Transaction object with its own instance variables and methods.
  
 If you have been following along with me, I extend what you do in Chapter 7. If you 
 want to start with a clean copy of the project from where you left off, you can use the 
 project found at the website in the Chapter 9 Start Here folder, which is in the Chapter 9 
 folder.
  
 I have you start by adding a new file to your project. (I explain how to do this in more detail 
 in Chapter 6.) Follow these steps:
  
 1. Select the
  Classes
  folder in the Project navigator.
  
 This tells Xcode to place the new file in the
  Classes
  folder.
  
 2. Choose File
 ⇒
 New File (or press
 +N) to get the New File dialog.
  
 3. In the leftmost column of the dialog, first select Cocoa under OS X; then select the 
 Objective-C class template in the upper-right pane. Click Next.
  
 You see a new screen asking for some more information.",NA
Using switch Statements,"A
  switch
  statement is a kind of
  control statement.
  Control statements are used to de-termine 
 what to do when a certain condition arises. I introduce one of those, the
  if 
 statement, in 
 Chapter 4. Later in this chapter, in the section “Taking the Leap: Jump Statements,” I introduce 
 you to the balance of those C statements. Although these kinds of statements can be useful in 
 object-oriented programming, you need to be especially careful about how you use them.
  
 For now however, you’ll work with the
  switch
  statement.
  
 I want to review the code that you will add that will implement the
  switch
  statement:
  
  
 switch ([aTransaction returnType]) { 
  
  
  
 case cash: 
  
  
   
 [europeBudget spendDollars: 
  
  
   
  
 [aTransaction returnAmount]]; 
  
  
   
 break; 
  
  
  
 case charge: 
  
  
   
 [europeBudget chargeForeignCurrency: 
  
  
   
  
 [[aTransaction returnAmount] doubleValue]]; 
  
   
 break; 
  
  
  
 default: 
  
  
   
 break; 
  
  
  
 } 
  
 }
  
 Let me explain how this works.
  
 A
  switch
  statement is a type of control statement that allows the value of a variable or 
 expression to control the flow of program execution. In this case, you are using the 
 transactionType
 .
  
 As you can see in Listing 9-2, for a
  transactionType cash
  (remember, you declared 
 transactionType
  and the values it can take on in the
  typedef
  in Listing 9-1), you send the
  
 spendDollars:
  message to the
  europeBudget
  object with the amount returned to you by 
 the
  returnAmount
  method as the argument.",NA
Using Loop Statements to Repeat Instruc-,NA,NA
tions,"Loop statements
  allow you to have the same set of instructions repeated over and over and 
 over again — at least until some criterion is met. You actually do that in Chapter 8, using the 
 enumerator
  for in
  statement. In this chapter, I expand upon that. Loops are the kinds of 
 things you’ll continue to use as you discover more about Objective-C and programming in 
 general.
  
 Remember, using loops here is only a convenience in your program to create 
 transactions. In the real world (and in Chapters 17 and 18), you allow the users to enter 
 transactions through a user interface. But even so, loops, as you will find out, are 
 fundamental to programming — so fundamental that you find them in most computer 
 languages.
  
 So, it’s time to find out more about loops. You’ll use three kinds of loops:
  
 The
  for
  loop
  
 The
  while
  loop
  
 The
  do while
  loop",NA
The for loop,NA,NA
The while loop,"The
  for
  loop is typically used when the number of iterations is known before entering the 
 loop, whereas the
  while
  and
  do while
  loops repeat until a certain condition is met.",NA
for or for in?,"for
  loops are used when you know what the number of iterations is going to be. Because 
  
 [
 europeTransactions count]
  determines how many times you need to iterate through the 
 ar-ray, you could have used a
  for
  loop instead of using the
  for in
  array iterator described in 
 Chapter 7.
  
 The iterator you used was
  
 for (NSNumber * aTransaction in europeTransactions) { 
 [europeBudget spendDollars: aTransaction]; 
  
 }
  
 To accomplish the same thing with a
  for
  loop, you use the array’s
  count
  method, which tells 
 you the number of elements it has. (As I mention in Chapter 7, this is one of the key methods 
 you will use.)
  
 for (int n = 1; n <= [europeTransactions count]; n++) { 
 [europeBudget spendDollars: 
  
 [europeTransactions objectAtIndex:n]]; 
  
 }
  
 The iterator is just faster and more convenient than coding your own
  for
  loop.
  
  
 To add transactions to your array by using a
  while
  loop, you code the following:
  
 int n = 1;",NA
The do while loop,"The
  do while
  loop works the same way as the
  while
  loop with one exception. The 
 condition
  is evaluated
  after
  the execution of
  Statement(s) to execute while the 
 condition is true
  instead of before, meaning that you will always have at least one 
 execution of
  Statement(s) to execute while the condition is true
  even if the 
 condition is never fulfilled:",NA
Adding Loops to Your Program,"To add the
  switch
  statement and loops to
  main
  in the
  main.m
  file, delete the bold, italic, 
 underlined code and add the code in bold, as shown in Listing 9-3.
  
 Listing 9-3: Adding switch Statements and Loops to the main Function
  
  
 #import <Foundation/Foundation.h>
  
  
 #import “Budget.h”",NA
Building the New Application,"So that you can admire all the work you’ve done, it is time to build the application.
  
 Click the Run button on the Project Window toolbar to build and run the application.
  
 You should see the following in the Debugger Console:
  
 Converting 100.00 US dollars into foreign currency leaves $900.00
  
  
 Charging 100.00 in foreign currency leaves $775.00
  
  
 Charging 200.00 in foreign currency leaves $525.00
  
  
 Charging 300.00 in foreign currency leaves $150.00
  
  
 Converting 100.00 US dollars into foreign currency leaves $1900.00
  
  
 Charging 100.00 in foreign currency leaves $1750.00
  
  
 You can find the completed project at the website in the Example 9 folder,
  
 which is in the Chapter 9 folder.",NA
Taking the Leap: Jump Statements,"To finish your tour of C coding, I provide the rest of the control statements that are available 
 in Objective-C. You’ll use a few of them, such as
  break
  (which you used in 
 switch
  
 statements) and
  return
 , in your code. You’ll use the rest occasionally (with the exception of 
 the
  goto
  statement, which should never use). The rest of the control state-ments are as 
 follows:
  
  
 break
 : Using
  break
 , you can leave a loop even if the condition for its end is not 
 fulfilled. It can be used to end an infinite loop or to force it to end before its nat-
  
 ural end. Recall that this is how you terminate instruction execution after it starts 
 executing instructions for a given
  case
 .
  
  
  
 continue
 : The
  continue
  statement causes the program to skip the rest of the 
 loop in the current iteration and jump to the start of the next iteration.
  
 return
 : The
  return
  statement ends a method or function. You used a
  return 
 statement in
  main
 , as well as in your methods. It is included here to remind you",NA
Knowing the Problems with switch State-,NA,NA
ments,"Although I have achieved my goal of creating a single array of transaction objects for a given 
 country, I still have a way to go if I want to make it possible to have a single array that 
 handles all transaction types for all countries.
  
 For example, if I were to add a country and a
  returnCountry:
  method to the transac-tion, 
 I’d have to add an additional
  switch
  structure within each existing
  case
  to use the right
  
 budget
  object — makes my head hurt to think about it. And as you can see, my program 
 would become much more complicated as I add more transactions and coun-tries. Whereas 
 this is only one place in this program (so far) that I need to use that kind of logic, in a real 
 program, you could find it all over the place.
  
 In the following code example, I implemented a
  switch
  structure to handle different 
 countries, within the
  switch
  structure to handle the type of transaction. You can see how 
 easily this will get out of hand:
  
 for (Transaction * aTransaction in transactions) {
  
  
 switch ([aTransaction returnType]) {
  
  
 case cash:
  
  
 switch ([aTransaction returnCountry]) {
  
  
 case Europe:
  
  
 [europeBudget spendDollars:",NA
Part III ,NA,NA
Walking the Object-,NA,NA
Oriented Walk,NA,NA
In this part . . .,NA,NA
Chapter 10,NA,NA
Basic Inheritance,"In This Chapter
  
  
  
  
 Understanding inheritance 
  
 Implementing inheritance 
  
 Understanding the connection between inheritance and polymorphism
  
 In Chapter 9, you create a
  Transaction
  object and use a
  switch
  statement to manage more 
 than one kind of transaction in a single array. The problem with that approach is that the
  
 switch
  statements can rapidly get very complicated, and a program with
  switch 
 statements 
 scattered throughout becomes difficult to extend and enhance.
  
 Quite frankly, this kind of complex control structure is characteristic of the procedural program 
 paradigm that I speak of in Chapter 3. Object-oriented programming and Objective-C do not 
 “improve” this control structure as much as eliminate it as much as possible. The way this is 
 done is by using one of those Objective-C’s extensions to C —
  in-heritance
  — to take advantage of
  
 polymorphism
  (which I explain in Chapter 3). As you find out as I lead you through implementing 
 an inheritance-based class structure in this chapter, this greatly simplifies things, and you end up 
 with a program that is a great deal easier to understand and extend (the two actually go hand in 
 hand).
  
 After you get into the rhythm of thinking this way, programming and making changes 
 become more fun and less dreary. You introduce fewer bugs as you add functionality to 
 your program, and your coding becomes completely focused on the new functionality 
 instead of requiring that you go back through everything you have done to see whether 
 you are about to break something that now works just fine.",NA
Replacing a Control Structure with Poly-,NA,NA
morphism,NA,NA
How inheritance works,"You may notice a bit of a problem here. You got rid of the complicated
  switch
 , but now you 
 have to maintain all those transactions. If want to make a change or add to generic transaction 
 functionality, you have to go back and modify both the cash and credit card transactions. In 
 Chapter 5, when I discuss adding a separate
  struct
  for New Zealand to track wool purchases, 
 I say specifically that this is something you want to avoid (you may want to refer to Chapter 5).
  
 What I say at the end of Chapter 5 is still true, but fortunately, I don’t have to worry about 
 maintaining a host of similar classes. Objective-C, like other object-oriented pro-gramming 
 languages, permits you to base a new class definition on a class that’s already defined. The 
 base class is called a
  superclass;
  the new class is its
  subclass.
  The subclass is defined only by its 
 differences from its superclass; everything else remains the same.
  
 All I need to do is create a transaction base superclass that encapsulates what is the same 
 between a cash and credit card transaction, and then create cash and credit card transaction 
 subclasses that implement the differences.
  
 The terms
  superclass
  and
  subclass
  can be confusing. When most people think of
  
 super,
  they think of something with more functionality, not less. In some lan-guages, 
 the term used is
  base class,
  which I think does a better job of conveying meaning. But it 
 is what it is, so keep this in mind.
  
 In Figure 10-2, you see an example of a
  class diagram
  that uses the UML (Unified Model-ing 
 Language) notation (the superclass and subclass arrows and terms are not part of the 
 notation; they are there to illustrate the hierarchy of the
  Transaction
  classes in the 
 program) — one often used by programmers to describe their classes. The name of the class is 
 at the top of the box, the middle section describes the instance variables, and the bottom box 
 shows you the methods of that (sub) class.",NA
Knowing what inheritance enables you to do,"Inheritance enables you to do a number of things that make your programs more extens-ible 
 and enhanceable. In a subclass, you can make the following three kinds of changes to what you 
 inherit from a superclass. Think of this section as describing the mechanics of creating a 
 subclass.
  
 You can add new methods and instance variables.
  Although you haven’t done that 
 yet, this is the one of the most common reasons for defining a subclass in general.
  
 You can refine or extend the behavior of a method.
  You do this by adding a new 
 version of the same method while still continuing to use the code in the old method. To 
 add a new version, you implement a new method with the same name as one that’s 
 inherited. The new version
  overrides
  the inherited version. In the body of the new 
 method, you send a message to execute the inherited ver-sion. I illustrate this later in 
 this chapter, in Listing 10-6, and explain it in Step 3 following the listing (and again 
 when I explain initialization in Chapter 12). Imple-menting a new method with the 
 same name as one that’s inherited is referred to as
  overriding
  a method.
  
 You can change the behavior of a method you inherit.
  You do this by replacing an 
 existing method with a new version. Overriding the old method does this. In this case, 
 however, you do not send a message to execute the inherited version.
  
 The old implementation is still used for the class that defined it and other classes that 
 inherit it, although classes that inherit from the new class use your",NA
Using inheritance effectively,"Given the preceding possibilities, here are some ways that you can use inheritance in your 
 programs:
  
  
 Create a contract.
  You are actually creating a contract with the
  Transaction 
 class. 
 A contract in this sense is a list of method(s) that subclasses are expected
  
 to implement. The superclass might have empty versions of the methods, or it might 
 implement partial versions that you use in the subclass methods. In either case, the 
 superclass’s declaration (its list of methods) defines a structure of methods that all its 
 subclasses must follow if they implement their own particu-lar versions of the same 
 methods.
  
 When different classes implement similarly named methods, a program is better able 
 to make use of polymorphism (see the discussion of the more-of-the-same approach in 
 Chapter 3). Actually one of the things I really like about Objective-C is that it provides 
 additional ways to do this, as you see when I explain delega-tion in Chapter 16. Both 
 inheritance and delegation are extensively used in Co-coa.
  
 This use of inheritance is exemplified by the concept of an
  abstract
  class — often called 
 an
  abstract superclass
  (or
  abstract base class
 ). This is a class designed to have classes 
 inherit from it. An abstract class brings together the methods and instance variables 
 that are to be used by subclasses. In doing that, abstract classes define the structure of 
 an application, and when you create your sub-classes, they fit effortlessly into the 
 application structure and work seamlessly with other objects.
  
 You usually do not create an instance of an abstract class, because it really can’t do 
 anything, being dependent on its subclasses to implement the key functional-",NA
Implementing Inheritance in a Program,"Now it’s time to put everything you know about inheritance and polymorphism together and 
 add it to your program. You have to start by making some changes to the
  Transac-tion
  
 class.",NA
Creating the Transaction superclass,NA,NA
Adding the files for the new subclasses,"Next, you take advantage of what you just did and create two subclasses of
  Transac-tion
 ,
  
 CashTransaction
 , and
  CreditCardTransaction
 . They inherit all the methods and 
 instance variables of the
  Transaction
  class, but each implements its own
  spend: 
 method. I also have both methods send a message to their superclass’s
  trackSpend-ing:
  
 method to show you how to send messages to your superclass.
  
 Object-oriented programmers like to think of subclasses like
  CashTransac-tion
  
 as having an “is a” relationship to their superclasses. A cash transaction “is a” 
 transaction — a
  CashTransaction
  “is a”
  Transaction
 .
  
 Now, look at how to create the two new subclasses.
  
 First, you need to create four new files, as you do in Chapter 6. Follow these steps:
  
 1. Select the
  Classes
  folder in the Project navigator list.
  
 This tells Xcode to place the new file in the
  Classes
  folder.
  
 2. Choose File
 ⇒
 New File (or press
 +N) to get the New File dialog.
  
 3. In the leftmost column of the dialog, first select Cocoa under OS X; then select the 
 Objective-C class template in the upper-right pane. Click Next.
  
 You see a new dialog asking for some more information.
  
 4. Enter
  CashTransaction
  in the Class field and enter
  Transaction
  in the Subclass Of 
 drop-down menu; then click Next.
  
 Choose a location to save the new class files (the default location works just fine) and 
 click Create.
  
 5. Choose File
 ⇒
 New File again (or press
 +N) to get the New File dialog.",NA
Implementing the new subclasses,"Now that you have the files for the new subclasses in place, it’s time to get to work filling those 
 files with code. You do that by adding and deleting the code in Listings 10-3 and 10-4 to the
  
 CashTransaction.m
  and
  CreditCard Transaction.m
  files. The 
  
 CashTransaction.h
  and
  CreditCard Transaction.h
  files don’t require any modifica-
 tion.
  
 Listing 10-3: CashTransaction.m
  
  
 #import “CashTransaction.h”
  
  
 #import “Budget.h”
  
  
 @implementation CashTransaction
  
  
 - (void) spend {
  
  
 [self trackSpending:[amount doubleValue]];
  
  
 [budget spendDollars:amount];
  
  
 }
  
  
 @end
  
  
 Listing 10-4: CreditCardTransaction.m
  
  
 #import “CreditCardTransaction.h”
  
  
 #import “Budget.h”
  
  
 @implementation CreditCardTransaction
  
  
 - (void) spend {
  
  
 [super trackSpending:[amount doubleValue]];
  
  
 [budget chargeForeignCurrency:[amount doubleValue]];
  
  
 }
  
  
 @end
  
 To add the two new subclasses, you only had to declare the unique behavior in each class. 
 Here are the steps you took to implement these two classes:
  
 1. You left the
  CashTransaction.h
  and
  CreditCardTransaction.h
  files alone, be-
 cause Xcode did everything necessary to make them subclasses of
  Transaction
 . By 
 entering Transaction in the Subclass Of drop-down menu field, you told Xcode that these 
 two classes would have
  Transaction
  as their superclass. Xcode created the correct
  
 #import
  statement and
  @interface
  statement to ensure this.",NA
Modifying main to use the new classes,"Now that you have done all the spadework, you can take the final step in making your 
 program much more extensible and enhanceable. You use that new inheritance-based 
 Transaction
  class design in
  main
 .
  
 To do that, add the code in bold and delete the bold, italic, underlined code in Listing 10-5 to
  
 main
  in the
  main.m
  file.
  
 Listing 10-5: main in main.m
  
  
 #import <Foundation/Foundation.h>
  
  
 #import “Budget.h”",NA
Considering Polymorphism and Inherit-,NA,NA
ance,"You have just used one of the Objective-C extensions to C — inheritance — to imple-ment 
 polymorphism (or as I like to think of it, more-of-the-same). As you have seen, 
 polymorphism is the ability of different object types to respond to the same message, each 
 one in its own way. Because each object can have its own version of a method, a program 
 becomes easier to extend and enhance because you don’t have to change the message to add 
 functionality. All you have to do is create a new subclass, and it re-sponds to the same 
 messages in its own way.
  
 This enables you to isolate code in the methods of different objects instead of gathering them 
 in a single function that has to know all the possible cases and in control struc-tures such as
  
 if
  and
  switch
  statements. As you have seen, this makes the code you write more extensible 
 and enhanceable, because when a new case comes along, you won’t have to recode all those
  
 if
  and
  switch
  statements — you need only add a new",NA
Chapter 11,NA,NA
Encapsulating Objects,"In This Chapter
  
  
  
  
  
 Understanding the Model-View-Controller pattern 
  
 Knowing the role of interfaces 
  
 Seeing how composite objects work 
  
 Factoring your code to implement Model-View-Controller
  
 Using encapsulation enables you to safely tuck data behind an object’s walls. You can keep the 
 data safe and reduce the dependencies of other parts of your app on what the data is and how 
 it is structured.
  
 Encapsulation is also useful when you apply it to application functionality. When you lim-it what 
 your objects know about other objects in your application, changing objects or their functionality 
 becomes much easier because it reduces the effect of those changes on the rest of your 
 application.
  
 In this chapter, I show you a way to design, or architect, your application that limits the 
 knowledge that objects have of other objects.",NA
Getting to Know the Model-View-Control-,NA,NA
ler (MVC) Pattern,"The Cocoa framework you use on the Mac is designed around certain programming paradigms, 
 known as
  design patterns
  — a commonly used template that gives you a con-sistent way to get 
 a particular task done.
  
 Although you need to be comfortable with several design patterns in Cocoa, one of them 
 implements the kind of object encapsulation that reduces the effect of changes to an ap-plication 
 — the Model-View-Controller (MVC) design pattern. This design pattern is not unique to Cocoa 
 — a version of it has been in use since the early days of Smalltalk (which the Objective-C 
 extensions to the C language were based on). It goes a long way back, and the fact that it is still 
 being used tells you something about its value.",NA
Implementing the MVC Pattern,"Because you will eventually be providing user-interface functionality, it is time to make sure 
 that you have only model functionality (managing data, for example) in the model objects, 
 and similarly that all the model functionality is in model objects and not scattered in
  main
 . 
 That way, you can easily slide the model into place after you define the views and controllers 
 necessary for your application.
  
 Earlier, I said what made the separation between models, views, and controllers possible is a 
 well-defined interface, which I show you how to develop in this chapter. You create an interface 
 between the model and the sometime-in-the-future-to-be-developed control-ler by using a 
 technique called
  composition,
  which is a useful way to create interfaces. A composite object is 
 like a toolbox containing different objects, each of which delivers different features and 
 functionality.
  
 I’m a big fan of composition because it’s another way to hide what is really going on be-hind 
 the curtains. It keeps the objects that use the composite object ignorant of the ob-jects that 
 the composite object uses and actually makes the components ignorant of each other, 
 allowing you to switch components in and out at will.
  
 As it stands now, some user-interface type functionality is scattered throughout our model, and 
 a lot of model knowledge is in
  main
 , so I start by having you take all the user-interface 
 functionality and putting it in
  main
 . You’ll also take model functionality out of 
 main
  and create 
 a new composite object —
  Destination
  — that will be the interface to 
 main
 . You will use
  
 main
  as a surrogate for both the views and controllers that you will be adding in Chapters 17 
 and 18. Practically speaking, as you’ll see, controllers need to be more intimate with views than",NA
Get out of main,"In Listing 11-1, you can look at what goes on in
  main
  and begin to think about what 
 needs to be moved into the new
  Destination
  object.
  
 Listing 11-1: The Current main Function
  
  
 int main (int argc, const char * argv[]) {",NA
"Oh no, not factoring again!","While it may appear to you that you have spent a lot of time writing code, only to discard it, 
 that is in fact true.
  
 As I mention earlier, I need to show you both the mechanics of programming in Objective-C 
 and how to use those mechanics to create an application. This means that as you find out 
 more, you need to refine the application to use what you have discovered.
  
 In this chapter especially, you do a major factoring of your code, which you will find, when 
 developing your own applications, is an integral part of the development process.
  
  
 What comes to my mind is the following:
  
 1. Take the creation of the
  Budget
 s for each leg of my trip out of
  main
 . While the re-
 quest for a budget for a new leg of my trip comes from the user interface — hey, I want to 
 go someplace new — it shouldn’t be the user interface or controller that cre-ates those
  
 Budget
  objects. It’s not in their respective job descriptions.
  
 2. Similarly, take the creation and management of the
  Transaction
 s for each part of my 
 trip out of
  main
 . Although a user interface is definitely responsible for delivering 
 transactions to the model, managing the list of
  transaction
  objects is not something that 
 should be in a controller or view.
  
 3. If you do Steps 1 and 2, you also need to take sending the message to each
  Trans-
 action
  to apply itself to its
  Budget
  out of
  main
 .",NA
Get into main,"While you’re at it, remember that views are responsible for supplying information to the user. 
 Currently,
  Budget
  has
  NSLog
  statements that will evolve into user-interface func-tionality. 
 That functionality should be moved into
  main
  and later into a view.",NA
Creating a New Project,"Now that you have some idea of what you need to move out of
  main
 , I want you to cre-ate a 
 new object —
  Destination
  — that acts as the interface to
  main
  and that becomes the 
 composite object for each part of my trip.
  
 Up to now, you’ve been experimenting with the various features of Objective-C as you built this 
 program. Now that you know quite a bit, it is time to take a more professional attitude toward 
 this project. From this chapter on, you move away from finding out about Objective-C as a
  
 language
  and toward how to use the language you mastered to build useful
  applications.
  I 
 concentrate on architecture and the functionality you need to make your application 
 commercial quality.
  
 I show you how to design this as you would a “real” application and create a structure that 
 will actually be the basis for an application of this type, in case you want to move forward 
 with it.
  
 You start by creating a new project that will be the basis for your commercial-quality ap-
 plication (and also because the name
  Budget Object
  no longer describes what the applic-ation is 
 about). I also want you to go through creating a new project so that I can show you the 
 mechanics for reusing the classes you’ve developed thus far in a new project —something 
 you’ll likely be doing regularly.
  
 You create a new project here. You can do that, or you can skip Steps 1 through 9 (I 
 know it’s tedious, but it’s for your own good) and start with the Pro-ject in Example 11A, 
 in the Chapter 11 folder at the website. Or, if prefer to start from a clean copy of the 
 project from where you left off, you can use the project found at the website in the 
 Chapter 11 Start Here folder, which is in the Chapter 11 folder.
  
 You follow these steps to get started with the Vacation project:
  
 1. Launch Xcode.
  
 2. Start the New Project Assistant by Choosing File
 ⇒
 New
 ⇒
 Project to create a new 
 project.
  
 3. In the New Project window, click Application under the OS X heading.
  
 4. Select Command Line Tool from the choices displayed and then click Next.",NA
Creating the Destination Class,"If you have been following along with me, I extend what you just did in the first 
 exercise. If you prefer to start from a clean copy of the project from where you left off, 
 you can use the project found in the Example 11A folder, which is in the Chapter 11 
 folder.
  
 The next thing I want you to do is to add the new
  Destination
  object, as follows:
  
 1. Select the
  Classes
  group in the Project navigator.
  
 This tells Xcode to place the new file in the
  Classes
  group.
  
 2. Choose File
 ⇒
 New
 ⇒
 File (or press
 +N) to get the New File dialog.
  
 3. In the leftmost column of the dialog, select Cocoa under OS X and then select the 
 Objective-C class template in the upper-right pane. Click Next.
  
 You see a new screen asking for some more information.",NA
Designing the destination,"Enter the bold code in Listing 11-2 into the
  Destination.h
  file.
  
 Listing 11-2: Destination.h — the Destination Design
  
  
 #import <Foundation/Foundation.h>
  
 @class Budget; 
  
 @interface Destination : NSObject
  
 {
  
 NSString
  
 *country;
  
  
 NSMutableArray *transactions;
  
 Budget
  
 *theBudget;
  
 }
  
 - (void) createWithCountry: (NSString*) theCountry andBudget: 
 (double) budgetAmount withExchangeRate: (double) theExchangeRate;- 
 (void) spendCash: (double) amount;
  
 - (void) chargeCreditCard: (double) amount;
  
 - (double) leftToSpend; 
  
 @end
  
 The methods and instance variables you declared in this class will enable you to do the 
 following:
  
 1.
  createWithCountry:andBudget:withExchangeRate:
 ’s arguments will enable you 
 to initialize a new
  Destination
  with the country you are headed to (as you can see, as you 
 factor the code, I have you add additional functionality that you can use), the amount you 
 want to budget, and the current exchange rate.
  
 2. Create the
  Budget
  object previously created in
  main
 . This was the first goal in the 
 section “Get out of/into main.”",NA
Implementing the methods,"Enter the bold code in Listing 11-3 into the
  Destination.m
  file.
  
 Listing 11-3: Destination.m
  
  
 #import “Destination.h”
  
  
 #import “CashTransaction.h”
  
  
 #import “CreditCardTransaction.h”
  
  
 #import “Budget.h”
  
  
 #import “Transaction.h”
  
  
 @implementation Destination
  
  
 - (void) createWithCountry: (NSString*) theCountry andBudget:
  
  
 (double) budgetAmount withExchangeRate: (double) theExchangeRate{
  
  
 transactions = [[NSMutableArray alloc]",NA
Modifying the Budget class,"Finishing the implementation of the
  Destination
  object’s functionality as the interface to 
 the model requires that you make changes to the
  Budget
  class. Because the
  Destin-ation
  
 object is responsible for reporting to the controller the amount left to spend, it needs to get the 
 amount from the
  Budget
  object, requiring you to add a new method, 
 returnBalance
 , to
  
 Budget
 . And in line with factoring all your code to move all user-in-terface functionality out of 
 the model objects, you also need to remove the “user inter-face” from
  Budget
  — that is, the
  
 NSLog
  statements. You do all of this by following these steps:
  
 1. Delete the bold, italic, underlined code in Listing 11-4 in the
  Budget.m
  file. Then 
 add the code in bold.
  
 Listing 11-4: Budget.m
  
  
 #import “Budget.h”
  
 @implementation Budget
  
 - (void) createBudget: (double) aBudget 
  
    
 withExchangeRate: (float) anExchangeRate { 
  
  
 exchangeRate = anExchangeRate; 
  
  
 budget = aBudget; 
  
 }
  
 - (void) spendDollars: (double) dollars { 
  
  
 budget -= dollars; 
  
 //NSLog(@”Converting %.2f US dollars into foreign currency leaves 
 $%.2f”, dollars, budget); 
  
 }
  
 - (void) chargeForeignCurrency: (double) foreignCurrency { 
  
  
 exchangeTransaction = foreignCurrency*exchangeRate; 
  
  
 budget -= exchangeTransaction; 
  
 //NSLog(@”Charging %.2f in foreign currency leaves $%.2f”, for-
 eignCurrency, budget); 
  
 }
  
 - (double) returnBalance { 
  
  
 return budget; 
  
 } 
  
 @end
  
 2. Add the code in bold in Listing 11-5 to the
  Budget.h
  file.
  
 Listing 11-5: Budget.h
  
  
 #import <Foundation/Foundation.h>
  
  
 @interface Budget : NSObject {
  
 float
  
 exchangeRate;
  
  
 double budget;
  
  
 double exchangeTransaction;",NA
Removing UI type functionality from the Trans-,NA,NA
action objects,"Because you are moving all the user-interface functionality out of the model, you can de-lete 
 the
  Transaction
 ’s
  trackSpending
  message used by
  CashTransaction
  and
  Cred-
 itCardTransaction
 . You implement comparable functionality in
  main
 .
  
 Delete the bold, italic, underlined code in Listings 11-6 through 11-9.
  
 Listing 11-6: Transaction.h
  
  
 #import <Foundation/Foundation.h>
  
 @class Budget;
  
 @interface Transaction : NSObject {
  
  
 Budget *budget;
  
  
 NSNumber *amount; 
  
 }
  
 - (void) createTransaction: (double) theAmount forBudget: (Budget*) 
 aBudget;
  
 - (void) spend; 
  
 //- (void) trackSpending: (double) theAmount;
  
 @end
  
 Listing 11-7: Transaction.m
  
  
  
 #import “Transaction.h”
  
  
 #import “Budget.h”
  
  
 @implementation Transaction
  
  
 - (void) createTransaction: (double) theAmount forBudget: (Budget*)
  
  
 aBudget {
  
  
 budget = aBudget;
  
  
 amount = @( theAmount );
  
 }",NA
Coding the New main,"That leaves only
  main
 . As I said, the functionality that remains there acts as a surrogate for 
 the user interface and controller.
  
 Because the changes you need to make to
  main
  are so significant, it’s easier to delete 
 everything in
  main
  and start from scratch. So, in the
  main.m
  file, replace
  main
  with List-ing 
 11-10. (Notice that you no longer need that long list of
  #import
 s in
  main
 , shown in the 
 following code, because now its sole interface to the model is through
  Destina-tion
 .)
  
 #import “Budget.h”
  
  
 #import “Transaction.h”
  
  
 #import “CashTransaction.h”
  
  
 #import “CreditCardTransaction.h”
  
  
 Listing 11-10: The New main Function in Vacation.m",NA
"Yes, Another Two Steps Forward and One",NA,NA
Step Back,NA,NA
Chapter 12,NA,NA
The Birth of an Object,"In This Chapter
  
  
  
  
  
 Understanding how objects are created 
  
 Knowing what it means to allocate an object 
  
 Finding out the standard way to do initialization 
  
 Working with initialization and superclasses and subclasses
  
 Up until now, you have been doing initialization on an ad hoc basis, using initialization 
 methods such as these:
  
 - (void) createTransaction: (double) theAmount
  
  
 forBudget: (Budget*) aBudget;
  
  
 - (void) createBudget: (double) aBudget
  
  
 withExchangeRate: (float) anExchangeRate;
  
 A standard way exists to do initialization, however — one designed to work in a class 
 hierarchy that ensures that all the superclasses and subclasses are initialized properly.
  
 In this chapter, I show you how to implement these standard initialization methods. First, 
 though, you must allocate memory for the new object, as described in the first section of this 
 chapter.",NA
Allocating Objects,"To create an object in Objective-C, you must do the following:
  
 1. Allocate memory for the new object.
  
 2. Initialize the newly allocated memory, as described in the next section.
  
 Allocation (
 alloc
 ) starts the process of creating a new object by getting the amount of 
 memory it needs from the operating system to hold all the object’s instance variables. The
  
 alloc
  message is sent to the
  NSObject
  class, from which all the classes you are us-ing are 
 derived. But not only does the
  alloc
  method allocate the memory for the object. It also 
 initializes all the memory it allocates to 0 — all the
  int
 s are 0, all the
  float
 s be-",NA
Initializing Objects,"Initialization is not required. And if you can live with all the instance variables initialized to 0 
 and
  nil
 , you don’t need to do anything. But if your class (or your superclass) has instance 
 variables that you need to initialize to anything other than 0 or
  nil
 , you are go-ing to have to 
 code some kind of initialization method.
  
 The initialization method does not have to include an argument for every instance vari-able 
 because some will only become relevant during the course of your object’s existen-ce. You 
 must make sure, however, that all the instance variables your object needs, in-cluding objects it 
 needs to do its work, are in a state that enables your object to respond to the messages it is 
 sent.
  
 For example, right after
  
 Destination *europe = [Destination new]
  
 I had you code a method
  
 - (void) createWithCountry: (NSString*) theCountry
  
  
 andBudget: (double) budgetAmount
  
  
 withExchangeRate: (double) theExchangeRate;
  
 in which you created a budget, created a transactions array, and set the exchange rate.
  
 In fact, the
  Destination
  object you created was unusable until you did that.
  
 You may think that the main job in initialization is to, well, initialize your objects (hence, the 
 name), but more is involved when you have a superclass and a subclass chain.
  
 Start by looking at the new initializer that I have you code for the
  CashTransaction 
 class in Listing 12-1.
  
 Listing 12-1: CashTransaction Initializer
  
  
 - (id) initWithAmount: (double) theAmount forBudget: (Budget*)
  
  
 aBudget {
  
  
 if (self = [super initWithAmount:theAmount
  
  
 forBudget:aBudget]) {",NA
Invoking the superclass’s init method,"This is the general form you use:
  
 self = [super initWithAmount:theAmount
  
  
 forBudget:aBudget]
  
 If you are having a little problem figuring this out, you might like to know that it took me more 
 than a few minutes to get my arms around this statement, so don’t feel bad. For-tunately, I do 
 understand it now, and I explain it to you very slowly (which is what I wish that someone had 
 done for me).
  
 I start with the easy part of the compound statement, where all I do is invoke the super-class’s
  
 init
  method:",NA
Initializing instance variables,"Initializing instance variables, including creating the objects you need, is what you prob-ably 
 thought initialization is about. Notice that you are initializing your instance variable after your 
 superclass’s initialization, which you can see in Listings 12-1 and 12-2. Waiting until after your 
 superclass does its initialization gives you the opportunity to actually change something that 
 your superclass may have in initialization, but more important, it enables you to perform 
 initialization knowing that what you have inherited is initialized and ready to be used.
  
 In the
  CashTransaction initWithAmount:forBudget:
  initializer, all that is done is the 
 initialization of the
  name
  instance variable of the superclass (
 Transaction
 ) with the kind of 
 transaction it is:
  
 name = @”Cash”;",NA
Returning self,"In the section “Invoking the superclass’s init method,” earlier in this chapter, the
  self = 
 statement ensures that
  self
  is set to whatever object you get back from the superclass 
 initializer. After the code block that initializes the variables, you find
  
 return self;
  
 No matter what you get back from invoking the superclass initializer, in the initialization 
 method, you need to set
  self
  to that value and then return it to the invoking method. The 
 method that invokes your class’s initializer could be a method in another part of your code that 
 is creating an instance of your class. Or it could be a subclass that is it-self being initialized and 
 is invoking its superclass’s initializer to ensure that its data is ready to go when the subclass 
 object needs it.
  
 When you are instantiating a new object, it behooves you to determine whether a return of
  
 nil
  is a nonfatal response to your request (and if so, coding for it). In this book, the",NA
The Designated Initializer,"You can have more than one initializer per class. After you have more than one initial-izer in a 
 class, according to Cocoa convention, you are expected to designate one as the 
 designated 
 initializer.
  This designated initializer is usually the one that does the most ini-tialization, and
  it 
 is the one responsible for invoking the superclass’s initializer.
  Because this initializer is the one 
 that does the most work, again by convention, the other initial-izers are expected to invoke it 
 with appropriate default values as needed.
  
 While at some point you will need to explore this topic further, it is really a framework and 
 therefore beyond the scope of this book.",NA
Chapter 13,NA,NA
Getting a Handle on ,NA,NA
Memory Management,"In This Chapter
  
  
  
  
 Understanding memory management 
  
 Using Automatic Reference Counting (ARC) 
  
 Converting older projects to use ARC
  
 In Chapter 12, I explain object allocation and initialization. You start with
  alloc
  and 
 init
 . It is
  
 alloc
 , if you remember, that sets aside some memory for the object and re-turns a
  pointer
  to 
 that memory. This is important to keep in mind because the memory used by this object cannot 
 be used for any other purpose while that object is still in use by some part of your program. If 
 your computer had an infinite amount of memory avail-able for your program to use, this 
 wouldn’t be a problem. But it doesn’t, and so your pro-gram needs to manage the memory it 
 allocates — and your program must free up that memory when it’s no longer needed.
  
 Managing the memory allocated for your objects used to be one of the few real hassles in 
 programming with Objective-C. But now there’s a new feature available that removes all the 
 problems that your code could encounter by managing memory in code. Both iOS and Mac OS X 
 applications can take advantage of
  Automatic Reference Counting (ARC)
 . But a word to the wise: 
 Even if you want to program using ARC, read through this chapter anyway because it really will 
 help solidify your understanding of pointers and objects and what gets passed when you include 
 objects as arguments in messages.
  
 Memory management is not glamorous, but it trumps cool in an application. In fact, 
 memory management is probably the single most vexing thing about iOS and Mac OS X 
 programming. It has made countless programmers crazy, and I can’t stress enough how 
 important it is to build memory management into your code from the start. Take it from",NA
Raising and Terminating Responsible Ob-,NA,NA
jects,"What with everything else going on, managing memory can be a real challenge, not only to 
 someone new to programming but also to those of us with many lines of code under our belts. 
 Allocating memory when you need it isn’t that hard. It is realizing that you don’t need an object 
 anymore and then releasing the memory back to the operating sys-tem that can be a challenge. 
 If you don’t do that, and your program runs long enough, eventually you run out of memory 
 (sooner on an iOS device than a Mac for a variety of reasons — see the upcoming sidebar, “The 
 iOS challenge”) and your program will come crashing down. Long before that you may even 
 notice system performance approaching“molasses in February — outdoors in Hibbing, 
 Minnesota.” Oh, and by the way, if you do free an object (memory) and that object is still being 
 used, you have “London Bridge Is Falling Down” as well. Now, if you created a giant application 
 and run out of memory while all the objects you created are being used, that’s one issue, and 
 one I’m not going to deal with here. But if you run out of memory because you have all these 
 objects float-ing around that no one is using, that’s another thing, and it’s known as a
  memory 
 leak.
  
 Now that you’ve heard about the bad things that can happen with poor memory man-agement, 
 it’s time to talk about the things you can do to make managing your app’s memory easy. Living 
 the good life with your objects means enabling ARC for your pro-ject. ARC makes memory 
 management so easy there’s almost nothing more you need to do. There are some rules you 
 will have to follow to make sure that your code is correctly taking advantage of ARC. But 
 they’re pretty easy, and obeying them makes it easier for you to focus on the features of your 
 applications without spending time making sure that all your objects are being managed 
 properly.",NA
The iOS challenge ,"Although iOS devices and the Mac both use what is known as virtual memory, unlike the Mac, 
 virtual memory in an iOS device is limited to the actual amount of physical memory. This is 
 because when it begins to run low on memory, iOS frees memory pages that contain read-only 
 content (such as code), where all it has to do is load the “originals” into memory when they’re 
 needed. It doesn’t, like the Mac",NA
Understanding the object life cycle,"In the preceding chapter, you find out how to allocate and initialize objects by using a 
 combination of
  alloc
  and
  init
 . Many objects that you allocate stay around for the dur-ation 
 of your program, and for those objects, all you have to do is, well, nothing really. When your 
 program terminates, they are deallocated, and the memory is returned to the operating system.
  
 But some objects you use for a while to get your money’s worth, and then you’re done with 
 them. When you are done with them, you should return the memory allocated to them back to 
 the OS so that it can allocate that memory for new objects. This is the scenario that can cause 
 problems.
  
 Start by looking at how memory management works.
  
 In Objective-C 2.0 (as opposed to earlier versions), you can manage memory in two ways:
  
 Reference counting:
  You are the one responsible for doing your part in keeping 
  
  
 the system up-to-date on whether an object is currently being used.
  
 Automatic Reference Counting:
  The compiler takes all the responsibility and 
  
  
 does all the work to free up memory when it’s no longer needed.
  
 I cover reference counting first so that you understand what’s actually happening be-hind the 
 scenes. However, by using ARC, you’ll find almost no need to use reference counting in your 
 projects, unless you’re using code from a project that didn’t or couldn’t take advantage of ARC 
 when it was first created. I cover how to convert older projects to use ARC in the section 
 “Converting Non-ARC Code to ARC.”",NA
Understanding Reference Counting,"Using ARC for all the projects you start from scratch makes managing your objects’memory 
 very easy. However, there may come a time when you encounter legacy code —Objective-C 
 modules that were originally crafted before ARC. You’ll even find some of this code at the Apple 
 developer website in the Sample Code. Apple does a great job of",NA
"Managing memory, retro-style","In many ways, Objective-C is like the coolest guy in your school, who now makes a 
 seven-figure income bungee jumping and skateboarding during the summers while 
 snowboarding around the world in the winter.
  
 In other ways, though, Objective-C is like the nerd in your class who grew up to be an ac-
 countant and reads the
  Financial Times
  for fun. Memory management falls into this cat-egory.
  
 In fact, manual memory management is simply an exercise in counting. To manage its memory, 
 Objective-C (actually Cocoa) uses a technique known as
  reference counting. 
 Every object has its 
 own reference count, or
  retain count.
  When an object is created via 
 alloc
  or
  new
  — or 
 through a
  copy
  message, which creates a copy of an object, but has some subtleties beyond 
 the scope of this book — the object’s retain count is set to 1. As long as the retain count is 
 greater than 0, the memory manager assumes that someone cares about that object and leaves 
 it alone. It is your responsibility to maintain that ref-erence count by directly or indirectly 
 increasing the retain count when you are using an object, and then decreasing it when you are 
 finished with it. When the retain count goes to 0, Cocoa assumes that no one needs it anymore. 
 Cocoa automatically sends the ob-ject a
  dealloc
  message, and after that, its memory is 
 returned to the system to be re-used. As part of your responsibility for manual memory 
 management, you may need to override
  dealloc
  to release any related resources that the 
 object being deallocated might have allocated.
  
 Never invoke
  dealloc
  directly — Cocoa sends the
  dealloc
  message to your 
  
 object at the right time.
  
 Take a look at an example now. In the Vacation project’s
  main.m
 , you create a string ob-ject 
 and then pass that as an argument into the
  init
  method when you create the
  des-
 tination
  object, as shown here:
  
 NSString* englandText = [[NSString alloc]",NA
Using ARC,"You create a project to use ARC when you tell Xcode to create a new project for you. You can 
 see this in Figure 13-1, which is similar to Figure 2-20 in Chapter 2.
  
 Figure 13-1:
  ARC 
 enabled for a new 
 Xcode project.
  
  
 Every new project you create with ARC enabled takes advantage of ARC’s ability to man-age the 
 memory your code allocates. As I mention previously in this chapter, there are some rules you 
 need to obey while writing code when using ARC. These rules are",NA
Rule 1: Do not send,NA,NA
 retain,NA,NA
",",NA,NA
 release,NA,NA
", or",NA,NA
autorelease,NA,NA
 messages to your objects,"These three messages are used when applications managed reference counting on their own, 
 as described in the section “Understanding Reference Counting”. You’re really only likely to run 
 into an issue with this rule when you use code written for a pre-ARC applic-ation. But this is 
 the most important rule of the set: It’s the easiest one to follow, and it’s also the one you’re 
 most likely to come across. Each of these messages, which are inher-ited from
  NSObject
 , 
 performs a function that manages memory of objects. If your pro-ject was not using ARC, you 
 would create code that would send these messages to your objects during your application’s 
 lifetime. This form of programming requires you to manage your memory manually, rather 
 than automatically with ARC. With ARC, using these messages is not permitted — the compiler 
 marks them as errors, as you can see in Figure 13-2.
  
 Figure 13-2:
  At-
  
 tempting to send a 
  
 release
  mes-
  
 sage to an ARC-
  
 managed object.",NA
Rule 2: Do not store pointers to Objective-C ob-,NA,NA
jects in C structures (structs),"When your code creates an object, the compiler returns a pointer to that object in memory. You 
 can use this pointer just like any other, including storing it as part of a C 
 struct
  that contains a 
 member element of the pointer’s type. However, doing this when ARC is enabled would make 
 ARC’s job impossible because ARC would lose track of where the pointer is. The compiler 
 marks code that tries to do this as an error, as you can see in Figure 13-3.",NA
Rule 3: Inform the compiler about ownership,NA,NA
when using Core Foundation-type objects,"ARC does not automatically manage the memory for objects created by using the
  Core 
 Foundation framework
 . These objects have their own memory management rules and 
 functions. I don’t demonstrate any examples of these in the code I have you write in this book, 
 but you should be aware that ARC is not managing the memory of these objects if your 
 applications create them and that you have to manage these yourself, using the ap-propriate 
 Core Foundation functions.",NA
Rule 4: Use the @autoreleasepool keyword,"The
  @autoreleasepool
  keyword is a compiler directive that sets up code to handle 
 situations where memory is automatically released. In your command tool projects, Xcode 
 created initial code in
  main.m
  that looks like this:
  
 int main( int argc, const char * argv[] )
  
  
 {",NA
Rule 5: Follow the naming conventions,"When ARC is enabled, the compiler examines your code and applies some rules to de-termine 
 whether an object returned by a method has been retained. In order for you to tell the compiler 
 whether a returned object has been retained, there are several method-naming conventions 
 that the compiler understands and reviews to indicate the status of the returned object. The 
 compiler assumes that a method whose name starts with one of the following words is 
 returning a retained object:
  
 alloc
  
 copy
  
 init
  
 mutableCopy
  
 new
  
 So just avoid using any of these words as the first word in your methods’ names, and you won’t 
 break Rule 5. Okay, that won’t work all the time — you will undoubtedly cre-ate methods that 
 begin with the word
  init
 . Just be sure that the object returned by an 
 init
  method has been 
 retained — and you can be sure of this because your code should execute
  [super init]
  
 within your
  init
  method implementation, which should eventually lead to the
  init
  method 
 in the
  NSObject
  ancestor class.
  
 Last, you cannot use
  new
  as the beginning of a name of an Objective-C
  property
 . I discuss 
 properties in Chapter 14, but as an example, the following code causes an error when you try 
 to build a project using it when ARC is enabled:
  
 @interface Budget : NSObject
  
  
 @property NSDate* newYear;
  
  
 @end
  
 The error you see from the compiler contains text like this:",NA
Converting Non-ARC Code to ARC,"Now you’re ready to convert a module built to do manual memory management to work with a 
 project where ARC is enabled. You’ll come across code built like this in older sample code and 
 other examples online or in print. Luckily, Xcode makes it fairly easy to find and fix all the 
 manual memory management issues so that your non-ARC modules can work in an ARC 
 project.
  
 If you want to avoid all the typing below, you can find this project at the web-
  
 site in the Start Here folder of the Chapter 13 folder.
  
 To see how this works, follow these steps:
  
 1. Launch Xcode.
  
 2. Create a new project by selecting New
 ⇒
 Project from the File menu.
  
 3. Select Application under OS X in the left pane and Command Line Tool in the 
 right pane. Click Next.
  
 4. Enter a name for the project — I chose NonARCDemo — and deselect the Use 
 Automatic Reference Counting check box, as shown in Figure 13-4. Click Next.
  
 Figure 13-4:
  
 Turn-
  
 ing off ARC.",NA
Part IV ,NA,NA
Moving from ,NA,NA
Language to ,NA,NA
Application,NA,NA
In this part . . .,"In this part, you begin to add more functionality to your program. I introduce you to how 
 to work with data as well as more advanced ways to extend your program.
  
 After you get all the application functionality up and running, you will probably be eager to 
 make it available to the user. In this part, you fit your application into the user inter-face 
 frameworks on the Mac and iOS devices that make developing applications for them so easy 
 (well, okay, relatively easy). What will be really exciting (for me at least) is when you 
 experience how easy it is to take the application you develop and just slide it into a user 
 interface. Of course, you have to create the user interface, and I give you a crash course in 
 Interface Builder, a tool that comes with Xcode. After you’ve built an in-terface, just add a few 
 lines of code, and presto change-o, you’re running iOS and then Mac applications (the same 
 application code, I might add, with some minor user inter-face differences).
  
 The technical term for this accomplished feat is “way cool.”",NA
Chapter 14,NA,NA
Getting Data from Other ,NA,NA
Ob-jects,"In This Chapter
  
  
  
  
  
  
  
 Getting the data an object needs for another object 
  
 Understanding how declared properties work 
  
 Seeing how the compiler creates accessors 
  
 Recognizing the effect of declared properties on your program Using 
 accessors 
  
 Knowing the best way to use declared properties and accessors
  
 In Chapter 11, you factor your code to create a
  Destination
  object that manages the other 
 objects you need in your model. You see how the
  Destination
  object can use oth-er objects by 
 sending them messages. Although most of those messages are to get an ob-ject to do something 
 (
 spendDollars:
 , for example), as you see when you implement
  re-turn Balance
  in
  
 Budget
  and
  leftToSpend
  in
  Destination
 , some of these messages are about data.
  
 That data returned by those methods is stored as instance variables, but as you know, one object 
 can’t and shouldn’t access another object’s instance variables directly (hence, the need for those 
 two methods). In this chapter, I show you another way to get data from an object —
  declared 
 properties
  — and I also tell you about some things you need to handle with care.",NA
Getting Data from Objects,"As I refine the Vacation application, I need to start thinking more about the practical as-pects 
 of using this application, especially as I march down the road toward putting on a user 
 interface.",NA
Working with Declared Properties,"As you soon discover, you will use declared properties a lot (most people just call them 
 properties
 ). If you need to have an instance variable accessible by other objects in your 
 program, you need to create accessor methods for that particular instance variable.
  
 Accessor methods effectively get (using a
  getter method
 ) and set (using a
  setter method
 ) the 
 values for an instance variable. For many years, programmers had to code these methods 
 themselves or buy add-on tools that would do it for them (usually advertised late at night on 
 the Programmers Channel). The nice folks in charge of Objective-C came to our collective 
 rescue when they released Objective-C 2.0 with its
  declared properties 
 feature. Now the 
 compiler can write access methods for you, according to the direction you give it in the
  
 property declaration
 . Kind of like getting the smartest kid in your class to do your homework 
 while you hang out with your friends at the malt shoppe.
  
 Objective-C creates the getter and setter methods for you by using a
  @property
  declara-tion 
 in the interface file. The default names for the getter and setter methods associated with a 
 property are
  whateverThePropertyNameIs
  for the getter (yes, the default getter method 
 name is the same as the property’s name) and
  set
 WhateverTheProper-tyNameIs
 :
  for the 
 setter. (You replace what is in italic with the actual property name or identifier.) For example, 
 the accessors that are generated for the
  exchangeRate
  instance variable are
  
 exchangeRate
  as the getter and
  setExchangeRate:
  as the setter.",NA
Adding properties,"If you have been following along with me, I extend what you did in Chapter 12. If you 
 prefer to start from a clean copy of the project from where you left off, you can use the 
 project found in the Chapter 14 Start Here folder, which is in the Chapter 14 folder.
  
 To declare some properties for the
  Destination
  class, add the code in bold, and re-
 move the bold, italic, underlined code in Listing 14-1 to
  Destination.h
 .
  
 Listing 14-1: Adding Properties to the Destination Class",NA
Implementing declared properties,"At the end of the day, you need to do only one thing in your code for the compiler to cre-ate 
 accessors: Declare an instance variable in the interface file as an
  @property
 .
  
 This is straightforward, but there are a couple of interesting parts to the
  @property
  de-
 claration, and so I explain them here.
  
 The declaration specifies the name and type of the property and some
  attributes
  that provide 
 the compiler with information about exactly how you want the accessor meth-ods to be 
 implemented.",NA
Strong and weak properties ,"One memory management challenge happens when each of two objects contains a reference to 
 the other. ARC runs into difficulty when it comes time to free up the memory of these two 
 objects because trying to free up the memory for object A causes it to check whether any other 
 object still has a refer-ence to it — which will be object B. And when ARC tries to free up the 
 memory of object B, it finds that object A still has a reference to it. Each object can be recycled 
 only when the other is. So ARC depends on you to give it a hint about which reference is more 
 important than the other by using the attributes
  strong
  and
  weak
  for your properties 
 (
 strong
  is used by default). If object A maintains a",NA
Accessing the instance variables from within the,NA,NA
class,"After you declare the properties, you can access them from other objects or from
  main
 . But 
 before I show you that, I want to show you about accessing them within the class.
  
 You can use the getter and setter accessors within your code. Objective-C follows a simple 
 pattern for naming the accessors it creates for your properties. For instance, for the property 
 named
  country
 , the getter is
  
 NSString* myCountry = [self country];
  
 For the same property, the setter is
  
 [self setCountry:aCountry];
  
 You also can use the dot notation (which refugees from other object-oriented languages will 
 recognize):
  
 NSString* aCountry = self.country;
  
  
 self.country = aCountry;
  
 Now, I want you to update
  Destination.m
  to use properties by deleting the bold, italic, 
 underlined code in Listing 14-2 and adding the code in bold.
  
 Listing 14-2: Using Accessors within the Destination Class
  
  
 #import “Destination.h”
  
  
 #import “CashTransaction.h”
  
  
 #import “CreditCardTransaction.h”
  
  
 #import “Budget.h”
  
  
 #import “Transaction.h”
  
  
 @implementation Destination",NA
Using Accessors to Get Data from Objects,"Now that you have created these accessors, you can use them. You will have to make some 
 changes to
  Budget.m
  and
  Budget.h
 . These are shown in Listings 14-3 and 14-4. Use the 
 following steps to make the
  Budget
  class meet the expectations of the
  Destina-tion
  class:
  
 1. Start by deleting the bold, italic, underlined code in Listing 14-3 and adding the 
 code in bold to
  Budget.m
 .
  
 Listing 14-3: Budget.m
  
  
 #import “Budget.h”
  
 #import “Destination.h”
  
 @implementation Budget 
  
 //- (id) initWithAmount: (double) aBudget withExchangeRate: 
 (double) anExchangeRate {
  
 //
  
  
 //
  
 if (self = [super init]) {
  
 //
  
 exchangeRate = anExchangeRate;
  
 //
  
 budget = aBudget;
  
 //
  
 }
  
 //
  
 return self;
  
 //}
  
 - (id) initWithAmount: (double) aBudget forDestination: (Destina-
 tion*) aDestination { 
  
  
 if (self = [super init]) { 
  
   
 self.destination = aDestination; 
  
   
 budget = aBudget; 
  
  
 } 
  
  
 return self; 
  
 }
  
 - (void) spendDollars: (double) dollars { 
  
  
 budget -= dollars; 
  
 }
  
 - (void) chargeForeignCurrency: (double) foreignCurrency { 
  
 //exchangeTransaction = foreignCurrency*exchangeRate; 
  
  
 exchangeTransaction = foreignCurrency* 
  
    
  
 [self.destination exchangeRate]; 
  
  
 budget -= transaction; 
  
 }
  
 - (double) returnBalance {
  
 return budget; 
  
 }
  
 @end",NA
Properly Using Properties,"What you just did with the exchange rate and country data in the
  Destination
  object may 
 seem, well, a bit pointless to you. If the point of object-oriented programming is to 
 encapsulate data, what difference does it really make whether you allow direct data ac-cess or 
 whether you force the user of the data to send a message and the supplier to code the",NA
Chapter 15,NA,NA
Show Me the Data,"In This Chapter
  
  
  
  
  
 Creating and using property lists 
  
 Seeing how dictionaries work 
  
 Updating dictionaries and plists 
  
 Having a property list object (array) write itself to a file
  
 In Chapter 1, I explain that a computer program is a set of instructions that perform oper-ations 
 on data. Although this is what you have been steadily doing since Chapter 1 —coding statements 
 that operate on data — all the data you have been working with so far has been “hard-coded” 
 into the program.
  
 After you put on the user interface, of course, that will change. The user will be entering 
 transactions, and you will be processing them, and probably storing both the transac-tions and 
 the results as well. For example, you’ll want to save all the credit card transac-tions to reconcile 
 them against your statement when you get home, and you definitely want the ability to store 
 what’s left of your budget after a series of transactions so that every time you restart the 
 program, you don’t start with your original budget (well, it would be nice if you could do that, 
 but I guess that’s not realistic).
  
 In this chapter, I show you how to store what’s left of your budget after a series of trans-actions 
 to a file, and then read that file when the application starts up again. This illus-trates some of the 
 ways you can save data. But before I show you that, I want to make you aware of another kind of 
 data that you need for your program:
  application-based data.",NA
Understanding Application-Based Data,"As I look at my program, I think it would be nice to be able to display the euro symbol (€) when 
 I display a euro-based credit card transaction and the pound symbol (£) when I dis-play a 
 pound-based one.
  
 Although I could “hard-code” those symbols in my program, doing so doesn’t give me much 
 flexibility. Either I have to build some kind of array into my program for the cur-rency symbols 
 of the places I might go (and “waste” the CPU cycles and memory to build",NA
Defining property lists,"Applications and other system software on OS X and iOS use property lists extensively. For 
 example, the Mac OS X Finder stores file and directory attributes in a property list, and iOS uses 
 them for user defaults. You also get a property list editor with Xcode, which makes property list 
 files (or
  plists
  as they are referred to) easy to create and main-tain in your own programs.
  
 Figure 15-1 shows the property list I show you how to build, one that will enable you to add 
 the euro and pound symbols to your application.
  
 Figure 15-1:
  
 Ap-pData
  
 property list.",NA
Working with property lists,"Property lists are perfect for storing small amounts of data that consist primarily of strings and 
 numbers. What adds to their appeal is the ability to easily read them into your programs, use 
 or even modify the data, and then write them back out again. That’s because Cocoa provides a 
 small set of objects that have that behavior built in.
  
 The technical term for these objects is
  serializable.
  A serializable object can convert 
 itself into a stream of bytes so that it can be stored in a file and can then reconstitute 
 itself into the object it once was when it is read back in — yes “beam me up, Scotty” does 
 exist, at least on your computer.
  
 These objects, called
  property list objects,
  that you have to work with are as follows:
  
 NSData
  and
  NSMutableData
  
 NSDate
  
 NSNumber
  
 NSString
  and
  NSMutableString
  
 NSArray
  and
  NSMutableArray
  
 NSDictionary
  and
  NSMutableDictionary
  
 As you can see in the plist in Figure 15-1, the property list contains two strings, one each for 
 the Europe and England currency symbols. The property list itself is a dictionary cre-ated for 
 you automatically by Xcode.
  
 Property lists contain two kinds of property list objects:
  
 Primitives:
  The term
  primitives
  is not a reflection on how civilized these property 
 objects are, but it is a word used to describe the simplest kind of object. They are what 
 they are.
  
 Containers:
  Containers can hold primitives as well as other containers.",NA
Using Dictionaries,"Dictionaries are like the city cousins of arrays. They both pretty much do the same 
 things, but dictionaries add a new level of sophistication.
  
 I love dictionaries, now. But I have to admit that when I started programming with Objective-C 
 and Cocoa, trying to get my head around the idea of dictionaries was a real challenge — not 
 because dictionaries are hard; they really aren’t. The “problem” was be-cause of what you can 
 do with them. Not only will you use them to hold property list ob-jects, but you’ll also use them 
 to hold application objects — just as you did with the ar-ray that holds
  Transaction
  objects.
  
 So, now, I take you through them slowly and with lots of illustrations.",NA
Understanding a dictionary’s keys and values,NA,NA
Creating a dictionary,NA,NA
Adding a plist to Your Project,"Although I’m sure you found that explanation of dictionaries fascinating, I still haven’t shown 
 you how to use a file instead of having to create the dictionary in your program. If you use a 
 file, you can use Xcode’s handy editor (which I show you in a moment) to add new currencies 
 and countries as you develop your program.
  
 If you have been following along with me, note that I extend what you did in 
 Chapter 14. If you want to start from a clean copy of the project, you can use the 
 project found in the Chapter 15 Start Here folder at the website.
  
 Create a plist for your program by following these steps:
  
 1. In the Project navigator (at the left in the Xcode Project window), select Vacation (at 
 the top of the pane) and then choose File
 ⇒
 New File or press
 +N.
  
 The New File dialog appears.
  
 2. Choose Resource under the OS X heading in the left pane and then select Prop-erty 
 List, as shown in Figure 15-3.",NA
Using plists,"The only file you work with in this chapter is
  main.m
 . So start by making the following 
 changes to use the plist.
  
 In
  main
  in
  main.m
 , add the code to
  main
  in bold and delete the bold, italic, underlined 
 code in Listing 15-1.
  
 Listing 15-1: Using plists
  
  
 #import <Foundation/Foundation.h>
  
  
 #import “Destination.h”
  
  
 int main (int argc, const char * argv[]) {
  
  
 @autoreleasepool {",NA
Creating a mutable dictionary,"Next you create a mutable dictionary and read the file into it, using the
  initWithCon-
 tentsOfFile:
  method (it needs to be mutable because I show you how to modify it in the 
 section “Updating the dictionary,” later in this chapter):
  
 NSMutableDictionary *appDictionary = 
  
 [[NSMutableDictionary alloc]
  
 initWithContent-
  
  
 sOfFile:appDataPath];
  
 You specified where the file was located (
 appDataPath
 ) and then sent a message to the 
 NSMutableDictionary
  to initialize itself with that file.
  
 NSDictionary
 ,
  NSMutableDictionary
 ,
  NSArray
 , and
  NSMutable Array
  all 
 have the methods
  initWithContentsOfFile:
  and
  writeToFile:atomically: 
 that read themselves in from a file and write themselves out to a file, respectively. This 
 is one of the things that makes property list objects so useful.
  
 As I mention earlier, property list containers, and only property list contain-ers, 
 can read themselves in from and write themselves out to a file. The other property list 
 objects can only store themselves, without any effort on your part, as part of a file.",NA
"Creating, initializing, and using the symbol string","The next thing you do is access the key Europe and create and initialize a string 
 europeSymbol
  with its value. I do the same thing for England and
  englandSymbol
 :
  
 NSString* europeSymbol = [[NSString alloc] initWithFormat: @”%@”,
  
  
 appDictionary[@”Europe”]];",NA
Dictionaries of Dictionaries,"Although using a plist and dictionary this way is very clever (at least I think so), it just barely 
 shows what you can do with dictionaries — especially considering what you see as you look at 
 some of the code in the frameworks. In that spirit, I make things a little more interesting.",NA
Creating a more complex plist,"You can continue working based on what you have done or use the project at the 
 website in the Example 15A folder, which is in the Chapter 15 folder, as your base.
  
 Follow these steps to delete all the entries in the plist and create a more interesting plist:
  
 1. Delete the Europe and England entries from your plist.
  
 That takes you back to what was shown earlier in Figure 15-4. You have no entries.
  
 2. In the Editor window, select the Root item and choose Editor
 ⇒
 Add Item (or Control-
 click in the window and select Add Row), as you did in Step 5 in the earlier section, 
 “Adding a plist to Your Project” (refer to Figure 15-4).
  
 A new entry appears.
  
 3. Click the pop-up menu arrows to select Dictionary for the type of entry you want 
 instead of String, again, as you did in Step 6 in the section “Adding a plist to Your 
 Project.”",NA
Managing a dictionary of dictionaries,NA,NA
Modifying the plist,NA,NA
Adding a new entry to the plist,"To save the budget data, you start by declaring two variables to hold the budget bal-ances 
 for
  Europe
  and
  England
 :
  
 double europeBudget = 1000;
  
  
 double englandBudget = 2000;
  
 Checking to see whether the dictionary is there
  
 You have to initialize these variables because the first time you run the program, you will have 
 no
  Budgets
  key and corresponding dictionary in the
  AppData
  plist. This gives you a place to 
 start.
  
 Just as I did with the value for the
  Europe
  and
  England
  keys, I take the value of the 
 Budgets
  key and assign it to a pointer to that dictionary:
  
 NSMutableDictionary* budgetsDictionary = appDictionary[@”Budgets”];",NA
Updating the dictionary,"Every time you run your program, you save what’s left of your budget by using
  setOb-
 ject:forKey:
 . If you use
  setObject:forKey:
  on a key that’s already there, it replaces 
 the old value with the new one. (If you want to take a key out of a mutable dictionary, use the
  
 removeObjectForKey:
  method.) Remember, these methods work only for 
 NSMutableDictionary
  objects.
  
 First you create the
  europeBalance
  and
  englandBalance
  as objects:
  
 NSNumber* europeBalance = @( [europe leftToSpend] );
  
  
 NSNumber* englandBalance = @( [england leftToSpend] );
  
 Now that you have
  europeBalance
  and
  englandBalance
  as objects, you update the 
 dictionary you created earlier when you read in the plist:
  
 budgetsDictionary[@”Europe”] = europeBalance;
  
  
 budgetsDictionary[@”England”] = englandBalance;
  
 You use the bracket notation (
 []
 ) once again, only this time in reverse: You are assign-ing
  
 europeBalance
  as an object in the
  budgetsDictionary
  with the key
  @”Europe”
 .
  
 You could also write the same code as follows:
  
 [budgetsDictionary setObject:europeBalance forKey: @”Europe”];
  
  
 [budgetsDictionary setObject:englandBalance forKey: @”England”];
  
 Now for the exciting part. After you update the
  Budgets
  dictionary, you write the whole file 
 back to the plist file by using the path you defined earlier (
 appDataPath
 ):
  
 [appDictionary writeToFile:appDataPath atomically:YES];",NA
Saving Data in a Separate File,"Of course, a dictionary is just another property list object, and so is an array. So instead of 
 adding the new
  Budgets
  dictionary to the
  AppData
  plist, I show you how to save the budget 
 data in an array.
  
 You declare the array you are going to save and initialize it to
  nil
 :
  
 NSArray* tripBalance = nil;
  
 You add a new file here, so you need to create a new path for the file you want to save:
  
 NSString* balancePath =@”/Users/Karl/Desktop/Example 15D/Balan-
  
  
 ceData.txt”;
  
 Notice that the filename will be
  BalanceData.txt
 , and it will be in the 
 Example 15D folder. As with
  appData
 , you will change the path every time you 
 change the location or the name of the folder your project is in.
  
 You start again by reading in the data. Reading in the array you saved is similar to read-ing in 
 the plist:
  
 if ([[NSFileManager defaultManager] fileExistsAtPath: balan-
  
  
 cePath]) {
  
 First, you ask the file manager (
 [NSFileManager defaultManager]
 ) to check whether the 
 file is there. Previously, you knew the plist was there; you just weren’t sure that the 
 Budgets
  
 entry had been added. If this is the first time you are running the program, the file won’t be 
 there. Alternatively, you could have just read in the file and checked for 
 nil
 .
  
 If the file is there, you read in the array by using its
  initWithContentsOfFile:
  (just as I 
 did with the plist) and copying the values in the array to the
  europeBudget
  and 
 englandBudget
  variables as you did before:
  
 tripBalance = [[NSArray alloc]
  
  
 initWithContentsOfFile:balancePath];
  
  
 europeBudget = [tripBalance[0] doubleValue];
  
  
 englandBudget = [tripBalance[1] doubleValue];
  
  
 }",NA
Saving Objects as Objects,"This chapter shows you a great way to start saving your data, but you have other ways as well.
  
 As you develop applications, you will find that not all your objects are made up of prop-erty 
 list objects. Even in this simple application, your
  Destination
  object has an array of
  
 Transaction
  objects.
  
 Although most objects can eventually be deconstructed into property list objects, this can take 
 a lot of work and requires changing the logic you use if you add or remove something from an 
 object — not very extensible is it?
  
 Cocoa does, however, provide several ways to save objects as objects. I leave this, too, as an 
 exercise for you to do on your own.",NA
Chapter 16,NA,NA
Extending the Behavior of ,NA,NA
Ob-jects,"In This Chapter
  
  
  
  
 Using delegation to implement a new transaction 
 Defining formal and informal protocols 
  
 Using categories to extend a class
  
 In your application so far, you have two kinds of transaction objects, a
  CashTransaction 
 and 
 a
  CreditCardTransaction
 . As I was field-testing the application, sitting in a bar (bars in Italy 
 serve coffee, so don’t get too excited) on the Grand Canal in Venice, I needed some euros, so I 
 went to the ATM.
  
 It dawned on me that because this was not my own bank’s ATM, I might have to pay a $2 
 transaction fee. I realized I need to add a new type of transaction — ATM.
  
 In Chapter 10, you find out how to use inheritance to create subclasses such as 
  
 CashTransaction
  and
  CreditCardTransaction
  to
  implement subclass–specific function-
 ality
 , whose default implementation was defined by a superclass, such as the spend func-
 tionality in the
  Transaction
  class. I also mention that you could also use inheritance to add 
 new functionality, new methods, and new instance variables to a subclass.
  
 So it makes sense to use inheritance to create a new subclass. If I did that it would also mean, 
 thanks to polymorphism, that the only changes I would have to make to my pro-gram, besides 
 defining the new class, would be to add a new method to
  Destination
  (in addition to the 
 existing
  spendCash:
  and
  chargeCreditCard:
  methods) —
  useATM:
  to create the new 
 ATM transaction.
  
 As you start to work with the
  UIKit
  and
  AppKit
  frameworks, you will be using inherit-ance to 
 extend the behavior of framework classes and to add your own unique applica-tion behavior. But 
 sometimes, for some technical or architectural reason, inheritance will not be an option. But all is 
 not lost. Objective-C allows you to accomplish virtually the same thing by using
  delegation,
  which 
 enables you to implement methods defined by oth-er classes, and
  categories,
  which enable you to 
 extend the behavior of a class without subclassing.",NA
Understanding Delegation,"I start by showing you how to use delegation to create a class that implements the 
 spend
  
 method of the
  Transaction
  (the
  delegator
 ) class, one that behaves in the same way as a 
 subclass.
  
 Delegation
  is a pattern (I explain patterns in Chapter 11) used extensively in the
  UIKit 
 and
  
 AppKit
  frameworks to customize the behavior of an object without subclassing. In-stead, one 
 object (a framework object) delegates the task of implementing one of its methods to another 
 object.
  
 To implement a delegated method, you put the code for the behavior your application requires 
 into a separate (
 delegate
 ) object. When a request is made of the delegator, the delegate’s 
 method that implements the application-specific behavior is invoked by the delegator.
  
 The methods a class delegates are defined in a
  protocol
  — similar to the “
 spend:
  pro-tocol” 
 that you define in the
  Transaction
  class in Chapter 10. Protocols can be
  formal 
 or
  
 informal.
  I start with formal protocols and then work my way into informal ones.",NA
Using Protocols,NA,NA
Declaring a protocol,"You declare formal protocols with the
  @protocol
  directive. If you want to create a 
 TransactionDelegate
  protocol that required that its delegates implement a
  spend 
 message (like its subclasses), you code the following:
  
 @protocol TransactionDelegate
  
  
 @required
  
  
 - (void) spend: (Transaction *) aTransaction;
  
  
 @optional
  
  
 - (void) transaction: (Transaction *) transaction spend: (double)
  
  
 amount;
  
  
 @end
  
 Methods can be optional or required. If you do not mark a method as optional, it is as-sumed to 
 be required; but you can make that designation specific via the use of the
  @re-quired
  
 keyword.
  
 I declared the
  TransactionDelegate
  protocol with a required method —
  spend:
  —
 and an optional method,
  transaction:spend:
 .
  
 The more formal representation is
  
 @protocol
  ProtocolName
  
  
 method declarations
  
  
 @end",NA
Creating a protocol,"You start with defining the protocol because that’s the easiest step. You won’t affect the classes 
 currently in your project; you’re just adding something that will be used farther ahead.
  
 If you have been following along with me, I now extend what you did in Chapter 15. 
 If you want to start from a clean copy, you can use the project at the website in the 
 Chapter 16 Start Here folder.
  
 To create the
  TransactionDelegate
  protocol, here’s what you do:
  
 1. Select the
  Classes
  group in the Project navigator and then choose File
 ⇒
 New File
  
 (or press
 +N) to get the New File dialog.
  
 2. In the leftmost column of the dialog, first select Cocoa under Mac OS X; then se-lect 
 the Objective-C protocol in the upper-right pane, as shown in Figure 16-1. Click Next.
  
 Figure 16-1:
  
 The 
  
 Objective-C pro-
  
 tocol template.",NA
Adding delegation to Transaction,"So far, you have created a protocol that defines how a protocol for the
  Transaction 
 class 
 should act to handle the
  spend:
  method. It now becomes the responsibility of the delegator,
  
 Transaction
 , to invoke the
  spend:
  method in its delegate. Here’s how you do that in
  
 Transaction
 :
  
 1. Remove the bold, italic, underlined code and add the code in bold to the
  Trans-
 action.h
  file.
  
 #import <Foundation/Foundation.h>
  
 #import “TransactionDelegate.h”
  
 @class Budget; 
  
 @interface Transaction : NSObject {
  
 //Budget *budget;
  
  
 //NSNumber *amount;
  
  
 NSString *name; 
  
 }
  
 - (id) initWithAmount: (double) theAmount forBudget: (Budget*) 
 aBudget;
  
 - (void) spend; 
  
 @property (nonatomic) Budget *budget; 
  
 @property (nonatomic) id<TransactionDelegate> delegate; 
  
 @property (nonatomic,readwrite) NSNumber *amount; 
  
 @end
  
 You did several things here:
  
 a. Added the instance variable
  delegate
 . This is the object that implements the 
 behavior you specified in the protocol. This object is declared as
  id<Transac-
 tionDelegate>
  so that the compiler knows to expect that the object implements the
  
 TransactionDelegate
  protocol and so that Xcode can let you know when you try to 
 assign an object that doesn’t implement it.
  
 b. Removed the budget and amount instance variables. These are being re-cre-ated 
 as properties.
  
 c. Added three properties: one to be able to set the
  delegate
  and two others to 
 allow the delegate access to the
  amount
  and
  budget
  instance variables. Doing this 
 means that you have to change the code in
  CashTransaction.m
  and
  Cred-
 itCardTransaction.m
 , but the change is pretty easy and you can take care of that 
 after you change
  Transaction.m
 .
  
 2. Remove the bold, italic, underlined code and add the code in bold to the
  Trans-
 action.m
  file.
  
 #import “Transaction.h”
  
  
 #import “Budget.h”",NA
Adopting a protocol,"Adopting a protocol is similar in some ways to declaring a superclass. In both cases, you are 
 adding methods to your class. When you use a superclass, you are adding inherited methods; 
 when you use a protocol, you are adding methods declared in the protocol list. A class adopts a 
 formal protocol by listing the protocol within angle brackets after the superclass name:
  
 @interface ClassName : ItsSuperclass < protocol list >
  
 A class can adopt more than one protocol, and if so, names in the protocol list are separ-ated by 
 commas:
  
 @interface Translator : NSObject < English, Italian >
  
 Just as with any other class, you can add instance variables, properties, and even non-
 protocol methods to a class that adopts a protocol.
  
 In the code that follows, you create a new class,
  ATMTransactionDelegate
 , that adopts the
  
 TransactionDelegate
  protocol, which you created a few moments ago.
  
 Use the following steps to add a class —
  ATMTransactionDelegate
  — that will adopt the
  
 TransactionDelegate
  protocol to your project:",NA
Categories,"To complete the implementation of the ATM transaction, you need to add a method to 
 Destination
  to process an ATM transaction just as it does cash and credit cards. The 
 preferred approach is to add the new method to the
  Destination
  class or add a new 
 method to a subclass (you’d have to add a subclass if you did have the source code, as is the 
 case with a framework), but instead I want to show you another Objective-C fea-ture.",NA
Using categories,"You can use categories in the following ways:
  
 To extend classes defined by other implementers (instead of subclassing — this is
  
 what you just did for
  Destination
 ).
  
 To declare informal protocols — I told you I’d get back to this. You have come full
  
 circle here, so I examine informal protocols.",NA
Defining informal protocols,"In addition to formal protocols, you can also define an informal protocol by grouping the
  
 methods in a category declaration:
  
 @interface Transaction (TransactionDelegate)
  
  
 - (void) spend;
  
  
 @end
  
 In fact, if you added the preceding code to the
  Transaction.h
  file and changed the
  
 ATMTransactionDelegate.h
  as follows
  
 @interface ATMTransactionDelegate : NSObject/* <TransactionDeleg-
  
  
 ate> */
  
 your program would work the same way.
  
 Being informal, protocols declared in categories don’t receive much language support.
  
 You get no type checking at compile time, for example.
  
 An informal protocol may be useful when all the methods are optional, such as for a del-
  
 egate, but it is typically better to use a formal protocol with optional methods.",NA
Chapter 17,NA,NA
Adding an iPhone User ,NA,NA
Inter-face,"In This Chapter
  
  
  
  
  
  
 Painlessly putting a user interface on the model 
 Creating a user interface with Interface Builder Adding 
 controls to the view 
  
 Creating a view controller 
  
 Launching the application in the iPhone Simulator
  
 I’ve been promising you all along, at least since Chapter 11, that if you create the right class 
 structure, putting on a user interface will be easy. As you see, I wasn’t exaggerating when I said 
 that. The only challenge will be actually finding out how to create a user inter-face on the iPhone 
 in this chapter and on the Mac in Chapter 18. To do that, you need to know the basics of a 
 program called Interface Builder (part of Xcode), which you use to build the user interface.
  
 Along the way, I also tie together a number of the concepts I talk about that relate to cre-ating 
 enhanceable and extensible applications. Frameworks, as I say again and again, are the poster 
 children for enhanceability and extensibility, and now you finally get to see why. They are 
 created to be reused, so you can integrate techniques that the framework builders use into your 
 own programs. The frameworks are also created to be extended, so that you can go beyond what 
 the framework builders intended and add in your own creative enhancements to make your 
 applications different from every other app by using the frameworks.
  
 When you are done with this chapter and Chapter 18, though, you will have discovered 
 something about developing iPhone and Mac OS X applications: You need to find out more about 
 both. So, I suggest you get copies of
  iPhone Application Development For Dummies,
  4th Edition
 ,
  by 
 Neal Goldstein, and
  Mac Application Development For Dummies, 
 by Karl Kowalski (both published 
 by John Wiley & Sons, Inc.).",NA
Creating Your Project,"To develop an iPhone application, you work in an Xcode project — just as you have done 
 so far. The only difference is that this time you are creating an iPhone project.
  
 So let’s get started. Follow these instructions to create an iPhone application Xcode pro-ject:
  
 1. Launch Xcode if it is not already running.
  
 2. Choose File
 ⇒
 New Project to create a new project, or press Shift+
 +N.
  
 3. In the New Project window (see Figure 17-1), click Application under the iOS 
 heading.
  
 Just as before, when you select a template, a brief description of the template is dis-played 
 underneath the main pane. As you know, each of these choices is actually a template that 
 generates some code. In the past, when you were using the Founda-tion Command Line 
 Tool, that code was minimal. Now, however, you are going to see a lot more.
  
 Figure 17-1:
  
 The 
  
 New Project 
  
 Assistant.",NA
Using Interface Builder to Create a User,NA,NA
Interface,Here’s how to use Interface Builder to create a user interface:,NA
XIB Files ,"Interface Builder was originally developed at NeXT Computer, and the files it created were 
 called
  nib 
 files, from NeXT Interface Builder. A nib file is a special type of resource file that you 
 use to store the iOS user interface you create with the Interface Builder editor. Originally, a nib 
 file contained binary data — all 1s and 0s — which was rather difficult to read (for humans).
  xib
  
 files are XML versions of the original nib files, and these are the user-interface resource files 
 that the Interface Builder editor uses to store all the information about the user interfaces you 
 create for your applications. However, stored deep inside your finished application is a nib file, a 
 compiled version of the xib file you create and edit with Interface Builder.
  
  
  
 3. Click the Hide or show the Utilities button or press
  
 +Option+0 (zero).",NA
Implementing the User Interface,"As I promise earlier, the coding you have to do to hook up the user interface is minimal.
  
 In this section, I extend what you did in Chapter 16. If you want to start from a clean 
 copy of the project from where you left off, you can use the project found at the website 
 in the Chapter 17 Start Here folder, which is in the Chapter 17 folder.
  
 The first thing you have to do is copy all the classes in the
  Classes
  folder in the Groups & 
 Files list in the Vacation project (from Chapter 16) into the iVacation project. I show you how to 
 do that in Chapter 11 — you can see how to do that in Figure 17-15.
  
 Figure 17-15:
  
 Copy the classes 
 to the new 
 project.
  
  
  
 Be sure to select the Copy Items into Destination Group’s Folder check box,
  
 and make certain that the check box for iVacation is selected in the Add to Targets 
 section when the Copy dialog pops up.
  
 I also could have chosen Project
 ⇒
 Add to Project or pressed
 +Option+A, navigated to the 
 Vacation project folder, and selected the classes I wanted to add.",NA
Adding outlets,"Here is how you connect your visual interface with the ViewController code:
  
 1. In the Project navigator pane, select iVacationViewController.xib to open Inter-
 face Builder.
  
 2. Click the Show the Assistant Editor button and resize the Project window so that 
 you can see the full iPhone screen, as shown in Figure 17-19.
  
 The Assistant Editor is going to help you make connections between elements in your 
 user interface — the
  .xib
  file — and the Objective-C header and source files for the
  
 iVacationViewController
 . The Assistant Editor has opened the
  iVaca-
 tionViewController.h
  file in a separate editor.
  
 Figure 17-19:
  
 The Assistant 
 Editor.",NA
@synthesize ,"In
  iVacationViewController.m
 , you will notice that the Assistant Editor has also added 
 two dir-ectives that look like this:
  
 @synthesize transactionField;
  
 @synthesize balanceField;
  
 These directives tell the compiler to
  synthesize
  the getter and setter methods for the two 
 properties that were added to
  iVacationViewController.h
 . Xcode no longer requires the 
 presence of the 
 @synthesize
  directive, but the Assistant Editor still puts these into the 
 implementation file. Your code will still build and run correctly, with or without them.
  
  
 The Assistant Editor has added two
  @property
  instance variables to
  iVaca-
  
 tionViewController.h
 , one for each of the outlets you just connected. The outlets are 
 automatically initialized with a pointer to the text field (
 transactionField
 ) and label 
 (
 balanceField
 ) objects when the application is launched and the view is displayed.
  
 The Assistant Editor added these two outlets to your code like this:
  
 @property (
 strong
 , nonatomic) IBOutlet UITextField *transac-
  
  
 tionField;
  
  
 @property (
 strong
 , nonatomic) IBOutlet UILabel *balanceField;
  
 IBOutlet
  is a keyword that is recognized by Interface Builder when it comes time to connect 
 the user interface elements added to the
  .xib
  with the code elements that your app’s code 
 needs to work with. If you continue to use the Assistant Editor when con-necting your user 
 interface to your code, you don’t need to think about
  IBOutlet
 s.
  
 Next, you’re going to connect the buttons to methods in
  iVacationViewController
  so that 
 the methods are executed when the user clicks the buttons.",NA
Connecting Targets with Actions,"If you have a button in your interface, you need to add a method to your code to handle those 
 times when somebody decides to actually tap the button. You do this much like you did when 
 you added the Text Field and Label as outlets, using the Assistant Editor:
  
 1. Select
  iVacationViewController.xib
  to open the Interface Builder if it’s not 
 already on display. Click the Show the Assistant Editor button.
  
 2. Click and Control-drag from the Cash button into the Assistant Editor, right 
 above the
  @end
  statement, as shown in Figure 17-22.
  
 Xcode displays the connection dialog again, this time for the Cash button.
  
 Figure 17-22: 
  
 Creating a Target-
 Action connection.
  
  
 3. Select Action from the Connection drop menu, and enter
  spendDollars
  in the 
 Name field, as shown in Figure 17-23. Then click Connect.
  
 Figure 17-23:
  
 Edit-
  
 ing a Target-Action 
  
 Connection.",NA
Adding the methods,"Now that you are finished with the interface specifications, it is time to implement the code.
  
 Okay, you declared the method. The next thing for you to do is actually add the 
 spendDollars:
  and
  chargeCreditCard:
  methods to the implementation file,
  iVaca-
 tionViewController.m
 . Follow these steps:
  
 1. Go back to the
  Classes
  folder in the Project navigator and select iVaca-
 tionViewController.m — the implementation file for
  iVacation ViewController
 .
  
 You can also hide the Assistant Editor by clicking the Show the Standard Editor but-ton, to 
 give you more space.
  
 2. Look for the following lines of code in the implementation file:
  
 #import “iVacationViewController.h”
  
  
 @implementation iVacationViewController
  
 3. Add the following after
  #import “iVacationViewController.h”
 :
  
 #import “Destination.h”
  
 4. Add the following bold lines to the
  spendDollars:
  method:
  
 - (IBAction)spendDollars:(id)sender{",NA
Running iVacation in the Simulator,"Your iVacation app is now ready to run. You created the user interface, connected the 
 buttons and the Label and the Text Field with the view controller that manages",NA
A Final Note,"This is it! For those of you who haven’t programmed before, you may be thinking that just as 
 you expected (and I promised), the programming described in this book is pretty easy. But for 
 those of you with programming experience, the ease with which you can accomplish things by 
 using object-oriented programming can be truly breathtaking. I still feel like a kid in a candy 
 store when I code this way.
  
 Although you have a lot more to do to turn
  iVacation
  into a useful application, includ-ing 
 saving data, you now have the knowledge and skill to explore extending this applica-tion on 
 your own — so go for it!",NA
Chapter 18,NA,NA
Adding a Mac User ,NA,NA
Interface,"In This Chapter
  
  
  
  
  
  
 Painlessly putting a user interface on the model 
 Create a user interface with Interface Builder 
 Adding controls to the view 
  
 Creating a view controller 
  
 Running the application on the Mac
  
 In this chapter, I keep the second part of the promise I’ve been talking about since Chapter 
 11 — if you create the right class structure, putting on a user interface will be easy.
  
 Now that you have seen how easy it is to take your application’s components and add an 
 iPhone user interface, I show you how to do the same thing for the Mac OS. Although the basic 
 idea is the same, you find a few differences in detail that I explain in this chapter.",NA
Creating Your Project,"As with the iPhone, you will be working in an Xcode project. Create a Mac application 
 project by following these steps:
  
 1. Launch Xcode if it is not already running.
  
 2. Choose File
 ⇒
 New
 ⇒
 Project to create a new project. You can also press Shift+
 +N.
  
 3. In the New Project window (see Figure 18-1), click Application under the OS X 
 heading.
  
 Just as before, when you select a template, a brief description of the template is dis-played 
 underneath the main pane. As you know, each of these choices is actually a template that",NA
Using Interface Builder to Create a User,NA,NA
Interface,"Just as you do in Chapter 17, you use Interface Builder to create your user interface. Fol-low 
 these steps:
  
 1. In the Project navigator, click the
  MainMenu.xib
  file.
  
 The Interface Builder editor displays the contents of
  MainMenu.xib
 .
  
 2. Select the Window – mVacation item in the Objects list, as shown in Figure 18-4.
  
 If Interface Builder shows a set of icons instead of text to the left of the editor area, click 
 the Show Document Outline button in the bottom left corner of the editor area.
  
 Figure 18-4:
  
 Inter-
  
 face Builder edit-
  
 ing.",NA
Implementing the User Interface,"Just as on the iPhone, the coding required to hook the user interface to the model is 
 minimal.
  
 If you have been following along with me, I extend what you did in Chapter 16. If you 
 prefer to start from a clean copy of the project from where you left off, you can use the 
 project found at the website in the Chapter 18 Start Here folder, which can be found in 
 the Chapter 18 folder.",NA
Using the Assistant Editor to add outlets and,NA,NA
Targets-Actions,"The only differences between what you have to do here and what you do in Chapter 17 are 
 that the classes of the Label and the Text Field have changed in the
  IBOutlet
  de-clarations. 
 On the iPhone, you use a
  UITextField
  and
  UILabel
 ; with OS X, you use 
 NSTextField
  
 for both.
  
 The two
  IBAction
  method declarations —
  spendDollars:
  and
  charge 
 CreditCard:
 — are the same.
  
 You’re going to add the
  IBOutlet
 s and the
  IBAction
 s just as you do in Chapter 17, us-ing 
 the Assistant Editor. But you first need to tell Xcode that the
  mVacationController 
 class 
 you just created will be used with the app’s interface.
  
 You do this because when your application is launched, the runtime goes out and loads and 
 creates the objects in your
  .xib
  file (there’s actually more to it, but this is more or less what 
 happens). Adding an
  mVacation Controller
  object here means that in addi-tion to the",NA
Implementing the methods,"Okay, you now created the methods and the outlets within the header and implementa-tion 
 files for
  mVacationController
 . The next thing you need to do is to add the code to the
  
 spendDollars:
  and
  chargeCreditCard:
  methods in the implementation file,
  mVa-
 cationController.m
 . Follow these steps:
  
 1. Go back to the
  mVacation
  folder in the Project navigator and select mVaca-
 tionController.m — the implementation file for
  mVacationController
 .
  
 2. Look for the following lines of code in the implementation file:
  
 #import “mVacationController.h”@implementation mVacationController
  
 3. Add the following after
  #import “mVacationController.h”
 :
  
 #import “Destination.h”
  
 4. Add the code in bold to the two action methods:
  
 - (IBAction)spendDollars:(id)sender{
  
  
 NSLog (@”Sending a %.2f cash transaction”,
  
  
  
  
 [transactionField.stringValue floatValue]); 
 [europe spendCash: 
  
  
  
  
 [transactionField.stringValue doubleValue]]; 
 [balanceField setStringValue: 
  
  
  
 [[NSString alloc]initWithFormat:@”%.2f”, 
  
  
 [europe leftToSpend]]]; 
  
 }
  
 - (IBAction)chargeCreditCard:(id)sender { 
  
 NSLog (@”Sending a %.2f credit card transaction”, 
  
  
  
 [transactionField.stringValue floatValue]); 
 [europe chargeCreditCard: 
  
  
  
  
 [transactionField.stringValue floatValue]]; 
 [balanceField setStringValue: 
  
  
  
 [[NSString alloc] initWithFormat:@”%.2f”, 
  
  
 [europe leftToSpend]]]; 
  
 }",NA
Running mVacation on the Mac,"Your OS X application is now ready to go.
  
 Click the Run button to compile and build the application.
  
 You can click in the Transaction field to enter a transaction and then click one of the buttons. 
 In Figure 18-11, you see that I entered 100 and then clicked the Cash button —and lo and 
 behold, the math works.",NA
Knowing What’s Left to Do,"Just like with the iPhone application, you have a little more to do besides the 
 cosmetics and additional application functionality — for example, the menu and other 
 user-interface functionality expected by the user of a Mac application.",NA
The End of the Beginning,"Now that you finished
  Objective-C For Dummies,
  your adventure really starts.
  
 Go out there and write programs, and let me know how you are doing. You’ll find inform-ation 
 and ideas about programming and design on Neal’s website, 
  
 www.nealgoldstein.com
 . And you can contact Karl at
  kgkfordummies@gmail.com
 .",NA
Part V ,NA,NA
The Part of ,NA,NA
Tens,NA,NA
In this part . . .,NA,NA
Chapter 19,NA,NA
Ten Debugging Tips,"In This Chapter
  
  
  
  
  
  
  
  
  
  
  
 Checking for semicolons 
  
 Watching for lowercase versus uppercase terms 
 Paying attention to the first syntax error 
  
 Recognizing the usefulness of compiler warnings 
 Knowing your debugger’s features 
  
 Checking for messages to
  nil 
  
 Sending messages to the right object 
  
 Using
  NSLog 
  
 Testing incrementally 
  
 Solving logic errors
  
 When you’re developing an application, you’ll find that a few things don’t work out quite the 
 way you planned. That means you will have to go through your code and determine what 
 happened, and more important, what to do about it.",NA
Check for Semicolons,"Semicolons are the heart and soul of Objective-C statements, and leaving one out can cause 
 incredible havoc. For some reason, forgetting to end a statement with one is something I’m 
 pretty good at. So, when I see a lot of errors and warnings, especially if I’ve just added a few lines 
 of code, semicolons are one of the first things I check. And Xcode will assist you with this, if you 
 use Fix-It.",NA
“Right” Is Not Always “right”,NA,NA
"When You’ve Blown It, You’ve Blown It","It’s generally better to ignore the subsequent errors after the first syntax error because they 
 may be the result of that first error. This is especially true when you leave out
  #im-port
  
 statements (or spell them wrong) or forget a semicolon or comma, or colon, or anything else 
 that the complier uses to make sense of your statements.",NA
Compiler Warnings Are for Your Own,NA,NA
Good,"You may get only one chance to pay attention to a compiler warning. If you don’t make any 
 changes to the file that generated the warning, you won’t see the warning the next time you 
 build your program, but you can always see them again by clicking Show Issue on the 
 Navigator selector bar.
  
 You can also choose Product
 ⇒
 Clean to remove all the files the compiler creates — so your next 
 build starts from a clean state — and you probably should on a regular basis.",NA
Get Friendly with Your Debugger,"The debugger has a lot of features that can really help you. Breakpoints are especially helpful. 
 Take the compiler out for a date some time and really get to know it.
  
 It may seem intuitively obvious (although in the heat of the moment after a program crash, 
 you may forget), but make sure to read what the Debugger Console says. For ex-ample
  
 2012-05-28 10:18:07.148 Vacation[26213:a0f] *** Terminating app due
  
  
 to uncaught exception NSInvalidArgumentException’, reason: ‘-
  
  
 [__NSCFNumber doublValue]: unrecognized selector sent to instance
  
  
 0x7fdb02c017f0’
  
 makes things pretty clear. Although not covered here, you should also get to know the 
 commands that you can type into the Debugger Console.",NA
Messages to nil,"In Objective-C, you can send messages to a
  nil
  object. Although this does not crash your 
 program, in some cases, it will make you crazy trying to figure out why something doesn’t 
 work the way it should.",NA
Dialing a Wrong Number,"One of the great features of Objective-C is its implementation of polymorphism. As long as the 
 object has implemented the method you are sending the message to, Objective-C will let you 
 send the object that message. Sometimes, however, that object may not be the one you wanted 
 to send the message to, so be careful of that concern.",NA
Create a “Paper” Trail,"I am a big fan of
  NSLog
 . Sure, the debugger gives you a stack trace, and you can use 
 breakpoints, but
  NSLog
  can create a narrative of what is going on. Use it to display where you 
 are in your code and the value of variables. Using all the tools available gives you the best 
 chance of fixing that bug before the next SDK and all those new devices are released.
  
 Just be careful, though, because
  NSLog
  can also be a source of bugs — ironic but true. If you 
 try to use a C String as in
  NSLog(“I’m here”)
 , you will get complier warnings. If you try to 
 display a nonobject by using the
  %@
  string formatter, you may cause a pro-gram crash. What 
 is more insidious, though, is when you use the wrong formatter, and you don’t get what you 
 expect, and you spend hours tracking it down, only to find that you were trying to display an
  
 int
  as a
  float
 .",NA
Incrementally Test,"Most software developers quickly figure out that incremental development is the way to go. 
 Write a method and try to test it immediately if you can, even if it means just putting in
  NSLog
  
 statements to examine the output. It is a lot easier to debug 15 lines of code than to try to 
 figure out why the 200 lines of code you’ve been working on for two days don’t work the way 
 you expect.",NA
Use Your Brain,NA,NA
Chapter 20,NA,NA
Ten Ways to Be a ,NA,NA
Happy Developer,"In This Chapter
  
  
  
  
  
  
  
  
  
  
  
  
 Limiting dependencies to what objects do, not how they do it 
 Creating code that is easy to understand 
  
 Following memory management rules 
  
 Initializing the right way 
  
 Using the documentation 
  
 Practicing your coding 
  
 Understanding the development process 
  
 Trying to get it right the first time 
  
 Knowing what’s important — that the software works 
  
 Planning ahead to extend your code 
  
 Keeping it fun
  
 I really like writing software. When I first started, I couldn’t believe that I was actually paid to 
 do something that was so much fun (believe me, I quickly got over that). Along the way, I’ve 
 discovered a few ways to make my life as a developer easier.",NA
Keep Everyone in the Dark,"One of the things that can really cause you problems as you develop your application is building 
 into your code “detailed” knowledge about how things in your program work. This ranges from 
 data structures, to instance variable visibility (to other objects), to how methods work, to the 
 basic structure of the program. As I speak about more than once, you want to make sure that you 
 keep your objects as ignorant as you can about their en-vironment. Although you will always 
 have some dependency whenever one object uses",NA
Make Your Code Easy to Understand,"Often developers think that comments are for other people who are reading your code.
  
 In reality, think about them as being for yourself when you are picking up some code that you 
 wrote six months ago. It will amaze you how foreign it can appear. I suggest the following:
  
 Use comments often, but especially when you are doing something clever — espe-cially if 
 it took you a while to figure out how to do that thing in the first place.
  
 Give your classes descriptive names.
  
 Do the same thing with method names.
  
 Do the same thing with both local and instance variables.
  
 Take advantage of argument names in method declarations so that you know 
  
  
 what each argument is for.",NA
Remember Memory,"With Automatic Reference Counting — ARC — you can now develop iOS and OS X apps without 
 using
  retain
 ,
  release
 , or
  autorelease
 . But you should still keep in mind what you read 
 about memory management in Chapter 13 because it’s important to under-stand exactly what’s 
 going on behind the scenes. And although you may write your own code by using ARC, you 
 likely will encounter example code that still has
  retain
 s and 
 release
 s.",NA
Start by Initializing the Right Way,"Even though it is just about as unglamorous as things get, initialization is extremely im-
 portant. Don’t try to backfit later in your development cycle; do it correctly from the start. 
 Always use the following form:
  
 - (id) init...: {
  
  
 if (self = [super ...]) {
  
  
 your initialization goes here
  
  
 }
  
  
 return self;
  
  
 }",NA
Take Advantage of the Documentation,"This may sound silly, but it’s a good idea to actually read the documentation if you want to 
 know how something works. What I find myself doing when I am learning something new, 
 Control-right-click a symbol and then select Find Text in Documentation — I use this all the 
 time.
  
 Of course you can find search in the Help menu and Option-double-click a symbol to bring up 
 Quick Help. Also, these two Apple Dev Center sites have a plethora of reference material:
  
 http://developer.apple.com/ios
  
 http://developer.apple.com/mac",NA
"Code, Code, Code","Every book I write has a few themes running through it, and one of those in this book is code, 
 code, code. My experience, both personally and in teaching, is that the more you type — that is, 
 the more code you actually write — the more you understand and the faster you understand it.
  
 You should try things out to see how they work. For example, experiment with similar methods 
 to see how they work differently. Try everything out to make sure that when you invoke a 
 method, you can predict what the result will be. Let your curiosity run free, and if something 
 intrigues you, go explore it. And don’t worry, you can’t do anything in an Xcode application that 
 will break anything in Xcode, much less take down your entire system. This isn’t Windows, 
 after all.",NA
Understand That Development Is Not Lin-,NA,NA
ear,"Development is not linear. In this book, I talked about showing you how to do 
  
 something, and then having you delete the code and try it a different or better way. If I’m trying 
 something new, I often just code a rough version of it to make sure that I under-stand the 
 basics before things get complicated.
  
 You’ll find yourself creating a rough application structure, implementing a few classes, seeing 
 whether the idea works, and then going back and refining it, especially when it comes to using 
 inheritance and polymorphism. Personally, even if I know I will have class hierarchy, like I did 
 with
  Transaction
 , I’ll build out one concrete example of it —say
  CashTransaction
  — and 
 make sure that it works. Then I create the superclass and the first subclass and make sure that I 
 get the same results, and then go on to create oth-er subclasses. This is known as
  factoring
  your 
 code, and it’s all in a day’s work.",NA
Do It Right from the Start If You Need to,NA,NA
Do It Right from the Start,"I just talked about the nonlinear approach to development: building something to see how it 
 works and then doing it the right way. Although that works for some things, it doesn’t work 
 for a few other things over the long term. You have to start doing some things the right way 
 from day one of development, including the following:
  
 Building your application, using the Model-View-Controller pattern
  
 Initialization
  
 Memory management
  
 Localization (I don’t cover this, but you can find lots of information in other texts 
  
  
 and online)
  
 Error handling
  
 Although you might not always do the listed things exactly right from the get-go, you better go 
 back and do them properly before you get very far — it becomes an enorm-ously error-prone 
 task to backfit these. I still have nightmares about going back and ret-rofitting my first iPhone 
 program to correctly manage memory.",NA
Avoid the Code Slinger Mentality,"Some programmers get so carried away with the purity of the language and program-ming that 
 they spend days arguing about a point that, in the long run, makes no differen-ce to how well 
 your program actually works.
  
 Also avoid cleverness as much as you can, as well as excessive nesting of statements. If clarity 
 requires a few more lines of code, you are always better off in the long run.
  
 This is a good time to point out that your main interest should be in developing great 
 applications, while quickly working through issues (often style issues) that make no dif-
 ference. Usually, if equal passion exists on both sides, each side has its pros and cons, and no 
 one is really “right.”
  
 I like to keep in mind a quotation from Voltaire:
  
 The perfect is the enemy of the good.",NA
The Software Isn’t Finished Until the Last,NA,NA
User Is Dead,"If I can guarantee one thing about app development, it’s that Nobody Gets It Right the First 
 Time. The design for all applications evolves over time, as you discover the capab-ilities and 
 intricacies of the platform, as user behavior changes in response to your ap-plication, and as 
 the users, based on usage, get a better idea of what they can do with technology.
  
 Object orientation makes extending your application (not to mention fixing bugs) easier, so 
 pay attention to the principles.",NA
Keep It Fun,"This is another one of those ongoing themes in this and my other books (and in my per-sonal 
 life as well). Programming is inherently fun (at least after you get going), and the point is to 
 keep it that way.
  
 It’s important to remember this when you have spent hours trying to debug your pro-gram, 
 and you think all is lost. Don’t worry; you’ll eventually figure it out. You wrote it, after all.",NA
