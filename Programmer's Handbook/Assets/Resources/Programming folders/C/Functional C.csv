Larger Text,Smaller Text,Symbol
Functional C,NA,NA
Pieter Hartel,NA,NA
Henk Muller,NA,NA
University of Southampton University of Bristol,Revision: 6.7,NA
Preface,"The Computer Science Departments of many universities teach a functional lan-
 guage as the first programming language. Using a functional language with its 
 high level of abstraction helps to emphasize the principles of programming. 
 Func-tional programming is only one of the paradigms with which a student 
 should be acquainted. Imperative, Concurrent, Object-Oriented, and Logic 
 programming are also important. Depending on the problem to be solved, one of 
 the paradigms will be chosen as the most natural paradigm for that problem.
  
 This book is the course material to teach a second paradigm:
  imperative pro-
 gramming
 , using C as the programming language. The book has been written so 
 that it builds on the knowledge that the students have acquired during their first 
 course on functional programming, using SML. The prerequisite of this book is 
 that the principles of programming are already understood; this book does not 
 specifically aim to teach ‘problem solving’ or ‘programming’. This book aims to:
  
 Familiarise the reader with
  imperative programming
  as another way of imple-
 menting programs. The aim is to preserve the programming style, that is, 
 the programmer thinks functionally while implementing an imperative 
 pro-gram.
  
 Provide understanding of the
  differences between functional and imperative pro-
 gramming
 . Functional programming is a high level activity. The ordering of 
 computations and the allocation of storage are automatic. Imperative pro-
 gramming, particularly in C, is a low level activity where the programmer 
 controls both the ordering of computations and the allocation of storage. 
 This makes imperative programming more difficult, but it offers the 
 imperative programmer opportunities for optimisations that are not 
 available to the func-tional programmer.
  
 Familiarise the reader with the
  syntax and semantics of ISO-C
 , especially the 
 power of the language (at the same time stressing that power can kill). We 
 visit all dark alleys of C, from
  void *
  to pointer arithmetic and 
 assignments in expressions. On occasions, we use other languages (like C++ 
 and Pascal) to illustrate concepts of imperative languages that are not 
 present in C. C has been chosen because it is a de facto standard for 
 imperative programming, and because its low level nature nicely contrasts 
 with SML. Those who want to learn, for example, Modula-2 or Ada-95 
 afterwards should not find many difficulties.
  
 iii",NA
Acknowledgements,"The help and comments of Hugh Glaser, Andy Gravell, Laura Lafave, Denis 
 Nicole, Peter Sestoft, and the anonymous referees have been important to us. The 
 mate-rial of the book has undergone its first test in Southampton in 1995/1996. The 
 first year Computer Science students of 1995, and in particular Jason Datt and 
 Alex Walker have given us a lot of useful feedback.
  
 We have used a number of public domain software tools in the development 
 of the book. The
  noweb
  literate programming tools of Norman Ramsey, the rail 
 road diagramming tools from L. Rooijakkers,
  gpic
  by Brian Kernighan, TEX, 
 L
 A
 TEX, New Jersey SML, and the Gnu C compiler were particularly useful.
  
 Revision: 6.8",NA
Contents,"Preface
  
 iii
  
 1 
  
 1 
  
 3 
  
 3 
  
 3 
  
 4
  
 7 
  
 7 
  
 8 
  
 9 
  
 10 
  
 10 
  
 14 
  
 15 
  
 17 
  
 18 
  
 19 
  
 20 
  
 21 
  
 22 
  
 26 
  
 27 
  
 29 
  
 32 
  
 34 
  
 34 
  
 37 
  
 39 
  
 44 
  
 47
  
 1
  
 Introduction
  
 1.1
  
 The functional and the imperative paradigms . . . . . . . . . . . . . .
  
 1.1.1
  
 The advantage of state . . . . . . . . . . . . . . . . . . . . . . .
  
 1.1.2
  
 The advantage of pure functions . . . . . . . . . . . . . . . . .
  
 1.1.3
  
 Idiomatic building blocks in C
  
 . . . . . . . . . . . . . . . . . .
  
 1.2
  
 Guide to the book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
  
 Functions and numbers
  
 2.1
  
 A model of computation . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.1.1
  
 A computational model for SML programs . . . . . . . . . . .
  
 2.1.2
  
 A computational model for C programs . . . . . . . . . . . . .
  
 2.1.3
  
 Compiling and executing a C program
  
 . . . . . . . . . . . . .
  
 2.2
  
 Elementary functions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.2.1
  
 The header of a C function, types and identifiers . . . . . . . .
  
 2.2.2
  
 The body of a C function and its behaviour . . . . . . . . . . .
  
 2.2.3
  
 The execution of a C program . . . . . . . . . . . . . . . . . . .
  
 2.2.4
  
 Integers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.2.5
  
 Logical operators . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.2.6
  
 Defining a type for Booleans,
  typedef
  and
  enum
  . . . . . . .
  
 2.3
  
 Characters, pattern matching, partial functions . . . . . . . . . . . . .
  
 2.3.1
  
 Implementing pattern matching in C . . . . . . . . . . . . . . .
  
 2.3.2
  
 Partial 
 functions
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.3.3
  
 Differences and similarities between characters and integers .
  
 2.4
  
 Real numbers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.4.1
  
 Coercions of integers and floating point numbers . . . . . . .
  
 2.5
  
 Functions as 
 arguments
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.5.1
  
 Sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.5.2
  
 Products . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.5.3
  
 An extended example of higher order functions: bisection . .
  
 2.6
  
 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2.7
  
 Further exercises
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 vii",NA
Chapter 1,NA,NA
Introduction,"Programming is the activity of instructing a computer so that it will help to solve 
 a problem. These instructions can be prepared on the basis of a number of 
 paradigms. This book has been written for those who are familiar with the func-
 tional paradigm, using SML as a programming language, and who wish to learn 
 how to program in the imperative paradigm, using C as a programming 
 language.",NA
1.1 The functional and the imperative paradigms,"The functional and imperative paradigms operate from different viewpoints. The 
 functional paradigm is based on the
  evaluation of expressions
 , and binding 
 variables to values. The basic program phrase is the expression; the purpose of 
 evaluating an expression is to produce a value. The order in which 
 subexpressions are evalu-ated does not affect the resulting values.
  
 The imperative paradigm is based on the
  execution of statements
 , and having a 
 store where the statements can leave their results. The basic program phrase is 
 the statement; the purpose of executing a statement is to change the store. The 
 order in which statements are executed does affect the resulting values in the 
 store. The current set of values in the store is referred to as the
  state
  of the 
 program.
  
 The reasons for these different approaches lie in the roots of the languages 
 based on these paradigms. Functional languages were developed coming from 
 mathematics. The foundation of these languages is therefore clean and well 
 under-stood. Imperative languages were designed coming from the machine 
 operational point of view: The von Neumann architecture has a memory and a 
 processor op-erating on this memory. The imperative paradigm is a high level 
 abstraction of this model.
  
 Functional and imperative languages can be used to program in either style: 
 it is possible to write an imperative program in SML, and it is also possible to 
 write a functional program in C. However, these programs are often ‘unnatural’, 
 in that their formulation is clumsy because the language does not offer the most 
 appro-priate abstractions.
  
  
 As an example, consider the classical problem of generating pseudo random 
 numbers. This is how we can formulate this problem functionally in C:",NA
1.1.1 ,NA,NA
The advantage of state,"A useful extension of the random function would be to build a function that re-
 turns the value of a dice. The value of a dice can be computed by taking the ran-
 dom number modulo
  6
 , and adding one to it, which will return a value in the 
 range
  1
  ...
  6
 . The imperative function for the dice would read:
  
 int imperative_dice( void ) { 
  
  
 return imperative_random() % 6 + 1 ; 
 }
  
 A random number is generated, the modulo operation is performed, and one is 
 added. Writing the functional version is more difficult, two numbers have to be 
 returned from this function: the value of the dice and the state of the random 
 num-ber generator. The caller of the functional dice would have to take one of 
 the num-bers, and remember to pass the next on to the next call.",NA
1.1.2 ,NA,NA
The advantage of pure functions,"Storing state somewhere in a hidden place has a disadvantage: it becomes more 
 difficult to create functions that can be used as neat building blocks. As an exam-
 ple, assume that we would like to roll two dice every time. The theory of random 
 number generators tells us that it is incorrect to use alternate numbers from one 
 random number generator to generate the values of the two dice [5]. Instead, two 
 independent random generators must be used.
  
 The functional version offers a random generator that can be used as a 
 building block, supposing that the initial seeds where stored in
  r
  and
  s
 , then 
 the following fragment of code will generate a value for the two dice:
  
 int x = functional_random( r ) 
 ; 
  
 int y = functional_random( s ) 
 ; 
  
 int dice = x%6 + 1 + y%6 + 1 ;
  
 It is impossible to achieve this with the imperative version, because there is only 
 one variable
  seed
  which stores
  the
  seed.",NA
1.1.3 ,NA,NA
Idiomatic building blocks in C,"Ideally, we would like to have the best of both worlds. The reader can look 
 ahead to Chapter 8 to see a random number generator, which is a good building 
 block, and which passes the state around in a manner that scales well beyond a 
 single function.",NA
1.2 Guide to the book,"The next chapter discusses the basic execution model of C. The basic syntax and 
 data types are also presented. In that chapter a declarative subset of C is used. 
 This does not result in idiomatic or efficient C programs, but it serves to 
 familiarise the reader with the basic syntax of C. Chapter 2 also introduces the 
 first systematic transformation of functional code into C.
  
 Chapter 3 discusses iteration. Functional languages iterate over data 
 structures by means of direct recursion or by means of indirect recursion through 
 higher or-der functions such as
  map
  and
  foldl
 . C offers constructions that 
 iterate with-out recursion by repeatedly executing certain parts of the program 
 code. In Chap-ter 3 we create efficient and idiomatic C for most example 
 programs of Chapter 2. This is done using a number of systematic, but informal, 
 program transformation schemas.
  
 Chapter 4 discusses the type constructors of C that are necessary to build 
 (non recursive) algebraic data types. These constructors are called
  structures
  and
  
 unions
 . The chapter discusses how to create complex types and ends with a 
 discussion on destructive updates in these data structures (using a
  pointer
 ).
  
 The first 4 chapters discuss the basic data types and their C representation. 
 More complex data types can store sequences data. There are a number of repre-
 sentations for storing sequences. In functional languages, lists are popular; arrays 
 are used when efficient random access is required to the elements. Lists are less 
 popular in C because the management of lists is more work than the 
 management of lists in functional languages. Sequences, arrays, lists, and 
 streams are discussed in Chapters 5 to 7.
  
 Chapter 5 presents the basic principles of sequences and the implementation 
 of arrays. Arrays in C are at a low level, but it is shown that high level structures, 
 as available in functional languages, can be constructed. Lists are discussed in 
 Chap-ter 6. The implementation of lists requires explicit memory management; 
 this is one of the reasons that using lists is less convenient in C than in SML. The 
 stream, a list of items that are consumed or written sequentially (as in I/O), are 
 the topic of Chapter 7.
  
 Chapter 8 finally goes into details of how the module system of C works, 
 com-paring it to the module system of SML. Modular programming is the key 
 issue in software engineering. Defining interfaces in such a way that modules 
 have a clear function and the proper use of state are the subjects of this chapter.
  
 The last chapter, Chapter 9, shows three case studies in elementary graphics. 
 The first case is completely worked out, it shows how to use an X-window 
 system for drawing a fractal for the Mandelbrot set. The second case study is 
 partially
  
 Revision: 6.19",NA
Chapter 2,NA,NA
Functions and numbers,"Functional programming in SML and imperative programming in C have much 
 in common. The purpose of this chapter is to show that, when given an SML 
 solu-tion to a problem, a C solution can often be found without much difficulty. 
 The C solutions presented here are not necessarily the best from the point of 
 view of their efficiency, but will be a good starting point for the further 
 refinements that are presented in later chapters. In the present chapter, we 
 emphasise the differ-ences between computation as perceived by the 
 mathematician and computation as carried out on computers. We support this 
 by introducing a model of computa-tion, and we illustrate the concepts by 
 solving a number of sample problems.
  
 The first problem that will be solved is to compute the greatest common 
 divisor of two natural numbers. This example discusses in some detail the 
 representation of integral numbers and the C syntax to denote functions. The 
 second example computes the values of arithmetic expressions. It serves to 
 discuss the differences between pattern matching, as it is commonly found in 
 functional languages, and conditionals. The third example calculates an integral 
 power of a real number. It uses floating point numbers. This example is used to 
 discuss the ins and outs of representing reals in C. The fourth example uses 
 higher order functions to com-pute sums and products. With some extra effort, 
 this powerful abstraction can be used in C programs, albeit in a slightly limited 
 setting.",NA
2.1 A model of computation,"A programmer solves a problem by writing a computer program. The answer to 
 the problem is then the result produced by the program. First and foremost, the 
 programmer must understand the problem that is being solved. The 
 programmer must also have an understanding of the way in which computers 
 work, for a pro-gram is merely an instruction to the computer to carry out 
 particular computa-tions in a particular order. Without such an understanding, 
 the programmer may attempt to instruct a computer to do things that it cannot 
 do without exceeding the given resources, or worse, the programmer might 
 attempt to make the computer do things that it cannot do at all. Compared to the 
 human brain, computers are rather limited in what they can do. On the other 
 hand, a computer can do certain",NA
2.1.1 ,NA,NA
A computational model for SML programs,"An SML program consists of a number of function definitions and a main expres-
 sion. Computation is the process of finding the value of the main expression. In 
 all but trivial programs, the evaluation of the main expression will cause 
 subsidiary expressions to be evaluated until no more expressions remain whose 
 values are required. The SML programmer needs to know about this 
 computational process for a number of reasons.
  
  
 Firstly, the process is started with the main expression, so this must be given 
 as part of the program.
  
 Secondly, the main expression will make use of certain functions (either pre-
 defined or user defined), so these definitions must be available to the computer. 
 These function definitions may make use of further functions, if so these must be 
 given also. The program is complete only if all required definitions are given.
  
 The SML programmer also needs to know how an expression is evaluated. 
 As-sume that an expression consists of a function name and a list of argument 
 values to which that function is applied. The mechanism involved in evaluating 
 the ex-pression consists of four steps:
  
 The definition of the named function is looked up in the list of known func-
 tion definitions.
  
 The formal arguments of the function definition are associated with the val-
 ues provided by the actual arguments of the function.
  
 The body of the function is examined to yield a further expression that can 
 be evaluated now. This includes evaluation of the arguments, where 
 necessary.
  
 As soon as all subsidiary expressions are evaluated, the result of the 
 function is returned. The value of this result only depends on the values of 
 the actual arguments of the function.
  
 The mechanism of starting with a given expression, activating the function it 
 men-tions, and looking for the next expression to evaluate comprises the 
 computational model that underlies an implementation of SML. Knowledge of 
 this mechanism enables the programmer to reason about the steps taken whilst 
 the program is be-ing executed. The programmer will have to make sure that 
 only a finite number of such steps are required, for otherwise the program would 
 never yield an answer. In most circumstances, the programmer will also try to 
 make sure that the least number of steps are used to find an answer, as each step 
 takes a certain amount of time.",NA
2.1.2 ,NA,NA
A computational model for C programs,"To some extent it is possible to write C programs in a functional style, such that 
 the computational model that we sketched above for SML is applicable. How-
 ever, this has two important drawbacks. Firstly, the resulting C programs would 
 be rather inefficient, and secondly, a programmer trained to read and write C 
 pro-grams written in a functional style would not be able to read C programs 
 written by other programmers, as they would be using the language in a way 
 that is not covered by the computational model.
  
 In this chapter, we introduce a simplified computational model for C 
 programs which is almost the same as that for SML. In the next chapter, we will 
 add a model of the store, so as to expand the simple model to a full 
 computational model of C programs.
  
 In the simple computational model, a C program is a list of function declara-
 tions. One of the functions should have the name
  main
 . This function plays the 
 same role as the main expression of an SML program. In the simple model, ex-
 pressions are evaluated as for SML. The difference is that in C functions consist 
 not of pure expressions but of statements. A statement is an operation on the 
 state of the program, by executing statements in the right order, the program 
 achieves its result. In this chapter we will only use three statements:
  
 The
  return
 -statement terminates the execution of a function and returns 
 a result value.
  
 The expression-statement evaluates an expression, ignoring the result. To 
 contribute to the computation, the expression will often have a
  side effect
 . A 
 side effect refers to any result which is not returned as the value of the ex-
 pression but which ends up somewhere else, printing output on the screen 
 for example. Purely functional languages do not allow side effects.
  
 The
  if
 -statement conditionally executes other statements.
  
 In the coming chapters, we will gradually introduce all statements of C. We will 
 not use any state in this chapter, the concept of the store is introduced in Chapter 
 3.
  
 The following C program demonstrates a simple program:
  
 /* A simple C program, it prints Hello World */ 
 int main( void ) { 
  
  
 printf( ""Hello world\n"" ) ; 
  
  
 return 0 ; 
  
 }
  
 The text between a “
 /*
 ” and a “
 */
 ” is comment, and ignored by the C compiler. 
 The first statement of the function
  main
  is:
  
 printf( ""Hello world\n"" ) ;
  
 Revision: 6.47",NA
2.1.3 ,NA,NA
Compiling and executing a C program,"Once the C program is written, it needs to be compiled and executed. Here we 
 give a minimal introduction how to compile a program, which is stored in a 
 single file. The compilation of multi module programs is dealt with in Chapter 8. 
 On UNIX systems (or one of its equivalents such as LINUX, AUX, AIX, and so 
 on), the C program must be stored in a file with a name that ends on
  .c
 . The 
 program can then be compiled by invoking the C compiler,
  cc
 :
  
 cc -o monkey hello.c
  
 This will compile the program
  hello.c
 . Any errors are reported, and if the 
 com-piler is satisfied with the code, an executable file,
  monkey
  in this case, is 
 created.
  
 The program can be executed by typing
  monkey
 :
  
 Hello world
  
 Newer systems, such as Macintoshes or PC’s often offer integrated environments 
 such as the Codewarrior or Borland C. From within the editor, the compiler can 
 be called, and the program can be executed. It is impossible to give an exhaustive 
 description of all these systems, local manuals should be consulted on how to 
 edit, compile and execute programs on these systems.",NA
2.2 Elementary functions,"We are now ready to study an interesting algorithm. The greatest common 
 divisor (gcd) of two positive natural numbers is the largest natural number that 
 exactly divides both numbers. The gcd of 14 and 12 is 2, while the gcd of 14 and 
 11 is 1.
  
 The gcd of two numbers is given by the
  specification
 :
  
 gcd
  
 gcd 
  
 (2.1)
  
 The standard
  algorithm
  for calculating the gcd follows Euclid’s method. If, for 
 two 
 ! #""$ 
  
  
 &%(' 
  
 ! #"" 
  
 )%+*",NA
2.2.1 ,NA,NA
"The header of a C function, types and identifiers","The header of the first C function in the program is:
  
 int euclid( int m, int n )
  
 The definition of the function
  euclid
  starts with the definition of the type of 
 the value that the function will return. In this case, the type is
  int
  which is 
 short for the type of integer numbers. The SML equivalent of this type is also
  
 int
 .
  
 After the type of the function, the function name is specified (
 euclid
 ) and 
 then, between parentheses, the types and names of the arguments of the function 
 are given. In this function there are two arguments. The first argument is of type 
 int
  and is named
  m
 , and the second argument (after the comma) is again of 
 type 
 int
  and is named
  n
 . The argument names
  m
  and
  n
  are used to refer to the 
 first and second argument in the body of the function.
  
 The declaration of
  main
  is:
  
 int main( void )
  
 This header declares that the function with the name
  main
  will return an
  int 
 value. The argument list is specified to be
  void
 , which means that the function 
 main
  has no arguments.
  
 In C, every function must be declared before it can be used. As the function 
 main
  refers to
  euclid
 ,
  euclid
  must be defined before
  main
 . Defining the 
 func-tions in the other order might work (if the C compiler manages to guess the 
 types of the function correctly), but it is bad practice to rely on this.
  
 There are cases where both functions call each other, so-called mutually 
 recur-sive functions. In this case, neither function can be defined first. The 
 solution that C offers is the
  function prototype
 . A prototype is like a type signature 
 in SML: it declares a function and its type, but does not define the internal 
 details. After the prototype is defined, the function can be used. The function can 
 be defined completely later on. A function prototype consists of the header of the 
 function followed by a semicolon. Thus the prototypes of the two functions 
 above are:
  
 int euclid( int m, int n ) ; 
  
 int main( void ) ;
  
 In most functional languages, types are automatically inferred by the compiler. It 
 is good functional programming style to always specify the types of functions, so",NA
2.2.2 ,NA,NA
The body of a C function and its behaviour,"After the definition of the types of the function and its arguments, the code of the 
 function is defined. In an imperative language, this code consists of a sequence of 
 statements
 . A statement is a command to perform some kind of operation. As is 
 shown in detail in Section 2.2.3, a function is evaluated by evaluating each state-
 ment in turn.
  
 In C, each statement is terminated with a semicolon. A number of statements that 
 are logically one statement can be grouped by enclosing the statement group The 
 body of a function is a group of statements, enclosed in curly brackets.
  
 in curly brackets. The function
  euclid
  contains two kinds of statements: the 
 return
  statement and the
  if
  statement.
  
 A
  return
  statement is used to terminate the execution of the function and to 
 calculate the return value of the function. The return value is defined by the ex-
 pression between the
  return
  and the semicolon terminating the statement.
  
 An
  if
  statement has the general form:
  
 if( 
  
 ) {
  
 } else {
  
 }
  
 This can be read as follows: if the conditional expression 
  
 evaluates to true, exe-
 cute the statements , else execute the statements . We generally use upper case 
 italic letters to indicate where statements may occur. Upon completion of 
  
 or , 
 any statements following the
  if
  statement are executed. In the case of
  euclid
 , 
 there are no statements following the
  if
  statement. The
  if
  statement above 
 can also be used without the optional
  else
  part:
  
 if( 
  
 ) {
  
 }
  
 If the else part is omitted, the C program will just continue with the next state-
 ment if the conditional expression evaluates to false. The curly brackets
  {
  and
  } 
 are used to group statements. They can be omitted if there is only one statement 
 between them, but we will always use them to make it easier to modify 
 programs later on.
  
  
 Expressions in C are like functional expressions except that they use a slightly 
 different syntax. For example, the arguments of a function must be separated by 
 commas, and they must be enclosed in brackets. Therefore the function ap-
 plication
  f x y
  in the functional language is written in C as
  f(x,y)
 . The op-
 erators have also different syntax: for example, 
  
 is denoted in C as
  x%y
 .
  
 ! #""
  
 Revision: 6.47",NA
2.2.3 ,NA,NA
The execution of a C program,"The execution of every C program starts by calling the function with the name 
 main
 . Thus, every C program should have a function called
  main
 . Apart from 
 the name, the type of the arguments and the type of the return value of
  main
  
 are special.
  Main
  should always return an
  int
 , and if there are arguments for
  
 main
 , they should follow the syntax discussed in Chapter 8, which deals with 
 the envi-ronment. For now, all
  main
  functions will be without arguments and 
 will always return the value
  0
 . This value will be interpreted by the 
 environment as ‘every-thing all right, the program completed satisfactorily’.
  
 Upon execution of
  main
 , the first statement of the program has to be 
 executed. In the case of the example program, this is a call to
  printf
 . The C 
 language re-quires that all arguments of a function must be evaluated before the 
 function is called, similar to the
  strict
  evaluation of SML. The values of the 
 arguments are then passed to the function. This mechanism is known as
  call by 
 value
 . Another way to pass arguments,
  call by reference
 , is discussed in Chapter 4.
  
  
 The first argument passed to
  printf
 , the string
  ""%d\n""
 , is a constant, so it 
 does not need to be evaluated. The second argument is the expression:
  
 euclid( 14, 12 )
  
 This expression represents a function call that has to be evaluated first. However, 
 before
  euclid
  can be executed,
  its
  arguments have to be evaluated. These argu-
 ments are constants (the integers
  14
  and
  12
 ) so
  euclid
  is executed directly, 
 with 
 m
  having the value
  14
  and
  n
  having the value
  12
 . Eventually when
  
 euclid
  re-turns a value, the
  printf
  will be invoked.
  
 The first statement of
  euclid
  tests if
  n
  is greater than
  0
 . Since this is true, 
 the
  then
  statement is executed. This will in turn call the function
  euclid
  with 
 arguments
  12
  and
  14%12
 , which is
  2
 . Therefore,
  euclid
  is called again with
  
 m 
 equal to
  12
  and
  n
  equal to
  2
 .
  
 The first statement of
  euclid
  tests again if
  n
  is greater than
  0
 . This is true, 
 so the
  then
  statement is executed. This will cause the function
  euclid
  to be 
 called with arguments
  2
  and
  12%2
 , which is
  0
 . Thus
  euclid
  is called with
  m
  
 equal to
  2 
 and
  n
  equal to
  0
 .
  
 The first statement of
  euclid
  tests again if
  n
  is greater than
  0
 . Since this is 
 not true, the
  else
 -statement is executed, which causes the function to
  return 
 m
 , which will return the value
  2
 . This value is returned in turn by each of the 
 pre-vious invocations of
  euclid
 , and will eventually turn up in the
  main
  
 function in which the arguments of
  printf
  are now fully evaluated to give:
  
 printf( ""%d\n"", 2 ) ;
  
 The function
  printf
  is called, it will print the first argument to the output; 
 how-ever, it handles percent signs in a special manner. Every time
  printf
  
 encounters a
  %d
 , it replaces the
  %d
  with a decimal representation of the integer 
 that is taken from the argument list. In this example, the value printed is
  2
 , 
 which was just cal-culated. The
  \n
  results in a newline, just like SML. The 
 resulting output is there-fore:
  
 2
  
 Revision: 6.47",NA
2.2.4 ,NA,NA
Integers,"The
  euclid
  example works with integer numbers, which are captured by the C 
 type
  int
 . There are many ways to denote integer constants in C. The most com-
 mon form is to use the decimal representation, as already used before.
  13
  stands 
 for the integer 13. A minus sign can be used to denote negative values, as in
  -
 13
 . A second option is to specify numbers with a different base, either base
  8
  or 
 base 
 16
 . Hexadecimal values (using base
  16
 ) can be specified by writing them 
 after the letters
  0x
 . So
  0x2C
  and
  44
  both refer to the same number. Octal 
 numbers (with base
  8
 ) should begin with the digit
  0
 . So
  0377
 ,
  0xFF
  and
  255
  
 all specify the same number.
  
  
 The operators that can be applied to integers are listed below, together with 
 their SML and mathematical equivalents:
  
 C
  
 SML
  
 Math
  
 Meaning
  
 Unary
  
 +
  
 Unary plus
  
 -
  
 ˜
  
 div ,
  
 Unary minus
  
 ˜
  
 Bitwise complement
  
 Binary
  
 *
  
 *
  
 Multiplication
  
 /
  
 div
 ,
  /
  
 Division
  
 %
  
 mod
  
 ! #""
  
 Modulo
  
 +
  
 +
  
 Addition
  
 -
  
 -
  
 Subtraction
  
 <<
  
 Bitwise shift left,
  
  <<
  
 >>
  
 Bitwise shift right,
  
  >>
  
 &
  
 Bitwise and
  
 |
  
 Bitwise or
  
 ˆ
  
 Bitwise exclusive or
  
 Revision: 6.47",NA
2.2.5 ,NA,NA
Logical operators,"The language C does not have a separate type for booleans, instead integers are 
 used to represent booleans. The comparison operators, listed below, result in the 
 integer value
  1
  or
  0
 ;
  1
  is used to represent true and
  0
  is used to represent 
 false.
  
 C
  
 SML
  
 Math
  
 Meaning
  
 <
  
 <
  
 Less than
  
 <=
  
 <=
  
 Less than or equal
  
 >=
  
 >=
  
 Greater than or equal
  
 >
  
 >
  
 Greater than
  
 ==
  
 =
  
 Equal
  
 !=
  
 <>
  
 Not equal
  
 C provides the three usual logical operators. They take integers as their 
 operands, and produce an integer result:",NA
2.2.6 ,NA,NA
"Defining a type for Booleans,",NA,NA
 typedef,NA,NA
 and,NA,NA
 enum,"The official way to denote the truth values in C is
  0
  and
  1
 , but to have a clear 
 struc-ture for a program involving logical operations, it is often convenient to 
 introduce a type for booleans. The following line at the beginning of a program 
 takes care of that:
  
 typedef enum { false=0, true=1 } bool ;",NA
"2.3 Characters, pattern matching, partial functions","The data types integer and boolean have now been discussed at some length, so 
 let us examine another useful data type, the character. The character is a 
 standard scalar data type in many languages, including C. Interestingly, the 
 character is not a standard data type in SML. Instead, SML offers strings as a 
 basic data type. In all languages that offer characters as basic data types, strings 
 occur as structured data types, that is, as data types built out of simpler data 
 types. Structured data types will be discussed in detail in Chapter 4 and later 
 chapters. To overcome the slight oddity of SML we will assume that an SML 
 string containing precisely one element is really a character. The SML type
  char
  
 will be defined as follows:
  
 type char = string ;
  
 As an example of a function that works on characters, consider the specification 
 below for evaluating an expression. Suppose an expression that consists of three 
 integers and two operators (either
  
  or 
  
 ) has to be evaluated. The rules 
 for operator precedence state that multiplication takes precedence over addition, 
 as indicated in the specification below. Here, the set represents all possible char-
 acters.
  
 + *",NA
2.3.1 ,NA,NA
Implementing pattern matching in C,"As a preparation to implementing
  eval
  in C, consider how it could be imple-
 mented in SML using conditionals. This is not difficult once the function has 
 been written using pattern matching, as above.
  
 (* eval : int -> char -> int -> char -> int -> int *) fun 
 eval x o1 y o2 z 
  
  
 = if o1 = ""+"" andalso o2 = ""+"" 
  
  
  
 then (x + y) + z 
  
  
  
 else if o1 = ""+"" andalso o2 = ""*"" 
  
  
  
  
 then x + (y * z) 
  
  
  
  
 else if o1 = ""*"" andalso o2 = ""+"" 
  
  
  
  
 then (x * y) + z 
  
  
  
  
 else if o1 = ""*"" andalso o2 = ""*"" 
  
  
  
  
  
 then (x * y) * z : int 
  
  
  
  
  
 else raise Match ;
  
 The last statement
  else raise Match ;
  makes explicit what happens if
  
 eval 
 is applied to a pair of operators other than
  ""+""
  and
  ""*""
 . The 
 specification of 
 eval
 , and the pattern matching of
  eval
  should have handled 
 this case explicitly. The latter actually does handle the error situation by raising 
 the exception
  Match
 , but it does so implicitly. We have left this problem to be 
 solved until this late stage to show that now we are actually forced to think 
 about this missing part of the specification: simply omitting the statement
  else 
 raise Match ;
  will give a syntax error. The problem specification only 
 partially specifies the solution. The
  
 Revision: 6.47",NA
2.3.2 ,NA,NA
Partial functions,"Functions that use pattern matching or guards are often partially defined. This 
 means that the function is not defined for the entire domain: there are arguments 
 for which the function is undefined. We have seen that the pattern matching ver-
 sion of
  eval
  is only defined if the operators are in the set
  + * 
 *
  . An attempt to 
 call the SML function
  eval 6 ""/"" 3 ""+"" 4
  in its pattern matching version 
 will result in a run time error. The program is aborted because none of the defini-
 tions of
  eval
  match the call.
  
 If we were to leave the as yet unfinished statement
  else /*raise 
 Match*/ 
 out of our C versions of
  eval
 , a call to
  eval( 6, /, 3, +, 4 )
  
 in the C implementation will result in an undefined value. Since none of the if 
 statements match, the end of the function is reached without executing a return 
 statement. Then the function will return with some arbitrary, unknown return 
 value. Contin-uing the computation with this unknown value makes little sense, 
 it is therefore good practice to prevent this from happening. The solution is to 
 call the function 
 abort()
 , which is available from
  stdlib.h
 :
  
  
 /*previous statements*/ 
  
  
 if( o2 == * ) { 
  
  
  
 return (x * y) * z ; 
  
  
 } else { 
  
  
  
 abort() ; 
  
  
 } 
  
 } else { 
  
  
 abort() ; 
  
 }
  
 A call to
  abort()
  causes a C program to stop execution immediately, to report 
 a run time error, and often to invoke a debugger or leave a memory dump. Then 
 the programmer can inspect which cases were missed out. The environment will 
 often allow the programmer to detect where the program failed, but it is good 
 practice to call
  printf
  just before aborting:
  
 printf(""Arghh, first argument of eval is neither"") ;
  
 Revision: 6.47",NA
2.3.3 ,NA,NA
Differences and similarities between characters and inte-,NA,NA
gers,"Character constants are denoted between single quotes: the constants
  *
  and 
 +
  
 have already been shown before. Most single characters can be denoted in this 
 way, but for some characters a
  backslash escape
  is needed, like in SML. For ex-
 ample, to denote a single quote, one has to write
  \
 . The most important back-
 slash escapes are:
  
 \a 
  
 \b 
  
 \f 
  
 \n 
  
 \r 
  
 \t 
  
 \v 
  
 \\ 
  
 \ 
  
 \"" 
  
 \0 
  
 \ddd 
  
 \xdd
  
 Bell signal (alarm) 
  
 Backspace (one character to the left) 
  
 Form feed (new sheet of paper or clear screen) 
 Newline 
  
 Carriage return (start again on the same line) 
 Tabulation (goes to next tab stop) 
  
 Vertical Tabulation (goes to next vertical tab) 
 A backslash (
 \
  ) 
  
 A single quote “”
  
 A double quote “
 ""
 ”
  
 NULL-character (value 0) 
  
 ddd
  should be a three digit octal number 
  
 dd
  should be a two digit hexadecimal number
  
 Although the type
  char
  is a separate type, it is actually part of the family of 
 integers. In C, characters are encoded by their integer equivalent. This means 
 that the character
  q
  and the integer value 113 are actually identical (assuming 
 that an ASCII encoding of characters is used). Denoting an argument to be of 
 type
  char 
 means that it is a
  small
  integer constant. The type
  char
  covers all 
 integers that are necessary to encode the character set.
  
 The fact that the characters are a subset of the integers has a number of con-
 sequences. Firstly, functions that convert characters into integers and vice versa, 
 such as the
  chr
  and
  ord
  of SML and other languages, are unnecessary. 
 Secondly, all integer operators are applicable to characters. This can be useful as 
 shown by
  
 Revision: 6.47",NA
2.4 Real numbers,"Characters and integers are sufficient to solve problems of a symbolic nature. For 
 solving numerical problems, it is often desirable to use real numbers. To explain 
 the use of real numbers in C, an algorithm that calculates
  
  is discussed. In this 
 example, 
  
 can be any real number, but 
  
 must be a non-negative integer. The 
 specification of the power operator is as follows:
  
 (2.3)
  
 The operator 
  
 is like 
  
 , except that it performs multiplications instead of addi-
 tions. The ‘Indian’ algorithm to calculate this product is based on the following
  
 Revision: 6.47",NA
2.4.1 ,NA,NA
Coercions of integers and floating point numbers,"Constants of the type
  double
  are denoted in scientific notation with a decimal 
 point and an
  e
  preceding the exponent. For example
  3.14159
  is the value of 
  
 to 
 6 digits. The speed of light in metres per second is
  2.9979e8
 . Floating point 
 and integer constants are distinguished by the presence of the decimal point 
 and/or exponent. The constant
  12
  denotes the integer twelve, but
  12.0
 ,
  12e0
  
 and
  1.2e1 
 denote the floating point number twelve.
  
 In C, doubles and integers are converted silently into each other when appro-
 priate. This is called
  coercion
 . The arithmetic operators are overloaded: applied to 
 two doubles, these operators deliver a double; applied to two integers, the result 
 is an integer; and applied to one integer and one double, the integer is coerced to 
 a double, and the result is also a double. Although this comes in handy in many 
 cases (the constant
  2
  of type
  int
  is coerced into the constant
  2.0
  of type
  
 double 
 whenever that is necessary), it can lead to unexpected surprises. Here 
 are a num-ber of typical examples:
  
 1.0 + 5.0/2.0
  
 In both C and SML, the value of this expression will be
  3.5
 . In C, the type of the 
 expression is
  double
 ; in SML it is
  real
 . The same expression with an integer
  
 5 
 instead of the real
  5.0
  is:
  
 1.0 + 5/2.0
  
 When interpreted as a C expression, the result will be the
  double 3.5
 . In this 
 case, because one of the operands of the division,
  2.0
 , is a double, the other 
 operand is coerced to a double. This means that a floating point division and not 
 an integer division is required. Thus the overloading of the division operator is 
 re-solved towards a floating point division. The result of the division,
  2.5
 , is 
 added to
  1.0
  to yield the double
  3.5
  as the total result of the expression. SML 
 does not accept this expression, since in SML the division operator
  /
  works 
 exclusively on reals. The SML system will complain about a type conflict 
 between the operands 
 2.0
  and
  5
  and the operator
  /
 .
  
 1.0 + 5/2
  
 Revision: 6.47",NA
2.5 Functions as arguments,"The functions discussed so far operate on basic values like integers, floating 
 point numbers, or characters. Functions can also have a function as an argument. 
 Func-tions with functions as arguments are called
  higher order
  functions (as 
 opposed to first order functions that operate on basic values). Higher order 
 functions are a powerful tool to the functional programmer. They can also be 
 used in C but re-quire some extra effort on the part of the programmer.",NA
2.5.1 ,NA,NA
Sums,"A common operation in mathematics, statistics, and even in everyday life is the 
 summation of a progression of numbers. We learn at an early age that the sum of 
 an arithmetic progression is:
  
 (2.5)
  
 Another useful sum, which is not so well known, adds successive odd numbers. 
 This sum can be used to calculate the square of a number:
  
 / 
  
 (2.6)
  
 It is interesting to look at the differences and similarities of these sums. The 
 differ-ences are that they may have other begin and end values than and 
  
 (although in our two examples 
 both summations range from to ), and that they may have
  
 Revision: 6.47",NA
2.5.2 ,NA,NA
Products,"The functions used in the previous section were all defined in terms of sums. 
 Sim-ilar functions can be given in terms of products. Here is the
  product
  
 function in SML:
  
 (* product : int -> int -> (int -> real) -> real *) 
 fun product i n f = if i > n 
  
  
 then 1.0 
  
  
 else f i * product (i+1) n f ;
  
 Revision: 6.47",NA
2.5.3,"Give an SML function
  nearly_phi
  using the function
  repeat
  to calculate
  
 an approximation to
  
  . You should use the first
  n
  terms of the continued
  
 fraction given by (2.9); make
  n
  an argument of
  nearly_phi
 . Transform 
 your function into C.",NA
An extended example of higher order functions: bisection,"An interesting algorithm that can be implemented with higher order functions is 
 the
  bisection method
 . Bisection is the process of reducing a larger problem to a 
 smaller problem until the problem is so small that the solution is trivial (it is an 
 example of the important class of
  divide and conquer
  algorithms). The bisec-tion 
 method can be applied to search for some particular information in a mass
  
 Revision: 6.47",NA
Interval 1,"Interval 2
  
 Interval 3
  
 Int. 4
  
 X-axis
  
 Summarising, when given some initial estimates
  
  and
  
  , the bisection method
  
 finds two points
  
  and
  
  , which are as near as possible to either side of the inter-
  
 section point. It takes max
  
  steps to reach this result.
  
 To state more accurately what ‘as near as possible’ actually means, we will have
  
 to use some mathematical notation. For the bisection method to work properly
  
 there must be two points given, and , such that
  
  . If 
  
 is a con-
  
 tinuous function, there must be a root of 
  
 between and . The bisection method
  
 tries to find such a root by calculating the arithmetic mean of and 
  
 as 
  
 .
  
 Given a particular set of values
  
  , there are three possibilities:
  
 If
  
 root). 
 1 
  
 %
  , the root has been found (or at least we are close enough to the
  
 If
  
  is positive, we need to move left and continue to use 
  
 as the new
  
 value of .
  
 The bisection method thus closes in on the root, either by moving If 
  
 1
  
  is a 
 negative number, we continue to use 
  
 as the new value of
  
  up or by mov-
  
  .
  
 ing down. The method is careful not to move either of these values past the root.
  
 In mathematical notation we write:
  
 bisection 
  
 bisection 
  
 .
  
 bisection if 
  
  
 if
  
 if 
  
 1 
 (2.10)
  
 bisection 
  
 otherwise
  
 where
  
 To express that we are close enough to the root, the bisection method uses two
  
 margins, and . We say that we are close enough to a root if either the function",NA
2.6 Summary,"The following C constructs were introduced:
  
 Revision: 6.47",NA
2.7 Further exercises,"Exercise 2.20
  Write a program that converts a temperature from Centigrade to 
  
 Fahrenheit: 
  
 o 
  
 o
  , and 
  
 o 
  
  
 o
  . Test it on 0, 28, 37 and 100 
  
 degrees Centigrade. 
    
  
 %
  
 Exercise 2.21
  Some computers offer a ‘population count’ instruction to count the 
 number of bits in an integer that are set to 1; for example, the population 
 count of 7 is 3 and the population count of 8 is 1.
  
 (a)
  Give a specification of the
  pop_count
  function.
  
 Assume that the 
 bits as follows
  
 given word
  
 is represented as a sequence of
  
  , where each of the
  
 %
  
 *
  .
  
 Revision: 6.47",NA
Chapter 3,NA,NA
Loops,"In the preceding chapter, we have used a purely functional programming style. 
 This style has the advantage that the correspondence between algorithms and C 
 implementations is close. However, it is not always possible to use this style of 
 programming in C for three reasons. Firstly, not all C data types are first class cit-
 izens; For example in C, a function cannot return an array as a result, whereas it 
 can return a structure as a result. Secondly, more efficient implementations 
 which require the use of constructs not directly available in a functional 
 language, such as loops, are sometimes possible. A good C compiler would 
 generate the same efficient code for loops and tail recursive functions. Using 
 loops to implement non-tail recursive functions makes it possible to achieve a 
 degree of efficiently be-yond what most C compilers are able to offer using just 
 recursion. Thirdly, the efficiency of the allocation and reuse of store can often be 
 improved if we do not adhere strictly to the functional style.
  
 This chapter presents a model of the store that will serve as the basis for writ-
 ing idiomatic and efficient C functions. The internal workings of these functions 
 may no longer be functional, but the interface to these functions will stay purely 
 functional. We also provide a number of techniques to assist in the development 
 of C functions from their functional counterparts. These techniques are based on 
 the use of program transformation schemas, similar to the function schema of the 
 previous chapter. The schemas of the present chapter are used to transform tail 
 re-cursive functions into loops. It is generally not possible to use a schema for 
 trans-forming non-tail recursion into tail recursion, because this requires 
 intelligence that cannot be captured in a schema.",NA
3.1 A model of the store,"Computers have a store in which data is entered, maintained, and retrieved. The 
 functional programming style hides the details of the storage management from 
 the programmer. This makes life easy. All the programmer needs to consider is 
 the algorithmic aspects of problem solving. The disadvantage of hiding the ma-
 nipulation of the store is that the programmer sometimes may wish to exert con-
 trol over exactly how data is manipulated in order to improve the efficiency of
  
 51",NA
3.2 Local variable declarations and assignments,"To illustrate how the model of the store might help us to understand C programs 
 let us now write a function that implements the addition of the four cells. This 
 pro-gram needs two new concepts, one to access the store and one concept to 
 modify the store:
  
 Store access is provided by a
  local variable declaration
 , which associates a 
 name with a cell in the store. The declaration of a local variable has the 
 following general form:
  
 = 
  
 ;
  
 Here should be a type, should be an identifier and should be the initial 
 value of the cell associated with . The value should have type . The local 
 variables can be declared immediately at the beginning of each block of 
 code (that is just after a
  {
 ). The cell can be used in the
  scope
  of the variable, 
 that is, until the end of a block of code (until the matching closing curly 
 bracket
  }
 ). A local variable declaration differs from a local constant 
 declaration in that the variable does not represent a fixed value, but instead 
 a cell where values can be stored and updated.
  
 It is good programming practice to always initialise local variables, 
 although C does not require it. An uninitialised local variable declaration 
 has the fol-lowing general form:
  
 ;
  
 Revision: 6.41",NA
3.3 While loops,"Consider the problem of finding the next leap year. The next leap year following 
 any year after 1582 is given by the specification:
  
 leap 
  
 leap 
  
 (3.1)
  
 The condition for a leap year is a bit too long for this example, so we simplify it 
  
 ! 
 #"" ! #"" 
  
 &% &% 
  
 ! #"" 
  
 only to give the right answer between 1901 and 2099 (the general case is left to 
 the reader, see Exercises 3.2 and 3.4):
  
 leap 
  
 leap
  
 - 
 (3.2)
  
 Given a particular year , a leap year cannot be far away. The following algorithm 
 ! 
 #"" 
  
 )% 
  
 moves onto the next year if the current year is not a leap year.",NA
3.3.1 ,NA,NA
Single argument tail recursion,"The execution trace of the function
  leap
  shows that recursive functions do not 
 necessarily produce efficient implementations. The problem is that the function 
 remembers all previous argument values, even though it never needs them 
 again. To remember a potentially large number of old argument values is a 
 source of in-efficiency that can, and should, be avoided.
  
 An efficient implementation of a tail recursive function requires the use of a 
 loop
 . There are several loop constructs in C. For this problem, the while-statement 
 is the most appropriate. The other loop constructs will be described later in this 
 chapter, when we will also discuss how to select a loop construct appropriate to 
 the problem being solved. The while-loop is a statement that has the following 
 syntactical form:
  
 while( 
  
 ) {
  
 }
  
 The purpose of the while-statement is to evaluate the expression , and if this 
 yields true, to execute the statement(s) of the body. The evaluation of 
  
 and 
 the execution of the body are repeated until the condition yields false. The body 
 should be constructed such that executing it should eventually lead to the con-
 dition failing and the while-loop halting. As in the case of the if-statements, the 
 curly brackets are not necessary if the body of the while-loop consists of just one 
 statement. We will always use brackets though, to make the programs more 
 main-tainable.
  
 We now show a transformation for turning a tail recursive function such as 
 leap
  into a C function using a while-statement. Consider the following 
 schematic rendering of a tail recursive function with a single argument:
  
 (*SML single argument tail recursion 
 schema*) (* 
  
 :
  
 -> 
  
 *) 
  
 fun 
  
  
 = if 
  
   
   
  
 then 
  
   
   
  
 else 
  
  
 ;
  
 Revision: 6.41",NA
3.3.2 ,NA,NA
Multiple argument tail recursion,"The function
  leap
  of the previous section has a single argument. This is too re-
 strictive. For a recursive function with more than one argument, the while-
 schema can be generalised. The standard method in functional programming for 
 general-izing a function with a single argument to one with many arguments is 
 to treat the collection of all arguments as a tuple. This tupling of the arguments 
 brings a func-",NA
3.3.3 ,NA,NA
Non-tail recursion: factorial,"Not all functions are tail recursive. To investigate the ramifications of this fact on 
 our ability to code efficient and idiomatic C functions, let us consider an 
 example: the factorial function.
  
 (3.3)
  
 We have seen the recursive SML function to compute the factorial before:
  
 (* fac : int -> int *) 
  
 fun fac n = if n > 1 
  
  
 then n * fac (n-1) 
  
 else 1 ;
  
 Revision: 6.41",NA
3.3.4 ,NA,NA
More on assignments,"Many of the while loops will have assignments with the following patttern:
  
 = 
  
 ;
  
 Here, 
  
 stands for one of the possible C operators. Examples include both assign-
 ments in the while loop of
  fac
  above:
  
 b = n*b ; 
  
 n = n-1 ;",NA
3.3.5 ,NA,NA
Breaking out of while-loops,"We are now ready to tackle the most general case of turning a tail recursive func-
 tion into an efficient loop. Consider the function
  bisection
  from Chapter 2. 
 This poses the following problems to the while-schema: the recursion has two 
 termina-tion points (see the lines marked 1 and 2) and it can continue in two 
 different ways (lines marked 3 and 4).
  
 (* bisection : (real->real) -> real -> real -> real *) 
 fun bisection f l h 
  
  
 = let 
  
  
  
  
 val m = (l + h) / 2.0 
  
  
  
  
 val f_m = f m 
  
  
  
 in 
  
  
  
  
 if absolute f_m < eps 
  
 (* 1 *) 
  
  
  
 then m 
  
   
  
  
 else if absolute (h-
 l) < delta 
  
 (* 2 *) 
   
   
 then m 
  
  
  
  
  
   
  
 else if f_m < 0.0 
  
 (* 3 *) 
   
   
   
 then bisection f m h 
  
 (* 4 *) 
  
  
  
  
  
   
 else bisection f l m 
  
  
 end ;
  
 The third and last version of the while-schema that we are about to see will be 
 fully general. It takes into account:
  
 Multiple termination points based on arbitrary predicates.
  
 Multiple continuation points based on arbitrary predicates.
  
 An arbitrary ordering of termination- and continuation-points.
  
 Local definitions.
  
 (*SML general tail recursion 
 schema*) (* 
  
 : ( * ...
   
  
  ) 
 -> 
  
 *)
  
   
    
  , ...
   
  ) 
  
 fun 
    
 ( 
  
 = let 
  
   
    
   
 val = 
  
 (* 
   
 : 
  
 *) 
  
   
    
  
 ...
  
 val 
  
 = 
   
 (* 
  
 : *) 
  
 in 
  
 if 
  
  
  
 then 
  
  
  
 else 
  
  
  
  
  
 ...
  
  
 if 
  
  
  
 then 
  
  
  
 else 
  
 end ;",NA
3.4 For loops,"C offers various different kinds of loop structure. 
  
 The while-statement is the 
 most general loop structure. A more specific but useful loop-structure is the for-
 statement. To see why the for-statement is useful, consider again the specification 
 of the factorial function :
  
 The computation of starts by generating the value and steps through the val-ues , 
 , and so on, until it reaches . The operator has built-in knowledge about the 
 following:
  
 evaluate and accumulate the values of the expression (here just ), with the 
 index bound to a sequence of values.
  
 the sequence of values is generated, starting with
  
  , incrementing the 
 value of by and ending at the value .
  
 Revision: 6.41",NA
3.4.1,"In the decreasing case, the test for termination tests on greater or equal, 
  
 >=
  
  .
  
 The iteration expression is now a 
 decrement:
  
  --
 .",NA
Factorial using a for-loop,"The increasing for-schema can be applied after substitution of the definition of 
 prod
  in that of
  fac
 . This yields the following explicitly folding version of
  fac
 :
  
 (* fac : int -> int *) 
  
 fun fac n = foldl mul 1 (1--n) ;
  
 The correspondence between the foldl-schema, the increasing for-schema, and 
 this explicitly folding version of
  fac
  is:
  
 schema:
  
 Functional
  
 C
  
  :
  
  :
  
 fac
  
 fac
  
 1
  
 1
  
  :
  
 n
  
 n
  
  :
  
 int
  
 int
  
  :
  
 int
  
 int
  
  :
  
  :
  
 mul
  
 *
  
 1
  
 1
  
  :
  
 :
  
 1
  
 1
  
 n
  
 n
  
 This yields the following C implementation below, where
  mul( accu, i )
  
 has been simplified to
  accu * i
 :
  
 int fac( int n ) { 
  
  
 int i ; 
  
  
 int accu = 1 ; 
  
  
 for( i = 1; i <= n; i++ ) { 
  
  
  
 accu = accu * i ; 
  
  
 } 
  
  
 return accu ; 
  
 }
  
 To investigate the behaviour of the for-statement, the execution of
  fac(3)
  will 
 be traced. At Step 1 the argument
  n
  is allocated, and the variable is associated 
 with the value 3.
  
 Revision: 6.41",NA
3.4.2 ,NA,NA
Folding from the right,"The for-schemas of Section 3.4 are based on the use of
  foldl
 . This is one of two 
 common folding functions:
  foldl
  folds from the left. Its dual
  foldr
  folds 
 from the right.
  
 (* foldr : (a->b->b) -> b -> a list -> b *) fun 
 foldr f r [] 
  
 = r 
  
  
 | foldr f r (x::xs) = f x (foldr f r xs) ;
  
 The difference between
  foldl
  and
  foldr
  can be visualised as shown below. 
 Here we are using a three element list for convenience. The binary folding 
 operator is
  
 Revision: 6.41",NA
3.5 Generalizing loops and control structures,"The schemas presented so far show how we can transform SML programs 
 system-atically into equivalent C programs. In this chapter, the schemas 
 transform recur-sion into loops, thus eliminating a source of inefficiency. The use 
 of the schemas that we have presented so far has two disadvantages that we will 
 address in this section.
  
 The first disadvantage is that the for-schemas of Sections 3.4 and 3.4.2 are re-
 stricted because they deal with a single arithmetic sequence only. We will 
 alleviate this restriction by allowing more general expressions in the place of the 
 arithmetic sequence.
  
 The second disadvantage is that, when larger programs are implemented 
 using the for-schemas of Sections 3.4 and 3.4.2, the resulting C code is not 
 particularly idiomatic because all the functions that result from the schemas are 
 smaller than the functions that are typically found in C programs. The reason for 
 this is that where in the functional paradigm one uses a number of functions to 
 describe a certain behaviour, in C one often writes a larger function using using a 
 number of loops and if-statements. The iterative functions that we have created 
 so far contain at most one loop. In this section, we will show how to create larger 
 C functions.
  
 As a first example program, we will show the development of a function that 
 computes the sum of the squares of the numbers , , .... As a second, more in-
 volved example, we develop a function to decide whether a number is perfect. 
 As a final example, we compute a table of powers and add all the elements of the 
 ta-ble.
  
 Revision: 6.41",NA
3.5.1 ,NA,NA
Combining,NA,NA
 foldl,NA,NA
 with,NA,NA
 map,NA,NA
: sum of squares,"Given a positive natural number
  
  , consider the problem of summing all the 
 squares from
  
  :
  
 sum of squares
  
  
 sum of squares 
 13 
  
 The SML solution can be written on the basis of the following observations:
  
 1. Generate all numbers . 
  
 This requires an arithmetic sequence 
 (1 -- 
 n)
 .
  
 2. Square each number. 
  
 This is conveniently done by mapping a function 
 square
  over all elements of the arithmetic sequence using the standard 
 function
  map
 .
  
 3. Sum the squares. For this, we use the standard function
  sum
 .
  
 Here is the auxiliary function
  square
 :
  
 (* square : int -> int *) 
  
 fun square x = x * x : int ;
  
 For ease of reference, we give the definitions of the standard functions
  map
  and 
 sum
  and an auxiliary function
  add
 , which is the curried version of the addition 
 operator
  +
 :
  
 (* sum : int list -> int *) 
  
 fun sum xs = foldl add 0 xs ;
  
 (* add : int -> int -> int *) 
  
 fun add x y = x + y : int ;
  
 (* map : (a->b) -> a list -> b list *) fun 
 map h [] 
  
 = [] 
  
  
 | map h (x::xs) = h x :: map h xs ;
  
 With these preparations, the SML version of
  sum_of_squares
  can now be 
 writ-ten as follows:
  
 (* sum_of_squares : int -> int *) 
 fun sum_of_squares n 
  
  
 = sum (map square (1 -- n)) ;
  
 To derive a C implementation of
  sum_of_squares
 , we need to be able to 
 match its SML definition to the foldl-schema. In its present form,
  
 sum_of_squares 
 does not match the foldl-schema because of the absence of a 
 call to
  foldl
  and the presence of the call to
  map
 . The first problem is easy to 
 solve by substituting the definition of
  sum
 . This exposes the
  foldl
 :
  
 (* sum_of_squares : int -> int *) 
  
 fun sum_of_squares n 
  
  
 = foldl add 0 (map square (1 -- n)) ;
  
 Revision: 6.41",NA
3.5.2 ,NA,NA
Combining,NA,NA
 foldl,NA,NA
 with,NA,NA
 filter,NA,NA
: perfect numbers,"A positive natural number 
  
 is a perfect number if it is equal to the sum of those 
 factors that are strictly less than 
  
  
 itself. Examples of perfect numbers are 6 (
  
  
 ) and 28 (
  
  
  ). The problem that we are about to solve is to 
 write a function that determines whether its argument is a perfect number. Here 
 is the specification that a perfect number has to satisfy:
  
 perfect
  
 Let us develop the solution by top-down program design: Assume that we already 
  
 perfect 
 13 
  
 ! #"" 
  
 &% 
  
  
  
  
  
 (3.5)
  
 have a function
  sum_of_factors
  to compute the sum of those factors of a 
 num-ber that are strictly less than the number itself. Then, the first part of the 
 solution is:
  
 (* perfect : int -> bool *) 
  
 fun perfect n = n = sum_of_factors n ;
  
 The second problem is to compute the sum of the factors. This problem has three 
 parts, each corresponding to the three important elements of the problem specifi-
 cation (3.5):
  
 1. Generate all potential factors of
  n
  which are strictly less than
  n
 . This 
 requires an arithmetic sequence
  (1 -- n-1)
 .
  
 Revision: 6.41",NA
3.5.3 ,NA,NA
Nested for statements,"Nested recursion, that is, recursion within recursion, is common. It is worthwhile
  
 to investigate whether the for-schema can be applied to deal with this. Consider
  
 the following problem. Given two natural numbers 
  
 and 
  
 , generate a table of
  
 the powers 
  
 of all numbers from 
  
 and 
  
 . For
  
  and
  
  , this
  
 yields the following table:
  
 0 1 2 
  
 3 
  
 4 
  
 5
  
 0 1 0 0 
  
 0 
  
 0 0
  
 1 1 1 1 
  
 1 
  
 1 1
  
 2 1 2 4 
  
 8 
  
 16 
  
 32
  
 3 1 3 9 27 
  
 81 
  
 243
  
 4 1 4 16 64 
  
 256 
  
 1024
  
 We want to compute the sum of all these powers, 1799 in the case of the above
  
 table. In general, the sum is:
  
 sum of sum of powers
  
 sum of sum of powers 
  
 (3.7)
  
 This shows a summation within a summation. It is not difficult to find a formula
  
 that computes the same answer using a single summation, but to find one that
  
 uses no summation at all is more difficult. To show how nested for-statements
  
 may be created, we will perform the double summation here.
  
 The 
  
 innermost
  
 summation of (3.7) is easily written as a function
  sum_of_powers
 . It will have
  
 two arguments,
  m
  and
  i
 :
  
 (* sum_of_powers : int -> int -> int *)
  
 fun sum_of_powers m i
  
 = sum (map (power i) (0--m)) ;
  
 An integer version of the
  power
  function from Section 2.4 can be used here to
  
 do the actual exponentiation. The technique for dealing with a combination of
  
 map
  and
  foldl
  of Section 
  
 3.5.2 gives us the following C implementation of
  
 sum_of_powers
 :
  
 int sum_of_powers( int m, int i ) {
  
 int k ;
  
 int accu = 0 ;
  
 Revision: 6.41",NA
3.6 Summary,"The following C constructs were introduced:
  
 Revision: 6.41",NA
3.7 Further exercises,"Exercise 3.15
  The function
  sum_of_sum_of_powers
  is rather inefficient if it 
  
 uses a naive
  power
  function, that is one that performs 
  
 multiplications 
  
 to compute 
  
 . Rewrite
  sum_of_sum_of_powers
  such that it completely 
  
 avoids the use of a
  power
  function, and thus makes the least possible 
 num-
  
 ber of multiplications.
  
 Exercise 3.16
  Exercise 2.21 required the implementation of a
  pop_count
  func-
  
 tion. Implement this function in C with a loop.
  
 Exercise 3.17
  Exercise 2.25 required the implementation of a
  power_of_power 
 function. Reimplement the C function using loops. Try to embed the func-
 tions into each other so that you don’t have an auxiliary function
  power
 .
  
 Exercise 3.18
  Write a C function
  chess_board
  with two integer arguments 
  
 width
  and
  height
  to print out a
  width height
  chess board using 
 ASCII 
  
 characters. If
  width
  
  and
  height
   
  the output should look as fol-
  
 lows:
  
 --------
 -
  
 | 
 |X| 
 |X|
  
 --------
 -",NA
Chapter 4,NA,NA
Structs and Unions,"The functions discussed so far operate on either integers, booleans, characters, 
 floating point numbers, or functions. These are all primitive types in C (with re-
 strictions) and in SML (without restrictions). Like SML, C has support for
  struc-
 tured
  data. In its simplest form, structured data makes it possible to gather into 
 one object a collection of previously defined values of particular types. This 
 builds a structured data type from a collection of previously defined types. This 
 is, for example, supported with the tuple of SML and with the
  struct
  of C. 
 These so-called ‘flatly structured aggregate data types’ are the subject of this 
 chapter. In subsequent chapters we will look at other forms of structured data, 
 namely se-quences of data items (arrays, Chapter 5) and recursively structured 
 data types (lists, Chapter 6).",NA
4.1 Structs,"The primitive data structures discussed in the previous chapter make it possible to 
 pass single numbers around. Often, one is not interested in single numbers but in 
 a collection of numbers. An example of a collection of numbers is a point in a 
 plane, say . The point is represented by a tuple
  
  , where
  
  is the X-
 coordinate and
  
  
  
  is the Y-coordinate. An operation that one may wish to perform 
 on a point is to rotate it around the origin. To rotate a point
   
  
  around 
 the origin by 90 degrees in the clockwise direction, we compute a new point, say , 
 with coordinates
  
  and
  
  :
  
 Here is the type
  point
  in SML:
  
 type point = real * real ;
  
 The SML rotation function takes a
  point
  and computes the rotated point as 
 shown below. For the name of this function, we would have liked to use ‘new-
 point-which-is-the-old-one-rotated’. 
  
 This would express our intentions clearly.
  
 101",NA
4.2 Structs in structs,"A
  struct
  can be used not only to gather primitive data types into a flatly struc-
 tured data type, but also to build more complex data structures out of those 
 previ-ously built. Given that we have available the type
  point
 , it is possible to 
 create a new type
  rectangle
  by listing the coordinates of the lower left and 
 upper right corners of the rectangle. A function that calculates the area of the 
 rectangle would be:
  
 area
  
 area
  
 .
  
 (
  
 (4.1)
  
 The SML type
  rectangle
  uses
  point
  as follows:
  
 type rectangle = point * point ;
  
 Using this new data type, the SML function
  area
  is: (the function
  absolute
  is 
 defined in Section 2.5.3):
  
 (* area : rectangle -> real *) fun area 
 ((llx,lly),(urx,ury)) = absolute ((urx-
 llx) * (ury-lly)) ;
  
 Revision: 6.37",NA
4.3 Unions in structs: algebraic data types,"A tuple can be used to store a collection of values, but a tuple does not suggest 
 how the type is being used in the program. If one has a tuple of two integers, for 
 example
  (7,4)
 , then this tuple can encode a date (the 7th of April, or the 4th of 
 July, depending on the country you are in), but it could also encode a time (7:04 
 pm), or a fractional number ( ). Algebraic data types are used instead of tuples 
 when a particular data type may have different interpretations and/or alternative 
 forms. For example, the following type can be defined in SML to encode a 
 distance in either ˚Angstr¨oms, miles, kilometres, or light years.
  
 datatype distance = Angstrom 
  
 of real |
  
 Revision: 6.37",NA
4.3.1 ,NA,NA
Union types,"The general form of the
  union
  definition is similar to that of a
  struct
  definition:
  
 union { 
  
  
  
 ; 
  
  
  
 ; 
  
  
 ...
  
 }
  
 Here the
  
  are the types and the are the names of the members of the
  union
 . 
 The difference between a
  struct
  and a
  union
  is that the latter stores just one 
 of its members at any one time, whereas the former stores all its members at the 
 same time. A
  struct
  is sometimes called a product of types, while a
  union
  is 
 a sum of types. In SML, we have the same distinction: the alternatives in an 
 algebraic data type declaration (as separated by vertical bars) represent the sum 
 type, and the types within each alternative represent a product type.
  
  
 The storage model can be used to visualise the differences between a
  
 struct 
 and a
  union
 . Assume that we have a structure
  pair
  which is defined 
 as follows:
  
 typedef struct { 
  
  
 int x ; 
  
  
 int y ; 
  
 } pair ;
  
 Below are a structure (
 structx
 ) and a union (
 unionx
 ), with their respective 
 stor-age requirements:",NA
4.3.2 ,NA,NA
Pattern matching: the switch statement,"SML functions using algebraic data types need pattern matching to select which 
 data is stored. In C, this pattern matching is conveniently implemented using a 
 switch statement
 . The switch selects one out of many options in one operation:
  
 switch(
  
 ) {
  
 ;
  
 case
  
 :",NA
4.3.3 ,NA,NA
Algebraic types in other imperative languages,"From a theoretical point of view the
  struc
  and
  union
  of C are well designed. 
 The language offers product types (the struct) and sum types (the union). These 
 are essentially separate concepts, so the language should have separate notations 
 for these concepts. However, from a programming point of view, it is not so clear 
 that these two concepts should be kept separate at all times. The problem is, that 
 as we have seen, there is nothing in a sum type (the union) to help us distinguish 
 between the various cases. The theorist has two notions of sum types: the disjoint 
 sum and the coalesced sum. The disjoint sum makes it possible to distinguish be-
 tween the different variants of the sum type; the coalesced sum makes this 
 impos-sible. Such a distinction could have been made in C but it has not been.
  
 There is only one way to safely use a union in C, that is when the union is em-
 bedded in a struct. In this context we can store, together with the union itself, the 
 tag that remembers which of the variants of the union is stored. The designers of
  
 Revision: 6.37",NA
4.4 Pointers: references to values,"Until this moment, every data structure has been handled
  by value
 , in exactly the 
 same way as SML and other functional languages treat data structures. Handling 
 large data structures by value can be inefficient, as they must often be copied. In 
 SML, the compiler can optimise the code so that large data structures are passed 
 by reference
  instead of by value. In C, the programmer must explicitly use a call 
 by reference mechanism if data structures are not to be copied.
  
 In C, the call-by-reference mechanism is based on manipulating, not the data 
 itself, but
  pointers
  to the data. A pointer is a reference to a place where data is 
 stored, it is pointing to some data location. In terms of a von Neumann machine, 
 a pointer is the address of a memory location. A pointer is itself a value, so that 
 one can perform operations on a pointer as well as on the data.
  
 The pointer concept provides the means to implement any conceivable opera-
 tion on data, but the mechanism itself is of a low level of abstraction. Its proper 
 use is more difficult to master than the use of data structures in functional lan-
 guages, but the rewards in terms of increased efficiency may be considerable. Af-
 ter explaining the basic principles of pointers, an example program will show 
 how pointers are used to improve efficiency.",NA
4.4.1 ,NA,NA
Defining pointers,"Consider an example, where we have an integer
  i
  and a pointer
  p
  which refers 
 to 
 i
 . In terms of a storage model, this can be visualised as follows:
  
 Revision: 6.37",NA
4.4.2,"(a)
  Is
  *&i
  the same as
  i
  (given that
  i
  is a variable of type
  int
 )?
  
 (b)
  Is
  
 *&
  
  the same as
  
  for all
  
  ?
  
 (c)
  Is
  &*p
  the same as
  p
  (given that
  p
  is a variable of type
  int *
 )
  
 (d)
  Is
  &*
  the same as for all ?",NA
Assignments through pointers,"After pointers have been defined, one can not only access values through them 
 (as shown in the previous section), but also write values through pointers. 
 Assign-ing values through pointers is a low level activity, which can cause havoc 
 in big programs. Consider the following function:
  
 void pointer_assignment( void ) { 
  
 int 
  
 i = 123 ; 
  
  
 int 
  
 j = 1972 ;
  
 Revision: 6.37",NA
4.4.3 ,NA,NA
Passing arguments by reference,"One of the main uses of pointers in C is to pass function arguments by reference, 
 instead of by value. 
  
 Rather than passing the value to the function, we pass a 
 pointer to the value to the function. When used carefully, this has two 
 advantages:
  
 1. Passing a pointer to a large data structure is more efficient than passing the 
 data structure itself. Passing a data structure by value will cause the imple-
 mentation to make a copy of the data structure and to pass that to the func-
 tion, while passing a data structure by reference only passes a pointer.
  
 2. Data structures that are passed by reference can be modified. The modifica-
 tion of values should be performed with utmost care, as the modifications 
 will be visible to any procedure using the data structure.
  
 To show these two advantages, we will use the core of a personnel information 
 system as an example. The personnel system stores the employee’s number, 
 salary, year of birth, and first year of employment in a 4-tuple:
  
 employee
  
 The SML representation of this 4-tuple is:
  
 type employee = int * real * int * int ;
  
 The operation defined on the type
  employee
  is a function that may be used to 
 give the employee a pay rise by a given percentage:
  
 (* payrise : employee -> real -> employee *) 
  
 fun payrise (nr, salary, birth, employed) inc 
  
  
 = (nr, salary * (1.0+inc/100.0), birth, employed) ;
  
 The C version of the data type
  employee
  is the following:
  
 typedef struct { 
  
  
 int employee_number ; 
  
  
 double salary ; 
  
  
 int year_of_birth ; 
  
  
 int year_of_employment ; 
  
 } employee ;
  
 There are two ways to implement the function
  payrise
 ; it can be implemented 
 in an applicative way, or in an imperative way. Applicative means that data 
 items, once they have been created, will not be changed. Imperative means that 
 data items may be changed. The applicative implementation of
  payrise
  
 follows the pattern that we have seen before:
  
 employee payrise_ap( employee e, double inc ) { 
  
 e.salary = e.salary * (1 + inc/100) ; 
  
  
 return e ; 
  
 }
  
 Revision: 6.37",NA
4.4.4 ,NA,NA
Lifetime of pointers and storage,"Passing around references to values opens a large trap in C. Consider the follow-
 ing code fragment:
  
 int *wrong( void ) { 
  
  
 int x = 2 ; 
  
  
 return &x ; 
  
 }
  
 int main( void ) { 
  
  
 int *y = wrong() ; 
  
  
 printf(""%d\n"", *y ) ; 
  
  
 return 0 ; 
  
 }
  
 The function
  wrong
  is
  legal
  C; no compiler will complain about the code. The 
 func-tion has a local variable, initialised with the value 2, and a pointer to this 
 value is returned as the function result. The typing of this function is correct, 
 since
  x
  is of",NA
4.5 Void pointers: partial application,"The functions that have been discussed so far operate on one specific type. This 
 can be a bit restrictive; it is useful to be able to create functions that have argu-
 ments of a generic type. Pointers in C offer a mechanism that allows values of an 
 unspecified, generic type to be passed. To see why arguments of a generic type 
 can be useful, consider again the function
  bisection
  as discussed in Section 
 2.5.3. It determines the root of a function in a given interval. It is likely that the 
 roots of a 
 parametrised
  function may also be needed. For example, one might 
 want to deter-",NA
4.5.1 ,NA,NA
The danger of explicit type casts,"It is enlightening to introduce explicit type casts. An explicit type cast has the fol-
 lowing general form:
  
 ( )
  
 Here is the type to which the variable 
  
 has to be cast. Therefore
  (double) 2 
 has the same type and value as
  2.0
 . Likewise, the assignment in
  parabola
  
 above could have been written:
  
 double *c = (double *) p ;
  
 Alternatively, the problem with the incorrect typing in
  main
  could have been 
 solved by calling
  extra_bisection
  with:
  
 extra_bisection( (double (*)(void *,double)) parabola, 
  
 &c, 4.0, 7.0) ; 
  
 /*initialise dd*/ 
  
 extra_bisection( (double (*)(void *,double)) quadratic, 
  
 &dd, 4.0, 7.0 ) ;
  
 Revision: 6.37",NA
4.5.2 ,NA,NA
Void pointers and parametric polymorphism,"There is an important difference between parametric polymorphism in a strongly 
 typed language and the use of
  void *
  in C. In a strongly typed language, dif-
 ferent occurrences of the same type variable must all be instantiated to the same 
 type. In C, different occurrences of
  void *
  may represent different types, as the 
 type
  void *
  stands literally for a pointer to anything. As an example, consider 
 again the C version of
  extra_bisection
 , where the type
  void *
  appears 
 twice in the function prototype:
  
 double extra_bisection( double (*f)( double, void *), 
  
 void * x, double l, double h
  
 )
  
 The first and the second declaration of
  void *
  have no relation according to the 
 C language definition. This should be contrasted with the type of the SML 
 definition of the same function which is:
  
 (* extra_bisection : (a->real->real) -> 
  
  
 a -> real -> real -> real *)
  
 Here the type variable
  a
  refers to the one and the same type. In more complex 
 definitions, various type arguments can be used (
 a
 ,
  b
 , ...); in C, they are all the 
 same,
  void *
 .
  
 Type consistency is a valuable property as it prevents programming errors. In 
 the example above, the function
  extra_bisection
  could have been called as 
 follows:
  
 char t ; 
  
 extra_bisection( quadratic, &t, 0, 1 ) ;
  
 This is completely legal C:
  &t
  is a pointer to a character, so it conforms to the 
 type 
 void *
 . The function
  quadratic
  requires a pointer to a structure, so it 
 also con-forms to the type
  void *
 . The fact that this character pointer is going 
 to be used (in
  quadratic
 ) as a pointer to a structure is not noted by the 
 compiler, since it does not enforce the consistent use of polymorphic types. 
 Polymorphism is dis-cussed in more detail in Chapter 6.
  
 Revision: 6.37",NA
4.6 Summary,"The following C constructs have been introduced:
  
 Data type constructors
  A
  struct
  can hold a collection of values, which are 
 logi-cally one entity. A
  union
  can hold one value of a number of different 
 types of values. They are defined as follows:
  
 typedef struct 
  
  
 /*optional name*/ 
 { 
  
  
  
 ; 
 ... 
  
 ; } 
  
  
 ;
  
 typedef union 
  
  
 /*optional name*/ { 
  
  
  
 ; ... 
  
 ; 
 } 
   
 ;
  
 Here
  
  and
  
  are the types and names of the members. The
  struct
  can 
 op-tionally be supplied with a structure-name. (This will be discussed in 
 Chap-ter 6).
  
 Structure and union members are accessed using the ‘
 .
 ’ operator. The nota-
 tion
  . 
  
 accesses field 
  
 of variable .
  
 Switch
  A
  switch
  statement allows the programmer to choose one alternative 
 out of many. The switch statement has the following syntax:
  
 switch( 
   
 ) { 
  
  
 case 
  
 : 
  
  
 case 
  
 : 
  
  
 ...
  
  
 default : 
  
 }
  
 Revision: 6.37",NA
4.7 Further exercises,"Exercise 4.10
  The C languages offers operators to create and dereference pointers.
  
 (a)
  Explain the relationship between the C language operators
  *
  and
  
 &
 . 
 (b)
  What is the output of the following program?
  
 int main( void ) { 
  
  
 int i = 3 ; 
  
  
 int * p = & i ; 
  
  
 int * * q = & p ; 
  
  
 printf( ""%d %d %d %d %d %d %d\n"", 
  
  
  
 3, i, p==*q, *p, q==& p, *q==&i, **q ) ; 
  
 return 0 ; 
  
 }
  
 (c)
  State what the output of the following program would be and explain 
 why.
  
 int twice( int (*f) (int), int a ) { 
  
 return f( f( a ) ) ; 
  
 }
  
 int add( int a ) { 
  
  
 return a + 1 ; 
  
 }
  
 int main( void ) { 
  
  
 printf(""%d\n"", twice( add, 2 ) ) ; 
  
 return 0 ; 
  
 }
  
 (d)
  Which are the differences between the program below and that of 
 question (c)?
  
 int twice( int (*f) (int, int, int), 
  
  
 int x, int y, int a ) { 
  
 return f( x, y, f( x, y, a ) ) ; }
  
 int add( int a, int b, int c ) { 
  
  
 return a + b + c ; 
  
 }
  
 int main( void ) {
  
 Revision: 6.37",NA
Chapter 5,NA,NA
Arrays,"The C
  struct
  of the previous chapter provides the means to collect a
  small, 
 fixed 
 number of data items in a single entity. The items may be of different types. 
 The main topic of this chapter is the
  array
  data structure. An array gathers an
  
 arbitrary 
 number of elements into a single entity. The elements of an array must 
 all be of the same type. Sample applications of arrays are vectors of numbers and 
 databases of records.
  
 There are other data structures designed to store a sequence of data items of 
 identical type, the
  list
  for example. Although the purpose of lists and arrays is the 
 same, the data structures have different performance characteristics. For this 
 reason, some problems must be solved by using lists (arrays would be 
 inefficient), while for other problems the programmer should choose to use 
 arrays (because lists would be inefficient).
  
 Although lists and arrays can be expressed both in imperative and in func-
 tional languages, the ‘natural’ data structure for both paradigms is different. 
 Han-dling arrays in a functional language can be inefficient, since a purely 
 functional semantics does not allow elements of the array to be updated without 
 creating a new version of the whole array. (We ignore the non-declarative 
 extensions of SML and sophisticated compiler optimisations designed to detect 
 single threaded use of arrays). Handling lists in C can be cumbersome, as 
 memory has to be managed explicitly. For these reasons, problems that do not 
 have a specific preference for either lists or arrays are generally solved with lists 
 in a functional language, but implemented in C using arrays. In the next chapter 
 we compare the efficiency of list and array representations.
  
 This chapter is the first of three that discuss the implementation of sequences 
 of data. Therefore the present chapter starts with a model to explain how one can 
 reason about sequences. After that, the representation of arrays in C is explained. 
 Arrays in C are of a low level of abstraction, that is the programmer has to be 
 con-cerned with all details of managing arrays. Arrays in C can be used to build 
 pow-erful abstractions, that hide some of the management details.
  
 While discussing arrays, we present the concept of
  dynamic
  memory. This is 
 needed to implement dynamic arrays and also to implement lists in C, as shown 
 in Chapter 6.
  
 133",NA
5.1 Sequences as a model of linear data structures,"From an abstract point of view, an array is a
  sequence over a set of values
 . A se-
 quence is defined as a function from natural numbers to a set of values. A 
 familiar example is a string: it is a sequence of characters. A string can be 
 interpreted as a function by explicitly listing all possible argument/result pairs of 
 the function. We write such pairs using the ‘maplet’ symbol 
  
 . Here are the 
 strings “cucum-ber” and “sandwich” represented as functions and respectively.
  
 - 
  
  
 % 
  
 (5.1)
  
 % 
  
 (5.2)
  
 Note that these sequences start with the index 0: they are
  zero-based
 . 
  
 Further-
 more, each sequence numbers the elements consecutively. Indeed, sequences can 
 be generalised to start at arbitrary numbers, to leave ‘gaps’ in the domain, or to 
 use any other discrete domain. Such more advanced data structures include
  as-
 sociative arrays
  and
  association lists
 . They are beyond the scope of this book; the 
 interested reader should consult a book on algorithms and data structures, such 
 as Sedgewick [12].
  
 The advantage of the interpretation of an array as a sequence is that many 
 use-ful operations on sequences can be expressed using only elementary set 
 theory. We will discuss the five most important sequence operations in the 
 following sec-tions. The first three operations, taking the length of a sequence 
 and accessing and updating an element of a sequence, are used immediately 
 when we define arrays. The next two operations, concatenating two sequences 
 and extracting a subsequence from a sequence, are used when discussing lists in 
 Chapter 6.",NA
5.1.1 ,NA,NA
The length of a sequence,"The length of a sequence is the cardinality of the set of argument/result pairs. We 
 will denote the cardinality of a set as
  
  . For the set defined by (5.2), we have
  
  
 .",NA
5.1.2 ,NA,NA
Accessing an element of a sequence,"To access an element of a sequence, we can apply the sequence (which is a func-
 tion!) to a natural number. The -th element of the sequence is
  
  ; for example, 
 the last character of the string (5.1) is 
  
 . The function to access an 
 element will almost always be partial. This means that an undefined value is 
 obtained if we try to access an element of a sequence that is outside its domain,",NA
5.1.3 ,NA,NA
Updating an element of a sequence,"The third operation that we need is updating a sequence. When given a sequence
  
  and an index domain
  
  , then the sequence
  
  is the same as except
  
 at the index position where it has the value :
  
 . 
  
 / 
 domain 
  
 (5.3)
  
 For example, the sequence from (5.2) can be updated as follows:
  
 %",NA
5.1.4 ,NA,NA
The concatenation of two sequences,"To concatenate two sequences, the set union operator seems appropriate, but with
  
 a twist. If we try to concatenate the two strings and above by naively writing
  
  , the result would be a relation but not a function:
  
 %
  
 When two sequences are concatenated, we must decide explicitly which one will
  
 be the first part of the resulting sequence and which one will the last part. The
  
 domain of the sequence that will be the last part must be changed. To do this, we
  
 define the operator to denote string concatenation as follows:
  
 - 
  
 - 
 domain 
  
 (5.4)
  
 Applying the concatenation operator to the two strings of (5.2) and (5.1) yields a
  
 proper function:
  
 %
  
 The definition of the concatenation operator looks a bit complicated because con-
  
 catenation
  is
  actually a complicated operation. When one array is concatenated
  
 with another in a program, at least one of them must be copied to empty cells at
  
 the end of the other. (If there are no empty cells, then both of them need to be",NA
5.1.5 ,NA,NA
The subsequence,"With the concatenation operator we can build larger sequences from smaller 
 ones. It is also useful to be able to recover a subsequence from a larger sequence. 
 When given that 
  
 domain
  
  , then a subsequence
  
  of a sequence can be 
 defined as follows:
  
 . 
  
 / 
 domain 
 . 
  
 (5.5)
  
 The lower bound of the subsequence is , and the upper bound is . The domain of 
 the resulting subsequence is changed, so that the index of the left most element 
 of every sequence is always 0.
  
  
 As an example, we will take the subsequence corresponding to the string 
 “and”from the string “sandwich”:
  
 We now have at our disposal a notion of sequences based on elementary set the-
 % 
  
 ory. Sequences will be used in this chapter to specify a number of operations on 
 arrays. In the next chapter, we shall look at alternative implementations of se-
 quences based on lists.",NA
5.2 Sequences as arrays in SML,"Arrays are not part of the SML language, but the SML/NJ implementation offers 
 the type
  array
  as part of the standard library. We will be using the SML/NJ ar-
 ray to represent a sequence. Several functions are defined on the type
  array
 ; 
 we will briefly review the most important ones here. Like our sequences, arrays 
 in SML/NJ are zero-based. The index of the first element is always 0, and the 
 index of the last element is always
  n-1
  where
  n
  is the length of the array.",NA
5.2.1 ,NA,NA
Creating an SML array,"An array is created by one of two functions,
  array
  or
  tabulate
 . The first is 
 the least powerful of the two:
  array(n,v)
  creates an array of length
  n
  such 
 that all array elements have the initial value
  v
 . This corresponds to the 
 following se-quence:
  
 array(n,v)
  
 % 
  
 ...
  
 The type of the SML
  array
  function is:
  
 (* array : int * a -> a array *)",NA
5.2.2 ,NA,NA
The length of an SML array,"The number of elements of an array
  s
  is given by the function
  length(s)
 . 
 This corresponds directly with the operation 
  
 on a sequence. The type of
  
 length
  is:
  
 (* length : a array -> int *)
  
 In SML/NJ the name
  length
  is used for both lists and arrays, but
  length
  is 
 not overloaded. When using arrays and lists in the same SML module one 
 should be careful to indicate whether
  Array.length
  or
  List.length
  is 
 needed.",NA
5.2.3 ,NA,NA
Accessing an element of an SML array,"The function
  sub(s,i)
  accesses the
  i
 -th element of an array
  s
 . This 
 corresponds directly to accessing an element of a sequence using the operation
  
  
 . Trying to access an element that is not within the domain of the array gives an 
 error. The type of
  sub
  is:
  
 (* sub : a array * int -> a *)",NA
5.2.4 ,NA,NA
Updating an element of an SML array,"The final operation that we need is an array update. This
  upd
  operation can be 
 defined if we follow closely the specification of the sequence update
  
  :
  
 (* upd : a array * int * a -> a array *) fun 
 upd(s,k,v) = let 
  
  
  
 val n 
  
 = length(s) 
  
  
  
 fun f i = if i = k 
  
  
  
  
  
 then v 
  
  
  
  
  
 else sub(s,i) 
  
 in 
  
  
  
 tabulate(n,f) 
  
  
 end ;",NA
5.2.5 ,NA,NA
Destructive updates in SML,"SML provides a built-in function
  update
 , which has a completely different be-
 haviour from that of our function
  upd
 . The type of
  update
  is:
  
 (* update : a array * int * a -> unit *)
  
 The result type of the function is
  unit
 , not
  a array
 . This implies that the 
 func-tion can only do useful work by updating one of its arguments as a side 
 effect. In this particular case it changes the contents of the array
  destructively
 . 
 SML provides the side effecting function
  update
  purely for efficiency reasons. 
 It is costly to cre-ate a new array just to change one element. If the programmer 
 knows that the old array is not going to be needed again, then no harm is done 
 by reusing the cells occupied by the old array and changing its value. However, 
 the function
  update 
 can be used only when the programmer is sure that the 
 old contents of the array are not going to be used again.
  
 In general, it is difficult to know when it is safe to use
  update
 , so we 
 discour-age its use. In this book, we do not make use of
  update
 , so as not to 
 blur the division between the algorithmic aspects of programming, for which we 
 use SML, and the problem of creating efficient programs, for which we use C.
  
 This completes the representation of sequences in SML. The implementation 
 of the two remaining useful functions corresponding to concatenation and subse-
 quencing are left as an exercise.
  
 Exercise 5.1
  Give an SML function
  concatenate(s,t)
  to concatenate two ar-
  
 rays
  s
  and
  t
 .
  
 Exercise 5.2
  Define an SML function
  slice(s,l,u)
  to return the data of the 
 ar-ray
  s
  from index
  l
  to index
  u
  as a new array. This corresponds to 
 taking a subsequence.",NA
5.3 Sequences as arrays in C,"Arrays form a proper part of the C language. In this section we give a brief 
 general overview of the arrays. We will elaborate each concept in considerable 
 detail in subsequent sections.",NA
5.3.1 ,NA,NA
Declaring a C array,"In C an uninitialised array is declared as follows:
  
  [ ] ;
  
 Revision: 6.37",NA
5.3.2 ,NA,NA
Accessing an element of a C array,"An array can be subscripted using the expression.
  
  [ ]
  
 Here is an array and is an integer valued expression. As in our sequences and
  
 in SML, the lower bound of an array in C is always 0. Thus the first element of is
  
 the element with index 0. The upper bound of the array is the number of elements
  
 in the array minus 1. For example, if an array has elements, the array bounds are
  
 %
  and .",NA
5.4 Basic array operations : Arithmetic mean,"We will now discuss the arrays of C in more detail. Consider the problem of cal-
  
 culating the arithmetic mean of a sequence of numbers. The mean of a sequence
  
 of numbers is defined as:
  
 where 
  
 (5.6)
  
 All numbers of the sequence are to be added together, and the sum should be di-
  
 vided by the length of the sequence. Here is the SML algorithm to compute the
  
 Revision: 6.37",NA
5.5 Strings,"In the second chapter, we introduced string constants. We postponed discussing 
 the type of this string constant. Now that arrays have been introduced, the type 
 of strings and their usage can be discussed in greater detail.
  
  
 In C, a string is stored as an array of characters. A string constant is denoted 
 by a series of characters enclosed between double quotes
  ""
 . If there are 
  
 characters between the quotes, the compiler will store the string in an array of
  
  
  charac-ters. The first characters hold the characters of the string, while the 
 element with index
  
  (the
   
  -th element, as the first element has index 
 %
  ) holds a special char-
 acter, the NULL-character. The NULL-character, denoted as
  \0
 , signals the end 
 of a string.
  
 The motivation for ending a string with a NULL-character is that any 
 function can now determine the length of a string, even though C does not 
 provide a mech-anism to determine the size of an array. By searching for the 
 NULL-character, the end of the string can be found. Note that a string cannot 
 contain a NULL-character",NA
5.5.1 ,NA,NA
Comparing strings,"The function
  strlen
  above is one of a dozen string processing functions that 
 are predefined in the standard C library. The most important of these functions 
 are discussed below, as they allow programmers to handle strings without 
 reinvent-ing string processing functions over and over again. To use these 
 functions the following include directive must be present in the program.
  
 #include <string.h>
  
 The first two functions to be discussed are functions that compare strings. In 
 many modern languages the relational operators,
  ==
 ,
  >=
 , and so on, can be 
 used to com-pare arbitrary data. In C, the relational operators work on 
 characters, integers, and floating point numbers, but they do not operate 
 structured data, and hence, not on strings. Instead, the programmer must call a 
 function
  strcmp
 . This function has two strings as arguments and returns an 
 integer: zero if the strings are equal, a negative number if the first string is ‘less 
 than’ the second string, and a positive number if the first string is ‘greater than’ 
 the second. Less than and greater than use the underlying representation of the 
 character set (as integers) to order strings.
  
 The following inequalities are all true:
  
 strcmp( ""monkey"", ""donkey"" ) > 0, 
 strcmp( ""multiple"", ""multiply"" ) < 0,
  
 Revision: 6.37",NA
5.5.2 ,NA,NA
Returning strings; more properties of arrays,"The functions
  strlen
 ,
  strcmp
 , and
  strncmp
  all deliver an integer as the 
 result value (returning the length of the string or the result of the equality test). 
 More complicated operations, like string concatenation, require the returning of 
 a string as a result. In C, it is not possible for a function to return an array as a 
 result. Ar-rays in C are ‘second class citizens’. In a functional language, an array 
 is a first class citizen in that it can be manipulated in exactly the same way as any 
 other data type. In C, arrays cannot be assigned and an array cannot be returned 
 as function result. Furthermore, when an array is passed as an argument to a 
 func-tion, a special parameter passing mechanism is used. Instead of passing an 
 array by value, as is done for basic data types, an array is passed by reference.
  
 Because of these restrictions on arrays, functions that need to return a string 
 (or any other array) must do some in a special way. Below, we will introduce a 
 first so-lution. Section 5.7 shows a more elegant method that requires the use of 
 dynamic memory. As an example program, we will discuss the function
  
 strcpy
  that copies one array to another array. This is an operation which is not 
 necessary in SML, but in C it is a necessary operation (as strings cannot be 
 assigned). Because the copy-ing function cannot return a string, the array where 
 the result appears is passed as an argument to the function. The C program 
 below defines and uses the function 
 strcpy
 . This function is part of the 
 standard library, so it is given here by way of example only:
  
 void strcpy( char output[], char input[] ) { 
  
 int i = 0 ; 
  
  
 while( input[i] != \0 ) { 
  
  
  
 output[i] = input[i] ; 
  
  
  
 i = i + 1 ; 
  
  
 } 
  
  
 output[i] = \0 ; 
  
 }
  
 int main( void ) { 
  
 char s[ 10 ] ; 
  
 strcpy( s, ""Monkey"" ) ;
  
 Revision: 6.37",NA
5.5.3 ,NA,NA
An application of arrays and strings:,NA,NA
 argc,NA,NA
 and,NA,NA
 argv,"Most of the programs that we have seen so far are written for one specific pur-
 pose. They compute the answer to just the one problem that they are intended to 
 solve. The programs are not capable of finding solutions to even slightly 
 different problems. This is too restricted. It is possible to make programs a bit 
 more flexible by allowing the user of the program to pass some information to it. 
 In SML, one would type the name of the main function and give various 
 different arguments to the function. In C, we can use something similar, but a 
 little more effort is required to make it work. The main function of a C program 
 has hitherto been declared as having the following type:
  
 int main( void )
  
 This type states that no information (
 void
 ) is passed to the main function and 
 that an integer value should be returned. C permits us to declare the type of
  
 main
  as follows:
  
 int main( int argc, char * argv[] )
  
 This states that the function
  main
  takes two arguments:
  
 argc
  is an integer that tells how many strings are passed to the program. The 
 value of
  argc
  is at least 1.
  
 Revision: 6.37",NA
"5.6 Manipulating array bounds, bound checks","In the previous section it has been shown that three issues regarding the bounds 
 of arrays in C are different from arrays in other languages:
  
 Revision: 6.37",NA
5.7 Dynamic memory,"Arrays as discussed so far have two serious limitations:
  
 1. The array size has to be fixed statically. In the example of the histogram, it 
 was assumed that the string had only lowercase letters: the bounds were 
 fixed at
  a
  and
  z
 .
  
 2. The lifetime of an array that is declared in a function is limited.
  
 Revision: 6.37",NA
5.7.1 ,NA,NA
The allocation of dynamic arrays,"The histogram function had both limitations mentioned above: the array bounds 
 were limited and the array had to be passed as an extra argument to the function. 
 In the functional version, the array was also specified with fixed bounds. At first, 
 we give an array type with arbitrary bounds in SML. The elements of the 
 dynamic array are restricted to type integer.
  
 type dynamic_array = int array * int * int ;
  
 The type
  dynamic_array
  comprises a zero-based array, the desired lower 
 bound, and the upper bound. To avoid confusion, we will use the term zero-
 based array for the proper, zero-based array. When we refer to a dynamic array, 
 then this includes the
  dynamic_array struct
  as well as the zero-based 
 array. The type of a dynamic array in C could be defined as follows:
  
 typedef struct { 
  
 int *data ; 
  
  
 int lb ; 
  
  
 int ub ; 
  
 } dynamic_array ;
  
 /* The zero-based array */ 
  
 /* Lower bound of dynamic array */ 
 /* Upper bound */
  
 The
  dynamic_array
  data structure holds a pointer to the zero-based array
  
 data 
 as well as the bounds of the array in two integers
  lb
  and
  ub
 . The 
 elements of the zero-based array are all of type
  int
 . Thus, the proper zero-
 based array is not part of the struct
  dynamic_array
 ; only a pointer to the zero-
 based array is part of the struct.
  
 To create an initialised dynamic array in SML we write:
  
 (* array_alloc : int -> int -> dynamic_array *) 
 fun array_alloc l u = (array(u-l+1,0),l,u) ;
  
 To create a dynamic array in C, the storage for it has to be
  allocated
 . This alloca-
 tion operation is performed by calling the C library function
  calloc
 , defined in 
 stdlib.h
 . The arguments passed to
  calloc
  are the number of cells needed 
 and the size of each cell. A dynamic array with a given pair of bounds therefore 
 can be allocated using the following function:
  
 #include <stdlib.h>
  
 dynamic_array array_alloc( int l, int u ) { 
 dynamic_array da ; 
  
 da.lb = l ;
  
 Revision: 6.37",NA
5.7.2 ,NA,NA
The extension of dynamic arrays,"In the histogram program, a dynamic array must be extended when an element 
 is encountered that is not in the range of the array. Extending arrays is an 
 expensive operation, for in the general case, we may not assume that an array 
 can be ex-tended by claiming more space. The problem is that other dynamically 
 allocated data structures may occupy that extra space already. The only safe way 
 of extend-ing an array is by copying its contents to a new area of store, that does 
 allow for extra room. This problem is not specific to C, any language that offers 
 arrays is faced with this difficulty.
  
  
 In SML, the extension of a dynamic array is taken care of by the function 
 extend
 , shown below:
  
 (* extend : dynamic_array -> int -> int -> dynamic_array *) 
 fun extend (old,old_lb,old_ub) l u 
  
  
 = let 
  
  
  
  
 fun copy new i = upd(new,i-l,sub(old,i-old_lb)) 
  
  
 in 
  
  
  
  
 (foldl copy (array(u-l+1,0)) (old_lb -- old_ub),l,u) 
  
  
 end ;
  
 The function
  extend
  takes an old array, and new lower and upper bounds
  l
  
 and 
 u
 . It creates a new array which is large enough for the extended bounds and 
 then folds the function
  copy
  over the domain of the old array, so as to copy the 
 old array elements.
  
 The C implementation closely follows the pattern of the SML function
  extend
 :
  
 dynamic_array extend( dynamic_array old, int l, int u ) { 
 dynamic_array new = array_alloc( l, u ) ; 
  
 int i ; 
  
 for( i=old.lb ; i<=old.ub ; i++ ) {
  
 Revision: 6.37",NA
5.7.3 ,NA,NA
The deallocation of dynamic arrays,"Reviewing the dynamic array based histogram program of the previous section 
 shows that there is something wrong with the use of the function
  extend
 . The 
 function takes the
  dynamic_array
  structure
  hist
  as an argument and 
 returns a new
  dynamic_array
  structure. This new structure is then written 
 over the old structure
  hist
 . The figure below shows the state of the relevant 
 areas of store at the point where
  hist
  has just been overwritten. The pointer to 
 the old
  data
  is shown as a dashed pointer; its place has been taken by the 
 pointer to the new data, shown as a solid pointer.
  
 data
 :
  
 a
  
 1
  
 lb
 :
  
 ub
 :
  
 b
  
 1
  
 0
  
 Destroying the only pointer to an area of store causes the area to become inacces-
 sible. In C such an inaccessible area of store will not be reclaimed automatically. 
 All functional languages have a garbage collector, and also some modern imper-
 ative languages such as Java, Modula-3 and Eiffel have a garbage collector. This 
 is a component of the language implementation that detects when an area of the 
 store is not longer accessible so that it can be reused. Unfortunately, C and C++ 
 do not have garbage collectors, so the programmer must assume full 
 responsibility for the management of the store.
  
 When inaccessible areas of store are not reclaimed, a program may eventually 
 run out of available space. This situation is known as a
  memory leak
  because store 
 seems to disappear without warning.
  
 The inaccessible store of the old dynamic array must be
  deallocated
  explicitly 
 so that it can be reused later. This deallocation can be performed by calling the 
 function
  free
 , with the pointer to the block of store to be freed as an argument. 
 The function
  free
  will mark the block for reuse by
  calloc
  at a later stage. The 
 following call thus deallocates the block of store that was referenced from 
 hist.data
 :
  
 free( hist.data ) ;
  
 The new inner part of the for loop of the function
  histogram
  would read:
  
 dynamic_array new ; 
  
 if( input[i] < hist.lb ) { 
  
  
 new = extend( hist, input[i], hist.ub ) ; 
  
 free( hist.data ) ; 
  
  
 hist = new ;
  
 Revision: 6.37",NA
5.7.4 ,NA,NA
Explicit versus implicit memory management,"The functions
  calloc
  and
  free
  manage memory
  explicitly
 . This is in contrast 
 with the
  implicit
  memory management offered by languages with a garbage col-
 lector. When a data structure is used in SML, the store that is needed for the data 
 structure is allocated automatically, that is, without the programmer being aware 
 of it or it being visible to the programmer. When structures are no longer used, a 
 garbage collector automatically reclaims the storage areas that are no longer in 
 use so that they can be reused for storage. The garbage collector of a declara-tive 
 language is implemented in such a way that only data structures that cannot be 
 reached by the program are reclaimed. This means that
  live
  data is never re-
 claimed.
  
 The explicit memory management in C does not have this safeguard. The C 
 programmer decides when a block of store is to be reclaimed by calling the func-
 tion
  free
 . If the C programmer makes a mistake and deallocates a block of 
 store that is actually still in use, a dangling pointer is created somewhere in the 
 pro-gram. As has been shown before, this will probably lead to random answers 
 or a program crash. To prevent dangling pointers we should make sure that data 
 lives longer than the pointer(s) to the data.
  
 In the case of explicitly allocated memory, the lifetime is completely deter-
 mined by the programmer. The lifetime of a block of dynamically allocated store 
 ends when
  free
  is called. Therefore no pointers to that block of store should be 
 alive when the block is deallocated. It is good practice to destroy data in the 
 same function where the pointer to the data is destroyed (provided, that the 
 pointer has not been copied!). This was the case in the last version of the 
 histogram program and in an earlier version of the program where
  free
  was 
 called from the function 
 histogram
 . In later chapters, we will see that this 
 combined deallocation of the block and destruction of the last reference to it is 
 also the desired practice in other programs.
  
 The problem of memory leaks is also related to the lifetime of pointers and 
 data. In this case the rule is exactly the opposite: memory does leak away if the 
 data has a lifetime that is longer than the pointer pointing to it, for if the pointer 
 is destroyed before the data is deallocated, the data cannot be deallocated any-
  
 Revision: 6.37",NA
5.7.5 ,NA,NA
Efficiency aspects of dynamic memory,"The reason why C uses explicit memory management is efficiency. From an exe-
 cution time viewpoint, the allocation and deallocation of memory are costly 
 oper-ations. Allocating a block of memory takes probably one or two orders of 
 mag-nitude more time than performing a simple operation like comparing two 
 num-bers or indexing an array. Because C programmers (are supposed to) know 
 that memory allocation is time consuming, they will do everything possible to 
 avoid unnecessary allocation operations.
  
 In an ideal situation one would know a priori how large an array will have to 
 be. In this case the array can be allocated once with the right size and then used 
 without the need for extension. Information about the size of an array is often 
 not available at the right time (for example when reading the data to be 
 incorporated in the histogram from a file). Dynamic arrays provide a flexible 
 solution, that can be highly efficient if used with care.
  
 The way the dynamic array is used to construct a histogram is not expensive, 
 at least if the input data is long enough. The reasoning behind this is that the 
 num-ber of allocation operations will never exceed the number of
  different
  
 characters in the input stream. Suppose that there are 70 different characters 
 (letters, capitals, digits, punctuation marks, and so on); if the input length is a 
 10000 characters, the 70 allocation operations add negligible overhead.
  
 However if the average length of the input data is about 7 characters, the cost 
 of allocation will far exceed the cost of making the histogram. The real work per-
 formed is 7 index operations and increments, while the overhead is up to 7 
 alloca-tion and deallocation operations.
  
 The functions
  calloc
  and
  free
  provide a mechanism to build data 
 abstrac-tions like the dynamic array, but they should be used with care. There is 
 nothing to protect the programmer from using these functions incorrectly (by 
 deallocat-ing memory at the wrong moment) or from using these functions too 
 often. The programmer has the control over the memory management and 
 should not expect any assistance from the compiler.
  
 Using another language, for example C++, does not help to relieve this per-
 formance problem. Memory allocation is an expensive operation. Higher level 
 languages do succeed in hiding the details of memory allocation though, as is 
 suc-cessfully shown in SML. This does not mean that the penalty is not paid. It 
 only means that the programmer has no longer any control when the penalty is 
 paid,
  
 Revision: 6.37",NA
5.8 Slicing arrays: pointer arithmetic,"So far, we have considered arrays as single entities which were passed as a 
 whole (albeit by reference). C has a mechanism that allows array slices to be 
 passed. This mechanism is known as
  pointer arithmetic
 . To illustrate the use of 
 pointer arith-metic, we will write a function that searches for the first occurrence 
 of word in a text. In the specification below, both the word ( ) and the text ( ) are 
 sequences:
  
 search
  
 search
  
 min
  
 If the word
  
 does not appear in the text
  
  , the function min is asked to calculate
  
 the minimum of an empty set. In this case we shall assume that the number
  
  is
  
 returned.
  
 To give a search algorithm let us assume that we first try to match the word 
 with the text, starting at the first position of the text. If this match fails, then we 
 move on to the second position and see if we can match the word there. If the 
 word occurs in the text then we will ultimately find it, and return the present
  
 starting position. Otherwise, we will exhaust the text, and return
  
  . Here is a
  
 schematic rendering of the first three steps of the search process, where we have 
 chosen a word of length :
  
 Step 1:
  
  
  
  
  
  
  
 ...
  
  
  
  
  
  
 Step 2:
  
  
  
  
  
  
  
 ...
  
  
  
  
  
  
  
 Step 3:
  
  
  
  
  
  
  
 ...
  
  
  
  
  
  
  
 The implementation of the search algorithm in SML takes as arguments the word 
 w
  and the text
  t
 . Both the word and the text are represented as an array of char-
 acter. The function
  search
  also takes the current position
  i
  as argument. This 
 indicates where a match is to be attempted:
  
 (* search : char array -> char array -> int -> int *) 
 fun search w t i 
  
  
 = if i > length t - length w 
  
  
  
 then ˜1 
  
  
  
 else if slice (t,i,(i+length w-1)) = w 
  
  
  
  
 then i 
  
  
  
  
 else search w t (i+1)
  
 Revision: 6.37",NA
5.9 Combining arrays and structures,"Arrays and structs can be combined freely. It is possible to construct an array of 
 structures or a structure with one or more arrays as its components. Details of 
 these data types are discussed using a personnel database as a running example.
  
 In the previous chapter, we discussed the data type
  employee
 , which was 
 de-signed to record information about an employee of some company. Here we 
 will adapt the example in two ways. Firstly, slightly different information about 
 the employee is stored; the records of the database will now contain more 
 detailed in-formation. Secondly, the information for a number of employees is 
 stored; we are now actually building a database. The personnel database is 
 intended for use by a company that sells bicycles. The information to be 
 maintained is the name of the employee, the salary, the year of birth, and the 
 number of bicycles sold over each of the past five years. The company has 4 
 employees. The manager of the com-pany needs a program that increases the 
 salary of each employee who sold more than 100 bicycles on average over the 
 last five years. Here is the SML solution to the problem:
  
 type employee 
  
 = (string * real * int * int array) ; 
 type personnel = employee array ;
  
 (* mean : int array -> real *)
  
 Revision: 6.37",NA
5.10 ,NA,NA
Multi-dimensional arrays with fixed bounds,"C has proper support for multi-dimensional arrays
  with fixed boundaries
 . Such an 
 array is denoted with a sequence of bounds; one for each dimension. 
  
 A two-
 dimensional array for example has two bounds, and is thus an array of arrays. 
 Usually, a
  typedef
  is given for a multidimensional array, which fixes the 
 bounds.
  
 Here is the
  typedef
  for a
  
  matrix of integers:
  
 #define 
 ROW 
 3 
  
 #define 
 COL 
 5 
  
 typedef int matrix[ROW][COL] 
 ;
  
 A multi-dimensional array can be initialised by listing the desired values for each 
 element. To initialise the
  
  matrix we would list the desired values for the first 
 row (
  
  ), then those for the second row (
  
  ) etc:
  
 matrix m = { {11,12,13,14,15}, 
 {21,22,23,24,25}, 
 {31,32,33,34,35} 
 } 
 ;
  
 A multi-dimensional array with fixed bounds can be passed to a function. Here is 
 a function to print a
  matrix
 :
  
 void print_matrix( matrix m ) { 
  
 int i,k ; 
  
  
 for( i = 0; i < ROW; i++) { 
  
  
  
 printf( ""row %d:"", i ) ; 
  
  
  
 for( k = 0; k < COL; k++) { 
  
  
  
 printf( ""\t%d"", m[i][k] ) ; 
  
  
 } 
  
  
  
 printf( ""\n"" ) ;",NA
5.11 ,NA,NA
Summary,"The following C constructs were introduced:
  
 Array types
  Array types are denoted using square brackets. Static arrays must 
 have a compile time constant size. Dynamic arrays can be created using the 
 function
  calloc
 , which has two parameters, the size of an element and 
 the number of elements to allocate, it returns a
  pointer
  to the first element of 
 the array.
  
 Array index
  Arrays are indexed with square brackets:
  
  [ ]
 , where 
  
 is the ar-
 ray and
   
  is the (integer) index. 
  
 The first element of an array has index 0. 
 The same notation can be used to identify an element to be overwritten.
   
  [ ] 
 =
  
  overwrites the -th element of with .
  
 Array bounds
  C does not provide array bound checking. It is wise to either be 
 able to argue that array bounds cannot be exceeded or put explicit checks in 
 a program to make sure that the bounds are not exceeded.
  
 Arrays as function arguments and result
  In C, an array is not a set of values, but 
 a
  pointer to
  the set of values. The consequence is that when passing an ar-
 ray as an argument, the array is
  passed by reference
 . Arrays should not be 
 returned as a function result, as only the pointer is returned, and the set of 
 values might cease to exist when the function terminates. Arrays allocated 
 explicitly can safely be passed around.
  
 Assignment to whole arrays
  It is not permitted to assign a new contents to an 
 en-tire array at once. A loop should be used to achieve this.
  
 Pointer arithmetic
  Values can be added to a pointer, effectively slicing an array.
  
 The programming principles that we have encountered in this chapter are:
  
 An array is a sequence, that is, a mapping from natural numbers to some 
 set of values.
  
 Working with arrays gives rise to a common programming error, the
  off by 
 one error
 ; it is particularly easy to overrun the upper bound of an array by 
 mistaking the length for the upper bound.
  
 Revision: 6.37",NA
5.12 ,NA,NA
Further exercises,"Exercise 5.8
  The last example program assumes that the company has 4 employ-
 ees and 5 years of history. Modify the program to use dynamic arrays so 
 that an arbitrary number of employees and years of history can be main-
 tained. (a further extension, storing the database on a file, can be found in 
 Chapter 7)
  
 Exercise 5.9
  Rewrite your card simulation program from Exercise 5.4 so that it 
 plays a real game. When playing, the user should choose a secret number 
 and the program should try to ‘guess’ it. Here is sample dialogue with 
 such a program. The input of the user is underlined; the text produced by 
 the program is in plain font.
  
 Does the number appear on the first card: 1 3 5 7?
  
 y 
  
 n 
  
 n
  
 Does it appear on the second:
  
 2 3 6 7?
  
 And on the third:
  
 4 5 6 7?
  
 Your secret number must be: 1!
  
 Exercise 5.10
  In this exercise, create a function that prints a table of the months of 
 a year with the number of days in each month. Furthermore, write a 
 function that when given a particular date in a year calculates what date it 
 will be exactly one week later.
  
 Revision: 6.37",NA
Chapter 6,NA,NA
Lists,"The preceding chapters discussed non-recursive data structures. Chapters 2 and 
 3 used scalar data types such as
  int
 ,
  double
 ,
  bool
 , the enumerated types 
 and functions. Chapter 4 used non-recursive structures to build tuples and 
 algebraic data types using the C language elements
  struct
  and
  union
 . The 
 resulting data structures are strictly hierarchical. These data structures are 
 characterised by their simplicity and their inflexibility: once defined, the 
 structure cannot be changed, although the components of the structure can be 
 given arbitrary values.
  
 Chapter 5 made a first step towards a more flexible data structure, the array. 
 An array was introduced as an implementation of a sequence. One of the major 
 problems with arrays is that they are expensive to extend and to contract. The list 
 provides an alternative implementation of a sequence. Lists are easy to extend 
 and contract, but lists also have disadvantages. The present chapter will see a 
 develop-ment of a recursive data type by discussing the list. We will also 
 compare lists to arrays. We are careful not to change the representation of data 
 when moving from the functional to the imperative domain.",NA
6.1 Lists of characters,"The list is one of the fundamental data types of functional programming. Sev-
 eral examples have been discussed where a recursive algorithm operates on an 
 arithmetic sequence. Such a sequence is just a list of integers. So far, the C im-
 plementations could be made without lists, mainly because arithmetic sequences 
 were represented in the C implementations as for-statements. However, there are 
 many problems that require flexible data structures such as lists, so their C 
 imple-mentation will be discussed. To simplify the discussion, a list of characters 
 will be defined and used in this chapter. In Chapter 8, the approach will be 
 generalised to polymorphic lists.
  
 All functional languages provide lists as primitives. It is also possible to 
 define a list explicitly. Here is the definition in SML of an algebraic data type 
 with two constructors
  Nil
  and
  Cons
 , which is effectively a list:
  
 datatype char_list = Nil 
  
  
 | Cons of (char * char_list) ;
  
 181",NA
6.1.1 ,NA,NA
List access functions: head and tail,"When accessing the elements of a list, it is convenient to have access functions for 
 the components of the structure. This gives rise to the following two SML func-
 tions:
  
 (* head : char_list -> char *) 
  
 fun head (Cons(x,xs)) = x ;
  
 (* tail : char_list -> char_list *) 
 fun tail (Cons(x,xs)) = xs ;
  
 These functions are readily implemented in C:
  
 char head( char_list l ) { 
  
  
 if( l == NULL ) { 
  
  
  
 abort() ; 
  
  
 } 
  
  
 return l->list_head ; 
  
 }
  
 char_list tail( char_list l ) { 
  
  
 if( l == NULL ) { 
  
  
  
 abort() ;
  
 Revision: 6.34",NA
6.2 The length of a list,"The basic list abstraction can be put to work in the implementation of a few 
 recur-sive list functions. The SML function
  length
  computes the length of a 
 list, which corresponds to
  
  on a sequence.
  
 (* length : char_list -> int *) 
  
 fun length Nil 
  
 = 0 
  
  
 | length (Cons(x,xs)) = 1 + length xs ;
  
 C has no pattern matching, so explicit calls to list access functions are required. 
 To prepare for the transition to C, the
  length
  function must be rewritten to use 
 access functions and a conditional instead of pattern matching:
  
 (* length : char_list -> int *) 
  
 fun length x_xs = if x_xs = Nil 
  
  
 then 0 
  
  
 else 1 + length (tail x_xs) ;
  
 The corresponding C implementation is now constructed using the basic tech-
 nique from Chapter 2.
  
 int length( char_list x_xs ) { 
  
  
 if ( x_xs == NULL ) { 
  
  
  
 return 0 ; 
  
  
 } else { 
  
  
  
 return 1 + length( tail( x_xs ) ) ; 
  
 } 
  
 }
  
 Exercise 6.3
  Write a tail recursive version of
  length
  in SML and give the corre-
  
 sponding C implementation that uses a while-statement.",NA
6.3 Accessing an arbitrary element of a list,"Another useful function,
  nth
 , accesses an arbitrary element from a list. This cor-
 responds to the access operator on sequences
  
  .
  
 (* nth : char_list -> int -> char *) 
 fun nth (Cons(x,xs)) 0 = x 
  
  
 | nth (Cons(x,xs)) n = nth xs (n-1) ;
  
 The pattern matching can be removed from
  nth
 . This yields an SML-function 
 that can be directly implemented in C.
  
 (* nth : char_list -> int -> char *) 
  
 fun nth x_xs n = if n = 0 
  
  
 then head x_xs 
  
  
 else nth (tail x_xs) (n-1) ;
  
 The function
  nth
  is tail recursive; this makes it straightforward to use the while-
 schema from Chapter 3:
  
 char nth( char_list x_xs, int n ) { 
  
 while( n != 0 ) { 
  
  
  
 x_xs = tail( x_xs ) ; 
  
  
  
 n-- ; 
  
  
 } 
  
  
 return head( x_xs ) ; 
  
 }
  
 Exercise 6.4
  When trying to access a non-existent list element, the SML definition 
 of
  nth
  raises the exception
  Match
 , but the C implementation of
  nth
  
 pro-duces an undefined result. Modify the C version of
  nth
  so that it 
 aborts with an error message when a non-existent list element is accessed.",NA
"6.4 Append, filter and map: recursive versions","The last three generally useful list processing functions,
  append
 ,
  filter
 , and 
 map
 , are functions that are not tail recursive. It is possible to develop efficient C 
 versions using a technique known as
  open lists
 . Below, we will first discuss three 
 simple recursive (and inefficient) versions; the next section discusses the 
 optimisa-tion technique.",NA
6.4.1 ,NA,NA
Appending two lists,"The function
  append
  corresponds to concatenation of sequences. When given 
 two separate lists, it creates a new list from the concatenation of the two lists.
  
 The recursive SML definition is:
  
 (* append : char_list -> char_list -> char_list *) 
 fun append Nil 
  
 ys = ys 
  
  
 | append (Cons(x,xs)) ys = Cons(x,append xs ys) ;
  
 Revision: 6.34",NA
6.4.2 ,NA,NA
Filtering elements from a list,"Filtering is a generally useful operation over lists. When given a predicate
  pred 
 and an input list, the
  filter
  function selects only those elements for which the 
 predicate returns true:
  
 (* filter : (char->bool) -> char_list -> char_list *) 
 fun filter pred Nil 
  
  
  
 = Nil 
  
  
 | filter pred (Cons(x,xs)) 
  
  
  
 = if pred(x) 
  
  
  
  
 then Cons(x,filter pred xs) 
  
  
  
  
 else filter pred xs ;
  
 Exercise 6.6
  Give the specification of
  filter
  in terms of sequences.
  
 The
  filter
  function can be written directly in C, using the techniques that 
 have been developed earlier in this chapter:
  
 char_list filter( bool (*pred)( char ), char_list x_xs ) { 
  
 if ( x_xs == NULL ) { 
  
  
  
 return NULL ; 
  
  
 } else { 
  
  
  
 char x = head( x_xs ) ; 
  
  
  
 char_list xs = tail( x_xs ) ; 
  
  
  
 if( pred( x ) ) { 
  
  
  
  
 return cons( x, filter( pred, xs ) ) ; 
  
  
  
 } else { 
  
  
  
  
 return filter( pred, xs ) ; 
  
  
  
 } 
  
  
 } 
  
 }
  
 Let us now use
  filter
  to select all digits from a list of characters. The SML ver-
 sion is:
  
 (* filter_digit : char_list -> char_list *) 
 fun filter_digit xs = filter digit xs ;
  
 Revision: 6.34",NA
6.4.3 ,NA,NA
Mapping a function over a list,"Another powerful higher order abstraction of list operations is to map a function 
 over a list, that is, to apply a certain function
  f
  to all elements of a list. Here is 
 the SML version of
  map
 :
  
 (* map : (char->char) -> char_list -> char_list *) 
 fun map f Nil 
  
 = Nil 
  
  
 | map f (Cons(x,xs)) = Cons(f x,map f xs) ;
  
 Exercise 6.7
  Give the specification of
  map
  in terms of sequences.
  
 Exercise 6.8
  Prove that the SML-function
  map
  shown above satisfies the specifi-
  
 cation given in Exercise 6.7.
  
 Revision: 6.34",NA
6.5 Open lists,"The conceptually simple operation of making a copy of a list is surprisingly diffi-
 cult to implement efficiently. In this section, a list copy function will be discussed 
 to illustrate a useful optimisation technique that can be applied in a C implemen-
 tation but not in the (pure) functional world. An SML function to copy a list is:
  
 (* copy : char_list -> char_list *) 
  
 fun copy Nil 
  
 = Nil 
  
  
 | copy (Cons(x,xs)) = Cons(x,copy xs) ;
  
 After rewriting this function without pattern matching, a recursive C 
 implementa-tion can be derived using the while-schema:
  
 char_list copy( char_list x_xs ) { 
  
  
 if( x_xs == NULL ) { 
  
  
  
 return NULL ; 
  
  
 } else { 
  
  
  
 return cons( head( x_xs ), copy( tail( x_xs ) ) ) ; 
  
 } 
  
 }
  
 Although this implementation is efficient in time (the list copy will take a time 
 proportional to the length of the list), the implementation is not tail recursive. 
 This means that the implementation requires stack space proportional to the 
 length of the list, which is undesirable.
  
 Revision: 6.34",NA
6.5.1 ,NA,NA
Open lists by remembering the last cell,"A relatively clean way to complete the implementation of the list copy function is 
 to remember where the last element has been appended to the output list. To do 
 this, there must be a cell that can be identified with the last element. 
  
 The 
 copy function will now be completed in three steps. As the first step, the while-
 statement will be
  unrolled
  once. A while-statement can always be unrolled based 
 on the following observation:
  
 while( condition ) { 
  
 statement ; 
  
 }
  
 if( condition ) { 
  
 statement ; 
  
 while( condition ) { 
  
 statement ; 
  
 } 
  
 }
  
 The result of unrolling is that the first iteration of the loop is executed before the 
 while
 . The statements of the first iteration, now separate from the statements of 
 subsequent iterations, can be optimised using the knowledge that all variables 
 have their initial values. This information will help to create an efficient function.",NA
6.5.2 ,NA,NA
Open lists by using pointers to pointers,"The first method to complete the
  copy
  function from the previous section 
 remem-bers a pointer to the last cell added. In this section, we describe another 
 method.
  
 Revision: 6.34",NA
6.5.3 ,NA,NA
Append using open lists,"When the
  append
  function was introduced earlier in this chapter, we noted that
  
 the efficiency could still be improved by making the function tail recursive. The
  
 structure of
  append
  is similar to that of
  copy
 . Here is a comparison between the
  
 two:
  
 fun append 
  
 Nil ys 
  
 fun copy 
  
 Nil
  
 = ys 
  
 = Nil
  
 | append (Cons(x,xs)) ys 
  
 | copy (Cons(x,xs))
  
 = Cons(x,append xs ys) ; 
  
 = Cons(x,copy xs) ;
  
 The differences between
  copy
  and
  append
  are few:
  
 Argument:
  append
  has an extra argument
  ys
 .
  
 End of input:
  where
  copy
  returns the empty list
  Nil
 ,
  append
  returns its extra
  
 argument list
  ys
 .
  
 Therefore, taking the efficient loop-based C implementation of
  copy
  from Sec-
  
 tion 6.5.1 and making changes corresponding to the differences noted above
  
 should give an efficient C implementation of
  append
 . Here is the result, anno-
  
 tated with the changes:
  
 char_list append( char_list xs, 
  
  
  
  
 char_list ys ) { 
  
 char_list accu = ys; 
  
  
 char_list last ; 
  
  
 if( xs != NULL ) { 
  
  
  
 last = accu 
  
  
  
  
 = cons( head(xs), ys ) ; 
  
  
 xs = tail( xs ) ; 
  
  
  
 while( xs != NULL ) {
  
 Revision: 6.34
  
 /*added char_list ys*/ 
 /*replaced NULL by ys*/
  
 /*replaced NULL by ys*/",NA
6.6 Lists versus arrays,"The previous chapter discussed the array and, in this chapter, we have 
 introduced lists. From a mathematical point of view, arrays and lists are the 
 same. Both repre-sent a sequence, that is, an ordered set of elements. From an 
 algorithmic point of view, there are differences. The table below gives the cost of 
 each of the ‘abstract’operations that can be performed on a sequence of 
  
 elements.
  
 operation 
  
  
 representation 
  
  
  
 list 
  
 array 
 create a sequence of 
  
 extend with new first element 
  
 extend with new arbitrary element 
  
 remove first element 
  
 remove arbitrary element 
  
 access first element 
  
 elements
  
 13 13
  
  
 3 
 3
  
  
  
 3
  
 As an example, the last entry in the table ‘access arbitrary element’ states that a access 
 arbitrary element 
  
 13",NA
6.6.1 ,NA,NA
Converting an array to a list,"To study the difference between an array and a list more closely, we consider the 
 problem of transferring the contents of an array into a list and the conversion 
 from a list into an array. As before, the elements of both data structures will be 
 charac-ters to simplify the presentation.
  
 The following SML program converts an array to a list. It first creates a list of 
 all possible index values of the array and then accesses each array element using 
 the appropriate index value.
  
 (* array_to_list : char array -> char_list *) 
 fun array_to_list s 
  
  
 = let 
  
  
  
  
 val l = 0 
  
  
  
  
 val u = length s - 1 
  
  
  
  
 fun subscript i = sub(s, i) 
  
  
  
 in 
  
  
  
  
 map subscript (l--u)
  
 Revision: 6.34",NA
6.6.2 ,NA,NA
From a list to an array,"The dual problem of transferring an array into a list is creating an array from a 
 list. This is what the
  foldl
  based SML function below achieves:
  
 (* list_to_array : char_list -> char array *) 
 fun list_to_array xs 
  
  
 = let 
  
  
  
  
 val n = length xs 
  
  
  
  
 val u = n - 1 
  
  
  
  
 val s = array(n, "" "") 
  
  
  
  
 fun update s i = upd(s,i,nth xs i) 
  
  
 in 
  
  
  
  
 foldl update s (0 -- u) 
  
  
  
 end ;
  
 The function
  list_to_array
  starts by creating a new array
  s
  of the right size. 
  
 The lower bound of the array is assumed to be 0; the upper bound
  u 
 is 
 then one less than the length
  n
  of the list
  xs
 . Subsequently, the expression 
 foldl update s (0 -- u)
  runs trough the permissible index range, calling 
 upon the auxiliary function
  update
  to first access the required elements from 
 the list
  xs
  and then to update the array
  s
 . The new values are obtained by 
 indexing the list using the list index function
  nth
 .
  
 Revision: 6.34",NA
6.7 Variable number of arguments,"It is sometimes useful to be able to write a single function that can be applied to a 
 variable number of arguments. Good examples of such functions are
  printf
  
 and 
 scanf
 .
  
 In SML and other functional languages, there are two ways to write such 
 func-tions. If all arguments have the same type, they can be collected in a list, 
 and passed to the function. If the arguments have different types, an Algebraic 
 Data Type can be used to define which combinations of types are legal, and used 
 to pass the arguments. (This in addition to
  overloaded
  functions, which we will 
 not discuss here.) As an example, the standard function
  sum
  computes the sum 
 of a series of numbers, which are passed in a list.
  
 The same solution could be used in C, but since C does not have the syntax to 
 support easy creation and matching of lists and algebraic data types, this 
 strategy results almost always in unreadable programs. To allow the 
 programmer to pass a variable number of arguments, C has a built-in mechanism 
 for
  variable arguments 
 lists, also known as
  vararg
  lists.
  
 The concept of a variable argument list in C is simple. Instead of specifying 
 the arguments precisely in a prototype, one must specify them with the ellipsis 
 notation
  ...
 , which stands for ‘any additional arguments of unspecified type’. 
 Thus, the prototype of a function
  sum
  that would add a certain number
  n
  of 
 values would read:
  
 int sum( int n, ... ) ;
  
 After this declaration, the following calls are legal:
  
 sum( 3, 5, 1, 9 ) == 15 
 sum( 2, 314, 52 ) == 366 
 sum( 0 ) == 0
  
 && 
  
 &&
  
 The
  ...
  notation in the prototype allows the programmer to indicate that any 
 number of arguments may be passed to this function. To use these arguments, 
 the function call must specify how many actual arguments there are and the 
 func-tion definition must be written such that the arguments can be retrieved 
 from the argument list. Arguments are retrieved one at the time via an
  argument 
 list pointer 
 and using three functions that operate on this pointer.
  
 The type of the argument list pointer is
  va_list
 , which stands for variable 
 ar-gument list. This type is declared in the include file
  stdarg.h
 . A variable of 
 type 
 va_list
  must be initialised with a call to
  va_start
 . Successive elements 
 can be retrieved with calls to
  va_arg
 , while the function must end with a call to
  
 va_end
 . As an example of its use, the function
  sum
  is defined below with a 
 variable argu-ment list:
  
 #include <stdarg.h>
  
 Revision: 6.34",NA
6.8 Store reuse,"As we have seen on a number of occasions, store allocation in C requires care. 
 Most list processing functions in this chapter allocate storage (the exceptions be-
 ing
  head
 ,
  tail
 ,
  length
 , and
  nth
 ). None of the functions deallocate or reuse 
 storage. A program built using such greedy primitives, must, unless it is short, 
 soon exhaust any available space. In the following, we give some general guide-
 lines on how to approach allocation. To do this, we must make some 
 assumptions about the context in which we are working.
  
 The most common form of deallocation has been discussed before in Chap-ter 
 5. When a function deletes the last reference to a block of store, then this block
  
 Revision: 6.34",NA
6.9 Summary,"The following C constructs were introduced:
  
 Recursive types
  Structures need to contain a pointer to a value of their own type 
 in order to create a linked list. It is not legal to refer forward to a type in C, 
 so instead, the struct must be named, this name is then used in combination 
 with the keyword
  struct
  to refer to the type:
  
 typedef struct 
  
  
 { 
  
  
 /* other member declarations */ 
  
 struct 
  
 * 
  
 ; 
  
 } 
  
  
 ;
  
 This defines a struct with, amongst others, a member called , which is a 
 pointer to a value of type
  struct
  
  , which is its own type. The typedef 
 defines to be the type
  struct
  .
  
 NULL pointer
  The NULL pointer is a pointer that does not point to anything. It 
 is used to signal error conditions (functions returning NULL), and it is used 
 to signal the end of lists.
  
 Memory allocation
  The function
  malloc
  allocates memory, like
  calloc
 , but 
 memory is not initialised, and only one cell of the specified size is allocated. 
 The function
  free
  releases memory.
  
 Variable argument list
  It is possible to define functions with a variable number 
 of arguments (such as
  printf
 ).
  
 Revision: 6.34",NA
6.10 ,NA,NA
Further exercises,"Exercise 6.18
  Give the specification of reversing a sequence and implement an ef-
  
 ficient C function
  reverse
  to operate on the type
  char_list
 .
  
 Exercise 6.19
  In this exercise, binary trees will be implemented.
  
 (a)
  Give an equivalent definition in C of the following SML data type:
  
 datatype tree = Branch of (tree * tree) 
  
 | Leaf 
  
 of int ;
  
 (b)
  Write a C function
  mkLeaf
  to create a leaf node of the
  tree
  type. 
 The function
  mkLeaf
  should have the following prototype:
  
 tree_ptr mkLeaf( int leaf ) ;
  
 Also write a function
  mkBranch
  with the prototype below to create 
 an interior node.
  
 tree_ptr mkBranch( tree_ptr left, tree_ptr right ) ;
  
 (c)
  Write a recursive C function to print a tree as follows:
  
 For each leaf, print its key value.
  
 For each branch, print its left branch and print its right branch, 
 separated by a comma and enclosed in parentheses. As an exam-
 ple, the tree below should be printed as
  (1,(2,3))
 .
  
 1
  
 2 
  
 3
  
 Revision: 6.34",NA
Chapter 7,NA,NA
Streams,"The previous chapters discussed two data structures for storing sequences of 
 data items: lists and arrays. A third kind of sequence is the stream. An example 
 of a stream is the sequence of characters being typed by the user as input to a 
 program, or conversely, the characters being printed on the screen.
  
  
 In this chapter, streams are discussed, and they are compared with the two 
 other sequences. A stream has two distinguishing features:
  
 A stream can
  only
  be accessed sequentially. That is, after accessing element
  
  
 of the stream, only the next element
  
  can be accessed. If is needed 
 later on, it must be remembered explicitly.
  
 The number of items in a stream is not known beforehand. At any moment, 
 the stream might dry up.
  
 In C and SML streams work by side effects. That is, reading a character 
 from a stream uses a function that returns a character (the result), and 
 updates some state to record that this character has been read. Writing a 
 character deposits the character on the stream, and updates some state to 
 record this.
  
 In a functional language, a stream is sometimes captured via a list abstraction. 
 That is, a certain list does not have a predetermined value, but contains all 
 charac-ters that come from the stream. When the stream ends, the list is 
 terminated (with 
 []
 ). Using a list is slightly deceptive, as it ‘remembers’ all 
 previous characters in the stream.
  
 Most programming languages, including C and SML, offer a set of low level 
 primitives that allow a program to open a certain stream, access the elements of 
 the stream sequentially, and then finally close the stream. The elements cannot 
 be accessed in an arbitrary order, as is the case with other sequences. Should the 
 programmer wish to use the elements of a stream in a different order than 
 sequen-tially, or should the programmer wish to use them more than once, the 
 elements of the stream must be stored for later use. Streams can be large, so it is 
 often im-practical to keep the entire contents of a stream in the store. The main 
 issue in this chapter is how to access a stream such that the least amount of store 
 is needed to remember stream elements.
  
 213",NA
7.1 Counting sentences: stream basics,"We will now write a program to count the number of sentences in a text. The so-
 lution has two aspects. The first is how to define a sentence. We will assume that 
 a sentence is a sequence of characters that ends with a full stop. The number of 
 sentences will be taken as the number of full stop characters
  .
  in the text:
  
 sentence count
  
 .
  
  
 domain
  
 (7.1)
  
 sentence count
  
 As a first solution, we can use two functions. One function captures the stream in 
 a list, and another function counts the number of full stops in a list. For the sec-
 ond we use the SML function
  full_stop_count
  shown below. Please note 
 that, whilst we used a monomorphic type
  char_list
  in Chapter 6, here we use 
 the standard SML type
  list
  with the usual polymorphic operators, such as
  
 length 
 and
  filter
 .
  
 (* full_stop_count : char list -> int *) 
 fun full_stop_count cs 
  
  
 = let 
  
  
  
  
 fun is_full_stop c = c = ""."" 
  
  
 in 
  
  
  
  
 length (filter is_full_stop cs) 
  
  
 end ;
  
 The second aspect of the solution is to capture the input stream. In SML streams 
 are accessed using two functions. The predicate
  end_of_stream(stream)
  de-
 termines whether the end of a stream has been reached. For as long as the predi-
 cate yields false (and there are thus elements to be accessed from the stream), the 
 function
  input(stream,n)
  can be used to access the actual characters from 
 the stream. The argument
  stream
  identifies the stream. The argument
  n
  
 specifies how many characters should be accessed. The function
  input
  has a 
 side effect on the stream, in that it makes sure that a subsequent call to input will 
 cause the next character(s) to be accessed. A complete SML function to transfer 
 all charac-
  
 Revision: 6.33",NA
7.1.1 ,NA,NA
Efficiently transferring a stream to a list,"The
  stream_to_list
  function will recurse over the input, so the stack size re-
 quired for this program is proportional to the size of the input stream. This space 
 efficiency problem can be solved using tail recursive functions and open lists in the 
 same way as the efficiency problems of the
  copy
  and
  append
  functions were solved 
 in Chapter 6. The body of
  stream_to_list
  is a conditional. To compare the 
 function
  copy
  to
  stream_to_list
 , we must rewrite
  copy
  so that it also uses a 
 conditional. Furthermore, the functions in Chapter 6 were all specialised to oper-ate on 
 the data type
  char_list
 . Here we use the standard SML type
  list
 . The two 
 functions are: 
  
 fun stream_to_list stream 
  
 fun copy xs 
  
  
 = if end_of_stream stream 
  
  
 = if xs = [] 
  
  
  
  
 then [] 
  
  
  
 then [] 
  
  
  
  
 else input(stream,1) :: 
  
  
  
  
 else head xs :: 
  
  
  
  
 stream_to_list 
 stream ; 
   
  
 copy (tail xs) ;
  
 Revision: 6.33",NA
7.1.2 ,NA,NA
Avoiding the intermediate list,"The SML and C solutions of the sentence count problem transfer the entire con-
 tents of the stream into the store before the function
  full_stop_count
  can 
 count the number of full stops. This is not necessary: the elements of the stream 
 could be read step by step, while counting the full stops at the same time. So far, 
 our efforts to make
  stream_to_list
  efficient are necessary, but not sufficient. 
 For as long as one of the functions involved in the solution causes inefficiency, 
 the entire solution will be inefficient.
  
 Here is an efficient version of
  sentence_count
 . It uses an auxiliary 
 function 
 count
  to do the real work. This SML function shows how the two 
 processes of reading and counting have been merged:
  
 (* sentence_count : instream -> int *) 
  
 fun sentence_count stream 
  
  
 = let 
  
  
  
  
 fun count stops 
  
  
  
  
  
 = if end_of_stream stream 
  
  
  
  
  
  
 then stops 
  
  
  
  
  
  
 else if input (stream, 1) = ""."" 
  
  
  
  
  
  
 then count (stops+1) 
  
  
  
  
  
  
 else count stops 
  
  
  
 in 
  
  
  
  
 count 0 
  
  
  
 end ;
  
 The auxiliary function
  count
  is efficient because:
  
 count
  is tail-recursive.
  
 count
  does not create intermediate list structure.
  
 Exercise 7.3
  Prove that the efficient version of
  sentence_count
  is equivalent 
  
 to the inefficient version of the previous section.
  
 The efficient C version of
  sentence_count
  is:
  
 int sentence_count( FILE * stream ) { 
  
 int stops = 0 ; 
  
  
 while( true ) { 
  
  
  
 int c = getc( stream ) ; 
  
  
  
 if( c == EOF ) { 
  
  
  
  
 return stops ; 
  
  
  
 } else if( c == . ) { 
  
  
  
  
 stops++ ;
  
 Revision: 6.33",NA
7.1.3 ,NA,NA
IO in C: opening files as streams,"A C program may operate on several streams at the same time. Three predefined 
 streams are always available:
  stdin
  for accessing the standard input stream, 
 stdout
  for accessing the standard output stream, and
  stderr
  which is a 
 stream for writing error messages.
  
 Further input and output streams can be made available to the program using 
 the function
  fopen
 , which creates a stream so that it reads from, or writes to a 
 file. This function has two parameters, the first parameter is the name of the file 
 to be opened, the second parameter is the mode. The two most frequently used 
 modes are
  ""r""
  (which results in a stream from which input can be read) and
  
 ""w""
  (which results in a stream to which output can be written). Other modes, 
 amongst oth-ers for appending to files, are specified in the C manual [7]. The 
 function
  fopen 
 will return a stream (of type
  FILE *
 , defined in
  stdio.h
 ), if 
 the file cannot be opened, it will return the value NULL.
  
  
 When the program is finished with a stream, the function
  fclose
  should be 
 called to close the stream.
  
 printf
  which 
 We have seen two functions operating on streams so far: 
  
 printed to the standard output and
  getc
  which reads a character from a 
 specified stream. They are part of two families of functions for reading data from 
 streams, and writing data to streams.
  
 Input
  
 There are three more functions to read from an input stream:
  getchar
 ,
  scanf
 , 
 and
  fscanf
 . The function
  getchar()
 , reads a character from the standard 
 input stream, it is the same as
  getc( stdin )
 . The function
  scanf
  reads a 
 number of data items of various types from the standard input stream and stores 
 the values of these data items (
 scanf
  stands for ‘scan formatted’). The function
  
 scanf
  can be used to read strings, integers, floating point numbers, and 
 characters. The first argument of
  scanf
  specifies what needs to be read; all 
 other arguments specify where the data should be stored. As an example of 
 scanf, consider the following call:
  
 int i, n ; 
  
 char c ; 
  
 double d ; 
  
 n = scanf(""%d %c %lf"", &i, &c, &d ) ;
  
 This section of code will read three data items: an integer (because of the
  %d
  in 
 the format string), which is stored in
  i
 ; a character (denoted by the
  %c
  in the 
 format",NA
7.2 Mean sentence length: how to avoid state,"The previous problem counted the number of sentences in a text. A slightly more 
 complicated problem is not only to count the number of sentences, but to 
 calculate the mean sentence length:
  
 mean sentence length
  
 .
  
  
  div sentence count
  
 (7.2)
  
 mean sentence length
  
 As we have already developed an efficient function
  sentence_count
  to count 
 the number of sentences, all we have to do is write a function
  
 character_count 
 to count the number of characters in a stream. Then we 
 may divide the number of characters by the number of sentences. If our function
  
 sentence_count
  is a good building block, we should be able to reuse it for this 
 purpose.
  
  
 Here is an efficient function
  character_count
 , which is basically a simpli-
 fied version of
  sentence_count
 :
  
 (* character_count : instream -> int *) 
  
 fun character_count stream 
  
  
 = let 
  
  
  
  
 fun count chars 
  
  
  
  
  
 = if end_of_stream stream 
  
  
  
  
  
  
 then chars 
  
  
  
  
  
  
 else let 
  
  
  
  
  
  
  
  
 val c = input (stream, 1) 
  
  
  
  
  
  
 in 
  
  
  
  
  
  
  
  
 count (chars+1) 
  
  
  
  
  
  
  
 end 
  
  
  
 in 
  
  
  
  
 count 0 
  
  
  
 end ;
  
 The mean sentence length would be given by the SML function below:
  
 (* mean_sentence_length : instream -> int *) 
 fun mean_sentence_length stream 
  
  
 = (character_count stream) div 
  
  
  
 (sentence_count stream) ;
  
 Unfortunately, executing this program will not produce the expected result. Ei-
 ther the function
  mean_sentence_length
  will produce the answer 0 or it will 
 fail with a ‘divide by zero’ exception. How can this be? The two building blocks 
 sentence_count
  and
  character_count
  are not faulty. 
  
 The reason is that 
 the function
  input
 , which is used by both, has a side effect and modifies the 
 stream. Depending on the order in which the two operands of the
  div
  operator
  
 Revision: 6.33",NA
7.3 Counting words: how to limit the size of the state,"The programs developed for the previous two examples operated on the stream 
 on a per character basis. Programs often act on larger units of data. An example 
 of such a problem is the word-count problem. Given a text (for example the text 
 of this book), we may wish to count how often a certain word (for example, the 
 word“cucumber”) occurs in the text (the answer is 11 times).
  
  
 The number of occurrences of the word 
  
 in the text is given by the function 
 below, where both the word and the text are represented by a sequence of 
 charac-ters:
  
 word count 
  
 word count
  
 - 
  
 (7.3)
  
 An algorithm to count all the occurrences of the word
  w
  would try to match it to 
 each position in the text
  t
 . Using lists to represent both the word and the text, 
 successful matches can be counted as follows in SML:
  
 (* word_count : char list -> char list -> int *) 
  
 fun word_count ws [] = 0 
  
  
 | word_count ws (t::ts) = if match ws (t::ts) 
  
  
  
  
 then 1 + word_count ws ts 
  
  
  
 else 
  
 word_count ws ts ;
  
 The
  word_count
  function requires a subsidiary function
  match
  to check 
 whether a word matches the text at a particular position. The
  match
  function 
 compares the characters from the word and the text. It yields false if either the 
 text contains too few symbols or if a mismatch is found:
  
 (* match : char list -> char list -> bool *) 
  
 fun match [] 
  
 t = true 
  
  
 | match (w::ws) [] = false 
  
  
 | match (w::ws) (t::ts) = w = (t:char) andalso match ws ts ;
  
 Exercise 7.5
  Given a word , a text , and (7.3). Prove that: word count 
  
 word_count w t
  
 As a first step, we use the naive approach: transfer the contents of a stream into a 
 list and then count the number of occurrences of the word “cucumber”:
  
 (* main : instream -> int *)
  
 Revision: 6.33",NA
7.3.1 ,NA,NA
Using a sliding queue,"As we have seen in the previous sections, first transferring the contents of a 
 stream into a list and then manipulating the list is not ideal. For the word count 
 problem, we need a
  queue
  to buffer elements from the input stream: each time a 
 new char-acter of the stream is needed, it is entered to the rear of the queue. Each 
 time a character has ceased to be useful, it is deleted from the front of the queue. 
 The net effect of this is that the queue appears to advance over the text and that 
 the word shifts along with the queue.
  
 To illustrate this process suppose that the text contains the characters “cucu-
 cumbers” and that we have seen that the first character of the text matches the 
 first character of the word “cucumber”. This situation is shown graphically be-
 low. Here the portion of the text that has been accessed so far is labelled
  t
 , and 
 the word is labelled
  w
 . The front of the queue is to the left of the picture, and the 
 rear of the queue is to the right.
  
 t:
  
  
 c
  
  
 u
  
 c
  
 u
  
 m
  
 b
  
 e
  
 r
  
 w:
  
 c
  
 The word and the text are shown with corresponding matching characters verti-
 cally aligned. Now the second character of the text must be accessed for it to be 
 compared to the second character of the word. The character
  u
  enters the queue 
 at the rear (right).
  
 Revision: 6.33",NA
7.3.2 ,NA,NA
Implementing the sliding queue in SML,"An implementation of the sliding queue should satisfy the following require-
 ments:
  
 New elements should be appended to the rear of the queue.
  
 Revision: 6.33",NA
7.3.3 ,NA,NA
Implementing the sliding queue in C,"The sliding queue implementation in SML uses the append operator to enter 
 new elements from the stream into the queue. We have seen that this is an 
 inefficient operation. The same operation can be implemented efficiently if we 
 use open lists. To develop a C data structure and a set of functions that 
 implement the sliding queue with open lists, we need to keep track of the end of 
 the list for the queue operations. Therefore, we define the equivalent of our SML 
 type
  queue
  with a provision for keeping track of the beginning as well as the 
 end of the list.
  
 typedef struct queue_struct { 
  
  
 FILE 
  
 * queue_stream ; 
  
  
 char_list queue_first ; 
  
  
 char_list queue_last ; 
  
 } * char_queue ;
  
 As in SML, our C program will have to be able to create an initial queue with a 
 number
  n
  of elements already entered into the list:
  
 #define queue_struct_size sizeof( struct queue_struct )
  
 Revision: 6.33",NA
7.3.4 ,NA,NA
Counting words using arrays,"The process of creating a queue from a stream of characters as shown in the pre-
 vious section is effective, but its efficiency could still be improved. For each each 
 iteration of
  word_count
 , a list cell has to be allocated, and another cell has to be 
 freed. Allocation of cells is usually expensive, and if performance is important, it 
 is better avoided. Another data structure might be more appropriate for buffer-
 ing the input stream, the array. Firstly, an array is allocated all at once rather 
 than piecemeal, as is the case for the cells of a list. Secondly, an array offers more 
 effi-cient access to arbitrary elements than a list. Below, we will show how arrays 
 can be used to implement the word count problem.
  
 Let us begin by revising the queue data type to use an array instead of a list. 
 The SML version of the data type is shown below. The actual elements that are 
 part of the queue are now stored in an array. We aim to always keep a certain 
 number of elements in the queue. This is an important consideration as arrays 
 are not easily extended. If we can allocate an array of the right size at the 
 beginning, the array based queue will never have to do any storage allocation or 
 deallocation. We cannot guarantee that all elements of the array will always 
 contain useful in-formation, so we maintain the index of the last element that is 
 actually valid. We could have chosen to maintain a count of the valid elements 
 instead. This turns out to be less convenient, as we will see.
  
 datatype a queue = Queue of (instream * int * a array) ;
  
 Here is the equivalent data structure in C:
  
 typedef struct queue_struct { 
  
  
 FILE * queue_stream ; 
  
  
 int queue_valid ; 
  
  
 char * queue_array ; 
  
 } * char_queue ;
  
 To create the queue, we use the
  stream_to_list
  function to transfer the first
  
 n 
 elements of the stream to a list. Then we use the function
  list_to_array
  
 from Chapter 6 to create the array. As the function
  create
  is only used once 
 (during initialisation), it should not matter that it creates a small intermediate list 
 structure. It is important to make functions efficient that are often used. 
 Spending effort on functions that are rarely used does not pay. This tradeoff is 
 often referred to as the 90%/10% rule: a program will often spend 90% of its time 
 in only 10% of its
  
 Revision: 6.33",NA
7.4 Quicksort,"The final example of this chapter discusses the problem of sorting the contents of 
 a stream. The problem here is that it is impossible to sort a stream efficiently 
 without having access to its entire contents. This time, no optimisations apply 
 that only keep part of the stream in the store. The problem of efficient sorting is 
 by itself interesting and worthy of study.
  
  
 To sort data, it should be possible to compare two arbitrary data elements and 
 to decide which of the two should come first in a sorted sequence. When given
  
  
 of length
  
  and an operation 
  
 defined on the elements of the a sequence 
  
 sequence, the sorted sequence sort is:
  
 sort sort 
  
 .
  
 where
  
 and 
 % *
  is a permutation of 
  
  
 %
  
 An elegant divide and conquer algorithm to sort a sequence is quicksort [3]. The 
 recursive specification of quicksort on sequences is given below. Here we are us-
 ing the filter function as defined in Exercise 6.6. The predicates are written as sec-
 tions; for example , when applied to some value , is the same as
  
  .
  
 qsort 
  
 . 
  
 range 
 .
  
  
 qsort filter 
  
 qsort
  
  
  filter 
  
  
 qsort filter 
  
 if 
  
  
  
   
  
 otherwise
  
 Some element of the sequence is used as a ‘pivot’. The three filters partition the 
 elements less than the pivot, those equal to the pivot (of which there is at least 
 one), and the elements which are greater than the pivot into three separate sets. 
 The elements of the first and third partitions are sorted recursively. The two 
 sorted partitions are finally joined with the pivot partition to form the result.
  
 Quicksort can be implemented using both lists and arrays. The list based im-
 plementation is elegant, but not efficient. The array based implementation is 
 com-plicated, but more efficient. Both implementations will be discussed in the 
 follow-ing sections.
  
 Revision: 6.33",NA
7.4.1 ,NA,NA
Quicksort on the basis of lists,"The specification of quicksort uses filters which can be translated directly into 
 SML:
  
 (* qsort : char list -> char list *) 
  
 fun qsort [] 
  
 = [] 
  
  
 | qsort (p::xs) = let 
  
  
  
  
  
 fun less_eq x = x <= (p:char) 
  
  
  
  
 fun greater x = x > 
  
 (p:char) 
  
  
  
 in 
  
  
  
  
  
 qsort (filter less_eq xs) 
  
  
  
  
  
 @ [p] @ 
  
  
  
  
  
 qsort (filter greater xs) 
  
  
  
 end ;
  
 Local function definitions are required to capture the value of the pivot
  p
  for the 
 benefit of the comparison operators (See Section 6.4.2).
  
 The C version of
  qsort
  follows the SML version closely. The extra argument 
 version of
  filter
  is used to pass the pivot
  p
  to the comparison operators
  <=
  
 and 
 >
 .
  
 char_list qsort( char_list p_xs ) { 
  
  
 if( p_xs == NULL) { 
  
  
  
 return NULL ; 
  
  
 } else { 
  
  
  
 char 
  
 p 
  
 = head( p_xs ) ; 
  
  
  
 char_list xs = tail( p_xs ) ; 
  
  
  
 char_list ls = extra_filter( less_eq, &p, xs ) ; 
  
  
 char_list gs = extra_filter( greater, &p, xs ) ; 
  
  
 return append( qsort( ls ), 
  
  
  
  
  
  
 append( cons( p, NULL ), 
  
  
  
  
  
  
  
 qsort( gs ) ) ) ; 
  
  
 } 
  
 }
  
 We cannot define local functions in C so the auxiliary functions
  less_eq
  and 
 greater
  are defined as separate functions: 
  
 bool less_eq( void * arg, 
  
 bool greater( void * arg, 
  
  
  
 char x ) { 
   
  
 char x ) { 
   
 char * p = arg 
 ; 
  
  
 char * p = arg ; 
  
  
  
 return x <= * p ; 
  
  
 return x > * p ; 
  
 } 
  
  
  
 }
  
 The C version of
  qsort
  above is incomplete: the functions
  extra_filter
 , 
 cons
 , and
  append
  all allocate cells, but the store is not deallocated. Therefore, 
 this program needs to be amended so that the temporary lists are deallocated.
  
 Exercise 7.14
  Amend the code for quicksort so that redundant lists are deallo-
 cated. Assume that
  append( x, y )
  copies the list
  x
 ,
  cons
  creates 
 one
  
 Revision: 6.33",NA
7.4.2 ,NA,NA
Quicksort on the basis of arrays,"Arrays and lists are both representations of sequences. The difference between 
 the two representations is in the cost of the operations that can be applied to the 
 sequence. The quicksort algorithm partitions the input sequence into two 
 separate sequences. Implementing this efficiently using lists is difficult, since it 
 requires changing the linkage of the cells of the list. Moving data around in an 
 array is easier.
  
 Consider, as an example, the following operation of swapping two elements 
 of an array. The SML version accesses the elements of the array
  data
  at 
 positions
  i 
 and
  j
  and creates a new array with the values at positions
  i
  and
  
 j
  exchanged:
  
 (* swap : a array -> int -> int -> a array *) 
 fun swap data i j 
  
  
 = let 
  
  
  
  
 val data_i = sub (data, 
  
 i) 
  
  
  
  
 val data_j = sub (data, 
  
 j) 
  
  
  
  
 val data 
  
  
 = upd (data, 
  
 j, data_i) 
  
  
  
 val 
 data = upd (data, i, data_j) 
  
  
 in 
  
  
  
  
 data 
  
  
  
 end ;
  
 In a purely functional language, accessing an element of an array has a time com-
 plexity of
  
  and updating an element is an
  
  operation. In C, both accessing 
 and updating an array element is
  
  , because the array can be overwritten. An",NA
7.5 Summary,"The following C constructs were introduced:
  
 Streams
  The type to denote a stream in C is
  FILE *
 . The stream is stored exter-
 nally, it can be input by the user, from another program, or from a file. A 
 stream is a linear sequence, like an array and a list, but it can usually only 
 be accessed sequentially.
  
 The main programming principles that we have seen in this chapter are:
  
 The re-use of volatile information, such as that accessed from a stream, re-
 quires careful planning. Often, algorithms require the information from a 
 stream to be accessed a number of times. This is inefficient, and it pays off 
 to spend effort in trying to devise equivalent algorithms that glean the 
 relevant information from a stream whilst making a single pass.
  
 The primitives provided with the standard data types are often of a low 
 level of abstraction. In this chapter, we have built functions that provide a 
 buffered view of a stream. It is often a good idea to invest in a collection of 
 building blocks (functions and data structures) that deliver additional ser-
 vices, in this case buffering. In a sense, the buffering facilities mitigate one 
 of the restrictions that streams impose, the sequential access. Within certain 
 limits, the elements of a stream can be accessed in an order that is not quite 
 sequential. Enlarging the size of the buffer weakens the limited access to 
 the",NA
7.6 Further exercises,"Exercise 7.18
  The database of employees (Section 5.9 and Exercise 5.8) was stored 
 in memory. A real data base would be stored on a file. Design functions 
 which will allow the employee database to be stored on a file. Use the fol-
 lowing file format: the members of the structure are terminated by hash 
 signs (
 #
 ), each new structure starts on a new line. For example:
  
 John#18813#1963#80#90#75#20#69# 
 Mary#19900#1946#72#83#75#18#75# 
 Bob#12055#1969#120#110#100#99#99# 
 Alice#15133#1972#200#230#75#11#35#
  
 Exercise 7.19
  Quicksort is not the only sorting method. Another method is 
 bubble 
  
 sort. 
 It compares every element in an array of data to every other element. 
  
 If 
 two elements are out of order, then they are swapped. If there are 
  
 data
  
 Revision: 6.33",NA
Chapter 8,NA,NA
Modules,"All programs developed so far were small. They typically consisted of no more 
 than 10 functions. Real programs are larger (thousands of functions). Large pro-
 grams must be designed in such a way that the code can easily be inspected, 
 main-tained, and reused. This process of organising is generally known as 
 modularisa-tion.
  
 Modules are parts of the program that perform some specific function 
 together. During the design of a program, the solution is split into modules. 
 These modules use each other according to some well defined interface. Once the 
 interface and the functionality of a module are defined, modules can be 
 inspected, designed, compiled, tested, debugged, and maintained separately. 
 Additionally, modules can be reused in other programs where a similar 
 functionality is required.
  
 SML has a sophisticated module mechanism. It is completely integrated with 
 the language. An SML
  structure
  is a collection of types and functions; a
  signature 
 describes the interface of a structure, and a
  functor
  operates on structures to cre-
 ate a new structure. SML modules support everything mentioned above, with 
 the flexibility of a polymorphic type system.
  
 The module mechanism of C is rather different. It is probably the most crude 
 module mechanism of any programming language. The C module mechanism is 
 implemented by a separate program, the C preprocessor. The C preprocessor 
 takes a C program and prepares it for the C compiler. This preprocessor has no 
 knowledge of the syntax of C, but handles the program as text instead (indeed, 
 the C preprocessor can be used for many other purposes). The C module mecha-
 nism consequently lacks the sophistication of a real module system, as provided 
 by SML.
  
 The first section of this chapter describes the basic structure of the C module 
 system, and henceforth, of the C preprocessor. After that, we discuss the con-cept 
 of global variables as an important aspect of modularisation. Global variables 
 can be used to store state information that remains accessible across function 
 calls. When used correctly, global variables can be an asset. However, it is easy to 
 abuse them and obscure code. We show how global state can be stored 
 differently, lead-ing to a cleaner interface. This is akin to an
  object oriented
  style of 
 programming. After this, we show how modules can also be generalised, by 
 discussing the coun-terpart of polymorphism.
  
 245",NA
8.1 Modules in C: files and the C preprocessor,"The module concept of C is text oriented. The module facilities are implemented
  
 by the
  C preprocessor
 . This is a program that is separate from the C compiler. As
  
 far as the C preprocessor is concerned, it can process C programs, but it can pro-
  
 cess an assembly language program or an HTML script equally well. The entity
  
 on which the C preprocessor operates is the
  file
 . A file that is passed to the C com-
  
 piler for compilation is first processed by the C preprocessor. All lines that start
  
 with a hash-sign
  #
  are interpreted as commands. Textual substitutions are made
  
 where necessary throughout the entire file, substitution is not restricted to lines be-
  
 ginning with a
  #
  sign. Below, we create a module that implements complex arith-
  
 metic. After that, the features of the C preprocessor are explored in detail.",NA
8.1.1 ,NA,NA
"Simple modules,",NA,NA
 #include,"As an example, we develop a module for arithmetic on complex numbers. A com-
  
 plex number is defined as follows:
  
  
 Here is the imaginary part of the complex number ,
  
  , and is the real
  
 part of . Complex arithmetic works just like ordinary arithmetic, except that we
  
 have to take care that is properly handled. Examples:
  
  
 (8.1)
  
  (8.2)
  
 Equality (8.2) is true because
  
  .
  
 The implementation of complex subtraction and multiplication as functions in
  
 SML is given below. The
  complex_distance
  function gives the distance from
  
 the origin of the complex plane.
  
 structure Complex = struct
  
 type complex = real * real ;
  
 (* complex_sub : complex -> complex -> complex *)
  
 fun complex_sub (r,s) (t,u)
  
 = (r-t,s-u) : complex ;
  
 (* complex_multiply : complex -> complex -> complex *)
  
 Revision: 6.38",NA
8.1.2 ,NA,NA
Type checking across modules,"The module system is the Achilles heel of the C type system; it is important that 
 the C programmer is aware of this weakness so to avoid common mistakes. As 
 described so far, the typing system is safe (that is if certain C features, such as 
 void *
 , type casts and variable argument list are not used). If the prototype of a 
 function specifies three arguments of certain types, the compiler will not accept a 
 call with any other number of arguments or with the wrong types. There are, 
 however, two weaknesses:
  
 1. What if there is no prototype?
  
 2. Can the compiler verify that the prototype is correct?
  
 The first problem is caused by backward compatibility of ISO-C with C. Any 
 func-tion that is called for which no prototype has been declared is assumed to 
 be a function returning an integer number, and no checking of any kind is 
 performed on the argument list. This means that if one forgets to include a 
 header file, the compiler will not complain about using undefined functions, but 
 will simply as-sume that these functions return an integer. Most of the time the 
 compilation will fail because of some other problem. If, for example, the module
  
 complex.h
  is not included, the type
  complex
  is not defined, which will result 
 in an error. How-ever, a classic error is not to include the file
  math.h
  when 
 using the mathematical library. When calling the function
  sin(x)
  or
  sqrt(x)
 , 
 the compiler will silently assume that these function return an integer. The 
 results are dramatic. Most mod-ern compilers will (on request) inform the 
 programmer about missing prototypes.
  
  
 The second problem is also interesting. 
  
 When a module, for example 
 complex.h
 , is included, the compiler must assume that the specification is cor-
 rect. The correctness of this specification is verified when
  complex.c
  is 
 compiled. So far so good, but if the programmer forgets to include
  complex.h
  
 in the source",NA
8.1.3 ,NA,NA
Double imports,"In large programs, one often needs the interface to one module whilst building 
 the interface to another module. For example, a module with graphics primitives 
 might rely on a module defining matrices, vectors, and the associated arithmetic. 
 In turn, these modules might depend on other module interfaces.
  
 As in SML, C allows module interfaces to be imported in interfaces. However, 
 the C module system relies on the programmer to do so correctly. As a first 
 exam-ple, suppose that the graphics module uses matrices and vectors. 
 Therefore, the header file of the graphics module reads:
  
 #include 
 ""vector.h"" 
  
 #include 
 ""matrix.h"" 
  
 /*C 
 graphics 
 function 
 prototypes*/
  
 The matrix package in turn needs a definition of vectors, in order to supply oper-
 ations to multiply a matrix and a vector:
  
 #include ""vector.h""
  
 typedef struct { 
  
  
 vector *columns ; 
  
  
 int coordinates ; 
  
 } matrix ; 
  
 extern matrix matrix_multiply( matrix x, matrix y ) ; 
 extern vector matrix_vector( matrix x, vector y ) ;
  
 Finally, the vector header file defines some type for a vector:
  
 typedef struct { 
  
  
 double *elements ; 
  
  
 int coordinates ; 
  
 } vector ; 
  
 extern double vector_multiply( vector x, vector y ) ; 
 extern vector vector_add( vector x, vector y ) ;
  
 When the interface of the graphics module is used somewhere, the C preproces-
 sor will expand all include directives to import all types and primitives. This will 
 result in the following collection of C declarations:
  
 typedef struct {
  
 /*Lines imported by graphics.h*/ 
 Revision: 6.38",NA
8.1.4 ,NA,NA
Modules without an implementation,"The modules that we have seen so far have an implementation and an interface. 
 Not all modules need an implementation; a module may consist of only an inter-
 face. As an example, we can define a module for the booleans as follows:
  
 #ifndef BOOL_H 
  
 #define BOOL_H
  
 typedef enum { false = 0 , true = 1 } bool ;
  
 #endif /* BOOL_H */
  
 This module only exports a type, and it has no corresponding source file. From 
 now on, we will import the module
  bool.h
  when booleans are needed. 
  
  
 Like the vector module, the interface of the boolean module has been 
 protected against multiple inclusion, using a
  #ifndef
  and
  #define
 .",NA
8.1.5 ,NA,NA
The macro semantics of,NA,NA
 #define,NA,NA
 directives,"The
  #define
  mechanism is used for other purposes than for preventing the 
 mul-tiple inclusion of header files. In Chapter 5, we saw that constants can be 
 defined using a
  #define
 . In general,
  #define
  associates an identifier with a 
 (possibly empty) sequence of characters:
  
 #define monkeys 
  
 42 gorillas and 12 gibbons
  
 This 
  
 replaces 
  
 the 
  
 iden-tifier
  monkeys
  by the text
  42 gorillas and 
 12 gibbons
  everywhere in the program text after this definition. This 
 mechanism can be abused by defining, for example:
  
 #define BECOMES 
  
 = 
  
 #define INCREMENT ++
  
 Now we can write
  i INCREMENT
  instead of
  i++
 , or
  i BECOMES 13
  instead 
 of 
 i = 13
 . This will make the code guaranteed unreadable for anyone but the 
 origi-nal author. Because replacement of identifiers is textual, the scoping rules 
 of the C grammar are ignored by the C preprocessor. This means that
  #define
  
 statements
  
 Revision: 6.38",NA
8.2 Compiling modules,"The C language has been designed so that modules can be compiled separately. 
 That is, the compiler can compile one module without knowledge of the imple-
 mentation of any of the other modules. The header files provide the necessary 
 information about the interfaces of the other modules. Therefore, if the code of 
 one module is changed, only that module needs to be recompiled. The code from 
 all other modules stays the same. This shortens the development cycle of a C 
 pro-gram, as only small parts of programs need to be recompiled.
  
 If one of the header files is changed (for example, because the argument list of 
 a function has been changed), each module that imports the changed header file 
 needs to be recompiled. This is necessary for the compiler to verify that the 
 changed interface is still used correctly. If a module is not recompiled, it might 
 lead to a runtime error. Because it is hard to remember which modules need to 
 be compiled upon a change, most development environments offer a facility to 
 recompile all modules that are dependent on a changed interface.",NA
8.2.1 ,NA,NA
Separate compilation under UNIX,"UNIX C-compilers have a command line option to tell them that a module must 
 be compiled separately. This means that the compiler will not generate an 
 executable, but it will generate an
  object
 -file. As an example, we can compile the 
 source code of the module
  vector
  above by:
  
 cc -c vector.c
  
 Revision: 6.38",NA
8.2.2 ,NA,NA
Separate compilation on other systems,"The reader may at this moment exclaim “This is one big kludge! Each loophole is 
 patched with another loophole”. This statement is true to a certain extent. The 
 reason why it seems to be a system of patches on patches is that the UNIX design 
 philosophy (where
  make
 ,
  C
 , and many other tools stem from) states that all 
 tools should be as reusable as possible.
  
 This was a revolutionary idea in the early seventies. The program
  make
  can 
 be used to compile any language, not just C. It can compile Fortran programs, 
 make a new UNIX kernel, or be used to decide which chapters of a book need to 
 be type-set. Similarly, UNIX offered one editor that was used for all purposes; 
 furthermore the C preprocessor is, as we have seen before, to a large extent C 
 independent. The advantage is that one has one big toolbox containing many 
 (semi-)general purpose tools.
  
 The disadvantage of this approach is that it is not user friendly at all. Given 
 the set of C modules that constitute a C program, the compiler could itself decide 
 which modules to recompile, without needing a make file or make file-generator. 
 This is more user friendly. Indeed, this is the approach taken by many C devel-
 opment environments running on Macintoshes or modern PCs. Internally, these 
 environments have an editor, a
  make
  facility, a tool to work out which 
 dependen-cies exist, a C preprocessor, a compiler, and a linker, but the subtle 
 differences are hidden from the user. Additionally, an integrated editor allows 
 the editor to check the syntax of the program and can highlight compiler errors 
 in the source code.
  
 Many of these development environments exist; most of these have built-in 
 fa-cilities to recompile only those modules that need recompilation. It is 
 impossible to address all these systems in detail. The reader is referred to the 
 appropriate documentation for the system of interest.",NA
8.3 Global variables,"All functions that have been defined so far are functions that operate on values 
 provided via their arguments. Imperative languages have another place where 
 data can be stored known as
  global variables
 . Global variables can ‘remember’ 
 data between function calls. When used with care, global variables can be an 
 asset. However, it is often better to use explicit global state, which is not hidden 
 in global variables. As an example, we will develop a pseudo random number 
 generator.",NA
8.3.1 ,NA,NA
"Random number generation, how to use a global variable","Random numbers are often used in simulation programs, where a random choice 
 is to be made. True random numbers cannot be generated by a program, but 
 good",NA
8.3.2 ,NA,NA
Moving state out of modules,"Clean C modules use a purely functional interface, as, for example, the module 
 on complex numbers presented in the first section of this chapter. Some functions 
 like the random number generator shown above are naturally formulated using 
 state and state changes. However, they can still be designed so that they have a 
 clear interface. The purely functional interface of the random number module 
 was
  
 Revision: 6.38",NA
8.3.3 ,NA,NA
Scoping and life time of global and local variables,"Using the technique of lifting state out of modules, global variables can almost 
 always be avoided. However, in some cases, global variables are the appropriate 
 solution. To explain this, it is important to elaborate on the lifetime and visibility 
 (or scoping) of variables. The variables used in the first 7 chapters are all local 
 variables. Local variables are declared in a block. A local variable is associated 
 with a storage cell just before execution begins of the first statement in the block. 
 The store is deallocated when the last statement of the block has been executed. 
 The block is also the
  scope
  of the variable, where it can be seen and where it can 
 be used.
  
 Variables declared
  static
  live for as long as the program executes. They 
 are created when the program starts and cease to exist when the program 
 terminates. These variables are visible to all functions in a module. When a
  
 static
  variable is declared inside a function, the
  scope
  of this variable, the
  
 visibility
 , is restricted to the enclosing group of statements. Consider the function
  
 counter
  below:
  
 int counter( void ) { 
  
  
 static int count = 10 ; 
  
  
 return count++ ; 
  
 }
  
 The declaration
  static int count = 10
  creates a variable called
  count
 . 
 The scope of count is restricted to this function, but the lifetime of count is that of 
 a global variable. So
  count
  is created when the program starts; it is at that 
 moment initialised to
  10
 , and then
  count
  is used by the function
  counter
  in 
 subsequent calls. Note that the initialisation happens only during program 
 startup, not on each function invocation. Thus, the function
  counter
  will 
 return the values
  10
 , 
 11
 ,
  12
 ,
  13
 , ... on successive calls to
  counter
 .
  
 C also supports variables that are visible to
  any
  module of the program. These 
 variables are known as
  external variables
 . An external variable must be declared 
 outside a function, just like a
  static
  variable, but without the keyword
  
 static
 :
  
 int very_global_count = 10 ;
  
 To make an external variable visible to other modules, it should also be declared 
 in the header file of the module with the keyword
  extern
 :
  
 extern int very_global_count ;
  
 External variables can be read and written by any function in the program. Com-
 munication between functions via global variables should be avoided if possible. 
 A good use of global variables is when data need to be broadcasted
  once
 . As an 
 ex-ample, one can have a boolean
  verbose
  that indicates that every function in 
 the whole program should print what it is doing.
  
 A common mistake with the use of external global variables is to have two 
 global variables with the same name in two separate modules of the program. 
 The C compiler will not complain, but the linker will silently unify these two 
 variables (as they share the same name space). Suppose that there are two 
 modules and that each module has a variable
  counter
 :
  
 /*C module 1 with counter*/",NA
8.4 Abstract Data Types,"There is one important detail that can be improved on the modules shown 
 earlier. In most cases, the header file exports the full details of the data type on 
 which the module operates. As an example, the header file of the random 
 number module contains a full declaration of the type
  random
 :
  
 typedef struct { 
  
  
 int seed ; 
  
 } random ;
  
 This is undesirable as it exposes some of the internal workings of the module to 
 its clients, while the clients are not supposed to know it. Each time the internal 
 details of the type
  random
  change, the interface is changed as well, which will 
 require all clients of the random module to be compiled again. Worse, spelling 
 out the details invites programmers to
  use
  the internal details.
  
 It is better to omit the details of the type from the interface. C allows this by 
 means of an
  incomplete
  structure definition. An incomplete structure definition 
 re-quires the struct to be named, as was necessary to define a recursive type 
 (Chap-ter 6). This results in the following definition of
  random
 :
  
 typedef struct random_struct random ;
  
 Revision: 6.38",NA
8.5 Polymorphic typing,"A module supports a number of important concepts. One of these concepts is 
 that of
  reusability
 . The random generator shown before returns random numbers 
 in a certain range. The range is an argument of the function. It would not be a 
 good idea to write another random generator for each range. In the same way as 
 func-tions are permitted to be parametrised over their argument values, it is also 
 useful to allow
  types
  to be parametrised.
  
   
 As an example, consider lists: a list of characters was defined in Chapter 6, a 
 list of strings was defined in Exercise 8.6. If the user needs a list of integers, 
 neither of these modules can be reused. The solution to this problem in 
 functional languages is to use polymorphism, implemented through a
  type 
 parameter
 . The SML definitions of a character list and a general list are: 
  
 datatype char_list 
  
 datatype a list 
  
    
 = Nil 
  
   
 = Nil 
  
  
  
  
  
 | Cons of (a*a 
 list); | Cons of (char*char_list);
  
 Revision: 6.38",NA
8.6 Summary,"The following C constructs were introduced:
  
 Header and implementation files
  In C, the interface of a module is defined in the
  
 header (
 .h
 ) file, and the implementation in the source (
 .c
 ) file.
  
 Preprocessor
  The C preprocessor processes the text of a C program before the
  
 actual compilation. 
  
 The three most important directives are
  #define
 ,
  
 #include
  and
  #ifndef
 . The
  #define
  directive will cause a macro name
  
 to be (literally) replaced with a sequence of characters. The
  #include
  direc-
  
 tive literally includes a file (typically a header file of a module) at that place
  
 in the source. The
  #ifndef
  directive leaves text out if a macro has been de-
  
 fined:
  
 #ifndef
  
 #include ""filename""
  
 #define 
  
 ( , 
  
 ...)
  
 #endif /* 
  
 */
  
 Revision: 6.38",NA
8.7 Further exercises,"Exercise 8.10
  Functions with a small domain are often implemented using a
  
 memo 
 table. For each value in the domain, one would keep the 
 corresponding function value. Instead of computing the value, it is merely 
 looked up. The factorial function is a good example of a function with a 
 small domain.
  
 Here is a table of some of its values:
  
  
 1 
           
 1 
  
  
 2 
           
 2 
  
  
 3 
           
 6 
  
  
 4 
          
 24 
  
  
 5 
         
 120 
  
  
 6 
         
 720 
  
  
 7 
        
 5,040 
  
  
 8 
       
 40,320 
  
  
 9 
      
 362,880 
  
 10 
     
 3,628,800 
  
 11 
    
 39,916,800 
  
 12 
   
 479,001,600 
  
 13 
  
 6,227,020,800 
  
 14 87,178,291,200
  
 The function values grow so quickly that, with 32-bit arithmetic, overflow 
 occurs for . Thus a table of 12 values is sufficient to maintain the entire 
 domain and range of the factorial function for 32-bit arithmetic.
  
 Write a C function that uses an array as a memo table. Your function 
 should compute the appropriate values just once, and it should not 
 compute more values than strictly necessary. When the argument is 
 beyond the domain, your function should abort.
  
 Exercise 8.11
  Exercise 8.7 required the implementation of a dynamic array of in-
 tegers. Define a module that implements a polymorphic dynamic array. 
 Upon creation of the array, the size of the data elements is passed, subse-
 quent functions (for indexing and bound changes) do not need extra pa-
 rameters.",NA
Chapter 9,NA,NA
Three case studies in graphics,"In this chapter we will make three case studies to put in practice the principles 
 and techniques introduced before. The first case study is a small program to 
 draw a fractal using X-windows. The second study is a device independent 
 graphics driver, using X-windows, PostScript, and possibly some other graphics 
 output de-vices. The third case study is an interpreter for an elementary graphics 
 descrip-tion language, called
  gp
 . The
  gp
  interpreter uses the device 
 independent graphics driver of the second case study.
  
 The three case studies are increasingly more difficult, and the amount of 
 detail left to the reader also increases. The first case study spells out the data 
 structures and algorithms to be used. The second case study gives the data 
 structures and some code. The third case study only suggests the data structures 
 that might be used. The reader is encouraged to work out these case studies.
  
 All programs use X-windows to render the graphics. Being able to use the X-
 windows library is at the same time a useful skill and a good test of one’s 
 program-ming abilities. We choose the X-windows system because it is widely 
 available; it runs on PC’s, workstations and the Macintosh; and it is public 
 domain software. The disadvantage of choosing the X windows system is that it 
 is a complex system, especially for the beginning programmer. For this reason, 
 we use only an essen-tial subset of X. The interested reader is referred to the X-
 windows programming manuals for complete details [17].",NA
9.1 First case study: drawing a fractal,"The
  Mandelbrot set
  is a fractal, a shape that is irregular, no matter how far it is 
 mag-nified. It is also a pretty picture. We will write a program to render such a 
 picture on the screen. To perform the actual drawing on the screen, we use the X-
 windows toolkit.
  
 We divide the problem into two parts. First we will define the Mandelbrot set 
 and define a module that computes whether a point is part of the set or not. Then 
 a module is defined that displays the points on the screen. These two modules 
 constitute a relatively complicated program which will be developed by refining 
 an initial, inefficient version to a final efficient version.
  
 283",NA
9.1.1 ,NA,NA
Defining the Mandelbrot set,"The Mandelbrot set is defined as follows. Given a point in the complex plane,
  
 the recurrence relation below defines a series of complex numbers
  
  :
  
  
  if
  
 For some choices of the point , the series diverges. Take the following two ex-
  
 amples. If
  
  , the series is:
  
 For another choice,
  
  , the series is:
  
 An example value of for which the series does not diverge is
  
  :
  
 &%
  
 This series converges to . In general, if for a given , there is a 
  
 such
  
 that
  
 which the series 
 +
  
  , the series
  
  converges. If the set of points is plotted in the complex plane, a 
 diverges. The Mandelbrot set is defined as all points for
  
 pretty picture results.
  
 The program that we are going to develop will calculate an approximation to
  
 the Mandelbrot set. To decide whether a point belongs to the set, it would be nec-
  
 essary to compute all points of the series , which is an infinite task. We are going
  
 to approximate this by calculating only a fixed length prefix of each series. If this
  
 prefix does not diverge, then we assume that the infinite series does not diverge.
  
 The approximation can be improved by increasing the number of steps, but at the
  
 expense of extra run time.
  
 The solution to the Mandelbrot problem is first given in SML. We will also need
  
 the complex arithmetic module from Chapter 8. The function that decides whether
  
 a point belongs to the Mandelbrot set is:
  
 (* in_Mandelbrot : Complex.complex -> bool *)
  
 fun in_Mandelbrot c
  
 = let
  
 open Complex
  
 val MAXSTEPS = 31
  
 fun step i z
  
 = let
  
 val z = complex_sub (complex_multiply z z) c
  
 in
  
 if complex_distance z > 1.0",NA
9.1.2 ,NA,NA
Drawing the fractal on the screen,"Before we show which functions the X-windows library provides to draw some-
 thing on the screen, we give a short overview of the X-windows package. The 
 figure below shows a possible environment where X-windows can be used.
  
 Network
  
 Displays
  
 Windows
  
 Pixels
  
 This particular configuration shows three computers, two of which have a
  dis-
 play
 . The computers are connected via a network. An X application can run on 
 any computer (whether it has a screen or not) and can use any number of 
 displays on the network. As an example, a multi user game could run on the 
 computer in the middle and use the two displays connected to systems on the 
 left and right. Sim-ple applications, like an editor, will often use only one display 
 and will execute on the machine connected to that display.
  
 Within a display, an X-application distinguishes one or more
  windows
  that it 
 controls. Most applications will use a single window, but an application can con-
 trol an arbitrary number of windows. Within a window, the application program 
 can do whatever it wants; the X-server will not allow an application to write out-
 side its window to avoid destroying other windows, nor will it allow writing in 
 parts of a window that are obscured by other windows.
  
  
 Each window of an X application is composed of a grid of dots, or
  pixels
 . Each 
 dot has a specific colour. On a monochrome display, a dot can be ‘black’ or 
 ‘white’, but most modern computers have a colour screen, allowing a pixel to 
 have any of a large range of colours. Each pixel on the grid is addressed with a 
 coordinate. The coordinate system is slightly unusual: the origin is in the top left 
 hand corner, the X coordinates run from left to right, and the Y coordinates run
  
 top-down
 . So the top left hand pixel of a window is the pixel with coordinates
  
  
 , the next one down is pixel
  
  , and so on. 
 The X library provides functions, for example, to fill a rectangular area of dots 
 with a colour, or to render some characters.
  
 Given that an X application may use multiple displays and windows, the spe-
 cific window and display to be used must be specified when performing some 
 graphics operation. This information is not stored implicitly in the library, but 
 must be explicitly passed by the program. This might be confusing at first 
 because many applications use only one display and one window, but it makes 
 the library more general. The X designers could have stored a “Current display” 
 and “Cur-rent window” in global variables to shorten the argument list, but have 
 (in our opinion rightly) chosen to avoid the global state.
  
 Revision: 1.25",NA
9.1.3 ,NA,NA
Shortening the argument lists,"Each 
  
 of 
  
 the 
  
 three 
  
 functions 
  
 window_to_complex
 , 
  
 draw_pixel
 , 
  
 and 
 draw_Mandelbrot
  has a large number of arguments. This is undesirable, as it 
 does not look pretty, it is too much work to type, and it sometimes obscures the 
 purpose of a function. Here are the prototypes of the relevant functions gathered 
 together:
  
 complex window_to_complex( int X, int Y, 
  
 int WIDTH, int HEIGHT, 
  
 double x, double y, 
  
 double width, double height ) ;
  
 void draw_pixel( Display *theDisplay, Window theWindow, 
 long colour, 
  
 int x, int y ) ;
  
 void draw_Mandelbrot( Display *theDisplay, Window theWindow, 
 long black, long white, 
  
 int WIDTH, int HEIGHT, 
  
 double x, double y, 
  
 double width, double height) ;
  
 Some of these arguments are unnecessary, since they are constant. As an 
 example, the variable
  theDisplay
  is a constant: it is set once (in the
  main
  
 program) and used afterwards in many functions. As this application uses only 
 one display, we can choose to make
  theDisplay
  a
  static
  variable by 
 declaring it before the first function of the module as follows:
  
 static Display *theDisplay ;
  
 Revision: 1.25",NA
9.1.4 ,NA,NA
Handling events,"The program as it has been developed so far has two problems. Firstly, the pro-
 gram cannot be stopped in an elegant way: the user has either to abort the 
 compu-tation, or to destroy the window. Secondly, the program does not 
 properly redraw",NA
9.2 Second case study: device independent graphics,"The first case study used the X-windows system as its sole output device. In this 
 second case study we will develop a well engineered
  device driver
 . The X-
 windows library offers functions for rendering boxes, circles, and so on, and 
 there are func-tion calls to initialise the X-windows library. All graphics systems 
 have an inter-face which has such a structure, but the details differ. In this 
 section we will show how to define a general interface that supports the various 
 devices.
  
 We will first develop an interface that has only limited functionality: it should 
 be possible to draw a line from one point to another. As soon as that has been 
 achieved, the functionality will be extended to cater for other primitives, such as 
 boxes, circles or text. The running example will consider two output devices: X-
 windows and PostScript, but other devices can be added with relative ease. X 
 Windows was introduced in the previous chapter. It is a windowing system that 
 runs on almost any workstation. PostScript is a graphics language that is mainly 
 used to control the output of printers. We will give a brief description of 
 PostScript below.",NA
9.2.1 ,NA,NA
PostScript,"PostScript is a programming language. 
  
 A PostScript program is specified in 
 ASCII. In order to render the graphics, the program need to be interpreted. 
 PostScript interpreters are found in printers, and in many windowing systems. 
 Note the difference with X: X graphics are drawn by calling a C function, 
 PostScript graphics are drawn by generating a bit of PostScript code. Consider 
 the following PostScript program:
  
 %!PS 
  
 newpath 
  
  
 0 
  
 0 moveto 
  
  
 0 100 lineto 
  
 100 100 lineto 
  
 100 
  
 0 lineto 
  
 closepath 
  
 stroke 
  
 showpage
  
 The first line
  %!PS
  declares this as a PostScript program. The second line starts a 
 new line drawing, called a
  path
  in PostScript. The
  moveto
  command moves the 
 current position to the point with coordinates (0,0).
  
 PostScript is a
  stack based language
 . This means that arguments are listed
  before 
 giving the name of the function for which the arguments are intended. PostScript 
 uses the standard Cartesian coordinate system, with the lower left corner of the 
 area that can be used for drawing at (0,0). This is thus different from X-windows, 
 which uses the top left hand corner of the image as point (0,0). Such differences 
 will be hidden by the device independent driver that we are about to develop.
  
 In the PostScript program above, the first
  lineto
  command defines a line
  
 Revision: 1.25",NA
9.2.2 ,NA,NA
Monolithic interface design,"To draw a line in X-windows we have to execute the following C function call:
  
 XDrawLine( display, window, gc, x1, y1, x2, y2 ) ;
  
 Here the display, window and graphics context are identified by
  display
 , 
 window
  and
  gc
 . The last four arguments identify the (integer) coordinates of 
 the begin and end point of the line. A PostScript program fragment to draw a 
 line reads:
  
 moveto 
  
 lineto
  
 Here
  
  and
  
  are the (real) coordinates of the begin and the end point 
 of the line. The data structures and function that will draw a line in either 
 PostScript or X-windows should take into account the peculiarities of both X-
 windows and PostScript. Here are the appropriate data structures, where
  X11
  
 represents the X-windows library and
  PS
  the PostScript format:
  
 #include <X11/Intrinsic.h> 
  
 #include <X11/StringDefs.h> 
  
 #include <stdio.h>
  
 #define X11HEIGHT 100 
  
 #define X11WIDTH 
  
 100
  
 typedef enum { X11, PS } Devicetype ; 
 typedef struct { 
  
  
 Devicetype tag ; 
  
  
 union { 
  
  
  
 struct { 
  
  
  
  
 Display *d ; 
  
  
  
  
 Window w ; 
  
  
  
  
 GC gc ;
  
 Revision: 1.25",NA
9.2.3 ,NA,NA
Modular interface design,"A better way to build a general interface to graphics devices is to insert a new 
 level of abstraction. Looking from an abstract viewpoint, a library to draw 
 pictures on some output device consists of a set of functions for drawing the 
 various primitive elements. For example:
  
 draw box
  
 lower left
  
 upper right
  
  and
  
 draw line
  
 from
  
 to
  
 draw circle
  
 centre
  
 radius
  
 draw ellipse
  
 centre
  
 radii
  
 To manipulate a set of functions such as those listed above we need a data struc-
 ture that holds them together. In SML we could define the data structure as fol-
 lows:
  
 datatype a graphics 
  
  
 = DrawBox of 
  
 (a * int * int * int * int -> a) 
  
 | DrawLine of 
  
 (a * int * int * int * int -> a) 
  
 | DrawCircle of 
  
 (a * int * int * int -> a) 
  
  
 | DrawEllipse of (a * int * int * int * int -> a) ;
  
 Revision: 1.25",NA
9.3 Third case study: a graphics language,"We have now discussed how a device independent library of graphics primitives 
 for boxes, circles and lines can be built. This library can be used directly from a C 
 program that intends to create some graphics. However, the library functions are 
 still quite low level because bookkeeping is required to place and size the lines, 
 circles and boxes appropriately. This can be especially cumbersome when a com-
 plicated picture is created out of a large number of primitive graphical objects.
  
 As our third case study we are going to define a graphics programming lan-
 guage for creating line drawings. In addition we will develop a C program,
  gp
 , 
 that interprets programs written in the graphics language to draw pictures on an 
 output device of our choice. The program will use the device independent graph-
 ics library.
  
 We will develop a working skeleton of the language. Not all features are 
 imple-mented, but the reader is encouraged to add these features. Still, 
 developing this skeleton is not a trivial task: we will have to use some advanced 
 programming techniques which are not covered in this book. We explain these 
 techniques, lexi-cal analysis and parsing, on a need-to-know basis. Books such as 
 the ‘red dragon book’ [1] on compiler construction, automata, and languages 
 give an in depth cov-erage of these techniques.
  
 Here is a picture showing the result of using
  gp
 . The picture has a dual pur-
 pose. Firstly it shows the style of line drawings that we will be able to produce.
  
 Secondly it symbolises the working of the graphics interpreter
  gp
  itself:
  
 file
  
 gp
  
 device
  
 Revision: 1.25",NA
9.3.1 ,NA,NA
Lexical analysis,"The graphics language has four different kinds of words, of which we have al-
 ready seen three categories:
  
 ident
  (short for identifier). Examples are
  circle
  and
  .PS
 .
  
 symbol
  such as
  ;
 .
  
 text
  enclosed in double quotes, such as
  ""file""
 .
  
 number
  It seems a good idea to include also real numbers in our graphics lan-
 guage, as they will be handy for creating primitives of a specific size and 
 movements over a certain distance. An example of a number is
  3.1415
 .
  
 error
  We have now essentially decided upon the possible form of the words that 
 we admit to our language. However, a well designed program should al-
 ways be able to deal with incorrect input. To cater for this we add a further 
 category of words that represent erroneous input. Some examples are:
  
 @#%$ 
 and
  3.A
  
 Now we can define a data structure to represent all possible words, which is con-
 ventionally called a
  token
 . Here is the SML version of the data structure:
  
 datatype token = Number of real 
  
 | Ident 
  
 of string 
  
 | Text 
  
 of string 
  
 | Symbol of string 
  
 | Error ;
  
 Revision: 1.25",NA
Parsing,Chapter 9. Three case studies in graphics,NA
9.3.2,"The lexical analysis delivers a stream of tokens, one for each call to the function 
 lex
 . So now is the time to gather selected tokens into larger units that 
 correspond to the sentences of the language. To make life easier for the 
 interpreter we will de-fine a number of data types that describe the relevant 
 sentences and sub sentences of the graphical language.
  
 Here is the SML data type definition of the graphical primitives:
  
 datatype primitive = Box | Circle | Line ;
  
 To allow for some flexibility in the graphics language we allow for expressions 
 that consist of either an identifier or a number:
  
 datatype expression = Ident 
  
 of string 
  
 | Number of real ;
  
 With a primitive we would like to associate not only its text label, but also 
 whether it should have a particular height, width or radius. This gives rise to the 
 following SML data type definition for an attribute of a graphics primitive:
  
 datatype attribute = Height of expression 
  
 | Width 
  
 of expression 
  
 | Radius of expression 
  
 | Text 
  
  
 of string ;
  
 We are now ready to define the data type for the elements (that is, the sentences 
 of the graphics language):
  
 datatype element = Up 
  
  
 | Down 
  
  
 | Right 
  
  
 | Left 
  
  
 | Assign of string * expression 
  
  
 | Prim 
  
 of primitive * attribute list ;
  
 The
  element
  data type allows for six different kinds of sentences. The first four 
 are intended to move to a particular position before beginning to draw the next 
 ob-ject. The
  Assign
  constructor associates an identifier (represented here as a 
 string of characters) with an expression. This will enable us to give a name to an 
 expres-sion and refer to that name wherever the value of the expression is 
 required. The last element is the most interesting for it associates a graphics 
 primitive with its list of attributes.
  
 Exercise 9.15
  Create a module that defines the data structures in C to represent 
 the
  primitive
 ,
  expression
 ,
  attribute
  and
  element
 . These 
 should be heap allocated structures.
  
 The definition of an
  element
  would allow us to write (in SML):
  
 val box_primitive = Prim(Box,[Text ""a box"", 
  
  
 Height (Number 3.0)]);
  
 Revision: 1.25",NA
9.3.3 ,NA,NA
Interpretation,"We have now at our disposal a library of device independent graphics primitives 
 and the lexing and parsing tools to create a structured, internal representation of 
 a
  gp
  program in the heap. To combine these elements we need to write an in-
 terpreter of the internal representation of the program, that calls the appropriate 
 library routines. Before we can embark on this two further explanations of how 
 gp
  works.
  
 Firstly, the program has a notion of a current point and a current direction. By 
 default the current direction is
  right
 , but it can be modified by one of the com-
 mands
  up
 ,
  down
 ,
  left
  or
  right
 .
  
 The current point will be aligned with a particular corner or point of the next 
 graphical object to be drawn. Let us assume for now that the current direction is 
 right
 . The current point is then aligned with:
  
 line
  The begin point of the line.
  
 box
  The middle of the left vertical.
  
 circle
  The left intersect of the circle and a horizontal line through its centre.
  
 The small circles in the picture below give a graphical indication of the alignment 
 points.
  
 line:
  
  
 direction
  
 box:
  
  
 direction
  
 circle:
  
 direction
  
 The alignment point is thus as far away from the point to which we are mov-ing. 
 This also applies to moves in one of the other three directions. For example, 
 should we be moving upwards, the alignment point is below the object, instead 
 of its left.
  
 Secondly, the
  gp
  program maintains a set of variables that control the default 
 dimensions of the primitive objects, as well as the default moving distances. 
 These variables can be set using assignment statements. The variables and their 
 initial settings (in inches) are:
  
 .PS 
  
 boxht = 0.5 
  
  
 ; 
  
 boxwid = 0.75 ; 
  
 circlerad = 0.25 ; 
  
 lineht 
  
 = 0.5 
  
 ; 
 linewid = 0.5 
  
 ;
  
 Revision: 1.25",NA
9.4 Summary,"Programming graphics systems is rewarding, but it also a difficult topic that is 
 worthy of study on its own. In this chapter we have merely hinted at some of the 
 possibilities of computer graphics. Three case studies have been made to show 
 how the principles of programming as we have developed them in this book are 
 used in practice. The most important practical points are:
  
 Use separate modules whenever possible. 
  
 Modularisation structures the 
 program and allows independent development, testing and maintenance.
  
 Hide platform and machine dependencies (for example graphics libraries) 
 in separate modules.
  
 Use higher order functions when appropriate. Writing device drivers using 
 higher order functions simplifies the structure of the program.
  
 To create your design use a language with polymorphic types. Then 
 translate the design into C, using
  void *
  if necessary.",NA
9.5 Further exercises,"Exercise 9.19
  Extend the expressions of the
  gp
  language with the usual 
 arithmetic 
  
 operators, such as
  +
 ,
  -
 ,
  *
  and
  /
  and with parentheses
  (
  and
  )
 .
  
 Revision: 1.25",NA
Bibliography,"[1] A. V. Aho, R. Sethi, and J. D. Ullman.
  Compilers: Principles, techniques, and 
  
 tools
 . Addison Wesley, Reading, Massachusetts, 1986.
  
 [2] J. L. Hennessy and D. A. Patterson.
  Computer architecture: A quantitative ap-
  
 proach
 . Morgan Kaufmann Publishers, Inc., San Mateo, California, 1990.
  
 [3] C. A. R. Hoare. Algorithm 64 quicksort.
  CACM
 , 4(7):321, Jul 1961.
  
 [4] Adobe Systems Inc. 
  
 PostScript language reference manual
 . 
  
 Addison 
 Wesley, 
  
 Reading, Massachusetts, 1985.
  
 [5] R. Jain. 
  
 The art of Computer Systems Performance Analysis
 . 
  
 John Wiley, 
  
 Newyork, 1991.
  
 [6] B. W. Kernighan. PIC — a language for typesetting graphics. 
  
 Software—
  
 practice and experience
 , 12(1):1–21, Jan 1982.
  
 [7] B. W. Kernighan and D. W. Ritchie.
  The C programming language - ANSI C
 . 
 Prentice Hall, Englewood Cliffs, New Jersey, second edition edition, 1988.
  
 [8] D. E. Knuth. 
  
 The art of computer programming, volume 1: Fundamental algo-
  
 rithms
 . Addison Wesley, Reading, Massachusetts, second edition, 1973.
  
 [9] L. C. Paulson.
  ML for the working programmer
 . Cambridge Univ. Press, New 
  
 York, 1991.
  
 [10] W. H. Press, B. P. Flannery, S. A. Tekolsky, and W. T. Vetterling.
  Numerical 
 recipes in C – The art of scientific computing
 . Cambridge Univ. Press, 
 Cambridge, England, 1993.
  
 [11] B. Schneier.
  Applied cryptography
 . John Wiley & Sons, Chichester, England, 
  
 second edition edition, 1996.
  
 [12] R. Sedgewick.
  Algorithms
 . Addison Wesley, Reading, Massachusetts, 1983.
  
 [13] E. H. Spafford. The internet worm program: an analysis. 
  
 communication review
 , 19(1):17–??, Jan 1989.
  
 ACM Computer
  
 [14] A. S. Tanenbaum.
  Structured computer organisation
 . Prentice Hall, Englewood 
  
 Cliffs, New Jersey, second edition, 1984.
  
 319",NA
Appendix A,NA,NA
Answers to exercises,"Below are the answers to a selection of the exercises in this book. For almost any
  
 exercise, there is more than one correct answer, as there are many algorithms and
  
 datastructures that implement a program. The answers that are presented here are
  
 the ones that we consider the most appropriate.",NA
Answers to the exercises of Chapter 2,"Answer to 2.1: 
  
 The function
  euclid
  is called 5 times. A complete trace is:
  
 euclid( 558, 198 )
  is
  
 euclid( 198, 162 )
  is
  
 euclid( 162, 36 )
  is
  
 euclid( 
  
 36, 18 )
  is
  
 euclid( 
  
 18, 
  
 0 )
  is
  
 18
  
 Answer to 2.2: 
 The general SML function schema for a cascade of conditionals
  
 is:
  
 (*SML general function schema*)
  
 (* 
  
 :
  
 -> ...
  
 -> 
  
 *)
  
 fun 
  
 ...
  
 = if
  
 then
  
 else if
  
 then
  
 ...
  
 else if
  
 then
  
 else 
  
 ;
  
 The arguments of 
  
 are
  
  , and their types are
  
  respectively. The ex-
  
 pressions
  
  are predicates over the arguments of ,
  
  and are expres-
  
 sions over the arguments of .
  
 321",NA
Answers to the exercises of Chapter 3,"Answer to 3.2: 
  
 The SML and C versions of
  leap
  that take the extended range of
  
 years into account are:
  
 (* leap : int -> int *)
  
 fun leap y = if y mod 4 <> 0 orelse
  
 y mod 100 = 0 andalso y mod 400 <> 0
  
 then leap (y+1)
  
 else y ;
  
 int leap( int y ) {
  
 if( (y % 4 != 0) ||
  
 (y % 100 == 0 && y % 400 != 0) ) {
  
 return leap( y+1 ) ;
  
 } else {
  
 return y ;
  
 }
  
 }
  
 Answer to 3.3: 
  
 The table below shows the correspondence between the two
  
 versions of
  leap
 . The first column refers to the basic while-schema.
  
 schema: 
  
 Functional 
  
 C
  
  : 
 leap 
  
 leap
  
  : 
  
 int 
  
 int
  
  : 
  
 int 
  
 int
  
  : 
 y 
  
 y
  
  : 
  
 y mod 4 <> 0 
  
 y % 4 != 0
  
  : 
  
 y+1 
  
 y+1
  
  : 
 y 
  
 y
  
 Answer to 3.5: 
  
 The correspondence between elements of the multiple argu-
  
 ment while-schema and the version of
  euclid
  above is as follows:
  
 Revision: 6.41",NA
Answers to the exercises of Chapter 4,"Answer to 
 4.1:
  
 In the drawings below we have used
  
 d
  
  and
  d
  
  to denote the two
  
 parts of
  d
 . Each of these parts occupies one storage cell. The structure
  structx 
 will occupy 5 cells, and the union
  unionx
  requires two cells:
  
 structx
 :
  
  
 i
  
 d
  
 d
  
 p.x
  
 p.y
  
  
 unionx
 :
  
  
 i
 ,
  d
  , or
  p.x
  
  ,
  d
  , or
  p.y
  
  
 Answer to 4.2:
  
 The SML datatype for a point in 2-dimensional space is defined
  
 in the following way:
  
  
 datatype coordinate = Polar 
  
 of
  
 Cartesian of
  
 The equivalent C type-declaration is:
  
 real * real | 
  
 real * real ;
  
 typedef enum { Polar, Cartesian } coordinatetype ;
  
 typedef struct { 
  
  
 coordinatetype tag ; 
  
  
 union { 
  
  
  
 struct { 
  
  
  
  
 double x ; 
  
  
  
  
 double y ; 
  
  
  
 } cartesian ; 
  
  
  
 struct { 
  
  
  
  
 double r ; 
  
  
  
  
 double theta ; 
  
  
  
 } polar ; 
  
  
 } contents ; 
  
 } coordinate ;
  
 For an argument, say
  p
 , of the type
  coordinate
 , the type of the coordinate is 
 stored in
  p.tag
 . If the type of the coordinate is
  Polar
 , then the radius is 
 stored in 
 p.contents.polar.r
 , and the angle is stored in
  
 p.contents.polar.theta
 . If it is a
  Cartesian
  coordinate, the X and Y-
 coordinates are stored in 
 p.contents.cartesian.x
  and
  
 p.contents.cartesian.y
 .
  
 Revision: 6.37",NA
Answers to the exercises of Chapter 5,"Answer to 5.1: 
 An SML function to concatenate two arrays
  s
  and
  t
  is:
  
 (* concatenate : a array * a array -> a array *) 
 fun concatenate(s,t) 
  
  
 = let 
  
  
  
  
 val n_s = length(s) 
  
  
  
  
 val n_t = length(t) 
  
  
  
  
 fun f i = if i < n_s 
  
  
  
  
  
 then sub(s,i) 
  
  
  
  
  
 else sub(t,i-n_s) 
  
  
  
 in 
  
  
  
  
 tabulate(n_s+n_t,f) 
  
  
  
 end ;
  
 Answer to 5.2: 
 to index
  u
  is:
  
 An SML function to return the data of the array
  s
  from index
  l
  
 (* slice : a array * int * int -> a array *) 
 fun slice(s,l,u) = let 
  
  
  
 fun f i = sub(s,i+l) 
  
 in 
  
  
  
 tabulate(u-l+1,f) 
  
  
 end ;
  
 Answer to 5.4: 
  
 Here is a complete C program that simulates the card game. 
 Please note that the function
  player_A
  does not read
  secret
 , but
  only
  passes 
 it on to
  player_B
 .
  
 #include <stdlib.h>
  
 typedef enum { false=0, true=1 } bool ;
  
 #define n_number 4 
  
 #define n_card 3 
  
 typedef int deck[n_card][n_number] ;
  
 const deck card = {{1,3,5,7},{2,3,6,7},{4,5,6,7}} ;
  
 bool player_B( int c, int n ) { 
  
  
 int i ;
  
 Revision: 6.37",NA
Answers to the exercises of Chapter 6,"Answer to 6.1: 
 statement.
  
 The following C procedure prints a character list using a while-
  
 void print_list( char_list x_xs ) { 
  
 while( x_xs != NULL ) { 
  
  
  
 printf( ""%c"", head( x_xs ) ) ; 
  
  
 x_xs = tail( x_xs ) ; 
  
  
 } 
  
 }
  
 Answer to 6.2:
  
 typedef enum { Cons, Nil } char_list_tags ;
  
 typedef struct char_list { 
  
  
 char_list_tags tag ; 
  
  
 union { 
  
  
  
 struct { 
  
  
  
  
 char 
  
  
 list_head ; 
  
  
  
 struct char_list 
  
 * list_tail ; 
  
  
 } cons_cell ; 
  
  
 } char_list_union ; 
  
 } *char_list ;
  
 The alternative, corresponding to the tag
  Nil
 , does not hold any information. In 
 such a case, where there is only one alternative that holds information, the
  
 union 
 is not necessary, and the
  type
  can be simplified to:
  
 typedef enum { Cons, Nil } char_list_tags 
 typedef struct char_list {
  
 ;
  
 char_list_tags
  
 tag ;
  
 char
  
 list_head ;
  
 struct char_list
  
 * list_tail ;
  
 } *char_list ;
  
 Each list must now be terminated with an extra element with a
  tag
 -value
  Nil
 . 
 The inefficiency of managing these cells that terminate lists is the reason that C 
 uses a special pointer value
  NULL
  to terminate a list.
  
 Answer to 6.3: 
 A tail recursive version of
  length
  is:
  
 (* length : char_list -> int *) 
  
 fun length x_xs 
  
 = length 0 x_xs
  
 Revision: 6.34",NA
Answers to the exercises of Chapter 7,"Answer to 7.2: 
 Here is
  stream_to_list
  using pointers to pointers.
  
 char_list stream_to_list( FILE * stream ) { 
  
 char_list accu = NULL ; 
  
  
 char_list *last = &accu ; 
  
  
 int c ; 
  
  
 while( ( c = getc( stream ) ) != EOF ) { 
  
  
 char_list new = cons( c, NULL ) ; 
  
  
  
 *last = new ; 
  
  
  
 last = & new->list_tail ; 
  
  
 } 
  
  
 return accu ; 
  
 }
  
 Answer to 7.4: 
 stream:
  
 Here is a side effecting SML function to output a list to a
  
 (* list_to_stream : outstream -> char list -> unit *) 
 fun list_to_stream stream [] 
  
  
  
 = () 
  
  
 | list_to_stream stream (x::xs) 
  
  
  
 = (output(stream,x); list_to_stream stream xs) ;
  
 The C equivalent is:
  
 void list_to_stream( FILE * stream, char_list list ) { 
  
 while( list != NULL ) { 
  
  
  
 putc( head( list ), stream ) ; 
  
  
  
 list = tail( list ) ; 
  
  
 } 
  
 }
  
 Answer to 7.6: 
 A tail recursive version of
  word_count
  is:
  
 (* word_count : char list -> char list -> int *) 
  
 fun word_count ws ts 
  
  
 = let 
  
  
  
 fun count accu ws ts 
  
  
  
  
 = if ts = [] 
  
  
  
  
  
 then accu 
  
  
  
  
  
 else if match ws ts 
  
  
  
  
  
  
 then count (accu+1) ws (tail ts)
  
 Revision: 6.33",NA
Answers to the exercises of Chapter 8,"Answer to 8.1:
  
 graphics.o: graphics.c graphics.h matrix.h vector.h 
  
 cc -c graphics.c
  
 Answer to 8.2: 
  
 The combined make file is:
  
 vector.o: vector.c vector.h 
  
  
 cc -c vector.c 
  
 matrix.o: matrix.c matrix.h vector.h 
  
  
 cc -c matrix.c 
  
 graphics.o: graphics.c graphics.h matrix.h vector.h 
  
 cc -c graphics.c
  
 The dependency graph is:
  
 cc -c graphics.c 
  
 graphics.c
  
 graphics.o
  
 graphics.h
  
 cc -c vector.c 
  
 vector.c
  
 vector.o
  
 vector.h
  
 cc -c matrix.c 
  
 matrix.c
  
 matrix.o
  
 matrix.h
  
 Answer to 8.3: 
  
 Following the arrows shows that
  graphics.o
 ,
  matrix.o
 , 
 and 
 graphics
  need to be remade if
  matrix.h
  is changed.
  
 Revision: 6.38",NA
Answers to the exercises of Chapter 9,"Answer to 9.1: 
  
 The C preprocessor performs a textual substitution, so any oc-
 currence of the identifiers
  WIDTH
  and
  HEIGHT
  would be replaced. This results 
 in troubles for the functions
  window_to_complex
  and
  draw_Mandelbrot
 , as 
 WIDTH
  and
  HEIGHT
  appear in their argument lists. The header of the function 
 window_to_complex
  is:
  
 complex window_to_complex( int X, int Y, int WIDTH, 
  
 int HEIGHT, double x, double 
 y, double width, double height 
 )
  
 After substitution of
  WIDTH
  and
  HEIGHT
  it would read:
  
 complex window_to_complex( int X, int Y, int 100, 
  
 int 100, double x, double y, 
 double width, double height 
 )
  
 This is not legal C. The same substitution would take place in the argument list of 
 draw_Mandelbrot
 .
  
 Answer to 9.3: 
  
 The following two elements are needed:
  
 void 
  
 (*draw_circle)( void *g, int x0, int y0, int r ) ; 
  
 void 
  
 (*draw_ellipse)( void *g, int x0, int y0, int r, int dx ) 
 ;
  
 Answer to 9.4: 
  
 The SML data structure uses a type variable
  a
 . This type is re-
 turned by the
  Open
  function and used by subsequent functions. The C data 
 struc-ture uses
  void *
  as replacement for polymorphic typing. The C compiler 
 cannot check whether the appropriate data structure is passed from the open-
 function to the draw-functions (see Section 4.5).
  
 Answer to 9.6: 
  
 The PostScript driver for the device independent graphics is:
  
 #include ""PSdriver.h"" 
  
 #include <stdio.h> 
  
 #include <stdlib.h>
  
 typedef struct { 
  
  
 FILE *file ; 
  
 } PSInfo ;
  
 void *PS_open( void *what ) { 
  
 PSInfo *i = malloc( sizeof( PSInfo ) ) 
 ; char *filename = what ; 
  
 i->file = fopen( filename, ""w"" ) ;",NA
Appendix B,NA,NA
A brief review of SML,"In this appendix we will present a brief overview of the salient features of SML 
 for the reader who is familiar with another functional programming language. 
 We cover just enough material to make the reader feel comfortable when reading 
 our book. We should point out that SML has more to offer than we use in this 
 book; the interested reader might wish to consult one of the many textbooks 
 available on programming in SML [15, 9, 16].",NA
B.1 ,NA,NA
About the four main functional languages,"The most important functional languages to date are Lisp, SML, Miranda, and 
 Haskell. There are many small differences between these four languages and 
 only a few major differences.
  
 The main difference between Lisp and the other three is that Lisp is dynami-
 cally typed, whereas the other three languages are statically typed. In a statically 
 typed language the compiler will reject expressions that are incorrectly typed; in 
 a dynamically typed languages such errors are detected at run time.
  
 The compilers for SML, Miranda, and Haskell will automatically infer the 
 types of all functions. In addition, Miranda and Haskell allow the programmer to 
 explicitly declare the type of a function. The compiler will check that the explicit 
 type declaration is consistent with type information as has been inferred. Explicit 
 type declarations are a useful form of documentation, which help the reader to 
 un-derstand the purpose of a function. The fact that this form of documentation 
 can be checked for consistency makes it also a reliable form of documentation. 
 SML unfortunately does not permit the explicit declaration of function types. 
 Therefore we have resorted to giving the type of each function in this book as a 
 comment. (Comments in SML are enclosed in the symbols
  (*
  and
  *)
 ).
  
  
 The main difference between SML and Miranda on the one hand and Haskell 
 on the other hand is that the type system of Haskell provides proper support for 
 overloaded functions by means of the type class system. A function (or more ap-
 propriately an operator) such as 
  
 is overloaded if it can be applied to arguments 
 (or operands) of different types. For example, in the expression
  
  , the operands 
 are integers and, in the expression
   
  , the operands are reals.
  
 391",NA
B.2 ,NA,NA
"Functions, pattern matching, and integers","All functional languages offer the possibility to define a function by giving its 
 name, a list of arguments and the function body. We give as an example the 
 defini-tion of a function to calculate a binomial coefficient. The function has two 
 integer arguments and computes an integer result. We use the following 
 equation to com-pute the binomial coefficient, assuming that
  
  :
  
 if
  
 otherwise
  
 Here is the SML function
  over
  which uses this equation. The type of the 
 function is given as a comment. It states that
  over
  has two integer arguments 
 and that its function result is also an integer.
  
 (* over : int -> int -> int *) 
  
 fun over n 0 = 1 
  
  
 | over n m = if n = m 
  
  
  
 then 1 
  
  
  
 else over (n-1) m + over (n-1) (m-1) ;
  
 A function definition in SML is introduced by the keyword
  fun
  and terminated 
 by a semicolon
  ;
 . Layout is not significant in SML; in particular, there is no off 
 side rule as in Miranda and Haskell. The function name is
  over
 . The function 
 name is then followed by the names of the formal arguments. The function
  
 over
  has two alternative definitions, separated by the vertical bar
  |
 . The first 
 clause applies when the second argument has the value
  0
 . The second clause 
 applies when the
  
 Revision: 6.18",NA
B.3 ,NA,NA
Local function and value definitions,"SML permits the definition of local functions and values within an expression. 
 Lo-cal definitions are often useful to avoid the recomputation of a value that is 
 used several times. In the function
  over
  defined earlier, the expression
  n-1
  
 appears twice. This value can be computed just once by giving it a name in a 
 local
  let 
 definition:
  
 (* over : int -> int -> int *) 
  
 fun over n 0 = 1 
  
  
 | over n m = if n = m 
  
  
  
 then 1 
  
  
  
 else let 
  
  
  
  
  
 val k = n-1 
  
  
  
  
 in 
  
  
  
  
  
 over k m + over k (m-1) 
  
  
  
 end ;
  
 The construct
  let
  ...
  in
  ...
  end
  represents a single expression with one or more 
 local definitions. After the keyword
  let
 , any number of function and value def-
 initions may appear, each introduced by the relevant keyword
  fun
  or
  val
 . The 
 let
  expressions of SML are more general than the
  where
  clauses of Miranda, 
 be-cause
  let
  expressions may be arbitrarily nested. Miranda’s
  where
  clauses 
 apply to function definitions and can only be nested if the function definitions 
 are nested. Haskell provides both facilities.",NA
B.4 ,NA,NA
"Reals, booleans, strings, and lists","The basic data types of SML are integers, reals, booleans, strings, and lists. In the 
 previous section we have only used integers; here we will define a function that 
 works on other data types to see how they could be used. The function
  locate 
 below is a polymorphic function of two arguments. The second argument is a list 
 of values of some polymorphic type
  a
 , in which the function
  locate
  will be 
 searching for an occurrence of the first argument. In SML type variables are 
 written as
  a
 ,
  b
 , and so on. In Haskell we would write
  a
 ,
  b
  and in Miranda one 
 would use
  *
 ,
  **
 , and so on.
  
 The first argument of
  locate
  is of the same type
  a
  as the elements of the 
 list. If the element is found in the list, the boolean value
  true
  is returned,
  
 false
  oth-erwise. The term ‘polymorphic’ stems from the fact that a 
 polymorphic function has really many forms; it adapts itself to the form of its 
 actual argument.
  
 (* locate : a -> a list -> bool *) 
  
 fun locate a [] 
  
 = false 
  
  
 | locate a (x::xs) = (a = x) orelse locate a xs ;
  
 The function
  locate
  uses pattern matching on the second argument. If this 
 repre-sents the empty list
  []
 , the function result is
  false
 . Otherwise, the list is 
 deemed to be non empty, with a head element
  x
  and tail
  xs
 . The double colon
  
 ::
  is the",NA
B.5 ,NA,NA
Type synonyms and algebraic data types,"User defined data types are introduced either by type synonyms or by algebraic 
 data type declarations. A type synonym gives a name to an existing type. For 
 example, a pair of two integers has type
  int * int
 . Instead of spelling this out 
 each time we use this type, we can give it a name, say
  int_pair
 , and use the 
 name instead of
  int * int
 . This is how we would define the type synonym in 
 SML:
  
 type int_pair = int * int ;
  
 The keyword
  type
  indicates that a type synonym is going to be defined. This is 
 the same as in Haskell. In Miranda the symbol
  ==
  introduces a type synonym.
  
 Revision: 6.18",NA
B.6 ,NA,NA
Higher order functions,"The
  walk_add
  function from the previous section is a combination of two 
 things: it embodies a tree traversal algorithm and it encodes a particular 
 operation (addi-tion) over the tree. These two issues can be separated to make 
 the code usable in a wider context. This separation requires the introduction of a 
 polymorphic data type
  tree
  and a pure tree walk function
  poly_walk
 . Here 
 is the polymorphic 
 tree
  data type:
  
 datatype a tree = Branch of a tree * a tree 
  
 | Leaf of a ;
  
 The
  tree
  data type has a type parameter, indicated by the type variable
  a
 , for 
 which any type may be substituted. Our sample tree can be encoded using the 
 tree
  data type as follows:
  
 (* sample_poly_tree : int tree *) 
  
 val sample_poly_tree 
  
  
 = Branch(Leaf 1, 
  
  
  
 Branch(Leaf 2,Leaf 3)) ;
  
 The type of
  sample_poly_tree
  is
  int tree
 , which indicates that we have 
 in-stantiated the polymorphic
  tree
  data type to a concrete tree with data of 
 type
  int 
 at the leaves.
  
 Not only the data type
  tree
  but also the
  poly_walk
  function carries a 
 param-eter. This parameter (called
  comb
  below) represents the binary function 
 applied when results of the left and right branch are combined.
  
 (* poly_walk : (a->a->a) -> a tree -> a *) 
  
 fun poly_walk comb (Branch(left,right)) 
  
  
  
 = comb (poly_walk comb left) (poly_walk comb right) 
  
 | poly_walk comb (Leaf data) 
  
  
  
 = data ;
  
 The type of
  poly_walk
  indicates that the
  comb
  function has type
  a->a->a
 . It 
 should produce a result of the same type as that of its two arguments. A value of 
 that same type should be stored in the tree, and a value of this type will also be 
 produced as the final result of
  poly_walk
 .
  
 The value
  poly_add_int_main
  below applies the general
  poly_walk
  
 func-tion to the concrete binary tree
  sample_poly_tree
 , which has integers at 
 its leaf nodes. Here
  add
  is the curried version of the addition operator:
  
 (* poly_add_int_main : int *) 
  
 val poly_add_int_main
  
 Revision: 6.18",NA
B.7 ,NA,NA
Modules,"A module system serves to gather related type, data type, function, and value 
 dec-larations together so that the collection of these items can be stored, used, 
 and
  
 Revision: 6.18",NA
B.8 ,NA,NA
Libraries,"The SML language provides a set of predefined operators and functions. 
  
 Fur-
 thermore, different implementations of SML may each offer an extensive set of li-
 braries. We have made as little use as possible of the wealth of library functions 
 that are available to the SML programmer. Firstly, having to know about a min-
 imal core of SML and its libraries makes it easier to concentrate on learning C. 
 Secondly, by using only a few library functions the book is only loosely tied to a 
 particular implementation of SML.
  
 We use a small number of predefined operators and functions and only four 
 functions from the SML/NJ array library. In addition, we have defined a number 
 of functions of our own which are similar to the SML library functions of most 
 implementations.
  
  
 Here are the predefined operators and their types as they are being used 
 throughout the book:
  
 operator type
  
 +
 ,
  -
 ,
  *
 ,
  div
 ,
  
 mod +
 ,
  -
 ,
  *
 ,
  / 
  
 <
 ,
  <=
 ,
  <>
 ,
  =
 ,
  
 >=
 ,
  > <
 ,
  <=
 ,
  <>
 ,
  
 =
 ,
  >=
 ,
  >ˆ
  
 size 
  
 ord 
  
 chr 
  
 :: 
  
 @
  
 int * int -> int 
  
 real * real -> real 
  
 int * int -> bool 
  
 real * real -> bool 
  
 string * string -> string 
  
 string -> int 
  
 string -> int 
  
 int -> string 
  
 a * a list -> a list 
  
 a list * a list -> a list
  
 The list processing functions below are similar to those found in Haskell and Mi-
 randa. The SML versions that we use are not from a standard library. Instead, 
 they
  
 Revision: 6.18",NA
Appendix C,NA,NA
Standard Libraries,"C offers a rich variety of library functions. Some of these functions are used so 
 often that a short reference is indispensable to the reader of this book. This 
 chapter provides such a reference. For the complete set of standard libraries one 
 has to consult the C reference manual [7].
  
 Besides the standard libraries many
  system calls
  are usually directly available 
 to the C programmer. As an example, functions for accessing files under UNIX, 
 Win-dows, or Macintosh and usually also functions to manage processes or 
 network connections are readily available.
  
 In addition to these, there are many other libraries available. We have seen a 
 small part of the X-window library in Chapter 9. Other libraries that exist are for 
 example cryptographic libraries [11], and numerical libraries [10]. For all these, 
 we refer the reader to the appropriate documentation.
  
 The standard library consists of a collection of modules. Each of these 
 modules requires a different interface file to be loaded. Most computer systems 
 will not require you to specify that you wish to link any of the libraries, with the 
 excep-tion of the mathematics library under UNIX. Below, five modules are 
 explained in detail: I/O, strings, character types, mathematics, and utilities. The 
 final section summarises the purpose of the modules that we have not described.",NA
C.1 ,NA,NA
Standard I/O,"The standard I/O library provides functions that allow the programmer to per-
 form input and output operations. Input and output can be performed on files, 
 which have a type
  FILE *
 . There are three standard file descriptors:
  stdin
 , 
 which is the standard input of the programming, normally from the keyboard; 
 stdout
 , the standard output of the program, normally directed to the screen; 
 and 
 stderr
 , the file to write error messages, normally directed to the screen.
  
 To use any of the I/O facilities, the file
  stdio.h
  has to be included:
  
 #include <stdio.h>
  
 The most important data and functions of this library are listed below. A 
 complete reference is given in the C reference manual [7]:
  
 403",NA
C.2 ,NA,NA
Strings,"A string is represented as an array of characters (see also Section 5.5). To 
 manipu-late these arrays of characters, a string library is provided. To use this 
 library, the file
  string.h
  must be included:
  
 #include <string.h>
  
 The most important functions of this library are:
  
 int strlen( char *string )
  Returns the length of a string.
  
 char *strncpy( char *out, char *in, int n )
  Copies a string. 
  
 The 
 third argument limits the number of characters that will be copied. The first 
 argument is the destination array, the second the source array.
  
 char *strcpy( char *out, char *in )
  Is like
  strncpy
 , but has no 
 safe-guard against copying too many characters.
  
 char *strdup( char *string )
  Allocates heap space using
  malloc
  to 
 hold a copy of the string and copies the string into it. If no space is 
 available, a NULL pointer is returned. When the string is no longer needed 
 it should be destroyed using
  free
 .
  
 char *strncat( char *out, char *in, int n )
  Appends a string to 
 an existing string. The third argument limits the number of characters that 
 will be appended. The first argument should contain the prefix of the string 
 and will contain the concatenated string when the function returns.
  
 char *strcat( char *out, char *in )
  Is like
  strncat
 , but has no 
 safe-guard against copying too many characters.
  
 int strcmp( char *s, char *t )
  Performs a relational operation on two 
 strings. The functions returns a negative number (if
  s < t
 ), zero (if 
 s == t
 ), or 
 a positive number (if
  s > t
 ).
  
 int strncmp( char *s, char *t, int n )
  Is like
  strcmp
  but it com-
 pares at most
  n
  characters. If the strings are equal up to the
  n
 -th character,
  
 0 
 is returned.
  
 Revision: 6.8",NA
C.3 ,NA,NA
Character classes,"The representation of characters may differ from one machine to another. To 
 write portable programs, the character class library provides predicates that 
 yield true if a character belongs to a certain class. The predicates can be used 
 after including the file
  ctype.h
 .
  
 #include <ctype.h>
  
 The functions available in this library are:
  
 bool isdigit(char c)
  Tests if
  c
  is a digit.
  
 bool isalpha(char c)
  Tests if
  c
  is a letter.
  
 bool isupper(char c)
  Tests if
  c
  is an uppercase letter.
  
 bool islower(char c)
  Tests if
  c
  is a lowercase letter.
  
 bool isalnum(char c)
  Tests if
  c
  is a letter or a digit.
  
 bool isxdigit(char c)
  Tests if
  c
  is a hexadecimal digit.
  
 bool isspace(char c)
  Tests if
  c
  is a white space.
  
 bool isprint(char c)
  Tests if
  c
  is a printable character.
  
 bool isgraph(char c)
  Tests if
  c
  is a printable character but not a space. 
 bool ispunct(char c)
  Tests if
  c
  is a printable character but not a space, 
 letter or digit.
  
 bool iscntrl(char c)
  Tests if
  c
  is a control character.
  
 char toupper(char c)
  Converts
  c
  to an uppercase letter.
  
 char tolower(char c)
  Converts
  c
  to a lowercase letter.
  
 Revision: 6.8",NA
C.4 ,NA,NA
Mathematics,"The mathematics library provides a number of general mathematical functions. 
 More specialised functions and numerical algorithms are provided by other li-
 braries. It is essential to import the file
  math.h
 ; the compiler might not warn 
 you if it is not included, but the functions will return random results.
  
 #include <math.h>
  
 The functions available in this library are:
  
 double sin( double rad )
  Calculates the sine of an angle. 
  
 The angle 
 should be in radians.
  
 double cos( double rad )
  Calculates the cosine of an angle 
 double tan( double rad )
  Calculates the tangent of an angle.
  
 double asin( double x )
  Calculates the arc sine of
  x
 .
  
 double acos( double x )
  Calculates the arc cosine of
  x
 .
  
 double atan( double x )
  Calculates the arc tangent of
  x
 .
  
 double atan2( double x, double y )
  Calculates the arc tangent of
  y/x
 .
  
 (A proper result is returned when
  x
  is 0.) 
  
 double sinh( double rad )
  Calculates the hyperbolic sine of
  x
 .
  
 double cosh( double rad )
  Calculates the hyperbolic cosine of
  x
 .
  
 double tanh( double rad )
  Calculates the hyperbolic tangent of
  x
 .
  
 double exp( double x )
  Calculates the exponential function of a number,
  
  
 .
  
  
  (natural) logarithm of
  x
 . 
 double log( double x )
  Calculates the base 
  
 double log10( double x )
  Calculates the base 10 logarithm of
  x
 .
  
 double pow( double x, double p )
  Calculates
  x
  to the power
  p
 ,
  
  . 
 double sqrt( double x )
  Calculates the square root of
  x
 ,
  
  .
  
  
  
  
  . 
 double ceil( double x )
  Calculate
  
  , the smallest integer not less than 
 The function returns a
  double
 , not an
  int
 . It does not perform a coercion, but 
 it only rounds a floating point number.
  
 double floor( double x )
  Calculate
  
  , the largest integer not greater 
 than .
  
  
  
  
  . 
 double 
 fabs( double x )
  Returns the absolute value of
  x
 , 
  
 double ldexp( double x, int n )
  Returns 
  
 as a floating point num-
 ber.
  
 double frexp( double x, int * n )
  Splits
  x
  into a fraction 
  
 and a
  
  
  and
  
  . The fraction is the re-power of 2, , such that 
  
 turn value of
  frexp
  and the power is assigned to
  *n
 .
  
 double modf( double x, double *i )
  Takes a double, and splits it into 
 its integer and fractional part. The integer part is returned via
  i
 , the 
 fractional part is the return value of the function.
  
 double fmod( double x, double y )
  Calculates
  x
  modulo
  y
 .",NA
Variable argument lists,Appendix C. Standard Libraries,NA
C.5,"The include file
  stdarg.h
  provides the facilities needed to work with variable 
 argument lists. This is how to include it into a module:
  
 #include <stdarg.h>
  
 Examples of functions that are implemented using this facility are
  printf
  and 
 scanf
 . A function using the variable argument list facility must have at least one 
 proper argument. The last proper argument must be followed by ellipses in the 
 prototype. Here is an example:
  
 void printf( char *format, ... ) ;
  
 The variable argument list module provides the following type and macro defini-
 tions:
  
 va_list
  This is the type of the data structure that provides access to the 
 variable arguments. A variable of type
  va_list
  must be declared in each 
 function using variable argument lists.
  
 va_start( va_list ap, 
  
 )
  The
  va_start
  macro must be called once be-
 fore processing of the variable argument list begins. The variable should be the 
 last proper argument before the ellipses (
 ...
 ) in the function prototype. In the 
 case of
  printf
  above the would be
  format
 .
  
 va_arg( va_list ap, 
  
 )
  The
  va_arg
  macro will deliver the next item 
 from the argument list. This value has type . Each call to
  va_arg
  advances to 
 the next argument, until the argument list is exhausted.
  
 va_end( va_list ap )
  The
  va_end
  macro terminates processing of the 
 argu-ment list. It should be called once before a function using the variable 
 argu-ment facility terminates.",NA
C.6 ,NA,NA
Miscellaneous,"The utility library is a collection of miscellaneous routines that did not fit any-
 where else. The utility library can be used by including
  stdlib.h
 :
  
 #include <stdlib.h>
  
 This module contains a large number of functions. We discuss only the most im-
 portant functions below:
  
 int abs( int x )
  Returns the absolute value of an integer.
  
 int atoi( char *string )
  Converts a string to an integer (the name stands 
 for
  a
 scii
  to i
 nteger):
  atoi( ""123"" )
  is 123.
  
 double atof( char *string )
  Converts a string to a floating point 
 number. 
 void *calloc( int x, int y )
  Allocates heap space: sufficient 
 space is allocated to hold
  x
  cells of size
  y
 . All space is initialised to 0. 
  
 This 
 function returns
  NULL
  if it cannot allocate sufficient space. 
  
 You can use 
 sizeof
  to find out how many bytes a certain type needs. 
  
  
 The call 
 calloc( 4, sizeof( int ) )
  will return a pointer to an area 
 of store large enough to store 4 integers.
  
 Revision: 6.8",NA
C.7 ,NA,NA
Other modules,"There are 6 more modules in the C standard library. Each of these modules has 
 an associated include file and a number of library functions. Below we give a 
 brief description of each of these modules.
  
 Diagnostics,
  include file
  assert.h
 . 
  
 This module allows the programmer to 
 verify that certain conditions are met (consistency check), the program is aborted 
 if the condition fails.
  
 Non local jumps,
  include file
  setjmp.h
 . A non local jump ‘returns’ from a 
 num-ber of nested function calls all at once and continues at a 
 predetermined place somewhere else in the program.
  
 Signals,
  include file
  signal.h
 . Signals are similar to SML exceptions. Signals 
 can be caught and sent. The system may send signals to indicate that some-
 thing went wrong, for example a reference through a dangling pointer.
  
 Date and Time,
  include file
  time.h
 . These are functions to find out what time 
 it is, and to convert time and date information into strings.
  
 Integer limits,
  include file
  limits.h
 . This module defines constants that 
 denote the maximum values that variables of type
  int
 ,
  char
 , and so on, can 
 take. 
 Floating point limits,
  include file
  float.h
 . This module defines constants 
 that denote the maximum floating point number that can be represented, the 
 number of bits in the mantissa and exponent, and so on.
  
 Revision: 6.8",NA
Appendix D,NA,NA
ISO-C syntax diagrams,"This chapter summarises the complete syntax of ISO-C using
  railroad diagrams
 . A 
 railroad diagram has a name, a beginning at the top left hand side and an end at 
 the top right hand side. A diagram is read starting from the beginning and 
 follow-ing the lines and arcs to the end. Similar to what real trains on real rail 
 roads can do, you must always follow smooth corners and never take a sharp 
 turn.
  
 On your way through a rail road diagram, you will encounter various sym-
 bols. There are two kinds of symbols. A symbol in a circle or an oval stands for 
 itself. This is called a
  terminal symbol
 . Such a symbol represents text that may be 
 typed as part of a syntactically correct C program. A symbol in a rectangular box 
 is the name of another rail road diagram. This is a
  non-terminal symbol
 . To find 
 out what such a symbol stands for you must lookup the corresponding diagram. 
 Rail-road diagrams can be recursive, when a non terminal is referring to the 
 present diagram.
  
 The rail road diagrams can be used for two purposes. The first is to check that 
 a given C program uses the correct syntax. This should be done by starting at the 
 first diagram (
 translation˙unit
 ), and trying to find a path through the diagrams 
 such that all symbols in the program are matched to symbols found on the way.
  
 Railroad diagrams are also useful as a reminder of what the syntax exactly 
 looks like. A path through the diagrams corresponds to an ordering on the sym-
 bols that you may use. For example if you what to know what a
  for
 -statement 
 looks like, you should look up the diagram called statement, find the keyword 
 for
 , and follow a path to the end of the diagram to see what you may write to 
 create a
  for
 -statement. Note that the railroad diagrams only describe the
  syntax 
 of the language. A syntactically correct program is not necessarily accepted by 
 the compiler as it may contain
  semantic
  errors (for example an illegal combination 
 of types).
  
 The diagrams that represent the ISO-C syntax are ordered in a top down fash-
 ion. We explain a few diagrams in some detail to help you find out for yourself 
 how to work with them. Let us study what a program or
  translation˙unit
  may 
 look like.
  
 ???
  
 411",NA
