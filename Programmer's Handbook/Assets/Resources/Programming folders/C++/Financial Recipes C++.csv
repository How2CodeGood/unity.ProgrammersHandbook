Larger Text,Smaller Text,Symbol
Financial Numerical Recipes in C,++,NA
.,"Bernt Arne Ødegaard
  
 June 2014",NA
Contents,"5
  
 5.1
  
 The interchangeability of discount factors, spot
  
 interest rates and forward interest rates
  
 . . . . .
  
 52
  
 5.2
  
 The term structure as an object . . . . . . . . . .
  
 55
  
 5.2.1
  
 Base class . . . . . . . . . . . . . . . . . .
  
 55
  
 5.2.2
  
 Flat term structure.
  
 . . . . . . . . . . . .
  
 57
  
 5.3
  
 Using the currently observed term structure. . . .
  
 58
  
 5.3.1
  
 Linear Interpolation. . . . . . . . . . . . .
  
 59
  
 5.3.2
  
 Interpolated term structure class. . . . . .
  
 61
  
 5.4
  
 Bond calculations with a general term structure
  
 and continous compounding . . . . . . . . . . . .
  
 64
  
 1
  
 On C++ and programming.
  
 6
  
 The Mean Variance Frontier
  
 67
  
 6.1
  
 Setup
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  
 67
  
 6.2
  
 The minimum variance frontier
  
 . . . . . . . . . .
  
 69
  
 6.3
  
 Calculation of frontier portfolios
  
 . . . . . . . . .
  
 69
  
 1.1
  
 Compiling and linking
  
 . . . . . . . . . . . . . . .
  
 5
  
 6.4
  
 The global minimum variance portfolio . . . . . .
  
 72
  
 1.2
  
 The structure of a C++ program . . . . . . . . .
  
 6
  
 6.5
  
 Efficient portfolios
  
 . . . . . . . . . . . . . . . . .
  
 72
  
 1.2.1
  
 Types
  
 . . . . . . . . . . . . . . . . . . . .
  
 6
  
 6.6
  
 The zero beta portfolio . . . . . . . . . . . . . . .
  
 73
  
 1.2.2
  
 Operations
  
 . . . . . . . . . . . . . . . . .
  
 6
  
 6.7
  
 Allowing for a riskless asset. . . . . . . . . . . . .
  
 73
  
 1.2.3
  
 Functions and libraries . . . . . . . . . . .
  
 7
  
 6.8
  
 Efficient sets with risk free assets. . . . . . . . . .
  
 74
  
 1.2.4
  
 Templates and libraries
  
 . . . . . . . . . .
  
 7
  
 6.9
  
 Short-sale constraints . . . . . . . . . . . . . . . .
  
 75
  
 1.2.5
  
 Flow control . . . . . . . . . . . . . . . . .
  
 8
  
 6.10 The Sharpe Ratio . . . . . . . . . . . . . . . . . .
  
 75
  
 1.2.6
  
 Input Output . . . . . . . . . . . . . . . .
  
 8
  
 6.11 Equilibrium: CAPM
  
 . . . . . . . . . . . . . . . .
  
 76
  
 1.2.7
  
 Splitting up a program . . . . . . . . . . .
  
 8
  
 6.11.1 Treynor
  
 . . . . . . . . . . . . . . . . . . .
  
 76
  
 1.2.8
  
 Namespaces . . . . . . . . . . . . . . . . .
  
 9
  
 6.11.2 Jensen
  
 . . . . . . . . . . . . . . . . . . .
  
 76
  
 1.3
  
 Extending the language, the class concept.
  
 . . .
  
 9
  
 6.12 Working with Mean Variance and CAPM . . . . .
  
 76
  
 1.3.1
  
 date, an example class . . . . . . . . . . .
  
 10
  
 6.13 Mean variance analysis using matrix libraries
  
 . .
  
 77
  
 1.4
  
 Const references . . . . . . . . . . . . . . . . . . .
  
 16
  
 7
  
 Futures algoritms.
  
 81
  
 1.5
  
 Other C
 ++
 concepts . . . . . . . . . . . . . . . . .
  
 16
  
 2
  
 Matrix Tools
  
 17
  
 7.1
  
 Pricing of futures contract.
  
 . . . . . . . . . . . .
  
 81
  
 2.1
  
 The first screen . . . . . . . . . . . . . . . . . . .
  
 18
  
 8
  
 Binomial option pricing
  
 82
  
 2.2
  
 Linear algebra . . . . . . . . . . . . . . . . . . . .
  
 18
  
 8.1
  
 Options
  
 . . . . . . . . . . . . . . . . . . . . . . .
  
 82
  
 2.2.1
  
 Basic matrix operations
  
 . . . . . . . . . .
  
 18
  
 8.2
  
 Pricing . . . . . . . . . . . . . . . . . . . . . . . .
  
 82
  
 8.3
  
 Multiperiod binomial pricing
  
 . . . . . . . . . . .
  
 85
  
 2.2.2
  
 Arithmetic Matrix Operations.
  
 . . . . . .
  
 19
  
 9
  
 Basic Option Pricing, the Black Scholes formula
  
 89
  
 2.3
  
 Solving linear equations
  
 . . . . . . . . . . . . . .
  
 22
  
 2.4
  
 Element by element operations
  
 . . . . . . . . . .
  
 24
  
 9.1
  
 The formula . . . . . . . . . . . . . . . . . . . . .
  
 90
  
 2.5
  
 Function definitions
  
 . . . . . . . . . . . . . . . .
  
 24
  
 9.2
  
 Understanding the why’s of the formula
  
 . . . . .
  
 92
  
 2.6
  
 m files . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 9.2.1
  
 The original Black Scholes analysis . . . .
  
 93
  
 2.7
  
 Flow control . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 9.2.2
  
 The limit of a binomial case . . . . . . . .
  
 93
  
 2.8
  
 Plotting . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 9.2.3
  
 The representative agent framework
  
 . . .
  
 93
  
 2.9
  
 Libraries . . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 9.3
  
 Partial derivatives. . . . . . . . . . . . . . . . . .
  
 93
  
 2.10 References . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 9.3.1
  
 Delta . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 3
  
 The value of time
  
 26
  
 9.3.2
  
 Other Derivatives . . . . . . . . . . . . . .
  
 94
  
 9.3.3
  
 Implied Volatility.
  
 . . . . . . . . . . . . .
  
 96
  
 3.1
  
 Present value
  
 . . . . . . . . . . . . . . . . . . . .
  
 26
  
 3.2
  
 One interest rate with annual compounding . . .
  
 27
  
 9.4
  
 References . . . . . . . . . . . . . . . . . . . . . .
  
 98
  
 3.2.1
  
 Internal rate of return. . . . . . . . . . . .
  
 30
  
 10 Warrants
  
 99
  
 3.3
  
 Continously compounded interest . . . . . . . . .
  
 34
  
 10.1 Warrant value in terms of assets . . . . . . . . . .
  
 99
  
 3.3.1
  
 Present value . . . . . . . . . . . . . . . .
  
 35
  
 10.2 Valuing warrants when observing the stock value
  
 100
  
 3.4
  
 Further readings
  
 . . . . . . . . . . . . . . . . . .
  
 35
  
 10.3 Readings . . . . . . . . . . . . . . . . . . . . . . . 101
  
 4
  
 Bond Pricing with a flat term structure
  
 36
  
 11 Extending the Black Scholes formula
  
 102
  
 4.1
  
 Flat term structure with discrete, annual com-
  
 37
  
 11.1 Adjusting for payouts of the underlying. . . . . . 102
  
 pounding
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 4.1.1
  
 Bond Price
  
 . . . . . . . . . . . . . . . . .
  
 37
  
 11.1.1 Continous Payouts from underlying.
  
 . . . 102
  
 4.1.2
  
 Yield to maturity . . . . . . . . . . . . . .
  
 38
  
 11.1.2 Dividends. . . . . . . . . . . . . . . . . . . 103
  
 4.1.3
  
 Duration . . . . . . . . . . . . . . . . . . .
  
 41
  
 11.2 American options . . . . . . . . . . . . . . . . . . 104
  
 4.1.4
  
 Measuring bond sensitivity to interest
  
 43
  
 11.2.1 Exact american call formula when stock is
  
 paying one dividend. . . . . . . . . . . . . 105
  
 rate changes . . . . . . . . . . . . . . . . .
  
 4.2
  
 Continously compounded interest . . . . . . . . .
  
 47
  
 11.3 Options on futures
  
 . . . . . . . . . . . . . . . . . 108
  
 4.3
  
 Further readings
  
 . . . . . . . . . . . . . . . . . .
  
 50
  
 11.3.1 Black’s model . . . . . . . . . . . . . . . . 108
  
 11.4 Foreign Currency Options . . . . . . . . . . . . . 109
  
 5
  
 The term structure of interest rates and an object lesson
  
 51
  
 11.5 Perpetual puts and calls . . . . . . . . . . . . . . 110
  
 1",NA
Chapter 1,NA,NA
On C++ and programming.,"Contents
  
 1.1
  
 Compiling and linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5
  
 1.2
  
 The structure of a C++ program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.3
  
 1.2.1
  
 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.2.2
  
 Operations
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.2.3
  
 Functions and libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.2.4
  
 Templates and libraries
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 1.2.5
  
 Flow control
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 1.2.6
  
 Input Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 1.2.7
  
 Splitting up a program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 1.2.8
  
 Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 Extending the language, the class concept. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 1.4
  
 1.3.1
  
 date, an example class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 Const references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 1.5
  
 Other C
 ++
 concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 In this chapter I introduce C
 ++
 and discuss how to run programs written in C
 ++
 . This is by no means a 
 complete reference to programming in C
 ++
 , it is designed to give enough information to understand the 
 rest of the book. This chapter also only discusses a subset of C
 ++
 , it concentrates on the parts of the 
 language used in the remainder of this book. For really learning C
 ++
 a textbook is necessary. I have found 
 Lippman and Lajoie (1998) an excellent introduction to the language.
 1
 The authorative source on the 
 language is Stroustrup (1997b).",NA
1.1 ,NA,NA
Compiling and linking,"To program in C
 ++
 one has to first write a separate file with the program, which is then
  compiled 
 into low-
 level instructions (machine language) and
  linked
  with libraries to make a complete executable program. 
 The mechanics of doing the compiling and linking varies from system to system, and we leave these 
 details as an exercise to the reader.
  
 1
 I learned C
 ++
  from the previous edition of the book, Lippman (1992). From what I can tell the present editions still seems like a good 
 way of learning the language, but C
 ++
 has changed a lot in recent years.
  
 5",NA
1.2 ,NA,NA
The structure of a C++ program,"The first thing to realize about C
 ++
 is that it is a strongly typed language. Everything must be declared 
 before it is used, both variables and functions. C
 ++
 has a few basic building blocks, which can be grouped 
 into types, operations and functions.
  
 1.2.1 
  
 Types
  
 The types we will work with in this book are bool, int, long, double and string.
  
 Here are some example definitions
  
 bool this_is_true=true; 
  
 int i = 0; 
  
 long j = 123456789; 
  
 double pi = 3.141592653589793238462643; 
  
 string s(""this is a string"");
  
 The most important part of C
 ++
 comes from the fact that these basic types can be expanded by use of 
 classes
 , of which more later.
  
 1.2.2 
  
 Operations
  
 To these basic types the common mathematical operations can be applied, such as addition, subtraction, 
 multiplication and division:
  
 int i = 100 + 50; 
  
 int j = 100 - 50; 
  
 int n = 100 * 2; 
  
 int m = 100 / 2;
  
 These operations are defined for all the common datatypes, with exception of the string type. Such 
 operations can be defined by the programmer for other datatypes as well.
  
 Increment and decrement In addition to these basic operations there are some additional operations with 
 their own shorthand. An example we will be using often is incrementing and decrementing a variable.
  
 When we want to increase the value of one item by one, in most languages this is written:
  
 int 
 i=0; 
  
 i = i+1; 
  
 i = i-1;
  
 In C++ this operation has its own shorthand
  
 int i=0; 
  
 i++; 
  
 i--;
  
 While this does not seem intuitive, and it is excusable to think that this operation is not really necessary, 
 it does come in handy for more abstract data constructs. For example, as we will see later, if one defines a 
 date class with the necessary operations, to get the next date will simply be a matter of
  
 date d(1,1,1995); 
  
 d++;
  
 These two statements will result in the date in d being 2jan95.
  
 6",NA
1.3 ,NA,NA
"Extending the language, the class concept.","One of the major advances of C
 ++
 relative to other programming languages is the programmers ability to 
 extend the language by creating new data types and defining standard operations on these data types. 
 This ability is why C
 ++
 is called an object oriented programming language, since much of the work in 
 programming is done by creating
  objects
 . An object is best though of as a data structure with operations 
 on it defined. How one uses an object is best shown by an example.
  
 9",NA
1.4 ,NA,NA
Const references,"Let us now discuss a concept of more technical nature. Consider two alternative calls to a function, 
 defined by function calls:
  
 some_function(double r); 
  
 some_function(const double& r);
  
 They both are called by an argument which is a double, and that argument is guaranteed to not be 
 changed in the calling function, but they work differently. 
  
 In the first case a copy of the variable 
 referenced to in the argument is created for use in the function, but in the second case one uses the same 
 variable, the argument is a
  reference
  to the location of the variable. The latter is more efficient, in 
 particular when the argument is a large class. However, one worries that the variable referred to is 
 changed in the function, which in most cases one do not want. Therefore the const qualifier, it says that 
 the function can not modify its argument. The compiler will warn the programmer if an attempt is made 
 to modify such a variable.
  
 For efficiency, in most of the following routines arguments are therefore given as as constant references.",NA
1.5 ,NA,NA
Other C,++,NA
concepts,"A number of other C
 ++
 concepts, such as function prototypes and templates, will be introduced later in 
 particular contexts. They only appear in a few places and is better introduced where they are used.
  
 16",NA
Chapter 2,NA,NA
Matrix Tools,"Being computer literate entails being aware of a number of computer tools and being able to choose the 
 most suitable tool for the problem at hand. Way to many people turns this around, and want to fit any 
 problem to the computer tool they know. The tool that very often is
  the
  tool for business school students 
 is a spreadsheet like
  Excel
 . Of course, a spreadsheet is very useful for very many business applications. 
 However, it is not the best tool for more computationally intensive tasks.
  
 While the bulk of the present book concerns itself with C
 ++
 , in many applications in finance a very handy 
 tool is a language for manipulating vectors and matrices using linear algebra. There are a lot of different 
 possible programs that behaves very similarly, with a syntax taken from the mathematical formulation of 
 linear algebra. An early tool of this sort was
  matlab
 , with a large number of programs copying much of the 
 syntax of this program. As a result of this there is a proliferation of programs with similar syntax to 
 Matlab doing similar analysis. General tools include the commercial package Matlab sold by Mathworks, 
 the public domain programs octave and scilab. Tools that are similar, but more geared towards 
 econometrics, include Gauss, Ox and
  S
  with its public domain “clone” R. As for what program to install, 
 there is no right answer. For the basic learning of how these tools work, any of the mentioned packages 
 will do the job. For students on a limited budget the public domain tools octave, scilab and R are obvious 
 candidates. All of them perform the basic operations done by the commercial Matlab package, and good 
 for learning the basics of such a matrix tool.
  
 All of these tools are programs that lets the user manipulate vectors and matrices using very compact 
 notation. While compact notation is always prone to tense, making programs using it unreadable, this is 
 not such a large problem in Matlab, the notation tends to be so close how a mathematician would write 
 them that programs can be relatively easy to follow. There are some pitfalls for the unwary user, in 
 particular it is easy to “miss” the difference between a command operating on a whole matrix and the 
 corresponding element by element operation. For example, consider the following short example, where 
 the operator ˆ means that the matrix A is taken to the power 2 (multiplied with itself), and the operator .ˆ 
 means that each element of the matrix A is taken to the power 2. The two commands give very different 
 answers.
  
 >> A = [1 1 ; 1 1] 
  
 A = 
  
  
 1 1 
  
  
 1 1 
  
 >> A^2 
  
 ans = 
  
  
 2 2 
  
  
 2 2 
  
 >> A.^2 
  
 ans =
  
 17",NA
2.1 ,NA,NA
The first screen,"How you start the particular tool you are using depend both on which program and which operating 
 system you are working on. The details of how to start it is left as an exercise to the reader.
  
 The tools are interactive, they present you with a prompt, and expect you to start writing commands. We 
 will
  
 >>
  
 as the prompt, which means that the program is ready to receive commands.
  
 In the text output of the matrix tool will be shown typewritten as:
  
 >>
  
 A = [1, 2, 3;
  
 4, 5, 6]
  
 This particular command defines a matrix A, the matrix tool will respond to this command by printing the 
 matrix that was just defined:
  
 A = 
  
 1 2 3 
  
 4 5 6",NA
2.2 ,NA,NA
Linear algebra,"To use such a tool you need some knowledge of linear algebra. We assume the reader have this basic 
 knowledge, if not a quick perusal of a standard mathematical text on linear algebra is called for.
  
 2.2.1 
  
 Basic matrix operations
  
 In matrix algebra a set of mathematical rules are given for operating on the basic elements real numbers, 
 vectors, and matrices. In Matlab the type of each variable is determined when you first define it.
  
 >> a=1 
  
 a = 1 
  
 >> b=2 
  
 b = 2 
  
 >> c=3 
  
 c = 3 
  
 >> y=[1;2;3] 
  
 y = 
  
  
 1 
  
  
 2 
  
  
 3 
  
 >> x=[1,2,3] 
  
 x =
  
 1
  
 2
  
 3
  
 18",NA
2.3 ,NA,NA
Solving linear equations,"Consider the basic linear equation
  
 Ax
  =
  b
  
 This equation has a defined solution if the rank of A equals the rank of [
 A
 j
 b
 ]. If A is nonsingular, we solve 
 the linear equation by finding the unique solution
  
 x
  =
  A
 1
 b
  
 22",NA
2.4 ,NA,NA
Element by element operations,"When a command is prefixed with a period, it means the command applies to each element of a vector or 
 matrix, not the vector or matrix.
  
 For example, with the two vectors below, consider the difference in multiplying the two and doing an 
 element by element multiplication:
  
 > x=[1 2 3 ] 
  
 x =
  
 1
  
 2
  
 3
  
 > t=[1 2 3] 
  
 t =
  
 1
  
 2
  
 3
  
 >> x*t’
  
 ans = 14 
  
 > x.*t 
  
 ans =
  
 1
  
 4
  
 9
  
 Similarly, when taking the exponent of a matrix
  
 > A=[1 1;1 1] 
  
 A = 
  
  
 1 1 
  
  
 1 1
  
 >> A^10 
  
 ans = 
  
  
 512 
  
 512 
  
  
 512 
  
 512 
  
 >> A.^10 
  
 ans = 
  
  
 1 1 
  
  
 1 1",NA
2.5 ,NA,NA
Function definitions,NA,NA
2.6 ,NA,NA
m files,NA,NA
2.7 ,NA,NA
Flow control,NA,NA
2.8 ,NA,NA
Plotting,"A very important use for a tool like Matlab is its ability to produce plots graphing mathematical 
 relationships. For illustrating mathematical relations a two or three dimensional picture
  can
  be better 
 than the thousands words of the old adage.
  
 24",NA
2.9 ,NA,NA
Libraries,NA,NA
2.10 ,NA,NA
References,"You need the manual for your chosen package.
  
 25",NA
Chapter 3,NA,NA
The value of time,"Contents
  
 3.1
  
 Present value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 3.2
  
 One interest rate with annual compounding . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 27
  
 3.3
  
 3.2.1
  
 Internal rate of return. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 Continously compounded interest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 34
  
 3.4
  
 3.3.1
  
 Present value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 Further readings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 Finance as a field of study is sometimes somewhat flippantly said to deal with the value of two things: 
 time
  and
  risk
 . While this is not the whole story, there is a deal of truth in it. These are the two issues which 
 is always present. We start our discussion by ignoring risk and only considering the implications of the 
 fact that anybody prefers to get something earlier rather than later, or the value of time.",NA
3.1 ,NA,NA
Present value,"The present value is the current value of a stream of future payments. Let C
 t
  be the cash flow at time t. 
 Suppose we have N future cash flows that occur at times t
 1
 ; t
 2
 ; ; t
 N
 .
  
  
 C
 1
  
 C
 2
  
 C
 N
  
 -
  
 0
  
 t
 1
  
 t
 2
  
 t
 N
  
  
 time
  
 To find the
  present
  value of these future cash flows one need a set of prices of future cash flows. Suppose 
 d
 t
  is the price one would pay today for the right to receive one dollar at a future date t. Such a price is also 
 called a
  discount factor
 . To complicate matters further such prices will differ depending on the riskiness of 
 the future cash flows. For now we concentrate on one particular set of prices, the prices of 
 riskless
  future 
 cash flows. We will return to how one would adjust the prices for risky cash flows.
  
 If one knows the set of prices for future claims of one dollar, d
 1
 ; d
 2
 ; : : : ;, one would calculate the present 
 value as the sum of the present values of the different elements.
  
 PV =
  
 N 
  
 X
  
 d
 t
 i
 C
 t
 i
  
 26",NA
3.2 ,NA,NA
One interest rate with annual compounding,"The best known way to simplify the present value calculation is to rewrite the discount factors in terms of 
 interest rates, or yields, through the relationship:
  
 =
  
 1
  
 t
  =
  
 (1 + r
 t
 )
 t
  
 where r
 t
  is the interest rate (usually termed the spot rate) relevant for a t-period investment. To further 
 simplify this calculation one can impose that this interest rate r is constant for all periods. This is termed 
 a
  flat
  term structure. We will in the next chapter relax this simplifying assumption. The prices for valuing 
 the future payments d
 t
  is calculated from this interest rate:
  
 d
 t
  =
  
 1 
  
 (1 + r)
 t
  ;
  
 In this case one would calculate the present value of a stream of cash flows paid at discrete dates t = 1; 2; : : 
 : N as
  
 PV =
  
 N 
  
 X
  
  
 C
 t 
  
 (1 + r)
 t
  :
  
 The implementation of this calculation is shown in C
 ++
 Code 3.1.
  
 #include <cmath> 
  
 #include <vector> 
  
 using namespace std; 
  
 #include <iostream> 
  
 double cash flow pv discrete(const vector<double>& cflow times, 
  
  
  
 const vector<double>& cflow amounts, 
  
  
  
 const double& r){ 
  
  
 double PV=0.0; 
  
  
 for (int t=0; t<cflow times.size();t++) { 
  
  
  
 PV += cflow amounts[t]/pow(1.0+r,cflow times[t]); 
  
 }; 
  
  
 return PV; 
  
 };
  
 C
 ++
 Code 3.1: Present value with discrete compounding
  
 Example
  
 27",NA
3.3 ,NA,NA
Continously compounded interest,"Such discrete compounding as we have just discussed is not the only alternative way to approximate the 
 discount factor. The discretely compounded case assumes that interest is added at discrete points in time 
 (hence the name). However, an alternative assumption is to assume that interest is added continously. If 
 compounding is continous, and r is the interest rate, one would calculate the current price d
 t
  of reciving 
 one dollar at a future date t as
  
 d
 t
  = e
 rt
 ;
  
 Formula 3.1 summarizes some rules for translating between continously compounded and discretly com-
 pounded interest rates.
  
 r = n ln
  
 e
  
 1 +r
 n 
  
  
 n
  
 r
 n
  = n
  
 r 
  
 n
  1
  
 Future value = e
 rt
  
 Present value = e
 rt
  
 Notation: r
 n
 : interest rate with discrete compounding, n: compounding periods per year. r: interest rate with 
 continuous compounding, t: time to maturity.
  
 Formula 3.1: Translating between discrete and continous compounding
  
 Example
  
 1. Given a 15% interest rate with monthly compounding, calculate the equivalent interest rate with con-
  
 tinuous compounding.
  
 2. Given a 12% interest rate with continuous compounding, find the equivalent interest rate with 
 quarterly 
  
 compounding.
  
 Carrying out the calculations:
  
 1. r
 12
  = 15%, r = 12 ln
  
 1 +
 0:15 12
  
 = 14:91%
  
 = 12:18%
  
 2. r = 12% , r
 4
  = n
  
 e
  
 r 
  
 n
  1
  
 = 4
  
 e
  
 0:12
  
  1
  
 4
  
 Using Matlab to do the calculations:
  
 Matlab program: 
  
 r 
  
 = 12 * log( 1+0.15/12) 
  
 r4 = 4 * ( exp(0.12/4)1 ) 
  
 Output from Matlab program: 
  
 r = 0.14907 
  
 r4 = 0.12182
  
 34",NA
3.4 ,NA,NA
Further readings,"The material in this chapter is covered in most standard textbooks of corporate finance (e.g. Brealey, 
 Myers, and Allen (2010) or Ross, Westerfield, and Jaffe (2009)) and investments (e.g. Bodie, Kane, and 
 Marcus (2007), Haugen (2001) or Sharpe, Alexander, and Bailey (1999)).
  
 35",NA
Chapter 4,NA,NA
Bond Pricing with a flat term structure,"Contents
  
 4.1
  
 Flat term structure with discrete, annual compounding . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 4.2
  
 4.1.1
  
 Bond Price
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 4.1.2
  
 Yield to maturity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 38
  
 4.1.3
  
 Duration
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 41
  
 4.1.4
  
 Measuring bond sensitivity to interest rate changes . . . . . . . . . . . . . . . .
  
 43
  
 Continously compounded interest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 47
  
 4.3
  
 Further readings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 50
  
 In this section we use the present value framework of the previous chapter to price bonds and other fixed 
 income securities. What distinguishes bonds is that the future payments are set when the security is 
 issued. The simplest, and most typical bond, is a fixed interest, constant maturity bond with no default 
 risk. There is however a large number of alternative contractual features of bonds. The bond could for 
 example ba an annuity bond, paying a fixed amount each period. For such a bond the principal amount 
 outstanding is paid gradually during the life of the bond. The interest rate the bond pays need not be 
 fixed, it could be a floating rate, the interest rate paid could be a function of some market rate. Many 
 bonds are issued by corporations, and in such cases there is a risk that the company issued the bond 
 defaults, and the bond does not pay the complete promised amount. Another thing that makes bond 
 pricing difficult in practice, is that interest rates tend to change over time.
  
 We start by assuming that all the promised payments are certain.
  
 Then the bond current price B
 0
  is found as the present value of these payments. The first step of pricing is 
 to use the terms of the bond to find the promised payments. We start by considering a fixed interest bond 
 with no default risk. Such bonds are typically bonds issued by governments. The bond is a promise to pay 
 a face value F at the maturity date T periods from now. Each period the bond pays a fixed percentage 
 amount of the face value as coupon C. The cash flows from the bond thus look as follows.
  
 t =
  
 0
  
 1
  
 2
  
 3
  
 T
  
 Coupon
  
  
 C
  
 C
  
 C
  
 C
  
 Face value
  
 F
  
 Total cash flows
   
 C
 1
  = C
  
 C
 2
  = C
   
 C
 T
  = C + F
  
 In general a bond price is found as the present value
  
 B
 0
  = d
 1
 C
 1
  + d
 2
 C
 2
  + + d
 T
  C
 T
  =
  
 T 
  
 X
  
 d
 t
 C
 t
  
 where d
 t
  is the discount factor, or the time 0 price of a payment of 1 at time t. To fully specify the
  
 36",NA
4.1 ,NA,NA
"Flat term structure with discrete, annual compounding","This is the simplest possible specification of a term structure,
  
  
  
 1
  
 t
   
 1
  
 4.1.
 1
  
 d
 t
  =
  
 1 + r
   
 =
  
 (1 + r)
 t
  
 Bond 
 Price
  
 The current bond price (B
 0
 ) is the present value of the cash flows from the bond
  
 T 
  
 T
  
 B
 0
  = X (1 + r)
 t 
 C
 t
  = X (1 + r)
 t
  
 (4.1)
  
 1 C
 t
  
 If we continue with the example of a standard fixed interest bond, where C
 t
  = C when t < T and
  
 C
 T
  = C + F, and show how the bond price will be calculated using Matlab.
  
 Example
  
 A 3 year bond with a face value of $100 makes annual coupon payments of 10%. The current interest rate 
 (with annual compounding) is 9%.
  
 1. Determine the current bond price.
  
 The current bond price: B
 0
  =
  
  
 10 
  
 (1+0:09)
 1
  +
  
 10 
  
 (1+0:09)
 2
  +
  
 (1+0:09)
 3
  = 102:531.
  
 Here are the calculations:
  
 Matlab program:
  
 C =[10,10,110] 
  
 t = 1:3 
  
 r = 0.09 
  
 d=(1./(1+r).^t) 
  
 B= d * C’
  
 Output from Matlab program:
  
 C = 
  
 10 10 110 
  
 t = 
  
 1 2 3 
  
 r = 0.090000 
  
 d = 
  
 0.91743 0.84168 0.77218 
  
 B = 102.53
  
  
 C
 ++
 program:
  
 vector<double> cflows; cflows.push back(10); cflows.push back(10); cflows.push back(110); 
 vector<double> times; times.push back(1); times.push back(2); times.push back(3); double r=0.09; 
  
 cout << "" bonds price = "" << bonds price discrete(times, cflows, r) << endl;
  
 Output from C
 ++
 program:
  
 bonds price = 102.531
  
 37",NA
4.2 ,NA,NA
Continously compounded interest,"We will go over the same concepts as covered in the previous section on bond pricing. There are certain 
 subtle differences in the calculations. Formula 4.2 corresponds to the earlier summary in formula 4.1.
  
  
 Bond Price B
 0
 : 
  
  
 B
 0
  = X e
 rt
 i
 )
 C
 t
 i
  
 Yield to maturity y solves: 
  
 B
 0
  = X C
 t
 i
 e
 yt
 i
  
 Duration D: 
  
  
 D = 1 
  
  
 B
 0 
 X t
 i
 C
 t
 i
 e
 rt
 i
  
 Macaulay duration
  
 Convexity Cx:
  
 Cx = 1 
  
  
 B
 0
  
 X
  
 C
 t
 i
 t
 2 i
 e
 rt
 i
  
 Approximating bond price changes
  
 B
 0
  
 Dy
  
 B
 0
  
 D = 1 
  
 B
 0
  
 X
  
 t
 i
 C
 t
 i
 e
 yt
 i
  
 B
 0
  
 Dy + 1 2 Cx (y)
 2
  
 X
  
 B
 0
  
 Bond paying cash flows C
 t1
 ; C
 t2
 ; : : : at times t
 1
 ; t
 2
 ; : : :. Notation: B
 0
 : current bond price. e: natural exponent.
  
  
 Formula 4.2: Bond pricing formulas with continously compounded interest and a flat term structure
  
 Some important differences is worth pointing out. When using continously compounded interest, one 
 does not need the concept of
  modified duration
 . In the continously compounded case one uses the 
 calculated duration directly to approximate bond changes, as seen in the formulas describing the ap-
 proximation of bond price changes. Note also the difference in the
  convexity
  calculation, one does not 
 divide by (1 + y)
 2
 in the continously compounded formula, as was done in the discrete case.
  
 C
 ++
 Code 4.7, C
 ++
 Code 4.8, C
 ++
 Code 4.9 and C
 ++
 Code 4.10 show continously compounded analogs of the earlier 
 codes for the discretely compounded case.
  
 #include 
 <cmath> 
  
 #include 
 <vector> 
  
 using 
 namespace 
 std;
  
 double bonds price(const vector<double>& cashflow times, 
  
  
  
  
 const vector<double>& cashflows, 
  
  
  
  
 const double& r) { 
  
  
 double p=0; 
  
  
 for (int i=0;i<cashflow times.size();i++) { 
  
  
  
 p += exp(r*cashflow times[i])*cashflows[i]; 
  
  
 }; 
  
  
 return p; 
  
 };
  
 C
 ++
 Code 4.7: Bond price calculation with continously compounded interest and a flat term structure
  
 47",NA
4.3 ,NA,NA
Further readings,"The material in this chapter is covered in most standard textbooks on investments (e.g. Bodie et al. 
 (2007), Haugen (2001) or Sharpe et al. (1999)). More details can be found in textbooks on fixed income, 
 such as Sundaresan (2001).
  
 50",NA
Chapter 5,NA,NA
The term structure of interest rates and ,NA,NA
an object lesson,"Contents
  
 5.1
  
 The interchangeability of discount factors, spot interest rates and forward interest 
 rates
  
 . . . . .
  
 52
  
 5.2
  
 The term structure as an object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 55
  
 5.3
  
 5.2.1
  
 Base class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 55
  
 5.2.2
  
 Flat term structure.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 57
  
 Using the currently observed term 
 structure.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 58
  
 5.4
  
 5.3.1
  
 Linear Interpolation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 59
  
 5.3.2
  
 Interpolated term structure class. . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 61
  
 Bond calculations with a general term structure and continous compounding . . . . . . . . . . .
  
 64
  
 In this chapter we expand on the analysis of the previous chapter by relaxing the “one interest 
 rate”assumption used there and allow the spot rates to change as you change the time you are 
 discounting over.
  
 Recall that we said that the present value of a set of cash flows is calculated as
  
 PV =
  
 N 
  
 X
  
 d
 t
 i
 C
 t
 i
  
 -
  
  
 C
 t
 1
  
 C
 t
 2
  
 C
 t
 N
  
  
  
  
 time
  
 0
  
 t
 1
  
 t
 2
  
 t
 N
  
 d
 t
 1
 C
 t
 1
  
  
 d
 t
 2
 C
 t
 2
  
  
 d
 t
 N
  C
 t
 N
  
 To make this applicable to cash flows received at any future date t we potentially need an infinite number 
 of discount factors d
 t
 . This is not feasible, so some lower dimensional way needs to be found to 
 approximate d
 t
 , but with more flexibility than the extremely strong assumption that there is one fixed 
 interest rate r, and that the discount factor for any time t is calculated as either d
 t
  = 1=(1+r)
 t
 (discrete 
 compounding), or d
 t
  = e
 rt
 (continuous compounding), which we used in the previous chapter.
  
 51",NA
5.1 ,NA,NA
"The interchangeability of discount factors, spot interest rates and ",NA,NA
forward ,NA,NA
interest rates,"The term structure can be specified in terms of either discount factors, spot interest rates or forward 
 interest rates. A discount factor is the current price for a future (time t) payment of one dollar. To find the 
 current value PV of a cash flow C
 t
 , we calculate PV = d
 t
 C
 t
 . This discount factor can also be specified in 
 terms of interest rates, where we let r
 t
  be the relevant interest rate (spot rate) for discounting a t-period 
 cashflow. Then we know that the present value PV = e
 r
 t
 t
 C
 t
 . Since these two methods of calculating the 
 present value must be consistent,
  
 PV = d
 t
 C
 t
  = e
 r
 t
 t
 C
 t
  
 and hence
  
 d
 t
  = e
 r
 t
 t
  
 Note that this equation calculates d
 t
  given r
 t
 . Rearranging this equation we find the spot rate r
 t
  in terms of 
 discount factors
  
 r
 t
  = ln(d
 t
 ) 
  
  
 t
  
 An alternative concept that is very useful is a forward interest rate, the yield on borrowing at some future 
 date t
 1
  and repaying it at a later date t
 2
 . Let f
 t
 1
 ;t
 2
  be this interest rate. If we invest one dollar today, at the 
 current spot rate spot rate till period t
 1
  and the forward rate for the period from t
 1
  to t
 2 
 (which is what 
 you would have to do to make an actual investment), you would get the following future value
  
 FV = e
 r
 t1
 t
 1
 e
 f
 t1;t2
 (t
 2
 t
 1
 )
  
 The present value of this forward value using the time t
 2
  discount factor has to equal one:
  
 d
 t
 2
 FV = 1
  
 These considerations are enough to calculate the relevant transforms. The forward rate for borrowing at 
 time t
 1
  for delivery at time t
 2
  is calculated as
  
  
  n
  
 d
 t2
   
 l
  
 d
 t1
  
  
  n
  
 d
 t1
   
 l
  
 d
 t2
  
 f
 t
 1
 ;t
 2
  =
  
 t
 2
  t
 1
  
 =
  
 t
 2
  t
 1
  
 The forward rate can also be calculated directly from yields as
  
 f 
  
 t
 2
  
 r
  
 t
 1
  
 f
 t
 1
 ;t
 2
   
 t
 2
  
 t
 2
  t
 1
  
 r
 t
 1
  
 t
 2
  t
 1
  
 52",NA
5.2 ,NA,NA
The term structure as an object,"From the previous we see that the term structure can be described in terms of discount factors, spot rates 
 or forward rates, but that does not help us in getting round the dimensionality problem. If we think in 
 terms of discount factors, for a complete specification of the current term structure one needs an infinite 
 number of discount factors fd
 t
 g
 t2R
 +
 . It is perhaps easier to think about this set of discount factors as a
  
 function
  d(t), that, given a nonnegative time t, returns the discount factor. Since we have established that 
 there are three equivalent ways of defining a term structure, discount factors, spot rates and forward 
 rates, we can therefore describe a term structure as a collection of three different functions that offer 
 different views of the same underlying object.
  
 A term structure is an abstract object that to the user should provide
  
  discount factors d (prices of zero coupon bonds).
  
  spot rates r (yields of zero coupon bonds).
  
  forward rates f
  
 for any future maturity t. The user of a term structure will not need to know how the term structure is 
 implemented, all that is needed is an interface that specifies the above three functions.
  
 This is tailor made for being implemented as a C
 ++
 class
 . A class in C
 ++
 terms is a collection of data structures 
 and functions that operate on these data structures. In the present context it is a way of specifying the 
 three functions.
  
 r(t)
  
 d(t)
  
 f(t)
  
 5.2.1 
  
 Base class
  
 Header File 5.1 shows how we describe the generic term structure as a C
 ++
 class.
  
  
 #ifndef 
 #define
  
 TERM STRUCTURE CLASS H 
  
 TERM STRUCTURE CLASS H
  
 class term structure class { 
  
 public: 
  
  
 virtual double r(const double& t) const;
  // yield on zero coupon bond 
  
  
 virtual double d(const double& t) const;
  // discount factor/price of zero coupon bond 
  
 virtual double f(const double& t1, const double& t2) const;
  // forward rate 
  
  
 virtual ˜term structure class(); 
  
 };
  
 #endif
  
 Header file 5.1: Header file describing the term_structure base class
  
 The code for these functions uses algorithms that are described earlier in this chapter for transforming 
 between various views of the term structure. 
  
 The term structure class merely provide a convenient 
 interface to these algorithms. The code is shown in C
 ++
 Code 5.2
  
 Note that the definitions of calculations are circular. Any given
  specific
  type of term structure has to over-
 ride at least one of the functions r (yield), d (discount factor) or f (forward rate).
  
 We next consider two examples of
  specific
  term structures.
  
 55",NA
5.3 ,NA,NA
Using the currently observed term structure.,"A first step to a general term structure is to use market data on bond prices and interest rates to infer 
 discount factors. The simplest way of presenting this problem is in terms of linear algebra. Suppose we 
 have three bonds with cash flows at times 1, 2 and 3.
  
 B
 1
  
 =
  
 d
 1
 C
 11
  
 +
  
 d
 2
 C
 12
  
 +
  
 d
 2
 C
 13
  
 =
  
 +
  
 +
  
 B
 2
  
 d
 1
 C
 21
  
 d
 2
 C
 22
  
 d
 2
 C
 23
  
 =
  
 +
  
 +
  
 B
 1
  
 d
 1
 C
 31
  
 d
 2
 C
 32
  
 d
 2
 C
 33
  
 Writing this in terms of matrices
  
 2 4
  
 B
 1
  
 3 5 
 =
  
 2 
 4
  
 d
 1
  
 3 
 5
  
 2 
 4
  
 C
 11
  
 C
 12
  
 C
 13 
 C
 23 
 C
 33
  
 3 
 5
  
 3 5
  
 B
 2
  
 d
 2
  
 C
 21
  
 C
 22
  
 B
 3
  
 d
 3
  
 C
 31
  
 C
 32
  
 Solving for the discount factors
  
 1
  2 4
  
 B
 1 
 B
 2 
 B
 3
  
 or
  
 2 4
  
 d
 1
  
 3 5 
 =
  
 2 
 4
  
 C
 11
  
 C
 12
  
 C
 13
  
 3 
 5
  
 d
 2
  
 C
 21
  
 C
 22
  
 C
 23
  
 d
 3
  
 C
 31
  
 C
 32
  
 C
 33
  
 d
  =
  C
 1
 B
  
 using the obvious matrix definitions
  
 B
  =
  
 2 
 4
  
 B
 1
  
 3 5
  
 d
  =
  
 2 
 4
  
 d
 1
  
 3 5
  
 C
  =
  
 2 
 4
  
 C
 11
  
 C
 12
  
 C
 13
  
 3 5
  
 B
 2
  
 d
 2
  
 C
 21
  
 C
 22
  
 C
 23
  
 Example
  
 B
 3
  
 d
 3
  
 C
 31
  
 C
 32
  
 C
 33
  
 The following set of bond and bond prices is observed:
  
 Time (in years)
  
 Bond
  
 Bond
  
 0
  
 0.5
  
 1
  
 1.5
  
 2
  
 3
  
 4
  
 Price
  
 1
  
 98
  
  
 100
  
 100
  
 100
  
 110
  
 108
  
 109
  
 2
  
 96
  
 2
  
 92
  
 3
  
 118
  
 10
  
 10
  
 10
  
 4
  
 109
  
 8
  
 8
  
 8
  
 8
  
 5
  
 112
  
 9
  
 9
  
 9
  
 9
  
 9
  
 The bonds are treasury secrurities, which can be viewed as nominally riskless.
  
 1. For what maturities is it possible to infer discount factors?
  
 2. Determine the implicit discount factors in the market.
  
 3. What is the interest rates implied in this set of discount rates?
  
 Here we can find the discount factors for maturities of 0.5,1,1.5,2,3 and 4.
  
 58",NA
5.4 ,NA,NA
Bond calculations with a general term structure and continous ,NA,NA
compound-,NA,NA
ing,"Coupon bond paying coupons at dates t
 1
 ; t
 2
 ; : : :
 : 
 Bond Price B
 0
 :
  
 Yield to maturity y solves:
  
 B
 0
  =
  
 X
  
 C
 t
 i
 e
 yt
 i
  
 B
 0
  =
  
 X
  
 d
 t
 i
 C
 t
 i
  =
  
 X
  
 e
 r
 ti
 t
 i
 C
 t
 i
  
 Convexity Cx:
  
 Duration D:
  
 Cx = 1 
  
  
 B
 0
  
 X
  
 t
 2 i
 d
 t
 i
 C
 t
 i
  
 D = 1 
  
 B
 0
  
 X
  
 t
 i
 d
 t
 i
 C
 t
 i
  
 Cx = 1 
  
  
 B
 0
  
 X
  
 t
 2 i
 e
 r
 ti
 t
 i
 C
 t
 i
  
 D = 1 
  
 B
 0
  
 X
  
 t
 i
 e
 r
 ti
 t
 i
 C
 t
 i
  
 D = 1 
  
 B
 0
  
 X
  
 t
 i
 e
 yt
 i
 C
 t
 i
  
 Cx = 1 
  
  
 B
 0
  
 X
  
 t
 2 i
 e
 yt
 i
 C
 t
 i
  
  
 Formula 5.1: Bond pricing with a continously compounded term structure
  
 C
 ++
 Code 5.6 and C
 ++
 Code 5.7 illustrates how one would calculate bond prices and duration if one has a term 
 structure class.
  
 #include ""fin_recipes.h""
  
 double bonds price(const vector<double>& cashflow times, 
  
  
  
  
 const vector<double>& cashflows, 
  
  
  
  
 const term structure class& d) { 
  
  
 double p = 0; 
  
  
 for (unsigned i=0;i<cashflow times.size();i++) { 
  
  
  
 p += d.d(cashflow times[i])*cashflows[i]; 
  
  
 }; 
  
  
 return p; 
  
 };
  
 C
 ++
 Code 5.6: Pricing a bond with a term structure class
  
 64",NA
Chapter 6,NA,NA
The Mean Variance Frontier,"Contents
  
 6.1
  
 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
 7 
  
 6
 9 
  
 6
 9 
  
 7
 2 
  
 7
 2 
  
 7
 3 
  
 7
 3 
  
 7
 4 
  
 7
 5 
  
 7
 5 
  
 7
 6 
  
 7
 6 
  
 7
 6 
  
 7
 6 
  
 7
 7
  
 6.2
  
 The minimum variance frontier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.3
  
 Calculation of frontier portfolios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.4
  
 The global minimum variance portfolio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.5
  
 Efficient portfolios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.6
  
 The zero beta portfolio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.7
  
 Allowing for a riskless asset. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.8
  
 Efficient sets with risk free assets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.9
  
 Short-sale constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.10 The Sharpe Ratio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6.11 Equilibrium: CAPM . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.11.1 Treynor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.11.2 Jensen
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.12 Working with Mean Variance and CAPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.13 Mean variance analysis using matrix 
 libraries
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 We now discuss a classical topic in finance, mean variance analysis. This leads to ways of accounting for 
 the riskiness of cashflows.
  
 Mean variance analysis concerns investors choices between portfolios of risky assets, and how an investor 
 chooses portfolio weights. 
  
 Let r
 p
  be a portfolio return. 
  
 We assume that investors preferences over 
 portfolios p satisfy a mean variance utility representation, u(p) = u(E[r
 p
 ]; (r
 p
 )), with utility increasing in 
 expected return (@u=@E[r
 p
 ] > 0) and decreasing in variance (@u=@var(r
 p
 ) < 0). In this part we consider 
 the representation of the
  portfolio opportunity set
  of such decision makers. There are a number of useful 
 properties of this opportunity set which follows purely from the mathematical formulation of the 
 optimization problem. It is these properties we focus on here.",NA
6.1 ,NA,NA
Setup,"We assume there exists n 2 risky securities, with expected returns
  e
  
 e
  =
  
 2 
 6
 6
 6
 4
  
 E[r
 1
 ]
  
 3 
  
 7
 7
 7
 5
  
 E[r
 2
 ] 
 ...
  
 E[r
 n
 ]
  
 67",NA
6.2 ,NA,NA
The minimum variance frontier,"A portfolio is a
  frontier
  portfolio if it minimizes the variance for a given expected return, that is, a
  
 frontier portfolio p solves
  
 w
 p
  = arg min 
  
 w
  
 1 
  
 2
 w
 0
 Vw
  
 subject to:
  
 w
 0
 e
  = E[~r
 p
 ]
  
 w
 0
 1
  = 1
  
 The set of all frontier portfolios is called the
  minimum variance frontier
 .",NA
6.3 ,NA,NA
Calculation of frontier portfolios,"Proposition 1
  If the matrix
  V
  is full rank, and there are no restrictions on shortsales, the weights
  
 w
 p
  for a frontier portfolio
  p
  with mean
  E[~r
 p
 ]
  can be found as
  
 w
 p
  =
  g
  +
  h
 E[r
 p
 ]
  
 where
  
 g
  = 1 D(B
 1
 0
  A
 e
 0
 )
  V
 1
  
 h
  = 1 D(C
 e
 0
  A
 1
 0
 )
  V
 1
  
 A =
  1
 0
 V
 1
 e
  
 B =
  e
 0
 V
 1
 e
  
 C =
  1
 0
 V
 1
 1
  
 A
  =
  
  B
  
 A
  
 A
  
 C
  
 D = BC A
 2
 = j
 A
 j
  
 Proof
  
 Any minimum variance portfolio solves the program
  
 w
 p
  = arg min 
 w
  
 1 
  
 2
 w
 0
 Vw
  
 subject to
  
 w
 0
 e
  = E[~r
 p
 ]
  
 w
 0
 1
  = 1
  
 Set up the Lagrangian corresponding to this problem
  
 L(
 w
 ; ;  
 j
 e
 ;
  V
 ) = 1 2
 w
 0
 Vw
  
 E[~r
 p
 ]
  w
 0
 e
  
 (1
  w
 0
 1
 )
  
 69",NA
6.6 ,NA,NA
The zero beta portfolio,"Proposition 3
  For any portfolio
  p
  on the frontier, there is a frontier portfolio
  zc(p)
  satisfying
  
 cov
 (r
 zc(p)
 ; r
 p
 ) = 0:
  
 This portfolio is called the zero beta portfolio relative to
  p
 . The zero beta portfolio
  zb(p)
  has return
  
  
 D
  
  
  A
  
 C
 2
  
  
 zc(p)
  
  
 C
  
  
 E[r
 p
 ]
 A C
  
 E[r
 zc(p)
 ]
  
 6
  
 s
  
 mvp
  
 sp
  
  
 szc(p)
  
 Note that if p is an efficient portfolio on the mean variance frontier then zc(p) is inefficient. Conversely,
  
 if p is inefficient zc(p) is efficient.
  
 E[r]",NA
6.8,NA,NA
Efficient sets with risk free assets.,"Suppose r
 f
  <
 A C
 . Then the efficient set is the line from (0; r
 f
 ) through tangency on the efficient set of
  
 risky
  assets.
  
 r
 f
  @ 
  
 C 
  
 A",NA
6.9,NA,NA
Short-sale constraints,"So far the analysis has put no restrictions on the set of weights w
 p
  that defines the minimum variance
  
 frontier.
  
 For practical applications, existence of negative weights is problematic, since this involves
  
 selling securities short.
  
 This has led to the investigation of
  restricted
  mean variance frontiers, where the weights are constrained 
 to be non-negative.
  
 Definition 1
  A short sale resctricted minimum variance portfolio
  p
  solves
  
 w
 p
  = arg min 
  
 w
  
 1 
  
 2
 w
 0
 Vw
  
 subject to
  
 w
 0
 e
  = E[~r
 p
 ]
  
 w
 0
 1
  = 1
  
 w
 0
  0
  
 Such short sale resctricted minimum variance portfolio portfolios are much harder to deal with ana-
 lytically, since they do not admit a general solution, one rather has to investigate the Kuhn-Tucker 
 conditions for corner solutions etc. To deal with this problem in practice one will use a subroutine for 
 solving constrained optimization problems.",NA
6.10 ,NA,NA
The Sharpe Ratio,"The Sharpe ratio of a given portfolio p is defined as
  
 S
 p
  =E[r
 p
 ] r
 f 
  
  
 (r
 p
 )
  
 The Sharpe ratio S
 p
  of a portfolio p is the slope of the line in mean-standard deviations space from the risk 
 free rate through p. Note that in the case with a risk free asset, the tangency portfolio has the maximal 
 Sharpe Ratio on the efficient frontier.
  
 75",NA
6.11 ,NA,NA
Equilibrium: CAPM,"Under certain additional assumptions, an economy of mean variance optimizers will aggregate to an 
 economy where the Capital Asset Pricing Model (CAPM) holds. Under the CAPM, any asset returns will 
 satisfy.
  
 E[r
 i
 ] = r
 f
  +
 i
 (E[r
 m
 ] r
 f
 )
  
 where r
 i
  is the return on asset i, r
 f
  the return on the risk free asset,
  
 6.11.1 
  
 Treynor
  
 T
 p
  =r
 p
  r
 f 
  
 p
  
 6.11.2 
  
 Jensen
  
 p
  = r
 p
  (r
 f
  +
 p
 (r
 m
  r
 f
 )",NA
6.12 ,NA,NA
Working with Mean Variance and CAPM,"The computational problems in mean variance optimization and the CAPM are not major, except for the 
 case of short sales constrained portfolios (quadratic programming). The issues of more concern is 
 estimation of parameters such as covariances and betas.
  
 function s= sharpe(r,rf) 
  
  
 s=(mean(r)mean(rf))/std(rrf); 
  
 endfunction
  
 Matlab Code 6.2: Sharpe Ratio
  
 function t = treynor(r, rm, rf) 
  
  
 beta = cov(r,rm)/var(rm); 
  
  
 t = (mean(rrf))/beta; 
  
 endfunction
  
 Matlab Code 6.3: Treynor Ratio
  
 function alpha = jensen(r, rm, rf) 
  
  
 beta = cov(r,rm)/var(rm); 
  
  
 alpha = mean(r) (rf+beta*(mean(rm)rf)); 
  
 endfunction
  
 Matlab Code 6.4: Jensens alpha
  
 Readings and Sources 
  
 The classical sources for this material are Merton (1972) and Roll (1977a). 
 (Huang and Litzenberger, 1988, Ch 3) has a good textbook discussion of it.
  
 76",NA
6.13 ,NA,NA
Mean variance analysis using matrix libraries,"Let us now consider how to implement mean variance analysis in C
 ++
 . As shown using Matlab, the 
 calculations are relatively simple matrix expressions. To implement the calculations in C
 ++
 the best way of 
 doing it is to use a linear algebra class to deal with the calculations. For illustrative purposes we will show 
 usage of two different matrix classes, Newmat and IT++. These classes are described in more detail in an 
 appendix, with some references to how to obtain and install them.
  
 In C
 ++
 Code 6.1 and C
 ++
 Code 6.2 we show how to do the basic mean variance calculations, calculating means 
 and standard deviations, using the two classes. Note the similarity to using Matlab in the way the matrix 
 and vector multiplications are carried out. Note also an important difference between the two classes. In 
 IT++ the indexing of elements start at zero, the usual C
 ++
 way. Hence, when adressing element tmp(0,0) in 
 the IT++ example we are pulling the first element. In Newmat the default indexing starts at one, the 
 Matlab way. Therefore, in adressing tmp(1,1) in the Newmat example we are
  also 
 pulling the first 
 element. This serves as a warning to read the documentation carefully, the “off by one”error is a very 
 common occurrence when mixing libraries like this.
  
 #include <cmath> 
  
 using namespace 
 std;
  
 #include <itpp/itbase.h> 
  
 using namespace itpp;
  
 double mv calculate mean(const vec& e, const vec& w){ 
  
  
 vec tmp = e.transpose()*w; 
  
  
 return tmp(0); 
  
 };
  
 double mv calculate variance(const mat& V, const vec& w){ 
  
  
 mat tmp = w.transpose()*V*w; 
  
  
 return tmp(0,0); 
  
 };
  
 double mv calculate st dev(const mat& V, const vec& w){ 
  
  
 double var = mv calculate variance(V,w); 
  
  
 return sqrt(var); 
  
 };
  
 C
 ++
 Code 6.1: Mean variance calculations using IT++
  
 Example
  
 Mean variance calculations.
  
 e
  =
  
  0:05
  
 0:0
  
 0:1
  
 V
  =
  
  1:0
  
 0:0
  
 1:0
  
 Calculate mean, variance and stdev for portfolio
  
 w
  =
  
  0:5 
  
 0:5
  
 77",NA
Chapter 7,NA,NA
Futures algoritms.,"Contents
  
 7.1
  
 Pricing of futures contract. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 81
  
 In this we discuss algoritms used in valuing futures contracts.",NA
7.1 ,NA,NA
Pricing of futures contract.,"The futures price of an asset without payouts is the future value of the current price of the assset.
  
 f
 t
  = e
 r(Tt)
 S
 t
  
 #include <cmath> 
  
 using namespace 
 std;
  
 double futures price(const double& S, 
 // current price of underlying asset 
  
  
 const double& r, 
   
 // risk free interest rate 
  
  
  
 const double& time to maturity) { 
  
  
 return exp(r*time to maturity)*S; 
  
 };
  
 C
 ++
 Code 7.1: Futures price 
  
 Example 
  
 Let S = 100 and r = 10%. What is the futures price for a contract with time to maturity of half a year?
  
 C
 ++
 program:
  
 double S=100;
  
 double r=0.10;
  
 double time=0.5;
  
  
 cout << "" futures price = "" << futures price(S,r, time) << endl; 
 Output from 
 C
 ++
 program: 
  
 futures price = 105.127
  
 81",NA
Chapter 8,NA,NA
Binomial option pricing,"Contents
  
  
 8.1
  
 Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 82
  
 8.2
  
 Pricing
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 82
  
 8.3
  
 Multiperiod binomial pricing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 85",NA
8.1,NA,NA
Options,"Option and other derivative pricing is one of the prime “success stories” of modern finance. An option is a 
 derivative security, the cash flows from the security is a function of the price of some
  other
  security, 
 typically called the underlying security. A call option is a right, but not obligation, to buy a given quantity 
 of the underlying security at a given price, called the exercise price K, within a certain time interval. A put 
 option is the right, but not obligation, to
  sell
  a given quantity of the underlying security to an agreed 
 excercise price within a given time interval. If an option can only be exercised (used) at a given date (the 
 time interval is one day), the option is called an European Option. If the option can be used in a whole 
 time period up to a given date, the option is called American.
  
 An option will only be used if it is valuable to the option holder. In the case of a call option, this is when 
 the exercise price K is lower than the price one alternatively could buy the underlying security for, which 
 is the current price of the underlying security. Hence, options have never negative cash flows at maturity. 
 Thus, for anybody to be willing to offer an option, they must have a cost when entered into. This cost, or 
 price, is typically called an option
  premium
 . As notation, let C signify the price of a call option, P the price 
 of a put option and S the price of the underlying security. All of these prices are indexed by time. We 
 typically let 0 be “now” and T the final maturity date of the option. From the definition of the options, it is 
 clear that at their last possible exercise date, the maturity date, they have cash flows.
  
 C
 T
  = max(0; S
 T
  K)
  
 P
 T
  = max(0; K S
 T
  )
  
 The challenge of option pricing is to determine the option premia C
 0
  (call price) and P
 0
  (put price).",NA
8.2 ,NA,NA
Pricing,"All pricing uses that the cashflows from the derivative is a direct function of the price of the underlying 
 security. Pricing can therefore be done
  relative
  to the price of the underlying security. To price options
  
 82",NA
8.3 ,NA,NA
Multiperiod binomial pricing,"Of course, an assumption of only two possible future states next period is somewhat unrealistic, but if we 
 iterate this assumption, and assume that every date, there are only two possible outcomes
  next
  date, but 
 then, for each of these two outcomes, there is two new outcomes, as illustrated in the next figure:
  
 *
  
 *
  
 u(uS
 t
 ) = uuS
 t
  
 HHHHHHHH *
  
 d(uS
 t
 ) = u(dS
 t
 ) = udS
 t
  
 HHHHHHHH
  
 HHHHHHHH
  
 d(dS
 t
 ) = ddS
 t
  
 Iterating this idea a few times more, the number of different
  terminal
  states increases markedly, and we 
 get closer to a realistic distribution of future prices of the underlying at the terminal date. Note that a 
 crucial assumption to get a picture like this is that the factors u and d are the same on each date.
  
 HHH
  
 HHHHHHHHHHHHH HHHHHHHHHH HHHHHHHH
  
 Pricing in a setting like this is done by working backwards, starting at the terminal date. Here we know all 
 the possible values of the underlying security. For each of these, we calculate the payoffs from the 
 derivative, and find what the set of possible derivative prices is
  one period before
 . Given these, we can find 
 the option one period before this again, and so on. Working ones way down to the root of the tree, the 
 option price is found as the derivative price in the first node.
  
 For example, suppose we have two periods, and price a two period call option with exercise price K.
  
 85",NA
Chapter 9,NA,NA
"Basic Option Pricing, the Black ",NA,NA
Scholes formula,"Contents
  
 9.1
  
 The formula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 90
  
 9.2
  
 Understanding the why’s of the formula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 92
  
 9.3
  
 9.2.1
  
 The original Black Scholes analysis . . . . . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 9.2.2
  
 The limit of a binomial case . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 9.2.3
  
 The representative agent framework
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 Partial derivatives.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 9.4
  
 9.3.1
  
 Delta
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 93
  
 9.3.2
  
 Other Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 94
  
 9.3.3
  
 Implied Volatility.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 96
  
 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 98
  
 The pricing of options and related instruments has been a major breakthrough for the use of financial 
 theory in practical application. Since the original papers of Black and Scholes (1973) and Merton (1973), 
 there has been a wealth of practical and theoretical applications. We will now consider the orginal Black 
 Scholes formula for pricing options, how it is calculated and used. For the basic intuition about option 
 pricing the reader should first read the discussion of the binomial model in the previous chapter, as that 
 is a much better environment for understanding what is actually calculated.
  
 An option is a
  derivative security
 , its value depends on the value, or price, of some other underlying 
 security, called the
  underlying
  security.. Let S denote the value, or price, of this underlying security. We 
 need to keep track of what time this price is observed at, so let S
 t
  denote that the price is observed at time 
 t. A call (put) option gives the holder the right, but not the obligation, to buy (sell) some underlying asset 
 at a given price K, called the exercise price, on or before some given date T. If the option is a so called
  
 European
  option, it can only be used (exercised) at the maturity date. If the option is of the so called
  
 American
  type, it can be used (exercised) at any date up to and including the maturity date T. If exercised 
 at time T, a call option provides payoff
  
 C
 T
  = max(0; S
 T
  K)
  
 and a put option provides payoff
  
 P
 T
  = max(0; K S
 T
  )
  
 The Black Scholes formulas provides analytical solutions for
  European
  put and call options, options which 
 can only be exercised at the options maturity date. Black and Scholes showed that the additional
  
 89",NA
9.1 ,NA,NA
The formula,"Formula 9.1 gives the exact formula for a call option, and the calculation of the same call option is shown in 
 C
 ++
 Code 9.1 and Matlab Code 9.1.
  
  
 c = SN(d
 1
 ) Ke
 r(Tt)
 N(d
 2
 ) 
  
 where
  
  
  S
  
 1 2
  
 d
 1
  = ln
  
 K
  
 + (r + 
 2
 )(T t)
  
 p T t
  
 and
  
 d
 2
  = d
 1
  
 p T t
  
 Alternatively one can calculate d
 1
  and d
 2
  as
  
 l
  
  S
  
 +(t
  
  
  
  l
  
 K
  
 +(t
  
 +1
  
 t
  
 1
   
  
  S
  
 p T t
  
 +
  
 2
  
  
 t
  
 l
  
 +(t
  
  
  
 l
  
 K
  
 +(t
  
 1
   
 d
 2
  = 
  
  
 p T t
  
 2
  
 T t
  
 S is the price of the underlying security, K the exercise price, r the (continously compounded) risk free interest rate, the standard deviation of the 
 underlying asset, t the current date, T the maturity date, T t the time to maturity for the option and N() the cumulative normal distribution.
  
 Formula 9.1: The Black Scholes formula
  
 #include <cmath> 
  
 // mathematical C library 
  
 #include ""normdist.h"" 
  
 // the calculation of the cumularive normal distribution
  
 double option price call black scholes(const double& S, 
  
 // spot (underlying) price 
  
  
 const double& K, 
  
  
 // strike (exercise) price, 
  
  
 const double& r, 
  
  
 // interest rate 
  
  
  
 const double& sigma,
  // volatility 
  
  
  
 const double& time) {
  // time to maturity 
  
 double time sqrt = sqrt(time); 
  
  
 double d1 = (log(S/K)+r*time)/(sigma*time sqrt)+0.5*sigma*time sqrt; 
  
  
 double d2 = d1(sigma*time sqrt); 
  
  
 return S*N(d1) K*exp(r*time)*N(d2); 
  
 };
  
 C
 ++
 Code 9.1: Price of European call option using the Black Scholes formula
  
 90",NA
9.2 ,NA,NA
Understanding the why’s of the formula,"To get some understanding of the Black Scholes formula and why it works will need to delve in some 
 detail into the mathematics underlying its derivation. It does not help that there are a number of ways to 
 prove the Black Scholes formula, depending on the setup. As it turns out, two of these ways are important 
 to understand for computational purposes, the original Black Scholes continous time way, and the “limit 
 of a binomial process” way of Cox, Ross, and Rubinstein (1979).
  
 92",NA
9.3 ,NA,NA
Partial derivatives.,"In trading of options, a number of partial derivatives of the option price formula is important.
  
 9.3.1 
  
 Delta
  
 The first derivative of the option price with respect to the price of the underlying security is called the 
 delta
  of the option price. 
  
 It is the derivative most people will run into, since it is important in hedging of 
 options.
  
 @c 
  
 @S= N(d
 1
 )
  
 C
 ++
 Code 9.2 shows the calculation of the delta for a call option.
  
 93",NA
9.4,NA,NA
References,"Black and Scholes (1973) Merton (1973) 
  
 Gray and Gray (2001) has a simple proof of the formula.
  
 98",NA
Chapter 10,NA,NA
Warrants,"Contents
  
 10.1 Warrant value in terms of 
 assets
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
 9 
  
 10
 0 
  
 10
 1
  
 10.2 Valuing warrants when observing the stock value . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10.3 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 A warrant is an option-like security on equity, but it is issued by the same company which has issued the 
 equity, and when a warrant is exercised, a
  new
  stock is issued. This new stock is issued at a the warrant 
 strike price, which is lower than the current stock price (If it wasn’t the warrant would not be exercised.) 
 Since the new stock is a a fractional right to all cashflows, this stock issue
  waters out
 , or 
 dilutes
 , the equity 
 in a company. The degree of dilution is a function of how many warrants are issued.",NA
10.1 ,NA,NA
Warrant value in terms of assets,"Let K be the strike price, n the number of shares outstanding and m the number of warrants issued. 
 Assume each warrant is for 1 new share, and let A
 t
  be the current asset value of firm. Suppose all 
 warrants are exercised simultaneously. Then the assets of the firm increase by the number of warrants 
 times the strike price of the warrant.
  
 A
 t
  + mK;
  
 but this new asset value is spread over more shares, since each exercised warrant is now an equity. The 
 assets of the firm is spread over all shares, hence each new share is worth:
  
 A
 t
  + mK
  
 m + n
  
 making each exercised warrant worth:
  
 A
 t
  + mK
  
   =
  
 n
  
 A
 t
  
  K
  
  
 m + n
  
   =
  
 m + n
  
 n K
  
 If we knew the current value of assets in the company, we could value the warrant in two steps:
  
 1. Value the option using the Black Scholes formula and
 A
 t 
 n
 as the current stock price.
  
 2. Multiply the resulting call price with 
 m+n
 .
  
 If we let W
 t
  be the warrant value, the above arguments are summarized as:
  
 W
 t
  =
  
 n 
  
 n + mC
 BS
  
 A 
  
 n ; K; ; r; (T t)
  
 ;
  
 99",NA
10.2 ,NA,NA
Valuing warrants when observing the stock value ,"However, one does not necessarily observe the asset value of the firm. Typically one only observes the
  
 equity value of the firm. If we let S
 t
  be the current stock price, the asset value is really: 
  
 A
 t
  = nS
 t
  + mW
 t
  
 Using the stock price, one would value the warrant as
  
  
 n
  
 nS
 t
  + mW
 t
  
 K; ;r t
  
 t
  
  
 n + m
 BS
  
 n
  
 K; ;r t
  
 or
  
 W
 t
  =
  
 n 
  
 n + mC
 BS
  
 S
 t
  +m n W
 t
 ; K; ; r; (T t)
  
 Note that this gives the value of W
 t
  as a function of W
 t
 . One need to solve this equation numerically to
  
 find W
 t
 .
  
 The numerical solution for W
 t
  is done using the Newton-Rhapson method. Let
  
 g(W
 t
 ) = W
 t
  
 n 
  
 n + mC
 BS
  
 S
 t
  +m n W
 t
 ; K; ; r; (T t)
  
 Starting with an initial guess for the warrant value W
 o t
 , the Newton-Rhapson method is that one iterates
  
 as follows
  
 i 
 = W
  i1
  
 g(W
  i1 t
  
 )
  
 ;
  
 t
 = W
  
 g
 0
 (W
 i1
  
 )
  
  
 where i signifies iteration i, until the criterion function g(W
 i1 t
  
 case
  
  
 m 
  
 g
 0
 (W
 t
 ) = 1 
  
 m + nN(d
 1
 )
  
 where
  
  
  
  
 l
  
  S
 t
 +
  m n
 W
 t
  
 + + 
 1 
  
 2
 (t
  
 d
 1
  =
  
 l
  
 K
  
 + + p T t
  
 2
 (t
  
  
  
 ) is below some given accuracy. In this
  
 An obvious starting value is to set calculate the Black Scholes value using the current stock price, and 
 multiply it with 
 m+n
 .
  
 C
 ++
 Code 10.1 implements this calculation.
  
 Example
  
 A stock is currently priced at S = 48. Consider warrants on the same company with exercise price K = 40 
 and time to maturity of six months. The company has n = 10000 shares outstanding, and has issued m = 
 1000 warrants. The current (continously compounded) risk free interest rate is 8%. Determine the 
 current warrant price.
  
 100",NA
10.3 ,NA,NA
Readings,"McDonald (2013) and Hull (2011) are general references. A problem with warrants is that exercise of all 
 warrants simultaneously is not necessarily optimal.
  
 Press et al. (1992) discusses the Newton-Rhapson method for root finding.
  
 101",NA
Chapter 11,NA,NA
Extending the Black Scholes formula,"Contents 
  
  
 11.1 Adjusting for payouts of the underlying. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 102 
  
  
 11.1.1 Continous Payouts from underlying. . . . . . . . . . . . . . . . . . . . . . . . . 102 
  
  
 11.1.2 Dividends. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 
  
 11.2 American 
 options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 104 
  
  
  
 . . . . . . . . 105 11.2.1 Exact american call formula when stock is paying one dividend.
  
 11.3 Options on futures 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 108 
  
 11.3.1 Black’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
  
  
 11.4 Foreign Currency Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 109
  
 11.5 Perpetual puts and calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 110
  
 11.6 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 111",NA
11.1,NA,NA
Adjusting for payouts of the underlying.,"For options on other financial instruments than stocks, we have to allow for the fact that the underlying 
 may have payouts during the life of the option. For example, in working with commodity options, there is 
 often some storage costs if one wanted to hedge the option by buying the underlying.
  
 11.1.1 
  
 Continous Payouts from underlying.
  
 The simplest case is when the payouts are done continuously. To value an European option, a simple 
 adjustment to the Black Scholes formula is all that is needed. Let q be the
  continuous payout
  of the 
 underlying commodity.
  
 Call and put prices for European options are then given by formula 11.1, which are implemented in 
 C
 ++
 Code 11.1.
  
 Exercise 11.1.
  
 The price of a put on an underlying security with a continous payout of q is:
  
 p = Ke
 r(Tt)
 N(d
 2
 ) Se
 q(Tt)
 N(d
 1
 )
  
 1. Implement this formula.
  
 102",NA
11.2,NA,NA
American options,"American options are much harder to deal with than European ones. The problem is that it may be 
 optimal to use (exercise) the option before the final expiry date. This optimal exercise policy will affect 
 the value of the option, and the exercise policy needs to be known when solving the pde. However, the 
 exercise policy is not known. There is therefore no general analytical solutions for American call and put 
 options. There are some special cases. For American call options on assets that do not have any payouts, 
 the American call price is the same as the European one, since the optimal exercise policy is to not 
 exercise. For American puts this this not the case, it may pay to exercise them early. When the underlying 
 asset has payouts, it may also pay to exercise an American call option early. There is one known known 
 analytical price for American call options, which is the case of a call on a stock that pays a known dividend
  
 once
  during the life of the option, which is discussed next. In all other cases the American price has to be 
 approximated using one of the techniques discussed in later chapters: Binomial approximation, numerical 
 solution of the partial differential equation, or another numerical approximation.
  
 104",NA
11.3 ,NA,NA
Options on futures,"11.3.1 
  
 Black’s model
  
 For an European option written on a futures contract, we use an adjustment of the Black Scholes solution, 
 which was developed in Black (1976). Essentially we replace S
 0
  with e
 r(Tt)r
 F in the Black Scholes formula, 
 and get the formula shown in 11.3 and implemented in C
 ++
 Code 11.4.
  
  
 c = e
 r(Tt)
 (FN(d
 1
 ) KN(d
 2
 )) 
  
 where
  
 l
  
  
  F
  
 + 
 1 2
 ( t
  
 d
 1
  = l
  
 K
  
 + 
 2
 ( t
  
 p T t
  
 p T t
  
 d
 2
  = d
 1
   
 F is the futures price, K is the exercise price, r the risk free interest rate, the volatility of the futures price, 
 and T t is the time to maturity of the option (in years).
  
 Formula 11.3: Black’s formula for the price of an European Call option with a futures contract as the 
 underlying security
  
  
 #include <cmath> 
  
 #include ""normdist.h"" 
 using namespace std;
  
 // mathematics library 
  
 // normal distribution
  
 double futures option price call european black( const double& F,
  // futures price
  
 const double& K, 
  
 const double& r,
  
 // exercise price 
  
 // interest rate
  
 const double& sigma,
  // volatility
  
 double sigma sqr = sigma*sigma;
  
 const double& time){
  // time to maturity
  
  
 double time sqrt = sqrt(time); 
  
  
 double d1 = (log (F/K) + 0.5 * sigma sqr * time) / (sigma * time sqrt); 
  
 double d2 = d1 sigma * time sqrt; 
  
  
 return exp(r*time)*(F * N(d1) K * N(d2)); 
  
 };
  
 C
 ++
 Code 11.4: Price of European Call option on Futures contract
  
 Example
  
 Price a futures option in the Black setting. Information: F = 50, K = 45, r = 8%, = 0:2, and time to maturity is 
 a half year.
  
 C
 ++
 program:
  
 double F = 50.0; double K = 45.0;
  
 double r = 0.08; double sigma = 0.2;
  
 double time=0.5;
  
 cout << "" european futures call option = ""
  
 << futures option price put european black(F,K,r,sigma,time) << endl;
  
 Output from C
 ++
 program:
  
 european futures call option = 0.851476
  
 Exercise 11.3.
  
 108",NA
11.4 ,NA,NA
Foreign Currency Options,"Another relatively simple adjustment of the Black Scholes formula occurs when the underlying security is 
 a currency exchange rate (spot rate). In this case one adjusts the Black-Scholes equation for the interest-
 rate differential.
  
 Let S be the spot exchange rate, and now let r be the domestic interest rate and r
 f
  the foreign interest rate. 
 is then the volatility of changes in the exchange rate. The calculation of the price of an European call 
 option is then shown in formula 11.4 and implented in C
 ++
 Code 11.5.
  
  
 c = Se
 r
 f
  (Tt)
 N(d
 1
 ) Ke
 r(Tt)
 N(d
 2
 ) 
  
 where
  
 l
  
  S
  
 +
  
 r+ 
 1 
  
 2
  
 T
  
 d
 1
  = l
  
 K
  
 +
  
 r
 f
  + 
 2 
 p T t
  
 T
  
  
 d
 2
  = d
 1
   
 p T t
  
  
 S is the spot exchange rate and K the exercise price. r is the domestic interest rate and r
 f
  the foreign interest rate. is the volatility of changes in the 
 exchange rate. T t is the time to maturity for the option.
  
 Formula 11.4: European currency call
  
 #include <cmath> 
  
 #include ""normdist.h"" 
  
 // define the normal distribution function
  
 double currency option price call european( const double& S,
  // exchange rate, 
  
  
 const double& X, 
 // exercise, 
  
  
  
 const double& r, 
 // r domestic, 
  
  
 const double& r f, 
 // r foreign, 
  
  
 const double& sigma,
  // 
 volatility, 
  
  
 const double& time){
  // 
 time to maturity 
  
 double sigma sqr = sigma*sigma; 
  
  
 double time sqrt = sqrt(time); 
  
  
 double d1 = (log(S/X) + (rr f+ (0.5*sigma sqr)) * time)/(sigma*time sqrt); 
  
 double d2 
 = d1 sigma * time sqrt; 
  
  
 return S * exp(r f*time) * N(d1) X * exp(r*time) * N(d2); 
  
 };
  
 C
 ++
 Code 11.5: European Futures Call option on currency
  
 Example
  
 Price a European currency call given the following information S = 50, K = 52, r = 8%, r
 f
  = 5%, = 20% and 
 time to maturity = 0.5 years.
  
 109",NA
11.5 ,NA,NA
Perpetual puts and calls,"A
  perpetal
  option is one with no maturity date, it is inifinitely lived. Of course, only American perpetual 
 options make any sense, European perpetual options would probably be hard to sell.
 1
 For both puts and 
 calls analytical formulas has been developed. We consider the price of an American call, and discuss the 
 put in an exercise. Formula 11.5 gives the analytical solution.
  
  
 p
  
 K
  
 h
 1
  1
  
 S
  
 h
 1
  
   
  
 C=
  
 h
 1
  1
  
 h
 1
  
 K
   
 1
  
 2
  
 + 2r
  
 where
  
 h
 1
  = 1 2 r q
  
 +
  
 +
  
 sr q
  
 2
   
 + 
 2
  
 S is the current price of the underlying security, K is the exercise price, r is the risk free interest rate, q is the dividend yield and is the volatility of the 
 underlying asset.
  
 Formula 11.5: Price for a perpetual call option
  
 #include <cmath> 
  
 using namespace 
 std;
  
 double option price american perpetual call(const double& S, 
  
  
 const double& K, 
  
  
 const double& r, 
  
  
 const double& q, 
  
  
 const double& 
 sigma){ 
  
 double sigma 
 sqr=pow(sigma,2); 
  
  
 double h1 = 0.5 ((rq)/sigma sqr); 
  
  
 h1 += sqrt(pow(((rq)/sigma sqr0.5),2)+2.0*r/sigma sqr); 
  
 double 
 pric=(K/(h11.0))*pow(((h11.0)/h1)*(S/K),h1); 
  
 return pric; 
  
 };
  
 C
 ++
 Code 11.6: Price for an american perpetual call option
  
 1
 Such options would be like the classical April fools present, a perpetual zero coupon bond. . .
  
 110",NA
11.6 ,NA,NA
Readings,"Hull (2011) and McDonald (2013) are general references. A first formulation of an analytical call price 
 with dividends was in Roll (1977b). This had some errors, that were partially corrected in Geske (1979), 
 before Whaley (1981) gave a final, correct formula. See Hull (2011) for a textbook summary. Black (1976) 
 is the original development of the futures option. The original formulations of European foreign currency 
 option prices are in Garman and Kohlhagen (1983) and Grabbe (1983). The price of a perpetual put was 
 first shown in Merton (1973). For a perpetual call see McDonald and Siegel (1986). The notation for 
 perpetual puts and calls follows the summary in (McDonald, 2013, pg. 393).
  
 111",NA
Chapter 12,NA,NA
Option pricing with binomial ,NA,NA
approximations,"Contents
  
 12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 112
  
 12.2 Pricing of options in the Black Scholes setting 
  
 . . . . . . . . . . 
 . . . . . . . . . . . . . . . . 
  
 113
  
 12.2.1 European Options 
 12.2.2 American Options
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . 114
  
  
 12.2.3 Matlab implementation 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 12.3 How good is the binomial 
 approximation? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 119 
  
 12.3.1 Estimating partials. 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 
  
  
  
  
  
 123 12.4 Adjusting for payouts for the underlying 
  
 . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12.5 Pricing options on stocks paying dividends using a binomial approximation . . . . . . . . . . . . 
  
 124 
  
 12.5.1 Checking for early exercise in the binomial model. . . . . . . . . . . . . . . . . 124 
  
 12.5.2 Proportional dividends. 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 
  
 12.5.3 Discrete dividends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
  
  
 12.6 Option on futures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 128
  
 12.7 Foreign Currency options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 130
  
 12.8 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 131",NA
12.1,NA,NA
Introduction,"We have shown binomial calculations given an up and down movement in chapter 8. However, binomial 
 option pricing can also be viewed as an
  approximation
  to a continuous time distribution by judicious 
 choice of the constants u and d. To do so one has to ask: Is it possible to find a parametrization (choice of 
 u and d) of a binomial process",NA
12.2 ,NA,NA
Pricing of options in the Black Scholes setting,NA,NA
12.3 ,NA,NA
How good is the binomial approximation?,"To illustrate the behaviour of the binomial approximation figure 12.1 plots a comparison with the bino-
 mial approximation as a function of n, the number of steps in the binomial approximation, and the true 
 (Black Scholes) value of the option. Note the “sawtooth” pattern, the binomial approximation jumps back 
 and forth around the true value for small values of n, but rapidly moves towards the Black Scholes value 
 as the n increases.
  
 Figure 12.1: Illustrating convergence of binomial to Black Scholes
  
 c
  
  17
  
  
  16.5
  
  16
  
  15.5
  
  15
  
  14.5
  
  14
  
  13.5
  
  0
  
  10
  
  20
  
  30
  
  40
  
  50
  
  60
  
  70
  
  80
  
  90
  
  100
  
 n
  
 binomial 
  
 Black Scholes
  
 119",NA
12.4 ,NA,NA
Adjusting for payouts for the underlying,"The simplest case of a payout is the similar one to the one we saw in the Black Scholes case, a continous 
 payout of y. This y needs to be brought into the binomial framework. Here we use it to adjust the 
 probability:
  
 t = p (T t)=n
  
 u = e
 t
  
 d = 1 
  
 u
  
 p
 u
  =e
 (ry)t
  d 
  
 u d
  
 p
 d
  = 1 p
 u
  
 For example, the last node
  
 C
 0
  = e
 rt
 (p
 u
 C
 u
  + (1 p
 u
 )C
 d
 )
  
  
 #include <cmath> 
  
 #include <algorithm> 
 #include <vector> 
  
 using namespace std;
  
 // standard mathematical library 
  
 // defines the max() operator 
  
 // STL vector templates
  
 double option price call american binomial( const double& S,
  // spot price
  
 double R = exp(r*(t/steps)); 
 double Rinv = 1.0/R;
  
 const double& K,
  
 // exercice price
  
 const double& r,
  
 // interest rate
  
 const double& y,
  
 // continous payout
  
 const double& sigma,
  // volatility
  
 const double& t,
  
 // time to maturity
  
 const int& steps) {
  
 // no steps in binomial tree
  
 // interest rate for each step 
  
 // inverse of interest rate
  
 double u = exp(sigma*sqrt(t/steps));
  // up movement 
  
 double uu = u*u; 
  
 double d = 1.0/u; 
  
 double p up = (exp((ry)*(t/steps))d)/(ud); 
  
 double p down = 1.0p up; 
  
 vector<double> prices(steps+1); 
  
 // price of underlying 
  
 prices[0] = S*pow(d, steps); 
  
 for (int i=1; i<=steps; ++i) prices[i] = uu*prices[i1];
  // fill in the endnodes.
  
 vector<double> call values(steps+1); 
  
 // value of corresponding call 
  
 for (int i=0; i<=steps; ++i) call values[i] = max(0.0, (prices[i]K));
  // call payoffs at maturity
  
  
 for (int step=steps1; step>=0;step) { 
  
  
 for (int i=0; i<=step; ++i) { 
  
    
 call values[i] = (p up*call values[i+1]+p down*call values[i])*Rinv; 
  
   
 prices[i] = d*prices[i+1]; 
  
    
 call values[i] = max(call values[i],prices[i]K); 
  
 // check for exercise 
  
 }; 
  
  
 }; 
  
  
 return call values[0]; 
  
 };
  
 C
 ++
 Code 12.5: Binomial option price with continous payout
  
 123",NA
12.5 ,NA,NA
Pricing options on stocks paying dividends using a binomial ,NA,NA
approximation,"12.5.1 
  
 Checking for early exercise in the binomial model.
  
 If the underlying asset is a stock paying dividends during the maturity of the option, the terms of the 
 option is not adjusted to reflect this cash payment, which means that the option value will reflect the 
 dividend payments.
  
 In the binomial model, the adjustment for dividends depend on whether the dividends are discrete or 
 proportional.
  
 12.5.2 
  
 Proportional dividends.
  
 For proportional dividends, we simply multiply with an adjustment factor the stock prices at the ex–
 dividend date, the nodes in the binomial tree will “link up” again, and we can use the same “rolling 
 back”procedure.
  
 124",NA
12.6,NA,NA
Option on futures,"For American options, because of the feasibility of early exercise, the binomial model is used to approx-
 imate the option value for both puts and calls.
  
 Example 
  
 F = 50:0; K = 45:0; r = 0:08; sigma = 0:2, time=0.5, no steps=100; Price the futures option
  
 C
 ++
 program:
  
 double F = 50.0; 
 double r = 0.08; 
 double time=0.5;
  
 double K = 45.0; 
  
 double sigma = 0.2;
  
   
 int no steps=100; 
  
   
 cout << "" european futures call option = "" 
  
   
  
 << futures option price call american binomial(F,K,r,sigma,time,no steps) << endl; 
 Output 
 from C
 ++
 program: 
  
 european futures call option = 5.74254
  
 128",NA
12.7 ,NA,NA
Foreign Currency options ,"For American options, the usual method is approximation using binomial trees, checking for early exercise 
 due to the interest rate differential.
  
 #include <cmath> 
  
 #include <algorithm> 
  
 #include <vector> 
  
 using namespace std;
  
 double currency option price call american binomial(const double& S, 
  
  
  
  
 const double& K, 
  
  
  
  
 const double& r, 
  
  
  
  
 const double& r f, 
  
  
  
  
 const double& sigma, 
  
  
  
  
 const double& time, 
  
  
  
  
 const int& no steps) { 
  
  
 vector<double> exchange rates(no steps+1); 
  
  
 vector<double> call values(no steps+1); 
  
  
 double t delta= time/no steps; 
  
  
 double Rinv = exp(r*(t delta)); 
  
  
 double u = exp(sigma*sqrt(t delta)); 
  
  
 double d = 1.0/u; 
  
  
 double uu= u*u; 
  
  
 double pUp = (exp((rr f)*t delta)d)/(ud);
  // adjust for foreign int.rate 
  
  
 double pDown = 1.0 pUp; 
  
  
 exchange rates[0] = S*pow(d, no steps); 
  
  
 int i; 
  
  
 for (i=1; i<=no steps; ++i) { 
  
  
  
 exchange rates[i] = uu*exchange rates[i1];
  // terminal tree nodes 
  
  
 } 
  
  
 for (i=0; i<=no steps; ++i) call values[i] = max(0.0, (exchange rates[i]K)); 
  
 for (int step=no 
 steps1; step>=0;step) { 
  
  
  
 for (i=0; i<=step; ++i) { 
  
  
  
  
 exchange rates[i] = d*exchange rates[i+1]; 
  
  
  
  
 call values[i] = (pDown*call values[i]+pUp*call values[i+1])*Rinv; 
  
  
  
  
 call values[i] = max(call values[i], exchange rates[i]K);
  // check for exercise 
  
  
 }; 
  
  
 }; 
  
  
 return call values[0]; 
  
 };
  
 C
 ++
 Code 12.9: Pricing an american call on an option on currency using a binomial approximation
  
 Example 
  
 Price a futures currency option with the following information: S = 50; K = 52; r = 0:08; r
 f
  = 0:05;  = 0:2, 
 time=0.5, number of steps = 100.
  
 C
 ++
 program:
  
 double S = 50.0; 
  
 double K = 52.0; 
  
 double r = 0.08; 
  
 double rf=0.05; 
  
 double sigma = 0.2; double time=0.5; 
  
 int no steps = 100; 
  
 cout << "" european currency option call = "" 
  
  
 << currency option price call american binomial(S,K,r,rf,sigma,time,no steps) << endl;
  
 Output from C
 ++
 program:
  
 european currency option call = 2.23129
  
 130",NA
12.8 ,NA,NA
References,"The original source for binomial option pricing was the paper by Cox et al. (1979). Textbook discussions
  
 are in Cox and Rubinstein (1985), Bossaerts and Ødegaard (2001) and Hull (2011).
  
 131",NA
Chapter 13,NA,NA
Finite Differences,"Contents
  
  
 13.1 Explicit Finite differences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 132
  
 13.2 European 
 Options.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 132
  
 13.3 American 
 Options.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 134
  
 13.4 Implicit finite 
 differences
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 137
  
 13.5 An example matrix 
 class
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 137
  
 13.6 Finite Differences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 137
  
 13.7 American Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 137
  
 13.8 European Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 140
  
 13.9 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 141",NA
13.1,NA,NA
Explicit Finite differences,"The method of choice for any engineer given a differential equation to solve is to numerically 
 approximate it using a finite difference scheme, which is to approximate the continous differential 
 equation with a discrete
  difference
  equation, and solve this difference equation.",NA
13.2 ,NA,NA
European Options.,"For European options we do not need to use the finite difference scheme, but we show how one would 
 find the european price for comparison purposes. We show the case of an explicit finite difference scheme 
 in C
 ++
 Code 13.1. A problem with the explicit version is that it may not converge for certain combinations 
 of inputs.
  
 132",NA
13.3 ,NA,NA
American Options.,"We now compare the American versions of the same algoritms, the only difference being the check for
  
 exercise at each point. C
 ++
 Code 13.2 shows the C
 ++
 code for an american put option and Matlab Code 13.1
  
 shows the same implemented in Matlab.
  
 #include <cmath> 
  
 #include <algorithm> 
  
 #include <vector> 
  
 using namespace std;
  
 double option price put american finite diff explicit( const double& S, 
  
  
  
 const double& K, 
  
  
 const double& r, 
  
  
  
 const double& sigma, 
  
  
 const double& time, 
  
  
 const int& no S steps, 
  
  
 const int& no t steps) { 
  
 double sigma sqr = sigma*sigma; 
  
  
 int M=no S steps+(no S steps%2);
  // need no S steps to be even: 
  
 double delta 
 S = 2.0*S/M; 
  
  
 vector<double> S values(M+1); 
  
  
 for (int m=0;m<=M;m++) { S values[m] = m*delta S; }; 
  
  
 int N=no t steps; 
  
  
 double delta t = time/N;
  
  
 vector<double> a(M); 
  
  
 vector<double> b(M); 
  
  
 vector<double> c(M); 
  
  
 double r1=1.0/(1.0+r*delta t); 
  
  
 double r2=delta t/(1.0+r*delta t); 
  
  
 for (int j=1;j<M;j++){ 
  
  
  
 a[j] = r2*0.5*j*(r+sigma sqr*j); 
  
  
  
 b[j] = r1*(1.0sigma sqr*j*j*delta t); 
  
  
  
 c[j] = r2*0.5*j*(r+sigma sqr*j); 
  
  
 }; 
  
  
 vector<double> f next(M+1); 
  
  
 for (int m=0;m<=M;++m) { f next[m]=max(0.0,KS values[m]); }; 
  
 vector<double> f(M+1); 
  
  
 for (int t=N1;t>=0;t) { 
  
  
  
 f[0]=K; 
  
  
  
 for (int m=1;m<M;++m) { 
  
  
  
  
 f[m]=a[m]*f next[m1]+b[m]*f next[m]+c[m]*f next[m+1]; 
  
  
  
 f[m] = max(f[m],KS values[m]);
  // check for exercise 
   
 }; 
  
  
  
 f[M] = 0; 
  
  
  
 for (int m=0;m<=M;++m) { f next[m] = f[m]; }; 
  
  
 }; 
  
  
 return f[M/2]; 
  
 };
  
 C
 ++
 Code 13.2: Explicit finite differences calculation of american put option
  
 134",NA
13.4 ,NA,NA
Implicit finite differences,"What really distinguishes C
 ++
 from standard C is the ability to
  extend
  the language by creating classes
  
 and collecting these classes into libraries. A library is a collection of classes and routines for one particular
  
 purpose. We have already seen this idea when creating the date and term_structure classes. However,
  
 one should not necessarily always go ahead and create such classes from scratch. It is just as well to use
  
 somebody else’s class, as long as it is correct and well documented and fulfills a particular purpose.",NA
13.5 ,NA,NA
An example matrix class,Use Newmat as an example matrix class.,NA
13.6 ,NA,NA
Finite Differences,"We use the case of implicit finite difference calculations to illustrate matrix calculations in action.
  
 The method of choice for any engineer given a differential equation to solve is to numerically approximate
  
 it using a finite difference scheme, which is to approximate the continous differential equation with a
  
 discrete
  difference
  equation, and solve this difference equation.
  
 In the following we implement
  implicit finite differences
 . Explicit finite differences was discussed earlier,
  
 we postponed the implicit case to now because it is much simplified by a matrix library.",NA
13.7 ,NA,NA
American Options,"Let us first look at how this pricing is implemented in Matlab. Matlab Code 13.2 shows the implementa-
  
 tion. Implementation of the same calculation in C
 ++
 Code 13.3 using the Newmat library and C
 ++
 Code 13.4
  
 using IT++.
  
 function P = findiff imp am put(S,K,r,sigma,time,no S steps,no t steps) 
  
  
 sigma sqr = sigma^2; 
  
  
  
 M=no S steps + rem(no S steps,2); # need no S steps to be even: 
  
  
 delta S = 2.0*S/double(M); 
  
  
  
 S values = delta S* (1:M+1)’; 
  
  
  
 N=no t steps; 
  
  
  
 delta t = time/N; 
  
  
  
 A = zeros(M+1,M+1); 
  
  
  
 A(1,1)=1.0; 
  
  
  
 for j=2:M 
  
  
  
 A(j,j1) = 0.5*j*delta t*(rsigma sqr*j); 
  
  
  
 A(j,j) = 1.0 + delta t*(r+sigma sqr*j*j); 
  
  
  
 A(j,j+1) = 0.5*j*delta t*(rsigma sqr*j); 
  
  
 endfor 
  
  
 A(M+1,M+1)=1.0; 
  
  
 B = max(0,KS values); 
  
  
 F = inv(A)*B;
  
 for
  
 t=N1:1:1 
  
 B = F;
  
   
 F = inv(A)*B; 
  
   
 F=max(F,KS values); 
  
   
 endfor 
  
  
 P= F(M/2); 
  
 endfunction
  
 Matlab Code 13.2: Calculation of price of American put using implicit finite differences
  
 137",NA
13.8 ,NA,NA
European Options,"For European options we do not need to use the finite difference scheme, but for comparison purposes
  
 C
 ++
 Code 13.5 show how one would find the European price.
  
 #include <cmath> 
  
 #include ""newmat.h""
  // definitions for newmat matrix library 
  
 using namespace NEWMAT;
  
 #include <vector>
  // standard STL vector template 
  
 #include <algorithm> 
  
 using namespace std;
  
 double option price put european finite diff implicit(const double& S, const double& 
 K, const double& r, const 
 double& sigma, const 
 double& time, const int& 
 no S steps,
  
 double sigma sqr = sigma*sigma;
  
 const int& no t steps) {
  
 int M=no S steps + (no S steps%2);
  // need no S steps to be even: 
  
 // 
  
 int M=no S steps; if ((no S steps%2)==1) { ++M; }; // need no S steps to be even: 
 double delta S = 
 2.0*S/M; 
  
 vector<double> S values(M+1); 
  
 for (int m=0;m<=M;m++) { S values[m] = m*delta S; }; 
  
 int N=no t steps; 
  
 double delta t = time/N;
  
  
 BandMatrix A(M+1,1,1); A=0.0; 
  
  
 A.element(0,0) = 1.0; 
  
  
 for (int j=1;j<M;++j) { 
  
  
  
 A.element(j,j1) = 0.5*j*delta t*(rsigma sqr*j);
  // a[j] 
  
  
  
 A.element(j,j) = 1.0 + delta t*(r+sigma sqr*j*j);
  // b[j]; 
  
  
  
 A.element(j,j+1) = 0.5*j*delta t*(rsigma sqr*j);
  // c[j]; 
  
  
 }; 
  
  
 A.element(M,M)=1.0; 
  
  
 ColumnVector B(M+1); 
  
  
 for (int m=0;m<=M;++m){ B.element(m) = max(0.0,KS values[m]); }; 
  
 ColumnVector F=A.i()*B; 
  
  
 for(int t=N1;t>0;t) { 
  
  
  
 B = F; 
  
  
  
 F = A.i()*B; 
  
  
 }; 
  
  
 return F.element(M/2); 
  
 };
  
 C
 ++
 Code 13.5: Calculation of price of European put using implicit finite differences
  
 140",NA
13.9 ,NA,NA
References,"Hull (2011). See the natbib documentation.
  
 141",NA
Chapter 14,NA,NA
Option pricing by simulation,"Contents 
  
  
 14.1 Simulating lognormally distributed random variables . . . . . . . . . . . . . . . . . . . . . . . . 
  
 143 
  
 14.2 Pricing of European Call options 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 143 
  
 14.3 Hedge parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 144 
  
 14.4 More general payoffs. Function prototypes 
  
 . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . 
  
 146 
  
 14.5 Improving the efficiency in simulation . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . 
  
 147 
  
  
 14.5.1 Control variates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 
  
  
 14.5.2 Antithetic variates. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
  
 14.6 More exotic options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 151 
  
 152
  
 14.7 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 We now consider using Monte Carlo methods to estimate the price of an European option, and let us first 
 consider the case of the “usual” European Call, which can priced by the Black Scholes equation. Since 
 there is already a closed form solution for this case, it is not really necessary to use simulations, but we 
 use the case of the standard call for illustrative purposes.
  
 At maturity, a call option is worth
  
 c
 T
  = max(0; S
 T
  X)
  
 At an earlier date t, the option value will be the expected present value of this.
  
 c
 t
  = E[PV (max(0; S
 T
  X)]
  
 Now, an important simplifying feature of option pricing is the “risk neutral result,” which implies that we 
 can treat the (suitably transformed) problem as the decision of a risk neutral decision maker, if we also 
 modify the expected return of the underlying asset such that this earns the risk free rate.
  
 c
 t
  = e
 r(Tt)
 E[max(0; S
 T
  X)];
  
 where E[] is a transformation of the original expectation. One way to estimate the value of the call is to 
 simulate a large number of sample values of S
 T
  according to the assumed price process, and find the 
 estimated call price as the average of the simulated values. By appealing to a law of large numbers, this 
 average will converge to the actual call value, where the rate of convergence will depend on how many 
 simulations we perform.
  
 142",NA
14.1 ,NA,NA
Simulating lognormally distributed random variables,"Lognormal variables are simulated as follows. Let ~x be normally distributed with mean zero and variance
  
 one. If S
 t
  follows a lognormal distribution, then the one-period-later price S
 t+1
  is simulated as
  
 S
 t+1
  = S
 t
 e(
 r
  1 22
 )
 +~x
 ;
  
 or more generally, if the current time is t and terminal date is T, with a time between t and T of (Tt),
  
 S
 T
  = S
 t
 e(
 r
  1 22
 )
 (Tt)+pTt~x
  
 Simulation of lognormal random variables is illustrated by C
 ++
 Code 14.1.
  
 #include <cmath> 
  
 using namespace std; 
  
 #include ""normdist.h""
  
 double simulate lognormal random variable(const double& S,
  // current value of variable 
  
  
 const double& r,
  // interest rate 
  
   
 const double& sigma,
  // volatitily 
  
   
 const double& time) {
  // time to final date 
  
 double R = (r 0.5 * pow(sigma,2) )*time; 
  
  
 double SD = sigma * sqrt(time); 
  
  
 return S * exp(R + SD * random normal()); 
  
 };
  
 C
 ++
 Code 14.1: Simulating a lognormally distributed random variable",NA
14.2 ,NA,NA
Pricing of European Call options,"For the purposes of doing the Monte Carlo estimation of the price of an European call
  
 c
 t
  = e
 r(Tt)
 E[max(0; S
 T
  X)];
  
 note that here one merely need to simulate the terminal price of the underlying, S
 T
  , the price of the
  
 underlying at any time between t and T is not relevant for pricing. We proceed by simulating lognormally
  
 distributed random variables, which gives us a set of observations of the terminal price S
 T
  . If we let
  
 S
 T;1
 ; S
 T;2
 ; S
 T;3
 ; : : : S
 T;n
  denote the n simulated values, we will estimate E[max(0; S
 T
 X)] as the average
  
 of option payoffs at maturity, discounted at the risk free rate.
  
 ^c
 t
  = e
 r(Tt)
  
 n 
  
 X
  
 max (0; S
 T;i
  X) !
  
 C
 ++
 Code 14.2 shows the implementation of a Monte Carlo estimation of an European call option.
  
 Example
  
 Given S = 100, K = 100, r = 0:1, = 0:25, time=1. Use 5000 simulations. Price put and call option using
  
 Black Scholes and simulation.
  
 143",NA
14.3,NA,NA
Hedge parameters,"It is of course, just as in the standard case, desirable to estimate hedge parameters as well as option prices. 
 We will show how one can find an estimate of the option
  delta
 , the first derivative of the call
  
 price with respect to the underlying security:  =
 @c
 t 
 @S
 . To understand how one goes about estimating
  
 this, let us recall that the first derivative of a function f is defined as the limit
  
 0
  
 f(x + h) f(x)
  
 f(x) = lim 
 h!0
  
 h
  
 Thinking of f(S) as the option price formula c
 t
  = f (S; X; r; ; (T t)), we see that we can evaluate the option 
 price at two different values of the underlying, S and S + q, where q is a small quantity, and estimate the 
 option delta as
  
 b =f(S + q) f(S)
  
 144",NA
14.4 ,NA,NA
More general payoffs. Function prototypes,"The above shows the case for a call option. If we want to price other types of options, with different payoffs 
 we could write similar routines for every possible case. 
  
 But this would be wasteful, instead a 
 bit of thought allows us to write option valuations for any kind of option whose payoff depend on the value 
 of the underlying at maturity, only. Let us now move toward a generic routine for pricing derivatives with 
 Monte Carlo. This relies on the ability of C
 ++
 to write subroutines which one call with 
 function prototypes
 , i.e. 
 that in the call to to the subroutine/function one provides a function instead of a variable. Consider pricing 
 of standard European put and call options. At maturity each option only depend on the value of the 
 underlying S
 T
  and the exercise price X through the relations
  
 C
 T
  = max(S
 T
  X; 0)
  
 P
 T
  = max(X S
 T
  ; 0)
  
 C
 ++
 Code 14.4 shows two C
 ++
 functions which calculates this.
  
 #include <algorithm> 
  
 using namespace std;
  
 double payoff call(const double& S, 
  
  
  
 const double& K){ 
  
  
 return max(0.0,SK); 
  
 };
  
 double payoff put (const double& S, 
  
  
  
 const double& K) { 
  
  
 return max(0.0,KS); 
  
 };
  
 C
 ++
 Code 14.4: Payoff call and put options
  
 The interesting part comes when one realises one can write a generic simulation routine to which one 
 provide one of these functions, or some other function describing a payoff which only depends on the 
 price of the underlying and some constant. C
 ++
 Code 14.5 shows how this is done.
  
 #include <cmath> 
  
 using namespace std; 
  
 #include ""fin_recipes.h""
  
 double derivative price simulate european option generic(const double& S, 
  
  
   
 const double& K, 
  
  
   
 const double& r, 
  
  
   
 const double& sigma, 
  
  
   
 const double& time, 
  
  
   
 double payoff(const double& price, const double& X), 
  
   
 const int& no sims) { 
  
  
 double sum payoffs=0; 
  
  
 for (int n=0; n<no sims; n++) { 
  
  
  
 double S T = simulate lognormal random variable(S,r,sigma,time); 
  
  
  
 sum payoffs += payoff(S T,K); 
  
  
 }; 
  
  
 return exp(r*time) * (sum payoffs/no sims); 
  
 };
  
 C
 ++
 Code 14.5: Generic simulation pricing
  
 Note the presence of the line
  
 146",NA
14.5 ,NA,NA
Improving the efficiency in simulation,"There are a number of ways of “improving” the implementation of Monte Carlo estimation such that the 
 estimate is closer to the true value.
  
 14.5.1 
  
 Control variates.
  
 One is the method of control variates. The idea is simple. When one generates the set of terminal values of 
 the underlying security, one can value several derivatives using the same set of terminal values. What if 
 one of the derivatives we value using the terminal values is one which we have an analytical solution to? 
 For example, suppose we calculate the value of an at the money European call option using both the 
 (analytical) Black Scholes formula and Monte Carlo simulation. If it turns out that the Monte Carlo 
 estimate overvalues the option price, we think that this will also be the case for other derivatives valued 
 using the same set of simulated terminal values. We therefore move the estimate of the price of the 
 derivative of interest downwards.
  
 Thus, suppose we want to value an European put and we use the price of an at the money European call 
 as the control variate. Using the same set of simulated terminal values S
 T;i
 , we estimate the two options 
 using Monte Carlo as:
  
 ^p
 t
  = e
 r(Tt)
  
 n 
  
 X
  
 max (0; X S
 T;i
 ) !
  
 147",NA
14.6 ,NA,NA
More exotic options,"These generic routines can also be used to price other options. Any European option that only depends on 
 the terminal value of the price of the underlying security can be valued. Consider the
  binary
  options 
 discussed by e.g. Hull (2011). An
  cash or nothing call
  pays a fixed amount Q if the price of the asset is 
 above the exercise price at maturity, otherwise nothing. An
  asset or nothing call
  pays the price of the asset 
 if the price is above the exercise price at maturity, otherwise nothing. Both of these options are easy to 
 implement using the generic routines above, all that is necesary is to provide the payoff functions as 
 shown in C
 ++
 Code 14.8.
  
 double payoff cash or nothing call(const double& S,
  
 if (S>=K) return 1;
  
 const double& K){
  
  
 return 0; 
  
 };
  
 double payoff asset or nothing call(const double& S, 
  
  
  
 const double& K){ 
  
  
 if (S>=K) return S; 
  
  
 return 0; 
  
 };
  
 C
 ++
 Code 14.8: Payoff binary options
  
 Now, many exotic options are not simply functions of the terminal price of the underlying security, but 
 depend on the evolution of the price from “now” till the terminal date of the option. For example options 
 that depend on the average of the price of the underlying (Asian options). For such cases one will have to 
 simulate the whole path. We will return to these cases in the chapter on pricing of exotic options.
  
 Example
  
 Given S = 100, K = 100, r = 0:1, = 0:25, time=1. Use 5000 simulations. Price cash or nothing option with Q = 
 1.
  
 Price asset or nothing option.
  
 In both cases compare results using control variate and anthitetic methods.
  
 151",NA
14.7 ,NA,NA
References,"Boyle (1977) is a good early source on the use of the Monte Carlo technique for pricing derivatives. 
 Simulation is also covered in Hull (2011).
  
 152",NA
Chapter 15,NA,NA
Pricing American Options – ,NA,NA
Approximations,"Contents
  
 15.1 The Johnson (1983) approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
 3 
  
 15
 6 
  
 15
 9 
  
 16
 2 
  
 16
 5
  
 15.2 An approximation to the American Put due to Geske and Johnson 
 (1984)
  
 . . . . . . . . . . . .
  
 15.3 A quadratic approximation to American prices due to Barone–Adesi and Whaley. . . . . . . . . .
  
 15.4 An alternative approximation to american options due to Bjerksund and Stensland 
 (1993)
  
 . . . .
  
 15.5 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 There has been developed some useful
  approximations
  to various specific options. It is of course Amer-
 ican options that are approximated. We will look at a number of approximations, both for their intrinsic 
 usefulness, but also as examples of different approaches to generating an approximated value. The first 
 we will look at is the Johnson (1983) approximation to an American put. This is a purely empirical 
 approach to estimating the functional forms, with parameters estimated using regressions. The Geske and 
 Johnson (1984) approach is to view the American option as a the limit of a sequence of Bermudan options 
 with increasing number of exercise dates. The American value is found by interpolating forward the 
 Bermudan values. The Barone-Adesi and Whaley (1987) approximation decomposes the American option 
 into two, the European value, and the early exercise premium. The early exercise premium is relatively 
 small, and is easier to approximate. Finally, the Bjerksund and Stensland (1993) is an example of 
 bounding the option value by finding a lower bound on its value. A typical approach to doing so is to 
 specify some (suboptimal) exercise strategy. As soon as the exercise strategy is known, the option is 
 easily valued.
  
 Approximations are useful, but they should be used with caution. Typically, an approximation works well 
 within a range of parameter values, but can go seriously wrong for some unfortunate combination of 
 parameters. The user is well advised to to consider alternative approximations, and at a minimum use the 
 price of the corresponding European option as a “sanity check” in the calculations. (In fact, in several of 
 the following routines values are checked against Black Scholes values.)",NA
15.1 ,NA,NA
The Johnson (1983) approximation,"An early attempt at an analytical approximation to the price of an American put is provided by Johnson 
 (1983). Formula 15.1 provides the details, and C
 ++
 Code 15.1 provides the implementation.
  
 Example
  
 Using the parameters r = 0:125, S = 1:1, X = 1, = 0:5 and time to maturity of one year, calculate the price of 
 an american call using the Johnson (1983) approximation.
  
 153",NA
15.2 ,NA,NA
An approximation to the American Put due to Geske and Johnson ,NA,NA
(1984),"Geske and Johnson (1984) develop an approximation for the American put problem. 
  
 The solution
  
 technique is to view the American put as an sequence of Bermudan options, with the number of exercise
  
 dates increasing. The correct value is the limit of this sequence.
  
 Define P
 i
  to be the price of the put option with i dates of exercise left. P
 1
  is then the price of an
  
 european option, with the one exercise date the expiry date. P
 2
  is the price of an option that can be
  
 exercised twice, once halfway between now and expiry, the other at expiry. Geske-Johnson shows how
  
 these options may be priced, and then develops a sequence of approximate prices that converges to the
  
 correct price. An approximation involving 3 option evaluations is
  
 ^P = P
 3
  + 7 2(P
 3
  P
 2
 ) 1 2(P
 2
  P
 1
 )
  
 To calculate these, first define
  
 d
 1
 (q; ) =
  
 ln
  
 S
  
 +
  
 r +
 1 22
  
 p
  
 ;
  
 d
 2
 (q; ) = d
 1
 p
  
 q
  
 and
  
  
 1
  
  
 1
  
  
 r
  
 2
  
 12
  =
  
 p 2;
  
 13
  =
  
 p 3;
  
 23
  =
  
 r
  
 3
  
 In this notation, P
 1
  is the ordinary (european) Black Scholes value:
  
 P
 1
  = Xe
 rT
 N
 1
 (d
 2
 (X; T)) SN
 1
 (d
 1
 (X; T))
  
 To calculate P
 2
 :
  
 P
 2
  
 =
  
 Xe
 r
  T 2
  N
 1
  
  
 d
 2
  
 S
  T 2
 ; T 2
  
  SN
 1
  
 d
 1
  
 S
  T 2
 ; T 2
   
 T
  
  
  
 T
  
  
 +
  
 Xe
 rT
 N
 2
  
 d
 2
   
 S
  T 2
 ; 
  
 2
  
  
 ;d
 2
 (X; T);
 12
  
  SN
 2
  
 d
 1
  
 S
  T 2
 ; 
  
 2
  
  
 ;d
 1
  (X; T) ;
 12
  
 and S
  T 2
 solves
  
 S = X p
  
 S; X; T 2; r; 
  
 = S
  T 
  
 2
  
 To calculate P
 3
 :
  
 P
 3
  
 =
  
 Xe
 r
  T 3
  N
 1
  
 d
 2
  
 S
  T 3
 ; T 
 3
  
  SN
 1
  
 d
 1
  
 S
  T 3
 ; T 3
  
 Xe
 r
  2T 3
  N
 2
  
 d
 2
  
 S
  T 3
 ; T 3
  
 ;d
 2
  
 S
  2T 3
 ; 2T 3
   
  
 +
  
 ;
 12
  
 SN
 2
  
 d
 1
  
 S
  T 3
 ; T 
 3
  
 ;d
 1
  
 S
  2T 3
 ; 2T 
 3
  
 ;
 12
  
  
 +
  
 Xe
 rT
 N
 3
  
 d
 1
  
 S
  T 3
 ; T 3
  
 ; d
 1
  
 S
  2T 3
 ; 2T 3
  
 ;d
 1
 (X; T);
 12
 ;
 13
 ;
 23
  
 SN
 3
  
 d
 2
  
 S
  T 3
 ; T 
 3
  
 ; d
 2
  
 S
  2T 3
 ; 2T 3
  
 ;d
 2
 (X; T);
 12
 ;
 13
 ;
 23
  
 156",NA
15.3 ,NA,NA
A quadratic approximation to American prices due to Barone–Adesi ,NA,NA
and ,NA,NA
Whaley.,"We now discuss an approximation to the option price of an American option on a commodity, described 
 in Barone-Adesi and Whaley (1987) (BAW).
 1
 The commodity is assumed to have a continuous payout b. 
 The starting point for the approximation is the (Black-Scholes) stochastic differential equation valid for 
 the value of any derivative with price V .
  
 1 
  
 2
 2
 S
 2
 V
 S
 S + bSV
 S
  rV + V
 t
  = 0
  
 (15.1)
  
 Here V is the (unknown) formula that determines the price of the contingent claim. For an European 
 option the value of V has a known solution, the adjusted Black Scholes formula. For American options, 
 which may be exercised early, there is no known analytical solution.
  
 To do their approximation, BAW decomposes the American price into the European price and the early 
 exercise premium
  
 C(S; T) = c(S; T) + ""
 C
 (S; T)
  
 Here ""
 C
  is the early exercise premium. The insight used by BAW is that ""
 C
  must
  also
  satisfy the same 
 partial differential equation. To come up with an approximation BAW transformed equation (15.1) into 
 one where the terms involving V
 t
  are neglible, removed these, and ended up with a standard linear 
 homeogenous second order equation, which has a known solution.
  
 The functional form of the approximation is shown in formula 15.2.
  
  
  c(S; T) + A
 2
  
  S
  
 q
 2
  
 if
  
 S < S
  
 C(S; T) =
  
 where
  
 S
   
  
 S X
  
 if
  
 S S
  
 (N 1) +
  
 r (N 1)
 2
 + 4M
  
 K
  
 !
  
 q
 2
  = 1 
  
 2
  
 A
 2
  =S 
  
 q
 2
  
 1 e
 (br)(Tt)
 N (d
 1
 (S))
  
 M = 2r 
 2
  ; N = 2b 
 2
  ; K(T) = 1 e
 r(Tt)
  
 and Ssolves
  
 S X = c (S; T) +S 
  
 q
 2
  
 1 e
 (br)(Tt)
 N (d
 1
 (S))
  
 Notation: S Stock price. X: Exercise price.
  
 Formula 15.2: The functional form of the Barone Adesi Whaley approximation to the value of an American 
 call
  
 In implementing this formula, the only problem is finding the critical value S. This is the classical problem 
 of finding a root of the equation
  
 g(S) = S X c(S)S 
  
 q
 2
  
 1 e
 (br)(Tt)
 N (d
 1
 (S))
  
 = 0
  
 1
 The approximation is also discussed in Hull (2011).
  
 159",NA
15.4 ,NA,NA
An alternative approximation to american options due to Bjerksund ,NA,NA
and ,NA,NA
Stensland (1993),"Bjerksund and Stensland (1993) provides an alternative approximation to the price of American options. 
 Their approximation is an example of calculating a lower bound for the option value. 
  
 Their valua-
 tion relies on using an exercise strategy that is known, and although suboptimal, close enough to the 
 (unknown) exercise strategy that the approximated value is
  
 The corresponding put option can be estimated as
  
 P(S; X; T; r; b; ) = C(X; S; T; r b;b; )
  
 162",NA
15.5 ,NA,NA
Readings,"See Broadie and Detemple (1996) for some comparisions of various approximations. A survey of the 
 pricing of options, including American options, is Broadie and Detemple (2004). Barone-Adesi (2005) 
 summarizes the history of approximating the American put.
  
 165",NA
Chapter 16,NA,NA
"Average, lookback and other exotic ",NA,NA
options,"Contents
  
 16.1 Bermudan options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 166
  
 16.2 Asian options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 169
  
 16.3 Lookback options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 170
  
 16.4 Monte Carlo Pricing of options whose payoff depend on the whole price path . . . . . . . . . . .
  
 172
  
 16.4.1 Generating a series of lognormally distributed variables
  
 . . . . . . . . . . . . . 172
  
 16.5 Control variate
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 175
  
 16.6 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 176
  
 We now look at a type of options that has received a lot of attention in later years. The distinguishing 
 factor of these options is that they depend on the
  whole price path
  of the underlying security between 
 today and the option maturity.",NA
16.1 ,NA,NA
Bermudan options,"A Bermudan option is, as the name implies,
 1
 a mix of an European and American option. 
  
 It is a 
 standard put or call option which can only be exercised at discrete dates throughout the life of the option. 
 The simplest way to do the pricing of this is again the binomial approximation, but now, instead of 
 checking at every node whether it is optimal to exercise early, only check at the nodes corresponding to 
 the potential exercise times. C
 ++
 Code 16.1 shows the calculation of the Bermudan price using binomial 
 approximations. The times as which exercise can happen is passed as a vector argument to the routine, 
 and in the binomial a list of which nodes exercise can happen is calculated and checked at every step.
  
 Example
  
 Price a Bermudan put. The following informaton is given S = 80, K = 100 r = 0.20; time = 1; = 0:25, steps = 
 500, q = 0:0, Potential exercise times = 0,25, 0.5 and 0.75.
  
 1
 Since Bermuda is somewhere between America and Europe...
  
 166",NA
16.2 ,NA,NA
Asian options,"The payoff depends on the average of the underlying price. An
  average price call
  has payoff 
  
 C
 T
  = 
 max(0;S X); 
  
 whereS is the average of the underlying in the period between t and T.
  
 Another Asian is the
  average strike call 
  
  
 C
 T
  = max(0; S
 T
 S) 
  
 There are different types of Asians depending on how the averageS is calculated. For the case of S being 
 lognormal and the averageS being a geometric average, there is an analytic formula due to Kemna and
  
 Vorst (1990). Hull (2011) also discusses this case. It turns out that one can calculate this option using the 
 regular Black Scholes formula adjusting the volatility to = p 3 and the dividend yield to
  
 1
  
  q  1 
  
 2
  
 2
  
  q  
  
 6
  
 in the case of continous sampling of the underlying price distribution.
  
 C
 ++
 Code 16.2 shows the calculation of the analytical price of an Asian geometric average price call.
  
 #include <cmath> 
  
 using namespace std; 
  
 #include ""normdist.h""
  // normal distribution definitions
  
 double 
  
 option price asian geometric average price call(const double& S, 
  
 const double& K, 
  
 const double& r, 
  
 const double& q, 
  
 const double& sigma,
  
 double sigma sqr = pow(sigma,2);
  
 const double& time){
  
  
 double adj div yield=0.5*(r+q+sigma sqr/6.0); 
  
  
 double adj sigma=sigma/sqrt(3.0); 
  
  
 double adj sigma sqr = pow(adj sigma,2); 
  
  
 double time sqrt = sqrt(time); 
  
  
 double d1 = (log(S/K) + (radj div yield + 0.5*adj sigma sqr)*time)/(adj sigma*time sqrt); 
  
 double d2 = 
 d1(adj sigma*time sqrt); 
  
  
 double call price = S * exp(adj div yield*time)* N(d1) K * exp(r*time) * N(d2); 
  
 return call price; 
  
 };
  
 C
 ++
 Code 16.2: Analytical price of an Asian geometric average price call
  
 Example 
  
 Relevant parameters: S = 100, K = 100, q = 0, r = 0:06, = 0:25 and time to maturity is one year. Price an 
 Asian geometric average price call.
  
 C
 ++
 program:
  
 double S=100; double K=100; double q=0; 
  
 double r=0.06; double sigma=0.25; double time=1.0; 
  
 cout << "" Analytical geometric average = "" 
  
  
 << option price asian geometric average price call(S,K,r,q,sigma,time) 
  
 << 
 endl;
  
 Output from C
 ++
 program:
  
 Analytical geometric average = 6.74876
  
 169",NA
16.3 ,NA,NA
Lookback options,"The payoff from lookback options depend on the maximum or minimum of the underlying achieved 
 through the period. The payoff from the lookback call is the terminal price of the undelying less the 
 minimum value
  
 C
 T
  = max(0; S
 T
  min 
 2[t;T ]
 S)
  
 For this particular option an analytical solution has been found, due to Goldman, Sosin, and Gatto (1979), 
 which is shown in Formula 16.1 and implemented in C
 ++
 Code 16.3.
  
  
 C = Se
 q(Tt)
 N(a
 1
 ) Se
 q(Tt)
  
 2 
  
 2(r q)N(a
 1
 ) S
 min
 e
 r(Tt)
  
 N(a
 2
 )
  
 2 
  
 2(r q)e
 Y
 1
 N(a3)
  
 a
 1
  =
  
 ln
  
 S
  
 + (r q +
 1 22
 )(T t)
  
 p T t
  
 S
 min
  
  
  
 a
 2
  = a
 1
  
 p T t
  
 a
 3
  =
  
 ln
  
 S
   
 r + q +
 1 22
  
 p T t
  
 (T t)
  
 S
 min
  
 +
  
  
  
 Y
 1
  =
  
 2
  
 r q
 1 22
  
 n
  
 S
  
 2
  
 n
  
 S
 min
  
  
  
  
 2
   
  
  
  
 Formula 16.1: Analytical formula for a lookback call
  
 #include <cmath> 
  
 using namespace std; 
  
 #include ""normdist.h""
  
 double option price european lookback call(const double& S, const 
 double& Smin, const 
 double& r, const 
 double& q, const 
 double& sigma,
  
 if (r==q) return 0;
  
 const double& time){
  
  
 double sigma sqr=sigma*sigma; 
  
  
 double time sqrt = sqrt(time); 
  
  
 double a1 = (log(S/Smin) + (rq+sigma sqr/2.0)*time)/(sigma*time sqrt); 
  
 double a2 = 
 a1sigma*time sqrt; 
  
  
 double a3 = (log(S/Smin) + (r+q+sigma sqr/2.0)*time)/(sigma*time sqrt); 
  
 double Y1 = 
 2.0 * (rqsigma sqr/2.0)*log(S/Smin)/sigma sqr; 
  
  
 return S * exp(q*time)*N(a1) S*exp(q*time)*(sigma sqr/(2.0*(rq)))*N(a1)
  
  Smin * 
 exp(r*time)*(N(a2)(sigma sqr/(2*(rq)))*exp(Y1)*N(a3)); };
  
 C
 ++
 Code 16.3: Price of lookback call option
  
 Example
  
 Parameters S = 100, Smin = S q = 0, r = 0:06, = 0:346, time = 1.0, Price an European lookback call.
  
 170",NA
16.4 ,NA,NA
Monte Carlo Pricing of options whose payoff depend on the whole ,NA,NA
price ,NA,NA
path,"Monte Carlo simulation can be used to price a lot of different options. The limitation is that the options 
 should be European. American options can not be priced by simulation methods. There is (at least) two 
 reasons for this. First, the optimal exercise policy would have to be known. But if the exercise policy was 
 known there would be an analytical solution. Second, approximations using Monte Carlo relies on a law of 
 large numbers. But if some of the sample paths were removed, the LLN would be invalidated.
  
 In chapter 14 we looked at a general simulation case where we wrote a generic routine which we passed 
 a payoff function to, and the payoff function was all that was necessary to define an option value. The 
 payoff function in that case was a function of the
  terminal
  price of the underlying security. The only 
 difference to the previous case is that we now have to generate a price
  sequence
  and write the terminal 
 payoff of the derivative in terms of that, instead of just generating the terminal value of the underlying 
 security from the lognormal assumption.
  
 16.4.1 
  
 Generating a series of lognormally distributed variables
  
 Recall that one will generate lognormally distributed variables as
  
 S
 T
  = S
 t
 e(
 r
  1 22
 )
 (Tt)+pTt~x
  
 where the current time is t and terminal date is T. To simulate a price sequence one splits this period into 
 say N periods, each of length
  
 t =T t 
  
  
 N
  
 -
  
 t
  
 t + t
  
 t + 2t t + 3t
  
 T
  
 Time
  
 Each step in the simulated price sequence is
  
 S
 t+t
  = S
 t
 e(
 r
  1 22
 )
 +
  
 p
  
 t~x
  
 C
 ++
 Code 16.4 shows how one would simulate a sequence of lognormally distributed variables.
  
 This code is then used in the generic routine to do calculations, as shown in C
 ++
 Code 16.5.
  
 To price an option we are then only in need of a definition of a payoff function. We consider a couple of 
 examples. One is the case of an Asian option, shown in C
 ++
 Code 16.6.
 2
  
 Another is the payoff for a lookback, shown in C
 ++
 Code 16.7.
 3
  
 2
 Note the use of the accumulate() function, which is part of the C
 ++
  standard.
  
 3
 Note the use of the min_element() and max_element functions, which are part of the C
 ++
  standard.
  
 172",NA
16.5 ,NA,NA
Control variate,"As discussed in chapter 14, a control variate is a price which we both have an analytical solution of and 
 find the Monte Carlo price of. The differences between these two prices is a measure of the bias in the 
 Monte Carlo estimate, and is used to adjust the Monte Carlo estimate of other derivatives priced using the 
 same random sequence.
  
 C
 ++
 Code 16.8 shows the Black Scholes price used as a control variate. An alternative could have been the 
 analytical lookback
  
 price, or the analytical solution for a geometric average price call shown earlier.
  
 #include ""fin_recipes.h"" 
  
 #include <cmath> 
  
 using namespace std;
  
 double 
  
 derivative price simulate european option generic with control variate(const double& S, 
  
  
  
  
 const double& K, 
  
  
  
  
 const double& r, 
  
  
  
  
 const double& sigma, 
  
  
  
  
 const double& time, 
  
  
  
  
 double payoff(const vector<double>& prices, 
  
  
  
  
 const double& X), 
  
  
  
  
 const int& no steps, 
  
  
  
  
 const int& no sims) { 
  
  
 double c bs = option price call black scholes(S,S,r,sigma,time);
 // price an at the money Black Scholes call 
  
 double 
 sum payoffs=0; 
  
  
 double sum payoffs bs=0; 
  
  
 for (int n=0; n<no sims; n++) { 
  
  
  
 vector<double> prices = simulate lognormally distributed sequence(S,r,sigma,time, no steps); 
  
  
  
 double S1= prices.back(); 
  
  
  
 sum payoffs += payoff(prices,K); 
  
  
  
 sum payoffs bs += payoff call(S1,S);
  // simulate at the money Black Scholes price 
  
  
 }; 
  
  
 double c sim = exp(r*time) * (sum payoffs/no sims); 
  
  
 double c bs sim = exp(r*time) * (sum payoffs bs/no sims); 
  
  
 c sim += (c bsc bs sim); 
  
  
 return c sim; 
  
 };
  
 C
 ++
 Code 16.8: Control Variate
  
 Example
  
 Using the parameters S = 100, K = 120, r = 0:10, time = 1.0 = 0:25, no sims = 10000, no steps = 250, q = 0, 
 price arithmetric and geometric average calls by generic simulation.
  
 175",NA
16.6,NA,NA
References,"Exotic options are covered in Hull (2011). Rubinstein (1993) has an extensive discussion of analytical 
 solutions to various exotic options. Gray and Gray (2001) also looks at some analytical solutions.
  
 176",NA
Chapter 17,NA,NA
Generic binomial pricing,"Contents
  
  
 17.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 177
  
 17.2 Delta calculation
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 182",NA
17.1,NA,NA
Introduction,"In earlier chapters we have seen a large number of different versions of the binomial pricing formula. In 
 this chapter we see how we can build a framework for binomial pricing that lets us write a single generic 
 routine that can be used for a binomial approximation of all sorts of derivatives. The important feature 
 that lets us write such a generic routine is that the only place the terms of the derivative appears in the 
 calculation is the calculation of the value at each node. Consider the binomial approximation of an 
 American call in Chapter 12’s C
 ++
 Code 12.2, repeated below as C
 ++
 Code 17.1 for convenience.
  
 The terms of the derivative only appears when calculating the value at the nodes, where the calculation 
 max(prices[]-K,0) appears. 
  
 The key to building a generic binomial routine lies in replacing this 
 calculation with a generic routine. C
 ++
 Code 17.2 shows how the generic ruotine is implemented.
  
 177",NA
17.2 ,NA,NA
Delta calculation,"Deltas and other greeks are calculated using the same style of generic routine. C
 ++
 Code 17.5 shows how
  
 to calculate delta using the same generic approach.
  
 #include <cmath> 
  
 #include <algorithm> 
  
 #include <vector> 
  
 using namespace std;
  
 double option price delta generic binomial(const double& S, 
  
 const double& K, 
  
 double generic payoff(const double& S, const double& K), 
 const double& r, 
  
 const double& sigma, 
  
 const double& t,
  
 double R = exp(r*(t/no steps));
  
 const int& no steps){
  
 double Rinv = 1.0/R; 
  
 double u = exp(sigma*sqrt(t/no steps)); 
  
 double d = 1.0/u; 
  
 double uu= u*u; 
  
 double pUp = (Rd)/(ud); 
  
 double pDown = 1.0 pUp;
  
 vector<double> prices (no steps+1); 
  
 prices[0] = S*pow(d, no steps); 
  
 for (int i=1; i<=no steps; ++i) prices[i] = uu*prices[i1];
  
 vector<double> values (no steps+1); 
  
 for (int i=0; i<=no steps; ++i) values[i] = generic payoff(prices[i],K);
  
  
 for (int CurrStep=no steps1 ; CurrStep>=1;CurrStep) { 
  
 for (int 
 i=0; i<=CurrStep; ++i) { 
  
    
 prices[i] = d*prices[i+1]; 
  
    
 values[i] = (pDown*values[i]+pUp*values[i+1])*Rinv; 
    
 values[i] = max(values[i], generic payoff(prices[i],K)); 
  
 }; 
  
  
 }; 
  
  
 double delta = (values[1]values[0])/(S*uS*d); 
  
  
 return delta; 
  
 };
  
 C
 ++
 Code 17.5: Generic binomial calculation of delta
  
 Exercise 17.1.
  
 The generic routines discussed in this chapter have been for American options. How would you modify 
 them
  
 to account for European options?
  
 182",NA
Chapter 18 ,NA,NA
Trinomial ,NA,NA
trees,"Contents
  
  
 18.1 Intro
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 183
  
 18.2 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 183
  
 18.3 Further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 185",NA
18.1,NA,NA
Intro,"A trinomial tree is similar to a binomial tree, just with one more branch. At each point of time there
  
 are three possible future values of the underlying S.",NA
18.2,"S
 0
  
 *
  
 S
 u
  = uS
 0
  
 S
 m
  = S
 0
  
 -
 HHHHHHHH",NA
Implementation,"S
 d
  = dS
 0
  
 A trinomial tree can be implemented with various parameterizations. We will show the calulation using
  
 the following parameterization:
  
 u = e
  
 p 3t
  
 e = 1
  
 u
  
  
 r
  
 t
  
 2
  
 1
  
 p
 u
  =
  
 r
  
 12
 2
  
 r q
  
 2
  
  
 + 
  
 6
  
 p
 m
  = 2
  
 3
  
  
 r
  
 t
  
 2
  
 1
  
 p
 u
  =
  
 r
  
 12
 2
  
 r q
  
 2
  
  
 + 
  
  
 6",NA
18.3 ,NA,NA
Further reading,"Hull (2011)
  
 185",NA
Chapter 19,NA,NA
Alternatives to the Black Scholes type ,NA,NA
option formula,"Contents
  
 19.1 Merton’s Jump diffusion model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 186 
  
 188
  
 19.2 Hestons pricing formula for a stochastic volatility 
 model
  
 . . . . . . . . . . . . . . . . . . . . .
  
 A large number of alternative formulations to the Black Scholes analysis has been proposed. Few of them 
 have seen any widespread use, but we will look at some of these alternatives.",NA
19.1 ,NA,NA
Merton’s Jump diffusion model.,"Merton (1976) has proposed a model where in addition to a Brownian Motion term, the price process of 
 the underlying is allowed to have
  jumps
 . The risk of these jumps is assumed to not be priced.
  
 In the following we look at an implementation of a special case of Merton’s model, described in (Hull, 
 1993, pg 454), where the size of the jump has a normal distribution. and are parameters of the jump 
 distribution. The price of an European call option is given in Formula 19.1 and implemented in C
 ++
 Code 
 19.1
  
  
  
 X
  
 e
 0
 (
 0
 )
 n
  
 2
  
 c =
  
 X
  
 n!
  
 C
 BS
 (S; X; r
 n
 ; 
  
 n
 ; T t)
  
 where
  
  = T t
  
 0
 =(1 +)
  
 C
 BS
 () is the Black Scholes formula, and
  
 n
 =
 2
  + n
 2
  
 r
 n
  = r +n ln(1 +)
  
 Formula 19.1: The option pricing formula of the Merton (1976) model
  
 In implementing this formula, we need to terminate the infinite sum at some point. 
  
 But since the
  
 186",NA
19.2 ,NA,NA
Hestons pricing formula for a stochastic volatility model,"Heston (1993) relaxes the Black-Scholes assumption of a constant volatility by introducing a stochastic 
 volatility. He finds exact solutions for European options.
  
 Let S be the stock price and v the volatility. These two variables are assumed to follow joint stochastic 
 processes.
  
 The two processes z
 1
  and z
 2
  have correlation. Rewrite the process for the volatility as
  
  dS(t) = Sdt +
  
 d
  
 p 
  
  
 v(t) =
  
 p v(t)dt + v(t)Sdz
 2
 (t) p v(t)Sdz
 1
 (t)
  
 Let(S; v; t) be the price of volatility risk. Under a constant interest rate r 
  
 dv(t) = ( v(t)) dt + 
  
 p v(t)dz
 2
  
 P(t; T) = e
 r(Tt)
  
 Consider a call option with strike price K. Its price is given by Formula 19.2.
  
 Price of Call option using Hestons formula The option price is 
  
 C(s; v; t) = SP
 1
  KP(t; T)P
 2 
  
 where
  
 1 1
  
  1
  
  
 e
 i ln(K)
 f
 j
 (x; v; T; )
  
  
 P
 j
 (x; v; T; ln(K)) = 2 + 
  
 Z
  
 Re
  
 i
  
 d
  
 f
 j
 (x; v; T; ) = e
 C(;)+D(;)v+ix
  
 C(; ) = ri +a 
 2
  
 (b
 j
  i + d) 2 ln
  
 1 ge
 d
  
 1 g
  
 D(; ) =b
 j
  i + d 
 2
  
  1 e
 d 
  
 1 ge
 d
  
  
 u
 1
  = 1 2;
  
 u
 2
  =1 
  
 2
  
 a =
  
 b
 1
  = + b
 2
  = +
  
 x = ln(S) 
  
 g =b
 j
  i + d 
  
 b
 j
  i d
  
 d = q (i b
 j
 )
 22
 (2u
 j
 i
 2
 )
  
 Notation: S: price of undelying security. K: exercise price.
  
 The implementation of this pricing formula has some instructive C
 ++
 features. First, it illustrates cal-
 culations of of complex variables. Complex numbers is part of the C
 ++
 standard, and are accessed by 
 including the
  
 #include <complex>
  
 188",NA
Chapter 20,NA,NA
"Pricing of bond options, basic models","Contents
  
 20.1 Black Scholes bond option pricing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20.2 Binomial bond 
 option pricing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 191 
  
 193
  
 The area of fixed income securities is one where a lot of work is being done in creating advanced 
 mathematical models for pricing of financial securities, in particular fixed income derivatives. The focus 
 of the modelling in this area is on modelling the term structure of interest rates and its evolution over 
 time, which is then used to price both bonds and fixed income derivatives. However, in some cases one 
 does not need the machinery of term structure modelling which we’ll look at in later chapters, and price 
 derivatives by modelling the evolution of the bond price directly.
  
 Specifically, suppose that the price of a Bond follows a Geometric Brownian Motion process, just like the 
 case we have studied before. This is not a particularly realistic assumption for the long term behaviour of 
 bond prices, since any bond price converges to the bond face value at the maturity of the bond. The 
 Geometric Brownian motion may be OK for the case of short term options on long term bonds.",NA
20.1 ,NA,NA
Black Scholes bond option pricing,"Given the assumed Brownian Motion process, prices of European Bond Options can be found using the 
 usual Black Scholes formula, as shown in C
 ++
 Code 20.1 for a zero coupon bond and C
 ++
 Code 20.2 for the 
 case of an option on a coupon bond.
  
 #include <cmath> 
  
 #include ""normdist.h""
  
 double bond option price put zero black scholes(const double& B, 
  
  
  
 const double& X, 
  
  
  
 const double& r, 
  
  
  
 const double& sigma, 
  
  
  
 const double& time){ 
  
  
 double time sqrt = sqrt(time); 
  
  
 double d1 = (log(B/X)+r*time)/(sigma*time sqrt) + 0.5*sigma*time sqrt; 
  
 double d2 = d1(sigma*time sqrt); 
  
  
 double p = X * exp(r*time) * N(d2) B * N(d1); 
  
  
 return p; 
  
 };
  
 C
 ++
 Code 20.1: Black scholes price for European put option on zero coupon bond
  
 191",NA
20.2 ,NA,NA
Binomial bond option pricing,"Since we are in the case of geometric Brownian motion, the usual binomial approximation can be used to 
 price American options, where the bond is the underlying security. C
 ++
 Code 20.3 shows the calculation of 
 a put price
  
  
 #include <cmath> 
  
 #include <algorithm> 
 #include <vector> 
  
 using namespace std;
  
 // standard mathematical library 
  
  
 // defining the max() operator // STL 
 vector templates
  
 double bond option price put american binomial( const double& B,
  // Bond price 
  
   
   
 const double& K, 
  
 // exercise price 
  
   
   
 const double& r, 
  
 // interest rate 
  
   
   
 const double& sigma,
  // volatility 
  
   
   
 const double& t, 
  
 // time to maturity 
   
   
 const int& steps){
  // no steps in binomial tree 
  
 double R = 
 exp(r*(t/steps)); 
  
  
 // interest rate for each step 
  
  
 double Rinv = 1.0/R; 
  
  
 // inverse of interest rate 
  
  
 double u = exp(sigma*sqrt(t/steps));
  // up movement 
  
  
 double uu = u*u; 
  
  
 double d = 1.0/u; 
  
  
 double p up = (Rd)/(ud); 
  
  
 double p down = 1.0p up; 
  
  
 vector<double> prices(steps+1); 
  
 // price of underlying 
  
  
 vector<double> put values(steps+1);
  // value of corresponding put
  
 prices[0] = B*pow(d, steps);
  // fill in the endnodes.
  
  
 for (int i=1; i<=steps; ++i) prices[i] = uu*prices[i1]; 
  
  
 for (int i=0; i<=steps; ++i) put values[i] = max(0.0, (Kprices[i]));
  // put payoffs at maturity 
  
 for (int 
 step=steps1; step>=0;step) { 
  
  
 for (int i=0; i<=step; ++i) { 
  
    
 put values[i] = (p up*put values[i+1]+p down*put values[i])*Rinv; 
  
    
 prices[i] = d*prices[i+1]; 
  
    
  
 // check for exercise 
 put values[i] = max(put 
 values[i],(Kprices[i])); 
  
  
 }; 
  
  
 }; 
  
  
 return put values[0]; 
  
 };
  
 C
 ++
 Code 20.3: Binomial approximation to american put bond option price
  
 193",NA
Chapter 21,NA,NA
Credit risk,"Contents
  
 21.1 The Merton Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 195 
  
 196
  
 21.2 Issues in implementation
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Option pricing has obvious applications to the pricing of risky bonds.",NA
21.1 ,NA,NA
The Merton Model,"This builds on the Black and Scholes (1973) and Merton (1973) framework to find the value of the debt 
 issued by the firm. The ideas were already in Black and Scholes, who discussed the view of the firm as a 
 call option.
  
 Assume debt structure: There is a single debt issue. Debt is issued as a zero coupon bond. The bond is due 
 on a given date T.
  
 Assuming the firm value V follows the usual Brownian motion proces, debt is found as a closed form 
 solution, similar in structure to the Black Scholes equation for a call option.
  
 Easiest seen from the interpretation of firm debt as the price of risk free debt, minus the value of a put 
 option.
  
 Price debt by the price B of risk free debt, and then subtract the price of the put, using the Black Scholes 
 formula.
  
 The Black Scholes formula for a call option is
  
 c = S N(d
 1
 ) K e
 r(Tt)
 N(d
 2
 )
  
 where
  
  
  S
  
 1
  
 d
 1
  = ln
  
 K
  
 + (r + 
 2
 )(T t)
  
 p T t
  
 p T t
  
 d
 2
  = d
 1
   
 N() = The cumulative normal distribution
  
 p = Ke
 r(Tt)
 N(d
 2
 ) SN(d
 1
 )
  
 In the context here, reinterpret S as V , firm value. The put is priced as
  
 p = Ke
 r(Tt)
 N(d
 2
 ) V
 t
 N(d
 1
 )
  
 195",NA
21.2,NA,NA
Issues in implementation,"Firm value and firm volatility is unobservable.
  
  The model assumes a simple debt structure, most debt structures tend to be more complex.
  
 196",NA
Chapter 22,NA,NA
Term Structure Models,"Contents
  
 22.1 The Nelson Siegel term structure 
 approximation
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
 8 
  
 20
 0 
  
 20
 2 
  
 20
 5 
  
 20
 8 
  
 21
 0
  
 22.2 Extended Nelson Siegel models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.3 Cubic spline.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.4 Cox Ingersoll Ross.
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.5 Vasicek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22.6 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 We now expand on the analysis of the term structure in chapter 5. As shown there, the term structure is 
 best viewed as an abstract class providing, as functions of term to maturity, the prices of zero coupon 
 bonds (discount factors), yield on zero coupon bonds (spot rates) or forward rates. In the earlier case we 
 considered two particular implementations of the term structure: A flat term structure or a term 
 structure estimated by linear interpolations of spot rates. We now consider a number of alternative term 
 structure models. The focus of this chapter is empirical, we consider ways in which on one can specify a 
 term structure in a lower dimensional way. Essentially we are looking at ways of doing curve-fitting, of 
 estimating a nonlinear relationship between time and discount factors, or between time and spot rates. 
 Since the relationship is nonlinear, this is a nontrivial problem. One has to choose a functional form to 
 estimate, which allows enough flexibility to “fit” the term structure, but not so flexible that it violates the 
 economic restrictions on the term structure. Here are some considerations.
  
  Discount factors must be positive. (d
 t
  > 0). This is because they are prices, negative prices allow for 
 abritrage.
  
  Discount factors must be a nonincreasing function of time. (d
 t
  d
 t+k
  8 k > 0). Again, this is to avoid 
 arbitrage.
  
  Nominal interest rates can not be negative. (r
 t
  0 8 t) This is another implication of the absence of 
 arbitrage opportunities.
  
  Both discount factors and interest rates must be smooth functions of time.
  
  The value of a payment today is the payment today. d
 0
  = 1.
  
 A number of alternative ways of estimating the term structure has been considered. Some are purely used 
 as interpolation functions, while others are fully specified, dynamic term structure models. Of the models 
 that follow, the approximating function proposed in Nelson and Siegel (1987) and the cubic spline used 
 by e.g. McCulloch (1971) are examples of the first kind, and the term structure models of Cox, Ingersoll, 
 and Ross (1985) and Vasicek (1977) are examples of the second kind.
  
 197",NA
22.1 ,NA,NA
The Nelson Siegel term structure approximation,"Nelson and Siegel (1987) proposes the parameterization shown in FormulaRefns
  
  
 ""
  
 1 e
  t
  
 #
  
  
  t
  
  
 r(t) =
 0
  + (
 1
  +
 2
 )
  
  
 t
  
  
 +
 2
  
 h e
  
 i
  
 Notation: t: Time to maturity. r spot interest rate,
 0
 ; 
 1
 ; 
 2
  and: constants.
  
 Formula 22.1: Nelson and Siegel (1987) parameterization of term structure
  
 The implementation of this calculation is shown in C
 ++
 Code 22.1.
  
 #include <cmath> 
  
 using namespace 
 std;
  
 double term structure yield nelson siegel(const double& t, 
  
   
 const double& beta0, 
  
   
 const double& beta1, 
  
   
 const double& beta2, 
  
   
 const double& lambda) { 
  
  
 if (t==0.0) return beta0; 
  
  
 double tl = t/lambda; 
  
  
 double r = beta0 + (beta1+beta2) * ((1exp(tl))/tl) + beta2 * exp(tl); 
  
 return r; 
  
 };
  
 C
 ++
 Code 22.1: Calculation of the Nelson and Siegel (1987) term structure model
  
 This is wrapped in a term structure
  class
  as shown in Header File 22.1 and C
 ++
 Code 22.2.
  
 class term structure class nelson siegel : public term structure class { 
 private: 
  
  
 double beta0 , beta1 , beta2 , lambda ; 
  
 public: 
  
  
 term structure class nelson siegel(const double& beta0, 
  
  
  
 const double& beta1, 
  
  
  
 const double& beta2, 
  
  
  
 const double& lambda); 
  
  
 virtual double yield(const double& T) const; 
  
 };
  
 Header file 22.1: Header file defining a term structure class wrapper for the Nelson Siegel approximation
  
 198",NA
22.2,NA,NA
Extended Nelson Siegel models,"The Nelson and Siegel (1987) model is simple, with parameters with clear obvious economic interpre-
 tations. It does have the problem that the term structure shapes that it allows is limited. To allow for 
 more complex shapes, such as humped shapes, it has been extended in various ways. A popular 
 approximation was introduced by Lars Svensson, parameterized as shown in Formula 22.2
  
  
 1 e
  t 1
  
 !
  
  
 1 e
  t 1
  
  t
  
 !
  
  
 1 e
  t 2
  
  t
  
 !
  
 r(t) =
 0
  +
 1
  
 t
  
 !
  
 +
 2
  
 t
  
  e 
  
 1
  
 !
  
 +
 3
  
 t
  
  e 
  
 2
   
  
  
 !
  
  
 1
  
  
 !
  
  
 2
  
  
  
 Notation: t: Time to maturity. r spot interest rate,
 0
 ; 
 1
 ; 
 2
  and: constants.
  
 Formula 22.2: Svensson’s extension of the Nelson and Siegel (1987) parameterization of term structure
  
 This is wrapped in a term structure class as shown in Header File 22.2 and C
 ++
 Code 22.4.
  
 200",NA
22.3 ,NA,NA
Cubic spline.,"Cubic splines are well known for their good interpolation behaviour. The cubic spline parameterization 
 was first used by McCulloch (1971) to estimate the nominal term structure. He later added taxes in 
 McCulloch (1975). The cubic spline was also used by Litzenberger and Rolfo (1984). In this case the qubic 
 spline is used to approximate the
  discount factor
 , not the yields.
  
 d(t) = 1 + b
 1
 t + c
 1
 t
 2
 + d
 1
 t
 3
 +
  
 K 
  
 X
  
 F
 j
 (t t
 j
 )
 3
 1
 ft<t
 j
 g
  
 Here 1
 fAg
  is the indicator function for an event A, and we have K
  knots
 . To 
 estimate this we need to find the 3 + K parameters:
  
 fb
 1
 ; c
 1
 ; d
 1
 ; F
 1
 ; ; F
 K
 g
  
 If the spline
  knots
  are known, this is a simple linear regression. C
 ++
 Code 22.5 shows the calculation using 
 this approximation.
  
 #include 
 <cmath> 
  
 #include 
 <vector> 
  
 using 
 namespace 
 std;
  
 double term structure discount factor cubic spline(const double& t, 
  
  
  
  
 const double& b1, 
  
  
  
  
 const double& c1, 
  
  
  
  
 const double& d1, 
  
  
  
  
 const vector<double>& f, 
  
  
  
 const vector<double>& knots){ 
  
 double d = 1.0 + b1*t + 
 c1*(pow(t,2)) + d1*(pow(t,3)); 
  
  
 for (int i=0;i<knots.size();i++) { 
  
  
  
 if (t >= knots[i]) { d += f[i] * (pow((tknots[i]),3)); } 
  
  
  
 else { break; }; 
  
  
 }; 
  
  
 return d; 
  
 };
  
 C
 ++
 Code 22.5: Approximating a discount function using a cubic spline
  
 Header File 22.3 and C
 ++
 Code 22.6 wraps this calculations into a term structure class.
  
 #include ""fin_recipes.h"" 
  
 #include <vector> 
  
 using namespace std;
  
 class term structure class cubic spline : public term structure class { 
  
 private: 
  
  
 double b ; double c ; double d ; 
  
  
 vector<double> f ; vector<double> knots ; 
  
 public: 
  
  
 term structure class cubic spline(const double& b, const double& c, const double& d, 
  
  
 const vector<double>& f, const vector<double> & knots); 
  
 virtual ˜term structure class cubic 
 spline(); 
  
  
 virtual double d(const double& T) const; 
  
 };
  
 Header file 22.3: Term structure class wrapping the cubic spline approximation
  
 202",NA
22.4 ,NA,NA
Cox Ingersoll Ross.,"The Cox et al. (1985) model is the best known example of a continuous time, general equilibrium model of 
 the term structure. It is commonly used in academic work because it is a general equilibrium model that 
 still is “simple enough” to let us find closed form expressions for derivative securities.
  
 The short interest rate.
  
 dr(t) =( r(t))dt + p r(t)dW
  
 The discount factor for a payment at time T.
  
 d(t; T) = A(t; T)e
 B(t;T )r(t)
  
 where
  
  = p ( +)
 2
 + 2
 2
  
 A(t; T) = "" ( + +)(e
 (Tt)
  1) + 2 2 
 e 
 2
 (++)(Tt)
  
 1
  
 #
 2
  
 2
  
 and
  
  
 2e
 (Tt)
  1
  
 B(t; T) =
  
 ( + +)(e
 (Tt)
  1) + 2
  
 Five parameters: r, the short term interest rate,, the mean reversion parameter,, the “market” risk 
 parameter, the long–run mean of the process and, the variance rate of the process.
  
 #include <cmath> 
  
 using namespace 
 std;
  
 double term structure discount factor cir(const double& t, 
  
 const double& r, 
  
 const double& kappa, 
 const double& lambda, 
 const double& theta,
  
 double sigma sqr=pow(sigma,2);
  
 const double& sigma){
  
  
 double gamma = sqrt(pow((kappa+lambda),2)+2.0*sigma sqr); 
  
  
 double denum = (gamma+kappa+lambda)*(exp(gamma*t)1)+2*gamma; 
  
 double p=2*kappa*theta/sigma sqr; 
  
  
 double enum1= 2*gamma*exp(0.5*(kappa+lambda+gamma)*t); 
  
  
 double A = pow((enum1/denum),p); 
  
  
 double B = (2*(exp(gamma*t)1))/denum; 
  
  
 double dfact=A*exp(B*r); 
  
  
 return dfact; 
  
 };
  
 C
 ++
 Code 22.7: Calculation of the discount factor using the Cox et al. (1985) model
  
 205",NA
22.5,NA,NA
Vasicek,"#include <cmath> 
  
 using namespace 
 std;
  
 double term structure discount factor vasicek(const double& time, 
  
  
  
  
 const double& r, 
  
  
  
  
 const double& a, 
  
  
  
  
 const double& b, 
  
  
  
  
 const double& sigma){ 
  
  
 double A,B; 
  
  
 double sigma sqr = sigma*sigma; 
  
  
 double aa = a*a; 
  
  
 if (a==0.0){ 
  
  
  
 B = time; 
  
  
  
 A = exp(sigma sqr*pow(time,3))/6.0; 
  
  
 } 
  
  
 else { 
  
  
  
 B = (1.0 exp(a*time))/a; 
  
  
  
 A = exp( ((Btime)*(aa*b0.5*sigma sqr))/aa((sigma sqr*B*B)/(4*a))); 
  
 }; 
  
  
 double dfact = A*exp(B*r); 
  
  
 return dfact; 
  
 }
  
 C
 ++
 Code 22.9: Calculating a discount factor using the Vasicek functional form
  
 #include ""fin_recipes.h""
  
 class term structure class vasicek : public term structure class { 
  
 private: 
  
  
 double r ; double a ; double b ; double sigma ; 
  
 public: 
  
  
 term structure class vasicek(const double& r, const double& a, const double& b, const double& sigma); 
  
 virtual double discount factor(const double& T) const; 
  
 };
  
 Header file 22.5: Class definition, Vasicek (1977) model
  
 208",NA
22.6,NA,NA
Readings,"The methods in this chapter I first studied in my dissertation at Carnegie Mellon University in 1992, 
 which lead to the paper published as Green and Ødegaard (1997). A textbook treatment of estimation and 
 fitting of term structure models can be found in (Martinelli, Priaulet, and Priaulet, 2003, Ch 4)
  
 210",NA
Chapter 23,NA,NA
Binomial Term Structure models,"Contents
  
 23.1 The Rendleman and Bartter model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 211 
  
 213
  
 23.2 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Pricing bond options with the Black Scholes model, or its binomial approximation, as done in chapter 20, 
 does not always get it right. For example, it ignores the fact that at the maturity of the bond, the bond 
 volatility is zero. The bond volatility decreases as one gets closer to the bond maturity. This behaviour is 
 not captured by the assumptions underlying the Black Scholes assumption. We therefore look at more 
 complicated term structure models, the unifying theme of which is that they are built by building
  trees 
 of 
 the interest rate.",NA
23.1 ,NA,NA
The Rendleman and Bartter model,"The Rendleman and Bartter approach to valuation of interest rate contingent claims (see Rendleman and 
 Bartter (1979) and Rendleman and Bartter (1980)) is a particular simple one. Essentially, it is to apply 
 the same binomial approach that is used to approximate options in the Black Scholes world, but the 
 random variable is now the interest rate. This has implications for multiperiod discounting: Taking the 
 present value is now a matter of choosing the correct sequence of spot rates, and it may be necessary to 
 keep track of the whole “tree” of interest rates. Such a tree can then be used to price various fixed income 
 securities. In the next chapter we illustrate this more generally, here we show a direct implementation of 
 the original model. C
 ++
 Code 23.1 implements the original algorithm for a call option on a (long maturity) 
 zero coupon bond.
  
 211",NA
23.2,NA,NA
Readings,"General references include Sundaresan (2001).
  
 Rendleman and Bartter (1979) and Rendleman and Bartter (1980) are the original references for building 
 standard binomial interest rate trees.
  
 213",NA
Chapter 24,NA,NA
Interest rate trees,"Contents
  
 24.1 The movement of interest rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24.2 Discount factors . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24.3 Pricing bonds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . 24.4 Callable bond . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 21
 4 
  
 21
 6 
  
 21
 6 
  
 21
 8 
  
 22
 0
  
 24.5 Readings
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 In this chapter we show a way of building interest rate trees and apply it to the pricing of various fixed 
 income securities. The first need in such a procedure is to specify the future evolution of interest rates.",NA
24.1 ,NA,NA
The movement of interest rates,"We will assume that interest rates follow a Geometric Brownian Motion process
  
 dr = rdt + rdZ
  
 This is the same assumption which was used for stock prices in the Black Scholes case. This leads to the 
 same binomial approximation, for one period:
  
 r
 0
  
 *
  
 r
 u
  
 HHHHH
  
 r
 d
  
 or several periods:
  
 214",NA
24.2,NA,NA
Discount factors,"We want to price bonds and other fixed income securities, which contains sets of future cash flows. 
 Instead of interest rates we need prices, not interest rates, i.e. discount factors. The interest rate tree 
 therefore needs to be used to generate discount factors, which needs to be specified at every point of the 
 tree, and for all relevant maturities. Let d(t; T) be the discount factor at time t for a time T payment.
  
 If we at time 0 want to price cash flows at time 2, we need the following set of discount factors
  
 * 
  
 d
 u
 (1; 2)
  
 HHHHHHHH d
 d
 (1; 2)
  
 In constructing trees of discount we need one additional piece of information, q, which are used as 
 follows:
  
 d(0; 2) = e
 r
 0
 (qd
 u
 (1; 2) + (1 + q)d
 d
 (1; 2))
  
 The parameter q serves the same purpose as the state price probability, but it is found differently.
  
 Exercise 24.1.
  
 Given the prices of two discount bonds, with maturities 1 and 2, how would you back out q?
  
 Exercise 24.2.
  
 Suppose you have q and the tree of short interest rates. How would you calculate the t-period spot rate?",NA
24.3 ,NA,NA
Pricing bonds,"Pricing straight bonds is then just a matter of the usual recursive valuation
  
 Example
  
 Parameters: r
 0
  10%, u = 1:02, d = 0:99. Let q = 0:5. Determine the price of a 3 period coupon bond with 
 coupon of 10 and face value of 100.
  
 216",NA
24.4 ,NA,NA
Callable bond ,"A slightly more involved example is a callable bond.
  
 #include 
 <vector> 
  
 #include 
 <cmath> 
  
 using 
 namespace 
 std;
  
 double interest rate trees gbm value of callable bond(const vector<double>& cflows, 
  
  
  
  
  
 const vector< vector<double> >& r tree, 
  
  
  
  
 const double& q, 
  
  
  
  
  
 const int& first call time, 
  
  
  
  
  
 const double& call price){ 
  
  
 int n = int(cflows.size()); 
  
  
 vector< vector<double> > values(n); 
  
  
 vector<double> value(n); 
  
  
 for (int i=0;i<n;i++){ value[i]=cflows[n1]; }; 
  
  
 values[n1]=value; 
  
  
 for (int t=n1;t>0;t){ 
  
  
  
 vector<double> value(t,0.0); 
  
  
  
 for (int i=0;i<t;++i){ 
  
  
  
  
 value[i]=cflows[t1]+exp(r tree[t1][i])*(q*values[t][i]+(1q)*values[t][i+1]); 
  
  
  
 if (t>=first call time){ value[i]=min(value[i],call price); }; 
  
  
  
 }; 
  
  
  
 values[t1]=value; 
  
  
 }; 
  
  
 return values[0][0]; 
  
 };
  
 C
 ++
 Code 24.3: Valuing callable bond 
  
 Example 
  
 Construct a short rate lattice for periods (years) 0 through 9 with an initial rate of r
 0
  = 6% and with 
 successive rates determined by a multiplicative factors u = 1:2 or d = 0:9. Assign q = 0:5.
  
 1. Using this lattice, find the value of a 10-year 6% bond.
  
 2. Suppose this bond can be called by the issuing party at any time after 5 years. (When the bond is 
 called, the face value plus the currently due coupon are paid at that time and the bond is canceled.) 
 What is the fair value of this bond?
  
 The interest rate lattice:
  
 step:
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 8
  
 9
  
  
 nodes:
  
 31.0
  
 6.0
  
 7.2
  
 8.6
  
 10.4
  
 12.4
  
 14.9
  
 17.9
  
 21.5
  
 25.8
  
 23.2
  
 19.3
  
 17.4
  
 16.1
  
 14.5
  
 13.1
  
 13.4
  
 12.1
  
 10.9
  
 9.8
  
 11.2
  
 10.1
  
 9.1
  
 8.2
  
 7.3
  
 9.3
  
 8.4
  
 7.6
  
 6.8
  
 6.1
  
 5.5
  
 7.8
  
 7.0
  
 6.3
  
 5.7
  
 5.1
  
 4.6
  
 4.1
  
 6.5
  
 5.8
  
 5.2
  
 4.7
  
 4.3
  
 3.8
  
 3.4
  
 3.1
  
 5.4
  
 4.9
  
 4.4
  
 3.9
  
 3.5
  
 3.2
  
 2.9
  
 2.6
  
 2.3
  
  
 1. Valuing the noncallable bond 
  
  
 The cash flow lattice
  
 218",NA
24.5 ,NA,NA
Readings ,"General references include Sundaresan (2001).
  
 Rendleman and Bartter (1979) and Rendleman and Bartter (1980) are the original references for building 
 standard binomial interest rate trees.
  
 220",NA
Chapter 25,NA,NA
Building term structure trees using the ,NA,NA
Ho and Lee (1986) approach,NA,NA
25.1 ,NA,NA
Intro,"In this section we build interest rate trees following the orgiginal paper of Ho and Lee (1986). We will 
 follow the analysis in the paper, and use it to illustrate how yu can build trees of more complex term 
 structures than the simple binomial trees of the interest rate. The selling point of the original paper was 
 that one could fit an initial term structure and then specify an evolution of the term structure consistent 
 with this initial term structure.",NA
25.2 ,NA,NA
Building trees of term structures,NA,NA
25.3 ,NA,NA
Ho Lee term structure class,221,NA
25.4 ,NA,NA
Pricing things,"We now have access to what we need to do pricing through the recursive relationship
  
 C(n; i) = [C(n + 1; i + 1) + (1)C(n + i; i)] P
 (n) i 
 (1)
  
 where C(n; i) is the value of a security at time n at node i.
  
 What we are pricing are typically state and time-contingent claims to cash flows. Let us illustrate pricing 
 of an (European) call option on some underlying bond. Suppose this bond is risk free. Its cash flows at 
 each future date does not depend on the state, but the timing of cash flows changes as you move in the 
 tree. It is therefore necessary to some way figure out at date t: What are the future cash flows when you 
 want to price the underlying bond at that date. We build a small class that contains this information, and 
 use it, together with the term structures in the individual nodes, to find the bond price at each node. The 
 value of the bond at the different nodes change because the term structure you use for discounting is 
 changing. This bond price is then used to find the option value at each node.
  
 224",NA
25.5 ,NA,NA
References,"The discussion in this chapter follows closely the original paper Ho and Lee (1986)
  
 226",NA
Chapter 26,NA,NA
Term Structure Derivatives,"Contents
  
  
 26.1 Vasicek bond option pricing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 227",NA
26.1,NA,NA
Vasicek bond option pricing,"If the term structure model is Vasicek’s model there is a solution for the price of an option on a zero 
 coupon bond, due to Jamshidan (1989).
  
 Under Vacisek’s model the process for the short rate is assumed to follow.
  
 dr = a(b r)dt + dZ
  
 where a, b and are constants. We have seen earlier how to calculate the discount factor in this case. We 
 now want to consider an European Call option in this setting.
  
 Let P(t; s) be the time t price of a zero coupon bond with a payment of $1 at time s (the discount factor). 
 The price at time t of a European call option maturing at time T on on a discount bond maturing at time s 
 is (See Jamshidan (1989) and Hull (1993))
  
 P(t; s)N(h) XP(t; T)N(h
 P
  )
  
 where
  
 h = 1
  
 ln
  
 P(t; T)X+ 1 2
 P
  
 P
  
 P
  = v(t; T)B(T; s)
  
 B(t; T) = 1 e
 a(Tt) 
  
 a
  
 v(t; T)
 2
 =
 2
 (1 e
 a(Tt)
 ) 
  
 2a
  
 In the case of a = 0,
  
 v(t; T) =
  
 p T t
  
 P
  =(s T) p T t
  
 Example
  
 Parameters: a = 0:1, b = 0:1, = 0:02, r = 0:05, X = 0:9. Price a Vacicek call on a zero.
  
 227",NA
Chapter 27,NA,NA
Date (and time) revisited - the ,NA,NA
BOOST libraries,"In the introduction we used the construction of a
  date
  class as an example of building a nontrivial (and 
 useful) class. However, even if we follow the hints in the exercises, and use the operating system utilities 
 for dealing with dates, at some point such a “homespun” date class needs to be replaced with something 
 more reliable.
  
 The date class that is most likely to spring to the programmers’ minds these days is one provided by the 
 Boost C++ library. Let us therefore use this opportunity to introduce the Boost libraries, and show some 
 examples of date usage. The Boost libraries are collections of C
 ++
 libraries, many of which may at some 
 point become part of the C
 ++
 standard.
 1
 One of the most useful of the Boost libraries are complete libraries 
 for date (gregorian) and date and time (date_time.
  
 We are not going to go into detail here, we limit ourselves to showing some examples of usage:
  
 1
 Ten Boost libraries actually became part of the latest C
 ++
  standard (C++-11). If you have a recent C
 ++
  implementation, the Boost 
 libraries are typically included.
  
 229",NA
27.1,NA,NA
References,"The Boost homepage is at http://www.boost.org/
  
 230",NA
Appendix A ,NA,NA
Normal Distribution ,NA,NA
approximations.,"Contents
  
 A.1
  
 The normal distribution 
 function
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 231
  
 A.2
  
 The cumulative normal distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 232
  
 A.3
  
 Multivariate normal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 232
  
 A.4
  
 Calculating cumulative bivariate normal 
 probabilities
  
 . . . . . . . . . . . . . . . . . . . . . . .
  
 233
  
 A.5
  
 Simulating random normal numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 235
  
 A.6
  
 Cumulative probabilities for general multivariate distributions . . . . . . . . . . . . . . . . . . .
  
 236
  
 A.7
  
 Implementation in C
 ++
 11
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 236
  
 A.8
  
 References
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 236
  
 We will in general not go into detail about more standard numerical problems not connected to finance,
  
 there are a number of well known sources for such, but we show the example of calculations involving
  
 the normal distribution.",NA
A.1 ,NA,NA
The normal distribution ,NA,NA
function ,"The nurmal distribution function
  
 n(x) = e
  x2
  
 is calculated as
  
 #include <cmath>
  // c library of math functions 
  
 using namespace std;
  // which is part of the standard namespace
  
 // most C compilers define PI, but just in case it doesn’t 
  
 #ifndef PI 
  
 #define PI 3.141592653589793238462643 
  
 #endif
  
 double n(const double& z) {
  // normal distribution function 
  
  
 return (1.0/sqrt(2.0*PI))*exp(0.5*z*z); 
  
 };
  
 C
 ++
 Code A.1: The normal distribution function",NA
A.2 ,NA,NA
The cumulative normal distribution,"The solution of a large number of option pricing formulas are written in terms of the cumulative normal 
 distribution. For a random variable x the cumulative probability is the probability that the outcome is 
 lower than a given value z. To calculate the probability that a normally distubuted random variable with 
 mean 0 and unit variance is less than z, N(z), one have to evaluate the integral
  
 Prob(x z) = N(z) =
  
 Z
  z 1
  
 n(x)dx =
  
 Z
  z 1
  
 e
  x2 2
  dx
  
 There is no explicit closed form solution for calculation of this integral, but a large number of well known 
 approximations exists. Abramowiz and Stegun (1964) is a good source for these approximations. The 
 following is probably the most used such approximation, it being pretty accurate and relatively fast. The 
 arguments to the function are assumed normalized to a (0,1) distribution.
  
 #include <cmath>
  // math functions. 
  
 using namespace std;
  
 double N(const double& z) { 
  
 if (z > 6.0) { return 1.0; };
  // this guards against overflow 
 if (z <6.0) 
 { return 0.0; };
  
 double b1 = 0.31938153; 
  
 double b2 =0.356563782; 
  
 double b3 = 1.781477937; 
  
 double b4 =1.821255978; 
  
 double b5 = 1.330274429; 
  
 double p = 0.2316419; 
  
 double c2 = 0.3989423;
  
  
 double a=fabs(z); 
  
  
 double t = 1.0/(1.0+a*p); 
  
  
 double b = c2*exp((z)*(z/2.0)); 
  
  
 double n = ((((b5*t+b4)*t+b3)*t+b2)*t+b1)*t; 
  
  
 n = 1.0b*n; 
  
  
 if ( z < 0.0 ) n = 1.0 n; 
  
  
 return n; 
  
 };
  
 C
 ++
 Code A.2: The cumulative normal",NA
A.3 ,NA,NA
Multivariate normal,"The normal distribution is also defined for several random variables. We then characterise the
  vector
  of 
 random variables
  
 X
  = 2 
  
 x
 2 
 3 
  
  
  
 x
 1 
  
  
  
  
  
 7775 
 6664 x
 n 
   
  
 ...
  
 A probability statement about this vector is a joint statement about all elements of the vector.",NA
A.4 ,NA,NA
Calculating cumulative bivariate normal probabilities,"The most used multivariate normal calculation is the bivariate case, where we let x and y be bivariate 
 normally distributed, each with mean 0 and variance 1, and assume the two variables have correlation of. 
 By the definition of correlation 2 [1; 1]. The cumulative probability distribution
  
 P(x < a; y < b) = 
  
 N(a; b; )
  
 = 
  
 Z
  a 1 
 Z
  b 1 
 2 
  
 p 1
 2
  exp 
  
 2 
  
  
 1
 2 
  
   
   
  
    
   
  
 dxdy 
  
   
   
  
   
 1 
  
 1 x
 2
  2xy + y
 2
  
 There are several approximations to this integral. We pick one such, discussed in (Hull, 1993, Ch 10),
  
 shown in C
 ++
 Code A.3.
  
 If one has more than two correlated variables, the calculation of cumulative probabilites is a nontrivial 
 problem. One common method involves Monte Carlo estimation of the definite integral. We will consider 
 this, but then it is necessary to first consider simulation of random normal variables.
  
 Example
  
 Calculate N(0) and N(0,0,0)
  
 C
 ++
 program: 
  
   
 cout << "" N(0) = "" << N(0) << endl; 
  
   
 cout << "" N(0,0,0) = "" << N(0,0,0) << endl; 
  
 Output from C
 ++
 program: 
  
 N(0) = 0.5 
  
 N(0,0,0) = 0.25
  
 233",NA
A.5 ,NA,NA
Simulating random normal numbers,"Generation of random numbers is a large topic and is treated at length in such sources as Knuth (1997). 
 The generated numbers can never be truly random, only “pseudo”-random, they will be generated 
 according to some reproducible algorithm and after a (large) number of random number generations the 
 sequence will start repeating itself. The number of iterations before replication starts is a measure of the 
 quality of a random number generator. For anybody requiring high-quality random number generators 
 the rand() function provided by the standard C
 ++
 library should be avoided, but for not getting into 
 involved discussion of random number generations we use this function as a basis for the generation of 
 uniformly distributed numbers in the interval [0; 1), as shown in C
 ++
 Code A.4.
  
 #include <cstdlib> 
  
 using namespace std;
  
 double random uniform 0 1(void){ 
  
  
 return double(rand())/double(RAND MAX);
  // this uses the C library random number generator.
  
 };
  
 C
 ++
 Code A.4: Pseudorandom numbers from an uniform [0; 1) distribution
  
 Exercise A.1.
  
 Replace the random_uniform function here by an alternative of higher quality, by looking into what 
 numerical libraries is available on your computing platform, or by downloading a high quality random 
 number generator from such places as mathlib or statlib.
  
 These uniformly distributed distributed random variates are used as a basis for the polar method for 
 normal densities discussed in Knuth (1997) and inplemented as shown in C
 ++
 Code A.5.
  
 #include <cmath> 
  
 #include <cstdlib> 
  
 using namespace 
 std;
  
 double random uniform 0 1(void);
  
 double random normal(void){ 
  
  
 double U1, U2, V1, V2; 
  
  
 double S=2; 
  
  
 while (S>=1) { 
  
  
  
 U1 = random uniform 0 1(); 
  
  
  
 U2 = random uniform 0 1(); 
  
  
  
 V1 = 2.0*U11.0; 
  
  
  
 V2 = 2.0*U21.0; 
  
  
  
 S = pow(V1,2)+pow(V2,2); 
  
  
 }; 
  
  
 double X1=V1*sqrt((2.0*log(S))/S); 
  
  
 return X1; 
  
 };
  
 C
 ++
 Code A.5: Pseudorandom numbers from a normal (0; 1) distribution
  
 Example
  
 1. Generate 5 random uniform numbers (0,1)
  
 2. Generate 5 random N(0,1) numbers.
  
 235",NA
A.6,NA,NA
Cumulative probabilities for general multivariate distributions,"When moving beyond the bivariate case calculation of probability integrals become more of an exercise in 
 general numerical integration. A typical tool is Monte Carlo integration, but that is not the only possibility.",NA
A.7 ,NA,NA
Implementation in C,++,NA
11,"The latest standard of the C
 ++
 language, C
 ++
 11, includes a library for generating random numbers. See 
 (Stroustrup, 1997a, Section 5.6.3).",NA
A.8 ,NA,NA
References,"Tong (1990) discusses the multivariate normal distribution, and is a good reference. For the ultimate 
 source, see Knuth (1997).
  
 236",NA
Appendix B,NA,NA
C++ concepts,"This chapter contains a listing of various C/C
 ++
 concepts and some notes on each of them.
  
 accumulate() Function accumulating the elements of a sequence.
  
 bool Boolean variable, taking on the two values true and false. For historical reasons one can also 
  
 use 
 the values zero and one for false and true.
  
 class (C
 ++
 keyword).
  
 const (qualifyer to variable in C
 ++
 function call).
  
 double (basic type). A floating point number with high accuracy.
  
 exp(x) (C function). Defined in <cmath>. Returns the natural exponent e to the given power x, e
 x
 .
  
 fabs 
  
 float (basic type). A floating point number with limited accuracy.
  
 for Loop 
  
 header file 
  
 if 
  
 Indexation (in vectors and matrices). To access element number i in an array A, use A[i-1]. Well 
  
  
 known trap for people coming to C from other languages. Present in C for historical efficiency 
  
  
 reasons. Arrays in C were implemented using pointers. Indexing was done by finding the first 
  
  
 element of the array, and then adding pointers to find the indexed element. The first element is of 
  
  
 course found by adding nothing to the first elment, hence the first element was indexed by zero.
  
 include 
  
 inline (qualifyer to C
 ++
 function name). Hint to the optimizer that this function is most efficiently 
  
 implemented by
  inlining
  it, or putting the full code of the function into each instance of its 
  
 calling. Has the side effect of making the function local to the file in which it is defined.
  
 int (basic type). An integer with a limited number of significant digits.
  
 log(x) (C function). Defined in <cmath>. Calculates the natural logarithm ln(x) of its argument. long 
 (basic type). An integer that can contain a large number.
  
 min_element() (C
 ++
 function)
  
 237",NA
Appendix C,NA,NA
Interfacing to external libraries,"Contents
  
 C.1 
  
 C.2 
  
 C.3 
  
 C.4
  
 C.5
  
 Boost . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 239
  
 Newmat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 239
  
 IT++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 239
  
 GSL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 239
  
 C.4.1
  
 The evaluation of N
 3
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
  
 Internet links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 240
  
 In various places we have used routines from other public domain packages. In this appendix there are 
 some notes about the libraries which are referenced, and some comments about linking to them.",NA
C.1 ,NA,NA
Boost,"Large collection of peer-reviewed code. Particularly useful: the
  date_time
  library.",NA
C.2 ,NA,NA
Newmat,"Newmat is a matrix library that attempts to do matlab-like operations in C
 ++
 , in that one can define 
 matrices and vectors, and then multiply them and so on without needing to explicitly call subroutines, 
 instead writing the operations in a more mathematically oriented way.",NA
C.3 ,NA,NA
IT++,IT++ is a large library with various different,NA
C.4 ,NA,NA
GSL,"C.4.1 
  
 The evaluation of N
 3
  
 In the calculation of the American Put approximation of Geske and Johnson (1984), a trivariate normal 
 needs to be evaluated. Following the discussion in the paper, this is evaluated as
  
 N
 3
 (h; k; j;
 12
 ; 
 13
 ; 
 23
 ) =
  
 Z
  j 1
  
 n(z)N
 2
  
 k
 23
 z p 1
 2 23
  
 ; h
 13
 z 
  
 p 
 1
 2 13
  
 ;
  
 121323
  
 p 1
 2 13 
 p 1
 2 23
  
 !
  
 239",NA
C.5 ,NA,NA
Internet links,"Some useful internet links
  
  http://www.robertnz.net: Homepage for Newmat, the matrix class used as an example.
  
 240",NA
Appendix D,NA,NA
Summarizing routine names,"In many of the algorithms use is made of
  other
  routines. To simplify the matter all routines are summarised in one header file, fin_recipes.h. This 
 appendix shows this file.
  
 // file: fin recipes.h 
  
 // author: Bernt Arne Oedegaard
  
 //
  
 defines all routines in the financial numerical recipes “book”
  
 #ifnde
 f
  
 FIN RECIPES H
  
 #defin
 e
  
 FIN RECIPES H
  
 #include 
 <vector> 
  
 #include 
 <cmath> 
  
 using 
 namespace 
 std;
  
 ///////// present value //////////////////////////////////// // discrete 
 coumpounding 
  
 ///////////////////////////////// 
  
 // discrete, annual compounding
  
 double cash flow pv discrete ( const vector<double>& cflow times, const vector<double>& cflow amounts, 
  
  
 const double& r); 
  
 double cash flow irr discrete(const vector<double>& cflow times, const vector<double>& cflow amounts); bool 
 cash flow unique irr(const vector<double>& cflow times, const vector<double>& cflow amounts); double bonds 
 price discrete(const vector<double>& cashflow times, const vector<double>& cashflows, 
  
 const double& r); 
  
 double bonds yield to maturity discrete(const vector<double>& times, 
  
  
    
 const vector<double>& amounts, 
  
  
    
 const double& bondprice); 
  
 double bonds duration discrete(const vector<double>& times, 
  
  
  
 const vector<double>& cashflows, 
  
  
  
 const double& r); 
  
 double bonds duration macaulay discrete(const vector<double>& cashflow times, 
  
  
    
 const vector<double>& cashflows, 
  
  
    
 const double& bond price); 
  
 double bonds duration modified discrete (const vector<double>& times, 
  
  
    
  
 const vector<double>& amounts, 
  
  
    
  
 const double& bond price); 
  
 double bonds convexity discrete(const vector<double>& cflow times, 
  
  
   
 const vector<double>& cflow amounts, 
  
  
   
 const double& r); 
  
 ///////////////////////////////// 
  
 // continous compounding.
  
 double cash flow pv(const vector<double>& cflow times,const vector<double>& cflow amounts,const double& r); 
 double cash flow irr(const vector<double>& cflow times, const vector<double>& cflow amounts); 
  
 double bonds price(const vector<double>& cashflow times, const vector<double>& cashflows, const double& r); double 
 bonds price(const vector<double>& coupon times, const vector<double>& coupon amounts, 
  
  
 const vector<double>& principal times, const vector<double>& principal amounts, 
  
 const double& 
 r);
  
 241",NA
Appendix E,NA,NA
Installation,The routines discussed in the book are available for download.,NA
E.1 ,NA,NA
Source availability,"The algorithms are available from my home page as a ZIP file containing the source code. These have been 
 tested with the latest version of the GNU C++ compiler. As the algorithms in places uses code from the 
 Standard Template Library, other compilers may not be able to compile all the files directly. If your 
 compiler complains about missing header files you may want to check if the STL header files have 
 different names on your system. The algorithm files comply with the current ANSI standard for C++ 
 libraries. If the compiler is more than a couple of years old, it will not have STL. Alternatively, the GNU 
 compiler gcc is available for free on the internet, for most current operating systems.
  
 251",NA
List of C++ Codes,"1.1
  
 A complete program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 2
 7 
  
 3
 1 
  
 3
 3 
  
 3
 5 
  
 3
 8 
  
 3
 9 
  
 4
 1 
  
 4
 2 
  
 4
 3 
  
 4
 4 
  
 4
 7 
  
 4
 8
  
 4
 8 
  
 4
 8 
  
 5
 3
  
 56 
  
 57 
  
 60 
  
 62 
  
 64 
  
 65 
  
 65 
  
 77 
  
 78 
  
 79 
  
 80 
  
 81 
  
 84 
  
 87 
  
 88 
  
 90 
  
 1.2
  
 Basic operations for the date class
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.3
  
 Comparison operators for the date class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1.4
  
 Iterative operators for the date class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.1
  
 Present value with discrete compounding
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.2
  
 Estimation of the internal rate of return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.3
  
 Test for uniqueness of IRR
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3.4
  
 Present value calculation with continously compounded interest . . . . . . . . . . . . . . . . . . .
  
 4.1
  
 Bond price calculation with discrete, annual compounding.
  
 . . . . . . . . . . . . . . . . . . . . .
  
 4.2
  
 Bond yield calculation with discrete, annual compounding . . . . . . . . . . . . . . . . . . . . . .
  
 4.3
  
 Bond duration using discrete, annual compounding and a flat term structure
  
 . . . . . . . . . . .
  
 4.4
  
 Calculating the Macaulay duration of a bond . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.5
  
 Modified duration
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.6
  
 Bond convexity with a flat term structure and annual compounding
  
 . . . . . . . . . . . . . . . .
  
 4.7
  
 Bond price calculation with continously compounded interest and a flat term structure
  
 . . . . .
  
 4.8
  
 Bond duration calculation with continously compounded interest and a flat term structure
  
 . . .
  
 4.9
  
 Calculating the Macaulay duration of a bond with continously compounded interest and a flat
  
 term structure
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4.10 Bond convexity calculation with continously compounded interest and a flat term structure . . .
  
 5.1
  
 Term structure transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.2
  
 Default code for transformations between discount factors, spot rates and forward rates in a term
  
 structure class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.3
  
 Implementing term structure class using a flat term structure . . . . . . . . . . . . . . . . . . . .
  
 5.4
  
 Interpolated term structure from spot rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.5
  
 Term structure class using linear interpolation between spot rates
  
 . . . . . . . . . . . . . . . . .
  
 5.6
  
 Pricing a bond with a term structure class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5.7
  
 Calculating a bonds duration with a term structure class
  
 . . . . . . . . . . . . . . . . . . . . . .
  
 5.8
  
 Calculating a bonds convexity with a term structure class . . . . . . . . . . . . . . . . . . . . . .
  
 6.1
  
 Mean variance calculations using IT++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.2
  
 Mean variance calculations using Newmat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6.3
  
 Calculating the unconstrained frontier portfolio given an expected return using Newmat . . . . . .
  
 6.4
  
 Calculating the unconstrained frontier portfolio given an expected return using IT++ . . . . . . .
  
 7.1
  
 Futures price
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8.1
  
 Binomial European, one period . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8.2
  
 Building a binomial tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8.3
  
 Binomial multiperiod pricing of European call option . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9.1
  
 Price of European call option using the Black Scholes formula . . . . . . . . . . . . . . . . . . . .
  
 9.2
  
 Calculating the delta of the Black Scholes call option price
  
 . . . . . . . . . . . . . . . . . . . . .
  
 9.3
  
 Calculating the partial derivatives of a Black Scholes call option
  
 . . . . . . . . . . . . . . . . . .
  
 9.4
  
 Calculation of implied volatility of Black Scholes using bisections . . . . . . . . . . . . . . . . . .
  
 9.5
  
 Calculation of implied volatility of Black Scholes using Newton-Raphson . . . . . . . . . . . . . .
  
 10.1 Adjusted Black Scholes value for a Warrant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11.1 Option price, continous 
 payout from underlying . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11.2 European option price, dividend paying stock . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . 11.3 Option price, Roll–Geske–Whaley call formula for dividend paying stock . . . . . . . 
 . . . . . . .
  
 11.4 Price of European Call option on Futures contract
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 252",NA
List of Matlab Codes,"6.1 
  
 Calculation of minimum variance portfolio for given return . . . . . . . . . . . . . . . . . . . . . 
  
 71
  
 6.2 
  
 Sharpe Ratio 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
  
 6.3 
  
 Treynor Ratio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
  
 6.4 
  
 Jensens alpha . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
  
 9.1 
  
 Price of European call option using the Black Scholes formula . . . . . . . . . . . . . . . . . . . . 
  
 91
  
 12.1 Price of American call using a binomial approximation . . . . . . . . . . . . . . . . . . . . . . . . 
  
 11
 6
  
 12.2 Price of American put using a binomial approximation . . . . . . . . . . . . . . . . . . . . . . . . 
  
 11
 7
  
 13.1 Explicit finite differences calculation of American put option 
  
 . . . . . . . . . . . . . . . . . . . . 
  
 135
  
 13.2 Calculation of price of American put using implicit finite differences . . . . . . . . . . . . . . . . 
  
 13
 7
  
 18.1 Price of american put using a trinomial tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 18
 5
  
 24.1 Building interest rate tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 21
 5",NA
Appendix F,NA,NA
Acknowledgements.,"After this paper was put up on the net, I’ve had quite a few emails about them. Some of them has pointed 
 out bugs and other inaccuracies.
  
 Among the ones I want to say thanks to for making improving suggestions and pointing out bugs are
  
 Ariel Almedal 
  
 Andrei Bejenari 
  
 Steve Bellantoni 
  
 Jean-Paul Beveraggi 
  
 Lars Gregori 
  
 Daniel Herlemont 
  
 Lorenzo Isella 
  
 Jens Larsson 
  
 Garrick Lau 
  
 Steven Leadbeater 
  
 Michael L Locher 
  
 Lotti Luca, Milano, Italy 
  
 Tuan Nguyen 
  
 Michael R Wayne
  
 256",NA
Index,", 94 
  
 , 94 
  
 , 94
  
 A, 137 
  
 a, 135 
  
 antithetic variates, 148 
 asset or nothing call, 151
  
 build_time_series_of_bond_time_contingent_cash_flows, 225
  
 calcP2, 158 
  
 call option, 82 
  
 cash flow, 26 
  
 cash or nothing call, 151 
  
 cash_flow_irr_discrete, 31
  
  
 Barone–Adesi and Whaley, 159 
  
 binary option, 151 
  
 binomial option price, 82, 112 
  
 binomial term structure models, 211 
 binomial_tree, 87 
  
 Black 
  
  
 futures option, 108 
  
 Black Scholes option pricing formula, 89 
 Bond 
  
  
 Price 
  
  
  
 Flat term structure, 36 
  
  
 Promised payments, 36 
  
 bond 
  
  
 duration, 41 
  
  
 price, 37 
  
  
 yield to maturity, 38 
  
 bond convexity, 44 
  
 bond option
  
 cash_flow_pv, 35 
  
 cash_flow_pv_discrete, 27, 28, 32, 241 
  
 cash_flow_unique_irr, 33 
  
 class, 9 
  
 cmath, 7 
  
 Complex numbers 
  
 in C
 ++
 , 189 
  
 control variates, 147 
  
 convexity 
  
 of bond, 44 
  
 Cox Ingersoll Ross term structure model, 205 
  
 currency 
  
 option, 109 
  
 currency option 
  
 American, 130 
  
 European, 109 
  
 currency_option_price_call_american_binomial, 130 
 currency_option_price_call_european, 109, 110
  
 basic binomial, 193 
  
 d, 57, 63, 249
  
 Black Scholes, 191 
  
 d1, 158
  
 Vasicek, 227 
  
 d2, 158
  
 bond_option_price_call_zero_american_rendleman_bartter, date::date, 12
  
 212, 213, 249 
  
 date::day, 12
  
 bond_option_price_call_zero_vasicek, 228 
  
 date::month, 12
  
 bond_option_price_put_american_binomial, 193 
  
 date::valid, 12
  
 bond_option_price_put_coupon_bond_black_scholes, date::year, 12
  
 192 
  
 delta, 93
  
 bond_option_price_put_zero_black_scholes, 191, 194 
  
 binomial, 120
  
 bonds_convexity, 48, 65 
  
 Black Scholes, 93
  
 bonds_convexity_discrete, 44 
  
 derivative_price_simulate_european_option_generic,
  
 bonds_duration, 48, 49, 65 
  
 146, 152, 173, 176
  
 bonds_duration_discrete, 41, 42, 45 
  
 derivative_price_simulate_european_option_generic_with_antithetic_
  
 bonds_duration_macaulay, 48 
  
 149
  
 bonds_duration_macaulay_discrete, 42 
  
 derivative_price_simulate_european_option_generic_with_control_va
  
 bonds_duration_modified_discrete, 43 
  
 148, 175
  
 bonds_price, 47, 64, 66, 242 
  
 Discount factor, 36
  
 bonds_price_discrete, 37, 38 
  
 discount factor, 26
  
 bonds_yield_to_maturity_discrete, 39, 40 
  
 discount_factor, 208
  
 bool (C
 ++
 type), 6 
  
 double (C
 ++
 type), 6
  
 duration, 41
  
 257",NA
Bibliography ,"Milton Abramowiz and Irene A Stegun.
  Handbook of Math-
  
 ematical Functions
 . National Bureau of Standards, 1964.
  
 M B Garman and S W Kohlhagen. Foreign currency option 
 values.
  Journal of International Money and Finance
 , 2: 231–37, 
 1983.
  
 Robert Geske. The valuation of compound options.
  Journal 
  
 of 
 Financial Economics
 , 7:63–81, March 1979.
  
 Robert Geske and H E Johnson. The american put valued 
 analytically.
  Journal of Finance
 , XXXIX(5), December
  
 Giovanni Barone-Adesi. The saga of the American put.
  Jour-
  
 1984.
  
 nal of Banking and Finance
 , 29:2909–2918, 2005.
  
 Giovanni Barone-Adesi and Robert E Whaley. Efficient an-alytic 
 approximation of American option values.
  Journal of Finance
 , 
 42(2):301–20, June 1987.
  
 Petter Bjerksund and Gunnar Stensland. Closed form ap-
 proximations of american options.
  Scandinavian Journal of 
 Management
 , 20(5):761–764, 1993.
  
 Petter Bjerksund and Gunnar Stensland. Closed form valu-ation 
 of american options. Working Paper, NHH, October 2002.
  
 Fisher Black. The pricing of commodity contracts.
  Journal 
  
 of 
 Financial Economics
 , 3:167–79, 1976.
  
 Fisher Black and Myron S Scholes. The pricing of options and 
 corporate liabilities.
  Journal of Political Economy
 , 7:637–54, 
 1973.
  
 M Barry Goldman, Howard B Sosin, and Mary Ann Gatto. Path–
 dependent options: Buy at the low, sell at the high. 
 Journal of 
 Finance
 , 34, December 1979.
  
 J O Grabbe. The pricing of call and put options on foreign 
 exchange.
  Journal of International Money and Finance
 , 2:239–
 53, 1983.
  
 Philip Gray and Stephen F Gray. A framework for valuing 
 derivative securities.
  Financial Markets, Institutions and 
 Instruments
 , 10(5):253–276, December 2001.
  
 Richard C Green and Bernt Arne Ødegaard. Are there tax effects 
 in the relative pricing of U.S. Government bonds? 
 Journal of 
 Finance
 , 52:609–633, June 1997.
  
 Robert A Haugen.
  Modern Investment Theory
 . Prentice–
  
 Hall, fifth edition, 2001.
  
 Steven L Heston. A closed-form solution fo optionc with 
  
 stochastick volatility with applications to bond and cur-
  
 Zvi Bodie, Alex Kane, and Alan J Marcus.
  
 Investments
 .
  
 rency options.
  Review of Financial Studies
 , 6(2):327–343,
  
 1993.
  
 McGraw Hill/Irwin, Seventh edition, 2007.
  
 T S Ho and S Lee. Term structure movement and pricing
  
  
 Peter L Bossaerts and Bernt Arne Ødegaard.
  Lectures on 
  
 Corporate Finance
 . 
  
 World Scientific Press, Singapore,
  
 interest rate contingent claims.
  Journal of Finance
 , 43: 1011–
 29, 1986.
  
 2001.
  
 Chi-fu Huang and Robert H Litzenberger.
  Foundations for
  
  
 Phelim P Boyle. Options: A Monte Carlo approach.
  Journal 
  
 of 
 Financial Economics
 , 4:323–38, 1977.
  
 Richard A Brealey, Stewart C Myers, and Franklin Allen.
  
 financial economics
 . North–Holland, 1988.
  
 John Hull.
  Options, Futures and other Derivative Securities
 . 
  
 Prentice–Hall, second edition, 1993.
  
 Principles of Corporate Finance
 .
  
 McGraw–Hill/Irwin,
  
 John
  
 Hull.
  
 Options,
  
 Futures
  
 and
  
 other
  
 Derivatives
 .
  
 tenth edition, 2010.
  
 Prentice-Hall, eight edition, 2011.
  
  
 Michael Brennan and Eduardo Schwartz. Finite difference 
  
 methods and jump processes arising in the pricing of con-
  
 tingent claims: A synthesis. 
 Journal of Financial and 
  
 Quantitative Analysis
 , 13:461–74, 1978.
  
 Mark Broadie and Jerome Detemple. American option val-
 uation: New bounds, approximations, and a comparison of 
 existing methods.
  Review of Financial Studies
 , 9(4): 1211–
 1250, Winter 1996.
  
 Mark Broadie and Jerome Detemple. Option pricing: Valu-ation 
 models and applications.
  Management Science
 , 50 (9):1145–
 1177, September 2004.
  
 John Cox and Mark Rubinstein.
  Options markets
 . Prentice–
  
 F Jamshidan. An exact bond option pricing formula.
  Jour-
  
 nal 
 of Finance
 , 44:205–9, March 1989.
  
 H E Johnson. An analytic approximation of the american put 
 price.
  Journal of Financial and Quantitative Analy-sis
 , 
 18(1):141–48, 1983.
  
 A Kemna and A Vorst. A pricing method for options based on 
 average asset values.
  Journal of Banking and Finance
 , 14:113–
 29, March 1990.
  
 Donald E Knuth. 
 The Art of Computer Programming 
  
 Volume 2, Seminumerical Algotithms
 . Addison–Wesley, 
  
 third edition, 1997.
  
 Stanley B Lippman.
  C++ primer
 . Addison–Wesley, 2 edi-
  
 Hall, 1985. 
  
 tion, 1992.
  
 261",NA
