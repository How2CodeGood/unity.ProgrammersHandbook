Larger Text,Smaller Text,Symbol
C++ Annotations Version 10.1.0,"Frank B. Brokken 
  
 Center of Information Technology, 
  
 University of Groningen 
  
 Nettelbosje 1, 
  
 P.O. Box 11044, 
  
 9700 CA Groningen 
  
 The Netherlands 
  
 Published at the University of Groningen 
 ISBN 90 367 0470 7
  
 1994 - 2014",NA
Contents,"1
  
 Overview Of The Chapters
  
 1
  
  
 2
  
 Introduction
  
 3
  
 2.1
  
 What’s new in the C++ Annotations
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 2.2
  
 C++’s history
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 2.2.1
  
 History of the C++ Annotations
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 2.2.2
  
 Compiling a C program using a C++ compiler
  . . . . . . . . . . . . . . . . . . .
  
 7
  
 2.2.3
  
 Compiling a C++ program
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8
  
 2.3
  
 C++: advantages and claims
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 2.4
  
 What is Object-Oriented Programming?
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 2.5
  
 Differences between C and C++
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 2.5.1
  
 The function ‘main’
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.5.2
  
 End-of-line comment
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.5.3
  
 Strict type checking
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.5.4
  
 Function Overloading
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 2.5.5
  
 Default function arguments
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 2.5.6
  
 NULL-pointers vs. 0-pointers and nullptr
  . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.5.7
  
 The ‘void’ parameter list
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 2.5.8
  
 The ‘#define __cplusplus’
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 2.5.9
  
 Using standard C functions
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.5.10
  
 Header files for both C and C++
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.5.11
  
 Defining local variables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 2.5.12
  
 The keyword ‘typedef’
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 2.5.13
  
 Functions as part of a struct
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 ii",NA
Chapter 1,NA,NA
Overview Of The Chapters,"The chapters of the
  C++
  Annotations cover the following topics:
  
 • Chapter
  1
 : This overview of the chapters.
  
 • Chapter
  2
 : A general introduction to
  C++
 .
  
 • Chapter
  3
 : A first impression: differences between
  C
  and
  C++
 .
  
 • Chapter
  4
 : Name Spaces: how to avoid name collisions.
  
 • Chapter
  5
 : The ‘string’ data type.
  
 • Chapter
  6
 : The
  C++
  I/O library.
  
 • Chapter
  7
 : The ‘class’ concept: structs having functions. The ‘object’ concept: variables of a 
  
 class.
  
 • Chapter
  8
 : Static data and functions: members of a class not bound to objects.
  
 • Chapter
  9
 :
  
 Allocation and returning unused memory:
  
 new, delete, and the function
  
 set_new_handler().
  
 • Chapter
  10
 : Exceptions: handle errors where appropriate, rather than where they occur.• 
 Chapter
  11
 : Give your own meaning to operators.
  
 • Chapter
  12
 : Abstract Containers to put stuff into.
  
 • Chapter
  13
 : Building classes upon classes: setting up class hierarcies.
  
 • Chapter
  14
 : Changing the behavior of member functions accessed through base class pointers.• 
 Chapter
  15
 : Gaining access to private parts: friend functions and classes.
  
 • Chapter
  16
 : Classes having pointers to members: pointing to locations inside objects.• 
 Chapter
  17
 : Constructing classes and enums within classes.
  
 • Chapter
  18
 : The Standard Template Library.
  
 • Chapter
  19
 : The STL generic algorithms.
  
 • Chapter
  20
 : Multi Threading.
  
 1",NA
Chapter 2,NA,NA
Introduction,"This document offers an introduction to the
  C++
  programming language. It is a guide for
  C/C++ 
 programming courses, yearly presented by Frank at the University of Groningen. This document is not a 
 complete
  C/C++
  handbook, as much of the
  C
 -background of
  C++
  is not covered. Other sources should be 
 referred to for that (e.g., the Dutch book De programmeertaal C, Brokken and Kubat, University of 
 Groningen, 1996) or the on-line book
 1
 suggested to me by George Danchev (danchev at spnet dot net).
  
 The reader should be forwarned that extensive knowledge of the
  C
  programming language is ac-tually 
 assumed. The
  C++
  Annotations continue where topics of the
  C
  programming language end, such as 
 pointers, basic flow control and the construction of functions.
  
 Some elements of the language, like specific lexical tokens (such as trigraphs (such as ??< for {, and using 
 ??> for })), and bigraphs (such as <: for [, and >: for ]) are not covered by the
  C++ 
 Annotations, as these 
 tokens occur extremely seldom in
  C++
  source code. The reader is referred to the document covering the 
 C++11 standard for an overview.
  
 The version number of the
  C++
  Annotations (currently 10.1.0) is updated when the contents of the 
 document change. The first number is the major number, and is probably not going to change for some 
 time: it indicates a major rewriting. The middle number is increased when new information is added to the 
 document. The last number only indicates small changes; it is increased when, e.g., series of typos are 
 corrected.
  
 This document is published by the Center of Information Technology, University of Groningen, the 
 Netherlands under the GNU General Public License
 2
 .
  
 The
  C++ Annotations
  were typeset using the yodl
 3
 formatting system.
  
 All correspondence concerning suggestions, additions, 
  
 improvements or 
 changes to this document should be directed to the author:
  
 Frank B. Brokken 
  
 Center of Information Technology, 
  
 University of Groningen 
  
 Nettelbosje 1,
  
 1
 http://publications.gbdirect.co.uk/c_book/ 
  
 2
 http://www.gnu.org/licenses/ 
  
 3
 http://yodl.sourceforge.net
  
 3",NA
2.1 ,NA,NA
What’s new in the C++ Annotations,"This section is modified when the first or second part of the version number changes (and sometimes for 
 the third part as well).
  
 • Version 10.1.0 adds several sections about C++11 regular expression handling, supported since the 
 C++11 standard, but which was overlooked when 10.0.0 was published. Coverage of reg-ular 
 expression handling was moved from the Containers chapter to the chapter covering the Standard 
 Template Library.
  
 • Version 10.0.0 adds a new chapter about multi threading, which is formally supported since the 
 C++11 standard. In addition some minor topics (e.g., std::distance, some new syntax elements) were 
 added to the
  C++
  Annotations.
  
 • In version 9.9.0 sections in chapter
  18
  about specifying absolute and relative time were rewrit-ten and 
 moved to sections of their own. Sections about condition variablles were also rewritten.
  
 • Version 9.8.0 adds new sections in chapter
  22
  about static polymorphism, removes the con-crete/a2x 
 section, now made superfluous by string conversion functions, and removes the C++11 indicators 
 from section headers. The C++ standard has by now been implemented in Gnu’s g++ compiler (4.8.2). 
 Note that the -std=c++11 compiler flag is still necessary if you want the compiler to activate the 
 C++11 extensions.
  
 • Version 9.7.0/9.7.1 adds several new sections (about time specifications, system_error, er-
 ror_category, error_code, this_thread, locks) and other sections received a major overhaul (multi-
 threading, lambda expressions, the main function).
  
 • Version 9.6.0 adds a section about noexcept, deprecating throw lists. Also the string chapter 
  
 was updated.
  
 • Version 9.5.0 adapts the abstract containers to C++11, and adds a new section (Allocators) just before 
 introducing the sequential containers. make_shared, combining shared_ptr and (new).
  
 • Version 9.4.0 adds a new section to chapter
  18
  about make_shared, combining shared_ptr 
  
 and (new).
  
 • Version 9.3.0 refines the coverage of the static_cast and reinterpret_cast, following a 
  
 suggestion 
 provided by Gido Schoenmacker.
  
 • There are two major differences between versions 9.2.0 and 9.1.0. First, unrestricted unions are 
 covered in more detail (cf. section
  12.6
 ). Second, by now flexc++
 4
 has been released, and the sections 
 previously using flex (cf. section
  24.8
 ) are now using flexc++.
  
 4
 http://flexcpp.org/",NA
2.2 ,NA,NA
C++’s history,"The first implementation of
  C++
  was developed in the 1980s at the AT&T Bell Labs, where the Unix 
 operating system was created.
  
 C++
  was originally a ‘pre-compiler’, similar to the preprocessor of
  C
 , converting special constructions in its 
 source code to plain
  C
 . Back then this code was compiled by a standard
  C
  compiler. The ‘pre-code’, which 
 was read by the
  C++
  pre-compiler, was usually located in a file with the extension .cc, .C or .cpp. This file 
 would then be converted to a
  C
  source file with the extension .c, which was thereupon compiled and linked.
  
 The nomenclature of
  C++
  source files remains: the extensions .cc and .cpp are still used. How-ever, the 
 preliminary work of a
  C++
  pre-compiler is nowadays usually performed during the actual compilation 
 process. Often compilers determine the language used in a source file from its exten-sion. This holds true 
 for Borland’s and Microsoft’s
  C++
  compilers, which assume a
  C++
  source for an extension .cpp. The Gnu 
 compiler g++, which is available on many Unix platforms, assumes for 
 C++
  the extension .cc.
  
 The fact that
  C++
  used to be compiled into
  C
  code is also visible from the fact that
  C++
  is a superset of
  C
 :
  
 C++
  offers the full
  C
  grammar and supports all
  C
 -library functions, and adds to this features of its own. This 
 makes the transition from
  C
  to
  C++
  quite easy. Programmers familiar with
  C
  may start ‘programming in
  
 C++
 ’ by using source files having extensions .cc or .cpp instead of .c, and may then comfortably slip into all 
 the possibilities offered by
  C++
 . No abrupt change of habits is required.
  
 2.2.1 
  
 History of the C++ Annotations
  
 The original version of the
  C++
  Annotations was written by Frank Brokken and Karel Kubat in Dutch using 
 LaTeX. After some time, Karel rewrote the text and converted the guide to a more suitable format and (of 
 course) to English in september 1994.
  
 The first version of the guide appeared on the net in october 1994. By then it was converted to SGML.
  
 Gradually new chapters were added, and the contents were modified and further improved (thanks to 
 countless readers who sent us their comment).
  
 In major version four Frank added new chapters and converted the document from SGML to yodl
 7
 .
  
 The
  C++
  Annotations are freely distributable. Be sure to read the legal notes
 8
 .
  
 Reading the annotations beyond this point implies that you are aware of these notes and 
 that you agree with them.
  
 If you like this document, tell your friends about it. Even better, let us know by sending email to Frank
 9
 .
  
 2.2.2 
  
 Compiling a C program using a C++ compiler
  
 Prospective
  C++
  programmers should realize that
  C++
  is not a perfect superset of
  C
 . There are some 
 differences you might encounter when you simply rename a file to a file having the extension .cc
  
 7
 http://yodl.sourceforge.net 
  
 8
 legal.shtml 
  
 9
 mailto:f.b.brokken@rug.nl",NA
2.3 ,NA,NA
C++: advantages and claims,"Often it is said that programming in
  C++
  leads to ‘better’ programs. Some of the claimed advantages of
  C++
  
 are:
  
 • New programs would be developed in less time because old code can be reused.
  
 • Creating and using new data types would be easier than in
  C
 .
  
 • The memory management under
  C++
  would be easier and more transparent.
  
 • Programs would be less bug-prone, as
  C++
  uses a stricter syntax and type checking.
  
 • ‘Data hiding’, the usage of data by one program part while other program parts cannot access 
  
 the data, would be easier to implement with
  C++
 .
  
 Which of these allegations are true? Originally, our impression was that the
  C++
  language was somewhat 
 overrated; the same holding true for the entire object-oriented programming (OOP) approach. 
  
 The 
 enthusiasm for the
  C++
  language resembles the once uttered allegations about Artificial-Intelligence (AI) 
 languages like Lisp and Prolog: these languages were supposed to solve the most difficult AI-problems 
 ‘almost without effort’. New languages are often oversold: in the end, each problem can be coded in any 
 programming language (say BASIC or assembly language). The advantages and disadvantages of a given 
 programming language aren’t in ‘what you can do with them’, but rather in ‘which tools the language offers 
 to implement an efficient and understandable solution to a programming problem’. Often these tools take 
 the form of syntactic restrictions, enforc-ing or promoting certain constructions or which simply suggest 
 intentions by applying or ‘embracing’such syntactic forms. Rather than a long list of plain assembly 
 instructions we now use flow control statements, functions, objects or even (with
  C++
 ) so-called templates 
 to structure and organize code and to express oneself ‘eloquently’ in the language of one’s choice.
  
 Concerning the above allegations of
  C++
 , we support the following, however.
  
 • The development of new programs while existing code is reused can also be implemented in 
 C
  by, e.g., 
 using function libraries. Functions can be collected in a library and need not be re-invented with each 
 new program.
  C++
 , however, offers specific syntax possibilities for code reuse, apart from function 
 libraries (see chapters
  13
  and
  21
 ).
  
 • Creating and using new data types is certainly possible in
  C
 ; e.g., by using structs, typedefs etc.. From 
 these types other types can be derived, thus leading to structs containing structs and so on. In
  C++
  
 these facilities are augmented by defining data types which are completely‘self supporting’, taking 
 care of, e.g., their memory management automatically (without having to resort to an independently 
 operating memory management system as used in, e.g.,
  Java
 ).
  
 • In
  C++
  memory management can in principle be either as easy or as difficult as it is in C. Especially 
 when dedicated
  C
  functions such as xmalloc and xrealloc are used (allocating the memory or aborting 
 the program when the memory pool is exhausted). However, with functions like malloc it is easy to 
 err. Frequently errors in
  C
  programs can be traced back to miscalculations when using malloc. 
 Instead,
  C++
  offers facilities to allocate memory in a somewhat safer way, using its operator new.",NA
2.4 ,NA,NA
What is Object-Oriented Programming?,"Object-oriented (and object-based) programming propagates a slightly different approach to pro-
 gramming problems than the strategy usually used in
  C
  programs. In
  C
  programming problems are usually 
 solved using a ‘procedural approach’: a problem is decomposed into subproblems and this process is 
 repeated until the subtasks can be coded. Thus a conglomerate of functions is created, communicating 
 through arguments and variables, global or local (or static).
  
 In contrast (or maybe better: in addition) to this, an object-based approach identifies the
  keywords 
 used 
 in a problem statement. These keywords are then depicted in a diagram where arrows are drawn between 
 those keywords to depict an internal hierarchy. The keywords become the objects in the implementation 
 and the hierarchy defines the relationship between these objects. The term object is used here to describe a 
 limited, well-defined structure, containing all information about an entity: data types and functions to 
 manipulate the data. As an example of an object oriented approach, an illustration follows:
  
 The employees and owner of a car dealer and auto garage company are paid as follows. First, 
 mechanics who work in the garage are paid a certain sum each month. Second, the owner of the 
 company receives a fixed amount each month. Third, there are car salesmen who work in the 
 showroom and receive their salary each month plus a bonus per sold car. Finally, the company 
 employs second-hand car purchasers who travel around; these employees receive their 
 monthly salary, a bonus per bought car, and a restitution of their travel expenses.
  
 When representing the above salary administration, the keywords could be mechanics, owner, sales-men 
 and purchasers. The properties of such units are: a monthly salary, sometimes a bonus per purchase or 
 sale, and sometimes restitution of travel expenses. When analyzing the problem in this manner we arrive 
 at the following representation:
  
 • The owner and the mechanics can be represented by identical types, receiving a given salary",NA
2.5 ,NA,NA
Differences between C and C++,"In this section some examples of
  C++
  code are shown. Some differences between
  C
  and
  C++
  are highlighted.",NA
Chapter 3,NA,NA
A First Impression Of C++,"In this chapter
  C++
  is further explored. The possibility to declare functions in structs is illustrated in 
 various examples; the concept of a class is introduced; casting is covered in detail; many new types are 
 introduced and several important notational extensions to
  C
  are discussed.",NA
3.1 ,NA,NA
Extensions to C,"Before we continue with the ‘real’ object-approach to programming, we first introduce some exten-sions to 
 the
  C
  programming language: not mere differences between
  C
  and
  C++
 , but syntactic constructs and 
 keywords not found in
  C
 .
  
 3.1.1 
  
 Namespaces
  
 C++
  introduces the notion of a namespace: all symbols are defined in a larger context, called a namespace. 
 Namespaces are used to avoid name conflicts that could arise when a programmer would like to define a 
 function like sin operating on degrees, but does not want to lose the capability of using the standard sin 
 function, operating on radians.
  
 Namespaces are covered extensively in chapter
  4
 . For now it should be noted that most compilers require 
 the explicit declaration of a standard namespace: std. So, unless otherwise indicated, it is stressed that all 
 examples in the Annotations now implicitly use the
  
 using namespace std;
  
 declaration. So, if you actually intend to compile examples given in the
  C++
  Annotations, make sure that the 
 sources start with the above using declaration.
  
 3.1.2 
  
 The scope resolution operator ::
  
 C++
  introduces several new operators, among which the scope resolution operator (::). This op-erator can 
 be used in situations where a global variable exists having the same name as a local variable:
  
 #include <stdio.h>
  
 25",NA
3.2 ,NA,NA
Functions as part of structs,"Earlier it was mentioned that functions can be part of structs (see section
  2.5.13
 ). Such functions are called 
 member functions. This section briefly discusses how to define such functions.
  
 The code fragment below shows a struct having data fields for a person’s name and address. A function 
 print is included in the struct’s definition:
  
 struct Person 
  
 { 
  
  
 char name[80]; 
  
  
 char address[80];
  
  
 void print(); 
  
 };
  
 When defining the member function print the structure’s name (Person) and the scope resolution operator 
 (::) are used:
  
 void Person::print() 
  
 { 
  
  
 cout << ""Name: 
  
 "" << name << ""\n"" 
  
  
 ""Address: 
  
 "" << address << ’\n’; }
  
 The implementation of Person::print shows how the fields of the struct can be accessed without using the 
 structure’s type name. Here the function Person::print prints a variable name. Since Person::print is itself a 
 part of struct person, the variable name implicitly refers to the same type.
  
 This struct Person could be used as follows:
  
 Person person;",NA
3.3 ,NA,NA
More extensions to C,"3.3.1 
  
 References
  
 In addition to the common ways to define variables (plain variables or pointers)
  C++
  introduces references 
 defining synonyms for variables. A reference to a variable is like an alias; the variable and the reference can 
 both be used in statements involving the variable:
  
 int int_value; 
  
 int &ref = int_value;
  
 In the above example a variable int_value is defined. Subsequently a reference ref is defined, which (due to 
 its initialization) refers to the same memory location as int_value. In the definition of ref, the reference 
 operator & indicates that ref is not itself an int but a reference to one. The two statements
  
 ++int_value; 
  
 ++ref;
  
 have the same effect:
  
 they increment int_value’s value.
  
 Whether that location is called
  
 int_value or ref does not matter.
  
 References serve an important function in
  C++
  as a means to pass modifiable arguments to func-tions. E.g., 
 in standard
  C
 , a function that increases the value of its argument by five and returning nothing needs a 
 pointer parameter:
  
 void increase(int *valp) 
  
 // expects a pointer { 
  
  
 // to an int 
  
  
 *valp += 5; 
  
 }
  
 int main() 
  
 { 
  
  
 int x;
  
  
 increase(&x); 
  
 // pass x’s address }
  
 This construction can also be used in
  C++
  but the same effect is also achieved using a reference:
  
 void increase(int &valr) 
  
 // expects a reference { 
  
  
 // to an int 
  
  
 valr += 5; 
  
 }
  
 int main()",NA
3.4 ,NA,NA
New language-defined data types,"In
  C
  the following built-in data types are available: void, char, short, int, long, float and double.
  C++
  extends 
 these built-in types with several additional built-in types: the types bool, wchar_t, long long and long 
 double (Cf. ANSI/ISO draft (1995), par. 27.6.2.4.1 for examples of these very long types). The type long long 
 is merely a double-long long datatype. The type long double is merely a double-long double datatype. 
 These built-in types as well as pointer variables are called primitive types in the
  C++
  Annotations.",NA
3.5 ,NA,NA
A new syntax for casts,"Traditionally,
  C
  offers the following cast syntax:
  
 (typename)expression
  
 here typename is the name of a valid type, and expression is an expression.
  
 C
  style casts are now deprecated.
  C++
  programs should merely use the new style
  C++
  casts as they offer 
 the compiler facilities to verify the sensibility of the cast. Facilities which are not offered by the classic
  C
 -
 style cast.
  
 A cast should not be confused with the often used constructor notation:
  
 typename(expression)
  
 the constructor notation is not a cast, but a request to the compiler to construct an (anonymous) variable of 
 type typename from expression.
  
 If casts are really necessary one of several new-style casts should be used. These new-style casts are 
 introduced in the upcoming sections.
  
 3.5.1 The ‘static_cast’-operator
  
 The static_cast<type>(expression) is used to convert ‘conceptually comparable or related types’ to each 
 other. Here as well as in other
  C++
  style casts type is the type to which the type of expression should be 
 cast.
  
 Here are some examples of situations where the static_cast can (or should) be used:
  
 • When converting an int to a double.
  
 This happens, for example when the quotient of two int values must be computed without losing the 
 fraction part of the division. The sqrt function called in the following fragment returns 2:
  
 int x = 19; 
  
 int y = 4; 
  
 sqrt(x / y);
  
 whereas it returns 2.179 when a static_cast is used, as in:
  
 sqrt(static_cast<double>(x) / y);
  
 The important point to notice here is that a static_cast is allowed to change the represen-tation of its 
 expression into the representation that’s used by the destination type.",NA
3.6 ,NA,NA
Keywords and reserved names in C++,"C++
 ’s keywords are a superset of
  C
 ’s keywords. Here is a list of all keywords of the language:
  
 alignas 
  
 char32_t 
  
 enum namespace 
  
 return 
  
 typedef
  
 alignof 
  
 class 
  
 explicit new 
  
 short 
  
 typeid
  
 and 
  
 compl 
  
 export noexcept 
  
 signed 
  
 typename
  
 and_eq 
  
 concept 
  
 extern not 
  
 sizeof 
  
 union
  
 asm 
  
 const 
  
 false not_eq 
  
 static 
  
 unsigned
  
 auto 
  
 const_cast 
  
 float nullptr 
  
 static_assert using
  
 axiom 
  
 constexpr 
  
 for operator 
  
 static_cast 
  
 virtual
  
 bitand 
  
 continue 
  
 friend or 
  
 struct 
  
 void
  
 bitor 
  
 decltype 
  
 goto or_eq 
  
 switch 
  
 volatile
  
 bool 
  
 default 
  
 if private 
  
 template 
  
 wchar_t
  
 break 
  
 delete 
  
 import protected 
  
 this 
  
 while
  
 case 
  
 do 
  
 inline public 
  
 thread_local 
  
 xor
  
 catch 
  
 double 
  
 int register 
  
 throw 
  
 xor_eq
  
 char 
  
 dynamic_cast long reinterpret_cast true
  
 char16_t else 
  
 mutable requires 
  
 try
  
 Notes:
  
 • The export keyword is removed from the language under the C++11 standard, but remains a
  
 keyword, reserved for future use.
  
 • the operator keywords: 
  
 and, and_eq, bitand, bitor, compl, not, not_eq, or,
  
 or_eq, xor and xor_eq are symbolic alternatives for, respectively, &&, &=, &, |, ~, !,
  
 !=, ||, |=, ^ and ^=.
  
 • C++11 also recognizes the special identifiers final and override. These identifiers are spe-
  
 cial in the sense that they acquire special meanings when declaring classes or polymorphic
  
 functions. Section
  14.4
  provides further details.
  
 Keywords can only be used for their intended purpose and cannot be used as names for other entities
  
 (e.g., variables, functions, class-names, etc.). In addition to keywords identifiers starting with an
  
 underscore and living in the global namespace (i.e., not using any explicit namespace or using the
  
 mere :: namespace specification) or living in the std namespace are reserved identifiers in the sense
  
 that their use is a prerogative of the implementor.",NA
Chapter 4,NA,NA
Name Spaces,NA,NA
4.1 ,NA,NA
Namespaces,"Imagine a math teacher who wants to develop an interactive math program. For this program functions 
 like cos, sin, tan etc. are to be used accepting arguments in degrees rather than arguments in radians. 
 Unfortunately, the function name cos is already in use, and that function accepts radians as its arguments, 
 rather than degrees.
  
 Problems like these are usually solved by defining another name, e.g., the function name cosDegrees is 
 defined.
  C++
  offers an alternative solution through namespaces. Namespaces can be considered as areas or 
 regions in the code in which identifiers may be defined. Identifiers de-fined in a namespace normally won’t 
 conflict with names already defined elsewhere (i.e., outside of their namespaces). So, a function cos 
 (expecting angles in degrees) could be defined in a names-pace Degrees. When calling cos from within 
 Degrees you would call the cos function expecting degrees, rather than the standard cos function expecting 
 radians.
  
 Now that the ANSI/ISO standard has been implemented to a large degree in recent compilers, the use of 
 namespaces is more strictly enforced than in previous versions of compilers. This affects the setup of class 
 header files. At this point in the Annotations this cannot be discussed in detail, but in section
  7.12.1
  the 
 construction of header files using entities from namespaces is discussed.
  
 4.1.1 
  
 Defining namespaces
  
 Namespaces are defined according to the following syntax:
  
 namespace identifier 
  
 { 
  
  
 // declared or defined entities 
  
  
 // (declarative region) 
  
 }
  
 The identifier used when defining a namespace is a standard
  C++
  identifier.
  
 Within the declarative region, introduced in the above code example, functions, variables, structs, classes 
 and even (nested) namespaces can be defined or declared. Namespaces cannot be defined within a function 
 body. However, it is possible to define a namespace using multiple namespace
  
 57",NA
Chapter 5,NA,NA
The ‘string’ Data Type,"C++
  offers many solutions for common problems. Most of these facilities are part of the Standard Template 
 Library or they are implemented as generic algorithms (see chapter
  19
 ).
  
 Among the facilities
  C++
  programmers have developed over and over again are those manipulating chunks 
 of text, commonly called strings. The
  C
  programming language offers rudimentary string support.
  C
 ’s NTBS 
 is the foundation upon which an enormous amount of code has been built
 1
 .
  
 To process text
  C++
  offers a std::string type. In
  C++
  the traditional
  C
  library functions manipu-lating NTB 
 strings are deprecated in favor of using string objects. Many problems in
  C
  programs are caused by buffer 
 overruns, boundary errors and allocation problems that can be traced back to improperly using these 
 traditional
  C
  string library functions. Many of these problems can be prevented using
  C++
  string objects.
  
 Actually, string objects are class type variables, and in that sense they are comparable to stream objects 
 like cin and cout. In this section the use of string type objects is covered. The focus is on their definition and 
 their use. When using string objects the member function syntax is commonly used:
  
 stringVariable.operation(argumentList)
  
 For example, if string1 and string2 are variables of type std::string, then
  
 string1.compare(string2)
  
 can be used to compare both strings.
  
 In addition to the common member functions the string class also offers a wide variety of operators, like 
 the assignment (=) and the comparison operator (==). Operators often result in code that is easy to 
 understand and their use is generally preferred over the use of member functions offering comparable 
 functionality. E.g., rather than writing
  
 if (string1.compare(string2) == 0)
  
 the following is generally preferred:
  
 1
 Following the C++11 standard, an NTBS (null-terminated byte string, also NTB string) is a character sequence whose highest-
 addressed element with defined content has the value zero (the terminating null character); no other character in the sequence has 
 the value zero.
  
 69",NA
5.1 ,NA,NA
Operations on strings,"Some of the operations that can be performed on strings return indices within the strings. Whenever such 
 an operation fails to find an appropriate index, the value string::npos is returned. This value is a symbolic 
 value of type string::size_type, which is (for all practical purposes) an (unsigned) int.
  
 All string members accepting string objects as arguments also accept char const * (NTBS) arguments. The 
 same usually holds true for operators accepting string objects.
  
 Some string-members use iterators. Iterators are formally introduced in section
  18.2
 . Member functions 
 using iterators are listed in the next section (
 5.2
 ), but the iterator concept itself is not further covered by 
 this chapter.
  
 Strings support a large variety of members and operators. A short overview listing their capabilities is 
 provided in this section, with subsequent sections offering a detailed discussion. The bottom line: 
 C++
  
 strings are extremely versatile and there is hardly a reason for falling back on the
  C
  library to process text.
  
 C++
  strings handle all the required memory management and thus memory related problems, which is the 
 #1 source of problems in
  C
  programs, can be prevented when
  C++
  strings are used. Strings do come at a 
 price, though. The class’s extensive capabilities have also turned it into a beast. It’s hard to learn and 
 master all its features and in the end you’ll find that not all that you expected is actually there. For example, 
 std::string doesn’t offer case-insensitive comparisons. But in the end it isn’t even as simple as that. It is 
 there, but it is somewhat hidden and at this point in the
  C++
  Annotations it’s too early to study into that 
 hidden corner yet. Instead, realize that
  C
 ’s standard library does offer useful functions that can be used as 
 long as we’re aware of their limitations and are able to avoid their traps. So for now, to perform a 
 traditional case-insensitive comparison of the contents of two std::string objects str1 and str2 the following 
 will do:
  
 strcasecmp(str1.c_str(), str2.c_str());
  
 Strings support the following functionality:
  
 • initialization:
  
 when string objects are defined they are always properly initialized. In other words, they 
 are always in a valid state. Strings may be initialized empty or already existing text can be 
 used to initialize strings.
  
 • assignment:
  
 strings may be given new values. New values may be assigned using member func-tions 
 (like assign) but a plain assignment operator (i.e., =)may also be used. Fur-thermore, 
 assignment to a character buffer is also supported.",NA
5.2 ,NA,NA
A std::string reference,"In this section the string members and string-related operations are referenced. The subsections cover, 
 respectively the string’s initializers, iterators, operators, and member functions. The following terminology 
 is used throughout this section:
  
 • object is always a string-object;",NA
Chapter 6,NA,NA
The IO-stream Library,"Extending the standard stream (FILE) approach, well known from the
  C
  programming language, 
 C++
  offers 
 an input/output (I/O) library based on class concepts.
  
 All
  C++
  I/O facilities are defined in the namespace std. The std:: prefix is omitted below, except for 
 situations where this would result in ambiguities.
  
 Earlier (in chapter
  3
 ) we’ve seen several examples of the use of the
  C++
  I/O library, in particular showing 
 insertion operator (<<) and the extraction operator (>>). In this chapter we’ll cover I/O in more detail.
  
 The discussion of input and output facilities provided by the
  C++
  programming language heavily uses the 
 class concept and the notion of member functions. Although class construction has not yet been covered 
 (for that see chapter
  7
 ) and although inheritance is not covered formally before chapter
  13
 , it is quite 
 possible to discuss I/O facilities long before the technical background of class construction has been 
 covered.
  
 Most
  C++
  I/O classes have names starting with basic_ (like basic_ios). However, these basic_ names are not 
 regularly found in
  C++
  programs, as most classes are also defined using typedef definitions like:
  
 typedef basic_ios<char> ios;
  
 Since
  C++
  supports various kinds of character types (e.g., char, wchar_t), I/O facilities were devel-oped 
 using the template mechanism allowing for easy conversions to character types other than the traditional 
 char type. As elaborated in chapter
  21
 , this also allows the construction of generic soft-ware, that could 
 thereupon be used for any particular type representing characters. So, analogously to the above typedef 
 there exists a
  
 typedef basic_ios<wchar_t> wios;
  
 This type definition can be used for the wchar_t type. Because of the existence of these type defini-tions, 
 the basic_ prefix was omitted from the
  C++
  Annotations without loss of continuity. The
  C++ 
 Annotations 
 primarily focus on the standard 8-bits char type.
  
 Iostream objects cannot be declared using standard forward declarations, like:
  
 class std::ostream; 
  
 // now erroneous
  
 85",NA
6.1 ,NA,NA
Special header files,"Several iostream related header files are available. Depending on the situation at hand, the follow-ing 
 header files should be used:
  
 • iosfwd: sources should include this header file if only a declaration of the stream classes is required. 
 For example, if a function defines a reference parameter to an ostream then the compiler does not 
 need to know exactly what an ostream is. When declaring such a function the ostream class merely 
 needs to be be declared. One cannot use
  
 class std::ostream; // erroneous declaration
  
 void someFunction(std::ostream &str);
  
 but, instead, one should use:
  
 #include <iosfwd> 
  
 // correctly declares class ostream
  
 void someFunction(std::ostream &str);
  
 • <ios>: 
  
 sources should include this header file when using types and facilites (like 
  
 ios::off_type, see below) defined in the ios class.
  
 • <streambuf>: sources should include this header file when using streambuf or filebuf 
  
 classes. See 
 sections
  14.8
  and
  14.8.2
 .
  
 • <istream>: sources should include this preprocessor directive when using the class istream 
  
 or 
 when using classes that do both input and output. See section
  6.5.1
 .",NA
6.2 ,NA,NA
The foundation: the class ‘ios_base’,"The class std::ios_base forms the foundation of all I/O operations, and defines, among other things, facilities 
 for inspecting the state of I/O streams and most output formatting facilities. Every stream class of the I/O 
 library is, through the class ios, derived from this class, and inherits its capabilities. As ios_base is the 
 foundation on which all
  C++
  I/O was built, we introduce it here as the first class of the
  C++
  I/O library.
  
 Note that, as in
  C
 , I/O in
  C++
  is not part of the language (although it is part of the ANSI/ISO standard on
  
 C++
 ). Although it is technically possible to ignore all predefined I/O facilities, nobody does so, and the I/O 
 library therefore represents a de facto I/O standard for
  C++
 . Also note that, as mentioned before, the 
 iostream classes themselves are not responsible for the eventual I/O, but delegate this to an auxiliary class: 
 the class streambuf or its derivatives.
  
 It is neither possible nor required to construct an ios_base object directly. 
  
 Its construction is 
 always a side-effect of constructing an object further down the class hierarchy, like std::ios. Ios is the next 
 class down the iostream hierarchy (see figure
  6.1
 ). Since all stream classes in turn inherit from ios, and 
 thus also from ios_base, the distinction between ios_base and ios is in practice not important. Therefore, 
 facilities actually provided by ios_base will be discussed as facilities provided by ios. The reader who is 
 interested in the true class in which a particular facility is defined should consult the relevant header files 
 (e.g., ios_base.h and basic_ios.h).",NA
6.3 ,NA,NA
Interfacing ‘streambuf’ objects: the class ‘ios’,"The std::ios class is derived directly from ios_base, and it defines de facto the foundation for all stream 
 classes of the
  C++
  I/O library.
  
 Although it is possible to construct an ios object directly, this is seldom done. The purpose of the class ios is 
 to provide the facilities of the class basic_ios, and to add several new facilites, all related to the streambuf 
 object which is managed by objects of the class ios.
  
 All other stream classes are either directly or indirectly derived from ios. This implies, as explained in 
 chapter
  13
 , that all facilities of the classes ios and ios_base are also available to other stream classes. Before 
 discussing these additional stream classes, the features offered by the class ios (and by implication: by 
 ios_base) are now introduced.
  
 In some cases it may be required to include ios explicitly. An example is the situations where the formatting 
 flags themselves (cf. section
  6.3.2.2
 ) are referred to in source code.",NA
6.4,"cin >> ws;
  
 // skip white space
  
 cin.get();
  
 // returns ’X’",NA
Output,"In
  C++
  output is primarily based on the std::ostream class. The ostream class defines the basic operators 
 and members inserting information into streams: the insertion operator (<<), and special members like 
 write writing unformatted information to streams.
  
 The class ostream acts as base class for several other classes, all offering the functionality of the ostream 
 class, but adding their own specialties. In the upcoming sections the following classes are discussed:
  
 • The class ostream, offering the basic output facilities;
  
 • The class ofstream, allowing us to write files (comparable to
  C
 ’s fopen(filename, ""w""));
  
 • The class ostringstream, allowing us to write information to memory (comparable to
  C
 ’s 
  
 sprintf 
 function).
  
 6.4.1 Basic output: the class ‘ostream’
  
 The class ostream defines basic output facilities. The cout, clog and cerr objects are all ostream objects. All 
 facilities related to output as defined by the ios class are also available in the ostream class.
  
 We may define ostream objects using the following ostream constructor:
  
 • std::ostream object(std::streambuf *sb):
  
 this constructor creates an ostream object which is a wrapper around an existing 
 std::streambuf object. It isn’t possible to define a plain ostream object (e.g., using 
 std::ostream out;) that can thereupon be used for insertions. When cout or its friends are 
 used, we are actually using a predefined ostream object that has already been defined for 
 us and interfaces to the standard output stream using a (also predefined) streambuf object 
 handling the actual interfacing.
  
 It is, however, possible to define an ostream object passing it a 0-pointer. Such an object 
 cannot be used for insertions (i.e., it raises its ios::bad flag when something",NA
6.5 ,NA,NA
Input,"In
  C++
  input is primarily based on the std::istream class. The istream class defines the basic operators and 
 members extracting information from streams: the extraction operator (>>), and special members like 
 istream::read reading unformatted information from streams.",NA
6.6 ,NA,NA
Advanced topics,"6.6.1 Redirecting streams
  
 Using ios::rdbuf streams can be forced to share their streambuf objects. Thus information writ-ten to one 
 stream is actually written to another stream; a phenomenon normally called redirection. Redirection is 
 commonly implemented at the operating system level, and sometimes that is still necessary (see section
  
 24.2.3
 ).
  
 A common situation where redirection is useful is when error messages should be written to file rather 
 than to the standard error stream, usually indicated by its file descriptor number 2. In the Unix operating 
 system using the bash shell, this can be realized as follows:
  
 program 2>/tmp/error.log
  
 Following this command any error messages written by program are saved on the file /tmp/error.log, 
 instead of appearing on the screen.
  
 Here is an example showing how this can be implemented using streambuf objects. Assume program 
 expects an argument defining the name of the file to write the error messages to. It could be called as 
 follows:
  
 program /tmp/error.log
  
 The program looks like this, an explanation is provided below the program’s source text:",NA
Chapter 7,NA,NA
Classes,"The
  C
  programming language offers two methods for structuring data of different types. The
  C 
 struct holds 
 data members of various types, and the
  C
  union also defines data members of var-ious types. 
  
 However, a union’s data members all occupy the same location in memory and the 
 programmer may decide on which one to use.
  
 In this chapter classes are introduced. A class is a kind of struct, but its contents are by default inaccessible 
 to the outside world, whereas the contents of a
  C++
  struct are by default accessible to the outside world. In
  
 C++
  structs find little use: they are mainly used to aggregate data within the context of classes or to define 
 elaborate return values. Often a
  C++
  struct merely contains plain old data (POD, cf. section
  9.9
 ). In
  C++
  the 
 class is the main data structuring device, by default enforcing two core concepts of current-day software 
 engineering: data hiding and encapsulation (cf. sections
  3.2.1
  and
  7.1.1
 ).
  
 The union is another data structuring device the language offers. The traditional
  C
  union is still available in
  
 C++
 , but the C++11 standard adds unrestricted unions to the language. Unrestricted unions are unions 
 whose data fields may be of class types. The
  C++
  Annotations covers these unre-stricted unions in section
  
 12.6
 , after having introduced several other new concepts of
  C++
 ,
  
 C++
  extends the
  C
  struct and union concepts by allowing the definition of member functions (introduced in 
 this chapter) within these data types. Member functions are functions that can only be used with objects of 
 these data types or within the scope of these data types. Some of these member functions are special in that 
 they are always, usually automatically, called when an object starts its life (the so-called constructor) or 
 ends its life (the so-called destructor). These and other types of member functions, as well as the design 
 and construction of, and philosophy behind, classes are introduced in this chapter.
  
 We step-by-step construct a class Person, which could be used in a database application to store a person’s 
 name, address and phone number.
  
 Let’s start by creating a class Person right away. From the onset, it is important to make the distinction 
 between the class interface and its implementation. A class may loosely be defined as ‘a set of data and all 
 the functions operating on those data’. This definition is later refined but for now it is sufficient to get us 
 started.
  
 A class interface is a definition, defining the organization of objects of that class. Normally a defini-tion 
 results in memory reservation. E.g., when defining int variable the compiler ensures that some memory is 
 reserved in the final program storing variable’s values. Although it is a definition no memory is set aside by 
 the compiler once it has processed the class definition. But a class defini-tion follows the one definition 
 rule: in
  C++
  entities may be defined only once. As a class definition
  
 123",NA
7.1 ,NA,NA
The constructor,"C++
  classes may contain two special categories of member functions which are essential to the proper 
 working of the class. These categories are the constructors and the destructor. The destruc-tor’s primary 
 task is to return memory allocated by an object to the common pool when an object goes ‘out of scope’. 
 Allocation of memory is discussed in chapter
  9
 , and destructors are therefore be discussed in depth in that 
 chapter. In this chapter the emphasis is on the class’s organization and its constructors.
  
 Constructor are recognized by their names which is equal to the class name. 
  
 Constructors do 
 not specify return values, not even void. 
  
 E.g., the class Person may define a constructor 
 Person::Person(). The
  C++
  run-time system ensures that the constructor of a class is called when a variable 
 of the class is defined. It is possible to define a class lacking any constructor. In that case the compiler 
 defines a default constructor that is called when an object of that class is defined.",NA
7.2 ,NA,NA
Ambiguity resolution,"Defining objects may result in some unexpected surprises. Assume the following class interface is available:
  
 class Data 
  
 { 
  
  
 public: 
  
  
 Data(); 
  
  
 Data(int one); 
  
  
 Data(int one, int two);
  
 void display(); 
  
 };
  
 The intention is to define two objects of the class Data, using, respectively, the first and second 
 constructors. Your code looks like this (and compiles correctly):
  
 #include ""data.h"" 
  
 int main() 
  
 { 
  
  
 Data d1(); 
  
  
 Data d2(argc); 
  
 }
  
 Now it’s time to make some good use of the Data objects. You add two statements to main:
  
 d1.display(); 
  
 d2.display();
  
 But, surprise, the compiler complains about the first of these two:",NA
7.3 ,NA,NA
Objects inside objects: composition,"In the class Person objects are used as data members. This construction technique is called compo-sition.
  
 Composition is neither extraordinary nor
  C++
  specific: in
  C
  a struct or union field is commonly used in 
 other compound types. In
  C++
  it requires some special thought as their initialization some-times is subject 
 to restrictions, as discussed in the next few sections.
  
 7.3.1 Composition and const objects: const member initializers
  
 Unless specified otherwise object data members of classes are initialized by their default construc-tors. 
 Using the default constructor might not always be the optimal way to intialize an object and it might not 
 even be possible: a class might simply not define a default constructor.
  
 Earlier we’ve encountered the following constructor of the Person:
  
 Person::Person(string const &name, string const &address, 
  
  
 string 
 const &phone, size_t mass) 
  
 { 
  
  
 d_name = name; 
  
  
 d_address = address; 
  
  
 d_phone = phone; 
  
  
 d_mass = mass; 
  
 }
  
 Think briefly about what is going on in this constructor. In the constructor’s body we encounter 
 assignments to string objects. Since assignments are used in the constructor’s body their left-hand side 
 objects must exist. But when objects are coming into existence constructors must have been called. The 
 initialization of those objects is thereupon immediately undone by the body of Person’s constructor. That is 
 not only inefficient but sometimes downright impossible. Assume that the class interface mentions a string 
 const data member: a data member whose value is not supposed to change at all (like a birthday, which 
 usually doesn’t change very much and is therefore a good candidate for a string const data member). 
 Constructing a birthday object and providing it with an initial value is OK, but changing the initial value 
 isn’t.
  
 The body of a constructor allows assignments to data members. The initialization of data members happens 
 before that. 
  
 C++
  defines the member initializer syntax allowing us to specify the way data 
 members are initialized at construction time. Member initializers are specified as a list of",NA
7.4 ,NA,NA
Data member initializers,"Non-static data members of classes are usually initialized by the class’s constructors. Frequently (but not 
 always) the same initializations are used by different constructors, resulting in multiple points where the 
 initializations are performed, which in turn complicates class maintenance.
  
 Consider a class defining several data members: a pointer to data, a data member storing the num-ber of 
 data elements the pointer points at, a data member storing the sequence number of the object.
  
 The class also offer a basic set of constructors, as shown in the following class interface:
  
 class Container 
  
 { 
  
  
 Data *d_data; 
  
  
 size_t d_size; 
  
  
 size_t d_nr;
  
 static size_t s_nObjects;
  
  
 public: 
  
  
  
 Container(); 
  
  
  
 Container(Container const &other); 
  
  
 Container(Data *data, size_t size); 
  
  
 Container(Container &&tmp); 
  
 };
  
 The initial values of the data members are easy to describe, but somewhat hard to implement. Consider the 
 initial situation and assume the default constructor is used: all data members should be set to 0, except for 
 d_nr which must be given the value ++s_nObjects. Since these are non-default actions, we can’t declare the 
 default constructor using = default, but we must provide an actual implementation:
  
 Container() 
  
 : 
  
  
 d_data(0), 
  
  
 d_size(0), 
  
  
 d_nr(++s_nObjects) 
  
 {}
  
 In fact, all constructors require us to state the d_nr(++s_nObjects) initialization. So if d_data’s type would 
 have been a (move aware) class type, we would still have to provide implementations for all of the above 
 constructors.
  
 The C++11 standard, however, supports data member initializers, simplifying the initialization of non-
 static data members. Data member initializers allow us to assign initial values to data mem-bers. The 
 compiler must be able to compute these initial values from initialization expressions, but the initial values 
 do not have to be constant expressions. So ++s_nObjects can be an initial value.",NA
7.5 ,NA,NA
Uniform initialization,"When defining variables and objects they may immediately be given initial values. Class type objects are 
 always initialized using one of their available constructors.
  C
  already supports the array and struct 
 initializer list consisting of a list of constant expressions surrounded by a pair of curly braces.",NA
7.6 ,NA,NA
Defaulted and deleted class members,"In everyday class design two situations are frequently encountered:
  
 • A class offering constructors explicitly has to define a default constructor;
  
 • A class (e.g., a class implementing a stream) cannot initialize objects by copying the values from an 
 existing object of that class (called copy construction) and cannot assign objects to each other.
  
 Once a class defines at least one constructor its default constructor is not automatically defined by the 
 compiler. The C++11 standard relaxes that restriction somewhat by offering the ‘= default’syntax. A class 
 specifying ‘= default’ with its default constructor declaration indicates that the trivial default constructor 
 should be provided by the compiler. A trivial default constructor performs the following actions:
  
 • Its data members of built-in or primitive types are not initialized;
  
 • Its composed (class type) data members are initialized by their default constructors.
  
 • If the class is derived from a base class (cf. chapter
  13
 ) the base class is initialized by its default 
  
 constructor.
  
 Trivial implementations can also be provided for the copy constructor, the overloaded assignment 
 operator, and the destructor. Those members are introduced in chapter
  9
 .
  
 Conversely, situations exist where some (otherwise automatically provided) members should not be made 
 available. This is realized by specifying ‘= delete’. Using = default and = delete is illustrated by the following 
 example. The default constructor receives its trivial implementation, copy-construction is prevented:
  
 class Strings 
  
 { 
  
  
 public: 
  
  
 Strings() = default;",NA
7.7 ,NA,NA
Const member functions and const objects,"The keyword const is often used behind the parameter list of member functions. This keyword indicates 
 that a member function does not alter the data members of its object. 
  
 Such member 
 functions are called const member functions. In the class Person, we see that the accessor functions were 
 declared const:
  
 class Person 
  
 { 
  
  
 public: 
  
  
  
 std::string const &name() 
  
  
 const; 
  
  
 std::string const &address() const; 
  
  
 std::string const &phone() 
  
  
 const; 
  
  
 size_t mass() const; };
  
 The rule of thumb given in section
  3.1.3
  applies here too: whichever appears to the left of the keyword 
 const, is not altered. With member functions this should be interpreted as ‘doesn’t alter its own data’.
  
 When implementing a const member function the const attribute must be repeated:
  
 string const &Person::name() const 
  
 { 
  
  
 return d_name; 
  
 }
  
 The compiler prevents the data members of a class from being modified by one of its const member 
 functions. Therefore a statement like
  
 d_name[0] = toupper(static_cast<unsigned char>(d_name[0]));
  
 results in a compiler error when added to the above function’s definition.
  
 Const member functions are used to prevent inadvertent data modification. Except for constructors and the 
 destructor (cf. chapter
  9
 ) only const member functions can be used with (plain, references or pointers to) 
 const objects.
  
 Const objects are frequently encounterd as const & parameters of functions. Inside such functions only the 
 object’s const members may be used. Here is an example:
  
 void displayMass(ostream &out, Person const &person) 
  
 { 
  
  
 out << person.name() << "" weighs "" << person.mass() << "" kg.\n""; }",NA
7.8 ,NA,NA
Member function reference bindings (& and &&),TO DO,NA
7.9 ,NA,NA
The keyword ‘inline’,"Let us take another look at the implementation of the function Person::name():
  
 std::string const &Person::name() const 
  
 { 
  
  
 return d_name; 
  
 }
  
 This function is used to retrieve the name field of an object of the class Person. Example:
  
 void showName(Person const &person) 
  
 { 
  
  
 cout << person.name(); 
  
 }
  
 To insert person’s name the following actions are performed:
  
 • The function Person::name() is called.
  
 • This function returns person’s d_name as a reference.
  
 • The referenced name is inserted into cout.
  
 Especially the first part of these actions causes some time loss, since an extra function call is nec-essary to 
 retrieve the value of the name field. Sometimes a faster procedure immediately making the d_name data 
 member available is preferred without ever actually calling a function name. This can be realized using 
 inline functions. An inline function is a request to the compiler to insert the function’s code at the location 
 of the function’s call. This may speed up execution by avoiding a func-tion call, which typically comes with 
 some (stack handling and parameter passing) overhead. Note that inline is a request to the compiler: the 
 compiler may decide to ignore it, and will probably ignore it when the function’s body contains much code. 
 Good programming discipline suggests to be aware of this, and to avoid inline unless the function’s body is 
 fairly small. More on this in section 
 7.9.2
 .",NA
7.10 Local classes: classes inside functions,"Classes are usually defined at the global or namespace level. However, it is entirely possible to define a local 
 class, i.e., inside a function. Such classes are called local classes.
  
 Local classes can be very useful in advanced applications involving inheritance or templates (cf. section
  
 13.9
 ). At this point in the
  C++
  Annotations they have limited use, although their main features can be 
 described. At the end of this section an example is provided.
  
 • Local classes may use almost all characteristics of normal classes. They may have constructors, 
  
 destructors, data members, and member functions;
  
 • Local classes cannot define static data members. Static member functions, however, can be 
  
 defined.
  
 • Since a local class may define static member functions, it is possible to define nested functions in
  C++
  
 somewhat comparable to the way programming languages like
  Pascal
  allow nested functions to be 
 defined.",NA
7.11 The keyword ‘mutable’,"Earlier, in section
  7.7
 , the concepts of const member functions and const objects were introduced.
  
 C++
  also allows the declaration of data members which may be modified, even by const member func-tion. 
 The declaration of such data members in the class interface start with the keyword mutable.
  
 Mutable should be used for those data members that may be modified without logically changing the 
 object, which might therefore still be considered a constant object.
  
 An example of a situation where mutable is appropriately used is found in the implementation of a string 
 class. Consider the std::string’s c_str and data members. The actual data returned by the two members are 
 identical, but c_str must ensure that the returned string is terminated by an 0-byte. As a string object has 
 both a length and a capacity an easy way to implement c_str is to ensure that the string’s capacity exceeds 
 its length by at least one character. This invariant allows c_str to be implemented as follows:
  
 char const *string::c_str() const 
  
 { 
  
  
 d_data[d_length] = 0; 
  
  
 return d_data; 
  
 }
  
 This implementation logically does not modify the object’s data as the bytes beyond the object’s initial 
 (length) characters have undefined values. But in order to use this implementation d_data must be 
 declared mutable:
  
 mutable char *d_data;
  
 The keyword mutable is also useful in classes implementing, e.g., reference counting. Consider a class 
 implementing reference counting for textstrings. The object doing the reference counting might be a const 
 object, but the class may define a copy constructor. Since const objects can’t be modified, how would the 
 copy constructor be able to increment the reference count? Here the mutable key-word may profitably be 
 used, as it can be incremented and decremented, even though its object is a const object.
  
 The keyword mutable should sparingly be used. Data modified by const member functions should never 
 logically modify the object, and it should be easy to demonstrate this. As a rule of thumb: do not use 
 mutable unless there is a very clear reason (the object is logically not altered) for violating this rule.",NA
7.12 Header file organization,"In section
  2.5.10
  the requirements for header files when a
  C++
  program also uses
  C
  functions were 
 discussed. Header files containing class interfaces have additional requirements.
  
 First, source files. With the exception of the occasional classless function, source files contain the code of 
 member functions of classes. here there are basically two approaches:
  
 • All required header files for a member function are included in each individual source file.
  
 • All required header files (for all member functions of a class) are included in a header file that 
  
 is 
 included by each of the source files defining class members.",NA
7.13 Sizeof applied to class data members,"In the C++11 standard the sizeof operator can be applied to data members of classes without the need to 
 specify an object as well. Consider:
  
 class Data 
  
 { 
  
  
 std::string d_name; 
  
  
 ...
  
 };
  
 To obtain the size of Data’s d_name member C++11 allows the following expression:
  
 sizeof(Data::d_name);
  
 However, note that the compiler observes data protection here as well. Sizeof(Data::d_name) can only be 
 used where d_name may be visible as well, i.e., by Data’s member functions and friends.",NA
Chapter 8,NA,NA
Static Data And Functions,"In the previous chapters we provided examples of classes where each object had its own set of data 
 members data. Each of the class’s member functions could access any member of any object of its class.
  
 In some situations it may be desirable to define common data fields, that may be accessed by all objects of 
 the class. For example, the name of the startup directory, used by a program that recur-sively scans the 
 directory tree of a disk. A second example is a variable that indicates whether some specific initialization 
 has occurred. In that case the object that was constructed first would perform the initialization and would 
 set the flag to ‘done’.
  
 Such situations are also encountered in
  C
 , where several functions need to access the same variable. A 
 common solution in
  C
  is to define all these functions in one source file and to define the variable static: the 
 variable name is invisible outside the scope of the source file. This approach is quite valid, but violates our 
 philosophy of using only one function per source file. Another
  C
 -solution is to give the variable in question 
 an unusual name, e.g., _6uldv8, hoping that other program parts won’t use this name by accident. Neither 
 the first, nor the second legacy
  C
  solution is elegant.
  
 C++
  solves the problem by defining static members: data and functions, common to all objects of a class 
 and (when defined in the private section) inaccessible outside of the class. These static members are this 
 chapter’s topic.
  
 Static members cannot be defined as virtual functions. A virtual member function is an ordinary member in 
 that it has a this pointer. As static member functions have no this pointer, they cannot be declared virtual.",NA
8.1 ,NA,NA
Static data,"Any data member of a class can be declared static; be it in the public or private section of the class 
 interface. Such a data member is created and initialized only once, in contrast to non-static data members 
 which are created again and again for each object of the class.
  
 Static data members are created as soon as the program starts. Even though they’re created at the very 
 beginning of a program’s execution cycle they are nevertheless true members of their classes.
  
 It is suggested to prefix the names of static member with s_ so they may easily be distinguished (in class 
 member functions) from the class’s data members (which should preferably start with d_).
  
 163",NA
8.2,"};
  
 //
  
 expression",NA
Static member functions,"In addition to static data members,
  C++
  allows us to define static member functions. Similar to static data 
 that are shared by all objects of the class, static member functions also exist without any associated object 
 of their class.
  
 Static member functions can access all static members of their class, but also the members (private or 
 public) of objects of their class if they are informed about the existence of these objects (as in",NA
Chapter 9,NA,NA
Classes And Memory Allocation,"In contrast to the set of functions that handle memory allocation in
  C
  (i.e., malloc etc.), memory allocation 
 in
  C++
  is handled by the operators new and delete. Important differences between malloc and new are:
  
 • The function malloc doesn’t ‘know’ what the allocated memory will be used for. E.g., when memory for 
 ints is allocated, the programmer must supply the correct expression using a multiplication by 
 sizeof(int). In contrast, new requires a type to be specified; the sizeof expression is implicitly handled 
 by the compiler. Using new is therefore type safe.
  
 • Memory allocated by malloc is initialized by calloc, initializing the allocated characters to a 
 configurable initial value. This is not very useful when objects are available. As operator new knows 
 about the type of the allocated entity it may (and will) call the constructor of an allocated class type 
 object. This constructor may be also supplied with arguments.
  
 • All
  C
 -allocation functions must be inspected for NULL-returns. This is not required anymore when 
 new is used. In fact, new’s behavior when confronted with failing memory allocation is configurable 
 through the use of a new_handler (cf. section
  9.2.2
 ).
  
 A comparable relationship exists between free and delete: delete makes sure that when an object is 
 deallocated, its destructor is automatically called.
  
 The automatic calling of constructors and destructors when objects are created and destroyed has 
 consequences which we shall discuss in this chapter. Many problems encountered during
  C
  program 
 development are caused by incorrect memory allocation or memory leaks: memory is not allocated, not 
 freed, not initialized, boundaries are overwritten, etc..
  C++
  does not ‘magically’ solve these problems, but it 
 does provide us with tools to prevent these kinds of problems.
  
 As a consequence of malloc and friends becoming deprecated the very frequently used str... functions, like 
 strdup, that are all malloc based, should be avoided in
  C++
  programs. Instead, the facilities of the string 
 class and operators new and delete should be used instead.
  
 Memory allocation procedures influence the way classes dynamically allocating their own memory should 
 be designed. Therefore, in this chapter these topics are discussed in addition to discussions about 
 operators new and delete. We’ll first cover the peculiarities of operators new and delete, followed by a 
 discussion about:
  
 • the destructor: the member function that’s called when an object ceases to exist;
  
 • the assignment operator, allowing us to assign an object to another object of its own class;
  
 175",NA
9.1 ,NA,NA
Operators ‘new’ and ‘delete’,"C++
  defines two operators to allocate memory and to return it to the ‘common pool’. These operators are, 
 respectively new and delete.
  
 Here is a simple example illustrating their use. An int pointer variable points to memory allocated by 
 operator new. This memory is later released by operator delete.
  
 int *ip = new int; 
  
 delete ip;
  
 Here are some characteristics of operators new and delete:
  
 • new and delete are operators and therefore do not require parentheses, as required for func-
  
 tions like malloc and free;
  
 • new returns a pointer to the kind of memory that’s asked for by its operand (e.g., it returns a 
  
 pointer to an int);
  
 • new uses a type as its operand, which has the important benefit that the correct amount of 
  
 memory, 
 given the type of the object to be allocated, is made available;
  
 • as a consequence, new is a type safe operator as it always returns a pointer to the type that was 
 mentioned as its operand. In addition, the type of the receving pointer must match the type specified 
 with operator new;
  
 • new may fail, but this is normally of no concern to the programmer. In particular, the program does 
 not have to test the success of the memory allocation, as is required for malloc and friends. Section
  
 9.2.2
  delves into this aspect of new;
  
 • delete returns void;
  
 • for each call to new a matching delete should eventually be executed, lest a memory leak 
  
 occurs;
  
 • delete can safely operate on a 0-pointer (doing nothing);
  
 • otherwise delete must only be used to return memory allocated by new. It should not be used 
  
 to 
 return memory allocated by malloc and friends.
  
 • in
  C++
  malloc and friends are deprecated and should be avoided.
  
 Operator new can be used to allocate primitive types but also to allocate objects. When a primitive type or 
 a struct type without a constructor is allocated the allocated memory is not guaranteed to be initialized to 
 0, but an initialization expression may be provided:
  
 int *v1 = new int; 
  
 int *v1 = new int(); int *v2 = 
 new int(3);
  
 // not guaranteed to be initialized to 0 // initialized to 
 0 
  
 // initialized to 3
  
 int *v3 = new int(3 * *v2); // initialized to 9",NA
9.2 ,NA,NA
The destructor,"Comparable to the constructor, classes may define a destructor. This function is the constructor’s 
 counterpart in the sense that it is invoked when an object ceases to exist. A destructor is usually called 
 automatically, but that’s not always true. The destructors of dynamically allocated objects are not 
 automatically activated, but in addition to that: when a program is interrupted by an exit call, only the 
 destructors of already initialized global objects are called. In that situation destructors of objects defined 
 locally by functions are also not called. This is one (good) reason for avoiding exit in
  C++
  programs.
  
 Destructors obey the following syntactical requirements:
  
 • a destructor’s name is equal to its class name prefixed by a tilde;
  
 • a destructor has no arguments;
  
 • a destructor has no return value.
  
 Destructors are declared in their class interfaces. Example:
  
 class Strings 
  
 { 
  
  
 public: 
  
  
  
 Strings(); 
  
  
  
 ~Strings(); 
  
 // the destructor };
  
 By convention the constructors are declared first. The destructor is declared next, to be followed by other 
 member functions.
  
 A destructor’s main task is to ensure that memory allocated by an object is properly returned when the 
 object ceases to exist. Consider the following interface of the class Strings:
  
 class Strings 
  
 { 
  
  
 std::string *d_string; 
  
  
 size_t d_size;
  
 public: 
  
 Strings(); 
  
 Strings(char const *const *cStrings, size_t n); ~Strings();
  
  
 std::string const &at(size_t idx) const; 
  
 size_t size() 
 const; 
  
 };
  
 The constructor’s task is to initialize the data fields of the object. E.g, its constructors are defined as follows:
  
 Strings::Strings() 
  
 : 
  
  
 d_string(0),",NA
9.3 ,NA,NA
The assignment operator,"In
  C++
  struct and class type objects can be directly assigned new values in the same way as this is possible 
 in
  C
 . The default action of such an assignment for non-class type data members is a straight byte-by-byte 
 copy from one data member to another. For now we’ll use the following simple class Person:
  
 class Person 
  
 { 
  
  
 char *d_name; 
  
  
 char *d_address; 
  
  
 char *d_phone;
  
 public: 
  
  
 Person(); 
  
  
 Person(char const *name, char const *addr, char const *phone); 
  
 ~Person(); 
  
 private:
  
 };
  
 char *strdupnew(char const *src); 
  
 // returns a copy of src.
  
 // strdupnew is easily implemented, here is its inline implementation: inline char 
 *Person::strdupnew(char const *src) 
  
 { 
  
  
 return strcpy(new char [strlen(src) + 1], src); 
  
 }
  
 2
 http://www.linuxdevcenter.com/pub/a/linux/2006/11/30/linux-out-of-memory.html",NA
9.4 ,NA,NA
The ‘this’ pointer,"A member function of a given class is always called in combination with an object of its class. There is 
 always an implicit ‘substrate’ for the function to act on.
  C++
  defines a keyword, this, to reach this substrate.
  
 The this keyword is a pointer variable that always contains the address of the object for which the member 
 function was called. The this pointer is implicitly declared by each member function (whether public, 
 protected, or private). The this ponter is a constant pointer to an object of the member function’s class. For 
 example, the members of the class Person implicitly declare:
  
 extern Person *const this;
  
 A member function like Person::name could be implemented in two ways: with or without using the this 
 pointer:
  
 char const *Person::name() const { 
  
  
 return d_name; 
  
 }
  
 char const *Person::name() const { 
  
  
 return this->d_name; 
  
 }
  
 // implicitly using ‘this’
  
 // explicitly using ‘this’
  
 The this pointer is seldom explicitly used, but situations do exist where the this pointer is actually required 
 (cf. chapter
  16
 ).
  
 9.4.1 Sequential assignments and this
  
 C++
 ’s syntax allows for sequential assignments, with the assignment operator associating from right to left. 
 In statements like:
  
 a = b = c;",NA
9.5 ,NA,NA
The copy constructor: initialization vs. assignment,"Consider the class Strings, introduced in section
  9.2
 , once again. As it contains several primitive type data 
 members as well as a pointer to dynamically allocated memory it needs a constructor, a destructor, and an 
 overloaded assignment operator. In fact the class offers two constructors: in addition to the default 
 constructor it offers a constructor expecting a char const *const * and a size_t.
  
 Now consider the following code fragment. The statement references are discussed following the example:
  
 int main(int argc, char **argv) 
  
 { 
  
  
 Strings s1(argv, argc); // (1) 
  
  
 Strings s2; // (2) 
  
  
 Strings s3(s1); // (3)
  
  
 s2 = s1; // (4) }",NA
9.6 ,NA,NA
Revising the assignment operator,"The overloaded assignment operator has characteristics also encountered with the copy constructor and 
 the destructor:
  
 • The copying of (private) data occurs (1) in the copy constructor and (2) in the overloaded as-
  
 signment function.
  
 • Allocated memory is deleted (1) in the overloaded assignment function and (2) in the destructor.
  
 The copy constructor and the destructor clearly are required. If the overloaded assignment operator also 
 needs to return allocated memory and to assign new values to its data members couldn’t the destructor 
 and copy constructor be used for that?
  
 As we’ve seen in our discussion of the destructor (section
  9.2
 ) the destructor can explicitly be called, but 
 that doesn’t hold true for the (copy) constructor. But let’s briefly summarize what an overloaded 
 assignment operator is supposed to do:
  
 • It should delete the dynamically allocated memory controlled by the current object;",NA
3,NA,NA
4,199,NA
1,NA,NA
2,NA,NA
Before Swapping 2 and 3,NA,NA
1,NA,NA
3,NA,NA
2,NA,NA
4,NA,NA
After Swapping 2 and 3,"Figure 9.3: Swapping a linked list
  
 There is even a swap generic algorithm (cf. section
  19.1.61
 ), which is commonly implemented using the 
 assignment operator. When implementing a swap member for our class Strings it could be used, provided 
 that all of String’s data members can be swapped. As this is true (why this is true is discussed shortly) we 
 can augment class Strings with a swap member:
  
 void Strings::swap(Strings &other) 
  
 { 
  
  
 swap(d_string, other.d_string); 
  
  
 swap(d_size, other.d_size); 
  
 }
  
 Having added this member to Strings the copy-and-swap implementation of String::operator= can now be 
 used.
  
 When two variables (e.g., double one and double two) are swapped, each one holds the other one’s value 
 after the swap. So, if one == 12.50 and two == -3.14 then after swap(one, two) one == -3.14 and two == 
 12.50.
  
 Variables of primitive data types (pointers and the built-in types) can be swapped, class-type objects can be 
 swapped if their classes offer a swap member.
  
 So should we provide our classes with a swap member, and if so, how should it be implemented?
  
 The above example (Strings::swap) shows the standard way to implement a swap member: each of its data 
 members are swapped in turn. But there are situations where a class cannot implement a swap member 
 this way, even if the class only defines data members of primitive data types. Consider the situation 
 depicted in figure
  9.3
 .
  
 In this figure there are four objects, each object has a pointer pointing to the next object. The basic 
 organization of such a class looks like this:
  
 class List 
  
 { 
  
  
 List *d_next; 
  
  
 ...
  
 };
  
 Initially four objects have their d_next pointer set to the next object: 1 to 2, 2 to 3, 3 to 4. This is shown in 
 the upper half of the figure. At the bottom half it is shown what happens if objects 2 and 3",NA
Before:,NA,NA
&,NA,NA
&b,NA,NA
&,NA,NA
&d,NA,NA
a,NA,NA
c,NA,NA
b,NA,NA
d,NA,NA
After:,NA,NA
&,NA,NA
&d,NA,NA
&,NA,NA
&b,NA,NA
a,NA,NA
c,NA,NA
b,NA,NA
d,"Figure 9.4: Swapping objects with self-referential data
  
 are swapped: 3’s d_next point is now at object 2, which still points to 4; 2’s d_next pointer points to 3’s 
 address, but 2’s d_next is now at object 3, which is therefore pointing to itself. Bad news! Another situation 
 where swapping of objects goes wrong happens with classes having data members pointing or referring to 
 data members of the same object. Such a situation is shown in figure
  9.4
 .
  
 Here, objects have two data members, as in the following class setup:
  
 class SelfRef 
  
 {
  
 };
  
 size_t *d_ownPtr; // initialized to &d_data
  
 size_t d_data;
  
 The top-half of figure
  9.4
  shows two objects; their upper data members pointing to their lower data 
 members. But if these objects are swapped then the situation shown in the figure’s bottom half is 
 encountered. Here the values at addresses a and c are swapped, and so, rather than pointing to their 
 bottom data members they suddenly point to other object’s data members. Again: bad news.
  
 The common cause of these failing swapping operations is easily recognized: simple swapping oper-ations 
 must be avoided when data members point or refer to data that is involved in the swapping. If, in figure
  9.4
  
 the a and c data members would point to information outside of the two objects (e.g., if they would point to 
 dynamically allocated memory) then the simple swapping would succeed.
  
 However, the difficulty encountered with swapping SelfRef objects does not imply that two SelfRef objects 
 cannot be swapped; it only means that we must be careful when designing swap members. Here is an 
 implementation of SelfRef::swap:
  
 void SelfRef::swap(SelfRef &other) 
  
 { 
  
  
 swap(d_data, other.d_data); 
  
 }",NA
9.7 ,NA,NA
Moving data,"Before the advent of the C++11 standard
  C++
  offered basically two ways to assign the information pointed 
 to by a data member of a temporary object to an lvalue object. Either a copy constructor or reference 
 counting had to be used. The C++11 standard adds move semantics to these two, allowing transfer of the 
 data pointed to by a temporary object to its destination.
  
 Moving information is based on the concept of anonymous (temporary) data. Temporary values are 
 returned by functions like operator-() and operator+(Type const &lhs, Type const &rhs), and in general by 
 functions returning their results ‘by value’ instead of returning references or pointers.
  
 Anonymous values are always short-lived. When the returned values are primitive types (int, double, etc.) 
 nothing special happens, but if a class-type object is returned by value then its de-structor can be called 
 immediately following the function call that produced the value. In any case, the value itself becomes 
 inaccessible immediately after the call. Of course, a temporary return value may be bound to a reference 
 (lvalue or rvalue), but as far as the compiler is concerned the value now has a name, which by itself ends its 
 status as a temporary value.
  
 In this section we concentrate on anonymous temporary values and show how they can be used to improve 
 the efficiency of object construction and assignment. These special construction and assignment methods",NA
9.8 ,NA,NA
Copy Elision and Return Value Optimization,"When the compiler selects a member function (or constructor) it applies a simple set of rules, match-ing 
 arguments with parameter types.
  
 Below two tables are shown. The first table should be used in cases where a function argument has a name, 
 the second table should be used in cases where the argument is anonymous. In each table select the const 
 or non-const column and then use the topmost overloaded function that is available having the specified 
 parameter type.",NA
9.9 ,NA,NA
Plain Old Data,"C++
  inherited the struct concept from
  C
  and extended it with the class concept. Structs are still used in
  C++
 , 
 mainly to store and pass around aggregates of different data types. A commonly term for these structs is 
 plain old data (pod). Plain old data is commonly used in
  C++
  programs to aggre-gate data. E.g., when a 
 function needs to return a double, bool and std::string these three different data types may be aggregated 
 using a struct that merely exists to pass along values. Data protection and functionality is hardly ever an 
 issue. For such cases
  C
  and
  C++
  use structs. But as a
  C++
  struct is just a class with special access rights 
 some members (constructors, de-structor, overloaded assignment operator) may implicitly be defined. The 
 plain old data capitalizes on this concept by requiring that its definition remains as simple as possible. 
 Specifically the C++11 standard considers pod to be a class or struct having the following characteristics:
  
 • it has a trivial default constructor.
  
 If a type has some trivial member then the type (or its base class(es), cf. chapter
  13
 ) does not 
 explicitly define that member. Rather, it is supplied by the compiler. A trivial default constructor 
 leaves all its non-class data members unitialized and calls the default constructors of all its class data 
 members. A class having a trivial default constructor does not define any constructor at all (nor 
 does/do its base class/classes). It may also define the default constructor using the default 
 constructor syntax introduced in section
  7.6
 ;",NA
9.10 Conclusion,"Four important extensions to classes were introduced in this chapter: the destructor, the copy con-
 structor, the move constructor and the overloaded assignment operator. In addition the importance of 
 swapping, especially in combination with the overloaded assignment operator, was stressed.
  
 Classes having pointer data members, pointing to dynamically allocated memory controlled by the objects 
 of those classes, are potential sources of memory leaks. The extensions introduced in this chapter 
 implement the standard defense against such memory leaks.
  
 Encapsulation (data hiding) allows us to ensure that the object’s data integrity is maintained. The 
 automatic activation of constructors and destructors greatly enhance our capabilities to ensure the data 
 integrity of objects doing dynamic memory allocation.
  
 A simple conclusion is therefore that classes whose objects allocate memory controlled by themselves must 
 at least implement a destructor, an overloaded assignment operator and a copy constructor. Implementing 
 a move constructor remains optional, but it allows us to use factory functions with classes not allowing 
 copy construction and/or assignment.
  
 In the end, assuming the availability of at least a copy or move constructor, the compiler might avoid them 
 using copy elision. The compiler is free to use copy elision wherever possible; it is,",NA
Chapter 10,NA,NA
Exceptions,"C
  supports several ways for a program to react to situations breaking the normal unhampered flow of a 
 program:
  
 • The function may notice the abnormality and issue a message. 
  
 This is probably the least 
  
 disastrous reaction a program may show.
  
 • The function in which the abnormality is observed may decide to stop its intended task, re-turning an 
 error code to its caller. This is a great example of postponing decisions: now the calling function is 
 faced with a problem. Of course the calling function may act similarly, by passing the error code up to 
 its caller.
  
 • The function may decide that things are going out of hand, and may call exit to terminate the program 
 completely. A tough way to handle a problem if only because the destructors of local objects aren’t 
 activated.
  
 • The function may use a combination of the functions setjmp and longjmp to enforce non-local exits. 
 This mechanism implements a kind of goto jump, allowing the program to continue at an outer level, 
 skipping the intermediate levels which would have to be visited if a series of returns from nested 
 functions would have been used.
  
 In
  C++
  all these flow-breaking methods are still available. However, of the mentioned alternatives, setjmp 
 and longjmp isn’t frequently encountered in
  C++
  (or even in
  C
 ) programs, due to the fact that the program 
 flow is completely disrupted.
  
 C++
  offers exceptions as the preferred alternative to, e.g., setjmp and longjmp. Exceptions allow 
 C++
  
 programs to perform a controlled non-local return, without the disadvantages of longjmp and setjmp.
  
 Exceptions are the proper way to bail out of a situation which cannot be handled easily by a function itself, 
 but which is not disastrous enough for a program to terminate completely. Also, exceptions provide a 
 flexible layer of control between the short-range return and the crude exit.
  
 In this chapter exceptions are covered. First an example is given of the different impact exceptions and the 
 setjmp/longjmp combination have on programs. This example is followed by a discussion of the formal 
 aspects of exceptions. In this part the guarantees our software should be able to offer when confronted 
 with exceptions are presented. Exceptions and their guarantees have consequences for constructors and 
 destructors. We’ll encounter these consequences at the end of this chapter.
  
 217",NA
Exception syntax,CHAPTER 10. EXCEPTIONS,NA
10.1,"Before contrasting the traditional
  C
  way of handling non-local gotos with exceptions let’s introduce the 
 syntactic elements that are involved when using exceptions.
  
 • Exceptions are generated by a throw statement. The keyword throw, followed by an expres-sion of a 
 certain type, throws the expression value as an exception. In
  C++
  anything having value semantics 
 may be thrown as an exception: an int, a bool, a string, etc. However, there also exists a standard 
 exception type (cf. section
  10.8
 ) that may be used as base class (cf. chapter
  13
 ) when defining new 
 exception types.
  
 • Exceptions are generated within a well-defined local environment, called a try-block. The run-time 
 support system ensures that all of the program’s code is itself surrounded by a global try block. Thus, 
 every exception generated by our code will always reach the boundary of at least one try-block. A 
 program terminates when an exception reaches the boundary of the global try block, and when this 
 happens destructors of local and global objects that were alive at the point where the exception was 
 generated are not called. This is not a desirable situation and therefore all exceptions should be 
 generated within a try-block explicitly defined by the program. Here is an example of a string 
 exception thrown from within a try-block:
  
 try 
  
 { 
  
  
 // any code can be defined here 
  
  
 if (someConditionIsTrue) 
  
  
 throw string(""this is the std::string exception""); 
  
 // any code can be 
 defined here 
  
 }
  
 • catch: Immediately following the try-block, one or more catch-clauses must be defined. A catch-clause 
 consists of a catch-header defining the type of the exception it can catch followed by a compound 
 statement defining what to do with the caught exception:
  
 catch (string const &msg) 
  
 { 
  
  
 // statements in which the caught string object are handled }
  
 Multiple catch clauses may appear underneath each other, one for each exception type that has to be 
 caught. In general the catch clauses may appear in any order, but there are excep-tions requiring a 
 specific order. To avoid confusion it’s best to put a catch clause for the most general exception last. At 
 most one exception clause will be activated.
  C++
  does not support a 
 Java
 -style finally-clause 
 activated after completing a catch clause.",NA
10.2 ,NA,NA
An example using exceptions,"In the following examples the same basic program is used. The program uses two classes, Outer and Inner.
  
 First, an Outer object is defined in main, and its member Outer::fun is called. 
  
 Then, in 
 Outer::fun an Inner object is defined. Having defined the Inner object, its member Inner::fun is called.",NA
10.3 Throwing exceptions,"Exceptions are generated by throw statements. The throw keyword is followed by an expression, defining 
 the thrown exception value. Example:
  
 throw ""Hello world"";
  
 // throws a char *",NA
10.4 ,NA,NA
The try block,"The try-block surrounds throw statements. Remember that a program is always surrounded by a global try 
 block, so throw statements may appear anywhere in your code. More often, though, throw statements are 
 used in function bodies and such functions may be called from within try blocks.
  
 A try block is defined by the keyword try followed by a compound statement. This block, in turn, must be 
 followed by at least one catch handler:
  
 try 
  
 { 
  
  
 // any statements here 
  
 } 
  
 catch(...) 
  
 // at least one catch clause here {}
  
 Try-blocks are commonly nested, creating exception levels. For example, main’s code is surrounded by a 
 try-block, forming an outer level handling exceptions. Within main’s try-block functions are called which 
 may also contain try-blocks, forming the next exception level. As we have seen (section 
 10.3.1
 ), exceptions 
 thrown in inner level try-blocks may or may not be processed at that level. By",NA
10.5 Catching exceptions,"A catch clause consists of the keyword catch followed by a parameter list defining one parameter 
 specifying type and (parameter) name of the exception caught by that particular catch handler. This name 
 may then be used as a variable in the compound statement following the catch clause.
  
 Example:
  
 catch (string &message) 
  
 { 
  
  
 // code to handle the message 
  
 }
  
 Primitive types and objects may be thrown as exceptions. It’s a bad idea to throw a pointer or refer-ence to 
 a local object, but a pointer to a dynamically allocated object may be thrown if the exception handler 
 deletes the allocated memory to prevent a memory leak. Nevertheless, throwing such a pointer is 
 dangerous as the exception handler won’t be able to distinguish dynamically allocated memory from non-
 dynamically allocated memory, as illustrated by the next example:
  
 try 
  
 { 
  
  
 static int x; 
  
  
 int *xp = &x;
  
 if (condition1) 
  
  
 throw xp;
  
  
 xp = new int(0); 
  
  
 if (condition2) 
  
  
  
 throw xp; 
  
 } 
  
 catch (int *ptr) 
  
 { 
  
  
 // delete ptr or not?
  
 }
  
 Close attention should be paid to the nature of the parameter of the exception handler, to make sure that 
 when pointers to dynamically allocated memory are thrown the memory is returned once the handler has 
 processed the pointer. In general pointers should not be thrown as exceptions. If dynamically allocated 
 memory must be passed to an exception handler then the pointer should be wrapped in a smart pointer, 
 like unique_ptr or shared_ptr (cf. sections
  18.3
  and
  18.4
 ).
  
 Multiple catch handlers may follow a try block, each handler defining its own exception type. The order of 
 the exception handlers is important. When an exception is thrown, the first exception handler matching the 
 type of the thrown exception is used and remaining exception handlers are ignored. Eventually at most one 
 exception handler following a try-block is activated. Normally this is of no concern as each exception has its 
 own unique type.
  
 Example: if exception handlers are defined for char *s and void *s then NTB strings are caught by the 
 former handler. Note that a char * can also be considered a void *, but the exception type",NA
10.6 ,NA,NA
Declaring exception throwers (deprecated),"Functions defined elsewhere may be linked to code that uses these functions. Such functions are normally 
 declared in header files, either as standalone functions or as class member functions.
  
 Those functions may of course throw exceptions. Declarations of such functions may contain a (now 
 deprecated, see also section
  23.7
 ) function throw list or exception specification list specifying the types of 
 the exceptions that can be thrown by the function. For example, a function that may throw‘char *’ and ‘int’ 
 exceptions can be declared as
  
 void exceptionThrower() throw(char *, int);",NA
10.7 Iostreams and exceptions,"The
  C++
  I/O library was used well before exceptions were available in
  C++
 . Hence, normally the classes of 
 the iostream library do not throw exceptions. However, it is possible to modify that behav-ior using the 
 ios::exceptions member function. This function has two overloaded versions:
  
 • ios::iostate exceptions():
  
 this member returns the state flags for which the stream will throw exceptions;
  
 • void exceptions(ios::iostate state)
  
 this member causes the stream to throw an exception when state state is observed.
  
 In
  
 the
  
 I/O
  
 library,
  
 exceptions
  
 are
  
 objects
  
 of
  
 the
  
 class
  
 ios::failure,
  
 derived
  
 from
  
 ios::exception. A std::string const &message may be specified when defining a failure object. Its message 
 may then be retrieved using its virtual char const *what() const mem-ber.
  
 Exceptions should be used in exceptional circumstances. 
  
 Therefore, we think it is questionable to 
 have stream objects throw exceptions for fairly normal situations like EOF. Using exceptions to handle 
 input errors might be defensible (e.g., in situations where input errors should not occur and imply a 
 corrupted file) but often aborting the program with an appropriate error message would probably be the 
 more appropriate action. As an example consider the following interactive program using exceptions to 
 catch incorrect input:
  
 #include <iostream> 
  
 #include <climits> 
  
 using namespace::std;
  
 int main() 
  
 {
  
 cin.exceptions(ios::failbit); while (true) 
  
 { 
  
  
 try 
  
  
 {
  
 // throw exception on fail
  
  
 cout << ""enter a number: ""; 
  
  
 int value; 
  
  
 cin >> value; 
  
  
 cout << ""you entered "" << value << ’\n’; } 
  
 catch (ios::failure const &problem) 
  
 { 
  
  
 cout << problem.what() << ’\n’;",NA
10.8 ,NA,NA
Standard Exceptions,"All data types may be thrown as exceptions. Several additional exception classes are now defined by the
  
 C++
  standard. Before using those additional exception classes the <stdexcept> header file must be 
 included. All of these standard exceptions are class types by themselves, but also offer all facilities of the 
 std::exception class and objects of the standard exception classes may also be considered objects of the 
 std::exception class.
  
 The std::exception class offers the member
  
 char const *what() const;
  
 describing in a short textual message the nature of the exception.
  
 C++
  defines the following standard exception classes:
  
 • std::bad_alloc (this requires the <new> header file): thrown when operator new fails;
  
 • std::bad_exception (this requires the header file <exception> header file): thrown when 
  
 a function 
 tries to generate another type of exception than declared in its function throw list;
  
 • std::bad_cast (this requires the <typeinfo> header file): thrown in the context of polymor-
  
 phism (see 
 section
  14.6.1
 );
  
 • std::bad_typeid (this requires the <typeinfo> header file): also thrown in the context of 
  
 polymorphism (see section
  14.6.2
 );
  
 All additional exception classes were derived from std::exception. The constructors of all these additional 
 classes accept std::string const & arguments summarizing the reason for the ex-ception (retrieved by the 
 exception::what member). The additionally defined exception classes are:
  
 • std::domain_error: a (mathematical) domain error is detected;
  
 • std::invalid_argument: the argument of a function has an invalid value;
  
 • std::length_error: thrown when an object would have exceeded its maximum permitted 
  
 length;
  
 • std::logic_error: a logic error should be thrown when a problem is detected in the internal logic of the 
 program. Example: a function like
  C
 ’s printf is called with more arguments than there are format 
 specifiers in its format string;
  
 • std::out_of_range: thrown when an argument exceeds its permitted range. 
  
 Example: 
  
 thrown by at members when their arguments exceed the range of admissible index values;",NA
"10.9 System error, error code and error category","A std::system_error can be thrown when an error occurs that has an associated error code. Such errors are 
 typically encountered when calling low-level (like operating system) functions.
  
 Before using system_error the <system_error> header file must be included.
  
 A system_error object can be constructed using the standard textual description of the nature of the 
 encountered error, but in addition accepts an error_code or error_category object (see the next two 
 sections), further specifying the nature of the error. The error_code and error_category classes are also 
 declared in the system_error header file.
  
 The header file system_error also defines an enum class errc whose values are equal to and describe in a 
 less cryptic way the traditional error code values as offered by
  C
  macros, e.g.,
  
 enum class errc 
  
 { 
  
  
 address_family_not_supported, // EAFNOSUPPORT 
  
 address_in_use, // EADDRINUSE 
  
 address_not_available, 
 // EADDRNOTAVAIL 
  
 // EISCONN 
  
 already_connected, 
  
 argument_list_too_long, 
 // E2BIG 
  
  
 argument_out_of_domain, // EDOM 
  
  
 bad_address, // EFAULT 
  
  
 ...
  
 };
  
 In addition to the standard what member, the system_error class also offers a member code returning a 
 const reference to the exception’s error code. Here is the class’s public interface:
  
 class system_error: public runtime_error 
  
 { 
  
 public: 
  
  
 system_error(error_code ec, string const &what_arg); 
  
 system_error(error_code ec, char const *what_arg); 
  
 system_error(error_code 
 ec); 
  
  
 system_error(int ev, error_category const &ecat, 
  
  
 string const 
 &what_arg); 
  
  
 system_error(int ev, error_category const &ecat, 
  
  
 char const 
 *what_arg);",NA
10.10 ,NA,NA
Exception guarantees,"Software should be exception safe: the program should continue to work according to its specifica-tions in 
 the face of exceptions. It is not always easy to realize exception safety. In this section some guidelines and 
 terminology is introduced when discussing exception safety.
  
 Since exceptions may be generated from within all
  C++
  functions, exceptions may be generated in many 
 situations. Not all of these situations are immediately and intuitively recognized as situations where 
 exceptions can be thrown. Consider the following function and ask yourself at which points exceptions may 
 be thrown:
  
 void fun() 
  
 { 
  
  
 X x; 
  
  
 cout << x; 
  
  
 X *xp = new X(x); 
  
  
 cout << (x + *xp); 
  
  
 delete xp; 
  
 }
  
 If it can be assumed that cout as used above does not throw an exception there are at least 13 opportunities 
 for exceptions to be thrown:
  
 • X x: the default constructor could throw an exception (#1)",NA
10.11 ,NA,NA
Function try blocks,"Exceptions may be generated while a constructor is initializing its members. How can exceptions generated 
 in such situations be caught by the constructor itself, rather than outside the constructor? The intuitive 
 solution, nesting the object construction in a try block does not solve the problem. The exception by then 
 has left the constructor and the object we intended to construct isn’t visible anymore.
  
 Using a nested try block is illustrated in the next example, where main defines an object of class PersonDb. 
 Assuming that PersonDb’s constructor throws an exception, there is no way we can ac-cess the resources 
 that might have been allocated by PersonDb’s constructor from the catch handler as the pdb object is out of 
 scope:
  
 int main(int argc, char **argv) 
  
 { 
  
  
 try 
  
  
 { 
  
  
 PersonDb pdb(argc, argv); 
  
 // may throw exceptions 
  
 ... 
  
 // main()’s other code 
  
 }",NA
10.12 ,NA,NA
Exceptions in constructors and destructors,"Object destructors are only activated for completely constructed objects. Although this may sound like a 
 truism, there is a subtlety here. If the construction of an object fails for some reason, the object’s destructor 
 is not called when the object goes out of scope. This could happen if an exception that is generated by the 
 constructor is not caught by the constructor. If the exception is thrown when the object has already 
 allocated some memory, then that memory is not returned: its destructor isn’t called as the object’s 
 construction wasn’t successfully completed.",NA
Chapter 11,NA,NA
More Operator Overloading,"Having covered the overloaded assignment operator in chapter
  9
 , and having shown several exam-ples of 
 other overloaded operators as well (i.e., the insertion and extraction operators in chapters
  3 
 and
  6
 ), we 
 now take a look at operator overloading in general.",NA
11.1 Overloading ‘operator[]()’,"As our next example of operator overloading, we introduce a class IntArray encapsulating an ar-ray of ints. 
 Indexing the array elements is possible using the standard array index operator [], but additionally checks 
 for array bounds overflow are performed. Furthermore, the index operator (operator[]) is interesting in 
 that it can be used in expressions as both lvalue and as rvalue.
  
 Here is an example showing the basic use of the class:
  
 int main() 
  
 { 
  
  
 IntArray x(20); // 20 ints
  
 for (int i = 0; i < 20; i++)
  
  
 x[i] = i * 2; 
  
 for (int i = 0; i <= 20; i++)
  
 // assign the elements 
  
 // produces boundary overflow
  
  
 cout << ""At index "" << i << "": value is "" << x[i] << ’\n’; }
  
 First, the constructor is used to create an object containing 20 ints. The elements stored in the object can 
 be assigned or retrieved. The first for-loop assigns values to the elements using the index operator, the 
 second for-loop retrieves the values but also results in a run-time error once the non-existing value x[20] is 
 addressed. The IntArray class interface is:
  
 #include <cstddef>
  
 class IntArray 
  
 { 
  
  
 int 
  
 *d_data; 
  
  
 size_t d_size;
  
 257",NA
11.2 ,NA,NA
Overloading the insertion and extraction operators,"Classes may be adapted in such a way that their objects may be inserted into and extracted from, 
 respectively, a std::ostream and std::istream.
  
 The class std::ostream defines insertion operators for primitive types, such as int, char *, etc.. In this section 
 we learn how to extend the existing functionality of classes (in particular std::istream and std::ostream) in 
 such a way that they can be used also in combination with classes developed much later in history.
  
 In particular we will show how the insertion operator can be overloaded allowing the insertion of any type 
 of object, say Person (see chapter
  9
 ), into an ostream. Having defined such an overloaded operator we’re 
 able to use the following code:
  
 Person kr(""Kernighan and Ritchie"", ""unknown"", ""unknown"");
  
 cout << ""Name, address and phone number of Person kr:\n"" << kr << ’\n’;
  
 The statement cout << kr uses operator<<.
  
 This member function has two operands: an
  
 ostream & and a Person &. 
  
 The required action is defined in an overloaded free function 
 operator<< expecting two arguments:
  
  
 // declared in ‘person.h’
  
 std::ostream &operator<<(std::ostream &out, Person const &person);
  
  
  
  
  
  
 // defined in some source file ostream 
 &operator<<(ostream &out, Person const &person) { 
  
  
 return 
  
  
 out << 
  
  
  
  
 ""Name: 
  
 "" << person.name() << "", "" 
  
  
  
  
 ""Address: "" << person.address() << "", "" 
  
  
  
  
 ""Phone: 
  
 "" << person.phone(); 
  
 }",NA
Conversion operators,CHAPTER 11. MORE OPERATOR OVERLOADING,NA
11.3,"A class may be constructed around a built-in type. E.g., a class String, constructed around the char * type. 
 Such a class may define all kinds of operations, like assignments. Take a look at the following class 
 interface, designed after the string class:
  
 class String 
  
 { 
  
  
 char *d_string;
  
  
 public: 
  
  
 String(); 
  
  
 String(char const *arg); 
  
  
 ~String(); 
  
  
 String(String const &other); 
  
  
 String const &operator=(String const &rvalue); 
  
 String const 
 &operator=(char const *rvalue); };
  
 Objects of this class can be initialized from a char const *, and also from a String itself. There is an 
 overloaded assignment operator, allowing the assignment from a String object and from a char const *
 1
 .
  
 Usually, in classes that are less directly linked to their data than this String class, there will be an accessor 
 member function, like a member char const *String::c_str() const. However, the need to use this latter 
 member doesn’t appeal to our intuition when an array of String objects is defined by, e.g., a class 
 StringArray. If this latter class provides the operator[] to access individual String members, it would most 
 likely offer at least the following class interface:
  
 class StringArray 
  
 { 
  
  
 String *d_store; 
  
  
 size_t d_n;
  
 public: 
  
 StringArray(size_t size); 
  
 StringArray(StringArray const &other); 
  
 StringArray const &operator=(StringArray const &rvalue); ~StringArray();
  
 String &operator[](size_t index); };
  
 This interface allows us to assign String elements to each other:
  
 StringArray sa(10);
  
 sa[4] = sa[3]; 
  
 // String to String assignment
  
 But it is also possible to assign a char const * to an element of sa:
  
  
 1
 Note that the assignment from a char const * also allows the null-pointer. An assignment like stringObject = 0 is perfectly in order.",NA
11.4 The keyword ‘explicit’,"Conversions are not only performed by conversion operators, but also by constructors accepting one 
 argument (i.e., constructors having one or multiple parameters, specifying default argument values",NA
11.5 Overloading the increment and decrement operators,"Overloading the increment operator (operator++) and decrement operator (operator−−) intro-duces a 
 small problem: there are two versions of each operator, as they may be used as postfix operator (e.g., x++) 
 or as prefix operator (e.g., ++x).
  
 Used as postfix operator, the value’s object is returned as an rvalue, temporary const object and the post-
 incremented variable itself disappears from view. Used as prefix operator, the variable is incremented, and 
 its value is returned as lvalue and it may be altered again by modifying the",NA
11.6 Overloading binary operators,"In various classes overloading binary operators (like operator+) can be a very natural extension of the 
 class’s functionality. For example, the std::string class has various overloaded forms of operator+.
  
 Most binary operators come in two flavors: the plain binary operator (like the + operator) and the 
 compound assignment variant (like the += operator). Whereas the plain binary operators return values, 
 the compound assignment operators return a reference to the object to which the operator was applied. 
 For example, with std::string objects the following code (annotations below the example) may be used:
  
 std::string 
 s1; 
  
 std::string 
 s2; 
  
 std::string s3;",NA
11.7 ,NA,NA
Overloading ‘operator new(size_t)’,"When operator new is overloaded, it must define a void * return type, and its first parameter must be of 
 type size_t. The default operator new defines only one parameter, but overloaded versions may define 
 multiple parameters. The first one is not explicitly specified but is deducted from the size of objects of the 
 class for which operator new is overloaded. In this section overloading operator new is discussed. 
 Overloading new[] is discussed in section
  11.9
 .
  
 It is possible to define multiple versions of the operator new, as long as each version defines its own unique 
 set of arguments. When overloaded operator new members must dynamically allocate memory they can do 
 so using the global operator new, applying the scope resolution operator ::. In the next example the 
 overloaded operator new of the class String initializes the substrate of dynamically allocated String objects 
 to 0-bytes:
  
 #include <cstddef> 
  
 #include <iosfwd>
  
 class String 
  
 { 
  
  
 std::string *d_data;
  
  
 public: 
  
  
 void *operator new(size_t size) 
  
  
 { 
  
  
  
  
 return memset(::operator new(size), 0, size); 
  
 } 
  
  
 bool empty() const 
  
  
 { 
  
  
  
  
 return d_data == 0; 
  
  
 } 
  
 };
  
 The above operator new is used in the following program, illustrating that even though String’s default 
 constructor does nothing the object’s data are initialized to zeroes:
  
 #include 
 ""string.h"" 
  
 #include 
 <iostream> 
  
 using namespace std;
  
 int main() 
  
 { 
  
  
 String *sp = new String;
  
  
 cout << boolalpha << sp->empty() << ’\n’; 
  
 // shows: true }
  
 At new String the following took place:",NA
11.8 ,NA,NA
Overloading ‘operator delete(void *)’,"The delete operator may also be overloaded. 
  
 In fact it’s good practice to overload operator delete 
 whenever operator new is also overloaded.
  
 Operator delete must define a void * parameter. A second overloaded version defining a second parameter 
 of type size_t is related to overloading operator new[] and is discussed in section 
 11.9
 .
  
 Overloaded operator delete members return void.
  
 The ‘home-made’ operator delete is called when deleting a dynamically allocated object after executing the 
 destructor of the associated class. So, the statement
  
 delete ptr;
  
 with ptr being a pointer to an object of the class String for which the operator delete was over-loaded, is a 
 shorthand for the following statements:
  
 ptr->~String(); // call the class’s destructor
  
  
 // and do things with the memory pointed to by ptr String::operator 
 delete(ptr);
  
 The overloaded operator delete may do whatever it wants to do with the memory pointed to by ptr. It 
 could, e.g., simply delete it. If that would be the preferred thing to do, then the default delete operator can 
 be called using the :: scope resolution operator. For example:
  
 void String::operator delete(void *ptr)",NA
11.9 Operators ‘new[]’ and ‘delete[]’,"In sections
  9.1.1
 ,
  9.1.2
  and
  9.2.1
  operator new[] and operator delete[] were introduced. Like operator new 
 and operator delete the operators new[] and delete[] may be overloaded.
  
 As it is possible to overload new[] and delete[] as well as operator new and operator delete, one should be 
 careful in selecting the appropriate set of operators. The following rule of thumb should always be applied:
  
 If new is used to allocate memory, delete should be used to deallocate memory. If new[] is used 
 to allocate memory, delete[] should be used to deallocate memory.
  
 By default these operators act as follows:
  
 • operator new is used to allocate a single object or primitive value. With an object, the object’s 
  
 constructor is called.
  
 • operator delete is used to return the memory allocated by operator new. Again, with 
  
 class-type 
 objects, the class’s destructor is called.
  
 • operator new[] is used to allocate a series of primitive values or objects. If a series of objects 
  
 is 
 allocated, the class’s default constructor is called to initialize each object individually.
  
 • operator delete[] is used to delete the memory previously allocated by new[]. If objects were 
 previously allocated, then the destructor is called for each individual object. Be careful, though, when 
 pointers to objects were allocated. If pointers to objects were allocated the de-structors of the objects 
 to which the allocated pointers point won’t automatically be called. A pointer is a primitive type and 
 so no further action is taken when it is returned to the common pool.
  
 11.9.1 Overloading ‘new[]’
  
 To overload operator new[] in a class (e.g., in the class String) add the following line to the class’s interface:
  
 void *operator new[](size_t size);",NA
Function Objects,CHAPTER 11. MORE OPERATOR OVERLOADING,NA
11.10,"Function Objects are created by overloading the function call operator operator(). By defining the function 
 call operator an object masquerades as a function, hence the term function objects. Function objects are 
 also known as functors.
  
 Function objects are important when using generic algorithms. The use of function objects is pre-ferred 
 over alternatives like pointers to functions. The fact that they are important in the context of generic 
 algorithms leaves us with a didactic dilemma. At this point in the
  C++
  Annotations it would have been nice 
 if generic algorithms would already have been covered, but for the discussion of the generic algorithms 
 knowledge of function objects is required. This bootstrapping problem is solved in a well known way: by 
 ignoring the dependency for the time being, for now concentrating on the function object concept.
  
 Function objects are objects for which operator() has been defined. Function objects are not just used in 
 combination with generic algorithms, but also as a (preferred) alternative to pointers to functions.
  
 Function objects are frequently used to implement predicate functions. Predicate functions return boolean 
 values. Predicate functions and predicate function objects are commonly referred to as ‘pred-icates’. 
 Predicates are frequently used by generic algorithms such as the count_if generic algorithm, covered in 
 chapter
  19
 , returning the number of times its function object has returned true. In the standard template 
 library two kinds of predicates are used: unary predicates receive one argument, binary predicates receive 
 two arguments.
  
 Assume we have a class Person and an array of Person objects. Further assume that the array is not sorted. 
 A well known procedure for finding a particular Person object in the array is to use the function lsearch, 
 which performs a lineair search in an array. Example:
  
 Person &target = targetPerson(); Person 
 *pArray; 
  
 size_t n = fillPerson(&pArray);
  
 cout << ""The target person is"";
  
 // determine the person to find
  
 if (!lsearch(&target, pArray, &n, sizeof(Person), compareFunction)) 
  
 cout << "" not""; 
  
 cout << ""found\n"";
  
 The function targetPerson determines the person we’re looking for, and fillPerson is called to fill the array. 
 Then lsearch is used to locate the target person.
  
 The comparison function must be available, as its address is one of the arguments of lsearch. It must be a 
 real function having an address. If it is defined inline then the compiler has no choice but to ignore that 
 request as inline functions don’t have addresses. CompareFunction could be implemented like this:
  
 int compareFunction(void const *p1, void const *p2) 
  
 { 
  
  
 return *static_cast<Person const *>(p1) 
  
 // lsearch wants 0 
  
  
 != 
  
 // for equal objects 
  
  
 *static_cast<Person 
 const *>(p2); 
  
 }
  
 This, of course, assumes that the operator!= has been overloaded in the class Person. But over-",NA
11.11 ,NA,NA
The case of [io]fstream::open(),"Earlier, in section
  6.4.2.1
 , it was noted that the [io]fstream::open members expect an ios::openmode value 
 as their final argument. E.g., to open an fstream object for writing you could do as follows:
  
 fstream out; 
  
 out.open(""/tmp/out"", ios::out);
  
 Combinations are also possible. To open an fstream object for both reading and writing the follow-ing 
 stanza is often seen:
  
 fstream out; 
  
 out.open(""/tmp/out"", ios::in | ios::out);
  
 When trying to combine enum values using a ‘home made’ enum we may run into problems. Consider the 
 following:",NA
11.12 ,NA,NA
User-defined literals,"The C++11 standard offers user-defined literals, also known as extensible literals. Standard
  C++ 
 defines 
 various kinds of literals, like numerical constants (with or without suffixes), character con-stants and 
 string (textual) literals.
  
 A user-defined literal is defined by a function (see also section
  23.3
 ) that must be defined at names-pace 
 scope. Such a function is called a literal operator. A literal operator cannot be a class member function. 
 Under the C++11 standard the names of a literal operator must start with an underscore, and a literal 
 operator is used (called) by suffixing its name (including the underscore) to the argu-ment that must be 
 passed to it . Assuming _NM2km (nautical mile to km) is the name of a literal operator, then it could be 
 called as 100_NM2km, producing, e.g., the value 185.2.
  
 Using Type to represent the return type of the literal operator its generic declaration looks like this:
  
 Type operator """" _identifier(parameter-list);
  
 The blank space trailing the empty string is required. The parameter lists of literal operators can be:
  
 • unsigned long long int. It is used as, e.g., 123_identifier. The argument to this literal operator can be 
 decimal constants, binary constants (initial 0b), octal constants (initial 0) and hexadecimal constants 
 (initial 0x);
  
 • long double. It is used as, e.g., 12.25_NM2km;
  
 • char const *text. The text argument is an NTBS. It is used as, e.g., 1234_pental. The argument must not 
 be given double quotes, and must represent a numeric constant, as also expected by literal operators 
 defining unsigned long long int parameters.
  
 • char const *text, size_t len. Here, the compiler determines len as if it had called 
  
 strlen(text). It is used 
 as, e.g., ""hello""_nVowels;
  
 • wchar_t const *text, size_t len, same as the previous one, but accepting a string of 
  
 wchar_t 
 characters. It is used as, e.g., L""1234""_charSum;
  
 • char16_t const *text, size_t len, same as the previous one, but accepting a string of 
  
 char16_t 
 characters. It is used as, e.g., u""utf 16""_uc;
  
 • char32_t const *text, size_t len, same as the previous one, but accepting a string of 
  
 char32_t 
 characters. It is used as, e.g., U""UTF 32""_lc;
  
 If literal operators are overloaded the compiler will pick the literal operator requiring the least‘effort’. E.g., 
 120 is processed by a literal operator defining a unsigned long long int parameter and not by its 
 overloaded version, defining a char const * parameter. But if overloaded literal operators exist defining 
 char const * and long double parameters then the operator defining a char const * parameter is used when 
 the argument 120 is provided, while the operator defining a long double parameter is used with the 
 argument 120.3.
  
 A literator operator can define any return type. Here is an example of a definition of the _NM2km literal 
 operator:
  
 double operator """" _NM2km(char const *nm) { 
  
  
 return std::stod(nm) * 1.852;",NA
11.13 ,NA,NA
Overloadable operators,"The following operators can be overloaded:
  
 +
  
 -
  
 *
  
 /
  
 %
  
 ^
  
 &
  
 |
  
 ~
  
 !
  
 ,
  
 =
  
 <
  
 >
  
 <=
  
 >=
  
 ++
  
 --
  
 <<
  
 >>
  
 ==
  
 !=
  
 &&
  
 ||
  
 +=
  
 -=
  
 *=
  
 /=
  
 %=
  
 ^=
  
 &=
  
 |=
  
 <<=
  
 >>=
  
 []
  
 ()
  
 ->
  
 ->*
  
 new
  
 new[]
  
 delete
  
 delete[]
  
 textual alternative
  
 operator
  
 ‘Textual’ alternatives
  
 and
  
 &&
  
 and_eq
  
 &=
  
 Several operators have textual alternatives:
  
 bitand
  
 &
  
 bitor
  
 |
  
 compl
  
 ~
  
 not
  
 !
  
 not_eq
  
 !=
  
 or
  
 ||
  
 or_eq
  
 |=
  
 xor
  
 ^
  
 xor_eq
  
 ^=
  
 of operators are also overloadable (e.g., operator and). However, note that textual alternatives",NA
Chapter 12,NA,NA
Abstract Containers,"C++
  offers several predefined datatypes, all part of the Standard Template Library, which can be used to 
 implement solutions to frequently occurring problems. The datatypes discussed in this chap-ter are all 
 containers: you can put stuff inside them, and you can retrieve the stored information from them.
  
 The interesting part is that the kind of data that can be stored inside these containers has been left 
 unspecified at the time the containers were constructed. That’s why they are spoken of as abstract 
 containers.
  
 Abstract containers rely heavily on templates, covered in chapter
  21
  and beyond. To use abstract 
 containers, only a minimal grasp of the template concept is required. In
  C++
  a template is in fact a recipe 
 for constructing a function or a complete class. The recipe tries to abstract the functionality of the class or 
 function as much as possible from the data on which the class or function operates. As the data types on 
 which the templates operate were not known when the template was implemented, the datatypes are 
 either inferred from the context in which a function template is used, or they are mentioned explicitly 
 when a class template is used (the term that’s used here is instantiated). In situations where the types are 
 explicitly mentioned, the angle bracket notation is used to indicate which data types are required. For 
 example, below (in section
  12.2
 ) we’ll encounter the pair con-tainer, which requires the explicit 
 mentioning of two data types. Here is a pair object containing both an int and a string:
  
 pair<int, string> myPair;
  
 The object myPair is defined as an object holding both an int and a string.
  
 The angle bracket notation is used intensively in the upcoming discussion of abstract containers. Actually, 
 understanding this part of templates is the only real requirement for using abstract con-tainers. Now that 
 we’ve introduced this notation, we can postpone the more thorough discussion of templates to chapter
  21
 , 
 and concentrate on their use in this chapter.
  
 Most of the abstract containers are sequential containers: they contain data that can be stored and 
 retrieved in some sequential way. Examples are the array, implementing a fixed-sized array; a vector, 
 implementing an extendable array; the list, implementing a data structure that allows for the easy insertion 
 or deletion of data; the queue, also called a FIFO (first in, first out) structure, in which the first element that 
 is entered is the first element to be retrieved again; and the stack, which is a first in, last out (FILO or LIFO) 
 structure.
  
 In addition to sequential containers several special containers are available. The pair is a basic container in 
 which a pair of values (of types that are left open for further specification) can be
  
 293",NA
12.1 Notations used in this chapter,"In this chapter about containers, the following notational conventions are used:
  
 • Containers live in the standard namespace. In code examples this will be clearly visible, but 
  
 in the 
 text std:: is usually omitted.
  
 • A container without angle brackets represents any container of that type. Mentally add the 
  
 required type in angle bracket notation. E.g., pair may represent pair<string, int>.
  
 • The notation Type represents the generic type. Type could be int, string, etc.
  
 • Identifiers object and container represent objects of the container type under discussion.
  
 • The identifier value represents a value of the type that is stored in the container.
  
 • Simple, one-letter identifiers, like n represent unsigned values.
  
 • Longer identifiers represent iteratoriterators. Examples are pos, from, beyond
  
 Some containers, e.g., the map container, contain pairs of values, usually called ‘keys’ and ‘values’. For such 
 containers the following notational convention is used in addition:
  
 • The identifier key indicates a value of the used key-type
  
 • The identifier keyvalue indicates a value of the ‘value_type’ used with the particular con-
  
 tainer.",NA
The ‘pair’ container,CHAPTER 12. ABSTRACT CONTAINERS,NA
12.2,"The pair container is a rather basic container. It is used to store two elements, called first and second, and 
 that’s about it. Before using pair containers the header file <utility> must be included.
  
 The pair’s data types are specified when the pair object is defined (or declared) using the template’s angle 
 bracket notation (cf. chapter
  21
 ). Examples:
  
 pair<string, string> piper(""PA28"", ""PH-ANI""); pair<string, 
 string> cessna(""C172"", ""PH-ANG"");
  
 here, the variables piper and cessna are defined as pair variables containing two strings. Both strings can be 
 retrieved using the first and second fields of the pair type:
  
 cout << piper.first << ’\n’ << 
 cessna.second << ’\n’;
  
 // shows ’PA28’
  
 // shows ’PH-ANG’
  
 The first and second members can also be used to reassign values:
  
 cessna.first = ""C152""; 
  
 cessna.second = ""PH-ANW"";
  
 If a pair object must be completely reassigned, an anonymous pair object can be used as the right-hand 
 operand of the assignment. An anonymous variable defines a temporary variable (which re-ceives no 
 name) solely for the purpose of (re)assigning another variable of the same type. Its generic form is
  
 type(initializer list)
  
 Note that when a pair object is used the type specification is not completed by just mentioning the 
 containername pair. It also requires the specification of the data types which are stored within the pair. For 
 this the (template) angle bracket notation is used again. E.g., the reassignment of the cessna pair variable 
 could have been accomplished as follows:
  
 cessna = pair<string, string>(""C152"", ""PH-ANW"");
  
 In cases like these, the type specification can become quite elaborate, which has caused a revival of interest 
 in the possibilities offered by the typedef keyword. If many pair<type1, type2> clauses are used in a source, 
 the typing effort may be reduced and readability might be improved by first defining a name for the clause, 
 and then using the defined name later. E.g.,
  
 typedef pair<string, string> pairStrStr;
  
 cessna = pairStrStr(""C152"", ""PH-ANW"");
  
 Apart from this (and the basic set of operations (assignment and comparisons)) the pair offers no further 
 functionality. It is, however, a basic ingredient of the upcoming abstract containers map, multimap and 
 hash_map.
  
 The C++11 standard offers a generalized pair container: the tuple, covered in section
  22.6
 .",NA
12.3 Allocators,"Most containers use a special object for allocating the memory that is managed by them. This object is 
 called an allocator, and it’s type is (usually by default) specified when a container is constructed. A 
 container’s allocator can be obtained using the container’s get_allocator member, which returns a copy of 
 the allocator used by the container. Allocators offer the following members:
  
 • value_type *address(value_type &object) returns the 
 address of object.
  
 • value_type *allocate(size_t count) 
  
 allocates raw memory for holding count values of the container’s value_type.
  
 • void construct(value_type *object, Arg &&...args) 
  
 using placement new, uses the arguments following object to install a value at object.
  
 • void destroy(value_type *object) 
  
 calls object’s destructor (but doesn’t deallocate object’s own memory).
  
 • void deallocate(value_type *object, size_t count)
  
 calls
  
 operator delete
  
 to
  
 delete
  
 object’s
  
 memory,
  
 previously
  
 allocated
  
 by
  
 allocate.
  
 • size_t max_size() 
  
 returns the maximum number of elements that allocate can allocate.
  
 Here is an example, using the allocator of a vector of strings (see section
  12.4.2
  below for a descrip-tion of 
 the vector container):
  
 #include <iostream> 
  
 #include <vector> 
  
 #include <string>
  
 using namespace std;
  
 int main() 
  
 { 
  
 vector<string> vs;
  
 auto allocator = vs.get_allocator(); string *sp = 
 allocator.allocate(3);
  
 // get the allocator 
  
 // alloc. space for 3 strings
  
 allocator.construct(&sp[0], ""hello world""); // initialize 1st string
  
 allocator.construct(&sp[1], sp[0]); 
 allocator.construct(&sp[2], 12, ’=’);
  
 cout << sp[0] << ’\n’ << sp[1] << 
 ’\n’ << sp[2] << ’\n’ 
 <<
  
 // use the copy constructor // string 
 of 12 = chars
  
 // show the strings",NA
12.4 ,NA,NA
Available Containers,"12.4.1 
  
 The ‘array’ container
  
 The array class implements a fixed-size array. Before using the array container the <array> header file must 
 be included.
  
 To define a std::array both the data type of its elements and its size must be specified: the data type is given 
 after an opening angular bracket, immediately following the ‘array’ container
  
 name.
  
 The array’s size is provided after the data type specification.
  
 Finally, a closing angular
  
 bracket completes the array’s type. Specifications like this are common practice with containers. The 
 combination of array, type and size defines a type. As a result, array<string, 4> defines another type than 
 array<string, 5>, and a function explicitly defining an array<Type, N> parameter will not accept an 
 array<Type, M> argument if N and M are unequal.
  
 The array’s size may may be defined as 0 (although such an array probably has little use as it cannot store 
 any element). The elements of an array are stored contiguously. If array<Type, N> arr has been defined, 
 then &arr[n] + m == &arr[n + m, assuming 0 <= n < N and assuming 0 <= n + m < N.
  
 The following constructors, operators, and member functions are available:
  
 • Constructors:
  
 –
  The copy and move constructors are available;
  
 –
  A array may be constructed with a fixed number N of default elements:
  
 array<string, N> object;
  
 –
  An initial subset of the elements of an array may be initialized using a brace delimited 
  
 initializer list:
  
 array<double, 4> dArr = {1.2, 2.4};
  
 Here dArr is defined as an array of 4 element, with dArr[0] and dArr[1] initialized to, 
 respectively 1.2 and 2.4, and dArr[2] and dArr[3] initialized to 0. A attractive charac-teristic of 
 arrays (and other containers) is that containers initialize their data elements to the data type’s 
 default value. The data type’s default constructor is used for this initializa-tion. With non-class 
 data types the value 0 is used. So, for an array<double, 4> array we know that all but its 
 explicitly initialized elements are initialized to zero.
  
 • In addition to the standard operators for containers, the array supports the index operator, which can 
 be used to retrieve or reassign individual elements of the array. Note that the ele-ments which are 
 indexed must exist. For example, having defined an empty array a statement like iarr[0] = 18 
 produces an error, as the array is empty. Note that operator[] does not respect its array bounds. If 
 you want run-time array bound checking, use the array’s at member.",NA
12.5 The ‘complex’ container,"The complex container defines the standard operations that can be performed on complex numbers. Before 
 using complex containers the header file <complex> must be included.
  
 The complex number’s real and imaginary types are specified as the container’s data type. Examples:
  
 complex<double> 
  
 complex<int> 
  
 complex<float>",NA
12.6 Unrestricted Unions,"We end this chapter about abstract containers with a small detour, introducing additions to the union 
 concept, made available by the C++11 standard. Although unions themselves aren’t ‘abstract containers’, 
 having covered containers has put us in a good position to introduce and illustrate unrestricted unions.
  
 The C++11 standard adds unrestricted unions to C++’s data structuring capabilities. Whereas the 
 traditional union can only contain primitive data, unrestricted unions allow data fields of types for",NA
Chapter 13,NA,NA
Inheritance,"When programming in
  C
 , programming problems are commonly approached using a top-down struc-tured 
 approach: functions and actions of the program are defined in terms of sub-functions, which again are 
 defined in sub-sub-functions, etc.. This yields a hierarchy of code: main at the top, followed by a level of 
 functions which are called from main, etc..
  
 In
  C++
  the relationship between code and data is also frequently defined in terms of dependencies among 
 classes. This looks like composition (see section
  7.3
 ), where objects of a class contain objects of another 
 class as their data. But the relation described here is of a different kind: a class can be defined in terms of 
 an older, pre-existing, class. This produces a new class having all the functionality of the older class, and 
 additionally defining its own specific functionality. Instead of composition, where a given class contains 
 another class, we here refer to derivation, where a given class is or is-implemented-in-terms-of another 
 class.
  
 Another term for derivation is inheritance: the new class inherits the functionality of an existing class, 
 while the existing class does not appear as a data member in the interface of the new class. When 
 discussing inheritance the existing class is called the base class, while the new class is called the derived 
 class.
  
 Derivation of classes is often used when the methodology of
  C++
  program development is fully ex-ploited. 
 In this chapter we first address the syntactic possibilities offered by
  C++
  for deriving classes. Following this 
 we address some of the specific possibilities offered by class derivation (inheritance).
  
 As we have seen in the introductory chapter (see section
  2.4
 ), in the object-oriented approach to problem 
 solving classes are identified during the problem analysis. Under this approach objects of the defined 
 classes represent entities that can be observed in the problem at hand. The classes are placed in a 
 hierarchy, with the top-level class containing limited functionality. Each new derivation (and hence descent 
 in the class hierarchy) adds new functionality compared to yet existing classes.
  
 In this chapter we shall use a simple vehicle classification system to build a hierarchy of classes. The first 
 class is Vehicle, which implements as its functionality the possibility to set or retrieve the mass of a vehicle. 
 The next level in the object hierarchy are land-, water- and air vehicles.
  
 The initial object hierarchy is illustrated in Figure
  13.1
 .
  
 This chapter mainly focuses on the technicalities of class derivation. The distinction between inher-itance 
 used to create derived classes whose objects should be considered objects of the base class and inheritance 
 used to implement derived classes in-terms-of their base classes is postponed until the next chapter (
 14
 ).
  
 Inheritance (and polymorphism, cf. chapter
  14
 ) can be used with classes and structs. It is not defined
  
 355",NA
13.1 ,NA,NA
Related types,"The relationship between the proposed classes representing different kinds of vehicles is further 
 investigated here. The figure shows the object hierarchy: a Car is a special case of a Land vehicle, which in 
 turn is a special case of a Vehicle.
  
 The class Vehicle represents the ‘greatest common divisor’ in the classification system. Vehicle is given 
 limited functionality: it can store and retrieve a vehicle’s mass:
  
 class Vehicle 
  
 { 
  
  
 size_t d_mass;
  
 public: 
  
 Vehicle(); 
  
 Vehicle(size_t mass);
  
 size_t mass() const; 
  
 void setMass(size_t mass); 
  
 };
  
 Using this class, the vehicle’s mass can be defined as soon as the corresponding object has been created. At 
 a later stage the mass can be changed or retrieved.
  
 To represent vehicles travelling over land, a new class Land can be defined offering Vehicle’s func-tionality 
 and adding its own specific functionality. Assume we are interested in the speed of land vehicles and in 
 their mass. The relationship between Vehicles and Lands could of course be rep-resented by composition 
 but that would be awkward: composition suggests that a Land vehicle is-implemented-in-terms-of, i.e., 
 contains, a Vehicle, while the natural relationship clearly is that the Land vehicle is a kind of Vehicle.
  
 A relationship in terms of composition would also somewhat complicate our Land class’s design. Consider 
 the following example showing a class Land using composition (only the setMass func-tionality is shown):",NA
"13.2 Access rights: public, private, protected","Early in the
  C++
  Annotations (cf. section
  3.2.1
 ) we encountered two important design principles when 
 developing classes: data hiding and encapsulation. Data hiding restricts control over an object’s data to the 
 members of its class, encapsulating is used to restrict access to the functionality of objects. Both principles 
 are invaluable tools for maintaining data integrity.
  
 The keyword private starts sections in class interfaces in which members are declared which can only be 
 accessed by members of the class itself. This is our main tool for realizing data hiding. According to 
 established good practices of class design the public sections are populated with mem-ber functions 
 offering a clean interface to the class’s functionality. These members allow users to communicate with 
 objects; leaving it to the objects how requests sent to objects are handled. In a well-designed class its 
 objects are in full control of their data.
  
 Inheritance doesn’t change these principles, nor does it change the way the private and protected 
 keywords operate. A derived class does not have access to a base class’s private section.",NA
13.3 The constructor of a derived class,"A derived class inherits functionality from its base class (or base classes, as
  C++
  supports multiple 
 inheritance, cf. section
  13.7
 ). When a derived class object is constructed it is built on top of its base class 
 object. As a consequence the base class must have been constructed before the actual derived class 
 elements can be initialized. This results in some requirements that must be observed when defining 
 derived class constructors.
  
 A constructor exists to initialize the object’s data members. 
  
 A derived class constructor is also 
 responsible for the proper initialization of its base class. Looking at the definition of the class Land 
 introduced earlier (section
  13.1
 ), its constructor could simply be defined as follows:
  
 Land::Land(size_t mass, size_t speed) 
  
 { 
  
  
 setMass(mass); 
  
  
 setspeed(speed); 
  
 }
  
 However, this implementation has several disadvantages.
  
 • When constructing a derived class object a base class constructor is always called before any action is 
 performed on the derived class object itself. By default the base class’s default con-structor is going 
 to be called.
  
 • Using the base class constructor only to reassign new values to its data members in the derived class 
 constructor’s body usually is inefficient, but sometimes sheer impossible as in situations where base 
 class reference or const data members must be initialized. In those cases a special-ized base class 
 constructor must be used instead of the base class default constructor.
  
 A derived class’s base class may be initialized using a dedicated base class constructor by calling the base 
 class constructor in the derived class constructor’s initializer clause. Calling a base class constructor in a 
 constructor’s initializer clause is called a base class initializer. The base class ini-tializer must be called 
 before initializing any of the derived class’s data members and when using the base class initializer none of 
 the derived class data members may be used. When constructing a derived class object the base class is 
 constructed first and only after that construction has success-fully completed the derived class data 
 members are available for initialization. Land’s constructor may therefore be improved:",NA
The destructor of a derived class,CHAPTER 13. INHERITANCE,NA
13.4,"Destructors of classes are automatically called when an object is destroyed. This also holds true for objects 
 of classes derived from other classes. Assume we have the following situation:
  
 class Base 
  
 { 
  
  
 public: 
  
  
 ~Base(); 
  
 };
  
 class Derived: public Base 
  
 { 
  
  
 public: 
  
  
 ~Derived(); 
  
 };
  
 int main() 
  
 { 
  
  
 Derived derived; 
  
 }
  
 At the end of main, the derived object ceases to exists. Hence, its destructor (~Derived) is called. However, 
 since derived is also a Base object, the ~Base destructor is called as well. The base class destructor is never 
 explicitly called from the derived class destructor.
  
 Constructors and destructors are called in a stack-like fashion: when derived is constructed, the 
 appropriate base class constructor is called first, then the appropriate derived class constructor is called. 
 When the object derived is destroyed, its destructor is called first, automatically followed by the activation 
 of the Base class destructor. A derived class destructor is always called before its base class destructor is 
 called.
  
 When the construction of a derived class objects did not successfully complete (i.e., the construc-tor threw 
 an exception) then its destructor is not called. However, the destructors of properly con-structed base 
 classes will be called if a derived class constructor throws an exception. This, of course, is it should be: a 
 properly constructed object should also be destroyed, eventually. Example:
  
 #include <iostream> 
  
 struct Base 
  
 { 
  
  
 ~Base() 
  
  
 { 
  
  
 std::cout << ""Base destructor\n""; 
  
  
 } 
  
 }; 
  
 struct Derived: public Base 
  
 { 
  
  
 Derived() 
  
  
 { 
  
  
 throw 1; 
  
 // at this time Base has been constructed 
  
 } 
  
 }; 
  
 int main() 
  
 {",NA
13.5 Redefining member functions,"Derived classes may redefine base class members. Let’s assume that a vehicle classification system must 
 also cover trucks, consisting of two parts: the front part, the tractor, pulls the rear part, the trailer. Both the 
 tractor and the trailer have their own mass, and the mass function should return the combined mass.
  
 The definition of a Truck starts with a class definition. Our initial Truck class is derived from Car but it is 
 then expanded to hold one more size_t field representing the additional mass information. Here we choose 
 to represent the mass of the tractor in the Car class and to store the mass of of full truck (tractor + trailer) 
 in its own d_mass data member:
  
 class Truck: public Car 
  
 { 
  
  
 size_t d_mass;
  
 public: 
  
  
 Truck(); 
  
  
 Truck(size_t tractor_mass, size_t speed, char const *name, 
   
 size_t 
 trailer_mass);
  
  
 void setMass(size_t tractor_mass, size_t trailer_mass); 
  
 size_t mass() const; 
  
 };
  
 Truck::Truck(size_t tractor_mass, size_t speed, char const *name, 
  
  
 size_t 
 trailer_mass) 
  
 : 
  
  
 Car(tractor_mass, speed, name) 
  
 { 
  
  
 d_mass = trailer_mass + trailer_mass; 
  
 }
  
 Note that the class Truck now contains two functions already present in the base class Car: setMass and 
 mass.
  
 • The redefinition of setMass poses no problems: this function is simply redefined to perform 
  
 actions which are specific to a Truck object.
  
 • Redefining setMass, however, hides Car::setMass. For a Truck only the setMass function 
  
 having two size_t arguments can be used.",NA
i/ostream::init,CHAPTER 13. INHERITANCE,NA
13.6,"Consider classes derived from std::istream or std::ostream. Such a class could be designed as follows:
  
 class XIstream: public std::istream 
  
 { 
  
  
 public: 
  
  
 ...
  
 };
  
 Assuming that the streambuf to which XIstream interfaces is not yet available construction time, XIstream 
 only 
 offers 
 default 
 constructors. 
 The 
 class 
 could, 
 however, 
 offer 
 a 
 member 
 void 
 switchStream(std::streambuf *sb) to provide XIstream objects with a streambuf to inter-face to. How to 
 implement switchStream?
  
 The
  
 classes
  
 std::istream
  
 and
  
 std::ostream
  
 offer
  
 a
  
 protected
  
 member
  
 void
  
 init(std::streambuf *sb) to realize this. The init member expects a pointer to a streambuf which is 
 associated with the istream or ostream object. The init member properly ends any existing association 
 before switching to the streambuf whose address is provided to init.
  
 Assuming that the streambuf to which switchStream’s sb points persists, then switchStream could simply 
 be implemented like this:
  
 void switchStream(streambuf *sb) 
  
 { 
  
  
 init(sb); 
  
 }",NA
13.7 ,NA,NA
Multiple inheritance,"Up to now, a class has always been derived from a single base class. In addition to single inheritance 
 C++
  
 also supports multiple inheritance. In multiple inheritance a class is derived from several base classes and 
 hence inherits functionality from multiple parent classes at the same time.
  
 When using multiple inheritance it should be defensible to consider the newly derived class an in-
 stantiation of both base classes. Otherwise, composition is more appropriate. In general, linear derivation 
 (using only one base class) is used much more frequently than multiple derivation. Good class design 
 dictates that a class should have a single, well described responsibility and that prin-ciple often conflicts 
 with multiple inheritance where we can state that objects of class Derived are both Base1 and Base2 
 objects.
  
 But then, consider the prototype of an object for which multiple inheritance was used to its extreme: the 
 Swiss army knife! This object is a knife, it is a pair of scissors, it is a can-opener, it is a corkscrew, it is ....
  
 The ‘Swiss army knife’ is an extreme example of multiple inheritance. In
  C++
  there are some good reasons, 
 not violating the ‘one class, one responsibility’ principle that is covered in the next chapter. In this section 
 the technical details of constructing classes using multiple inheritance are discussed.
  
 How to construct a ‘Swiss army knife’ in
  C++
 ? First we need (at least) two base classes. For example, let’s 
 assume we are designing a toolkit allowing us to construct an instrument panel of an aircraft’s cockpit. We 
 design all kinds of instruments, like an artificial horizon and an altimeter. One of the",NA
13.8 Conversions between base classes and derived classes,"When public inheritance is used to define classes, an object of a derived class is at the same time an object 
 of the base class. This has important consequences for object assignment and for the situation where 
 pointers or references to such objects are used. Both situations are now discussed.
  
 13.8.1 Conversions with object assignments
  
 Continuing our discussion of the NavCom class, introduced in section
  13.7
 , we now define two objects, a 
 base class and a derived class object:
  
 ComSet com(intercom); 
  
 NavComSet navcom(intercom2, dial2);
  
 The object navcom is constructed using an Intercom and a VHF_Dial object. 
  
 However, a 
 NavComSet is at the same time a ComSet, allowing the assignment from navcom (a derived class object) to 
 com (a base class object):
  
 com = navcom;",NA
13.9 Using non-default constructors with new[],"An often heard complaint is that operator new[] calls the default constructor of a class to initialize the 
 allocated objects. For example, to allocate an array of 10 strings we can do
  
 new string[10];
  
 but it is not possible to use another constructor. Assuming that we’d want to initialize the strings with the 
 text hello world, we can’t write something like:
  
 new string(""hello world"")[10];
  
 The initialization of a dynamically allocated object usually consists of a two-step process: first the array is 
 allocated (implicitly calling the default constructor); second the array’s elements are initial-ized, as in the 
 following little example:
  
 string *sp = new string[10]; 
  
 fill(sp, sp + 10, string(""hello world""));
  
 These approaches all suffer from ‘double initializations’, comparable to not using member initializers in 
 constructors.",NA
Chapter 14,NA,NA
Polymorphism,"Using inheritance classes may be derived from other classes, called base classes. In the previous chapter we 
 saw that base class pointers may be used to point to derived class objects. We also saw that when a base 
 class pointer points to an object of a derived class it is the type of the pointer rather than the type of the 
 object it points to what determines which member functions are visible. So when a Vehicle *vp, points to a 
 Car object Car’s speed or brandName members can’t be used.
  
 In the previous chapter two fundamental ways classes may be related to each other were discussed: a class 
 may be implemented-in-terms-of another class and it can be stated that a derived class is-a base class. The 
 former relationship is usually implemented using composition, the latter is usually implemented using a 
 special form of inheritance, called polymorphism, the topic of this chapter.
  
 An is-a relationship between classes allows us to apply the Liskov Substitution Principle (LSP) according to 
 which a derived class object may be passed to and used by code expecting a pointer or reference to a base 
 class object. In the
  C++
  Annotations so far the LSP has been applied many times. Every time an 
 ostringstream, ofstream or fstream was passed to functions expecting an ostream we’ve been applying this 
 principle. In this chapter we’ll discover how to design our own classes accordingly.
  
 LSP is implemented using a technique called polymorphism: although a base class pointer is used it 
 performs actions defined in the (derived) class of the object it actually points to. So, a Vehicle *vp might 
 behave like a Car * when pointing to a Car
 1
 .
  
 Polymorphism is implemented using a feature called late binding. It’s called that way because the decision 
 which function to call (a base class function or a function of a derived class) cannot be made at compile-
 time, but is postponed until the program is actually executed: only then it is determined which member 
 function will actually be called.
  
 In
  C++
  late binding is not the default way functions are called. By default static binding (or early binding) is 
 used. With static binding the functions that are called are determined by the compiler, merely using the 
 class types of objects, object pointers or object refences.
  
 Late binding is an inherently different (and slightly slower) process as it is decided at run-time, rather than 
 at compile-time what function is going to be called. As
  C++
  supports both late- and early-binding
  C++
  
 programmers are offered an option as to what kind of binding to use. Choices can be optimized to the 
 situations at hand. Many other languages offering object oriented facilities (e.g.,
  Java
 ) only or by default 
 offer late binding.
  C++
  programmers should be keenly aware of this. Expecting early binding and getting 
 late binding may easily produce nasty bugs.
  
 1
 In one of the StarTrek movies, Capt. Kirk was in trouble, as usual. He met an extremely beautiful lady who, however, later on changed 
 into a hideous troll. Kirk was quite surprised, but the lady told him: “Didn’t you know I am a polymorph?”
  
 381",NA
14.1 Virtual functions,"By default the behavior of a member function called via a pointer or reference is determined by the 
 implementation of that function in the pointer’s or reference’s class. E.g., a Vehicle * activates Vehicle’s 
 member functions, even when pointing to an object of a derived class. This is known as as early or static 
 binding: the function to call is determined at compile-time. In
  C++
  late or dynamic binding is realized using 
 virtual member functions.
  
 A member function becomes a virtual member function when its declaration starts with the key-word 
 virtual. It is stressed once again that in
  C++
 , different from several other object oriented languages, this is 
 not the default situation. By default static binding is used.
  
 Once a function is declared virtual in a base class, it remains virtual in all derived classes. The keyword 
 virtual should not be mentioned with members declared virtual in the base class. In derived classes those 
 members should be provided with the override indicator.
  
 In the vehicle classification system (see section
  13.1
 ), let’s concentrate on the members mass and setMass. 
 These members define the user interface of the class Vehicle. What we would like to accomplish is that this 
 user interface can be used for Vehicle and for any class inheriting from Vehicle, since objects of those 
 classes are themselves also Vehicles.
  
 If we can define the user interface of our base class (e.g., Vehicle) such that it remains usable irrespective of 
 the classes we derive from Vehicle our software achieves an enormous reusability: we design or software 
 around Vehicle’s user interface, and our software will also properly function for derived classes. Using 
 plain inheritance doesn’t accomplish this. If we define
  
 std::ostream &operator<<(std::ostream &out, Vehicle const &vehicle)",NA
14.2 ,NA,NA
Virtual destructors,"When an object ceases to exist the object’s destructor is called. Now consider the following code fragment 
 (cf. section
  13.1
 ):
  
 Vehicle *vp = new Land(1000, 120);
  
 delete vp; 
  
 // object destroyed",NA
14.3 Pure virtual functions,"The base class Vehicle is provided with its own concrete implementations of its virtual members (mass and 
 setMass). However, virtual member functions do not necessarily have to be implemented in base classes.
  
 When the implementations of virtual members are omitted from base classes the class imposes 
 requirements upon derived classes. The derived classes are required to provide the ‘missing imple-
 mentations’.
  
 This approach, in some languages (like
  C#, Delphi
  and
  Java
 ) known as an interface, defines a pro-tocol. 
 Derived classes must obey the protocol by implementing the as yet not implemented members. If a class 
 contains at least one member whose implementation is missing no objects of that class can be defined.
  
 Such incompletely defined classes are always base classes. They enforce a protocol by merely declar-ing 
 names, return values and arguments of some of their members. These classes are call abstract",NA
14.4 ,NA,NA
Explicit virtual overrides,"Consider the following situations:
  
 • A class Value is a value class. It offers a copy constructor, an overloaded assignment operator, maybe 
 move operations, and a public, non-virtual constructor. In section
  14.7
  it is argued that such classes is 
 not suited as a base class. New classes should not inherit from Value. How to enforce this?
  
 • A polymorphic class Base defines a virtual member v_process(int32_t). 
  
 A class 
  
 derived from Base needs to override this member, but the author mistakingly defined 
  
 v_proces(int32_t). How to prevent such errors, breaking the polymorphic behavior of the 
  
 derived 
 class?
  
 • A
  
 class
  
 Derived,
  
 derived
  
 from
  
 a
  
 polymorphic
  
 Base
  
 class
  
 overrides
  
 the
  
 member
  
 Base::v_process, but classes that are in turn derived from Derived should no longer over-ride 
 v_process, but may override other virtual members like v_call and v_display. How to enforce this 
 restricted polymorphic character for classes derived from Derived?
  
 C++11 allows the use of two special identifiers, final and override to realize the above. These identifiers are 
 special in the sense that they only require their special meanings in specific contexts. Outside of this 
 context they are just plain identifiers, allowing the programmer to define a variable like bool final.
  
 The identifier final can be applied to class declarations to indicate that the class cannot be used as a base 
 class. E.g.:
  
 class Base1 final 
  
 {}; 
  
 class Derived1: public Base1 {};
  
 class Base2 
  
 {};
  
 // cannot be a base class // ERR: 
 Base1 is final
  
 // OK as base class
  
 class Derived2 final: public Base2 
  
 // OK, but Derived2 can’t be
  
 {}; 
  
 // 
  
 used as a base class
  
 class Derived: public Derived2 {};
  
 // ERR: Derived2 is final
  
 The identifier final can also be added to virtual member declarations. This indicates that those virtual 
 members cannot be overridden by derived classes. The restricted polymorphic character of a class, 
 mentioned above, can thus be realized as follows:
  
 class Base 
  
 {
  
 virtual int v_process(); virtual int 
 v_call(); 
  
 virtual int v_display();
  
 // define polymorphic behavior",NA
14.5 Virtual functions and multiple inheritance,"In chapter
  6
  we encountered the class fstream, one class offering features of ifstream and ofstream. In 
 chapter
  13
  we learned that a class may be derived from multiple base classes. Such a derived class inherits 
 the properties of all its base classes. Polymorphism can also be used in combination with multiple 
 inheritance.
  
 Consider what would happen if more than one ‘path’ leads from the derived class up to its (base) classes. 
 This is illustrated in the next (fictitious) example where a class Derived is doubly derived from Base:
  
 class Base 
  
 { 
  
  
 int d_field; 
  
  
 public: 
  
  
  
 void setfield(int val); 
  
  
  
 int field() const; 
  
 }; 
  
 inline void Base::setfield(int val) 
  
 { 
  
  
 d_field = val; 
  
 } 
  
 inline int Base::field() const",NA
14.6 ,NA,NA
Run-time type identification,"C++
  offers two ways to (run-time) retrieve the type of objects and expressions. The possibilities of
  C++
 ’s 
 run-time type identification are limited compared to languages like
  Java
 . Usually static",NA
14.7 ,NA,NA
Inheritance: when to use to achieve what?,"Inheritance should not be applied automatically and thoughtlessly. Often composition can be used instead, 
 improving on a class’s design by reducing coupling. When inheritance is used public inheri-tance should 
 not automatically be used but the type of inheritance that is selected should match the programmer’s 
 intent.
  
 We’ve seen that polymorphic classes on the one hand offer interface members defining the function-ality 
 that can be requested of base classes and on the other hand offer virtual members that can be overridden. 
 One of the signs of good class design is that member functions are designed according",NA
14.8 The ‘streambuf’ class,"The class std::streambuf receives the character sequences processed by streams and defines the interface 
 between stream objects and devices (like a file on disk). A streambuf object is usually not directly 
 constructed, but usually it is used as base class of some derived class implementing the communication 
 with some concrete device.
  
 The primary reason for existence of the class streambuf is to decouple the stream classes from the devices 
 they operate upon. The rationale here is to add an extra layer between the classes allowing us to 
 communicate with devices and the devices themselves. This implements a chain of command which is seen 
 regularly in software design.
  
 The chain of command is considered a generic pattern when designing reusable software, encoun-tered 
 also in, e.g., the TCP/IP stack.
  
 A streambuf can be considered yet another example of the chain of command pattern. Here the program 
 talks to stream objects, which in turn forward their requests to streambuf objects, which in turn 
 communicate with the devices. Thus, as we will see shortly, we are able to do in user-software what had to 
 be done via (expensive) system calls before.
  
 The class streambuf has no public constructor, but does make available several public member functions. 
 In addition to these public member functions, several member functions are only avail-able to classes 
 derived from streambuf. In section
  14.8.2
  a predefined specialization of the class streambuf is introduced. 
 All public members of streambuf discussed here are also available in filebuf.
  
 The next section shows the streambuf members that may be overridden when deriving classes from 
 streambuf. Chapter
  24
  offers concrete examples of classes derived from streambuf.
  
 The class streambuf is used by streams performing input operations and by streams performing output 
 operations and their member functions can be ordered likewise. The type std::streamsize used below may, 
 for all practical purposes, be considered equal to the type size_t.
  
 When inserting information into ostream objects the information is eventually passed on to the ostream’s 
 streambuf. The streambuf may decide to throw an exception. However, this exception does not leave the 
 ostream using the streambuf. Rather, the exception is caught by the ostream, which sets its ios::bad_bit. 
 Exception raised by manipulators inserted into ostream objects are not caught by the ostream objects.
  
 Public members for input operations
  
 • std::streamsize in_avail():
  
 Returns a lower bound on the number of characters that can be read immediately.
  
 • int sbumpc():
  
 The next available character or EOF is returned. The returned character is removed from 
 the streambuf object. If no input is available, sbumpc calls the (protected)",NA
14.9 A polymorphic exception class,"Earlier in the
  C++
  Annotations (section
  10.3.1
 ) we hinted at the possibility of designing a class Exception 
 whose process member would behave differently, depending on the kind of exception that was thrown. 
 Now that we’ve introduced polymorphism we can further develop this example.
  
 It probably does not come as a surprise that our class Exception should be a polymorphic base class from 
 which special exception handling classes can be derived. In section
  10.3.1
  a member severity was used 
 offering functionality that may be replaced by members of the Exception base class.
  
 The base class Exception may be designed as follows:
  
 #ifndef INCLUDED_EXCEPTION_H_ 
  
 #define INCLUDED_EXCEPTION_H_ 
  
 #include <iostream> 
  
 #include <string>
  
 class Exception 
  
 { 
  
  
 std::string d_reason;
  
 public: 
  
 Exception(std::string const &reason); virtual 
 ~Exception();
  
 std::ostream &insertInto(std::ostream &out) const; void handle() 
 const;
  
  
 private: 
  
  
  
 virtual void action() const; 
  
 };
  
 inline void Exception::action() const 
  
 { 
  
  
 throw;",NA
14.10 ,NA,NA
How polymorphism is implemented,"This section briefly describes how polymorphism is implemented in
  C++
 . It is not necessary to un-derstand 
 how polymorphism is implemented if you just want to use polymorphism. However, we think it’s nice to 
 know how polymorphism is possible. Also, knowing how polymorphism is imple-mented clarifies why 
 there is a (small) penalty to using polymorphism in terms of memory usage and efficiency.
  
 The fundamental idea behind polymorphism is that the compiler does not know which function to call at 
 compile-time. The appropriate function is selected at run-time. That means that the address of the function 
 must be available somewhere, to be looked up prior to the actual call. This‘somewhere’ place must be 
 accessible to the object in question. So when a Vehicle *vp points to a Truck object, then vp->mass() calls 
 Truck’s member function. the address of this function is obtained through the actual object to which vp 
 points.
  
 Polymorphism is commonly implemented as follows: an object containing virtual member functions also 
 contains, usually as its first data member a hidden data member, pointing to an array containing the 
 addresses of the class’s virtual member functions. The hidden data member is usually called the vpointer, 
 the array of virtual member function addresses the vtable.
  
 The class’s vtable is shared by all objects of that class. The overhead of polymorphism in terms of memory 
 consumption is therefore:
  
 • one vpointer data member per object pointing to:
  
 • one vtable per class.
  
 Consequently, a statement like vp->mass first inspects the hidden data member of the object pointed to by 
 vp. In the case of the vehicle classification system, this data member points to a table containing two 
 addresses: one pointer to the function mass and one pointer to the function setMass (three pointers if the 
 class also defines (as it should) a virtual destructor). The actually called function is determined from this 
 table.
  
 The internal organization of the objects having virtual functions is illustrated in figures Figure
  14.5 
 and 
 Figure
  14.6
  (originals provided by Guillaume Caumon
 3
 ).
  
 As shown by figures Figure
  14.5
  and Figure
  14.6
 , objects potentially using virtual member functions must 
 have one (hidden) data member to address a table of function pointers. The objects of the
  
 3
 mailto:Guillaume.Caumon@ensg.inpl-nancy.fr",NA
14.11 ,NA,NA
Undefined reference to vtable ...,"Occasionaly, the linker generates an error like the following:
  
 In function ‘Derived::Derived()’: 
  
  
 : undefined reference to ‘vtable for Derived’
  
 This error is generated when a virtual function’s implementation is missing in a derived class, but the 
 function is mentioned in the derived class’s interface.
  
 Such a situation is easily encountered:
  
 • Construct a (complete) base class defining a virtual member function;
  
 • Construct a Derived class mentioning the virtual function in its interface;
  
 • The Derived class’s virtual function is not implemented. Of course, the compiler doesn’t know that the 
 derived class’s function is not implemented and will, when asked, generate code to create a derived 
 class object;
  
 • Eventually, the linker is unable to find the derived class’s virtual member function. Therefore, 
  
 it is 
 unable to construct the derived class’s vtable;
  
 • The linker complains with the message:
  
 undefined reference to ‘vtable for Derived’
  
 Here is an example producing the error:
  
 class Base 
  
 { 
  
  
 virtual void member(); 
  
 }; 
  
 inline void Base::member() 
  
 {} 
  
 class Derived: public Base 
  
 {
  
 };
  
 virtual void member(); // only declared
  
 int main() 
  
 { 
  
  
 Derived d; 
  
 // Will compile, since all members were declared.
  
  
 // Linking will fail, since we don’t have the 
  
 // 
 implementation of Derived::member() 
  
 }",NA
14.12 ,NA,NA
Virtual constructors,"In section
  14.2
  we learned that
  C++
  supports virtual destructors. Like many other object oriented 
 languages (e.g.,
  Java
 ), however, the notion of a virtual constructor is not supported. Not having virtual 
 constructors becomes a liability when only base class references or pointers are available, and a copy of a 
 derived class object is required. Gamma et al. (1995) discuss the Prototype design pattern to deal with this 
 situation.
  
 According to the Prototype Design Pattern each derived class is given the responsibility of implement-ing a 
 member function returning a pointer to a copy of the object for which the member is called. The usual 
 name for this function is clone. Separating the user interface from the reimplementa-tion interface clone is 
 made part of the interface and newCopy is defined in the reimplementation interface. A base class 
 supporting ‘cloning’ defines a virtual destructor, clone, returning newCopy’s return value and the virtual 
 copy constructor, a pure virtual function, having the prototype virtual Base *newCopy() const = 0. As 
 newCopy is a pure virtual function all derived classes must now implement their own ‘virtual constructor’.
  
 This setup suffices in most situations where we have a pointer or reference to a base class, but it fails when 
 used with abstract containers. We can’t create a vector<Base>, with Base featuring the pure virtual copy 
 member in its interface, as Base is called to initialize new elements of such a vector.
  
 This is impossible as newCopy is a pure virtual function, so a Base object can’t be constructed.
  
 The intuitive solution, providing newCopy with a default implementation, defining it as an ordinary virtual 
 function, fails too as the container calls Base(Base const &other), which would have to call newCopy to 
 copy other. At this point it is unclear what to do with that copy, as the new Base object already exists, and 
 contains no Base pointer or reference data member to assign newCopy’s return value to.
  
 Alternatively (and preferred) the original Base class (defined as an abstract base class) is kept as-is and a 
 wrapper class Clonable is used to manage the Base class pointers returned by newCopy. In chapter
  17
  ways 
 to merge Base and Clonable into one class are discussed, but for now we’ll define Base and Clonable as 
 separate classes.
  
 The class Clonable is a very standard class. 
  
 It contains a pointer member so it needs a copy 
 constructor, destructor, and overloaded assignment operator. It’s given at least one non-standard member: 
 Base &base() const, returning a reference to the derived object to which Clonable’s Base * data member 
 refers. It is also provided with an additional constructor to initialize its Base *data member.
  
 Any non-abstract class derived from Base must implement Base *newCopy(), returning a pointer to a newly 
 created (allocated) copy of the object for which newCopy is called.",NA
Chapter 15,NA,NA
Friends,"In all examples discussed up to now, we’ve seen that private members are only accessible by the members 
 of their class. This is good, as it enforces encapsulation and data hiding. By encapsulating functionality 
 within a class we prevent that a class exposes multiple responsibilities; by hiding data we promote a class’s 
 data integrity and we prevent that other parts of the software become implementation dependent on the 
 data that belong to a class.
  
 In this (very) short chapter we introduce the friend keyword and the principles that underly its use. The 
 bottom line being that by using the friend keyword functions are granted access to a class’s private 
 members. Even so, this does not imply that the principle of data hiding is abandoned when the friend 
 keyword is used.
  
 In this chapter the topic of friendship among classes is not discussed. Situations in which it is natural to use 
 friendship among classes are discussed in chapters
  17
  and
  21
  and such situations are natural extensions of 
 the way friendship is handled for functions.
  
 There should be a well-defined conceptual reason for declaring friendship (i.e., using the friend keyword). 
 The traditionally offered definition of the class concept usually looks something like this:
  
 A class is a set of data together with the functions that operate on that set of data.
  
 As we’ve seen in chapter
  11
  some functions have to be defined outside of a class interface. They are defined 
 outside of the class interface to allow promotions for their operands or to extend the facilities of existing 
 classes not directly under our control. According to the above traditional definition of the class concept 
 those functions that cannot be defined in the class interface itself should nevertheless be considered 
 functions belonging to the class. Stated otherwise: if permitted by the language’s syntax they would 
 certainly have been defined inside the class interface. There are two ways to implement such functions. 
 One way consists of implementing those functions using available public member functions. This approach 
 was used, e.g., in section
  11.2
 . Another approach applies the definition of the class concept to those 
 functions. By stating that those functions in fact belong to the class they should be given direct access to the 
 data members of objects. This is accomplished by the friend keyword.
  
 As a general principle we state that all functions operating on the data of objects of a class that are declared 
 in the same file as the class interface itself belong to that class and may be granted direct access to the 
 class’s data members.
  
 427",NA
Friend functions,CHAPTER 15. FRIENDS,NA
15.1,"In section
  11.2
  the insertion operator of the class Person (cf. section
  9.3
 ) was implemented like this:
  
 ostream &operator<<(ostream &out, Person const &person) { 
  
  
 return 
  
  
 out << 
  
  
  
  
 ""Name: 
  
 "" << person.name() << 
  
 "", "" 
  
  
  
  
 ""Address: "" << person.address() << 
  
  
 "", "" 
   
  
 ""Phone: 
  
 "" << 
 person.phone(); 
  
 }
  
 Person objects can now be inserted into streams.
  
 However, this implementation required three member functions to be called, which may be considered a 
 source of inefficiency. An improvement would be reached by defining a member Person::insertInto and let 
 operator« call that function. These two functions could be defined as follows:
  
 std::ostream &operator<<(std::ostream &out, Person const &person) { 
  
  
 return person.insertInto(out); 
  
 } 
  
 std::ostream &Person::insertInto(std::ostream &out) 
  
 { 
  
  
 return 
  
  
 out << ""Name: 
  
 "" << d_name << "", "" 
   
  
 ""Address: "" << d_address << "", "" 
  
  
  
  
 ""Phone: "" << d_phone; 
  
 }
  
 As insertInto is a member function it has direct access to the object’s data members so no addi-tional 
 member functions must be called when inserting person into out.
  
 The next step consists of realizing that insertInto is only defined for the benefit of operator«, and that 
 operator«, as it is declared in the header file containing Person’s class interface should be considered a 
 function belonging to the class Person. The member insertInto can therefore be omitted when operator« is 
 declared as a friend.
  
 Friend functions must be declared as friends in the class interface. These friend declarations are not 
 member functions, and so they are independent of the class’s private, protected and public sections. Friend 
 declaration may be placed anywhere in the class interface. Convention dictates that friend declaractions 
 are listed directly at the top of the class interface. The class Person, using friend declaration for its 
 extraction and insertion operators starts like this:
  
 class Person 
  
 { 
  
  
 friend std::ostream &operator<<(std::ostream &out, Person &pd); 
  
 friend std::istream 
 &operator>>(std::istream &in, Person &pd);
  
  
 // previously shown interface (data and functions) };",NA
15.2 Extended friend declarations,"C++11 simplifies friend declarations by adding extended friend declarations to the language. When a class 
 is declared as a friend, then the class keyword no longer has to be provided. E.g.,
  
 class Friend; // declare a class
  
 typedef Friend FriendType; using 
 FName = Friend;
  
 class Class1 
  
 { 
  
  
 friend Friend; };
  
 // and a typedef for it 
  
 // and a using declaration
  
 // FriendType and FNaem: also OK
  
 In the pre-C++11 standards the friend declaration required an explicit class; e.g., friend class Friend.
  
 The explicit use of class remains required if the compiler hasn’t seen the friend’s name yet. E.g.,
  
 class Class1 
  
 { 
  
  
 // friend Unseen; // fails to compile: Unseen unknown.
  
  
 friend class Unseen; // OK 
  
 };
  
 Section
  22.10
  covers the use of extended friend declarations in class templates.",NA
Chapter 16,NA,NA
Classes Having Pointers To,NA,NA
Members,"Classes having pointer data members have been discussed in detail in chapter
  9
 . Classes defin-ing pointer 
 data-members deserve some special attention, as they usually require the definitions of copy constructors, 
 overloaded assignment operators and destructors
  
 Situations exist where we do not need a pointer to an object but rather a pointer to members of a class. 
 Pointers to members can profitably be used to configure the behavior of objects of classes.
  
 Depending on which member a pointer to a member points to objects will show certain behavior.
  
 Although pointers to members have their use, polymorphism can frequently be used to realize com-parable 
 behavior. Consider a class having a member process performing one of a series of alternate behaviors. 
 Instead of selecting the behavior of choice at object construction time the class could use the interface of 
 some (abstract) base class, passing an object of some derived class to its constructor and could thus 
 configure its behavior. This allows for easy, extensible and flexible configuration, but access to the class’s 
 data members would be less flexible and would possibly require the use of‘friend’ declarations. In such 
 cases pointers to members may actually be preferred as this allows for (somewhat less flexible) 
 configuration as well as direct access to a class’s data members.
  
 So the choice apparently is between on the one hand ease of configuration and on the other hand ease of 
 access to a class’s data members. In this chapter we’ll concentrate on pointers to members, investigating 
 what these pointers have to offer.",NA
16.1 Pointers to members: an example,"Knowing how pointers to variables and objects are used does not intuitively lead to the concept of pointers 
 to members . Even if the return types and parameter types of member functions are taken into account, 
 surprises can easily be encountered. For example, consider the following class:
  
 class String 
  
 { 
  
  
 char const *(*d_sp)() const;
  
  
 public: 
  
  
  
 char const *get() const; 
  
 };
  
 431",NA
16.2 ,NA,NA
Defining pointers to members,"Pointers to members are defined by prefixing the normal pointer notation with the appropriate class plus 
 scope resolution operator. Therefore, in the previous section, we used char const * (String::*d_sp)() const 
 to indicate that d_sp
  
 • is a pointer (*d_sp);
  
 • points to something in the class String (String::*d_sp);
  
 • is
  
 a
  
 pointer
  
 to
  
 a
  
 const
  
 function,
  
 returning
  
 a
  
 char const *
  
 (char const *
  
 (String::*d_sp)() const).
  
 The prototype of a matching function is therefore:
  
 char const *String::somefun() const;
  
 which is any const parameterless function in the class String, returning a char const *.
  
 When defining pointers to members the standard procedure for constructing pointers to functions can still 
 be applied:
  
 • put parentheses around the fully qualified function name (i.e., the function’s header, including 
  
 the function’s class name):
  
 char const * ( String::somefun ) () const
  
 • Put a pointer (a star (*)) character immediately before the function name itself:
  
 char const * ( String:: * somefun ) () const",NA
16.3 ,NA,NA
Using pointers to members,"Using pointers to members to call a member function requires the existence of an object of the class of the 
 members to which the pointer to member refers to. With pointers operating at global scope, the 
 dereferencing operator * is used. With pointers to objects the field selector operator operating on pointers 
 (->) or the field selector operating operating on objects (.) can be used to select appropriate members.
  
 To use a pointer to member in combination with an object the pointer to member field selector (.*) must be 
 specified. To use a pointer to a member via a pointer to an object the ‘pointer to member field selector 
 through a pointer to an object’ (->*) must be specified. These two operators combine the notions of a field 
 selection (the . and -> parts) to reach the appropriate field in an object and of dereferencing: a dereference 
 operation is used to reach the function or variable the pointer to member points to.
  
 Using the example from the previous section, let’s see how we can use pointers to member functions and 
 pointers to data members:
  
 #include <iostream>",NA
16.4 Pointers to static members,"Static members of a class can be used without having available an object of their class. Public static 
 members can be called like free functions, albeit that their class names must be specified when they are 
 called.
  
 Assume a class String has a public static member function count, returning the number of string objects 
 created so far. Then, without using any String object the function String::count may be called:
  
 void fun() 
  
 { 
  
  
 cout << String::count() << ’\n’; 
  
 }
  
 Public static members can be called like free functions (but see also section
  8.2.1
 ). Private static members 
 can only be called within the context of their class, by their class’s member or friend functions.
  
 Since static members have no associated objects their addresses can be stored in ordinary func-tion 
 pointer variables, operating at the global level. Pointers to members cannot be used to store addresses of 
 static members. Example:",NA
16.5 ,NA,NA
Pointer sizes,"An interesting characteristic of pointers to members is that their sizes differ from those of ‘normal’pointers. 
 Consider the following little program:
  
 #include <string> 
  
 #include <iostream>
  
 class X 
  
 { 
  
  
 public: 
  
  
 void fun(); 
  
  
 std::string d_str; 
  
 }; 
  
 inline void X::fun() 
  
 { 
  
  
 std::cout << ""hello\n""; 
  
 }
  
 using namespace std; 
  
 int main() 
  
 { 
  
  
 cout << 
  
  
 ""size of pointer to data-member: 
  
 "" << sizeof(&X::d_str) << ""\n"" 
  
 ""size 
 of pointer to member function: "" << sizeof(&X::fun) << ""\n"" 
  
 ""size of pointer to non-member data: "" << 
 sizeof(char *) << ""\n""
  
 }
  
 ""size of pointer to free function: 
  
 "" << sizeof(&printf) << ’\n’;
  
 /* 
  
  
 generated output (on 32-bit architectures):
  
  
 size of pointer to data-member: 
  
 4 
  
 size of pointer to member function: 8 
  
 size of pointer to non-member data: 4 
  
 size of pointer to free function: 
  
 4 
 */
  
 On a 32-bit architecture a pointer to a member function requires eight bytes, whereas other kind of pointers 
 require four bytes (Using Gnu’s g++ compiler).
  
 Pointer sizes are hardly ever explicitly used, but their sizes may cause confusion in statements like:",NA
Chapter 17,NA,NA
Nested Classes,"Classes can be defined inside other classes. Classes that are defined inside other classes are called nested 
 classes. Nested classes are used in situations where the nested class has a close conceptual re-lationship to 
 its surrounding class. For example, with the class string a type string::iterator is available which provides 
 all characters that are stored in the string. This string::iterator type could be defined as an object iterator, 
 defined as nested class in the class string.
  
 A class can be nested in every part of the surrounding class: in the public, protected or private section. Such 
 a nested class can be considered a member of the surrounding class. The normal access and rules in classes 
 apply to nested classes. If a class is nested in the public section of a class, it is visible outside the 
 surrounding class. If it is nested in the protected section it is visible in subclasses, derived from the 
 surrounding class, if it is nested in the private section, it is only visible for the members of the surrounding 
 class.
  
 The surrounding class has no special privileges towards the nested class. The nested class has full control 
 over the accessibility of its members by the surrounding class. For example, consider the following class 
 definition:
  
 class Surround 
  
 { 
  
  
 public: 
  
  
  
 class FirstWithin 
  
  
  
 { 
  
  
  
  
 int d_variable;
  
  
  
 public: 
  
  
  
  
 FirstWithin(); 
  
  
  
  
 int var() const; 
  
  
 }; 
  
 private: 
  
  
 class SecondWithin 
  
  
 { 
  
  
  
 int d_variable;
  
  
  
 public: 
  
  
  
  
 SecondWithin(); 
  
  
  
  
 int var() const; 
  
  
 }; 
  
 };
  
 441",NA
17.1 Defining nested class members,"Member functions of nested classes may be defined as inline functions. Inline member functions can be 
 defined as if they were defined outside of the class definition. To define the member function Outer::caller 
 outside of the class Outer, the function’s fully qualified name (starting from the outermost class scope 
 (Outer)) must be provided to the compiler. Inline and in-class functions can be defined accordingly. They 
 can be defined and they can use any nested class. Even if the nested class’s definition appears later in the 
 outer class’s interface.
  
 When (nested) member functions are defined inline, their definitions should be put below their class 
 interface. Static nested data members are also usually defined outside of their classes. If the class 
 FirstWithin would have had a static size_t datamember epoch, it could have been initialized as follows:
  
 size_t Surround::FirstWithin::epoch = 1970;
  
 Furthermore, multiple scope resolution operators are needed to refer to public static members in code 
 outside of the surrounding class:
  
 void showEpoch() 
  
 { 
  
  
 cout << Surround::FirstWithin::epoch; }
  
 Within the class Surround only the FirstWithin:: 
  
 scope must be used; within the class 
 FirstWithin there is no need to refer explicitly to the scope.
  
 What about the members of the class SecondWithin? 
  
 The classes FirstWithin and 
 SecondWithin are both nested within Surround, and can be considered members of the sur-rounding class. 
  
 Since members of a class may directly refer to each other, members of the class 
 SecondWithin can refer to (public) members of the class FirstWithin. 
  
 Consequently, members of the class 
 SecondWithin could refer to the epoch member of FirstWithin as FirstWithin::epoch.",NA
Declaring nested classes,CHAPTER 17. NESTED CLASSES,NA
17.2,"Nested classes may be declared before they are actually defined in a surrounding class. Such forward 
 declarations are required if a class contains multiple nested classes, and the nested classes contain 
 pointers, references, parameters or return values to objects of the other nested classes.
  
 For example, the following class Outer contains two nested classes Inner1 and Inner2. The class Inner1 
 contains a pointer to Inner2 objects, and Inner2 contains a pointer to Inner1 objects. Cross references 
 require forward declarations. Forward declarations must be given an access speci-fication that is identical 
 to the access specification of their definitions. In the following example the Inner2 forward declaration 
 must be given in a private section, as its definition is also part of the class Outer’s private interface:
  
 class Outer 
  
 { 
  
  
 private:
  
 };
  
 class Inner2; 
  
 // forward declaration
  
 class Inner1 
  
 { 
  
  
 Inner2 *pi2; 
  
 // points to Inner2 objects }; 
  
 class Inner2 
  
 { 
  
  
 Inner1 *pi1; 
  
  
 // points to Inner1 objects };",NA
17.3 ,NA,NA
Accessing private members in nested classes,"To grant nested classes access rights to the private members of other nested classes, or to grant a 
 surrounding class access to the private members of its nested classes the friend keyword must be used.
  
 Note that no friend declaration is required to grant a nested class access to the private members of its 
 surrounding class. After all, a nested class is a type defined by its surrounding class and as such objects of 
 the nested class are members of the outer class and thus can access all the outer class’s members. Here is 
 an example showing this principle. The example won’t compile as members of the class Extern are denied 
 access to Outer’s private members, but Outer::Inner’s members can access Outer’s private memebrs:
  
 class Outer 
  
 { 
  
  
 int d_value; 
  
  
 static int s_value;
  
 public: 
  
 Outer()",NA
17.4 ,NA,NA
Nesting enumerations,"Enumerations may also be nested in classes. Nesting enumerations is a good way to show the close 
 connection between the enumeration and its class. Nested enumerations have the same controlled 
 visibility as other class members. They may be defined in the private, protected or public sections of 
 classes and are inherited by derived classes. In the class ios we’ve seen values like ios::beg and ios::cur. In 
 the current Gnu
  C++
  implementation these values are defined as values of the seek_dir enumeration:
  
 class ios: public _ios_fields 
  
 { 
  
  
 public: 
  
  
 enum seek_dir 
  
  
 { 
  
  
  
  
 beg, 
  
  
  
  
 cur, 
  
  
  
  
 end 
  
  
 }; 
  
 };",NA
17.5 Revisiting virtual constructors,"In section
  14.12
  the notion of virtual constructors was introduced. In that section a class Base was defined 
 as an abstract base class. A class Clonable was defined to manage Base class pointers in containers like 
 vectors.
  
 As the class Base is a minute class, hardly requiring any implementation, it can very well be defined as a 
 nested class in Clonable. This emphasizes the close relationship between Clonable and Base.
  
 Nesting Base under Clonable changes
  
 class Derived: public Base
  
 into:
  
 class Derived: public Clonable::Base
  
 Apart from defining Base as a nested class and deriving from Clonable::Base rather than from Base (and 
 providing Base members with the proper Clonable:: prefix to complete their fully qualified names), no 
 further modifications are required. Here are the modified parts of the program shown earlier (cf. section
  
 14.12
 ), now using Base nested under Clonable:
  
 // Clonable and nested Base, including their inline members: class Clonable 
  
 { 
  
  
 public: 
  
  
  
  
 class Base; 
  
  
 private: 
  
  
  
  
 Base *d_bp; 
  
  
 public: 
  
  
  
  
 class Base 
  
  
  
  
 { 
  
  
  
  
  
 public: 
  
  
  
  
  
 virtual ~Base(); 
  
  
  
  
  
 Base *clone() const; 
  
  
  
  
  
 private: 
  
  
  
  
  
 virtual Base *newCopy() const = 0; 
  
  
  
  
 }; 
  
  
  
  
 Clonable(); 
  
  
  
  
 explicit Clonable(Base *base); 
  
  
  
  
 ~Clonable(); 
  
  
  
  
 Clonable(Clonable const &other); 
  
  
  
  
 Clonable(Clonable &&tmp); 
  
  
  
  
 Clonable &operator=(Clonable const &other); 
  
  
  
 Clonable &operator=(Clonable &&tmp);
  
  
  
 Base &base() const; 
  
 }; 
  
 inline Clonable::Base *Clonable::Base::clone() const { 
  
  
 return newCopy(); 
  
 } 
  
 inline Clonable::Base &Clonable::base() const 
  
 {",NA
Chapter 18,NA,NA
The Standard Template Library,"The Standard Template Library (STL) is a general purpose library consisting of containers, generic 
 algorithms, iterators, function objects, allocators, adaptors and data structures. The data structures used by 
 the algorithms are abstract in the sense that the algorithms can be used with (practically) any data type.
  
 The algorithms can process these abstract data types because they are template based. This chapter does 
 not cover template construction (see chapter
  21
  for that). Rather, it focuses on the use of the algorithms.
  
 Several elements also used by the standard template library have already been discussed in the
  C++ 
 Annotations. In chapter
  12
  abstract containers were discussed, and in section
  11.10
  function objects were 
 introduced. Also, iterators were mentioned at several places in this document.
  
 The main components of the STL are covered in this and the next chapter. Iterators, adaptors, smart 
 pointers, multi threading and other features of the STL are discussed in coming sections. Generic 
 algorithms are covered in the next chapter (
 19
 ).
  
 Allocators take care of the memory allocation within the STL. The default allocator class suffices for most 
 applications, and is not further discussed in the
  C++
  Annotations.
  
 All elements of the STL are defined in the standard namespace. Therefore, a using namespace std or a 
 comparable directive is required unless it is preferred to specify the required namespace explicitly. In 
 header files the std namespace should explicitly be used (cf. section
  7.12.1
 ).
  
 In this chapter the empty angle bracket notation is frequently used. In code a typename must be supplied 
 between the angle brackets. E.g., plus<> is used in the
  C++
  Annotations, but in code plus<string> may be 
 encountered.",NA
18.1 Predefined function objects,"Before using the predefined function objects presented in this section the <functional> header file must be 
 included.
  
 Function objects play important roles in generic algorithms. For example, there exists a generic algorithm 
 sort expecting two iterators defining the range of objects that should be sorted, as well as a function object 
 calling the appropriate comparison operator for two objects. Let’s take a quick look at this situation. 
 Assume strings are stored in a vector, and we want to sort the vector in
  
 453",NA
18.2 Iterators,"In addition to the conceptual iterator types presented in this section the STL defines several adap-tors 
 allowing objects to be passed as iterators. These adaptors are presented in the upcoming sec-tions. Before 
 those adaptors can be used the <iterator> header file must be included.
  
 Iterators are objects acting like pointers. Iterators have the following general characteristics:
  
 • Two iterators may be compared for (in)equality using the == and != operators. The ordering 
  
 operators (e.g., >, <) can usually not be used.
  
 • Given an iterator iter, *iter represents the object the iterator points to (alternatively, 
  
 iter-> can be 
 used to reach the members of the object the iterator points to).
  
 • ++iter or iter++ advances the iterator to the next element. The notion of advancing an iter-ator to the 
 next element is consequently applied: several containers support reversed_iterator types, in which 
 the ++iter operation actually reaches a previous element in a sequence.
  
 • Pointer arithmetic may be used with iterators of containers storing their elements consec-
  
 utively in memory like vector and deque.
  
 For such containers iter + 2 points to the
  
 second element beyond the one to which iter points. 
  
 See also section
  18.2.1
 , covering
  
 std::distance.",NA
18.3 The class ’unique_ptr’,"Before using the unique_ptr class presented in this section the <memory> header file must be included.
  
 When pointers are used to access dynamically allocated memory strict bookkeeping is required to prevent 
 memory leaks. When a pointer variable referring to dynamically allocated memory goes out of scope, the 
 dynamically allocated memory becomes inaccessible and the program suffers from a memory leak.
  
 To prevent such memory leaks strict bookkeeping is required: the programmer has to make sure that the 
 dynamically allocated memory is returned to the common pool just before the pointer variable goes out of 
 scope.
  
 When a pointer variable points to a dynamically allocated single value or object, bookkeeping re-
 quirements are greatly simplified when the pointer variable is defined as a std::unique_ptr ob-ject.
  
 Unique_ptrs are objects masquerading as pointers. Since they are objects, their destructors are called when 
 they go out of scope. Their destructors automatically delete the dynamically allocated memory.
  
 Unique_ptrs have some special characteristics:
  
 • when assigning a unique_ptr to another move semantics is used. If move semantics is not available 
 compilation fails. On the other hand, if compilation succeeds then the used containers or generic 
 algorithms support the use of unique_ptrs. Here is an example:
  
 std::unique_ptr<int> up1(new int);
  
 std::unique_ptr<int> up2(up1);
  
 // compilation error",NA
18.4 ,NA,NA
The class ’shared_ptr’,"In addition to unique_ptr the C++11 standard offers std::shared_ptr<Type> which is a refer-ence counting 
 smart pointer.
  
 Before using shared_ptrs the <memory> header file must be included.
  
 The shared pointer automatically destroys its contents once its reference count has decayed to zero. As 
 with unique_ptr, when defining a shared_ptr<Base> to store a newly allocated Derived class object, the 
 returned Base * may be cast to a Derived * using a static_cast: polymorphism isn’t required, and when 
 resetting the shared_ptr or when the shared_ptr goes out of scope, no slicing occurs, and Derived’s 
 destructor is called (cf. section
  18.3
 ).
  
 Shared_ptrs support copy and move constructors as well as standard and move overloaded assign-ment 
 operators.
  
 Like unique_ptrs, shared_ptrs may refer to dynamically allocated arrays.
  
 18.4.1 
  
 Defining ‘shared_ptr’ objects
  
 There are four ways to define shared_ptr objects. specifier 
 between angle brackets:
  
 Each definition contains the usual <type>
  
 • The default constructor simply creates a shared_ptr object that does not point to a particular 
  
 block of memory. Its pointer is initialized to 0 (zero):
  
 shared_ptr<type> identifier;
  
 This form is discussed in section
  18.4.2
 .
  
 • The copy constructor initializes a shared_ptr so that both objects share the memory pointed at by the 
 existing object. The copy constructor also increments the shared_ptr’s reference count. Example:
  
 shared_ptr<string> org(new string(""hi there"")); 
  
 shared_ptr<string> copy(org); // reference count now 2
  
 • The move constructor initializes a shared_ptr with the pointer and reference count of a 
  
 temporary shared_ptr. The temporary shared_ptr is changed into a 0-pointer. An ex-
  
 isting 
 shared_ptr may have its data moved to a newly defined shared_ptr (turning the 
  
 existing 
 shared_ptr into a 0-pointer as well). In the next example a temporary, anonymous 
  
 shared_ptr object is constructed, which is then used to construct grabber. Since grabber’s",NA
18.5 ,NA,NA
Using ‘make_shared’ to combine ‘shared_ptr’ and ‘new’,"Usually a shared_ptr is initialized at definition time with a pointer to a newly allocated object. Here is an 
 example:
  
 std::shared_ptr<string> sptr(new std::string(""hello world""))
  
 In such statements two memory allocation calls are used: one for the allocation of the std::string and one 
 used interally by std::shared_ptr’s constructor itself.
  
 The two allocations can be combined into one single allocation (which is also slightly more efficient than 
 explicitly calling shared_ptr’s constructor) using the make_shared template. The function template 
 std::make_shared has the following prototype:
  
 template<typename Type, typename ...Args> 
  
 std::shared_ptr<Type> std::make_shared(Args ...args);
  
 Before using make_shared the <memory> header file must be included.
  
 This function template allocates an object of type Type, passing args to its constructor (using perfect 
 forwarding, see section
  22.5.2
 ), and returns a shared_ptr initialized with the address of the newly allocated 
 Type object.
  
 Here is how the above sptr object can be initialized using std::make_shared. Notice the use of auto which 
 frees us from having to specify sptr’s type explicitly:
  
 auto sptr(std::make_shared<std::string>(""hello world""));
  
 After this initialization std::shared_ptr<std::string> sptr has been defined and initialized. It could be used as 
 follows:
  
 std::cout << *sptr << ’\n’;",NA
18.6 ,NA,NA
Classes having pointer data members,"Classes having pointer data members require special attention. In particular at construction time one must 
 be careful to prevent wild pointers and/or memory leaks. Consider the following class defining two pointer 
 data members:
  
 class Filter 
  
 { 
  
  
 istream *d_in; 
  
  
 ostream *d_out; 
  
  
 public: 
  
  
 Filter(char const *in, char const *out); };
  
 Assume that Filter objects filter information read from *d_in and write the filtered information to *d_out. 
 Using pointers to streams allows us to have them point at any kind of stream like",NA
18.7 Lambda expressions,"The C++11 standard adds lambda expressions to the language. As we’ll see in chapter
  19
  generic 
 algorithms often accept arguments that can either be function objects or plain functions. Examples are the 
 sort (cf. section
  19.1.58
 ) and find_if (cf. section
  19.1.16
 ) generic algorithms. As a rule of thumb: when a 
 called function must remember its state a function object is appropriate, otherwise a plain function can be 
 used.
  
 Frequently the function or function object is not readily available, and it must be defined in or near the 
 location where it is used. This is commonly realized by defining a class or function in the anonymous 
 namespace (say: class or function A), passing an A to the code needing A. If that code is itself a member 
 function of the class B, then A’s implementation might benefit from having access to the members of class 
 B.
  
 Often this scheme results in a significant amount of code (defining the class), or it results in complex code 
 (to make available software elements that aren’t automatically accessible to A’s code). It may also result in 
 code that is irrelevant at the current level of specification. Nested classes don’t solve these problems either. 
 Moreover, nested classes can’t be used in templates.
  
 Lamba expressions solve these problems. A lambda expression defines an anonymous function ob-ject, also 
 called a closure object. When a lambda expression is evaluated it results in a temporary object (the closure 
 object). The type of a closure object is called its closure type.
  
 Lambda expressions may be used inside blocks, classes or namespaces (i.e., pretty much anywhere you 
 like). Their implied closure type is defined in the smallest block, class or namespace scope which contains 
 the lamba expression. The closure object’s visibility starts at its point of definition and ends where its 
 closure type ends.
  
 The closure type defines a (const) public inline function call operator. Here is an example of a lambda 
 expression:
  
 [] 
  
  
 // the ‘lambda-introducer’(int x, int y) 
  
 // the ‘lambda-declarator’{ 
   
 // a normal compound-statement 
  
 return x * y; 
  
 }
  
 The function call operator of the closure object created by this lambda expression expects two int 
 arguments and returns their product. It is an inline const member of the closure type. To drop the const 
 attribute, the lamba expression should specify mutable, as follows:
  
 [](int x, int y) mutable 
  
 ...
  
 The lambda-declarator may be omitted, if no parameters are defined. The parameters in a lamba declarator 
 may not be given default arguments.
  
 A closure object as defined by the above lamda expression could be used e.g., in combination with the 
 accumulate (cf. section
  19.1.1
 ) generic algorithm to compute the product of a series of int values stored in a 
 vector:
  
 cout << accumulate(vi.begin(), vi.end(), 1, 
  
  
 [](int x, int y) { return x * y; });",NA
18.8 ,NA,NA
Regular Expressions,"The C++11 standard adds handling of regular expression regular expressions to the language. Be-fore using 
 regular expressions as offered by the C++ standard the header file <regex> must be included.
  
 Regular expressions were already available in
  C++
  via its
  C
  heritage as
  C
  has always offered functions like 
 regcomp and regexec. 
  
 C++
  itself did not provide facilities for handling reg-ular 
 expressions. 
  
 Programmers had to use the basic std::string matching procedures (like find_first_of), 
 thus avoiding regular expressions, or they had to use the existing
  C
  functions (which do not encapsulate 
 (manipulating) the required data structures), or regular expressions where available through regular 
 expression classes made available by third-party libraries (like the Pattern class of the Bobcat
 1
 ) library.
  
 Regular expressions are extensively documented elsewhere (e.g.,
  regex
 (7), Friedl, J.E.F Mastering Regular 
 Expressions
 2
 , O’Reilly). The reader is referred to these sources for a refresher on the topic of regular 
 expressions. In essence, regular expressions define a small meta-language recog-nizing textual units (like 
 ‘numbers’, ‘identifiers’, etc.). They are extensively used in the context of lexical scanners (cf. section
  24.8.1
 ) 
 when defining the sequence of input characters associated with tokens. But they are also intensively used 
 in other situations. Programs like
  sed
 (1) and
  grep
 (1) use regular expressions to find pieces of text in files 
 having certain characteristics, and a program like 
 perl
 (1) adds some ‘sugar’ to the regular expression 
 language, simplifying the construction of regular expressions. However, though extremely useful, it is also 
 well known that regular expressions tend to be very hard to read. Some even call the regular expression 
 language a write-only language: while specifying a regular expression it’s often clear why it’s written in a 
 particular way. But the opposite, understanding what a regular expression is supposed to represent if you 
 lack the proper context,
  
 1
 http://bobcat.sourceforge.net 
  
 2
 http://oreilly.com/catalog/",NA
18.9 Randomization and Statistical Distributions,"Before the statistical distributions and accompanying random number generators can be used the 
 <random> header file must be included.
  
 The C++11 standard introduces several standard mathematical (statistical) distributions into the STL. 
 These distributions allow programmers to obtain randomly selected values from a selected distribution.
  
 These statistical distributions need to be provided with a random number generating object. Several of 
 such random number generating objects are provided, extending the traditional rand function that is part 
 of the
  C
  standard library.
  
 These random number generating objects produce pseudo-random numbers, which are then pro-cessed by 
 the statistical distribution to obtain values that are randomly selected from the specified distribution.
  
 Although the STL offers various statistical distributions their functionality is fairly limited. The distributions 
 allow us to obtain a random number from these distributions, but probability density functions or cumulative 
 distribution functions are currently not provided by the STL. These func-tions (distributions as well as the 
 density and the cumulative distribution functions) are, however, available in other libraries, like the boost math 
 library
 4
 (specifically: 
  
 http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html).
  
 It is beyond the scope of the
  C++
  Annotations to discuss the mathematical character-
  
 istics
  
 of
  
 the
  
 various
  
 distributions
  
 that
  
 are
  
 supported
  
 by
  
 the
  
 C++11
  
 standard.
  
 The
  
 interested
  
 reader
  
 is
  
 referred
  
 to
  
 the
  
 pertinent
  
 mathematical
  
 textbooks
  
 (like
  
 Stuart
  
 and
  
 Ord’s
  
 (2009)
  
 Kendall’s
  
 Advanced
  
 Theory
  
 of
  
 Statistics,
  
 Wiley)
  
 or
  
 to
  
 web-locations
  
 like
  
 http://en.wikipedia.org/wiki/Bernoulli_distribution.
  
 4
 http://www.boost.org/",NA
Chapter 19,NA,NA
The STL Generic Algorithms,NA,NA
19.1 The Generic Algorithms,"Before using the generic algorithms presented in this chapter, except for those in the Operators category 
 (defined below), the <algorithm> header file must be included. Before using a generic algorithm in the 
 Operators category the <numeric> header file must be included.
  
 In the previous chapter the Standard Template Library (STL) was introduced. An important el-ement of the 
 STL, the generic algorithms, was not covered in that chapter as they form a fairly extensive part of the STL. 
 Over time the STL has grown considerably, mainly as a result of a grow-ing importance and appreciation of 
 templates. Covering generic algorithm in the STL chapter itself would turn that chapter into an unwieldy 
 one and so the generic algorithms were moved to a chapter of their own.
  
 Generic algorithms perform an amazing task. Due to the strength of templates, algorithms could be 
 developed that can be applied to a wide range of different data types while maintaining type safety. The 
 prototypical example of this is the sort generic algorithm. To contrast: while
  C
  requires programmers to 
 write callback functions in which type-unsafe void const * parameters have to be used, internally forcing 
 the programmer to resort to casts, STL’s sort frequently allows the programmer merely to state something 
 akin to
  
 sort(first-element, last-element)
  
 Generic algoritms should be used wherever possible. Avoid the urge to design your own code for com-
 monly encountered algorithms. Make it a habit to first thoroughly search the generic algorithms for an 
 available candidate. The generic algorithms should become your weapon of choice when writing code: 
 acquire full familiarity with them and make their use your ‘second nature’.
  
 This chapter’s sections cover the STL’s generic algorithms in alphabetical order. For each algorithm the 
 following information is provided:
  
 • The required header file;
  
 • The function prototype;
  
 • A short description;
  
 • A short example.
  
 525",NA
19.2 ,NA,NA
STL: More function adaptors,"Before using the function adaptors presented in these (sub)sections the <functional> header file must be 
 included.
  
 Member function adaptors are part of the Standard Template Library (STL). They are most useful in 
 combination with the generic algorithms, which is why they are discussed in this chapter instead of the 
 previous chapter which was devoted to the STL.
  
 The member function adaptors defined in the STL allow us to call (parameterless) member functions of 
 class objects as though they were non-member functions and to compose unary or binary argument 
 functions into single function objects so that they can jointly be used with generic algorithms.
  
 In the next section calling member functions as non-member functions is discussed; adaptable func-tions 
 are covered thereafter.",NA
Chapter 20,NA,NA
Multi Threading,"The 98
  C++
  standard did not acknowledge the existence of multi-threading. Between then and the release 
 of the C++11 standard computers have evolved to multi-core machines, and using multi-threading by now 
 is a real option to consider when developing software.
  
 Multi-threading is an extensive and complex subject, and many good reference texts on the subject exist. 
 The
  C++
  multi-threading is built upon the facilities offered by the pthreads library (cf. Nichols, B, et al.’s 
 Pthreads Programming
 1
 , O’Reilly ). However, in line with
  C++
 ’s current-day philosophy the multi-threading 
 implementation offered by the C++11 standard offers a high level interface to multi-threading, and using 
 the raw pthread building blocks is hardly ever necessary (cf. Williams, A. (2012):
  C++ Concurrency in 
 action
 , Manning).
  
 In this chapter the facilities for multi-threading as offered by the C++11 standard are covered. Although the 
 coverage aims at providing the tools and examples allowing you to create your own multi-threaded 
 programs, coverage necessarily is far from complete. The topic of multi threading is too extensive for that. 
 The mentioned reference texts provide a good starting point for any further study of multi threading.
  
 A thread of execution (commonly abbreviated to a thread) is a single flow of control within a program. It 
 differs from a separately executed program, as created by the
  fork
 (1) system call in the sense that threads 
 all run inside one program, while
  fork
 (1) creates independent copies of a running program. Multi-
 threading means that multiple tasks are being executed in parallel inside one program, and no assumptions 
 can be made as to which thread is running first or last, or at what moment in time. Especially when the 
 number of threads does not exceed the number of cores, each thread may be active at the same time. If the 
 number of threads exceed the number of cores, the operating system will resort to task switching, offering 
 each thread time slices in which it can perform its tasks. Task switching takes time, and the law of 
 diminishing returns applies here as well: if the number of threads greatly exceeds the number of available 
 cores (also called overpopulation), then the overhead incurred may exceed the benefit of being able to run 
 multiple tasks in parallel.
  
 Since all threads are running inside one single program, all threads share the program’s data and code. 
 When the same data are accessed by multiple threads, and at least one of the threads is modifying these 
 data, access must be synchronized to avoid that threads read data while these data are being modified by 
 other threads, and to avoid that multiple threads modify the same data at the same time.
  
 So how do we run a multi-threaded program in
  C++
 ? Let’s look at hello world, the multi-threaded way:
  
 1
 http://oreilly.com/catalog/
  
 609",NA
20.1 ,NA,NA
Handling time (absolute and relative),"The
  C
  programming language offered tools like
  sleep
 (3) and
  select
 (2) to suspend program execution for a 
 certain amount of time.
  
 In multi threaded programs threads are frequently suspended, albeit usually for a very short time interval. 
 E.g., when a thread must access a variable, but the variable is currently updated by another thread, then the 
 first thread should wait until the second thread has completed the update. Updating a variable usually 
 doesn’t take much time, but if it may take an unexpectedly long time, then the waiting thread may want to 
 be informed about it, so it can do something else as long as the second thread hasn’t finished updating the 
 variable.",NA
20.2 Multi Threading,"In C++ multi threading may be implemented at various levels of abstraction. In general the highest level of 
 abstraction which is available to implement a mult-threaded problem should be used. Not so much because 
 it’s often simpler than using lower levels of abstraction, but because higher levels of abstraction are usually 
 semantically closer to the original problem description, resulting in code which is easier to understand and 
 therefore easier to maintain. Also, high-abstraction classes also provide exception safety and prevent the 
 occurrence of memory leaks.
  
 C++
 ’s main tool for creating multi-threaded programs is the class std::thread, and some examples of its use 
 have already been shown at the beginning of this chapter.
  
 Characteristics of individual threads can be queried from the std::this_thread namespace. Also, 
 std::this_thread offers some control over the behavior of an individual thread.
  
 To synchronize access to shared data
  C++
  offers mutexes (implemented by the class std::mutex) and 
 condition variables (implemented by the class std::condition_variable).
  
 Members of these classes may throw system_error objects (cf. section
  10.9
 ) when encountering a low-level 
 error condition.
  
 20.2.1 The namespace std::this_thread
  
 The namespace std::this_thread contains functions that are uniquely associated with the cur-rently running 
 thread.
  
 Before using the namespace this_thread the <thread> header file must be included.
  
 Inside the std::this_thread namespace several free functions are defined, providing information about the 
 current thread or that can be used to control its behavior:",NA
20.3 ,NA,NA
Synchronization (mutexes),"The C++11 standard offers mutex classes to protect shared data.
  
 Before using mutexes the <mutex> header file must be included.
  
 One of the key characteristics of multi-threaded programs is that threads may share data. Functions 
 running as separate threads have access to all global data, and may also share the local data of their parent 
 threads. However, unless proper measures are taken, this may easily result in data corruption, as 
 illustrated by the following simulation of some steps that could be encountered in a multi-threaded 
 program:
  
 ---------------------------------------------------------------------------
  
 Time step:
  
 Thread 1:
  
 var
  
 Thread 2:
  
 description
  
 ---------------------------------------------------------------------------
  
 0
  
 starts
  
 5
  
 starts
  
 T1 active
  
 1
  
 2
  
 writes var
  
 T1 commences writing
  
 3
  
 stopped
  
 Context switch
  
 4
  
 T2 active
  
 5
  
 assigns 12
  
 10
  
 writes var
  
 T2 commences writing
  
 6
  
 assigns 10
  
 T2 writes 10
  
 7
  
 stopped
  
 Context switch
  
 8
  
 T1 writes 12
  
 9
  
 12
  
 ----------------------------------------------------------------------------
  
 In this example, threads 1 and 2 share variable var, initially having the value 5. At step 1 thread 1 starts, 
 and starts to write a value into var. However, it is interrupted by a context switch, and thread 2 is started 
 (step 4). Thread 2 also wants to write a value into var, and succeeds until time step 7, when another 
 context switch takes place. By now var is 10. However, thread 1 was also in the process of writing a value 
 into var, and it is given a chance to complete its work: it assigns 12 to var in time step 8. Once time step 9 is 
 reached, thread 2 proceeds on the (erroneous) assumption that var must be equal to 10. Clearly, from the 
 point of view of thread 2 its data have been corrupted.
  
 In this case data corruption was caused by multiple threads accessing the same data in an uncon-trolled 
 way. To prevent this from happening, access to shared data should be protected in such a way that only one 
 thread at a time may access the shared data.
  
 Mutexes are used to prevent the abovementioned kinds of problems by offering a guarantee that data are 
 only accessed by the thread that could lock the mutex that is used to synchronize access to those data.
  
 Exclusive data access completely depends on cooperation between the threads. If thread 1 uses mutexes, 
 but thread 2 doesn’t, then thread 2 may freely access the common data. Of course that’s bad practice, which 
 should be avoided.",NA
20.4 ,NA,NA
Locks and lock handling,"Locks are used to simplify the use of mutexes. Before locks can be used the <mutex> header file must be 
 included.
  
 Whenever threads share data, and at least one of the threads may change common data, mutexes should be 
 used to prevent threads from using the same data synchronously.
  
 Usually locks are released at the end of action blocks. This requires explicit calls to the mutexes’unlock 
 function, with introduces comparable problems as we’ve seen with the thread’s join mem-ber.
  
 To simplify locking and unlocking the C++11 standard provicdes two mutex wrapper classes:
  
 • std::lock_guard:
  
 objects of this class offer the basic unlock-guarantee: their destructors call the mem-ber 
 unlock of the mutexes they control;",NA
20.5 ,NA,NA
Event handling (condition variables),"This section introduces condition variables. 
  
 Condition variables allow programs to synchronize 
 threads using the states of data, rather than simply locking the access to data (which is realized using 
 mutexes).
  
 Before condition variables can be used the <condition_variable> header file must be included.
  
 To start our discussion, consider a classic producer-consumer scenario: the producer generates items 
 which are consumed by a consumer. The producer can only produce a certain number of items before its 
 storage capacity has filled up and the client cannot consume more items than the producer has produced.
  
 At some point the producer’s storage capacity has filled to the brim, and the producer has to wait until the 
 client has at least consumed some items, thereby creating space in the producer’s storage. Similarly, the 
 consumer cannot start consuming until the producer has at least produced some items.
  
 Implementing this scenario only using mutexes (data locking) is not an attractive option, as merely using 
 mutexes forces a program to implement the scenario using polling: processes must continu-ously 
 (re)acquire the mutex’s lock, determine whether they can perform some action, followed by the release of 
 the lock. Often there’s no action to perform, and the process is busy acquiring and releasing the mutex’s 
 lock. Polling forces threads to wait until they can lock the mutex, even though continuation might already 
 be possible. The polling interval could be reduced, but that too isn’t an attractive option, as that increases 
 the overhead associated with handling the mutexes (also called‘busy waiting’).
  
 Condition variables can be used to prevent polling. Threads can use condition variables to notify waiting 
 threads that there is something for them to do. This way threads can synchronize on data values (states).
  
 As data values may be modified by multiple threads, threads still need to use mutexes, but only for 
 controlling access to the data. In addition, condition variables allow threads to release ownership of 
 mutexes until a certain value has been obtained, until a preset amount of time has been passed, or until a 
 preset point in time has been reached.
  
 The prototypical setup of threads using condition variables looks like this:",NA
20.6 Atomic actions: mutexes not required,"Before using the facilities introduced in this section the <atomic> header file must be included.
  
 When data are shared among multiple threads, data corruption is usually prevented using mutexes.
  
 2
 A more elaborate example of the producer-consumer program is found in the yo/threading/examples/events.cc file in the
  C++
  
 Annotations’s source archive",NA
An example: threaded quicksort,CHAPTER 20. MULTI THREADING,NA
20.7,"The quicksort sorting algorithm (Hoare, 1962) is a well-known sorting algorithm. Given an array of n 
 elements, it works like this:
  
 • Pick an element from the array, and partition the array with respect to this element (call it the pivot 
 element). This leaves us with two (possibly empty) sub-arrays: one to the left of the pivot element, 
 and one to the right of the pivot element;
  
 • Recursively perform quicksort on the left-hand sub-array;
  
 • Recursively perform quicksort on the right-hand sub-array.
  
 To convert this algorithm to a multi-threaded algorithm appears to be be a simple task:
  
 void quicksort(Iterator begin, Iterator end) 
  
 { 
  
  
 if (end - begin < 2) 
  
 // less than 2 elements are left 
  
 return; 
  
 // 
 and we’re done
  
 Iter pivot = partition(begin, end); // determine an iterator pointing 
  
 // to the pivot element
  
 thread lhs(quicksort, begin, pivot);// start threads on the left-hand 
  
 // side sub-arrays
  
 thread rhs(quicksort, pivot + 1, end); lhs.join();
  
 // and on the right-hand side // sub-
 arrays
  
  
 rhs.join(); 
  
 // and we’re done }
  
 Unfortunately, this translation to a multi-threaded approach won’t work for reasonably large arrays 
 because of a phenomenon called overpopulation: more threads are started than the operating system is 
 prepared to give us. In those cases a Resource temporarily unavailable exception is thrown, and the 
 program ends.
  
 Overpopulation can be avoided by using a pool of workers, where each ‘worker’ is a thread, which in this 
 case is responsible for handling one (sub) array, but not for the nested calls. The pool of workers is 
 controlled by a scheduler, receiving the requests to sort sub-arrays, and passing these requests on to the 
 next available worker.
  
 The main data structure of the example program developed in this section is a queue of std::pairs 
 containing iterators of the array to be sorted (cf. Figure
  20.1
 , the sources of the program are found in the 
 annotation()’s yo/threading/examples/multisort directory). Two queues are being used: one queue is a 
 task-queue, receiving the iterators of sub-arrays to be partitioned. Instead of imme-diately launching new 
 threads (the lhs and rhs threads in the above example), the ranges to be sorted are pushed on the task-
 queue. The other queue is the work-queue: elements are moved from the task-queue to the work-queue, 
 where they will be processed by one of the worker threads.
  
 The program’s main function starts the workforce, reads the data, pushes the arrays begin and end 
 iterators on the task queue and then starts the scheduler. Once the scheduler ends the sorted array is 
 displayed:
  
 int main()",NA
task Q,651,NA
push,NA,NA
front,NA,NA
Scheduler,NA,NA
workQ,NA,NA
Activating,NA,NA
 workers,NA,NA
Partitioner,NA,NA
Workers,"Figure 20.1: Data structure used for multi-threading quicksort
  
 {
  
 workForce(); 
  
 readData(); 
  
 g_taskQ.push(
  
 // start the worker threads 
  
 // read the data into vector<int> g_data // prepare the 
 main task
  
  
  
 Pair(g_data.begin(), g_data.end()) 
  
 ); 
  
 scheduler(); 
  
 // sort g_data
  
 }
  
 display(); 
  
 // show the sorted elements
  
 The workforce consists of a bunch of detached threads. Each thread represents a worker, imple-mented in 
 the function void worker. Since the number of worker threads is fixed, overpopulation doesn’t occur. Once 
 the array has been sorted and the program stops these detached threads simply end:
  
 for (size_t idx = 0; idx != g_sizeofWorkforce; ++idx) 
  
 thread(worker).detach();
  
 The scheduler continues for as long as there are sub-arrays to sort. When this is the case the task queue’s 
 front element is moved to the work queue. This reduces the work queue’s size, and prepares an assignment 
 for the next available worker. The scheduler now waits until a worker is available. Once workers are 
 available one of them is informed of the waiting assignment, and the scheduler waits for the next task:
  
 void scheduler() 
  
 { 
  
  
 while (newTask())",NA
20.8 Shared States,"Just before a thread ends it may have produced some results. These results may have to to be 
 communicated to other threads. In multi threaded programs several classes and functions can be used that 
 produce shared states, making it easy to communicate results to other threads. Results could be values, 
 objects or exceptions.
  
 Objects that contain such shared states are called asynchronous return objects. However, due to the nature 
 of multi threading, a thread may request the results of an asynchronous return object before these result 
 are actually available. In those cases the requesting thread blocks, waiting for the results to become 
 available. Asynchronous return objects offer wait and get members which, respectively, wait until the 
 results have become available, and produce the asynchronous results once they are available. The phrase 
 that is used to indicate that the results are available is ‘the shared state has been made ready’.
  
 Shared states are made ready by asynchronous providers. Asynchronous providers are simply ob-jects or 
 functions providing results to shared states. Making a shared state ready means that an asynchronous 
 provider
  
 • marks its shared state as being ready, and",NA
20.9 ,NA,NA
Asynchronous return objects: std::future,"Condition variables allow threads to wait until data have obtained certain values. A thread may also have to 
 wait until a sub-thread has finished when calling a sub-thread’s join member.
  
 Waiting may be unwelcome: instead of just waiting our thread might also be doing something useful. It 
 might as well pick up the results produced by a sub-thread at some point in the future.
  
 In fact, exchanging data among threads always poses some difficulties, as it requires shared vari-ables, and 
 the use of locks and mutexes to prevent data corruption. Rather than waiting and using locks it would be 
 nice if some asynchronous task could be started, allowing the initiating thread (or even other threads) to 
 pick up the result at some point in the future, when the results are needed, without having to worry about 
 data locks or waiting times. For situations like these
  C++
  provides the class std::future.
  
 Before using the class std::future the <future> header file must be included.
  
 Objects of the class template std::future harbor the results produced by asynchronously executed tasks. 
 The class std::future is a class template. Its template type parameter specifies the type of the result 
 returned by the asynchronously executed task. This type may be void.
  
 On the other hand, the asynchronously executed task may throw an exception (ending the task). In that 
 case the future object catches the exception, and rethrows it once its return value (i.e., the value returned 
 by the asynchronously executed task) is requested.
  
 In this section the members of the class template future are described. Future objects are com-monly 
 initialized through anonymous future objects returned by the factory function std::async",NA
20.10,NA,NA
Shared,NA,NA
asynchronous,NA,NA
return,NA,NA
objects:,NA,NA
std::shared_future,"When a thread activates an asynchronous provider (e.g., a std::async) then the return value of the 
 asynchronously called function becomes available in its activating thread through a std::future
  
 object.
  
 The future object cannot be used by another thread.
  
 If this is required (e.g., see this
  
 chapter’s final section) the future object must be converted to a std::shared_future object.
  
 Before using the class std::shared_future the <future> header file must be included.
  
 Once a shared_future object is available, its get member (see below) can repeatedly be called to retrieve the 
 results of the original future object. This is illustrated by the next small example:
  
 1: int main() 
  
 2: { 
  
 3: std::promise<int> promise; 
  
 4: promise.set_value(15); 
  
 5: 
  
 6: 
  
 auto fut = promise.get_future(); 7: auto shared1 = fut.share(); 
  
 8: 
  
 9: std::cerr << ""Result: "" << shared1.get() << ’\n’; 10: 
  
  
 << ""Result: "" 
 << shared1.get() << ’\n’; 11: 
  
  
 << ""Valid: "" << fut.valid() << ’\n’; 12: 
  
 13: auto shared2 = fut.share(); 
  
 14: 
  
 15: std::cerr << ""Result: "" << shared2.get() << ’\n’; 16: 
   
 << ""Result: "" 
 << shared2.get() << ’\n’; 17: }
  
 In lines 9 and 10 the promise’s results are retrieved multiple times, but having obtained the shared_future 
 in line 7, the original future object no longer has an associated shared state. Therefore, when another 
 attempt is made (in line 13) to obtain the shared_future, a no associated state exception is thrown and the 
 program aborts.
  
 However, multiple copies of shared_future objects may co-exist. 
  
 When multiple copies of",NA
20.11 ,NA,NA
Starting a new thread: std::async,"In this section the function template std::async is covered. Async is used to start asynchronous tasks, 
 returning values (or void) to the calling thread, which is hard to realize merely using the std::thread class.
  
 Before using the function async the <future> header file must be included.
  
 When starting a thread using the facilities of the class std::thread the initiating thread at some point 
 commonly calls the thread’s join method. At that point the thread must have finished or execution blocks 
 until join returns. While this often is a sensible course of action, it may not",NA
20.12 ,NA,NA
Preparing a task for execution: std::packaged_task,"The class template std::packaged_task allows a program to ‘package’ a function or functor and pass the 
 package to a thread for further processing. The processing thread then calls the packaged function, passing 
 it its arguments (if any). After completing the function the packaged_task’s fu-ture is ready, allowing the 
 program to retrieve the results produced by the function. Thus, functions and the results of function calls 
 can be transferred between threads.
  
 Before using the class template packaged_task the <future> header file must be included.
  
 Before describing the class’s interface, let’s first look at an example to get an idea about how a 
 packaged_task can be used. Remember that the essence of packaged_task is that part of your program 
 prepares (packages) a task for another thread to complete, and that the program at some point needs the 
 result of the completed task.
  
 To clarify what’s happening here, let’s first look at a real-life analogon. Every now and then I make an 
 appointment with my garage to have my car serviced. The ‘package’ in this case are the details about my 
 car: its make and type determine the kind of actions my garage performs when servicing it. My neighbor 
 also has a car, which also needs to be serviced every now and then. This also results in a ‘package’ for the 
 garage. At the appropriate time me and my neighbor take our cars to the garage (i.e., the packages are 
 passed to another thread). The garage services the cars (i.e., calls the functions stored in the 
 packaged_tasks [note that the tasks differ, depending on the types of the cars]), and performs some actions 
 that are associated with it (e.g., registering that my or my neighbor’s car has been serviced, or order 
 replacement parts). In the meantime my neighbor and I perform our own businesses (the program 
 continues while a separate thread runs as well). But by the end of the day we’d like to use our cars again 
 (i.e., get the results associated with the packaged_task). A common result in this example is the garage’s 
 bill, which we have to pay (the program obtains the packaged_task’s results).
  
 Here is a little
  C++
  program illustrating the use of a packaged_task (assuming the required head-ers and 
 using namespace std have been specified):
  
 1: mutex carDetailsMutex; 
  
 2: condition_variable condition; 
  
 3: string carDetails; 
  
 4: packaged_task<size_t (std::string const &)> serviceTask; 
  
 5: 
  
 6: size_t volkswagen(string const &type) 
  
 7: { 
  
 8: 
  
 cout << ""performing maintenance by the book for a "" << type << ’\n’; 9: return type.size() * 75; 
  
 // the 
 size of the bill 
  
 10: } 
  
 11:",NA
20.13 ,NA,NA
The class ‘std::promise’,"In addition to std::package_task and std::async the class template std::promise can be used to obtain the 
 results from a separate thread.
  
 Before using the class template promise the <future> header file must be included.
  
 A promise is useful to obtain the results from another thread without further synchronization 
 requirements. Consider the following program:
  
 void compute(int *ret) 
  
 { 
  
  
 *ret = 9; 
  
 }
  
 int main() 
  
 { 
  
  
 int ret = 0; 
  
  
 std::thread(compute2, &ret).detach(); 
  
 cout << 
 ret << ’\n’; 
  
 }
  
 Chances are that this program shows the value 0: the cout statement is already executed before the 
 detached thread has had a chance to complete its work. In this example that problem can easily be solved 
 by using a non-detached thread, and using the thread’s join member, but when multiple threads are used 
 that requires named threads and as many join calls. Instead, using a promise might be preferred:
  
 1: void compute1(promise<int> &ref) 
  
 2: { 
  
 3: ref.set_value(9); 
  
 4: } 
  
 5: 
  
 6: int main() 
  
 7: { 
  
 8: std::promise<int> p; 
  
 9: std::thread(compute, ref(p)).detach();",NA
20.14 ,NA,NA
An example: multi-threaded compilations,"In this section another program is developed. This section’s example program illustrates the use of 
 packaged_tasks.
  
 Like the multi-threaded quicksort example a worker pool is used. However, in this example the workers in 
 fact do not know what their task is. In the current example the tasks happens to be identical, but diffent 
 tasks might as well have been used, without the need to update the workers.
  
 The program uses a class Task containing a command-specification (d_command, 
  
 and a 
 task specification (d_task) (cf. 
  
 Figure
  20.2
 , the sources of the program are found in the 
 yo/threading/examples/multicompile directory) of the
  C++
  Annotations).
  
 Like before main first starts its workforce as detached threads. Following this, the compilation jobs are 
 performed by yet another detached thread. Eventually, the results of the compilation jobs are handled by 
 results:
  
 int main() 
  
 {
  
 }
  
 workforce(); // start the worker threads
  
 thread(jobs).detach(); // start working on the jobs
  
 results(); // handle the results.
  
 The jobs-thread reads the names of the files to compile from the standard input stream, and passes them 
 on to dispatch for further handling by the workers. Lines 7 and 8 are executed at the end, and are a 
 safeguard against empty input. The safeguard is discussed below, at newResult’s de-scription.
  
 1: void jobs() 
  
 2: { 
  
 3: 
  
 string line; 
  
 4: 
  
 while (getline(cin, line) && dispatch(line)) 5: 
  
  
 ; 
  
 6: 
  
 7: 
  
 g_ready = true; 
  
 8: 
  
 g_resultCond.notify_one(); 
  
 9: }",NA
front,NA,NA
Task,CHAPTER 20. MULTI THREADING,NA
task Q,NA,NA
string d_command,NA,NA
packaged_task<...> d_task,NA,NA
push,NA,NA
Jobs/dispatch,NA,NA
resultQ,NA,NA
Activating,NA,NA
 workers,NA,NA
Results,NA,NA
done ,NA,NA
Workers,"Figure 20.2: Data structure used for the multi-threading compilation
  
 Next the dispatcher. It ignores empty lines. Also, if a compilation has failed by the time the dis-patcher is 
 called, processing stops (lines 6-7). Otherwise, the dispacher waits for an available worker, prepares a new 
 task, and notifies a worker to handle it:
  
 bool dispatch(string const &line) 
  
 { 
  
  
 if (line.empty()) 
  
  
 return true;
  
 if (g_done.load()) 
  
 return false;
  
  
 g_workforce.wait(); 
  
  
 newTask(line); 
  
  
 g_worker.notify_all(); 
  
  
 return true; 
  
 }
  
 The function newTask prepares the program for the next task. First a Task object is created. Task contains 
 the name of the file to compile, and a packaged_task. It encapsulates all activities that are associated with a 
 packaged_task. Here is its (in-class) definition:
  
 1: typedef packaged_task<Result (string const &fname)> PackagedTask; 2: 
  
 3: class Task",NA
Chapter 21,NA,NA
Function Templates,"C++
  supports syntactic constructs allowing programmers to define and use completely general (or 
 abstract) functions or classes, based on generic types and/or (possibly inferred) constant values. In the 
 chapters on abstract containers (chapter
  12
 ) and the STL (chapter
  18
 ) we’ve already used these constructs, 
 commonly known as the template mechanism.
  
 The template mechanism allows us to specify classes and algorithms, fairly independently of the actual 
 types for which the templates are eventually going to be used. Whenever the template is used, the compiler 
 generates code that is tailored to the particular data type(s) used with the template. This code is generated 
 at compile-time from the template’s definition. The piece of generated code is called an instantiation of the 
 template.
  
 In this chapter the syntactic peculiarities of templates are covered. The notions of template type parameter, 
 template non-type parameter, and function template are introduced and several examples of templates are 
 provided (both in this chapter and in chapter
  24
 ). Template classes are covered in chapter
  22
 .
  
 Templates already offered by the language include the abstract containers (cf. chapter
  12
 ); the string (cf. 
 chapter
  5
 ); streams (cf. chapter
  6
 ); and the generic algorithms (cf. chapter
  19
 ). So, templates play a central 
 role in present-day
  C++
 , and should not be considered an esoteric feature of the language.
  
 Templates should be approached somewhat similarly as generic algorithms: they’re a way of life; a 
 C++
  
 software engineer should actively look for opportunities to use them. Initially, templates may appear to be 
 rather complex and you might be tempted to turn your back on them. However, over time their strengths 
 and benefits are more and more appreciated. Eventually you’ll be able to rec-ognize opportunities for using 
 templates. That’s the time where your efforts should no longer focus on constructing ordinary functions 
 and classes (i.e., functions or classes that are not templates), but on constructing templates.
  
 This chapter starts by introducing function templates. The emphasis is on the required syntax. This chapter 
 lays the foundation upon which the other chapters about templates are built.",NA
21.1 Defining function templates,"A function template’s definition is very similar to the definition of a normal function. A function template 
 has a function head, a function body, a return type, possibly overloaded definitions, etc.. However, different 
 from ordinary functions, function templates always use one or more formal types:
  
 679",NA
21.2 ,NA,NA
Passing arguments by reference (reference wrappers),"Before using the reference wrappers discussed in this section the <functional> header file must be included.
  
 Situations exist where the compiler is unable to infer that a reference rather than a value is passed to a 
 function template. In the following example the function template outer receives int x as its argument and 
 the compiler dutifully infers that Type is int:
  
 template <typename Type> 
  
 void outer(Type t) 
  
 { 
  
  
 t.x(); 
  
 } 
  
 void useInt() 
  
 { 
  
  
 int arg; 
  
  
 outer(arg); 
  
 }",NA
21.3 Using Local and unnamed types as template arguments,"Usually, types have names. But an anonymous type may also be defined:",NA
21.4 ,NA,NA
Template parameter deduction,"In this section we’ll concentrate on the process by which the compiler deduces the actual types of the 
 template type parameters. These types are deduced when a function template is called using a process",NA
21.5 ,NA,NA
Declaring function templates,"Up to now, we’ve only defined function templates. 
  
 There are various consequences of including 
 function template definitions in multiple source files, none of them serious, but worth knowing.",NA
21.6 ,NA,NA
Instantiating function templates,"Different from an ordinary function that results in code once the compiler reads its definition a template is 
 not instantiated when its definition is read. A template is merely a recipe telling the",NA
21.7 Using explicit template types,"In the previous section we saw that the compiler may encounter ambiguities when attempting to 
 instantiate a template. In an example overloaded versions of a function (fun) existed, expecting different 
 types of arguments. The ambiguity resulted from the fact that both arguments could have been provided by 
 an instantiation of a function template. The intuitive way to solve such an ambi-guity is to use a static_cast. 
 But casts should be avoided wherever possible.
  
 With function templates static casts may indeed be avoided using explicit template type arguments. Explicit 
 template type arguments can be used to inform the compiler about the actual types it should use when 
 instantiating a template. To use explicit type arguments the function’s name is followed by an actual 
 template type argument list which may again be followed by the function’s argument list. The actual types 
 mentioned in the actual template argument list are used by the compiler to‘deduce’ what types to use when 
 instantiating the template. Here is the example from the previous section, now using explicit template type 
 arguments:",NA
21.8 ,NA,NA
Overloading function templates,"Let’s once again look at our add template. That template was designed to return the sum of two entities. If 
 we would want to compute the sum of three entities, we could write:
  
 int main() 
  
 { 
  
  
 add(add(2, 3), 4); 
  
 }
  
 This is an acceptable solution for the occasional situation. However, if we would have to add three entities 
 regularly, an overloaded version of the add function expecting three arguments might be a useful function 
 to have. There’s a simple solution to this problem: function templates may be overloaded.
  
 To define an overloaded function template, merely put multiple definitions of the template in its header file. 
 For the add function this would boil down to:
  
 template <typename Type> 
  
 Type add(Type const &lvalue, Type const &rvalue) 
  
 { 
  
  
 return lvalue + rvalue; 
  
 } 
  
 template <typename Type> 
  
 Type add(Type const &lvalue, Type const &mvalue, Type const &rvalue) { 
  
  
 return lvalue + mvalue + rvalue; 
  
 }
  
 The overloaded function does not have to be defined in terms of simple values. Like all overloaded 
 functions, a unique set of function parameters is enough to define an overloaded function template. For 
 example, here’s an overloaded version that can be used to compute the sum of the elements of a vector:
  
 template <typename Type> 
  
 Type add(std::vector<Type> const &vect)",NA
21.9 ,NA,NA
Specializing templates for deviating types,"The initial add template, defining two identically typed parameters works fine for all types sup-porting 
 operator+ and a copy constructor. However, these assumptions are not always met. For example, with char 
 *s, using operator+ or a ‘copy constructor’ does not make sense. The com-piler tries to instantiate the 
 function template, but compilation fails as operator+ is not defined for pointers.
  
 In such situations the compiler may be able to resolve the template type parameters but it (or we ...) may 
 then detect that the standard implementation is pointless or produces errors.
  
 To solve this problem a template explicit specialization may be defined. A template explicit spe-cialization 
 defines the function template for which a generic definition already exists using specific actual template 
 type parameters. As we saw in the previous section the compiler always prefers a more specialized 
 function over a less specialized one. So the template explicit specialization is selected whenever possible.
  
 A template explicit specialization offers a specialization for its template type parameter(s). The special type 
 is consistently subsituted for the template type parameter in the function template’s code. For example if 
 the explicitly specialized type is char const * then in the template definition
  
 template <typename Type>",NA
21.10 ,NA,NA
Static assertions,"The
  
 static_assert(constant expression, error message)
  
 utility is defined by the C++11 standard to allow assertions to be made within template definitions. Here 
 are two examples of its use:
  
 static_assert(BUFSIZE1 == BUFSIZE2, 
  
  
 ""BUFSIZE1 and BUFSIZE2 must be equal"");
  
 template <typename Type1, typename Type2> 
  
 void rawswap(Type1 &type1, Type2 &type2) 
  
 { 
  
  
 static_assert(sizeof(Type1) == sizeof(Type2), 
  
  
  
 ""rawswap: Type1 and Type2 must have equal sizes""); 
  
 // ...
  
 }
  
 The first example shows how to avoid yet another preprocessor directive (in this case the #error directive).
  
 The second example shows how static_assert can be used to ensure that a template operates under the 
 right condition(s).
  
 The string defined in static_assert’s second argument is displayed and compilation stops if the condition 
 specified in static_assert’s first argument is false.
  
 Like the #error preprocessor directive static_assert is a compile-time matter that doesn’t have any effect on 
 the run-time efficiency of the code in which it is used.",NA
21.11 ,NA,NA
Numeric limits,"The header file <climits> defines constants for various types, e.g., INT_MAX defines the maximum value that 
 can be stored in an int.
  
 The disadvantage of the limits defined in climits is that they are fixed limits. Let’s assume you write a 
 function template that receives an argument of a certain type. E.g,
  
 template<typename Type> 
  
 Type operation(Type &&type);
  
 Assume this function should return the largest negative value for Type if type is a negative value and the 
 largest positive value if type is a positive value. However, 0 should be returned if the type is not an integral 
 value.
  
 How to proceed?
  
 Since the constants in climits can only be used if the type to use is already known, the only approach seems 
 to be to create function template specializations for the various integral types, like:
  
 template<> 
  
 int operation<int>(int &&type) 
  
 { 
  
  
 return type < 0 ? INT_MIN : INT_MAX; 
  
 }
  
 The facilities provided by numeric_limits provide an alternative. To use these facilities the header file 
 <limits> header file must be included.
  
 The class template numeric_limits offers various members answering all kinds of questions that could be 
 asked of numeric types. Before introducing these members, let’s have a look at how we could implement 
 the operation function template as just one single function template:
  
 template<typename Type> 
  
 Type operation(Type &&type) 
  
 { 
  
  
 return 
  
  
  
 not numeric_limits<Type>::is_integer ? 0 : 
  
  
 type < 0 ? numeric_limits<Type>::min() : 
  
  
  
 numeric_limits<Type>::max(); }
  
 Now operation can be used for all the language’s primitive types.
  
 Here is an overview of the facilities offered by numeric_limits.
  
 Note that the member func-
  
 tions defined by numeric_limits return constexpr values. 
  
 A member ‘member’ defined by
  
 numeric_limits for type Type can be used as follows:
  
 numeric_limits<Type>::member // data members
  
 numeric_limits<Type>::member() // member functions
  
 All numeric_limits member functions return constexpr values.",NA
21.12 ,NA,NA
Polymorphous wrappers for function objects,"In
  C++
  pointers to (member) functions have fairly strict rvalues. They can only point to functions matching 
 their types. This becomes a problem when defining templates where the type of a function pointer may 
 depend on the template’s parameters.
  
 To solve this problem the C++11 standard introduces 
  
 polymorphous (function object) wrappers. 
 Polymorphous wrappers refer to function pointers, member functions or function objects, as long as their 
 parameters match in type and number.
  
 Before using polymorphic function wrappers the header file ‘<functional>’ must be included.
  
 Polymorphic function wrappers are made available through the std::function class template. Its template 
 argument is the prototype of the function to create a wrapper for. Here is an example of the definition of a 
 polymorphic function wrapper that can be used to point to a function expecting two int values and 
 returning an int:
  
 std::function<int (int, int)> ptr2fun;
  
 Here, the template’s parameter is int (int, int), indicating a function expecting two int argu-ments, and 
 returning and int. Other prototypes return other, matching, function wrappers.
  
 Such a function wrapper can now be used to point to any function the wrapper was created for. E.g., 
 ‘plus<int> add’ creates a functor defining an int operator()(int, int) function call member. As this qualifies 
 as a function having prototype int (int, int), our ptr2fun may point to add:
  
 ptr2fun = add;",NA
21.13 ,NA,NA
Compiling template definitions and instantiations,"Consider this definition of the add function template:
  
 template <typename Container, typename Type>
  
 Type add(Container const &container, Type init)
  
 {
  
 return std::accumulate(container.begin(), container.end(), init);
  
 }
  
 Here std::accumulate is called using container’s begin and end members.
  
 The calls container.begin() and container.end() are said to depend on template type pa-",NA
21.14 ,NA,NA
The function selection mechanism,"When the compiler encounters a function call, it must decide which function to call when overloaded 
 functions are available. Earlier we’ve encountered principles like ‘the most specific function is se-lected’. 
 This is a fairly intuitive description of the compiler’s function selection mechanism. In this section we’ll 
 have a closer look at this mechanism.
  
 Assume we ask the compiler to compile the following main function:
  
 int main() 
  
 { 
  
  
 process(3, 3); 
  
 }
  
 Furthermore assume that the compiler has encountered the following function declarations when it’s about 
 to compile main:
  
 template <typename T> 
  
 void process(T &t1, int i); 
  
 // 1
  
 template <typename T1, typename T2> 
  
 void process(T1 const &t1, T2 const &t2); 
  
 // 2
  
 template <typename T> 
  
 void process(T const &t, double d); 
  
 // 3",NA
21.15 ,NA,NA
Determining the template type parameters,"Having determined the set of candidate functions and from that set the set of viable functions the compiler 
 must now determine the actual types of the template type parameters.
  
 It may use any of the three standard template parameter transformation procedures (cf. section 
 21.4
 ) 
 when trying to match actual types to template type parameters. In this process it concludes that no type 
 can be determined for the T in function 1’s T &t1 parameter as the argument 3 is a constant int value. Thus 
 function 1 is removed from the list of viable functions. The compiler is",NA
Create viable,CHAPTER 21. FUNCTION TEMPLATES,NA
Create candidate,NA,NA
Determine,NA,NA
functions,NA,NA
functions,NA,NA
template,"(names match) 
 (#params match)",NA
parameters,NA,NA
Sort by,NA,NA
Type conversion,NA,NA
Sort by,NA,NA
direct-match count,NA,NA
ambiguity check,NA,NA
# ordinary params.,NA,NA
Sort by,NA,NA
function type,NA,NA
Select the ,NA,NA
topmost function,NA,NA
Report ,NA,NA
Re,NA,NA
Ambiguity,Figure 21.1: The function template selection mechanism,NA
21.16 ,NA,NA
SFINAE: Substitution Failure Is Not An Error,"Consider the following struct definition:
  
 struct Int 
  
 { 
  
  
 typedef int type; 
  
 };
  
 Although at this point it may seem strange to embed a typedef in a struct, in chapter
  23
  we’ll encounter 
 situations where this is actually very useful. It allows us to define a variable of a type that is required by the 
 template. E.g., (ignore the use of typename in the following function parameter list, but see section
  22.2.1
  
 for details):
  
 template <typename Type> 
  
 void func(typename Type::type value) 
  
 { 
  
 }
  
 To call func(10) Int has to be specified explicitly since there may be many structs that define type: the 
 compiler needs some assistance. The correct call is func<Int>(10). Now that it’s clear that Int is meant, and 
 the compiler correctly deduces that value is an int.
  
 But templates may be overloaded and our next definition is:
  
 template <typename Type> 
  
 void func(Type value) 
  
 {}
  
 Now, to make sure this function is used we specify func<int>(10) and again this compiles flaw-lessly.
  
 But as we’ve seen in the previous section when the compiler determines which template to instan-tiate it 
 creates a list of viable functions by matching the parameter types of available function pro-totypes with the 
 provided actual argument types. To do so it has to determine the types of the parameters and herein lies a 
 problem.
  
 When evaluating Type = int the compiler encounters the prototypes func(int::type) (first template 
 definition) and func(int) (second template definition). But there is no int::type, and so in a way this 
 generates an error. However, the error results from substituting the provided tem-plate type argument 
 into the various template definitions.
  
 A type-problem caused by substituting a type in a template definition is not considered an error, but 
 merely an indication that that particular type cannot be used in that particular template. The template is 
 therefore removed from the list of candidate functions.
  
 This principle is known as substitution failure is not an error (SFINAE) and it is often used by the compiler 
 to select not only a simple overloaded function (as shown here) but also to choose among available 
 template specializations (see also chapters
  22
  and
  23
 ).",NA
21.17 ,NA,NA
Summary of the template declaration syntax,"In this section the basic syntactic constructions for declaring templates are summarized. When defining 
 templates, the terminating semicolon should be replaced by a function body.
  
 Not every template declaration may be converted into a template definition. If a definition may be provided 
 it is explicitly mentioned.
  
 • A plain template declaration (a definition may be provided):
  
 template <typename Type1, typename Type2> 
  
 void function(Type1 const &t1, Type2 const &t2);
  
 • A template instantiation declaration (no definition may be provided):
  
 template 
  
 void function<int, double>(int const &t1, double const &t2);
  
 • A template using explicit types (no definition may be provided):
  
 void (*fp)(double, double) = function<double, double>; void (*fp)(int, int) = 
 function<int, int>;
  
 • A template explicit specialization (a definition may be provided):
  
 template <> 
  
 void function<char *, char *>(char *const &t1, char *const &t2);
  
 • A template declaration declaring friend function templates within class templates (covered in 
  
 section
  22.10
 , no definition may be provided):
  
 friend void function<Type1, Type2>(parameters);",NA
Chapter 22,NA,NA
Class Templates,"Templates can not only be constructed for functions but also for complete classes. Consider con-structing a 
 class template when a class should be able to handle different types of data. Class templates are frequently 
 used in
  C++
 : chapter
  12
  discusses data structures like vector, stack and queue, that are implemented as 
 class templates. With class templates, the algorithms and the data on which the algorithms operate are 
 completely separated from each other. To use a particular data structure in combination with a particular 
 data type only the data type needs to be specified when defining or declaring a class template object (as in 
 stack<int> iStack).
  
 In this chapter constructing and using class templates is discussed. In a sense, class templates compete 
 with object oriented programming (cf. chapter
  14
 ), that uses a mechanism resembling that of templates. 
 Polymorphism allows the programmer to postpone the implementation of algorithms by deriving classes 
 from base classes in which algorithms are only partially implemented. The actual definition and processing 
 of the data upon which the algorithms operate may be postponed until derived classes are defined. 
 Likewise, templates allow the programmer to postpone the specification of the data upon which the 
 algorithms operate. This is most clearly seen with abstract containers, which completely specify the 
 algorithms and at the same time leave the data type on which the algorithms operate completely 
 unspecified.
  
 There exists an intriguing correspondence between the kind of polymorphism we’ve encountered in 
 chapter
  14
  and certain uses of class templates. In their book
  C++ Coding Standards
  (Addison-Wesley, 
 2005) Sutter and Alexandrescu refer to static polymorphism and dynamic polymorphism. Dynamic 
 polymorphism is what we use when overriding virtual members. Using vtables the func-tion that is actually 
 called depends on the type of object a (base) class pointer points at. Static poly-morphism is encountered 
 in the context of templates, and is discussed and compared to dynamic polymorphism in section
  22.12
 .
  
 Generally, class templates are easier to use than polymorphism. 
  
 It is certainly easier to write 
 stack<int> istack to create a stack of ints than to derive a new class Istack: 
  
 public stack and to implement 
 all necessary member functions defining a similar stack of ints using object oriented programming. On the 
 other hand, for each different type for which an object of a class template is defined another, possibly 
 complete class must be reinstantiated. This is not re-quired in the context of object oriented programming 
 where derived classes use, rather than copy, the functions that are already available in their base classes 
 (but see also section
  22.11
 ).
  
 Previously
  
 we’ve
  
 already
  
 used
  
 class
  
 templates.
  
 Objects
  
 like
  
 vector<int> vi
  
 and
  
 vector<string> vs are commonly used. The data types for which these templates are defined and 
 instantiated are an inherent part of such container types. It is stressed that it is the combina-tion of a class 
 template type and its template parameter(s), rather than the mere class template’s
  
 721",NA
22.1 ,NA,NA
Defining class templates,"Having covered the construction of function templates, we’re now ready for the next step: con-structing 
 class templates. Many useful class templates already exist. Rather than illustrating the construction of a 
 class template by looking at an already existing class template the construction of another potentially 
 useful new class template will be undertaken.
  
 The new class implements a circular queue. A circular queue has a fixed number of max_size elements. New 
 elements are inserted at its back and only its head and tail elements can be accessed. Only the head element 
 can be removed from a circular queue. Once n elements have been appended the next element is inserted 
 again at the queue’s (physical) first position. The circular queue allows insertions until it holds max_size 
 elements. 
  
 As long as a circular queue contains at least one 
 element elements may be removed from it. Trying to remove an element from an empty circular queue or 
 to add another element to a full circular queue results in exceptions being thrown. In addition to other 
 constructors a circular queue must offer a constructor initializing its objects for max_size elements. This 
 constructor must make available the memory for the max_size elements but must not call those elements 
 default constructors (hinting at the use of the placement new operator). A circular queue should offer value 
 semantics as well as a move constructor.
  
 Please note that in the above description the actual data type that is used for the circular queue is nowhere 
 mentioned. This is a clear indication that our class could very well be defined as a class template. 
 Alternatively, the class could be defined for some concrete data type which is then abstracted when 
 converting the class to a class template.
  
 The actual construction of a class template is provided in the next section, where the class template CirQue 
 (circular queue) is developed.
  
 22.1.1 
  
 Constructing the circular queue: CirQue
  
 The construction of a class template is illustrated in this section. 
  
 Here, we’ll develop the class 
 template CirQue (circular queue). This class template has one template type parameter, Data, representing 
 the data type that is stored in the circular queue. The outline of the interface of this class template looks like 
 this:
  
 template<typename Data> 
  
 class CirQue 
  
 { 
  
  
 // member declarations 
  
 };
  
 A class template’s definition starts like a function template’s definition:",NA
22.2 Static data members,"When static members are defined in class templates, they are defined for every new type for which the 
 class template is instantiated. As they are static members, there will only be one member per type for 
 which the class template is instantiated. For example, in a class like:
  
 template <typename Type> 
  
 class TheClass 
  
 { 
  
  
 static int s_objectCounter; 
  
 };
  
 There will be one TheClass<Type>::objectCounter for each different Type specification. The following 
 object definitions result in the instantiation of just one single static variable, shared among the two objects:
  
 TheClass<int> theClassOne; 
  
 TheClass<int> theClassTwo;
  
 Mentioning static members in interfaces does not mean these members are actually defined. They are only 
 declared and must be defined separately. With static members of class templates this is no different. The 
 definitions of static members are usually provided immediately following (i.e., below) the template class 
 interface. For example, the static member s_objectCounter’s definition, positioned just below its class 
 interface, looks like this:
  
 template <typename Type> 
  
 int TheClass<Type>::s_objectCounter = 0;
  
 // definition, following // the 
 interface",NA
22.3 Specializing class templates for deviating types,"The class CirQue can be used for many different types. Their common characteristic is that they can simply 
 be pointed at by the class’s d_data member. But this is not always as simple as it looks. What if Data turns 
 out to be a vector<int>? For such data types the vanilla CirQue implemen-tation cannot be used and a 
 specialization could be considered. When considering a specialization one should also consider inheritance. 
 Often a class derived from the class template accepting the incompatible data structure as its argument but 
 otherwise equal to the original class template can easily be designed. The developmental advantage of 
 inheritance over specialization is clear: the inherited class inherits the members of its base class while the 
 specialization inherits nothing. All members defined by the original class template must be implemented 
 again by the class template’s specialization.
  
 The specialization considered here is a true specialization in that the data members and represen-tation 
 used by the specialization greatly differ from the original CirQue class template. Therefore all members 
 defined by the orginal class template must be modified to fit the specialization’s data organization.
  
 Like function template specializations class template specializations start with a template header that may 
 or may not have an empty template parameter list. If the template parameters are directly specialized by 
 the specialization it remains empty (e.g., CirQue’s template type parameter Data is specialized for char * 
 data). But the template parameter list may show typename Data when specializing for a vector<Data>, i.e., 
 a vector storing any type of data. This leads to the following principle:
  
 A template specialization is recognized by the template argument list following a function or 
 class template’s name and not by an empty template parameter list. Class template 
 specializations may have non-empty template parameter lists. If so, a partial class tem-plate 
 specialization is defined.
  
 A completely specialized class has the following characteristics:
  
 • The class template specialization must be provided after the generic class template definition. 
  
 As it 
 is a specialization the compiler must first have seen the original class template;
  
 • The completely specialized class template’s template parameter list is empty;",NA
22.4 Partial specializations,"In the previous section class template specializations were introduced. In this section we’ll introduce a 
 variant of this specialization, both in number and type of template parameters that are specialized. Partial 
 specializations may be defined for class templates having multiple template parameters. Function 
 templates cannot be partially specialized.
  
 With partial specializations a subset (any subset) of template type parameters are given specific values. It 
 is also possible to use a class template partial specialization when the intent is to specialize the class 
 template, but to parameterize the data type that is processed by the specialization.
  
 To start our discussion with an example of the latter use of a partial class template specializa-tion consider 
 the class CirQue<vector<int» developed in the previous section. When designing CirQue<vector<int» you 
 may have asked yourself how many specializations you’d have to imple-ment. One for vector<int>, one for 
 vector<string>, one for vector<double>? As long as the data types handled by the vector used by the class 
 CirQue<vector<...» behaves like an int (i.e., is a value-type of class) the answer is: zero. Instead of defining 
 full specializations for each new data type the data type itself can be parameterized, resulting in a partial 
 specialization:
  
 template <typename Data> 
  
 class CirQue<std::vector<Data>> 
  
 { 
  
  
 ...
  
 };
  
 The above class is a specialization as a template argument list is appended to the CirQue class name. But as 
 the class template itself has a non-empty template parameter list it is in fact recog-nized as a partial 
 specialization. There is one characteristic that distinguishes the implementation (subsequent to the class 
 template’s interface) of a class template member function of a partial spe-cialization from the 
 implementation of a member function of a full specialization. Implementations of partially specialized class 
 template member functions receive a template header. No template headers are used when implementing 
 fully specialized class template members.
  
 Implementing the partial specialization for CirQue is not difficult and is left as an exercise for the reader 
 (hints: simply change int into Data in the CirQue<vector<int» specialization of the previous section). 
 Remember to prefix the type iterator by typename (as in typedef typename DataVect::iterator iterator) (as 
 discussed in section
  22.2.1
 ).
  
 In the next subsections we’ll concentrate on specializing class template non-type template parame-ters. 
 These partial specializations are now illustrated using some simple concepts defined in matrix algebra, a 
 branch of linear algebra.",NA
22.5 ,NA,NA
Variadic templates,"Up to this point we’ve only encountered templates having a fixed number of template parameters. The 
 C++11 standard extends this with variadic templates.
  
 Variadic templates are defined for function templates and for class templates. Variadic templates allow us 
 to specify an arbitrary number of template arguments of any type.
  
 Variadic templates were added to the language to prevent us from having to define many overloaded 
 templates and to be able to create type safe variadic functions.
  
 Although
  C
  (and
  C++
 ) support variadic functions, their use has always been deprecated in
  C++ 
 as those 
 functions are notoriously type-unsafe. Variadic function templates can be used to process objects that until 
 now couldn’t be processed properly by
  C
 -style variadic functions.
  
 Template headers of variadic templates use the phrase typename ...Params (Params being a formal name). 
 A variadic class template Variadic could be declared as follows:
  
 template<typename ...Params> class Variadic;
  
 Assuming the class template’s definition is available then this template can be instantiated using any 
 number of template arguments. Example:",NA
22.6 Tuples,"The C++11 standard offers a generalized pair container: the tuple, covered in this section. Before tuples can 
 be used the header file <tuple> must be included.
  
 Whereas std::pair containers have limited functionality and only support two members, tuples have 
 slightly more functionality and may contain an unlimited number of different data types. In that respect a 
 tuple can be considered the ‘template’s answer to
  C
 ’s struct’.
  
 A tuple’s generic declaration (and definition) uses the variadic template notation:
  
 template <class ...Types> 
  
 class tuple;
  
 Here is an example of its use:
  
 typedef std::tuple<int, double &, std::string, char const *> tuple_idsc;
  
 double pi = 3.14; 
  
 tuple_idsc idsc(59, pi, ""hello"", ""fixed"");
  
 // access a field: 
  
 std::get<2>(idsc) = ""hello world"";
  
 The std::get<idx>(tupleObject) function template returns a reference to the idx
 th
 (zero based) field of the 
 tuple tupleObject. The index is specified as the function template’s non-type template argument.
  
 Tuples may be constructed without specifying initial values. Primitive types are initialized to zeroes; class 
 type fields are initialized by their default constructors. Be aware that in some situations the construction of 
 a tuple may succeed but its use may fail. Consider:
  
 tuple<int &> empty; 
  
 cout << get<0>(empty);
  
 Here the tuple empty cannot be used as its int & field is an undefined reference. However, empty’s 
 construction succeeds.",NA
22.7 ,NA,NA
Computing the return type of function objects,"As amply illustrated in chapter
  19
  function objects play an important role with generic algorithms. Like 
 generic algorithms themselves, function objects can be generically defined as members of class",NA
22.8 Instantiating class templates,"Class templates are instantiated when an object of a class template is defined. When a class tem-plate 
 object is defined or declared its template parameters must explicitly be specified.
  
 Template parameters are also specified when default template parameter values are specified albeit that in 
 that case the compiler provides the defaults (cf. section
  22.4
  where double is used as the default type to use 
 for the template’s DataType parameter). The actual values or types of template parameters are never 
 deduced from arguments as is done with function template parameters. So to define a Matrix of complex-
 valued elements, the following syntax is used:
  
 Matrix<3, 5, std::complex> complexMatrix;
  
 Since the class template Matrix uses a default data type a matrix of double-valued elements can be defined 
 like this:
  
 Matrix<3, 5> doubleMatrix;
  
 A class template object may be declared using the keyword extern. For example, to declare the matrix 
 complexMatrix use:
  
 extern Matrix<3, 5, std::complex> complexMatrix;
  
 A class template declaration suffices to compile return values or parameters that are of class tem-plate 
 types. Example: the following source file may be compiled, although the compiler hasn’t seen the definition 
 of the Matrix class template. Generic classes and (partial) specializations may all be declared. A function 
 expecting or returning a class template object, reference, or parameter auto-matically becomes a function 
 template itself. This is necessary to allow the compiler to tailor the function to the types of various actual 
 arguments that may be passed to the function:
  
 #include <cstddef>
  
 template <size_t Rows, size_t Columns, typename DataType = double> class Matrix;
  
 template <size_t Columns, typename DataType> class 
 Matrix<1, Columns, DataType>;
  
 Matrix<1, 12> *function(Matrix<2, 18, size_t> &mat);
  
 When class templates are used the compiler must first have seen their implementations. So, tem-plate 
 member functions must be known to the compiler when the template is instantiated. This does not mean 
 that all members of a template class are instantiated or must have been seen when a class template object 
 is defined. The compiler only instantiates those members that are actually used. This is illustrated by the 
 following simple class Demo that has two constructors and two members. When we use one constructor 
 and call one member in main note the sizes of the resulting object file and executable program. Next the 
 class definition is modified in that the unused constructor and member are commented out. Again we 
 compile and link the program. Now observe that these latter sizes are identical to the former sizes. There 
 are other ways to illustrate that only used members are instantiated. The nm program could be used. It 
 shows the symbolic contents of object files. Us-ing nm we’ll reach the same conclusion: only template 
 member functions that are actually used are instantiated. Here is the class template Demo that was used 
 for our little experiment. In main only",NA
22.9 ,NA,NA
Processing class templates and instantiations,"In section
  21.13
  the distinction between code depending on template parameters and code not de-pending 
 on template parameters was introduced. The same distinction also holds true when class templates are 
 defined and used.",NA
22.10 ,NA,NA
Declaring friends,"Friend functions are normally constructed as support (free) functions of a class that cannot be imple-
 mented and declared as class members. The insertion operator for output streams is a well known 
 example. Friend classes are most often seen in the context of nested classes. Here the inner class declares 
 the outer class as its friend (or the other way around). Again we see a support mechanism: the inner class 
 is constructed to support the outer class.
  
 Like ordinary classes, class templates may declare other functions and classes as their friends. Con-versely, 
 ordinary classes may declare template classes as their friends. Here too, the friend is con-structed as a 
 special function or class augmenting or supporting the functionality of the declaring class. Although the 
 friend keyword can be used by any type of class (ordinary or template) when using class templates the 
 following cases should be distinguished:
  
 • A class template may declare an ordinary function or class as its friend. This is a common 
  
 friend 
 declaration, such as the insertion operator for ostream objects.",NA
22.11 ,NA,NA
Class template derivation,"Class templates can be used for inheritance purposes as well. When a class template is used in class 
 derivation, the following situations should be distinguished:
  
 • An existing class template is used as base class when deriving a ordinary class. The derived class itself 
 will partially be a class template, but this is somewhat hidden from view when an object of the 
 derived class is defined.
  
 • An existing class template is used as the base class when deriving another class template. 
  
 Here 
 the class template characteristics remain clearly visible.",NA
22.12 ,NA,NA
Static Polymorphism,"Chapter
  14
  introduced polymorphism. Polymorphism allows us to use a base class’s interface to call 
 implementations which are defined in derived classes. Traditionally this involves defining Vtables for 
 polymorphic classes, containing pointers to functions that can be overridden in derived classes. Objects of 
 polymorphic classes feature hidden pointers, pointing to their class’s Vtables. This type of polymorphism is 
 called dynamic polymorphism, involving late binding as the function to call is determined run-time, rather 
 than compile-time.
  
 In many programs, however, using dynamic polymorphism isn’t really required. Usually the derived class 
 objects that are passed to functions expecting base class references are invariants: at fixed locations in 
 programs fixed class types are used to create objects. The polymorphic nature of these objects is used 
 inside the functions that receive these objects, expecting references to their base classes.
  
 The disadvantages of this scheme are that, firstly, inside the functions expecting references to poly-
 morphic base classes execution is somewhat slowed down precisely because of late-binding. Member 
 functions aren’t directly called, but are called indirectly via the object’s vpointer and their derived class’s 
 Vtable. Secondly, programs using dynamic polymorphism tend to become somewhat bloated compared to 
 programs using static binding. The code bloat is caused by the requirement to satisfy at link-time all the 
 references that are mentioned in all the object files comprising the final program. This requirement forces 
 the linker to link all the functions whose addresses are stored in the Vtables of all polymorphic classes, 
 even if these functions are never actually called.
  
 Static polymorphism allows us to avoid these disadvantages. It can be used instead of dynamic 
 polymorphism in cases where the abovementioned invariant holds. Static polymorphism, also called the 
 curiously recurring template pattern, is an example of template meta programming (see also chapter
  23
  for 
 additional examples of template meta programming).
  
 Whereas dynamic polymorphism is based on the concepts of vpointers, Vtables, and function overrid-ing, 
 static polymorphism capitalizes on the fact that function templates (c.q., member templates) are",NA
VehicleBase,NA,NA
Classes implementing ,NA,NA
the redefinable interface,NA,NA
CarBase: ,NA,NA
template <class Derived>,NA,NA
 VehicleBase ,NA,NA
class Vehicle: VehicleBase,NA,NA
TruckBase: ,NA,NA
"Car: CarBase, ",NA,NA
 CarBase Vehicle<Car>,NA,NA
Classes implementing ,NA,NA
the standard user interface,NA,NA
Truck: TruckBase,NA,NA
 Vehicle<Truck>,"Figure 22.1: Vehicle Static Polymorphic Class Design
  
 }
  
 When converting dynamically polymorphic classes to statically polymorphic classes we must realize that 
 polymorphic classes serve two functions: first, they define facilities (data members, member functions) 
 that are inherited by derived classes, and second polymorphic classes implement the redefinable interface 
 in a way that fits their purpose.
  
 With statically polymorphic classes it is important that these two aspects are implemented sepa-rately. As 
 we’ve seen in the previous section, a statically polymorphic derived class derives from the base class by 
 using its own class type as argument to the base class’s type parameter. This works fine if there’s only one 
 level of inheritance.
  
 With multiple levels of inheritance (e.g., Truck -> Car -> Vehicle) Truck’s inheritance spec-ification becomes 
 a problem. If it is inheriting from Car, then it implicitly derives from Vehicle<Car>, and thus Car’s vmass is 
 called by Vehicle::interface. 
  
 But Truck must inherit from Car to be able to use Car’s features. 
  
 Additionally inheriting Truck from Vehicle<Truck> isn’t an option 
 either, as this creates a class Truck which also inherits from Vehicle<Car> (through Truck’s Car base class).
  
 Generally it cannot be ruled out that classes use multiple levels of inheritance. When static poly-morphism 
 is used classes must carefully be designed. By separating the redefinable interface from the other elements 
 of the interface, the normal line of inheritance is used to make the protected and public interfaces of (direct 
 or indirect) base classes available to a derived class. The left-hand side of",NA
22.13 ,NA,NA
Class templates and nesting,"When a class is nested within a class template, it automatically becomes a class template itself. The nested 
 class may use the template parameters of the surrounding class, as shown by the follow-",NA
Constructing iterators,CHAPTER 22. CLASS TEMPLATES,NA
22.14,"In section
  18.2
  the iterators used with generic algorithms were introduced. We’ve seen that several types 
 of iterators were distinguished: InputIterators, ForwardIterators, OutputIterators, Bidirec-tionalIterators 
 and RandomAccessIterators.
  
 To ensure that an object of a class is interpreted as a particular type of iterator, the class must be de-rived 
 from the class std::iterator. Before a class can be derived from this class the <iterator> header file must be 
 included.
  
 In section
  18.2
  the characteristics of iterators were discussed. All iterators should support (using Iterator 
 as the generic name of the designed iterator class and Type to represent the (possibly const, in which case 
 the associated operator should be a const member as well) data type to which Iterator objects refer):
  
 • a prefix increment operator (Iterator &operator++());
  
 • a dereference operator (Type &operator*());
  
 • a ’pointer to’ operator (Type *operator->());
  
 • comparison
  
 operators
  
 testing
  
 the
  
 (in)equality
  
 of
  
 two
  
 iterator
  
 objects
  
 (bool
  
  
 operator==(Iterator const &other), &other)).
  
 bool operator!=(Iterator const
  
 When iterators are to be used in the context of generic algorithms they must meet additional re-
 quirements. This is caused by the fact that generic algorithms perform checks on the types of the iterators 
 they receive. Simple pointers are usually accepted, but if an iterator-object is used it must be able to specify 
 the kind of iterator it represents.
  
 When deriving a class from the class iterator the type of iterator is defined by the class template’s first 
 parameter, and the data type to which the iterator refers is defined by the class template’s second 
 parameter.
  
 The type of iterator that is implemented by the derived class is specified using a so-called itera-tor_tag, 
 provided as the first template argument of the class iterator. For the five basic iterator types, these tags 
 are:
  
 • std::input_iterator_tag. This tag defines an InputIterator. Iterators of this type allow reading 
 operations, iterating from the first to the last element of the series to which the iterator refers.
  
 The InputIterator dereference operator should be declared as follows:
  
 Type const &operator*() const;
  
 Except for the standard operators there are no further requirements for InputIterators.
  
 • std::output_iterator_tag. This tag defines an OutputIterator. Iterators of this type allow for assignment 
 operations, iterating from the first to the last element of the series to which the iterator refers.
  
 The OutputIterator dereference operator should allow assignment to the data its dereference 
 operator refers to. Therefore, the OutputIterator dereference operator should be declared as follows:
  
 Type &operator*();",NA
Chapter 23,NA,NA
Advanced Template Use,"The main purpose of templates is to provide a generic definition of classes and functions that may then be 
 tailored to specific types.
  
 But templates allow us to do more than that. If not for compiler implementation limitations, tem-plates 
 could be used to program, at compile-time, just about anything we use computers for. This remarkable feat, 
 offered by no other current-day computer language, stems from the fact that tem-plates allow us to do 
 three things at compile-time:
  
 • Templates allow us to do integer arithmetic (and to save computed values symbolically);
  
 • Templates allow us to make compile-time decisions;
  
 • Templates allow us to do things repeatedly.
  
 Of course, asking the compiler to compute, e.g., prime numbers, is one thing. But it’s a completely different 
 thing to do so in an award winning way. Don’t expect speed records to be broken when the compiler 
 performs complex calculations for us. But that’s all beside the point. In the end we can ask the compiler to 
 compute virtually anything using
  C++
 ’s template language, including prime numbers....
  
 In this chapter these remarkable features of templates are discussed. Following a short overview of 
 subtleties related to templates the main characteristics of template meta programming are intro-duced.
  
 In addition to template type and template non-type parameters there is a third kind of template parameter, 
 the template template parameter. This kind of template parameter is introduced next, laying the 
 groundwork for the discusion of trait classes and policy classes.
  
 This chapter ends with the discussion of several additional and interesting applications of templates: 
 adapting compiler error messages, conversions to class types and an elaborate example discussing 
 compile-time list processing.
  
 Much of the inspiration for this chapter came from two highly recommended books: Andrei Alexan-
 drescu’s 2001 book
  Modern C++ design
  (Addison-Wesley) and Nicolai Josutis and David Vandevo-orde’s 
 2003 book
  Templates
  (Addison-Wesley).
  
 815",NA
Subtleties,CHAPTER 23. ADVANCED TEMPLATE USE,NA
23.1,"In section
  22.2.1
  a special application of the keyword typename was discussed. There we learned that it is 
 not only used to define a name for a (complex) type, but also to distinguish types defined by class templates 
 from members defined by class templates. In this section two more applications of typename are 
 introduced:
  
 • In section
  23.1.1
  we apply typename to situations where types nested in templates are re-
  
 turned 
 from member functions of class templates;
  
 • in section
  23.1.2
  we cover the problem of how to refer to base class templates from derived class 
  
 templates.
  
 In addition to the special applications of typename section
  23.1.3
  introduces some new syntax that is 
 related to the extended use of the keyword typename: ::template, .template and ->template are used to 
 inform the compiler that a name used inside a template is itself a class template.
  
 23.1.1 
  
 Returning types nested under class templates
  
 In the following example a nested class, not depending on a template parameter, is defined inside a class 
 template. The class template member nested returns an object of this nested class. The example uses a 
 (deprecated) in-class member implementation. The reason for this shortly becomes clear.
  
 template <typename T> 
  
 class Outer 
  
 { 
  
  
 public: 
  
  
 class Nested 
  
  
 {}; 
  
  
 Nested nested() const 
  
  
 { 
  
  
  
  
 return Nested(); 
  
  
 } 
  
 };
  
 The above example compiles flawlessly. Inside the class Outer there is no ambiguity with respect to the 
 meaning of nested’s return type.
  
 However, following good practices inline and template members should be implemented below their class 
 interfaces (see section
  7.9.1
 ). So we remove the implementation from the interface and put it below the 
 interface:
  
 template <typename T> 
  
 class Outer 
  
 { 
  
  
 public: 
  
  
 class Nested 
  
  
 {};
  
 Nested nested() const;",NA
23.2 ,NA,NA
Template Meta Programming,"23.2.1 
  
 Values according to templates
  
 In template programming values are preferably represented by enum values. Enums are preferred over, 
 e.g., int const values since enums never require any linkage. They are pure symbolic values with no 
 memory representation whatsoever.
  
 Consider the situation where a programmer must use a cast, say a reinterpret_cast. A problem with a 
 reinterpret_cast is that it is the ultimate way to turn off all compiler checks. All bets are off, and we can 
 write extreme but absolutely pointless reinterpret_cast statements, like
  
 int intVar = 12; 
  
 ostream &ostr = reinterpret_cast<ostream &>(intVar);
  
 Wouldn’t it be nice if the compiler would warn us against such oddities by generating an error message?
  
 If that’s what we’d like the compiler to do, there must be some way to distinguish madness from weirdness. 
 Let’s assume we agree on the following distinction: reinterpret casts are never ac-ceptable if the target type 
 represents a larger type than the expression (source) type, since that would immediately result in 
 exceeding the amount of memory that’s actually available to the target type. For this reason it’s clearly silly 
 to reinterpret_cast<double *>(&intVar), but reinterpret_cast<char *>(&intVar) could be defensible.
  
 The intent is now to create a new kind of cast, let’s call it reinterpret_to_smaller_cast. It should only be 
 allowed to perform a reinterpret_to_smaller_cast if the target type occupies less memory than the source 
 type (note that this exactly the opposite reasoning as used by Alexan-drescu (2001), section 2.1).
  
 To start, we construct the following template:
  
 template<typename Target, typename Source> 
  
 Target &reinterpret_to_smaller_cast(Source &source) { 
  
  
 // determine whether Target is smaller than source 
  
 return 
 reinterpret_cast<Target &>(source); 
  
 }
  
 At the comment an enum-definition is inserted defining a symbol having a suggestive name. A compile-time 
 error results if the required condition is not met and the error message displays the name of the symbol. A 
 division by zero is clearly not allowed, and noting that a false value repre-sents a zero value, the condition 
 could be:
  
 1 / (sizeof(Target) <= sizeof(Source));
  
 The interesting part is that this condition doesn’t result in any code at all. The enum’s value is a plain value 
 that’s computed by the compiler while evaluating the expression:
  
 template<typename Target, typename Source> 
  
 Target &reinterpret_to_smaller_cast(Source &source) {",NA
23.3 ,NA,NA
User-defined literals,"In addition to the literal operators discussed in section
  11.12
  the C++11 standard also offers a func-tion 
 template literal operator, matching the prototype
  
 template <char ...Chars> 
  
 Type operator """" _identifier()
  
 This variadic non-type parameter function template defines no parameters, but merely a variadic non-type 
 parameter list.
  
 Its argument must be an int constant, as is also expected by the literal operator defining an unsigned long 
 long int parameter. All the characters of the int constant are passed as in-dividual char non-type template 
 arguments to the literal operator.
  
 For example, if _NM2km is a literal operator function template, it can be called as 80_NM2km. The function 
 template is then actually called as _NM2km<’8’, ’0’>(). If this function template merely uses template meta 
 programming techniques and only processes integral data then its actions can be performed completely at 
 compile-time. To illustrate this, let’s assume NM2km only processes and returns unsigned values.
  
 The function template _NM2km can forward its argument to a class template, defining an enum constant 
 value, and that performs the required computations. Here is the implementation of the variadic literal 
 operator function template _NM2km:
  
 template <char ... Chars> 
  
 size_t constexpr operator """" _NM2km() 
  
 { 
  
  
 return static_cast<size_t>( 
  
 // forward Chars to NM2km 
  
  
 NM2km<0, Chars ...>::value * 1.852); 
  
 }
  
 The class template NM2km defines three non-type parameters: acc accumulates the value, c is the first 
 character of the variadic non-type parameters, while ...Chars represents the remaining non-type 
 parameters, contained in a non-type parameter pack. Since c is, at each recursive call, the next character 
 from the original non-type parameter pack, the value so far multiplied by 10 plus the",NA
23.4 Template template parameters,"Consider the following situation: a software engineer is asked to design a storage class Storage. Data stored 
 in Storage objects may either make and store copies of the data or store the data as received. Storage 
 objects may also either use a vector or a linked list as its underlying storage medium. How should the 
 engineer tackle this request? Should four different Storage classes be designed?
  
 The engineer’s first reaction could be to develop an all-in Storage class. It could have two data members, a 
 list and a vector, and its constructor could be provided with maybe an enum value indicating whether the 
 data itself or new copies should be stored. The enum value can be used to initialize a series of pointers to 
 member functions performing the requested tasks (e.g., using a vector to store the data or a list to store 
 copies).
  
 Complex, but doable. Then the engineer is asked to modify the class: in the case of new copies a custom-
 made allocation scheme should be used rather than the standard new operator. He’s also asked to allow 
 the use of yet another type of container, in addition to the vector and the list that were already part of the 
 design. Maybe a deque would be preferred or maybe even a stack.
  
 It’s clear that the approach aiming at implementing all functionality and all possible combinations in one 
 class doesn’t scale. The class Storage soon becomes a monolithic giant which is hard to understand, 
 maintain, test, and deploy.
  
 One of the reasons why the big, all-encompassing class is hard to deploy and understand is that a well-
 designed class should enforce constraints: the design of the class should, by itself, disallow certain 
 operations, violations of which should be detected by the compiler, rather than by a program that might 
 terminate in a fatal error.
  
 Think about the above request. If the class offers both an interface to access the vector data storage and an 
 interface to access the list data storage, then it’s likely that the class offers an overloaded operator[] 
 member to access elements in the vector. This member, however, will be syntacti-cally present, but 
 semantically invalid when the list data storage is selected, which doesn’t support operator[].
  
 Sooner or later, users of the monolithic all-encompassing class Storage will fall into the trap of using 
 operator[] even though they’ve selected the list as the underlying data storage. The compiler won’t be able 
 to detect the error, which only appears once the program is running, confusing its users.
  
 The question remains: how should the engineer proceed, when confronted with the above questions? It’s 
 time to introduce policies.
  
 23.4.1 Policy classes - I
  
 A policy defines (in some contexts: prescribes) a particular kind of behavior. In
  C++
  a policy class defines a 
 certain part of the class interface. It may also define inner types, member functions, and data members.
  
 In the previous section the problem of creating a class that might use any of a series of allocation schemes 
 was introduced. These allocation schemes all depend on the actual data type to use, and so the ‘template 
 reflex’ should kick in.
  
 Allocation schemes should probably be defined as template classes, applying the appropriate alloca-tion 
 procedures to the data type at hand. When such allocation schemes are used by the familiar STL containers 
 (like std::vector, std::stack, etc.), then such home-made allocation schemes",NA
23.5 ,NA,NA
Template aliases,"In addition to function and class templates, C++11 also uses templates to define an alias for a set of types. 
 This is called a template alias. Template aliases can be specialized. The name of a template alias is a type 
 name.
  
 Template aliases can be used as arguments to template template parameters. This allows us to avoid the 
 ‘unexpected default parameters’ you may encounter when using template template parameters. E.g., 
 defining a template specifying a template <typename> class Container is fine, but it is impossible to specify 
 a container like vector or set as template template argument, as vector and set containers also define a 
 second template parameter, specifying their allocation policy.
  
 Template aliases are defined as using declarations, specifying an alias for an existing (maybe par-tially or 
 fully specialized) template type. In the following example Vector is defined as an alias for vector:
  
 template <typename Type>",NA
23.6 Trait classes,"// uses map<int, string>
  
 Scattered over the std namespace
  
 trait classes are found.
  
 E.g., most
  C++
  programmers have
  
 seen the compiler mentioning ‘std::char_traits<char>’ when performing an illegal operation on std::string 
 objects, as in std::string s(1).
  
 Trait classes are used to make compile-time decisions about types. Trait classes allow us to apply the 
 proper code to the proper data type, be it a pointer, a reference, or a plain value, all this maybe in 
 combination with const. The particular type of data to use can be inferred from the actual type that is 
 specified (or implied) when the template is used. This can be fully automated, not requiring the template 
 writer to make any decision.",NA
23.7 ,NA,NA
Using ‘noexcept’ when offering the ‘strong guarantee’,"When throwing exceptions while trying to achieve the strong guarantee a function’s actions are usually 
 split in two parts
  
 • First, usually on a temporary object, all operations that may throw are performed (which 
  
 doesn’t 
 affect the target object)
  
 • Then, the target object is modified using operations that offer the nothrow guarantee.
  
 The actions in the first step might be made move aware by using std::move (e.g., to assign the source’s 
 values to a (possibly temporary) destination). However, using std::move can easily affect the source (e.g., 
 when extending the source’s memory, moving the existing data to its new locations), which breaks the first 
 step’s assumption, as the target object is now modified.
  
 In this case (and generally) the move operation should not be allowed to throw exceptions. This, in turn, 
 implies that it is difficult to write code which must offer a non-throwing moving constructor, if it uses 
 (external) data types over which the moving constructor has no control. E.g.,
  
 template <typename Type> 
  
 class MyClass 
  
 { 
  
  
 Type d_f; 
  
  
 public: 
  
  
 MyClass() = default; 
  
  
 MyClass(MyClass &&tmp) 
  
  
 : 
  
  
  
  
 d_f(move(tmp.d_f)) 
  
  
 {} 
  
 };
  
 Here, MyClass’s author has no control over the design of Type. If Foreign merely has a (possibly throwing) 
 copy constructor, then the following code breaks the no-throw assumption underlying move constructors:
  
 MyClass<Foreign> s2(move(MyClass<Foreign>()));
  
 If templates are able to detect whether Type has non-throwing move constructors then their imple-
 mentations may be optimized by calling these move constructors (already modifying their targets in the 
 first part of code offering the strong guarantee) in situations where otherwise the non-modifying, but more 
 expensive copy constructor has to be used.
  
 The noexcept keyword was introduced to allow such templates to perform such optimizations. As with 
 throw lists, checking for noexcept is a run-time check, but the consequence of violating a noexept 
 declaration are more serious than violating a throw list: violating noexcept results in calling std::terminate, 
 terminating the program, possibly without unwinding the stack. In the",NA
23.8 ,NA,NA
More conversions to class types,"23.8.1 
  
 Types to types
  
 Although class templates may be partially specialized, function templates may not. At times this is 
 annoying. Assume a function template is available implementing a certain unary operator that could be 
 used with the transform generic algorithm (cf. section
  19.1.63
 ):
  
 template <typename Return, typename Argument> Return 
 chop(Argument const &arg) 
  
 { 
  
  
 return Return(arg); 
  
 }
  
 Furthermore assume that if Return is std::string then the above implementation should not be used. 
 Instead, with std::string a second argument 1 should always be provided. If Argument is a
  C++
  string, this 
 would allow us to, e.g., return a copy of arg from which its first character has been chopped off.
  
 Since chop is a function, it is not possible to define a partial specialization like this:
  
 template <typename Argument> 
  
 // This won’t compile! std::string 
 chop<std::string, Argument>(Argument const &arg) { 
  
  
 return string(arg, 1); 
  
 }
  
 Although a function template cannot be partially specialized it is possible to use overloading, defin-ing a 
 second, dummy, string parameter:
  
 template <typename Argument> 
  
 std::string chop(Argument const &arg, std::string) { 
  
  
 return string(arg, 1); 
  
 }
  
 Now it is possible to distinguish the two cases, but at the expense of a more complex function call. 
 Moreover, in code this function may require the use of the bind2nd binder (cf. section
  18.1.4
 ) to",NA
23.9 Template TypeList processing,"This section serves two purposes. 
  
 It illustrates capabilities of the various template meta-
 programming techniques, which can be used as a source of inspiration when developing your own 
 templates; and it offers a concrete example, illustrating some of the power offered by these tech-niques.
  
 This section itself was inspired by Andrei Alexandrescu’s (2001) book
  Modern C++ design
 . It diverts from 
 Alexandrescu’s book in its use of variadic templates which were not yet available when he wrote his book. 
 Even so, the algorithms used by Alexandrescu are still useful when using variadic templates.
  
 The C++11 standard offers the tuple to store and retrieve values of multiple types. Here the focus is merely 
 on processing types. A simple struct TypeList is going to be used as our working horse for the upcoming 
 subsections. Here is its definition:
  
 template <typename ...Types>",NA
23.10 ,NA,NA
Using a TypeList,"In the previous sections the definition and some of the features of typelists were discussed. Most 
 C++
  
 programmers consider typelists both exciting and an intellectual challenge, honing their skills in the area of 
 recursive programming.",NA
Chapter 24,NA,NA
Concrete Examples,"In this chapter concrete examples of
  C++
  programs, classes and templates are presented. Topics covered 
 by the
  C++
  Annotations such as virtual functions, static members, etc. are illustrated in this chapter. The 
 examples roughly follow the organization of earlier chapters.
  
 As an additional topic, not just providing examples of
  C++
  the subjects of scanner and parser genera-tors 
 are covered. We show how these tools may be used in
  C++
  programs. These additional examples assume a 
 certain familiarity with the concepts underlying these tools, like grammars, parse-trees and parse-tree 
 decoration. Once the input for a program exceeds a certain level of complexity, it’s attractive to use 
 scanner- and parser-generators to create the code doing the actual input processing.
  
 One of the examples in this chapter describes the usage of these tools in a
  C++
  environment.",NA
24.1 Using file descriptors with ‘streambuf’ classes,"24.1.1 Classes for output operations
  
 Reading and writing from and to file descriptors are not part of the
  C++
  standard. But on most operating 
 systems file descriptors are available and can be considered a device. It seems natural to use the class 
 std::streambuf as the starting point for constructing classes interfacing such file descriptor devices.
  
 Below we’ll construct classes that can be used to write to a device given its file descriptor. The devices may 
 be files, but they could also be pipes or sockets. Section
  24.1.2
  covers reading from such devices; section
  
 24.2.3
  reconsiders redirection, discussed earlier in section
  6.6.1
 .
  
 Using the streambuf class as a base class it is relatively easy to design classes for output operations. 
  
 The 
 only member function that must be overridden is the (virtual) member int streambuf::overflow(int c). This 
 member’s responsibility is to write characters to the device. If fd is an output file descriptor and if output 
 should not be buffered then the member overflow() can simply be implemented as:
  
 class UnbufferedFD: public std::streambuf { 
  
  
 public: 
  
  
  
 virtual int overflow(int c); 
  
  
  
 ...
  
 877",NA
24.2 The ‘fork’ system call,"From the
  C
  programming language the fork system call is well known. When a program needs to start a 
 new process, system can be used. The function system requires the program to wait for the child process to 
 terminate. The more general way to spawn subprocesses is to use fork.
  
 In this section we investigate how
  C++
  can be used to wrap classes around a complex system call like fork. 
 Much of what follows in this section directly applies to the Unix operating system, and the discussion 
 therefore focuses on that operating system. Other systems usually provide comparable facilities. What 
 follows is closely related to the Template Design Pattern (cf. Gamma et al. (1995) Design Patterns, Addison-
 Wesley)
  
 When fork is called, the current program is duplicated in memory, thus creating a new process. Fol-lowing 
 this duplication both processes continue their execution just below the fork system call. The two processes 
 may inspect fork’s return value: the return value in the original process (called the parent process) differs 
 from the return value in the newly created process (called the child process):",NA
24.3 Function objects performing bitwise operations,"In section
  18.1
  several predefined function objects were introduced. Predefined function objects 
 performing arithmetic operations, relational operations, and logical operations exist, corresponding to a 
 multitude of binary- and unary operators.
  
 Some operators appear to be missing: there appear to be no predefined function objects correspond-ing to 
 bitwise operations. However, their construction is, given the available predefined function objects, not 
 difficult. The following examples show a class template implementing a function object calling the bitwise 
 and (operator&), and a template class implementing a function object calling the unary not (operator~). It 
 is left to the reader to construct similar function objects for other operators.
  
 Here is the implementation of a function object calling the bitwise operator&:
  
 #include <functional>
  
 template <typename _Tp> 
  
 struct bitAnd: public std::binary_function<_Tp, _Tp, _Tp> { 
  
  
 _Tp operator()(_Tp const &__x, _Tp const &__y) const 
  
 { 
  
  
  
 return __x & __y; 
  
  
 } 
  
 };
  
 Here is the implementation of a function object calling operator~():
  
 #include <functional>
  
 template <typename _Tp> 
  
 struct bit_not: public std::unary_function<_Tp, _Tp> { 
  
  
 _Tp operator()(_Tp const &__x) const 
  
  
 { 
  
  
  
 return ~__x; 
  
  
 } 
  
 };
  
 These
  
 and
  
 other
  
 missing
  
 predefined
  
 function
  
 objects
  
 are
  
 also
  
 implemented
  
 in
  
 the
  
 file
  
 bitfunctional, which is found in the cplusplus.yo.zip archive. These classes are derived from existing class 
 templates (e.g., std::binary_function and std::unary_function). These base classes define several types 
 which are expected (used) by various generic algorithms as de-fined in the STL (cf. chapter
  19
 ), thus 
 following the advice offered in, e.g., the
  C++
  header file bits/stl_function.h:",NA
24.4 ,NA,NA
Adding binary operators to classes,"As we’ve seen in section
  11.6
  binary operators expecting const & arguments can be implemented in move-
 aware classes using a move-aware binary operator, using a rvalue reference for its first argument. This 
 latter function can in turn be implemented using the binary assignment member.
  
 The following examples illustrated this approach for a fictitious class Binary:
  
 class Binary 
  
 { 
  
  
 public: 
  
  
 Binary(); 
  
  
 Binary(int value); 
  
  
  
  
 // copy and move constructors are available by default, or 
  
  
  
 // they can be explicitly declared and implemented.
  
 Binary &operator+=(Binary const &other); 
  
 // see the text",NA
24.5 Range-based for-loops and pointer-ranges,"The standard range-based for-loop requires for its range-specificiation an array, an initializer list, or an 
 iterator range as offered by, e.g., containers (through their begin and end members).
  
 Ranges defined by a pointer pair or by a subrange defined by iterator expressions cannot currently be used 
 in combination with range-based for-loops.
  
 The Ranger class template developed in this section defines ranges that can be used with range-based for-
 loops. Ranger extends the applicability of range-based for-loops by turning pointer pairs„an initial pointer 
 or iterator and a pointer count, or a pair of iterators into a range that can be used by range-based for-loops. 
 The Ranger class template can also be used to process a pair of reverse iterators, normally not supported 
 by range-based for-loops.
  
 The Ranger class template requires but one template type parameter: Iterator, representing an iterator or 
 pointer type reaching the data when dereferenced. In practical applications users don’t have to specify 
 Ranger’s template type. The function template ranger deduces the required Iterator type and returns the 
 appropriate Ranger object.
  
 The ranger function template can be used in various ways:
  
 • Ranger<Iterator> ranger(Iterator const &begin, Iterator const &end) 
  
 this 
  
 function template returns a Ranger object for the (sub)range defined by two (reverse) iterators.
  
 Its definition is:
  
 template <typename Iter> 
  
 Ranger<Iter> ranger(Iter &&begin, Iter &&end) { 
  
 return Ranger<Iter>(begin, end); 
  
 }
  
 • Ranger<Iterator> ranger(Iterator const &begin, size_t count)
  
 this
  
 function
  
 template returns a Ranger object for the (sub)range defined by the (reverse) iterator range begin and 
 begin + count. Its definition is:
  
 template <typename Data> 
  
 Ranger<Data *> ranger(Data *begin, Data *end) { 
  
 return Ranger<Data *>(begin, end); 
  
 }",NA
24.6 Distinguishing lvalues from rvalues with operator[](),"A problem with operator[] is that it can’t distinguish between its use as an lvalue and as an rvalue. It is a 
 familiar misconception to think that
  
 Type const &operator[](size_t index) const
  
 is used as rvalue (as the object isn’t modified), and that
  
 Type &operator[](size_t index)
  
 is used as lvalue (as the returned value can be modified).
  
 The compiler, however, distinguishes between the two operators only by the const-status of the object for 
 which operator[] is called. With const objects the former operator is called, with non-const objects the 
 latter is always used. It is always used, irrespective of it being used as lvalue or rvalue.
  
 Being able to distinguish between lvalues and rvalues can be very useful. Consider the situation where a 
 class supporting operator[] stores data of a type that is very hard to copy. With data like that reference 
 counting (e.g., using shared_ptrs) is probably used to prevent needless copying.
  
 As long as operator[] is used as rvalue there’s no need to copy the data, but the information must be copied 
 if it is used as lvalue.
  
 The Proxy Design Pattern (cf. Gamma et al. (1995)) can be used to distinguish between lvalues and rvalues. 
 With the Proxy Design Pattern an object of another class (the Proxy class) is used to act as a stand in for the 
 ‘real thing’. The proxy class offers functionality that cannot be offered by the data themselves, like 
 distinguishing between its use as lvalue or rvalue. A proxy class can be used in many situations where 
 access to the real data cannot or should not be directly provided. In this regard iterator types are examples 
 of proxy classes as they create a layer between the real data and the software using the data. Proxy classes 
 could also dereference pointers in a class storing its data by pointers.",NA
24.7 ,NA,NA
Implementing a ‘reverse_iterator’,"In section
  22.14.1
  the construction of iterators and reverse iteraters was discussed. In that section the 
 iterator was constructed as an inner class in a class derived from a vector of pointers to strings.
  
 An object of this nested iterator class handles the dereferencing of the pointers stored in the vector. This 
 allowed us to sort the strings pointed to by the vector’s elements rather than the pointers.
  
 A drawback of this is that the class implementing the iterator is closely tied to the derived class as the 
 iterator class was implemented as a nested class. What if we would like to provide any class derived from a 
 container class storing pointers with an iterator handling pointer-dereferencing?
  
 In this section a variant of the earlier (nested class) approach is discussed. Here the iterator class is defined 
 as a class template, not only parameterizing the data type to which the container’s ele-ments point but also 
 the container’s iterator type itself. Once again, we concentrate on developing a RandomIterator as it is the 
 most complex iterator type.
  
 Our class is named RandomPtrIterator, indicating that it is a random iterator operating on pointer values. 
 The class template defines three template type parameters:
  
 • The first 
  
 parameter 
  
 specifies 
  
 the 
  
 derived 
  
 class 
  
 type 
   
 (Class). 
  
 Like before, 
  
 RandomPtrIterator’s constructor is private. 
  
 Therefore friend declarations are needed 
  
 to 
 allow client classes to construct RandomPtrIterators. 
  
 However, a friend class 
  
 Class cannot 
 be used as template parameter types cannot be used in friend class ... 
  
 declarations. But this is a 
 minor problem as not every member of the client class needs to 
  
 construct iterators. In fact, only 
 Class’s begin and end members must construct iterators. 
  
 Using the template’s first parameter, friend 
 declarations can be specified for the client’s begin 
  
 and end members.
  
 • The second template parameter parameterizes the container’s iterator type (BaseIterator);
  
 • The third template parameter indicates the data type to which the pointers point (Type).
  
 RandomPtrIterator has one private data member, a BaseIterator. Here is the class interface and the 
 constructor’s implementation:
  
 #include <iterator>
  
 template <typename Class, typename BaseIterator, typename Type> 
  
 class RandomPtrIterator: 
  
  
  
 public std::iterator<std::random_access_iterator_tag, Type> { 
  
  
 friend RandomPtrIterator<Class, BaseIterator, Type> Class::begin(); 
  
 friend 
 RandomPtrIterator<Class, BaseIterator, Type> Class::end();
  
 BaseIterator d_current;
  
 RandomPtrIterator(BaseIterator const &current);
  
 public: 
  
 bool operator!=(RandomPtrIterator const &other) const; int operator-
 (RandomPtrIterator const &rhs) const; RandomPtrIterator operator+(int 
 step) const; 
  
 Type &operator*() const; 
  
 bool operator<(RandomPtrIterator const &other) const;",NA
24.8 Using ‘bisonc++’ and ‘flexc++’,"The example discussed below digs into the peculiarities of using parser- and scanner generators generating
  
 C++
  sources. Once the input for a program exceeds a certain level of complexity, it becomes attractive to 
 use scanner- and parser-generators generating the code which does the actual input recognition.
  
 The examples in this and subsequent sections assume that the reader knows how to use the scanner 
 generator flex and the parser generator bison. Both bison and flex are well documented else-where. The 
 original predecessors of bison and flex, called yacc and lex are described in several books, e.g. in O’Reilly’s 
 book ‘lex & yacc’
 3
 .
  
 Scanner-
  
 and
  
 parser
  
 generators
  
 are
  
 also
  
 available
  
 as
  
 free
  
 software.
  
 Both
  
 bison
  
 and
  
 flex
  
 are
  
 usually
  
 part
  
 of
  
 software
  
 distributions
  
 or
  
 they
  
 can
  
 be
  
 obtained
  
 from
  
 ftp://prep.ai.mit.edu/pub/non-gnu. Flex creates a C++ class when %option c++ is speci-fied.
  
 For parser generators the program bison is available. 
  
 In the early 90’s Alain Coetmeur 
 (coetmeur@icdc.fr
 4
 ) created a
  C++
  variant (bison++) creating a parser class. 
  
 Although the 
 bison++ program produces code that can be used in
  C++
  programs it also shows many characteris-tics that 
 are more suggestive of a
  C
  context than a
  C++
  context. In January 2005 I rewrote parts of Alain’s bison++ 
 program, resulting in the original version of the program
  bisonc++
 . Then, in May 2005 a complete rewrite 
 of the bisonc++ parser generator was completed (version number 0.98). Current versions of bisonc++ can 
 be downloaded from http://bisoncpp.sourceforge.net/, where it is available as source archive and as 
 binary (i386) Debian
 5
 package (including bisonc++’s documentation).
  
 3
 http://www.oreilly.com/catalog/lex 
  
 4
 mailto:coetmeur@icdc.fr 
  
 5
 http://www.debian.org",NA
Index,"!=,
  294
  
 –std=c++11,
  8
 ,
  9
 ->,
  
 434
  
 ->*,
  434
  
 -O0,
  166
  
 -lpthread,
  610
  
 -pthread,
  610 
  
 .*,
  434 
  
 ...,
  753 
  
 .h,
  19 
  
 .ih extension,
  159
  
 %type,
  941 
  
 %union,
  940 
  
 &,
  38 
  
 __cplusplus,
  17
 ,
  18 
  
 �,
  51 
  
 0-pointer,
  176 
  
 0B,
  48 
  
 0b,
  48
 ,
  289 
  
 0x,
  48
  
 0,
  48
  
  
 .template,
  821 
  
 //,
  13 
  
 ::,
  25
 ,
  276 
  
 ::template,
  821 
  
 <,
  294 
  
 <=,
  294 
  
 = 0,
  388 
  
 = default,
  144
 ,
  212 
  
 = delete,
  144 
  
 ==,
  294 
  
 >,
  294 
  
 >=,
  294 
  
 >>,
  261 
  
 >>: with templates,
  318 
  
 [begin, end),
  300 
  
 [first, beyond),
  302
 ,
  306
 ,
  316
 ,
  330 
 [first, last),
  526 
  
 [left, right),
  464 
  
 #define __cplusplus,
  17 
  
 #error,
  708 
  
 #ifdef,
  19 
  
 #ifndef,
  19 
  
 #include,
  935
  
 abort exception,
  249 
  
 abs,
  347 
  
 absolute position,
  409 
  
 abstract base class,
  422
 ,
  896 
 abstract classes,
  387 
  
 access,
  50 
  
 access files,
  103
 ,
  110 
  
 access promotion,
  362 
  
 access rights,
  124 
  
 accessor,
  124
 ,
  127
 ,
  262 
  
 accumulate,
  527 
  
 actions,
  938 
  
 adaptor: inserter,
  467 
  
 adaptor: object to iterator,
  463 
 adaptor: required typedefs,
  467 
 add_const,
  848 
  
 add_cv,
  848 
  
 add_lvalue_reference,
  848 
  
 add_pointer,
  848 
  
 add_rvalue_reference,
  848 
  
 add_volatile,
  848 
  
 addExceptFd,
  908 
  
 addReadFd,
  908
  
 %baseclass-preinclude,
  940 
  
 address,
  297
  
 %debug,
  935 
  
 address of objects,
  194
  
 %filenames,
  936
 ,
  940 
  
 address-of operator,
  38
  
 %left,
  941 
  
 addWriteFd,
  908
  
 %nonassoc,
  941 
  
 adjacent_difference,
  527
  
 %option c++,
  933 
  
 adjacent_find,
  528
  
 %prec,
  941 
  
 adjustfield,
  96
  
 %right,
  941 
  
 Aho, A.V.,
  304
  
 %scanner,
  940 
  
 Alexandrescu, A.,
  721
 ,
  815
 ,
  822
 ,
  859
 ,
  869
 ,
  870
  
 %stype,
  940 
  
 Alexandrescu, H.,
  856
  
 %token,
  941 
  
 algorithm: header file,
  525
  
 957",NA
