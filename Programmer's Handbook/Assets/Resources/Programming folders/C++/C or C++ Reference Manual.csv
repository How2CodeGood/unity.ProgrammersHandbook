Larger Text,Smaller Text,Symbol
C/C++ Reference Manual,"0890497-030 
  
 July 2001",NA
Preface,"Scope of Manual
  
 This manual is a reference document on Concurrent C/C++, two general-purpose pro-
 gramming languages.
  
 Information in this manual applies to the platforms described in the latest Concurrent 
 Computer Corporation product catalogs.
  
 System manual page (man page) descriptions of programs, system calls and subroutines can 
 be found online.
  
 Syntax Notation
  
 The following notation is used throughout this guide:
  
 italic
  
 list bold
  
 list
  
 []
  
 {}
  
 ...
  
 ::=
  
 Books, reference cards, and items that the user must specify appear in
  
 italic
  type. Special terms may also appear in
  italic
 .
  
 User input appears in
  list bold
  type and must be entered exactly 
 as shown. Names of directories, files, commands, options and man 
 page references also appear in
  list bold
  type.
  
 Operating system and program output such as prompts and messages 
 and listings of files and programs appears in
  list
  type.
  
 Brackets enclose command options and arguments that are optional. 
 You do not type the brackets if you choose to specify such option or 
 arguments.
  
 Braces enclose mutually exclusive choices separated by the pipe (|) 
 character, where one choice must be selected. You do not type the 
 braces with the choice.
  
 An ellipsis follows an item that can be repeated.
  
 This symbol means “is defined as” in Backus-Naur Form (BNF).
  
 i",NA
Contents,"Chapter 1
  
 Compilation
  
 1-2
  
 Compilation Phases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Chapter 2
  
 Compiler Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-5
  
 Program Development Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-5
  
 Multiple Release Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-6
  
 Using Concurrent C/C++ with the PLDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-6
  
 PATH Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-6
  
 Include Files and Libraries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-7
  
 OS Versions and Target Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-8
  
 Shared vs. Static Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-9
  
 Makefile Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-11
  
 Explicit Modification Using ec/ec++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-11
  
 Use of /usr/ccs/crossbin in PATH Environment Variable . . . . . . . . . . . . . .
  
 1-11
  
 Use of CC Environment or Make Variables . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-11
  
 Invoking the Compiler. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-13
  
 Command Line Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-14
  
 Compilation Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-14
  
 Preprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-14
  
 Key Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-16
  
 C++ Specific Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-18
  
 Error Messages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-19
  
 Other. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-20
  
 Language Dialect. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-24
  
 Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-34
  
 Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-41
  
 Using the Program Development Environment
  
 Hello World - An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-1
  
 Creating an environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-1
  
 Introducing units. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-2
  
 Defining a partition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-3
  
 Building a partition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-4
  
 Success!!! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-4
  
 Let’s look around.... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-4
  
 Listing the contents of your environment . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-4
  
 Viewing the source for a particular unit . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-5
  
 Looking at the Environment Search Path . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-6
  
 What are my options? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-6
  
 Hello Galaxy - The Example Continues.... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-11
  
 Modifying an existing unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-11
  
 Building a unit with references outside the local environment . . . . . . . . . . . . .
  
 2-12
  
 Adding an environment to the Environment Search Path . . . . . . . . . . . . . . . . .
  
 2-13
  
 Making contact!!! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-13
  
 Who resides here now?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-13
  
 iii",NA
1 ,NA,NA
Compilation,"Compilation Phases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Compiler Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Program Development Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Multiple Release Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Using Concurrent C/C++ with the PLDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 PATH Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Include Files and Libraries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 OS Versions and Target Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Shared vs. Static Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Makefile Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Explicit Modification Using ec/ec++ . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Use of /usr/ccs/crossbin in PATH Environment Variable . . . . . . . . . . . . . .
  
 Use of CC Environment or Make Variables . . . . . . . . . . . . . . . . . . . . . . . .
  
 Invoking the Compiler. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Command Line Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Compilation Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Preprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Key Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 C++ Specific Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Error Messages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Other. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Language Dialect. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1-2 
  
 1-5 
  
 1-5 
  
 1-6 
  
 1-6 
  
 1-6 
  
 1-7 
  
 1-8 
  
 1-9 
  
 1-11 
 1-11 
 1-11 
 1-11 
 1-13 
 1-14 
 1-14 
 1-14 
 1-16 
 1-18 
 1-19 
 1-20 
 1-24 
 1-34 
 1-41",NA
1 ,Chapter 1,NA
Compilation,"1 
  
 1 
  
 1 
  
 C and C++ are programming languages suitable for systems programming and general 
 applications. C is a relatively low–level language in that it was designed to accommodate 
 the actual architecture of digital computers.
  
 Many of the advantages of assembly language are available to the C and C++ program-mer. 
 These include indirect addressing, address arithmetic, bit manipulation, and access to low–
 level I/O routines and system services.
  
 A wide variety of operators are also included in the language to take advantage of computer 
 instruction sets, such as shift operators that convert directly into shift right/shift left 
 instructions.
  
 C++ is an extension of the C language, although C++ is not strictly a superset of C. Many 
 of the extensions support object-oriented programming. The evolution of C++ has resulted 
 the development of national and international standards for the language.
  
 The Concurrent C/C++ compiler can be invoked as
  ec
  or
  ec++
 , or through the program 
 development environment tools. Concurrent C/C++ consists of:
  
 •
  An implementation of the language specified by the ANSI C++ standard. 
  
 For more information on ANSI C++, refer to the following:",NA
-,"The C++ Programming Language, Third Edition
  by B. Stroustrup 
  
 (Addison-Wesley Publishing Company, Reading, Mass.).",NA
-,"The Annotated C++ Reference Manual
  (ARM) by M. Ellis and B. 
  
 Stroustrup (Addison-Wesley Publishing Company, Reading, Mass.).",NA
-,"International Standard for Information Systems--Programming Lan-
 guage C++
 , Document No. X3J16/95-0185 by the American National 
 Standards Institute.
  
 •
  Partial support of the
  cfront
  dialect of C++. (The
  cfront
  dialect and 
 technology were developed by AT&T’s UNIX
 TM
 Software Operation, then 
 transferred to Unix System Laboratories, Inc., and finally sold to Novell, 
 Inc.)
  
 •
  A full implementation of the language specified by the ANSI C standard. For 
 more information on ANSI C, refer to
  C: A Reference Manual, Second 
 Edition
  by S. Harbison and G. Steele (Prentice–Hall, Inc., Englewood 
 Cliffs, N.J.) and
  Programming Languages--C
 , ISO/IEC 9899:1990 by the 
 International Organization for Standardization. (The ANSI/ISO standard for 
 C was formerly ANSI document X3.159-1989.)
  
 •
  A full implementation of the language described in
  The C Programming 
 Language
  by B. Kernighan and D. Ritchie (Prentice–Hall, Inc., Englewood 
 Cliffs, N.J.)
  
 •
  Extensions documented in 
  
 Chapter 6 (“Special Features of C++”) and 
  
 architecture–dependencies documented in Appendix B (“Architecture
  
 1-1",NA
Compilation Phases ,"1
  
 The Concurrent C/C++ compiler,
  ec/ec++(1)
 , is based on Concurrent’s Common Code 
 Generator. The steps involved in creating an executable from C/C++ source appear in the 
 following list and in Figure 1-1
  
 1. Create a file containing C/C++ source code. This is typically done in a text 
 editor like
  vi(1)
  or
  emacs(1)
 .
  
 2. Invoke the Concurrent C++ compiler,
  ec++(1)
 , or the Concurrent C 
 compiler,
  ec(1)
 , with appropriate options and arguments. See the 
 ec++(1) ec(1)
  man pages, “Invoking the Compiler” on page 1-13 
 and“Environment Variables” on page 6-37 for information on options, argu-
 ments, and environment variables available. See Chapter 7 (“Compilation 
 Modes”) for information on options that control compilation modes. Some 
 of the possible arguments include: C or C++ source files (generally end with
  
 .c
 ,
  .C
 , or
  .cpp
 ), assembly language source files (must end with
  .s
 ), 
 object files (must end with
  .o
 ), and libraries. Unless you provide options
  
 1-2",NA
Compiler Invocation,"1
  
 The
  ec
  and
  ec++
  compilers accepts many command-line options, also referred to as 
 flags. See the
  ec(1)
  and
  ec++(1)
  man page and Chapter 7 (“Compilation Modes”) for 
 more information. A compiler invocation looks like this:
  
 $ ec++ [
 options
 ]
  arguments 
  
 $ ec [
 options
 ]
  arguments
  
 In the following example,
  part1.c
  and
  part2.c
  are C++ source files,
  part3.s
  is 
 an assembly language source file, and
  part4.o
  is an object file. By default, the 
 compilation and linking is in C++ mode for
  ec++
 , and the compiler automatically 
 performs the steps listed above and creates a binary executable named
  a.out
 .
  
 $ ec++ part1.c part2.c part3.s part4.o
  
 In the following example, the same files are automatically compiled and linked in strict 
 mode (
 --strict
  option) and the executable is named
  flight_sim
  (
 -o
  option).
  
 $ ec++ --strict -oflight_sim part1.c part2.c \ 
  
 part3.s art4.o",NA
Program Development Environment ,"1
  
 Also provided with the Concurrent C/C++ compiler is a high level Program Development 
 Environment (PDE), a set of tools for maintaining complex projects. The PDE maintains a 
 database of all source files, libraries, and executables associated with a defined environ-
 ment. This database approach has several advantages:
  
 •
  Concentration of information makes it possible to make queries using tools in 
 the PDE about what options a given object file is built with, what include 
 files were pulled in, etc.
  
 •
  Template instantiation can deal with libraries better and doesn’t clutter up 
  
 directories with template and instantiation info files.
  
 •
  NightBench provides a graphical user interface that sits on top of the PDE, 
 providing the user with an intuitive graphical way of building complex 
 projects.
  
 •
  A database provides a means for implementing program development tools 
 such as interprocedural analysis and class browsers in future releases of the 
 compilers.
  
 1-5",NA
Multiple Release Support,"1
  
 Beginning with release 5.1, the C and C++ compilers support having multiple releases 
 installed at the same time. Additionally, the Concurrent C 4.3 and Concurrent C++ 3.1 
 compilers can also be installed with C/C++ 5.1.
  
 The follow-on release of both C 4.3 and C++ 3.1 is the C/C++ 5.1 compiler. To access 
 release 5.1 and later, as well as the PDE tools, the user must add
  /usr/ccs/bin
  to his 
 PATH
  environment variable. 
  
 The C++ compiler is then accessed as 
 /usr/ccs/bin/ec++
  and the C compiler is accessed as
  /usr/ccs/bin/ec
  and 
 /usr/ccs/bin/ec++ --c
 .
  
 By default, the commands formerly used to invoke C 4.3 (
 /usr/ccs/bin/cc
  and 
 /usr/ccs/bin/hc
 ) and the commands formerly used to invoke C++ 3.1 
 (
 /usr/bin/cc++
  and
  /usr/bin/c++
 ) will now invoke the default release of C/C++. 
 However, the system administrator can use the
  c.install -p
  option to configure these 
 commands to invoke the pre-5.1 releases by default. Refer to the release notes 
 and“c.install” on page 4-29 for details.
  
 The programs in
  /usr/ccs/bin
  are actually invokers that then invoke the correct 
 release. There is a system wide default release set by the system administrator when he 
 installs the compiler. The user may override that in a number of ways. He may specify a 
 specific release on the command line with the
  --rel
 =
 release
  option to the compiler (or 
 the
  -rel
  release
  option to the PDE tools), or he may set the environment variable 
 PDE_RELEASE
  to the release he wants, or he may set a user specific default with the 
 c.release
  command. The invoker attempts selecting the release by each of these in turn 
 before resorting to the system wide release.
  
 If the PDE is being used to maintain an environment, then the environment remembers 
 what release was used to create it and any tool acting upon that environment will use that 
 release unless the user overrides it with the
  -rel
  option.
  
 The
  c.release
  command can also be used to obtain a list of installed releases. 
 See“c.release” on page 4-59.",NA
Using Concurrent C/C++ with the PLDE ,"1
  
 The following should be taken into consideration in order to use Concurrent C/C++ with the 
 PowerWorks Linux Development Environment.",NA
PATH Considerations ,"1
  
 On Linux systems, the
  cc
 ,
  c++
 ,
  gcc
 , and
  g++
  commands invoke the native Linux 
 com-pilers, which are completely unrelated (and incompatible at the object level) with 
 Power-MAX OS
 TM
 and the Concurrent C/C++ cross-compiler.
  
 1-6",NA
Include Files and Libraries ,"1
  
 By default, the Concurrent C/C++ compiler automatically looks for PowerMAX OS include 
 files and libraries in the tree rooted as:
  
 /pmax/os/
 version
 /
 arch
  
 where
  version
  and
  arch
  indicate the PowerMAX OS version and target architecture of your 
 choice (see “OS Versions and Target Architectures” on page 1-8 for more details).
  
 Files located under
  /usr/include
  and
  /usr/lib
  are native Linux files and are 
 unre-lated and incompatible with the corresponding files for PowerMAX OS. Do not 
 attempt to utilize files from those directories when building PowerMAX OS programs.
  
 Remove any explicit references to these directories in:
  
 •
  source files (e.g.
  #include ""/usr/include/unistd.h""
 )
  
 •
  Makefiles (e.g.
  cc -I/usr/include
 )
  
 •
  build scripts.
  
 Include file references of the form:
  
 #include <unistd.h>
  
 or
  
 #include ""unistd.h""
  
 need not be changed. These forms are supported, as the appropriate
  
 /pmax/os/
 version
 /
 arch
  
 trees are searched.
  
 1-7",NA
OS Versions and Target Architectures,"1
  
 The PowerWorks Linux Development Environment supports building PowerMAX OS 
 programs for various versions of PowerMAX OS and various systems.
  
 The current versions of PowerMAX OS (
 osversion
 ) that are supported are:
  
 •
  4.3
  
 •
  5.0
  
 The current architectures (
 arch
 ) that are supported are:
  
 •
  nh
  
 •
  moto
  
 •
  synergy
  
 which correspond to the following systems:
  
 Table 1-1. Target Architectures
  
 System type
  
 architecture
  
 PowerMAXION-4 
  
 PowerMAXION 
  
 Night Hawk 6800 
  
 Night Hawk 6800 Plus 
 TurboHawk 
  
 Power Hawk 610 
  
 Power Hawk 620 
  
 Power Hawk 640 
  
 PowerStack 
  
 PowerStack II 
  
 Power Hawk 710 
  
 Power Hawk 720 
  
 Power Hawk 740
  
 nh 
  
 nh 
  
 nh 
  
 nh 
  
 nh 
  
 moto 
  
 moto 
  
 moto 
  
 moto 
  
 moto 
  
 synergy 
  
 synergy 
  
 synergy
  
 NOTE
  
 The default OS version is currently
  4.3
  and the default target 
 architecture is
  nh
 .
  
 You can change the
  osversion
  and
  arch
  settings in several ways:
  
 1-8",NA
Shared vs. Static Linking ,"1
  
 By default, the Concurrent C/C++ compiler links with shared libraries. Thus, if you attempt 
 to execute your C++ program on a PowerMAX OS system it will require, at a minimum, 
 the shared library
  libCruntime.so
  or
  libCruntime_mt.so
 .
  
 If your PowerMAX OS system doesn't have either the Concurrent C/C++ product or the 
 c++runtime package installed, your program will fail to execute. You can install the full 
 PowerMAX OS version of the Concurrent C/C++ compiler, install just the c++runtime 
 package, or relink your program using static libraries.
  
 The PowerMAX OS c++runtime package is included on the PowerWorks Linux Develop-
 ment Environment Installation CD. See the section titled “Target Installation” in the Pow-
 erWorks Linux Development Environment Release Notes (0898000) for installation 
 instructions.
  
 To link your program using static libraries, append the
  -Zlink=static
  option to your 
 command line:
  
 1-9",NA
Makefile Considerations,"1
  
 Makefiles may already contain references to
  cc
  or
  c++
  commands explicitly within 
 them. Additionally, if default rules for compilation, such as
  
 .c.o:
  
 or
  
 .cc.o:
  
 are not explicitly mentioned, the make processor will also attempt to invoke
  cc
 ,
  c++
 , or 
 even
  g++
 .
  
 By default, unless you have
  /usr/ccs/crossbin
  early in your
  PATH
  variable, these 
 situations will result in the Linux native compilers being invoked instead of the Concur-
  
 rent C/C++ compiler.
  
 To resolve these problems you can take any of the following approaches.
  
 Explicit Modification Using ec/ec++ 
  
 1
  
 Ensure that
  /usr/ccs/bin
  is in your
  PATH
  environment variable.
  
 Modify all occurrences of
  cc
  and
  c++
  to utilize
  ec
  and
  ec++
 , respectively.
  
 Supply default
  .c.o
  rules (and the like) to explicitly utilize the
  ec
  and
  ec++
  commands.
  
 Use of /usr/ccs/crossbin in PATH Environment Variable 
  
 1
  
 Put
  /usr/ccs/crossbin
  at the head of your
  PATH
  environment variable.
  
 This will cause references to
  cc
  and
  c++
  to invoke the Concurrent C/C++ compiler as 
 opposed to the Linux compilers.
  
 Use of CC Environment or Make Variables 
  
 1
  
 If you don't want
  /usr/ccs/crossbin
  early on your
  PATH
  (perhaps because you plan 
 to build for Linux and/or PowerMAX OS at various times), then you'll want to just use the
  
 ec
  and
  ec++
  when you want to compile for PowerMAX OS (it is still necessary to add 
 /usr/ccs/bin
  to your
  PATH
 ).
  
 One approach to using
  ec
  and
  ec++
  that requires minimal changes to Makefiles, etc., is 
 to use environment variables or
  make
  variables to control which C/C++ compiler you're 
 using. The following commands will all build using the PLDE cross-compilers:
  
 Short-lived environment variables:
  
 $ CC=ec CXX=ec++ make arguments
  
 1-11",NA
Invoking the Compiler,"1
  
 The compiler is invoked by a command of the form
  
 ec[++] [
 options
 ]
  ifile
  
 to compile the single input file
  ifile
 . If
  -
  (hyphen) is specified for
  ifile
 , the compiler reads 
 from
  stdin
 .
 1
  
 Command line options may be specified using either single character option codes (e.g.,
 -o
 ) 
 or keyword options (e.g.,
  --output
 ). A single character option specification con-sists of 
 a hyphen followed by one or more option characters (e.g.,
  -Ab
 ). If an option requires an 
 argument, the argument may immediately follow the option letter, or may be separated 
 from the option letter by white space. A keyword option specification consists of two 
 hyphens followed by the option keyword (e.g.,
  --strict
 ). If an option requires an 
 argument, the argument may be separated from the keyword by white space, or the key-
 word may be immediately followed by
  =
 option
 . When the second form is used there may 
 not be any white space on either side of the equals sign.
  
 A list of files may appear for
  ifile
 . If a list of files is specified, options that specify a com-
 pilation output file (
 --output
 ,
  --list
 , and
  --xref
 ) may not be used, and the name 
 of each source file is written to
  stderr
  as the compilation of that file begins.
  
 When one of the preprocessing-only modes is specified (see below), the
  --output 
 option can be used to specify the preprocessing output file. If
  --output
  is not specified, 
 preprocessing output is written to
  stdout
 . Preprocessing output has trigraphs and line 
 splices processed (and thus they do not appear in their original form).
  
 When compilation (rather than just preprocessing) is done, the output (if any) from the 
 compilation is written to a file selected by the back end; see the documentation of the back 
 end for further information. For versions of the front end that generate an intermediate lan-
 guage file, the
  --output
  option can be used to specify the IL output file.
  
 1. This is not recommended in general, since diagnostic messages and the like will then not include a file 
  
 name or will refer to the file name “
 -
 ”.
  
 1-13",NA
Command Line Options,"1
  
 The
  options
  to
  ec[++]
  are broken down into the following categories:
  
 •
  Compilation Process (see page 1-14)
  
 •
  Language Dialect (see page 1-24)
  
 •
  Optimization (see page 1-34)
  
 •
  Linking (see page 1-41)
  
 Compilation Process 
  
 1
  
 The
  options
  to
  ec[++]
  concerned with controlling the compilation process are broken 
 down into the following categories:
  
 •
  Preprocessing (see page 1-14)
  
 •
  C++ Specific Features (see page 1-18)
  
 •
  Error Messages (see page 1-19)
  
 •
  Other (see page 1-20)
  
 Preprocessing 
  
 1
  
 The following are
  ec[++]
  options
  related to preprocessing
 :
  
 --preprocess
  
 -E
  
 Do preprocessing only. Write preprocessed text to the preprocessing output file, with 
 comments removed and with line control information.
  
 --no_line_commands
  
 --preprocess_to_file
  
 -P
  
 Do preprocessing only. Write preprocessed text to the preprocessing output file, with 
 comments removed and without line control information.
  
 --comments
  
 -C
  
 Keep comments in the preprocessed output. This should be specified after either
 --
 preprocess
  or
  --no_line_commands
 ; it does not of itself request prepro-
 cessing output.
  
 --dependencies
  
 Do preprocessing only. Instead of the normal preprocessing output, generate on the 
 preprocessing output file a list of dependency lines suitable for input to the 
 UNIX
 ®
 make
  program. Note that when implicit inclusion of templates is enabled, the 
 output may indicate false (but safe) dependencies.
  
 1-14",NA
2 ,NA,NA
Using the Program Development Environment,"Hello World - An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Creating an environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Introducing units. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Defining a partition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Building a partition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Success!!! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Let’s look around.... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Listing the contents of your environment . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Viewing the source for a particular unit . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Looking at the Environment Search Path . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 What are my options? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Hello Galaxy - The Example Continues.... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Modifying an existing unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Building a unit with references outside the local environment . . . . . . . . . . . . .
  
 Adding an environment to the Environment Search Path . . . . . . . . . . . . . . . . .
  
 Making contact!!! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Who resides here now?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2-1 
  
 2-1 
  
 2-2 
  
 2-3 
  
 2-4 
  
 2-4 
  
 2-4 
  
 2-4 
  
 2-5 
  
 2-6 
  
 2-6 
  
 2-11 
 2-11 
 2-12 
 2-13 
 2-13 
 2-13 
 2-15",NA
2 ,Chapter 2,NA
Using the Program Development Environment,"2 
  
 2 
  
 2 
  
 The Concurrent C/C++ Program Development Environment consists of a number of utili-
 ties that provide support for library management, compilation, program generation, and 
 debugging.
  
 This chapter provides an simple tutorial which will guide the user in using a number of 
 these utilities. See Chapter 4 (“Program Development Environment Utilities”) for more 
 detailed information on each of these utilities.",NA
Hello World - An Example ,"2
  
 To demonstrate the ease of use of Concurrent C/C++ Program Development Environment, 
 a simple example will be given. This example will traverse through the core functions 
 needed to build an executable under the Concurrent C/C++ system.
  
 Building an executable under Concurrent C/C++ can be broken down into as few as four 
 steps:
  
 •
  Creating an environment
  
 •
  Introducing units
  
 •
  Defining a partition
  
 •
  Building the partition
  
 This section will demonstrate each of these steps on a simple, but well-known example -
 Hello World.
  
 Before we begin...
  
 You must make sure that the path
  /usr/ccs/bin
  is added to 
 your
  PATH
  environment variable. This is the only path necessary 
 to access the Concurrent C/C++ utilities, regardless of the number 
 of releases of Concurrent C/C++ installed on the system.",NA
Creating an environment ,"2
  
 One of the first steps you must take in order to use Concurrent C/C++ is to create an
  envi-
 ronment
 . Concurrent C/C++ uses environments as its basic structure of organization. 
 Environments contain all the information relevant to a particular project. All of the Con-
 current C/C++ utilities work within the context of a particular environment.
  
 2-1",NA
Introducing units ,"2
  
 Compilation units
  (henceforth referred to simply as
  units
 ) are the basic building blocks of 
 Concurrent C/C++ environments. It is through units that Concurrent C/C++ performs most 
 of its library management and compilation activities. These units are, however, introduced 
 into the system in the form of
  source files
 .
  
 In our example, we have one unit,
  hello
 , that resides in a source file,
  hello.C
 . This 
 source file is just an ordinary text file. By default, the name of the unit is the file name of 
 the source file without any path prepended or extension postpended.
  
 The source file,
  hello.C
 , is shown below:
  
 #include <iostream> 
  
 main() { 
  
  
 std::cout << “Hello World!!!\n”; 
  
 }
  
 Create this source file within the directory in which you created your environment. (It is 
 not necessary for the source file to reside in the same directory as the environment. You 
 may specify a relative or absolute path name of the source file.)
  
 We introduce this unit to the environment by using the
  c.intro
  utility. (See “Invoking 
 the Compiler” on page 1-13)
  c.intro
  introduces a unit for source file into the current 
 environment.
  
 2-2",NA
Defining a partition ,"2
  
 If we want to create an executable program to use our unit, we must define a
  partition
 . We 
 will be creating an
  executable partition
  which is the type that corresponds to executable 
 programs.
  
 We must also name the partition. You can name your partition anything you want and then 
 add units to it, but since this is a simple example, we are taking the most direct route. 
 Hence, our partition will be named
  hello
 . We wUill use the Concurrent C/C++ utility 
 c.partition
  to do this.
  
 $ 
 c.partition -create executable hello
  
 Screen 2-3. Defining a partition 
  
 Because it has the same name as the executable partition being created, the unit
  hello
  is 
 automatically added to this partition.
  
 NOTE 
  
 The command in Screen 2-3 could have been explicitly specified as:
  
 $ 
  
 c.partition -create executable -add hello hello 
 This command creates an active partition named
  hello
  and adds 
 the
  hello
  unit to it.
  
 2-3",NA
Building a partition ,"2
  
 The last step now is to build the executable. All the necessary steps have been done. Just 
 issue
  c.build
 . This will build an executable file that you can run.
  
 $ 
 c.build
  
 Screen 2-4. Building a partition
  
 Because no arguments were specified,
  c.build
  tries to build everything it can within 
 this environment. Since we’ve only defined one unit,
  hello
 , contained in one partition, 
 hello
 , it will only build that.",NA
Success!!! ,"2
  
 Now all that’s left is to run the program as you would any other executable program. Enter 
 the name of the executable, in this case
  hello
 .
  
 $ 
 ./hello
  
 Hello World!!!
  
 $
  
 Screen 2-5. Executing the program
  
 And there you have it! Your program has successfully been built and run.",NA
Let’s look around... ,"2
  
 Now that we have some substance to our environment, let’s take a look around and see 
 what things look like. We can use some of the Concurrent C/C++ utilities to investigate the 
 state of our environment and what’s in it.
  
 Listing the contents of your environment 
  
 2
  
 Something you might want to do is to see what units and partitions are contained within 
 this environment.
  c.ls
  provides this list for you.
  c.ls
  provides many different options, 
 allowing you to sort the list by some attribute or filter the units based on certain criteria. 
 We’ll just take a look at a basic list of the contents of the environment. This is done by 
 issuing the
  c.ls
  command with no options from within your current environment.
  
 2-4",NA
Hello Galaxy - The Example Continues... ,"2
  
 Let’s set up another environment with a function that our
  hello
  unit can contact.
  
 Let’s set up a new environment,
  galaxy
 , and introduce a source file very similar to 
 hello.C
 . We’ll call this file
  alien.C
  and it will contain the following unit,
  alien
 .
  
 The file is shown below:
  
 #include <iostream>
  
 void planet() {
  
 std::cout << “Greetings from Outer Space!!!\n”;
  
 }
  
 Create a different directory
  /pathname/galaxy
  to contain our new environment and 
 place the source file,
  alien.C
 , in it. From within that directory, the following com-
 mands will create our environment and introduce the source file into it.
  
 $ 
 c.mkenv
  
 $ 
 c.intro alien.C
  
 Screen 2-21. Setting up another environment
  
 NOTE
  
 We have not compiled this unit nor have we created a partition
  
 and included the unit in the partition to be built. This was inten-
  
 tional to demonstrate a point later in the example.",NA
Modifying an existing unit ,"2
  
 Now we must go back to our original environment
  earth
  that contains our original unit 
 hello
 .
  
 We will update the unit
  hello
  so that it references the new
  alien
  unit. We do this by 
 using the
  c.edit
  utility.
  c.edit
  edits the source file that contains the unit specified. It 
 does this by using the editor referenced in the
  EDITOR
  environment variable. It then 
 updates the environment so that the automatic compilation utility,
  c.build
 , knows that 
 this unit needs to be rebuilt.
  
 2-11",NA
Building a unit with references outside the local environment ,"2
  
 Now let’s try to build it.
  
 Issue the
  c.build
  command as before.
  
 $
  c.build 
  
 Undefined 
  
  
 first referenced 
  
 symbol 
  
   
 in file 
  
 planet() 
  
 .c++/.units/hello.o 
  
 ld: hello: fatal error: Symbol referencing errors. No output written to 
 hello ec++: ERROR: Errors in the ld pass, status = 1 
  
 c.build: failed building partition hello 
  
 c.build: there was a failure building one or more partitions 
  
 $
  
 Screen 2-23. Building the partition with reference to
  alien
  unit
  
 Because the
  alien
  unit does not exist in the current environment AND because we have 
 not manually added it to our Environment Search Path,
  c.build
  cannot find it and there-
 fore complains.
  
 2-12",NA
Adding an environment to the Environment Search Path ,"2
  
 This is easily remedied by adding the new environment’s path to the Environment Search 
 Path for the
  earth
  environment using the
  c.path
  utility.
  
 You can see that it has been added to your Environment Search Path by issuing the 
 c.path
  command with no parameters again.
  
 $
  c.path -A /pathname/galaxy 
  
 $
  c.partition -add alien 
 hello 
  
 $
  c.path -v 
  
 Environment Search Path: 
  
 /pathname/galaxy 
  
 $
  
 Screen 2-24. Adding to and viewing the updated Environment Search Path",NA
Making contact!!! ,"2
  
 Now try to issue
  c.build
  again. This time it will be successful.
  
 After it is successfully built, run the
  hello
  executable again.
  
 $
  
 c.build 
  
 $
  
 ./hello 
  
 Hello 
 World!!!
  
 Greetings from Outer Space!!!
  
 $
  
 Screen 2-25. Executing the new
  hello
  - contact is made!",NA
Who resides here now? ,"2
  
 Let’s take a look at who inhabits our environment
  earth
  now. Remember before when 
 we issued the
  c.ls
  command, we saw that our environment contained the lone unit 
 hello
 . Let’s issue the command again and see what has happened since we made contact 
 with the
  alien.
  
 2-13",NA
-,"The unit
  hello
  was introduced directly into this environment. Therefore, 
  
 it is regarded as a
  native
  unit.",NA
-,"The
  alien
  unit, however, was never formally introduced into the local 
  
 environment. It was found on the Environment Search Path.
  
 Now, remember that the
  alien
  unit was not compiled in its original for-
 eign environment. The
  c.build
  command, when run in this local envi-
 ronment, could not find a compiled form of the
  alien
  unit on the Envi-
 ronment Search Path and had to do something in order to build the partition. 
 It therefore compiled the
  alien
  unit in the local environment.
  
 This compiled form of a foreign unit within the local environment is con-
 sidered
  naturalized
  by the system.
  
 NOTE
  
 If the
  alien
  unit had been compiled in its own foreign environ-
 ment,
  c.build
  would have found that compiled form on the 
 Environment Search Path and would have used that when linking 
 the
  hello
  executable together.
  
 FURTHER NOTE
  
 The
  -noimport
  option will inhibit the automatic naturalization 
 behavior of
  c.build
 . If it had been used in this example, 
 c.build
  would have reported an error.
  
 2-14",NA
Conclusion,"2
  
 This concludes the Concurrent C/C++ Program Development Environment tutorial. You 
 should now be familiar enough with the Concurrent C/C++ PDE to explore the additional 
 functionality not covered in this tutorial. You may investigate the other sections of this 
 manual to get more detailed explanations of PDE functionality.
  
 If any questions arise while you are using the Program Development Environment, you may 
 use invoke the online help system by issuing the command:
  
 c.man
  
 and selecting the
  Concurrent C/C++ Reference Manual
  from the bookshelf. See“c.man” 
 on page 4-45 for details.
  
 2-15",NA
3 ,NA,NA
Program Development Environment Concepts,"Environments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Local Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Foreign Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Environment Search Path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Naturalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Fetching. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Freezing Environments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Environment-wide Compile Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Units. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Unit Identification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Nationalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Local Units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Foreign Units. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Artificial Units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Unit Compile Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Types of Partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Executable Partitions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Shared Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Lazy Versus Immediate Binding . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Position Independent Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Share Path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Issues to consider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Object Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Link Options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Compilation and Program Generation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Automatic Compilation Utility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Compile Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Environment-wide Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Permanent Unit Options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Temporary Unit Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Effective Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Compilation States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Programming Hints and Caveats. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Linking Executable Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Real-Time Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Debug Information and cprs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Source Control Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Makefile Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3-1 
  
 3-2 
  
 3-2 
  
 3-2 
  
 3-2 
  
 3-3 
  
 3-3 
  
 3-3 
  
 3-3 
  
 3-4 
  
 3-4 
  
 3-4 
  
 3-5 
  
 3-5 
  
 3-5 
  
 3-5 
  
 3-6 
  
 3-6 
  
 3-6 
  
 3-6 
  
 3-7 
  
 3-7 
  
 3-7 
  
 3-7 
  
 3-8 
  
 3-8 
  
 3-9 
  
 3-9 
  
 3-9 
  
 3-9 
  
 3-10 
 3-10 
 3-10 
 3-11 
 3-11 
 3-12 
 3-13 
 3-13 
 3-13 
 3-13 
 3-13 
 3-14 
 3-14",NA
3 ,Chapter 3,NA
Program Development Environment Concepts,"3 
  
 3 
  
 3 
  
 Concurrent C/C++ uses the concept of
  environments
  as its basic structure of organization. 
 These environments take advantage of various utilities provided by Concurrent C/C++ to 
 manipulate
  compilation units
  (referred to simply as
  units
 ) that may form
  partitions
 .
  
 Utilities for library management, compilation and program generation, and debugging are 
 provided by Concurrent C/C++.
  
 This chapter will discuss in further detail the concepts of environments, units and parti-
 tions and their relationship to library management, program generation, and debugging.",NA
Environments ,"3
  
 Concurrent C/C++ uses the concept of environments as its basic structure of organization. 
 Environments may include:
  
 •
  units that have been introduced
  
 •
  partitions that have been defined
  
 •
  Environment Search Paths
  
 •
  references to source files (which generally contain units)
  
 •
  other information used internally by Concurrent C/C++
  
 Environments collect and maintain
  separate compilation information
  which is informa-tion 
 collected from previous compilations.
  
 Concurrent C/C++ permits local environments to reference other
  foreign
  environments thus 
 providing visibility to the units and partitions therein. This feature allows program-mers to 
 work on local versions of individual program units while retrieving the remainder of the 
 program from previously developed environments.
  
 A Concurrent C/C++ environment may be initialized or created in any desired location in a 
 filesystem using the
  c.mkenv
  utility.
  
 Concurrent C/C++ provides several other utilities to maintain, modify and report on the 
 contents of environments. Any modifications to the environment other than through the 
 tools provided by Concurrent C/C++ is discouraged, although the tools support it as well as 
 possible.
  
 3-1",NA
Local Environments,"3
  
 By default, Concurrent C/C++ uses the current working directory as its
  local environment
 . 
 All Concurrent C/C++ utilities perform their actions within this local environment unless 
 the
  -env
  option is explicitly specified.
  
 For example, if no environment is specified with the
  c.mkenv
  tool, Concurrent C/C++ 
 will set up its internal directory structure for that environment within the current working 
 directory.
  
 When used with any of the Concurrent C/C++ utilities, however, the
  -env
  option allows 
 the user to specify a target environment other than the current working directory. The 
 actions of the Concurrent C/C++ utility using this option will be performed in the environ-
 ment specified and not in the local environment. (See Chapter 4 (“Program Development 
 Environment Utilities”) for more details on using this parameter with each of the tools.)",NA
Foreign Environments ,"3
  
 Concurrent C/C++ uses the Environment Search Path to reference units within foreign 
 environments. These units can be used as foreign units or can be brought into the local 
 environment through naturalization or fetching.
  
 Environment Search Path 
  
 3
  
 Concurrent C/C++ uses the concept of an
  Environment Search Path
  to allow users to spec-
 ify that units from environments other than the current environment should be made avail-
 able in the current environment. This Environment Search Path relates only to each par-
 ticular environment and each environment has its own Environment Search Path.
  
 By placing the location of another environment on the
  Environment Search Path
  for a 
 given environment, all the units from the other environment are conceptually added to the 
 given environment, unless that would involve replacing a unit which was either introduced 
 manually into the environment by a user, or would replace a unit which was introduced 
 from yet a third environment which precedes the other environment in the Environment 
 Search Path. In order to add or delete environments on your Environment Search Path, you 
 may use the
  c.path
  tool. See “c.path” on page 4-57.
  
 In addition to accessing units in foreign environments, the user may also link with parti-
 tions (archives, shared-object, and object partitions) that are located in foreign environ-
 ments. Partition names have the same visibility rules that units do.
  
 Naturalization 
  
 3
  
 At times, it is necessary for the compilation system to make local copies of units that exist 
 in foreign environments. For example, if a foreign unit is referenced within a local unit and 
 no compilation has been done on that foreign unit in that foreign environment, a local copy 
 of the foreign unit will be compiled within the current environment, using any options that 
 would apply to the foreign unit. This happens transparently to the user. Should a 
 naturalized unit subsequently be built within its native environment, then the
  
 3-2",NA
Freezing Environments ,"3
  
 An environment may be frozen using the
  c.freeze
  utility. This changes an environ-
 ment so that it is unalterable.
  
 A frozen environment is able to provide more information about its contents than one that 
 is not frozen. Therefore, accesses to frozen environments from other environments func-
 tion much faster than accesses to unfrozen environments.
  
 Any environment which will not be changed for a significant period of time and which will 
 be used by other environments is a good candidate to be frozen to improve compila-tion 
 performance.
  
 See “c.freeze” on page 4-25 for information on this utility.",NA
Environment-wide Compile Options ,"3
  
 Environment-wide compile options apply to all units within an environment. See “Envi-
 ronment-wide Options” on page 3-10.",NA
Units ,"3
  
 Compilation units (or simply units) are the basic building blocks of Concurrent C/C++ 
 environments. Instead of dealing with source files for library management and compila-tion 
 activities, Concurrent C/C++ focuses on the concept of units. A
  compilation unit
  can be the 
 routines and global data packaged in a primary source file, an extern inline func-tion, or an 
 instantiatable template entity (in C++).
  
 3-3",NA
Unit Identification,"3
  
 For many of the Concurrent C/C++ utilities in Chapter 4, the following definition is given:
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all",NA
Nationalities ,"3
  
 Compilation units in Concurrent C/C++ have a nationality associated with them. Units can 
 be either
  local
  or
  foreign
 .
  
 Local Units 
  
 3
  
 Compilation units that are
  local
  to a system can be one of three types:
  
 native
  
 Native compilation units are introduced into an environment by using the 
 c.intro
  function.
  
 Once a unit is introduced into an environment, it is considered to be owned by 
 that environment and any functions performed on that unit should be managed 
 by the environment through the Concurrent C/C++ utilities.
  
 naturalized
  
 Sometimes, the compiled form of a foreign unit is not available when it is 
 needed locally for a build. In this case, the system automatically makes a local 
 compilation. This local compiled form is considered to be naturalized.
  
 A naturalized unit retains the compile options from its original environment. 
 These options can only be altered by changing them in the original environ-
 ment.
  
 Naturalized units are automatically expelled from the local environment should 
 an up-to-date version be built in its native environment.
  
 fetched
  
 In some cases, it may be desirable for users to manually fetch unit from another 
 environment into the local environment.
  
 A fetched unit retains the unit-specific options from the original unit but these 
 options may be changed in the local environment. However, it does not retain 
 the environment-wide options of its original environment. It uses those of the 
 current environment instead.
  
 3-4",NA
Artificial Units ,"3
  
 At times, the implementation may create units to fill internal roles such as instantiating 
 template entities or extern inline functions. These units are created, utilized, and some-
 times discarded during the compilation phase. The user may use the
  -art
  option to 
 c.ls
  
 to display the artificial units in the environment. See “c.ls” on page 4-36 for more 
 information.",NA
Unit Compile Options ,"3
  
 Each unit has a set of permanent and temporary compile options associated with it. These 
 compile options are described in more detail in “Permanent Unit Options” on page 3-10",NA
Partitions ,"3
  
 A
  partition
  is an executable, archive, shared object, or object file that can be invoked or 
 referenced outside of the Concurrent C/C++ Program Development Environment. Parti-
 tions consist of one or more units that have been introduced into the environment. The units 
 included in a partition are those that the user explictly assigns and units which they require. 
 Concurrent C/C++ manages these units and their dependencies, as well as link options and 
 configuration information for each partition within the context of an
  environ-ment
 . A 
 partition definition must include one or more units in order to be built.
  
 A partition within Concurrent C/C++ is created and maintained by using the
  c.parti-
 tion
  function. This function provides tools to create a partition, add or delete units from a 
 partition, and various other utilities.
  
 In much the same way that options and configuration information concerning compilation 
 are associated with units, linker options and configuration information for linking are 
 associated with partitions. Partitions are basically recipes to the linker which indicate how 
 to build a target file from units.
  
 3-5",NA
Types of Partitions,"3
  
 Concurrent C/C++ defines four types of partitions:
  
 •
  Executable Programs
  
 •
  Archives
  
 •
  Shared Objects
  
 •
  Object Files
  
 Executable Partitions 
  
 3
  
 Executable partitions describe how to build an executable program.
  
 Archives 
  
 3
  
 An
  archive
  is a collection of routines and data that is associated with an application during 
 the link phase. Archives are useful for linking into other, potentially non-C/C
 ++
 , applica-
 tions. Archives are usually designated with a
  .a
  suffix.
  
 Archives differ from shared objects by the form of the object contained within it. Archives 
 contain statically-built (i.e. non-shared) objects within them. (See “Position Independent 
 Code” on page 3-7 for more details)
  
 Shared Objects 
  
 3
  
 A
  shared object
  is a collection of routines and data that is associated with an application 
 during the link and execution phases. Shared objects are useful for linking into other C/C++ 
 or non-C/C++ applications. Shared objects are usually designated with a
  .so
  suf-fix.
  
 Shared objects differ from archives by the form of the object contained within it. Shared 
 objects are dynamically built (i.e. shared) objects that contain position independent code.
  
 (See “Position Independent Code” on 3-7 for more details)
  
 At link time, routines and data objects from a shared object may satisfy unresolved refer-
 ences from an application, but they are not copied into the resultant application’s execut-
 able image. The actual associations and memory allocations occur during the initial phase 
 of the application’s execution; this is termed the
  dynamic linking
  phase. Because of this, it 
 is possible for shared objects to be changed and these changes to affect the application that 
 has linked with them. However, due to this dynamic linking property of shared objects, it is 
 often not necessary to rebuild the calling application after the shared object has changed.
  
 During dynamic linking, all shared objects that the application requires are allocated and 
 linked into the application’s address space, sharing as many physical memory pages with 
 other concurrently executing applications as possible. Therefore, totally dissimilar appli-
 cations may share the same physical pages for the same shared object. This applies to the 
 memory for the actual code or machine instructions in the shared object. The memory for
  
 3-6",NA
Link Options ,"3
  
 Concurrent C/C++ supports a set of link options for each partition. These link options are 
 persistent and can be specified using the following options to
  c.partition
  :
  
 -oset
  opts 
  
 Sets the link options as indicated by
  opts
  
 -oappend
  opts 
  
 Appends the
  opts
  argument to the link option listing
  
 -oprepend
  opts 
  
 Prepends the
  opts
  argument to the link option listing
  
 -oclear 
  
 Clears the link options
  
 opts
  is a single parameter containing one or more link options; it 
 must be enclosed in double quotes.
  
 A link option set is maintained for each Concurrent C/C++ partition and these options 
 remain effective throughout the life of the partition. Any changes to these options should be 
 done using
  c.partition
 .
  
 3-8",NA
Compilation and Program Generation ,"3
  
 The compiler operates in several distinct phases, designed to satisfy the needs of the entire 
 software development process. These phases include:
  
 •
  Syntax checking
  
 •
  Semantic checking
  
 •
  Code generation and optimization
  
 •
  Instruction scheduling
  
 •
  Machine-code assembly
  
 Various options can be specified with the
  c.options
  command in order to control com-
 pilation phases. For example, during preliminary software development, it is often useful to 
 limit the compilation phases to syntax and semantic checking. Errors from these phases can 
 be brought up into a text editor automatically for fast, iterative editing and compiling.",NA
Compilation ,"3
  
 Concurrent C/C++ uses an C/C++ compiler that supports the C/C++ language specifica-tion 
 as defined in the ISO/IEC 14882
  Programming languages -- C++
 .
  
 Automatic Compilation Utility 
  
 3
  
 Concurrent C/C++ provides
  c.build
  for automatic compilation and program generation. 
 c.build
  calls various internal tools to create an executable image of the program. 
 See“c.build” on page 4-9 for more information.
  
 Compile Options 
  
 3
  
 Unlike most compilation systems, Concurrent C/C++ uses the concept of
  persistent options
 . 
 These options do not need to be specified on the command line for each compila-tion. 
 Rather, they are stored as part of the environment or as part of an individual unit’s 
 information. These options are “remembered” when the Concurrent C/C++ compilation 
 tools are used.
  
 There are four “levels” of compilation options:
  
 •
  Permanent environment-wide options
  
 3-9",NA
-,"If a unit is manually compiled (using
  c.compile
  - see “c.compile” on 
 page 4-14) with any specified options, these are added to its set of tempo-
 rary options.",NA
-,"The temporary options may also be set using the
  c.options
  tool.
  
 Temporary options allow users to “try out” options under consideration. 
  
 By designating 
 these options as “temporary”, the user can first see the effect these options have and then 
 decide if this is what is desired. If so, Concurrent C/C++ provides a way to add these tem-
 porary options to the set of permanent options for that unit using
  c.options
 . If these 
 options are not what the user desires,
  c.options
  also provides a way to eliminate all 
 temporary options from a unit (or from all units in the environment).
  
 Another case in which temporary options might also prove useful is one in which a unit 
 needs to be compiled with debug information. If this is not the manner in which the unit is 
 normally compiled, a temporary option can be set for that unit to be compiled with debug 
 information. When the debug information is no longer needed, the temporary option can be 
 removed and the unit can be recompiled in its usual manner.
  
 See the description of “c.options” on page 4-49 for more details.
  
 3-10",NA
Linking Executable Programs ,"3
  
 Concurrent C/C++ provides a linker that verifies and creates an ELF executable image of 
 all component units required for a given main unit. The linker can be invoked directly but 
 should be called from the compilation utility
  c.build
 .",NA
Debugging ,3,NA
Real-Time Debugging ,"3
  
 In addition to the symbolic debugging capabilities provided by NightView (see
  NightView 
 User’s Guide
  (0890395)), and the post-analysis debugging capabilities provided by the 
 tracing mechanism, Concurrent C/C++ also provides several ways to debug programs in 
 real-time.",NA
Debug Information and cprs ,"3
  
 The
  cprs
  utility (see
  cprs(1)
 ), supplied with PowerMAX OS, reduces the size of an 
 application by removing duplicate type information. The Concurrent C/C++ compiler 
 reduces the value of this tool by already referencing the debug information for types 
 defined in other units from those other units. However, the
  cprs
  utility can still reduce 
 the size of Concurrent C/C++ applications. Also, if debug code from other languages is
  
 3-13",NA
Source Control Integration ,"3
  
 There are a number of software packages for managing versions of source code. The envi-
 ronment provides a rudimentary way inter integrate with such packages. In the direc-tory 
 /usr/ccs/release/
 release
 /source
 , the system administrator can create a directory 
 for a particular source management system, that we’ll call
  sms
  for illustrative purposes. In 
 that directory, the system administrator should place two scripts: pre-edit and post-edit. 
 These scripts are destined to run before and after a source file is edited.
  
 Now, the user, when he creates his environment, would issue the
  c.mkenv
  command with 
 the -src option like this:
  
 $
  c.mkenv -src “
 sms
  -v %f”
  
 Now, whenever
  c.edit
 , or any command that invokes
  c.edit
  is run, the pre- and 
 post-edit scripts are run before and after the editor, passing the -v option and the name of 
 the source file, as if the user had invoked:
  
 $
  /usr/ccs/release/
 release
 /source/
 sms
 /pre-edit 
 \
  
 -v file.c 
  
 $
  $EDITOR file.c 
  
 $
  /usr/ccs/release/
 release
 /source/
 sms
 /post-edit 
 \
  
 -v file.c
  
 DISCLAIMER
  
 Concurrent Computer Corporation does not support any particular 
 source management system. The
  -src
  mechanism may not pro-
 vide the flexibility needed by any particular system.",NA
Makefile Integration ,"3
  
 The C/C++ Program Development Environment provides a mechanism to escape to 
 Makefiles or any other arbitrary software to generate source files by means other than 
 editing them. The
  c.intro
  command includes a
  -make
  option that specifies an arbi-
 trary shell command line that will be used to construct the source file whenever it needs to 
 determine if it needs to rebuild the unit that is being introduced.
  
 $
  c.intro -make “make myfile.c” myfile.c
  
 3-14",NA
4 ,NA,NA
Program Development Environment Utilities,"Common Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.analyze . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Link-Time Optimizations with c.analyze. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Profiling with c.analyze . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.cat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.chmod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.compile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.demangle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.edit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.error. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.expel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.fetch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.freeze. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.grep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.install. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.instantiation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.intro. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.invalid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.link . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.ls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Formatting the listing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.lssrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.make . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.man . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.mkenv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Option Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Listing options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Setting options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Modifying options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Clearing options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Deleting options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Keeping temporary options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Setting options on foreign units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.partition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Link Options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.prelink . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.release . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.report. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.restore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.rmenv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 c.rmsrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4-3 
  
 4-4 
  
 4-6 
  
 4-7 
  
 4-9 
  
 4-12 
 4-13 
 4-14 
 4-16 
 4-17 
 4-18 
 4-22 
 4-23 
 4-24 
 4-25 
 4-26 
 4-28 
 4-29 
 4-31 
 4-32 
 4-34 
 4-35 
 4-36 
 4-39 
 4-41 
 4-42 
 4-43 
 4-45 
 4-47 
 4-49 
 4-50 
 4-50 
 4-51 
 4-51 
 4-51 
 4-52 
 4-52 
 4-52 
 4-53 
 4-55 
 4-57 
 4-58 
 4-59 
 4-61 
 4-63 
 4-64 
 4-65",NA
4 ,Chapter 4,NA
Program Development Environment Utilities,"4 
  
 4 
  
 4 
  
 The Concurrent C/C++ Program Development Environment consists of a number of utili-
 ties that provide support for library management, compilation, program generation, and 
 debugging. Table 4-1 lists these tools and gives a brief description of each one.
  
 Table 4-1. Concurrent C/C++ Utilities
  
 Environment Utilities
  
 c.mkenv
  
 Create an environment which is required for compilation, link-ing, 
 etc.
  
 c.path
  
 Display or change the Environment Search Path for an environ-
 ment
  
 c.options
  
 Set compilation options for the environment (or for units)
  
 c.rmenv
  
 Destroy an environment; compilation, linking, etc. no longer 
 possible
  
 c.chmod
  
 Modify the UNIX file system permissions of an environment
  
 c.release
  
 Display release installation information
  
 c.script
  
 Generate a script that will recreate an environment
  
 c.freeze
  
 Disallow changes to, and optimize uses of an environment
  
 c.make
  
 Generate a Makefile to reproduce build the partitions in the envi-
 ronment
  
 c.restore
  
 Restore a corrupted database from an automatic backup
  
 Unit Utilities
  
 c.ls
  
 List units in the environment (state, source file, dependencies, etc.)
  
 c.options
  
 Set compilation options for units (or the environment)
  
 c.edit
  
 Edit the source of a unit, then update the environment
  
 c.cat
  
 Output the source of a unit
  
 c.touch
  
 Make the environment consider a unit consistent with its source 
 file's timestamp
  
 c.invalid
  
 Force a unit to be inconsistent thus requiring it to be recompiled
  
 c.instantiation
  
 Control instantiation automation
  
 c.fetch
  
 Fetch the compiled form of a unit from another environment
  
 c.expel
  
 Expel fetched or naturalized units from the environment
  
 4-1",NA
Common Options,"Program Development Environment Utilities
  
 4
  
 There are a number of options that are the same for each utility. They are listed for each
  
 tool but are also listed below.
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 help
  
 Display syntax and options for that particular function
  
 -H
  
 verify
  
 Show actions that would be executed without actually doing them. Not all
  
 -V
  
 commands have a
  -V
  option.
  
 -v
  
 verbose
  
 Provide feedback as actions are performed. Not all commands have a
  -v 
 option.
  
 -vv
  
 very verbose
  
 Provide extra feedback as actions are performed. This usually includes
  
 showing the exact command line used to invoke subordinate tools. Not all
  
 commands have a
  -vv
  option.
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 See “Unit Identification” on page 3-4 for more information about the
  unit-id
 .
  
 4-3",NA
c.analyze,"c.analyze
  
 4
  
 Optimize or analyze performance of fully-linked executables 
 The syntax of the
  c.analyze
  command is:
  
 c.analyze [
 options
 ]
  executable-file
  
 The following represents the
  c.analyze
  options:
  
 Option
  
 Meaning
  
 Function
  
 -A
  
 all
  
 Include all the routines in the analysis (initial default)
  
 add
  
 Add the specific named
  routine
  to the list of routines to analyze (implies
  
 -a
  routine
  
 -N
 )
  
 -C
  
 cache
  
 Gather cache activity statistics during profiling. Requires
  -P
  option.
  
 debug
  
 -D
  flag
  
 Turn on the specified debug flag. Not of general user interest. Use
  
 -Dhelp
  for list of options
  
 -Dhelp
  
 debug help
  
 List of debug options
  
 disassemble
  
 Generate a detailed disassembly listing of each routine included in the
  
 -d
  file
  
 analysis in
  file
 . The listing is done on a per basic block basis. By default
  
 -env
  env
  
 environment
  
 this only generates the assembler listing, the clock cycle each instruction
  
 executes at (relative to the beginning of each basic block), and the reason
  
 any instruction is delayed. Use the
  -v
  option for more detail. Use
 -
 Zstage_status
  for much more verbose status of each pipeline stage 
 each cycle. Use
  -
  for
  file
  to direct output to
  stdout.
  
 Specify an environment pathname. Defaults to current directory.
  
 global
  
 Generate global program statistics to
  file.
  Use
  -
  for
  file
  to direct output to 
 stdout
  
 -g
  file
  
 -H
  
 help
  
 Display syntax and options for this function
  
 information
  
 Display information only messages
  
 -i
  
 null
  
 Set the list of routines to be analyzed to the empty set (no routines)
  
 -N
  
 nesting level
  
 use nesting level to weight the count of lis instructions. This option is
  
 -n
  
 used with the -O option.
  
 -O
  file
  
 optimize
  
 Generate a new program file in
  file
  which has been optimized by replacing
  
 many of the two-instruction sequences (which are required to reference
  
 global memory locations) with single instructions which use the reserved
  
 linker registers as base registers. This allows faster access to the four most
  
 commonly referenced 64K data blocks.
  
 Certain library routines that are
  
 known to access the linker registers (e.g.,
  setjmp
  and
  longjmp
 ) are 
 automatically excluded from the optimization process. The
  -X
  option may 
 be used to specifically exclude others. (Normally any reference to a linker
  
 register will cause an error)
  
 4-4",NA
Link-Time Optimizations with c.analyze ,"4
  
 To enhance the optimization of C/C
 ++
 source, in addition to compiling the source code at 
 the
  MAXIMAL
  level (
 -O3
 ), you can elect to invoke
  c.analyze
  when linking your 
 C/C
 ++ 
 programs in order to perform additional optimizations at link time. For example, the
  
 -O 
 option to
  c.analyze
  replaces many of the two-instruction sequences required for 
 refer-encing global memory locations with a single instruction.
  
 You can invoke
  c.analyze
  in two ways: either directly on executables or as an option to 
 the linker (
 c.link
 ).
  
 To invoke the
  c.analyze
  optimizer directly on an executable file (
 a.out
 ), simply type 
 the following:
  
 $
  c.analyze -O na.out a.out
  
 The original executable,
  a.out
 , remains the same and the resulting executable generated 
 by
  c.analyze
  is contained in a file called
  na.out
 .
  
 Alternatively, you can invoke
  c.analyze
  at link time by specifying the
  -O
  link option 
 for a given partition:
  
 $
  c.partition -oappend -O main 
  
 $
  c.build main
  
 What results from this sequence of commands is that a single executable file (
 a.out
 ) is 
 optimized at level
  GLOBAL
  followed by an additional link-time optimization performed by 
 the
  c.analyze
  optimizer.
  
 Because of the
  -O
  option,
  c.analyze
  performs the following link optimization. It 
 replaces the two-instruction sequences (which are required to reference global memory
  
 locations) with single instructions which use the reserved linker registers (
 r28
  and
  r30
 ) as 
 base registers. This allows faster access to the two most commonly referenced 64K data
  
 blocks.
  
 NOTE
  
 Certain library routines that are known to access the linker regis-
  
 ters (e.g.,
  setjmp
  and
  longjmp
 ) are automatically excluded 
 from the optimization process.
  
 4-6",NA
Profiling with c.analyze ,"4
  
 In addition to performing link-time optimizations,
  c.analyze
  can be used in tandem 
 with the
  c.report
  tool in order to generate profiling statistics. See “c.report” on page 4-
 61.
  
 To profile an executable C/C
 ++
 program with
  c.analyze
 , the
  -P
  (profiling) option 
 must be specified. With the
  -P
  option set, a new executable file is created that has been 
 patched to gather profiling statistics. The original executable file remains intact. For 
 example, the
  
 following command line:
  
 $
  c.analyze -P
  
 profiled_a.out
  
 a.out
  
 takes the executable
  a.out
  as input, profiles it, and then produces the patched executable 
 file
  profiled_a.out
 . The original executable remains unchanged; however, invoking 
 the patched executable gathers profiling information and dumps this information to the
  
 file
  profiled_a.out.prof
 . The
  .prof
  file can then be displayed in various 
 formats with the help of the
  c.report
  program.
  
 Many other options are available for profiling executables using
  c.analyze
 . Refer to the 
 online man pages for more information about
  c.analyze
  and
  c.report
 .
  
 4-7",NA
c.build,"Program Development Environment Utilities
  
 4
  
 Compile and link as necessary to build a unit, partition or environ-
 ment 
  
 The syntax of the
  c.build
  command is:
  
  
 c.build [
 options
 ] [
 partition
  ...] 
  
 The following represents the
  c.build
  options:
  
 Option
  
 Meaning
  
 Function
  
 -allparts
  
 all partitions
  
 Build all partitions in the environment. This option is not allowed if the
  
 -o
  option is specified.
  
 -C
  
 “
 compiler
 ”
  
 compiler
  
 Use
  compiler
  to compile units (may be used to pass options to the com-
  
 piler, e.g.
  c.build -C “c.compile -v”
 )
  
 -e[e|l|v]
  
 error
  
 Pipe compiler output through
  c.error
 :
  
 -e 
 lists errors to stdout;
  
 -ee 
 embeds errors in the source file and invokes
  $EDITOR
 ;
  
 -el 
 lists errors with the source file to
  stdout
 ; and
  
 -ev 
  
 embeds errors in the source file and invokes
  vi
 .
  
 -
 env
  
 env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -i
  
 infos
  
 Suppress
  c.build
  information messages
  
 -L“
 linker
 ”
  
 linker
  
 Use “
 linker
 ” to link partitions (may be used to pass options to the
  
 c.link
 )
  
 -link
  
 link only
  
 Link an non-archive without updating any dependant partition. For inter-
  
 nal use only.
  
 -noimport
  
 no import
  
 Don’t naturalize foreign units that are not up to date. Generates an error
  
 instead.
  
 -nomake
  
 no make
  
 Don’t invoke make command to build source file. Use whatever version
  
 of the source that is already built.
  
 -nosource
  
 no source
  
 Skip checks of the source timestamps for out-of-date units (should only be
  
 used if no source files have changed)
  
 -o file
  
 output
  
 Override the output file for the partition being built. Only a single parti-
  
 tion file name is allowed with this option.
  
 -P“
 prelinker
 ”
  
 prelinker
  
 Use
  “prelinker”
  to prelink partitions (may be used to pass options to
  
 c.prelink
 ).
  
 -part
  partition
  
 partition
  
 Build the given
  partition
 , all included units and all units upon which they
  
 directly or indirectly depend
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 4-9",NA
c.cat,"c.cat
  
 4
  
 Output the source of a unit
  
 The syntax of the
  c.cat
  command is:
  
 c.cat [
 options
 ]
  unit-id
  
 The following represents the
  c.cat
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -h
  
 no header
  
 Does not output filename header
  
 -l
  
 line numbers
  
 Prepend each line of source with its line number
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 unit-id
  is defined by the following syntax:
  
 unit
  
 ie,
  all
  may not be specified as a unit name.
  
 The
  c.cat
  command is similar to the UNIX
  cat(1)
  command in functionality. It 
 accepts as its argument a
  unit_id
  and prints to
  stdout
  the source file in which this unit is 
 found.
  
 By default, it outputs a header containing the full path name of the source file. This can be
  
 suppressed by specifying the
  -h
  option.
  
 Also, line numbers can be prepended to each line of source by using the
  -l
  option.
  
 4-12",NA
c.chmod,"Program Development Environment Utilities
  
 4
  
 Modify the UNIX file system permissions of an environment 
 The syntax of the
  c.chmod
  command is:
  
 c.chmod [
 options
 ]
  access_mode
  
 The following represents the
  c.chmod
  options:
  
 Option
  
 Meaning
  
 Function
  
 -a
  
 all
  
 In addition to internal environment files, change the permissions of all
  
 files associated with the environment, including source files and partition
  
 -env
  env
  
 environment
  
 targets
  
 Specify an environment pathname
  
 -f
  
 force
  
 Force, if some environment components are missing
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -i
  
 ignore
  
 Quietly ignore all non-fatal errors
  
 -include
  
 #include 
 files
  
 Change permissions on primary source files and any files they
  #include 
 (except system include files). Units built from the primary source file
  
 -p
  
 must have been compiled in order for the environment to have discovered
  
 what files were
  #include
 d.
  
 partitions
  
 Change permissions on partitions in the environment
  
 -q
  
 query
  
 Display the permissions on the current environment
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -s
  
 source
  
 Change permissions on primary source files (see also
  -include
 ).
  
 access_mode
  is the permissions as would be specified using the
  chmod(1)
  command
  
 (q.v.).
  
 4-13",NA
c.compile,"c.compile
  
 4
  
 Compile one or more units
  
 INTERNAL UTILITY 
  
 This tool is used internally by
  c.build
  which is the recommended 
 utility for compilation and program generation.
  
 c.compile
  is not intended for general usage.
  
 The syntax of the
  c.compile
  command is:
  
 c.compile [
 options
 ] [--] [
 compile_options
 ] [
 unit-id
  ...]
  
 The following represents the
  c.compile
  options:
  
 Option
  
 Meaning
  
 Function
  
 -e[e|l|v]
  
 error
  
 Pipe compiler output through
  c.error
 :
  
 -e 
 lists errors to stdout;
  
 -ee 
 embeds errors in the source file and invokes
  $EDITOR
 ;
  
 -el 
 lists errors with the source file to
  stdout
 ; and
  
 -ev 
 embeds errors in the source file and invokes
  vi
 .
  
 -env
  env
  
 environment
  
 Specify an environment pathname, default is $PWD
  
 help
  
 Display syntax and options for this function
  
 -H
  
 help compile
  
 Display list of compile options
  
 -HC
  
 help qualifier
  
 Display list of qualifier keywords (
 -Q
  options)
  
 -HQ
  
 language
  
 -language
  lang
  
 Select
  C
  or
  C++
  as language (
 lang
 ) to be used.
  
 partition
  
 -partition
  part
  
 Let compiler know which partition is being built for template instantiation
  
 purposes (not necessary, but it lets the compiler make better automatic
  
 -quiet
  
 quiet options
  
 decisions)
  
 Suppress display of effective options
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 state
  
 Compile the specified unit to compilation state
  s
 .
  
 -state
  s
  
 verbose
  
 Print header for each compilation
  
 -v
  
 very verbose
  
 Print subordinate tool invocations
  
 -vv
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 4-14",NA
c.demangle,"c.demangle
  
 4
  
 Output the source form of a unit name
  
 The syntax of the
  c.demangle
  command is:
  
 c.demangle [
 options
 ]
  
 The following represents the
  c.demangle
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 The
  c.demangle
  utility is a filter that accepts mangled Concurrent C++ symbol names, 
 such as those found in a C++ object file, and returns C++ unit names in expanded form. It
  
 reads text from
  stdin
 , transforms anything that looks like a mangled name and writes the 
 result to
  stdout
 . It is useful for processing the output from utilities such as
  nm(1)
 , 
 dump(1)
 , etc.
  
 4-16",NA
c.edit,"Program Development Environment Utilities
  
 4
  
 Edit the source of a unit 
  
 The syntax of the
  c.edit
  command is:
  
  
 c.edit [
 options
 ]
  unit-id 
  
 The following represents the
  c.edit
  options:
  
 Option
  
  
 Meaning
  
 Function
  
 -e
  editor
  
 [
 options
 ]
  
 editor
  
 Use
  editor
  instead of
  $EDITOR
  
 environ-
  
 Specify an environment pathname
  
 -env
  env
  
 ment
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -i
  
 inhibit
  
 Do not immediately notify the environment that the unit has changed
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -src “
 dir 
 %f”
  
 source
  
 Run pre- and post-edit scripts for interfacing with source manage-
  
 management
  
 ment.
  
 -v
  
 verbose
  
 Generate verbose output.
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 4-17",NA
c.error,"c.error
  
 4
  
 Process diagnostic messages generated by the compiler and other tools
  
 INTERNAL UTILITY 
  
 This tool is used internally by
  c.build
  which is the recommended 
 utility for compilation and program generation.
  
 c.error
  is not intended for general usage.
  
 The syntax of the
  c.error
  command is:
  
  
 c.error [
 options
 ] 
  
 The following represents the
  c.error
  options:
  
 Option
  
 Meaning
  
 Function
  
 -e [
 editor
 ]
  
 editor
  
 Embed error messages in the source file and invoke the specified
  edi-
  
 tor
 . The default editor is
  $EDITOR
 .
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 source file
  
 Restrict errors to those in specified source file
  
 -f
  file
  
 help
  
 Display syntax and options for this function
  
 -H
  
 listing
  
 Produce listing to
  stdout
  
 -l
  
 no line #’s
  
 -N
  
 Do not display line numbers
  
 order
  
 Do not sort the order of the diagnostics by file and line number; pro-
  
 -o
  
 cess each diagnostic in the order given
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 suppress
  
 Suppress non-error lines
  
 -s
  
 source man-
  
 Run pre- and post-edit scripts for interfacing with source manage-
  
 -src 
 %f”
  
 “
 dir
  [
 options
 ]
  
 agement
  
 ment.
  
 vi
  
 Embed error messages in the source file and invoke the
  vi
  editor
  
 -vi
  
 -W
  
 warnings
  
 Ignore warnings
  
 Compiler output may be redirected into a file and examined with the aid of the
  c.error
  
 command or can be piped directly into
  c.error
  via the
  -e
  option to
  c.build
 .
  
 c.error
  reads the specified file or the standard input, determining the source file(s) con-
  
 taining errors and processing the errors according to the options given.
  
 4-18",NA
c.expel,"c.expel
  
 4
  
 Expel fetched or naturalized units from the environment
  
 The syntax of the
  c.expel
  command is:
  
 c.expel [
 options
 ]
  unit-id
  ...
  
 The following represents the
  c.expel
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 verbose
  
 Print message for each expelled unit
  
 -v
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 Local versions of foreign units may be created via the
  c.fetch
  tool (see “c.rmsrc” on 
 page 4-65). These versions are called
  fetched
 . (See “Nationalities” on page 3-4 for a more 
 detailed discussion.)
  
 It may be desirable to later remove these local versions, thus making the foreign versions 
 once again visible. The
  c.expel
  tool is provided for this purpose.
  
 NOTE
  
 Other methods exist for removing native units. See 
 Section“c.rmsrc” on page 4-65 for more information.
  
 4-22",NA
c.features,"Program Development Environment Utilities
  
 4
  
 Indicate features of current release
  
 INTERNAL UTILITY 
 This tool is used internally by
  NightBench
 . 
 c.features
  is not intended for general usage.
  
 The syntax of the
  c.features
  command is:
  
  
 c.features [
 options
 ] 
  
 The following represents the
  c.features
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname, default is $PWD
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 The
  c.features
  command outputs a list of features added or altered since the initial
  
 release. This is so NightBench can tailor its graphical interface to the release of tools
  
 being used without having to be congizant of specific release names.
  
 4-23",NA
c.fetch,"c.fetch
  
 4
  
 Fetch the compiled form of a unit from another environment
  
 The syntax of the
  c.fetch
  command is:
  
 c.fetch [
 options
 ]
  unit-id
  ...
  
 The following represents the
  c.fetch
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -from
  env
  
 from env
  
 Specify an environment pathname from which to fetch the unit(s)
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -v
  
 verbose
  
 Display a message for each fetched unit
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 NOTE
  
 If the
  -from
  option is not specified,
  c.fetch
  will try to 
 “find”the specified unit by searching the Environment Search Path.
  
 At times, it may be desirable for users to be able to force copies of specified units from
  
 other environments into the current environment. This command will cause the specified
  
 foreign units to be built in the local environment as if they were introduced as local units.
  
 The
  c.expel
  tool is provided to allow a fetched unit to be removed from the local 
 environment, thus restoring visibility to the foreign version. See “c.expel” on page 4-22.
  
 4-24",NA
c.freeze,"Program Development Environment Utilities
  
 4
  
 Freeze an environment, preventing changes
  
 The syntax of the
  c.freeze
  command is:
  
 c.freeze [
 options
 ]
  
 The following represents the
  c.freeze
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 query
  
 Displays an environment’s frozen status
  
 -q
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 transitive
  
 Freeze whole Environment Search Path
  
 -t
  
 unfreeze
  
 Thaw the environment, allowing changes
  
 -u
  
 verbose
  
 Displays the environment(s) being frozen (or thawed)
  
 -v
  
 An environment may be frozen using the
  c.freeze
  utility. This changes an environ-
 ment so that it is unalterable.
  
 Any environment which will not be changed for a significant period of time and which will 
 be used by other environments is a good candidate to be frozen to improve compila-tion 
 performance.
  
 4-25",NA
c.grep,"c.grep
  
 4
  
 Grep the introduced source in an environment 
  
 The syntax of the
  c.grep
  command is:
  
 c.grep [
 options
 ]
  expression
  [
 pattern
 ]
  
 The following represents the
  c.grep
  options:
  
 Option
  
 Meaning
  
 Function
  
 -b
  
 block number
  
 Precede each line with block number on which
  expression
  was found
  
 count
  
 Print only count of lines on which
  expression
  was found
  
 -c
  
 Expression
  
 Treat all specified expressions in
  expression
  and
  exprfile
  as full regu-
  
 -E
  
 lar expressions. See
  egrep(1)
  for an explanation of full regular 
 expressions
  
 -e
  expression
  
 expression
  
 Specify regular expression or strings in the command line
  
 environment
  
 Specify an environment pathname
  
 -env
  env
  
 file
  
 Treat all specified expressions in
  expression
  and
  exprfile
  as character
  
 -F
  
 strings. This is the same as invoking
  fgrep(1)
  
 -f
  exprfile
  
 Specify file containing
  expression
 s, one per line
  
 help
  
 Display syntax and options for this function
  
 -H
  
 ignore
  
 Ignore case distinction when matching
  
 -i
  
 list files
  
 List names of flies with matching lines, one per line
  
 -l
  
 number lines
  
 Precede each line by line number in the file
  
 -n
  
 no include
  
 Exclude
  #include
  files
  
 -no_include
  
 no /usr include
  
 Exclude
  #include
  files with paths beginning with
  /usr
  
 -no_usr_include
  
 partitions
  
 -plist
  list
  
 Specify a list of partitions whose source is searched
  
 quiet
  
 Do not write any matches to stdout, but exit with zero status if any
  
 -q
  
 input line matched.
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 suppress
  
 Suppress error messages about nonexistent or unreadable files
  
 -s
  
 sources
  
 Specify a list of source files to search
  
 -slist
  list
  
 transitive
  
 Include dependendant partitions when searching the source of a parti-
  
 -t
  
 tion. Requires that the
  -plist
  option be used.
  
 -ulist
  list
  
 units
  
 Specify a list of units whose source is searched
  
 Print all lines except those which match
  expression
  
 -v
  
 Print only matches for which
  expression
  matches the entire line.
  
 -x
  
 4-26",NA
c.help,"c.help
  
 4
  
 List usage and summary of each Concurrent C/C++ 
 utility 
 The syntax of the
  c.help
  command is:
  
 c.help
  
 4-28",NA
c.install,"Program Development Environment Utilities
  
 4
  
 Install, remove, or modify a release installation 
  
 The syntax of the
  c.install
  command is:
  
 c.install -rel
  release
  [
 options
 ]
  
 The following options are available with the
  c.install
  command:
  
 Option
  
 Meaning
  
 Function
  
 -arch
  arch
  
 default arch
  
 Set the default architecture (nh, moto, synergy, etc.) being targeted. Cur-
  
 rently only valid under the PLDE, although a future PowerMAX OS
  
 -d
  
 default
  
 release may support cross compilation.
  
 Mark the selected release installation as the system-wide default
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -i
  path
  
 install
  
 Install the release located at
  path
  into the release database (the name is
  
 determined from the
  -rel
  option)
  
 -m
  path
  
 move
  
 Move the selected release installation to
  path
  
 -osversion 
 osversion
  
 default os
  
 Set the default version of PowerMAX OS being targeted. Currently only
  
 version
  
 valid under the PLDE, although a future PowerMAX OS release may sup-
  
 port cross compilation.
  
 -p
  
 pre-5.1
  
 Mark the selected release isntallation as the default for
  cc
 ,
  hc
 ,
  cc++
 , 
 and 
 c++
 .
  
 -r
  
 remove
  
 Remove the specified release installation from the release database
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (REQUIRED)
  
 -target
  cpu
  
 default cpu
  
 Set the default
  cpu
  being targeted. Defaults to the native cpu under Pow-
  
 erMAX OS. A default must be set under PLDE.
  
 -v
  
 verbose
  
 Report changes as they are made
  
 NOTE
  
 Only the System Administrator (or a super user) can invoke
  
 c.install.
  
 The
  -i
 ,
  -m
 , and
  -r
  options may never be used together.
  
 The
  c.install
  utility is the tool that allows users to register installations with the sys-
  
 tem’s Concurrent C/C++ database. It may be used to install, move, and remove installa-
  
 tions.
  
 4-29",NA
c.instantiation,"Program Development Environment Utilities
  
 4
  
 Manipulate instantiation of templates and extern inlines. 
 The syntax of the
  c.instantiation
  command is:
  
  
 c.instantiation [
 options
 ] [
 unit-id
 ] 
  
 The following represents the
  c.instantiation
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -F
  
 force
  
 Force unit-id to exist. Used to setup template resolutions before any files
  
 are compiled, usually via the
  c.script
  command.
  
 -f
  
 force
  
 If the unit in the -r option is not in the potential associated units list, force
  
 it to be added anyway (otherwise an error is generated)
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -hide “
 unit-list
 ”
  
 hide
  
 Hide specified normal units from being considered for resolving instantia-
  
 tion requests
  
 -!hide
  
 “
 unit-list
 ”
  
 unhide
  
 Unhide specified normal units so they may be considered for resolving
  
 instantiation requests
  
 -l
  
 list
  
 List the potential and actual associated units of unit-id
  
 -
 magnet“
 uni
 t-list
 ”
  
 magnet
  
 Designate specified units as magnets. This means that instantiation auto-
  
 mation will prefer them over other units for hosting artificial units for
  
 template and extern inline instantiation.
  
 -
 !magnet“
 uni
 t-list
 ”
  
 unmagnet
  
 Remove magnet designation. Specified units will be consider for resolv-
  
 ing instantiation only if no magnetic unit can perform the resolution.
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -
 resolve“
 uni
 t-list
 ”
  
 resolve
  
 Add specified units to the list of units that will host the instantiation of
  
 unit-id
 .
  
 -
 !resolve“
 u
 nit-list
 ”
  
 unresolve
  
 Remove specified units from the list of units that will host the instantia-
  
 tion of
  unit-id
 .
  
 -v
  
 verbose
  
 Display a message for each selected or hidden definition
  
 unit-list
  is a comma or white space list of
  unit-id
 s. The list must be enclosed in quotes if
  
 more than one unit is specified.
  
 unit-id
  is defined by the following syntax:
  
 unit
  
 See “Unit Identification” on page 3-4 for more information about the
  unit-id
 .
  
 4-31",NA
c.intro,"c.intro
  
 4
  
 Introduce source files (and units therein) to the environment
  
 The syntax of the
  c.intro
  command is:
  
 c.intro [
 options
 ] [
 source_file
  ...]
  
 The following represents the
  c.intro
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -language [C|C++]
  
 language
  
 Specify whether the source file is written in
  C
  or
  C++
  
 -make “
 command
 ”
  
 make
  
 Specify a command for
  c.build
  to run before checking the times-
 tamp on the introduced source file. Typically, this command will be a
  
 command
  
 -o
  path
  
 “
 make
  source_file
 ” command to create a machine-generated source 
 file.
  
 output
  
 Specify the path to the object file where the unit will be compiled to.
  
 Normally this is
  .c++/.units/
 unitname
 .o
 . This option is intended 
 for internal use. Users should generally avoid it.
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -s
  file_list
  
 file list
  
 Read
  file_list
  for a list of files to process
  
 If - is specified, read file list from
  stdin
  
 -unit
  name
  
 unit name
  
 Override the default unit name for the source file. This allows the
  
 same source file to be introduced multiple times (to be built in more
  
 -v
  
 verbose
  
 than one way), or to introduce two source files that share the same
  
 basename, but have different paths.
  
 Echo files as they are processed
  
 The
  -s
  option takes as its argument a
  file_list
  containing the names of all the files to be 
 processed by
  c.intro
 . This is useful in order to introduce many files at once. Each file 
 must be on a separate line in the
  file_list
 .
  
 If
  -
  is specified for
  file_list
 ,
  c.intro
  uses input from
  stdin
 . This is provided mainly 
 so that users can pipe output from another UNIX command to
  c.intro
 .
  
 Since the unit name
  all
  is reserved to mean all units in various commands, if a file called 
 all.c
  is introduced, its default unit name is
  _all
 , and if a file called
  _all.c
  is intro-
 duced, its default unit name is
  __all
 , etc.
  
 To reference a foreign unit that hasn’t actually be introduced into a foreign environment
  
 on the environment search path yet, use “
 c.intro -name
  name
 ” without specifying a 
 source file. This declares the name to the local environment so that you can refer to the
  
 name without getting an error message. This isn’t necessary if the foreign unit has already
  
 4-32",NA
c.invalid,"c.invalid
  
 4
  
 Force a unit to be inconsistent thus requiring it to be recompiled
  
 The syntax of the
  c.invalid
  command is:
  
 c.invalid [
 options
 ] [
 unit-id
  ...]
  
 The following represents the
  c.invalid
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -source
  file
  
 source file
  
 Invalidate all units built from the specified file
  
 -t
  
 template
  
 Erase template instantiation associations
  
 -v
  
 verbose
  
 Display a message for each invalidated unit
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 The
  c.invalid
  tool is used to force a unit to be considered inconsistent, usually to force 
 them to be rebuilt by
  c.build
 . If the
  -t
  option is also specified, template instantiation 
 automation will forget the associates it made between the specified units and any instanti-
  
 atable entities (such as templates or extern inlines) that it decided to build using this unit’s
  
 source, but not those made explicitly by the user. See “Template Instantiation” on page
  
 6-3 and “c.instantiation” on page 4-31.
  
 The
  c.touch
  tool is provided to allow the opposite functionality. See “c.touch” on page 
 4-69.
  
 4-34",NA
c.link,"Program Development Environment Utilities
  
 4
  
 Link a partition (an executable, or shared object file)
  
 INTERNAL UTILITY 
  
 This tool is used internally by
  c.build
  which is the recommended 
 utility for compilation and program generation.
  
 c.link
  is not intended for general usage.
  
 The syntax of the
  c.link
  command is:
  
 c.link [
 options
 ] [
 link-options
 ]
  partitions
  ...
  
 The following represents the
  c.link
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 information
  
 Suppress information messages
  
 -i
  
 output
  
 Override the default output for the partition and place the output in
  file
  
 -o
  file
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 verify
  
 Display the link commands, suppressing execution
  
 -V
  
 verbose
  
 Display links as they are done
  
 -v
  
 very verbose
  
 Display the link commands before execution
  
 -vv
  
 warnings
  
 Suppress warning messages
  
 -w
  
 See “Link Options” on page 4-70 for list of link options.
  
 4-35",NA
c.ls,"c.ls
  
 4
  
 List information about the environment 
  
 The syntax of the
  c.ls
  command is:
  
 c.ls [
 options
 ]
  
 The following represents the
  c.ls
  options:
  
 Option
  
 Meaning
  
 Function
  
 -A
  
 all
  
 Dump information about everything information can be dumped: sets
  
 -E
 ,
  -S
 ,
  -U
 ,
  -T
 , and
  -P
 .
  
 -all
  
 all
  
 Include information from all environments on the Environment Search
  
 Path.
  
 -art
  
 artificial
  
 Include artificial units (those created by the environment to support
  
 templates and extern inlines)
  
 -E
  
 environment
  
 List attributes of the local environment
  
 -e
  
 everything
  
 Provide an all-encompassing listing using the same format as the
  -l 
 and
  -v
  options, but omitting nothing that may be known. Often gener-
 ates an overwhelming amount of output.
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -format
  fmt
  
 format
  
 Format the information supplied for each unit based on the format
  
 descriptor
  fmt.
  This option may not be used with any option that dis-
  
 -format help
  
 format help
  
 plays information about the environment other than units.
  
 Display list of format descriptors
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -h
  
 headers
  
 Suppress headers on long and verbose listings
  
 -instantiation
  
 instantiation
  
 Display instantiation information
  
 -l
  
 long
  
 List the same information as the
  -1
  option, but use a long format.
  
 -local
  
 local
  
 Filter candidate units and partitions to include only those found in the
  
 local environment (default)
  
 -N
  
 name
  
 Sort lists by name in ascending order
  
 -n
  
 number
  
 Include a total count of the number of units, partitions, etc.
  
 -P
  
 partition
  
 List information about all partitions. Use
  -all
  or
  -local
  to include 
 partitions in all environments on the environment search path or restrict
  
 -plist “
 list
 ”
  
 partition
  
 to local partitions only.
  
 List information about specific partitions.
  list
  is a list of partitions sepa-
  
 rated by commas or spaces. It is a single parameter, and so must be
  
 enclosed in double-quotes if more than one partition is specified. Mul-
  
 tiple
  -plist
  options may be specified on the command line.
  
 4-36",NA
Formatting the listing,"Program Development Environment Utilities
  
 4
  
 The
  -format
  option to
  c.ls
  allows you to format the information listed for each unit 
 based on a format descriptor,
  fmt
 , which takes the form:
  
 “%[Modifier]Descriptor random_text %[Modifier]Descriptor...” ...
  
 Characters encountered in the quoted format string which are not part of a descriptor are 
 echoed in the output. Any character other than ‘a’..’z’ and ‘_’ serve to terminate the cur-
 rent descriptor; any such characters are echoed.
  
 4-39",NA
Sorting,"$ c.ls -format “%name was built on %date\n”
  
 4
  
 hello was introduced on Mon Dec
  
 6 15:49:58 1999
  
 There are a few options to
  c.ls
  with which to sort the output. They are:
  
 -
 N
  
 -
 t
  
 -
 r
  
 Sort by name in ascending order 
 Sort by timestamp 
  
 Reverse the sorting order
  
 4-41",NA
c.lssrc,"c.lssrc
  
 4
  
 List source files associated with the environment
  
 The syntax of the
  c.lssrc
  command is:
  
 c.lssrc [
 options
 ] [
 source-file
 ]
  
 The following represents the
  c.lssrc
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 -H
  
 -rel
  
 release
 -s
  
 file_list
  
 -vv
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 file_list
  
 Read
  file_list
  for a list of files
  
 very verbose
  
 Display command lines used to invoke subordinate tools
  
  
 c.lssrc
  provides information about source files introduced to the environment. The 
 information available via this tool is specific only to the source file. For information about
  
 units contained within the source file, the
  c.ls
  tool should be used. 
 4-39 for more information.
  
 See “c.ls” on page
  
 With no options,
  c.lssrc
  provides a list of the names of all source files introduced to 
 the environment. If a
  source-file
  name is specified on the command line or the
  -s
  option 
 is used with a file containing a list of source file names, only the mentioned source files 
 will
  
 be listed.
  
 4-42",NA
c.make,"Program Development Environment Utilities
  
 4
  
 Create a make file for building the partitions of an environment
  
 The syntax of the
  c.make
  command is:
  
 c.make [
 options
 ]
  
 The following represents the
  c.make
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -ii
  
 ii file
  
 Create
  filename
 .ii targets for template instantiation.
  
 -no_include
  
 #include
  
 Omit
  #include
  files from the units’ dependency lists
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 -usr_include
  
 /usr/include
  
 Include system
  #include
  files from the units’ dependency lists.
  
 c.make
  writes a makefile to
  stdout
  for building the partitions local to a particular envi-
 ronment. This is useful for porting to systems not targeted by Concurrent’s Program 
 Development Environment.
  
 The generated makefile creates several symbols at the head to assist the user in porting the 
 makefile to other systems:
  
 EC 
  
 CFLAGS
  
 ECPP 
  
 CPPFLAGS 
  
 OBJ
  
 The C compiler to use. Defaults to
  /usr/ccs/bin/ec
  
 Options to pass to the C compiler. Empty by default. Each individ-ual 
 compile has its effective options in its own target.
  
 The C++ compiler to use. Defaults to
  /usr/ccs/bin/ec++
  
 Options to pass to the C++ compiler. Empty by default.
  
 The directory where unit’s object files will be placed. Defaults to 
 .c++/.units
  by default.
  
 The target
  all
  is output next. This target builds all the partitions.
  
 The targets for the units are output next. If the unit has been compiled in the environment, 
 then the full list of
  #include
  files are known. These are output into the dependency list. 
 The
  #include
  files may be omitted from the dependency list with the
  -no_include 
 option. Alternatively, system
  #include
  files (those whose 
  
 path starts with
  
 /usr/
 ), may be included in the dependency list with the
  -usr_include
  option.
  
 If automatic instantiation is used and instantiations have been assigned to a unit in the 
 environment, either manually or by the environments automatic mechanism, then the make 
 target for a unit can also set up a
  .ii
  file so that the the same instantiations are
  
 4-43",NA
-,".ii
  files use “mangled” names. Thus they may not be compatible
  
 between different versions of the compiler.",NA
-,"Other vendors’ compilers will not use the same mechanism (unless they are 
 based on the same version of the Edison Design Group’s front end and
  
 haven’t made changes to name mangling themselves).",NA
-,"Changes to source may result in changes to the instantiation assignments. The 
 non-PDE instantiation automation is not as flexibile as PDE automa-
  
 tion, so as further recompilations alter the
  .ii
  files, some templates (or 
 other instantiatable entities) may not longer get instantiated properly.
  
 Targets for each local partition are output last.
  
 4-44",NA
c.man,"Program Development Environment Utilities
  
 4
  
 Invoke/position interactive help system (requires an X
 TM
 terminal)
  
 The syntax of the
  c.man
  command is:
  
 c.man [
 options
 ] [
  manual
  [
 topic
 ] ]
  
 The following represents the
  c.man
  options:
  
 Option
  
 Meaning
  
 Function
  
 -display
  disp
  
 X display
  
 Select an X terminal
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -l
  
 list
  
 Lists available online manuals
  
 -man
  manpage
  
 man page
  
 Display
  man
  page for specified
  manpage
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -H
  
 help
  
 Display syntax and options for this function
  
 c.man
  invokes the interactive HyperHelp
 TM
 system as directed by options and arguments. 
 If a HyperHelp session for the user is already active,
  c.man
  will position the existing ses-
 sion to the specified topic or manual.
  
 To see a list of the names of each online
  manual
  available for viewing with HyperHelp,
  
 issue:
  
 $
  c.man -l
  
 To open a specific
  manual
 , issue
  c.man
  with the name of that
  manual
 :
  
 $
  c.man c++.LAG
  
 NOTE
  
 The manual
  c++.LAG
  points to the latest-and-greatest version of 
 the
  Concurrent C/C++ Reference Manual
 .
  
 If the manual is not recognized (and is not interpreted as a
  topic
 ), then HyperHelp is
  
 opened to the Bookshelf.
  
 4-45",NA
c.mkenv,"Program Development Environment Utilities
  
 4
  
 Create an environment which is required for compilation, linking, etc.
  
 The syntax of the
  c.mkenv
  command is:
  
 c.mkenv [
 options
 ] [--] [
 compile_options
 ] [
 environment
 _
 pathname
 ]
  
 The following represents the
  c.mkenv
  options:
  
 Option
  
 Meaning
  
 Function
  
 -arch
  arch
  
 architecture
  
 Add
  -arch
  to both the environment-wide default link options and 
 the environment-wide default compile options.
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -f
  
 force
  
 Force environment creation even if it or some portion of it already
  
 exists
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -language
  lang
  
 language
  
 Select
  C
  or
  C++
  as language (
 lang
 ) to be used as the default in 
 c.intro
  invocations.
  
 -oset “
 options
 ”
  
 link options
  
 Set the environment-wide default link options.
  
 -osversion
  osversion
  
 OS version
  
 Add
  -osversion
  to both the environment-wide default link 
 options and the environment-wide default compile options.
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -src 
 %f”
  
 “
 dir
  [
 options
 ]
  
 source
  
 Run pre- and post-edit scripts for interfacing with source manage-
  
 management
  
 ment whenever file is edited with
  c.edit
 .
  
 The
  compile_options
  specified with this command become the permanent environ-ment-
 wide compile options and apply to all units introduced into this environment. They may be 
 changed by using
  c.options
 . They may also be overridden by temporary envi-ronment-
 wide compile options, or for particular units by permanent or temporary unit options or 
 pragmas. See “Compile Options” on page 3-9 for a more detailed explanation of this 
 relationship.
  
 The
  -f
  option forces creation of an environment even if one has already been created or if 
 only a portion of it already exists. If the
  c.mkenv
  tool is interrupted or fails for some rea-
 son (such as not enough disk space, power failure, etc.), the creation of the environment 
 may not have completed. Trying to recover from this failure by running the
  c.mkenv 
 tool again may result in a message similar to the following:
  
 c.mkenv: database file .C++ already exists 
  
 in environment /some_dir/env_dir.
  
 The
  -f
  option will force this environment to be created, thereby overriding such error 
 messages.
  
 4-47",NA
c.options,"Program Development Environment Utilities
  
 4
  
 Set compilation options for units or the environment 
 The syntax of the
  c.options
  command is:
  
 c.options [
 options
 ] [--] [
 compile_options
 ] [
 unit-id
  ...]
  
 The following represents the
  c.options
  options:
  
 Option
  
 Meaning
  
 Function
  
 -clear
  
 clear
  
 Clear all designated options for the specified entities
  
 default
  
 Operate on the default options for the entire environment
  
 -default
  
 delete
  
 Delete the designated options from the specified entities
  
 -del
  
 effective
  
 Display the effective options (based on temporary, permanent,
  
 -eff
  
 environment defaults)
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 header
  
 Remove the header from the option list output
  
 -h
  
 help compile
  
 Display list of compile options
  
 -HC
  
 help qualifier
  
 Display list of qualifier keywords (
 -Q
  options)
  
 -HQ
  
 keep temporar-
  
 -keeptemp
  
 Propagate the temporary options for the units into the set of perma-
  
 ies
  
 nent options
  
 -language
  lang
  
 language
  
 Select
  C
  or
  C++
  as language to be used
  
 list
  
 -list
  
 List the option sets for the specified entities
  
 make
  
 Change the make command associated with the primary source file
  
 -make “
 command
 ”
  
 of the specified units.
  
 -mod
  
 modify
  
 Modify the designated options for the specified entities
  
 permanent
  
 Operate on the permanent options (this is the default)
  
 -perm
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 set
  
 Set the designated options for the specified entities
  
 -set
  
 source file
  
 Change options on units built from specified primary source file.
  
 -source
  file
  
 Most commonly used with
  -make
  option.
  
 -src 
 %f”
  
 “
 dir
  [
 options
 ]
  
 source
  
 Specify pre- and post-edit scripts for interfacing with source man-
  
 management
  
 agement when editing source files with
  c.edit
 .
  
 temporary
  
 -temp
  
 Operate on the temporary options
  
 verbose
  
 Display a message for each change
  
 -v
  
 separator
  
 Separate options to
  c.options
  from compiler options. Optional if 
 there is no ambiguity.
  
 --
  
 4-49",NA
Option Sets ,"4
  
 As discussed in “Compile Options” on page 3-9, there are different levels of options in 
 Concurrent C/C++. These option sets are designated by the following flags to 
 c.options
 :
  
 Flag
  
 Designation
  
 Operates on
  
 -default -perm
  
 environment-wide compile options
  
 all units
  
 -default -temp
  
 temporary environment-wide com-
  
 all units
  
 pile options.
  
 -perm
  
 permanent compile options
  
 specified units
  
 -temp
  
 temporary compile options
  
 specified units
  
 In addition, the
  effective options
  are derived from these four and their hierarchical rela-
 tionship to one another. This set is discussed in greater detail in “Effective Options” on 
 page 3-11.",NA
Listing options ,"4
  
 The option sets may be viewed using the
  -list
  option to
  c.options
 . When issued 
 alone,
  -list
  shows the permanent, temporary, and effective option sets for the units 
 specified. For example, the following command lists those option sets for the unit
  hello
 ,
  
 $
  c.options -list hello
  
 By combining the
  -list
  option and the desired option set’s flag, only that option set is 
 displayed for the specified units. For instance, to view the permanent options for the unit 
 hello
 ,
  
 $
  c.options -list -perm hello
  
 This only lists the permanent options for the units specified. You may specify multiple unit 
 names, or you may use the keyword
  all
  to specify all units in the environment.
  
 To list the effective options for all units in the environment,
  
 $
  c.options -list -eff all
  
 However, this particular option does the same thing when issued alone,
  
 $
  c.options -eff all
  
 4-50",NA
Setting options ,"4
  
 The option sets may be initialized or reset by using the
  -set
  flag to
  c.options
 . This 
 sets the specified options for the units designated. Any previous options for the set desig-
  
 nated are replaced. For example,
  
 $
  c.options -set -perm -g hello
  
 turns on debug information in the permanent option set for the unit
  hello
 .
  
 If the following command is issued,
  
 $
  c.options -set -perm -O1 hello
  
 the permanent option set will only contain the
  -O1
  option (the previous
  -g
  option will 
 have been replaced).",NA
Modifying options ,"4
  
 In order to modify an option set, the
  -mod
  flag is used with
  c.options
 . This flag adds 
 the specified options to the designated set, while retaining any other options that existed in
  
 this grouping. For instance, after the following command,
  
 $
  c.options -set -temp -g hello
  
 the temporary option set for the unit
  hello
  consists of
  -g
 .
  
 To add an optimization compile option to this set,
  
 $
  c.options -mod -temp -O2 hello
  
 The temporary option set for
  hello
  now consists of
  -g
  and
  -O2
 .",NA
Clearing options ,"4
  
 All of the options may be cleared from a designated option set by using the
  -clear 
 option to
  c.options
 . To clear all of the temporary options from all units in the environ-
 ment,
  
 $
  c.options -clear -temp all
  
 4-51",NA
Deleting options,"c.options
  
 4
  
 Using the
  -del
  flag with
  c.options
  is more specific than using the
  -clear
  option 
 and allows specified options to be deleted from a particular option set.
  
 For example, if the environment-wide compile option set (
 -default
 ) contains
  -O2
 ,
 -
 !g
  and
  -S
 , the following command,
  
 $
  c.options -del -!g -default
  
 will remove the
  -!g
  option from the set and leave
  -O2
  and
  -S
  to remain as the environ-
 ment-wide compile options.
  
 Some sets of options are mutually exclusive because they effectively set an attribute to a
  
 particular value. For example,
  --early_tiebreaker
  and
  --late_tiebreaker
 . 
 Specifying one will remove the other from the effective option list. Similarly, specifying
  
 --!early_tiebreaker
  will actually remove any tiebreaker setting from the effective 
 options list.",NA
Keeping temporary options ,"4
  
 Temporary options may be propagated into the permanent set by using the
  -keeptemp 
 option to
  c.options
 . This moves the temporary options into the permanent option set 
 and clears the temporary set. The following command does this for all units in the envi-
  
 ronment,
  
 $
  c.options -keeptemp all
  
 See “Link Options” on page 4-70 for more information.
  
 Also, see the example of this in “What are my options?” on page 2-6.",NA
Setting options on foreign units ,"4
  
 Options for units in foreign environments cannot be changed using
  c.options
  in the 
 local environment. In order to change the options on a foreign unit, it must first be fetched
  
 (see “c.fetch” on page 4-24).
  
 4-52",NA
c.partition,"Program Development Environment Utilities
  
 4
  
 Define or display a partition for the linker
  
 The syntax of the
  c.partition
  command is:
  
 c.partition [
 options
 ] [
 partitions
  ...]
  
 The following represents the
  c.partition
  options:
  
 Option
  
 Meaning
  
 Function
  
 -a
  
 all
  
 Display all partitions in the environment
  
 (Normally, only those originating in the environment are displayed)
  
 -add ""
 units
 ""
  
 add
  
 Add
  units
  to the partitions while retaining previously added units
  
 units
  is a single parameter; the names of individual units should be comma-
 separated and enclosed in double quotes
  
 -addfile
  file
  
 add from file
  
 As
  -add
 , but reads units from
  file
  
 create
  
 -create
  kind
  
 Create the new named partitions as
  kind
  where
  kind
  could be
  
 executable
  (
 exe
 ),
  shared_object
  (
 so
 ),
  archive
  (
 ar
 ), or 
 object
  (
 obj
 ). See also discussion of
  shadow
  below.
  
 -default
  
 default link
  
 Direct
  -oappend
 ,
  -oprepend
 , and
  -oset
  to operate on the environ-
 ment-wide link options.
  
 options
  
 -del ""
 units
 ""
  
 delete
  
 Delete
  units
  from the partitions
  
 units
  is a single parameter; the names of individual units should be comma-
 separated and enclosed in double quotes
  
 -delfile
  file
  
 delete from file
  
 As
  -del
 , but reads units from
  file
  
 environment
  
 -env
  env
  
 Specify an environment pathname
  
 force
  
 Force creation of existing partitions and removal of nonexistent partitions
  
 -f
  
 help
  
 Display syntax and options for this function
  
 -H
  
 help link
  
 Display link options
  
 -HL
  
 list all
  
 Display all partitions and information about them
  
 -List
  
 list
  
 List all partition names
  
 -list
  
 output
  
 Set the name of the corresponding partition output file to be created
  
 -o
  file
  
 append link
  
 Appends the
  opts
  argument to the link option listing
  
 -oappend
  opts
  
 options
  
 opts
  is a single parameter; it must be enclosed in double quotes
  
 -oclear
  
 clear link
  
 Clear the link options
  
 options
  
 4-53",NA
Link Options ,"4
  
 Link options are specified for a particular partition by using the following options to 
 c.partition
 :
  
 -oset
  opts 
  
 Sets the link options as indicated by
  opts
  
 -oappend
  opts 
  
 Appends the
  opts
  argument to the link option listing
  
 -oprepend
  opts 
  
 Prepends the
  opts
  argument to the link option listing
  
 -oclear 
  
 Clears the link options
  
 opts
  is a single parameter containing one or more link options; it must be enclosed in dou-
 ble quotes.
  
 NOTE
  
 Be sure to specify the link options within the double quotes and 
 ensure that they are specified as listed on page 4-70. For example, 
 if the link option
  -bound
  is desired, the leading “
 -
 ” must be 
 specified as well.
  
 For example, to set the link options for the partition
  hello
  to include the link 
 options
 --strip
  and
  -udump
 :
  
 $ 
  
 c.partition -oset “--strip -udump” hello
  
 Issuing
  c.ls
  will show the link options for this partition:
  
 $
  
 c.ls -plist hello -v
  
 : native
  
 PARTITION: hello
  
 nationality
  
 kind
  
 : executable
  
 output file
  
 : hello
  
 link options
  
 : --strip -udump
  
 included units (+)
  
 :
  
 hello
  
 To append a link option to this set, use the
  -oappend
  option:
  
 $ 
  
 c.partition -oappend “-lm” hello
  
 4-55",NA
c.path,"Program Development Environment Utilities
  
 4
  
 Display or change the Environment Search Path for an environment
  
 The syntax of the
  c.path
  command is:
  
 c.path [
 options
 ]
  
 The following represents the
  c.path
  options:
  
 Option
  
 Meaning
  
 Function
  
 -A
  path
  
 append
  
 Append
  path
  to the end of the Environment Search Path
  
 append
  
 Append
  path1
  after
  path2
 . If
  path2
  is not specified, this option is identical
  
 -a
  path1
  [
 path2
 ]
  
 to the
  -A
  option
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 full path
  
 Display full environment pathnames
  
 -f
  
 help
  
 Display syntax and options for this function
  
 -H
  
 insert
  
 Insert
  path
  at the beginning of the Environment Search Path
  
 -I
  path
  
 insert
  
 Insert
  path1
  before
  path2
 . If
  path2
  is not specified, this option is identical
  
 -i
  path1
  [
 path2
 ]
  
 to the
  -I
  option
  
 -P
  
 purge
  
 Remove all paths in the Environment Search Path
  
 replace
  
 Replace
  path1
  with
  path2
  
 -R
  path1 path2
  
 remove
  
 Remove
  path
  from the Environment Search Path
  
 -r
  path
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 transitive
  
 Display transitive closure of environments in the Environment Search
  
 -t
  
 Path
  
 -v
  
 verbose
  
 If combined with any other
  c.path
  option, display the Environment 
 Search Path after the operation is complete
  
 -w
  
 warnings
  
 Suppress warning messages
  
 exclude
  
 Remove all but
  path
  from the Environment Search Path
  
 -x
  path
  
 Concurrent C/C++ uses the concept of an Environment Search Path to allow users to spec-
 ify that units and partitions from environments other than the current environment should 
 be made available in the current environment. See “Environment Search Path” on page 3-2 
 for a more complete discussion.
  
 4-57",NA
c.prelink,"c.prelink
  
 4
  
 Resolve transitive closure of included units and template instantiation
  
 before linking.
  
 INTERNAL UTILITY 
  
 This tool is used internally by
  c.build
  which is the recommended 
 utility for compilation and program generation.
  
 c.prelink
  is not intended for general usage.
  
 The syntax of the
  c.prelink
  command is:
  
 c.prelink [
 options
 ] [
 partitions
 ]
  
 The following represents the
  c.prelink
  options:
  
 Option
  
 Meaning
  
 Function
  
 -auto_instantiation
  
 automatically
  
 Instantiate any templates used by units in the partition (this is
  
 instantiate
  
 the default for executable partitions)
  
 -C “
 compiler
 ”
  
 compiler
  
 Specify alternate compiler when compiling template instantia-
  
 tions
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -noimport
  
 no import
  
 Suppress naturalization to resolve templates
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default
  
 release)
  
 -ufile
  file
  
 units from file
  
 Prelink a list of units as though they were a partition
  
 -ulist
  “
 list
 ”
  
 units from list
  
 Prelink a list of units as though they were a partition
  
 -v
  
 verbose
  
 Print header for each compilation
  
 -vv
  
 very verbose
  
 Print subordinate tool command lines
  
 This tool takes care of template instantiation automation, selection of units that are going to 
 be included in the final link, and other bookkeeping activities that must be performed 
 before actually linking a partition.
  
 4-58",NA
c.release,"Program Development Environment Utilities
  
 4
  
 Display release installation information
  
 The syntax of the
  c.release
  command is:
  
 c.release [
 options
 ]
  
 The following represents the
  c.release
  options:
  
 Option
  
 Meaning
  
 Function
  
 -arch
  arch
  
 default arch
  
 Set the user’s default architecture target (nh, mot, synergy, etc.)
  
 -e
  
 env
  
 Display the path of the selected environment
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -n
  
 name
  
 Display the name of the selected release
  
 -osversion
  osversion
  
 default os ver.
  
 Set the user’s default osversion target
  
 -p
  
 path
  
 Display the path to the selected release
  
 -q
  
 query
  
 Display the selected environment and release
  
 -r
  
 remove
  
 Remove the default release currently set for the invoking user
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release
  
 -S
  
 system default
  
 Specify system default release (ignoring user default,
  
 release
  
 PDE_RELEASE environment variable, etc.)
  
 -target
  
 default target
  
 Set user’s default target microprocessor
  
 -U
  
 user default
  
 Specify the user default release (ignoring system default, PDE
  
 release
  
 RELEASE environment variable, etc.)
  
 -u
  
 user
  
 Set the default release for the invoking user
  
 If invoked without options,
  c.release
  lists all available release installations on the cur-
 rent host. For example,
  
 $ 
  
 c.release
  
 provides output similar to the following (the native compiler will not output OS Version 
 and Architecture information since only the PLDE currently supports cross compilation to 
 multiple versions of PowerMAX OS and multiple Concurrent supported architectures):
  
 4-59",NA
c.report,"Program Development Environment Utilities
  
 4
  
 Generate profile reports in conjunction with
  c.analyze 
 -P 
 The syntax of the
  c.report
  command is:
  
 c.report [
 options
 ]
  executable_file
  [
 executable_file
 .prof]
  
 The following represents the
  c.report
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -v
  
 verbose
  
 Print invocations of subprocesses
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -a
  
 all
  
 List information from all individual runs even if
  -t
  option is on
  
 -b
  
 basic
  
 List basic block statistics
  
 -B
  num
  
 expensive
  
 List only the
  num
  most expensive basic blocks
  
 basic
  
 -B
  num%
  
 % time basic
  
 List only the basic blocks where the first
  num
 %
  of time was spent
  
 -c
  
 calls
  
 For each routine, list calls it makes
  
 -d
  rng
  
 data range
  
 Restrict range of data sets examined
  
 -f
  
 for each
  
 For each routine, list who calls it
  
 -i
  
 info
  
 List summary information for the whole run
  
 -l
  
 max
  
 Use max time instead of min time of basic block
  
 -M
  hz
  
 Mhz
  
 Specify assumed megahertz clock rate for computing wall time
  
 -m
  
 milliseconds
  
 Print milliseconds rather than cycles for most reports
  
 -n
  
 miss
  
 List data access cache miss statistics
  
 -N
  num
  
 data acc miss
  
 List only the
  num
  most numerous data access secondary cache misses
  
 -o
  
 cache miss
  
 List instruction cache miss statistics
  
 -O
  num
  
 secondary miss
  
 List only the
  num
  most numerous instruction secondary cache misses
  
 -r
  
 routine
  
 List routine statistics
  
 -R
  num
  
 expensive rou-
  
 List only the
  num
  most expensive routines
  
 tine
  
 -R
  num%
  
 % time routine
  
 List only the routines that use the first
  num
 %
  of time
  
 -s
  
 summary
  
 List header summarizing data set from each run
  
 -t
  
 total
  
 Total all data sets and list cumulative times
  
 4-61",NA
c.restore,"Program Development Environment Utilities
  
 4
  
 Restore a corrupted database
  
 The syntax of the
  c.restore
  command is:
  
 c.restore [
 options
 ]
  
 The following represents the
  c.restore
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -n
  n
  
 number
  
 Select which backup of the database to restore
  
 -rel
  release
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -undo
  
 undo
  
 Undo the last restore
  
 The
  c.build
  command makes a backup of the database each time it is invoked from the 
 command line (recursive invokations do not trigger a new backiup). Three such backups 
 are maintained, numbered 1, 2, and 3, where 1 is the most recent. Should a power outage 
 crash the computer in middle of updating the database, it might be left in an inconsistant 
 state. The
  c.restore
  command will restore the database from the specified backup, and 
 remove any unit or partition that is newer than the restored database. This is because the 
 newer units and partitions may be built in a way that is inconsistant with the previous 
 configuration in the database, and so must be rebuilt to insure consistancy.
  
 4-63",NA
c.rmenv,"c.rmenv
  
 4
  
 Destroy an environment; compilation, linking, etc. no longer possible
  
 The syntax of the
  c.rmenv
  command is:
  
 c.rmenv [
 options
 ]
  environment_pathname
  
 The following represents the
  c.rmenv
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 force
  
 Force an environment destruction, even if it or some portion of it does not
  
 -f
  
 exist
  
 -H
  
 help
  
 Display syntax and options for this function
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 Removes an environment, including all units, their state information, and any partition
  
 definitions. The source files and any built partitions are left intact after this operation.
  
 The
  -f
  option can be used to force an environment’s destruction, even if some portion of 
 it does not exist. For example, if the
  c.mkenv
  utility was interrupted during its execution 
 (due to not enough disk space, power failure, etc.), the environment may not have been
  
 successfully created. If the environment cannot be recognized as valid, Concurrent C/C++
  
 will fail with a message similar to the following:
  
 c.rmenv: database file .c++/.database doesn’t
  
 exist in environment earth.
  
 The
  -f
  option will force this environment to be removed, thereby overriding such error 
 messages.
  
 The environment can be re-created with
  c.mkenv
  (see page 4-47), but it will be empty 
 and any state will have to be reconstructed by the user.
  
 4-64",NA
c.rmsrc,"Program Development Environment Utilities
  
 4
  
 Remove knowledge of source files (and units therein) from the 
 environ-ment 
  
 The syntax of the
  c.rmsrc
  command is:
  
 c.rmsrc [
 options
 ] [
 source_file
  ...]
  
 The following represents the
  c.rmsrc
  options:
  
 Option
  
 Meaning
  
 Function
  
 -all
  
 remove all
  
 Remove all units in the current environment
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -r
  
 remove
  
 Remove the actual source files
  
 -refs
  
 references
  
 Remove references to removed units. Otherwise, the environment will
  
 attempt to satisfy those references by searching the environment search
  
 -rel
  release
  
 release
  
 path for a unit of the same name.
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -s
  file
  
 file list
  
 file
  is assumed to be a file containing list of files. When this option is
  
 given,
  c.rmsrc
  reads
  file
  and removes each file in the list
  
 -v
  
 verbose
  
 Display a message for each removed source file
  
 -vv
  
 very verbose
  
 Echo removed units to
  stdout
  
 The
  c.intro
  tool can be used to re-associate the source files (and units therein) with the
  
 environment, but those units will be re-created in the
  uncompiled
  state (see “Compila-
  
 tion States” on page 3-11).
  
 4-65",NA
c.script,"c.script
  
 4
  
 Produce a script of c.* commands to reproduce the current environ-
  
 ment
  
 The syntax of the
  c.script
  command is:
  
 c.script
  
 The following represents the
  c.script
  options:
  
 Option
  
 Meaning
  
 Function
  
 -allparts
  
 all partitions
  
 Restrict script to recreating partitions; units are not recreated
  
 -echo
  
 echo
  
 Include echo commands in generated script to indicate progress
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 -executables
  
 recreate
  
 Restrict script to recreating executable partitions; units are not recre-
  
 executables
  
 ated
  
 -H
  
 help
  
 Display syntax and options for this function
  
 -length
  size
  
 restrict length
  
 Restrict length of command lines output to script
  
 -no_mkenv
  
 no mkenv
  
 Restrict script from creating a new environment and setting environ-
  
 ment wide options
  
 -no_shadow
  
 no shadow
  
 Restrict script from declaring referenced units and partitions that are
  
 not being recreated. Only useful with the
  -allparts, -pfile
 , 
 or
 -plist
  options
  
 -pfile
  file
  
 recreate
  
 Restrict script to recreating those partitions specified in
  file
 ; units are
  
 partitions in
  
 not recreated
  
 -plist “
 part-list
 ”
  
 file
  
 Restrict script to recreating specified partitions; units are not recre-
  
 recreate
  
 partitions in
  
 ated
  
 -rel
  release
  
 list
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 release
  
 -simple
  
 simple script
  
 Make the generated script “simple”, meaning each command invoca-
  
 tion is limited to a single unit. The resulting script is much easier to
  
 read, and thus manually edit, but will run much much slower.
  
 The
  c.script
  tool can be used to reconstruct an environment at a later time. For exam-
 ple, a future release of the tools may not use a compatible database format, so it will be
  
 necessary to use
  c.script
  in the old release, then run the script using the new release’s 
 commands.
  
 The
  -no_mkenv
  option suppresses the generatation of commands that create the environ-
 ment and that set environment-wide options. This would be used to merge all or part of
  
 one environment into another, for example.
  
 4-66",NA
c.touch,"Program Development Environment Utilities
  
 4
  
 Make the environment consider a unit consistent with its source file's
  
 timestamp
  
 The syntax of the
  c.touch
  command is:
  
 c.touch [
 options
 ] [
 unit-id ...
 ]
  
 The following represents the
  c.touch
  options:
  
 Option
  
 Meaning
  
 Function
  
 -env
  env
  
 environment
  
 Specify an environment pathname
  
 help
  
 Display syntax and options for this function
  
 -H
  
 release
  
 Specify a Concurrent C/C++ release (other than the default release)
  
 -rel
  release
  
 source file
  
 Touch all units in the specified file
  
 -source
  file
  
 verbose
  
 Display a message for each invalidated unit
  
 -v
  
 unit-id
  is defined by the following syntax:
  
 unit
  | all
  
 The
  c.touch
  tool is used to force a unit to be considered consistent with its source file, 
 usually to keep it from being rebuilt by
  c.build
 . Note that it may still be considered 
 inconsistent for other reasons.
  
 The
  c.invalid
  tool is provided to allow the opposite functionality. See “c.invalid” on 
 page 4-34 for details.
  
 4-69",NA
Link Options,"Link Options
  
 4
  
 NOTE
  
 Many link options have more than one spelling.
  
 Option
  
 Function
  
  
 --14
  
 --arch
  arch
  
 --auto_instantiation
  
 -c
  
 --c
  
 --c++
  
 -e
 sym
  
 --entry_point=
 sym
  
 -f
  
 -h
 name
  
 --dynamic_link_name=
 name
 -
 sp
 name
  
 -L
 dir
  
 --library_directory=
 dir
 -
 l
 lib
  
 --library=
 lib
  
 -M
 mapfile
  
 --mapfile=
 mapfile
  
 -m
  
 --memory_map
  
 -
 O[
 level
 ,[no_]post_linker]-
 O[no_]analyze
  
 --
 optimization_level=
 level
 --
 post_linker
  
 --no_post_linker
  
 -osversion
  osversion
  
 Truncate filenames in archives to 14 characters. Caveat: does not detect 
 name collisions!
  
 Select which architecture’s libraries to link with. Currently only valid 
 for the PLDE.
  
 Perform automatic template instantiation
  
 Suppress message generated when new archive is created
  
 Force linking as C or C++ program.
  
 Set the entry point address for the output file to be that of the symbol 
 sym
 .
  
 Cause archive to be a “fast updating” archive.
  
 Record
  name
  in the object’s
  dynamic
  section.
  name
  will be used by 
 the dynamic linker as the pathname of the shared object to search for 
 at run time.
  
 Add
  dir
  to the library search directories. This will effect subsequent
 -l
  
 link options.
  
 Search the library search path for a lib
 lib
 .so or lib
 lib
 .a file to link with.
  
 Read mapfile as a text files of directives to ld. Use of this option is 
 strongly discouraged.
  
 Produce a memory map of the input/output sections on stdout.
  
 Invoke the post-link optimization (
 analyze(1)
 ), select faster 
 libraries by default, etc. See “Optimization” in
  Compilation Systems 
 Volume 2 (Concepts)
  for detailed discussion of link-time and post-
 link-time optimizations.
  
 Select which PowerMAX OS version’s libraries to link with. Cur-rently 
 only valid for the PLDE.
  
 4-70",NA
5 ,NA,NA
Dialects,"C++ Dialect Accepted . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 New Language Features Accepted . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 New Language Features Not Accepted . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Anachronisms Accepted. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Extensions Accepted in Normal C++ Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Extensions Accepted in cfront 2.1 Compatibility Mode . . . . . . . . . . . . . . . . . .
  
 Extensions Accepted in cfront 2.1 and 3.0 Compatibility Mode . . . . . . . . . . . . C 
 Dialect Accepted . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 C9X Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 ANSI C Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 K&R/pcc Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Extensions Accepted in SVR4 Compatibility Mode . . . . . . . . . . . . . . . . . . . . .
  
 5-1 
  
 5-2 
  
 5-4 
  
 5-5 
  
 5-6 
  
 5-8 
  
 5-9 
  
 5-14 
 5-14 
 5-16 
 5-20 
 5-25",NA
5 ,Chapter 5,NA
Dialects,"5 
  
 5 
  
 5 
  
 This chapter discusses the various dialects of C++ and C that are supported by the Concur-
 rent C++ compiler. The following topics are covered:
  
 •
  C++ Dialect Accepted",NA
-,New Language Features Accepted,NA
-,New Language Features Not Accepted,NA
-,Anachronisms Accepted,NA
-,Extensions Accepted in Normal C++ Mode,NA
-,"Extensions Accepted in
  cfront
  2.1 Compatibility Mode",NA
-,"Extensions Accepted in
  cfront
  2.1 and 3.0 Compatibility Mode
  
 •
  C Dialect Accepted",NA
-,C9X Extensions,NA
-,ANSI C Extensions,NA
-,K&R/pcc Mode,NA
-,"Extensions Accepted in SVR4 C Compatibility Mode
  
 See Chapter 7 (“Compilation Modes”) for information on options to select these modes.",NA
C++ Dialect Accepted ,"5
  
 The front end accepts the C++ language as defined by the ISO/IEC 14882:1998 standard, 
 with the exceptions listed below.
  
 The front end also has a
  cfront
  compatibility mode, which duplicates a number of “fea-
 tures” and bugs of
  cfront
  2.1 and 3.0.x. Complete compatibility is not guaranteed or 
 intended—the mode is there to allow programmers who have unwittingly used
  cfront 
 features to continue to compile their existing code. In particular, if a program gets an error 
 when compiled by
  cfront
 , the EDG front end may produce a different error or no error 
 at all.
  
 Command-line options are also available to enable and disable anachronisms and strict 
 standard-conformance checking.
  
 5-1",NA
New Language Features Accepted,"5
  
 The following features not in traditional C++
 1
 but in the standard are implemented:
  
 •
  The dependent statement of an
  if
 ,
  while
 ,
  do-while
 , or
  for
  is consid-
 ered to be a scope, and the restriction on having such a dependent statement
  
 be a declaration is removed.
  
 •
  The expression tested in an
  if
 ,
  while
 ,
  do-while
 , or
  for
 , as the first 
 operand of a “
 ?
 ” operator, or as an operand of the “
 &&
 ”, “
 ||
 ”, or “
 !
 ” oper-
 ators may have a pointer-to-member type or a class type that can be con-
  
 verted to a pointer-to-member type in addition to the scalar cases permitted
  
 by the ARM.
  
 •
  Qualified names are allowed in elaborated type specifiers.
  
 •
  A global-scope qualifier is allowed in member references of the form 
  
 x.::A::B
  and
  p->::A::B
 .
  
 •
  The precedence of the third operand of the “
 ?
 ” operator is changed.
  
 •
  If control reaches the end of the
  main()
  routine, and
  main()
  has an inte-
  
 gral return type, it is treated as if a
  return 0;
  statement were executed.
  
 •
  Pointers to arrays with unknown bounds as parameter types are diagnosed 
  
 as errors.
  
 •
  A functional-notation cast of the form
  A()
  can be used even if
  A
  is a class 
 without a (nontrivial) constructor. The temporary created gets the same
  
 default initialization to zero as a static object of the class type.
  
 •
  A cast can be used to select one out of a set of overloaded functions when 
  
 taking the address of a function.
  
 •
  Template friend declarations and definitions are permitted in class defini-
  
 tions and class template definitions.
  
 •
  Type template parameters are permitted to have default arguments.
  
 •
  Function templates may have nontype template parameters.
  
 •
  A reference to
  const volatile
  cannot be bound to an rvalue.
  
 •
  Qualification conversions such as conversion from
  T**
  to
  T const * 
  
 const *
  are allowed.
  
 •
  Digraphs are recognized.
  
 •
  Operator keywords (e.g.,
  and
 ,
  bitand
 , etc.) are recognized.
  
 •
  Static data member declarations can be used to declare member constants.
  
 •
  wchar_t
  is recognized as a keyword and a distinct type.
  
 •
  bool
  is recognized.
  
 1. The C++ language of “
 The Annotated C++ Reference Manual
 ” by Ellis and Stroustrup.
  
 5-2",NA
New Language Features Not Accepted ,"5
  
 The following features of the C++ standard are not implemented yet:
  
 •
  reinterpret_cast
  does not allow casting a pointer to member of one 
 class to a pointer to member of another class if the classes are unrelated.
  
 •
  Two-phase name binding in templates, as described in [temp.res] and 
  
 [temp.dep] of the standard, is not implemented.
  
 •
  Template template parameters are not implemented.
  
 •
  The
  export
  keyword for templates is not implemented.
  
 •
  A
  typedef
  of a function type cannot include member function cv-qualifi-
  
 ers.
  
 5-4",NA
Anachronisms Accepted ,"5
  
 The following anachronisms are accepted when anachronisms are enabled:
  
 •
  overload
  is allowed in function declarations. It is accepted and ignored.
  
 •
  Definitions are not required for static data members that can be initialized 
 using default initialization. The anachronism does not apply to static data
  
 members of template classes; they must always be defined.
  
 •
  The number of elements in an array may be specified in an array
  delete 
  
 operation. The value is ignored.
  
 •
  A single
  operator++()
  and
  operator--()
  function can be used to 
  
 overload both prefix and postfix operations.
  
 •
  The base class name may be omitted in a base class initializer if there is 
  
 only 
 one immediate base class.
  
 •
  A bound function pointer (a pointer to a member function for a given 
  
 object) can be cast to a pointer to a function.
  
 •
  A nested class name may be used as a nonnested class name provided no 
 other class of that name has been declared. The anachronism is not applied
  
 to template classes.
  
 •
  A reference to a non-const type may be initialized from a value of a differ-ent 
 type. A temporary is created, it is initialized from the (converted) initial
  
 value, and the reference is set to the temporary.
  
 •
  A reference to a non-const class type may be initialized from an rvalue of the 
 class type or a derived class thereof. No (additional) temporary is used.
  
 •
  A function with old-style parameter declarations is allowed and may par-
 ticipate in function overloading as though it were prototyped. Default argu-
  
 ment promotion is not applied to parameter types of such functions when
  
 the check for compatibility is done, so that the following declares the over-
  
 loading of two functions named
  f
 :
  
 int f(int);
  
 int f(x) char x; { return x; }
  
 •
  It will be noted that in C this code is legal but has a different meaning: a 
  
 tentative declaration of
  f
  is followed by its definition.
  
 •
  When
  --nonconst_ref_anachronism
  is enabled, a reference to a 
 nonconst class can be bound to a class rvalue of the same type or a derived
  
 type thereof.
  
 struct A {
  
 A(int);
  
 A operator=(A&);
  
 A operator+(const A&);
  
 5-5",NA
Extensions Accepted in Normal C++ Mode ,"5
  
 The following extensions are accepted in all modes (except when strict ANSI violations are 
 diagnosed as errors):
  
 •
  A
  friend
  declaration for a class may omit the
  class
  keyword:
  
 class B; 
  
 class A { 
  
  
 friend B; 
  
 };
  
 // Should be ""friend class B""
  
 •
  Constants of scalar type may be defined within classes (this is an old form; 
  
 the modern form uses an initialized static data member):
  
 class A { 
  
  
 const int size = 10; 
  
  
 int a[size]; 
  
 };
  
 •
  In the declaration of a class member, a qualified name may be used:
  
 struct A { 
  
  
 int A::f(); 
  
 };
  
 // Should be int f();
  
 •
  The preprocessing symbol
  c_plusplus
  is defined in addition to the stan-
  
 dard
  __cplusplus
 .
  
 •
  An extension is supported to allow an anonymous union to be introduced into 
 a containing class by a
  typedef
  name — it needn’t be declared directly, 
 as with a true anonymous union. For example:
  
 typedef union { 
  
  
 int i, j; 
  
 } U; 
  
 // U identifies a reusable anonymous union.
  
 class A { 
  
  
 U; 
  
 // Okay -- references to A::i and 
  
  
 // A::j are allowed.
  
 };
  
 In addition, the extension also permits “anonymous classes” and “anonymous 
 structs,” as long as they have no C++ features (e.g., no static data members or mem-
 ber functions and no nonpublic members) and have no nested types other than other 
 anonymous classes, structs, or unions. For instance,
  
 struct A { 
  
 struct { 
  
 int i, j;
  
 5-6",NA
Extensions Accepted in cfront 2.1 Compatibility Mode,"5
  
 The following extensions are accepted in
  cfront
  2.1 compatibility mode in addition to 
 the extensions listed in the 2.1/3.0 section following (i.e., these are things that were cor-
 rected in the 3.0 release of
  cfront
 ):
  
 •
  The dependent statement of an
  if
 ,
  while
 ,
  do-while
 , or
  for
  is not 
 con-sidered to define a scope. The dependent statement may not be a 
 declara-tion. Any objects constructed within the dependent statement are 
 destroyed at exit from the dependent statement.
  
 •
  Implicit conversion from integral types to enumeration types is allowed.
  
 •
  A non-
 const
  member function may be called for a
  const
  object. A 
  
 warning is issued.
  
 •
  A
  const void *
  value may be implicitly converted to a
  void *
  value, 
  
 e.g., when passed as an argument.
  
 •
  When, in determining the level of argument match for overloading, a refer-
 ence parameter is initialized from an argument that requires a non-class 
 standard conversion, the conversion counts as a user-defined conversion. 
 (This is an outright bug, which unfortunately happens to be exploited in the 
 NIH class libraries.)
  
 •
  When a builtin operator is considered alongside overloaded operators in 
 overload resolution, the match of an operand of a builtin type against the 
 builtin type required by the builtin operator is considered a standard con-
 version in all cases (e.g., even when the type is exactly right without con-
 version).
  
 •
  A reference to a non-
 const
  type may be initialized from a value that is a 
 const
 -qualified version of the same type, but only if the value is the result 
 of selecting a member from a
  const
  class object or a pointer to such an 
 object.
  
 •
  A cast to an array type is allowed; it is treated like a cast to a pointer to the 
  
 array element type. A warning is issued.
  
 •
  When an array is selected from a class, the type qualifiers on the class object 
 (if any) are not preserved in the selected array. (In the normal mode, any 
 type qualifiers on the object are preserved in the element type of the 
 resultant array.)
  
 •
  An identifier in a function is allowed to have the same name as a parameter 
  
 of the function. A warning is issued.
  
 •
  An expression of type
  void
  may be supplied on the return statement in a 
  
 function with a
  void
  return type. A warning is issued.
  
 •
  A parameter of type “
 const 
  
 void 
  
 *
 ” is allowed on
  operator 
  
 delete
 ; it is treated as equivalent to “
 void *
 ”.
  
 •
  A period (“
 .
 ”) may be used for qualification where “
 ::
 ” should be used. 
 Only “
 ::
 ” may be used as a global qualifier. Except for the global quali-
 fier, the two kinds of qualifier operators may not be mixed in a given name 
 (i.e., you may say
  A::B::C
  or
  A.B.C
  but not
  A::B.C
  or
  A.B::C
 ). 
 A
  
 5-8",NA
Extensions Accepted in cfront 2.1 and 3.0 Compatibility Mode,"The following extensions are accepted in both
  cfront
  2.1 and
  cfront
  3.0 
 compatibility mode (i.e., these are features or problems that exist in both
  cfront
  2.1 and 
 3.0):
  
 5-9",NA
C Dialect Accepted ,"5
  
 The front end accepts the ANSI C language as defined by X3.159–1989.
  
 The special comments recognized by the UNIX
  lint
  program —
  
 /*ARGSUSED*/
  
 /*VARARGS*/
  (with or without a count of non-varying arguments)
  
 /*NOTREACHED*/
  
 — are also recognized by the front end.",NA
C9X Extensions ,"5
  
 Certain C language extensions that have been approved for inclusion in the forthcoming 
 C9X language definition can be enabled selectively. Sometimes these extensions had been
  
 5-14",NA
ANSI C Extensions ,"5
  
 The following extensions are accepted:
  
 •
  A translation unit (input file) can contain no declarations.
  
 •
  Comment text can appear at the ends of preprocessing directives.
  
 •
  __ALIGNOF__
  is similar to
  sizeof
 , but returns the alignment require-
 ment value for a type, or
  1
  if there is no alignment requirement. It may be 
 followed by a type or expression in parentheses:
  
 5-16",NA
-,"not only anonymous unions but also anonymous structs are allowed— 
 that is, their members are promoted to the scope of the containing 
 struct and looked up like ordinary members;",NA
-,"they can be introduced into the containing struct by a
  typedef 
 name — they needn’t be declared directly, as with true anonymous 
 unions; and",NA
-,"a tag may be declared (C mode only).
  
 Among the restrictions: the extension only applies to constructs within structs.
  
 •
  External entities declared in other scopes are visible. A warning is issued.
  
 void f1(void) { extern void f(); } 
  
 void f2() { f(); /* Using out of scope declaration */ 
 }
  
 •
  A non-lvalue array expression is converted to a pointer to the first element 
  
 of the array when it is subscripted or similarly used.
  
 In the following areas considered “undefined behavior” by the ANSI C standard, the front 
 end does the following:
  
 •
  Adjacent wide and non-wide string literals are not concatenated unless 
 wchar_t
  and
  char
  are the same type. (In C++ mode, when
  wchar_t
  
 is a keyword, adjacent wide and non-wide string literals are never concate-
 nated.)
  
 •
  In character and string escapes, if the character following the
  \
  has no spe-
 cial meaning, the value of the escape is the character itself. Thus
  ""\s"" == 
 ""s""
 . A warning is issued.
  
 •
  A
  struct
  that has no named fields but at least one unnamed field is 
 accepted by default, but a diagnostic (a warning or error) is issued in strict 
 ANSI C mode.
  
 5-19",NA
K&R/pcc Mode,"5
  
 When
  pcc
  mode is specified, the front end accepts the traditional C language defined by 
 The C Programming Language
 , first edition, by Kernighan and Ritchie (K&R), Pren-tice-
 Hall, 1978. In addition, it provides almost complete compatibility with the Reiser 
 cpp
  and 
 Johnson
  pcc
  widely used as part of UNIX systems; since there is no documenta-tion of 
 the exact behavior of those programs, complete compatibility cannot be guaran-teed.
  
 In general, when compiling in
  pcc
  mode, the front end attempts to interpret a source pro-
 gram that is valid to
  pcc
  in the same way that
  pcc
  would. However, ANSI features that 
 do not conflict with this behavior are not disabled.
  
 In some cases where
  pcc
  allows a highly questionable construct, the front end will accept 
 it but give a warning, where
  pcc
  would be silent (for example:
  0x
 , a degenerate 
 hexadec-imal number, is accepted as zero).
  
 The known cases where the front end is not compatible with
  pcc
  are the following:
  
 •
  Token pasting is not done outside of macro expansions (i.e., in the primary 
 source line) when two tokens are separated only by a comment. That is, 
 a/**/b
  is not considered to be
  ab
 . The
  pcc
  behavior in that case can be 
 gotten by preprocessing to a text file and then compiling that file.
  
 The textual output from preprocessing is also equivalent but not identical: the blank 
 lines and white space will not be exactly the same.
  
 •
  pcc
  will consider the result of a
  ?:
  operator to be an lvalue if the first 
 operand is constant and the second and third operands are compatible lval-
 ues. This front end will not.
  
 •
  pcc
  mis-parses the third operand of a
  ?:
  operator in a way that some pro-
  
 grams exploit:
  
 i ? j : k += l
  
 is parsed by
  pcc
  as
  
 i ? j : (k += l)
  
 which is not correct, since the precedence of
  +=
  is lower than the precedence of
  ?:
 . 
 This front end will generate an error for that case.
  
 •
  lint
  recognizes the keywords for its special comments anywhere in a 
 comment, regardless of whether or not they are preceded by other text in the 
 comment. The front end only recognizes the keywords when they are the 
 first identifier following an optional initial series of blanks and/or hori-
 zontal tabs.
  lint
  also recognizes only a single digit of the
  VARARGS 
 count; the front end will accumulate as many digits as appear.
  
 The differences in
  pcc
  mode relative to the default ANSI mode are as follows:
  
 •
  The keywords
  signed
 ,
  const
 , and
  volatile
  are disabled, to avoid 
 problems with items declared with those names in old-style code. Those 
 keywords were ANSI C inventions. The other non-K&R keywords (
 enum 
 and
  void
 ) are judged to have existed already in code and are not disabled.
  
 5-20",NA
Extensions Accepted in SVR4 Compatibility Mode,"5
  
 The following extensions are accepted in SVR4 C compatibility mode:
  
 •
  Macro invocations having too many arguments are flagged with a warning 
  
 rather than an error. The extra arguments are ignored.
  
 •
  Macro invocations having too few arguments are flagged with a warning 
 rather than an error. A null string is used as the value of the missing param-
  
 eters.
  
 •
  The sequence
  /**/
  in a macro definition is treated as equivalent to the 
  
 token-pasting operator
  ##
 .
  
 •
  lvalues cast to a type of the same size remain lvalues, except when they 
  
 involve a floating-point conversion.
  
 •
  Assignment is allowed between pointers and integers, and between incom-
  
 patible pointer types, without an explicit cast. A warning is issued.
  
 •
  A field selection of the form
  p
 ->
 field
  is allowed even if
  p
  does not point to a
  
 struct
  or
  union
  that contains
  field
 .
  p
  must be a pointer. Likewise, 
 x
 .
 field
  is allowed even if
  x
  is not a
  struct
  or
  union
  that contains
  field
 .
  
 x 
 must be an lvalue. For both cases, all definitions of
  field
  as a field must
  
 have the same offset within their
  struct
  or
  union
 .
  
 •
  In an integral constant expression, an integer constant may be cast to a 
  
 pointer type and then back to an integral type.
  
 •
  Incompatible external object declarations are allowed if the object types 
  
 share the same underlying representation.
  
 •
  Certain incompatible function declarations are allowed. A warning is 
  
 issued.
  
 typedef unsigned int size_t;
  
 extern size_t strlen(const char *);
  
 extern int strlen(); 
  
 /* Warning */
  
 5-25",NA
6 ,NA,NA
Special Features of C++,"Namespace Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Template Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Automatic Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Instantiation Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Instantiation
  #pragma
  Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Implicit Inclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Automatic Instantiation Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 The Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Solving the Problem with
  --prelink_objects
  . . . . . . . . . . . . . . . . .
  
 Solving the Problem with the PDE Tools . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Solving the Problem with Makefiles and the PDE Tools . . . . . . . . . . . . . .
  
 Miscellaneous Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Edison Defined Pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Concurrent Defined Pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Source Listing Controls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Optimization Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Data Alignment Control Directives. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Data Alignment Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 #pragma align. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 #pragma min_align . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Miscellaneous Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 #pragma once . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 #pragma ident. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 #pragma weak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Template Instantiation Pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Precompiled Headers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Automatic Precompiled Header Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Manual Precompiled Header Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Other Ways for Users to Control Precompiled Headers. . . . . . . . . . . . . . . . . . .
  
 Performance Issues. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Intrinsic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 AltiVec Technology Programming Interface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 New Keywords for AltiVec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 New Intrinsic Functions for AltiVec. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 New Pragma for AltiVec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 varargs/stdarg for AltiVec. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Runtime for AltiVec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Interoperability with Non-AltiVec for AltiVec. . . . . . . . . . . . . . . . . . . . . . . . . . 
 Environment Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Diagnostic Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Termination Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Response to Signals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Exit Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Finding Include Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6-1 
  
 6-3 
  
 6-4 
  
 6-7 
  
 6-8 
  
 6-9 
  
 6-10 
 6-10 
 6-11 
 6-13 
 6-14 
 6-16 
 6-17 
 6-20 
 6-20 
 6-22 
 6-23 
 6-24 
 6-24 
 6-25 
 6-25 
 6-26 
 6-27 
 6-27 
 6-27 
 6-27 
 6-28 
 6-28 
 6-28 
 6-31 
 6-31 
 6-32 
 6-33 
 6-35 
 6-35 
 6-35 
 6-36 
 6-36 
 6-36 
 6-36 
 6-37 
 6-37 
 6-39 
 6-40 
 6-40 
 6-40",NA
6 ,Chapter 6,NA
Special Features of C++,"6 
  
 6 
  
 6 
  
 C++ provides powerful programming constructs. This chapter discusses the Concurrent C++ 
 compiler’s support of the following features:
  
 •
  Namespace Support
  
 •
  Template Instantiation",NA
-,Automatic Instantiation,NA
-,Instantiation Modes,NA
-,Instantiation #pragma Directives,NA
-,Implicit Inclusion,NA
-,"Automatic Instantiation Issues
  
 •
  Predefined Macros
  
 •
  Pragmas
  
 •
  Precompiled Headers
  
 •
  Intrinsic Functions
  
 •
  AltiVec Technology Programming Interface
  
 •
  Environment Variables
  
 •
  Diagnostic Messages
  
 •
  Termination Messages
  
 •
  Response to Signals
  
 •
  Exit Status
  
 •
  Finding Include Files",NA
Namespace Support ,"Namespaces are enabled by default except in th
  
 options
  --namespaces
  and
  --no_namespac
  
 features.
  
 6
  
 e
  cfront
  modes. The command-line
  
 es
  can be used to enable or disable the
  
 Name lookup during template instantiations now does something that approximates the 
 two-phase lookup rule of the standard. When a name is looked up as part of a template 
 instantiation but is not found in the local context of the instantiation, it is looked up in a 
 synthesized instantiation context. The front end follows the new instantiation lookup rules
  
 6-1",NA
Template Instantiation,"6
  
 The C++ language includes the concept of
  templates
 . A template is a description of a class 
 or function that is a model for a family of related classes or functions.
 1
 For example, one 
 can write a template for a
  Stack
  class, and then use a stack of integers, a stack of floats, 
 and a stack of some user-defined type. In the source, these might be written 
 Stack<int>
 ,
  
 Stack<float>
 , and
  Stack<X>
 . From a single source description of the template for a 
 stack, the compiler can create
  instantiations
  of the template for each of the types required.
  
 The instantiation of a class template is always done as soon as it is needed in a compila-
 tion. However, the instantiations of template functions, member functions of template 
 classes, and static data members of template classes (hereafter referred to as template enti-
 ties) are not necessarily done immediately, for several reasons:
  
 •
  One would like to end up with only one copy of each instantiated entity 
 across all the object files that make up a program. (This of course applies to 
 entities with external linkage.)
  
 •
  The language allows one to write a
  specialization
  of a template entity, i.e., 
  
 a specific version to be used in place of a version generated from the tem-
  
 plate for a specific data type. (One could, for example, write a version of 
  
 Stack<int>
 , or of just
  Stack<int>::push
 , that replaces the tem-
  
 plate-generated version; often, such a specialization provides a more effi-
  
 cient representation for a particular data type.) Since the compiler cannot 
  
 know, when compiling a reference to a template entity, if a specialization 
  
 for that entity will be provided in another compilation, it cannot do the 
  
 instantiation automatically in any source file that references it. (The mod-
  
 ern C++ language requires that a specialization be declared in every compi-
  
 lation in which it is used, but for compatibility with existing code and older 
  
 compilers the Concurrent compiler does not require that in some modes. 
  
 See 
  
 the 
  
 command-line 
  
 option
  
 --no_distinct_template_signatures
 .)
  
 •
  The language also dictates that template functions that are not referenced 
 should not be compiled, that, in fact, such functions might contain semantic 
 errors that would prevent them from being compiled. Therefore, a refer-
 ence to a template class should not automatically instantiate all the member 
 functions of that class.
  
 (It should be noted that certain template entities are always instantiated when used, e.g., 
 inline functions.)
  
 From these requirements, one can see that if the compiler is responsible for doing all the 
 instantiations automatically, it can only do so on a program-wide basis. That is, the com-
 piler cannot make decisions about instantiation of template entities until it has seen all the 
 source files that make up a complete program.
  
 The C++ front end provides an instantiation mechanism that does automatic instantiation at 
 link time. For cases where the programmer wants more explicit control over instantia-
  
 1. Since templates are descriptions of entities (typically, classes) that are parameterizable according to the types they operate upon, 
  
 they are sometimes called
  parameterized types
 .
  
 6-3",NA
Automatic Instantiation ,"6
  
 The goal of an automatic instantiation mode is to provide painless instantiation. The pro-
 grammer should be able to compile source files to object code, then link them and run the 
 resulting program, and never have to worry about how the necessary instantiations get 
 done.
  
 In practice, this is hard for a compiler to do, and different compilers use different auto-matic 
 instantiation schemes with different strengths and weaknesses:
  
 •
  AT&T/USL/Novell/SCO’s
  cfront
  product saves information about each 
 file it compiles in a special directory called
  ptrepository
 . It instanti-
 ates nothing during normal compilations. At link time, it looks for entities 
 that are referenced but not defined, and whose mangled names indicate that 
 they are template entities. For each such entity, it consults the
  
 ptreposi-tory
  information to find the file containing the source for the 
 entity, and it does a compilation of the source to generate an object file 
 containing object code for that entity. This object code for instantiated 
 objects is then com-bined with the “normal” object code in the link step.
  
 The programmer using
  cfront
  must follow a particular coding convention: all 
 templates must be declared in “
 .h
 ” files, and for each such file there must be a cor-
 responding “
 .C
 ” file containing the associated definitions. The compiler is never told 
 about the “
 .C
 ” files explicitly; one does not, for example, compile them in the 
 normal way. The link step looks for them when and if it needs them, and does so by 
 taking the “
 .h
 ” file name and replacing its suffix.
 2
  
 This scheme has the disadvantage that it does a separate compilation for each instan-
 tiated function (or, at best, one compilation for all the member functions of one 
 class). Even though the function itself is often quite small, it must be compiled along 
 with the declarations for the types on which the instantiation is based, and those dec-
 larations can easily run into many thousands of lines. For large systems, these com-
 pilations can take a very long time. The link step tries to be smart about recompiling 
 instantiations only when necessary, but because it keeps no fine-grained dependency 
 information, it is often forced to “recompile the world” for a minor change in a 
 “
 .h
 ”file. In addition,
  cfront
  has no way of ensuring that preprocessing symbols 
 are set correctly when it does these instantiation compilations, if preprocessing 
 symbols are set other than on the command line.
  
 •
  Borland’s C++ compiler instantiates everything referenced in a compila-tion, 
 then uses a special linker to remove duplicate definitions of instanti-ated 
 functions.
  
 2. The actual implementation allows for several different suffixes and provides a command-line option to change the suffixes 
  
 sought.
  
 6-4",NA
Instantiation Modes ,"6
  
 Normally, when a file is compiled, no template entities are instantiated (except those 
 assigned to the file by automatic instantiation). The overall instantiation mode can, how-
 ever, be changed by a command line option:
  
 -tnone
  
 -tused
  
 -tall
  
 -tlocal
  
 Do not automatically create instantiations of any template entities. 
 This is the default. It is also the usually appropriate mode when auto-
 matic instantiation is done.
  
 Instantiate those template entities that were used in the compilation. 
 This will include all static data members for which there are template 
 definitions.
  
 Instantiate all template entities declared or referenced in the compila-
 tion unit. For each fully instantiated template class, all of its member 
 functions and static data members will be instantiated whether or not 
 they were used. Nonmember template functions will be instantiated 
 even if the only reference was a declaration.
  
 Similar to
  -tused
  except that the functions are given internal link-
 age. This is intended to provide a very simple mechanism for those 
 getting started with templates. The compiler will instantiate the func-
 tions that are used in each compilation unit as local functions, and the 
 program will link and run correctly (barring problems due to multiple 
 copies of local static variables.) However, one may end up with many 
 copies of the instantiated functions, so this is not suitable for produc-
 tion use.
  -tlocal
  can not be used in conjunction with automatic 
 template instantiation. If automatic instantiation is enabled by default, 
 it will be disabled by the
  -tlocal
  option. If automatic
  
 6-7",NA
Instantiation,NA,NA
 #pragma,NA,NA
 Directives ,"6
  
 Instantiation pragmas can be used to control the instantiation of specific template entities or 
 sets of template entities. There are three instantiation pragmas:
  
 •
  The
  instantiate
  pragma causes a specified entity to be instantiated.
  
 •
  The
  do_not_instantiate
  pragma suppresses the instantiation of a 
 specified entity. It is typically used to suppress the instantiation of an entity 
 for which a specific definition will be supplied.
  
 •
  The
  can_instantiate
  pragma indicates that a specified entity can be 
 instantiated in the current compilation, but need not be; it is used in con-
 junction with automatic instantiation, to indicate potential sites for instanti-
 ation if the template entity turns out to be required.
 5
  
 The argument to the instantiation pragma may be:
  
 a template class name 
  
 A<int>
  
 a template class declaration 
  
 class A<int>
  
 a member function name 
  
 A<int>::f
  
 a static data member name 
  
 A<int>::i
  
 a static data declaration 
  
 int A<int>::i
  
 a member function declaration
 void A<int>::f(int, char)
  
 a template function declaration
 char* f(int, float)
  
 A pragma in which the argument is a template class name (e.g.,
  A<int>
  or
  class 
 A<int>
 ) is equivalent to repeating the pragma for each member function and static data 
 member declared in the class. When instantiating an entire class a given member function 
 or static data member may be excluded using the
  do_not_instantiate
  pragma. For 
 example,
  
 5. At the moment, the
  can_instantiate
  pragma ends up forcing the instantiation of the template instance even if it isn’t ref-
  
 erenced somewhere else in the program; that’s a weakness of the initial implementation which we expect to address.
  
 6-8",NA
Implicit Inclusion ,"6
  
 When implicit inclusion is enabled, the front end is given permission to assume that if it 
 needs a definition to instantiate a template entity declared in a “
 .h
 ” file it can implicitly 
 include the corresponding “
 .C
 ” file to get the source code for the definition. For example, 
 if a template entity
  ABC::f
  is declared in file
  xyz.h
 , and an instantiation of
  ABC::f
  
 is required in a compilation but no definition of
  ABC::f
  appears in the source code pro-
 cessed by the compilation, the compiler will look to see if a file
  xyz.C
  exists, and if so it 
 will process it as if it were included at the end of the main source file.
  
 To find the template definition file for a given template entity the front end needs to know 
 the full path name of the file in which the template was declared and whether the file was 
 included using the system include syntax (e.g.,
  #include <file.h>
 ). This informa-
 tion is not available for preprocessed source containing
  #line
  directives. Consequently, 
 the front end will not attempt implicit inclusion for source code containing
  #line
  direc-
 tives.
  
 6-9",NA
Automatic Instantiation Issues ,"6
  
 Template instantiation is a complex issue. We have been improving support for it, but it 
 remains intrinsically confusing. This section will attempt to explain some of the issues 
 surrounding template instantiation and its automation. It also documents enhancements that 
 have been made in the 5.1 and 5.2 releases to better automate template instantiation.
  
 The compiler can't know which templates will need to be instantiated in a program until 
 link time. Therefore, when first compiling source files, no templates are instantiated unless 
 their instantiation is explicitly requested in the source (or via command line options). The 
 template instantiations that can be provided by and that are needed by each compilation are 
 recorded in a
  .ti
  file that is placed in the same directory as the generated object file if the 
 file is compiled with the
  --auto_instantiation
  option. Before actually linking, a 
 tool called
  prelink
  collects a list of all the template instantiations that are needed to link 
 successfully, and assigns each to a compilation that can provide the instantiation if the link 
 is performed with the
  --auto_instantiation
  option. These assignments are 
 recorded in
  .ii
  files in the same directory as the
  .ti
  and object files. It then recompiles 
 those compilations and finally the linker is invoked.
  
 The Problem 
  
 6
  
 There is one obvious, huge, problem with this scheme. That is, if the build procedure 
 moves the object file elsewhere, such as into an archive, then the prelinker has no way of 
 finding the
  .ti
  and
  .ii
  files. The 5.1 release improved this situation
  if
  you use the pro-
 gram development environment tools (PDE tools). This is because the PDE’s database 
 knows how the archives were built, so it can assign a template instantiation to an compila-
 tion unit in an archive and update the archive before linking the program that uses the 
 archive.
  
 Consider the following
  Makefile
 :
  
 6-10",NA
 --prelink_objects ,"6
  
 The
  --prelink_objects
  option of
  ec++
  can be used to resolve the template 
 instanti-ations needed by a subset of the object files. To use this in the above example, one 
 would change the
  fg.a
  target to read:
  
 fg.a: f.o g.o 
  
 ec++ --prelink_objects f.o 
 g.o 
  
 ar r fg.a f.o g.o
  
 This will direct the compiler to determine what templates are needed by
  f.o
  and
  g.o
 , 
 assign instantiations of them to one or the other of them, if possible, and recompile them 
 with those instantiations. There is a drawback however.
  
 6-11",NA
Predefined Macros ,"6
  
 The front end defines a number of preprocessing macros. Many of them are only defined 
 under certain circumstances. This section describes the macros that are provided and the 
 circumstances under which they are defined.
  
 __STDC__
  
 Defined in ANSI C mode and in C++ mode. In C++ mode the value may be rede-
 fined.
 __cplusplus
  
 Defined in C++ mode.
  
 c_plusplus
  
 Defined in default C++ mode, but not in strict mode.
  
 __STDC_VERSION__
  
 Defined in ANSI C mode with the value
  199409L
 . The name of this macro, and its 
 value, are specified in Normative Addendum 1 of the ISO C Standard.
  
 __SIGNED_CHARS__
  
 Defined when plain
  char
  is signed. This is used in the
  <limits.h>
  header file 
 to get the proper definitions of
  CHAR_MAX
  and
  CHAR_MIN
 .
  
 _WCHAR_T
  
 Defined in C++ mode when
  wchar_t
  is a keyword. The name of this predefined 
 macro is specified by a configuration flag.
  _WCHAR_T
  is the default.
  
 _BOOL
  
 6-17",NA
Pragmas,"6
  
 #pragma
  directives are used within the source program to request certain kinds of special 
 processing. The
  #pragma
  directive is part of the standard C and C++ languages, but the 
 meaning of any pragma is implementation-defined. The front end recognizes several prag-
 mas.",NA
Edison Defined Pragmas ,"6
  
 The following are described in detail in the template instantiation section of this chapter:
  
 #pragma instantiate
  
 #pragma do_not_instantiate
  
 #pragma can_instantiate
  
 and two others are described in the section on precompiled header processing:
  
 #pragma hdrstop
  
 #pragma no_pch
  
 The front end also recognizes
  #pragma once
 , which, when placed at the beginning of a 
 header file, indicates that the file is written in such a way that including it several times has 
 the same effect as including it once. Thus, if the front end sees
  #pragma once
  at the 
 start of a header file, it will skip over it if the file is
  #include
 d again.
  
 A typical idiom is to place an
  #ifndef
  guard around the body of the file, with a 
 #define
  of the guard variable after the
  #ifndef
 :
  
 #pragma once 
  
 #define FILE_H 
  
 ...
  body of the header file
  ...
  
 #endif
  
 // #ifndef FILE_H
  
 The
  #pragma once
  is marked as optional in this example, because the front end recog-
 nizes the
  #ifndef
  idiom and does the optimization even in its absence.
  #pragma 
 once 
 is accepted for compatibility with other compilers and to allow the programmer to 
 use other guard-code idioms.
  
 The
  #pragma pack
  is used to specify the maximum alignment allowed for nonstatic 
 data members of structs and classes, even if that alignment is less than the alignment dic-
 tated by the member’s type. The basic syntax is:
  
 #pragma pack(
 n
 )
  
 #pragma pack()
  
 where argument
  n
 , a power-of-2 value, is the new packing alignment that is to go into 
 effect for subsequent declarations, until another
  #pragma pack
  is seen. The second 
 form cancels the effect of a preceding
  #pragma pack(
 n
 )
  and either restores the default 
 packing alignment specified by the
  --pack_alignment
  command-line option or, if the 
 option was not used, disables the packing of structs and classes. In addition, an enhanced
  
 6-20",NA
Concurrent Defined Pragmas ,"6
  
 The directive
  #pragma
  communicates implementation defined directives to the compiler. 
 Syntax.
  
 #pragma
  directive_string
  
 directive_string
  ::= 
  
  
 directive_w_poss_args 
  
 directive_w_poss_args
  ::= 
  
  
 directive_name
  [
 argument
  [,
 argument
  ... ]]
  
 The Concurrent implementation defined directives for use with
  #pragma
  appear below
  
 Table 6-1. Implementation Defined Directives Used with #pragma
  
 align
  
 ident
  
 optimize_for_space
  
 cautions
  
 min_align
  
 optimize_for_time
  
 error
  
 once
  
 warnings
  
 6-22",NA
Precompiled Headers ,"6
  
 It is often desirable to avoid recompiling a set of header files, especially when they intro-
 duce many lines of code and the primary source files that
  #include
  them are relatively 
 small. The EDG front end provides a mechanism for, in effect, taking a snapshot of the 
 state of the compilation at a particular point and writing it to a disk file before completing 
 the compilation; then, when recompiling the same source file or compiling another file with 
 the same set of header files, it can recognize the “snapshot point,” verify that the cor-
 responding precompiled header (“PCH”) file is reusable, and read it back in. Under the 
 right circumstances, this can produce a dramatic improvement in compilation time; the 
 trade-off is that PCH files can take a lot of disk space.",NA
Automatic Precompiled Header Processing ,"6
  
 When
  --pch
  appears on the command line, automatic precompiled header processing is 
 enabled. This means the front end will automatically look for a qualifying precompiled 
 header file to read in and/or will create one for use on a subsequent compilation.
  
 The PCH file will contain a snapshot of all the code preceding the “header stop” point. The 
 header stop point is typically the first token in the primary source file that does not belong 
 to a preprocessing directive, but it can also be specified directly by
  #pragma hdrstop
  
 (see below) if that comes first. For example:
  
 #include 
 ""xxx.h"" 
  
 #include 
 ""yyy.h"" 
  
 int i;
  
 The header stop point is
  int
  (the first non-preprocessor token) and the PCH file will con-
 tain a snapshot reflecting the inclusion of
  xxx.h
  and
  yyy.h
 . If the first non-
 preprocessor token or the
  #pragma hdrstop
  appears within a
  #if
  block, the header 
 stop point is the outermost enclosing
  #if
 . To illustrate, here’s a more complicated 
 example:",NA
Manual Precompiled Header Processing ,"6
  
 Command-line option
  --create_pch
  file-name
  specifies that a precompiled header file 
 of the specified name should be created.
  
 Command-line option
  --use_pch
  file-name
  specifies that the indicated precompiled 
 header file should be used for this compilation; if it is invalid (i.e., if its prefix does not 
 match the prefix for the current primary source file), a warning will be issued and the PCH 
 file will not be used.
  
 When either of these options is used in conjunction with
  --pch_dir
 , the indicated file 
 name (which may be a path name) is tacked on to the directory name, unless the file name 
 is an absolute path name.
  
 The
  --create_pch
 ,
  --use_pch
 , and
  --pch
  options may not be used together. If 
 more than one of these options is specified, only the last one will apply. Nevertheless, most 
 of the description of automatic PCH processing applies to one or the other of these modes 
 — header stop points are determined the same way, PCH file applicability is deter-mined 
 the same way, and so forth.",NA
Other Ways for Users to Control Precompiled Headers ,"6
  
 There are several ways in which the user can control and/or tune how precompiled headers 
 are created and used.
  
 6-31",NA
Performance Issues ,"6
  
 The relative overhead incurred in writing out and reading back in a precompiled header file 
 is quite small for reasonably large header files.
  
 In general, it doesn’t cost much to write a precompiled header file out even if it does not 
 end up being used, and if it
  is
  used it almost always produces a significant speedup in 
 compilation. The problem is that the precompiled header files can be quite large (from a 
 minimum of about 250K bytes to several megabytes or more), and so one probably doesn’t 
 want many of them sitting around.
  
 Thus, despite the faster recompilation, precompiled header processing is not likely to be 
 justified for an arbitrary set of files with nonuniform initial sequences of preprocessing 
 directives. Rather, the greatest benefit occurs when a number of source files can share the 
 same PCH file. The more sharing, the less disk space is consumed. With sharing, the dis-
 advantage of large precompiled header files can be minimized, without giving up the 
 advantage of a significant speedup in compilation times.
  
 Consequently, to take full advantage of header file precompilation, users should expect to 
 reorder the
  #include
  sections of their source files and/or to group
  #include
  
 directives within a commonly used header file.
  
 The front end source provides an example of how this can be done. A common idiom is this:
  
 #include ""fe_common.h"" 
  
 #pragma hdrstop 
  
 #include ...
  
 where
  fe_common.h
  pulls in, directly and indirectly, a few dozen header files; the 
 #pragma hdrstop
  is inserted to get better sharing with fewer PCH files. The PCH file
  
 6-32",NA
Intrinsic Functions ,"6
  
 Most
  intrinsic functions
  (intrinsics) provide access to hardware-related machine 
 instructions. Others provide inline substitutes for some time-critical functions.When the
 -F
  
 option is used, the compiler recognizes certain function names as being intrinsic functions
 .
  
 To override this on any given use, enclose the name in parentheses. Intrinsic functions are 
 used in the same manner as normal functions; however, rather than calling a subroutine, the 
 compiler generates code directly. To use an intrinsic, it must be prototyped and marked as 
 an intrinsic with a
  pragma
 . For example:
  
 extern “C” int abs(int); 
  
 #pragma intrinsic abs
  
 Any calls to a function declared like this will refer to the intrinsic.
  
 For example, the following code, when compiled with the
  -F
  option, uses the
  abs
  intrin-
 sic function:
  
 extern “C” int abs(int); 
  
 #pragma intrinsic abs 
  
 sub(int arg) 
  
 { 
  
  
 return abs(arg); 
  
 }
  
 However, the following code does not use the intrinsic function:",NA
AltiVec Technology Programming Interface,"6
  
 Motorola defined several extensions to C and C++ for accessing the AltiVec instructions of 
 the PowerPC 7400 family of microprocessors. These extensions include new key-words, 
 intrinsic functions, runtime functions, and a pragma. See the Motorola document 
 AltiVec 
 Technology Programming Interface Manual
  for detailed documentation of these 
 extensions. This document will only discuss issues specific to Concurrent’s implementa-
 tion.
  
 Currently the only microprocessor supported by Concurrent’s C/C++ compiler that has 
 AltiVec instruction is the MPC7400. It may be selected by the
  --target=ppc7400
  
 (or
 --target=mpc7400
 ) option. See discussion of
  c.install
  and
  c.release
  
 com-mands for ways of setting the default target microprocessor if none is specified under 
 the PLDE.",NA
New Keywords for AltiVec ,"6
  
 The following table shows the keywords that were added for AltiVec support and the com-
 piler options to enable and disable them (note that
  bool
  is present in standard C++).
  
 Keyword
  
 Option to Enable
  
 Option to Disable
  
 vector
  
 --vectors
  
 --no_vectors
  
 pixel
  
 --vectors
  
 --no_vectors
  
 bool
  
 --bool
  
 --no_bool
  
 __vector
  
 N/A
  
 __pixel
  
 N/A
  
 The following table documents the default settings for those compiler options:
  
 C & target microprocessor
  
 C & target microprocessor
  
 C++
  
  
 has AltiVec instructions
  
 does not have AltiVec
  
 instructions
  
 --no_vectors
  
 --no_vectors
  
 --no_vectors
  
  
 --no_bool
  
 --no_bool
  
 --bool",NA
New Intrinsic Functions for AltiVec,"6
  
 To access the intrinsic functions for AltiVec, include the header file
  <altivec.h>
 .
  
 6-35",NA
New Pragma for AltiVec,"6
  
 #pragma altivec_vrsave { on | off | allon | allzero }
  
 The
  allzero
  option will set the VRSAVE register to zero in the procedure in which it is 
 used. Refer to Motorola documentation for the other options.",NA
varargs/stdarg for AltiVec ,"6
  
 The base 5.3 release of Concurrent C/C++ has support
  varargs
 /
 stdarg
  for vector 
 types. However, PowerMAX OS release 5.1 or later header files and libraries are required 
 to use this feature.",NA
Runtime for AltiVec ,"6
  
 The Motorola defined
  vec_malloc()
 ,
  vec_calloc()
 ,
  vec_realloc()
 , and 
 vec_free()
  are not implemented in the 5.0 release of PowerMAX OS. The standard 
 system allocation routines -
  malloc()
 ,
  calloc()
 ,
  realloc()
 , and
  free()
  
 respec-tively - return quadword aligned memory (except for
  free()
  obviously), and can 
 be used instead. Release 5.1 of PowerMAX OS includes these functions.",NA
Interoperability with Non-AltiVec for AltiVec ,"6
  
 The global variable
  __vectors_present
  allows the user to determine at runtime 
 whether the system on which the program is running supports the AltiVec instruction set. 
 Attempting to execute an AltiVec instruction on a system that does not support it will result 
 in an Illegal Instruction exception. Any procedure that contains AltiVec instructions may 
 have additional AltiVec instructions generated in the routines prolog and epilog.
  
 In order to provide both normal and AltiVec accelerated versions of a routine, the follow-ing 
 code sequence is recommended:
  
 6-36",NA
Environment Variables ,"6
  
 The environment variable
  USR_INCLUDE
  can be set to a directory to be used instead of 
 /usr/include
  on the standard include file search list. (Of course, this has no effect if 
 the front end has been configured to have an empty “standard list” of include files.)",NA
Diagnostic Messages ,"6
  
 Diagnostic messages have an associated
  severity
 , as follows:
  
 •
  Catastrophic errors indicate problems of such severity that the compilation 
 cannot continue. For example: command-line errors, internal errors, and 
 missing include files. If multiple source files are being compiled, any source 
 files after the current one will not be compiled.
  
 •
  Errors indicate violations of the syntax or semantic rules of the C or C++ 
  
 language. Compilation continues, but object code is not generated.
  
 •
  Warnings indicate something valid but questionable. Compilation contin-
  
 ues and object code is generated (if no errors are detected).
  
 •
  Remarks indicate something that is valid and probably intended, but which a 
 careful programmer may want to check. These diagnostics are not issued by 
 default. Compilation continues and object code is generated (if no errors are 
 detected).
  
 Diagnostics are written to
  stderr
  with a form like the following:
  
 6-37",NA
Termination Messages ,"6
  
 n
  errors detected in the compilation of ""
 ifile
 "".
  
 1 catastrophic error detected in the compilation of ""
 ifile
 "".
  
 n
  errors and 1 catastrophic error detected in the compilation of ""
 ifile
 "".
  
 is written to indicate the detection of errors in the compilation. No message is writ-
 ten if no errors were detected. The following message
  
 Error limit reached.
  
 is written when the count of errors reaches the error limit (see the
  -e
  option, above); 
 compilation is then terminated. The message
  
 Compilation terminated.
  
 is written at the end of a compilation that was prematurely terminated because of a 
 catastrophic error. The message
  
 Compilation aborted.
  
 is written at the end of a compilation that was prematurely terminated because of an 
 internal error. Such an error indicates an internal problem in the compiler and should 
 be reported to those responsible for its maintenance.
  
 6-39",NA
Response to Signals,"6
  
 The signals
  SIGINT
  (caused by a user interrupt, like
  ^C
 ) and
  SIGTERM
  (caused by a 
 kill
  command) are trapped by the front end and cause abnormal termination.",NA
Exit Status ,"6
  
 On completion, the front end returns with a code indicating the highest-severity diagnostic
  
 detected: 4 if there was a catastrophic error, 2 if there were any errors, or 0 if there were
  
 any warnings or remarks or if there were no diagnostics of any kind.
  
 If multiple source files are compiled, the exit status indicates the highest-severity diagnos-
  
 tic detected in the entire compilation.",NA
Finding Include Files ,"6
  
 A file name specified in a
  #include
  directive is searched for in a set of directories spec-
 ified by command-line options and environment variables. If the file name specified does
  
 not include a suffix, a set of suffixes is used when searching for the file.
  
 Files whose names are not absolute pathnames and that are enclosed in
  ""...""
  will be 
 searched for in the following directories, in the order listed:
  
 1. The directory containing the current input file (the primary source file or the 
 file containing the
  #include
 );
 6
  
 2. any directories specified in
  --include_directory
  options (in the order 
 in which they were listed on the command line);
  
 3. any directories on the standard list (
 /usr/include
 ).
  
 For file names enclosed in
  <...>
 , only the directories that are specified using the
 --
 include_directory
  option and those on the standard list are searched. If the direc-
 tory name is specified as “
 -
 ”, e.g., “
 -I-
 ”, the option indicates the point in the list of
 --
 include_directory
  options at which the search for file names enclosed in
  <...> 
 should begin. That is, the search for
  <...>
  names should only consider directories named 
 in
  --include_directory
  options following the
  -I-
 , and the directories of item 3 
 above.
  -I-
  also removes the directory containing the current input file (item 1 above) 
 from the search path for file names enclosed in
  ""...""
 .
  
 An include directory specified with the
  --sys_include
  option is considered a “sys-
 tem” include directory. Warnings are suppressed when processing files found in system
  
 6. However, if
  STACK_REFERENCED_INCLUDE_DIRECTORIES
  is TRUE, the directories of all the source input files cur-
  
 rently in use are searched, in reverse order of
  #include
  nesting.
  
 6-40",NA
7 ,NA,NA
Compilation Modes,"ANSI C Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Normal C++ Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Strictly-Conforming Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 cfront
  2.1 Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 cfront 3.0 Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Transition Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Old Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Mode Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Common Features. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Differentiating Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Preprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Type-Promotion Rules. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Binary Operator Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Escape Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Redeclaration of Typedefs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Scope of Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Header File Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Function Prototypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Name-Space Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Library Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Locale-Support Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Anachronism Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7-2 
  
 7-2 
  
 7-3 
  
 7-4 
  
 7-4 
  
 7-4 
  
 7-5 
  
 7-6 
  
 7-6 
  
 7-7 
  
 7-7 
  
 7-10 
 7-13 
 7-14 
 7-14 
 7-15 
 7-15 
 7-15 
 7-16 
 7-16 
 7-18 
 7-18",NA
7 ,Chapter 7,NA
Compilation Modes,"7 
  
 7 
  
 7 
  
 This chapter describes the compilation modes of the Concurrent C++ compiler,
  ec++
  and 
 the Concurrent C compiler,
  ec
 . Compiler options let you select a compilation mode; the 
 modes are differentiated by their support for various dialects of C and C++.
  
 Compilation modes are selected via compiler options. They are distinguished by their level 
 of conformance to the ANSI C++ and ANSI C standards and dialects of C and C++. Table 
 7-1 depicts these modes and their command-line options.
  
 Table 7-1. C++ Compilation Modes
  
 cc++
  Options
  
 Mode
  
 Description
  
 (none
 )
  
 Normal C++ mode
  
 Accept normal ANSI C++ code.
  
 --strict
  
 ANSI C++ strictly-conforming mode
  
 Compile any ANSI C++ strictly-conform-
  
 ing program.
  
 --strict_warning
  
 ANSI C++ stricting-conforming
  
 Like
  --strict
 , but generates warning 
 instead of error.
  
 mode (warn on non-conforming
  
 --cfront_2.1
  
 usage)
  
 Support compatibility with
  cfront
  2.1.
  
 cfront
  2.1 compatibility mode
  
 --cfront_3.0
  
 cfront
  3.0 compatibility mode
  
 Support compatibility with
  cfront
  3.0.
  
 --anachronisms
  
 Anachronism mode
  
 Support various anachronisms (“Anachro-
  
 nisms Accepted” on page 5-5)
  
 From least to most conforming, these compilation modes for C are: Old, Transition, ANSI 
 C, and ANSI C Conforming. Table 7-1 depicts these modes and their command-line 
 options.
  
 Table 7-2. C Compilation Modes
  
 cc++
  Options
  
 Mode Name
  
 Description
  
 -Xo
  
 Old mode
  
 Compatibility mode for pre-ANSI C code.
  
 7-1",NA
ANSI C Mode ,"7
  
 ANSI C mode provides a nearly standard ANSI C compilation environment. All ANSI C 
 language syntax and semantics are obeyed. This mode differs from an ANSI C-conforming 
 compilation environment because it supports the full system name-space in the header files; 
 this allows access to all system macros and library routines even where forbidden for a 
 strictly conforming ANSI implementation.
  
 •
  All violations of ANSI C constraints on pointer type usage are diagnosed 
  
 with warning messages.
  
 •
  All system macros and library routines are available even where forbidden 
 for a strictly conforming ANSI C implementation. For more information on 
 name-space restrictions, see “Name-Space Restriction” on page 7-16.",NA
Normal C++ Mode ,"7
  
 This mode provides compatibility with the dialect of C++ described in the ARM. See Sec-
 tion “Extensions Accepted in Normal C++ Mode” on page 5-6 for more information.
  
 7-2",NA
Strictly-Conforming Mode,"7
  
 Strictly-conforming mode provides a compilation environment conforming to the emerging 
 ANSI C++ standard. All ANSI C name-space restrictions are enforced, and all violations of 
 ANSI C++ constraints and syntax rules produce warnings. This means that many variable 
 names, function names, and macro names are not defined in this mode. To compile in 
 strictly-conforming mode, invoke
  cc++
  with the
  --strict
  option. Strictly-conforming 
 mode has the following characteristics:
  
 Conforming mode is one of the three ANSI C compilation modes. This mode provides a 
 compilation environment conforming to ANSI C. It is identical to ANSI C mode except 
 that all ANSI C name-space restrictions are enforced, and all violations of ANSI C 
 constraints and syntax rules produce warnings. This means that many variable names, 
 function names, and macro names are not defined in this mode. To compile in Conforming 
 mode, invoke
  hc
  with the
  -Xc
  option. Aside from those features listed in Table 7-2, 
 Conforming mode has the following characteristics:
  
 •
  The compiler does not predefine macros that violate the ANSI C++ and 
 ANSI C name-space restrictions. Specifically, the predefined macros shown 
 below are not available:
  
 unix
  
 _unix
  
 •
  The following additional compiler error messages are generated for minor 
  
 violations of ANSI C++ and ANSI C syntax semantic constraints:",NA
-,"Warnings for the use of an extra comma at the end of
  enum
  type 
  
 declaration lists.",NA
-,Warnings for missing declaration specifiers in external definitions.,NA
-,"Warnings for missing semicolons for the last item in
  struct
  and 
  
 union
  declaration list.",NA
-,"Warnings for empty
  struct
  or
  union
  field declarations.",NA
-,Warnings for anonymous bit fields with empty type specifiers.,NA
-,Warnings for named bit fields with a size of zero.,NA
-,"Warning messages for empty (no tokens after preprocessing) source 
  
 files.",NA
-,"Fatal errors for the use of the
  $
  character in identifier names. (A fatal 
 error message is one for which
  ec++
  stops the compilation before 
 producing an object file and returns an error code to its parent 
 process.)",NA
-,"Fatal errors for the use of the
  sizeof
  on a bit-field. Normally
  cc++ 
  
 returns the size of the type of the bit-field.",NA
-,"Fatal error messages for using the
  &
  on variables declared with the 
 register storage class. Normally
  ec++
  just produces a warning 
 message.
  
 7-3",NA
cfront,NA,NA
 2.1 Compatibility Mode,"7
  
 This mode provides compatibility with the
  cfront
  2.1 dialect of C++. See “Extensions 
 Accepted in cfront 2.1 Compatibility Mode” on page 5-8 for more information.",NA
cfront 3.0 Compatibility Mode ,"7
  
 This mode provides compatibility with the
  cfront
  3.0 dialect of C++. See “Extensions 
 Accepted in cfront 2.1 and 3.0 Compatibility Mode” on page 5-9 for more information.",NA
Transition Mode ,"7
  
 Transition mode is one of the three ANSI C compilation modes. It is intended to help 
 customers convert their existing C code so it makes use of ANSI C semantics. This mode 
 provides all the features of ANSI C mode, but the compiler issues additional diagnostic 
 messages where ANSI C semantics conflict with the traditional semantics used in Old 
 mode. To compile in Transition mode, invoke
  cc++
  with the
  -Xt
  option.
  
 There are some cases where Transition mode cannot provide good diagnostics.
  
 •
  In Transition mode, the ANSI C preprocessor attempts to produce 
  
 diagnostics messages for
  cpp(1)
  preprocessing tricks but is unable to 
  
 splice tokens at the beginning or end of macros. For more information on 
  
 token-splicing, see “Preprocessing” on page 7-7 .
  
 •
  Other undocumented features of
  cpp(1)
  may also fail to receive 
  
 diagnostic messages.
  
 The illegal uses of type specifiers with typedefs generates syntax errors, 
 instead of cleaner diagnostic messages. For example,
  
 foo() 
  
 { 
  
  
 typedef int integer ; 
  
  
 { 
  
  
  
 short integer local ; 
  
  
 } 
  
 }
  
 generates the error messages
  
 ""file.c"", line 5: syntax: deleting, ' local ' 
  
 ""file.c"", line 5: syntax: inserting, ' , IDENTIFIER' prior to ' ; 
 '
  
 when compiled in any of the ANSI C compilation modes.
  
 •
  Transition mode attempts to generate warning messages for code whose 
 behavior may have changed because of changes in the default type-
 promotion rules or because of changes in the default types of literals. These
  
 7-4",NA
Old Mode ,"7
  
 Old mode provides maximal support for existing customer code and
  makefiles
 . How-
 ever, there have been some compiler changes that may require source changes even in Old 
 mode. These changes are discussed in “Library Enhancements” on page 7-16 .
  
 In addition to the information provided in Table 7-1 , Old mode has the following feature:
  
 •
  Some instances of illegal pointer usage receive caution messages rather than 
 warning messages. The printing of caution messages must be explicitly 
 enabled by using the
  -n
  option or the
  #pragma cautions 
 directive.
  
 7-5",NA
Mode Features,"7
  
 Each compilation mode has features that characterize it. These features are described in
  
 the following sections.",NA
Common Features ,"7
  
 The following ANSI C features are available in all compilation modes.
  
 •
  The function prototype syntax is always available. The PowerMAX OS 
 header files, however, only use function prototype declarations if one of the
  
 ANSI C compilation modes (see “Compilation Modes” on page 7-1) is
  
 used. Please refer to Chapter 9 of
  C: A Reference Manual
  by Harbison and
  
 Steele and “Function Prototypes” on page 7-15 in this manual for more
  
 information about function prototypes.
  
 •
  Initializers for automatic aggregate data objects such as structures and 
  
 arrays are accepted in all compilation modes.
  
 •
  Unions may be initialized. ANSI C defines the initializer for a union to 
  
 initialize its first element.
  
 •
  File-scoped declarations that use the
  extern
  storage class may be 
  
 initialized, thus producing a definition.
  
 •
  The
  long 
  
 double
  data type is supported. As currently implemented, 
  
 long double
  objects are of the same size and data format as objects of 
  
 type
  double
 , however, future releases may use an extended-precision 
  
 implementation for
  long double
 .
  
 •
  Integer constants are permitted to use the “unsigned” suffixes
  'u'
  and 
 'U'
 . 
 For example, an integer literal of the form 123u or 123U has the type 
 unsigned int
  rather than type
  int
 . Note: the
  u
  and
  U
  suffixes did 
 not exist before ANSI C.
  
 •
  Floating-point constants accept the suffixes
  'f'
  or
  'F'
 , and
  'l'
  or
  'L' 
 to indicate
  float
  type or
  long double
  type constants, respectively. 
 For example, 3.1415f and 3.1415F both produce constants with type
  
 float
 , while 3.1415l and 3.1415L produce constants with type
  long 
 double
 .
  
 •
  String constants that are separated by only white space are automatically 
  
 concatenated. For example:
  
 ""hello"" "" world\n""
  
 is treated as
  
 ""hello world\n""
  
 rather than as a syntax error.
  
 •
  The
  signed
 ,
  const
 , and
  volatile
  keywords are always recognized by 
  
 the compiler in Old mode.
  
 7-6",NA
Differentiating Features ,"7
  
 The C language defined by the ANSI C standard has a number of incompatibilities with 
 older dialects of the language. This section attempts to explain the major areas of 
 incompatibility introduced by the ANSI C standard that are likely to have significant 
 impact on existing source code.
  
 Preprocessing 
  
 7
  
 Older releases of the C compiler used an internal preprocessor. Now, in Old mode the 
 compiler uses the traditional UNIX preprocessor
  cpp(1)
 . In either case, ANSI C-specific 
 preprocessing features are not available.
  
 The ANSI C compilation modes use the
  /usr/ccs/lib/acpp
  preprocessor. This is a 
 separate standalone preprocessor written to the ANSI C standard. (This processor is not 
 considered to be a separately supported tool, but rather as a part of the compiler. A man 
 page is not provided, and future releases of the C compiler may not provide it as a separate 
 tool. Customers should not introduce any dependencies on its existence or undocumented 
 aspects of its behavior.)
  
 Providing the first complete specification of the C preprocessor is the ANSI C standard’s 
 most significant change. This change introduced a number of incompatibilities with the 
 preprocessing supported by the traditional UNIX preprocessor
  cpp(1)
  and with the 
 internal preprocessor used by older releases of the C compiler. These incompatibilities are:
  
 •
  Trigraphs are sequences of three adjacent characters that are mapped into 
 single characters during the first translation phase (before string constants 
 and comments have been recognized). These sequences are provided to 
 support non-ASCII hardware environments where certain common C 
 characters are not available. The trigraphs are shown in Table 7-3 .
  
 The trigraph sequences are seldom encountered in non-ANSI C source; 
 however, they do introduce a potential incompatibility for some uses in 
 string constants, character constants, or in
  #include
  header file names. 
 For example, the following statement appears differently in Old mode and 
 in ANSI C mode after trigraph substitutions:
  
 Old mode:
  
 printf(""warning: very strange error condition??!\n"");
  
 ANSI C mode:
  
 printf(""warning: very strange error condition|\n"");
  
 7-7",NA
-,sizeof(unsigned char) < sizeof(unsigned short),NA
-,sizeof(unsigned short) < sizeof(int),NA
-,"sizeof (int) == sizeof(long)
  
 This means that under the value-preserving rules, expressions 
 involving
  unsigned char
  and
  unsigned short
  types 
 promote to signed
  int
  type, instead of
  unsigned int
  as they 
 would under the unsigned-preserving rules. Expressions promote to
  
 unsigned int
  types only if an
  unsigned int
  appeared 
 explicitly 
 in 
 the 
 expression. 
 Likewise, 
 expressions 
 mixing
  
 unsigned int
  types with
  long
  types still promote to
  
 unsigned long
  under the value-preserving rules (because
  
 sizeof(int) == sizeof(long)
 , on all current targets).
  
 •
  Information about the implicit data-typing of integer constants follows:
  
 ANSI C introduced new rules for determining the data types of integer 
 constants (decimal, hex, and octal constants). In Old mode, these constants 
 are always treated as having signed
  int
  or signed
  long
  (if the
  L
  suffix 
 is used) type. You may apply the ANSI
  'u'
  or
  'U'
  unsigned suffix and 
 force the literals to have
  unsigned int
  or
  unsigned long
  type (if 
 the
  L 
 suffix is also used).
  
 The ANSI C standard specifies that the data types of integer constants are 
 chosen by picking the smallest type that can represent the constant value in 
 the list below. Like the value-preserving type-promotion rules (discussed 
 before), this rule depends on a particular implementation’s representation of 
 the
  int
  and
  long
  data types. In Table 7-4 parenthesized data types are 
 valid for ANSI C but are redundant for cc++ because cc++ implements the 
 int
  and
  long
  data types with the same 32-bit two’s complement 
 representation.
  
 Table 7-4. Constants and Type Lists
  
 Constant
  
 Type List
  
 unsuffixed decimal: 
  
 unsuffixed hex or octal:
  
 int, (long), unsigned long 
  
 int, unsigned int, (long), (unsigned long)
  
 7-11",NA
Header File Features ,"7
  
 The header files under
  /usr/include
  provide the following support for ANSI C:
  
 •
  Meet ANSI C requirements on their contents
  
 •
  Allow you to take advantage of the additional compile-time error checking 
  
 available with function prototypes",NA
Function Prototypes ,"7
  
 Function prototypes are available for functions declared in most system header files. This 
 has two advantages:
  
 •
  The compiler can do better error-checking on the type and number of 
  
 arguments to library routine calls.
  
 •
  The single-precision math library routines can be used (assuming 
 #include <math.h>
  appears) without resorting to the
  -fsingle2 
 command-line option to
  cc++
 .
  
 7-15",NA
Name-Space Restrictions ,"7
  
 The system header files contain conditional compilation code (
 #ifdef __STDC__
 ) that 
 controls the enforcement of ANSI C restrictions on their contents. In Old mode, the 
 __STDC__
  macro is undefined; this means that ANSI C syntax, semantics, and name-
 space restrictions are not enforced. In ANSI C conforming mode (
 -Xc
  option), the 
 __STDC__
  macro is defined to be 1, causing enforcement of the ANSI C syntax, 
 semantics, and name-space restrictions. In Transition mode and ANSI C mode, the 
 __STDC__
  macro is defined to be 0 (zero), indicating use of ANSI C syntax and semantics 
 but not the enforcement of ANSI C name-space restrictions.
  
 A POSIX
 TM
 -conforming name-space may be achieved in any compilation mode by 
 defining the macro
  _POSIX_SOURCE
  before any header files are included (the POSIX 
 1003.1 name-space is a superset of ANSI C name-space).
  
 In Figure 7-1, the User Name-Space represents the universe of identifiers, the ANSI C and 
 C++ Name-Space represents the identifiers defined by the ANSI C and C++ stan-dards, and 
 the shaded region represents identifiers that are defined in ANSI C and C++ header files 
 but that are not defined by the ANSI C and C++ standards. The shaded region is given to 
 the user in Conforming mode but is given to the system in all other modes.
  
 User 
  
 Name-Space
  
 ANSI C/C++
  
 Name-Space
  
 Figure 7-1. Name-Space Restriction",NA
Library Enhancements ,"7
  
 ANSI C specified a number of minor changes in the run-time behavior of several C library 
 routines. Where ANSI changes conflict with existing practice, the library behavior is 
 determined by the compilation mode specified on the command line when the final 
 executable is linked. Care must be taken with
  makefiles
  (or other ad hoc
  make 
 procedures) that do not automatically include compilation options with the link command 
 or which create the final executable by using
  ld(1)
  directly.
  
 7-16",NA
Locale-Support Enhancements,"7
  
 The following additional support is now provided by
  cc++
 :
  
 •
  The
  LC_COLLATE
  locale category is now supported:
  
 •
  A new tool,
  colltbl(1M)
 , is provided to define locale-dependent 
  
 collating sequences.
  
 •
  setlocale(3C)
  has been enhanced to support the
  LC_COLLATE 
  
 category.
  
 •
  Two new library routines,
  strxfrm(3C)
  and
  strcoll(3C)
 , are 
 provided to support programs that wish to make use of locale-dependent
  
 collating sequence information.
  
 •
  The following enhancements have been made to
  chrtbl(1M)",NA
-,"chrtbl
  now supports definition of the
  LC_NUMERIC
  (non-
 monetary numeric formatting information) locale data file.
  
 Previously, this data file had to be created manually. See
  
 localeconv(3C)
 .",NA
-,"chrtbl
  now contains preliminary support for the definition of multi-
 byte and wide-character locale definitions. This is done with
  
 the
  cswidth chrtbl
  specifier.
  
 Multi-byte locales are not currently supported, and these features are unused.",NA
Anachronism Mode ,"7
  
 This mode supports various anachronisms from
  cfront
  dialects of C++. See “Anachro-
 nisms Accepted” on page 5-5 for more information.
  
 7-18",NA
8 ,NA,NA
Runtime Libraries,"Runtime Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Language Support Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 Template Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 Cfront Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 8-1 
 8-1 
 8-1 
 8-2 
 8-2 
 8-3",NA
8 ,Chapter 8,NA
Runtime Libraries,"8 
  
 8 
  
 8 
  
 This chapter identifies the libraries provided with the Concurrent C++ compilation sys-tem. 
 This release of the compilation system includes runtime libraries that nearly in full 
 compliance with
  The ISO/IEC 14882:1998(E) C++ Standard
 .
  
 Previous releases included specialized C++ class libraries from another vendor. The core, 
 standardized functionality in those libraries is now supported by the runtime library, and 
 third-party libraries have been removed from the general release. They are available sepa-
 rately, however, for customers who rely heavily on the specialized functionality therein.
  
 The set of C-compatible system runtime libraries provided in Concurrent’s PowerMAX 
 operating system, such as the math library and the networking libraries, may be included in 
 programs compiled with the Concurrent C++ compilation system. The
  ec++
  driver 
 always includes the standard C library among the libraries whose names are passed to the 
 link editor.
  
 The runtime library provided with the Concurrent C++ compilation system is:
  
 •
  Runtime Library:
  libCruntime
  
 In addition, the following third-party libraries are available from Concurrent separately:
  
 •
  Cfront Libraries
  
 •
  I/O Library:
  libCio
  
 •
  Complex Library:
  libCcomplex",NA
Runtime Library ,8,NA
General ,"8
  
 The runtime library (
 libCruntime
 ) includes Concurrent’s implementation of the C++ 
 Standard Library and the Language Support Library. A description of the Standard Library 
 is beyond the scope of this manual, but there are many good references available at 
 bookstores.",NA
Language Support Library ,"8
  
 The Language Support Library provides the following support:
  
 •
  characteristics of predefined types
  
 8-1",NA
Linking ,"8
  
 The runtime library is provided in 4 forms: static (
 libCruntime.a
 ), shared (
 lib-
 Cruntime.so
 ), thread-safe static (
 libCruntime_mt.a
 ), and thread-safe shared 
 (
 libCruntime_mt.so
 ). The appropriate library is chosen based on the command line 
 options used when invoking the compiler. These are summarized in Table 8-1.
  
 Table 8-1. Choice of Runtime Library
  
  
  
 -Zlink=static
  
 -Zlink=dynamic
  
 (default)
  
 threads
  
 -lthread 
 (default)
  
  
 libCruntime_mt.
 a 
 (thread-safe static)
  
 libCruntime.a 
 (static)
  
 libCruntime_mt.so 
 (thread-safe shared)
  
 libCruntime.so 
 (shared)
  
  
 Note that any sources that use the
  <iostream>
  header, and whose object files are to be 
 linked with the -lthread option, should be compiled with the
  -D_REENTRANT
  option to 
 specify thread safety.",NA
Template Instantiation ,"8
  
 A common source of confusion when using the runtime library is template instantiation. 
 Certain templates, are instantiated in the library, either because they are required by the 
 standard, they are needed by other parts of the library, or for convenience. Notably, many 
 I/O template routines are instantiated for the types
  char
  and
  wchar_t
 . This is nice 
 because simple programs can often be compiled without using any special command-line 
 options or explicit instantiation in the source code. However, it can oversimplify the situ-
 ation for user programs including template code.
  
 When using template code with the C++ compiler, it is important to be familiar with the 
 template instantiation command-line options. See “C++ Specific Features” on page 1-18 
 ,“Template Instantiation” on page 6-3, and “Template Instantiation Pragmas” on page 6-28.
  
 8-2",NA
Cfront Libraries,"8
  
 In previous releases of the C++ compiler, Concurrent supplied a version of AT&T’s cfront 
 libraries. These libraries are no longer shipped with the compiler. They are available sep-
 arately, but their use is discouraged. It is recommended that code using the older cfront 
 libraries be migrated to the C++ Standard Library instead. Support for the cfront libraries 
 will be dropped entirely in a future release.
  
 I/O Library
  
 The cfront I/O library (
 libCio
 ) has been replaced by the I/O support in 
  
 the Standard Library.
  
 Complex LibraryThe cfront complex library (
 libCcomplex
 ) has been replaced by the 
 complex template class in the Standard Library.
  
 If you insist on using the cfront libraries, you will need the
  --cfront_io
  command-line 
 option which tells the compiler to use the old cfront I/O and which makes the compilation 
 link with
  libCio
 .
  
 When using the cfront complex library, you must explicitly tell the compiler to link with the
  
 libCcomplex
  by using the
  -lCcomplex
  option.
  
 8-3",NA
A ,Appendix A,NA
ANSI C++ Implementation,"1 
  
 1 
  
 1 
  
 Although the ANSI C++ Working Paper defines many details of the C++ language, it leaves 
 some areas to be defined by the implementation. This appendix explains how the Concurrent 
 ANSI C++ implementation defines those areas. The appendix identifies each portion of the 
 April 28, 1995, Working Paper which specifies an implementation-defined characteristic, 
 along with the definition used in the Concurrent implementation.",NA
Lexical Conventions (Chapter 2) ,1,NA
Phases of Translation (2.1) ,"1
  
 Nonempty sequences of white-space characters are retained by the compiler.",NA
Character Literals (2.9.2) ,"1
  
 The value of a multicharacter literal that does not begin with the letter
  L
  is encoded into an 
 integer character constant as follows:
  
 'a' 
  
 'ab' 
  
 'abc' 
  
 'abcd'
  
 = 'a' 
  
 = 'a'<< 8 | 'b' 
  
 = 'a'<<16 | 'b'<< 8 | 'c' 
  
 = 'a'<<24 | 'b'<<16 | 'c'<<8 | 
 'd'
  
 Wide-character literals are only supported for single-character sequences. The value of a 
 wide-character literal is the value of the right-most character enclosed in the single quotes.
  
 If the value of the selected character in a character literal exceeds that of the largest
  char 
 or
  wchar_t
 , the right-most byte of the selected character is regarded as the value of the 
 character literal.",NA
String Literals (2.9.4) ,"1
  
 All string literals are distinct (that is, are stored in non-overlapping objects). The compiler
 -
 R
  option may be used, however, to pool string literals.
  
 A-1",NA
Basic Concepts (Chapter 3) ,NA,NA
Types (3.9),"1
  
 1
  
 See Table 6-2, “Alignments by Data Type” for the alignment requirements of the various 
 object types.",NA
Main Function (3.6.1) ,"1
  
 The type and the parameters of the
  main
  function are: 
  
  
 int main (int argc, char *argv[], char *envp[]); 
 The
  main
  function has external linkage.",NA
Fundamental Types (3.9.1) ,"1
  
 Table A-1 shows the sizes and value ranges of floating–point types. (The epsilon of a type 
 is the difference between one and the next largest number that can be represented.) Table 
 A-2 shows the sizes and value ranges of integer types
  
 Table A-1. Floating-Point Types
  
 Designation
  
 Size (bits)
  
 Range (decimal)
  
 float
  
 32
  
 1.175494350822287e-38 through 
 3.4028234663852888540e+38 
 (The epsilon is 1.19209290e-07.)
  
 double
  
 64
  
 2.22507385850720140e-308 through 
 1.79769313486231470e+308 
  
 (The epsilon is 2.77555756156289e-17.)
  
 long double
  
 64
  
 2.22507385850720140e-308 through 
 1.79769313486231470e+308 
  
 (The epsilon is 2.77555756156289e-17.)
  
 A-2",NA
Standard Conversions (Chapter ,NA,NA
4) ,NA,NA
Integral Conversions (4.7),"1
  
 1
  
 When an integer type value is converted to a shorter integer type value, the original value is 
 truncated, discarding the high-order bits which do not fit in the new type.",NA
Expressions (Chapter 5) ,1,NA
Reinterpret Cast (5.2) ,"1
  
 When a pointer is converted to an integral type, the mapping function is a conversion of the 
 value of that pointer to the integral type, as if an explicit cast had been done to that integral 
 type.
  
 When an integral type is converted to a pointer, the mapping function is a conversion from 
 the integral type to a value that can be represented as an
  unsigned int
 , as if an 
 explicit cast had been done to
  unsigned int
 . The programmer must ensure that the 
 value of the pointer represents a correct alignment of the type pointed to.",NA
Sizeof (5.3.3) ,"1
  
 sizeof(bool)
  is 1.
  
 sizeof(wchar_t)
  is 4.
  
 The result of the
  sizeof
  operator is a constant of type
  unsigned int
 .",NA
Multiplicative Operators (5.6) ,"1
  
 In the operation
  E1 % E2
 , the sign of the remainder is the sign of
  E1
 .",NA
Additive Operators (5.7) ,"1
  
 The result of subtraction of two pointers to elements of the same array object is of type 
 signed int
 .
  
 A-4",NA
Shift Operators (5.8),"1
  
 In the operation
  E1 >> E2
 , if
  E1
  is negative, the vacated bits of
  E1
  are one-filled.",NA
Relational Operators (5.9) ,"1
  
 Other pointer comparisons produce a result equivalent to that produced by a comparison of 
 the pointer values each cast to type
  unsigned in
 t.",NA
Declarations (Chapter 7) ,1,NA
The asm declaration (7.4) ,"1
  
 asm()
  is regarded as an ordinary function declaration. It is not used to provide inline 
 assembly language code in a C program.",NA
Linkage Specifications (7.5) ,"1
  
 Only the linkage specifications “C” and “C++” are valid.
  
 Linkage from C++ to objects defined in other languages, or from other languages to objects 
 defined in C++, can be achieved by specifying
  
 extern “C” { 
  
 }
  
 around the declarations of the objects in the C++ code. Note that the objects’ link-level 
 names, when used in languages other than C++, must be the same as the names specified in 
 the linkage specification declaration. Linkage can also be achieved without use of the C 
 linkage specification, provided that the objects’ link-level names, when used in languages 
 other than C++, match the “mangled” names produced by the Concurrent C++ compiler.",NA
Declarators (Chapter 8) ,1,NA
Default Arguments (8.3.6) ,"1
  
 The order of evaluation of function arguments varies according to such factors as the 
 context of the function call, the level of optimization used in compilation, etc.
  
 A-5",NA
Classes (Chapter 9) ,NA,NA
Class Members (9.2),"1
  
 1
  
 Non-
 static
  data members separated by an access specifier are allocated within a class 
 object in order of declaration. If member
  y
  is declared after member
  x
 , member
  y
  has a 
 higher address than does member
  x
 .",NA
Bit-fields (9.7) ,"1
  
 Bit-fields are allocated from left to right (most to least significant bits). Bit-fields never 
 cross over an alignment boundary for their type. However, multiple bit-fields which are 
 sufficiently small may occupy the same allocation unit. For example, two
  int
  bit-fields 
 whose total size is less than 32 bits may share a single 32–bit word.
  
 However, if the first
  int
  bit-field is 17 bits and the second is 16 bits, there are 15 padding 
 bits between them. Bit-fields may also share their allocation unit with other
  struct 
 members. For example, a 16-bit
  int
  bit-field followed by a
  short
  occupies one 32–bit 
 word.
  
 A plain
  int
  bit-field is unsigned.",NA
Special Member Functions (Chapter 12) ,1,NA
Temporary Objects (12.2) ,"1
  
 The creation of temporaries by the compiler varies according to such factors as the context 
 of the function call, the level of optimization used in compilation, etc.",NA
Preprocessing Directives (Chapter 16) ,1,NA
Conditional Inclusion (16.1) ,"1
  
 Since the source and destination character sets are identical, character constants have the 
 same value whether they are in a preprocessing conditional statement or are in source code 
 which is passed by the preprocessor to the compiler.
  
 The above holds for the 7-bit ASCII characters. 8-bit characters are treated as unsigned by 
 the preprocessor.
  
 A-6",NA
Source File Inclusion (16.2),"1
  
 Includable source files whose names do not begin with “
 /
 ” are searched for in the 
 following manner:
  
 If the name is enclosed in double-quotes (
 “”
 ), the file is searched for in the directory of the 
 file containing the
  #include
  statement. If that search fails, or if the name is enclosed 
 between a
  <
  and a
  >
 , the file is searched for under
  /usr/include
 . This behavior can 
 be modified by using the
  -I
  command-line option. Refer to the
  cc++(1)
  man page for 
 more details.
  
 The name of the file to be included is the full name by which the file is known to the
  
 operation system. This may include an absolute or relative path. For example:
  
 <stdio.h> 
  
 Refers to
  /usr/include/stdio.h
  
 <sys/time.h> 
  
 Refers to
  /usr/include/sys/time.h
  
 ""
 /usr/include/sys/time.h
 "" 
  
  
 Also refers to
  
 /usr/include/sys/time.h
  
 ""
 fleas.h
 ""
  
 Searches for
  fleas.h
  first in the directory where 
 the including file is located, then in
  
 1
  
 ""
 sys/fleas.h
 ""
  
 /usr/include
  
 Searches for
  fleas.h
  in the
  sys
  subdirectory 
 (if any) of the directory in which the 
 including",NA
Predefined Macro Names (16.8),"file
  
 is
  
 located,
  
 then
  
 in
  
 /usr/include/sys.
  
 The date and time are always provided by the operating system. Therefore, no defaults
  
 exist for situations where the date and time of translation are not available.
  
 See “Predefined Macros” on page 6-17 for the definition of
  the __STDC__
  macro.",NA
Headers (Chapter 17) ,1,NA
Freestanding Implementations (17.3.1.3) ,"1
  
 The implementation provided in the Concurrent C++ compilation system is hosted. A
  
 freestanding implementation is not provided.
  
 A-7",NA
Library Introduction (Chapter 17) ,NA,NA
Reentrancy (17.3.4.5),"1
  
 1
  
 The following libraries are included:
  
 •
  C 
  
 system 
  
 library: 
 /usr/ccs/lib/libc.a 
  
 and
  
 /usr/ccs/lib/libc.so 
  
 provide r eentran cy;
  
 /usr/ccs/lib/libnc.a
  does not.
  
 •
  C++ runtime support library:
  /usr/ccs/lib/libCruntime.a
  does
  
 not provide reentrancy.
  
 •
  C++ I/O support library:
  /usr/ccs/lib/libCio_mt.a
  provides
  
 reentrancy;
  /usr/ccs/lib/libCio.a
  does not.",NA
Language Support Library ,1,NA
Class bad_alloc (18.4.2.1) ,"1
  
 what()
  returns the empty character string (
 ““
 ).",NA
Class bad_cast (18.5.2) ,"1
  
 what()
  returns the empty character string (
 ““
 ).",NA
Class bad_typeid (18.5.3) ,"1
  
 what()
  returns the empty character string (
 ““
 ).",NA
Class bad_exception (18.6.2.1) ,"1
  
 what()
  returns the empty character string (
 ““
 ).",NA
Class exception (18.6.1) ,"1
  
 what()
  returns the empty character string (
 ““
 ).
  
 A-8",NA
Input/Output Library (Chapter 27) ,NA,NA
Types (27.4.1),"1
  
 1
  
 The type
  streamoff
  is of type
  long
 .
  
 The type
  wstreamoff
  is not currently supported in the Concurrent C++ compilation sys-
 tem.
  
 The type
  streampos
  is of type
  long
 .
  
 The type
  wstreampos
  is not currently supported in the Concurrent C++ compilation 
 system.",NA
basic_ios iostate flags functions (27.4.4.3) ,"1
  
 The class
  basic_ios::failure
  is not currently supported in the Concurrent C++ 
 compilation system.",NA
Standard Manipulators (27.6.3) ,"1
  
 The type
  smanip
  is not currently supported in the Concurrent C++ compilation system. 
 The class
  SMANIP
  is supported. See
  manip(3c++)
  for more information.",NA
Compatibility (Appendix C) ,1,NA
Predefined Names (16.8) ,"1
  
 See “Predefined Macros” on page 6-17 for the definition of
  the __STDC__
  macro.
  
 A-9",NA
B ,Appendix B,NA
Architecture Dependencies,"2 
  
 2 
  
 2 
  
 The PowerPC-based systems targeted by the Concurrent C/C++ compilation system are 32-
 bit word, two’s complement computers. These systems support the following major data 
 types: bit, byte, half-word, word, double-word, and floating-point.",NA
Bit-Field ,"2
  
 A
  bit-field
  is a structure member or union member that consists of 1 through 31 contigu-ous 
 bits. Bit-fields may be of type
  unsigned int
 ,
  int
 , and
  signed int
 . The 
 compiler also allows them to be of types
  unsigned
 ,
  signed
 ,
  char
 , and
  short
 . 
 Fields that are declared to be
  unsigned int
  are zero-extended to
  unsigned int
  
 type when used in an expression. Similarly, fields declared to be of type
  signed int
  
 are sign-extended to
  int
  type. Fields that are not explicitly declared to be signed or 
 unsigned are zero-extended to
  unsigned int
  type. The use of bit-fields is often not 
 portable.
  
 The C/C++ compiler determines how bit-fields and structure members that take up less than 
 a word are stored. Each of the following rules is applied before a member is stored.
  
 •
  Members are packed in the order in which they were declared.
  
 •
  Members are packed as tightly as possible.
  
 •
  Members’ data-alignment rules are followed.
  
 •
  Members do not cross their storage unit boundaries; for example, if a field 
 does not fit into the remaining space left in a word, it is placed into the next 
 word. Fields declared as
  char
  or
  short
  behave just like int fields except 
 that instead of word boundaries, they do not cross
  char
  and
  short 
 boundaries, respectively.
  
 •
  Unused space in storage units is padded.
  
 Figure B-1 shows how the system stores sequentially defined bit-fields.
  
 B-1",NA
Byte ,"2
  
 A
  byte
  contains eight bits starting on an addressable byte boundary. The most significant 
 bit (MSB) designates the byte’s address. Figure B-2 shows the address and MSB of a byte 
 in the system.
  
  
 0 
  
 7
  
  
 Address MSB
  
  
 Figure B-2.
  
 Address and MSB of a Byte
  
 If the byte is an unsigned integer, then its value is in the decimal range 0 - 255 (binary 
 00000000 - 11111111).
  
 If the byte is a signed numeric integer, then it contains a two’s complement value. As a 
 two’s complement number, a byte represents a decimal ranging from -128 to +127.
  
 The following C/C++ data types take up one byte:
  unsigned char
 ,
  char
 ,
  signed 
 char
 . The default for the Concurrent C/C++ compiler is to treat plain
  char
  variables as 
 being unsigned.
  
 B-2",NA
Half-Word ,"2
  
 A 16-bit
  half-word
  contains two bytes and starts on an addressable 16-bit word boundary. 
 Figure B-3 shows that the MSB of the most significant byte is the half-word’s address.
  
  
 0
  
 Byte 0
  
 7 8
  
 Byte 1
  
 15
  
  
 Address MSB
  
  
 Figure B-3.
  
 Address and MSB of a Half-Word
  
 If the half-word is an unsigned integer, then its decimal value ranges from 0 to 64K-1. If 
 the half-word contains a signed numeric integer, then its two’s complement value ranges 
 from decimal -32K to +32K-1.
  
 The following C/C++ data types take up one half-word:
  unsigned short
 ,
  short, 
 signed short
 .",NA
Word ,"2
  
 A
  word
  contains four bytes (32 contiguous bits). The word’s address may be a word 
 boundary or a CPU register. The MSB is the word’s address. See Figure B-4. .
  
  
 Address
  
 Byte 0
  
 Byte 1
  
 Byte 2
  
 Byte 3
  
 MSB
  
  
  
 Figure B-4.
  
 Address and MSB of a Word
  
 If the word is an unsigned integer, then its value ranges from decimal 0 to 2**32-1. As a 
 signed numeric value, a word represents an integer from -2**31 to +2**31-1.
  
 B-3",NA
Double Word ,"2
  
 A
  double word
  contains eight bytes (64 contiguous bits). The word’s address may be a 
 double word boundary or a CPU register. The MSB is the word’s address. See Figure B-5 .
  
  
 Byte 0
  
 Byte 1
  
 Byte 2
  
 Byte 3
  
 Byte 4
  
 Byte 5
  
 Byte 6
  
 Byte 7
  
 Word 0
  
 Word 1
  
 Address MSB
  
  
 Figure B-5.
  
 Address and MSB of a Double Word
  
 If the word is an unsigned integer, then its value ranges from decimal 0 to 2**64-1. As a 
 signed numeric value, a word represents an integer from -2**63 to +2**63-1.
  
 The following C/C++ data types take up two words:
  unsigned long long int
 , 
 long long int
 ,
  signed long long int
 , and
  double
 .",NA
Shift Operations ,"2
  
 The
  shift operators
  shift an integer by 0 through 31 bit positions to the left (
 <<
 ) or to the 
 right (
 >>
 ).
  
 shift-expression ::= e1 << e2
  
 e1 >> e2
  
 The operands are the integer to be shifted (e1) and the number of bit positions by which it 
 is to be shifted (e2). Both must be an integral type. The right operand, e2, must be within 
 the range 0 through 31.
  
 In a left shift, all 32 bits, including the sign bit, are shifted to the left, with zeros replacing 
 the vacated rightmost bits.
  
 B-4",NA
Floating-,NA,NA
Point,"Figure B-7.
  
 Left/Right Shift of Signed Integer
  
 2
  
 Figure B-8 shows the format of a 32-bit single-precision floating-point number.
  
  
 Address
  
 0
  
 S
  
 1
  
 E
  
 8 9
  
 F
  
 31
  
  
  
 Figure B-8.
  
 Single-Precision Floating-Point Format
  
 B-5",NA
C/C++ Data Types ,"2
  
 For a summary of the sizes and value ranges of the C/C++ data types, see Table A-1 and 
 Table A-2
  
 B-6",NA
Index,"Symbols
  
 ! 5-2 
  
 != 5-18 
  
 # 7-9 
  
 ## 5-15, 5-25, 7-8 
  
 ### 4-20 
  
 #assert 5-18 
  
 #else 5-23 
  
 #if 5-23 
  
 #include 5-23, 6-28 
  
 #line 6-9, 6-29 
  
 #pragma 6-1 
  
 #pragma align 6-25 
  
 #pragma cautions 6-23 
  
 #pragma do_not_instantiate 6-8 
 #pragma errcount 6-23 
  
 #pragma error 6-23 
  
 #pragma hdrstop 6-28, 6-32 
  
 #pragma ident 6-27 
  
 #pragma instantiate 6-8 
  
 #pragma min_align 6-26 
  
 #pragma no_pch 6-29, 6-32 
  
 #pragma once 6-27 
  
 #pragma opt_class 6-24 
  
 #pragma opt_level 6-24 
  
 #pragma optimize_for_space 6-24 
 #pragma optimize_for_time 6-24 
 #pragma warnings 6-23 
  
 #pragma weak 6-27 
  
 $ 7-3 
  
 %lld 5-16 
  
 & 7-3 
  
 && 5-2 
  
 . 5-8 
  
 .ti 6-5 
  
 /**/ 5-20, 5-25 
  
 /*ARGSUSED*/ 5-14 
  
 /*NOTREACHED*/ 5-14 
  
 /*VARARGS*/ 5-14 
  
 :: 5-8 
  
 :: template 5-4 
  
 << 5-21 
  
 == 5-18
  
 -> 5-25 
  
 >> 5-21
  
 ->template 5-4 
  
 ? 5-2, 5-7, 5-10, 5-20 
  
 5-20 
  
 \a 5-23 
  
 __ALIGNOF__ 5-16 
  
 __ARRAY_OPERATORS 6-18 
  
 __cplusplus 5-6 
  
 __DATE__ 6-29 
  
 __EDG__ 6-18 
  
 __EDG_IMPLICIT_USING_STD 6-18 
  
 __EDG_RUNTIME_USES_NAMESPACES 6-18 
 __EDG_VERSION__ 6-18 
  
 __embedded_cplusplus 6-18 
  
 __EXCEPTIONS 6-18 
  
 __INTADDR__ 5-17 
  
 __PLACEMENT_DELETE 6-18 
  
 __RTTI 6-18 
  
 __SIGNED_CHARS__ 1-25, 6-17 
  
 __STDC__ 5-22, 6-17, A-7, A-9 
  
 __STDC_VERSION__ 6-17 
  
 __TIME__ 6-29 
  
 __VA_ARGS__ 5-15 
  
 _BOOL 6-17 
  
 _FAST_MATH_INTRINSICS 1-33 
  
 _unix 7-3 
  
 _WCHAR_T 6-17 
  
 || 5-2
  
 A
  
 a.demangle
  4-16 
  
 acpp 7-7 
  
 Address space 3-7 
  
 Ambiguous units 2-14 
  
 anachronism 1-30, 5-1, 7-1 
  
 analyze 1-23, 1-24, 1-36 
  
 and 5-2 
  
 anonymous struct 5-19 
  
 anonymous union 5-6, 5-19 
  
 ANSI C 5-1, 7-2 
  
  
 compilation modes 7-2
  
 Index-1",NA
Progr,"Bar: 1"" x 1/8"" beginning 
 1/4"" in from either side
  
 C/C++ Ref 
  
 Manual
  
 0890497
  
 Part Number: Helvetica, 
  
 6 pt, centered, 1/8"" up",NA
