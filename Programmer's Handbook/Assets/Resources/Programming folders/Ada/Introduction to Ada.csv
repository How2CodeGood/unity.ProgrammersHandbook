Larger Text,Smaller Text,Symbol
Introduction to ,NA,NA
Ada ,NA,NA
Release ,NA,NA
2024-01,NA,NA
Raphaël Amiard ,NA,NA
and Gustavo A. Hoffmann,"Jan 31, 2024",NA
CONTENTS:,"1
  
 Introduction
  
 3
  
  
 2
  
 1.1
  
 History
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.2
  
 Ada 
 today
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.3
  
 Philosophy
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 1.4
  
 SPARK
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 Imperative language
  
 5
  
 3
  
 2.1
  
 Hello world
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 5
  
 2.2
  
 Imperative language - If/Then/Else
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 7
  
 2.3
  
 Imperative language - Loops
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 2.3.1
  
 For loops
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 9
  
 2.3.2
  
 Bare loops
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 2.3.3
  
 While loops
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 2.4
  
 Imperative language - Case statement
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 12
  
 2.5
  
 Imperative language - Declarative regions
  . . . . . . . . . . . . . . . . . . . . . .
  
 14
  
 2.6
  
 Imperative language - conditional expressions
  
 . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.6.1
  
 If expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.6.2
  
 Case expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 Subprograms
  
 1
 9
  
 4
  
 3.1
  
 Subprograms
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 3.1.1
  
 Subprogram calls
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 20
  
 3.1.2
  
 Nested subprograms
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 22
  
 3.1.3
  
 Function calls
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 3.2
  
 Parameter modes
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 3.3
  
 Subprogram calls
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 3.3.1
  
 In parameters
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 3.3.2
  
 In out parameters
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 3.3.3
  
 Out parameters
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 3.3.4
  
 Forward declaration of subprograms
  . . . . . . . . . . . . . . . . . . . . .
  
 27
  
 3.4
  
 Renamin
 g
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 Modular programming
  
 3
 1
  
 5
  
 4.1
  
 Packages
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 4.2
  
 Using a package
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 4.3
  
 Package body
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 4.4
  
 Child 
 packages
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 4.4.1
  
 Child of a child package
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 4.4.2
  
 Multiple children
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 38
  
 4.4.3
  
 Visibility
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 39
  
 4.5
  
 Renamin
 g
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 42
  
 Strongly typed language
  
 4
 3
  
 5.1
  
 What is a type?
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 43
  
 5.2
  
 Integers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 43
  
 i",NA
ONE,NA,NA
INTRODUCTION,NA,NA
1.1 History,"In the 1970s the United States Department of Defense (DOD) suffered from an explosion 
 of the number of programming languages, with different projects using different and 
 non-standard dialects or language subsets / supersets. The DOD decided to solve this 
 problem by issuing a request for proposals for a common, modern programming 
 language. 
  
 The 
 winning proposal was one submitted by Jean Ichbiah from CII Honeywell-Bull.
  
 The first Ada standard was issued in 1983; it was subsequently revised and enhanced in 
 1995, 2005 and 2012, with each revision bringing useful new features.
  
 This tutorial will focus on Ada 2012 as a whole, rather than teaching different versions of 
 the language.",NA
1.2 Ada today,"Today, Ada is heavily used in embedded real-time systems, many of which are safety 
 critical. While Ada is and can be used as a general-purpose language, it will really shine 
 in low-level applications:
  
 • Embedded systems with low memory requirements (no garbage collector allowed).
  
 • Direct interfacing with hardware.
  
 • Soft or hard real-time systems.
  
 • Low-level systems programming.
  
 Specific domains seeing Ada usage include Aerospace & Defense, civil aviation, rail, and 
 many others. These applications require a high degree of safety: a software defect is not 
 just an annoyance, but may have severe consequences. Ada provides safety features 
 that detect defects at an early stage — usually at compilation time or using static 
 analysis tools.
  
 Ada can also be used to create applications in a variety of other areas, such as:
  
 •
  Video game programming
 3
  
 •
  Real-time audio
 4
  
 •
  Kernel modules
 5
  
 This is a non-comprehensive list that hopefully sheds light on which kind of programming 
 Ada is good at.
  
 3
  https://github.com/AdaDoom3/AdaDoom3 
  
 4
  http://www.electronicdesign.com/embedded-revolution/assessing-ada-language-audio-
 applications 
 5
  http://www.nihamkin.com/tag/kernel.html",NA
1.3 Philosophy,"Ada's philosophy is different from most other languages. Underlying Ada's design are 
 prin-ciples that include the following:
  
 • Readability is more important than conciseness. Syntactically this shows through the 
  
 fact that keywords are preferred to symbols, that no keyword is an abbreviation, 
 etc.
  
 • Very strong typing. It is very easy to introduce new types in Ada, with the benefit of 
  
 preventing data usage errors.
  
 –
  It is similar to many functional languages in that regard, except that the 
 program-mer has to be much more explicit about typing in Ada, because there 
 is almost no type inference.
  
 • Explicit is better than implicit. Although this is a
  Python
 8
 commandment, Ada takes it 
  
 way further than any language we know of:
  
 –
  There is mostly no structural typing, and most types need to be explicitly 
 named by the programmer.
  
 –
  As previously said, there is mostly no type inference.
  
 –
  Semantics are very well defined, and undefined behavior is limited to an 
 absolute minimum.
  
 –
  The programmer can generally give a
  lot
  of information about what their 
 program means to the compiler (and other programmers). This allows the 
 compiler to be extremely helpful (read: strict) with the programmer.
  
 During this course, we will explain the individual language features that are building 
 blocks for that philosophy.",NA
1.4 SPARK,"While this class is solely about the Ada language, it is worth mentioning that another lan-
 guage, extremely close to and interoperable with Ada, exists: the SPARK language.
  
 SPARK is a subset of Ada, designed so that the code written in SPARK is amenable to 
 auto-matic proof. This provides a level of assurance with regard to the correctness of 
 your code that is much higher than with a regular programming language.
  
 There is a dedicated course for the SPARK language but keep in mind that every time we 
 speak about the specification power of Ada during this course, it is power that you can 
 lever-age in SPARK to help proving the correctness of program properties ranging from 
 absence 
 of 
 run-time 
 errors 
 to 
 compliance 
 with 
 formally 
 specified 
 functional 
 requirements.
  
 6
  
 https://en.wikipedia.org/wiki/C%2B%2B",NA
TWO,NA,NA
IMPERATIVE LANGUAGE,"Ada is a multi-paradigm language with support for object orientation and some elements 
 of functional programming, but its core is a simple, coherent procedural/imperative 
 language akin to C or Pascal.
  
 In other languages
  
 One important distinction between Ada and a language like C is that statements and ex-
 pressions are very clearly distinguished. In Ada, if you try to use an expression where a 
 statement is required then your program will fail to compile. This rule supports a useful 
 stylistic principle: expressions are intended to deliver values, not to have side effects. It 
 can also prevent some programming errors, such as mistakenly using the equality 
 operator 
 =
  instead of the assignment operation := in an assignment statement.",NA
2.1 Hello world,"Here's a very simple imperative Ada program:
  
 Listing 1: greet.adb
  
 1
  
 with
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  Greet
  is 
  
 begin
  
 --
  
 Print ""Hello, World!"" to the screen
  
  
 Ada.Text_IO.Put_Line (
 ""Hello, World!""
 ); 
  
 end
  Greet
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Imperative_Language.Greet
  
  
 MD5: cba89a34b87c9dfa71533d982d05e6ab
  
 Runtime output
  
 Hello, World!
  
 which we'll assume is in the source file greet.adb.
  
 There are several noteworthy things in the above program:
  
 • A subprogram in Ada can be either a procedure or a function. A procedure, as illus-
  
 trated above, does not return a value when called.
  
 •
  with
  is used to reference external modules that are needed in the procedure. This is 
 similar to import in various languages or roughly similar to
  #include
  in C and C++.
  
 5",NA
2.2 Imperative language - If/Then/Else,"This section describes Ada's
  if
  statement and introduces several other fundamental lan-
 guage facilities including integer I/O, data declarations, and subprogram parameter 
 modes.
  
 Ada's
  if
  statement is pretty unsurprising in form and function:
  
 Listing 3: check_positive.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Integer_Text_IO;
  use
  Ada.Integer_Text_IO;
  
 3
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Check_Positive
  is 
  
  
 N :
  Integer
 ; 
  
 begin
  
 --
  
 Put a String
  
 Put (
 ""Enter an integer value: ""
 );
  
 9
  
 10 
  
 11
  
 --
  
 Read in an integer value
  
 Get (N);
  
 12
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8
  
 if
  N
  >
  0
  then
  
 --
  
 Put an Integer
  
  
  
 Put (N); 
  
  
  
 Put_Line (
 "" is a positive number""
 ); 
  
  
 end if
 ; 
  
 end
  Check_Positive
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Imperative_Language.Check_Positive
  
  
 MD5: 2e8b4b2f3f258fd9e02c2d65846af101
  
 The
  if
  statement minimally consists of the reserved word
  if
 , a condition (which must be 
 a Boolean value), the reserved word
  then
  and a non-empty sequence of statements (the 
 then
  part) which is executed if the condition evaluates to True, and a terminating
  end 
 if
 .
  
 This example declares an integer variable N, prompts the user for an integer, checks if 
 the value is positive and, if so, displays the integer's value followed by the string "" is a 
 positive number"". If the value is not positive, the procedure does not display any output.
  
 The type Integer is a predefined signed type, and its range depends on the computer ar-
 chitecture. On typical current processors Integer is 32-bit signed.
  
 The example illustrates some of the basic functionality for integer input-output. The rel-
 evant subprograms are in the predefined package Ada.Integer_Text_IO and include the 
 Get procedure (which reads in a number from the keyboard) and the Put procedure 
 (which displays an integer value).
  
 Here's a slight variation on the example, which illustrates an
  if
  statement with an
  else 
 part:
  
 Listing 4: check_positive.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Integer_Text_IO;
  use
  Ada.Integer_Text_IO;
  
 3
  
 4
  
  
 5
  
  
 6
  
  
 7
 procedure
  Check_Positive
  is 
  
  
 N :
  Integer
 ; 
  
 begin
  
 --
  
 Put a String
  
 Put (
 ""Enter an integer value: ""
 );
  
 (continues on next page)",NA
2.3 Imperative language - Loops,"Ada has three ways of specifying loops. They differ from the C / Java / Javascript for-
 loop, however, with simpler syntax and semantics in line with Ada's philosophy.
  
 2.3.1 For loops
  
 The first kind of loop is the
  for
  loop, which allows iteration through a discrete range.
  
 Listing 6: greet_5a.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11
  
 procedure
  Greet_5a
  is 
  
 begin 
  
  
 for
  I
  in
  1
  ..
  5
  loop
  
 --
  
 Put_Line is a procedure call
  
 Put_Line (
 ""Hello, World!"" 
  
 &
  Integer
 '
 Image
  (I));
  
 --
  
 ^ Procedure parameter
  
  
 end loop
 ; 
  
 end
  Greet_5a
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Imperative_Language.Greet_5a
  
  
 MD5: 7f588b67947126f789333adfaaf1b638
  
 Runtime output
  
 Hello, World! 1
  
  
 Hello, World! 2
  
  
 Hello, World! 3
  
  
 Hello, World! 4
  
  
 Hello, World! 5
  
 A few things to note:
  
 •
  1
  ..
  5
  is a discrete range, from
  1
  to
  5
  inclusive.
  
 • The loop parameter I (the name is arbitrary) in the body of the loop has a value 
 within 
  
 this range.
  
 • I is local to the loop, so you cannot refer to I outside the loop.
  
 • Although the value of I is incremented at each iteration, from the program's 
 perspec-tive it is constant. An attempt to modify its value is illegal; the compiler 
 would reject the program.
  
 2.3.
  
 Imperative language - Loops
  
 9",NA
2.4 Imperative language - Case statement,"Ada's
  case
  statement is similar to the C and C++
  switch
  statement, but with some 
 impor-tant differences.
  
 Here's an example, a variation of a program that was shown earlier with an
  if
  statement:
  
 Listing 11: check_direction.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Integer_Text_IO;
  use
  Ada.Integer_Text_IO;
  
 (continues on next page)
  
 12
  
 Chapter 2.
  
 Imperative 
 language",NA
2.5 Imperative language - Declarative regions,"As mentioned earlier, Ada draws a clear syntactic separation between declarations, 
 which introduce names for entities that will be used in the program, and statements, 
 which per-form the processing. The areas in the program where declarations may appear 
 are known as declarative regions.
  
 In any subprogram, the section between the
  is
  and the
  begin
  is a declarative region. You 
 can have variables, constants, types, inner subprograms, and other entities there.
  
 We've briefly mentioned variable declarations in previous subsection. Let's look at a 
 simple example, where we declare an integer variable X in the declarative region and 
 perform an initialization and an addition on it:
  
 Listing 12: main.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Main
  is 
  
  
 X :
  Integer
 ; 
  
 begin 
  
  
 X :=
  0
 ; 
  
  
 Put_Line (
 ""The initial value of X is "" 
  
  
 &
  Integer
 '
 Image
  (X));
  
 9
  
 10 
  
 11
  
 Put_Line (
 ""Performing operation on X...""
 ); 
  
 X := X
  +
  1
 ;
  
 12
  
 1
 3 
  
 1
 4 
  
 1
 5
  
  
 Put_Line (
 ""The value of X now is "" 
  
  
 &
  Integer
 '
 Image
  (X)); 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Imperative_Language.Variable_Declaration
  
  
 MD5: cbb08d5e382fbfcc28e986bea80cd253
  
 Runtime output
  
 The initial value of X is
  
 0
  
  
 Performing operation on X...
  
 The value of X now is
  
 1
  
 Let's look at an example of a nested procedure:
  
 14
  
 Chapter 2.
  
 Imperative 
 language",NA
2.6 Imperative language - conditional expressions,"Ada 2012 introduced an expression analog for conditional statements (
 if
  and
  case
 ).
  
 2.6.1 If expressions
  
 Here's an alternative version of an example we saw earlier; the
  if
  statement has been 
 replaced by an
  if
  expression:
  
 Listing 15: check_positive.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Integer_Text_IO;
  use
  Ada.Integer_Text_IO;
  
 3
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 procedure
  Check_Positive
  is 
  
  
 N :
  Integer
 ; 
  
 begin 
  
  
 Put (
 ""Enter an integer value: ""
 ); 
  
  
 Get (N); 
  
  
 Put (N);
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9
  
  
 declare 
  
  
  
 S
  :
  constant
  String
  := 
  
  
  
  
 (
 if
  N
  >
  0 
  
  
  
   
 then
  "" is a positive number"" 
  
  
  
   
 else
  "" is not a positive number""
 ); 
  
 begin 
  
  
  
 Put_Line (S); 
  
  
 end
 ; 
  
 end
  Check_Positive
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Imperative_Language.Check_Positive
  
  
 MD5: 01f23463b14774f750dbb21f6c65ea09
  
 The
  if
  expression evaluates to one of the two Strings depending on N, and assigns that 
 value to the local variable S.
  
 Ada's
  if
  expressions are similar to
  if
  statements. However, there are a few differences 
 that stem from the fact that it is an expression:
  
 • All branches' expressions must be of the same type
  
 • It
  must
  be surrounded by parentheses if the surrounding expression does not already 
  
 contain them
  
 • An
  else
  branch is mandatory unless the expression following
  then
  has a Boolean 
 value. In that case an
  else
  branch is optional and, if not present, defaults to
  else 
 True
 .
  
 Here's another example:
  
 16
  
 Chapter 2.
  
 Imperative 
 language",NA
THREE,NA,NA
SUBPROGRAMS,NA,NA
3.1 Subprograms,"So far, we have used procedures, mostly to have a main body of code to execute. Proce-
 dures are one kind of
  subprogram
 .
  
 There are two kinds of subprograms in Ada,
  functions
  and
  procedures
 . 
  
 The distinction 
 between the two is that a function returns a value, and a procedure does not.
  
 This example shows the declaration and definition of a function:
  
 Listing 1: increment.ads
  
 1
  
 function
  Increment
  (
 I
  :
  Integer
 )
  return
  Integer
 ;
  
  
 Listing 2: increment.adb
  
 1
  
 --
  
 We declare (but don't define) a function with
  
 2
  
 --
  
 one parameter, returning an integer value
  
 3
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 function
  Increment
  (
 I
  :
  Integer
 )
  return
  Integer
  is
  
 --
  
 We define the Increment function
  
 begin 
  
 return
  I
  +
  1
 ; 
  
 end
  Increment
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Subprograms.Increment
  
  
 MD5: 582fe283730a130cec071c455a0ce3d4
  
 Subprograms in Ada can, of course, have parameters. One syntactically important note 
 is that a subprogram which has no parameters does not have a parameter section at all, 
 for example:
  
 procedure
  Proc
 ;
  
  
 function
  Func return Integer
 ;
  
 Here's another variation on the previous example:
  
 Listing 3: increment_by.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 function
  Increment_By
  
  
 (
 I
  
 :
  Integer
  :=
  0
 ;
  
 Incr
  :
  Integer
  :=
  1
 )
  return
  Integer
 ;
  
 --
  
 ^ Default value for parameters
  
 Code block metadata
  
 19",NA
3.2 Parameter modes,"So far we have seen that Ada is a safety-focused language. There are many ways this is 
 realized, but two important points are:
  
 • Ada makes the user specify as much as possible about the behavior expected for the 
  
 program, so that the compiler can warn or reject if there is an inconsistency.
  
 • Ada provides a variety of techniques for achieving the generality and flexibility of 
 point-ers and dynamic memory management, but without the latter's drawbacks 
 (such as memory leakage and dangling references).
  
 Parameter modes are a feature that helps achieve the two design goals above. A subpro-
 gram parameter can be specified with a mode, which is one of the following:
  
 in
  
 Parameter can only be read, not written
  
 out
  
 Parameter can be written to, then read
  
 in out
  
 Parameter can be both read and written
  
 The default mode for parameters is
  in
 ; so far, most of the examples have been using
  in 
 parameters.
  
 Historically
  
 Functions and procedures were originally more different in philosophy. Before Ada 2012, 
 functions could only take
  in
  parameters.",NA
3.3 Subprogram calls,"3.3.1 In parameters
  
 The first mode for parameters is the one we have been implicitly using so far. 
 Parameters passed using this mode cannot be modified, so that the following program 
 will cause an error:
  
 Listing 8: swap.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 procedure
  Swap
  (
 A
 ,
  B
  :
  Integer
 )
  is 
  
  
 Tmp :
  Integer
 ; 
  
 begin 
  
  
 Tmp := A;
  
 5
  
 6
  
 --
  
 Error: assignment to ""in"" mode
  
 7
  
 --
  
 parameter not allowed
  
 (continues on next page)
  
 24
  
 Chapter 3.
  
 Subprograms",NA
3.4 Renaming,"Subprograms can be renamed by using the
  renames
  keyword and declaring a new name 
 for a subprogram:
  
 procedure
  New_Proc renames Original_Proc
 ;
  
 This can be useful, for example, to improve the readability of your application when 
 you're using code from external sources that cannot be changed in your system. Let's 
 look at an example:
  
 Listing 12: 
 a_procedure_with_very_long_name_that_cannot_be_changed.ads
  
 1 
  
 2
  
 procedure
  A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed
  
  
 (
 A_Message
  :
  String
 );
  
   
 Listing 13: 
 a_procedure_with_very_long_name_that_cannot_be_changed.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  
 A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed 
 (
 A_Message
  :
  String
 )
  is 
  
 begin 
  
  
 Put_Line (A_Message); 
  
 end
  A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Subprograms.Proc_Renaming
  
  
 MD5: 6d4952e9dee8ef69a9e3c3e185c635f1
  
 As the wording in the name of procedure above implies, we cannot change its name. We 
 can, however, rename it to something like Show in our test application and use this 
 shorter name. Note that we also have to declare all parameters of the original 
 subprogram — we may rename them, too, in the declaration. For example:
  
 Listing 14: show_renaming.adb
  
 1
  
 with
  A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed;
  
 2
  
 3
  
 procedure
  Show_Renaming
  is
  
 4
  
 5 
  
 6
  
 procedure
  Show
  (
 S
  :
  String
 )
  renames 
  
  
 A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed
 ;
  
 7
  
 8 
  
 9 
  
 10
  
 begin 
  
 Show (
 ""Hello World!""
 ); 
  
 end
  Show_Renaming
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Subprograms.Proc_Renaming
  
  
 MD5: 5b3b550f8a1cbeb7d9cfd3673f6d42b3
  
 Runtime output
  
 Hello World!
  
  
 Note that the original name 
 (A_Procedure_With_Very_Long_Name_That_Cannot_Be_Changed) is still visible after the 
 declaration of the Show procedure.",NA
FOUR,NA,NA
MODULAR PROGRAMMING,"So far, our examples have been simple standalone subprograms. Ada is helpful in that 
 regard, since it allows arbitrary declarations in a declarative part. We were thus able to 
 declare our types and variables in the bodies of main procedures.
  
 However, it is easy to see that this is not going to scale up for real-world applications. We 
 need a better way to structure our programs into modular and distinct units.
  
 Ada encourages the separation of programs into multiple packages and sub-packages, 
 pro-viding many tools to a programmer on a quest for a perfectly organized code-base.",NA
4.1 Packages,"Here is an example of a package declaration in Ada:
  
 Listing 1: week.ads
  
 1
  
 package
  Week
  is
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 Mon
  :
  constant
  String
  :=
  ""Monday""
 ; 
  
 Tue
  :
  constant
  String
  :=
  ""Tuesday""
 ; 
  
 Wed
  :
  constant
  String
  :=
  ""Wednesday""
 ; 
  
 Thu
  :
  constant
  String
  :=
  ""Thursday""
 ; 
  
 Fri
  :
  constant
  String
  :=
  ""Friday""
 ; 
  
 Sat
  :
  constant
  String
  :=
  ""Saturday""
 ; 
  
 Sun
  :
  constant
  String
  :=
  ""Sunday""
 ;
  
 10
  
 11
  
 end
  Week
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Modular_Programming.Week
  
  
 MD5: 0fa033dc8fe2b9741483de273354e7ee
  
 And here is how you use it:
  
 Listing 2: main.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO; 
  
 with
  Week;
  
 --
  
 References the Week package, and
  
 --
  
 adds a dependency from Main to Week
  
 5
  
 6
  
  
 7
  
  
 8
  
 procedure
  Main
  is 
  
 begin 
  
  
 Put_Line (
 ""First day of the week is ""
  
 (continues on next page)
  
 31",NA
4.2 Using a package,"As we have seen above, the
  with
  clause indicates a dependency on another package. 
 However, every reference to an entity coming from the Week package had to be prefixed 
 by the full name of the package. It is possible to make every entity of a package visible 
 directly in the current scope, using the
  use
  clause.
  
 In fact, we have been using the
  use
  clause since almost the beginning of this tutorial.
  
 Listing 3: main.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 --
  
 ^ Make every entity of the
  
 --
  
 Ada.Text_IO package
  
 --
  
 directly visible.
  
 with
  Week;
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 procedure
  Main
  is 
  
  
 use
  Week;
  
 --
  
 Make every entity of the Week
  
 --
  
 package directly visible.
  
 begin 
  
  
 Put_Line (
 ""First day of the week is ""
  &
  Mon); 
 end
  
 Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Modular_Programming.Week
  
  
 MD5: ea54077d4ae165b28ae8facfe8ba2db7
  
 Runtime output
  
 First day of the week is Monday
  
  
 As you can see in the example above:
  
 • Put_Line is a subprogram that comes from the Ada.Text_IO package. We can refer-
  
 ence it directly because we have
  use
 d the package at the top of the Main unit.
  
 • Unlike
  with
  clauses, a
  use
  clause can be placed either in the prelude, or in any 
 declara-tive region. In the latter case the
  use
  clause will have an effect in its 
 containing lexical scope.",NA
4.3 Package body,"In the simple example above, the Week package only has declarations and no body. 
 That's not a mistake: in a package specification, which is what is illustrated above, you 
 cannot declare bodies. Those have to be in the package body.
  
 4.2.
  
 Using a package
  
 33",NA
4.4 Child packages,"Packages can be used to create hierarchies. We achieve this by using child packages, 
 which extend the functionality of their parent package. 
  
 One example of a child 
 package that we've been using so far is the Ada.Text_IO package. Here, the parent 
 package is called Ada, while the child package is called Text_IO. In the previous 
 examples, we've been using the Put_Line procedure from the Text_IO child package.
  
 Important
  
 Ada also supports nested packages. However, since they can be more complicated to 
 use, the recommendation is to use child packages instead. Nested packages will be 
 covered in the advanced course.
  
 Let's begin our discussion on child packages by taking our previous Week package:
  
 4.4.
  
 Child packages
  
 35",NA
4.5 Renaming,"Previously, we've mentioned that
  subprograms can be renamed
  (page 28). 
  
 We can re-
 name packages, too. Again, we use the
  renames
  keyword for that. The following 
 example renames the Ada.Text_IO package as TIO:
  
 Listing 23: main.adb
  
 1
  
 with
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  Main
  is 
  
  
 package
  TIO
  renames
  
 Ada.Text_IO
 ; 
  
 begin 
  
  
 TIO.Put_Line (
 ""Hello""
 ); 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Modular_Programming.Rename_Text_IO
  
  
 MD5: 33652dd004ef33d95c168ab8893cd412
  
 Runtime output
  
 Hello
  
  
 We can use renaming to improve the readability of our code by using shorter package 
 names. In the example above, we write TIO.Put_Line instead of the longer version (Ada. 
 Text_IO.Put_Line). This approach is especially useful when we don't
  use
  packages and 
 want to avoid that the code becomes too verbose.
  
 Note we can also rename subprograms and objects inside packages. For instance, we 
 could have just renamed the Put_Line procedure in the source code example above:
  
 Listing 24: main.adb
  
 1
  
 with
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Main
  is 
  
  
 procedure
  Say
  (
 Something
  :
  String
 ) 
  
  
  
 renames
  Ada.Text_IO.Put_Line; 
  
 begin 
  
  
 Say (
 ""Hello""
 ); 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Modular_Programming.Rename_Put_Line
  
  
 MD5: f30174ff29eb01f33bc95f1787f9f1dc
  
 Runtime output
  
 Hello
  
  
 In this example, we rename the Put_Line procedure to Say.
  
 42
  
 Chapter 4.
  
 Modular programming",NA
FIVE,NA,NA
STRONGLY TYPED LANGUAGE,"Ada is a strongly typed language. It is interestingly modern in that respect: strong static 
 typing has been increasing in popularity in programming language design, owing to 
 factors such as the growth of statically typed functional programming, a big push from 
 the research community in the typing domain, and many practical languages with strong 
 type systems.",NA
5.1 What is a type?,"In statically typed languages, a type is mainly (but not only) a
  compile time
  construct. It 
 is a construct to enforce invariants about the behavior of a program. 
  
 Invariants are 
 unchangeable properties that hold for all variables of a given type. Enforcing them 
 ensures, for example, that variables of a data type never have invalid values.
  
 A type is used to reason about the
  objects
  a program manipulates (an object is a 
 variable or a constant). The aim is to classify objects by what you can accomplish with 
 them (i.e., the operations that are permitted), and this way you can reason about the 
 correctness of the objects' values.",NA
5.2 Integers,"A nice feature of Ada is that you can define your own integer types, based on the 
 require-ments of your program (i.e., the range of values that makes sense). In fact, the 
 definitional mechanism that Ada provides forms the semantic basis for the predefined 
 integer types. There is no ""magical"" built-in type in that regard, which is unlike most 
 languages, and ar-guably very elegant.
  
 Listing 1: integer_type_example.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Integer_Type_Example
  is
  
 --
  
 Declare a signed integer type,
  
 --
  
 and give the bounds
  
 type
  My_Int
  is range
  -
 1
  ..
  20
 ;
  
 --
  
 ^ High bound
  
 --
  
 ^ Low bound
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 --
  
 Like variables, type declarations can
  
 --
  
 only appear in declarative regions.
  
 begin 
  
  
 for
  I
  in
  My_Int
  loop 
  
  
  
 Put_Line (My_Int'
 Image
  (I));
  
 --
  
 ^ 'Image attribute
  
 (continues on next page)
  
 43",NA
5.3 Unsigned types,"Ada also features unsigned Integer types. They're called
  modular
  types in Ada parlance. 
 The reason for this designation is due to their behavior in case of overflow: They simply 
 ""wrap around"", as if a modulo operation was applied.
  
 For machine sized modular types, for example a modulus of 2
 32
 , this mimics the most 
 common implementation behavior of unsigned types. However, an advantage of Ada is 
 that the modulus is more general:
  
 Listing 4: main.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Main
  is 
  
  
 type
  Mod_Int
  is mod
  2
  **
  5
 ;
  
 --
  
 ^ Range is 0 .. 31
  
 6
  
 7 
  
 8
  
 A
  :
  constant
  Mod_Int :=
  20
 ; 
  
 B
  :
  constant
  Mod_Int :=
  15
 ;
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 M
  :
  constant
  Mod_Int := A
  +
  B;
  
 --
  
 No overflow here,
  
 --
  
 M = (20 + 15) mod 32 = 3
  
 begin 
  
  
 for
  I
  in
  1
  .. M
  loop 
  
  
  
 Put_Line (
 ""Hello, World!""
 );
  
 (continues on next page)
  
 46
  
 Chapter 5.
  
 Strongly typed language",NA
5.4 Enumerations,"Enumeration types are another nicety of Ada's type system. Unlike C's enums, they are
  
 not 
 integers, and each new enumeration type is incompatible with other enumeration 
 types. Enumeration types are part of the bigger family of discrete types, which makes 
 them usable in certain situations that we will describe later but one context that we have 
 already seen is a case statement.
  
 Listing 5: enumeration_example.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
 procedure
  Enumeration_Example
  is 
  
  
 type
  Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
  
 Thursday
 ,
  Friday
 , 
  
  
  
 Saturday
 ,
  Sunday
 );
  
 --
  
 An enumeration type
  
 begin 
  
  
 for
  I
  in
  Days
  loop 
  
  
  
 case
  I
  is 
  
  
  
 when
  Saturday .. Sunday => 
  
  
  
  
  
 Put_Line (
 ""Week end!""
 );
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1
  
 when
  Monday .. Friday => 
  
 Put_Line (
 ""Hello on "" 
  
 &
  Days'
 Image
  (I));
  
 --
  
 'Image attribute, works on
  
 --
  
 enums too
  
  
  
 end case
 ; 
  
  
 end loop
 ; 
  
 end
  Enumeration_Example
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Strongly_Typed_Language.Enumeration_Example
  
  
 MD5: 45d6c83992af4fb6d5015d5f22cb7113
  
 Runtime output
  
 10
  https://en.wikipedia.org/wiki/Circular_buffer
  
 5.4.
  
 Enumerations
  
 47",NA
5.5 Floating-point types,"5.5.1 Basic properties
  
 Like most languages, Ada supports floating-point types. The most commonly used 
 floating-point type is
  Float
 :
  
 Listing 6: floating_point_demo.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Floating_Point_Demo
  is 
  
  
 A
  :
  constant
  Float
  :=
  2.5
 ; 
  
 begin 
  
  
 Put_Line (
 ""The value of A is "" 
  
  
 &
  Float
 '
 Image
  (A)); 
  
 end
  Floating_Point_Demo
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Strongly_Typed_Language.Floating_Point_Demo
  
  
 MD5: 06998775497b68b742700138faecbb6a
  
 Runtime output
  
 The value of A is
  
  
 2.50000E+00
  
 The application will display
  2.5
  as the value of A.
  
 The Ada language does not specify the precision (number of decimal digits in the 
 mantissa) for Float; on a typical 32-bit machine the precision will be 6.
  
 All common operations that could be expected for floating-point types are available, 
 includ-ing absolute value and exponentiation. For example:
  
 Listing 7: floating_point_operations.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Floating_Point_Operations
  is 
  
  
 A :
  Float
  :=
  2.5
 ; 
  
 begin
  
 (continues on next page)
  
 48
  
 Chapter 5.
  
 Strongly typed language",NA
5.6 Strong typing,"As noted earlier, Ada is strongly typed. As a result, different types of the same family 
 are incompatible with each other; a value of one type cannot be assigned to a variable 
 from the other type. For example:
  
 Listing 13: illegal_example.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Illegal_Example
  is
  
 --
  
 Declare two different floating point types
  
 type
  Meters
  is new
  Float
 ;
  
 type
  Miles
  
 is new
  Float
 ;
  
 7
  
 8 
  
 Dist_Imperial : Miles;
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6
  
 --
  
 Declare a constant
  
  
 Dist_Metric
  :
  constant
  Meters :=
  1000.0
 ; 
 begin
  
 --
  
 Not correct: types mismatch
  
  
 Dist_Imperial := Dist_Metric
  *
  621.371
 e
 -
 6
 ; 
  
 Put_Line (Miles'
 Image
  (Dist_Imperial)); 
 end
  
 Illegal_Example
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Strongly_Typed_Language.Imperial_Metric_Error
  
  
 MD5: e28e341c5eda9b3b4cef691fa24b7f7e
  
 Build output
  
 illegal_example.adb:14:33: error: expected type ""Miles"" defined at line 6
  
  
 illegal_example.adb:14:33: error: found type ""Meters"" defined at line 5
  
  
 gprbuild: *** compilation phase failed
  
 A consequence of these rules is that, in the general case, a ""mixed mode"" expression 
 like 
 2
  *
  3.0
  will trigger a compilation error. In a language like C or Python, such 
 expressions are made valid by implicit conversions. In Ada, such conversions must be 
 made explicit:",NA
5.7 Derived types,"In Ada you can create new types based on existing ones. This is very useful: you get a 
 type that has the same properties as some existing type but is treated as a distinct type 
 in the interest of strong typing.
  
 Listing 17: main.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 procedure
  Main
  is
  
 --
  
 ID card number type,
  
 --
  
 incompatible with Integer.
  
 type
  Social_Security_Number
  is new
  Integer 
  
 range
  0
  ..
  999_99_9999
 ;
  
 --
  
 ^ Since a SSN has 9 digits
  
 --
  
 max., and cannot be
  
 --
  
 negative, we enforce
  
 --
  
 a validity constraint.
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4
  
 SSN : Social_Security_Number := 
  
 555_55_5555
 ;
  
 --
  
 ^ You can put underscores as
  
 --
  
 formatting in any number.
  
 15
  
 16
  
 I
  
 :
  Integer
 ;
  
 17
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4
  
 --
  
 The value -1 below will cause a
  
 --
  
 runtime error and a compile time
  
 --
  
 warning with GNAT.
  
  
 Invalid : Social_Security_Number :=
  -
 1
 ; 
  
 begin
  
 --
  
 Illegal, they have different types:
  
 I := SSN;
  
 25
  
 26
  
 --Likewise illegal:
  
 27 
  
 SSN := I;
  
 28
  
 29
  
 --OK with explicit conversion:
  
 30 
  
 I :=
  Integer
  (SSN);
  
 31
  
 3
 2 
  
 3
 3 
  
 3
 4
  
 --
  
 Likewise OK:
  
  
 SSN := Social_Security_Number (I); 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Strongly_Typed_Language.Derived_Types
  
  
 MD5: 63445601ddb5e52dceab095d3305623a
  
 Build output
  
 main.adb:21:40: warning: value not in range of type ""Social_Security_Number""
 ␣
 main.adb:21:40: 
 warning: Constraint_Error will be raised at run time [enabled by
 ␣
 ↪
 defined at line 4 [enabled by 
 default]
  
 ↪
 default] 
  
 (continues on next 
 page)
  
 5.7.
  
 Derived types
  
 55",NA
5.8 Subtypes,"As we are starting to see, types may be used in Ada to enforce constraints on the valid 
 range of values. However, we sometimes want to enforce constraints on some values 
 while staying within a single type. This is where subtypes come into play. A subtype does 
 not introduce a new type.
  
 Listing 19: greet.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Greet
  is 
  
  
 type
  Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
  
 Thursday
 ,
  Friday
 , 
  
  
  
 Saturday
 ,
  Sunday
 );
  
 7
  
 8 
  
 9 
  
 10 
  
 11
  
 --
  
 Declaration of a subtype
  
 subtype
  Weekend_Days
  is 
  
 Days
  range
  Saturday .. Sunday;
  
 --
  
 ^ Constraint of the subtype
  
 12
  
 13
  
 M : Days := Sunday;
  
 14
  
 (continues on next page)
  
 56
  
 Chapter 5.
  
 Strongly typed language",NA
SIX,NA,NA
RECORDS,"So far, all the types we have encountered have values that are not decomposable: each 
 instance represents a single piece of data. Now we are going to see our first class of 
 com-posite types: records.
  
 Records allow composing a value out of instances of other types. Each of those instances 
 will be given a name. The pair consisting of a name and an instance of a specific type is 
 called a field, or a component.",NA
6.1 Record type declaration,"Here is an example of a simple record declaration:
  
 type
  Date
  is record
  
 --
  
 The following declarations are
  
 --
  
 components of the record
  
 Day
  
 :
  Integer
  range
  1
  ..
  31
 ;
  
  
 Month : Months;
  
 --
  
 You can add custom constraints
  
 --
  
 on fields
  
 Year
  
 :
  Integer
  range
  1
  ..
  3000
 ;
  
  
 end record
 ;
  
 Fields look a lot like variable declarations, except that they are inside of a record 
 definition. And as with variable declarations, you can specify additional constraints when 
 supplying the subtype of the field.
  
 type
  Date
  is record
  
 Day
  
 :
  Integer
  range
  1
  ..
  31
 ;
  
  
 Month : Months := January;
  
 --
  
 This component has a default value
  
 Year
  
 :
  Integer
  range
  1
  ..
  3000
  :=
  2012
 ;
  
 --
  
 ^^^^
  
 --
  
 Default value
  
  
 end record
 ;
  
 Record components can have default values. When a variable having the record type is 
 declared, a field with a default initialization will be automatically set to this value. The 
 value can be any expression of the component type, and may be run-time computable.
  
 In the remaining sections of this chapter, we see how to use record types. In addition to 
 that, we discuss more about records in
  another chapter
  (page 97).",NA
6.2 Aggregates,"--
  
 Positional components
  
 Ada_Birthday
  
 : Date := (
 10
 , December,
  1815
 );
  
 --
  
 Named components
  
 Leap_Day_2020
  
 : Date := (Day
  
 =>
  29
 ,
  
  
 --
  
 Month => February,
  
 Year
  
 =>
  2020
 );
  
 ^ By name
  
 Records have a convenient notation for expressing values, illustrated above. This 
 notation is called aggregate notation, and the literals are called aggregates. They can be 
 used in a variety of contexts that we will see throughout the course, one of which is to 
 initialize records.
  
 An aggregate is a list of values separated by commas and enclosed in parentheses. It is 
 allowed in any context where a value of the record is expected.
  
 Values for the components can be specified positionally, as in Ada_Birthday example, or 
 by name, as in Leap_Day_2020. A mixture of positional and named values is permitted, 
 but you cannot use a positional notation after a named one.",NA
6.3 Component selection,"To access components of a record instance, you use an operation that is called 
 component selection. This is achieved by using the dot notation. For example, if we 
 declare a variable Some_Day of the Date record type mentioned above, we can access 
 the Year component by writing Some_Day.Year.
  
 Let's look at an example:
  
 Listing 1: record_selection.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 procedure
  Record_Selection
  is
  
 4
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 type
  Months
  is 
  
 (
 January
 ,
  February
 ,
  March
 ,
  April
 , 
  
   
 May
 ,
  June
 ,
  July
 ,
  August
 ,
  September
 , 
  
   
 October
 ,
  November
 ,
  December
 );
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4
  
 type
  Date
  is record
  
 Day
  
 :
  Integer
  range
  1
  ..
  31
 ;
  
 Month : Months;
  
 Year
  
 :
  Integer
  range
  1
  ..
  3000
  :=
  2032
 ;
  
 end record
 ;
  
 15
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3
  
 procedure
  Display_Date
  (
 D
  :
  Date
 )
  is 
  
 begin 
  
  
 Put_Line (
 ""Day:""
  &
  Integer
 '
 Image
  (D.Day) 
  
  
 &
  "", Month: "" 
  
  
  
 &
  Months'
 Image
  (D.Month) 
  
  
  
 &
  "", Year:"" 
  
  
  
 &
  Integer
 '
 Image
  (D.Year)); 
 end
  
 Display_Date
 ;
  
 24
  
 25 
  
 Some_Day : Date := (
 1
 , January,
  2000
 ); 
  
  
  
 (continues on next page)
  
 62
  
 Chapter 6.
  
 Records",NA
6.4 Renaming,"In previous chapters, we've discussed
  subprogram
  (page 28) and
  package
  (page 42) re-
 naming. We can rename record components as well. Instead of writing the full 
 component selection using the dot notation, we can declare an alias that allows us to 
 access the same component. This is useful to simplify the implementation of a 
 subprogram, for example.
  
 We can rename record components by using the
  renames
  keyword in a variable 
 declaration. For example:
  
  
 Some_Day : Date;
  
 Y
  
 :
  Integer
  renames
  Some_Day.Year;
  
 Here, Y is an alias, so that every time we using Y, we are really using the Year component 
 of Some_Day.
  
 Let's look at a complete example:
  
 Listing 2: dates.ads
  
 1
  
 package
  Dates
  is
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 type
  Months
  is 
  
 (
 January
 ,
  February
 ,
  March
 ,
  April
 , 
  
   
 May
 ,
  June
 ,
  July
 ,
  August
 ,
  September
 , 
  
   
 October
 ,
  November
 ,
  December
 );
  
 7
  
 8 
  
 9 
  
 10
  
 type
  Date
  is record
  
 Day
  
 :
  Integer
  range
  1
  ..
  31
 ;
  
 Month : Months;
  
 (continues on next page)",NA
SEVEN,NA,NA
ARRAYS,Arrays provide another fundamental family of composite types in Ada.,NA
7.1 Array type declaration,"Arrays in Ada are used to define contiguous collections of elements that can be selected 
 by indexing. Here's a simple example:
  
 Listing 1: greet.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Greet
  is 
  
 type
  My_Int
  is range
  0
  ..
  1000
 ; 
  
 type
  Index
  is range
  1
  ..
  5
 ;
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 type
  My_Int_Array
  is 
  
 array
  (Index)
  of
  My_Int;
  
 --
  
 ^ Type of elements
  
 --
  
 ^ Bounds of the array
  
 Arr : My_Int_Array := (
 2
 ,
  3
 ,
  5
 ,
  7
 ,
  11
 );
  
 --
  
 ^ Array literal
  
 --
  
 (aggregate)
  
 14
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3
  
  
 V : My_Int; 
  
 begin 
  
  
 for
  I
  in
  Index
  loop 
  
  
  
 V := Arr (I);
  
 --
  
 ^ Take the Ith element
  
  
  
 Put (My_Int'
 Image
  (V)); 
  
  
 end loop
 ; 
  
  
 New_Line; 
  
 end
  Greet
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Arrays.Greet
  
  
 MD5: ffdd2ba2322b0946dfcac3a55bce5270
  
 Runtime output
  
 2 3 5 7 11
  
 The first point to note is that we specify the index type for the array, rather than its size. 
 Here we declared an integer type named Index ranging from
  1
  to
  5
 , so each array 
 instance will have 5 elements, with the initial element at index 1 and the last element at 
 index 5.
  
 67",NA
7.2 Indexing,"We have already seen the syntax for selecting elements of an array. There are however a 
 few more points to note.
  
 First, as is true in general in Ada, the indexing operation is strongly typed. If you use a 
 value of the wrong type to index the array, you will get a compile-time error.
  
 Listing 4: greet.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO; 
  
 2
  
 3 
  
 4
  
 procedure
  Greet
  is 
  
  
 type
  My_Int
  is range
  0
  ..
  1000
 ;
  
 5
  
 6 
  
 7
  
 type
  My_Index
  
 is range
  1
  ..
  5
 ;
  
 type
  Your_Index
  is range
  1
  ..
  5
 ;
  
 8
  
 9 
  
 10
  
 type
  My_Int_Array
  is 
  
 array
  (My_Index)
  of
  My_Int;
  
 11
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9
  
  
 Tab : My_Int_Array := (
 2
 ,
  3
 ,
  5
 ,
  7
 ,
  11
 ); 
  
 begin 
  
  
 for
  I
  in
  Your_Index
  loop 
  
  
  
 Put (My_Int'
 Image
  (Tab (I)));
  
 --
  
 ^ Compile time error
  
 end loop
 ; 
  
 New_Line; 
  
 end
  Greet
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Arrays.Greet_2
  
  
 MD5: 54543017e4ec69d24bf9e43d507b50e6
  
 Build output
  
 70
  
 Chapter 7.
  
 Array
 s",NA
7.3 Simpler array declarations,"In the previous examples, we have always explicitly created an index type for the array. 
 While this can be useful for typing and readability purposes, sometimes you simply want 
 to express a range of values. Ada allows you to do that, too.
  
 Listing 6: simple_array_bounds.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 procedure
  Simple_Array_Bounds
  is 
  
  
 type
  My_Int
  is range
  0
  ..
  1000
 ;
  
 5
  
 6
  
  
 7
  
  
 8
  
 type
  My_Int_Array
  is 
  
 array
  (
 1
  ..
  5
 )
  of
  My_Int;
  
 --
  
 ^ Subtype of Integer
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8
  
  
 Tab
  :
  constant
  My_Int_Array := 
  
  
  
 (
 2
 ,
  3
 ,
  5
 ,
  7
 ,
  11
 ); 
  
 begin 
  
  
 for
  I
  in
  1
  ..
  5
  loop
  
 --
  
 ^ Subtype of Integer
  
  
  
 Put (My_Int'
 Image
  (Tab (I))); 
  
  
 end loop
 ; 
  
  
 New_Line; 
  
 end
  Simple_Array_Bounds
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Arrays.Simple_Array_Bounds
  
  
 MD5: c337a7fe0dacccc5f60f7b234aa96d39
  
 Runtime output
  
 2 3 5 7 11
  
  
 This example defines the range of the array via the range syntax, which specifies an 
 anony-mous subtype of Integer and uses it to index the array.
  
 This means that the type of the index is
  Integer
 . Similarly, when you use an 
 anonymous range in a for loop as in the example above, the type of the iteration 
 variable is also
  Integer
 , so you can use I to index Tab.
  
 You can also use a named subtype for the bounds for an array.",NA
7.4 Range attribute,"We noted earlier that hard coding bounds when iterating over an array is a bad idea, and 
 showed how to use the array's index type/subtype to iterate over its range in a
  for
  loop. 
 That raises the question of how to write an iteration when the array has an anonymous 
 range for its bounds, since there is no name to refer to the range. Ada solves that via 
 several attributes of array objects:
  
 Listing 7: range_example.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
  
 2 
  
 3
  
 procedure
  Range_Example
  is
  
 (continues on next page)",NA
7.5 Unconstrained arrays,"Let's now consider one of the most powerful aspects of Ada's array facility.
  
 Every array type we have defined so far has a fixed size: every instance of this type will 
 have the same bounds and therefore the same number of elements and the same size.
  
 However, Ada also allows you to declare array types whose bounds are not fixed: in that 
 case, the bounds will need to be provided when creating instances of the type.
  
 Listing 9: unconstrained_array_example.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Unconstrained_Array_Example
  is 
  
 type
  
 Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
  
 Thursday
 ,
  Friday
 , 
  
  
  
 Saturday
 ,
  Sunday
 );
  
 7
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
 type
  Workload_Type
  is 
  
 array
  (
 Days
  range
  <>)
  of
  Natural
 ;
  
 --
  
 Indefinite array type
  
 --
  
 ^ Bounds are of type Days,
  
 --
  
 but not known
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5
  
 Workload
  :
  constant 
  
 Workload_Type (Monday .. Friday) :=
  
 --
  
 ^ Specify the bounds
  
 --
  
 when declaring
  
 (Friday =>
  7
 ,
  others
  =>
  8
 );
  
 --
  
 ^ Default value
  
 --
  
 ^ Specify element by name of index
  
 begin 
  
  
 for
  I
  in
  Workload'
 Range
  loop 
  
  
  
 Put_Line (
 Integer
 '
 Image
  (Workload (I))); 
  
 end loop
 ; 
  
 end
  Unconstrained_Array_Example
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Arrays.Unconstrained_Array_Example
  
  
 MD5: c84910e9b424cfabbbbe018ba0a6de59
  
 Runtime output
  
 8
  
  
 8
  
  
 8
  
  
 8
  
  
 7
  
 The fact that the bounds of the array are not known is indicated by the Days
  range
  <> 
 syntax. Given a discrete type Discrete_Type, if we use Discrete_Type for the index in an 
 array type then Discrete_Type serves as the type of the index and comprises the range 
 of index values for each array instance.
  
 If we define the index as Discrete_Type
  range
  <> then Discrete_Type serves as the type 
 of the index, but different array instances may have different bounds from this type.
  
 74
  
 Chapter 7.
  
 Array
 s",NA
7.,NA,NA
6,"A 
 rec 
 type
 s the 
 u
  
 Here
  
 The 
 o 
 can 
 s
  
 A 
 and
  
 Cod
 e
  
 7.6.
  
 In other languages
  
  
    
  unconstrained arrays in Ada might seem similar to 
 varia 
  
  
 n reality much more powerful, because they're truly 
 frst-cl 
  
  
    
 an pass them as parameters to subprograms or 
 return the 
  
  
 citly contain their bounds as part of their value. This 
 mea 
  
  
   
 ounds or length of an array explicitly along with the 
 array, b 
  
 via the '
 First
 , '
 Last
 , '
 Range
  and '
 Length
  attributes 
 explained earlier.
  
  
   
 ugh diferent instances of the same unconstrained 
 arra ds, a specifc instance has the same bounds 
 throughout i 
  
 plement unconstrained arrays efciently; 
 instances can be not require heap allocation as in 
 languages like Java.",NA
7.6 Predefined array type: String,"urring theme in our introduction to Ada types has been  
 like
  Boolean
  or
  Integer
  are defned through the same fa 
 ser. This is also true for strings: The
  String
  type in Ada 
 is
  
 Here is how the string type is defined in Ada:
  
  
 nly built-in feature Ada adds to make strings more 
 ergono can see in the example below.
  
 A and B have the same value.
  
 Listing 10: string_literals.ads
  
 Code block metadata
  
 Predefined array type: String
  
 ble length arrays in C, 
 they ass values in the 
 language. m from 
 functions, and they ns 
 that it is useless to pass 
 ecause they are accessible 
 d earlier.
  
 y type can have diferent ts 
 lifetime. This allows Ada 
 stored on the stack and do
  
 the way important built-in 
 cilities that are available 
 to a simple array.
  
 mic is custom literals, as 
 we
  
 75
  
  
 Hint:
  
 String literals are a syntactic sugar for aggregates, so that in the following 
 example,",NA
7.7 Restrictions,"A very important point about arrays: bounds
  have
  to be known when instances are 
 created. It is for example illegal to do the following.
  
 declare
  
  
 A :
  String
 ;
  
  
 begin
  
  
 A :=
  ""World""
 ;
  
  
 end
 ;
  
 Also, while you of course can change the values of elements in an array, you cannot 
 change the array's bounds (and therefore its size) after it has been initialized. So this is 
 also illegal:
  
 declare
  
  
 A :
  String
  :=
  ""Hello""
 ;
  
  
 begin
  
 OK: Same size 
  
 Not OK: Different size
  
 A :=
  ""World""
 ;
  
 --
  
 A :=
  ""Hello World""
 ;
  --
  
  
 end
 ;
  
 Also, while you can expect a warning for this kind of error in very simple cases like this 
 one, it is impossible for a compiler to know in the general case if you are assigning a 
 value of the correct length, so this violation will generally result in a run-time error.
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
  
 3
  
 procedure
  Indefinite_Subtypes
  is",NA
7.8 Returning unconstrained arrays,"The return type of a function can be any type; a function can return a value whose size is 
 unknown at compile time. Likewise, the parameters can be of any type.
  
 For example, this is a function that returns an unconstrained
  String
 :
  
 Listing 15: main.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 procedure
  Main
  is
  
 4
  
 5
  
  
 6
  
  
 7
  
 type
  Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
 Thursday
 ,
  Friday
 , 
  
 Saturday
 ,
  Sunday
 );
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 function
  Get_Day_Name
  (
 Day
  :
  Days
  :=
  Monday
 ) 
  
   
 return
  String
  is 
  
 begin 
  
  
 return 
  
  
  
 (
 case
  Day
  is
  
 when
  Monday
  
 =>
  ""Monday""
 ,
  
 when
  Tuesday
  
 =>
  ""Tuesday""
 ,
  
 when
  Wednesday =>
  ""Wednesday""
 ,
  
 when
  Thursday
  
 =>
  ""Thursday""
 ,
  
 when
  Friday
  
 =>
  ""Friday""
 ,
  
 when
  Saturday
  
 =>
  ""Saturday""
 ,
  
 when
  Sunday
  
 =>
  ""Sunday""
 );
  
 end
  Get_Day_Name
 ;
  
 22
  
 (continues on next page)
  
 78
  
 Chapter 7.
  
 Array
 s",NA
7.9 Declaring arrays (2),"While we can have array types whose size and bounds are determined at run time, the 
 array's component type needs to be of a definite and constrained type.
  
 Thus, if you need to declare, for example, an array of strings, the
  String
  subtype used as 
 component will need to have a fixed size.
  
 Listing 16: show_days.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Show_Days
  is 
  
  
 type
  Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
  
 Thursday
 ,
  Friday
 , 
  
  
  
 Saturday
 ,
  Sunday
 );
  
 7
  
 8 
  
 9
  
 subtype
  Day_Name
  is
  String
  (
 1
  ..
  2
 );
  
 --
  
 Subtype of string with known size
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 type
  Days_Name_Type
  is 
  
 array
  (Days)
  of
  Day_Name;
  
 --
  
 ^ Type of the index
  
 --
  
 ^ Type of the element.
  
 --
  
 Must be definite
  
 (continues on next page)",NA
7.10 Array slices,"One last feature of Ada arrays that we're going to cover is array slices. It is possible to 
 take and use a slice of an array (a contiguous sequence of elements) as a name or a 
 value.
  
 Listing 17: main.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 procedure
  Main
  is 
  
 Buf :
  String
  :=
  ""Hello ...""
 ;
  
 5
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11
  
 Full_Name :
  String
  :=
  ""John Smith""
 ; 
  
 begin 
  
 Buf (
 7
  ..
  9
 ) :=
  ""Bob""
 ;
  
 --
  
 Careful! This works because the string
  
 --
  
 on the right side is the same length as
  
 --
  
 the replaced slice!
  
 12
  
 13 
  
 14
  
 --
  
 Prints ""Hello Bob""
  
 Put_Line (Buf);
  
 15
  
 1
 6 
  
 1
 7 
  
 1
 8
  
 --
  
 Prints ""Hi John""
  
 Put_Line (
 ""Hi ""
  &
  Full_Name (
 1
  ..
  4
 )); 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Arrays.Slices
  
  
 MD5: cdf582c6c9089658236f5c79b7be4c3f
  
 Runtime output",NA
7.11 Renaming,"So far, we've seen that the following elements can be renamed:
  subprograms
  (page 28), 
 packages
  (page 42), and
  record components
  (page 63). We can also rename objects by 
 using the
  renames
  keyword. This allows for creating alternative names for these 
 objects.
  
 Let's look at an example:
  
 Listing 18: measurements.ads
  
 1
  
 package
  Measurements
  is
  
  
 2 
  
 3
  
 subtype
  Degree_Celsius
  is
  Float
 ;
  
  
 4 
  
 5
  
 Current_Temperature : Degree_Celsius;
  
 6
  
 7
  
 end
  Measurements
 ;
  
 Listing 19: main.adb
  
 1
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 2
  
 with
  Measurements;
  
 3
  
 4
  
  
 5
  
  
 6
  
 procedure
  Main
  is 
  
  
 subtype
  Degrees
  is 
  
  
  
 Measurements.Degree_Celsius;
  
 7
  
 8 
  
 9 
  
 10 
  
 11
  
  
 T : Degrees 
  
  
  
 renames
  Measurements.Current_Temperature; 
 begin 
  
  
 T :=
  5.0
 ;
  
 12
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 Put_Line (Degrees'
 Image
  (T)); 
  
 Put_Line (Degrees'
 Image 
  
  
 (Measurements.Current_Temperature));
  
 16
  
 17 
 T := T
  +
  2.5
 ;
  
 18
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2
  
 Put_Line (Degrees'
 Image
  (T)); 
  
 Put_Line (Degrees'
 Image 
  
  
  
 (Measurements.Current_Temperature)); 
  
 end
  Main
 ;
  
 Code block metadata",NA
EIGHT,NA,NA
MORE ABOUT TYPES,NA,NA
8.1 Aggregates: A primer,"So far, we have talked about aggregates quite a bit and have seen a number of 
 examples. Now we will revisit this feature in some more detail.
  
 An Ada aggregate is, in effect, a literal value for a composite type. It's a very powerful 
 notation that helps you to avoid writing procedural code for the initialization of your data 
 structures in many cases.
  
 A basic rule when writing aggregates is that
  every component
  of the array or record has 
 to be specified, even components that have a default value.
  
 This means that the following code is incorrect:
  
 Listing 1: incorrect.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 package
  Incorrect
  is 
  
  
 type
  Point
  is record 
  
  
  
 X, Y :
  Integer
  :=
  0
 ; 
  
  
 end record
 ;
  
 5
  
 6 
  
 7
  
  
 Origin : Point := (X =>
  0
 ); 
  
 end
  Incorrect
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.More_About_Types.Incorrect_Aggregate
  
  
 MD5: 80a3475dece1c42cfb67b1d57b5bd464
  
 Build output
  
 incorrect.ads:6:22: error: no value supplied for component ""Y""
  
  
 gprbuild: *** compilation phase failed
  
 There are a few shortcuts that you can use to make the notation more 
 convenient:• To specify the default value for a component, you can use the <> 
 notation.
  
 • You can use the | symbol to give several components the same value.
  
 • You can use the
  others
  choice to refer to every component that has not yet been 
  
 specified, provided all those fields have the same type.
  
 • You can use the range notation .. to refer to specify a contiguous sequence of indices 
  
 in an array.
  
 However, note that as soon as you used a named association, all subsequent components 
 likewise need to be specified with named associations.",NA
8.2 Overloading and qualified expressions,"Ada has a general concept of name overloading, which we saw earlier in the section on 
 enumeration types
  (page 47).
  
 Let's take a simple example: it is possible in Ada to have functions that have the same 
 name, but different types for their parameters.
  
 Listing 3: pkg.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 package
  Pkg
  is
  
  
 function
  F
  (
 A
  :
  Integer
 )
  return
  Integer
 ;
  
  
 function
  F
  (
 A
  :
  Character
 )
  return
  Integer
 ;
  
  
 end
  Pkg
 ;
  
     
 Code block metadata
  
 Project: Courses.Intro_To_Ada.More_About_Types.Overloading
  
  
 MD5: defae85228ee183b536af395d077e71e
  
 This is a common concept in programming languages, called
  overloading
 12
 , or name over-
 loading.
  
 One of the novel aspects of Ada's overloading facility is the ability to resolve overloading 
 based on the return type of a function.
  
 Listing 4: pkg.ads
  
 1 
  
 2
  
 package
  Pkg
  is 
  
  
 type
  SSID
  is new
  Integer
 ;
  
 (continues on next page)
  
 12
  https://en.wikipedia.org/wiki/Function_overloading
  
 86
  
 Chapter 8.
  
 More about types",NA
8.3 Character types,"As noted earlier, each enumeration type is distinct and incompatible with every other 
 enu-
  
 meration type. However, what we did not mention previously is that character literals are
  
 permitted as enumeration literals. This means that in addition to the language's strongly
  
 typed character types, user-defined character types are also permitted:
  
 Listing 9: character_example.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Character_Example
  is 
  
  
 type
  My_Char
  is
  ('
 a
 ', '
 b
 ', '
 c
 ');
  
 --
  
 Our custom character type, an
  
 --
  
 enumeration type with 3 valid values.
  
 7
  
 8 
  
 9 
  
 10
  
 C :
  Character
 ;
  
 --
  
 ^ Built-in character type
  
 --
  
 (it's an enumeration type)
  
 11
  
 1
 2 
 1
 3 
 1
 4 
 1
 5 
 1
 6
  
  
 M : My_Char; 
  
 begin 
  
  
 C :=
  '?'
 ;
  
 --
  
 ^ Character literal
  
 --
  
 (enumeration literal)
  
 17
  
 18 
  
 M := '
 a
 ';
  
 19
  
 20 
  
 C :=
  65
 ;
  
 21
  
 --
  
 ^ Invalid: 65 is not a
  
 22
  
 --
  
 Character value
  
 23
  
 2
 4 
  
 2
 5 
  
 2
 6 
  
 2
 7
  
 C :=
  Character
 '
 Val
  (
 65
 );
  
 --
  
 Assign the character at
  
 --
  
 position 65 in the
  
 --
  
 enumeration (which is 'A')
  
 28
  
 29 
  
 M := C;
  
 30
  
 --
  
 ^ Invalid: C is of type Character,
  
 31
  
 --
  
 and M is a My_Char
  
 32
  
 3
 3 
 3
 4 
 3
 5 
 3
 6
  
 M := '
 d
 ';
  
 --
  
 ^ Invalid: 'd' is not a valid
  
 --
  
 literal for type My_Char
  
 end
  Character_Example
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.More_About_Types.Character_Example
  
  
 MD5: e4c5a07dbe8745749056f8c110d69fa3
  
 Build output
  
 character_example.adb:20:09: error: expected type ""Standard.Character""
  
  
 character_example.adb:20:09: error: found type universal integer
  
  
 character_example.adb:29:09: error: expected type ""My_Char"" defined at line 4",NA
NINE,NA,NA
ACCESS TYPES (POINTERS),NA,NA
9.1 Overview,"Pointers are a potentially dangerous construct, which conflicts with Ada's underlying phi-
 losophy.
  
 There are two ways in which Ada helps shield programmers from the dangers of pointers:
  
 1. One approach, which we have already seen, is to provide alternative features so 
 that the programmer does not need to use pointers. Parameter modes, arrays, and 
 varying size types are all constructs that can replace typical pointer usages in C.
  
 2. Second, Ada has made pointers as safe and restricted as possible, but allows 
 ""escape hatches"" when the programmer explicitly requests them and presumably 
 will be exer-cising such features with appropriate care.
  
 Here is how you declare a simple pointer type, or access type, in Ada:
  
 Listing 1: dates.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 package
  Dates
  is 
  
  
 type
  Months
  is 
  
  
  
 (
 January
 ,
  February
 ,
  March
 ,
  April
 , 
  
  
   
 May
 ,
  June
 ,
  July
 ,
  August
 ,
  September
 , 
  
  
   
 October
 ,
  November
 ,
  December
 );
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
 type
  Date
  is record
  
 Day
  
 :
  Integer
  range
  1
  ..
  31
 ;
  
 Month : Months;
  
 Year
  
 :
  Integer
 ;
  
  
 end record
 ; 
  
 end
  Dates
 ;
  
 Listing 2: access_types.ads
  
 1
  
 with
  Dates;
  use
  Dates;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 package
  Access_Types
  is
  
 --
  
 Declare an access type
  
 type
  Date_Acc
  is access
  Date;
  
 --
  
 ^ ""Designated type""
  
 --
  
 ^ Date_Acc values
  
 --
  
 point to Date
  
 --
  
 objects
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3
  
 D : Date_Acc :=
  null
 ;
  
 --
  
 ^ Literal for
  
 --
  
 ""access to nothing""
  
 (continues on next page)
  
 91",NA
9.2 Allocation (by type),"Once we have declared an access type, we need a way to give variables of the types a 
 meaningful value! You can allocate a value of an access type with the
  new
  keyword in 
 Ada.
  
 Listing 4: access_types.ads
  
 1
  
 with
  Dates;
  use
  Dates;
  
 2
  
 3 
  
 4
  
 package
  Access_Types
  is 
  
 type
  Date_Acc
  is access
  Date;
  
 5
  
 6
  
  
 7
  
  
 8
  
 D : Date_Acc :=
  new
  Date;
  
 --
  
 ^ Allocate a new Date record
  
 end
  Access_Types
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Access_Types.Access_Types
  
  
 MD5: e0be95b966e4aebaaf25db646d60c35c
  
 If the type you want to allocate needs constraints, you can put them in the subtype 
 indica-tion, just as you would do in a variable declaration:
  
 Listing 5: access_types.ads
  
 1
  
 with
  Dates;
  use
  Dates;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 package
  Access_Types
  is 
  
  
 type
  String_Acc
  is access
  String
 ;
  
 --
  
 ^
  
 --
  
 Access to unconstrained array type
  
 Msg : String_Acc;
  
 --
  
 ^ Default value is null
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3
  
 Buffer : String_Acc := 
  
 new
  String
  (
 1
  ..
  10
 );
  
 --
  
 ^ Constraint required
  
 end
  Access_Types
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Access_Types.Access_Types
  
  
 MD5: 83cf7a1074ff1b739658508098aa8208
  
 In some cases, though, allocating just by specifying the type is not ideal, so Ada also 
 allows you to initialize along with the allocation. This is done via the qualified expression 
 syntax:
  
 Listing 6: access_types.ads
  
 1
  
 with
  Dates;
  use
  Dates;
  
 2
  
 3
  
 package
  Access_Types
  is
  
 (continues on next page)",NA
9.3 Dereferencing,"The last important piece of Ada's access type facility is how to get from an access value 
 to the object that is pointed to, that is, how to dereference the pointer. Dereferencing a 
 pointer uses the .
 all
  syntax in Ada, but is often not needed — in many cases, the access 
 value will be implicitly dereferenced for you:
  
 Listing 7: access_types.ads
  
 1
  
 with
  Dates;
  use
  Dates;
  
 2
  
 3 
  
 4
  
 package
  Access_Types
  is 
  
  
 type
  Date_Acc
  is access
  Date;
  
 5
  
 6
  
 D
  
 : Date_Acc :=
  
 7
  
 new
  Date'(
 30
 , November,
  2011
 );
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6
  
 Today : Date := D.
 all
 ;
  
 --
  
 ^ Access value dereference
  
 J
  
 :
  Integer
  := D.Day;
  
 --
  
 ^ Implicit dereference
  
 --
  
 for record and array
  
 --
  
 components
  
 --
  
 Equivalent to D.all.day
  
 end
  Access_Types
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Access_Types.Access_Types
  
  
 MD5: 5cd1c259da04010b0dc1b43e9bd93b55",NA
9.4 Other features,"As you might know if you have used pointers in C or C++, we are still missing features 
 that are considered fundamental to the use of pointers, such as:
  
 • Pointer arithmetic (being able to increment or decrement a pointer in order to point 
 to 
  
 the next or previous object)
  
 • Manual deallocation - what is called free or delete in C. This is a potentially unsafe 
 operation. To keep within the realm of safe Ada, you need to never deallocate 
 manually.
  
 Those features exist in Ada, but are only available through specific standard library APIs.
  
 Attention: 
  
 The guideline in Ada is that most of the time you can avoid manual alloca-
  
 tion, and you should.",NA
9.5 Mutually recursive types,"The linked list is a common idiom in data structures; in Ada this would be most naturally 
 defined through two types, a record type and an access type, that are mutually 
 dependent.
  
 To declare mutually dependent types, you can use an incomplete type declaration:
  
 Listing 8: simple_list.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 package
  Simple_List
  is 
  
  
 type
  Node
 ;
  
 --
  
 This is an incomplete type declaration,
  
 --
  
 which is completed in the same
  
 --
  
 declarative region.
  
 6
  
 7
  
 type
  Node_Acc
  is access
  Node;
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3
  
 type
  Node
  is record
  
 Content
  
 :
  Natural
 ;
  
  
  
 Prev, Next : Node_Acc; 
  
  
 end record
 ; 
  
 end
  Simple_List
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Access_Types.Simple_List
  
  
 MD5: 4929b89c1fc913da635fa02e48248271
  
 In this example, the Node and Node_Acc types are mutually dependent.
  
 13
  ht 
 14
  ht
  
 9.5.
  
 tp://www.ada-
 auth.org/standards/12rat 
 tps://github.com/AdaCore/gnatcoll-
 core
  
 Mutually recursive types
  
 /html/Rat12-8-5.html 
  
 /blob/master/src/gnatcoll-
 refcount.ads
  
 95",NA
TEN,NA,NA
MORE ABOUT RECORDS,NA,NA
10.1 Dynamically sized record types,"We have previously seen
  some simple examples of record types
  (page 61). Let's now look 
 at some of the more advanced properties of this fundamental language feature.
  
 One point to note is that object size for a record type does not need to be known at 
 compile time. This is illustrated in the example below:
  
 Listing 1: runtime_length.ads
  
 1
  
  
 2
  
  
 3
  
 package
  Runtime_Length
  is
  
  
 function
  Compute_Max_Len return Natural
 ;
  
  
 end
  Runtime_Length
 ;
  
    
 Listing 2: var_size_record.ads
  
 1 
  
 with
  Runtime_Length;
  use
  Runtime_Length;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 package
  Var_Size_Record
  is 
  
 Max_Len
  :
  constant
  Natural
  := 
  
  
  
 Compute_Max_Len;
  
 --
  
 ^ Not known at compile time
  
 7
  
 8 
  
 9
  
 type
  Items_Array
  is 
  
  
 array
  (
 Positive
  range
  <>)
  of
  Integer
 ;
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6
  
 type
  Growable_Stack
  is record 
  
  
 Items : Items_Array (
 1
  .. Max_Len);
  
 Len
  
 :
  Natural
 ;
  
 end record
 ;
  
 --
  
 Growable_Stack is a definite type, but
  
 --
  
 size is not known at compile time.
  
 17
  
 18 
  
 19
  
 G : Growable_Stack; 
  
 end
  Var_Size_Record
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.More_About_Records.Var_Size_Record
  
  
 MD5: 6fb0b3f2b685a72ec694640ce378f77c
  
 It is completely fine to determine the size of your records at run time, but note that all 
 objects of this type will have the same size.
  
 97",NA
10.2 Records with discriminant,"In the example above, the size of the Items field is determined once, at run-time, but 
 every Growable_Stack instance will be exactly the same size. But maybe that's not what 
 you want to do. We saw that arrays in general offer this flexibility: for an unconstrained 
 array type, different objects can have different sizes.
  
 You can get analogous functionality for records, too, using a special kind of field that is 
 called a discriminant:
  
 Listing 3: var_size_record_2.ads
  
 1
  
  
 2
  
  
 3
  
 package
  Var_Size_Record_2
  is 
  
 type
  Items_Array
  is 
  
  
  
 array
  (
 Positive
  range
  <>)
  of
  Integer
 ;
  
 4
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15
  
 type
  Growable_Stack
  (
 Max_Len
  :
  Natural
 )
  is 
  
 record
  
 --
  
 ^ Discriminant. Cannot be
  
 --
  
 modified once
  
 --
  
 initialized.
  
 Items : Items_Array (
 1
  .. Max_Len);
  
 Len
  
 :
  Natural
  :=
  0
 ;
  
 end record
 ;
  
 --
  
 Growable_Stack is an indefinite type
  
 --
  
 (like an array)
  
 end
  Var_Size_Record_2
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.More_About_Records.Var_Size_Record_2
  
  
 MD5: 0c2ffe41b7553984e1ef48a50386559f
  
 Discriminants, in their simple forms, are constant: You cannot modify them once you 
 have initialized the object. This intuitively makes sense since they determine the size of 
 the object.
  
 Also, they make a type indefinite: Whether or not the discriminant is used to specify the 
 size of an object, a type with a discriminant will be indefinite if the discriminant is not 
 declared with an initialization:
  
 Listing 4: test_discriminants.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 package
  Test_Discriminants
  is 
  
  
 type
  Point
  (
 X
 ,
  Y
  :
  Natural
 )
  is record 
  
  
  
 null
 ; 
  
  
 end record
 ;
  
 5
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 P : Point;
  
 --
  
 ERROR: Point is indefinite, so you
  
 --
  
 need to specify the discriminants
  
 --
  
 or give a default value
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3
  
 P2 : Point (
 1
 ,
  2
 ); 
  
 P3 : Point := (
 1
 ,
  2
 );
  
 --
  
 Those two declarations are equivalent.
  
 14
  
 15
  
 end
  Test_Discriminants
 ;
  
 Code block metadata
  
 98
  
 Chapter 10.
  
 More about records",NA
10.3 Variant records,"The examples of discriminants thus far have illustrated the declaration of records of 
 varying size, by having components whose size depends on the discriminant.
  
 However, discriminants can also be used to obtain the functionality of what are 
 sometimes called ""variant records"": records that can contain different sets of fields.
  
 Listing 7: variant_record.ads
  
 1
  
  
 2
  
  
 3
  
 package
  Variant_Record
  is
  
 --
  
 Forward declaration of Expr
  
 type
  Expr
 ;
  
 4
  
 5 
  
 6
  
 --
  
 Access to a Expr
  
 type
  Expr_Access
  is access
  Expr;
  
 7
  
 8 
  
 9 
  
 10 
  
 11
  
 type
  Expr_Kind_Type
  is
  (
 Bin_Op_Plus
 , 
  
 Bin_Op_Minus
 , 
  
 Num
 );
  
 --
  
 A regular enumeration type
  
 12
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 type
  Expr
  (
 Kind
  :
  Expr_Kind_Type
 )
  is record
  
 --
  
 ^ The discriminant is an
  
 --
  
 enumeration value
  
 case
  Kind
  is 
  
 when
  Bin_Op_Plus | Bin_Op_Minus => 
  
  
  
 Left, Right : Expr_Access; 
  
 when
  Num => 
  
  
  
 Val :
  Integer
 ;
  
 (continues on next page)
  
 100
  
 Chapter 10.
  
 More about records",NA
ELEVEN,NA,NA
FIXED-POINT TYPES,NA,NA
11.1 Decimal fixed-point types,"We have already seen how to specify floating-point types. However, in some applications 
 floating-point is not appropriate since, for example, the roundoff error from binary arith-
 metic may be unacceptable or perhaps the hardware does not support floating-point in-
 structions. Ada provides a category of types, the decimal fixed-point types, that allows 
 the programmer to specify the required decimal precision (number of digits) as well as 
 the scal-ing factor (a power of ten) and, optionally, a range. In effect the values will be 
 represented as integers implicitly scaled by the specified power of 10. This is useful, for 
 example, for financial applications.
  
 The syntax for a simple decimal fixed-point type is
  
 type
  <
 type
 -
 name
 >
  is delta
  <
 delta
 -
 value
 >
  digits
  <
 digits
 -
 value
 >
 ;
  
  
 In this case, the
  delta
  and the
  digits
  will be used by the compiler to derive a range.
  
 Several attributes are useful for dealing with decimal types:
  
 Attribute Name
  
 Meaning
  
 First
  
 The first value of the type
  
 Last
  
 The last value of the type
  
 Delta
  
 The delta value of the type
  
 In the example below, we declare two data types: T3_D3 and T6_D3. For both types, the 
 delta value is the same: 0.001.
  
 Listing 1: decimal_fixed_point_types.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 procedure
  Decimal_Fixed_Point_Types
  is 
  
  
 type
  T3_D3
  is delta
  10.0
  **
  (
 -
 3
 )
  digits
  3
 ; 
  
 type
  T6_D3
  is delta
  10.0
  **
  (
 -
 3
 )
  digits
  6
 ; 
 begin
  
 Put_Line (
 ""The delta
  
 value of T3_D3 is ""
  
 &
  T3_D3'
 Image
  (T3_D3'
 Delta
 ));
  
 Put_Line (
 ""The minimum
  
 value of T3_D3 is ""
  
 &
  T3_D3'
 Image
  (T3_D3'
 First
 ));
  
 Put_Line (
 ""The maximum
  
 value of T3_D3 is ""
  
 &
  T3_D3'
 Image
  (T3_D3'
 Last
 )); 
  
 New_Line;
  
 14
  
 15 
  
 16
  
 Put_Line (
 ""The delta
  
 value of T6_D3 is ""
  
 &
  T6_D3'
 Image
  (T6_D3'
 Delta
 ));
  
 (continues on next page)
  
 103",NA
11.2 Ordinary fixed-point types,"Ordinary fixed-point types are similar to decimal fixed-point types in that the values are, 
 in effect, scaled integers. The difference between them is in the scale factor: for a 
 decimal fixed-point type, the scaling, given explicitly by the type's
  delta
 , is always a 
 power of ten.
  
 In contrast, for an ordinary fixed-point type, the scaling is defined by the type's small, 
 which is derived from the specified
  delta
  and, by default, is a power of two. Therefore, 
 ordinary fixed-point types are sometimes called binary fixed-point types.
  
 Note:
  
 Ordinary fixed-point types can be thought of being closer to the actual represen-
  
 tation on the machine, since hardware support for decimal fixed-point arithmetic is not 
 widespread (rescalings by a power of ten), while ordinary fixed-point types make use of 
 the available integer shift instructions.
  
 The syntax for an ordinary fixed-point type is
  
 type
  <
 type
 -
 name
 >
  is
  
  
 delta
  <
 delta
 -
 value
 >
  
  
 range
  <
 lower
 -
 bound
 >
  ..
  <
 upper
 -
 bound
 >
 ;
  
 By default the compiler will choose a scale factor, or small, that is a power of 2 no greater 
 than <delta-value>.
  
 For example, we may define a normalized range between -1.0 and 1.0 as following:
  
 Listing 3: normalized_fixed_point_type.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15 
  
 16
  
 procedure
  Normalized_Fixed_Point_Type
  is 
  
  
 D
  :
  constant
  :=
  2.0
  **
  (
 -
 31
 ); 
  
  
 type
  TQ31
  is delta
  D
  range
  -
 1.0
  ..
  1.0
  -
  D; 
 begin 
  
  
 Put_Line (
 ""TQ31 requires "" 
  
  
 &
  Integer
 '
 Image
  (TQ31'
 Size
 ) 
  
  
 &
  "" bits""
 );
  
 Put_Line (
 ""The delta
  
 value of TQ31 is ""
  
 &
  TQ31'
 Image
  (TQ31'
 Delta
 ));
  
 Put_Line (
 ""The minimum
  
 value of TQ31 is ""
  
 &
  TQ31'
 Image
  (TQ31'
 First
 ));
  
 Put_Line (
 ""The maximum
  
 value of TQ31 is ""
  
 &
  TQ31'
 Image
  (TQ31'
 Last
 )); 
  
 end
  Normalized_Fixed_Point_Type
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Fixed_Point_Types.Normalized_Fixed_Point_Type",NA
TWELVE,NA,NA
PRIVACY,"One of the main principles of modular programming, as well as object oriented program-
 ming, is
  encapsulation
 16
 .
  
 Encapsulation, briefly, is the concept that the implementer of a piece of software will dis-
 tinguish between the code's public interface and its private implementation.
  
 This is not only applicable to software libraries but wherever abstraction is used.
  
 In Ada, the granularity of encapsulation is a bit different from most object-oriented lan-
 guages, because privacy is generally specified at the package level.",NA
12.1 Basic encapsulation,"Listing 1: encapsulate.ads
  
 1 
  
 2
  
 package
  Encapsulate
  is 
  
 procedure
  Hello
 ;
  
  
 3 
  
 4
  
 private
  
 5
  
 6
  
  
 7
  
  
 8
  
 procedure
  Hello2
 ;
  
 --
  
 Not visible from external units
  
 end
  Encapsulate
 ;
  
 Listing 2: encapsulate.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 package body
  Encapsulate
  is
  
 4
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Hello
  is 
  
 begin 
  
  
 Put_Line (
 ""Hello""
 ); 
  
 end
  Hello
 ;
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3
  
 procedure
  Hello2
  is 
  
 begin 
  
  
 Put_Line (
 ""Hello #2""
 ); 
  
 end
  Hello2
 ;
  
 14
  
 15
  
 end
  Encapsulate
 ;
  
 16
  https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)",NA
12.2 Abstract data types,"With this high-level granularity, it might not seem obvious how to hide the 
 implementation details of a type. Here is how it can be done in Ada:
  
 Listing 4: stacks.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 package
  Stacks
  is 
  
  
 type
  Stack
  is private
 ;
  
 --
  
 Declare a private type: You cannot depend
  
 --
  
 on its implementation. You can only assign
  
 --
  
 and test for equality.
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11
  
 procedure
  Push
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 Integer
 );
  
 procedure
  Pop
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 out Integer
 );
  
 private
  
 12
  
 13 
  
 14
  
 subtype
  Stack_Index
  is 
  
 Natural
  range
  1
  ..
  10
 ;
  
 15
  
 16 
  
 17
  
 type
  Content_Type
  is 
  
 array
  (Stack_Index)
  of
  Natural
 ;
  
 18
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3
  
 type
  Stack
  is record
  
 Top
  
 : Stack_Index;
  
  
  
 Content : Content_Type; 
  
  
 end record
 ; 
  
 end
  Stacks
 ;
  
 Listing 5: stacks.adb
  
 1
  
 package body
  Stacks
  is
  
 2
  
 3 
  
 4
  
 procedure
  Push
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 Integer
 )
  is
  
 (continues on next page)
  
 110
  
 Chapter 12.
  
 Privacy",NA
12.3 Limited types,"Ada's
  limited type
  facility allows you to declare a type for which assignment and 
 comparison operations are not automatically provided.
  
 Listing 6: stacks.ads
  
 1
  
  
 2
  
  
 3
  
 package
  Stacks
  is 
  
  
 type
  Stack
  is limited private
 ;
  
 --
  
 Limited type. Cannot assign nor compare.
  
 4
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11
  
 procedure
  Push
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 Integer
 );
  
 procedure
  Pop
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 out Integer
 );
  
 private 
  
  
 subtype
  Stack_Index
  is 
  
  
  
 Natural
  range
  1
  ..
  10
 ;
  
 12
  
 13 
  
 14
  
 type
  Content_Type
  is 
  
 array
  (Stack_Index)
  of
  Natural
 ;
  
 15
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0
  
 type
  Stack
  is limited record
  
 Top
  
 : Stack_Index;
  
  
  
 Content : Content_Type; 
  
  
 end record
 ; 
  
 end
  Stacks
 ;
  
 Listing 7: stacks.adb
  
 1 
  
 package body
  Stacks
  is
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 procedure
  Push
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 Integer
 )
  is
  
 begin
  
 --
  
 Missing implementation!
  
  
 null
 ; 
  
 end
  Push
 ;
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 procedure
  Pop
  (
 S
  
 :
  in out Stack
 ;
  
 Val
  :
  
 out Integer
 )
  is
  
 begin
  
 --
  
 Dummy implementation!
  
  
 Val :=
  0
 ; 
  
 end
  Pop
 ;
  
 16
  
 17
  
 end
  Stacks
 ;
  
  
  
  
 112
  
 Chapter 12.
  
 Privacy",NA
12.4 Child packages & privacy,"We've seen previously (in the
  child packages section
  (page 35)) that packages can have 
 child packages. Privacy plays an important role in child packages. This section discusses 
 some of the privacy rules that apply to child packages.
  
 Although the private part of a package P is meant to encapsulate information, certain 
 parts of a child package P.C can have access to this private part of P. In those cases, 
 information from the private part of P can then be used as if it were declared in the 
 public part of its specification. To be more specific, the body of P.C and the private part 
 of the specification of P.C have access to the private part of P. However, the public part 
 of the specification of P.C only has access to the public part of P's specification. The 
 following table summarizes this:
  
 Part of a child package 
  
 Access to the private part of its parent's specification
  
 The rest of this section shows examples of how this access to private information actually 
 Specification: private part
  
 Body
  
 ✓
 ✓
  
 works for child packages.
  
 Let's first look at an example where the body of a child package P.C has access to the 
 private part of the specification of its parent P. We've seen, in a previous source-code 
 example,
  
 17
  http://www.ada-auth.org/standards/12rm/html/RM-7-6.html",NA
THIRTEEN,NA,NA
GENERICS,NA,NA
13.1 Introduction,"Generics are used for metaprogramming in Ada. They are useful for abstract algorithms 
 that share common properties with each other.
  
 Either a subprogram or a package can be generic. A generic is declared by using the key-
 word
  generic
 . For example:
  
 Listing 1: operator.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 generic
  
  
 type
  T
  is private
 ;
  
   
 --
  
 Declaration of formal types and objects
  
 --
  
 Below, we could use one of the following:
  
 --
  
 <procedure | function | package>
  
 procedure
  Operator
  (
 Dummy
  :
  in out T
 );
  
 Listing 2: operator.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 procedure
  Operator
  (
 Dummy
  :
  in out T
 )
  is
  
 begin
  
  
 null
 ;
  
  
     
 end
  Operator
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Generics.Show_Simple_Generic
  
  
 MD5: 1321d437043dafdb725fad416e654318",NA
13.2 Formal type declaration,"Formal types are abstractions of a specific type. For example, we may want to create an 
 algorithm that works on any integer type, or even on any type at all, whether a numeric 
 type or not. The following example declares a formal type T for the Set procedure.
  
 Listing 3: set.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 generic 
  
  
 type
  T
  is private
 ;
  
 --
  
 T is a formal type that indicates that
  
 --
  
 any type can be used, possibly a numeric
  
 --
  
 type or possibly even a record type.
  
 procedure
  Set
  (
 Dummy
  :
  T
 );
  
 119",NA
13.3 Formal object declaration,"Formal objects are similar to subprogram parameters. They can reference formal types 
 declared in the formal specification. For example:
  
 Listing 5: set.ads
  
 1
  
 generic
  
  
  
 2
  
 type
  T
  is private
 ;
  
 3
  
 X :
  in out
  T;
  
 4
  
 --
  
 X can be used in the Set procedure
  
 5
  
 procedure
  Set
  (
 E
  :
  T
 );
  
  
 120
  
 Chapter 13.
  
 Generics",NA
13.4 Generic body definition,"We don't repeat the
  generic
  keyword for the body declaration of a generic subprogram 
 or package. Instead, we start with the actual declaration and use the generic types and 
 objects we declared. For example:
  
 Listing 7: set.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 generic
  
  
 type
  T
  is private
 ;
  
  
 X :
  in out
  T;
  
  
 procedure
  Set
  (
 E
  :
  T
 );
  
     
 Listing 8: set.adb
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 procedure
  Set
  (
 E
  :
  T
 )
  is
  
  
 --
  
 Body definition: ""generic"" keyword
  
 --
  
 is not used
  
 begin 
  
  
 X := E; 
  
 end
  Set
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Generics.Show_Generic_Body_Definition
  
  
 MD5: de611ef77b528543fd6bad82c53857f7",NA
13.5 Generic instantiation,"Generic subprograms or packages can't be used directly. Instead, they need to be instan-
 tiated, which we do using the
  new
  keyword, as shown in the following example:
  
 Listing 9: set.ads
  
 1
  
 generic
  
  
 2
  
 type
  T
  is private
 ;
  
 3
  
 X :
  in out
  T;
  
 4
  
 --
  
 X can be used in the Set procedure
  
 5
  
 procedure
  Set
  (
 E
  :
  T
 );
  
  
 13.4.
  
 Generic body definition
  
 121",NA
13.6 Generic packages,"The previous examples focused on generic subprograms. In this section, we look at 
 generic
  
 packages. The syntax is similar to that used for generic subprograms: we start with the
  
 generic
  keyword and continue with formal declarations. The only difference is that
  
 package
  
 is specified instead of a subprogram keyword.
  
 Here's an example:",NA
13.7 Formal subprograms,"In addition to formal types and objects, we can also declare formal subprograms or 
 pack-ages. This course only describes formal subprograms; formal packages are 
 discussed in the advanced course.
  
 We use the
  with
  keyword to declare a formal subprogram. In the example below, we 
 declare a formal function (Comparison) to be used by the generic procedure Check.
  
 Listing 15: check.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 generic
  
  
 Description :
  String
 ;
  
  
 type
  T
  is private
 ;
  
  
 with
  function Comparison (X, Y : T)
  
  
 return
  Boolean
 ;
  
  
 procedure
  Check
  (
 X
 ,
  Y
  :
  T
 );
  
       
 Listing 16: check.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 (continues on next page)
  
 124
  
 Chapter 13.
  
 Generics",NA
13.8 Example: I/O instances,"Ada offers generic I/O packages that can be instantiated for standard and derived types.
  
 One example is the generic Float_IO package, which provides procedures such as Put and
  
 Get. In fact, Float_Text_IO — available from the standard library — is an instance of the
  
 Float_IO package, and it's defined as:
  
 with
  Ada.Text_IO;
  
  
 package
  Ada.Float_Text_IO
  is new
  Ada.Text_IO.Float_IO
  (Float);
  
  
 13.8.
  
 Example: I/O instances
  
 125",NA
13.9 Example: ADTs,"An important application of generics is to model abstract data types (ADTs). In fact, Ada
  
 includes a library with numerous ADTs using generics: Ada.Containers (described in the
  
 containers section
  (page 199)).
  
 A typical example of an ADT is a stack:
  
 Listing 21: stacks.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 generic 
  
  
 Max :
  Positive
 ; 
  
  
 type
  T
  is private
 ; 
  
 package
  Stacks
  is
  
 5
  
 6 
  
 type
  Stack
  is limited private
 ;
  
 7
  
 8 
  
 Stack_Underflow, Stack_Overflow :
  exception
 ;
  
 9
  
 10 
  
 function
  Is_Empty
  (
 S
  :
  Stack
 )
  return
  Boolean
 ;
  
 11
  
 12 
  
 function
  Pop
  (
 S
  :
  in out Stack
 )
  return
  T;
  
 13
  
 14 
  
 procedure
  Push
  (
 S
  :
  in out Stack
 ;
  
 15 
 V
  : 
  
 T
 );
  
 16
  
 17 
 private
  
 18
  
 19 
  
 type
  Stack_Array
  is
  
 20 
  
 array
  (
 Natural
  range
  <>)
  of
  T;
  
 21
  
 22 
  
 Min
  :
  constant
  :=
  1
 ;
  
 23
  
 2
 4 
  
 2
 5 
  
 2
 6 
  
 2
 7
  
 type
  Stack
  is record 
  
  
 Container : Stack_Array (Min .. Max);
  
 Top
  
 :
  Natural
  := Min
  -
  1
 ;
  
 end record
 ;
  
 28
  
 29 
 end
  Stacks
 ;
  
 Listing 22: stacks.adb
  
 1 
  
 package body
  Stacks
  is
  
 2
  
 3 
  
 4
  
 function
  Is_Empty
  (
 S
  :
  Stack
 )
  return
  Boolean
  is 
 (S.Top
  <
  S.Container'
 First
 );
  
 5
  
 6 
  
 7
  
 function
  Is_Full
  (
 S
  :
  Stack
 )
  return
  Boolean
  is 
 (S.Top
  >=
  S.Container'
 Last
 );
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 function
  Pop
  (
 S
  :
  in out Stack
 )
  return
  T
  is begin 
  
  
 if
  Is_Empty (S)
  then 
  
  
 raise
  Stack_Underflow; 
  
  
 else 
  
  
 return
  X : T
  do
  
 X
  
 := S.Container (S.Top);
  
  
  
  
 S.Top := S.Top
  -
  1
 ; 
  
  
 end
  return
 ; 
  
  
 end if
 ; 
  
 end
  Pop
 ;
  
 (continues on next page)
  
 128
  
 Chapter 13.
  
 Generics",NA
13.10 Example: Swap,"Let's look at a simple procedure that swaps variables of type Color:
  
 Listing 24: colors.ads
  
 1
  
  
 2
  
  
 3
  
 package
  Colors
  is 
  
  
 type
  Color
  is
  (
 Black
 ,
  Red
 ,
  Green
 , 
  
  
 Blue
 ,
  White
 );
  
 4
  
 (continues on next page)
  
 13.10.
  
 Example: Swap
  
 129",NA
13.11 Example: Reversing,"The previous example, with an algorithm to swap two values, is one of the simplest 
 exam-ples of using generics. Next we study an algorithm for reversing elements of an 
 array. First, let's start with a non-generic version of the algorithm, one that works 
 specifically for the Color type:
  
 Listing 31: colors.ads
  
 1
  
 package
  Colors
  is
  
  
 5
  
  
 6
  
  
 7
  
 type
  Color_Array
  is 
  
 array
  (
 Integer
  range
  <>)
  of
  Color;
  
  
 2
  
  
 3
  
  
 4
  
 type
  Color
  is
  (
 Black
 ,
  Red
 ,
  Green
 , 
  
 Blue
 ,
  White
 );",NA
13.12 Example: Test application,"In the previous example we've focused only on abstracting the reversing algorithm itself. 
 However, we could have decided to also abstract our small test application. This could be 
 useful if we, for example, decide to test other procedures that change elements of an 
 array. In order to do this, we again have to choose the elements to abstract. We 
 therefore declare the following formal parameters:
  
  
 • S: the string containing the array name
  
  
 • a function Image that converts an element of type T to a string
  
  
 • a procedure Test that performs some operation on the array 
  
 Note that Image and Test are examples of formal subprograms and S is an example of a 
 formal object.
  
 Here is a version of the test application making use of the generic Perform_Test 
 procedure:
  
 Listing 38: generic_reverse.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
 generic
  
  
 type
  T
  is private
 ;
  
  
 type
  Index
  is range
  <>;
  
  
 type
  Array_T
  is
  
  
 array
  (
 Index
  range
  <>)
  of
  T;
  
  
 procedure
  Generic_Reverse
  (
 X
  :
  in out Array_T
 );
  
       
 Listing 39: generic_reverse.adb
  
 1
  
 procedure
  Generic_Reverse
  (
 X
  :
  in out Array_T
 )
  is
  
  
  
 2
  
 begin
  
 3
  
 for
  I
  in
  X'
 First
  ..
  
 4
  
 (X'
 Last
  +
  X'
 First
 )
  /
  2
  loop
  
 5
  
 declare
  
 6
  
 Tmp
  
 : T;
  
 7
  
 X_Left
  
 : T
  
 8
  
 renames
  X (I);
  
 9
  
 X_Right : T
  
 10
  
 renames
  X (X'
 Last
  +
  X'
 First
  -
  I);
  
 11
  
 begin
  
 12
  
 Tmp
  
 := X_Left;
  
 13
  
 X_Left
  
 := X_Right;
  
 14
  
 X_Right := Tmp;
  
 15
  
 end
 ;
  
 16
  
 end loop
 ;
  
 17
  
 end
  Generic_Reverse
 ;",NA
FOURTEEN,NA,NA
EXCEPTIONS,"Ada uses exceptions for error handling. Unlike many other languages, Ada speaks about 
 raising
 , not
  throwing
 , an exception and
  handling
 , not
  catching
 , an exception.",NA
14.1 Exception declaration,"Ada exceptions are not types, but instead objects, which may be peculiar to you if you're 
 used to the way Java or Python support exceptions. Here's how you declare an exception:
  
 Listing 1: exceptions.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 package
  Exceptions
  is
  
  
 My_Except :
  exception
 ;
  
   
 --
  
 Like an object. *NOT* a type !
  
 end
  Exceptions
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Exceptions.Show_Exception
  
  
 MD5: 6201faeca9b029c790023856d2c8c419
  
 Even though they're objects, you're going to use each declared exception object as a 
 ""kind"" or ""family"" of exceptions. Ada does not require that a subprogram declare every 
 exception it can potentially raise.",NA
14.2 Raising an exception,"To raise an exception of our newly declared exception kind, do the following:
  
 Listing 2: main.adb
  
 1
  
 with
  Exceptions;
  use
  Exceptions;
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10
  
 procedure
  Main
  is 
  
 begin 
  
  
 raise
  My_Except;
  
 --
  
 Execution of current control flow
  
 --
  
 abandoned; an exception of kind
  
 --
  
 ""My_Except"" will bubble up until it
  
 --
  
 is caught.
  
 end
  Main
 ;
  
 Code block metadata
  
 139",NA
14.3 Handling an exception,"Next, we address how to handle exceptions that were raised by us or libraries that we 
 call. The neat thing in Ada is that you can add an exception handler to any statement 
 block as follows:
  
 Listing 4: open_file.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 with
  Ada.Exceptions;
  
 use
  Ada.Exceptions;
  
 3
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15 
  
 16
  
 procedure
  Open_File
  is 
  
  
 File :
  File_Type
 ; 
  
 begin
  
 --
  
 Block (sequence of statements)
  
 begin 
  
  
 Open (File, In_File,
  ""input.txt""
 ); 
  
 exception 
  
  
 when
  E : Name_Error =>
  
 --
  
 ^ Exception to be handled
  
 Put (
 ""Cannot open input file : ""
 ); 
  
 Put_Line (Exception_Message (E)); 
  
 raise
 ;
  
 --
  
 Reraise current occurence
  
 (continues on next page)
  
 140
  
 Chapter 14.
  
 Exceptions",NA
14.4 Predefined exceptions,"Ada has a very small number of predefined exceptions:
  
  
 • Constraint_Error is the main one you might see. It's raised:
  
  
  
 –
  When bounds don't match or, in general, any violation of constraints.
  
   
 –
  In case of overflow
  
   
 –
  In case of null dereferences
  
   
 –
  In case of division by 0
  
 • Program_Error might appear, but probably less often. It's raised in more arcane situ-
  
 ations, such as for order of elaboration issues and some cases of detectable 
 erroneous 
  
 execution.
  
 • Storage_Error will happen because of memory issues, such as:
  
   
 –
  Not enough memory (allocator)
  
   
 –
  Not enough stack
  
 •
  Task
 ing_Error will happen with task related errors, such as any error happening dur-
  
 ing task activation.
  
 You should not reuse predefined exceptions. If you do then, it won't be obvious when one 
 is raised that it is because something went wrong in a built-in language operation.",NA
FIFTEEN,NA,NA
TASKING,"Tasks and protected objects allow the implementation of concurrency in Ada. The 
 following sections explain these concepts in more detail.",NA
15.1 Tasks,"A task can be thought as an application that runs
  concurrently
  with the main application. 
 In other programming languages, a task might be called a
  thread
 18
 , and tasking might 
 be called
  multithreading
 19
 .
  
 Tasks may synchronize with the main application but may also process information com-
 pletely independently from the main application. Here we show how this is accomplished.
  
 15.1.1 Simple task
  
 Tasks are declared using the keyword
  task
 . The task implementation is specified in a
  
 task body
  block. For example:
  
 Listing 1: show_simple_task.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 procedure
  Show_Simple_Task
  is 
  
  
 task
  T;
  
 5
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
  
 task body
  T
  is 
  
  
 begin 
  
  
  
 Put_Line (
 ""In task T""
 ); 
  
  
 end
  T
 ; 
  
 begin 
  
  
 Put_Line (
 ""In main""
 ); 
  
 end
  Show_Simple_Task
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Tasking.Show_Simple_Task
  
  
 MD5: b17d9b35b4b2b53bc59776749e1be219
  
 Runtime output
  
 In task T
  
  
 In main
  
 18
  https://en.wikipedia.org/wiki/Thread_(computing) 
  
 19
  
 https://en.wikipedia.org/wiki/Thread_(computing)#Multithreading
  
 143",NA
15.2 Protected objects,"When multiple tasks are accessing shared data, corruption of that data may occur. For 
 example, data may be inconsistent if one task overwrites parts of the information that's 
 being read by another task at the same time. In order to avoid these kinds of problems 
 and ensure information is accessed in a coordinated way, we use
  protected objects
 .
  
 Protected objects encapsulate data and provide access to that data by means of
  
 protected operations
 , which may be subprograms or protected entries. Using protected 
 objects en-sures that data is not corrupted by race conditions or other concurrent 
 access.
  
 Important
  
 Objects can be protected from concurrent access using Ada tasks. In fact, this was the 
 only
  way of protecting objects from concurrent access in Ada 83 (the first version of the 
 Ada language). However, the use of protected objects is much simpler than using similar 
 mechanisms implemented using only tasks. Therefore, you should use protected objects 
 when your main goal is only to protect data.
  
 15.2.1 Simple object
  
 You declare a protected object with the
  protected
  keyword. The syntax is similar to that 
 used for packages: you can declare operations (e.g., procedures and functions) in the 
 public part and data in the private part. The corresponding implementation of the 
 operations is included in the
  protected body
  of the object. For example:
  
 Listing 14: show_protected_objects.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 procedure
  Show_Protected_Objects
  is
  
 4
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
 protected
  Obj
  is
  
 --
  
 Operations go here (only subprograms)
  
 procedure
  Set
  (
 V
  :
  Integer
 ); 
  
 function
  Get return Integer
 ; 
  
 private
  
 --
  
 Data goes here
  
  
 Local :
  Integer
  :=
  0
 ; 
  
 end
  Obj
 ;
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9
  
 protected body
  Obj
  is
  
 --
  
 procedures can modify the data
  
 procedure
  Set
  (
 V
  :
  Integer
 )
  is 
  
 begin 
  
 Local := V; 
  
 end
  Set
 ;
  
 20
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5 
  
 2
 6
  
 --
  
 functions cannot modify the data
  
  
 function
  Get return Integer
  is 
  
  
 begin 
  
  
 return
  Local; 
  
  
 end
  Get
 ; 
  
 end
  Obj
 ;
  
 27
  
 28 
 begin
  
 29 
  
 Obj.Set (
 5
 );
  
 (continues on next page)",NA
15.3 Task and protected types,"In the previous examples, we defined single tasks and protected objects. We can, 
 however, generalize tasks and protected objects using type definitions. This allows us, 
 for example, to create multiple tasks based on just a single task type.
  
 15.3.1 Task types
  
 A task type is a generalization of a task. The declaration is similar to simple tasks: you 
 replace
  task
  with
  task type
 . The difference between simple tasks and task types is that 
 task types don't create actual tasks that automatically start. Instead, a task object 
 decla-ration is needed. This is exactly the way normal variables and types work: objects 
 are only created by variable definitions, not type definitions.
  
 To illustrate this, we repeat our first example:
  
 Listing 16: show_simple_task.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 procedure
  Show_Simple_Task
  is 
  
  
 task
  T;
  
 5
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
  
 task body
  T
  is 
  
  
 begin 
  
  
  
 Put_Line (
 ""In task T""
 ); 
  
  
 end
  T
 ; 
  
 begin 
  
  
 Put_Line (
 ""In main""
 ); 
  
 end
  Show_Simple_Task
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Tasking.Show_Simple_Task
  
  
 MD5: b17d9b35b4b2b53bc59776749e1be219
  
 Runtime output
  
 In task T
  
  
 In main
  
 We now rewrite it by replacing
  task
  T with
  task type
  TT
 . We declare a task (A_Task) 
 based on the task type TT after its definition:
  
 Listing 17: show_simple_task_type.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 procedure
  Show_Simple_Task_Type
  is 
  
  
 task type
  TT
 ;
  
 5
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 task body
  TT
  is 
  
 begin 
  
  
 Put_Line (
 ""In task type TT""
 ); 
  
 end
  TT
 ;
  
 10
  
 11
  
 A_Task : TT;
  
  
 12
  
 begin
  
 13
  
 Put_Line (
 ""In main""
 );
  
 14
  
 end
  Show_Simple_Task_Type
 ;
  
  
 15.3.
  
 Task and protected types
  
 157",NA
SIXTEEN,NA,NA
DESIGN BY CONTRACTS,"Contracts are used in programming to codify expectations. Parameter modes of a 
 subpro-gram can be viewed as a simple form of contracts. When the specification of 
 subprogram Op declares a parameter using
  in
  mode, the caller of Op knows that the
  in
  
 argument won't be changed by Op. In other words, the caller expects that Op doesn't 
 modify the argument it's providing, but just reads the information stored in the 
 argument. Constraints and subtypes are other examples of contracts. In general, these 
 specifications improve the consistency of the application.
  
 Design-by-contract
  programming refers to techniques that include pre- and 
 postconditions, subtype predicates, and type invariants. We study those topics in this 
 chapter.",NA
16.1 Pre- and postconditions,"Pre- and postconditions provide expectations regarding input and output parameters of 
 subprograms and return value of functions. If we say that certain requirements must be 
 met before calling a subprogram Op, those are preconditions. Similarly, if certain 
 requirements must be met after a call to the subprogram Op, those are postconditions. 
 We can think of preconditions and postconditions as promises between the subprogram 
 caller and the callee: a precondition is a promise from the caller to the callee, and a 
 postcondition is a promise in the other direction.
  
 Pre- and postconditions are specified using an aspect clause in the subprogram declara-
 tion. A
  with
  Pre =>
  <
 condition
 >
  clause specifies a precondition and a
  with
  Post => 
 <
 condition
 >
  clause specifies a postcondition.
  
 The following code shows an example of preconditions:
  
 Listing 1: show_simple_precondition.adb
  
 1
  
 procedure
  Show_Simple_Precondition
  is
  
 2
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12
  
 procedure
  DB_Entry
  (
 Name
  :
  String
 ;
  
 Age
  
 :
  Natural
 )
  
 with
  Pre => Name'
 Length
  >
  0 
  
 is 
  
 begin
  
 --
  
 Missing implementation
  
  
  
 null
 ; 
  
  
 end
  DB_Entry
 ; 
  
 begin 
  
  
 DB_Entry (
 ""John""
 ,
  30
 );
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6
  
 --
  
 Precondition will fail!
  
 DB_Entry (
 """"
 ,
  
 21
 );
  
 end
  Show_Simple_Precondition
 ;",NA
16.2 Predicates,"Predicates specify expectations regarding types. They're similar to pre- and 
 postconditions, but apply to types instead of subprograms. Their conditions are checked 
 for each object of a given type, which allows verifying that an object of type T is 
 conformant to the requirements of its type.
  
 There are two kinds of predicates: static and dynamic. In simple terms, static predicates 
 are used to check objects at compile-time, while dynamic predicates are used for checks 
 at run time. Normally, static predicates are used for scalar types and dynamic predicates 
 for the more complex types.
  
 Static and dynamic predicates are specified using the following clauses, respectively:",NA
16.3 Type invariants,"Type invariants are another way of specifying expectations regarding types. While predi-
 cates are used for
  non-private
  types, type invariants are used exclusively to define 
 expec-tations about private types. If a type T from a package P has a type invariant, the 
 results of operations on objects of type T are always consistent with that invariant.
  
 Type invariants are specified with a
  with
  Type_Invariant =>
  <
 property
 >
  clause. Like 
 predicates, the
  property
  defines a condition that allows us to check if an object of type T 
 is conformant to its requirements. In this sense, type invariants can be viewed as a sort 
 of predicate for private types. However, there are some differences in terms of checks. 
 The following table summarizes the differences:
  
 Element
  
 Subprogram parameter checks
  
 Assignment checks
  
 Predi-
  
 On all
  in
  and
  out
  parameters
  
 On assignments and ex-
  
 cates
  
  
 plicit initializations
  
 Type
  
 in-
  
 On
  out
  parameters returned from subprograms
  
 On all initializations
  
 variants
  
 declared in the same public scope
  
 We could rewrite our previous example and replace dynamic predicates by type 
 invariants. It would look like this:",NA
SEVENTEEN,NA,NA
INTERFACING WITH C,"Ada allows us to interface with code in many languages, including C and C++. This 
 section discusses how to interface with C.",NA
17.1 Multi-language project,"By default, when using
  gprbuild
  we only compile Ada source files. To compile C files as 
 well, we need to modify the project file used by
  gprbuild
 . We use the Languages entry, 
 as in the following example:
  
 project Multilang
  is
  
  
 for
  Languages
  use
  (
 ""ada""
 ,
  ""c""
 );
  
  
 for
  Source_Dirs
  use
  (
 ""src""
 );
  
  
 for
  Main
  use
  (
 ""main.adb""
 );
  
  
 for
  Object_Dir
  use
  ""obj""
 ;
  
  
 end
  Multilang
 ;",NA
17.2 Type convention,"To interface with data types declared in a C application, you specify the Convention 
 aspect on the corresponding Ada type declaration. In the following example, we interface 
 with the C_Enum enumeration declared in a C source file:
  
 Listing 1: show_c_enum.adb
  
 1
  
 procedure
  Show_C_Enum
  is
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 type
  C_Enum
  is
  (
 A
 ,
  B
 ,
  C
 ) 
  
 with
  Convention => C;
  
 --
  
 Use C convention for C_Enum
  
 begin 
  
  
 null
 ; 
  
 end
  
 Show_C_Enum
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Interfacing_With_C.Ada_C_Enum
  
  
 MD5: a14d7d981fd7d6d806cf3c55f35e19c8
  
 171",NA
17.3 Foreign subprograms,"17.3.1 Calling C subprograms in Ada
  
 We use a similar approach when interfacing with subprograms written in C. Consider the 
 following declaration in the C header file:
  
 Listing 4: my_func.h
  
 1
  
 int
  my_func
  (
 int
  a);
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Interfacing_With_C.Ada_C_Func
  
  
 MD5: 37b9d7ba668f7ec83c2b27ee33637937
  
  
  
 172
  
 Chapter 17.
  
 Interfacing with 
 C",NA
17.4 Foreign variables,"17.4.1 Using C global variables in Ada
  
 To use global variables from C code, we use the same method as subprograms: we 
 specify the Import and Convention aspects for each variable we want to import.
  
 Let's reuse an example from the previous section. We'll add a global variable (func_cnt) 
 to count the number of times the function (my_func) is called:
  
 Listing 11: test.h
  
 1
  
 extern
  int
  func_cnt;
  
 2
  
 3
  
 int
  my_func
  (
 int
  a);
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Interfacing_With_C.Ada_C_Vars
  
  
 MD5: 11ba8f7a72ce7058571994870a02b052
  
 The variable is declared in the C file and incremented in my_func:
  
 Listing 12: test.c
  
 1
  
 #include
  ""test.h""
  
 2
  
 3
  
 int
  func_cnt
  =
  0
 ;
  
 4
  
 5
  
  
 6
  
  
 7
  
 int
  my_func
  (
 int
  a) 
  
 { 
  
 func_cnt
 ++
 ;
  
 8
  
 9
  
 }
  
 return
  a
  *
  2
 ;
  
 10
  
 Code block metadata
  
 17.4.
  
 Foreign variables
  
 175",NA
17.5 Generating bindings,"In the examples above, we manually added aspects to our Ada code to correspond to the 
 C source-code we're interfacing with. This is called creating a
  binding
 . We can automate 
 this process by using the
  Ada spec dump
  compiler option: -fdump-ada-spec. We 
 illustrate this by revisiting our previous example.
  
 This was our C header file:
  
 Listing 17: test.h
  
 1
  
 extern
  int
  func_cnt;
  
 2
  
 3
  
 int
  my_func
  (
 int
  a);
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Interfacing_With_C.C_Binds
  
  
 MD5: 11ba8f7a72ce7058571994870a02b052
  
 To create Ada bindings, we'll call the compiler like this:
  
 gcc -c -fdump-ada-spec -C ./test.h
  
  
 The result is an Ada spec file called test_h.ads:
  
 Listing 18: test_h.ads
  
 1 
  
 2
  
 pragma
  Ada_2005
 ; 
  
 pragma
  Style_Checks
  (Off);
  
 3
  
 4
  
 with
  Interfaces.C;
  use
  Interfaces.C;
  
 5
  
 6
  
 package
  test_h
  is
  
 7
  
 (continues on next page)
  
 178
  
 Chapter 17.
  
 Interfacing with 
 C",NA
EIGHTEEN,NA,NA
OBJECT-ORIENTED PROGRAMMING,"Object-oriented programming (OOP) is a large and ill-defined concept in programming 
 lan-guages and one that tends to encompass many different meanings because different 
 lan-guages often implement their own vision of it, with similarities and differences from 
 the implementations in other languages.
  
 However, one model mostly ""won"" the battle of what object-oriented means, if only by 
 sheer popularity. It's the model used in the Java programming language, which is very 
 similar to the one used by C++. Here are some defining characteristics:
  
 • Type derivation and extension: Most object oriented languages allow the user to add 
  
 fields to derived types.
  
 • Subtyping: Objects of a type derived from a base type can, in some instances, be 
  
 substituted for objects of the base type.
  
 • Runtime polymorphism: Calling a subprogram, usually called a
  method
 , attached to 
  
 an object type can dispatch at runtime depending on the exact type of the object.
  
 • Encapsulation: Objects can hide some of their data.
  
 • Extensibility: People from the ""outside"" of your package, or even your whole library, 
  
 can derive from your object types and define their own behaviors.
  
 Ada dates from before object-oriented programming was as popular as it is today. Some 
 of the mechanisms and concepts from the above list were in the earliest version of Ada 
 even before what we would call OOP was added:
  
 • As we saw, encapsulation is not implemented at the type level in Ada, but instead at 
  
 the package level.
  
 • Subtyping can be implemented using, well, subtypes, which have a full and permis-
 sive static substitutability model. The substitution will fail at runtime if the dynamic 
 constraints of the subtype are not fulfilled.
  
 • Runtime polymorphism can be implemented using variant records.
  
 However, this lists leaves out type extensions, if you don't consider variant records, and 
 extensibility.
  
 The 1995 revision of Ada added a feature filling the gaps, which allowed people to 
 program following the object-oriented paradigm in an easier fashion. This feature is 
 called
  tagged types
 .
  
 Note:
  
 It's possible to program in Ada without ever creating tagged types. If that's your
  
 prefered style of programming or you have no specific use for tagged types, feel free to 
 not use them, as is the case for many features of Ada.
  
 However, they can be the best way to express solutions to certain problems and they 
 may be the best way to solve your problem. If that's the case, read on!
  
 185",NA
18.1 Derived types,"Before presenting tagged types, we should discuss a topic we have brushed on, but not 
 really covered, up to now:
  
 You can create one or more new types from every type in Ada. Type derivation is built 
 into the language.
  
 Listing 1: newtypes.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
 package
  Newtypes
  is 
  
  
 type
  Point
  is record 
  
  
  
 X, Y :
  Integer
 ; 
  
  
 end record
 ;
  
 5
  
 6 
  
 7
  
  
 type
  New_Point
  is new
  Point; 
  
 end
  Newtypes
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Object_Oriented_Programming.Newtypes
  
  
 MD5: 0d45096755b4bfb08ba8db19ecba3f57
  
 Type derivation is useful to enforce strong typing because the type system treats the two 
 types as incompatible.
  
 But the benefits are not limited to that: you can inherit things from the type you derive 
 from. You not only inherit the representation of the data, but you can also inherit 
 behavior.
  
 When you inherit a type you also inherit what are called
  primitive operations
 . A primitive 
 operation (or just a
  primitive
 ) is a subprogram attached to a type. Ada defines primitives 
 as subprograms defined in the same scope as the type.
  
 Attention: 
  
 A subprogram will only become a primitive of the type if: 
 1. The subprogram is declared in the same scope as the type and 2. 
 The type and the subprogram are declared in a package
  
 Listing 2: primitives.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  Primitives
  is 
  
  
 package
  Week
  is 
  
  
  
 type
  Days
  is
  (
 Monday
 ,
  Tuesday
 ,
  Wednesday
 , 
  
  
  
 Thursday
 ,
  Friday
 , 
  
  
  
  
 Saturday
 ,
  Sunday
 );
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2
  
 --
  
 Print_Day is a primitive
  
 --
  
 of the type Days
  
 procedure
  Print_Day
  (
 D
  :
  Days
 ); 
  
 end
  Week
 ;
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9
  
 package body
  Week
  is 
  
  
 procedure
  Print_Day
  (
 D
  :
  Days
 )
  is 
  
  
 begin 
  
  
 Put_Line (Days'
 Image
  (D)); 
  
  
 end
  Print_Day
 ; 
  
 end
  Week
 ;
  
 (continues on next page)",NA
18.2 Tagged types,"The 1995 revision of the Ada language introduced tagged types to fullfil the need for an 
 unified solution that allows programming in an object-oriented style similar to the one 
 de-scribed at the beginning of this chapter.
  
 Tagged types are very similar to normal records except that some functionality is added:
  
 • Types have a
  tag
 , stored inside each object, that identifies the
  runtime type
 20
 of that 
  
 object.
  
 • Primitives can dispatch. A primitive on a tagged type is what you would call a
  
 method 
 in Java or C++. If you derive a base type and override a primitive of it, you 
 can often call it on an object with the result that which primitive is called depends 
 on the exact runtime type of the object.
  
 20
  https://en.wikipedia.org/wiki/Run-time_type_information
  
 18.2.
  
 Tagged types
  
 187",NA
18.3 Classwide types,"To remain consistent with the rest of the language, a new notation needed to be 
 introduced to say ""This object is of this type or any descendant derives tagged type"".
  
 In Ada, we call this the
  classwide type
 . It's used in OOP as soon as you need 
 polymorphism. For example, you can't do the following:
  
 Listing 5: main.adb
  
 1 
  
 with
  P;
  use
  P;
  
 2
  
 3 
  
 procedure
  Main
  is
  
 4
  
 5 
  
 6
  
 O1 : My_Class;
  
 --
  
 Declaring an object of type My_Class
  
 7
  
 8 
  
 9
  
 O2 : Derived := (A =>
  12
 );
  
 --
  
 Declaring an object of type Derived
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7
  
 O3 : My_Class := O2;
  
 --
  
 INVALID: Trying to assign a value
  
 --
  
 of type derived to a variable of
  
 --
  
 type My_Class.
  
 begin 
  
  
 null
 ; 
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Object_Oriented_Programming.Tagged_Types
  
  
 MD5: c87ad8bb686cb1763740750846258357
  
 Build output
  
 main.adb:11:21: error: expected type ""My_Class"" defined at p.ads:2
  
  
 main.adb:11:21: error: found type ""Derived"" defined at p.ads:16
  
  
 gprbuild: *** compilation phase failed
  
 This is because an object of a type T is exactly of the type T, whether T is tagged or not. 
 What you want to say as a programmer is ""I want O3 to be able to hold an object of type 
 My_Class or any type descending from My_Class"". Here's how you do that:
  
 Listing 6: main.adb
  
 1
  
 with
  P;
  use
  P;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Main
  is 
  
 O1 : My_Class;
  
 --
  
 Declare an object of type My_Class
  
 6
  
 7 
  
 8
  
 O2 : Derived := (A =>
  12
 );
  
 --
  
 Declare an object of type Derived
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6
  
 O3 : My_Class'
 Class
  := O2;
  
 --
  
 Now valid: My_Class'Class designates
  
 --
  
 the classwide type for My_Class,
  
 --
  
 which is the set of all types
  
 --
  
 descending from My_Class (including
  
 --
  
 My_Class).
  
 begin
  
 (continues on next page)
  
 18.3.
  
 Classwide types
  
 189",NA
18.4 Dispatching operations,"We saw that you can override operations in types derived from another tagged type. The 
 eventual goal of OOP is to make a dispatching call: a call to a primitive (method) that 
 depends on the exact type of the object.
  
 But, if you think carefully about it, a variable of type My_Class always contains an object 
 of exactly that type. If you want to have a variable that can contain a My_Class or any 
 derived type, it has to be of type My_Class'
 Class
 .
  
 In other words, to make a dispatching call, you must first have an object that can be 
 either of a type or any type derived from this type, namely an object of a classwide type.
  
 Listing 7: main.adb
  
 1 
  
 with
  P;
  use
  P;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Main
  is 
  
 O1 : My_Class;
  
 --
  
 Declare an object of type My_Class
  
 6
  
 7 
  
 8
  
 O2 : Derived := (A =>
  12
 );
  
 --
  
 Declare an object of type Derived
  
 9
  
 10 
  
 O3 : My_Class'
 Class
  := O2;
  
 11
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
  
 O4 : My_Class'
 Class
  := O1; 
  
 begin 
  
  
 Foo (O1);
  
 --
  
 Non dispatching: Calls My_Class.Foo
  
 Foo (O2);
  
 --
  
 Non dispatching: Calls Derived.Foo
  
 Foo (O3);
  
 --
  
 Dispatching: Calls Derived.Foo
  
 Foo (O4);
  
 --
  
 Dispatching: Calls My_Class.Foo
  
 end
  Main
 ;
  
 Code block metadata
  
 190
  
 Chapter 18.
  
 Object-oriented 
 programming",NA
18.5 Dot notation,"You can also call primitives of tagged types with a notation that's more familiar to object 
 ori-ented programmers. Given the Foo primitive above, you can also write the above 
 program this way:
  
 Listing 9: main.adb
  
 1 
  
 with
  P;
  use
  P;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Main
  is 
  
 O1 : My_Class;
  
 --
  
 Declare an object of type My_Class
  
 6
  
 7 
  
 8
  
 O2 : Derived := (A =>
  12
 );
  
 --
  
 Declare an object of type Derived
  
 9
  
 10 
  
 O3 : My_Class'
 Class
  := O2;
  
 11
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2
  
  
 O4 : My_Class'
 Class
  := O1; 
  
 begin 
  
  
 O1.Foo;
  
 --
  
 Non dispatching: Calls My_Class.Foo
  
 O2.Foo;
  
 --
  
 Non dispatching: Calls Derived.Foo
  
 O3.Foo;
  
 --
  
 Dispatching: Calls Derived.Foo
  
 O4.Foo;
  
 --
  
 Dispatching: Calls My_Class.Foo
  
 end
  Main
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Object_Oriented_Programming.Tagged_Types
  
  
 MD5: 9c6ebdfec9ceeb986d92eb90ec9ff59b
  
 Runtime output
  
 In My_Class.Foo 
  
 In Derived.Foo, A = In 
 Derived.Foo, A =
  
 12 
  
 12
  
  
 In My_Class.Foo
  
 If the dispatching parameter of a primitive is the first parameter, which is the case in our 
 examples, you can call the primitive using the dot notation. Any remaining parameter 
 are passed normally:
  
 Listing 10: main.adb
  
 1
  
 with
  P;
  use
  P;
  
 2
  
 3
  
  
 4
  
  
 5
  
 procedure
  Main
  is 
  
  
 package
  Extend
  is 
  
  
  
 type
  D2
  is new
  Derived
  with null record
 ;
  
 6
  
 7
  
  
 8
  
  
 9
  
 procedure
  Bar
  (
 Self
  :
  in out D2
 ;
  
 Val
  
 :
  
 Integer
 );
  
 end
  Extend
 ;
  
 10
  
 11 
  
 12
  
 package body
  Extend
  is 
  
  
 procedure
  Bar
  (
 Self
  :
  in out D2
 ;
  
 (continues on next page)
  
 192
  
 Chapter 18.
  
 Object-oriented 
 programming",NA
18.6 Private & Limited,"We've seen previously (in the
  Privacy
  (page 109) chapter) that types can be declared 
 limited or private. These encapsulation techniques can also be applied to tagged types, 
 as we'll see in this section.
  
 This is an example of a tagged private type:
  
 Listing 11: p.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 package
  P
  is
  
  
 type
  T
  is tagged private
 ;
  
  
 private
  
  
 type
  T
  is tagged record
  
  
 E :
  Integer
 ;
  
  
 end record
 ;
  
  
        
 end
  P
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Object_Oriented_Programming.Tagged_Private_Types
  
  
 MD5: 4cd4bcd1a54d5f6407a500558b5da417
  
 This is an example of a tagged limited type:
  
 Listing 12: p.ads
  
 1
  
  
 2
  
  
 3
  
  
 4
  
  
 5
  
 package
  P
  is
  
  
 type
  T
  is tagged limited record
  
  
 E :
  Integer
 ;
  
  
 end record
 ;
  
  
 end
  P
 ;
  
      
 Code block metadata
  
 18.6.
  
 Private & Limited
  
 193",NA
18.7 Classwide access types,"In this section, we'll discuss an useful pattern for object-oriented programming in Ada: 
 class-wide access type. Let's start with an example where we declare a tagged type T 
 and a derived type T_New:
  
 Listing 16: p.ads
  
 1 
  
 2
  
 package
  P
  is 
  
  
 type
  T
  is tagged null record
 ;
  
 3
  
 4
  
 procedure
  Show
  (
 Dummy
  :
  T
 );
  
 5
  
 6
  
 type
  T_New
  is new
  T
  with null record
 ;
  
 7
  
 8 
  
 9
  
  
 procedure
  Show
  (
 Dummy
  :
  T_New
 ); 
  
 end
  P
 ;
  
 Listing 17: p.adb
  
 1 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3 
  
 package body
  P
  is
  
 4
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 procedure
  Show
  (
 Dummy
  :
  T
 )
  is 
  
 begin 
  
  
 Put_Line (
 ""Using type "" 
  
  
  
 &
  T'
 External_Tag
 ); 
  
 end
  Show
 ;
  
 10
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5
  
 procedure
  Show
  (
 Dummy
  :
  T_New
 )
  is 
  
 begin 
  
  
 Put_Line (
 ""Using type "" 
  
  
  
 &
  T_New'
 External_Tag
 ); 
  
 end
  Show
 ;
  
 16
  
 17 
 end
  P
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Object_Oriented_Programming.Classwide_Error
  
  
 MD5: fd5cb99925d3c88536546aa0be8104b7
  
 Note that we're using null records for both types T and T_New. Although these types 
 don't actually have any component, we can still use them to demonstrate dispatching. 
 Also note that the example above makes use of the '
 External_Tag
  attribute in the 
 implementation of the Show procedure to get a string for the corresponding tagged type.
  
 As we've seen before, we must use a classwide type to create objects that can make dis-
 patching calls. In other words, objects of type T'
 Class
  will dispatch. For example:
  
 Listing 18: dispatching_example.adb
  
 1
  
 with
  P;
  use
  P;
  
 2
  
 3
  
 procedure
  Dispatching_Example
  is
  
 (continues on next page)
  
 18.7.
  
 Classwide access types
  
 195",NA
NINETEEN,NA,NA
STANDARD LIBRARY: CONTAINERS,"In previous chapters, we've used arrays as the standard way to group multiple objects of 
 a specific data type. In many cases, arrays are good enough for manipulating those 
 objects. However, there are situations that require more flexibility and more advanced 
 operations. For those cases, Ada provides support for containers — such as vectors and 
 sets — in its standard library.
  
 We present an introduction to containers here. For a list of all containers available in Ada, 
 see
  Appendix B
  (page 267).",NA
19.1 Vectors,"In the following sections, we present a general overview of vectors, including 
 instantiation, initialization, and operations on vector elements and vectors.
  
 19.1.1 Instantiation
  
 Here's an example showing the instantiation and declaration of a vector V:
  
 Listing 1: show_vector_inst.adb
  
 1
  
 with
  Ada.Containers.Vectors;
  
 2
  
 3
  
 procedure
  Show_Vector_Inst
  is
  
 4
  
 5
  
  
 6
  
  
 7
  
  
 8
  
 package
  Integer_Vectors
  is new 
  
 Ada.Containers.Vectors
  
 (
 Index_Type
  
 => Natural,
  
 Element_Type
  => Integer);
  
 9
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3
  
  
 V : Integer_Vectors.Vector; 
  
 begin 
  
  
 null
 ; 
  
 end
  Show_Vector_Inst
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Show_Vector_Inst
  
  
 MD5: 8b737842d2784f25502990f21e1cf6de
  
 Containers are based on generic packages, so we can't simply declare a vector as we 
 would declare an array of a specific type:
  
 A :
  array
  (
 1
  ..
  10
 )
  of
  Integer
 ;
  
 199",NA
19.2 Sets,"Sets are another class of containers. While vectors allow duplicated elements to be in-
 serted, sets ensure that no duplicated elements exist.
  
 In the following sections, we'll see operations you can perform on sets. However, since 
 many of the operations on vectors are similar to the ones used for sets, we'll cover them 
 more quickly here. Please refer back to the section on vectors for a more detailed discus-
 sion.
  
 19.2.1 Initialization and iteration
  
 To initialize a set, you can call the Insert procedure. However, if you do, you need to 
 ensure no duplicate elements are being inserted: if you try to insert a duplicate, you'll 
 get an exception. If you have less control over the elements to be inserted so that there 
 may be duplicates, you can use another option instead:
  
 • a version of Insert that returns a Boolean value indicating whether the insertion was 
  
 successful;
  
 • the Include procedure, which silently ignores any attempt to insert a duplicated ele-
  
 ment.
  
 To iterate over a set, you can use a
  for
  E
  of
  S loop, as you saw for vectors. This gives 
 you a reference to each element in the set.
  
 Let's see an example:
  
 Listing 15: show_set_init.adb
  
 1 
  
 2
  
 with
  Ada.Containers;
  use
  Ada.Containers; 
  
 with
  Ada.Containers.Ordered_Sets;
  
 3
  
 4 
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 5
  
 6 
  
 procedure
  Show_Set_Init
  is
  
 7
  
 8 
  
 9 
  
 10
  
 package
  Integer_Sets
  is new 
  
 Ada.Containers.Ordered_Sets 
  
  
 (
 Element_Type
  => Integer);
  
 11
  
 12 
  
 use
  Integer_Sets;
  
 13
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0
  
 S : Set;
  
 --
  
 Same as:
  
 S : Integer_Sets.Set;
  
  
 C :
  Cursor
 ; 
  
  
 Ins :
  Boolean
 ; 
  
 begin 
  
  
 S.Insert (
 20
 ); 
  
  
 S.Insert (
 10
 );
  
 (continues on next page)
  
 216
  
 Chapter 19.
  
 Standard library: Containers",NA
19.3 Indefinite maps,"The previous sections presented containers for elements of definite types. Although most 
 examples in those sections presented
  Integer
  types as element type of the containers, 
 containers can also be used with indefinite types, an example of which is the
  String
  
 type. However, indefinite types require a different kind of containers designed specially 
 for them.
  
 We'll also be exploring a different class of containers: maps. They associate a key with a 
 specific value. An example of a map is the one-to-one association between a person and 
 their age. If we consider a person's name to be the key, the value is the person's age.
  
 19.3.1 Hashed maps
  
 Hashed maps are maps that make use of a hash as a key. The hash itself is calculated by 
 a function you provide.
  
 In other languages
  
 Hashed maps are similar to dictionaries in Python and hashes in Perl. One of the main 
 differences is that these scripting languages allow using different types for the values 
 con-tained in a single map, while in Ada, both the type of key and value are specified in 
 the package instantiation and remains constant for that specific map. You can't have a 
 map where two elements are of different types or two keys are of different types. If you 
 want to use multiple types, you must create a different map for each and use only one 
 type in each map.
  
 When instantiating a hashed map from Ada.Containers.Indefinite_Hashed_Maps, we 
 specify following elements:
  
 • Key_Type: type of the key
  
 • Element_Type: type of the element
  
 • Hash: hash function for the Key_Type
  
 • Equivalent_Keys: an equality operator (e.g.
  =
 ) that indicates whether two keys are 
  
 to be considered equal.
  
 –
  If the type specified in Key_Type has a standard operator, you can use it, which 
 you do by specifying that operator as the value of Equivalent_Keys.
  
 In the next example, we'll use a string as a key type. We'll use the Hash function 
 provided by the standard library for strings (in the Ada.Strings package) and the 
 standard equality operator.
  
 You add elements to a hashed map by calling Insert. If an element is already contained 
 in a map M, you can access it directly by using its key. For example, you can change the 
 value of an element by calling M (
 ""My_Key""
 ) :=
  10
 . If the key is not found, an exception",NA
TWENTY,NA,NA
STANDARD LIBRARY: DATES & TIMES,"The standard library supports processing of dates and times using two approaches:
  
 •
  Calendar
  approach, which is suitable for handling dates and times in general;
  
 •
  Real-time
  approach, which is better suited for real-time applications that require en-
 hanced precision — for example, by having access to an absolute clock and 
 handling time spans. Note that this approach only supports times, not dates.
  
 The following sections present these two approaches.",NA
20.1 Date and time handling,"The Ada.Calendar package supports handling of dates and times. Let's look at a simple 
 example:
  
 Listing 1: display_current_time.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Calendar;
  use
  Ada.Calendar;
  
 3
  
 4 
  
 5
  
 with
  Ada.Calendar.Formatting;
  
 use
  
 Ada.Calendar.Formatting;
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11
  
 procedure
  Display_Current_Time
  is 
  
  
 Now : Time := Clock; 
  
 begin 
  
  
 Put_Line (
 ""Current time: ""
  &
  Image (Now)); 
 end
  
 Display_Current_Time
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Display_Current_Time
  
  
 MD5: 4a88069b33ecf80314b0164a472ff606
  
 Runtime output
  
 Current time: 2024-01-31 21:10:40
  
  
 This example displays the current date and time, which is retrieved by a call to the Clock 
 function. We call the function Image from the Ada.Calendar.Formatting package to get a
  
 String
  for the current date and time. We could instead retrieve each component using 
 the Split function. For example:
  
 227",NA
20.2 Real-time,"In addition to Ada.Calendar, the standard library also supports time operations for real-
 time applications. These are included in the Ada.Real_Time package. This package also 
 include a Time type. However, in the Ada.Real_Time package, the Time type is used to 
 represent an absolute clock and handle a time span. This contrasts with the 
 Ada.Calendar, which uses the Time type to represent dates and times.
  
 In the previous section, we used the Time type from the Ada.Calendar and the
  delay 
 until 
 statement to delay an application by 5 seconds. We could have used the 
 Ada.Real_Time package instead. Let's modify that example:
  
 Listing 6: display_delay_next_real_time.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Real_Time;
  use
  Ada.Real_Time;
  
 3
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 procedure
  Display_Delay_Next_Real_Time
  is
  
 D
  
 : Time_Span := Seconds (
 5
 );
  
 Next
  
 : Time
  
 := Clock
  +
  D;
  
 begin 
  
  
 Put_Line (
 ""Let's wait "" 
  
  
 &
  Duration
 '
 Image
  (To_Duration (D)) 
  
 &
  "" 
 seconds...""
 ); 
  
  
 delay until
  Next; 
  
  
 Put_Line (
 ""Enough waiting!""
 ); 
  
 end
  Display_Delay_Next_Real_Time
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Display_Delay_Next_Real_Time
  
  
 MD5: a80e96c4ac7bd3ba7813f983b10cb038
  
 Runtime output
  
 Let's wait
  
 5.000000000 seconds...
  
  
 Enough waiting!
  
 The main difference is that D is now a variable of type Time_Span, defined in the Ada. 
 Real_Time package. We call the function Seconds to initialize D, but could have gotten a 
 finer granularity by calling Nanoseconds instead. Also, we need to first convert D to the 
 Duration
  type using To_Duration before we can display it.
  
 20.2.
  
 Real-time
  
 231",NA
TWENTYONE,NA,NA
STANDARD LIBRARY: STRINGS,"In previous chapters, we've seen source-code examples using the
  String
  type, which is 
 a fixed-length string type — essentialy, it's an array of characters. In many cases, this 
 data type is good enough to deal with textual information. However, there are situations 
 that require more advanced text processing. Ada offers alternative approaches for these 
 cases:
  
 •
  Bounded strings
 : similar to fixed-length strings, bounded strings have a maximum 
 length, which is set at its instantiation. However, bounded strings are not arrays of 
 characters. At any time, they can contain a string of varied length — provided this 
 length is below or equal to the maximum length.
  
 •
  Unbounded strings
 : similar to bounded strings, unbounded strings can contain 
 strings of varied length. However, in addition to that, they don't have a maximum 
 length. In this sense, they are very flexible.
  
 The following sections present an overview of the different string types and common 
 oper-ations for string types.",NA
21.1 String operations,"Operations on standard (fixed-length) strings are available in the Ada.Strings.Fixed 
 pack-age. As mentioned previously, standard strings are arrays of elements of
  
 Character
  type with
  a fixed-length
 . That's why this child package is called Fixed.
  
 One of the simplest operations provided is counting the number of substrings available in 
 a string (
 Count
 ) and finding their corresponding indices (Index). Let's look at an 
 example:
  
 Listing 1: show_find_substring.adb
  
 1 
  
 2
  
 with
  Ada.Strings.Fixed;
  use
  Ada.Strings.Fixed;
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 3
  
 4 
  
 procedure
  Show_Find_Substring
  is
  
 5
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 S
  
 :
  String
  :=
  ""Hello""
  &
  3
  *
  "" World""
 ;
  
 P
  
 :
  constant
  String
  :=
  ""World""
 ;
  
  
 Idx :
  Natural
 ; 
  
  
 Cnt :
  Natural
 ; 
  
 begin 
  
  
 Cnt := Ada.Strings.Fixed.
 Count
  
 (Source
  
 => S,
  
 Pattern => P);
  
 14
  
 1
 5 
  
 1
 6 
  
 1
 7
  
 Put_Line (
 ""String: ""
  &
  S); 
  
 Put_Line (
 ""Count for '""
  &
  P
  &
  ""': "" 
  
 &
  Natural
 '
 Image
  (Cnt));
  
 18
  
 (continues on next page)",NA
21.2 Limitation of fixed-length strings,"Using fixed-length strings is usually good enough for strings that are initialized when 
 they are declared. However, as seen in the previous section, procedural operations on 
 strings cause difficulties when done on fixed-length strings because fixed-length strings 
 are arrays of characters. The following example shows how cumbersome the initialization 
 of fixed-length strings can be when it's not performed in the declaration:
  
 Listing 4: show_char_array.adb
  
 1
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 procedure
  Show_Char_Array
  is 
  
  
 S :
  String
  (
 1
  ..
  15
 );
  
 --
  
 Strings are arrays of Character
  
 begin
  
 S :=
  ""Hello
  
 ""
 ;
  
 (continues on next page)
  
 21.2.
  
 Limitation of fixed-length strings
  
 239",NA
21.3 Bounded strings,"Bounded strings are defined in the Ada.Strings.Bounded.
 Generic
 _
 Bounded_Length 
 pack-age. Because this is a generic package, you need to instantiate it and set the 
 maximum length of the bounded string. You can then declare bounded strings of the 
 Bounded_String type.
  
 Both bounded and fixed-length strings have a maximum length that they can hold. How-
 ever, bounded strings are not arrays, so initializing them at run-time is much easier. For 
 example:
  
 Listing 5: show_bounded_string.adb
  
 1
  
 with
  Ada.Strings;
  
 use
  Ada.Strings;
  
 2
  
 with
  Ada.Strings.Bounded;
  
 use
  Ada.Text_IO;
  
 3
  
 with
  Ada.Text_IO;
  
 4
  
 5
  
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 procedure
  Show_Bounded_String
  is 
  
  
 package
  B_Str
  is new 
  
  
  
 Ada.Strings.Bounded.Generic_Bounded_Length 
  
   
 (
 Max
  => 15); 
  
  
 use
  B_Str;
  
 10
  
 (continues on next page)
  
 240
  
 Chapter 21.
  
 Standard library: Strings",NA
21.4 Unbounded strings,"Unbounded strings are defined in the Ada.Strings.Unbounded package. 
  
 This is
  not
  a 
 generic package, so we don't need to instantiate it before using the Unbounded_String 
 type. 
  
 As you may recall from the previous section, bounded strings require a package 
 instantiation.
  
 Unbounded strings are similar to bounded strings. The main difference is that they can 
 hold strings of any size and adjust according to the input string: if we assign, e.g., a 10-
 character string to an unbounded string and later assign a 50-character string, internal 
 operations in the container ensure that memory is allocated to store the new string. In 
 most cases, developers don't need to worry about these operations. Also, no truncation 
 is necessary.
  
 242
  
 Chapter 21.
  
 Standard library: Strings",NA
TWENTYTWO,NA,NA
STANDARD LIBRARY: FILES AND STREAMS,"Ada provides different approaches for file input/output (I/O):
  
 •
  Text I/O
 , which supports file I/O in text format, including the display of information 
 on 
  
 the console.
  
 •
  Sequential I/O
 , which supports file I/O in binary format written in a sequential 
 fashion 
  
 for a specific data type.
  
 •
  Direct I/O
 , which supports file I/O in binary format for a specific data type, but also 
  
 supporting access to any position of a file.
  
 •
  Stream I/O
 , which supports I/O of information for multiple data types, including 
 objects 
  
 of unbounded types, using files in binary format.
  
 This table presents a summary of the features we've just seen:
  
 File I/O option
  
 Format
  
 Random access
  
 Data types
  
 In the following sections, we discuss details about these I/O approaches. 
  
 Direct I/O 
  
 Stream I/O 
  
  
 binary 
  
  
 binary
  
 ✓✓
  
  
  
  
 single type 
  
  
  
  
 multiple 
 types 
  
 Text I/O 
  
 text 
  
  
 string type 
  
 Sequential I/O 
  
 binary 
  
  
 single type",NA
22.1 Text I/O,"In most parts of this course, we used the Put_Line procedure to display information on 
 the console. However, this procedure also accepts a
  File_Type
  parameter. For example, 
 you can select between standard output and standard error by setting this parameter 
 explicitly:
  
 Listing 1: show_std_text_out.adb
  
 1
  
 with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  
 3
  
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  Show_Std_Text_Out
  is 
  
 begin 
  
  
 Put_Line (Standard_Output,
  ""Hello World #1""
 );
  
 Put_Line (Standard_Error,
  
 ""Hello World #2""
 );
  
 end
  Show_Std_Text_Out
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Show_Std_Text_Out
  
  
 MD5: 4d75bd2906226897244e3d2a611c9725
  
 245",NA
22.2 Sequential I/O,"The previous section presented details about text file I/O. Here, we discuss doing file I/O 
 in binary format. The first package we'll explore is the Ada.Sequential_IO package. 
 Because this package is a generic package, you need to instantiate it for the data type 
 you want to use for file I/O. Once you've done that, you can use the same procedures 
 we've seen in the previous section: Create, Open, Close, Reset and Delete. However, 
 instead of calling the Get_Line and Put_Line procedures, you'd call the Read and Write 
 procedures.
  
 In the following example, we instantiate the Ada.Sequential_IO package for floating-point 
 types:
  
 Listing 5: show_seq_float_io.adb
  
 1 
  
 with
  Ada.Text_IO;
  
 2 
  
 with
  Ada.Sequential_IO;
  
 3
  
 4
  
  
 5
  
  
 6
  
  
 7
  
 procedure
  Show_Seq_Float_IO
  is 
  
  
 package
  Float_IO
  is 
  
  
  
 new
  Ada.Sequential_IO
  (Float); 
  
  
 use
  Float_IO;
  
 8
  
 9
  
  
 1
 0 
  
 1
 1 
  
 1
 2 
  
 1
 3 
  
 1
 4 
  
 1
 5 
  
 1
 6 
  
 1
 7
  
 F
  
 : Float_IO.
 File_Type
 ;
  
  
 File_Name
  :
  constant
  String
  := 
  
  
  
 ""float_file.bin""
 ; 
  
 begin 
  
  
 Create (F, Out_File, File_Name);
  
 Write (F,
  
 1.5
 );
  
 Write (F,
  
 2.4
 );
  
 Write (F,
  
 6.7
 );
  
 Close (F);
  
 18
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5 
  
 2
 6 
  
 2
 7 
  
 2
 8 
  
 2
 9 
  
 3
 0
  
  
 declare 
  
  
  
 Value :
  Float
 ; 
  
  
 begin 
  
  
  
 Open (F, In_File, File_Name); 
  
  
  
 while not
  End_Of_File (F)
  loop 
  
  
  
 Read (F, Value); 
  
  
  
 Ada.Text_IO.Put_Line 
  
  
  
  
  
 (
 Float
 '
 Image
  (Value)); 
  
  
  
 end loop
 ; 
  
  
  
 Close (F); 
  
  
 end
 ; 
  
 end
  Show_Seq_Float_IO
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Show_Seq_Float_IO
  
  
 MD5: 27aa5daf92cba5df23fdc55c3578aa34
  
 Runtime output",NA
22.3 Direct I/O,"Direct I/O is available in the Ada.Direct_IO package. This mechanism is similar to the 
 sequential I/O approach just presented, but allows us to access any position in the file. 
 The package instantiation and most operations are very similar to sequential I/O. To 
 rewrite the Show_Seq_Float_IO application presented in the previous section to use the 
 Ada. Direct_IO package, we just need to replace the instances of the Ada.Sequential_IO 
 pack-age by the Ada.Direct_IO package. This is the new source code:
  
 Listing 7: show_dir_float_io.adb
  
 1 
  
 with
  Ada.Text_IO;
  
 2 
  
 with
  Ada.Direct_IO;
  
 3
  
 4
  
  
 5
  
  
 6
  
 procedure
  Show_Dir_Float_IO
  is 
  
 package
  Float_IO
  is new
  Ada.Direct_IO
  (Float); 
 use
  Float_IO;
  
 7
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14 
  
 15 
  
 16
  
 F
  
 : Float_IO.
 File_Type
 ;
  
  
 File_Name
  :
  constant
  String
  := 
  
  
  
 ""float_file.bin""
 ; 
  
 begin 
  
  
 Create (F, Out_File, File_Name);
  
 Write (F,
  
 1.5
 );
  
 Write (F,
  
 2.4
 );
  
 Write (F,
  
 6.7
 );
  
 Close (F);
  
 17
  
 1
 8 
  
 1
 9 
  
 2
 0 
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5 
  
 2
 6 
  
 2
 7 
  
 2
 8 
  
 2
 9
  
  
 declare 
  
  
  
 Value :
  Float
 ; 
  
  
 begin 
  
  
  
 Open (F, In_File, File_Name); 
  
  
  
 while not
  End_Of_File (F)
  loop 
  
  
  
 Read (F, Value); 
  
  
  
 Ada.Text_IO.Put_Line 
  
  
  
  
  
 (
 Float
 '
 Image
  (Value)); 
  
  
  
 end loop
 ; 
  
  
  
 Close (F); 
  
  
 end
 ; 
  
 end
  Show_Dir_Float_IO
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Show_Dir_Float_IO
  
  
 MD5: e4e5855976de44f53a821eb90dcbb206
  
 Runtime output
  
 1.50000E+00
  
  
 2.40000E+00
  
  
 6.70000E+00
  
  
  
 250
  
 Chapter 22.
  
 Standard library: Files and streams",NA
22.4 Stream I/O,"All the previous approaches for file I/O in binary format (sequential and direct I/O) are 
 spe-cific for a single data type (the one we instantiate them with). You can use these 
 approaches to write objects of a single data type that may be an array or record 
 (potentially with many fields), but if you need to create and process files that include 
 different data types, or any objects of an unbounded type, these approaches are not 
 sufficient. Instead, you should use stream I/O.
  
 Stream I/O shares some similarities with the previous approaches. We still use the 
 Create, Open and Close procedures. However, instead of accessing the file directly via a
  
 File_Type 
 element, you use a Stream_Access element. To read and write information, 
 you use the '
 Read
  or '
 Write
  attributes of the data types you're reading or writing.
  
 Let's look at a version of the Show_Dir_Float_IO procedure from the previous section that 
 makes use of stream I/O instead of direct I/O:
  
 Listing 9: show_float_stream.adb
  
 1 
  
 with
  Ada.Text_IO;
  
 2
  
 3 
  
 with
  Ada.Streams.Stream_IO;
  
 4 
  
 use 
  
 Ada.Streams.Stream_IO;
  
 5
  
 6 
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13
  
 procedure
  Show_Float_Stream
  is
  
 F
  
 :
  File_Type
 ;
  
 S
  
 : Stream_Access;
  
  
 File_Name
  :
  constant
  String
  := 
  
  
  
 ""float_file.bin""
 ; 
  
 begin 
  
  
 Create (F, Out_File, File_Name); 
  
  
 S := Stream (F);
  
 14
  
 1
 5 
  
 1
 6 
  
 1
 7
  
 Float
 '
 Write
  
 (S,
  
 1.5
 ); 
  
 Float
 '
 Write
  
 (S,
  
 2.4
 ); 
  
 Float
 '
 Write
  (S,
  6.7
 );
  
 18
  
 19 
  
 Close (F);
  
 20
  
 2
 1 
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5
  
 declare 
  
  
 Value :
  Float
 ; 
  
 begin 
  
  
 Open (F, In_File, File_Name); 
  
  
 S := Stream (F);
  
 26
  
 2
 7 
  
 2
 8 
  
 2
 9 
  
 3
 0 
  
 3
 1 
  
 3
 2 
  
 3
 3 
  
 3
 4
  
  
  
 while not
  End_Of_File (F)
  loop 
  
  
  
 Float
 '
 Read
  (S, Value); 
  
  
  
 Ada.Text_IO.Put_Line 
  
  
  
  
  
 (
 Float
 '
 Image
  (Value)); 
  
  
  
 end loop
 ; 
  
  
  
 Close (F); 
  
  
 end
 ; 
  
 end
  Show_Float_Stream
 ;
  
 Code block metadata
  
 Project: Courses.Intro_To_Ada.Standard_Library.Show_Float_Stream
  
  
 MD5: 34ccf04b0821074a332019ac0e38bb3e
  
  
 252
  
 Chapter 22.
  
 Standard library: Files and streams",NA
TWENTYTHREE,NA,NA
STANDARD LIBRARY: NUMERICS,"The standard library provides support for common numeric operations on floating-point
  
 types as well as on complex types and matrices. In the sections below, we present a brief
  
 introduction to these numeric operations.",NA
23.1 Elementary Functions,"The Ada.Numerics.Elementary_Functions package provides common operations for
  
 floating-point types, such as square root, logarithm, and the trigonometric functions 
 (e.g.,
  
 sin, cos). For example:
  
 Listing 1: show_elem_math.adb
  
 1 
  
 with
  Ada.Text_IO; 
 use
  Ada.Text_IO;
  
 2 
  
 with
  Ada.Numerics;
  use
  Ada.Numerics;
  
 3
  
 4 
  
 with
  Ada.Numerics.Elementary_Functions;
  
 5 
  
 use 
  
 Ada.Numerics.Elementary_Functions;
  
 6
  
 7 
  
 8 
  
 9 
  
 10 
  
 11 
  
 12 
  
 13 
  
 14
  
 procedure
  Show_Elem_Math
  is 
  
  
 X :
  Float
 ; 
  
 begin 
  
  
 X :=
  2.0
 ; 
  
  
 Put_Line (
 ""Square root of "" 
  
  
 &
  Float
 '
 Image
  (X) 
  
  
 &
  "" is "" 
  
  
 &
  Float
 '
 Image
  (Sqrt (X)));
  
 15
  
 1
 6 
  
 1
 7 
  
 1
 8 
  
 1
 9 
  
 2
 0
  
 X := e; 
  
 Put_Line (
 ""Natural log of "" 
  
 &
  Float
 '
 Image
  (X) 
  
 &
  "" is "" 
  
 &
  Float
 '
 Image
  (Log (X)));
  
 21
  
 2
 2 
  
 2
 3 
  
 2
 4 
  
 2
 5 
  
 2
 6
  
 X :=
  10.0
  **
  6.0
 ;
  
 Put_Line (
 ""Log_10
  
 of ""
  
 &
  Float
 '
 Image
  (X) 
  
 &
  "" is "" 
  
 &
  Float
 '
 Image
  (Log (X,
  10.0
 )));
  
 27
  
 2
 8 
  
 2
 9 
  
 3
 0 
  
 3
 1 
  
 3
 2
  
 X :=
  2.0
  **
  8.0
 ;
  
 Put_Line (
 ""Log_2
  
 of ""
  
 &
  Float
 '
 Image
  (X) 
  
 &
  "" is "" 
  
 &
  Float
 '
 Image
  (Log (X,
  2.0
 )));
  
 33
  
 (continues on next page)
  
 255",NA
23.2 Random Number Generation,"The Ada.Numerics.Float_Random package provides a simple random number generator
  
 for the range between 0.0 and 1.0. To use it, declare a generator G, which you pass to
  
 Random. For example:
  
 Listing 2: show_float_random_num.adb
  
 1
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 2
  
 3 
  
 4
  
 with
  Ada.Numerics.Float_Random;
  
 use
  
 Ada.Numerics.Float_Random;
  
 5
  
 6
  
  
 7
  
  
 8
  
  
 9
  
 procedure
  Show_Float_Random_Num
  
 is 
  
  
 G :
  Generator
 ; 
  
  
 X : Uniformly_Distributed; 
  
 begin
  
 (continues on next page)
  
 256
  
 Chapter 23.
  
 Standard library: Numerics",NA
23.3 Complex Types,"The
  
 Ada.Numerics.Complex_Types
  
 package
  
 provides
  
 support
  
 for
  
 complex
  
 number
  
 types and the Ada.Numerics.Complex_Elementary_Functions package provides sup-port 
 for common operations on complex number types, similar to the Ada.Numerics. 
 Elementary_Functions package. Finally, you can use the Ada.Text_IO.Complex_IO pack-
 age to perform I/O operations on complex numbers. In the following example, we 
 declare variables of the Complex type and initialize them using an aggregate:
  
 Listing 4: show_elem_math.adb
  
 1 
  
 2
  
 with
  Ada.Text_IO;
  
 use
  Ada.Text_IO;
  
 with
  Ada.Numerics;
  use
  Ada.Numerics;
  
 (continues on next page)",NA
23.4 Vector and Matrix Manipulation,"The Ada.Numerics.Real_Arrays package provides support for vectors and matrices. It
  
 includes common matrix operations such as inverse, determinant, eigenvalues in addition
  
 to simpler operators such as matrix addition and multiplication. You can declare vectors
  
 and matrices using the Real_Vector and Real_Matrix types, respectively.
  
 The following example uses some of the operations from the Ada.Numerics.Real_Arrays
  
 package:",NA
TWENTYFOUR,NA,NA
APPENDICES,NA,NA
24.1 Appendix A: Generic Formal Types,"The following tables contain examples of available formal types for generics:
  
 Formal type
  
 Actual type
  
 Incomplete type
  
 Any type
  
 Format
 :
  type
  T
 ;
  
 Discrete type
  
 Any integer, modular or enumeration type
  
  
 Format
 :
  type
  T
  is
  (<>);
  
  
 Range type
  
 Any signed integer type
  
  
 Format
 :
  type
  T
  is range
  <>;
  
  
 Modular type
  
 Any modular type
  
  
 Format
 :
  type
  T
  is mod
  <>;
  
  
 Floating-point type
  
 Any floating-point type
  
  
 Format
 :
  type
  T
  is digits
  <>;
  
  
 Binary fixed-point type
  
 Any binary fixed-point type
  
  
 Format
 :
  type
  T
  is delta
  <>;
  
  
 Decimal fixed-point type
  
 Any decimal fixed-point type
  
  
 Format
 :
  type
  T
  is delta
  <>
  digits
  <>;
   
 Definite nonlimited private type
  
 Any nonlimited, definite type
  
  
 Format
 :
  type
  T
  is private
 ;
  
  
 Nonlimited Private type with discriminant
  
 Any nonlimited type with discriminant
  
  
 Format
 :
  type
  T
  (
 D
  :
  DT
 )
  is private
 ;
  
  
 Access type
  
 Any access type for type T
  
  
 Format
 :
  type
  A
  is access
  T;
  
  
 Definite derived type 
  
 Format
 :
  type
  T
  is new
  B;
  
 Any concrete type derived from base type 
 B
  
 Limited private type
  
 Any definite type, limited or not
  
  
 Format
 :
  type
  T
  is limited private
 ;
  
  
 Incomplete tagged type
  
 Any concrete, definite, tagged type
  
  
 Format
 :
  type
  T
  is tagged
 ;
  
  
 Definite tagged private type
  
 Any concrete, definite, tagged type
  
  
 Format
 :
  type
  T
  is tagged private
 ;
  
  
 Definite tagged limited private type 
  
 Format
 :
  type
  T
  is tagged limited pri-
  
 Any concrete definite tagged type, limited 
 or not
  
  
 vate
 ;
  
  
 Definite abstract tagged private type
  
 Any nonlimited, definite tagged type, ab-
 stract or concrete
  
 Format
 :
  type
  
 T
  
 is
  
 abstract
  
 tagged
  
  
 private
 ;
  
 continues on next page
  
 265",NA
24.2 Appendix B: Containers,"The following table shows all containers available in Ada, including their versions 
 (standard, bounded, unbounded, indefinite):
  
 Cate-
  
 Container
  
 Std
  
 Bounded
  
 Un-
  
 Indefi-
  
 gory
  
 bounded
  
 nite
  
 Vector
  
 Vectors
  
 Y
  
 Y
  
  
 Y
  
 List
  
 Doubly Linked Lists
  
 Y
  
 Y
  
  
 Y
  
 Map
  
 Hashed Maps
  
 Y
  
 Y
  
  
 Y
  
 Map
  
 Ordered Maps
  
 Y
  
 Y
  
  
 Y
  
 Set
  
 Hashed Sets
  
 Y
  
 Y
  
  
 Y
  
 Set
  
 Ordered Sets
  
 Y
  
 Y
  
  
 Y
  
 Tree
  
 Multiway Trees
  
 Y
  
 Y
  
  
 Y
  
 Generic
  
 Holders
  
  
  
  
 Y
  
 Queue
  
 Synchronized Queue Interfaces
  
 Y",NA
