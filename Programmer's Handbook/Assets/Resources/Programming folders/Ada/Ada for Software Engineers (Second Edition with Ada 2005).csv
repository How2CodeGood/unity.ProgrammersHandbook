Larger Text,Smaller Text,Symbol
Ada for Software Engineers (Second Edition with Ada 2005),NA,NA
Mordechai Ben-Ari,NA,NA
Ada for Software Engineers,NA,NA
(Second Edition with Ada 2005),NA,NA
ABC,NA,NA
Preface,"Albert Einstein once said everything should be made as simple as possible, but not simpler. 
 Einstein could have been talking about programming languages, as the landscape is strewn with 
 “simple” languages that, several versions later, have 500-page reference manuals!
  
 The truth is that we expect a lot of our programming languages. We demand support for en-
 capsulation and abstraction, type checking and exception handling, polymorphism and more. 
 Ada, unlike other languages which grew by the gradual addition of features, was designed as a 
 coherent programming language for complex software systems.
  Ada for Software Engineers (ASE)
  
 is written to equip you with the knowledge necessary to use the Ada programming lan-guage to 
 develop software systems.
  
 Although Ada never achieved the popularity of Java and the C-something languages, it remains 
 the programming language of choice for reliable software. Every time you step on an airplane or 
 a fast train, you are quite literally trusting your life to software written in Ada. Given the low 
 level of reliability of much of the software we use daily, I can only regret that the use of Ada is not 
 more widespread, and I hope that this book will encourage more software engineers to give Ada 
 a chance.
  
 Intended audience
  
 The book is intended for software engineers making the transition to Ada, and for upper-level 
 undergraduate and graduate students, including those who have had the good fortune to study 
 Ada as their first programming language. No specific knowledge of Ada is assumed; the pre-
 requisites are a basic knowledge of computer science and computer systems, and at least two 
 years of programming experience. As the title implies, if you are a software engineer or training 
 to become one, this book is for you.
  
 v",NA
Contents,"Preface
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 v
  
 1
  
 The Language for a Complex World
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 2
  
 1.1
  
 Programming or software engineering? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 1.2
  
 Reliable software engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 1.3
  
 Programming languages for software engineering . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 2
  
 1.4
  
 Ada for software engineering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.5
  
 The development of Ada . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 3
  
 1.6
  
 The Ada Reference Manual . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.7
  
 Case studies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11
  
 First Steps in Ada
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 3
  
 2.1
  
 Case study: country of origin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 13
  
 2.2
  
 Library units and context clauses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 2.3
  
 Input–output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 2.4
  
 Attributes for string conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 15
  
 2.5
  
 Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.6
  
 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.7
  
 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 19
  
 2.8
  
 Objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 2.9
  
 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 23
  
 2.10
  
 Subtypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 25
  
 2.11
  
 Lexical elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 28
  
 Subprograms
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 31
  
 3.1
  
 Parameter modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 32
  
 3.2
  
 Overloading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 34
  
 3.3
  
 Parameter associations and default expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 36
  
 3.4
  
 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 37
  
 ix",NA
Chapter 1,NA,NA
The Language for a Complex World,"1.1 Programming or software engineering?
  
 Computer science students often extrapolate from their demonstrated ability to write small 
 programs and believe that the same methods and techniques will enable them to develop large 
 software systems. Only later, when they gain experience and mature into competent software 
 engineers, do they realize that the real world does not correspond to the ideal setting of a lab.
  
 Modern software systems are built by tens, even hundreds, of software engineers. Inevitably, 
 a large team will suffer from inconsistencies caused by growth and rapid turnover. Throw in 
 human personality traits such as ambition and envy, and it is a wonder that a large system can 
 even be built!
  
 The work of a software engineer is often the most complex in the entire project. The rea-son is 
 that the tasks that are implemented in software rather than hardware are precisely those that 
 concern the entire system. Other engineers typically work on individual components and 
 subsystems, which are then integrated into a software-controlled project. For example, a me-
 chanical engineer who designs the landing gear of an airplane is less involved in systems engi-
 neering than a software engineer who writes the control program of the aircraft and who must 
 understand the general principles of all the subsystems. Even in fields not traditionally consid-
 ered engineering, the same situation holds: the software engineer working on a stock exchange 
 must be familiar with the basic principles of the instruments being traded, together with the 
 communications system and the requirements of the traders using the system. Software engi-
 neering is significantly more complex than just programming, and it should not be surprising 
 that different tools are needed.
  
 1.2 Reliable software engineering
  
 The structure of the software market for personal computers has caused reliability to be con-
 sciously neglected. Software packages are compared by lists of features, performance, and
  
 1",NA
Chapter 2,NA,NA
First Steps in Ada,"This chapter presents the basic concepts of Ada starting with a simple program.
  
 2.1 Case study: country of origin
  
 The following program reads the name of a car manufacturer and prints the country of origin. In 
 this era of globalization, where cars are designed in one country and assembled in several others, 
 the program is admittedly artificial and incomplete, but it will serve its purpose of presenting the 
 basics of Ada.
  
  
 Ada uses the term
  subprogram
  to refer to either a procedure or a function. The main subpro-
 gram §10.2(7), here
  Country1
 , is a subprogram that is not nested within any other unit:
  
 country1
  
 1
  with
  Ada.Text_IO;
  use
  Ada.Text_IO;
  
 2
  procedure
  Country1
  is
  
 The first line of the program is a
  context clause
 , which is used to obtain access to the input–output 
 library
  Ada.Text_IO
 .
  
 A subprogram consists of a subprogram_specification, followed by a declarative_part and a 
 handled_sequence_of_statements §6.3(2). The declarative part begins with declarations of the 
 types
  Cars
  and
  Countries
 , followed by a declaration of the variable
  Car
 :
  
 3 
  
 4 
  
 5 
  
 6 
  
 7 
  
 8 
  
 9 
  
 10
  
 type
  Cars
  is 
  
 (Ford, Chevrolet, Pontiac, Chrysler, Dodge, 
  
 Rover, 
 Rolls_Royce, 
  
  
 Peugeot, Renault, Citroen, 
  
  
 BMW, Volkswagen, Opel, 
  
  
 Honda, Mitsubishi, Toyota, 
  
  
 Daewoo, Hyundai 
  
 );
  
 13",NA
Chapter 3,NA,NA
Subprograms,"The concept of encapsulating local data and a sequence of statements in a subprogram is ubiq-
  
 uitous in all programming languages; nevertheless, there are differences between languages—
  
 especially in the area of parameter passing—that must be carefully studied. There is no separate
  
 case study for this chapter because subprograms appear in all programs in this book.
  
 §6
  
 1
  A subprogram is a program unit or intrinsic operation whose execution is invoked by a 
 subprogram call. There are two forms of subprogram: procedures and 
  
 functions. A procedure call is a statement; a function call is an expression and returns a 
 value. The definition of a subprogram can be given in two parts: a subprogram 
 declaration defining its interface, and a subprogram_body defining its execution. 
 Operators and enumeration literals are functions.
  
 The subprogram declaration and body are written separately when the declaration is part of
  
 the declaration of a package specification, while the body is encapsulated in the package body
  
 (Section 6). Another use for separate declarations is to define mutually recursive subprograms.
  
 In the absence of a separate declaration, the subprogram_body by itself can also serve as the
  
 declaration of the subprogram §6.3(4).
  
 The syntax of subprograms holds few surprises §6.1(2–16), §6.3(2). Here are several subpro-
  
 gram declarations from the input–output library:
  
 function 
  
 Is_Open(File: 
  
 in 
  
 File_Type)
  return
  Boolean;
  
 procedure
  Put(Item: 
  
 in 
  
 String);
  
 procedure
  Put_Line(Item:
  in 
  
 String);
  
 procedure
  Get(Item: 
  
 out
  String);
  
 function 
  
 Get_Line
  return
  String;
  
 procedure
  Get_Line(Item:
  out
  String; Last:
  out
  Natural);
  
 31",NA
Chapter 4,NA,NA
Arrays,"In this chapter and the next, we present the basic concepts of composite types (arrays and 
 records) and access types (pointers). A comprehensive explanation of all the constructs relating 
 to these types is deferred to Chapters 11 and 12, and numeric types are discussed in Chapter 13. 
 The intervening chapters present constructs for structuring large programs and for extending 
 types to support object-oriented programming. The chapter begins with a large case study, 
 followed by a detailed presentation of the language constructs related to arrays.
  
 4.1 Case study: fill and justify text
  
 The case study is to implement a core algorithm used in word-processors:
  
 Read a text file and write it with the text filled (as many words as possible on a line) and 
 justified (set flush with both margins). A word is a maximal sequence of non-space 
 characters.
  
 The following example shows four lines of input data, the two lines of text after filling, and the 
 text after justification:
  
 The
  
 quick
  
 brown
  
 fox
  
 jumped
  
 over
  
 the
  
 lazy dog
  
 The quick brown fox
  
 jumped over the lazy dog
  
 The
  
 quick
  
 brown
  
 fox
  
 jumped over the lazy
  
 dog
  
 41",NA
Chapter 5,NA,NA
Elementary Data Structures,"This chapter is an introduction to the construction of data structures in Ada using arrays, records 
 and access types. Here we discuss the language support for implementing data struc-tures; their 
 encapsulation into abstract data types will be presented in the next chapter.
  
 The case study is the implementation of a
  priority queue
 , first using arrays and then using 
 pointers. A priority queue is a data structure that stores items so that retrieval of the item of the 
 highest priority can be done efficiently, although insertion of new items may be less efficient. In 
 the case study, we assume that the items are simply integers and that higher-priority items have 
 lower values. This is a common situation: customers in a store take numbered tickets and the 
 lowest outstanding number is served first.
  
 5.1 Case study: array priority queue
  
 The elements of the priority queue are stored in an array whose lower bound is 0 (the lower 
 bound of the subtype
  Natural
 ) and whose upper bound is determined when the array is al-located. 
 The queue itself is a record with three fields: (a) an array field
  Data
 , (b)
  Size
 , which contains the 
 size of the array, and (c)
  Free
 , which holds an index to the first free position in the array:
  
  
 10
  
  
  
 5
  
  
  
 −
 6
  
 0
  
 5
  
 10
  
 25
  
 ?
  
 ?
  
 ?
  
 ?
  
 ?
  
 ?
  
  
 Size
  
 Free
  
 0
  
 1
  
 2
  
 3
  
 4
  
 5
  
 6
  
 7
  
 8
  
 9
  
 10
  
 The elements of the queue are stored in increasing order as shown in the diagram. The element 
 with the highest priority (the smallest value) is stored in the first position and can be retrieved in 
 constant time. Inserting a new element is necessarily less efficient, because a search must be 
 made for the correct place to insert the element and existing elements must be moved to free up 
 the space.
  
 59",NA
Chapter 6,NA,NA
Packages and Abstract Data Types,"6.1 Modularization
  
 Since a large software system must be decomposed into modules, the structures in a program-
 ming language for creating modules and for describing their interconnections determine the 
 language’s suitability for the development of complex systems. It is important to distinguish 
 among three uses of modules:
  
 • A module as a
  unit of design and management
 . Even before a single executable statement is 
 written, the software will be designed as a system of modules. The project manager will then 
 assign the responsibility for the development of each module to a software engineer or team 
 of engineers.
  
 • A module as a
  unit of abstraction
 . To abstract is to hide details of a resource so that it can be 
  
 used without knowledge of its internal structure.
  
 • A module as a
  physical unit of source code
 . Configuration management of a large software 
 system requires a system for storing source code modules and for building versions of the 
 software.
  
 In Ada, the
  package
  is the unit of design. A package is divided into a
  specification
  and a
  body
 , 
 which are separate physical units of source code. The specification and the body also serve to 
 encapsulate abstractions by separating the interface from the implementation. Abstract data 
 types in Ada are built by combining packages with
  private types
  that allow a client of an inter-
 face to use the type according to its public properties, while the details of its implementation 
 remain hidden.
  
 The development of very large programs is facilitated by
  child units
 , which provide a hi-
 erarchial structure for groups of related packages (Section 7.9).
  Subunits
  (Section 15.3) enable 
 portions of a package to exist as independent physical units, while retaining their semantic sta-
 tus as part of the package; they have little use since child packages were introduced in Ada 95.
  
 We will now develop a progression of six packages for priority queues that encapsulate the 
 array and tree implementations given in the previous chapter. Each version will motivate and 
 highlight a specific way of programming with packages.
  
 73",NA
Chapter 7,NA,NA
Type Extension and Inheritance,"Object-oriented programming (OOP)
  is a widely used approach for software development. In the 
 terminology of languages like Java and C
 ++
 , the unit of design in OOP is the
  class
 , which defines a 
 type consisting of data
  fields
  and operations called
  methods
 . A class is a template from which
  
 objects
  or
  instances
  can be created. Values can be assigned to the fields of an object and the 
 methods can be invoked on it. Classes can organized into a hierarchy by inheritance: one class is 
 derived from another
  parent
  class, inheriting the parent’s fields and methods, possibly adding 
 fields and methods, and possibly overriding the parent’s methods.
  
 The constructs we studied in the previous chapter—packages and private types—support 
 OOP, but without type deriviation and inheritance. This chapter and the next one describe the 
 Ada constructs that support these concepts. The chapter will introduce a case study for the 
 discrete event simulation
  of a rocket; this case study will be used extensively in the rest of the 
 book. While the details of the case study are artificial, its structure and the use of the language 
 constructs are realistic. The size of the case study will require quite a few forward references to 
 concepts discussed later in the chapter and in other chapters, but we prefer to show the 
 constructs in context, rather than discussing them one-by-one.
  
 Language Comparison
  
 If you are an experienced OOP programmer learning Ada, please note that al-
 though the concepts are the same, the constructs and the terminology are quite 
 different from those in Java or C
 ++
 . In particular, Ada does not have a
  class
  con-
 struct that both defines a type and serves as a module. Types in Ada are defined by 
 type declarations, while packages implement modules. OOP is a style of us-ing 
 these constructs, not something required (or even strongly encouraged) by the 
 language definition. Finally, the
  package
  construct in Java serves only to or-ganize 
 the namespace of the program, not to specify what resources are imported like the 
 Ada with_clause.
  
 99",NA
Chapter 8,NA,NA
Type Extension and Inheritance (Continued),"8.1 Designated receiver syntax
  
 In most languages that support object-oriented programming, the syntax for invoking meth-ods 
 (subprograms) is designed so that there is a
  designated receiver
 , that is, an
  object
  that is 
 the“receiver” of the method:
  
 event.simulate();
  
 Within the method, the designated receiver is an implicit parameter that is known by a special 
 name (usually,
  this
 ). Distinguished receiver syntax is also supported in Ada:
  
 rocketp
  
 1
  with
  Event_Queue;
  
 2
  procedure
  Rocket
  is
  
 3 
  
 Q: Event_Queue.Queue_Ptr :=
  new
  Event_Queue.Queue;
  
 4 
  
 procedure
  Create(Q:
  in
  Event_Queue.Queue_Ptr)
  is separate
 ;
  
 5
  begin
  
 6 
  
 Create(Q);
  
 7 
  
 while not
  Event_Queue.Empty(Q.
 all
 )
  loop
  
 8 
 Event_Queue.Get(Q).Simulate;
  
 9 
  
 end loop
 ;
  
 10
  end
  Rocket;
  
 Event_Queue.Get(Q).Simulate
  denotes a
  prefixed view
  §4.1.3(9.1–9.2). The prefix must be of a specific 
 or class-wide tagged type; in this case,
  Event_Queue.Get(Q)
  is of type
  Event’Class
 . The selector must 
 denote a primitive or class-wide operation for the tagged type whose
  first 
 parameter is of this 
 type; here,
  Simulate
  is a primitive operation of the tagged type
  Event 
 whose first parameter is of 
 this type. The value returned by the call to
  Event_Queue.Get(Q) 
 becomes the implicit first (and only) 
 parameter in the (dispatching) call to
  Simulate
  §6.4(10.1).
  
 125",NA
Chapter 9,NA,NA
Generics,"In Chapter 5 we developed a priority queue abstract data type and showed how to change the 
 implementation of the queue from an array to a tree without changing the client interface sup-
 plied by the package specification. However, that data structure was specialized for elements of 
 type
  Integer
 , so when a priority queue was needed in Chapter 7 for elements of type
  Event
 , a new 
 package was written.
  
 Generic units
  enable the parameterization of data structures and algorithms by parameteriz-
 ing packages and subprograms. A generic unit is a
  template
  from which
  instances
  can be created 
 at
  compile-time
  by supplying actual parameters, which can be types, subprograms or even other 
 generic units. The creation of an instance—called
  instantiation
 —is done at compile time. The 
 compiler enforces type checking on the generic unit, and verifies that the actual parameters used 
 in the instantiation match the formal parameters of the generic unit.
  
 Generics are an alternative to heterogenous types that were discussed in the previous chap-
 ter. There are two drawbacks to heterogenous types: (a) additional overhead is required be-
 cause indirect allocation must be used, and (b) a potentially dangerous type conversion must be 
 done on all elements retrieved from the data structure.
  
  
 This chapter presents generic units in Ada except for generic tagged and interface types, 
 which are discussed separately in Chapter 17 on multiple inheritance.
  
 Language Comparison
  
 C
 ++
 supports
  templates
 , which are similar to Ada generics, although explicit in-
 stantiation is not supported, so every occurrence of a type must be written in the 
 form
  Priority_Queue<Event>
 ; this makes it difficult to read the source code. There is 
 no contract model in C
 ++
 , so the entire instance must be checked for legality. In 
 Ada, most error messages will result from the actual parameters sup-plied in the 
 instantiation not matching the formal parameters. In C
 ++
 , error mes-sages will 
 refer the source code of the template, making it difficult to treat the template as an 
 abstraction.
  
 143",NA
Chapter 10,NA,NA
Exceptions and Run-Time Checks,"Type checking in Ada is designed to discover and prevent compile-time errors. However, there 
 are some errors that can occur only at run-time; for example, input that is not in the expected 
 format or that exceeds the range of an input variable. Run-time errors cause
  exceptions
  to be 
 raised
  during execution, and the exception occurrences can be
  handled
  in order to recover from 
 the error or to display information that will help diagnose the error.
  
 10.1 Declaring and raising exceptions
  
 Exceptions are declared with an object-like syntax:
  
 §11.1
  
 1
  An exception_declaration declares a name for an exception. 
 2
  
 exception_declaration ::= defining_identifier_list :
  exception
 ;
  
 In the priority queue case study in Section 5.1, two exceptions were declared:
  
 Overflow, Underflow:
  exception
 ;
  
 There are also predefined exceptions §11.1(4) (see Section 2.6) that are raised by the run-time 
 system. Exceptions that are not predefined must be explicitly raised using a raise_statement:
  
 §11.3
  
 1
  A raise_statement raises an exception.
  
 2
  raise_statement ::=
  raise
 ; 
  
  
 |
  raise
  exception_name [
 with
  string_expression];
  
 171",NA
Chapter 11,NA,NA
Composite Types,"11.1 Characters and strings
  
 The support for character and string handling in Ada is extensive. In this section we 
 discuss“ordinary” characters and strings, while in the next section we give an overview of 
 multibyte characters and their strings; these are used in programs that process text in non-
 European nat-ural languages and other notations. This is followed by a case study that 
 demonstrates string handling as well as the container library.
  
 Ada.Characters.Latin_1
  §A.3.3 supplies names for all the characters in the ISO 8859-1 set, except 
 for the digits
  ’0’
  through
  ’9’
  and the upper case letters
  ’A’
  through
  ’Z’
 , which are assumed to be 
 directly available on any keyboard.
  
 Ada.Characters.Handling
  §A.3.2 contains functions like
  Is_Upper
  and
  Is_Alphanumeric 
 for classifying 
 characters, as well as conversion functions such as
  To_Upper
 . Note that the cat-egory
  letters
  
 includes international characters such as the French letter ç (named
  LC_C_Cedilla 
 in
  
 Ada.Characters.Latin_1
 ); the predefined upper/lower case conversion functions take ac-count of 
 these characters.
  
 Ada.Strings
  §A.4.1 has child packages that provide operations for three string types:
  
 Fixed 
  
 This is the predefined type
  String
 ; the length of a string value is fixed when it is allocated, as for 
 all array types.
  
 H
  
 e
  
 l
  
 l
  
 o
  
  
 W
  
 o
  
 r
  
 l
  
 d
  
 Bounded 
  
 A bounded string object is declared with a
  maximum
  length; the
  current
  length is automati-
 cally maintained by the library subprograms. A bounded string object can vary in size dur-ing 
 its lifetime, up to the declared maximum.
  
  
 11
  
  
  
 H
  
 e
  
 l
  
 l
  
 o
  
  
 W
  
 o
  
 r
  
 l
  
 d
  
  
  
  
 189",NA
Chapter 12,NA,NA
Access Types,"12.1 General access types
  
 The access types we have been using are called
  pool-specific
  access types, because every access 
 value points to a designated object that is allocated in a
  storage pool
  on the heap.
  
 §3.10
  
 8
  Access-to-object types are further subdivided into
  pool-specific
  access types, whose 
 values can designate only the elements of their associated storage pool, and
  general 
 access types, whose values can designate the elements of any storage pool, as well as 
 aliased objects created by declarations rather than allocators, and aliased 
  
 subcomponents of other objects.
  
 General access types can be used just like pool-specific access types to hold pointers to allocated 
 objects:
  
 type
  Pointer
  is access all
  Integer;
  
 P1: 
  
 Pointer :=
  new
  Integer;
  
 The reserved word
  all
  indicates that
  Pointer
  is a general
  access-to-variable
  type §3.10(10). 
  
 In addition, they can be used to create pointers to declared objects:
  
 N: 
 aliased
  Integer;
  
 P2: Pointer := N’Access;
  
 P2
  contains a pointer to a declared object
  N
 ; it is created by applying the attribute
  
 Access
 §3.10.2(24) to the object. The attribute can only be used on objects that are
  aliased
  
 §3.10(9). This property is usually specified explicitly by including the reserved word
  aliased
  
 §3.3.1(2) in the declaration of an object. The explicit declaration is a warning to the programmer 
 reading the code that there might be more than one way of accessing the variable (the variable 
 name
  N
  and the dereference
  P2.
 all
 ). It is also an indication to the compiler that optimization 
 techniques such as storing the value of the variable in a register may not be appropriate.
  
 217",NA
Chapter 13,NA,NA
Numeric Types,"There are three approaches to defining the precision of numeric types:
  
 • In C, the precision is not part of the type; for example, the type
  int
  might be implemented with 
 16 bits on one computer and 64 bits on another. Programs in C are, therefore, not portable, 
 although clever use of macros can work around this problem.
  
 • Java specifies the precision of each type. Values of type
  int
  are required to be 32-bit signed 
 integers, so Java programs are portable. However, this may result in reduced performance, 
 because a choice of precision might not be optimal for a particular computer. For example, if 
 the values of a variable are bounded by 10, 000, type
  int
  will be optimal for a 32-bit machine, 
 while
  short
  will be optimal for a 16-bit controller. The program will be portable regardless of 
 which type you choose, but the performance on one machine can be suboptimal.
  
 • In Ada, you can declare the
  required precision
  of a numeric type. When the program is com-
 piled, the implementation will choose a representation that is appropriate for the machine.
  
 For example, a type declared as an integer type with a range of 1 to 100, 000 will be repre-
 sented as a double word on a 16-bit machine and as a single word on a 32-bit machine. To 
 port the program to another machine requires only recompilation.
  
 Ada supports the definition of both integer and real types with a specified precision. Both 
 floating point and fixed point real types are supported. Fixed point types are not found in most 
 programming languages, but they are useful in applications where absolute, rather than relative, 
 precision is required.
  
 13.1 Basic concepts
  
 13.1.1 Universal types
  
 The numeric types in Ada form derivation hierarchies, similar to classes of tagged types (Fig-ure 
 13.1). The classes are called
  universal types
  §3.4.1(6–7) and the specific types at the roots of
  
 245",NA
Chapter 14,NA,NA
Input–Output,"14.1 Libraries for input–output
  
 Sections §A.6–§A.14 of Annex §A describe the input–output facilities of Ada. We have used 
 Ada.Text_IO
  §A.10 extensively for input and output of characters and strings. There are pack-ages 
 of identical functionality for
  Wide_Character
 ,
  Wide_String
 ,
  Wide_Wide_Character
 , and 
 Wide_Wide_String
  in 
 §A.11:
  
 •
  Ada.Wide_Text_IO
  
 •
  Ada.Wide_Wide_Text_IO
  
 Subprograms for IO of characters and strings are declared directly within
  Ada.Text_IO
 ; for 
 bounded and unbounded strings, generic subpackages must be instantiated §A.10.11, §A.10.12:
  
 •
  Ada.Text_IO.Bounded_IO
  
 •
  Ada.Text_IO.Unbounded_IO
  
 The following generic subpackages of
  Ada.Text_IO
  can be instantiated for IO of scalar types:
  
 •
  Ada.Text_IO.Integer_IO
  
 •
  Ada.Text_IO.Modular_IO
  
 •
  Ada.Text_IO.Float_IO
  
 •
  Ada.Text_IO.Fixed_IO
  
 •
  Ada.Text_IO.Decimal_IO
  
 •
  Ada.Text_IO.Enumeration_IO
  
 If you are going to use these packages frequently in your system, it is more efficient at compile-
 time if you instantiate them once, for example, as library packages:
  
 package
  P
  is
  
 type
  Countries
  is
  (US, UK, France, Germany, Japan, Korea);
  
 end
  P;
  
 277",NA
Chapter 15 ,NA,NA
Program ,NA,NA
Structure,"15.1 Compilation and execution
  
 This section discusses topics from Section §10 Program Structure and Compilation Issues. The 
 basic definitions are given in §10.1.
  
 §10.1
  
 1
  A
  program unit
  is either a package, a task unit, a protected unit, a protected entry, a 
  
 generic unit, or an explicitly declared subprogram other than an enumeration literal.
  
 Certain kinds of program units can be separately compiled. Alternatively, they can 
 appear physically nested within other program units.
  
 2
  The text of a program can be submitted to the compiler in one or more compilations.
  
 Each compilation is a succession of compilation_units. A compilation_unit contains 
 either the declaration, the body, or a renaming of a program unit. The representation for 
 a compilation is implementation-defined.
  
 A context clause is associated with a single compilation_unit §10.1.1(3), §10.1.2, so if several 
 units that are semantically dependent the same package are contained in one compilation, each 
 unit must have a with_clause for the package.
  
 §10.1
  
 3
  A library unit is a separately compiled program unit, and is always a package, 
 subprogram, or generic unit. Library units may have other (logically nested) library 
 units as children, and may have other program units physically nested within them. A 
 root library unit, together with its children and grandchildren and so on, form a 
 subsystem
 .
  
 A task is not a library unit.
  
 287",NA
Chapter 16,NA,NA
Containers,"The Ada library contains packages for data structures called
  containers
  §A.18. The containers are 
 generic packages that can be instantiated for any nonlimited type. There are separate packages 
 for definite and indefinite types, because indefinite types must be implemented using pointers 
 and thus are less efficient. The container library also includes generic procedures for sorting 
 arrays §A.18.16 (see Section 9.4).
  
 The subprograms in the container packages are required to be
  reentrant
 , as are all subpro-
 grams in Annex A §A(3). The containers are not “thread-safe,” so subprograms that operate on a 
 single object should not be called from different tasks without additional synchronization.
  
 The description of the container library takes over 50 pages of the
  ARM
 . In this chapter, we 
 limit the presentation to the concepts that you need to know in order to use containers; a case 
 study using containers was given in Section 11.3.
  
 There are six containers. Two are encapsulations of physical data structures:
  Vector
  imple-
 ments extensible arrays, and
  Doubly_Linked_List
  implements what its name says it does. A 
 map
  is a 
 data structure that associates values with keys. The container
  Hashed_Maps
  uses a hashing 
 function on the keys to efficiently store and retrieve the values, while
  Ordered_Maps 
 maintains a 
 data structure that enables efficient sequential access. A
  set
  is a data structure that contains only 
 values with no duplication. Here, too, there are two containers:
  Hashed_Sets
  and 
 Ordered_Sets
 .
  
 Ada 95
  
 There are several open source container libraries for Ada 95:
  
 • Ada 95 Booch Components 
  
  
 http://sourceforge.net/projects/booch95
 ;
  
 • Ada Structured Library 
  
  
 http://sourceforge.net/projects/adasl
 ;
  
 • Charles Container Library 
  
  
 http://home.earthlink.net/~matthewjheaney/charles/index.html
 .
  
 307",NA
Chapter 17 ,NA,NA
Interfaces and Multiple Inheritance,"A derived type
  inherits
  the components and primitive subprograms defined in its ancestor types; 
 it can add new components and subprograms, as well as override the inherited sub-programs. 
 Dynamic dispatching within a derivation class can be efficiently implemented using dispatch 
 tables (Section 8.13).
  
 Suppose that we wish to derive a type from more than one parent type; for example:
  
 type
  Root_Event
  is tagged 
  
  
 record 
  
  
 Time: Simulation_Time; 
  
  
 end record
 ; 
  
 procedure
  Simulate(E: Root_Event);
  
 type
  Thermodynamic_Model
  is tagged 
  
  
 record 
  
  
 Temperatures: Temperature_Array; 
  
  
 end record
 ; 
  
 procedure
  Update(M:
  in out
  Thermodynamic_Model);
  
 type
  Engine_Event
  is new 
  
  
 Root_Event
  and
  Thermodynamic_Model
  with
  ...-- ???
  
 This is called
  multiple inheritance (MI)
  and is supported by languages like C
 ++
 and Eiffel. 
  
 It is 
 not easy to give a clear definition of the semantics of multiple inheritance. The problems arise 
 when the same component is inherited from more than one ancestor:
  
 type
  T1
  is tagged record
  A: Integer;
  end record
 ; 
 type
  T2
  is tagged 
 record
  A: Integer;
  end record
 ;
  
 type
  T3
  is new
  T1
  and
  T2
  with
  ...
  
 --- ???
  
 Which component
  A
  is inherited?
  
 323",NA
Chapter 18,NA,NA
Concurrency,"An Ada program contains one or more
  tasks
  that execute
  concurrently
 . (Tasks are called
  
 processes 
 or
  threads
  in other languages; the distinctions are not important in this context.) We 
 use the term concurrent in preference to “parallel” to emphasize that the parallelism is 
 conceptual, not necessarily physical. A correct
  multitasking
  Ada program will produce the same 
 result, whether it is run on a multiprocessor system or on a time-shared single processor, though 
 the multiprocessor system will (hopefully) be significantly faster.
  
 For convenience, the material on concurrency is divided into two chapters, with more ad-
 vanced material in Chapter 19. Multitasking programs are frequently written for embedded 
 computer systems where hardware interfaces and program performance are critical; the con-
 structs in Ada that support embedded systems are discussed in Chapters 20–21.
  
 Chapters 18–21 are not an introduction to concurrent programming, for which the reader is 
 referred to the author’s textbook [2]. The software archive accompanying that book contains 
 implementations in Ada of many concurrent and distributed algorithms. More advanced text-
 books are [4] on concurrent and real-time programming in Ada 2005, and [5] on algorithms for 
 building real-time systems.
  
 A task is like a subprogram because it has data declarations, a sequence of statements and ex-
 ception handlers; the difference is that a
  thread of control
  is associated with each task. The 
 thread is implemented using a data structure containing pointers to the task’s current 
 instruction and to local memory such as a stack segment. If each task is assigned a processor, the 
 processors will execute the instructions of the tasks simultaneously. If there are more tasks than 
 processors—at worst, if there is only one processor—a
  scheduler
  will assign processors to tasks 
 according to some scheduling algorithm.
  
 In Ada, there are three main constructs for writing concurrent programs:
  
 • Load and store of shared variables (Section 20.7); these are usually too low-level.• 
 Protected objects for asynchronous sharing of resources.
  
 • Rendezvous for direct task-to-task synchronous communication.
  
 (See Sections 21.11–21.12 for other, low-level, constructs defined in the Real-Time Annex.)
  
 345",NA
Chapter 19,NA,NA
Concurrency (Continued),"19.1 Activation and termination
  
 Tasks must be activated and terminated. It is important to specify what happens if an exception 
 is raised during activation and to define when a task can participate in a rendezvous. We have to 
 specify what happens if a task is terminated during the execution of a protected action or a 
 rendezvous. Finally, the termination of a task must take into account the tasks that it activated.
  
 §9
  
 10
  Over time, tasks proceed through various
  states
 . A task is initially
  inactive
 ; upon 
 activation, and prior to its
  termination
  it is either
  blocked
  (as part of some task 
 interaction) or
  ready
  to run. While ready, a task competes for the available
  execution 
 resources
  that it requires to run.
  
 19.1.1 Activation
  
 It is important to distinguish between the elaboration of a task and its activation. Elaboration is 
 performed as part of the elaboration of the enclosing package, subprogram or task. Elaboration 
 of the task declaration can set its priority §D.1 and the amount of storage allocated for the task 
 §13.3(61); elaboration of the task body essentially does nothing §9.1(13). Activation creates the 
 task and allows it to begin execution, or at least to compete for the available execution resources. 
 The rules for task activation §9.2 can be summarized as follows:
  
 • Task that are declared within a unit (such as the producer and consumer tasks) are activated 
 before the enclosing unit begins executing its statements §9.2(3). The task executing the en-
 closing unit waits at the
  begin
  until all its tasks have been activated §9.2(5).
  
 • Task created by allocators (such as the employee tasks in the CEO program) are activated as 
  
 part of the evaluation of the allocator §9.2(4).
  
 375",NA
Chapter 20,NA,NA
Systems Programming,"20.1 Implementation dependences
  
 Ada is rooted in the requirements of computer systems with their hardware and operating 
 systems, and in the requirements of projects for performance, reliability and reuse. The design of 
 a programming language for complex projects must cope with conflicting requirements:
  
 • If the language is small, implementation-specific extensions and third-party add-ons will be 
 needed, making the software non-portable. If the language is large, it may be too difficult to 
 implement fully for important target computers and operating systems.
  
 • If the language specification is too general, implementations will fill in the details as they see fit 
 and the software developer will not be able to rely on a portable behavior. If the language 
 specification is very detailed, there may be difficulty implementing the language as specified 
 on a target architecture.
  
 The Ada approach to implementation dependency can be summarized as follows: certain fea-
 tures in the language need not be implemented, but if you do implement them, it must be done as 
 described in the standard. Where the standard leaves a decision up to the implementation, the 
 decision must be documented. The standard specification of “optional” features means that 
 programming techniques and even existing source code can be easily adapted to a new imple-
 mentation. Furthermore, little retraining is necessary for software engineers moving from one 
 implementation to another, because the concepts, the terminology, and even the type and sub-
 program declarations will be almost identical across all implementations. There are two levels of 
 implementation dependency in Ada. First, there are six
  Specialized Needs Annexes
 :
  
 • Annex C Systems Programming
  
 • Annex D Real-Time Programming
  
 • Annex E Distributed Systems
  
 • Annex F Information Systems
  
 • Annex G Numerics
  
 • Annex H Safety and Security
  
 401",NA
Chapter 21,NA,NA
Real-Time Systems,"21.1 Annex D Real-Time Systems
  
 The essence of real-time systems is
  predictability
 . The software requirements of these systems 
 include reactive time constraints: when an input event occurs, the system must react within a 
 specified time by computing and sending the correct output. Real-time systems frequently need 
 to be very
  efficient
 —reacting to a large number of events within a very short time—but there is 
 no necessary relationship between the two concepts. Annex §D goes into great detail on two 
 main topics: task scheduling and time. The Annex includes documentation requirements and 
 metrics, which supply the systems engineer with information needed to design a real-time 
 program using a specific implementation.
  
  
 An implementation that implements Annex D is also required to implement Annex §C Sys-
 tems Programming.
  
 21.2 Scheduling and priorities
  
 Recall (Section 19.1) that a
  ready
  task competes for resources such as processors that it needs to 
 run. However, the core language does not specify how a ready task is chosen if there are more 
 ready tasks than resources. Similarly, the language does not specify how a task blocked on an 
 entry queue is chosen if there is more than one open protected entry §9.5.3(17) or selective 
 accept alternative §9.7.1(16), although paragraph §9.5.3(17) does specify that any particular 
 entry queue will be served in first-in, first-out (FIFO) order of the arrival of the calling tasks. 
 There could also be more than one expired delay §9.7.1(18) to choose from.
  
 §D.1 through §D.5 describe how priorities are used with scheduling rules. For portability, an 
 implementation must support these rules, though it is free to support other scheduling rules 
 needed by applications.
  
 423",NA
Chapter 22 ,NA,NA
Distributed and High Integrity Systems,"22.1 Distributed systems 
  
 A distributed system consists of several computers running their own programs that commu-
 nicate with each other over a network. The terms used in Ada are:
  
 §E
  
 2
  A
  distributed system
  is an interconnection of one or more
  processing nodes
  (a system 
 resource that has both computational and storage capabilities), and zero or more 
 storage nodes
  (a system resource that has only storage capabilities, with the storage 
 addressable by one or more processing nodes).
  
 3
  A
  distributed program
  comprises one or more partitions that execute independently 
  
 (except when they communicate) in a distributed system.
  
 4
  The process of mapping the partitions of a program to the nodes in a distributed 
  
 system is called
  configuring the partitions of the program
 .
  
 5
  The implementation shall provide means for explicitly assigning library units to a 
 partition and for the configuring and execution of a program consisting of multiple 
 partitions on a distributed system; the means are implementation defined.
  
 What is normally called a “program” is called a
  partition
  §10.2 in Ada, while a program is a set of 
 partitions that can be assigned to the nodes of a distributed system. One or more or all (active) 
 partitions may be assigned to a (processing) node. The versions of the units of a distributed 
 system must be consistent, as defined in §E.3.
  
 22.1.1 Categorization 
  
 A central problem that arises in the development of a distributed system is to establish the 
 semantic connections between units assigned to different active partitions §E.1(2). If a type
  T
  is
  
 451",NA
Appendix A ,NA,NA
Glossary of ARM Terms,"The
  ARM
  is written in a precise style, with specialized terms defined and then used consistently 
 throughout the document; this glossary collects the definitions of these terms. For brevity, the 
 glossary does not include well known terms like
  procedure
  and terms from the Annexes. Source 
 code examples will help you understand and remember the definitions. The following decla-
 rations will be used in the examples:
  
 type
  Piece
  is
  (Pawn, Knight, Bishop, Rook, Queen, King); 
 type
  Matrix (Integer
  
 range
  <>, Integer
  range
  <>)
  of
  Piece; 
 type
  Game_Board(Size: Positive)
  is 
  
  
 record 
  
  
 B: Matrix(1..Size, 1..Size); 
  
  
 end record
 ;
  
 type
  Node; 
  
 type
  Ptr
  is access
  Node; 
  
 type
  Node
  is 
  
  
 record 
  
  
 Key: Integer; 
  
  
 Next: Ptr; 
  
  
 end record
 ;
  
 package
  P
  is 
  
  
 type
  Parent
  is tagged null record
 ; 
  
  
 procedure
  Primitive(X: Parent); 
  
  
 type
  Derived
  is new
  Parent
  with null record
 ; 
  
 procedure
  Primitive(X: Derived); 
  
 end
  P;
  
 459",NA
Appendix B ,NA,NA
Hints,"2.1. §3.5.1(7), §3.5.4(15), §3.5.5(6) 7.4. §7.3.1(8–9) 2.2. §4.4(2–7)
  
 2.3. §2.4.1(6), §2.4.2(7–8)
  
 8.1. §13.14(7,16), §3.9.2(13) 
 8.2. §3.3(12), §4.6(5), §5.2(5)
  
 3.1. §6.1(21) 8.3. §3.9.3(4,6)
  
 3.2. §6.6(5) 8.4. §3.9.2(11)
  
 3.3. §6.6(6) 8.5. §13.14(6)
  
 4.1. §4.3.3(3–4), §4.3.1(4-6) 9.1. §12.5.3(3)
  
 4.2. §4.3.3(19) 
  
 4.3. §4.1.2(7)
  
 9.2. §12.1(10), §12.3(20) 
  
 9.3. §3.4(6), §12.5.1(11–14)
  
 4.4. §4.3.3(27), §4.3.3(26,29) 9.4. §12.7(10)
  
 4.5. §4.3.3(17) 9.5. §12.3(16–17)
  
 9.6. §12.6(9)
  
 5.1. §3.6(10), §3.3(23)
  
 5.2. §4.3.1(15), §4.5.2(22) 10.1. §11.4.1(12)
  
 5.3. §5.2(7,13)
  
 5.4. §4.3.1(17), §4.9(6,21–22) 11.1. None
  
 11.2. §3.8(12)
  
 6.1. §7.3(5) 11.3. §8.5.1(5)
  
 6.2. §3.10.1(3) 11.4. §3.7(11)
  
 6.3. §7.3.1(3,5) 11.5. §3.7(9.1)
  
 11.6. §4.6(43)
  
 7.1. §4.3(4), §3.9(29) 11.7. §13.1(10)
  
 7.2. §3.4(17), §4.5.2(14)
  
 7.3. §4.5.2(24) 12.1. §6.4.1(12–15)
  
 477",NA
Appendix C,NA,NA
Answers,"2.1. Prints an asterisk that is at position 42 in the enumeration type
  Character
  and then 
  
 prints zero. The position of an enumeration value is its position within the type, not the 
  
 subtype, and the position of an integer is its value.
  Val
  returns a value of the
  base
  type. 2.2. 
 Compile-time error. The declaration of
  B1
  is legal because repetitions of
  and
  (or
  or
 ) are 
  
 allowed by the syntax. The declaration of
  B2
  is illegal because combining operators re-
  
 quires the syntax of a parenthesized expression.
  
 2.3. Compile-time error. The third statement is a parse error because the exponent must be 
 exponent letters and hexadecimal digits can be of either case. decimal. With the third 
 statement deleted, the program prints 2560 (
 =
  10
  ·
  16
 2
 ) twice:
  
 3.1. Compile-time error. A formal parameter cannot be used in the formal part.
  
 3.2. Compile-time error. An explicit declaration of
  ""/=""
  for predefined
  Boolean
  is illegal. 3.3. 
 Prints
  True
  twice. Except for predefined
  Boolean
  type, there is no relationship between 
  
 ""=""
  
 and
  ""/=""
 .
  
 4.1. Compile-time error. While record aggregates can have named associations after posi-tional 
 associations, array aggregates must be either positional or named (except for 
 others
 ).
  
 4.2. Prints
  S
 . The bottom subaggregate can be a string literal if the component is of type 
  
 Character
 .
  
 4.3. Prints nothing. A null slice does not cause
  Constraint_Error
 .
  
 4.4. Raises
  Constraint_Error
 . The declaration of
  V1
  is legal: the aggregate bounds are taken 
  
 from the discrete choice list and then converted during the assignment (
 sliding
 ). Because 
  
 of the
  others
 , the bounds of the aggregate for
  V2
  are taken from the index constraint, 
  
 and 
 6 is not within the bounds of the constraint. Aggregates with
  others
  do not slide. 4.5. Compile-
 time error. The second aggregate is illegal, because a choice may not be dy-
  
 namic 
 unless it is the only choice.
  
 479",NA
References,"1. J. Barnes.
  High Integrity Software: The SPARK Approach to Safety and Security
 . Addison-Wesley, 
  
 Harlow, UK, 2003.
  
 2. M. Ben-Ari.
  Principles of Concurrent and Distributed Programming (Second Edition)
 . Addison-
  
 Wesley, Harlow, UK, 2006.
  
 3. A. Burns, B. Dobbing, and T. Vardanega. Guide for the use of the Ada Ravenscar Profile in high 
 integrity systems. Technical Report YCS-2003-348, University of York, 2003.
  http: 
 //www.sigada.org/ada_letters/jun2004/ravenscar_article.pdf
 .
  
 4. A. Burns and A. Wellings.
  Concurrency and Real-Time Programming in Ada 2005
 . Cambridge 
  
 University Press, Cambridge, 2007.
  
 5. J.W.S. Liu.
  Real-Time Systems
 . Prentice Hall, Upper Saddle River, NJ, 2000.
  
 6. S.T. Taft and R.A. Duff, editors.
  Ada 95 Reference Manual: Language and Standard Libraries.
  
 International Standard ISO/IEC 8652:1995(E)
 , volume 1246 of
  Lecture Notes in Computer 
 Science
 . Springer, 1997.
  
 7. S.T. Taft, R.A. Duff, R.L. Brukardt, E. Ploedereder, and P. Leroy, editors.
  Ada 2005 Refer-ence 
 Manual. Language and Standard Libraries. International Standard ISO/IEC 8652/1995(E) with 
 Technical Corrigendum 1 and Amendment 1
 , volume 4348 of
  Lecture Notes in Computer 
 Science
 . Springer, 2006.
  
 487",NA
