Larger Text,Smaller Text,Symbol
GNU COBOL Programmer’s Guide ,For Version 2.1 [23NOV2013],NA
Gary L. Cutler (,NA,NA
cutlergl@gmail.com,NA,NA
).,NA,NA
Table of Contents,NA,NA
1. Introduction,NA,NA
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA,NA
 1,"1.1. Additional Reference Sources
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  1 
 1.2. 
 Introducing COBOL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  1 
 1.2.1. 
 Why YOU Should Learn COBOL
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  2 
 1.2.2. 
 Programmer Productivity
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  4 
 1.3. So What 
 is GNU COBOL?
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  5 
 1.3.1. Language 
 Reserved Words
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  6 
 1.3.2. User-Defined 
 Words
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  6 
 1.3.3. Case Insensitivity
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  7 
 1.3.4. Readability of Programs
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  7 
 1.3.5. Divisions Organize Programs
 . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . .
  10 
 1.3.6. Copybooks
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . .
  10 
 1.3.7. Structured Data
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  10 
 1.3.8. Files
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 11 
 1.3.9. Table Handling
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  15 
 1.3.10. Sorting and Merging Data
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  15 
 1.3.11. 
 String Manipulation Features
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  16 
 1.3.12. Screen 
 Formatting Features
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  18 
 1.3.12.1. A Sample 
 Screen
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  19 
 1.3.12.2. Color Palette and 
 Video Attributes
 . . . . . . . . . . . . . . . . . .
  20 
 1.3.13. Report Writer Features
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  22 
 1.3.14. Data Initialization
  . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  23 
 1.3.15. Syntax Diagram Conventions
  . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . .
  24 
 1.3.16. Format of Program Source Lines
  . . . . . . . . . . . . . . . . . . 
 . . . . . . .
  26 
 1.3.17. Program Structure
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 29 
 1.3.18. Comments
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  31 
 1.3.19. Literals
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  32 
 1.3.19.1. Numeric Literals
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 1.3.19.2. 
 Alphanumeric Literals
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 1.3.19.3. 
 Figurative Constants
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  35 
 1.3.20. 
 Punctuation
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36 
 1.3.21. 
 LENGTH OF
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36 
 1.3.22. 
 Interfacing to Other Environments
  . . . . . . . . . . . . . . . . . . . . . . .
  37",NA
2. CDF - Compiler Directing Facility,NA,NA
 . . . . . . . . . . .,NA,NA
 39,"2.1. COPY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  40 
 2.2. 
 REPLACE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  42 
 2.3. 
 >>DEFINE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  45 
 2.4. 
 >>IF
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  46 
 2.5. 
 >>SET
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  49 
 2.6. 
 >>SOURCE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  50 
 2.7. 
 >>TURN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  51
  
 3 June 2014  
 Contents",NA
3. IDENTIFICATION DIVISION,NA,NA
 . . . . . . . . . . . . . . .,NA,NA
 53,NA,NA
4. ENVIRONMENT DIVISION,NA,NA
 . . . . . . . . . . . . . . . . .,NA,NA
 55,"4.1. CONFIGURATION SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  56 
 4.1.1. 
 SOURCE-COMPUTER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  57 
 4.1.2. OBJECT-
 COMPUTER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  58 
 4.1.3. REPOSITORY
  . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  60 
 4.1.4. SPECIAL-NAMES
 . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  62 
 4.1.4.1. Alphabet-Name-Clause
 . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  67 
 4.1.4.2. Class-Definition-Clause
 . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .
  69 
 4.1.4.3. Switch-Definition-Clause
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 70 
 4.1.4.4. Symbolic-Characters-Clause
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  71 
 4.2. 
 INPUT-OUTPUT SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  72 
 4.2.1. 
 SELECT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  73 
 4.2.1.1. 
 ORGANIZATION SEQUENTIAL
 . . . . . . . . . . . . . . . . . . . .
  78 
 4.2.1.2. 
 ORGANIZATION LINE SEQUENTIAL
 . . . . . . . . . . . . . .
  80 
 4.2.1.3. 
 ORGANIZATION RELATIVE
  . . . . . . . . . . . . . . . . . . . . . . .
  82 
 4.2.1.4. 
 ORGANIZATION INDEXED
  . . . . . . . . . . . . . . . . . . . . . . . .
  84 
 4.2.2. MULTIPLE 
 FILE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  86 
 4.2.3. SAME RECORD 
 AREA
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  87",NA
5. DATA DIVISION,NA,NA
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA,NA
 89,"5.1. Data Definition Principles
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  90 
 5.2. 
 FILE SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  93 
 5.2.1. 
 File/Sort-Description
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  94 
 5.2.2. FILE-
 SECTION-Data-Item
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  98 
 5.3. WORKING-
 STORAGE SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  100 
 5.4. LOCAL-STORAGE 
 SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  102 
 5.5. LINKAGE SECTION
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  104 
 5.6. REPORT SECTION
  . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  107 
 5.6.1. Report Group Definitions
  . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . .
  111 
 5.6.2. REPORT SECTION Data Items
  . . . . . . . . . . . . . . . 
 . . . . . . . . . .
  113 
 5.7. SCREEN SECTION
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  115 
 5.8. Special Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 118 
 5.8.1. 01-Level Constants
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  118 
 5.8.2. 66-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  121 
 5.8.3. 
 77-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  122 
 5.8.4. 78-
 Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  123 
 5.8.5. 88-Level 
 Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  124 
 5.9. Data Description 
 Clauses
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  125 
 5.9.1. ANY LENGTH
 . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  125 
 5.9.2. AUTO
 . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  126 
 5.9.3. AUTO-SKIP
  . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  127 
 5.9.4. AUTOTERMINATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .
  128 
 5.9.5. BACKGROUND-COLOR
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 129 
 5.9.6. BASED
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  130
  
 Contents  
 3 June 2014",NA
6. PROCEDURE DIVISION,NA,NA
 . . . . . . . . . . . . . . . . . . .,NA,NA
 201,"6.1. PROCEDURE DIVISION USING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  202 
 6.2. 
 PROCEDURE DIVISION CHAINING
 . . . . . . . . . . . . . . . . . . . . . . . .
  204 
 6.3. 
 PROCEDURE DIVISION RETURNING
  . . . . . . . . . . . . . . . . . . . . .
  206 
 6.4. 
 PROCEDURE DIVISION Sections and Paragraphs
  . . . . . . . . . . .
  207 
 6.5. 
 DECLARATIVES
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  208 
 6.6. Table 
 References
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  211 
 6.7. 
 Qualification of Data Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  212 
 6.8. 
 Reference Modifiers
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  213 
 6.9. 
 Arithmetic Expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  215 
 6.10. 
 Conditional Expressions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  218 
 6.10.1. 
 Condition Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  218 
 6.10.2. Class 
 Conditions
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  219 
 6.10.3. Sign 
 Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  221 
 6.10.4. Switch-
 Status Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  222 
 6.10.5. Relation 
 Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  223 
 6.10.6. Combined 
 Conditions
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  225 
 6.10.7. Negated 
 Conditions
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  226 
 6.11. Use of Periods
 . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  227 
 6.12. Use of VERB/END-
 VERB Constructs
  . . . . . . . . . . . . . . . . . . . . . . .
  229 
 6.13. Concurrent Access to 
 Files
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  231 
 6.13.1. File Sharing
  . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  231 
 6.13.2. Record Locking
 . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . .
  233 
 6.14. Common Clauses on Executable 
 Statements
  . . . . . . . . . . . . . . . . .
  235 
 6.14.1. AT END + NOT AT END
  . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . .
  235 
 6.14.2. CORRESPONDING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  236 
 6.14.3. INVALID KEY + NOT INVALID KEY
  . . . . . . . . . . . . . . . .
  238 
 6.14.4. ON EXCEPTION + NOT ON EXCEPTION
  . . . . . . . . . . .
  238 
 6.14.5. ON 
 OVERFLOW + NOT ON OVERFLOW
 . . . . . . . . . . . .
  239 
 6.14.6. ON SIZE ERROR 
 + NOT ON SIZE ERROR
  . . . . . . . . . . .
  239 
 6.14.7. ROUNDED
  . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  240 
 6.15. Special Registers
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . .
  243 
 6.16. Intrinsic Functions
  . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . .
  245 
 6.16.1. ABS
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . .
  246 
 6.16.2. ACOS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  247 
 6.16.3. ANNUITY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  248 
 6.16.4. ASIN
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  249 
 6.16.5. 
 ATAN
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  250 
 6.16.6. BYTE-
 LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  251 
 6.16.7. CHAR
  . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  252 
 6.16.8. COMBINED-DATETIME
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  253 
 6.16.9. CONCATENATE
  . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  254 
 6.16.10. COS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . .
  255 
 6.16.11. CURRENCY-SYMBOL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  256 
 6.16.12. CURRENT-DATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  257 
 6.16.13. DATE-OF-INTEGER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  258 
 6.16.14. 
 DATE-TO-YYYYMMDD
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  259
  
 Contents  
 3 June 2014",NA
7. Report Writer Usage Notes,NA,NA
 . . . . . . . . . . . . . . . . . .,NA,NA
 483,"7.1. RWCS Lexicon
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  483 
 7.2. 
 The Anatomy of a Report
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  484 
 7.3. The 
 Anatomy of a Report Page
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  485 
 7.4. How 
 RWCS Builds Report Pages
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  486 
 7.5. Control 
 Hierarchy
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  488 
 7.6. An 
 Example
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  490 
  
 7.6.1. Data
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  490 
  
 7.6.2. Program
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  492 
  
 7.6.3. Generated Report Pages
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  497 
 7.7. 
 Control Hierarchy (Revisited)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  503 
 7.8. 
 Turning PHYSICAL Page Formatting Into LOGICAL Formatting  
 . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  506
  
 Contents  
 3 June 2014",NA
8. Interfacing With The OS,NA,NA
. . . . . . . . . . . . . . . . . . . . .,NA,NA
 509,"8.1. Compiling Programs
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  509 
 8.1.1. cobc - The GNU COBOL Compiler
  . . . . . . . . . . . . . . . . . . . . . .
  509 
 8.1.2. 
 Compilation Time Environment Variables
  . . . . . . . . . . . . . . . .
  514 
 8.1.3. 
 Locating Copybooks
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  515 
 8.1.4. 
 Compiler Configuration Files
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  516 
 8.2. Running 
 Programs
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  519 
 8.2.1. Direct 
 Execution
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  519 
 8.2.2. Executing 
 Dynamically-Loadable Libraries
  . . . . . . . . . . . . . . .
  520 
 8.2.2.1. cobcrun - 
 Command-line Execution
  . . . . . . . . . . . . . . . . .
  520 
 8.2.2.2. Dynamically 
 Loaded Subprograms
  . . . . . . . . . . . . . . . . . .
  521 
 8.2.3. Run Time Environment 
 Variables
  . . . . . . . . . . . . . . . . . . . . . . . .
  522 
 8.2.4. Program Arguments
  . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  524 
 8.3. Built-In System Subroutines
  . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . .
  525 
 8.3.1. C$CALLEDBY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . .
  526 
 8.3.2. C$CHDIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . .
  526 
 8.3.3. C$COPY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 527 
 8.3.4. C$DELETE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  527 
 8.3.5. C$FILEINFO
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  527 
 8.3.6. 
 C$GETPID
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  528 
 8.3.7. 
 C$JUSTIFY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  528 
 8.3.8. 
 C$MAKEDIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  529 
 8.3.9. 
 C$NARG
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  529 
 8.3.10. 
 C$PARAMSIZE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  530 
 8.3.11. 
 C$PRINTABLE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  530 
 8.3.12. 
 C$SLEEP
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  530 
 8.3.13. 
 C$TOLOWER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  531 
 8.3.14. 
 C$TOUPPER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  531 
 8.3.15. CBL 
 AND
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  531 
 8.3.16. CBL CHANGE 
 DIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  532 
 8.3.17. CBL CHECK FILE EXIST
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  532 
 8.3.18. CBL CLOSE FILE
 . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . .
  533 
 8.3.19. CBL COPY FILE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . .
  533 
 8.3.20. CBL CREATE DIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 534 
 8.3.21. CBL CREATE FILE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  534 
 8.3.22. CBL DELETE DIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  535 
 8.3.23. 
 CBL DELETE FILE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  535 
 8.3.24. CBL EQ
  . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  536 
 8.3.25. CBL ERROR PROC
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  536 
 8.3.26. CBL EXIT PROC
  . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . .
  538 
 8.3.27. CBL FLUSH FILE
 . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . .
  540 
 8.3.28. CBL GET CSR POS
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  540 
 8.3.29. CBL GET CURRENT DIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  541 
 8.3.30. CBL GET SCR SIZE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  541 
 8.3.31. 
 CBL IMP
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  542 
 8.3.32. CBL 
 NIMP
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  543 
 8.3.33. CBL NOR
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  543
  
 3 June 2014  
 Contents",NA
9. Sub-Programming,NA,NA
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA,NA
 557,"9.1. Subprogram Types
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  557 
 9.2. 
 Independent vs Contained vs Nested Subprograms
  . . . . . . . . . . . .
  557 
 9.3. 
 Alternate Entry Points
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  559 
 9.4. 
 Dynamic vs Static Subprograms
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  559 
 9.5. 
 Subprogram Execution Flow
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  561 
  
 9.5.1. Subroutine Execution Flow
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  561 
  
 9.5.2. User-Defined Function Execution Flow
  . . . . . . . . . . . . . . . . . . .
  563 
 9.6. Sharing Data Between Calling and Called Programs
 . . . . . . . . . . .
  565 
  
 9.5.1. Subprogram Arguments
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  565 
  
  
 9.6.1.1. Calling Program Considerations
 . . . . . . . . . . . . . . . . . . . . .
  565 
  
  
 9.6.1.2. Called Program Considerations
 . . . . . . . . . . . . . . . . . . . . . .
  566 
  
 9.6.2. GLOBAL Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  567 
  
 9.6.3. EXTERNAL Data Items
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  567 
 9.7. 
 Recursive Subprograms
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  568 
 9.8. 
 Combining GNU COBOL and C Programs
 . . . . . . . . . . . . . . . . . . . .
  571 
  
 9.9.1. GNU COBOL Run-Time Library Requirements
  . . . . . . . . . .
  571 
  
 9.9.2. String Allocation Differences Between GNU COBOL and C  
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  572 
  
 9.9.3. Matching C Data Types with GNU COBOL USAGEs
  . . . .
  573 
  
 9.9.4. GNU COBOL Main Programs CALLing C Subprograms
 . .
  574 
  
 9.9.5. C Main Programs Calling GNU COBOL Subprograms
  . . .
  575
  
 Contents  
 3 June 2014",NA
10. Programming Style Suggestions,NA,NA
 . . . . . . . . . . . .,NA,NA
 579 ,"10.1. 
 Marking Changes in Programs
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  579
  
 10.2. Data Item Coding and Naming Conventions
  . . . . . . . . . . . . . . . . .
  579
  
 10.3. Table Subscripting versus Table Indexing
  . . . . . . . . . . . . . . . . . . . .
  582
  
 10.4. Copybook Naming Conventions and Usage
  . . . . . . . . . . . . . . . . . . .
  584
  
 10.5. PROCEDURE DIVISION Sections Versus Paragraphs
  . . . . . . .
  585
  
 10.6. COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  586",NA
Appendix A - Glossary of Terms,NA,NA
 . . . . . . . . . . . . . . .,NA,NA
 589 ,NA,NA
Appendix B - Reserved Word List,NA,NA
 . . . . . . . . . . . . .,NA,NA
 599 ,NA,NA
Appendix C - GNU Free Documentation License ,NA,NA
. . . . . . . . . . ,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,NA,NA
 603 ,NA,NA
Appendix D - ,NA,NA
Summary of Document Changes ,NA,NA
. . . . . . . . . . . . . . . . . . . . . . ,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . .,NA,NA
 611 ,NA,NA
Index,NA,NA
. . . . . . . . . . . . . . . . . . . . . . . . . ,NA,NA
. . . . . . . . . . . . . . . . . . . . .,NA,NA
 615,"3 June 2014  
 Contents",NA
1. Introduction,"This document describes the syntax, semantics and usage of the COBOL programming lan-
 guage as implemented by the current version of GNU COBOL, formerly known as Open-
 COBOL. 
 The principal developers of GNU COBOL are Keisuke Nishida and Roger While. They may be 
 contacted through the GNU COBOL website – sourceforge.net/projects/open-cobol. 
 This document was intended to serve as a full-function reference and user’s guide suitable 
 for both those readers learning COBOL for the first time as well as those already familiar 
 with some dialect of the COBOL language.",NA
1.1. Additional Reference Sources,"For those wishing to learn COBOL for the first time, I can strongly recommend the following 
 resources. 
 If you like to hold a book in your hands, I strongly recommend ""Murach’s Structured 
 COBOL"", by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. 
 Mike Murach and his various writing partners have been writing outstanding COBOL text-
 books for decades, and this text is no exception. It’s an excellent book for those familiar with 
 the concepts of programming in other languages, but unfamiliar with COBOL. 
 Would you prefer a web-based tutorial? Try the University of Limerick (Ireland) COBOL web 
 site - ‘http://www.csis.ul.ie/cobol/’.",NA
1.2. Introducing COBOL,"If you already know a programming language, and that language isn’t COBOL, chances are 
 that language is Java, C or C++. You will find COBOL a much different programming language 
 than those; sometimes those differences are a good thing and sometimes they aren’t. The 
 thing to remember about COBOL is this — it was designed to solve business problems. 
 COBOL, first introduced to the programming public in 1959, was the very first programming 
 language to become standardized (in 1960). This meant that a standard-compliant COBOL 
 program written on computer ""A"" made by company ""B"" would be able to be compiled and 
 executed on computer ""X"" made by company ""Y"" with very few, if any, changes. This may 
 not seem like such a big deal today, but it was a radical departure from all programming 
 languages that came before it and even many that came after it. 
 The name
  COBOL
  actually says it all — COBOL is an acronym that stands for ""(
 CO
 )mmon 
 (
 B
 )usiness (
 O
 )riented (
 L
 )anguage"". Note the fact that the word ""common"" comes before all 
 others. The word ""business"" is a close second. Therein lies the key to COBOL’s success. 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.2.1. Why YOU Should Learn COBOL,"Despite statements from industry ""insiders"", the COBOL programming language is not dead, 
 even though newer and so-called ""modern"" languages like Java, C#, .NET, Ruby on Rails and 
 so on appear to have become the languages of choice in the Information Technology world. 
 These languages have become popular because they address the following desired 
 requirements for ""modern"" programming: 
 1. They conform to the principles of Object-Oriented Programming (OOP). This is desired 
 for one major reason — it facilitates ""code reusability"", thus improving the productivity 
 of programmers by allowing them to re-use previously written (and debugged) code in 
 new applications. For one reason or another, COBOL is perceived as being weak in this 
 regard. It isn’t (especially today), as we’ll see in the next section, but perception is 
 important. 
 2. Those languages aren’t limited to mainframe computers, as COBOL is
  perceived
  to be. 
 Some, like .NET and Ruby, aren’t even
  available
  on mainframes. The ""modern"" pro-
 gramming languages were designed and intended for use on the full variety of 
 computer platforms, from shirt-pocket computers (i.e. smartphones) up to the most 
 massive of supercomputers. 
 There are several excellent commercially available COBOL implementations available 
 for non-mainframe systems (Micro Focus COBOL, AccuCOBOL, NetCOBOL and Elas-tic 
 COBOL, just to name a few), including Windows and UNIX/Linux systems. These aren’t 
 cheap, however. 
 3. Universities love the ""Modern"" languages. In the U.S., 73% of colleges lack even one 
 COBOL course on their curricula. COBOL, it appears, is no longer ""cool"" enough for 
 students to fill a classroom. 
 Just because COBOL doesn’t traditionally support objects, classes, and the like doesn’t mean 
 that its ""procedural"" approach to computing isn’t valuable — after all, it runs 70% of the
  
 worlds
  business transactions, and does so: 
 •
  Using programs that, for the most part, are much more self-documenting than would be the 
 case with any other programming language. 
 •
  Effortlessly providing arithmetic accuracy to 31 digits, with performance approaching 
 that of well-written assembly-language programs. Don’t think this isn’t critically im-
 portant to banks, investment houses and any business interested in tracking revenues, 
 expenses and profits (duh - like ALL of them). 
 •
  Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any 
 DBMS, Transaction Processing platforms, Queue-Management facilities and other 
 programming languages.",NA
1.2.2. Programmer Productivity,"Throughout the history of computer programming, the search for new ways to improve of 
 the productivity of programmers has been a major consideration. Other than hobbyists, 
 programming is an activity performed for money, and businesses abhor spending anything 
 more than is absolutely necessary; even government agencies try to spend as little money 
 on projects as is absolutely necessary. 
 The amount of programming necessary to accomplish a given task — including rework 
 needed by any errors found during testing (testing is sometimes jokingly defined as: ""that 
 time during which an application is actually in production, allowing users to discover the 
 problems"") is the measure of programmer productivity. Anything that reduces that effort 
 will therefore reduce the time spent in such activities therefore reducing the expense of 
 same. 
 When the expense of programming is reduced, programmer productivity is increased. 
 Sometimes the quest for improved programmer productivity (and therefore reduced pro-
 gramming
  expense
 ) has taken the form of introducing new features in programming lan-
 guages, or even new languages altogether. Sometimes it has resulted in new ways of using 
 the existing languages. 
 While many technological and procedural developments have made
  evolutionary
  improve-
 ments to programmer productivity, each of the following three events has been responsible 
 for
  revolutionary
  improvements: 
 •
  The development of so-called ""higher-level"" programming languages that enable a pro-
 grammer to specify in a single statement of the language an action that would have 
 required many more separate statements in a prior programming language. The stan-
 dardization of such languages, making them usable on a wide variety of computers and 
 operating systems, was a key aspect of this development. COBOL was a pioneering de-
 velopment in this area, being a direct descendant of the very first higher-level language 
 (FLOW-MATIC, developed by US Naval Lieutenant Grace Hopper) and the first to 
 become standardized. 
 •
  The establishment of programming techniques that make programs easier to read and 
 therefore easier to understand. Not only do such techniques reduce the amount of rework 
 necessary simply to make a program work as designed, but they also reduce the amount of 
 time a programmer needs to study an existing program in order how to best adapt it to 
 changing business requirements. The foremost development in this area was structured 
 programming. Introduced in the late 1970s, this approach to programming spawned new 
 programming languages (
 PASCAL
 ,
  ALGOL
 ,
  PL/1
  and so forth) designed around it. With the 
 ANSI85 standard, COBOL embraced the principles espoused",NA
1.3. So What is GNU COBOL?,"GNU COBOL is an open source COBOL compiler and runtime environment, written using the 
 C programming language. GNU COBOL is typically distributed in source-code form, and 
 must then be built for your computer’s operating system using the system’s C compiler and 
 loader. While originally developed for the UNIX and Linux operating systems, GNU COBOL 
 has also been successfully built for OSX computers or Windows computers utilizing the 
 UNIX-emulation features of such tools as Cygwin and MinGW. 
 The MinGW approach is a personal favorite with the author of this manual because it 
 creates a GNU COBOL compiler and runtime library that require only a single MinGW DLL to 
 be available for the GNU COBOL compiler, runtime library and user programs. That DLL is 
 freely distributable under the terms of the GNU General Public License. A MinGW build of 
 GNU COBOL fits easily on and runs from a 128MB flash drive with no need to install any 
 software onto the Windows computer that will be using it. Some functionality of the 
 language, dealing with the sharing of files between concurrently executing GNU COBOL 
 programs and record locking on certain types of files, is sacrificed however as the 
 underlying",NA
1.3.1. Language Reserved Words,"COBOL programs consist of a sequence of words and symbols. Words, which consist of 
 sequences of letters (upper- and/or lower-case), digits, dashes (""-"") and/or underscores ("" 
 "") may have a pre-defined, specific, meaning to the compiler or may be invented by the 
 programmer for his/her purposes. 
 The GNU COBOL language specification defines over 700 ’
 Reserved Words
 ’ — words to which 
 the compiler assigns a special meaning. 
 Programmers may use a reserved word as
  part
  of a word they are creating themselves, but 
 may not create their own word as an exact duplicate (without regard to case) of a COBOL 
 reserved word. 
 See
  [Appendix B - Reserved Word List], page 599
 , for a complete list of GNU COBOL reserved 
 words.",NA
1.3.2. User-Defined Words,"When you write GNU COBOL programs, you’ll need to create a variety of words to represent 
 various aspects of the program, the program’s data and the external environment in which 
 the program will run. This will include internal names by which data files will be referenced, 
 data item names and names of executable logic procedures. 
 User-defined words may be composed from the characters ""A"" through ""Z"" (upper- and/or 
 lower-case), ""0"" through ""9"", dash (""-"") and underscore ("" ""). User-defined words may 
 neither start nor end with hyphen or underscore characters. 
 Other programming language provide the programmer with a similar capability of creat-ing 
 their own words (names) for parts of a program; COBOL is somewhat unusual when 
 compared to other languages in that user-defined words may
  start
  with a digit. 
 With the exception of logic procedure names, which may consist entirely of nothing but 
 digits, user-defined words must contain at least one letter. 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.3. Case Insensitivity,"All COBOL implementations allow the use of both upper and lowercase letters in program 
 coding. GNU COBOL is completely insensitive to the case used when writing reserved words 
 or user-defined names. Thus, ""AAAAA"", ""aaaaa"", ""Aaaaa"" and ""AaAaA"" are all the same word 
 as far as GNU COBOL is concerned. 
 The only time the case used does matter is within quoted character strings, where character 
 values will be exactly as coded. 
 By convention throughout this document, COBOL reserved words will be shown entirely in 
 UPPERCASE while those words that were created by a programmer will be represented by 
 tokens in mixed or lower case. 
 This isn’t a bad practice to use in actual programs, as it leads to programs where it is much 
 easier to distinguish reserved words from user-defined ones!",NA
1.3.4. Readability of Programs,"The most vociferous critics of COBOL frequently focus on the wordiness of the language, 
 often citing the case of a so-called ""Hello World"" program as the ""proof"" that COBOL is so 
 much more tedious to program in than more ""modern"" languages. This tedium is cited as 
 such a significant impact to programmer productivity that, in their opinions, COBOL can’t go 
 away quickly enough. 
 Here are two different ""Hello World"" applications — one written in Java and the second in 
 GNU COBOL. First, the Java version: 
 Class HelloWorld {  
  
 public static void main(String[] args) { 
  
 System.out.println(""Hello World!"");  
 }  
 } 
 And here is the same program, written in GNU COBOL: 
 IDENTIFICATION DIVISION.  
 PROGRAM-ID. HelloWorld.  
 PROCEDURE DIVISION. 
 DISPLAY ""Hello World!"". 
 Both of the above programs could have been written on a single line, if desired, and both 
 languages allow a programmer to use (or not use) indentation as they see fit to improve 
 program readability. Sounds like a tie so far. 
 Let’s look at how much more ""wordy"" COBOL is than Java. Count the characters in the two 
 programs. The Java program has 95 (not counting carriage returns and any indenta-tion). 
 The COBOL program has 89 (again, not counting carriage returns and indentation)! 
 Technically, it could have been only 65 because the ""IDENTIFICATION DIVISION."" header 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.5. Divisions Organize Programs,"COBOL programs are structured into four major areas of coding, each with its own purpose. 
 These four areas are known as divisions. 
 Each division may consist of a variety of sections and each section consists of one or more 
 paragraphs.  A paragraph consists of sentences, each of which consists of one or more 
 statements. 
 This hierarchical structure of program components standardizes the composition of all 
 COBOL programs. Much of this manual describes the various divisions, sections, para-
 graphs and statements that may comprise any COBOL program.",NA
1.3.6. Copybooks,"A ’
 Copybook
 ’ is a segment of program code that may be utilized by multiple programs 
 simply by having those programs use the ""COPY"" statement (see
  [COPY], page 40
 ) to import 
 that code. This code may define files, data structures or procedural code. 
 Today’s current programming languages have a statement (usually, this statement is named 
 ""import"", ""include"" or ""#include"") that performs this same function. What makes the COBOL 
 copybook feature different than the ""include"" facility in newer languages, however, is the 
 fact that the ""COPY"" statement can edit the imported source code as it is being copied. 
 This capability makes copybook libraries extremely valuable to making code reusable.",NA
1.3.7. Structured Data,"A contiguous area of storage within the memory space of a program that may be refer-
 enced, by name, in a COBOL program is referred to as a ’
 Data Item
 ’. Other programming 
 languages use the term variable, property or attribute to describe the same thing. 
 COBOL introduced the concept of structured data. The principle of structured data in 
 COBOL is based on the idea of being able to group related and contiguously-allocated data 
 items together into a single aggregate data item, called a ’
 Group Item
 ’. For example, a 35-
 character ’Employee-Name’ group item might consist of a 20-character ’Last-Name’followed 
 by a 14-character ’First-Name’ and a 1-character ’Middle-Initial’.",NA
1.3.8. Files,"One of COBOLs strengths is the wide variety of data files it is capable of accessing. GNU 
 COBOL programs, like those created with other COBOL implementations, need to have the 
 structure of any files they will be reading and/or writing described to them. The highest-
 level characteristic of a file’s structure is defined by specifying the organization of the file, as 
 follows: 
 ""ORGANIZATION LINE SEQUENTIAL"" 
 These are files with the simplest of all internal structures. Their contents are 
 structured simply as a series of identically- or differently-sized data records, 
 each terminated by a special end-of-record delimiter character. An ASCII line-
 feed character (hexadecimal 0A) is the end-of-record delimiter character used 
 by any UNIX or pseudo-UNIX (MinGW, Cygwin, OSX) GNU COBOL build. A truly 
 native Windows build would use a carriage-return, line-feed (hexadecimal 
 0D0A) sequence. 
 Records must be read from or written to these files in a purely sequential 
 manner. The only way to read (or write) record number 100 would be to have 
 read (or written) records number 1 thru 99 first. 
 When the file is written to by a GNU COBOL program, the delimiter sequence 
 will be automatically appended to each data record as it is written to the file. A 
 ""WRITE"" (see
  [WRITE], page 479
 ) to this type of file will be done as if a 
 ""BEFORE ADVANCING 1 LINE"" clause were specified on the ""WRITE"", if no 
 ""ADVANCING"" clause is coded. 
 When the file is read, the GNU COBOL runtime system will strip the trailing 
 delimiter sequence from each record. The data will be padded (on the right) 
 with spaces if the data just read is shorter than the area described for data 
 records in the program. If the data is too long, it will be truncated and the 
 excess will be lost. 
 These files should not be defined to contain any exact binary data fields because 
 the contents of those fields could inadvertently have the end-of-record 
 sequence as part of their values — this would confuse the runtime system when 
 reading the file, and it would interpret that value as an actual end-of-record 
 sequence. 
 ""LINE ADVANCING"" 
 These are files with an internal structure similar to that of a line sequential file. 
 These files are defined (without an explicit ""ORGANIZATION"" specification) 
 using the ""LINE ADVANCING"" clause on their ""SELECT"" statement (see
  
 [SELECT], page 73
 ). 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.9. Table Handling,"Other programming languages have arrays, COBOL has tables. They’re basically the same 
 thing. There are two special statements that exist in the COBOL language — ""SEARCH"" (see
  
 [SEARCH], page 440
 ) and ""SEARCH ALL"" (see
  [SEARCH ALL], page 442
 ) — that make 
 finding data in a table easy. 
 The first can search a table sequentially, stopping only when either a table entry matching 
 one of any number of search conditions is found, or when all table entries have been 
 checked against the search criteria and none matched any of those criteria. 
 The second can perform an extremely fast search against a table sorted by and searched 
 against a key field contained in each table entry. The algorithm used for such a search is a 
 binary search (also known as a half-interval search). This algorithm ensures that only a 
 small number of entries in the table need to be checked in order to find a desired entry or to 
 determine that the desired entry doesn’t exist in the table. The larger the table, the more 
 effective this search becomes. For example, a binary search of a table containing 32,768 
 entries will be able to locate a particular entry or determine the entry doesn’t exist by 
 looking at no more than fifteen (15) entries! The algorithm is explained in detail in the 
 documentation of the ""SEARCH ALL"" statement (see
  [SEARCH ALL], page 442
 ). 
 Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.",NA
1.3.10. Sorting and Merging Data,"The COBOL language includes a powerful ""SORT"" statement (see
  [SORT], page 453
 ) that can 
 sort large amounts of data according to arbitrarily complex key structures. This data may 
 originate from within the program or may be contained in one or more external files. 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.11. String Manipulation Features,"There have been programming languages designed specifically for the processing of text 
 strings, and there have been programming languages designed for the sole purpose of per-
 forming high-powered numerical computations. Most programming languages fall some-
 where in the middle. 
 COBOL is no exception, although it does include some very powerful string manipulation 
 capabilities; GNU COBOL actually has even more string-manipulation capabilities than many 
 other COBOL implementations. The following summarizes GNU COBOL’s string-processing 
 capabilities: 
 Concatenate two or more strings:
  
 •
  ""CONCATENATE"" intrinsic function (see
  [CONCATENATE], page 254
 ).
 •
  
 ""STRING"" statement (see
  [STRING], page 463
 ). 
 Conversion of a numeric time or date to a formatted character string:
  
 •
  ""LOCALE-TIME"" intrinsic function (see
  [LOCALE-TIME], page 281
 ).
 •
  
 ""LOCALE-DATE"" intrinsic function (see
  [LOCALE-DATE], page 280
 ). 
 Convert a binary value to its corresponding character in the program’s characterset:
  
 •
  ""CHAR"" intrinsic function (see
  [CHAR], page 252
 ). Add 1 to argument before invoking 
 the function; the description of the ""CHAR"" intrinsic function presents a technique 
 utilizing the ""MOVE"" statement that will accomplish the same thing without the need of 
 adding 1 to the numeric argument value first. 
 Convert a character string to lower-case:
  
 •
  ""LOWER-CASE"" intrinsic function (see
  [LOWER-CASE], page 285
 ).
 •
  
 ""C$TOLOWER"" built-in system subroutine (see
  [C$TOLOWER], page 531
 ). 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.12. Screen Formatting Features,"The COBOL2002 standard formalizes extensions to the COBOL language that allow for the 
 definition and processing of text-based screens, as is a typical function on mainframe and 
 1
  These delimiters may be single characters, multiple-character strings or multiple consecutive occurrences of 
 either
  
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.12.1. A Sample Screen,"A Sample Screen Produced by a GNU COBOL Program: 
  
 The above screen was produced by the GNU COBOL Interactive Compiler, or GCic. See the 
 ""GNU COBOL Sample Programs (gnucobsp)"" documentation for the source code to this 
 program. 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.12.2. Color Palette and Video Attributes,"GNU COBOL supports the following visual attribute specifications in the ""SCREEN SECTION"" 
 (see
  [SCREEN SECTION], page 115
 ): 
 Color 
 Eight (8) different colors may be specified for both the background (screen) 
 and foreground (text) color of any row/column position on the screen. Colors 
 are specified by number, although a copybook supplied with all GNU COBOL 
 distributions (""screenio.cpy"") defines COB-COLOR-xxxxxx names for the var-
 ious colors so they may be specified as a more meaningful name rather than a 
 number. The eight colors, by number, with the constant nams defined in 
 screenio.cpy, are as follows: 
 0. Black: COB-COLOR-BLACK 
 1. Blue: COB-COLOR-BLUE 
 2. Green: COB-COLOR-GREEN 
 3. Cyan (Turquoise): COB-COLOR-CYAN 
 4. Red: COB-COLOR-RED 
 5. Magenta: COB-COLOR-MAGENTA 
 6. Yellow: COB-COLOR-YELLOW 
 7. White: COB-COLOR-WHITE 
 Text Brightness 
 There are three possible brightness levels supported for text — lowlight (dim), 
 normal and highlight (bright).  
 Not all GNU COBOL implementations will 
 support all three (some treat lowlight the same as normal). The deciding factor 
 as to whether two or three levels are supported lies with the version of the 
 ""curses"" package that is being used. This is a utility screen-IO package that is 
 included into the GNU COBOL run-time library when the GNU COBOL software is 
 built. 
 As a general rule of thumb, Windows implementations support two levels while 
 Unix ones support all three. 
 Blinking 
 This too is a video feature that is dependent upon the ""curses"" package built 
 into your version of GNU COBOL. If blinking is enabled in that package, text 
 displayed in fields defined in the screen section as being blinking will endlessly 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.13. Report Writer Features,"GNU COBOL includes an implementation of the Report Writer Control System, or RWCS. 
 This is a standardized, optional add-on feature to the COBOL language which automates 
 much of the mechanics involved in the generation of printed reports by: 
 1. Controlling the pagination of reports, including: 
 A. The automatic production of a one-time notice on the first page of the report (report 
 heading). 
 B. The production of zero or more header lines at the top of every page of the report 
 (page heading). 
 C. The production of zero or more footer lines at the bottom of every page of the report 
 (page footing). 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.14. Data Initialization,"There are three ways in which data division data gets initialized. 
 1. When a program or subprogram is first executed, much of the data in it’s data division 
 will be initialized as follows:",NA
1.3.15. Syntax Diagram Conventions,"Syntax of the GNU COBOL language will be described in special ""syntax diagrams"" using the 
 following syntactical-description techniques: 
 MANDATORY-RESERVED-
 WORD  
 ~~~~~~~~~~~~~~~~
 ~~~~~~~ 
 Reserved words of the COBOL language will appear in UPPERCASE. When they 
 appear underlined, as this one is, they are required reserved words. 
 OPTIONAL-RESERVED-WORD 
 When reserved words appear without underlining, as this one is, they are op-
 tional; such reserved words are available in the language syntax merely to im-
 prove readability — their presence or absence has no effect upon the program. 
 ABBREVIATION  
 ~~~~ 
 When only a portion of a reserved word is underlined, it indicates that the word 
 may either be coded in its full form or may be abbreviated to the portion that is 
 underlined.",NA
1.3.16. Format of Program Source Lines,"Prior to the COBOL2002 standard, source statements in COBOL programs were structured 
 around 80-column punched cards. This means that each source line in a COBOL program 
 consisted of five different ""areas"", defined by their column number(s). 
 As of the COBOL2002 standard, a second mode now exists for COBOL source code state-
 ments — in this mode of operation, COBOL statements may each be up to 255 characters 
 long, with no specific requirements as to what should appear in which columns. 
 Of course, in keeping with the long-standing COBOL tradition of maintaining backwards 
 compatibility with older standards, programmers (and, of course, compliant COBOL com-
 pilers) are capable of working in either mode. It is even possible to switch back and forth in 
 the same program. The terms ’
 Fixed Format Mode
 ’ and ’
 Free Format Mode
 ’ are used to refer 
 to these two modes of source code formatting. 
 The GNU COBOL compiler (cobc) supports both of these source line format modes, de-
 faulting to Fixed Format Mode lacking any other information. 
 The compiler can be instructed to operate in either mode in any of the following four ways: 
 1. Using a compiler option switch — use the ""-fixed"" switch to start in Fixed Format Mode 
 (remember that this is the default) or the ""-free"" switch to start in Free Format Mode. 
 2. You may use the ""SOURCEFORMAT AS FIXED"" and ""SOURCEFORMAT AS FREE"" clauses 
 of the "">>SET"" CDF directive (see
  [>>SET], page 49
 ) within your source code to switch 
 to Fixed or Free Format Mode, respectively. 
 3. You may use the "">>FORMAT IS FIXED"" and ""FORMAT IS FREE"" clauses of the 
 "">>DEFINE"" CDF directive (see
  [>>DEFINE], page 45
 ) within your source code to 
 switch to Fixed or Free Format Mode, respectively. 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.17. Program Structure,"Complete GNU COBOL Program Syntax
  
 [ IDENTIFICATION DIVISION. ] 
 ~~~~~~~~~~~~~~~~~~~~~~~ 
 PROGRAM-ID|FUNCTION-ID. 
  
 ~~~~~~~~~~ 
 ~~~~~~~~~~~ [ 
 ENVIRONMENT DIVISION. ] 
  
 ~~~~~~~~~~~ 
 ~~~~~~~~ 
 name-1 [ Program-Options ] . 
 [ CONFIGURATION SECTION. ] 
 ~~~~~~~~~~~~~ ~~~~~~~ 
 [ SOURCE-COMPUTER. 
 Compilation-Computer-Specification . 
 ] 
 ~~~~~~~~~~~~~~~ 
 [ OBJECT-COMPUTER. 
 Execution-Computer-Specification . 
 ] 
 ~~~~~~~~~~~~~~~ 
 [ REPOSITORY. 
 Function-Specification... 
 . 
 ] 
 ~~~~~~~~~~ 
 [ SPECIAL-NAMES. 
 Program-Configuration-Specification . 
 ] 
 ~~~~~~~~~~~~~ 
 [ INPUT-OUTPUT SECTION. ] 
 ~~~~~~~~~~~~ ~~~~~~~ 
 [ FILE-CONTROL. 
 General-File-Description... 
 . 
 ] 
 ~~~~~~~~~~~~ 
 [ I-O-CONTROL. 
 File-Buffering-Specification... 
 . 
 ] 
 ~~~~~~~~~~~ 
 [ DATA DIVISION. ] 
 ~~~~~~~~~~~~~ 
 [ FILE SECTION. 
 Detailed-File-Description... 
 . 
 ] 
 ~~~~~~~~~~~~ 
 [ WORKING-STORAGE SECTION. Permanent-Data-Definition... 
 . 
 ] 
 ~~~~~~~~~~~~~~~ ~~~~~~~ 
 [ LOCAL-STORAGE SECTION. 
 Temporary-Data-Definition... 
 . 
 ] 
 ~~~~~~~~~~~~~ ~~~~~~~ 
 [ LINKAGE SECTION. 
 Subprogram-Argument-Description... 
 . 
 ] 
 ~~~~~~~ ~~~~~~~ 
 [ REPORT SECTION. 
 Report-Description... 
 . 
 ] 
 ~~~~~~ ~~~~~~~ 
 [ SCREEN SECTION. 
 Screen-Layout-Definition... 
 . 
 ] 
 ~~~~~~ ~~~~~~~ 
 PROCEDURE DIVISION [ { USING  
 Subprogram-Argument...  
 } ] 
 ~~~~~~~~~ ~~~~~~~~  
 { ~~~~~  
 } 
 { CHAINING Main-Program-Argument... } 
 ~~~~~~~~ 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.18. Comments,"The following information describes how comments may be imbedded into GNU COBOL 
 program source to provide documentation.",NA
1.3.19. Literals,"Literals are constant values that will not change during the execution of a program. There 
 are two fundamental types of literals — numeric and alphanumeric. 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.19.1. Numeric Literals,"A numeric literal is a numeric constant which may be used as an array subscript, as a value 
 in arithmetic expressions, or in any procedural statement where a numeric value may be 
 used. Numeric literals may take any of the following forms: 
 •
  Integers such as 1, 56, 2192 or -54. 
 •
  Non-integer fixed point values such as 1.317 or -2.95. 
 •
  Floating-point values using ""Enn"" notation such as 9.92E25, representing 9.92 x 10^25 
 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the-
 14th power). Both the mantissa (the number before the E) and the exponent (the 
 number after the E) may be explicitly specified as positive (with a +), negative (with a-) 
 or unsigned (and therefore implicitly positive). A floating-point literal’s value must be 
 within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of 
 precision. 
 •
  Hexadecimal numeric literals such as H""1F"" (31 decimal), h’22’ (34 decimal) or H’DEAD’ 
 (57005 decimal). The H character may either be upper- or lower-case and either single 
 quote (’) or double-quote ("") characters may be used in a hexadecimal literal, provided 
 both aren’t used in the same literal. Hexadecimal numeric literals are limited to a 
 maximum of sixteen hexadecimal digits (a 64-bit value).",NA
1.3.19.2. Alphanumeric Literals,"An alphanumeric literal is a character string suitable for display on a computer screen, 
 printing on a report, transmission through a communications connection or storage in al-
 phanumeric or alphabetic data items. 
 An alphanumeric literal is not valid for use in arithmetic expressions unless it is first con-
 verted to it’s numeric computational equivalent; there are three numeric conversion intrin-
 sic functions built into GNU COBOL that can perform this conversion — ""NUMVAL"" (see 
 [NUMVAL], page 304
 ), ""NUMVAL-C"" (see
  [NUMVAL-C], page 305
 ) and ""NUMVAL-F"" (see 
 [NUMVAL-F], page 306
 ). 
 Alphanumeric literals may take any of the following forms: 
 •
  A sequence of characters enclosed by a pair of single-quote (’) or double-quote ("") 
 characters constitutes a string literal. The double-quote character ("") may be used as a 
 data character within an apostrophe-delimited string literal, and an apostrophe may be 
 used as a data character within a double-quote-delimited string literal. If an apostrophe 
 character must be included as a data character within an apostrophe-delimited string 
 literal, express that character as two consecutive apostrophes (”). If a double-quote 
 character must be included as a data character within a double-quote-delimited string 
 litaral, express that character as two consecutive double-quotes ("""").",NA
1.3.19.3. Figurative Constants,"Figurative constants are reserved words that may be used as literals anywhere the 
 figurative constant’s value could be interpreted as an arbitrarily long sequence of the 
 characters in question. When a specific length is required, such as would be the case with an 
 argument to a subprogram, a figurative constant may not be used. Thus, the following are 
 valid uses of figurative constants: 
 05 FILLER  
 PIC 9(10) VALUE ZEROS. 
  
 ... 
 MOVE SPACES TO Employee-Name 
 But this is not: 
 CALL ""SUBPGM"" USING SPACES 
 The following are the GNU COBOL figurative constants and their respective equivalent 
 values. 
 ""ZERO"" 
 This figurative constant has a value of numeric 0 (zero). ""ZEROS"" and ""ZEROES"" 
 are both synonyms of ""ZERO"". 
 ""SPACE"" 
 This figurative constant has a value of one or more space characters. ""SPACES"" is 
 a synonym of ""SPACE"". 
 ""QUOTE"" 
 This figurative constant has a value of one or more double-quote characters (""). 
 ""QUOTES"" is a synonym of ""QUOTE"". 
 ""LOW-VALUE"" 
 This figurative constant has a value of one or more of whatever character oc-
 cupies the lowest position in the program’s collating sequence as defined in the 
 ""OBJECT-COMPUTER"" (see
  [OBJECT-COMPUTER], page 58
 ) paragraph or — if 
 no such specification was made — in whatever default characterset the 
 program is using (typically, this is the ASCII characterset). ""LOW-VALUES"" is a 
 synonym of ""LOW-VALUE"". 
 When the characterset in use is ASCII with no collating sequence modifications, 
 the ""LOW-VALUES"" figurative constant value is the ASCII ""NUL"" character. 
 Because charactersets can be redefined, however, you should not rely on this 
 fact — use the ""NULL"" figurative constant instead. 
 3 June 2014  
 Chapter 1 - Introduction",NA
1.3.20. Punctuation,"A comma ("","") or a semicolon ("";"") may be inserted into a GNU COBOL program to improve 
 readability at any spot where white space would be legal, except of course within 
 alphanumeric literals (unless you actually
  mean
  for those characters to be part of the al-
 phanumeric literal’s value). These characters are always optional. 
 The use of comma characters can cause confusion to a COBOL compiler if the ""DECIMAL 
 POINT IS COMMA"" clause is used in the ""SPECIAL-NAMES"" (see
  [SPECIAL-NAMES], page 62
 ) 
 paragraph, as might be the case in Europe. The following statement, which calls a 
 subroutine passing it two arguments (the numeric constants 1 and 2): 
 CALL ""SUBROUTINE"" USING 1,2 
 Would — with ""DECIMAL POINT IS COMMA"" in effect — actually be interpreted as a sub-
 routine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 
 tenths). For this reason, it is best to always follow a comma with a space. 
 The period character (""."") is used to terminate statements in the identification, environment 
 and data divisions and sentences in the procedure division. Syntax diagrams describing 
 code in the first three divisions will explicitly show where periods need to occur. 
 The rules for where and when periods are needed in the procedure division are somewhat 
 complicated. See
  [Use of Periods], page 227
 , for the details.",NA
1.3.21. LENGTH OF,"LENGTH OF Syntax
  
 LENGTH OF numeric-literal-1 | identifier-1 
 ~~~~~~ 
 Chapter 1 - Introduction  
 3 June 2014",NA
1.3.22. Interfacing to Other Environments,"Through the ""CALL"" statement, COBOL programs may invoke other COBOL programs serving 
 as subprograms. This is quite similar to cross-program linkage capabilities provided by 
 other languages.  
 In GNU COBOL’s case, the ""CALL"" facility is powerful enough to be 
 tailored to the point where a GNU COBOL program can communicate with operating system, 
 database management and run-time library APIs, even if they weren’t written in COBOL 
 themselves.  
 See
  [GNU COBOL Main Programs CALLing C Subprograms], page 574
 , 
 for an example of how a GNU COBOL program could invoke a C-language subprogram, 
 passing information back and forth between the two. 
 The fact that GNU COBOL supports a full-featured two-way interface with C-language 
 programs means that — even if you cannot access a library API directly — you could always 
 do so via a small C ""wrapper"" program that is ""CALL""ed by a GNU COBOL program. 
 ———————————————————— 
 End of Chapter 1 — Introduction 
 3 June 2014  
 Chapter 1 - Introduction",NA
2. CDF - Compiler Directing Facility,"The Compiler Directing Facility, or CDF, is a means of controlling the compilation of GNU 
 COBOL programs. CDF provides a mechanism for dynamically setting or resetting certain 
 compiler switches, introducing new source code from one or more source code libraries, 
 making dynamic source code modifications and conditionally processing or ignoring source 
 statements altogether. This is accomplished via a series of special CDF statements and 
 directives that will appear in the program source code. 
 When the compiler is operating in Fixed Format Mode, all CDF statements must begin in 
 column eight (8) or beyond. 
 There are two types of supported CDF statements in GNU COBOL — Text Manipulation 
 Statements and Compiler Directives. 
 The CDF text manipulation statements ""COPY"" and ""REPLACE"" are used to introduce new 
 code into programs either with or without changes, or may be used to modify existing 
 statements already in the program. Text manipulation statements are always terminated 
 with a period. 
 CDF directives, denoted by the presence of a "">>"" character sequence as part of the state-
 ment name itself, are used to influence the process of program compilation. 
 Compiler directives are
  never
  terminated with a period. 
 3 June 2014  
 Chapter 2 - CDF - Compiler Directing Facility",NA
2.1. COPY,"CDF COPY Statement Syntax
  
 COPY copybook-name  
 ~~~~  
 [ IN|OF library-name ]  
  
 ~~ ~~  
 [ SUPPRESS PRINTING ]  
  
 ~~~~~~~~ 
 [ REPLACING { Phrase-Clause | String-Clause }... 
 ] 
 . 
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 CDF COPY Phrase-Clause Syntax
  
 { ==pseudo-text-1== } BY { ==pseudo-text-2== } 
 { identifier-1 
 } ~~ { identifier-2 
 } 
 { literal-1 
 } 
 { literal-2 
 } 
 { word-1 
 } 
 { word-2 
 } 
 ———————————————————————————————————————— 
 CDF COPY String-Clause Syntax
  
 [ LEADING|TRAILING ] ==partial-word-1== BY ==partial-word-2== 
  
 ~~~~~~~ ~~~~~~~~  
 ~~ 
 ———————————————————————————————————————— 
 1. ""COPY"" statements are used to import copybooks (see
  [Copybooks], page 10
 ) into a 
 program. 
 2. ""COPY"" statements may be used anywhere within a COBOL program where the code 
 contained within the copybook would be syntactically valid. 
 3. The optional ""SUPPRESS"" clause (with or without the optional ""PRINTING"" reserved 
 word) is valid syntactically but is non-functional. It is supported to facilitate compat-
 ibility with source code written for other versions of COBOL. 
 4. There is no difference between the use of the word ""IN"" and the word ""OF"" — use the one 
 you prefer. 
 5. A period is absolutely mandatory at the end of every ""COPY"" statement, even if the 
 statement occurs within the scope of another one where a period might appear dis-ruptive, 
 such as within the scope of an ""IF"" (see
  [IF], page 397
 ) statement. This 
 Chapter 2 - CDF - Compiler Directing Facility  
 3 June 2014",NA
2.2. REPLACE,"CDF REPLACE Statement (Format 1) Syntax
  
 REPLACE [ ALSO ] { Phrase-Clause | String-Clause }... 
 . 
 ~~~~~~
 ~ 
 ~~~~ 
 ———————————————————————————————————————— 
 CDF REPLACE Statement (Format 2) Syntax
  
 REPLACE [ LAST ] OFF . 
 ~~~~~~
 ~ 
 ~~~~ 
 ~~~ 
 ———————————————————————————————————————— 
 CDF REPLACE Phrase-Clause Syntax
  
 { ==pseudo-text-1== } BY { ==pseudo-text-2 } ~~ 
 ———————————————————————————————————————— 
 CDF REPLACE String-Clause Syntax
  
 [ LEADING|TRAILING ] ==partial-word-1== BY ==partial-word-2== 
  
 ~~~~~~~ ~~~~~~~~  
 ~~ 
 ———————————————————————————————————————— 
 1. The ""REPLACE"" statement provides a mechanism for changing all or part of one or more 
 GNU COBOL statements. 
 2. A period is absolutely mandatory at the end of every ""REPLACE"" statement (either 
 format), even if the statement occurs within the scope of another one where a period 
 might appear disruptive (such as within the scope of an ""IF"" (see
  [IF], page 397
 ) state-
 ment; the period will not, however, affect the statement scope in which the ""REPLACE"" 
 occurs. 
 3. The following points apply to Format 1 of the ""REPLACE"" statement: 
 A. Format 1 of the ""REPLACE"" statement can be used to make changes to program 
 source code in much the same way as the ""REPLACING"" option of the ""COPY"" 
 statement can, via these options: 
 Chapter 2 - CDF - Compiler Directing Facility  
 3 June 2014",NA
2.3.,NA,NA
 >>,NA,NA
DEFINE,"CDF
  >>
 DEFINE Directive Syntax
  
 >>DEFINE [ CONSTANT ] cdf-variable-1 AS { OFF 
 }  
 } 
 ~~~~~~
 ~~ 
 ~~~~~~~~ 
 { ~~~ 
 { literal-1 [ OVERRIDE ] } 
 { 
 ~~~~~~~~ 
 } 
 { PARAMETER [ OVERRIDE ] }  
  
 ~~~~~~~~~ ~~~~~~~~ 
 ———————————————————————————————————————— 
 Use the "">>DEFINE"" CDF directive to create CDF variables and (optionally) assign them 
 either literal or environment variable values. 
 1. The reserved word ""AS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. CDF variables defined in this way become undefined once an ""END PROGRAM"" or ""END 
 FUNCTION"" directive is encountered in the input source. 
 3. The "">>DEFINE"" CDF directive is one way to create CDF variables that may be pro-
 cessed by other CDF statements such as "">>IF"" (see
  [>>IF], page 46
 ). The "">>SET"" CDF 
 directive (see
  [>>SET], page 49
 ) provides another way to create them. 
 4. CDF variable names follow the rules for standard GNU COBOL user-defined names, and 
 may not duplicate any CDF reserved word. CDF variable names may duplicate COBOL 
 reserved words, provided the ""CONSTANT"" option is not specified, but such names are 
 not recommended. 
 5. The ""CONSTANT"" option is valid only in conjunction with <
 literal-1
 >. When 
 ""CONSTANT"" is specified, the CDF variable that is created may be used within your 
 regular COBOL code as if it were a literal value. Without this option, the CDF variable 
 may only be referenced on other CDF statements. The ""OFF"" option is used to create a 
 variable without assigning it any value. 
 6. The ""PARAMETER"" option is used to create a variable whose value is that of the environ-
 ment variable of the same name. Note that this value assignment occurs at compilation 
 time, not program execution time. 
 7. In the absence of the ""OVERRIDE"" option, <
 cdf-variable-1
 > must not yet have been 
 defined. When the ""OVERRIDE"" option is specified, <
 cdf-variable-1
 > will be created 
 with the specified value, if it had not yet been defined. If it had already been defined, it 
 will be redefined with the new value. 
 3 June 2014  
 Chapter 2 - CDF - Compiler Directing Facility",NA
2.4.,NA,NA
 >>,NA,NA
IF,"CDF
  >>
 IF Directive Syntax
  
 >>IF CDF-Conditional-Expression-1 
 ~~~~  
 [ Program-Source-Lines-1 ] 
 [ >>ELIF CDF-Conditional-Expression-2 
 ~~~~~~ [ Program-Source-Lines-2 ] ]... 
 [ >>ELSE 
 ~~~~~~ [ Program-Source-Lines-3 ] ] 
 >>END-IF 
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 CDF-Conditional-Expression Syntax
  
 { cdf-variable-1 } IS [ NOT ] { DEFINED 
 }  
 }  
 }  
 } 
 { literal-1 
 } 
 ~~~ 
 { ~~~~~~~ 
 { SET  
 { ~~~ 
 { CDF-RelOp { cdf-variable-2 } } 
 { 
 { literal-2 
 } } 
 ———————————————————————————————————————— 
 CDF-RelOp Syntax
  
 >= 
 or 
 GREATER THAN OR EQUAL TO 
 > 
 or 
 ~~~~~~~ 
 ~~ ~~~~~ 
 GREATER THAN 
 ~~~~~~~ 
 <= 
 or 
 LESS THAN OR EQUAL TO 
 < 
 or 
 ~~~~ 
 ~~ ~~~~~ 
 LESS THAN 
 ~~~~ 
 = 
 or 
 EQUAL TO 
 ~~~~~ 
 <> 
 or 
 EQUAL TO (with ""NOT"") 
 ~~~~~ 
 ———————————————————————————————————————— 
 Chapter 2 - CDF - Compiler Directing Facility  
 3 June 2014",NA
2.5.,NA,NA
 >>,NA,NA
SET,"CDF
  >>
 SET Directive Syntax
  
 >>SET { [ CONSTANT ] cdf-variable-1 [ AS literal-1 ] } 
 ~~~~~ { 
 ~~~~~~~~ 
 ~~ 
 } 
 { SOURCEFORMAT AS FIXED|FREE 
 } 
 { ~~~~~~~~~~~~ 
 ~~~~~ ~~~~ 
 } 
 { NOFOLDCOPYNAME 
 } 
 { ~~~~~~~~~~~~~~ 
 } 
 { FOLDCOPYNAME AS 
 UPPER|LOWER 
 } 
 ~~~~~~~~~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 The "">>SET"" CDF directive provides an alternate means of performing the actions of the 
 "">>DEFINE"" and "">>SOURCE"" directives, as well as a means of controlling the compiler’s ""-
 free"" switch, ""-fixed"" switch and ""-ffold-copy"" switch from within program source code. 
 1. The reserved word ""AS"" is optional (only on the ""SOURCEFORMAT"" and 
 ""FOLDCOPYNAME"" clauses) and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. CDF variables defined in this way become undefined once an ""END PROGRAM"" or ""END 
 FUNCTION"" directive is encountered in the input source. 
 3. The ""FOLDCOPYNAME"" option provides the equivalent of specifying the compiler ""-ffold-
 copy=xxx"" switch, where ""xxx"" is either ""UPPER"" or ""LOWER"". 
 4. The ""NOFOLDCOPYNAME"" option turns off the effect of either the "">>SET 
 FOLDCOPYNAME"" statement or the compiler ""-ffold-copy=xxx"" switch. 
 5. If the ""CONSTANT"" option is used, <
 literal-1
 > must also be used. This option provides 
 another means of defining constants that may be used anywhere in the program that a 
 literal could be specified. 
 6. The remaining options of the "">>SET"" CDF directive provide equivalent functionality to 
 the "">>DEFINE"" and "">>SOURCE"" directives, as follows: 
 A. "">>SET <
 cdf-variable-1
 >""
  ≡
  "">>DEFINE <
 cdf-variable-1
 > AS OFF"" B. "">>SET <
 cdf-
 variable-1
 > AS <
 literal-1
 >""
  ≡
  "">>DEFINE <
 cdf-variable-1
 > AS <
 literal-1
 >"" 
 C. "">>SET CONSTANT <
 cdf-variable-1
 > AS <
 literal-1
 >"" CONSTANT <
 cdf-variable-1
 > AS 
 <
 literal-1
 >"" 
 ≡
  
 "">>DEFINE 
 D. "">>SET SOURCEFORMAT AS FIXED""
  ≡
  "">>SOURCE FORMAT IS FIXED"" E. 
 "">>SET SOURCEFORMAT AS FREE""
  ≡
  "">>SOURCE FORMAT IS FREE"" 
 3 June 2014  
 Chapter 2 - CDF - Compiler Directing Facility",NA
2.6.,NA,NA
 >>,NA,NA
SOURCE,"CDF
  >>
 SOURCE Directive Syntax
  
 >>SOURCE FORMAT IS FIXED|FREE  
 ~~~~~~~~  
 ~~~~~ 
 ~~~~ 
 ———————————————————————————————————————— 
 The "">>SOURCE"" CDF directive puts the compiler into ""FIXED"" or ""FREE"" source-code 
 format mode. This, in effect, provides yet another mechanism for controlling the compiler’s 
 ""-free"" switch and ""-fixed"" switch. 
 1. The reserved words ""FORMAT"" and ""IS"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. You may switch between ""FIXED"" and ""FREE"" mode as desired. 
 3. You may also use the "">>SET"" CDF directive to perform this function. 
 4. If the compiler is already in the specified mode, this statement will have no effect. 
 Chapter 2 - CDF - Compiler Directing Facility  
 3 June 2014",NA
2.7.,NA,NA
 >>,NA,NA
TURN,"CDF
  >>
 TURN Directive Syntax
  
 >>TURN { exception-name-1 [ file-name-1 ]... 
 }... 
 ~~~~~~ 
 { OFF } 
 { ~~~ } 
 { CHECKING ON [ WITH LOCATION ] } 
 ~~~~~~~~ ~~ ~~~~~~~~ 
 The "">>TURN"" CDF directive is syntactically recognized but is otherwise non-functional. 
 ———————————————————————————————————————— 
 ———————————————————— 
 End of Chapter 2 — CDF - Compiler Directing Facility 
 3 June 2014  
 Chapter 2 - CDF - Compiler Directing Facility",NA
3. IDENTIFICATION DIVISION,"IDENTIFICATION DIVISION Syntax
  
 [ IDENTIFICATION DIVISION. ]  
  
 ~~~~~~~~~~~~~~ ~~~~~~~~  
 { PROGRAM-ID. } program-id [ AS literal-1 ] [ Type-Clause ] . 
 { ~~~~~~~~~~ }  
 { FUNCTION-ID. }  
  
 ~~~~~~~~~~~  
 [ AUTHOR. comment-1. ]  
  
 ~~~~~~  
 [ DATE-COMPILED. comment-2.  
  
  
 ] 
  
 ~~~~~~~~~~~~~  
 [ DATE-WRITTEN. comment-3.  
 ]  
  
 ~~~~~~~~~~~~  
 [ INSTALLATION. comment-4.  
 ]  
  
 ~~~~~~~~~~~~  
 [ REMARKS. comment-5.   ]  
  
 ~~~~~~~  
  
  
  
   ] [ 
 SECURITY. comment-6. 
 ~~~~~~~~ 
 The ""AUTHOR"", ""DATE-COMPILED"", ""DATE-WRITTEN"", ""INSTALLATION"", ""REMARKS"" and 
 ""SECURITY"" paragraphs are supported by GNU COBOL only to provide compatibility with 
 programs written for the ANS1974 (or earlier) standards. As of the ANS1985 standard, 
 these clauses have become obsolete and should not be used in new programs. 
 ———————————————————————————————————————— 
 PROGRAM-ID Type Clause Syntax
  
 IS [ COMMON ] [ INITIAL|RECURSIVE PROGRAM ] 
  
 ~~~~~~  
 ~~~~~~~ ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The identification division provides basic identification of the program by giving it a name 
 and optionally defining some high-level characteristics via the eight pre-defined paragraphs 
 that may be specified. 
 1. The paragraphs shown above may be coded in any sequence. 
 2. The reserved words ""AS"", ""IS"" and ""PROGRAM"" are optional and may be included, or not, 
 at the discretion of the programmer. The presence or absence of these words has no 
 effect upon the program. 
 3 June 2014 
 Chapter 3 - IDENTIFICATION DIVISION",NA
4. ENVIRONMENT DIVISION,"ENVIRONMENT DIVISION Syntax
  
 ENVIRONMENT DIVISION. 
 ~~~~~~~~~~~ ~~~~~~~~ 
 [ CONFIGURATION SECTION. ] 
 ~~~~~~~~~~~~~ ~~~~~~~~ 
 [ SOURCE-COMPUTER. 
 Compilation-Computer-Specification . 
 ] 
 ~~~~~~~~~~~~~~~ 
 [ OBJECT-COMPUTER. 
 Execution-Computer-Specification . 
 ] 
 ~~~~~~~~~~~~~~~ 
 [ REPOSITORY. 
 Function-Specification... 
 . 
 ] 
 ~~~~~~~~~~ 
 [ SPECIAL-NAMES. 
 Program-Configuration-Specification . 
 ] 
 ~~~~~~~~~~~~~ 
 [ INPUT-OUTPUT SECTION. ] 
 ~~~~~~~~~~~~ ~~~~~~~ 
 [ FILE-CONTROL. 
 General-File-Description... 
 . 
 ] 
 ~~~~~~~~~~~~ 
 [ I-O-CONTROL. 
 File-Buffering Specification... 
 . 
 ] 
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This division defines the external computer environment in which the program will be 
 operating. This includes defining any files that the program may be . 
 •
  If both optional sections of this division are coded, they must be coded in the sequence 
 shown. 
 •
  The paragraphs within the sections may be coded in any order. 
 •
  These (""SOURCE-
 COMPUTER""  
 sections 
  
 consist 
 and 
 of a 
 series of 
 specific, 
 pre-defined, 
 paragraphs 
 ""OBJECT-COMPUTER"", for example), each of 
 which 
 serves a specific purpose. If no code is required for the purpose one of the paragraphs 
 serves, the entire paragraph may be omitted. 
 •
  If any of the paragraphs within one of the sections are coded, the section header itself must 
 be coded. 
 •
  If none of the paragraphs within one of the sections are coded, the section header itself may 
 be omitted. 
 •
  If none of the sections within the environment division are coded, the ""ENVIRONMENT 
 DIVISION."" header itself may be omitted.",NA
4.1. CONFIGURATION SECTION,"CONFIGURATION SECTION Syntax
  
 CONFIGURATION SECTION. 
  
 ~~~~~~~~~~~~~ ~~~~~~~  
 [ SOURCE-COMPUTER. Compilation-Computer-Specification .  
 ] 
  
 ~~~~~~~~~~~~~~~  
 [ OBJECT-COMPUTER. Execution-Computer-Specification .  
 ] 
  
 ~~~~~~~~~~~~~~~ 
 [ REPOSITORY. 
 Function-Specification... 
 . 
 ] 
 ~~~~~~~~~~ 
 [ SPECIAL-NAMES. 
 Program-Configuration-Specification . 
 ] 
 ~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This section defines the computer system upon which the program is being compiled and 
 executed and also specifies any special environmental configuration or compatibility char-
 acteristics. 
 1. The four paragraphs in this section may be specified in any order. 
 2. The configuration section is not allowed in a nested subprogram — nested programs will 
 inherit the configuration section settings of their parent program. 
 3. If none of the features provided by the configuration section are required by a program, 
 the entire ""CONFIGURATION SECTION."" header may be omitted from the program. 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.1.1. SOURCE-COMPUTER,"SOURCE-COMPUTER Syntax
  
 SOURCE-COMPUTER. computer-name [ WITH DEBUGGING MODE ] . 
 ~~~~~~~~~~~~~~~  
 ~~~~~~~~~ 
 ~~~~ 
 ———————————————————————————————————————— 
 This paragraph defines the computer upon which the program is being compiled and pro-
 vides one way in which debugging code imbedded within the program may be activated. 
 1. The reserved word ""WITH"" is optional and may be included, or not, at the discretion of 
 the programmer. The presence or absence of this word has no effect upon the program. 
 2. This paragraph is not allowed in a nested subprogram — nested programs will inherit 
 the ""SOURCE-COMPUTER"" settings of their parent program. 
 3. The value specified for <
 computer-name
 > is irrelevant, provided it is a valid COBOL 
 word that does not match any GNU COBOL reserved word. The <
 computer-name
 > value 
 may include spaces. This need not match the <
 computer-name
 > used with the ""OBJECT-
 COMPUTER"" paragraph, if any. 
 4. The ""DEBUGGING MODE"" clause, if present, will inform the compiler that debugging 
 lines (those with a ""D"" in column 7 if Fixed Source Mode is in effect, or those prefixed 
 with a "">>D"" if Free Source Mode is in effect) — normally treated as comments — are 
 to be compiled. 
 5. Even without the ""DEBUGGING MODE"" clause, it is still possible to compile debugging 
 lines. Debugging lines may also be compiled by specifying the ""-fdebugging-line"" switch 
 to the GNU COBOL compiler. 
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
4.1.2. OBJECT-COMPUTER,"OBJECT-COMPUTER Syntax
  
 OBJECT-
 COMPUTER. 
 [ computer-name ] 
 ~~~~~~~~~~~~~~~  
 [ MEMORY SIZE IS integer-1 WORDS|CHARACTERS ] 
  
 ~~~~~~ ~~~~  
 ~~~~~ ~~~~~~~~~~  
 [ PROGRAM COLLATING SEQUENCE IS alphabet-name-1 ] 
  
  
 ~~~~~~~~~  
 [ SEGMENT-LIMIT IS integer-2 ]  
  
 ~~~~~~~~~~~~~  
 [ CHARACTER CLASSIFICATION IS { locale-name-1  
 } ] 
  
  
  
 ~~~~~~~~~~~~~~   
 { 
 LOCALE  
 }   
  
  
  
 { 
 ~~~~~~  }   
  
  
  
 { 
 USER-DEFAULT  
  
 }  
  
  
  
  
 { ~~~~~~~~~~~~ 
  
 }  
  
  
  
  
 { SYSTEM-DEFAULT } 
  
  
  
  
  
  
 ~~~~~~~~~~~~~~ 
 . 
 The ""MEMORY SIZE"" and ""SEGMENT-LIMIT"" clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 This paragraph describes the computer upon which the program will execute. 
 1. The <
 computer-name
 >, if specified, must immediately follow the ""OBJECT-COMPUTER"" 
 paragraph name. The remaining clauses may be coded in any sequence. 
 2. The reserved words ""CHARACTER"", ""IS"", ""PROGRAM"" and ""SEQUENCE"" are optional and 
 may be included, or not, at the discretion of the programmer. The presence or absence 
 of these words has no effect upon the program. 
 3. The value specified for <
 computer-name
 >, if any, is irrelevant provided it is a valid 
 COBOL word that does not match any GNU COBOL reserved word. The <
 computer-
 name
 > may include spaces. This need not match the <
 computer-name
 > used with the 
 ""SOURCE-COMPUTER"" paragraph, if any. 
 4. The ""OBJECT-COMPUTER"" paragraph is not allowed in a nested subprogram — nested 
 programs will inherit the ""OBJECT-COMPUTER"" settings of their parent program. 
 5. The ""COLLATING SEQUENCE"" clause allows you to specify a customized character collat-
 ing sequence to be used when alphanumeric values are compared to one another. Data 
 will still be stored in the characterset native to the computer, but the logical sequence 
 in which characters are ordered for comparison purposes can be altered from that de- 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.1.3. REPOSITORY,"REPOSITORY Syntax
  
 REPOSITORY. 
 ~~~~~~~~~~  
  
 FUNCTION { function-prototype-name-1 [ AS literal-1 ] }... 
 ~~~~~~~~ { 
 ~~ 
 } 
 { intrinsic-function-name-1 [ AS literal-2 ] } {  
  
  
 ~~  
 } { intrinsic-function-
 name-2 INTRINSIC  
 } { ALL INTRINSIC 
  
 ~~~~~~~~~  
  
 }  
 ~~~ ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The REPOSITORY paragraph provides a way to control access to the various built-in intrinsic 
 functions and any user defined functions that your program will be using. 
 1. The ""REPOSITORY"" paragraph is not allowed in a nested subprogram — nested pro-
 grams will inherit the ""REPOSITORY"" settings of their parent program. 
 2. The ""INTRINSIC"" clause allows you to flag one or more (or ""ALL"") built-in intrinsic 
 functions as being usable without the need to code the keyword ""FUNCTION"" in front of 
 the function names. 
 3. As an alternative to using the ""ALL INTRINSIC"" clause, you may instead compile your 
 GNU COBOL programs using the ""-fintrinsics=ALL"" switch. 
 4. The <
 function-prototype-name-1
 > option is required to specify the name of a user-
 defined function your program will be using. Optionally, should you desire, you may 
 specify an alias name by which you will reference that user-defined function. Should 
 you wish, you may also use the ""AS"" clause to provide an alias name for a built-in 
 intrinsic function. 
 5. The following example enables all intrinsic functions to be specified without 
 the use of the ""FUNCTION"" keyword, (2) names two user-defined functions 
 named ""MY-FUNCTION-1"" and ""MY-FUNCTION-2"" that will be used by the program and 
 (3) specifies the alias names ""SIGMA"" for the intrinsic function ""STANDARD-
 DEVIATION"" and ""MF2"" for ""MY-FUNCTION-2"". 
 REPOSITORY. 
 FUNCTION ALL INTRINSIC. 
 FUNCTION MY-FUNCTION-1. 
 FUNCTION MY-FUNCTION-2 AS ""MF2"". 
 FUNCTION STANDARD-DEVIATION AS ""SIGMA"". 
 A special note about user-defined functions
  — because you must name a user-defined func- 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.1.4. SPECIAL-NAMES,"SPECIAL-NAMES Syntax
  
 SPECIAL-NAMES. 
 ~~~~~~~~~~~~~  
 [ CALL-CONVENTION integer-1 IS mnemonic-name-1 ]  
  ~~~~~~~~~~~~~~~  
 [ CONSOLE IS CRT ]  
   
 ~~~~~~~  ~~~  
 [ CRT STATUS IS identifier-1 ]  
   
 ~~~ ~~~~~~  
 [ CURRENCY SIGN IS literal-1 ]  
   
 ~~~~~~~~ ~~~~  
 [ CURSOR IS identifier-2 ]  
   
 ~~~~~~  
 [ DECIMAL-POINT IS COMMA ]  
   
 ~~~~~~~~~~~~~  
 ~~~~~  
 [ EVENT STATUS IS identifier-3 ]  
   
 ~~~~~ ~~~~~~  
 [ LOCALE locale-name-1 IS literal-2 ]... 
  
 ~~~~~~  
 [ NUMERIC SIGN IS TRAILING SEPARATE ]  
  
 ~~~~~~~ ~~~~  ~~~~~~~~ 
 ~~~~~~~~  
 [ SCREEN CONTROL IS identifier-4 ]  
  
 ~~~~~~ ~~~~~~~  
 [ device-name-1 IS mnemonic-name-2 ]... 
 [ feature-name-1 IS mnemonic-name-3 ]... 
 [ Alphabet-Clause ]... 
 [ Class-Definition-Clause ]... 
 [ Switch-Definition-Clause ]... 
 [ Symbolic-Characters-Clause ]...  
 . 
 The ""EVENT STATUS"" and ""SCREEN CONTROL"" clauses are syntactically recognized but are 
 otherwise non-functional. 
 ————————————————————————————————————————
  
  
 <<
 Alphabet-Name-Clause
 >>, <<
 Class-Definition-Clause
 >>,  
  
 <<
 Switch-Definition-Clause
 >> and <<
 Symbolic-Characters-Clause
 >>  
  
  
 are discussed in detail in the next four sections. 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.1.4.1. Alphabet-Name-Clause,"SPECIAL-NAMES Alphabet-Clause Syntax
  
 ALPHABET alphabet-name-1 IS { ASCII 
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 } 
 ~~~~~~~~ 
 { ~~~~~ 
 { EBCDIC  
 { ~~~~~~  
 { NATIVE  
 { ~~~~~~  
 { STANDARD-1  
 { ~~~~~~~~~~  
 { STANDARD-2  
 { ~~~~~~~~~~  
 { Literal-Clause... 
 ———————————————————————————————————————— 
 SPECIAL-NAMES ALPHABET Literal-Clause Syntax
  
 literal-1 [ { THRU|THROUGH literal-2 } ]  
  
 { ~~~~ ~~~~~~~  
 }  
  
 { {ALSO literal-3}...  
 }  
  
 ~~~~ 
 ———————————————————————————————————————— 
 The ""ALPHABET"" clause provides a means for relating a name to a specified character code 
 set or collating sequence, including those you define yourself using the <
 literal-1
 > option. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. GNU COBOL considers ""ASCII"", ""STANDARD-1"" and ""STANDARD-2"" to be interchange-
 able. 
 4. ""NATIVE"" specifies the system default characterset. 
 5. The following points apply to using the <
 literal-n
 > specifications to compose a custom 
 characterset: 
 A. The <
 literal-n
 > values are either integers or alphanumeric quoted characters. These 
 represent a single character in the ""NATIVE"" characterset, either by it’s actual text 
 value (alphanumeric quoted character) or by ordinal position in the ""NATIVE"" 
 characterset (integer), 
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
4.1.4.2. Class-Definition-Clause,"SPECIAL-NAMES Class-Definition-Clause Syntax
  
 CLASS class-name-1 IS { literal-1 [ THRU|THROUGH literal-2 ] }... ~~~~~ 
  
 ~~~~ ~~~~~~~ 
 ———————————————————————————————————————— 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. Both <
 literal-1
 > and <
 literal-2
 > must be alphanumeric literals of length 1. 
 4. The literal(s) specified on this clause define the possible characters that may be found in 
 a data item’s value in order to be considered part of the class. 
 5. For example, the following defines a class called ""Hexadecimal"", the definition of which 
 specifies the only characters that may be present in an alphanumeric data item if that 
 data item is to be part of the ""Hexadecimal"" class: 
 CLASS Hexadecimal IS ’0’ THRU ’9’ 
 ’A’ THRU ’F’ 
 ’a’ THRU ’f’ 
 6. Once class ""Hexadecimal"" has been defined, program code could then use a statement 
 such as ""IF input-item IS Hexadecimal"" to determine if the value of characters in a data 
 item are valid according to that class. 
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
4.1.4.3. Switch-Definition-Clause,"SPECIAL-NAMES Switch-Definition-Clause Syntax
  
 switch-name-1 [ IS mnemonic-name-1 ] 
 [ ON STATUS IS condition-name-1 ]  
 ~~  
 [ OFF STATUS IS condition-name-2 ]  
 ~~~ 
 ———————————————————————————————————————— 
 The switch-definition clause associates a condition-name with a run-time execution switch 
 so that the status of that switch may be tested from within a program. 
 1. The reserved words ""IS"" and ""STATUS"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The valid <
 switch-name-1
 > names are ""SWITCH-n"" (n=0-15). 
 3. If the program is compiled with the ""-fsyntax-extension"" switch, the switch names 
 ""SWn"" (n=0-15) are also valid; they correspond to ""SWITCH-0"" through ""SWITCH-15"", 
 respectively. 
 4. At execution time, each switch will be associated with a ""COB_SWITCH_n"" run-time 
 environment variable (see
  [Run Time Environment Variables], page 522
 ), where ""n"" 
 will have the value ""0"" through ""15"". Any of these sixteen environment variables that 
 have the value ""ON"" (regardless of upper- or lower-case value) will be considered to be 
 set ""on"". Any of these sixteen environment variables having no value at all or a value 
 other than ""ON"" will be considered ""OFF"". 
 5. Each specified switch must have at least one of a ""IS <
 mnemonic-name-1
 >"", ""ON 
 STATUS"" or an ""OFF STATUS"" option defined for it, otherwise there will be no way to 
 reference the switch from within a GNU COBOL program. 
 6. The ""IS <
 mnemonic-name-1
 >"" syntax provides a means for setting the switch to either an 
 ON or OFF value via the ""SET"" statement (see
  [SET], page 445
 ). 
 7. The ""ON STATUS"" and ""OFF STATUS"" syntax provides a way of associating a condition-
 name with either the on or off status of the switch, so that status may be tested at 
 execution time via the ""IF"" statement (see
  [IF], page 397
 ). 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.1.4.4. Symbolic-Characters-Clause,"SPECIAL-NAMES-Symbolic-Characters-Clause Syntax
  
 SYMBOLIC 
 CHARACTERS  
 ~~~~~~~~ 
 { symbolic-character-1... 
 IS|ARE integer-1... 
 }... 
 [ IN alphabet-name-1 ]  
 ~~ 
 ———————————————————————————————————————— 
 This clause may be used to define your own figurative constants. 
 1. The reserved words ""ARE"", ""CHARACTERS"" and ""IS"" are optional and may be included, 
 or not, at the discretion of the programmer. The presence or absence of these words 
 has no effect upon the program. 
 2. There must be exactly as many <
 integer-1
 > values specified as there are <
 symbolic-
 character-1
 > names. 
 3. Each symbolic character name will be associated with the corresponding <
 integer-1
 >th 
 character in the alphabet named in the ""IN"" clause. The integer values are selecting 
 characters from the alphabet by their ordinal position and not by their numeric value; 
 thus, an integer of 15 will select the 15th character in the specified alphabet, regardless 
 of the actual numeric value of the bit pattern that constitutes that character. 
 4. If no <
 alphabet-name-1
 > is specified, the systems native characterset will be assumed. 
 5. The following two code examples define the same set of figurative constant names for 
 five ASCII control characters (assuming that ASCII is the system’s native characterset). 
 The two examples are identical in their effects, even though the manner in which the 
 figurative constants are defined is different. 
 SYMBOLIC CHARACTERS NUL IS 1 
  
 SYMBOLIC CHARACTERS NUL SOH BEL DC1 
 DC2 
  
 SOH IS 2 
  
  
 ARE 
  
 1 
  
 2 
  
 8 
  
 18 19 
  
 BEL IS 8 
  
  
 DC1 IS 18 
  
  
 DC2 IS 19
  
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
4.2. INPUT-OUTPUT SECTION,"INPUT-OUTPUT SECTION Syntax
  
 [ INPUT-OUTPUT SECTION. ]  
  
 ~~~~~~~~~~~~ ~~~~~~~  
 [ FILE-CONTROL. ]  
  
 ~~~~~~~~~~~~  
  
 [ SELECT-Statement...  
 ] 
 [ I-O-CONTROL. ]  
  
 ~~~~~~~~~~~  
  
 [ MULTIPLE-FILE-Statement ] 
 [ SAME-RECORD-Statement ] 
 ———————————————————————————————————————— 
 The ""INPUT-OUTPUT"" section provides for the definition of any files the program will be 
 accessing as well as control of the I/O buffering process against those files through the 
 ""FILE-CONTROL"" and ""I-O-CONTROL"" paragraphs, respectively. 
 1. As the diagram shows, there are three types of statements that may occur in the two 
 paragraphs of this section. If none of the statements are coded in a particular 
 paragraph, the paragraph itself may be omitted, otherwise it is required. 
 2. If neither paragraph is coded, the ""INPUT-OUTPUT SECTION."" header itself may be 
 omitted, otherwise it is normally required. 
 3. If the compiler ""config"" file you are using has ""relaxed-syntax-check"" set to ""yes"", the 
 ""FILE-CONTROL"" and ""I-O-CONTROL"" paragraphs may be specified without the 
 ""INPUT-OUTPUT SECTION."" header having been coded. 
 4. If both statement types are coded in the ""I-O-CONTROL"" paragraph, the order in which 
 those statements are coded is irrelevant. 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.1. SELECT,"SELECT Statement Syntax
  
 SELECT [ [ NOT ] OPTIONAL ] file-name-1 
 ~~~~~~ ~~~ ~~~~~~~~ 
 [ ASSIGN { TO } [{ EXTERNAL }] [{ DISC|DISK  
 }] [{ identifier-1 }] ] 
 ~~~~~~ { USING }  { ~~~~~~~~ }  { ~~~~ ~~~~  
 }  
 { word-1  
 } 
 { DYNAMIC  } { DISPLAY  
 }  
 { literal-1 } 
 ~~~~~~~  
 { ~~~~~~~  
 } 
 { KEYBOARD  
 } 
 { ~~~~~~~~  
 } 
 { LINE ADVANCING } 
 { ~~~~ ~~~~~~~~~ } 
 { PRINTER  
 } 
 { ~~~~~~~  
 } 
 { RANDOM  
 } 
 { ~~~~~~  
 } 
 { TAPE  
 } 
 ~~~~ 
 [ COLLATING SEQUENCE IS alphabet-name-1 ] 
 ~~~~~~~~~ 
 [ FILE|SORT ] STATUS IS identifier-2 [ identifier-3 ] ] 
 ~~~~ ~~~~  ~~~~~~ 
 [ LOCK MODE IS { MANUAL|AUTOMATIC  
 } ] 
 ~~~~ { ~~~~~~ ~~~~~~~~~  
 } 
 { EXCLUSIVE [ WITH { LOCK ON MULTIPLE RECORDS } ] } 
 ~~~~~~~~~  
 { ~~~~ ~~ ~~~~~~~~ ~~~~~~~ } 
 { LOCK ON RECORD  
 } 
 [ ORGANIZATION-Clause ]  
 { ~~~~ ~~ ~~~~~~  
 } 
 { ROLLBACK  
 } 
 [ RECORD DELIMITER IS STANDARD-1 ]  
 ~~~~~~~~ 
 ~~~~~~ ~~~~~~~~~ ~~~~~~~~~~ 
 [ RESERVE integer-1 AREAS ] 
 ~~~~~~~ 
 [ SHARING WITH { ALL OTHER } ] 
 ~~~~~~~ 
 { ~~~ 
 } 
 { NO OTHER } 
 { ~~ 
 } 
 { READ ONLY } 
 .  
 ~~~~ ~~~~ 
 The ""COLLATING SEQUENCE"", ""RECORD DELIMITER"", ""RESERVE"" and ""ALL OTHER"" clauses 
 are syntactically recognized but are otherwise non-functional. 
 ———————————————————————————————————————— 
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
4.2.1.1. ORGANIZATION SEQUENTIAL,"ORGANIZATION SEQUENTIAL Clause Syntax
  
 [ ORGANIZATION|ORGANISATION IS ] RECORD BINARY SEQUENTIAL 
  
 ~~~~~~~~~~~~ ~~~~~~~~~~~~ 
  
 ~~~~~~~~~~  
  
 [ ACCESS 
 MODE IS SEQUENTIAL ]  
  
   
 ~~~~~~  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Files declared as ""ORGANIZATION SEQUENTIAL"" will consist of records with no explicit 
 end-of-record delimiter character sequences; records in such files are ""delineated"" by a 
 calculated byte-offset (based on the maximum record length) into the file. 
 1. The reserved words ""BINARY"", ""IS"", ""MODE"" and ""RECORD"" are optional and may be 
 included, or not, at the discretion of the programmer. The presence or absence of these 
 words has no effect upon the program. 
 2. The reserved words ""ORGANIZATION"" and ""ORGANISATION"" are interchangeable. 
 3. The phrase ""ORGANIZATION IS"" (and it’s internationalized alternative, ""ORGANISATION 
 IS"") is optional to provide compatibility with those (few) COBOL implementations that 
 consider ""ORGANIZATION"" to be optional. Most COBOL implementations do re-quire 
 the word ""ORGANIZATION"", so it should be used in new programs. 
 4. These files cannot be prepared with any standard text-editing or word processing soft-
 ware as all such programs will imbed delimiter characters at the end of records (use 
 ""ORGANIZATION IS LINE SEQUENTIAL"" instead). 
 5. These files may contain either ""USAGE DISPLAY"" or ""USAGE COMPUTATIONAL"" (of any 
 variety) data since no binary data sequence can be accidentally interpreted as an end-
 of-record delimiter. 
 6. While records in a ""ORGANIZATION SEQUENTIAL"" file may be defined as having 
 variable-length records, the file will be structured in such a manner as to reserve space 
 for each record equal to the size of the largest possible record, based on the file’s 
 description in the ""FILE SECTION"". 
 7. The ""ACCESS MODE SEQUENTIAL"" clause is optional because, if absent, it will be as-
 sumed anyway for this type of file. The internal structure of these files is such that they 
 can only be processed in a sequential manner; in order to read the 100th record in such 
 a file, for example, you first must read records 1 through 99. 
 8. Sequential files are processed using the following statements: 
 •
  ""CLOSE"" (see
  [CLOSE], page 364
 ) 
 •
  ""COMMIT"" (see
  [COMMIT], page 365
 ) 
 •
  ""DELETE"" (see
  [DELETE], page 369
 ) 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.1.2. ORGANIZATION LINE SEQUENTIAL,"ORGANIZATION LINE SEQUENTIAL Clause Syntax
  
 [ ORGANIZATION|ORGANISATION IS ] LINE SEQUENTIAL 
  
 ~~~~~~~~~~~~ ~~~~~~~~~~~~  
 ~~~~ 
 ~~~~~~~~~~  
  
 [ ACCESS MODE IS 
 SEQUENTIAL ]  
  
   
 ~~~~~~  
 ~~~~~~~~~~  
  
  [ PADDING CHARACTER IS literal-1 | identifier-1 ]   
  
 ~~~~~~~ 
 The ""PADDING CHARACTER"" clause is 
 syntactically recognized but is 
 otherwise 
 non-functional. 
 ———————————————————————————————————————— 
 Files declared as ""ORGANIZATION LINE SEQUENTIAL"" will consist of records terminated by 
 an end-of-record delimiter character or character sequence. 
 1. The reserved words ""CHARACTER"", ""IS"" and ""MODE"" are optional and may be included, 
 or not, at the discretion of the programmer. The presence or absence of these words 
 has no effect upon the program. 
 2. The reserved words ""ORGANIZATION"" and ""ORGANISATION"" are interchangeable. 
 3. The phrase ""ORGANIZATION IS"" (and it’s internationalized alternative, ""ORGANISATION 
 IS"") is optional to provide compatibility with those (few) COBOL implementations that 
 consider that word to be optional. Most COBOL implementations do require the word 
 ""ORGANIZATION"", so it should be used in new programs. 
 4. This is the only ""ORGANIZATION"" valid for files that are assigned to the ""PRINTER"" 
 device. 
 5. These files may be created with any standard text-editing or word processing software 
 capable of writing text files. Such files should not contain any ""USAGE 
 COMPUTATIONAL"" or ""BINARY"" (of any variety) data since such fields could 
 accidentally contain byte sequences that could be interpreted as an end-of-record 
 delimiter. 
 6. Both fixed- and variable-length record formats are supported. 
 7. The end-of-record delimiter sequence will be X’0A’ (an ASCII line-feed character) or a 
 X’0D0A’ (an ASCII carriage-return + line-feed sequence). The former is used on Unix 
 implementations of GNU COBOL (including Windows/MinGW, Windows/Cygwin and 
 OSX implementations) while the latter would be used with native Windows implemen-
 tations. 
 8. When reading a ""LINE SEQUENTIAL"" file, records in excess of the size implied by the 
 file’s description in the ""FILE SECTION"" will be truncated while records shorter than 
 that size will be padded to the right with ""SPACES"". 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.1.3. ORGANIZATION RELATIVE,"ORGANIZATION RELATIVE Clause Syntax
  
 [ ORGANIZATION|ORGANISATION IS ] RELATIVE 
  
 ~~~~~~~~~~~~ ~~~~~~~~~~~~ 
  
 ~~~~~~~~  
  
 [ ACCESS MODE IS { 
 SEQUENTIAL } ]  
  
   
 ~~~~~~  
 { ~~~~~~~~~~ }  
  
   
  
 { DYNAMIC  
 }  
  
   
  
 { ~~~~~~~  }  
  
   
  
 { RANDOM  
 }  
  
   
  
 ~~~~~~  
  
  [ RELATIVE KEY IS identifier-1 ]  
  
   
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 These files are files with an internal organization such that records may be processed in a 
 sequential manner based upon their physical location in the file or in a random manner by 
 allowing records to be read, written or updated by specifying the relative record number in 
 the file. 
 1. The reserved words ""IS"", ""KEY"" and ""MODE"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The reserved words ""ORGANIZATION"" and ""ORGANISATION"" are interchangeable. 
 3. The phrase ""ORGANIZATION IS"" (and it’s internationalized alternative, ""ORGANISATION 
 IS"") is optional to provide compatibility with those (few) COBOL implementations that 
 consider that word to be optional. Most COBOL implementations do require the word 
 ""ORGANIZATION"", so it should be used in new programs. 
 4. ""ORGANIZATION RELATIVE"" files cannot be assigned to the ""CONSOLE"", ""DISPLAY"", 
 ""LINE ADVANCING"" or ""PRINTER"" devices. 
 5. The ""RELATIVE KEY"" clause is optional only if ""ACCESS MODE SEQUENTIAL"" is specified. 
 6. While an ""ORGANIZATION RELATIVE"" file may be defined as having variable-length 
 records, the file will be structured in such a manner as to reserve space for each record 
 equal to the size of the largest possible record as defined by the file’s description in the 
 ""FILE SECTION"". 
 7. ""ACCESS MODE SEQUENTIAL"", the default ""ACCESS MODE"" if none is specified, indicates 
 that the records of the file will be processed in a sequential manner, according to their 
 physical sequence in the file. 
 8. ""ACCESS MODE RANDOM"" means that records will be processed in random sequence by 
 specifying their record number in the file every time the file is read or written. 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.1.4. ORGANIZATION INDEXED,"ORGANIZATION INDEXED Clause Syntax
  
 [ ORGANIZATION|ORGANISATION IS ] INDEXED  
  
 ~~~~~~~~~~~~ ~~~~~~~~~~~~ 
  
 ~~~~~~~  
  
  [ ACCESS MODE IS { SEQUENTIAL } ] 
 ~~~~~~ 
 { ~~~~~~~~~ 
 } 
 { DYNAMIC 
 } 
 { ~~~~~~~ 
 } 
 { RANDOM 
 } 
  
  
  
 ~~~~~~  
 [ RECORD KEY IS identifier-1  
  
 ~~~~~~  
  
  
 [ =|{SOURCE IS} identifier-2 ] ]  
  
  
  
 ~~~~~~  
 [ ALTERNATE RECORD KEY IS identifier-3  
  
 ~~~~~~~~~ ~~~~~~  
  
  
 [ =|{SOURCE IS} identifier-4 ]  
  
  
  
 ~~~~~~  
  
  
 [ WITH DUPLICATES ] ]... 
 ~~~~~~~~~~ 
 The ""SOURCE"" clause is syntactically recognized but is otherwise non-functional. It is sup-
 ported to provide compatibility with COBOL source written for other COBOL implemen-
 tations. 
 ———————————————————————————————————————— 
 Indexed files, like relative files, may have their records processed in either a sequential or 
 random manner. Unlike relative files, however, the actual location of a record in an indexed 
 file is calculated automatically based upon the value(s) of one or more alphanumeric fields 
 within records of the file. For example, an indexed file containing product data might use 
 the product identification code as a record key. This means you may read, write or update 
 the ""A6G4328""th record or the ""Z8X7723""th record directly, based upon the product id 
 value of those records! 
 1. The reserved words ""IS"", ""KEY"" and ""MODE"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The reserved words ""ORGANIZATION"" and ""ORGANISATION"" are interchangeable. 
 3. The phrase ""ORGANIZATION IS"" (and it’s internationalized alternative, ""ORGANISATION 
 IS"") is optional to provide compatibility with those (few) COBOL implementations that 
 consider that word to be optional. Most COBOL implementations do require the word 
 ""ORGANIZATION"", so it should be used in new programs. 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.2. MULTIPLE FILE,"I-O-CONTROL MULTIPLE FILE Syntax
  
 MULTIPLE FILE TAPE CONTAINS  
 ~~~~~~~~  
  
 { file-name-1 [ POSITION integer-1 ] }... 
  
 ~~~~~~
 ~~  
 . 
 The ""MULTIPLE FILE TAPE"" clause is obsolete and is therefore recognized but not func-
 tional. 
 ———————————————————————————————————————— 
 Chapter 4 - ENVIRONMENT DIVISION 
 3 June 2014",NA
4.2.3. SAME RECORD AREA,"I-O-CONTROL SAME AREA Syntax
  
 SAME { SORT-MERGE } AREA FOR file-name-1... 
 . 
 ~~~~ { 
 ~~~~~~~~~~ }  
  
 { SORT  
 }  
  
 { ~~~~  
 }  
  
 { RECORD  
 }  
  
  
 ~~~~~~ 
 The ""SAME SORT-MERGE"" and ""SAME SORT"" clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 The ""SAME RECORD AREA"" clause allows you to specify that multiple files should share the 
 same input and output memory buffers. 
 1. The reserved words ""AREA"" and ""FOR"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. This statement must be terminated with a period. 
 3. While coding only a single file name (the repeated <
 file-name-1
 > item) is syntactically 
 valid, this statement will have no effect upon the program unless at least two files are 
 specified. 
 4. The effect of this statement will be to cause the specified files to share the same I/O 
 buffer in memory. These buffers can sometimes get quite large, and by having multiple 
 files share the same buffer memory you may significantly cut down the amount of 
 memory the program is using (thus making ""room"" for more procedural code or data). 
 If you do use this feature, take care to ensure that no more than one of the specified 
 files are ever OPEN simultaneously. 
 ————————————————————End of 
 Chapter 4 — ENVIRONMENT DIVISION 
 3 June 2014 
 Chapter 4 - ENVIRONMENT DIVISION",NA
5. DATA DIVISION,"DATA DIVISION Syntax
  
 DATA DIVISION. 
 ~~~~ 
 ~~~~~~~~  
 [ FILE SECTION. 
 ~~~~ ~~~~~~~ 
 { File/Sort-Description [ { FILE-SECTION-Data-Item } ]... 
 }... 
 ] 
 { 
 { 01-Level-Constant 
 } 
 } 
 { 
 { 78-Level-Constant 
 } 
 } 
 { 01-Level-Constant 
 } 
 { 78-Level-Constant 
 } 
 [ WORKING-STORAGE SECTION. 
  
 ~~~~~~~~~~~~~~~ ~~~~~~~  
  
 [ { WORKING-STORAGE-SECTION-Data-Item } ]...  
 ] 
  
 { 01-Level-Constant  
 }  
  
 { 78-Level-Constant  
 }  
 [ LOCAL-STORAGE SECTION. 
  
 ~~~~~~~~~~~~~ ~~~~~~~  
  
 [ { LOCAL-STORAGE-SECTION-Data-Item } ]...  
 ] 
  
 { 01-Level-Constant  
 }  
  
 { 78-Level-Constant  
 }  
 [ LINKAGE SECTION. 
  
 ~~~~~~~ ~~~~~~~  
  
 [ { LINKAGE-SECTION-Data-Item } ]...  
 ] 
  
 { 01-Level-Constant  
 }  
  
 { 78-Level-Constant  
 }  
 [ REPORT SECTION. 
 ~~~~~~ ~~~~~~~ 
 { Report-Description [ { Report-Group-Definition } ]... 
 }... 
 ] 
 { 
 { 01-Level-Constant 
 } 
 } 
 { 
 { 78-Level-Constant 
 } 
 } 
 { 01-Level-Constant 
 } 
 { 78-Level-Constant 
 } 
 [ SCREEN SECTION. 
 ~~~~~~ ~~~~~~~  
 [ { SCREEN-SECTION-Data-Item } ]...  
 ]  
 { 01-Level-Constant  
 }  
 { 78-Level-Constant  
 } 
 ———————————————————————————————————————— 
 All data used by any COBOL program must be defined in one of the six sections of the data 
 division, depending upon the purpose of the data. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.1. Data Definition Principles,"GNU COBOL data items, like those of other COBOL implementations, are described in a 
 hierarchical manner. This accommodates the fact that data items frequently need to be able 
 to be broken up into subordinate items. Take for example, the following logical layout of a 
 portion of a data item named ""Employee"": 
  
 The ""Employee"" data item consists of two subordinate data items — an ""Employee-Name"" 
 and an ""Employment-Dates"" data item (presumably there would be a lot of others too, but 
 we don’t care about them right now). As the diagram shows, each of those data items are, in 
 turn, broken down into subordinate data items. This hierarchy of data items can get rather 
 ""deep"", and GNU COBOL, like other COBOL implementations, can handle up to 49 levels of 
 such hierarchical structures. 
 As was presented earlier (see
  [Structured Data], page 10
 ), a data item that is broken down 
 into other data items is referred to as a group item, while one that isn’t broken down is 
 called an elementary item. 
 COBOL uses the concept of a ""level number"" to indicate the level at which a data item occurs 
 in a data structure such as the example shown above. When these data items are defined, 
 they are all defined together with a number in the range 1-49 specified in front of their 
 names. Over the years, a convention has come to exist among COBOL programmers that 
 level numbers are always coded as two-digit numbers — they don’t
  have
  to be specified as 
 two-digit numbers, but every example you see in this document will take that approach! 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.2. FILE SECTION,"FILE SECTION Syntax
  
 [ FILE SECTION.  
  
 ~~~~ 
 ~~~~~~~ 
 { File/Sort-Description [ { FILE-SECTION-Data-Item } ]... 
 }... 
 ] 
 { 
 { 01-Level-Constant 
 } 
 } 
 { 
 { 78-Level-Constant 
 } 
 } 
 { 01-Level-Constant 
 } 
 { 78-Level-Constant 
 } 
 ———————————————————————————————————————— 
 Every file that has been referenced by a ""SELECT"" statement (see
  [SELECT], page 73
 ) must 
 also be described in the file section of the data division. 
 Files destined for use as sort/merge work files must be described with a Sort/Merge File 
 Description (""SD"") while every other file is described with a File Description (""FD""). Each of 
 these descriptions will almost always be followed with at least one record description. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.2.1. File/Sort-Description,"File/Sort-Description Syntax
  
 FD|SD file-name-1 [ IS EXTERNAL|GLOBAL ]  
 ~~ ~~  
 ~~~~~~~~ ~~~~~~  
 [ BLOCK CONTAINS [ integer-1 TO ] integer-2 CHARACTERS|RECORDS ] 
 ~~~~~ 
 ~~ 
 ~~~~~~~~~~ ~~~~~~~ 
 [ CODE-SET IS alphabet-name-1 ]  
  
 ~~~~~~~~ 
 [ DATA { RECORD IS 
 } identifier-1... 
 ] 
 ~~~~ { ~~~~~~ 
 } 
  
  
  
 { RECORDS ARE }  
  
  
  
   ~~~~~~~  
 [ LABEL { RECORD IS } OMITTED|STANDARD ]  
  
 ~~~~~ { ~~~~~~  
 } ~~~~~~~ ~~~~~~~~  
  
  
  
  { RECORDS ARE }  
  
  
  
    ~~~~~~~  
 [ LINAGE IS integer-3 | identifier-2 LINES  
  
 ~~~~~~  
  
 [ LINES AT BOTTOM integer-4 | identifier-3 ]  
  
  
  
      
 ~~~~~~  
  
 [ LINES AT TOP integer-5 | identifier-4 ]  
  
  
  
      
 ~~~  
  
 [ WITH FOOTING AT integer-6 | identifier-5 ] ]  
  
  
  
    ~~~~~~~  
 [ RECORD { CONTAINS [ integer-7 TO ] integer-8 CHARACTERS  
 } ] 
  
 ~~~~~~ {  
   
  
  
  
 ~~  
 } 
  
  
  
   { IS VARYING IN SIZE  
  
  
 } 
  
  
  
   {  
  
  
 ~~~~~~~    
  
 }  
  
  
  
  
 {   [ FROM [ integer-7 TO ] integer-8 CHARACTERS }  
  
  
  
  {    
   
  
  
 ~~  
 } 
  
  
  
   {  
  
  
  
  DEPENDING ON identifier-6 ]  }  
  
  
  
      
  ~~~~~~~~~  
 [ RECORDING MODE IS recording-mode ]  
  
 ~~~~~~~~~ 
 [ { REPORT IS 
 } report-name-1... 
 ] 
 { ~~~~~~ 
 } 
  
 { REPORTS ARE }  
  
 ~~~~~~~  
 [ VALUE OF implementor-name-1 IS literal-1 | identifier-7 ] . 
 ~~~~~ ~~ 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.2.2. FILE-SECTION-Data-Item,"FILE-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 | FILLER ] [ IS GLOBAL|EXTERNAL ]   
  
  
  
  
 ~~~~~~  
 ~~~~~~ ~~~~~~~~ [ BLANK 
 WHEN ZERO ]  
  
 ~~~~~  
 ~~~~  
 [ JUSTIFIED RIGHT ]  
  
 ~~~~  
 [ OCCURS [ integer-1 TO ] integer-2 TIMES  
  
 ~~~~~~  
  
  
 ~~  
  
  
 [ DEPENDING ON identifier-2 ]  
  
  
  
 ~~~~~~~~~  
  
  
 [ ASCENDING|DESCENDING KEY IS identifier-3 ]  
  
  
  
 ~~~~~~~~~ ~~~~~~~~~~  
  
  
 [ INDEXED BY identifier-4 ] ]  
  
  
  
 ~~~~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ REDEFINES identifier-5 ]  
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE [CHARACTER] ] ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 [ SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
  
 [ USAGE IS data-item-usage ] . 
  
 ~~~~~ 
 [ FILE-SECTION-Data-Item ]... 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 Every sort file description (""SD"" or ""FD"") must be followed by at least one 01-level data 
 item, except for file descriptions containing the ""REPORT IS"" clause. These 01-level data 
 items, in turn, may be broken down into subordinate group and elementary items. An 01-
 level data item defined here in the file section is also known as a ’
 Record
 ’, even if it is an 
 elementary item, provided that elementary item lacks the ""CONSTANT"" attribute. 
 1. The reserved words ""BY"", ""IS"", ""KEY"", ""ON"" and ""WHEN"" are optional and may be 
 included, or not, at the discretion of the programmer. The presence or absence of these 
 words has no effect upon the program. 
 2. The reserved words ""SYNCRONIZED"" and ""SYNCRONIZED"" are interchangeable.  
 Both 
 may be abbreviated to ""SYNC"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.3. WORKING-STORAGE SECTION,"WORKING-STORAGE-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 | FILLER ] [ IS GLOBAL | EXTERNAL ] 
 ~~~~~~ 
 ~~~~~~ 
 ~~~~~~~~ 
 [ BASED ]  
  
 ~~~~~  
 [ BLANK WHEN ZERO ]  
  
 ~~~~~  
 ~~~~  
 [ JUSTIFIED RIGHT ]  
  
 ~~~~  
 [ OCCURS [ integer-1 TO ] integer-2 TIMES  
  
 ~~~~~~  
  
 ~~  
  
 [ DEPENDING ON identifier-2 ]  
  
  
  
 ~~~~~~~~~  
  
 [ ASCENDING|DESCENDING KEY IS identifier-3 ]  
  
  
 ~~~~~~~~~ ~~~~~~~~~~  
  
 [ INDEXED BY identifier-4 ] ]  
  
  
  
 ~~~~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ REDEFINES identifier-5 ]  
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 [ SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
 [ USAGE IS data-item-usage ]  
  
 ~~~~~ 
 [ VALUE IS [ ALL ] literal-1 ] . 
  
 ~~~~~ ~~~ 
 [ WORKING-STORAGE-SECTION-Data-Item ]... 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 The working-storage section is used to describe data items that are not part of files, screens 
 or reports and whose data values persist throughout the execution of the program. 
 1. The reserved words ""BY"", ""CHARACTER"", ""IS"", ""KEY"", ""ON"", ""RIGHT"" (JUSTIFIED), 
 ""TIMES"" and ""WHEN"" are optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of these words has no effect upon the program. 
 2. The reserved words ""SYNCRONIZED"" and ""SYNCRONISED"" are interchangeable.  
 Both 
 may be abbreviated as ""SYNC"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.4. LOCAL-STORAGE SECTION,"LOCAL-STORAGE-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 | FILLER ] [ IS GLOBAL|EXTERNAL ]   
  
  
  
  
 ~~~~~~  
 ~~~~~~ ~~~~~~~~ [ BASED ]  
  
 ~~~~~  
 [ BLANK WHEN ZERO ]  
  
 ~~~~~  
 ~~~~  
 [ JUSTIFIED RIGHT ]  
  
 ~~~~  
 [ OCCURS [ integer-1 TO ] integer-2 TIMES  
  
 ~~~~~~  
  
 ~~  
  
 [ DEPENDING ON identifier-2 ]  
  
  
  
 ~~~~~~~~~  
  
 [ ASCENDING|DESCENDING KEY IS identifier-3 ]  
  
  
  
 ~~~~~~~~~ ~~~~~~~~~~  
  
 [ INDEXED BY identifier-4 ] ]  
  
  
  
 ~~~~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ REDEFINES identifier-5 ]  
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 [ SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
 [ USAGE IS data-item-usage ]  
  
 ~~~~~ 
 [ VALUE IS [ ALL ] literal-1 ] . 
  
 ~~~~~ ~~~ 
 [ LOCAL-STORAGE-SECTION-Data-Item ]... 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 The local-storage section is similar to working-storage, but describes data within a sub-
 program that will be dynamically allocated and initialized (automatically) each time the 
 subprogram is executed. See
  [Data Initialization], page 23
 , for the rules of data ititialization. 
 1. The reserved words ""BY"", ""CHARACTER"" ""IS"", ""KEY"", ""ON"", ""RIGHT"" (JUSTIFIED), 
 ""TIMES"" and ""WHEN"" are optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of these words has no effect upon the program. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.5. LINKAGE SECTION,"LINKAGE-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 | FILLER ] [ IS GLOBAL|EXTERNAL ]   
  
  
  
  
 ~~~~~~  
 ~~~~~~ ~~~~~~~~ [ ANY 
 LENGTH ]  
  
 ~~~ ~~~~~~  
 [ BASED ]  
  
 ~~~~~  
 [ BLANK WHEN ZERO ]  
  
 ~~~~~  
 ~~~~  
 [ JUSTIFIED RIGHT ]  
  
 ~~~~  
 [ OCCURS [ integer-1 TO ] integer-2 TIMES  
  
 ~~~~~~  
  
 ~~  
  
 [ DEPENDING ON identifier-3 ]  
  
  
  
 ~~~~~~~~~  
  
 [ ASCENDING|DESCENDING KEY IS identifier-4 ]  
  
  
  
 ~~~~~~~~~ ~~~~~~~~~~  
  
 [ INDEXED BY identifier-5 ] ]  
  
  
  
 ~~~~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ REDEFINES identifier-6 ]  
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 [ SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
  
 [ USAGE IS data-item-usage ] . 
  
 ~~~~~ 
 [ LINKAGE-SECTION-Data-Item ]... 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ———————————————————————————————————————— 
 The linkage section describes data within a subprogram that serves as either input argu-
 ments to or output results from the subprogram. 
 1. The reserved words ""BY"", ""CHARACTER"", ""IS"", ""KEY"", ""ON"" and ""WHEN"" are optional 
 and may be included, or not, at the discretion of the programmer. The presence or 
 absence of these words has no effect upon the program. 
 2. The reserved words ""SYNCRONIZED"" and """"SYNCRONISED"""" are interchangeable. Both 
 may be abbreviated as ""SYNC"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.6. REPORT SECTION,"REPORT SECTION Syntax
  
 [ REPORT SECTION.  
  
 ~~~~~~ 
 ~~~~~~~ 
 { Report-Description [ { Report-Group-Definition } ]... 
 }... 
 ] 
 { 
 { 01-Level-Constant 
 } 
 } 
 { 
 { 78-Level-Constant 
 } 
 } 
 { 01-Level-Constant 
 } 
 { 78-Level-Constant 
 } 
 ———————————————————————————————————————— 
 Report-Description (RD) Syntax
  
 RD report-name [ IS GLOBAL ]  
 ~~  
 ~~~~~~  
 [ CODE IS literal-1 | identifier-1 ]  
  
 ~~~~ 
 [ { CONTROL IS 
 } { FINAL 
 }... 
 ] 
 { ~~~~~~~ 
 } { ~~~~~ 
 } 
  
 { CONTROLS ARE } { identifier-2 }  
  
 ~~~~~~~~  
 [ PAGE [ { LIMIT IS } ] [ { literal-2  } LINES ]  
  
  
  
  
   
  
  
  
 { identifier-3 } ~~~~ ~~~~   
  
 { ~~~~~  
  
 }   
  
   
 { LIMITS ARE }  
  
  
  
  
  ~~~~~~  
  
  
 [ literal-3 | identifier-4 COLUMNS|COLS ]  
  
  
  
  
   
  
  
  
  
 ~~~~~~~ ~~~~  
  
  
 [ HEADING IS literal-4 | identifier-5 ]  
  
  
  
  
 ~~~~~~~  
  
  
 [ FIRST DE|DETAIL IS literal-5 | identifier-6 ]  
  
  
  
  
 ~~~~~ ~~ ~~~~~~  
  
  
 [ LAST CH|{CONTROL HEADING} IS literal-6 | identifier-7 ]   
  
  
 ~~~~ ~~ ~~~~~~~ ~~~~~~~  
  
  
 [ LAST DE|DETAIL IS literal-7 | identifier-8 ]  
  
  
  
  
 ~~~~ ~~ ~~~~~~  
  
  
 [ FOOTING IS literal-8 | identifier-9 ] ] . 
 ~~~~~~~ 
 The ""CODE IS"" and ""COLUMNS"" clauses are syntactically recognized but are otherwise non-
 functional. 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.6.1. Report Group Definitions,"Report-Group-Definition Syntax
  
 01 [ identifier-1 ] 
 [ LINE NUMBER IS { integer-1 [ [ ON NEXT PAGE ] } ] 
 ~~~~ 
 { 
 ~~~~ 
 ~~~~ 
 } 
 { +|PLUS integer-1 
 } 
 { 
 ~~~~ 
 } 
 { ON NEXT PAGE 
 } 
 ~~~~ ~~~~ 
 [ NEXT GROUP IS { [ +|PLUS ] integer-2  
 } ] 
 ~~~~ ~~~~~  { ~~~~  
 } 
 { NEXT|{NEXT PAGE}|PAGE } 
 ~~~~ ~~~~ ~~~~ ~~~~ 
 [ TYPE IS { RH|{REPORT HEADING}  
 } ] 
 ~~~~  
 { ~~  ~~~~~~ ~~~~~~~  
 } 
 { PH|{PAGE HEADING}  
 } 
 { ~~  ~~~~ ~~~~~~~  
 } 
 { CH|{CONTROL HEADING} FINAL|identifier-2  
 } 
 { ~~  ~~~~~~~ ~~~~~~~  
 ~~~~~  
 } 
 { DE|DETAIL  
 } 
 { ~~ ~~~~~~  
 } 
 { CF|{CONTROL FOOTING} FINAL|identifier-2  
 } 
 { ~~  ~~~~~~~ ~~~~~~~  
 ~~~~~  
 } 
 { PF|{PAGE FOOTING}  
 } 
 { ~~ ~~~~ ~~~~~~~  
 } 
 { RF|{REPORT FOOTING}  
 } 
 ~~  ~~~~~~ ~~~~~~~ 
 .  
 [ REPORT-SECTION-Data-Item ]... 
 ———————————————————————————————————————— 
 The syntax shown here documents how a report group is defined to a report. This syntax 
 is valid only in the report section, and only then after an ""RD"". 
 1. The reserved words ""IS"", ""NUMBER"" and ""ON"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. The ""RH"" and ""REPORT HEADING"" terms are interchangeable, as are ""PH"" and ""PAGE 
 HEADING"", ""CH"" and ""CONTROL HEADING"", ""DE"" and ""DETAIL"", ""CF"" and ""CONTROL 
 FOOTING"", ""PF"" and ""PAGE FOOTING"" as well as ""RF"" and ""REPORT FOOTING"". 
 3. The report group being defined will be a part of the most-recently coded ""RD"". 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.6.2. REPORT SECTION Data Items,"REPORT-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 ] 
 [ BLANK WHEN ZERO ] 
 ~~~~~ ~~~~ 
 [ COLUMN [ { NUMBER IS  
 } ] [ +|PLUS ] integer-1 ] 
 ~~~ { ~~~~~~  
 }  
 ~~~~ 
 { NUMBERS ARE } 
 ~~~~~~~ 
 [ GROUP INDICATE ] 
 ~~~~~ ~~~~~~~~ 
 [ JUSTIFIED RIGHT ] 
 ~~~~ 
 [ LINE NUMBER IS { integer-2 [ [ ON NEXT PAGE ] } ] 
 ~~~~ 
 { +|PLUS integer-2 ~~~~ ~~~~ 
 } 
 { 
 ~~~~ 
 } 
 { ON NEXT PAGE 
 } 
 ~~~~ ~~~~ 
 [ OCCURS [ integer-3 TO ] integer-4 TIMES 
 ~~~~~~  
 ~~ 
 [ DEPENDING ON identifier-2 ] 
 ~~~~~~~~~ 
 [ STEP integer-5 ] 
 ~~~~ 
 [ VARYING identifier-3 FROM { identifier-4 } BY { identifier-5 } ] 
 ~~~~~~~ 
 ~~~~ { integer-6 
 } ~~ { integer-7 
 } 
 [ PICTURE IS picture-string ] 
 ~~~ 
 [ PRESENT WHEN condition-name ] 
 ~~~~~~~ ~~~~ 
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
 ~~~~  
 ~~~~~~~ ~~~~~~~~  
 ~~~~~~~~ 
 [ { SOURCE IS literal-1|identifier-6 [ ROUNDED ]  
 } ] 
 { ~~~~~~  
 ~~~~~~~  
 } 
 { SUM OF { identifier-7 }...  
 [ { RESET ON FINAL|identifier-8 } ] } 
 { ~~~ { literal-2 }  
 { ~~~~~  
 ~~~~~  
 }  
 } 
 { VALUE IS [ ALL ] literal-3  
 { UPON identifier-9  
 }  
 } 
 ~~~~~  
 ~~~ ~~~~ 
 .  
 [ REPORT-SECTION-Data-Item ]... 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.7. SCREEN SECTION,"SCREEN-SECTION-Data-Item Syntax
  
 level-number [ identifier-1 | FILLER ]  
  
 ~~~~~~  
 [ AUTO | AUTO-SKIP | AUTOTERMINATE ] [ BELL | BEEP ] 
 ~~~~ ~~~~~~~~
 ~ 
 ~~~~~~~~~~~
 ~~ 
 ~~~~ 
 ~~~~ 
 [ BACKGROUND-COLOR|BACKGROUND-COLOUR IS integer-1 | identifier-2 ] 
  
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~  
 [ BLANK LINE|SCREEN ] [ ERASE EOL|EOS ]  
  
 ~~~~~ ~~~~ ~~~~~~  ~~~~~ ~~~ ~~~  
 [ BLANK WHEN ZERO ] [ JUSTIFIED RIGHT ] 
 ~~~~~ 
 ~~~~ 
 ~~~~ 
 [ BLINK ] [ HIGHLIGHT | LOWLIGHT ] [ REVERSE-VIDEO ] 
 ~~~~~ 
 ~~~~~~~
 ~~ 
 ~~~~~~~
 ~ 
 ~~~~~~~~~~~~~ 
 [ COLUMN NUMBER IS [ +|PLUS ] integer-2 | identifier-3 ]  
  
 ~~~  
  
 ~~~~  
 [ FOREGROUND-COLOR|FOREGROUND-COLOUR IS integer-3 | identifier-4 ] 
  
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~  
 [ { FROM literal-1 | identifier-5 } ]  
  
 { ~~~~  
  
  
 }  
  
 { TO identifier-5  
  
 }  
  
 { ~~  
  
  
 }  
  
 { USING identifier-5  
  
 }  
  
 { ~~~~~  
  
  
 }  
  
 { VALUE IS [ ALL ] literal-1  
 }  
  
 ~~~~~ ~~~  
 [ FULL | LENGTH-CHECK ] [ REQUIRED | EMPTY-CHECK ] [ SECURE | NO-ECHO ] 
 ~~~~ 
 ~~~~~~~~~~
 ~~ 
 ~~~~~~
 ~~ 
 ~~~~~~~~~
 ~~ 
 ~~~~~~ 
 ~~~~~~~ 
 [ LEFTLINE ] [ OVERLINE ] [ UNDERLINE ] 
 ~~~~~~~
 ~ 
 ~~~~~~~~ 
 ~~~~~~~~~ 
 [ LINE NUMBER IS [ +|PLUS ] integer-4 | identifier-6 ]  
 ~~~~  
  
  ~~~~  
 [ OCCURS integer-5 TIMES ]  
  
 ~~~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ PROMPT [ CHARACTER IS literal-2 | identifier-7 ]  
 ~~~~~~ 
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
  
 ~~~~  
 ~~~~~~~ ~~~~~~~~  
 ~~~~~~~~  
 .   [ SCREEN-SECTION-Data-Item ]... 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.8. Special Data Items,NA,NA
5.8.1. 01-Level Constants,"01-Level-Constant Syntax
  
 01 constant-name-1 CONSTANT [ IS GLOBAL ] 
 ~~~~~~~~ ~~~~~~ 
 { AS { literal-1  
 } } . 
 {  
 { { BYTE-LENGTH } OF { identifier-1 } } } 
 {  
 { { ~~~~~~~~~~~ }  
 { usage-name  
 } } } 
 {  
 { { LENGTH  
 }  
 } } 
 { ~~~~~~  
 } 
 { FROM CDF-variable-name-1  
 } 
 ~~~~ 
 ———————————————————————————————————————— 
 This syntax is valid in the following sections: 
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  SCREEN
  
 The 01-level constant is one of four types of compilation-time constants that can be declared 
 within a program. The other three types are "">>DEFINE"" CDF directive (see
  [>>DEFINE],
  
 page 45
 ) constants, "">>SET"" CDF directive (see
  [>>SET], page 49
 ) constants and 78-level 
 constants (see
  [78-Level Data Items], page 123
 ). 
 1. The reserved words ""AS"", ""IS"" and ""OF"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. See
  [GLOBAL], page 146
 , for information on the ""GLOBAL"" option. 
 3. This particular type of constant declaration provides the ability to determine the length 
 of a data item or the storage size associated with a particular numeric ""USAGE"" (see 
 [USAGE], page 186
 ) type — something not possible with the other types of constants. 
 4. Constants defined in this way become undefined once an ""END PROGRAM"" or ""END 
 FUNCTION"" is encountered in the input source. 
 5. Data descriptions of this form do not actually allocate any storage — they merely 
 define a name (<
 constant-name-1
 >) that may be used anywhere a numeric literal 
 (""BYTE-LENGTH"" or ""LENGTH"" options) or a literal of the same type as <
 literal-1
 > may 
 be used. 
 6. The <
 constant-name-1
 > name may not be referenced on a CDF directive. 
 7. Care must be taken that <
 constant-name-1
 > does not duplicate any other data item 
 name that has been defined in the program as references to that data item name will 
 refer to the constant and not the data item. The GNU COBOL compiler will not issue 
 a warning about this condition. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.8.2. 66-Level Data Items,"66-Level-Data-Item Syntax
  
 66 identifier-1 RENAMES identifier-2 [ THRU|THROUGH identifier-3 ] .  ~~~~~~~ 
  
 ~~~~ ~~~~~~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 A 66-level data item regroups previously defined items by specifying alternative, possibly 
 overlapping, groupings of elementary data items. 
 1. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 2. A level-66 data item cannot rename a level-66, level-01, level-77, or level-88 data item. 
 3. There may be multiple level-66 data items that rename data items contained within the 
 same 01-level record description. 
 4. All ""RENAMES"" entries associated with one logical record must immediately follow that 
 record’s last data description entry. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.8.3. 77-Level Data Items,"77-Level-Data-Item Syntax
  
 77 identifier-1 [ IS GLOBAL|EXTERNAL ]  
  
  
  
 ~~~~~~ ~~~~~~~~  
 [ BASED ]  
  
 ~~~~~  
 [ BLANK WHEN ZERO ]  
  
 ~~~~~ ~~~~  
 [ JUSTIFIED RIGHT ]  
  
 ~~~~  
 [ PICTURE IS picture-string ]  
  
 ~~~  
 [ REDEFINES identifier-5 ]  
  
 ~~~~~~~~~  
 [ SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 [ SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
 [ USAGE IS data-item-usage ]  
  
 ~~~~~  
 [ VALUE IS [ ALL ] literal-1 ] . 
 ~~~~~ ~~~ 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
 WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 The intent of a 77-level item is to be able to create a stand-alone elementary data item. 
 1. The reserved words ""CHARACTER"", ""IS"", ""RIGHT"" (JUSTIFIED) and ""WHEN"" are op-
 tional and may be included, or not, at the discretion of the programmer. The presence 
 or absence of these words has no effect upon the program. 
 2. The reserved word ""JUSTIFIED"" may be abbreviated as ""JUST"", the reserved word 
 ""PICTURE"" may be abbreviated as ""PIC"" and the reserved words ""SYNCRONIZED"" and 
 ""SYNCRONISED"" may be abbreviated as ""SYNC"". 
 3. New programs requiring a stand-alone elementary item should be coded to use a level 
 number of 01 rather than 77. 
 4. See
  [Data Description Clauses], page 125
 , for information on the usage of the various data 
 description clauses. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.8.4. 78-Level Data Items,"78-Level-Constant Syntax
  
 78 constant-name-1 VALUE IS literal-1 .  
  
 ~~~~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  SCREEN
  
 The 78-level constant is one of four types of compilation-time constants that can be 
 declared within a program. The other three types are "">>DEFINE"" CDF directive (see
  
 [>>DEFINE], page 45
 ) constants, "">>SET"" CDF directive (see
  [>>SET], page 49
 ) constants 
 and 01-level constants (see
  [01-Level Constants], page 118
 ). 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. Constants defined in this way become undefined once an ""END PROGRAM"" or ""END 
 FUNCTION"" is encountered in the input source. 
 3. Data descriptions of this form do not actually allocate any storage — they merely define 
 a name (<
 constant-name-1
 >) that may be used anywhere a literal of the same type as 
 <
 literal-1
 > may be used. 
 4. The <
 constant-name-1
 > name may not be referenced on a CDF directive. 
 5. Care must be taken that <
 constant-name-1
 > does not duplicate any other data item name 
 that has been defined in the program as references to that data item name will refer to 
 the constant and not the data item. The GNU COBOL compiler will not issue a warning 
 about this condition. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.8.5. 88-Level Data Items,"88-Level-Data-Item Syntax
  
  88 condition-name-1 { VALUE IS 
  
 { ~~~~~ 
 } {literal-1 [ THRU|THROUGH literal-2 ]}... 
 } 
 ~~~~ ~~~~~~~ 
 { VALUES ARE }  
 ~~~~~~ 
 [ WHEN SET TO FALSE IS literal-3 ] .  
  
 ~~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 Condition names are Boolean (i.e. TRUE / FALSE) data items that receive their TRUE and 
 FALSE values based upon the values of the non 88-level data item whose definition they 
 immediately follow. 
 1. The reserved words ""ARE"", ""IS"", ""SET"" and ""TO"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. Condition names are always defined subordinate to another (non 88-level) data item. 
 That data item must be an elementary item. Whenever the parent data item assumes 
 one of the values specified on the 88-level item’s ""VALUE"" (see
  [VALUE], page 197
 ) 
 clause, <
 condition-name-1
 > will take on the value of TRUE. 
 4. Condition names do not occupy any storage. 
 5. The optional ""THROUGH"" clause allows a range of possible TRUE values to be specified. 
 6. Whenever the parent data item assumes any value
  except
  one of the values specified on 
 <
 condition-name-1
 >’s ""VALUE"" clause, <
 condition-name-1
 > will take on the value of 
 FALSE. 
 7. Executing the statement ""SET <
 condition-name-1
 > TO TRUE"" will cause <
 condition-
 name-1
 >’s parent data item to take on the first value specified on <
 condition-name-1
 >’s 
 ""VALUE"" clause. 
 8. Executing the statement ""SET <
 condition-name-1
 > TO FALSE"" will cause <
 condition-
 name-1
 >’s parent data item to take on the value specified on <
 condition-name-1
 >’s 
 ""FALSE"" clause. If <
 condition-name-1
 > does not have a ""FALSE"" clause, the ""SET"" (see 
 [SET], page 445
 ) statement will generate an error message at compilation time. 
 9. See
  [Condition Names], page 218
 , for more information. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9. Data Description Clauses,NA,NA
5.9.1. ANY LENGTH,"ANY LENGTH Attribute Syntax
  
 ANY 
 LENGTH  
 ~~~ 
 ~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 LINKAGE
  
 Data items declared with the ""ANY LENGTH"" attribute have no fixed compile-time length. 
 Such items may only be defined in the linkage section of a subprogram as they may only 
 serve as subroutine argument descriptions. These items must have a ""PICTURE"" (see
  
 [PICTURE], page 162
 ) clause that specifies exactly one A, X or 9 symbol. 
 1. The ""ANY LENGTH"" and ""BASED"" (see
  [BASED], page 130
 ) clauses cannot be used to-
 gether in the same data item description. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.2. AUTO,"AUTO Attribute Syntax
  
 AUT
 O  
 ~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 A field whose description includes this attribute will cause the cursor to automatically 
 advance to the next input-enabled field of a screen if the field is completely filled with input 
 data. 
 1. The ""AUTO"", ""AUTO-SKIP"" (see
  [AUTO-SKIP], page 127
 ) and ""AUTOTERMINATE"" (see 
 [AUTOTERMINATE], page 128
 ) clauses are interchangeable, and may not be used 
 together in the same data item description. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.3. AUTO-SKIP,"AUTO-SKIP Attribute Syntax
  
 AUTO-SKIP  
 ~~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 A field whose description includes this attribute will cause the cursor to automatically 
 advance to the next input-enabled field of a screen if the field is completely filled with input 
 data. 
 1. The ""AUTO"" (see
  [AUTO], page 126
 ), ""AUTO-SKIP"" and ""AUTOTERMINATE"" (see 
 [AUTOTERMINATE], page 128
 ) clauses are interchangeable, and may not be used 
 together in the same data item description. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.4. AUTOTERMINATE,"AUTOTERMINATE Attribute Syntax
  
 AUTOTERMINA
 TE  
 ~~~~~~~~~
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 A field whose description includes this attribute will cause the cursor to automatically 
 advance to the next input-enabled field of a screen if the field is completely filled with input 
 data. 
 1. The ""AUTO"" (see
  [AUTO], page 126
 ), ""AUTO-SKIP"" (see
  [AUTO-SKIP], page 127
 ) and 
 ""AUTOTERMINATE"" clauses are interchangeable, and may not be used together in the 
 same data item description. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.5. BACKGROUND-COLOR,"BACKGROUND-COLOR Attribute Syntax
  
 BACKGROUND-COLOR|BACKGROUND-COLOUR IS integer-1 | identifier-1 
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause is used to specify the screen background color of the screen data item or the 
 default screen background color of subordinate items if used on a group item. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved words ""BACKGROUND-COLOR"" and ""BACKGROUND-COLOUR"" are 
 interchange-able. 
 3. You specify colors by number (0-7), or by using the constant names provided in the 
 ""screenio.cpy"" copybook (which is provided with all GNU COBOL source distribu-tions). 
 4. Colors may also be specified using a numeric non-edited identifier whose value is in the 
 range 0-7. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.6. BASED,"BASED Attribute Syntax
  
 BASED  
 ~~~~
 ~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
 WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 Data items declared with ""BASED"" are allocated no storage at compilation time. At run-time, 
 the ""ALLOCATE"" (see
  [ALLOCATE], page 356
 ) or ""SET ADDRESS"" (see
  [SET AD-DRESS], 
 page 447
 ) statements are used to allocate space for and (optionally) initialize such items. 
 1. The ""BASED"" and ""ANY LENGTH"" (see
  [ANY LENGTH], page 125
 ) clauses cannot be used 
 together in the same data item description. 
 2. The ""BASED"" clause may only be used on level 01 and level 77 data items. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.7. BEEP,"BEEP Attribute Syntax
  
 BEEP  
 ~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 1. The ""BEEP"" and ""BELL"" (see
  [BELL], page 132
 ) clauses are interchangeable, and may not 
 be used together in the same data item description. 
 2. Use this clause to cause an audible tone to occur when the screen item is DISPLAYed. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.8. BELL,"BELL Attribute Syntax
  
 BELL  
 ~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 1. The ""BEEP"" (see
  [BEEP], page 131
 ) and ""BELL"" clauses are interchangeable, and may not 
 be used together in the same data item description. 
 2. Use this clause to cause an audible tone to occur when the screen item is DISPLAYed. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.9. BLANK,"BLANK Attribute Syntax
  
 BLANK 
 LINE|SCREEN  
 ~~~~~ ~~~~ 
 ~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause will blank out either the entire screen (BLANK SCREEN) or just the line upon 
 which data is about to be displayed (BLANK LINE). 
 1. Blanked-out areas will have their foreground and background colors set to the attributes 
 of the field containing the ""BLANK"" clause. 
 2. This clause is useful when one screen section item is being displayed over the top of a 
 previously-displayed one. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.10. BLANK WHEN ZERO,"BLANK-WHEN-ZERO Attribute Syntax
  
 BLANK WHEN 
 ZERO  
 ~~~~~ ~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 This clause will cause that item’s value to be automatically transformed into spaces if a value 
 of 0 is ever MOVEd to the item. 
 1. The reserved word ""WHEN"" is optional and may be included, or not, at the discretion of 
 the programmer. The presence or absence of this word has no effect upon the program. 
 2. This clause may only be used on a PIC 9 data item with a ""USAGE"" (see
  [USAGE], page 
 186
 ) of ""DISPLAY"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.11. BLINK,"BLINK Attribute Syntax
  
 BLINK  
 ~~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""BLINK"" clause modifies the visual appearance of the displayed field by making the field 
 contents blink. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.12. COLUMN,"COLUMN (REPORT SECTION) Clause Syntax
  
 COLUMN [ { NUMBER IS 
 } ] [ +|PLUS ] integer-1 ] 
 ~~~ 
 { NUMBERS ARE } 
 ~~~~ 
 ———————————————————————————————————————— 
 COLUMN (SCREEN SECTION) Clause Syntax
  
 COLUMN NUMBER IS [ +|PLUS ] integer-2 | identifier-3 ] ~~~ 
  
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
 ,
  SCREEN
  
 The ""COLUMN"" clause provides the means of stating in which column a field should be 
 presented on the console window (screen section) or a report (report section). 
 1. The reserved words ""ARE"", ""IS"", ""NUMBER"" and ""NUMBERS"" are optional and may be 
 included, or not, at the discretion of the programmer. The presence or absence of these 
 words has no effect upon the program. 
 2. The reserved word ""COLUMN"" may be abbreviated as ""COL"". 
 3. The line location of a report section or screen section field will be determined by the 
 ""LINE"" (see
  [LINE], page 153
 ) clause. 
 4. The value of <
 integer-1
 > must be 1 or greater. 
 5. If <
 identifier-1
 > is used to specify either an absolute or relative column position, 
 <
 identifier-1
 > must be defined as a numeric item of any ""USAGE"" (see
  [USAGE], page 
 186
 ) other than ""COMPUTATIONAL-1"" or ""COMPUTATIONAL-2"", without editing 
 symbols. The value of <
 identifier-1
 > at the time the screen data item is presented must 
 be 1 or greater. Note that a ""COMPUTATIONAL-1"" or ""COMPUTATIONAL-2"" identifier 
 will be accepted by the compiler, but will produce unpredictable results at run-time. 
 6. The column coordinate of a field may be stated on an absolute basis (i.e. ""COLUMN 5"") or 
 on a relative basis based upon the end of the previously-presented field (i.e. ""COLUMN 
 PLUS 1""). 
 7. The symbol ""+"" may be used in lieue of the word ""PLUS"", if desired; if symbol ""+"" is used, 
 however, there must be at least one space separating it from <
 integer-1
 >. Failure to 
 include this space will cause the symbol ""+"" sign to be simply treated as part of 
 <
 integer-1
 > and will treat the ""COLUMN"" clause as an absolute column specification 
 rather than a relative one. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.13. CONSTANT,"CONSTANT Attribute Syntax
  
 CONSTAN
 T  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  SCREEN
  
 This option signifies that the 01-level data item in whose declaration ""CONSTANT"" is 
 specified will be treated as a symbolic name for a literal value, useable wherever a literal of 
 the appropriate type could be used. 
 1. The value of a data item defined as a constant cannot be changed at run-time. In fact, it is 
 not syntactically acceptable to use such a data item as the destination field of any 
 procedure division statement that stores a value. 
 2. See
  [01-Level Constants], page 118
 , for additional information. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.14. EMPTY-CHECK,"EMPTY-CHECK Attribute Syntax
  
 EMPTY-
 CHECK  
 ~~~~~~~~
 ~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause forces the user to enter data into the field it is specified on (or into all 
 subordinate input-capable fields if ""EMPTY-CHECK"" is specified on a group item). 
 1. The ""EMPTY-CHECK"" and ""REQUIRED"" (see
  [REQUIRED], page 174
 ) clauses are inter-
 changeable, and may not be used together in the same data item description. 
 2. In order to take effect, the user must first move the cursor into the field having this 
 clause in its definition. 
 3. The 
 ""ACCEPT screen-data-item"" 
 statement (see 
 [ACCEPT
  
 screen-data-item],
  
 page 342
 ) will ignore the Enter key and any other cursor-moving keystrokes that 
 would cause the cursor to move to another screen item
  unless
  data has been entered 
 into the field. Function keys will still be allowed to terminate the ""ACCEPT"". 
 4. In order to be functional, this attribute must be supported by the underlying 
 ’curses’package your GNU COBOL implementation was built with.  
 As of this time, 
 the’PDCurses’ package (used for native Windows or MinGW builds) does not support 
 ""EMPTY-CHECK"". 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.15. ERASE,"ERASE Clause Syntax
  
 ERASE EOL|EOS  
 ~~~~~ ~~~ 
 ~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 ""ERASE"" will blank-out screen contents from the location where the screen data item whose 
 description contains this clause will be displayed, forward until the end of the screen 
 (""ERASE EOS"") or line (""ERASE EOL"") prior to displaying the screen data item. 
 1. Erased areas will have their foreground and background colors set to the attributes of 
 the field containing the ""ERASE"" clause. 
 2. This clause is useful when one screen section item is being displayed over the top of a 
 previously-displayed one. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.16. EXTERNAL,"EXTERNAL Attribute Syntax
  
 EXTERNA
 L  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
  
 This clause marks a data item description, ""FD"" or ""SD"" see
  [File/Sort-Description], page 94 
 as being sharable with other programs executed from the same execution thread. 
 1. By specifying the ""EXTERNAL"" clause on either an FD or an SD, the file description is 
 capable of being shared between all programs executed from the same execution 
 thread, provided an ""EXTERNAL"" clause is coded with the file’s description in
  each
  
 program requiring it. This sharing allows the file to be opened, read and/or written and 
 closed in different programs. This sharing applies to the record descriptions 
 subordinate to the file description too. 
 2. By specifying the ""EXTERNAL"" clause on the description of a data item, the data item is 
 capable of being shared between all programs executed from the same execution 
 thread, provided the data item is coded (with an ""EXTERNAL"" clause) in each program 
 requiring it. 
 3. The following points apply to the specification of ""EXTERNAL"" in a data item’s definition: 
 A. The ""EXTERNAL"" clause may only be specified at the 77 or 01 level. 
 B. An ""EXTERNAL"" item must have a data name and that name cannot be ""FILLER"". 
 C. ""EXTERNAL"" cannot be combined with ""BASED"" (see
  [BASED], page 130
 ), ""GLOBAL"" 
 (see
  [GLOBAL], page 146
 ) or ""REDEFINES"" (see
  [REDEFINES], page 172
 ). 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.17. FALSE,"FALSE Clause Syntax
  
 WHEN SET TO FALSE IS literal-1  
  
 ~~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 This clause, which may only appear on the definition of a level-88 condition name, is used to 
 specify the value of the data item that serves as the parent of the level-88 condition name 
 that will force the condition name to assume a value of FALSE. 
 1. The reserved words ""IS"", ""SET"", ""TO"" and ""WHEN"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. See
  [88-Level Data Items], page 124
 , or See
  [Condition Names], page 218
 , for more 
 information. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.18. FOREGROUND-COLOR,"FOREGROUND-COLOR Attribute Syntax
  
 FOREGROUND-COLOR|FOREGROUND-COLOUR IS integer-1 | identifier-1 
 ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause is used to specify the color of text within a screen data item or the default text 
 color of subordinate items if used on a group item. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved words ""FOREGROUND-COLOR"" and ""FOREGROUND-COLOUR"" are 
 interchange-able. 
 3. You specify colors by number (0-7), or by using the constant names provided in the 
 ""screenio.cpy"" copybook (which is provided with all GNU COBOL source distribu-tions). 
 4. Colors may also be specified using a numeric non-edited identifier whose value is in the 
 range 0-7. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.19. FROM,"FROM Clause Syntax
  
 FROM literal-1 | identifier-5  
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause is used to specify either the data item a screen section field is to obtain it’s value 
 from when the screen is displayed, or a literal that will specify the value of that same field. 
 1. The ""FROM"", ""TO"" (see
  [TO], page 183
 ), ""USING"" (see
  [USING], page 196
 ) and ""VALUE"" 
 (see
  [VALUE], page 197
 ) clauses are mutually-exclusive in any screen section data 
 itsm’s definition. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.20. FULL,"FULL Attribute Syntax
  
 FULL  
 ~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""FULL"" clause forces the user to enter data into the field it is specified on (or into all 
 subordinate input-capable fields if specified on a group item) sufficient to fill every 
 character position of the field. 
 1. The ""FULL"" and ""LENGTH-CHECK"" (see
  [LENGTH-CHECK], page 152
 ) clauses are in-
 terchangeable, and may not be used together in the same data item description. 
 2. In order for this clause to take effect at execution time, the user must move the cursor 
 into the field having this clause in its definition. 
 3. The 
 ""ACCEPT screen-data-item"" 
 statement (see 
 [ACCEPT
  
 screen-data-item],
  
 page 342
 ) will ignore the Enter key and any other cursor-moving keystrokes that 
 would cause the cursor to move to another screen item unless the proper amount of 
 data has been entered into the field. Function keys will still be allowed to terminate the 
 ""ACCEPT"", however. 
 4. In order to be functional, this attribute must be supported by the underlying 
 ’curses’package your GNU COBOL implementation was built with. As of this time, the 
 ’PD-Curses’ package (used for native Windows or MinGW builds) does not support 
 ""FULL"". 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.21. GLOBAL,"GLOBAL Attribute Syntax
  
 GLOBAL  
 ~~~~~
 ~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  REPORT
  
 This clause marks a data item, 01-level constant, ""FD"" (see
  [File/Sort-Description], page 94
 ), 
 ""SD"" (see
  [File/Sort-Description], page 94
 ) or an ""RD"" (see
  [REPORT SECTION], page 107
 ) 
 as being sharable with any nested subprograms. 
 1. By specifying the ""GLOBAL"" clause on the description of a file or a report, that descrip-
 tion is capable of being shared between a program and any nested subprograms within 
 it, provided the ""FD"", ""SD"" or ""RD"" is coded (with a ""GLOBAL"" clause) in each nested 
 subprogram requiring it. This sharing allows the file to be opened, read and/or written 
 and closed or the report to be initiated or terminated in those programs. Separately 
 compiled programs may not share a ""GLOBAL"" file description, but they may share an 
 ""EXTERNAL"" (see
  [EXTERNAL], page 141
 ) file description. This sharing applies to the 
 record descriptions subordinate to the file description and the report groups 
 subordinate to the ""RD"" also. 
 2. By specifying the ""GLOBAL"" clause on the description of a data item, the data item is 
 capable of being shared between a program and any nested subprograms within it, 
 provided the data item is coded (with a ""GLOBAL"" clause) in each program requiring it. 
 3. The following points apply to the specification of ""GLOBAL"" in a data item’s definition: 
 A. The ""GLOBAL"" clause may only be specified at the 77 or 01 level. 
 B. A ""GLOBAL"" item must have a data name and that name cannot be ""FILLER"". 
 C. ""GLOBAL"" cannot be combined with ""EXTERNAL"" (see
  [EXTERNAL], page 141
 ), 
 ""REDEFINES"" (see
  [REDEFINES], page 172
 ) or ""BASED"" (see
  [BASED], page 130
 ). 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.22. GROUP INDICATE,"GROUP-INDICATE Attribute Syntax
  
 GROUP 
 INDICATE  
 ~~~~~ 
 ~~~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 The ""GROUP INDICATE"" clause specifies that the data item in whose definition the clause 
 appears will be presented only in very limited circumstances. 
 1. This clause may only appear within a ""DETAIL"" report group (see
  [TYPE], page 184
 ). 
 2. When this clause is present, the data item in question will be presented only under the 
 following circumstances: 
 A. On the first presentation of the detail group following the ""INITIATE"" (see 
 [INITIATE], page 404
 ) of the report. 
 B. On the first presentation of the detail group after every new page is started. 
 C. On the first presentation of the detail group after any control break occurs. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.23. HIGHLIGHT,"HIGHLIGHT Attribute Syntax
  
 HIGHLIGH
 T  
 ~~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause controls the intensity of text (""FOREGROUND-COLOR"" (see
  [FOREGROUND-
 COLOR], page 143
 )) by setting that intensity to its highest of three possible settings. 
 1. This clause, along with ""LOWLIGHT"" (see
  [LOWLIGHT], page 155
 ), are intended to 
 provide a three-level intensity scheme (""LOWLIGHT"" . . . nothing (Normal) . . . 
 ""HIGHLIGHT""). 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.24. JUSTIFIED,"JUSTIFIED Attribute Syntax
  
 JUSTIFIED RIGHT  
 ~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 The presence of a ""JUSTIFIED RIGHT"" clause in a data item’s definition alters the manner in 
 which data is stored into the field from the default ’left-justified, space filled’ behavior to 
 ’right justified, space filled’. 
 1. The reserved word ""RIGHT"" is optional and may be included, or not, at the discretion of 
 the programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved word ""JUSTIFIED"" may be abbreviated as ""JUST"". 
 3. This clause is valid only on alphabetic (PIC A) or alphanumeric (PIC X) data items. 
 4. The presence or absence of this clause influences the behavior of the ""MOVE"" (see 
 [MOVE], page 414
 ) statement as well as the ""FROM"" (see
  [FROM], page 144
 ), ""SOURCE"" 
 (see
  [SOURCE], page 178
 ) and ""USING"" (see
  [USING], page 196
 ) data item description 
 clauses. 
 5. If the value being stored into the field is the same length as the receiving field, the 
 presence or absence of the ""JUSTIFIED RIGHT"" clause on that field’s description is 
 irrelevant. 
 6. The following examples illustrate the behavior of the presence and absence of the 
 ""JUSTIFIED RIGHT"" clause when the field size is different than that of the value being 
 stored. In these examples, the symbol
  b
  represents a space. 
 When the value is shorter than the field size...
  
 Without JUSTIFIED 
 01 A PIC X(6). 
 With JUSTIFIED 
  
 01 A PIC X(6) JUSTIFIED RIGHT. 
 MOVE ""ABC"" TO A  
 MOVE ""ABC"" TO A 
 Result is ’ABC
 bbb
 ’ 
 Result is ’
 bbb
 ABC’ 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.25. LEFTLINE,"LEFTLINE Attribute Syntax
  
 LEFTLINE  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""LEFTLINE"" clause will introduce a vertical line at the left edge of a screen field. 
 1. The ""LEFTLINE"", ""OVERLINE"" (see
  [OVERLINE], page 161
 ) and ""UNDERLINE"" (see 
 [UNDERLINE], page 185
 ) clauses may be used in any combination in a single field’s 
 description. 
 2. This clause is essentially non-functional when used within Windows command shell 
 (cmd.exe) environments and running programs compiled using a GNU COBOL imple-
 mentation built using ’PDCurses’ (such as Windows/MinGW builds). 
 3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend 
 upon the video attribute capabilities of the terminal output drivers and 
 ’curses’software being used. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.26. LENGTH-CHECK,"LENGTH-CHECK Attribute Syntax
  
 LENGTH-
 CHECK  
 ~~~~~~~~
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""LENGTH-CHECK"" clause forces the user to enter data into the field it is specified on (or 
 into all subordinate input-capable fields if specified on a group item) sufficient to fill every 
 character position of the field. 
 1. The ""FULL"" (see
  [FULL], page 145
 ) and ""LENGTH-CHECK"" clauses are interchangeable, 
 and may not be used together in the same data item description. 
 2. In order for this clause to take effect at execution time, the user must move the cursor 
 into the field having this clause in its definition. 
 3. The 
 ""ACCEPT screen-data-item"" 
 statement (see 
 [ACCEPT
  
 screen-data-item],
  
 page 342
 ) will ignore the Enter key and any other cursor-moving keystrokes that 
 would cause the cursor to move to another screen item unless the proper amount of 
 data has been entered into the field. Function keys will still be allowed to terminate the 
 ""ACCEPT"", however. 
 4. In order to be functional, this attribute must be supported by the underlying 
 ’curses’package your GNU COBOL implementation was built with.  
 As of this time, 
 the’PDCurses’ package (used for native Windows or MinGW builds) does not support 
 ""LENGTH-CHECK"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.27. LINE,"LINE (REPORT SECTION) Clause Syntax
  
 LINE NUMBER IS { integer-2 [ [ ON NEXT PAGE ] } 
 ~~~~ 
 { 
 ~~~~ 
 ~~~~ 
 } 
 { +|PLUS integer-2 
 } 
 { 
 ~~~~ 
 } 
 { ON NEXT PAGE 
 } 
 ~~~~ ~~~~ 
 ———————————————————————————————————————— 
 LINE (SCREEN SECTION) Clause Syntax
  
 [ LINE NUMBER IS [ +|PLUS ] integer-4 | identifier-6 ]  
 ~~~~ 
  
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
 ,
  SCREEN
  
 This clause provides a means of explicitly stating on which line a field should be presented 
 on the console window (screen section) or on a report (report section). 
 1. The reserved words ""IS"", ""NUMBER"" and ""ON"" are optional and may be included, or not, 
 at the discretion of the programmer. The presence or absence of these words has no 
 effect upon the program. 
 2. The following points document the use of format 1 of the ""LINE"" clause: 
 A. The column location of a report item will be determined by the ""COLUMN"" (see 
 [COLUMN], page 136
 ) clause. 
 B. The value of <
 integer-1
 > must be 1 or greater. 
 C. The report line number upon which the data item containing this clause along with 
 any subordinate data items will be presented may be stated on an absolute basis 
 (i.e. ""LINE 5"") or on a relative basis based upon the previously-displayed line (i.e. 
 ""LINE PLUS 1""). 
 D. The symbol ""+"" may be used in lieue of the word ""PLUS"", if desired; if ""+"" is used, 
 however, there must be at least one space separating it from <
 integer-1
 >. Failure 
 to include this space will cause the ""+"" to be simply treated as part of <
 integer-1
 > 
 and will treat the LINE clause as an absolute line specification rather than a 
 relative one. 
 E. The optional ""NEXT PAGE"" clause specifies that — regardless of whether or not the 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.28. LOWLIGHT,"LOWLIGHT Attribute Syntax
  
 LOWLIGH
 T  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""LOWLIGHT"" clause controls the intensity of text (""FOREGROUND-COLOR"") by setting 
 that intensity to its lowest of three possible settings. 
 1. This clause, along with ""HIGHLIGHT"" (see
  [HIGHLIGHT], page 148
 ), are intended to 
 provide a three-level intensity scheme (""LOWLIGHT"" . . . nothing (Normal) . . . 
 ""HIGHLIGHT""). In environments such as a Windows console where only two levels of 
 intensity are supported, ""LOWLIGHT"" is the same as leaving this clause off altogether. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.29. NEXT GROUP,"NEXT-GROUP Clause Syntax
  
 NEXT GROUP IS { [ +|PLUS ] integer-2 
 }  
 } 
 ~~~~ 
 ~~~~~ 
 { 
 ~~~~ 
 { NEXT|{NEXT PAGE}|PAGE } 
 ~~~~ 
 ~~~~ 
 ~~~~ 
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 This clause defines any rules for where the next group to be presented on a report will begin, 
 line-wise, with respect to the
  last
  line of the group in which this clause appears. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The terms ""NEXT"", ""NEXT PAGE"" and ""PAGE"" are interchangeable. 
 3. A report group must contain at least one ""LINE NUMBER"" clause in order to also contain 
 a ""NEXT GROUP"" clause. 
 4. If the ""RD"" (see
  [REPORT SECTION], page 107
 ) in which the report group containing a 
 ""NEXT GROUP"" clause does not contain a ""PAGE LIMITS"" clause, only the ""PLUS 
 integer-1"" option may be specified. 
 5. The ""NEXT PAGE"" option cannot be used in a ""PAGE FOOTING"". 
 6. The ""NEXT GROUP"" option cannot be specified in either a ""REPORT HEADING"" or a 
 ""PAGE HEADING"". 
 7. The effects of ""NEXT GROUP"" will be in addition to any line spacing defined by the next-
 presented group’s ""LINE NUMBER"" clause. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.30. NO-ECHO,"NO-ECHO Attribute Syntax
  
 NO-
 ECHO  
 ~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""NO-ECHO"" clause will cause all data entered into the field to appear on the screen as 
 asterisks. 
 1. The ""NO-ECHO"" and ""SECURE"" (see
  [SECURE], page 176
 ) clauses are interchangeable, 
 and may not be used together in the same data item description. 
 2. This clause may only be used on a field allowing data entry (a field containing either the 
 ""USING"" (see
  [USING], page 196
 ) or ""TO"" (see
  [TO], page 183
 ) clause). 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.31. OCCURS,"OCCURS (REPORT SECTION) Clause Syntax
  
 OCCURS [ integer-1 TO ] integer-2 TIMES  
 ~~~~~~  
 ~~  
  
 [ DEPENDING ON identifier-1 ]  
  
 ~~~~~~~~~  
  
 [ STEP integer-3 ]  
  
 ~~~~  
  
 [ VARYING identifier-2 FROM { identifier-3 } BY { identifier-4 } ] 
 ~~~~~~~ 
 ~~~~ { integer-4 
 } ~~ { integer-5 
 } 
 ———————————————————————————————————————— 
 OCCURS (SCREEN SECTION) Clause Syntax
  
 OCCURS integer-2 TIMES  
 ~~~~~~ 
 ———————————————————————————————————————— 
 OCCURS (All Other Sections Clause Syntax
  
 OCCURS [ integer-1 TO ] integer-2 TIMES  
 ~~~~~~  
  
 ~~  
  
 [ DEPENDING ON identifier-1 ]  
  
  
 ~~~~~~~~~  
  
 [ ASCENDING|DESCENDING KEY IS identifier-5...  
 ]... 
  
 ~~~~~~~~~ 
 ~~~~~~~~~~  
 [ INDEXED BY identifier-6 ]  
  
 ~~~~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 The ""OCCURS"" clause is used to create a data structure called a table, where entries in that 
 structure repeat multiple times. 
 1. The reserved words ""BY"" (INDEXED), ""IS"", ""KEY"", ""ON"" and ""TIMES"" are optional and 
 may be included, or not, at the discretion of the programmer. The presence or absence 
 of these words has no effect upon the program. 
 2. The value of <
 integer-2
 > specifies how many entries will be allocated in the table. 
 3. The following is an example of how a table might be defined: 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.32. OVERLINE,"OVERLINE Attribute Syntax
  
 OVERLIN
 E  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""OVERLINE"" clause will introduce a horizontal line at the top edge of a screen field. 
 1. The ""LEFTLINE"" (see
  [LEFTLINE], page 151
 ), ""OVERLINE"" and ""UNDERLINE"" (see 
 [UNDERLINE], page 185
 ) clauses may be used in any combination in a single field’s 
 description. 
 2. This clause is essentially non-functional when used within Windows command shell 
 (cmd.exe) environments and running programs compiled using a GNU COBOL imple-
 mentation built using ’PDCurses’ (such as Windows/MinGW builds). 
 3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend 
 upon the video attribute capabilities of the terminal output drivers and 
 ’curses’software being used. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.33. PICTURE,"PICTURE Clause Syntax
  
 PICTURE IS picture-string  
 ~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 The picture clause defines the class (numeric, alphabetic or alphanumeric), size and format 
 of the data that may be contained by the data item being defined. Sometimes this role is 
 assisted by the ""USAGE"" (see
  [USAGE], page 186
 ) clause, and in a few instances will be 
 assumed entirely by that clause. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved word ""PICTURE"" may be abbreviated as ""PIC"". Most programmers prefer to 
 use the latter. 
 3. A picture clause may only be specified on an elementary item. 
 4. A <
 picture-string
 > is a sequence of the special symbols ""$"", ""*"", ""+"", "","", ""-"", ""."", ""/"", ""0"" 
 (zero), ""9"", ""A"", ""B"", ""CR"", ""DB"", ""S"", ""V"", ""X"" and ""Z"". 
 5. In general, each picture symbol represents either a single character in storage or a single 
 decimal digit. There are a few exceptions, and they will be discussed as needed. 
 6. When a <
 picture-string
 > contains a repeated sequence of symbols — ""PIC 
 9999/99/99""— for example, the repetition can be specified using a parenthetic repeat 
 count, as in ""PIC 9(4)/9(2)/9(2)"".  
 Using repeat counts is optional and their use (or 
 not) is entirely at the discretion of the programmer. Many programmers use repetition for 
 small sequences (""PIC XXX"") and repeat counts for larger ones (""PIC 9(9)"". 
 7. This first set of picture symbols defines the basic data type of a data item. Each symbol 
 represents a single character’s worth of storage. 
 ""A"" Defines storage reserved for a single alphabetic character (""A""-""Z"", ""a""-""z""). 
 ""N"" Defines storage reserved for a single character in the computer’s ’
 National 
 Characterset
 ’.  
 Support for national charactersets in GNU COBOL is 
 currently only partially implemented, and the compile- and run-time effect of using the 
 ""N"" picture symbol is the same as if ""X(2)"" had been coded, with the additional effect 
 that such a field will qualify as a ""NATIONAL"" or ""NATIONAL-EDITED"" field on an 
 ""INITIALIZE"" (see
  [INITIALIZE], page 399
 ) statement. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.34. PRESENT WHEN,"PRESENT-WHEN Clause Syntax
  
 PRESENT WHEN condition-name  
 ~~~~~~~ ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 This clause names an existing ""Condition Name"" (see
  [Condition Names], page 218
 ) that will 
 serve as a switch controlling the presentation or suppression of a report group. 
 1. If the specified condition-name has a value of FALSE when a ""GENERATE"" statement 
 (see
  [GENERATE], page 391
 ) causes a report group to be presented, the presentation of 
 that group will be suppressed. 
 2. If the condition-name has a value of TRUE, the group will be presented. 
 3. See
  [Condition Names], page 218
 , for more information. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.35. PROMPT,"PROMPT Clause Syntax
  
 PROMPT [ CHARACTER IS literal-1 | identifier-1 ] 
 ~~~~~~  ~~~~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause defines the character that will be used as the fill-character for any input fields on 
 the screen. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The default prompt character, should no ""CHARACTER"" specification be coded, or should 
 the ""PROMPT"" clause be absent altogether, is an underscore ("" ""). 
 3. Prompt characters will be automatically transformed into spaces upon input. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.36. REDEFINES,"REDEFINES Clause Syntax
  
 REDEFINES identifier-1  
 ~~~~~~~~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 The ""REDEFINES"" clause causes the data item in who’s definition the ""REDEFINES"" clause is 
 specified (hereafter referred to as the redefines object) to occupy the same physical storage 
 space as <
 identifier-1
 > (hereafter referred to as the redefines subject). 
 1. The following rules must all be followed in order to use REDEFINES: 
 A. The level number of both the subject and object data items must be the same. 
 B. The level numbers of both the subject and object data items cannot be 66, 78 or 88. 
 C. If ""n"" represents the level number of the object, then no other data items with level 
 number ""n"" may be defined between the subject and object data items unless they 
 too are ""REDEFINES"" of the subject. 
 D. If ""n"" represents the level number of the object, then no other data items with a 
 level number numerically less than ""n"" may be defined between the subject and 
 object data items. 
 E. The total allocated size of the subject data item must be the same as the total 
 allocated size of the object data item. 
 F. No ""OCCURS"" (see
  [OCCURS], page 158
 ) clause may be part of the definition of 
 either the subject or object data items. Either or both, however, may be group 
 items that
  contain
  data items with ""OCCURS"" clauses. 
 G. No ""VALUE"" (see
  [VALUE], page 197
 ) clause may be defined on the object data item, 
 and no data items subordinate to the object data item may have ""VALUE"" clauses, 
 with the exception of level-88 condition names. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.37. RENAMES,"RENAMES Clause Syntax
  
 RENAMES identifier-1 [ THRU|THROUGH identifier-2 
 ~~~~~~~  
 ~~~~ ~~~~~~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 The ""RENAMES"" clause regroups previously defined items by specifying alternative, possibly 
 overlapping, groupings of elementary data items. 
 1. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 2. You must use the level number 66 for data description entries that contain the 
 ""RENAMES"" clause. 
 3. The <
 identifier-1
 > and <
 identifier-2
 > data items, along with all data items defined 
 between those two data items in the program source, must all be contained within the 
 same 01-level record description. 
 4. See
  [66-Level Data Items], page 121
 , for additional information on the RENAMES clause. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.38. REQUIRED,"REQUIRED Attribute Syntax
  
 REQUIRE
 D  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause forces the user to enter data into the field it is specified on (or into all 
 subordinate input-capable fields if ""REQUIRED"" is specified on a group item). 
 1. The ""EMPTY-CHECK"" (see
  [EMPTY-CHECK], page 139
 ) and ""REQUIRED"" clauses are 
 interchangeable, and may not be used together in the same data item description. 
 2. In order to take effect, the user must first move the cursor into the field having this 
 clause in its definition. 
 3. The 
 ""ACCEPT screen-data-item"" 
 statement (see 
 [ACCEPT
  
 screen-data-item],
  
 page 342
 ) will ignore the Enter key and any other cursor-moving keystrokes that 
 would cause the cursor to move to another screen item
  unless
  data has been entered 
 into the field. Function keys will still be allowed to terminate the ""ACCEPT"". 
 4. In order to be functional, this attribute must be supported by the underlying 
 ’curses’package your GNU COBOL implementation was built with.  
 As of this time, 
 the’PDCurses’ package (used for native Windows or MinGW builds) does not support 
 ""REQUIRED"". 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.39. REVERSE-VIDEO,"REVERSE-VIDEO Attribute Syntax
  
 REVERSE-
 VIDEO  
 ~~~~~~~~~
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""REVERSE-VIDEO"" attribute swaps the specified or implied ""FOREGROUND-COLOR"" 
 (see 
 [FOREGROUND-COLOR], page 143
 ) and ""BACKGROUND-COLOR"" (see
  [BACKGROUND-
 COLOR], page 129
 ) attributes for the field whose definition contains this clause (or all 
 subordinate fields if used on a group item). 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.40. SECURE,"SECURE Attribute Syntax
  
 SECURE  
 ~~~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause will cause all data entered into the field to appear on the screen as asterisks. 
 1. The ""NO-ECHO"" (see
  [NO-ECHO], page 157
 ) and ""SECURE"" clauses are interchangeable, 
 and may not be used together in the same data item description. 
 2. This clause may only be used on a field allowing data entry (a field containing either the 
 ""USING"" (see
  [USING], page 196
 ) or ""TO"" (see
  [TO], page 183
 ) clause). 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.41. SIGN IS,"SIGN-IS Clause Syntax
  
 SIGN IS LEADING|TRAILING [ SEPARATE CHARACTER ] 
 ~~~~ 
 ~~~~~~~ 
 ~~~~~~~~ 
 ~~~~~~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 This clause, allowable only for ""USAGE DISPLAY"" numeric data items, specifies how an ""S"" 
 symbol will be interpreted in a data item’s picture clause. 
 1. The reserved words ""CHARACTER"" and ""IS"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2.
  Without
  the ""SEPARATE CHARACTER"" option, the sign of the data item’s value will be 
 encoded by transforming the last (""TRAILING"") or first (""LEADING"") digit as follows: 
 First/Last Digit
  
 Value For Positive
  
 Value for Negative
  
 0 
 0 
 p 
 1 
 1 
 q 
 2 
 2 
 r 
 3 
 3 
 s 
 4 
 4 
 t 
 5 
 5 
 u 
 6 
 6 
 v 
 7 
 7 
 w 
 8 
 8 
 x 
 9 
 9 
 y 
 3. If the ""SEPARATE CHARACTER"" clause
  is
  used, then an actual ""+"" or ""-"" character will be 
 inserted into the field’s value as the first (""LEADING"") or last (""TRAILING"") character. 
 Note that having this character imbedded within the data item’s storage does not 
 prevent the data item from being used as a source field in arithmetic operations. 
 4. When ""SEPARATE CHARACTER"" is specified, the ""S"" symbol in the data item’s ""PICTURE"" 
 must be counted when determining the data item’s size. 
 5. Neither the presence of an encoded digit (see above) nor an actual ""+"" or ""-"" character 
 imbedded within the data item’s storage prevents the data item from being used as a 
 source field in arithmetic operations. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.42. SOURCE,"SOURCE Clause Syntax
  
 SOURCE IS literal-1 | identifier-1 [ ROUNDED ] 
 ~~~~~~ 
  
 ~~~~~~
 ~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 This clause logically attaches a report section data item to another data item defined else-
 where in the data division. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. When the report group containing this clause is presented, the value of the specified 
 numeric literal or identifier will be automatically moved to the report data item prior 
 to presentation. 
 3. The specified identifier may be defined anywhere in the data division, but if it is defined 
 in the report section it may only be ""PAGE-COUNTER"", ""LINE-COUNTER"" or a ""SUM"" 
 (see 
 [SUM], page 326
 ) counter. 
 4. The ""PICTURE"" (see
  [PICTURE], page 162
 ) of the report data item must be such that it 
 would be legal to ""MOVE"" (see
  [MOVE], page 414
 ) the specified literal or identifier to a 
 data item with that ""PICTURE"". 
 5. The ""ROUNDED"" option comes into play should the number of digits to the right of an 
 actual or assumed decimal point be different between the specified literal or identifier 
 value (the ""source value"") and the ""PICTURE"" specified for the field in whose definition 
 the ""SOURCE"" clause appears (the ""target field"").
  Without
  ""ROUNDED"", excess digits in 
 the source value will simply be truncated to fit the target field.
  With
  ""ROUNDED"", the 
 source value will be arithmetically rounded to fit the target field. See
  [ROUNDED], page 
 240
 , for information on the ""NEAREST-AWAY-FROM-ZERO"" rounding rule, which is the 
 one that will apply. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.43. SUM OF,"SUM-OF Clause Syntax
  
 SUM OF { identifier-7 }... 
 [ { RESET ON FINAL|identifier-8 } ] 
 ~~~ 
 { literal-2 
 } 
 { ~~~~~ 
 ~~~~~ 
 } 
 { UPON identifier-9 
 } 
 ~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 The ""SUM"" clause establishes a summation counter whose value will be arithmetically cal-
 culated whenever the field is presented. 
 1. The reserved words ""OF"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The ""SUM"" clause may only appear in a ""CONTROL FOOTING"" report group. 
 3. If the data item in which the ""SUM"" clause appears has been assigned it’s own identifier 
 name, and that name is not ""FILLER"", then that data item is referred to as a sum 
 counter. 
 4. All <
 identifier-7
 > data items must be non-edited numeric in nature. 
 5. If any <
 identifier-7
 > data item is defined in the report section, it must be a sum counter. 
 6. Any <
 identifier-7
 > data items that are sum counters must either be defined in the same 
 report group as the data item in which this ""SUM"" clause appears or they must be 
 defined in a report data item that exists at a lower level in this report’s control 
 hierarchy. See
  [Control Hierarchy], page 488
 , for additional information. 
 7. The ""PICTURE"" of the report data item in who’s description this ""SUM"" clause appears in 
 must be such that it would be legal to ""MOVE"" (see
  [MOVE], page 414
 ) the specified 
 <
 identifier-7
 > or <
 literal-2
 > value to a data item with that ""PICTURE"". 
 8. The following points apply to the ""UPON"" option: 
 A. The data item <
 identifier-9
 > must be the name of a detail group specified in the same 
 report as the control footing group in which this ""SUM"" clause appears. 
 B. The presence of an ""UPON"" clause limits the ""SUM"" clause to adding the specified 
 numeric literal or identifier value into the sum counter only when a ""GENERATE 
 <
 identifier-9
 >"" statement is executed. 
 C. If there is no ""UPON"" clause specified, the value of <
 identifier-7
 > or <
 literal-2
 > will 
 be added into the sum counter whenever a ""GENERATE"" (see
  [GENERATE], page 
 391
 ) of any detail report group in the report is executed. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.44. SYNCRONIZED,"SYNCRONIZED Syntax
  
 SYNCRONIZED|SYNCHRONISED [ LEFT|RIGHT ] 
 ~~~~ 
 ~~~~ 
 ~~~~ ~~~~~ 
 The ""LEFT"" and ""RIGHT"" (SYNCRONIZED) clauses are syntactically recognized but are 
 otherwise non-functional. 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
  
 This optional clause optimizes the storage of binary numeric items to store them in such a 
 manner as to make it as fast as possible for the CPU to fetch them. 
 1. The reserved words ""SYNCRONIZED"" and ""SYNCHRONISED"" are interchangeable, and 
 may be abbreviated as ""SYNC"". 
 2. If the ""SYNCRONIZED"" clause is coded on anything but a numeric data item with a 
 ""USAGE"" (see
  [USAGE], page 186
 ) that specifies storage of data in a binary form, the 
 ""SYNCRONIZED"" clause will be ignored. 
 3. Synchronization is performed (by the compiler) as follows: 
 A. If the binary item occupies one byte of storage, no synchronization is performed. 
 B. If the binary item occupies two bytes of storage, the binary item is allocated at the 
 next half-word boundary. 
 C. If the binary item occupies four bytes of storage, the binary item is allocated at the 
 next word boundary. 
 D. If the binary item occupies four bytes of storage, the binary item is allocated at the 
 next word boundary. 
 The following illustrates the allocation of a group of data items both without and with the 
 ""SYNCRONIZED"" option. The grey blocks represent the unused bytes that are allocated in 
 the Group-Item-2 structure because of the ""SYNC"" clauses. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.45. TO,"TO Clause Syntax
  
 TO identifier-5  
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause logically attaches a screen section data item to another data item defined else-
 where in the data division. 
 1. The ""TO"" clause is used to define a data-entry field with no initial value; when a value is 
 entered, it will be saved to the specified identifier. 
 2. The ""FROM"" (see
  [FROM], page 144
 ), ""TO"", ""USING"" (see
  [USING], page 196
 ) and 
 ""VALUE"" (see
  [VALUE], page 197
 ) clauses are mutually-exclusive in any screen section 
 data itsm’s definition. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.46. TYPE,"TYPE Clause Syntax
  
 [ TYPE IS { RH|{REPORT HEADING} 
 } ]  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 } 
 ~~~~ 
 { ~~ 
 ~~~~~~ ~~~~~~~ 
 { PH|{PAGE HEADING} 
 { ~~ 
 ~~~~ ~~~~~~~ 
 { CH|{CONTROL HEADING} FINAL|identifier-2 
 { ~~ 
 ~~~~~~~ 
 ~~~~~~~ 
 ~~~~~ 
 { 
 DE|DETAIL  
 { 
 ~~ 
 ~~~~~~  
 { CF|{CONTROL FOOTING} FINAL|identifier-2 
 { ~~ 
 ~~~~~~~ 
 ~~~~~~~ 
 ~~~~~ 
 { PF|{PAGE FOOTING} 
 { 
 ~~ ~~~~ ~~~~~~~ 
 { RF|{REPORT FOOTING} 
 ~~ 
 ~~~~~~ ~~~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 REPORT
  
 This clause defines the type of report group that is being defined for a report. 
 1. This clause is required on any 01-level data item definitions (other than 01-level con-
 stants) in the report section. This clause is invalid on any other report section data item 
 definitions. 
 2. There may be a maximum of one (1) report group per ""RD"" defined with a ""TYPE"" of 
 ""REPORT HEADING"", ""PAGE HEADING"", ""PAGE FOOTING"" and ""REPORT FOOTING"". 
 3. There must be either a ""CONTROL HEADING"" or a ""CONTROL FOOTING"" or both 
 specified for each entry specified on the ""CONTROLS ARE"" clause of the ""RD"". 
 4. The various report groups that constitute a report may be defined in any order. 
 5. See
  [RWCS Lexicon], page 483
 , for a description of the seven different types of report 
 groups. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.47. UNDERLINE,"UNDERLINE Attribute Syntax
  
 UNDERLIN
 E  
 ~~~~~~~
 ~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 The ""UNDERLINE"" clause will introduce a horizontal line at the bottom edge of a screen field. 
 1. The ""LEFTLINE"" (see
  [LEFTLINE], page 151
 ), ""OVERLINE"" (see
  [OVERLINE], page 161
 ) 
 and ""UNDERLINE"" clauses may be used in any combination in a single field’s description. 
 2. This clause is essentially non-functional when used within Windows command shell 
 (cmd.exe) environments and running programs compiled using a GNU COBOL imple-
 mentation built using ’PDCurses’ (such as Windows/MinGW builds). 
 3. Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend 
 upon the video attribute capabilities of the terminal output drivers and 
 ’curses’software being used. 
 See
  [Color Palette and Video Attributes], page 20
 , for more information on screen colors and 
 video attributes. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
5.9.48. USAGE,"USAGE Clause Syntax
  
 USAGE IS data-item-usage  
 ~~~~~ 
 ————————————————————————————————————————
  
  
 This syntax is valid in the following sections:  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
  
 The ""USAGE"" clause defines the format that will be used to store the value of a data item. 
 1. The reserved word ""IS"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The following table summarizes the various USAGE specifications available in GNU 
 COBOL. 
 BINAR
 Y  
 ~~~~
 ~~ 
 Range of Values: 
 Storage Format: 
 Negative Values Allowed?: 
 Defined by the quantity of ""9""s and the presence 
 or absence of an ""S"" in the ""PICTURE"" 
 Compatible Binary Integer 
 If ""PICTURE"" contains ""S"" 
 ""PICTURE"" Used?:  
 Yes 
 BINARY-C-LONG [ SIGNED ] 
 ~~~~~~~~~~~~~ 
 Same as ""BINARY-DOUBLE SIGNED"" 
 BINARY-C-LONG UNSIGNED 
 ~~~~~~~~~~~~~ ~~~~~~~~ 
 Range of Values:  
 Storage Format: 
 Typically 0 to 4,294,967,295  
 Native Binary Integer 
 Negative Values Allowed?: 
 No 
 3 June 2014 
 ""PICTURE"" Used?: 
 No 
 Chapter 5 - DATA DIVISION",NA
5.9.49. USING,"USING Clause Syntax
  
 USING identifier-1  
 ~~~~~ 
 ————————————————————————————————————————
  
 This syntax is valid in the following sections:  
  
  
 SCREEN
  
 This clause logically attaches a screen section data item to another data item defined else-
 where in the data division. 
 1. When the screen item whose definition this clause is part of is displayed, the value 
 currently in <
 identifier-1
 > will be automatically moved into the screen item first. 
 2. When the screen item whose definition this clause is part of (or its parent) is accepted, 
 the current contents of the screen item will be saved back to <
 identifier-1
 > at the 
 conclusion of the ""ACCEPT"". 
 3. The ""FROM"" (see
  [FROM], page 144
 ), ""TO"" (see
  [TO], page 183
 ), ""USING"" and ""VALUE"" 
 (see
  [VALUE], page 197
 ) clauses are mutually-exclusive in any screen section data 
 itsm’s definition. 
 Chapter 5 - DATA DIVISION  
 3 June 2014",NA
5.9.50. VALUE,"VALUE (Condition Names) Clause Syntax
  
 { VALUE IS { 
 ~~~~~ 
 } {literal-1 [ THRU|THROUGH literal-2 ]}... 
 } 
 ~~~~ ~~~~~~~ 
 { VALUES ARE }  
  
 ~~~~~~ 
 ———————————————————————————————————————— 
 VALUE (Other Data Items) Syntax
  
 VALUE IS [ ALL ] literal-1  
 ~~~~~ ~~~ 
 ————————————————————————————————————————
   
 This syntax is valid in the following sections:  
  
 FILE
 ,
  WORKING-STORAGE
 ,
  LOCAL-STORAGE
 ,
  LINKAGE
 ,
  REPORT
 ,
  SCREEN
  
 The ""VALUE"" clause is used to define condition names or to assign values (at compilation 
 time) to data items. 
 1. The reserved words ""ARE"" and ""IS"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. This clause cannot be specified on the same data item as a ""FROM"" (see
  [FROM], page 
 144
 ), ""TO"" (see
  [TO], page 183
 ) or ""USING"" (see
  [USING], page 196
 ) clause. 
 3. The following points apply to using the ""VALUE"" clause in the definition of a condition 
 name: 
 A. The clauses ""VALUE IS"" and ""VALUES ARE"" are interchangeable. 
 B. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 C. See
  [88-Level Data Items], page 124
 , for a discussion of how this format of ""VALUE"" 
 is used to create condition names. 
 D. See
  [Condition Names], page 218
 , for a discussion of how condition names are used. 
 4. The following points apply to using the ""VALUE"" clause in the definition of any other data 
 item: 
 A. In this context, ""VALUE"" specifies an initial compilation-time value that will be 
 assigned to the storage occupied by the data item in the program object code 
 generated by the compiler. 
 3 June 2014  
 Chapter 5 - DATA DIVISION",NA
6. PROCEDURE DIVISION,"PROCEDURE DIVISION Syntax
  
 PROCEDURE DIVISION [ { USING Subprogram-Argument ... 
 } ]  
 } 
 ~~~~~~~~~ 
 ~~~~~~~~ 
 { ~~~~~ 
  
 { CHAINING Main-Program-Argument...}  
  
  
 ~~~~~~~~  
 [ RETURNING identifier-1 ] . 
 [ DECLARATIVES. ] 
  
 ~~~~~~~~~  
  
 ~~~~~~~~~~~~ 
 [ Event-Handler-Routine... 
 . 
 ] 
 [ END DECLARATIVES. ]  
 ~~~ ~~~~~~~~~~~~  
 General-Program-Logic 
 [ Nested-Subprogram...  
 ] 
 [ END PROGRAM|FUNCTION name-1 
 ]  
  
 ~~~ ~~~~~~~ ~~~~~~~~ 
 ———————————————————————————————————————— 
 The PROCEDURE DIVISION of any GNU COBOL program marks the point where all 
 executable code is written. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.1. PROCEDURE DIVISION USING,"PROCEDURE DIVISION Subprogram-Argument Syntax
  
 [ BY { REFERENCE [ OPTIONAL ] 
 } ] identifier-1 }  
 } ] }  
 }  
 }  
 } 
 { ~~~~~~~~~ 
 ~~~~~~~~ 
 { VALUE [ [ UNSIGNED ] SIZE IS { AUTO 
 ~~~~~ 
 ~~~~~~
 ~~ 
 ~~~~ 
 { ~~~~ 
 { DEFAULT  
 { 
 ~~~~~~~ 
 { integer-1 } 
 ———————————————————————————————————————— 
 The ""USING"" clause defines the arguments that will be passed to a GNU COBOL program 
 which is serving as a subprogram. 
 1. The reserved words ""BY"" and ""IS"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words have no effect 
 upon the program. 
 2. The ""USING"" clause should only be used on the procedure division header of subpro-
 grams (subroutines or user-defined functions). 
 3. The calling program will pass zero or more data items, known as arguments, to this 
 subprogram — there must be exactly as many <
 identifier-1
 > data items specified on the 
 USING clause as the maximum number of arguments the subprogram will ever be 
 passed. 
 4. If a subprogram does not expect any arguments, it should not have a ""USING"" clause 
 specified on it’s procedure division header. 
 5. The order in which arguments are defined on the ""USING"" clause must correspond to the 
 order in which those arguments will be passed to the subprogram by the calling 
 program. 
 6. The identifiers specified on the ""USING"" clause must be defined in the linkage section of 
 the subprogram. No storage is actually allocated for those identifiers in the subprogram 
 as the actual storage for them will exist in the calling program. 
 7. A GNU COBOL subprogram expects that all arguments to it will be one of two things: 
 •
  The memory address of the actual data item (allocated in the calling program) that is 
 being passed to the subprogram. 
 •
  A numeric, full-word, binary value (i.e. 
 page 186
 )) which is the actual argument being 
 passed to the subprogram. ""USAGE BINARY-LONG"" (see
  [USAGE],
  
 In the case of the former, the ""USING"" clause on the procedure division header should 
 describe the argument via the ""BY REFERENCE"" clause — in the latter case, a ""BY",NA
6.2. PROCEDURE DIVISION CHAINING,"PROCEDURE DIVISION Main-Program-Argument Syntax
  
 [ BY REFERENCE ] [ OPTIONAL ] identifier-1 
  
 ~~~~~~~~~  ~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""CHAINING"" term provides one mechanism a programmer may use to retrieve 
 command-line arguments passed to a program at execution time. 
 1. ""PROCEDURE DIVISION CHAINING"" may only be coded in a main program (that is, the 
 first program executed when a compiled GNU COBOL compilation unit is executed). It 
 cannot be used in any form of subprogram. 
 2. The ""CHAINING"" clause defines arguments that will be passed to a main program from 
 the operating system. The argument identifiers specified on the CHAINING clause will 
 be populated by character strings comprised of the parameters specified to the 
 program on the command line that executed it, as follows: 
 A. When a GNU COBOL program is excecuted from a command-line, the complete 
 command line text will be broken into a series of ""tokens"", where each token is 
 identified as being a word separated from the others in the command text by at 
 least one space. For example, if the command line was /usr/local/myprog THIS IS 
 A TEST, there will be five tokens identified by the operating system —
 ""/usr/local/myprog"", ""THIS"", ""IS"", ""A"" and ""TEST"". 
 B. Multiple space-delimited tokens may be treated as a single token by enclosing them 
 in quotes. For example, there are only three tokens generated from the command 
 line C:\Pgms\myprog.exe ""THIS IS A"" TEST — ""C:\Pgms\myprog.exe"", ""THIS IS A"" 
 and ""TEST"". When quote characters are used to create multi-word tokens, the 
 quote characters themselves are stripped from the token’s value. 
 C. Once tokens have been identified, the first (the command) will be discarded; the rest 
 will be stored into the ""CHAINING"" arguments when the program begins 
 execution, with the 2nd token going to the 1st argument, the 3rd token going to the 
 2nd argument and so forth. 
 D. If there are more tokens than there are arguments, the excess tokens will be dis-
 carded. 
 E. If there are fewer tokens than there are arguments, the excess arguments will be 
 initialized as if the ""INITIALIZE <
 identifier-1
 >"" (see
  [INITIALIZE], page 399
 ) 
 statement were executed. 
 F. All identifiers specified on the CHAINING clause should be defined as PIC X, PIC A, 
 group items (which are treated implicitly as PIC X) or as PIC 9 USAGE DISPLAY. 
 The use of USAGE BINARY (or the like) data items as CHAINING 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.3. PROCEDURE DIVISION RETURNING,"PROCEDURE DIVISION RETURNING Syntax
  
 RETURNING identifier-1  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The RETURNING clause on the PROCEDURE DIVISION header documents that the 
 subprogram in which the clause appears will be returning a numeric value back to the 
 program that called it. 
 1. The ""RETURNING"" clause is optional within a subroutine, as not all subroutines return a 
 value to their caller. 
 2. The ""RETURNING"" clause is mandatory within a user-defined function, as all such must 
 return a numeric result. 
 3. The <
 identifier-1
 > data item should be defined as a USAGE BINARY-LONG data item. 
 4. Main programs that wish to ""pass back"" a return code value to the operating system 
 when they exit do not use RETURNING - they do so simply by MOVEing a value to the 
 ""RETURN-CODE"" special register. 
 5. This is not the only mechanism that a subprogram may use to pass a value back to it’s 
 caller. Other possibilities are: 
 A. The subprogram may modify any argument that is specified as ""BY REFER-ENCE"" on 
 it’s PROCEDURE DIVISION header. Whether the calling program can actually ""see"" 
 any modifications depends upon how the calling program passed the argument to 
 the subprogram. See
  [CALL], page 359
 , for more information. 
 B. A data item with the ""GLOBAL"" (see
  [GLOBAL], page 146
 ) attribute specified in it’s 
 description in the calling program is automatically visible to and updatable by a 
 subprogram nested with the calling program. See
  [Independent vs Contained vs 
 Nested Subprograms], page 557
 , for more information on subprogram nesting. 
 C. A data item defined with the ""EXTERNAL"" (see
  [EXTERNAL], page 141
 ) attribute in 
 a subprogram and the calling program (same name in both programs) is auto-
 matically visible to and updatable by both programs, even if those programs are 
 compiled separately from ona another. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.4. PROCEDURE DIVISION Sections and Paragraphs,"The procedure division is the only one of the COBOL divisions that allows you to create your 
 own sections and paragraphs. These are collectively referred to as ’
 Procedures
 ’, and the 
 names you create for those sections and paragraphs are called ’
 Procedure Names
 ’. 
 Procedure names are optional in the procedure division and — when used — are named 
 entirely according to the needs and whims of the programmer. 
 Procedure names may be up to thirty one (31) characters long and may consist of letters, 
 numbers, dashes and underscores. A procedure name may neither begin nor end with a 
 dash (-) or underscore ( ) character. This means that ""Main"", ""0100-Read-Transaction"" and 
 ""17"" are all perfectly valid procedure names. 
 There are three circumstances under which the use of certain GNU COBOL statements or 
 options will require the specification of procedures. These situations are: 
 1. When ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 ) are specified. 
 2. When the ""ENTRY"" statement (see
  [ENTRY], page 382
 ) is being used. 
 3. When any procedure division statement that references procedures is used.  
 These 
 statements are: 
 •
  ""ALTER <
 procedure-name
 >"" 
 •
  ""GO TO <
 procedure-name
 >"" 
 •
  ""MERGE ... OUTPUT PROCEDURE <
 procedure-name
 >""
 •
  
 ""PERFORM <
 procedure-name
 >"" 
 •
  ""SORT ... INPUT PROCEDURE <
 procedure-name
 >"" 
 PROCEDURE <
 procedure-name
 >"" 
 and/or 
 ""SORT ... INPUT 
  
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.5. DECLARATIVES,"DECLARATIVES Syntax
  
 section-name-1 SECTION. 
 USE { [ GLOBAL ] AFTER STANDARD { EXCEPTION } PROCEDURE ON { INPUT } } 
 ~~~ {  
 ~~~~~~  
 { ~~~~~~~~~ }  
 { ~~~~~ } } 
 {  
 { ERROR  
 }  
 { OUTPUT } } 
 {  
 ~~~~~  
 { ~~~~~~ } } 
 {  
 { I-O } } 
 { FOR DEBUGGING ON { procedure-name-1  
 }  
 { ~~~ } } 
 {  
 ~~~~~~~~~  { ALL PROCEDURES  
 }  
 { EXTEND } } 
 {  
 { ~~~ ~~~~~~~~~~  
 }  
 { ~~~~~~ } } 
 {  
 { REFERENCES OF identifier-1 }  
 { file-name-1 } } 
 { } 
 { [ GLOBAL ] BEFORE REPORTING identifier-2 } 
 {  
 ~~~~~~  ~~~~~~ ~~~~~~~~~ } 
 { } 
 { AFTER EC|{EXCEPTION CONDITION} } 
 ~~  ~~~~~~~~~ ~~~~~~~~~ 
 The ""AFTER EXCEPTION CONDITION"" and ""AFTER EC"" clauses are syntactically recognized 
 but are otherwise non-functional. 
 ———————————————————————————————————————— 
 The ""DECLARATIVES"" area of the procedure division allows the programmer to define a 
 series of ""trap"" procedures (referred to as declarative procedures) capable of intercepting 
 certain events that may occur at program execution time. The syntax diagram above shows 
 the format of a single such procedure. 
 1. The reserved words ""AFTER"", ""FOR"", ""ON"", ""PROCEDURE"" and ""STANDARD"" are optional 
 and may be included, or not, at the discretion of the programmer. The presence or 
 absence of these words has no effect upon the program. 
 2. ""EC"" and ""EXCEPTION CONDITION"" are interchangeable. 
 3. The declaratives area may contain any number of declarative procedures, but no two 
 declarative procedures should be coded to trap the same event. 
 4. The following points apply to the ""USE BEFORE REPORTING"" clause: 
 A. <
 identifier-2
 > must be a report group. 
 B. At run-time, the declaratives procedure will be executed prior to the processing 
 of the specified report group’s presentation; within the procedure you may take 
 either of the following actions: 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.6. Table References,"COBOL uses parenthesis to specify the subscripts used to reference table entries (tables in 
 COBOL are what other programming languages refer to as arrays). 
 For example, observe the following data structure which defines a 4 column by 3 row grid of 
 characters: 
 01 GRID. 
 05 GRID-ROW OCCURS 3 TIMES. 
 10 GRID-COLUMN OCCURS 4 TIMES.  
  
 15 GRID-CHARACTER  
 PIC X(1). 
 If the structure contains the following grid of characters: 
 A B C D  
 E F G H  
 I J K L 
 Then ""GRID-CHARACTER (2, 3)"" references the ""G"" and ""GRID-CHARACTER (3, 2)"" ref-
 erences the ""J"". 
 Subscripts may be specified as numeric (integer) literals, numeric (integer) data items, data 
 items created with any of the picture-less integer ""USAGE"" (see
  [USAGE], page 186
 ) 
 specifications, ""USAGE INDEX"" data items or arithmetic expressions resulting in a non-zero 
 integer value. 
 In the above examples, a comma is used as a separator character between the two subscript 
 values; semicolons ("";"") are also valid subscript separator characters, as are spaces! The use 
 of a comma or semicolon separator in such a situation is technically optional, but by 
 convention most COBOL programmers use one or the other.  The use of no separator 
 character (other than a space) is not recommended, even though it is syntactically correct, as 
 this practice can lead to programmer-unfriendly code.  
 It isn’t too difficult to read 
 and understand ""GRID-CHARACTER(2 3)"", but it’s another story entirely when trying to 
 comprehend ""GRID-CHARACTER(I + 1 J / 3)"" (instead of ""GRID-CHARACTER(I + 1, J / 3)""). 
 The compiler accepts it, but too much of this would make
  my
  head hurt. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.7. Qualification of Data Names,"COBOL allows data names to be duplicated within a program, provided references to those 
 data names may be made in such a manner as to make those references unique through a 
 process known as qualification. 
 To see qualification at work, observe the following segments of two data records defined in a 
 COBOL program: 
 01 
 EMPLOYEE. 
 01 
 CUSTOMER. 
 05 MAILING-ADDRESS. 
 05 MAILING-ADDRESS. 
 10 STREET 
 PIC X(35). 
 10 STREET 
 PIC X(35). 
 10 CITY 
 PIC X(15). 
 10 CITY 
 PIC X(15). 
 10 STATE 
 PIC X(2). 
 10 STATE 
 PIC X(2). 
 10 ZIP-CODE. 
 10 ZIP-CODE. 
 15 ZIP-CODE-5 PIC 9(5). 
 15 ZIP-CODE-5 PIC 9(5). 
 15 FILLER 
 PIC X(4). 
 15 FILLER 
 PIC X(4). 
 Now, let’s deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-
 ADDRESS to ""Philadelphia"".  
 Clearly, ""MOVE ’Philadelphia’ TO CITY"" 
 cannot work because the compiler will be unable to determine which of the two CITY fields 
 you are referring to. 
 In an attempt to correct the problem, we could qualify the reference to CITY as 
 ""MOVE’Philadelphia’ TO CITY OF MAILING-ADDRESS"". 
 Unfortunately that too is insufficient because it still insufficiently specifies which CITY is 
 being referenced. To truly identify which specific CITY you want, you’d have to code 
 ""MOVE’Philadelphia’ TO CITY OF MAILING-ADDRESS OF EMPLOYEE"". 
 Now there can be no confusion as to which CITY is being changed. Fortunately, you don’t 
 need to be quite so specific; COBOL allows intermediate and unnecessary qualification 
 levels to be omitted. This allows ""MOVE ’Philadelphia’ TO CITY OF EMPLOYEE"" to do the job 
 nicely. 
 If you need to qualify a reference to a table, do so by coding something like ""<
 identifier-1
 > OF 
 <
 identifier-2
 > ( subscript(s) )"". 
 The reserved word ""IN"" may be used in lieu of ""OF"". 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.8. Reference Modifiers,"Reference Modifier (Format 1) Syntax
  
  identifier-1 [ OF|IN identifier-2 ] [ (subscript...) 
 ] 
 (start:[ length ]) 
 ~~ ~~ 
 ———————————————————————————————————————— 
 Reference Modifier (Format 2) Syntax
  
 intrinsic-function-reference (start:[ length ]) 
 ————————————————————————————————————————
 The COBOL ’85 standard introduced the concept of a reference modifier to facilitate refer-
 ences to only a portion of a data item; GNU COBOL fully supports reference modification. The 
 <
 start
 > value indicates the starting character position being referenced (character posi-tion 
 values start with 1, not 0 as is the case in some programming languages) and <
 length
 > 
 specifies how many characters are wanted. 
 If no <
 length
 > is specified, a value equivalent to the remaining character positions from 
 <
 start
 > to the end of <
 identifier-1
 > or to the end of the value returned by the function will 
 be assumed. 
 Both <
 start
 > and <
 length
 > may be specified as integer numeric literals, integer numeric data 
 items or arithmetic expressions with an integer value. 
 Here are a few examples: 
 ""CUSTOMER-LAST-NAME (1:3)""  
 References the first three characters of CUSTOMER-LAST-NAME. 
 ""CUSTOMER-LAST-NAME (4:)""  
 References all character positions of CUSTOMER-LAST-NAME from the fourth 
 onward. 
 ""FUNCTION CURRENT-DATE (5:2)""  
 References the current month as a 2-digit number in character form.  
 See 
 [CURRENT-DATE], page 257
 , for more information. 
 ""Hex-Digits (Nibble + 1:1)""  
 Assuming that ""Nibble"" is a numeric data item with a value in the range 0-15, 
 and Hex-Digits is a ""PIC X(16)"" item with a value of ""0123456789ABCDEF"", this 
 converts that numeric value to a hexadecimal digit. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.9. Arithmetic Expressions,"Arithmetic-Expression Syntax
  
 Unary-Expression-1 { **|^ } Unary-Expression-2  { *|/ }  
  
 { +|- } 
 ———————————————————————————————————————— 
 Unary-Expression Syntax
  
 { [ +|- ] { ( Arithmetic-Expression-1 ) 
 } } 
 { 
 { [ LENGTH OF ] { identifier-1 
 } } } 
 { 
 { ~~~~~~ ~~ { literal-1 
 } } } 
 { 
 { 
 { Function-Reference } } } 
 { Arithmetic-Expression-2 
 } 
 ———————————————————————————————————————— 
 Arithmetic expressions are formed using four categories of operations — exponentiation, 
 multiplication & division, addition & subtraction, and sign specification. 
 In complex expressions composed of multiple operators and operands, a precedence of op-
 eration applies whereby those operations having a higher precedence are computed first 
 before operations with a lower precedence. 
 As is the case in almost any other programming language, the programmer is always free to 
 use pairs of parenthesis to enclose sub-expressions of complex expressions that are to be 
 evaluated before other sub-expressions rather than let operator precedence dictate the 
 sequence of evaluation. 
 In highest to lowest order of precedence, here is a discussion of each category of operation: 
 Level 1 (Highest) — Unary Sign Specification (""+"" and ""-"" with a single argument) 
 The unary ""minus"" (-) operator returns the arithmetic negation of its single 
 argument, effectively returning as its value the product of its argument and -1. 
 The unary ""plus"" (+) operator returns the value of its single argument, effec-
 tively returning as its value the product of its argument and +1. 
 Level 2 — Exponentiation (""**"" or ""^"") 
 The value of the left argument is raised to the power indicated by the right ar-
 gument. Non-integer powers are allowed. The ""^"" and ""**"" operators are both 
 supported to provide compatibility with programs written for other COBOL 
 implementations. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.10. Conditional Expressions,"Conditional expressions are expressions which identify the circumstances under which a 
 program may take an action or cease taking an action. As such, conditional expressions 
 produce a value of TRUE or FALSE. 
 There are seven types of conditional expressions, as discussed in the following sections.",NA
6.10.1. Condition Names,"These are the simplest of all conditions. Observe the following code: 
 05 
 SHIRT-SIZE 
 PIC 99V9. 
 88 TINY 
 VALUE 0 THRU 12.5 
 88 XS 
 VALUE 13 THRU 13.5. 
 88 S 
 VALUE 14, 14.5. 
 88 M 
 VALUE 15, 15.5. 
 88 L 
 VALUE 16, 16.5. 
 88 XL 
 VALUE 17, 17.5. 
 88 XXL 
 VALUE 18, 18.5. 
 88 XXXL 
 VALUE 19, 19.5. 
 88 VERY-LARGE 
 VALUE 20 THRU 99.9. 
 The condition names ""TINY"", ""XS"", ""S"", ""M"", ""L"", ""XL"", ""XXL"", ""XXXL"" and ""VERY-LARGE"" will 
 have TRUE or FALSE values based upon the values within their parent data item (SHIRT-
 SIZE). 
 A program wanting to test whether or not the current ""SHIRT-SIZE"" value can be classified 
 as ""XL"" could have that decision coded as a combined condition (the most complex type of 
 conditional expression), as either: 
 IF SHIRT-SIZE = 17 OR SHIRT-SIZE = 17.5 
 - or - 
 IF SHIRT-SIZE = 17 OR 17.5 
 Or it could simply utilize the condition name XL as follows: 
 IF XL 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.10.2. Class Conditions,"Class-Condition Syntax
  
 identifier-1 IS [ NOT ] { NUMERIC 
 }  
 }  
 }  
 } 
 ~~~ 
 { ~~~~~~~ 
 { 
 ALPHABETIC  
 { 
 ~~~~~~~~
 ~~ 
 { ALPHABETIC-LOWER }  
 { 
 ~~~~~~~~~~~~~~~
 ~ }  
 { ALPHABETIC-UPPER }  
 { 
 ~~~~~~~~~~~~~~~
 ~ }  
 { OMITTED  
 }  
 { ~~~~~~~  
 }  
 { class-name-1  
 } 
 ———————————————————————————————————————— 
 Class conditions evaluate the type of data that is currently stored in a data item. 
 1. The ""NUMERIC"" class test considers only the characters ""0"", ""1"", . . . , ""9"" to be numeric; 
 only a data item containing nothing but digits will pass a ""NUMERIC"" class test. Spaces, 
 decimal points, commas, currency signs, plus signs, minus signs and any other 
 characters except the digit characters will all fail ""NUMERIC"" class tests. 
 2. The ""ALPHABETIC"" class test considers only upper-case letters, lower-case letters and 
 spaces to be alphabetic in nature. 
 3. The ""ALPHABETIC-LOWER"" and ""ALPHABETIC-UPPER"" class conditions consider only 
 spaces and the respective type of letters to be acceptable in order to pass such a class 
 test. 
 4. The ""NOT"" option reverses the TRUE/FALSE value of the condition. 
 5. Note that what constitutes a ""letter"" (or upper/lower case too, for that manner) may be 
 influenced through the use of ""CHARACTER CLASSIFICATION"" specifications in the 
 ""OBJECT-COMPUTER"" (see
  [OBJECT-COMPUTER], page 58
 ) paragraph. 
 6. Only data items whose ""USAGE"" (see
  [USAGE], page 186
 ) is either explicitly or implic-
 itly defined as ""DISPLAY"" may be used in ""NUMERIC"" or any of the ""ALPHABETIC"" class 
 conditions. 
 7. Some COBOL implementations disallow the use of group items or ""PIC A"" items with 
 ""NUMERIC"" class conditions and the use of ""PIC 9"" items with ""ALPHABETIC"" class 
 conditions. GNU COBOL has no such restrictions. 
 8. The ""OMITTED"" class condition is used when it is necessary for a subprogram to deter-
 mine whether or not a particular argument was passed to it. In such class conditions, 
 <
 identifier-1
 > must be a linkage section item defined on the ""USING"" clause of the sub-",NA
6.10.3. Sign Conditions,"Sign-Condition Syntax
  
 identifier-1 IS [ NOT ] { POSITIVE }  
  
 ~~~  { 
 ~~~~~~~~ }  
  
  
 { NEGATIVE }  
  
  
 { 
 ~~~~~~~~ }  
  
  
 { ZERO  
 }  
  
  
 ~~~~ 
 ———————————————————————————————————————— 
 Sign conditions evaluate the numeric state of a data item defined with a ""PICTURE"" (see 
 [PICTURE], page 162
 ) and/or ""USAGE"" (see
  [USAGE], page 186
 ) that supports numeric 
 values. 
 1. A ""POSITIVE"" or ""NEGATIVE"" class condition will be TRUE only if the value of <
 identifier-
 1
 > is strictly greater than or less than zero, respectively. 
 2. A ""ZERO"" class condition can be passed only if the value of <
 identifier-1
 > is exactly zero. 
 3. The ""NOT"" option reverses the TRUE/FALSE value of the condition. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.10.4. Switch-Status Conditions,"In the ""SPECIAL-NAMES"" (see
  [SPECIAL-NAMES], page 62
 ) paragraph, an external switch 
 name can be associated with one or more condition names. These condition names may 
 then be used to test the ON/OFF status of the external switch. 
 Here are the relevant sections of code in a program named ""testprog"", which is designed to 
 simply announce if SWITCH-1 is on: 
 ... 
 ENVIRONMENT DIVISION. 
 SPECIAL-NAMES. 
 SWITCH-1 ON STATUS IS Switch-1-Is-ON. ... 
 PROCEDURE DIVISION. 
 ... 
 IF Switch-1-Is-ON  
  
  
 DISPLAY ""Switch 1 Is On""  
 END-IF  
 ... 
 the following are two different command window sessions — the left on a 
 Unix/Cygwin/OSX system and the right on a windows system — that will set the switch on 
 and then execute the ""testprog"" program. Notice how the message indicating that the 
 program detected the switch was set is displayed in both examples: 
 $ COB_SWITCH_1=ON C:>SET COB_SWITCH_1=ON $ export 
 COB_SWITCH_1 C:>testprog  
 $ ./testprog Switch 1 Is On  
 Switch 1 Is On C:>  
 $ 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.10.5. Relation Conditions,"Relation-Condition Syntax
  
 { identifier-1 
 } IS [ NOT ] RelOp { identifier-2 
 } 
 { literal-1 
 } 
 ~~~ 
 { literal-2 
 } 
 { arithmetic-expression-1 } 
 { arithmetic-expression-2 } 
 { index-name-1 
 } 
 { index-name-2 
 } 
 ———————————————————————————————————————— 
 RelOp Syntax
  
 { EQUAL TO  
 { ~~~~~  
 { EQUALS  
 { ~~~~~~  
 { GREATER 
 THAN { 
 ~~~~~~~ 
 }  
 }  
 }  
 }  
 }  
 } 
 { GREATER THAN OR EQUAL TO } 
 { ~~~~~~~ ~~ ~~~~~  
 } 
 { LESS THAN  
 } 
 { ~~~~  
 } 
 { LESS THAN OR EQUAL TO  
 } 
 { ~~~~  
 ~~ ~~~~~  
 } 
 { =  
 } 
 { >  
 } 
 { >=  
 } 
 { <  
 } 
 { <=  
 } 
 ———————————————————————————————————————— 
 These conditions evaluate how two different values ""relate"" to each other. 
 1. When comparing one numeric value to another, the ""USAGE"" (see
  [USAGE], page 186
 ) 
 and number of significant digits in either value are irrelevant as the comparison is 
 performed using the actual algebraic values. 
 2. When comparing strings, the comparison is made based upon the program’s collating 
 sequence. When the two string arguments are of unequal length, the shorter is assumed 
 to be padded (on the right) with a sufficient number of spaces as to make the two 
 strings of equal length. String comparisons take place on a corresponding character- 
 by-character basis, left to right, until the TRUE/FALSE value for the relation test can 
 be established. Characters are compared according to their relative position in the 
 program’s ""COLLATING SEQUENCE"" (as defined in ""SPECIAL-NAMES"" (see
  [SPECIAL-
  
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.10.6. Combined Conditions,"Combined Condition Syntax
  
 [ ( ] Condition-1 [ ) ] { AND } [ ( ] Condition-2 [ ) ]  
 { ~~~ }  
  
 { OR  }  
  
 { ~~  } 
 ———————————————————————————————————————— 
 A combined condition is one that computes a TRUE/FALSE value from the TRUE/FALSE 
 values of two other conditions (which could themselves be combined conditions). 
 1. If either condition has a value of TRUE, the result of ""OR""ing the two together will result 
 in a value of TRUE. ""OR""ing two FALSE conditions will result in a value of FALSE. 
 2. In order for ""AND"" to yield a value of TRUE, both conditions must have a value of TRUE. 
 In all other circumstances, ""AND"" produces a FALSE value. 
 3. When 
 chaining multiple, 
 similar conditions together 
 with the same operator 
 (OR/AND), and left or right arguments have common subjects, it is possible to 
 abbreviate the program code. For example: 
 IF ACCOUNT-STATUS = 1 OR ACCOUNT-STATUS = 2 OR ACCOUNT-STATUS = 7 
 Could be abbreviated as: 
 IF ACCOUNT-STATUS = 1 OR 2 OR 7 
 4. Just as multiplication takes precedence over addition in arithmetic expressions, so does 
 ""AND"" take precedence over ""OR"" in combined conditions. Use parenthesis to change 
 this precedence, if necessary. For example: 
 ""FALSE AND FALSE OR TRUE AND TRUE"" 
 Evaluates to TRUE 
 ""(FALSE AND FALSE) OR (TRUE AND TRUE)"" 
 Evaluates to TRUE (since AND has precedence over OR) - this is identical to 
 the previous example 
 ""(FALSE AND (FALSE OR TRUE)) AND TRUE"" 
 Evaluates to FALSE 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.10.7. Negated Conditions,"Negated Condition Syntax
  
 NOT Condition-1  
 ~~~ 
 ————————————————————————————————————————
 A condition may be negated by prefixing it with the ""NOT"" operator. 
 1. The ""NOT"" operator has the highest precedence of all logical operators, just as a unary 
 minus sign (which ""negates"" a numeric value) is the highest precedence arithmetic 
 operator. 
 2. Parenthesis must be used to explicitly signify the sequence in which conditions are 
 evaluated and processed if the default precedence isn’t desired. For example: 
 ""NOT TRUE AND FALSE AND NOT FALSE""  
 Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE ""NOT (TRUE AND 
 FALSE AND NOT FALSE)""  
 Evaluates to NOT (FALSE) which evaluates to TRUE  
 ""NOT TRUE AND (FALSE AND NOT FALSE)""  
 Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.11. Use of Periods,"All COBOL implementations distinguish between sentences and statements in the 
 procedure division. A ’
 Statement
 ’ is a single executable COBOL instruction. For example, 
 these are all statements: 
 MOVE SPACES TO Employee-Address  
 ADD 1 TO Record-Counter  
 DISPLAY ""Record-Counter="" Record-Counter 
 Some COBOL statements have a ""scope of applicability"" associated with them where one or 
 more other statements can be considered to be part of or related to the statement in 
 question. An example of such a situation might be the following, where the interest on a 
 loan is being calculated and displayed — 4% interest if the loan balance is under $10000 
 and 4.5% otherwise (WARNING – the following code has an error!): 
 IF Loan-Balance < 10000  
 MULTIPLY Loan-Balance BY 0.04 GIVING Interest ELSE  
 MULTIPLY Loan-Balance BY 0.045 GIVING Interest DISPLAY 
 ""Interest Amount = "" Interest 
 In this example, the IF statement actually has a scope that can include two sets of associated 
 statements – one set to be executed when the ""IF"" (see
  [IF], page 397
 ) condition is TRUE 
 and another if it is FALSE. 
 Unfortunately, there’s a problem with the above.  
 A human being looking at that code 
 would probably infer that the ""DISPLAY"" (see
  [DISPLAY], page 370
 ) statement, because of its 
 lack of indentation, is to be executed regardless of the TRUE/FALSE value of the ""IF"" 
 condition. Unfortunately, the GNU COBOL compiler (or any other COBOL compiler for that 
 matter) won’t see it that way because it really couldn’t care less what sort of indentation, if 
 any, is used. In fact, any COBOL compiler would be just as happy to see the code written like 
 this: 
 IF Loan-Balance < 10000 MULTIPLY Loan-balance BY 
 0.04 GIVING Interest ELSE MULTIPLY  
 Loan-Balance BY 0.045 GIVING Interest DISPLAY 
 ""Interest Amount = "" Interest 
 So how then do we inform the compiler that the ""DISPLAY"" statement is outside the scope of 
 the ""IF""? 
 That’s where sentences come in. 
 A COBOL ’
 Sentence
 ’ is defined as any arbitrarily long sequence of statements, followed by a 
 period (.) character. The period character is what terminates the scope of a set of 
 statements. Therefore, our example should have been coded like this: 
 IF Loan-Balance < 10000 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.12. Use of VERB/END-VERB Constructs,"Prior to the 1985 COBOL standard, using a period character was the only way to signal the 
 end of a statement’s scope. 
 Unfortunately, this caused some problems. Take a look at this code: 
 IF A = 1  
 IF B = 1  
  
  
 DISPLAY ""A & B = 1""  
 ELSE *> This ELSE has a problem! 
 IF B = 1  
  
 DISPLAY ""A NOT = 1 BUT B = 1""  
 ELSE  
  
 DISPLAY ""NEITHER A NOR B = 1"". 
 The problem with this code is that indentation — so critical to improving the human-
 readability of a program — can provide an erroneous view of the logical flow. An ""ELSE"" is 
 always associated with the most-recently encountered ""IF""; this means the emphasized 
 ""ELSE"" will be associated with the ""IF B = 1"" statement, not the ""IF A = 1"" statement as the 
 indentation would appear to imply. 
 This sort of problem led to a band-aid solution — the ""NEXT SENTENCE"" clause — being 
 added to the COBOL language. 
 IF A = 1  
 IF B = 1  
  
  
 DISPLAY ""A & B = 1""  
 ELSE  
  
  
 NEXT SENTENCE  
 ELSE  
 IF B = 1  
  
  
 DISPLAY ""A NOT = 1 BUT B = 1""  
 ELSE  
  
  
 DISPLAY ""NEITHER A NOR B = 1"". 
 The ""NEXT SENTENCE"" clause informs the compiler that if the ""B = 1"" condition is false, 
 control should fall into the first statement that follows the next period. 
 With the 1985 standard for COBOL, a much more elegant solution was introduced. Any 
 COBOL ’
 Verb
 ’ (the first reserved word of a statement) that needed such a thing was allowed 
 to use an ""END-verb"" construct to end it’s scope without disrupting the scope of any other 
 statement it might have been in. Any COBOL 85 compiler would have allowed the following 
 solution to our problem: 
 IF A = 1  
 IF B = 1  
  
  
 DISPLAY ""A & B = 1"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.13. Concurrent Access to Files,"The manipulation of data files is one of the COBOL language’s great strengths. There are 
 features built into COBOL to deal with the possibility that multiple programs may be 
 attempting to access the same file concurrently. Multiple program concurrent access is dealt 
 with in two ways — file sharing and record locking. 
 Not all GNU COBOL implementations support file sharing and record-locking options. 
 Whether they do or not depends upon the operating system they were built for and the 
 build options that were used when the specific GNU COBOL implementation was generated.",NA
6.13.1. File Sharing,"GNU COBOL controls concurrent-file access at the highest level through the concept of file 
 sharing, enforced when a program attempts to open a file. This is accomplished via a UNIX 
 operating-system routine called ""fcntl()"". That module is not currently supported by 
 Windows and is not present in the MinGW Unix-emulation package. GNU COBOL builds 
 created using a MinGW environment will be incapable of supporting file-sharing controls —
 files will always be shared in such environments. A GNU COBOL build created using the 
 Cygwin environment on Windows
  would
  have access to ""fcntl()"" and therefore
  will
  support 
 file sharing. Of course, actual Unix builds of GNU COBOL, as well as OSX builds, should have 
 no issues because ""fcntl()"" should be available. 
 Any limitations imposed on a successful ""OPEN"" (see
  [OPEN], page 420
 ) will remain in place 
 until your program either issues a ""CLOSE"" (see
  [CLOSE], page 364
 ) against the file or the 
 program terminates. 
 File sharing is controlled through the use of a ""SHARING"" clause: 
 SHARING WITH { ALL OTHER } 
 ~~~~~~~ 
 { ~~~ 
 } 
 { NO OTHER } 
 { ~~ 
 } 
 { READ ONLY }  
 ~~~~ ~~~~ 
 This clause may be used either in the file’s ""SELECT"" statement (see
  [SELECT], page 73
 ), on 
 the ""OPEN"" statement (see
  [OPEN], page 420
 ) which initiates your program’s use of the file, 
 or both. If a ""SHARING"" option is specified in
  both
  places, the specifications made on the 
 ""OPEN"" statement will take precedence over those from the ""SELECT"" statement. 
 Here are the meanings of the three options: 
 ""ALL OTHER"" 
 When your program opens a file with this sharing option in effect, no restric-
 tions will be placed on other programs attempting to ""OPEN"" the file after your 
 program did. This is the default sharing mode. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.13.2. Record Locking,"Record-locking is supported by advanced file-management software built-in to the GNU 
 COBOL implementation you are using. This software provides a single point-of-control for 
 access to files — usually ""ORGANIZATION INDEXED"" (see
  [ORGANIZATION INDEXED], page 
 84
 ) files. One such runtime package capable of doing this is the Berkely Database (BDB) 
 package — a package frequently used in GNU COBOL builds to support indexed files. 
 The various I/O statements your program can execute are capable of imposing limitations 
 on access by other concurrently-executing programs to the file record they just accessed. 
 These limitations are syntactically imposed by placing a lock on the record using a ""LOCK"" 
 clause. Other records in the file remain available, assuming that file-sharing limitations 
 imposed at the time the file was opened didn’t prevent access to the entire file. 
 1. If the GNU COBOL build you are using was configured to use the Berkely Data-base 
 (BDB) package for indexed file I/O, record locking will be available by using the 
 ""DB_HOME"" run-time environment variable (see
  [Run Time Environment Variables], 
 page 522
 ). 
 2. If the ""SELECT"" (see
  [SELECT], page 73
 ) statement or file ""OPEN"" (see
  [OPEN], page 420
 ) 
 specifies ""SHARING WITH NO OTHER"", record locking will be disabled. 
 3. If the file’s ""SELECT"" contains a ""LOCK MODE IS AUTOMATIC"" clause, every time a 
 record is read from the file, that record is automatically locked. Other programs may 
 access
  other
  records within the file, but not a locked record. 
 4. If the file’s ""SELECT"" contains a ""LOCK MODE IS MANUAL"" clause, locks are placed on 
 records
  only
  when a ""READ"" statement executed against the file includes a ""LOCK"" 
 clause (this clause will be discussed shortly). 
 5. If the ""LOCK ON"" clause
  is
  specified in the file’s ""SELECT"", locks (either automatically or 
 manually acquired) will continue to accumulate as more and more records are read, 
 until they are explicitly released. This is referred to as ’
 multiple record locking
 ’. 
 Locks acquired vie multiple record locking remain in-effect until the program holding 
 the lock. . . 
 •
  . . .terminates, or . . . 
 •
  . . .executes a ""CLOSE"" statement (see
  [CLOSE], page 364
 ) against the file, or . . .
 •
  . . 
 .executes an ""UNLOCK"" statement (see
  [UNLOCK], page 474
 ) against the file, or . . . 
 •
  . . .executes a ""COMMIT"" statement (see
  [COMMIT], page 365
 ) or . . . 
 •
  . . .executes a ""ROLLBACK"" statement (see
  [ROLLBACK], page 439
 ). 
 6. If the ""LOCK ON"" clause is
  not
  specified, then the next I/O statement your program 
 executes, except for ""START"" (see
  [START], page 459
 ), will release the lock. This is 
 referred to as ’
 single record locking
 ’. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.14. Common Clauses on Executable Statements,NA,NA
6.14.1. AT END,NA,NA
 +,NA,NA
 NOT AT END,"AT END Syntax
  
 [ AT END imperative-statement-1 ]  
  
  
 ~~~  
 [ NOT AT END imperative-statement-2 ]  
  
 ~~~  
 ~~~ 
 ———————————————————————————————————————— 
 ""AT END"" clauses may be specified on ""READ"" (see
  [READ], page 428
 ), ""RETURN"" (see 
 [RETURN], page 436
 ), ""SEARCH"" (see
  [SEARCH], page 440
 ) and ""SEARCH ALL"" (see 
 [SEARCH ALL], page 442
 ) statements. 
 1. The following points pertain to the use of these clauses on ""READ"" (see
  [READ], page 
 428
 ) and ""RETURN"" (see
  [RETURN], page 436
 ) statements: 
 A. The ""AT END"" clause will — if present — cause <
 imperative-statement-1
 > (see 
 [Imperative Statement], page 593
 ) to be executed if the statement fails due to a file 
 status of 10 (end-of-file). See
  [File Status Codes], page 76
 , for a list of possible File 
 Status codes. 
 An ""AT END"" clause
  will not detect other non-zero file-status values
 . 
 Use a ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 ) routine or an explicitly-
 declared file status field tested after the ""READ"" or ""RETURN"" to detect error con-
 ditions other than end-of-file. 
 B. A ""NOT AT END"" clause will cause <
 imperative-statement-2
 > to be executed if the 
 ""READ"" or ""RETURN"" attempt is successful. 
 2. The following points pertain to the use of these clauses on ""SEARCH"" (see
  [SEARCH], 
 page 440
 ) and ""SEARCH ALL"" (see
  [SEARCH ALL], page 442
 ) statements: 
 A. An ""AT END"" clause detects and handles the case where either form of table search 
 has failed to locate an entry that satisfies the search conditions being used. 
 B. The ""NOT AT END"" clause is not allowed on either form of table search. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.14.2. CORRESPONDING,"Three GNU COBOL statements — ""ADD"" (see
  [ADD CORRESPONDING], page 354
 ), ""MOVE"" 
 (see
  [MOVE CORRESPONDING], page 415
 ) and ""SUBTRACT"" (see
  [SUBTRACT 
 CORRESPONDING], page 469
 ) support the use of a ""CORRESPONDING"" option: 
 ADD CORRESPONDING group-item-1 TO group-item-2  
 MOVE CORRESPONDING group-item-1 TO group-item-2  
 SUBTRACT CORRESPONDING group-item-1 FROM group-item-2 
 This option allows one or more data items within one group item (<
 group-item-1
 > — the 
 first named on the statement) to be paired with correspondingly-named (hence the name) 
 in a second group item (<
 group-item-2
 > — the second named on the statement). The 
 contents of <
 group-item-1
 > will remain unaffected by the statement while one or more data 
 items within <
 group-item-2
 > will be changed. 
 In order for <
 data-item-1
 >, defined subordinate to group item <
 group-item-1
 > to be a 
 ""corresponding"" match to <
 data-item-2
 > which is subordinate to <
 group-item-2
 >, each of 
 the following must be true: 
 1. Both <
 data-item-1
 > and <
 data-item-2
 > must have the same name, and that name may not 
 explicitly or implicitly be ""FILLER"". 
 2. Both <
 data-item-1
 > and <
 data-item-2
 >. . . 
 A. . . .must exist at the same relative structural ""depth"" of definition within <
 group-item-
 1
 > and <
 group-item-2
 >, respectively 
 B. . . .and all ""parent"" data items defined within each group item must have identical 
 (but non-""FILLER"") names. 
 3. When used with a ""MOVE"" verb. . . 
 A. . . .one of <
 data-item-1
 > or <
 data-item-2
 > (but not both) is allowed to be a group item 
 B. . . .and it must be valid to move <
 data-item-1
 > TO <
 data-item-2
 >. 
 4. When used with ""ADD"" or ""SUBTRACT"" verbs, both <
 data-item-1
 > and <
 data-item-2
 > 
 must be numeric, elementary, unedited items. 
 5. Neither <
 data-item-1
 > nor <
 data-item-2
 > may be a ""REDEFINES"" (see
  [REDEFINES], page 
 172
 ) or ""RENAMES"" (see
  [RENAMES], page 173
 ) of another data item. 
 6. Neither <
 data-item-1
 > nor <
 data-item-2
 > may have an ""OCCURS"" (see
  [OCCURS], page 
 158
 ) clause, although either may contain subordinate data items that
  do
  have an 
 ""OCCURS"" clause (assuming rule 3a applies) 
 Observe the definitions of data items ""Q"" and ""Y"". . . 
 01 
 Q. 
 PIC 9(1). 
 01 
 Y. 
 PIC X(1). 
 03 X. 
 02 A 
 05 A 
 02 G1. 
  
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.14.3. INVALID KEY,NA,NA
 +,NA,NA
 NOT INVALID KEY,"INVALID KEY Syntax
  
 [ INVALID KEY imperative-statement-1 ] 
  
 ~~~~~~~  
 [ NOT INVALID KEY imperative-statement-2 ] 
  
 ~~~ ~~~~~~~ 
 ———————————————————————————————————————— 
 ""INVALID KEY"" clauses may be specified on ""DELETE"" (see
  [DELETE], page 369
 ), ""READ"" 
 (see
  [Random READ], page 430
 ), ""REWRITE"" (see
  [REWRITE], page 437
 ), ""START"" (see 
 [START], page 459
 ) and ""WRITE"" (see
  [WRITE], page 479
 ) statements. 
 Specification of an ""INVALID KEY"" clause will allow your program to trap an I/O failure 
 condition (with an I/O error code in the file’s ""FILE-STATUS"" (see
  [SELECT], page 73
 ) field) 
 that has occurred due to a record-not-found condition and handle it gracefully by executing 
 <
 imperative-statement-1
 > (see
  [Imperative Statement], page 593
 ). 
 An optional ""NOT INVALID KEY"" clause will cause <
 imperative-statement-2
 > to be executed if 
 the statement’s execution was successful.",NA
6.14.4. ON EXCEPTION,NA,NA
 +,NA,NA
 NOT ON EXCEPTION,"ON EXCEPTION Syntax
  
 [ ON EXCEPTION imperative-statement-1 ]  
  
 ~~~~~~~~~  
 [ NOT ON EXCEPTION imperative-statement-2 ] 
  
 ~~~  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 ""EXCEPTION"" clauses may be specified on ""ACCEPT"" (see
  [ACCEPT], page 338
 ), ""CALL"" (see 
 [CALL], page 359
 ) and ""DISPLAY"" (see
  [DISPLAY], page 370
 ) statements. 
 Specification of an exception clause will allow your program to trap a failure condition that 
 has occurred and handle it gracefully by executing <
 imperative-statement-1
 > (see 
 [Imperative Statement], page 593
 ).  
 If such a condition occurs at runtime without hav-ing 
 one of these clauses specified, an error message will be generated (by the GNU COBOL 
 runtime library) to the SYSERR device (pipe 2). The program may also be terminated, 
 depending upon the type and severity of the error. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.14.5. ON OVERFLOW,NA,NA
 +,NA,NA
 NOT ON OVERFLOW,"ON OVERFLOW Syntax
  
 [ ON OVERFLOW imperative-statement-1 ]  
  
 ~~~~~~~~  
 [ NOT ON OVERFLOW imperative-statement-2 ] 
  
 ~~~  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 ""OVERFLOW"" clauses may be specified on ""CALL"" (see
  [CALL], page 359
 ), ""STRING"" (see 
 [STRING], page 463
 ) and ""UNSTRING"" (see
  [UNSTRING], page 475
 ) statements. 
 An ""ON OVERFLOW"" clause will allow your program to trap a failure condition that has 
 occurred and handle it gracefully by executing <
 imperative-statement-1
 > (see
  [Imperative 
 Statement], page 593
 ). If such a condition occurs at runtime without having one of these 
 clauses specified, an error message will be generated (by the GNU COBOL runtime library) 
 to the SYSERR device (pipe 2). The program may also be terminated, depending upon the 
 type and severity of the error. 
 An optional ""NOT ON OVERFLOW"" clause will cause <
 imperative-statement-2
 > to be 
 executed if the statement’s execution was successful.",NA
6.14.6. ON SIZE ERROR,NA,NA
 +,NA,NA
 NOT ON SIZE ERROR,"ON SIZE ERROR Syntax
  
 [ ON SIZE ERROR imperative-statement-1 ]  
  
 ~~~~ ~~~~~  
 [ NOT ON SIZE ERROR imperative-statement-2 ]  ~~~ 
  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 ""SIZE ERROR"" clauses may be included on ""ADD"" (see
  [ADD], page 350
 ), ""COMPUTE"" (see
  
 [COMPUTE], page 366
 ), ""DIVIDE"" (see
  [DIVIDE], page 376
 ), ""MULTIPLY"" (see 
 [MULTIPLY], 
 page 416
 ) and ""SUBTRACT"" (see
  [SUBTRACT], page 465
 ) statements. 
 Including an ""ON SIZE ERROR"" clause on an arithmetic statement will allow your program 
 to trap a failure of an arithmetic statement (either generating a result too large for the 
 receiving field, or attempting to divide by zero) and handle it gracefully by executing 
 <
 imperative-statement-1
 > (see
  [Imperative Statement], page 593
 ). Field size overflow 
 conditions occur 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.14.7. ROUNDED,"ROUNDED Syntax
  
 ROUNDED [ MODE IS { AWAY-FROM-ZERO 
 }  
 } 
 ~~~~~~
 ~ 
 ~~~~ 
 { ~~~~~~~~~~~~~~ 
 { NEAREST-AWAY-FROM-ZERO 
 }  
 { 
 ~~~~~~~~~~~~~~~~~~~
 ~~~ }  
 { NEAREST-EVEN  
 }  
 { ~~~~~~~~~~~~  
 }  
 { NEAREST-TOWARD-ZERO  }  
 { 
 ~~~~~~~~~~~~~~~~~~~ 
  
 }  
 { PROHIBITED  
 }  
 { ~~~~~~~~~~  
 }  
 { TOWARD-GREATER  
 }  
 { ~~~~~~~~~~~~~~  
 }  
 { TOWARD-LESSER  
 }  
 { ~~~~~~~~~~~~~  
 }  
 { TRUNCATION  
 }  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 GNU COBOL provides for control over the final rounding process applied to the receiv-ing 
 fields on all arithmetic verbs. Each of the arithmetic statements (""ADD"" (see
  [ADD], page 
 350
 ), ""COMPUTE"" (see
  [COMPUTE], page 366
 ), ""DIVIDE"" (see
  [DIVIDE], page 376
 ), 
 ""MULTIPLY"" (see
  [MULTIPLY], page 416
 ) and ""SUBTRACT"" (see
  [SUBTRACT], page 465
 )) 
 statements allow an optional ""ROUNDED"" clause to be applied to each receiving data item. 
 The following rules apply to the rounding behavior induced by this clause. 
 1. Rounding only applies when the result being saved to a receiving field with a 
 ""ROUNDED"" clause is a non-integer value. 
 2. Absence of a ""ROUNDED"" clause is the same as specifying ""ROUNDED MODE IS 
 TRUNCATION"".",NA
6.15. Special Registers,"GNU COBOL, like other COBOL dialects, includes a number of data items that are auto-
 matically available to a programmer without the need to actually define them in the data 
 division. COBOL refers to such items as registers or special registers. The special registers 
 available to a GNU COBOL program are as follows: 
 ""COB-CRT-STATUS"" 
 PIC 9(4) — This is the default data item allocated for use by the ""ACCEPT 
 <
 screen-data-item
 >"" statement (see
  [ACCEPT screen-data-item], page 342
 ), if 
 no ""CRT STATUS"" (see
  [SPECIAL-NAMES], page 62
 ) clause was specified.. 
 ""DEBUG-ITEM"" 
 Group Item — A group item in which debugging information generated by a 
 ""USE FOR DEBUGGING"" section in the declaratives area of the procedure 
 division will place information documenting why the ""USE FOR DEBUGGING"" 
 procedure was invoked. Consult the ""DECLARATIVES"" (see
  [DECLARATIVES], 
 page 208
 ) documentation for information on the structure of this register. 
 ""LINAGE-COUNTER"" 
 BINARY-LONG SIGNED — An occurrence of this register exists for each selected 
 file having a ""LINAGE"" (see
  [File/Sort-Description], page 94
 ) clause. If there are 
 multiple files whose file descriptions have ""LINAGE"" clauses, any explicit 
 references to this register will require qualification (using ""OF file-name""). The 
 value of this register will be the current logical line number within the page 
 body. The value of this register cannot be modified. 
 ""LINE-COUNTER"" 
 BINARY-LONG SIGNED — An occurrence of this register exists for each re-port 
 defined in the program (via an ""RD"" (see
  [REPORT SECTION], page 107
 )). If 
 there are multiple reports, any explicit references to this register not made in 
 the report section will require qualification (""OF report-name""). The value of 
 this register will be the current logical line number on the current page. The 
 value of this register cannot be modified. 
 ""NUMBER-OF-CALL-PARAMETERS"" 
 BINARY-LONG SIGNED — This register contains the number of arguments 
 passed to a subroutine — the same value that would be returned by the 
 ""C$NARG"" built-in system subroutine (see
  [C$NARG], page 529
 ). Its value will 
 be zero when referenced in a main program. This register, when referenced 
 from within a user-defined function, returns a value of one (1) if the function 
 has any number of arguments and a zero if it has no arguments. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16. Intrinsic Functions,"GNU COBOL supports a wide variety of ""intrinsic functions"" that may be used anywhere in 
 the PROCEDURE DIVISION where a literal is allowed. For example: 
 MOVE FUNCTION LENGTH(Employee-Last-Name) TO Employee-LN-Len 
 Note how the word ""FUNCTION"" is part of the syntax when you use an intrinsic function. You 
 can use intrinsic functions without having to include the reserved word ""FUNCTION"" via 
 settings in the ""REPOSITORY"" (see
  [REPOSITORY], page 60
 ) paragraph.  
 You may 
 accomplish the same thing by specifying the ""-fintrinsics"" switch to the GNU COBOL compiler 
 when you compile your programs. 
 User-written functions (see
  [Subprogram Types], page 557
 ) never require the ""FUNCTION"" 
 keyword when they are executed, because each user-written function a program uses 
 must
  
 be included in that program’s ""REPOSITORY"" paragraph, which therefore makes the 
 ""FUNCTION"" keyword optional. 
 The following intrinsic functions, known to other ""dialects"" of COBOL, are defined to GNU 
 COBOL as reserved words but are not otherwise implemented currently. Any attempts to 
 use these functions will result in a compile-time error message. 
 BOOLEAN-OF-INTEGER  
 FORMATTED-CURRENT-DATE  
 INTEGER-OF-FORMATTED-
 DATE  
 CHAR-NATIONAL  
 FORMATTED-DATE  
 NATIONAL-OF  
 DISPLAY-OF  
 FORMATTED-DATETIME  
 STANDARD-COMPARE  
 EXCEPTION-FILE-N  
 FORMATTED-TIME  
 TEST-FORMATTED-DATETIME  
 EXCEPTION-LOCATION-N  
 INTEGER-OF-BOOLEAN 
 The supported intrinsic functions are listed in the following sections, along with their syntax 
 and usage notes. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.1. ABS,"ABS Function Syntax
  
 ABS(number)  
 ~~~ 
 ———————————————————————————————————————— 
 This function determines and returns the absolute value of the <
 number
 > (a numeric literal 
 or data item) supplied as an argument. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.2. ACOS,"ACOS Function Syntax
  
 ACOS(cosine)  
 ~~~~ 
 ———————————————————————————————————————— 
 The ""ACOS"" function determines and returns the trigonometric arc-cosine, or inverse cosine, 
 of the <
 cosine
 > value (a numeric literal or data item) supplied as an argument. 
 The result will be an angle, expressed in radians. You may convert this to an angle measured 
 in degrees, as follows: 
 ""COMPUTE <
 degrees
 > = ( <
 radians
 > * 180 ) / FUNCTION PI"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.3. ANNUITY,"ANNUITY Function Syntax
  
 ANNUITY(interest-rate, number-of-periods) 
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns a numeric value approximating the ratio of an annuity paid at the 
 specified <
 interest-rate
 > (numeric data item or literal) for each of the specified <
 number-of-
 periods
 > (numeric data items or literals). 
 The <
 interest-rate
 > is the rate of interest paid at each payment. If you only have an annual 
 interest rate and you wish to compute monthly annuity payments, divide the annual 
 interest rate by 12 and use that value for <
 interest-rate
 > on this function. 
 Multiply the result uf this function times the desired principal amount to determine the 
 amount of each period’s payment. 
 A note for the financially challenged: an annuity is basically a reverse loan; an accountant 
 would take the result of this function multiplied by -1 times the principal amount to 
 compute a loan payment you are making. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.4. ASIN,"ASIN Function Syntax
  
 ASIN(sine)  
 ~~~~ 
 ———————————————————————————————————————— 
 The ""ASIN"" function determines and returns the trigonometric arc-sine, or inverse sine, of 
 the <
 sine
 > value (a numeric literal or data item) supplied as an argument. 
 The result will be an angle, expressed in radians. You may convert this to an angle measured 
 in degrees, as follows: 
 ""COMPUTE <
 degrees
 > = ( <
 radians
 > * 180 ) / FUNCTION PI"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.5. ATAN,"ATAN Function Syntax
  
 ATAN(tangent)  
 ~~~~ 
 ————————————————————————————————————————
 Use this function to determine and return the trigonometric arc-tangent, or inverse tangent, of 
 the <
 tangent
 > value (a numeric literal or data item) supplied as an argument. 
 The result will be an angle, expressed in radians. You may convert this to an angle measured 
 in degrees, as follows:  
  
 ""COMPUTE <
 degrees
 > = ( <
 radians
 > * 180 ) / FUNCTION PI"" 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.6. BYTE-LENGTH,"BYTE-LENGTH Function Syntax
  
 BYTE-LENGTH(string)  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 ""BYTE-LENGTH"" returns the length — in bytes — of the specified <
 string
 > (a group item, 
 ""USAGE DISPLAY"" elementary item or alphanumeric literal). This intrinsic function is iden-
 tical to the ""LENGTH-AN"" (see
  [LENGTH-AN], page 278
 ) function. Note that the value 
 returned by this function is not necessarily the number of
  characters
  comprising <
 string
 >, 
 but rather the number of actual
  bytes
  required to store it. 
 For example, if <
 string
 > is encoded using a double-byte characterset such as UNICODE 
 (where each character is represented by 16 bits of storage, not the 8-bits inherent to 
 charac-tersets like ASCII or EBCDIC), then calling this function with a <
 string
 > argument 
 whose ""PICTURE"" (see
  [PICTURE], page 162
 ) is ""X(4)"" would return a value of 8 rather than 
 the value 4. 
 Contrast this with the ""LENGTH"" (see
  [LENGTH], page 277
 ) function. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.7. CHAR,"CHAR Function Syntax
  
 CHAR(integer)  
 ~~~~ 
 ———————————————————————————————————————— 
 This function returns the character in the ordinal position specified by the <
 integer
 > ar-
 gument (a numeric integer literal or data item with a value of 1 or greater) from the 
 ""COLLATING SEQUENCE"" (see
  [OBJECT-COMPUTER], page 58
 ) being used by the pro-gram. 
 For example, if the program is using the (default) ASCII characterset, CHAR(34) returns the 
 34th character in the ASCII characterset — an exclamation-point (""!""). If you are using this 
 function to convert a numeric value to its corresponding ASCII character, you must use an 
 argument value one greater than the numeric value. 
 If an argument whose value is less than 1 or greater than 256 is specified, the character in 
 the program collating sequence corresponding to a value of all zero bits is returned. 
 The following code is an alternative approach when you just wish to convert a number to its 
 ASCII equivalent: 
 01 Char-Value. 
 ... 05 Numeric-Value  
 USAGE BINARY-CHAR. 
 MOVE numeric-character-value TO Numeric-Value 
 The ""Char-Value"" item now has the corresponding ASCII character value. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.8. COMBINED-DATETIME,"COMBINED-DATETIME Function Syntax
  
 COMBINED-DATETIME(days, seconds)  
 ~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns a 12-digit numeric result, the first seven digits of which are the 
 integer value of the <
 days
 > argument (a numeric data item or literal) and the last five of 
 which are the integer value of the <
 seconds
 > argument (also a numeric data item or literal). 
 If a <
 days
 > value less than 1 or greater than 3067671 is specified, or if a <
 seconds
 > value 
 less than 1 or greater than 86400 is specified, a value of 0 is returned and a runtime error 
 will result. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.9. CONCATENATE,"CONCATENATE Function Syntax
  
 CONCATENATE(string-1 [, string-2 ]...)  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function concatenates the <
 string-1
 >, <
 string-2
 >, . . . (group items, ""USAGE DISPLAY"" 
 elementary items and/or alphanumeric literals) together into a single string result. 
 If a numeric literal or ""PIC 9"" identifier is specified as an argument, decimal points, if any, 
 will be removed and negative signs in ""PIC S9"" fields or numeric literals will be inserted as 
 defined by the ""SIGN IS"" (see
  [SIGN IS], page 177
 ) clause (or absence thereof) of the field. 
 Numeric literals are processed as if ""SIGN IS TRAILING SEPARATE"" were in effect. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.10. COS,"COS Function Syntax
  
 COS(angle)  
 ~~~ 
 ———————————————————————————————————————— 
 The ""COS"" function determines and returns the trigonometric cosine of the <
 angle
 > (a 
 numeric literal or data item) supplied as an argument. 
 The <
 angle
 > is assumed to be a value expressed in radians. If you need to determine the 
 cosine of an angle measured in degrees, you first need to convert that angle to radians as 
 follows: 
 ""COMPUTE <
 radians
 > = ( <
 degrees
 > * FUNCTION PI) / 180"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.11. CURRENCY-SYMBOL,"CURRENCY-SYMBOL Function Syntax
  
 CURRENCY-
 SYMBOL  
 ~~~~~~~~~~~
 ~~~~ 
 ———————————————————————————————————————— 
 The ""CURRENCY-SYMBOL"" function returns the currency symbol character currently in 
 effect for the locale under which your program is running.  
 On UNIX systems, your 
 locale is established via the ""LANG"" run-time environment variable (see
  [Run Time 
 Environment Variables], page 522
 ) environment variable. On Windows, the Control Panel’s 
 ""Regional and Language Options"" define the locale. 
 Changing the currency symbol via the ""SPECIAL-NAMES"" (see
  [SPECIAL-NAMES], page 62
 ) 
 paragraph’s ""CURRENCY SYMBOL"" setting will
  not
  affect the value returned by this function. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.12. CURRENT-DATE,"CURRENT-DATE Function Syntax
  
 CURRENT-DATE 
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Returns the current date and time as the following 21-character structure: 
 01 
 CURRENT-DATE-AND-TIME. 
 PIC 9(4). 
 05 CDT-Year 
 05 CDT-Month 
 PIC 9(2). *> 01-12 
 05 CDT-Day 
 PIC 9(2). *> 01-31 
  
 05 CDT-Hour  
 05 CDT-Minutes  
 05 CDT-Seconds  
 05 CDT-Hundredths-Of-Secs 
 PIC 9(2). *> 00-23  
 PIC 9(2). *> 00-59  
 PIC 9(2). *> 00-59  
 PIC 9(2). *> 00-99 
 05 CDT-GMT-Diff-Hours  
 PIC S9(2) 
 SIGN LEADING SEPARATE. 
 05 CDT-GMT-Diff-Minutes  
 PIC 9(2). *> 00 or 30 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.13. DATE-OF-INTEGER,"DATE-OF-INTEGER Function Syntax
  
 DATE-OF-INTEGER(integer)  
 ~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns a numeric calendar date in yyyymmdd (i.e. Gregorian) format. The 
 date is determined by adding the number of days specified as <
 integer
 > (a numeric integer 
 data item or literal) to the date December 31, 1600. For example, ""DATE-OF-INTEGER(1)"" 
 returns 16010101 while ""DATE-OF-INTEGER(150000)"" returns 20110908. 
 A value less than 1 or greater than 3067671 (9999/12/31) will return a result of 0. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.14. DATE-TO-YYYYMMDD,"DATE-TO-YYYYMMDD Function Syntax
  
 DATE-TO-YYYYMMDD(yymmdd [, yy-cutoff ])  
 ~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 You can use this function to convert the six-digit Gregorian date specified as <
 yymmdd
 > (a 
 numeric integer data item or literal) to an eight-digit format (yyyymmdd). 
 The optional <
 yy-cutoff
  > (a numeric integer data item or literal) argument is the year cutoff 
 used to delineate centuries; if the year component of the date meets or exceeds this cutoff 
 value, the result will be 19yymmdd; if the year component of the date is less than the cutoff 
 value, the result will be 20yymmdd. The default cutoff value if no second argument is given 
 will be 50. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.15. DAY-OF-INTEGER,"DAY-OF-INTEGER Function Syntax
  
 DAY-OF-INTEGER(integer)  
 ~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns a calendar date in yyyyddd (i.e. Julian) format. The date is deter-
 mined by adding the number of days specified as integer (a numeric integer data item or 
 literal) to December 31, 1600. For example, ""DAY-OF-INTEGER(1)"" returns 1601001 while 
 ""DAY-OF-INTEGER(250000)"" returns 2011251. 
 A value less than 1 or greater than 3067671 (9999/12/31) will return a result of 0. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.16. DAY-TO-YYYYDDD,"DAY-TO-YYYYDDD Function Syntax
  
 DAY-TO-YYYYDDD(yyddd [, yy-cutoff])  
 ~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 You can use this function to convert the five-digit Julian date specified as <
 yyddd
 > (a numeric 
 integer data item or literal) to a seven-digit numeric Julian format (yyyyddd). 
 The optional <
 yy-cutoff
  > argument (a numeric integer data item or literal) is the year cutoff 
 used to delineate centuries; if the year component of the date meets or exceeds this cutoff 
 value, the result will be 19yyddd; if the year component of the date is less than the cutoff, 
 the result will be 20yyddd. The default cutoff value if no second argument is given will be 
 50. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.17. E,"E Function Syntax
  
 E 
 ~ 
 ———————————————————————————————————————— 
 This function returns the mathematical constant ""E"" 
 (the base of natural log- 
 arithms). 
 The maximum precision with which this value may be returne
 d 
 is 
 2.7182818284590452353602874713526625. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.18. EXCEPTION-FILE,"EXCEPTION-FILE Function Syntax
  
 EXCEPTION-FILE  
 ~~~~~~~~~~
 ~~~~ 
 ———————————————————————————————————————— 
 This function returns I/O exception information from the most-recently executed input or 
 output statement. The information is returned as a 34-character string, where the first two 
 characters are the two-digit file status value (see
  [File Status Codes], page 76
 ) and the 
 remaining 32 are the <
 file-name-1
 > specification from the file’s ""SELECT"" (see
  [SELECT], 
 page 73
 ) statement. 
 The name returned after the file status information will be returned only if the returned file 
 status value is not 00. 
 Since this function has no arguments, no parenthesis should be specified. 
 The 
 documentation of 
 the ""CBL_ERROR_PROC"" built-in system subroutine 
 (see 
 [CBL ERROR PROC], page 536
 ) built-in subroutine illustrates the use of this function. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.19. EXCEPTION-LOCATION,"EXCEPTION-LOCATION Function Syntax
  
 EXCEPTION-
 LOCATION  
 ~~~~~~~~~~~~~
 ~~~~~ 
 ———————————————————————————————————————— 
 This function returns exception information from the most-recently failing statement. The 
 information is returned to a 1023 character string in one of the following formats, 
 depending on the nature of the failure: 
 •
  primary-entry-point-name; paragraph OF section; statement-number
 •
  
 primary-entry-point-name; section; statement-number 
 •
  primary-entry-point-name; paragraph; statement-number 
 •
  primary-entry-point-name; statement-number 
 Since this function has no arguments, no parenthesis should be specified. 
 The program must be compiled with the ""-debug"" switch, ""-ftraceall"" switch or ""-g"" switch 
 for this function to return any meaningful information. 
 The 
 documentation of 
 the ""CBL_ERROR_PROC"" built-in system subroutine 
 (see 
 [CBL ERROR PROC], page 536
 ) built-in subroutine illustrates the use of this function. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.20. EXCEPTION-STATEMENT,"EXCEPTION-STATEMENT Function Syntax
  
 EXCEPTION-
 STATEMENT  
 ~~~~~~~~~~~~~~
 ~~~~~ 
 ————————————————————————————————————————
 This function returns the most-recent COBOL statement that generated an exception con-
 dition. 
 Since this function has no arguments, no parenthesis should be specified. 
 The program must be compiled with the ""-debug"" switch, ""-ftraceall"" switch or ""-g"" switch 
 for this function to return any meaningful information. 
 The 
 documentation of 
 the ""CBL_ERROR_PROC"" built-in system subroutine 
 (see 
 [CBL ERROR PROC], page 536
 ) built-in subroutine illustrates the use of this function. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.21. EXCEPTION-STATUS,"EXCEPTION-STATUS Function Syntax
  
 EXCEPTION-STATUS  
 ~~~~~~~~~~~~
 ~~~~ 
 ———————————————————————————————————————— 
 This function returns the error type (a text string — see column 2 of the upcoming table for 
 the possible values) from the most-recent COBOL statement that generated an exception 
 condition. 
 Since this function has no arguments, no parenthesis should be specified. 
 The 
 documentation of 
 the ""CBL_ERROR_PROC"" built-in system subroutine 
 (see 
 [CBL ERROR PROC], page 536
 ) built-in subroutine illustrates the use of this function. 
 The following are the error type strings, and their corresponding exception codes and de-
 scriptions. 
 Code
  
 Error Type
  
 Description
  
 0101 
 EC-ARGUMENT- 
 Function argument error 
 FUNCTION 
 0202 
 EC-BOUND-ODO 
 OCCURS . . . DEPENDING ON data item out of 
 bounds 
 0204 
 EC-BOUND-PTR 
 Data-pointer contains an address that is out of 
 bounds 
 0205 
 EC-BOUND-REF-MOD 
 Reference modifier out of bounds 
 0207 
 EC-BOUND-SUBSCRIPT 
 Subscript out of bounds 
 0303 
 EC-DATA-INCOMPATIBLE 
 Incompatible data exception 
 0500 
 EC-I-O 
 input-output exception 
 0501 
 EC-I-O-AT-END 
 I-O status ""1x"" 
 0502 
 EC-I-O-EOP 
 An end of page condition occurred 
 0504 
 EC-I-O-FILE-SHARING 
 I-O status ""6x"" 
 0505 
 EC-I-O-IMP 
 I-O status ""9x"" 
  
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.22. EXP,"EXP Function Syntax
  
 EXP(number)  
 ~~~ 
 ———————————————————————————————————————— 
 Computes and returns the value of the mathematical constant ""e"" raised to the power 
 specified by <
 number
 > (a numeric literal or data item). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.23. EXP10,"EXP10 Function Syntax
  
 EXP10(number)  
 ~~~~~ 
 ———————————————————————————————————————— 
 Computes and returns the value of 10 raised to the power specified by <
 number
 > (a numeric 
 literal or data item). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.24. FACTORIAL,"FACTORIAL Function Syntax
  
 FACTORIAL(number
 )  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function computes and returns the factorial value of <
 number
 > (a numeric literal or 
 data item). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.25. FRACTION-PART,"FRACTION-PART Function Syntax
  
 FRACTION-
 PART(number)  
 ~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns that portion of <
 number
 > (a numeric data item or a numeric literal) 
 that occurs to the right of the decimal point. ""FRACTION-PART(3.1415)"", for example, 
 returns a value of 0.1415. This function is equivalent to the expression: 
 <
 number
 > -- FUNCTION INTEGER-PART(<
 number
 >) 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.26. HIGHEST-ALGEBRAIC,"HIGHEST-ALGEBRAIC Function Syntax
  
 HIGHEST-ALGEBRAIC(numeric-identifier)  
 ~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the highest (i.e. largest or farthest away from 0 in a positive direction 
 if <
 numeric-identifier
 > is signed) value that could possibly be stored in the specified 
 <
 numeric-identifier
 >. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.27. INTEGER,"INTEGER Function Syntax
  
 INTEGER(number)  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 The ""INTEGER"" function returns the greatest integer value that is less than or equal to 
 <
 number
 > (a numeric literal or data item). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.28. INTEGER-OF-DATE,"INTEGER-OF-DATE Function Syntax
  
 INTEGER-OF-DATE(date)  
 ~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function converts <
 date
 > (a numeric integer data item or literal) — presumed to be a 
 Gregorian calendar form standard date (YYYYMMDD) — to internal date form (the number 
 of days that have transpired since 1600/12/31). 
 Once in that form, mathematical operations may be performed against the internal date 
 before it is transformed back into a date using the ""DATE-OF-INTEGER"" (see
  [DATE-OF-
 INTEGER], page 258
 ) or ""DAY-OF-INTEGER"" (see
  [DAY-OF-INTEGER], page 260
 ) func-tion. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.29. INTEGER-OF-DAY,"INTEGER-OF-DAY Function Syntax
  
 INTEGER-OF-DAY(date)  
 ~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function converts <
 date
 > (a numeric integer data item or literal) — presumed to be a 
 Julian calendar form standard date (YYYYDDD) — to internal date form (the number of days 
 that have transpired since 1600/12/31). 
 Once in that form, mathematical operations may be performed against the internal date 
 before it is transformed back into a date using the ""DATE-OF-INTEGER"" (see
  [DATE-OF-
 INTEGER], page 258
 ) or ""DAY-OF-INTEGER"" (see
  [DAY-OF-INTEGER], page 260
 ) func-tion. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.30. INTEGER-PART,"INTEGER-PART Function Syntax
  
 INTEGER-PART(number) 
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Returns the integer portion of the value of <
 number
 > (a numeric literal or data item). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.31. LENGTH,"LENGTH Function Syntax
  
 LENGTH(string)  
 ~~~~~~ 
 ———————————————————————————————————————— 
 Returns the length — in characters — of <
 string
 > (a group item, ""USAGE DISPLAY"" ele-
 mentary item or alphanumeric literal). 
 The value returned by this function is not the number of
  bytes
  of storage occupied by string, 
 but rather the number of actual
  characters
  making up the string. For example, if <
 string
 > is 
 encoded using a double-byte characterset such as UNICODE (where each character is 
 represented by 16 bits of storage, not the 8-bits inherent to charactersets like ASCII or 
 EBCDIC), then calling this function with a <
 string
 > argument whose ""PICTURE is X(4)"" 
 would return a value of 4 rather than the value 8 (the actual number of bytes of storage 
 occupied by that item). 
 Comtrast this function with the ""BYTE-LENGTH"" (see
  [BYTE-LENGTH], page 251
 ) and 
 ""LENGTH-AN"" (see
  [LENGTH-AN], page 278
 ) functions. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.32. LENGTH-AN,"LENGTH-AN Function Syntax
  
 LENGTH-AN(string)  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the length — in bytes of storage — of <
 string
 > (a group item, ""USAGE 
 DISPLAY"" elementary item or alphanumeric literal). 
 This intrinsic function is identical to the ""BYTE-LENGTH"" (see
  [BYTE-LENGTH], page 251
 ) 
 function. 
 Note that the value returned by this function is not the number of
  characters
  making up the 
 <
 string
 >, but rather the number of actual
  bytes
  of storage required to store <
 string
 >. For 
 example, if <
 string
 > is encoded using a double-byte characterset such as UNICODE (where 
 each character is represented by 16 bits of storage, not the 8-bits inherent to charac-tersets 
 like ASCII or EBCDIC), then calling this function with a <
 string
 > argument whose ""PICTURE 
 is X(4)"" would return a value of 8 rather than the value 4. 
 Contrast this with the ""LENGTH"" (see
  [LENGTH], page 277
 ) function. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.33. LOCALE-COMPARE,"LOCALE-COMPARE Function Syntax
  
 LOCALE-COMPARE(argument-1, argument-2 [ , locale ]) 
 ~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""LOCALE-COMPARE"" function returns a character indicating the result of comparing 
 <
 argument-1
 > and <
 argument-2
 > using a culturally-preferred ordering defined by a <
 locale
 >. 
 Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an 
 elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of 
 the two arguments are unequal, the shorter will be assumed to be padded to the right with 
 spaces. 
 The two arguments will be compared, character by character, against each other until their 
 relationship to each other can be determined. The comparison is made according to the 
 cultural rules in effect for the specified <
 locale
 > name or for the current locale if no <
 locale
 > 
 argument is specified. Once that relationship is determined, a one-character alphanumeric 
 value will be returned as follows: 
 •
  ""<"" — If <
 argument-1
 > is determined to be less than <
 argument-2
 >
 •
  ""="" 
 — If the two arguments are equal to each other 
 •
  "">"" — If <
 argument-1
 > is determined to be greater than <
 argument-2
 > 
 See
  [LOCALE Names], page 64
 , for a list of typically-available locale names. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.34. LOCALE-DATE,"LOCALE-DATE Function Syntax
  
 LOCALE-DATE(date [, locale ])  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Converts the eight-digit Gregorian <
 date
 > (a numeric integer data item or literal) from 
 yyyymmdd format to the format appropriate to the current locale. On a Windows system, 
 this will be the ""short date"" format as set using Control Panel. 
 You may include an optional second argument to specify the <
 locale
 > name (group item or 
 ""PIC X"" identifier) you’d like to use for date formatting. If used, this second argument 
 must
  
 be an identifier. Locale names are specified using UNIX-standard names. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.35. LOCALE-TIME,"LOCALE-TIME Function Syntax
  
 LOCALE-TIME(time [, locale ])  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Converts the four- (hhmm) or six-digit (hhmmss) <
 time
 > (a numeric integer data item or 
 literal) to a format appropriate to the current locale. On a Windows system, this will be the 
 ""time"" format as set using Control Panel. 
 You may include an optional <
 locale
 > name (a group item or ""PIC X"" identifier) you’d like to 
 use for time formatting. If used, this second argument
  must
  be an identifier. Locale names 
 are specified using UNIX-standard names. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.36. LOCALE-TIME-FROM-SECONDS,"LOCALE-TIME-FROM-SECONDS Function Syntax
  
 LOCALE-TIME-FROM-SECONDS(seconds [, locale ]) 
 ~~~~~~~~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Converts the number of <
 seconds
 > since midnight (a numeric integer data item or literal) to 
 a format appropriate to the current locale. On a Windows system, this will be the ""time"" 
 format as set using Control Panel. 
 You may include an optional <
 locale
 > name (a group item or ""PIC X"" identifier) you’d like to 
 use for time formatting. If used, this second argument
  must
  be an identifier. Locale names 
 are specified using UNIX-standard names. 
 See
  [LOCALE Names], page 64
 , for a list of typically-available locale names. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.37. LOG,"LOG Function Syntax
  
 LOG(number)  
 ~~~ 
 ———————————————————————————————————————— 
 Computes and returns the natural logarithm (base ""e"") of <
 number
 > (a numeric literal or 
 data item). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.38. LOG10,"LOG10 Function Syntax
  
 LOG10(number) 
 ~~~~~ 
 ———————————————————————————————————————— 
 Computes and returns the base 10 logarithm of <
 number
 > (a numeric literal or data item). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.39. LOWER-CASE,"LOWER-CASE Function Syntax
  
 LOWER-CASE(string)  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the value of <
 string
 > (a group item, ""USAGE DISPLAY"" elementary item 
 or alphanumeric literal), converted entirely to lower case. 
 What constitutes a ""letter"" (or upper/lower case too, for that manner) may be influ-enced 
 through the use of a ""CHARACTER CLASSIFICATION"" (see
  [OBJECT-COMPUTER], page 58
 ). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.40. LOWEST-ALGEBRAIC,"LOWEST-ALGEBRAIC Function Syntax
  
 LOWEST-ALGEBRAIC(numeric-identifier)  
 ~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the lowest (i.e. smallest or farthest away from 0 in a negative direc-
 tion if <
 numeric-identifier
 > is signed) value that could possibly be stored in the specified 
 <
 numeric-identifier
 >. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.41. MAX,"MAX Function Syntax
  
 MAX(number-1 [, number-2 ]...)  
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the maximum value from the specified list of numbers (each <
 number-
 n
 > may be a numeric data item or a numeric literal). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.42. MEAN,"MEAN Function Syntax
  
 MEAN(number-1 [, number-2 ]...) 
 ~~~~ 
 ———————————————————————————————————————— 
 This function returns the statistical mean value of the specified list of numbers (each 
 <
 number-n
 > may be a numeric data item or a numeric literal). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.43. MEDIAN,"MEDIAN Function Syntax
  
 MEDIAN(number-1 [, number-2 ]...) 
 ~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the statistical median value of the specified list of numbers (each 
 <
 number-n
 > may be a numeric data item or a numeric literal). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.44. MIDRANGE,"MIDRANGE Function Syntax
  
 MIDRANGE(number-1 [, number-2 ]...)  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""MIDRANGE"" (middle range) function returns a numeric value that is the arithmetic 
 mean (average) of the values of the minimum and maximum numbers from the supplied 
 list. Each <
 number-n
 > may be a numeric data items or a numeric literal. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.45. MIN,"MIN Function Syntax
  
 MIN(number-1 [, number-2 ]...)  
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the minimum value from the specified list of numbers (each <
 number-
 n
 > may be a numeric data item or a numeric literal). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.46. MOD,"MOD Function Syntax
  
 MOD(value, modulus)  
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the value of <
 value
 > modulo <
 modulus
 > (essentially the remainder 
 from the division of <
 value
 > by <
 modulus
 >). Both arguments may be numeric data items or 
 numeric literals. Either (or both) may have a non-integer value. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.47. MODULE-CALLER-ID,"MODULE-CALLER-ID Function Syntax
  
 MODULE-CALLER-
 ID  
 ~~~~~~~~~~~~
 ~~~~ 
 ———————————————————————————————————————— 
 This function returns the null string if it is executed within a main program. When exe-cuted 
 with a subprogram, it returns the entry-point name of the program that called the 
 subprogram. 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.48. MODULE-DATE,"MODULE-DATE Function Syntax
  
 MODULE-
 DATE  
 ~~~~~~~~
 ~~~ 
 ————————————————————————————————————————
 This function Returns the date the GNU COBOL program that is executing the function was 
 compiled, in the form yyyymmdd. 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.49. MODULE-FORMATTED-DATE,"MODULE-FORMATTED-DATE Function Syntax
  
 MODULE-FORMATTED-
 DATE  
 ~~~~~~~~~~~~~~~
 ~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the fully-formatted date and time when the program executing the 
 function was compiled. The exact format of this returned string value may vary depending 
 on the operating system and GNU COBOL build type. 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.50. MODULE-ID,"MODULE-ID Function Syntax
  
 MODULE-ID 
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returmns the primary entry-point name (i.e.  
 the ""PROGRAM-ID"" or 
 ""FUNCTION-ID"" of the program. 
 information on those clauses. 
 See
  [IDENTIFICATION DIVISION], page 53
 , for 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.55. MODULE-PATH,"MODULE-PATH Function Syntax
  
 MODULE-
 PATH  
 ~~~~~~~~
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the full path to the executable version of this GNU COBOL program. 
 The filename component of this value will be exactly as typed on the command line, down to 
 the use of upper- and lowercase letters and presence (or absence) of any extension. 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.52. MODULE-SOURCE,"MODULE-SOURCE Function Syntax
  
 MODULE-
 SOURCE  
 ~~~~~~~~~
 ~~~~ 
 ————————————————————————————————————————
 The filename of the source code of the program (as specified on the ""cobc"" command when the 
 program was compiled) is returned by this function. 
 The discussion of the ""MODULE-TIME"" (see
  [MODULE-TIME], page 299
 ) function includes a 
 sample program that uses this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.53. MODULE-TIME,"MODULE-TIME Function Syntax
  
 MODULE-
 TIME  
 ~~~~~~~~
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the time the GNU COBOL program was compiled, in the form hh-mmss. 
 Since this function has no arguments, no parenthesis should be specified. 
 The following sample program uses all the MODULE- Functions: 
 IDENTIFICATION DIVISION.  
 PROGRAM-ID. 
 DEMOMODULE. 
 ENVIRONMENT DIVISION.  
 CONFIGURATION 
 SECTION.  
 REPOSITORY. 
 FUNCTION ALL INTRINSIC.  
 PROCEDURE DIVISION. 
 000-Main. 
 DISPLAY ""MODULE-CALLER-
 ID DISPLAY ""MODULE-DATE 
 = ["" MODULE-CALLER-ID ""]"" = 
 ["" MODULE-DATE ""]"" 
 DISPLAY ""MODULE-FORMATTED-DATE = ["" MODULE-FORMATTED-DATE ""]"" 
 DISPLAY ""MODULE-ID  
 DISPLAY ""MODULE-PATH 
 DISPLAY ""MODULE-
 SOURCE DISPLAY 
 ""MODULE-TIME STOP RUN  
 . 
 = ["" MODULE-ID ""]""  
 = ["" MODULE-PATH ""]"" = ["" 
 MODULE-SOURCE ""]"" = ["" 
 MODULE-TIME ""]"" 
 The program produces this output when executed: 
 MODULE-CALLER-ID  
 = [] 
 MODULE-DATE  
 = [20120614] 
 MODULE-FORMATTED-DATE = [Jun 14 2012 15:07:45] 
 MODULE-ID  
 = [DEMOMODULE] 
 MODULE-PATH  
 = [E:\Programs\Demos\DEMOMODULE.exe] 
 MODULE-SOURCE  
 = [DEMOMODULE.cbl] 
 MODULE-TIME  
 = [150745]",NA
6.16.54. MONETARY-DECIMAL-POINT,"MONETARY-DECIMAL-POINT Function Syntax
  
 MONETARY-DECIMAL-
 POINT  
 ~~~~~~~~~~~~~~~~
 ~~~~~~ 
 ———————————————————————————————————————— 
 ""MONETARY-DECIMAL-POINT"" returns the character used to separate the integer portion 
 from the fractional part of a monetary currency value according to the rules currently in 
 effect for the locale under which your program is running. 
 On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is 
 established via the ""LANG"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) environment variable. On Windows, the Control Panel’s Regional and 
 Language Options define the locale. 
 Using the ""DECIMAL-POINT IS COMMA"" (see
  [SPECIAL-NAMES], page 62
 ) clause in your 
 program will not affect the value returned by this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.55. MONETARY-THOUSANDS-SEPARATOR,"MONETARY-THOUSANDS-SEPARATOR Function Syntax
  
 MONETARY-THOUSANDS-
 SEPARATOR  
 ~~~~~~~~~~~~~~~~~~~~
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the character used to separate the thousands digit groupings of mon-
 etary currency values according to the rules currently in effect for the locale under which 
 your program is running. 
 On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is 
 established via the ""LANG"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) environment variable. On Windows, the Control Panel’s Regional and 
 Language Options define the locale. 
 Using the ""DECIMAL-POINT IS COMMA"" (see
  [SPECIAL-NAMES], page 62
 ) clause in your 
 program will not affect the value returned by this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.56. NUMERIC-DECIMAL-POINT,"NUMERIC-DECIMAL-POINT Function Syntax
  
 NUMERIC-DECIMAL-
 POINT  
 ~~~~~~~~~~~~~~~
 ~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the character used to separate the integer portion of a non-integer 
 numeric item from the fractional part according to the rules currently in effect for the locale 
 under which your program is running. 
 On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is 
 established via the ""LANG"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) environment variable. On Windows, the Control Panel’s Regional and 
 Language Options define the locale. 
 Using the ""DECIMAL-POINT IS COMMA"" (see
  [SPECIAL-NAMES], page 62
 ) clause in your 
 program will not affect the value returned by this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.57. NUMERIC-THOUSANDS-SEPARATOR,"NUMERIC-THOUSANDS-SEPARATOR Function Syntax
  
 NUMERIC-THOUSANDS-
 SEPARATOR  
 ~~~~~~~~~~~~~~~~~~~
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the character used to separate the thousands digit groupings of nu-
 meric values according to the rules currently in effect for the locale under which your 
 program is running. 
 On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is 
 established via the ""LANG"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) environment variable. On Windows, the Control Panel’s Regional and 
 Language Options define the locale. 
 Using the ""DECIMAL-POINT IS COMMA"" (see
  [SPECIAL-NAMES], page 62
 ) clause in your 
 program will not affect the value returned by this function. 
 Since this function has no arguments, no parenthesis should be specified. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.58. NUMVAL,"NUMVAL Function Syntax
  
 NUMVAL(string)  
 ~~~~~~ 
 ————————————————————————————————————————
 The ""NUMVAL"" function converts a <
 string
 > (a group item, ""USAGE DISPLAY"" elementary item 
 or alphanumeric literal) to its corresponding numeric value. 
 The <
 string
 > must have any of the following formats, where ’#’ represents a sequence of one 
 or more decimal digits: 
 #.# 
 # 
 -# 
 +# 
 #- 
 #+ 
 #CR 
 #DB 
 #CR 
 -#.# 
 +#.# 
 #.#- 
 #.#+ 
 #.#CR 
 #.#DB 
 There must be at least one digit character in the string. 
 Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR 
 and DB characters. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.59. NUMVAL-C,"NUMVAL-C Function Syntax
  
 NUMVAL-C(string[,symbol]) 
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function converts a <
 string
 > (a group item, ""USAGE DISPLAY"" elementary item or 
 alphanumeric literal) representing a currency value to its corresponding numeric value. 
 The optional <
 symbol
 > character represents the currency symbol (a single-character group 
 item, ""USAGE DISPLAY"" elementary item or alphanumeric literal) that may be used as the 
 currency character in <
 string
 >. If no <
 symbol
 > is specified, the value that would be returned 
 by the ""CURRENCY-SYMBOL"" intrinsic function (see
  [CURRENCY-SYMBOL], page 256
 ) will 
 be used. 
 <
 string
 > may have any of the following formats, where ’#’ represents a sequence of one or 
 more decimal digits and ’$’ represents the <
 symbol
 > character: 
 # 
 -#  +#  #- 
 #+ #CR  
 #DB  
 #CR 
 #.# 
 -#.#  
 +#.# #.#- 
 #.#+  
 #.#CR  
 #.#DB 
 $# 
 -$# +$#  
 $#- 
 $#+  $#CR $#DB $#CR 
 $#.#-$#.#  
 +$#.#  
 $#.#-$#.#+  
 $#.#CR  
 $#.#DB 
 There must be at least one digit character in the string. 
 Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency 
 symbol, sign, CR and DB characters. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.60. NUMVAL-F,"NUMVAL-F Function Syntax
  
 NUMVAL-F(char) 
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function converts a <
 string
 > (a group item, ""USAGE DISPLAY"" elementary item or 
 alphanumeric literal) representing a floating-point value to its corresponding numeric value. 
 # 
 -# +# #E#-#E#  
 +#E# 
 #E+#-#E+#  
 +#E+#  
 #E-# 
 -#E-#  
 +#E-# 
 #.#-#.#  
 +#.# #.#E# 
 -#.#E#  
 +#.#E# 
 #.#E+# 
 -#.#E+#  
 +#.#E+#  
 #.#E-#-#.#E-#  
 +#.#E-# 
 There must be at least one digit character both before and after the ""E"" in the string. 
 Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign 
 characters. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.61. ORD,"ORD Function Syntax
  
 ORD(char)  
 ~~~ 
 ———————————————————————————————————————— 
 This function returns the ordinal position in the program characterset (usually ASCII) 
 corresponding to the 1st character of the <
 char
 > argument (a group item, ""USAGE DISPLAY"" 
 elementary item or alphanumeric literal). 
 For example, assuming the program is using the standard ASCII collating sequence, 
 ""ORD(’!’)"" returns 34 because ""!"" is the 34th ASCII character.  
 If you are using this 
 function to convert an ASCII character to its numeric value, you must subtract one from the 
 result. 
 The following code is an alternative approach when you just wish to convert an ASCII 
 character to its numeric equivalent: 
 01 Char-Value. 
 ... 05 Numeric-Value  
 USAGE BINARY-CHAR. 
 MOVE ""character"" TO Char-Value 
 ""Numeric-Value"" now has the numeric value of ""character"". 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.62. ORD-MAX,"ORD-MAX Function Syntax
  
 ORD-MAX(char-1 [, char-2 ]...)  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the ordinal position in the argument list corresponding to the <
 char-
 n
 > whose 1st character has the highest position in the program collating sequence (usually 
 ASCII). 
 For example, assuming the program is using the standard ASCII collating sequence, ""ORD-
 MAX(’Z’, ’z’, ’!’)"" returns 2 because the 2nd character in the argument list (the ASCII 
 character ’z’) occurs after ’Z’ and ’!’ 
 in the program collating sequence. 
 Each <
 char-n
 > argument may be a group item, ""USAGE DISPLAY"" elementary item or 
 alphanumeric literal. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.63. ORD-MIN,"ORD-MIN Function Syntax
  
 ORD-MIN(char-1 [, char-2 ]...)  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the ordinal position in the argument list corresponding to the <
 char-
 n
 > whose 1st character has the lowest position in the program collating sequence (usually 
 ASCII). 
 For example, assuming the program is using the standard ASCII collating sequence, ""ORD-
 MIN(’Z’, ’z’, ’!’)"" returns 3 because the 3rd character in the argument list (the ASCII character 
 ’!’)  
 occurs before ’Z’ and ’z’ in the program collating sequence. Each 
 <
 char-n
 > argument may be a group item, ""USAGE DISPLAY"" elementary item or 
 alphanumeric literal. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.64. PI,"PI Function Syntax
  
 PI  
 ~
 ~ 
 ———————————————————————————————————————— 
 This function returns the mathematical constant ""PI"". The maximum precision with which 
 this value may be returned is 3.1415926535897932384626433832795029. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.65. PRESENT-VALUE,"PRESENT-VALUE Function Syntax
  
 PRESENT-VALUE(rate, value-1 [, value-2 ]) 
 ~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""PRESENT-VALUE"" function returns a value that approximates the present value of a 
 series of future period-end amounts specified by the various <
 value-n
 > arguments at a 
 discount rate specified by the <
 rate
 > argument. 
 All arguments are numeric data items and/or numeric literals. 
 The following equation summarizes how present value is calculated, where ’N’ is the number 
 of <
 value
 > arguments: 
  
 N
  
 value
 i
  
 presentvalue
  = 
 i
 =1
  
 (1 +
  rate
 )
 i
  
  
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.66. RANDOM,"RANDOM Function Syntax
  
 RANDOM[(seed)]  
 ~~~~~~ 
 ———————————————————————————————————————— 
 This function returns a pseudo-random non-integer value in the range 0 to 1 (for example, 
 0.123456789). 
 The purpose of the optional <
 seed
 > argument, is to initialize the chain of pseudo-random 
 numbers that will be returned by the function. Not only will calls to this function using the 
 same <
 seed
 > value return the same pseudo-ranom number, but so will all subsequent 
 executions of the function without a <
 seed
 >.  
 This is actually a good thing when you are 
 testing your program because you can rely on always receiving the same sequence of 
 ""random"" numbers if you always start uising the same <
 seed
 >. 
 The <
 seed
 > may be any form of literal or data item. If <
 seed
 > is numeric, its numeric value 
 will serve as the seed value. If <
 seed
 > is alphanumeric, a value for it will be determined as if 
 it were used as an argument to ""NUMVAL"" (see
  [NUMVAL], page 304
 ). 
 Take, for example, the following sample program: 
 IDENTIFICATION DIVISION.  
 PROGRAM-ID. 
 DEMORANDOM.  
 DATA DIVISION. 
 WORKING-STORAGE SECTION. 
 01 
 Pseudo-Random-Number 
 USAGE COMP-1. 
 PROCEDURE DIVISION. 
 000-Main. 
 MOVE FUNCTION RANDOM(1) TO Pseudo-Random-Number 
 DISPLAY Pseudo-Random-Number  
 PERFORM 4 TIMES  
 MOVE FUNCTION RANDOM TO Pseudo-Random-Number 
 DISPLAY Pseudo-Random-Number  
 END-PERFORM  
 STOP RUN  
 . 
 Every time this program is executed, it will produce the same output, because the same 
 sequence of pseudo-random numbers will be generated: 
 0.41  
 0.18467  
 0.63340002  
 0.26499999 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.67. RANGE,"RANGE Function Syntax
  
 RANGE(number-1 [, number-2 ]...)  
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""RANGE"" function returns a value that is equal to the value of the maximum <
 number-n
 > 
 in the argument list minus the value of the minimum <
 number-n
 > argument. 
 All <
 number-n
 > arguments are numeric data items and/or numeric literals. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.68. REM,"REM Function Syntax
  
 REM(number,divisor)  
 ~~~ 
 ———————————————————————————————————————— 
 This function returns a numeric value that is the remainder of <
 number
 > divided by <
 divi-
 sor
 >. Both arguments must be numeric data items or numeric literals. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.69. REVERSE,"REVERSE Function Syntax
  
 REVERSE(string)  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the byte-by-byte reversed value of the specified <
 string
 > (a group item, 
 USAGE DISPLAY elementary item or alphanumeric literal). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.70. SECONDS-FROM-FORMATTED-TIME,"SECONDS-FROM-FORMATTED-TIME Function Syntax
  
 SECONDS-FROM-FORMATTED-
 TIME(format,time)  
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function decodes the string <
 time
 > — whose value represents a formatted time — and 
 returns the total number of seconds that string represents. 
 The <
 time
 > string must contain hours, minutes and seconds. The time argument may be 
 specified as a group item, ""USAGE DISPLAY"" elementary item or an alphanumeric literal. 
 The <
 format
 > argument is a string (a group item, ""USAGE DISPLAY"" elementary item or an 
 alphanumeric literal) documenting the format of <
 time
 > using ""hh"", ""mm"" and ""ss"" to denote 
 where the respective time information can be found. Any other characters found in <
 format
 > 
 represent character positions that will be ignored. For example, a format of ""hhmmss"" 
 indicates that <
 time
 > will be treated as a six-digit string value where the first two characters 
 are the number of hours, the next two represent minutes and the last two represent seconds. 
 A <
 format
 > of ""hh:mm:ss"", however, describes <
 time
 > as an eight-character string where 
 characters 3 and 6 will be ignored. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.71. SECONDS-PAST-MIDNIGHT,"SECONDS-PAST-MIDNIGHT Function Syntax
  
 SECONDS-PAST-
 MIDNIGHT  
 ~~~~~~~~~~~~~~~
 ~~~~~~ 
 ————————————————————————————————————————
 This function returns the current time of day expressed as the total number of elapsed 
 seconds since midnight. 
 Since this function has no arguments, no parenthesis should be specified. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.72. SIGN,"SIGN Function Syntax
  
 SIGN(number)  
 ~~~~ 
 ———————————————————————————————————————— 
 The ""SIGN"" function returns a -1 if the value of <
 number
 > (a numeric literal or numeric data 
 item) is negative, a zero if the value of <
 number
 > is exactly zero and a 1 if the value of 
 <
 number
 > if greater than 0. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.73. SIN,"SIN Function Syntax
  
 SIN(angle)  
 ~~~ 
 ———————————————————————————————————————— 
 This function determines and returns the trigonometric sine of the specified <
 angle
 > (a 
 numeric literal or numeric data item). 
 The <
 angle
 > is assumed to be a value expressed in radians. If you need to determine the 
 sine of an angle measured in degrees, you first need to convert that angle to radians as 
 follows: 
 ""COMPUTE <
 radians
 > = ( <
 degrees
 > * FUNCTION PI) / 180"" 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.74. SQRT,"SQRT Function Syntax
  
 SQRT(number
 )  
 ~~~~ 
 ———————————————————————————————————————— 
 The ""SQRT"" function returns a numeric value that approximates the square root of 
 <
 number
 > (a numeric data item or numeric literal with a non-negative value). 
 The following two statements produce identical results: 
 01 
 Result 
 PIC 9(4).9(10). 
 ... 
 MOVE FUNCTION SQRT(15) TO Result  
 COMPUTE Result = 15 ^ 0.5 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.75. STANDARD-DEVIATION,"STANDARD-DEVIATION Function Syntax
  
 STANDARD-DEVIATION(number-1 [, number-2 ]...) 
 ~~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the statistical standard deviation of the list of <
 number-n
 > arguments 
 (numeric data items or numeric literals). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.76. STORED-CHAR-LENGTH,"STORED-CHAR-LENGTH Function Syntax
  
 STORED-CHAR-
 LENGTH(string)  
 ~~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 Returns the length — in bytes — of the specified ""string"" (a group item, ""USAGE DISPLAY"" 
 elementary item or alphanumeric literal), minus the total number of trailing spaces, if any. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.77. SUBSTITUTE,"SUBSTITUTE Function Syntax
  
 SUBSTITUTE(string, from-1, to-1 [, from-n, to-n ]...) 
 ~~~~~~~~~~ 
 ————————————————————————————————————————
 This function parses the specified <
 string
 >, replacing all occurrences of the <
 from-n
 > strings 
 with the corresponding <
 to-n
 > strings. 
 The <
 from-n
 > strings must match sequences in <
 string
 > exactly with regard to value and 
 case. 
 A <
 from-n
 > string does not have to be the same length as its corresponding <
 to-n
 > string. All 
 arguments are group items, <
 USAGE DISPLAY
  > elementary items or alphanumeric literals. 
 A null <
 to-n
 > string will be treated as a single space. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.78. SUBSTITUTE-CASE,"SUBSTITUTE-CASE Function Syntax
  
 SUBSTITUTE-CASE(string, from-1, to-1 [, from-n, to-n ]...) 
 ~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SUBSTITUTE-CASE"" function operates the same as the ""SUBSTITUTE"" (see 
 [SUBSTITUTE], page 324
 ) function, except that <
 from-n
 > string matching is performed 
 without regard to case. 
 All arguments are group items, ""USAGE DISPLAY"" elementary items or alphanumeric literals. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.79. SUM,"SUM Function Syntax
  
 SUM(number-1 [, number-2 ]...)  
 ~~~ 
 ———————————————————————————————————————— 
 The ""SUM"" function returns a value that is the sum of the <
 number-n
 > arguments (these may 
 be numeric data items or numeric literals). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.80. TAN,"TAN Function Syntax
  
 TAN(angle)  
 ~~~ 
 ———————————————————————————————————————— 
 This function determines and returns the trigonometric tangent of the specified <
 angle
 > (a 
 numeric literal or numeric data item). 
 The <
 angle
 > is assumed to be a value expressed in radians. If you need to determine the 
 tangent of an angle measured in degrees, you first need to convert that angle to radians as 
 follows: 
 ""COMPUTE <
 radians
 > = ( <
 degrees
 > * FUNCTION PI) / 180"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.81. TEST-DATE-YYYYMMDD,"TEST-DATE-YYYYMMDD Function Syntax
  
 TEST-DATE-
 YYYYMMDD(date)  
 ~~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function determines if the supplied <
 date
 > argument (a numeric integer data item or 
 literal) is a valid date. 
 A valid date is one of the form yyyymmdd in the range 1601/01/01 to 9999/12/31, with no 
 more than the expected maximum number of days in the month, accounting for leap year. 
 If the <
 date
 > is valid, a 0 value is returned. If it isn’t, a value of 1, 2 or 3 is returned signaling 
 the problem lies with the year, month or day, respectively. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.82. TEST-DAY-YYYYDDD,"TEST-DAY-YYYYDDD Function Syntax
  
 TEST-DATE-
 YYYYDDD(date)  
 ~~~~~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function determines if the supplied <
 date
 > (a numeric integer data item or literal) is a 
 valid date. 
 A valid date is one of the form yyyyddd in the range 1601001 to 9999365. Leap year is 
 accounted for in determining the maximum number of days in a year. 
 If the date is valid, a 0 value is returned. If it isn’t, a value of 1 or 2 is returned signaling the 
 problem lies with the year or day, respectively. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.83. TEST-NUMVAL,"TEST-NUMVAL Function Syntax
  
 TEST-NUMVAL(string)  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""TEST-NUMVAL"" function evaluates the specified <
 string
 > (a group item, ""USAGE 
 DISPLAY"" elementary item or alphanumeric literal) for being appropriate for use as the 
 <
 string
 > argument to a ""NUMVAL"" (see
  [NUMVAL], page 304
 ) function, returning a TRUE 
 value if it is appropriate and FALSE otherwise. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.84. TEST-NUMVAL-C,"TEST-NUMVAL-C Function Syntax
  
 TEST-NUMVAL-C(string[,symbol])  
 ~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function evaluates the specified <
 string
 > (a group item, ""USAGE DISPLAY"" elementary 
 item or alphanumeric literal) for being appropriate for use as the <
 string
 > argument to a 
 ""NUMVAL-C"" (see
  [NUMVAL-C], page 305
 ) function, returning a TRUE value if it is 
 appropriate and FALSE otherwise. 
 The optional <
 symbol
 > argument serves the same function — and has the same default and 
 possible values — as the corresponding argument of the ""NUMVAL-C"" function. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.85. TEST-NUMVAL-F,"TEST-NUMVAL-F Function Syntax
  
 TEST-NUMVAL-F(string)  
 ~~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function evaluates the specified <
 string
 > (a group item, ""USAGE DISPLAY"" elemen-tary 
 item or alphanumeric literal) for being appropriate for use as the <
 string
 > argument to a 
 ""NUMVAL-F"" (see
  [NUMVAL-F], page 306
 ) function, returning a TRUE value if it is 
 appropriate and FALSE otherwise. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.86. TRIM,"TRIM Function Syntax
  
 TRIM(string [, LEADING|TRAILING ])  
 ~~~~ ~~~~~~~ ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function removes ""LEADING"" or ""TRAILING"" spaces from the specified <
 string
 > (a 
 group item, ""USAGE DISPLAY"" elementary item or alphanumeric literal). 
 The second argument is specified as a keyword, not a quoted string or identifier. If no 
 second argument is specified,
  both
  leading and trailing spaces will be removed. The case 
 (upper, lower or mixed) of this argument is irrelevant. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.87. UPPER-CASE,"UPPER-CASE Function Syntax
  
 UPPER-CASE(string)  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the value of <
 string
 > (a group item, ""USAGE DISPLAY"" elementary item 
 or alphanumeric literal), converted entirely to upper case. 
 What constitutes a ""letter"" (or upper/lower case too, for that manner) may be influ-enced 
 through the use of a ""CHARACTER CLASSIFICATION"" (see
  [OBJECT-COMPUTER], page 58
 ). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.88. VARIANCE,"VARIANCE Function Syntax
  
 VARIANCE(number-1 [, number-2 ]...)  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This function returns the statistical variance of the specified list of <
 number-n
 > arguments 
 (these may be numeric data items or numeric literals). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.16.89. WHEN-COMPILED,"WHEN-COMPILED Function Syntax
  
 WHEN-
 COMPILED  
 ~~~~~~~~~
 ~~~~ 
 ———————————————————————————————————————— 
 The ""WHEN-COMPILED"" intrinsic function, not to be confused with the ""WHEN-COMPILED"" 
 (see
  [Special Registers], page 243
 ) special register, returns the date and time the program 
 was compiled, in ASCII. 
 Since this function has no arguments, no parenthesis should be specified. 
 Unlike the ""WHEN-COMPILED"" special register, which has an ASCII value of the compila-
 tion date/time in the format ""mm/dd/yyhh.mm.ss"", the ""WHEN-COMPILED"" intrinsic func-
 tion returns the compilation date/time as an ASCII string in the format ""yyyymmddhh-
 mmssnnooooo"", where ""yyyymmdd"" is the date, ""hhmmss"" is the time, ""nn"" is the hun-
 dredths of a second component of the compilation time, if available (or ""00"" if it isn’t) and 
 ""ooooo"" is the timezone offset from GMT. 
 If the ""-fintrinsics=WHEN-COMPILED"" switch or ""-fintrinsics=ALL"" switch is specified to the 
 compiler or the ""REPOSITORY"" (see
  [REPOSITORY], page 60
 ) paragraph specifies either 
 ""FUNCTION WHEN-COMPILED INTRINSIC"" or ""FUNCTION ALL INTRINSIC"", then ref-
 erences to ""WHEN-COMPILED"" (without a leading ""FUNCTION"" keyword will always 
 reference this intrinsic function and there will be no way to access the ""WHEN-COMPILED"" 
 special register. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.16.90. YEAR-TO-YYYY,"YEAR-TO-YYYY Function Syntax
  
 YEAR-TO-YYYY(yy [, yy-cutoff ])  
 ~~~~~~~~~~~~ 
 ————————————————————————————————————————
 ""YEAR-TO-YYYY"" converts <
 yy
 > — a two-digit year — to a four-digit format (yyyy). The 
 optional <
 yy-cutoff
  > argument is the year cutoff used to delineate centuries; if <
 yy
 > meets or 
 exceeds this cutoff value, the result will be 19yy; if <
 yy
 > is less than the cutoff, the result will 
 be 20yy. The default cutoff value if no second argument is given will be 50. Both arguments 
 must be numeric data items or numeric literals. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17. GNU COBOL Statements,NA,NA
6.17.1. ACCEPT,NA,NA
6.17.1.1. ACCEPT FROM CONSOLE,"ACCEPT FROM CONSOLE Syntax
  
  
 ACCEPT identifier-1  
  
 ~~~~~~  
  
  [ FROM mnemonic-name-1 ]  
  
   
 ~~~~  
 [ END-ACCEPT ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to read a value from the console window or 
 the standard input device and store it into a data item (<
 identifier-1
 >). 
 1. If no ""FROM"" clause is specified, ""FROM CONSOLE"" is assumed. 
 2. The specified <
 mnemonic-name-1
 > must either be one of the built-in device names 
 ""CONSOLE"", ""STDIN"", ""SYSIN"" or ""SYSIPT"", or a user-defined (see
  [SPECIAL-NAMES], 
 page 62
 ) mnemonic name
  attached
  to one of those four device names. 
 3. Input will be read either from the console window (""CONSOLE"") or from the system-
 standard input (pipe 0 = ""STDIN"", ""SYSIN"" or ""SYSIPT"") and will be saved in <
 identifier-
 1
 >. 
 4. If <
 identifier-1
 > is a numeric data item, the character value read from the console or 
 standard-input device will be parsed according to the rules for input to the ""NUMVAL"" 
 intrinsic function (see
  [NUMVAL], page 304
 ), except that none of the trailing sign 
 formats are honored. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.1.2. ACCEPT FROM COMMAND-LINE,"ACCEPT FROM COMMAND-LINE Syntax
  
 ACCEPT identifier-1  
 ~~~~~~  
  
 FROM { COMMAND-LINE  
 } 
  
 ~~~~ { ~~~~~~~~~~~~  
 } 
  
  
 { ARGUMENT-NUMBER  
 } 
  
  
 { ~~~~~~~~~~~~~~~  
 } 
  
  
 { ARGUMENT-VALUE  
 } 
  
  
 { ~~~~~~~~~~~~~~  
 } 
  
  
 { [ ON EXCEPTION imperative-statement-1 ]  
 } 
  
  
 {  
 ~~~~~~~~~  
 } 
  
  
 { [ NOT ON EXCEPTION imperative-statement-2 ] } 
 [ END-ACCEPT ] 
 ~~~ 
 ~~~~~~~~~ 
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve information from the programs 
 command-line. 
 1. The reserved word ""ON"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. When you accept from the ""COMMAND-LINE"" option, you will retrieve the entire set of 
 arguments entered on the command line that executed the program, exactly as they 
 were specified. Parsing that returned data into its meaningful information will be your 
 responsibility. 
 3. By accepting from ""ARGUMENT-NUMBER"", you will be asking the GNU COBOL run-time 
 system to parse the arguments from the command-line and return the number of 
 arguments found. Parsing will be conducted according to the following rules: 
 A. Arguments will be separated by treating spaces and/or tab characters as the delim-
 iters between arguments. The number of such delimiters separating two non-
 blank argument values is irrelevant. 
 B. Strings enclosed in double-quote characters ("") will be treated as a single argument, 
 regardless of how many spaces or tab characters (if any) might be imbedded 
 within those quotation characters. 
 C. On Windows systems, single-quote, or apostrophe characters (’) will be treated just 
 like any other data character and will NOT delineate argument strings. 
 4. By accepting from ""ARGUMENT-VALUE"",  
 you will be asking the GNU COBOL run-time 
 system to parse the arguments from the command-line and return the ""current"" argument. 
  
 You specify which argument number is ""current"" via the 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.1.3. ACCEPT FROM ENVIRONMENT,"ACCEPT FROM ENVIRONMENT Syntax
  
  
 ACCEPT identifier-1  
  
 ~~~~~~  
  
  
  
 FROM { ENVIRONMENT-VALUE  
  
 } 
  
  
  
 ~~~~ { ~~~~~~~~~~~~~~~~~  
  
 } 
  
  
  
  
  
 { ENVIRONMENT { literal-1  
 } }  
  
  
  
  
 { ~~~~~~~~~~~ { identifier-1 } }   
 [ ON 
 EXCEPTION imperative-statement-1 ]  
  
  
  
 ~~~~~~~~~  
  
  
 [ NOT ON EXCEPTION imperative-statement-2 ] 
  
  
  
 ~~~   
 ~~~~~~~~~  
 [ END-ACCEPT ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve environment variable values. 
 1. The reserved word ""ON"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. By accepting from ""ENVIRONMENT-VALUE"", you will be asking the GNU COBOL run-time 
 system to retrieve the value of the environment variable whose name is currently in the 
 ""ENVIRONMENT-NAME"" register.  
 A value may be placed into the 
 ""ENVIRONMENT-NAME"" register using the ""ENVIRONMENT-NAME"" option of the 
 ""DISPLAY"" statement (see
  [DISPLAY UPON ENVIRONMENT-NAME], page 373
 ). 
 3. A simpler approach to retrieving an environment variables value is to use the 
 ""ENVIRONMENT"" option, where you specify the environment variable whose value is 
 to be retrieved right on the ""ACCEPT"" statement itself. 
 4. The optional ""ON EXCEPTION"" and ""NOT ON EXCEPTION"" clauses may be used to detect 
 and react to an attempt to retrieve the value of a non-existant environment variable or 
 the successful retrieval of an environment variable’s value, respectively. See
  [ON 
 EXCEPTION + NOT ON EXCEPTION], page 238
 , for additional information. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.1.4. ACCEPT screen-data-item,"ACCEPT screen-data-item Syntax
  
 ACCEPT identifier-1 [ FROM CRT ] [ MODE IS BLOCK ] 
 ~~~~~~ ~~~~ ~~~  
 ~~~~  
 ~~~~~ 
 [ AT { | LINE NUMBER { integer-1  
 } | } ] 
 ~~ { | ~~~~  
 { identifier-2 }  
 | } 
 { | COLUMN|POSITION NUMBER { integer-2  
 } | } 
 { | ~~~~~~ ~~~~~~~~  
 { identifier-3 } | } 
 {  
 } 
 { { integer-3  
 }  
 } 
 { { identifier-4 }  
 } 
 [ WITH [ Attribute-Specification ]... 
 ~~~~ 
 [ LOWER|UPPER ] 
 ~~~~~ ~~~~~ 
 [ SCROLL { UP  
 } [ { integer-4  
 } LINE|LINES ] ] 
 ~~~~~~ { ~~ } { identifier-5 } 
 { DOWN } 
 ~~~~ 
 [ TIMEOUT|TIME-OUT AFTER { integer-5  
 } ] 
  
 ~~~~~~~ 
 ~~~~~~~~  
 [ CONVERSION ]  
  
 ~~~~~~~~~~  
 [ UPDATE ] ]  
  
 ~~~~~~ 
 { identifier-6 } 
  
  
 [ ON EXCEPTION imperative-statement-1 ]   
  
  
 ~~~~~~~~~  
  
  
 [ NOT ON EXCEPTION imperative-statement-2 ]  
  
 ~~~  
 ~~~~~~~~~  
 [ END-ACCEPT ]  
  
 ~~~~~~~~~~ 
 The ""FROM CRT"", ""MODE IS BLOCK"", ""CONVERSION"" and ""UPDATE"" clauses are syntactically 
 recognized but are otherwise non-functional. 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve data from a formatted console 
 window screen. 
 1. The reserved words ""AFTER"", ""IS"", ""NUMBER"" and ""ON"" are optional and may be in-
 cluded, or not, at the discretion of the programmer. The presence or absence of these 
 words has no effect upon the program. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.1.5. ACCEPT FROM DATE/TIME,"ACCEPT FROM DATE/TIME Syntax
  
 ACCEPT identifier-1 FROM { DATE [ YYYYMMDD ] } 
 ~~~~~~ 
 ~~~~ { ~~~~ ~~~~~~~~ } 
 [ END-ACCEPT ] 
 { DAY [ YYYYDDD ] 
 } 
 { ~~~ 
 ~~~~~~~ 
 } 
 { DAY-OF-WEEK 
 } 
 { ~~~~~~~~~~~ 
 } 
 { TIME 
 } 
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve the current system date, time or 
 current day of the week and store it into a data item. 
 1. The data retrieved from the system and the format in which it is structured will vary, 
 as follows: 
 Syntax
  
 Data Retrieved
  
 Format
  
 ""DATE"" 
 Current date in Gregorian form 
 yymmdd 
 ""DATE YYYYMMDD"" 
 Current date in Gregorian form 
 yyyymmdd 
 ""DAY"" 
 Current date in Julian form 
 yyddd 
 ""DAY YYYYDDD"" 
 Current date in Julian form 
 yyyyddd 
 ""TIME"" 
 Time, including hundredths of a second 
 hhmmssnn 
 (nn) 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.1.6. ACCEPT FROM Screen-Info,"ACCEPT FROM Screen-Info Syntax
  
  
 ACCEPT identifier-1  
  
 ~~~~~~  
  
  
 FROM { LINES|LINE-NUMBER }  
  
  
 ~~~~ { ~~~~~ 
 ~~~~~~~~~~~ }  
  
  
  
 { COLS|COLUMNS  
 }  
  
  
  
 { ~~~~ ~~~~~~~  
 }  
  
  
  
 { ESCAPE KEY  
 }  
  
  
  
  
 ~~~~~~ ~~~  
 [ END-ACCEPT ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve information about the console 
 window or about the user’s interactions with it. 
 1. The reserved words ""LINES"" and ""LINE-NUMBER"" are interchangeable. 
 2. The reserved words ""COLS"" and ""COLUMNS"" are interchangeable. 
 3. The following points pertain to the use of the ""LINES"" and ""COLUMNS"" options: 
 A. The ""LINES"" and ""COLUMNS"" options will retrieve the respective components of the 
 size of the console display. 
 B. When the console is running in a windowed environment, this will be the sizing of 
 the window in which the program is executing, in terms of horizontal 
 (""COLUMNS"") or vertical (""LINES"") character counts — not pixels. 
 C. When the system is not running a windowing environment, the physical console 
 screen attributes will be returned. 
 D. Values of 0 will be returned if GNU COBOL was not generated to include screen I/O. 
 E. See the documentation on the ""CBL_GET_SCR_SIZE"" built-in system subroutine (see
  
 [CBL GET SCR SIZE], page 541
 ) for another way to retrieve this informa-tion. 
 4. The ""ESCAPE KEY"" option may be used after the ""ACCEPT FROM Screen-Info"" state-
 ment (see
  [ACCEPT FROM Screen-Info], page 348
 ) has executed. The result returned 
 will be the four-digit ""CRT STATUS"" (see
  [SPECIAL-NAMES], page 62
 ) identifier value. 
 See
  [CRT STATUS Codes], page 345
 , for the specific code values. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.1.7. ACCEPT FROM Runtime-Info,"ACCEPT FROM Runtime-Info Syntax
  
  
 ACCEPT identifier-1  
  
 ~~~~~~  
  
  
 FROM { EXCEPTION STATUS }  
  
  
 ~~~~ { ~~~~~~~~~ 
 ~~~~~~ }  
  
  
  
 { USER NAME  
 }  
  
  
  
  
 ~~~~ ~~~~  
 [ END-ACCEPT ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ACCEPT"" statement is used to retrieve run-time information such as the 
 most-recent error exception code and the current user’s user name. 
 1. The following points pertain to the use of the ""EXCEPTION STATUS"" option: 
 A. <
 identifier-1
 > must be defined as a ""PIC X(4)"" item. 
 B. See
  [Error Exception Codes], page 266
 , for a complete list of the exception codes and 
 their meanings. 
 C. An alternative to the use of ""ACCEPT FROM Runtime-Info"" is to use the ""EXCEPTION-
 STATUS"" intrinsic function (see
  [EXCEPTION-STATUS], page 266
 ). 
 2. The following points pertain to the use of the ""USER NAME"" option: 
 A. The returned result is the userid that was used to login to the system with, and not 
 any actual first and/or last name of the user in question (unless, of course, that is 
 the information used as a logon id). 
 B. <
 identifier-1
 > should be defined large enough to receive the longest user-name on 
 the system. 
 C. If insufficient space is allocated, the returned value will be truncated. 
 D. If excess space is allocated, the returned value will be padded with spaces (to the 
 right). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.2. ADD,NA,NA
6.17.2.1. ADD TO,"ADD TO Syntax
  
 ADD { literal-1 
 }... 
 ~~~ { identifier-1 } 
 TO { identifier-2  
 ~~  
  
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }... 
  
  
  
  
 ~~~~~~~  
 ~~~~  
 { ~~~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
  
  
 { NEAREST-AWAY-FROM-ZERO } 
  
  
  
  
  
  
  
  
 { 
 ~~~~~~~~~~~~~~~~~~~~~~ }  
  
  
  
  
  
  
  
 { NEAREST-EVEN  
 } 
  
  
  
  
  
  
  
  
 { ~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
  
  
 { NEAREST-TOWARD-ZERO  } 
  
  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~ 
  
 }   
  
  
  
  
  
  
 { PROHIBITED  
 } 
  
  
  
  
  
  
  
  
 { ~~~~~~~~~~  
 } 
  
  
  
  
  
  
  
  
 { TOWARD-GREATER  
 } 
  
  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
  
  
 { TOWARD-LESSER  
 } 
  
  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
  
  
 { TRUNCATION  
 } 
  
  
  
  
  
  
  
  
  
 ~~~~~~~~~~  
  
 [ ON SIZE ERROR imperative-statement-1 ]  
  
  
  
  
 ~~~~ ~~~~~  
  
 [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
  
 ~~~  ~~~~ ~~~~~  
 [ END-ADD ]  
  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ADD"" statement generates an intermediate arithmetic sum of the values 
 of all <
 identifier-1
 > and <
 literal-1
 >) items. The value of each <
 identifier-2
 > will be replaced, 
 in turn, by the sum of that <
 identifier-2
 >s value and the intermediate sum. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items while 
 <
 literal-1
 > must be a numeric literal. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.2.2. ADD GIVING,"ADD GIVING Syntax
  
 ADD { literal-1 
 }... 
 ~~~ { identifier-1 } 
 [ TO identifier-2 ] 
 ~~ 
 GIVING { identifier-3 
 ~~~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }... 
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~  
 } 
 { NEAREST-AWAY-FROM-ZERO } 
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 { NEAREST-EVEN  
 } 
 { ~~~~~~~~~~~~  
 } 
 { NEAREST-TOWARD-ZERO  } 
 { ~~~~~~~~~~~~~~~~~~~  
 } 
 { PROHIBITED  
 } 
 { ~~~~~~~~~~  
 } 
 { TOWARD-GREATER  
 } 
 { ~~~~~~~~~~~~~~  
 } 
 { TOWARD-LESSER  
 } 
 { ~~~~~~~~~~~~~  
 } 
 { TRUNCATION  
 } 
 ~~~~~~~~~~ 
 [ ON SIZE ERROR imperative-statement-1 ] 
 ~~~~ ~~~~~ 
 [ NOT ON SIZE ERROR imperative-statement-2 ] 
 ~~~ ~~~~ ~~~~~ 
 [ END-ADD ] 
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ADD"" statement generates the arithmetic sum of the values of all 
 <
 identifier-1
 >, <
 literal-1
 >) and <
 identifier-2
 > (if any) items and then saves that sum to 
 each <
 identifier-3
 >. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items while 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.2.3. ADD CORRESPONDING,"ADD CORRESPONDING Syntax
  
  
 ADD CORRESPONDING identifier-1  
  
 ~~~  
  
  
 TO identifier-2  
  
  
 ~~  
  
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ]  
  
 ~~~~~~~   
 ~~~~  
  
 { ~~~~~~~~~~~~~~  }   
  
  
  
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ }  
  
  
  
  
  
  
 { NEAREST-EVEN  
 }  
  
  
  
  
  
  
 { ~~~~~~~~~~~~  
 }  
  
  
  
  
  
  
 { NEAREST-TOWARD-ZERO  
 }  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~  
 }  
  
  
  
  
  
  
 { PROHIBITED  
 }  
  
  
  
  
  
  
 { ~~~~~~~~~~  
 }  
  
  
  
  
  
  
 { TOWARD-GREATER  
 }  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~  
 }  
  
  
  
  
  
  
 { TOWARD-LESSER  
 }  
  
  
  
  
  
  
 { ~~~~~~~~~~~~~  
 }  
  
  
  
  
  
  
 { TRUNCATION  
 }  
  
  
  
  
  
  
 ~~~~~~~~~~  
  
 [ ON SIZE ERROR imperative-statement-1 ]  
  
  
  
  
 ~~~~ ~~~~~  
  
 [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
  
 ~~~ ~~~~ ~~~~~  
 [ END-ADD ]  
  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""ADD"" statement generates code equivalent to individual ""ADD TO"" (see 
 [ADD TO], page 350
 ) statements for corresponding matches of data items found 
 subordinate to the two identifiers. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be group items. 
 3. See
  [CORRESPONDING], page 236
 , for information on how corresponding matches will 
 be found between <
 identifier-1
 > and <
 identifier-2
 >. 
 4. The optional ""ROUNDED"" (see
  [ROUNDED], page 240
 ) clause available to each 
 <
 identifier-3
 > will control how non-integer results will be saved. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.3. ALLOCATE,"ALLOCATE Syntax
  
 ALLOCATE { expression-1 CHARACTERS } [ { INITIALIZED } ] 
 ~~~~~~~~ { identifier-1 ~~~~~~~~~~ } { 
 ~~~~~~~~~~~ 
 }  
 { INITIALISED } 
 [ RETURNING identifier-2 ] 
  
 ~~~~~~~~~~~ 
  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""ALLOCATE"" statement is used to dynamically allocate memory at run-time. 
 1. The reserved words ""INITIALIZED"" and ""INITIALISED"" are interchangeable. 
 2. Both <
 identifier-1
 > and ""RETURNING <
 identifier-2
 >"" may not be specified in the same 
 statement. 
 3. If used, <
 expression-1
 > must be an arithmetic expression with a non-zero positive integer 
 value. 
 4. If used, <
 identifier-1
 > should be an 01-level item defined in working-storage or local-
 storage with the ""BASED"" (see
  [BASED], page 130
 ) attribute. It may be an 01 item 
 defined in the linkage section without the ""BASED"" attribute, but using such a data item 
 is not recommended. 
 5. If used, <
 identifier-2
 > should be a ""POINTER"" (see
  [USAGE], page 186
 ) data item. 
 6. The optional ""RETURNING"" clause will return the address of the allocated memory block 
 into the specified ""USAGE POINTER"" <
 identifier-2
 > data item. When this option is used, 
 knowledge of the originally-requested size of the allocated memory block will be 
 retained by the program in case a ""FREE"" (see
  [FREE], page 390
 ) statement is ever 
 issued against <
 identifier-2
 >. 
 7. When the <
 identifier-1
 > option is used in conjunction with ""INITIALIZED"" (or it’s 
 internationalized alternative ""INITIALISED""), the allocated memory block will be ini-
 tialized as if an ""INITIALIZE <
 identifier-1
 > WITH FILLER ALL TO VALUE THEN TO 
 DEFAULT"" (see
  [INITIALIZE], page 399
 ) were executed. 
 8. When the ""<
 expression-1
 > CHARACTERS"" option is used, ""INITIALIZED"" will initial-ize 
 the allocated memory block to binary zeros. If ""INITIALIZED"" is not used, the initial 
 contents of allocated memory will be left to whatever rules of memory allocation are in 
 effect for the operating system the program is running under. 
 9. There are two basic ways in which this statement is used. The simplest is: 
 ALLOCATE My-01-Item 
 With this form, a block of storage equal in size to the defined size of My-01-Item (which",NA
6.17.4. ALTER,"ALTER Syntax
  
 ALTER procedure-name-1 TO PROCEED TO procedure-name-2 
 ~~~~~  
 ~~ 
 ———————————————————————————————————————— 
 The ""ALTER"" statement was used in the early years of the COBOL language to edit the object 
 code of a program
  at execution time
 , changing a ""GO TO"" (see
  [Simple GO TO], page 394
 ) 
 statement to branch to a spot in the program different than where the ""GO TO"" statement 
 was originally compiled for. 
 1. The reserved words ""PROCEED"" and ""TO"" (the one
  after
  ""PROCEED"") are optional and 
 may be included, or not, at the discretion of the programmer. The presence or absence 
 of these words has no effect upon the program. 
 2. <
 procedure-name-1
 > must contain only a single statement, and that statement must be a 
 simple ""GO TO"". 
 3. The effect of this statement will be as if the generated machine-language code for the 
 ""GO TO"" statement in <
 procedure-name-1
 > is changed so that the ""GO TO"" statement 
 now transfers control to <
 procedure-name-2
 >, rather than to whatever procedure name 
 was specified in the program source code. 
 4. Support for the ""ALTER"" verb has been added to GNU COBOL for the purpose of enabling 
 GNU COBOL to pass those National Institute of Standards and Technology (NIST) tests 
 for the COBOL programming language that require support for ""ALTER"". 
 5. Because of the catastrophic effect this statement has on program readability and there-
 fore the programmer’s ability to debug problems with program logic, the use of 
 ""ALTER"" in new programs is
  STRONGLY
  discouraged. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.5. CALL,"CALL Syntax
  
 CALL [ { STDCALL 
 } ] { literal-1 
 } 
 ~~~~ 
 { ~~~~~~~ 
 } 
 { identifier-1 } 
 { STATIC  
 { 
 ~~~~~
 ~ 
 }  
 } 
 { mnemonic-name-1 } 
 [ USING CALL-Argument... ] 
 ~~~~~ 
 [ RETURNING|GIVING identifier-2 ] 
 ~~~~~~~~~ ~~~~~~ 
 [ ON OVERFLOW|EXCEPTION imperative-statement-1 ] 
 ~~~~~~~~ ~~~~~~~~~ 
 [ NOT ON OVERFLOW|EXCEPTION imperative-statement-2 ] 
 ~~~ ~~~~~~~~ ~~~~~~~~~ 
 [ END-CALL ] 
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 CALL Argument Syntax
  
 [ BY { REFERENCE } ] 
 { ~~~~~~~~~ } 
 { CONTENT } 
 { ~~~~~~~ } 
 { VALUE } 
 ~~~~~ 
 { OMITTED  
 } 
 { ~~~~~~~  
 } 
 { [ UNSIGNED ] [ SIZE IS { AUTO  
 } ] [ { literal-2  
 } } 
 ~~~~~~~~ ~~~~ { ~~~~  
 }  
 { identifier-2 } 
 { DEFAULT  
 } 
 { ~~~~~~~  } 
 { integer-1 } 
 ———————————————————————————————————————— 
 The ""CALL"" statement is used to transfer control to a subroutine. See
  [Sub-Programming],
  
 page 557
 , for the specifics of using subprograms with GNU COBOL programs. 
 1. The reserved words ""BY"", ""IS"" and ""ON"" are optional and may be included, or not, at 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.6. CANCEL,"CANCEL Syntax
  
 CANCEL { literal-1 
 }... 
 ~~~~~~ { identifier-1 } 
 ———————————————————————————————————————— 
 The ""CANCEL"" statement unloads the dynamically-loadable subprogram module containing 
 the entry-point specified as <
 literal-1
 > or <
 identifier-1
 > from memory. 
 1. If a dynamically-loadable module unloaded by the ""CANCEL"" statement is subsequently 
 re-executed, all data division storage for that module will once again be in it’s initial 
 state. 
 2. Whether the ""CANCEL"" statement actually physically unloads a dynamically-loaded 
 module or simply marks it as logically-unloaded depends on the use and value of the 
 ""COB_PHYSICAL_CANCEL"" 
 run-time 
 environment 
 variable 
 (see
  
 [Run 
 Time 
 Environment Variables], page 522
 ). 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.7. CLOSE,"CLOSE Syntax
  
 CLOSE { file-name-1 [ { REEL|UNIT [ FOR REMOVAL ] } ] }... 
 ~~~~~ 
 { ~~~~ ~~~~ 
 ~~~~~~
 ~ 
 } 
 { WITH LOCK 
 } 
 { 
 ~~~~ 
 } 
 { WITH NO REWIND 
 } 
 ~~ ~~~~~~ 
 The ""REEL"", ""LOCK"" and ""NO REWIND"" clauses are syntactically recognized but are 
 otherwise non-functional, except for the ""CLOSE...NO REWIND"" statement, which will 
 generate a file status of 07 rather than the usual 00 (but take no other action). 
 ———————————————————————————————————————— 
 The ""CLOSE"" statement terminates the program’s access to the specified file(s). 
 1. The reserved words ""FOR"" and ""WITH"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The reserved words ""REEL"" and ""UNIT"" are interchangeable. 
 3. The ""CLOSE"" statement may only be executed against files that have been successfully 
 opened. 
 4. A successful ""CLOSE"" will write any remaining unwritten record buffers to the file 
 (similar to an ""UNLOCK"" statement (see
  [UNLOCK], page 474
 )) and release any file 
 locks for the file, regardless of open mode. A closed file will then be no longer available 
 for subsequent I/O statements until it is once again OPENED. 
 5. When a ""ORGANIZATION LINE SEQUENTIAL"" (see
  [ORGANIZATION LINE SEQUEN-
 TIAL], page 80
 ) or ""LINE ADVANCING"" (see
  [LINE ADVANCING], page 11
 ) file is closed, 
 a final delimiter sequence will be written to the file to signal the termination point of 
 the final data record in the file. This will only be necessary if the final record written to 
 the file was written with the ""AFTER ADVANCING"" (see
  [WRITE], page 479
 ) option. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.8. COMMIT,"COMMIT Syntax
  
 COMMI
 T  
 ~~~~~
 ~ 
 ————————————————————————————————————————
 The ""COMMIT"" statement performs an ""UNLOCK"" against every currently-open file, but does 
 not close any of the files. 
 See the ""UNLOCK"" statement (see
  [UNLOCK], page 474
 ) for additional details. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.9. COMPUTE,"COMPUTE Syntax
  
 COMPUTE { identifier-1 
 ~~~~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] }... 
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~  
 } 
 { NEAREST-AWAY-FROM-ZERO } 
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 { NEAREST-EVEN  
 } 
 { ~~~~~~~~~~~~  
 } 
 { NEAREST-TOWARD-ZERO  } 
 { ~~~~~~~~~~~~~~~~~~~  
 } 
 { PROHIBITED  
 } 
 { ~~~~~~~~~~  
 } 
 { TOWARD-GREATER  
 } 
 { ~~~~~~~~~~~~~~  
 } 
 { TOWARD-LESSER  
 } 
 { ~~~~~~~~~~~~~  
 } 
 { TRUNCATION  
 } 
 ~~~~~~~~~~ 
 =|EQUAL arithmetic-expression-1 
 ~~~~~ 
 [ ON SIZE ERROR imperative-statement-1 ] 
 ~~~~ ~~~~~ 
 [ NOT ON SIZE ERROR imperative-statement-2 ] 
 ~~~ ~~~~ ~~~~~ 
 [ END-COMPUTE ] 
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""COMPUTE"" statement provides a means of easily performing complex arithmetic opera- 
 tions with a single statement, instead of using cumbersome and possibly confusing sequences 
 of ""ADD"", ""SUBTRACT"", ""MULTIPLY"" and ""DIVIDE"" statements. ""COMPUTE"" also allows the 
 use of exponentiation — an arithmetic operation for which no other statement exists in 
 COBOL. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The reserved word ""EQUAL"" is interchangeable with the use of ""="". 
 3. Each <
 identifier-1
 > must be a numeric or numeric-edited data item. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.10. CONTINUE,"CONTINUE Syntax
  
 CONTINU
 E  
 ~~~~~~
 ~~ 
 ———————————————————————————————————————— 
 The ""CONTINUE"" statement is a no-operation statement that may be coded anywhere an 
 imperative statement (see
  [Imperative Statement], page 593
 ) may be coded. 
 1. The ""CONTINUE"" statement has no effect on the execution of the program. 
 2. This statement (perhaps in combination with an appropriate comment or two) makes a 
 convenient ""placeholder"" — particularly in ""ELSE"" (see
  [IF], page 397
 ) or ""WHEN"" (see 
 [EVALUATE], page 383
 ) clauses where no code is currently expected to be needed, but 
 a place for code to handle the conditions in question is to be reserved in case it’s ever 
 needed. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.11. DELETE,"DELETE Syntax
  
  
 DELETE file-name-1 RECORD  
  
 ~~~~~~  
  
 [ INVALID KEY imperative-statement-1 ]  
  
 ~~~~~~~  
  
 [ NOT INVALID KEY imperative-statement-2 ]  
  
 ~~~ ~~~~~~~  
 [ END-DELETE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""DELETE"" statement logically deletes a record from a COBOL file. 
 1. The reserved words ""KEY"" and ""RECORD"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The ""ORGANIZATION"" of <
 file-name-1
 > cannot be ""ORGANIZATION LINE SEQUENTIAL"" 
 (see
  [ORGANIZATION LINE SEQUENTIAL], page 80
 ). 
 3. The <
 file-name-1
 > file cannot be a sort/merge work file (a file descibed using a ""SD"" (see
  
 [File/Sort-Description], page 94
 )). 
 4. For files in the ""SEQUENTIAL"" access mode, the last input-output statement executed 
 against <
 file-name-1
 > prior to the execution of the ""DELETE"" statement must have been 
 a successfully executed sequential-format ""READ"" statement (see
  [Sequential READ], 
 page 428
 ). That ""READ"" will therefore identify the record to be deleted. 
 5. If <
 file-name-1
 > is a ""RELATIVE"" file whose ""ACCESS MODE"" (see
  [ORGANIZATION 
 RELATIVE], page 82
 ) is either ""RANDOM"" or ""DYNAMIC"", the record to be deleted is the 
 one whose relative record number is currently the value of the field specified as the 
 files ""RELATIVE KEY"" in it’s ""SELECT"" statement. 
 6. If <
 file-name-1
 > is an ""INDEXED"" file whose ""ACCESS MODE"" (see
  [ORGANIZATION 
 INDEXED], page 84
 ) is ""RANDOM"" or ""DYNAMIC"", the record to be deleted is the one 
 whose primary key is currently the value of the field specified as the ""RECORD KEY"" in 
 the file’s ""SELECT"" statement. 
 7. The optional ""INVALID KEY"" and ""NOT INVALID KEY"" clauses may be used to detect and 
 react to the failure or success, respectively, of an attempt to delete a record. See 
 [INVALID KEY + NOT INVALID KEY], page 238
 , for additional information. 
 8. No ""INVALID KEY"" or ""NOT INVALID KEY"" clause may be specified for a file who’s 
 ""ACCESS MODE IS SEQUENTIAL"". 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.12. DISPLAY,NA,NA
6.17.12.1. DISPLAY UPON device,"DISPLAY UPON device Syntax
  
 DISPLAY { literal-1 
 }... 
  
 ~~~~~~~ { identifier-1 }  
  
  
 [ UPON mnemonic-name-1 ]  
  
  
  
 ~~~~  
  
  
 [ WITH NO ADVANCING ]  
  
  
  
  
  
 ~~ ~~~~~~~~~  
  
  
 [ ON EXCEPTION imperative-statement-1 ]  
  
  
  
 ~~~~~~~~~  
  
  
 [ NOT ON EXCEPTION imperative-statement-2 ]  
  
  
 ~~~   
 ~~~~~~~~~  
 [ END-DISPLAY ]  
  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""DISPLAY"" statement displays the specified identifier contents and/or 
 literal values on the system output device specified via the ""UPON"" clause. 
 1. The reserved words ""ON"" and ""WITH"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. If no ""UPON"" clause is specified, ""UPON CONSOLE"" will be assumed.  
 If the ""UPON"" 
 clause
  is 
  
 specified, <
 mnemonic-name-1
 > must be one of the built-in output device 
 names ""CONSOLE"", ""PRINTER"", ""STDERR"", ""STDOUT"", ""SYSERR"", ""SYSLIST"", ""SYSLST"" or 
 ""SYSOUT"" or a mnemonic name assigned to one of those devices via the ""SPECIAL-NAMES"" 
 (see
  [SPECIAL-NAMES], page 62
 ) paragraph. 
 When displaying upon the ""STDERR"" or ""SYSERR"" devices or to a <
 mnemonic-name-1
 > 
 attached to one of those two devices, the output will be written to output pipe #2, 
 which will normally cause the output to appear in the console output window. You 
 may, if desired, redirect that output to a file by appending ""2> filename"" to the end of 
 the command that executes the program. This applies to both Windows (any type) or 
 Unix versions of GNU COBOL. 
 When displaying upon the ""CONSOLE"", ""PRINTER"", ""STDOUT"", ""SYSLIST"", ""SYSLST"" or 
 ""SYSOUT"" devices or to a <
 mnemonic-name-1
 > attached to one of them, the output will 
 be written to output pipe #1, which will normally cause the output to appear in the 
 console output window. You may, if desired, redirect that output to a file by appending 
 ""1> filename"" or simply ""> filename"" to the end of the command that 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.12.2. DISPLAY UPON COMMAND-LINE,"DISPLAY UPON COMMAND-LINE Syntax
  
 DISPLAY { literal-1 
 }... 
  
 ~~~~~~~ { identifier-1 }  
  
  
  
 UPON { ARGUMENT-NUMBER|COMMAND-LINE } 
  
  
  
 ~~~~ { ~~~~~~~~~~~~~~~ 
 ~~~~~~~~~~~~ }  
  
 [ ON EXCEPTION 
 imperative-statement-1 ]  
  
  
  
 ~~~~~~~~~  
  
  
 [ NOT ON EXCEPTION imperative-statement-2 ]  
  
  
 ~~~  ~~~~~~~~~  
 [ END-DISPLAY ]  
  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This form of the ""DISPLAY"" statement may be used to specify the command-line argu-ment 
 number to be retrieved by a subsequent ""ACCEPT FROM ARGUMENT-VALUE"" statement 
 (see
  [ACCEPT FROM COMMAND-LINE], page 339
 ) or to specify a new value for the 
 command-line arguments themselves. 
 1. The reserved word ""ON"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. By displaying a numeric integer value UPON ""ARGUMENT-NUMBER"", you will specify 
 which argument (by its relative number) will be retrieved by a subsequent ""ACCEPT 
 FROM ARGUMENT-VALUE"" statement. 
 3. Executing a ""DISPLAY UPON COMMAND-LINE"" will influence subsequent ""ACCEPT 
 FROM COMMAND-LINE"" statements (which will then return the value you displayed), 
 but will not influence subsequent ""ACCEPT FROM ARGUMENT-VALUE"" statements — 
 these will continue to return the original program execution parameters. 
 4. The optional ""ON EXCEPTION"" and ""NOT ON EXCEPTION"" clauses may be used to detect 
 and react to the failure or success, respectively, of an attempt to display output to the 
 specified item. See
  [ON EXCEPTION + NOT ON EXCEPTION], page 238
 , for additional 
 information. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.12.3. DISPLAY UPON ENVIRONMENT-NAME,"DISPLAY UPON ENVIRONMENT-NAME Syntax
  
 DISPLAY { literal-1 
 }... 
 UPON { ENVIRONMENT-VALUE } 
  
 ~~~~~~~ { identifier-1 } 
 ~~~~ { 
 ~~~~~~~~~~~~~~~~~ } { 
 ENVIRONMENT-NAME  
 } 
  
 ~~~~~~~~~~~~~~~
 ~ 
  
  
 [ ON EXCEPTION imperative-statement-1 ]  
  
  
  
 ~~~~~~~~~  
  
  
 [ NOT ON EXCEPTION imperative-statement-2 ]  
  
  
 ~~~  ~~~~~~~~~  
 [ END-DISPLAY ]  
  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This form of the ""DISPLAY"" statement can be used to create or modify environment vari-
 ables. 
 1. The reserved word ""ON"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. To create or change an environment variable will require two ""DISPLAY"" statements. 
 The following example sets the environment variable ""MY ENV VAR"" to a value of 
 ""Demonstration Value"": 
 DISPLAY ""MY_ENV_VAR"" UPON ENVIRONMENT-NAME  
 DISPLAY ""Demonstration Value"" UPON ENVIRONMENT-VALUE 
 3. Environment variables created or changed from within GNU COBOL programs will be 
 available to any sub-shell processes spawned by that program (i.e. ""CALL ’SYSTEM’"" 
 (see
  [SYSTEM], page 549
 )) but will not be known to the shell or console window that 
 started the GNU COBOL program. 
 4. Consider using ""SET ENVIRONMENT"" (see
  [SET ENVIRONMENT], page 445
 ) in lieu of 
 ""DISPLAY"" to set environment variables as it is much simpler. 
 5. The optional ""ON EXCEPTION"" and ""NOT ON EXCEPTION"" clauses may be used to detect 
 and react to the failure or success, respectively, of an attempt to display output to the 
 specified item. See
  [ON EXCEPTION + NOT ON EXCEPTION], page 238
 , for additional 
 information. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.12.4. DISPLAY screen-data-item,"DISPLAY screen-data-item Syntax
  
 DISPLAY identifier-1 [ UPON CRT|CRT-UNDER ] 
 ~~~~~~~  
 ~~~~ ~~~ ~~~~~~~~~ 
 [ AT { | LINE NUMBER { integer-1  
 }  
 | } ] 
 ~~ { | ~~~~  
 { identifier-2 }  
 | } 
 { |  
 | } 
 { | COLUMN|POSITION NUMBER { integer-2  
 } | } 
 { | ~~~~~~ ~~~~~~~~  
 { identifier-3 } | } 
 {  
 } 
 { { integer-3  
 }  
 } 
 { { identifier-4 }  
 } 
 [ WITH [ DISPLAY-Attribute ]... 
 ~~~~ 
 [ SCROLL { UP  
 } [ { integer-4  
 } LINE|LINES ] ] 
 ~~~~~~ { ~~  }  
 { identifier-5 } 
 { DOWN } 
 ~~~~ 
 [ TIMEOUT|TIME-OUT AFTER { integer-5  
 } ] 
  
 ~~~~~~~ 
 ~~~~~~~~  
 [ CONVERSION ] ]  
  
 ~~~~~~~~~~ 
 { identifier-6 } 
  
 [ ON EXCEPTION imperative-statement-1 ]  
  
  
 ~~~~~~~~~  
  
 [ NOT ON EXCEPTION imperative-statement-2 ]  
  
  
 ~~~  ~~~~~~~~~  
 [ END-DISPLAY ]  
  
 ~~~~~~~~~~~ 
 The ""UPON CRT"", ""UPON CRT-UNDER"" and ""CONVERSION"" clauses are syntactically recog-
 nized but are otherwise non-functional. They are supported to provide compatibility with 
 COBOL source written for other COBOL implementations. 
 ———————————————————————————————————————— 
 This format of the ""DISPLAY"" statement presents data onto a formatted screen. 
 1. The reserved words ""AFTER"", ""LINE"", ""LINES"", ""NUMBER"" and ""ON"" are optional and 
 may be included, or not, at the discretion of the programmer. The presence or absence 
 of these words has no effect upon the program. 
 2. The reserved words ""COLUMN"" and ""POSITION"" are interchangeable. 
 3. The reserved words ""LINE"" and ""LINES"" are interchangeable. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.13. DIVIDE,NA,NA
6.17.13.1. DIVIDE INTO,"DIVIDE INTO Syntax
  
 DIVIDE { literal-1 
 } INTO { identifier-2 
 ~~~~~~ { identifier-1 } ~~~~ 
  
   
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }...  
  
   
  ~~~~~~~  
 ~~~~ { ~~~~~~~~~~~~~~  
 }  
  
   
   
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
   
   
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ }  
  
   
   
  
  
 { NEAREST-EVEN  
 }  
  
   
   
  
  
 { ~~~~~~~~~~~~  
 }  
  
   
   
  
  
 { NEAREST-TOWARD-ZERO  
 }  
  
   
   
  
  
 { ~~~~~~~~~~~~~~~~~~~  
 }  
  
   
   
  
  
 { PROHIBITED  
 }  
  
   
   
  
  
 { ~~~~~~~~~~  
 }  
  
   
   
  
  
 { TOWARD-GREATER  
 }  
  
   
   
  
  
 { ~~~~~~~~~~~~~~  
 }  
  
   
   
  
  
 { TOWARD-LESSER  
 }  
  
   
   
  
  
 { ~~~~~~~~~~~~~  
 }  
  
   
   
  
  
 { TRUNCATION  
 }  
  
   
   
  
  
  
  
 ~~~~~~~~~~  
  
  [ ON SIZE ERROR imperative-statement-1 ]  
  
   
   
 ~~~~ ~~~~~  
  
  [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
   
 ~~~  
 ~~~~ ~~~~~  
 [ END-DIVIDE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""DIVIDE"" statement will divide a numeric value (specified as a literal or 
 numeric data item) into one or more numeric data items, replacing the value in each of 
 those data items with the result(s). 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items and <
 literal-
 1
 > must be a numeric literal. 
 3. A division operation will be performed for each <
 identifier-2
 >, in turn. Each of the results 
 of those divisions will be saved to the corresponding <
 identifier-2
 > data item(s). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.13.2. DIVIDE INTO GIVING,"DIVIDE INTO GIVING Syntax
  
 DIVIDE { literal-1 
 } INTO { literal-2 
 } GIVING { identifier-3 
 ~~~~~~ { identifier-1 } ~~~~ { identifier-2 } ~~~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }... 
  
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~  
 }  
  
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 [ REMAINDER identifier-4 ] 
 { NEAREST-EVEN 
 } 
 { ~~~~~~~~~~~~ 
 } 
 { NEAREST-TOWARD-ZERO 
 } 
 { 
 ~~~~~~~~~~~~~~~~
 ~~~ 
 } 
 { PROHIBITED 
 } 
 { ~~~~~~~~~~ 
 } 
 { TOWARD-GREATER 
 } 
 { ~~~~~~~~~~~~~~ 
 } 
 { TOWARD-LESSER 
 } 
 { ~~~~~~~~~~~~~ 
 } 
 { TRUNCATION 
 } 
 ~~~~~~~~~~ 
  
   
 ~~~~~~~~~  
  
  [ ON SIZE ERROR imperative-statement-1 ]   
  
  ~~~~ ~~~~~  
  
  [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
  ~~~  ~~~~ ~~~~~  
 [ END-DIVIDE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""DIVIDE"" statement will divide one numeric value (specified as a literal 
 or numeric data item) into another numeric value (also specified as a literal or numeric data 
 item) and will then replace the contents of one or more receiving data items with the results 
 of that division. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items while both 
 <
 identifier-3
 > and <
 identifier-4
 > must be numeric (edited or unedited) data items. 
 3. Both <
 literal-1
 > and <
 literal-2
 > must be numeric literals. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.13.3. DIVIDE BY GIVING,"DIVIDE BY GIVING Syntax
  
 DIVIDE { literal-1 
 } BY { literal-2 
 } GIVING { identifier-3 
 ~~~~~~ { identifier-1 } ~~ { identifier-2 } ~~~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }... 
  
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~  
 }  
  
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 [ REMAINDER identifier-4 ] 
 { NEAREST-EVEN 
 } 
 { ~~~~~~~~~~~~ 
 } 
 { NEAREST-TOWARD-ZERO 
 } 
 { 
 ~~~~~~~~~~~~~~~~
 ~~~ 
 } 
 { PROHIBITED 
 } 
 { ~~~~~~~~~~ 
 } 
 { TOWARD-GREATER 
 } 
 { ~~~~~~~~~~~~~~ 
 } 
 { TOWARD-LESSER 
 } 
 { ~~~~~~~~~~~~~ 
 } 
 { TRUNCATION 
 } 
 ~~~~~~~~~~ 
  
   
 ~~~~~~~~~  
  
  [ ON SIZE ERROR imperative-statement-1 ]   
  
  ~~~~ ~~~~~  
  
  [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
  ~~~  ~~~~ ~~~~~  
 [ END-DIVIDE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""DIVIDE"" statement will divide one numeric value (specified as a literal 
 or numeric data item) into another numeric value (also specified as a literal or numeric data 
 item) and will then replace the contents of one or more receiving data items with the results 
 of that division. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items while both 
 <
 identifier-3
 > and <
 identifier-4
 > must be numeric (edited or unedited) data items. 
 3. Both <
 literal-1
 > and <
 literal-2
 > must be numeric literals. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.14. ENTRY,"ENTRY Syntax
  
 ENTRY literal-1 [ USING ENTRY-Argument... 
 ] 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 ENTRY-Argument Syntax
  
 [ BY { REFERENCE } ] identifier-1  
  
 { ~~~~~~~~~ }  
  
 { CONTENT }  
  
 { ~~~~~~~ }  
  
 { VALUE }  
  
  
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""ENTRY"" statement is used to define an alternate entry-point into a subroutine, along 
 with the arguments that subroutine will be expecting. 
 1. The reserved word ""BY"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. You may not use an ""ENTRY"" statement in a nested subprogram, nor may you use it in 
 any form of user-defined function. 
 3. The ""USING"" clause defines the arguments the subroutine entry-point supports. This list 
 of arguments must match up against the ""USING"" clause of any ""CALL"" statement that 
 will be invoking the subroutine using this entry-point. 
 4. Each <
 ENTRY-Argument
 > specified on the ""ENTRY"" statement must be defined in the 
 linkage section of the subroutine in which the ""ENTRY"" statement exists. 
 5. The <
 literal-1
 > value will specify the entry-point name of the subroutine. It must be 
 specified exactly on ""CALL"" statements (with regard to the use of upper- and lower-
 case letters) as it is specified on the ""ENTRY"" statement. 
 6. The meaning of ""REFERENCE"", ""CONTENT"" and ""VALUE"" are the same as the equivalent 
 specifications on the ""CALL"" statement (see
  [CALL], page 359
 ). Whatever specification 
 will be used for an argument on the ""CALL"" to this entry-point should match the 
 specification used in the corresponding <
 ENTRY-Argument
 >. The same rules regarding 
 the presence or absence of a ""BY"" clause on a ""CALL"" statement apply to the presence 
 or absence of a ""BY"" clause on the corresponding argument of the ""ENTRY"" statement. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.15. EVALUATE,"EVALUATE Syntax
  
 EVALUATE Selection-Subject-1 [ ALSO Selection-Subject-2 ]... 
  
 ~~~~~~~~  
 ~~~~  
 { { WHEN Selection-Object-1 [ ALSO Selection-Object-2 ] }... 
 ~~~~  
 ~~~~  
  
 [ imperative-statement-1 ] }... 
 [ WHEN OTHER  
 ~~~~ ~~~~~  
 imperative-statement-other ] 
 [ END-EVALUATE ]  
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 EVALUATE Selection Subject Syntax
  
 { TRUE  
 { ~~~~  
 { FALSE 
 { 
 ~~~~~ 
 }  
 }  
 }  
 } 
 { expression-1 }  
 { identifier-1 }  
 { literal-1 } 
 ———————————————————————————————————————— 
 EVALUATE Selection Object Syntax
  
 { ANY  
 { ~~~  
 { TRUE  
 { ~~~~  
 { FALSE  
 { ~~~~~  
 { partial-expression-1 { 
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 } 
 { { expression-2 } [ THRU|THROUGH { expression-3 } ] } 
 { { identifier-2 } 
 ~~~~ ~~~~~~~ { identifier-3 } 
 } 
 { { literal-2 
 } 
 { literal-3 
 } 
 } 
 ———————————————————————————————————————— 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.16. EXIT,"EXIT Syntax
  
 EXIT [ { PROGRAM 
 } ]  
 }  
 }  
 } 
 ~~~
 ~ 
 { ~~~~~~~ 
 { FUNCTION  
 { 
 ~~~~~~~
 ~ 
 { PERFORM [ CYCLE ] } 
 { ~~~~~~~ 
 ~~~~
 ~ 
 } 
 { SECTION 
 } 
 { ~~~~~~~ 
 } 
 { PARAGRAPH 
 } 
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""EXIT"" statement is a multi-purpose statement; it may provide a common end point for 
 a series of procedures, exit an inline PERFORM, paragraph or section or it may mark the 
 logical end of a subprogram, returning control back to the calling program. 
 1. The ""EXIT PROGRAM"" statement is not legal anywhere within a user-defined function. 
 2. The ""EXIT FUNCTION"" statement cannot be used anywhere within a subroutine. 
 3. Neither ""EXIT PROGRAM"" nor ""EXIT FUNCTION"" may be used within a ""USE GLOBAL"" 
 routine in ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 ). 
 4. The following points describe the ""EXIT"" statement with none of the optional clauses: 
 A. When this form of an ""EXIT"" statement is used, it must be the only statement in the 
 procedure (paragraph or section) in which it occurs. 
 B. This usage of the ""EXIT"" statement simply provides a common ""GO TO"" end point for 
 a series of procedures, as may be seen in the following example: 
 01  Switches. 
 05 Input-File-Switch PIC X(1). 
 88 EOF-On-Input-File VALUE Y FALSE N. 
 ... 
 SET EOF-On-Input-File TO FALSE. 
 PERFORM 100-Process-A-Transaction THRU 199-Exit 
  
 UNTIL EOF-On-Input-File. 
 ... 
 100-Process-A-Transaction. 
 READ Input-File AT END  
  
 SET EOF-On-Input-File TO TRUE  
  
 GO TO 199-Exit  
 END-READ. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.17. FREE,"FREE Syntax
  
 FREE { [ ADDRESS OF ] identifier-1 }...  
 ~~~~  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 The ""FREE"" statement releases memory previously allocated to the program by the 
 ""ALLOCATE"" statement (see
  [ALLOCATE], page 356
 ). 
 1. The ""ADDRESS OF"" clause is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this clause has no effect upon the program. 
 2. <
 identifier-1
 > must have a ""USAGE"" (see
  [USAGE], page 186
 ) of ""POINTER"", or it must be 
 an 01-level data item with the ""BASED"" (see
  [BASED], page 130
 ) attribute. 
 3. If <
 identifier-1
 > is a ""USAGE POINTER"" data item and it contains a valid address, the 
 ""FREE"" statement will release the memory block the pointer references. In addition, 
 any ""BASED"" data items that the pointer was used to provide an address for will 
 become un-based and therefore un-usable. If <
 identifier-1
 > did not contain a valid 
 address, no action will be taken. 
 4. If <
 identifier-1
 > is a ""BASED"" data item and that data item is currently based (meaning it 
 currently has memory allocated to it), its memory is released and <
 identifier-1
 > will 
 become un-based and therefore un-usable. If <
 identifier-1
 > was not based, no action 
 will be taken. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.18. GENERATE,"GENERATE Syntax
  
 GENERATE { report-name-1 }  
 ~~~~~~~~ { identifier-1  
 } 
 ———————————————————————————————————————— 
 The ""GENERATE"" statement presents data to a report. 
 1. The following points apply when <
 identifier-1
 > is specified: 
 A. <
 identifier-1
 > must be the name of a ""DETAIL"" (see
  [RWCS Lexicon], page 483
 ) 
 report group. 
 B. If necessary, <
 identifier-1
 > may be qualified with a report name. 
 C. The file in whose ""FD"" a ""REPORT"" clause exists for the report in which <
 identifier-
 1
 > is a detail group must be opened for ""OUTPUT"" or ""EXTEND"" at the time the 
 ""GENERATE"" is executed. See
  [OPEN], page 420
 , for information on file open 
 modes. 
 D. The report in which <
 identifier-1
 > is a ""DETAIL"" group must have been successfully 
 initiated via the ""INITIATE"" statement (see
  [INITIATE], page 404
 ) and not yet 
 terminated via the ""TERMINATE"" statement (see
  [TERMINATE], page 472
 ) at the 
 time the ""GENERATE"" is executed. 
 E. If at least one ""GENERATE"" statement of this form is executed against a report, the 
 report is said to be a ’
 detail report
 ’. If no ""GENERATE"" statements of this form are 
 executed against a report, the report is said to be a ’
 summary report
 ’. 
 2. The following points apply when <
 report-name-1
 > is specified: 
 A. <
 report-name-1
 > must be the name of a report having an ""RD"" defined for it in the 
 report section. 
 B. There must be at least one ""CONTROL"" (see
  [RWCS Lexicon], page 483
 ) group 
 defined for <
 report-name-1
 >. 
 C. There cannot be more than one ""DETAIL"" group defined for <
 report-name-1
 >. 
 D. The file in whose ""FD"" a ""REPORT <
 report-name-1
 >"" clause exists must be open for 
 ""OUTPUT"" or ""EXTEND"" at the time the GENERATE is executed. 
 E. <
 report-name-1
 > must have been successfully initiated (via ""INITIATE <
 report-
 name-1
 >"") and not yet terminated (via TERMINATE) at the time the ""GENERATE"" 
 is executed. See
  [OPEN], page 420
 , for information on file open modes. 
 F. The ""DETAIL"" group which is defined for <
 report-name-1
 >
  will
  be processed but will 
 not actually be presented to any report page. This will allow summary pro-cessing 
 to take place. If all ""GENERATE"" statements are of this form, the report 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.19. GOBACK,"GOBACK Syntax
  
 GOBACK  
 ~~~~~
 ~ 
 ————————————————————————————————————————
 The ""GOBACK"" statement is used to logically terminate an executing program. 
 1. If executed within a subprogram (i.e. a subroutine or user-defined function), ""GOBACK"" 
 behaves like an ""EXIT PROGRAM"" or ""EXIT FUNCTION"" statement, respectively. 
 2. If executed within a main program, ""GOBACK"" will act as a ""STOP RUN"" statement. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.20. GO TO,NA,NA
6.17.20.1. Simple GO TO,"Simple GO TO Syntax
  
 GO TO procedure-name-1  
 ~~ 
 ———————————————————————————————————————— 
 This form of the ""GO TO"" statement unconditionally transfers control in a program to the 
 first executable statement within the specified <
 procedure-name-1
 >. 
 1. The reserved word ""TO"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. If this format of the ""GO TO"" statement appears in a consecutive sequence of imperative 
 statements (see
  [Imperative Statement], page 593
 ) within a sentence, it must be the 
 final
  statement in the sentence. 
 3. If a ""GO TO"" is executed within the scope of. . . 
 A. ...an inline ""PERFORM"" (see
  [PERFORM], page 422
 ), the ""PERFORM"" is terminated as 
 control of execution transfers to <
 procedure-name-1
 >. 
 B. ...a procedural ""PERFORM"" (see
  [PERFORM], page 422
 ), and <
 procedure-name-1
 > 
 lies outside the scope of that ""PERFORM"", the ""PERFORM"" is terminated as control 
 of execution transfers to <
 procedure-name-1
 >. 
 C. ...a ""MERGE"" statement (see
  [MERGE], page 411
 ) ""OUTPUT PROCEDURE"" or within 
 the scope of either an ""INPUT PROCEDURE"" or ""OUTPUT PROCEDURE"" of a 
 ""SORT"" statement (see
  [File-Based SORT], page 453
 ), and <
 procedure-name-1
 > lies 
 outside the scope of that procedure, the ""SORT"" or ""MERGE"" operation is 
 terminated as control of execution transfers to <
 procedure-name-1
 >. Any sorted or 
 merged data accumu7lated to that point is lost. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.20.2. GO TO DEPENDING ON,"GO TO DEPENDING ON Syntax
  
 GO TO procedure-name-1... 
 ~~  
 DEPENDING ON identifier-1  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 This form of the ""GO TO"" statement will transfer control to any one of a number of specified 
 procedure names depending on the numeric value of the identifier specified on the 
 statement. 
 1. The reserved word ""TO"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The ""PICTURE"" (see
  [PICTURE], page 162
 ) and/or ""USAGE"" (see
  [USAGE], page 186
 ) of 
 the specified <
 identifier-1
 > must be such as to define it as a numeric, unedited, 
 preferably unsigned integer data item. 
 3. If the value of <
 identifier-1
 > has the value 1, control will be transferred to the 1st 
 specified procedure name. If the value is 2, control will transfer to the 2nd procedure 
 name, and so on. 
 If control of execution is transferred to a procedure named on the statement, and the 
 ""GO TO"" is executed within the scope of. . . 
 A. ...an inline ""PERFORM"" (see
  [PERFORM], page 422
 ), the ""PERFORM"" is terminated as 
 control of execution transfers to the procedure named on the statement. 
 B. ...a procedural ""PERFORM"" (see
  [PERFORM], page 422
 ), and <
 procedure-name-1
 > 
 lies outside the scope of that ""PERFORM"", the ""PERFORM"" is terminated as control 
 of execution transfers to the procedure named on the statement. 
 C. ...a ""MERGE"" statement (see
  [MERGE], page 411
 ) ""OUTPUT PROCEDURE"" or within 
 the scope of either an ""INPUT PROCEDURE"" or ""OUTPUT PROCEDURE"" of a ""SORT"" 
 statement (see
  [File-Based SORT], page 453
 ), and <
 procedure-name-1
 > lies outside the 
 scope of that procedure, the ""SORT"" or ""MERGE"" operation is terminated as control of 
 execution transfers to the procedure named on the statement.  
 Any 
 sorted or merged data accumu7lated to that point is lost. 
 4. If the value of <
 identifier-1
 > is less than 1 or exceeds the total number of procedure 
 names specified on the statement, control will simply fall thru into the next statement 
 following the ""GO TO"". 
 5. The following example shows how ""GO TO ... DEPENDING ON"" may be used in a real 
 application situation, and compares it against an alternative — ""EVALUATE"" (see 
 [EVALUATE], page 383
 ). 
 GO TO DEPENDING ON Example 
 3 June 2014 
 Equivalent EVALUATE Example 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.21. IF,"IF Syntax
  
  
 IF conditional-expression  
  
 ~~  
  
 THEN { imperative-statement-1 }  
  
  
 { NEXT SENTENCE  
 }  
  
  
  
 ~~~~ ~~~~~~~~  
 [ ELSE { imperative-statement-2 } ]  
  
 ~~~~ { NEXT SENTENCE  
  
 }  
  
  
 ~~~~ ~~~~~~~~  
 [ END-IF ]  
  
 ~~~~~~ 
 ———————————————————————————————————————— 
 The ""IF"" statement is used to conditionally execute an imperative statement (see 
 [Imperative Statement], page 593
 ) or to select one of two different imperative statements to 
 execute based upon the TRUE/FALSE value of a conditional expression. 
 1. The reserved word ""THEN"" is optional and may be included, or not, at the discretion of 
 the programmer. The presence or absence of this word has no effect upon the program. 
 2. You cannot use both ""NEXT SENTENCE"" and the ""END-IF"" scope terminator in the same 
 ""IF"" statement. 
 3. If <
 conditional-expression
 > evaluates to TRUE, <
 imperative-statement-1
 > will be ex-
 ecuted regardless of whether or not an ""ELSE"" clause is present. Once <
 imperative-
 statement-1
 > has been executed, control falls into the first statement following the 
 ""END-IF"" or to the first statement of the next sentence if there is no ""END-IF"" clause. 
 4. If the optional ""ELSE"" clause is present and conditional-expression evaluates to false, 
 then (and only then) <
 imperative-statement-2
 > will be executed. Once <
 imperative-
 statement-2
 > has been executed, control falls into the first statement following the 
 ""END-IF"" or to the first statement of the next sentence if there is no ""END-IF"" clause. 
 5. The clause ""NEXT SENTENCE"" may be substituted for either imperative-statement, but 
 not both. If control reaches a ""NEXT SENTENCE"" clause due to the truth or falsehood of 
 <
 conditional-expression
 >, control will be transferred to the first statement of the next 
 sentence found in the program (the first statement after the next period). 
 ""NEXT SENTENCE"" was needed for COBOL programs that were coded according to pre-
 1985 standards that wish to nest one ""IF"" statement inside another.  
 See 
 [Use of VERB/END-VERB Constructs], page 229
 , for an explanation of why ""NEXT 
 SENTENCE"" was necessary. 
 Programs coded for 1985 (and beyond) standards don’t need it, instead using the ex-
 plicit scope-terminator ""END-IF"" to inform the compiler where <
 imperative-statement-
  
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.22. INITIALIZE,"INITIALIZE Syntax
  
 INITIALIZE|INITIALISE identifier-1... 
 ~~~~~~~~~~ ~~~~~~~~~~  
  
 [ WITH FILLER ]  
  
  
 ~~~~~~  
  
 [ { category-name-1 } TO VALUE ] 
 { ALL 
 } 
 ~~~~~ 
  
 ~~~  
 [ THEN REPLACING { category-name-2 DATA BY  
  
 ~~~~~~~~~  
  
  
 ~~ 
  
 [ LENGTH OF ] { literal-1  
 } }...  ]  
  
  
 ~~~~~~  
 { identifier-1 } 
 [ THEN TO DEFAULT ]  
 ~~~~~~~ 
 ———————————————————————————————————————— 
 The ""INITIALIZE"" statement initializes each <
 identifier-1
 > with certain specific values, 
 depending upon the options specified. 
 1. The reserved words ""DATA"", ""OF"", ""THEN"", ""TO"" and ""WITH"" are optional and may be 
 included, or not, at the discretion of the programmer. The presence or absence of these 
 words has no effect upon the program. 
 2. The reserved words ""INITIALIZE"" and ""INITIALISE"" are interchangeable. 
 3. The ""WITH FILLER"", ""REPLACING"" and ""DEFAULT"" clauses are meaningful only if 
 <
 identifier-1
 > is a group item. They are accepted if it’s an elementary item, but will 
 serve no purpose. The ""VALUE"" clause is meaningful in both cases. 
 4. A <
 category-name-1
 > and/or <
 category-name-2
 > may be any of the following: 
 ""ALPHABETIC"" 
 The ""PICTURE"" (see
  [PICTURE], page 162
 ) of the data item only contains 
 ""A"" symbols. 
 ""ALPHANUMERIC"" 
 The ""PICTURE"" of the data item contains only ""X"" or a combination of ""A"" 
 and ""9"" symbols. 
 ""ALPHANUMERIC-EDITED"" 
 The ""PICTURE"" of the data item contains only ""X"" or a combination of ""A"" 
 and ""9"" symbols plus at least one ""B"", ""0"" (zero) or ""/"" symbol. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.23. INITIATE,"INITIATE Syntax
  
 INITIATE report-name-1  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""INITIATE"" statement starts Report-Writer Control System (RWCS) processing for a 
 report. 
 1. Each <
 report-name-1
 > must be the name of a report having an ""RD"" (see
  [REPORT 
 SECTION], page 107
 ) defined for it. 
 2. The file in whose ""FD"" (see
  [File/Sort-Description], page 94
 ) a ""REPORT <
 report-name-
 1
 >"" clause exists must be open for ""OUTPUT"" or ""EXTEND"" at the time the ""INITIATE"" 
 statement is executed. See
  [OPEN], page 420
 , for more information on file open modes. 
 3. The ""INITIATE"" statement will initialize all of the following for each report named on the 
 statement: 
 •
  All sum counters, if any, will be set to 0 
 •
  The report’s ""LINE-COUNTER"" special register (see
  [Special Registers], page 243
 ) 
 will be set to 0 
  
 •
  The report’s ""PAGE-COUNTER"" special register will be set to 1  
 4. No report content will actually presented to the report file as a result of a successful 
 ""INITIATE"" statement — that will not occur until the first ""GENERATE"" statement (see 
 [GENERATE], page 391
 ) is executed. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.24. INSPECT,"INSPECT Syntax
  
 INSPECT { literal-1  
 ~~~~~~~ { identifier-1 
 }  
 } 
 { function-reference-1 } 
 [ TALLYING { identifier-2 FOR { ALL|LEADING|TRAILING { literal-2  
 } } 
 ~~~~~~~~  
 ~~~ { ~~~ ~~~~~~~ ~~~~~~~~ { identifier-3 } } 
 { CHARACTERS } 
 ~~~~~~~~~~ 
 [ | { AFTER|BEFORE } INITIAL { literal-3 } | ] }...  
 ] 
 |  
 ~~~~~ ~~~~~~  
 { identifier-4 } | 
 [ REPLACING { { { ALL|FIRST|LEADING|TRAILING { literal-4  
 } } 
 ~~~~~~~~~ { { ~~~ ~~~~~ ~~~~~~~ ~~~~~~~~ { identifier-5 } } 
 { CHARACTERS  
 } 
 { ~~~~~~~~~~  
 } 
 BY { [ ALL ] literal-5 } 
 ~~ { ~~~  
 } 
 { identifier-6  
 } 
 [ | { AFTER|BEFORE } INITIAL { literal-6 } | ] }...  
 ] 
 |  
 ~~~~~ ~~~~~~  
 { identifier-7 } | 
 [ CONVERTING { { literal-7  
 } TO { literal-8  
 } 
 ~~~~~~~~~~  
 { identifier-8 } ~~ { identifier-9 } 
 [ | { AFTER|BEFORE } INITIAL { literal-9  
 } | ] ] 
 |  
 ~~~~~ ~~~~~~  
 { identifier-10 } | 
 ———————————————————————————————————————— 
 The ""INSPECT"" statement is used to perform various counting and/or data-alteration op- 
 erations against strings. 
 1. The reserved word ""INITIAL"" is optional and may be included, or not, at the discretion 
 of the programmer.  The presence or absence of this words has no effect upon the 
 program. 
 2. If a ""CONVERTING"" clause is specified, neither the ""TALLYING"" nor ""REPLACING"" clauses 
 may be used. 
 3. If either the ""TALLYING"" or ""REPLACING"" clauses are specified, the ""CONVERTING"" clause 
 cannot be used. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.25. MERGE,"MERGE Syntax
  
 MERGE sort-file-1  
 ~~~~~ 
 { ON { ASCENDING 
 } KEY identifier-1... 
 }... 
 { ~~~~~~~~~ 
 } 
  
 { DESCENDING }  
  
  
 ~~~~~~~~~~  
 [ WITH DUPLICATES IN ORDER ]  
  
  
 ~~~~~~~~~~  
 [ COLLATING SEQUENCE IS alphabet-name-1 ] 
  
 ~~~~~~~~~  
  
 USING file-name-1 file-name-2... 
  
 ~~~~~  
 { OUTPUT PROCEDURE IS procedure-name-1 } { 
 ~~~~~~ ~~~~~~~~~ } {  
 [ 
 THRU|THROUGH procedure-name-2 ] }  
  
 ~~~~ ~~~~~~~ } {  
 { GIVING file-name-3... } { ~~~~~~  
  } 
 The ""DUPLICATES"" clause is syntactically recognized but is otherwise non-functional. 
 ———————————————————————————————————————— 
 The ""MERGE"" statement merges the contents of two or more files that have each been pre-
 sorted on a set of specified identical keys. 
 1. The reserved words ""IN"", ""IS"", ""KEY"", ""ON"", ""ORDER"", ""SEQUENCE"" and ""WITH"" are 
 optional and may be included, or not, at the discretion of the programmer.  
 The 
 presence or absence of these words has no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. GNU COBOL always behaves as if the ""WITH DUPLICATES IN ORDER"" clause is speci-fied, 
 even if it isn’t. 
 While any COBOL implementation’s sort or merge facilities guarantee that records with 
 duplicate key values will be in proper sequence with regard to other records with 
 different key values, they generally make no promises as to the resulting relative 
 sequence of records having duplicate key values with one another. 
 Some COBOL implementations provide this optional clause to force their sort and 
 merge facilities to retain duplicate key-value records in their original input sequence, 
 relative to one another. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.26. MOVE,NA,NA
6.17.26.1. Simple MOVE,"Simple MOVE Syntax
  
 MOVE { literal-1 
 } TO identifier-2... 
 ~~~~ { identifier-1 } ~~ 
 ———————————————————————————————————————— 
 The Simple ""MOVE"" statement moves a specific value to one or more receiving data items. 
 1. The ""MOVE"" statement will replace the contents of one or more receiving data items 
 (<
 identifier-2
 >) with a new value — the one specified by <
 literal-1
 > or <
 identifier-1
 >. 
 2. Only numeric data can be moved to a numeric or numeric-edited <
 identifier-2
 >. A 
 ""MOVE"" involving numeric data will perform any necessary format conversions that 
 might be necessary due to differing ""USAGE"" (see
  [USAGE], page 186
 ) specifications. 
 3. The contents of the <
 identifier-1
 > data item will not be changed, unless that same data 
 item appears as an <
 identifier-2
 >. Note that such situations will cause a warning 
 message to be issued by the compiler, if warning messages are enabled. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.26.2. MOVE CORRESPONDING,"MOVE CORRESPONDING Syntax
  
 MOVE CORRESPONDING identifier-1 TO identifier-2... ~~~~ 
 ~~~~  
 ~~ 
 ———————————————————————————————————————— 
 The ""MOVE CORRESPONDING"" statement similarly-named items from one group item to an-
 other. 
 1. The reserved word ""CORRESPONDING"" may be abbreviated as ""CORR"". 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be group items. 
 3. See
  [CORRESPONDING], page 236
 , for a discussion of how corresponding matches 
 between two group items are established. 
 4. When corresponding matches are established, the effect of a ""MOVE CORRESPONDING"" 
 on those matches will be as if a series of individual ""MOVE""s were done — one for each 
 match. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.27. MULTIPLY,NA,NA
6.17.27.1. MULTIPLY BY,"MULTIPLY BY Syntax
  
 MULTIPLY { literal-1 
 } BY { identifier-2 
 ~~~~~~~~ { identifier-1 } ~~ 
  
   
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }...  
  
   
 ~~~~~~~ ~~~~  
 { ~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ }  
  
   
  
   
  
  
 { NEAREST-EVEN  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { NEAREST-TOWARD-ZERO  }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { PROHIBITED  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TOWARD-GREATER  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TOWARD-LESSER  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TRUNCATION  
 }  
  
   
  
   
  
  
  
 ~~~~~~~~~~  
  
  [ ON SIZE ERROR imperative-statement-1 ]  
  
   
  
  ~~~~ ~~~~~  
  
  [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
   
 ~~~  
 ~~~~ ~~~~~  
 [ END-DIVIDE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""MULTIPLY BY"" statement computes the product of one or more data items (<
 identifier-
 2
 >) and either a numeric literal or another data item. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric un-edited data items; <
 literal-1
 > 
 must be a numeric literal. 
 3. The product of <
 identifier-1
 > or <
 literal-1
 > and each <
 identifier-2
 >, in turn, will be 
 computed and moved to each of the <
 identifier-2
 > data items, replacing the prior 
 contents. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.27.2. MULTIPLY GIVING,"MULTIPLY GIVING Syntax
  
 MULTIPLY { literal-1 
 } BY { literal-2 
 } GIVING { identifier-3 
 ~~~~~~~~ { identifier-1 } ~~ { identifier-2 } ~~~~~~ 
  
   
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }...  
  
   
 ~~~~~~~ ~~~~  
 { ~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { NEAREST-AWAY-FROM-ZERO }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~~~~~~~~~ }  
  
   
  
   
  
  
 { NEAREST-EVEN  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { NEAREST-TOWARD-ZERO  }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { PROHIBITED  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TOWARD-GREATER  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TOWARD-LESSER  
 }  
  
   
  
   
  
  
 { ~~~~~~~~~~~~~  
 }  
  
   
  
   
  
  
 { TRUNCATION  
 }  
  
   
  
   
  
  
  
 ~~~~~~~~~~  
  
  [ ON SIZE ERROR imperative-statement-1 ]  
  
   
  
  ~~~~ ~~~~~  
  
  [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
   
 ~~~  
 ~~~~ ~~~~~  
 [ END-DIVIDE ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""MULTIPLY GIVING"" statement computes the product of two literals and/or data items 
 and saves that result in one or more other data items. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric un-edited data items; <
 literal-1
 > 
 and <
 literal-2
 > must be numeric literals. 
 3. The product of <
 identifier-1
 > or <
 literal-1
 > and <
 identifier-2
 > or <
 literal-2
 > will be 
 computed and moved to each of the <
 identifier-3
 > data items, replacing their old 
 contents. 
 4. Neither the value of <
 identifier-1
 > nor <
 identifier-2
 > will be altered, unless either 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.28. OPEN,"OPEN Syntax
  
 OPEN { { INPUT 
 } [ SHARING WITH { ALL OTHER } ] file-name-1 
 ~~~
 ~ 
 { ~~~~~ 
 } 
 ~~~~~~~ 
 { ~~~ 
 } 
 { OUTPUT } 
 { NO OTHER 
 } 
 { ~~~~~~ } 
 { ~~ 
 } 
 { I-O 
 } 
 { READ ONLY } 
 { ~~~ 
 } 
 ~~~~ ~~~~ 
 { EXTEND } 
 ~~~~~~ 
 [ { REVERSED  
 } ] }... 
 { ~~~~~~~~  
 } 
 { WITH { NO REWIND } } 
 { { ~~ ~~~~~~ } } 
 { { LOCK } } 
 ~~~~ 
 The ""NO REWIND"", and ""REVERSED"" clauses are syntactically recognized but are otherwise 
 non-functional. 
 ———————————————————————————————————————— 
 The ""OPEN"" statement makes one or more files described in your program available for use. 
 1. The reserved words ""OTHER"" and ""WITH"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The ""SHARING"" and ""WITH LOCK"" clauses may not both be specified in the same ""OPEN"" 
 statement. 
 3. Any file defined in a GNU COBOL program must be successfully opened before it or 
 any of it’s record descriptions may be referenced on: 
 A ""CLOSE"" statement (see
  [CLOSE], page 364
 ) 
 A ""DELETE"" statement (see
  [DELETE], page 369
 ) 
 A ""READ"" statement (see
  [READ], page 428
 ) 
 A ""REWRITE"" statement (see
  [REWRITE], page 437
 ) 
 A ""START"" statement (see
  [START], page 459
 ) 
 An ""UNLOCK"" statement (see
  [UNLOCK], page 474
 ) 
 A ""WRITE"" statement (see
  [WRITE], page 479
 ) 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.29. PERFORM,NA,NA
6.17.29.1. Procedural PERFORM,"Procedural PERFORM Syntax
  
 PERFORM procedure-name-1 [ THRU|THROUGH procedure-name-2 ] 
 ~~~~~~~  
 ~~~~ ~~~~~~~ 
 [ { [ WITH TEST { BEFORE } ] { VARYING-Clause  
 } } ] 
 {  
 ~~~~ { ~~~~~~ }  { UNTIL conditional-expression-1 } } 
 {  
 { AFTER  }  
 ~~~~~  
 } 
 {  
 ~~~~~  
 } 
 { UNTIL EXIT|FOREVER  
 } 
 { ~~~~~ ~~~~ ~~~~~~~  
 } 
 { { literal-1 } TIMES  } 
 { { identifier-1 } ~~~~~  
 } 
 ———————————————————————————————————————— 
 This format of the ""PERFORM"" statement is used to transfer control to one or more proce- 
 dures, which will return control back when complete. Execution of the procedure(s) can be 
 done a single time, multiple times, repeatedly until a condition becomes TRUE or forever 
 (with some way of breaking out of the control of the ""PERFORM"" or of halting program 
 execution within the procedure(s)). 
 1. The reserved word ""WITH"" is optional and may be included, or not, at the discretion of 
 the programmer. The presence or absence of this word has no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. The reserved word and phrase ""FOREVER"" and ""UNTIL EXIT"" are interchangeable. 
 4. Both <
 procedure-name-1
 > and <
 procedure-name-2
 > must be procedure division sections 
 or paragraphs defined in the same program as the ""PERFORM"" statement. If <
 procedure-
  
 name-2
 > is specified, it must follow <
 procedure-name-1
 > in the program’s source code. 
 5. The ’
 perform scope
 ’ is defined as being the statements within <
 procedure-name-1
 >, 
 the statements within <
 procedure-name-2
 > and all statements in all procedures defined 
 between them. 
 6. <
 literal-1
 > must be a numeric literal or a reference to a function that returns a numeric 
 value. The value must be an integer greater than zero. 
 7. <
 identifier-1
 > must be an elementary un-edited numeric data item with an integer value 
 greater than zero. 
 8. Without the ""UNTIL"", ""UNTIL EXIT"", ""TIMES"", <
 VARYING-Clause
 > (see
  [VARYING],
  
 page 425
 ) or ""FOREVER"" clauses, the code within the perform scope will be executed 
 once, after which control will return to the statement following the ""PERFORM"". 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.29.2. Inline PERFORM,"Inline PERFORM Syntax
  
 PERFORM 
 ~~~~~~~ 
 [ { [ WITH TEST { BEFORE } ] { VARYING-Clause  
 } } ] 
 {  
 ~~~~ { ~~~~~~ }  { UNTIL conditional-expression-1 } } 
 {  
 { AFTER  }  
 ~~~~~  
 } 
 {  
 ~~~~~  
 } 
 { UNTIL EXIT|FOREVER  
 } 
 { ~~~~~ ~~~~ ~~~~~~~  
 } 
 { { literal-1 } TIMES  } 
 { { identifier-1 } ~~~~~  
 } 
 imperative-statement-1 
 [ END-PERFORM ] 
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""PERFORM"" statement is identical in operation to the procedural 
 ""PERFORM"", except for the fact that the statement(s) comprising the perform scope 
 (<
 imperative-statement-1
 >) (see
  [Imperative Statement], page 593
 ) are now specified in-line 
 with the ""PERFORM"" code rather than in procedures located elsewhere within the program. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.29.3. VARYING,"VARYING Syntax
  
 VARYING identifier-2 FROM { literal-2 
 } [ BY { literal-3 
 } ] 
 ~~~~~~~ 
 ~~~~ { identifier-3 } 
 ~~ { identifier-4 } 
  
  
 [ UNTIL conditional-expression-1 ]  
  
  
  
 ~~~~~  
 [ AFTER identifier-5 FROM { literal-4  
 } [ BY { literal-5  
 } ] 
  
 ~~~~~   
  
 ~~~~ { identifier-6 }  
 ~~ 
 { identifier-7 }  
  
 [ UNTIL conditional-
 expression-2 ] ]... 
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""VARYING"" clause, available on both formats of the ""PERFORM"" statement, is a looping 
 mechanism that allows for the specification of one or more numeric data items that will be 
 initialized to a programmer-specified value and automatically incremented by another 
 programmer-specified value after each loop iteration. 
 1. All identifiers used in a <
 VARYING-Clause
 > must be elementary, un-edited numeric data 
 items. All literals must be numeric literals. 
 2. The following points describe the sequence of events that take place as a result of the 
 ""VARYING"" portion of the clause: 
 A. When the ""PERFORM"" begins execution, the ""FROM"" value will be moved to <
 iden-
 tifier
 >. 
 B. If the ""PERFORM"" specifies or implies ""WITH TEST BEFORE"", 
 <
 conditional-
  
 expression-1
 > will be evaluated and processing of the ""PERFORM"" will halt if the 
 expression evaluates to TRUE. If ""WITH TEST BEFORE"" was
  not
  specified or 
 implied, or if the conditional expression evaluated to FALSE, processing proceeds 
 with step (C). 
 C. The statements within the perform scope will be executed. If a ""GO TO"" executed 
 within the perform scope transfers control to a point outside the perform scope, 
 processing of the ""PERFORM"" will halt. 
 D. When the statements within the perform scope terminate the loop iteration, by. . . 
 •
  . . .allowing the flow of execution to attempt to fall past the last statement in the 
 perform scope, or. . . 
 •
  . . .executing an ""EXIT PERFORM CYCLE"" statement (see
  [EXIT], page 387
 ), or. . . 
 •
  . . .executing an ""EXIT PARAGRAPH"" statement or ""EXIT SECTION"" statement 
 when there is only one paragraph (or section) in the perform scope ( this 
  
 option only applies to a procedural ""PERFORM"")",NA
6.17.30. READ,NA,NA
6.17.30.1. Sequential READ,"Sequential READ Syntax
  
 READ file-name-1 [ { NEXT|PREVIOUS } ] RECORD [ INTO identifier-1 ] 
 ~~~~ 
 { ~~~~ ~~~~~~~~ } 
 ~~~~ 
 [ { IGNORING LOCK 
 } ] 
 { ~~~~~~~~ ~~~~ 
 } 
  
   
 { WITH [ NO ] LOCK }  
  
   
 {   
  
 ~~  ~~~~ }  
  
   
 { WITH KEPT LOCK  
 }  
  
   
 {   
 ~~~~ ~~~~  
  
 }   
  
 { WITH IGNORE LOCK }  
  
   
 {   
 ~~~~~~ ~~~~ }  
  
   
 { WITH WAIT  
  
 }  
  
   
  
  
 ~~~~  
  
  [ AT END imperative-statement-1 ]  
  
   
  
 ~~~  
  
  [ NOT AT END imperative-statement-2 ]  
  
   
 ~~~  
 ~~~  
 [ END-READ ]  
  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This form of the ""READ"" statement retrieves the next (or previous) record from a file. 
 1. The reserved words ""AT"", ""RECORD"" and ""WITH"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. The <
 file-name-1
 > file
  must
  have been defined via an ""FD"" (see
  [File/Sort-Description], 
 page 94
 ), not an ""SD"". 
 3. The <
 file-name-1
 > file must currently be open for ""INPUT"" (see
  [File OPEN Modes], page 
 421
 ) or ""I-O"". 
 4. If <
 file-name-1
 > is an ""ORGANIZATION RELATIVE"" (see
  [ORGANIZATION RELA-TIVE], 
 page 82
 ) or ""ORGANIZATION INDEXED"" (see
  [ORGANIZATION INDEXED], page 84
 ) file 
 with an ""ACCESS MODE RANDOM"", this statement cannot be used. 
 5. If <
 file-name-1
 > was specified as ""ACCESS MODE SEQUENTIAL"", this is the
  only
  format of 
 the ""READ"" statement that is available. 
 6. If <
 file-name-1
 > is an ""ORGANIZATION RELATIVE"" (see
  [ORGANIZATION RELA-TIVE], 
 page 82
 ) or ""ORGANIZATION INDEXED"" (see
  [ORGANIZATION INDEXED],
  
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.30.2. Random READ,"Random READ Syntax
  
 READ file-name-1 RECORD [ INTO identifier-1 ] 
 ~~~~ 
 } ] 
 ~~~~ 
 [ { IGNORING LOCK 
 { ~~~~~~~~ ~~~~ 
 } 
  
   
 { WITH [ NO ] LOCK }  
  
   
 {  
  
 ~~  ~~~~ }  
  
   
 { WITH KEPT LOCK  
 }  
  
   
 {  
 ~~~~ ~~~~  
  
 }   
  
 { WITH IGNORE LOCK }  
  
   
 {  
 ~~~~~~ ~~~~ }  
  
   
 { WITH WAIT  
  
 }  
  
   
  
 ~~~~  
  
  [ KEY IS identifier-2 ]  
  
   
 ~~~  
  
  [ INVALID KEY imperative-statement-1 ]  
  
  
 ~~~~~~~  
  
  [ NOT INVALID KEY imperative-statement-2 ]  
  
  ~~~ ~~~~~~~  
 [ END-READ ]  
  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 This form of the ""READ"" statement retrieves an arbitrary record from an ""ORGANIZATION 
 RELATIVE"" (see
  [ORGANIZATION RELATIVE], page 82
 ) or ""ORGANIZATION INDEXED"" (see
  
 [ORGANIZATION INDEXED], page 84
 ) file. 
 1. The reserved words ""IS"", ""KEY"" (on the ""INVALID"" and ""NOT INVALID"" clauses), 
 ""RECORD"" and ""WITH"" are optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of these words has no effect upon the program. 
 2. The <
 file-name-1
 > file
  must
  have been defined via an ""FD"" (see
  [File/Sort-Description], 
 page 94
 ), not an ""SD"". 
 3. The <
 file-name-1
 > file must currently be open for ""INPUT"" (see
  [File OPEN Modes], page 
 421
 ) or ""I-O"". 
 4. If the ""ACCESS MODE"" of <
 file-name-1
 > is ""SEQUENTIAL"", or the ""ORGANIZATION"" of the 
 file is any form of sequential, this format of the ""READ"" statement cannot be used. 
 5. If the ""ACCESS MODE"" of <
 file-name-1
 > is ""RANDOM"", this is the
  only
  format of the 
 ""READ"" statement that is available. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.31. READY TRACE,"READY TRACE Syntax
  
 READY TRACE  
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""READY TRACE"" statement turns procedure or procedure-and-statement tracing on. 
 1. In order for this statement to be functional, tracing code must have been generated into 
 the compiled program using either the ""-ftrace"" switch (procedures only) or ""-ftraceall"" 
 switch (procedures and statements). 
 2. Tracing may be turned off at any point by executing the ""RESET TRACE"" statement (see
  
 [RESET TRACE], page 435
 ). 
 3. The ""COB_SET_TRACE"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) provides another way to control tracing. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.32. RELEASE,"RELEASE Syntax
  
 RELEASE record-name-1 [ FROM { literal-1 
 } ] 
 ~~~~~~~ 
 ~~~~ { identifier-1 } 
 ———————————————————————————————————————— 
 The ""RELEASE"" statement adds a new record to a sort work file. 
 1. This statement is valid only within the ""INPUT PROCEDURE"" of a file-based ""SORT"" 
 statement (see
  [File-Based SORT], page 453
 ). 
 2. The specified <
 record-name-1
 > must be a record defined to the sort description (""SD"" 
 (see
  [File/Sort-Description], page 94
 )) of the sort work file being processed by the 
 current sort. 
 3. The optional ""FROM"" clause will cause <
 literal-1
 > or <
 identifier-1
 > to be automatically 
 moved into <
 record-name-1
 > prior to writing <
 record-name-1
 >’s contents to the <
 file-
 name-1
 >. If this clause is not specified, it is the programmer’s responsibility to populate 
 <
 record-name-1
 > with the desired data prior to executing the ""RELEASE"". 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.33. RESET TRACE,"RESET TRACE Syntax
  
 RESET TRACE  
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""RESET TRACE"" statement turns procedure or procedure-and-statement tracing off. 
 1. By default, procedure and procedure-and-statement tracing is off as programs begin 
 execution. The ""READY TRACE"" statement (see
  [READY TRACE], page 433
 ) can be used 
 to turn tracing on. 
 2. In order for this statement to be functional, tracing code must have been generated into 
 the compiled program using either the ""-ftrace"" switch (procedures only) or ""-ftraceall"" 
 switch (procedures and statements). 
 3. The ""COB_SET_TRACE"" run-time environment variable (see
  [Run Time Environment 
 Variables], page 522
 ) provides another way to control tracing. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.34. RETURN,"RETURN Syntax
  
  
 RETURN sort-file-name-1 RECORD  
  
 ~~~~~~  
  
  [ INTO identifier-1 ]  
  
   
 ~~~~  
  
   
 AT END imperative-statement-1  
  
   
  
 ~~~  
  
  [ NOT AT END imperative-statement-2 ]  
  
   
 ~~~  
  
 ~~~ [ END-RETURN ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""RETURN"" statement reads a record from a sort- or merge work file. 
 1. The reserved words ""AT"" and ""RECORD"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The ""RETURN"" statement is valid only within the ""OUTPUT PROCEDURE"" of a file-based 
 ""SORT"" (see
  [File-Based SORT], page 453
 ) or a ""MERGE"" statement (see
  [MERGE], page 
 411
 ) statement. 
 3. The <
 sort-file-name-1
 > file must be a sort- or merge work file defined with a ""SD"" (see 
 [File/Sort-Description], page 94
 ), not an ""FD"". 
 4. A successful ""RETURN"" will retrieve the next available record from <
 sort-file-name-1
 >. 
 The newly-retrieved record data will be saved into the 01-level record structure(s) that 
 immediately follow the file’s SD. If the optional ""INTO"" clause is present, a copy of the 
 just-retrieved record will be automatically moved to <
 identifier-1
 >. 
 5. The mandatory ""AT END"" clause is used to detect and react to the failure of an attempt 
 to retrieve another record from the file due to an end-of-file (i.e. no more records) 
 condition. 
 6. The optional ""NOT AT END"" clause, if coded, will check checking for a file status value of 
 00. See
  [File Status Codes], page 76
 , for additional information. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.35. REWRITE,"REWRITE Syntax
  
 REWRITE record-name-1  
 ~~~~~~~  
  
 [ FROM { literal-1  
 } ]  
  
  
 ~~~~ { identifier-1 } 
  
  
 [ WITH [ NO ] LOCK ]  
  
  
  
  
 ~~  ~~~~  
  
  
 [ INVALID KEY imperative-statement-1 ]   
  
 ~~~~~~~  
  
  
 [ NOT INVALID KEY imperative-statement-2 ]  
  
  
 ~~~ ~~~~~~~  
 [ END-REWRITE ]  
  
 ~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""REWRITE"" statement replaces a logical record on a disk file. 
 1. The reserved words ""KEY"" and ""WITH"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The <
 record-name-1
 > specified on the statement must be defined as an 01-level record 
 subordinate to the File Description (""FD"" (see
  [File/Sort-Description], page 94
 )) of a 
 file that is currently open for ""I-O"" (see
  [File OPEN Modes], page 421
 ). 
 3. The optional ""FROM"" clause will cause <
 literal-1
 > or <
 identifier-1
 > to be automatically 
 moved into <
 record-name-1
 > prior to writing <
 record-name-1
 >’s contents to the <
 file-
 name-1
 >. If this clause is not specified, it is the programmer’s responsibility to populate 
 <
 record-name-1
 > with the desired data prior to executing the ""REWRITE"". 
 4. This statement may not be used with ""ORGANIZATION LINE SEQUENTIAL"" (see 
 [ORGANIZATION LINE SEQUENTIAL], page 80
 ) files. 
 5. Rewriting a record does not cause the contents of the file to be physically updated until 
 the next block of the file is read, a ""COMMIT"" (see
  [COMMIT], page 365
 ) or ""UNLOCK"" 
 statement (see
  [UNLOCK], page 474
 ) is issued or that file is closed. 
 6. If the file has ""ORGANIZATION SEQUENTIAL"" (see
  [ORGANIZATION SEQUENTIAL], page 
 78
 ): 
 A. The record to be rewritten will be the one retrieved by the most-recently executed 
 ""READ"" (see
  [READ], page 428
 ) of the file. 
 B. If the ""FD"" of the file contains the ""RECORD CONTAINS"" or ""RECORD IS VARYING"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.36. ROLLBACK,"ROLLBACK Syntax
  
 ROLLBAC
 K  
 ~~~~~~
 ~~ 
 ————————————————————————————————————————
 The ""ROLLBACK"" statement has the same effect as if an ""UNLOCK"" statement (see
  [UNLOCK], 
 page 474
 ) were executed against every open file in the program. 
 1. All locks currently being held for all open files will be released. 
 2. See
  [Record Locking], page 233
 , to review the various record locking behaviors. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.37. SEARCH,"SEARCH Syntax
  
 SEARCH table-name-1  
 ~~~~~~  
  
 [ VARYING index-name-1 ]  
  
  
 ~~~~~~~  
  
 [ AT END imperative-statement-1 ]  
  
  
  
 ~~~  
  
 { WHEN conditional-expression-1 imperative-statement-2 }... 
  
  
 ~~~~  
 [ END-SEARCH ]  
  
 ~~~~~~~~~
 ~ 
 ———————————————————————————————————————— 
 The ""SEARCH"" statement is used to sequentially search a table, stopping either once a 
 specific value is located within the table or when the table has been completely searched. 
 1. The reserved word ""AT"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. The searching process will be controlled through a ’
 Search Index
 ’ — a data item with a 
 ""USAGE"" (see
  [USAGE], page 186
 ) of ""INDEX"". The search index is either the <
 index-
 name-1
 > identifier specified on the ""VARYING"" clause or — if no ""VARYING"" is spec-
 ified — the ""USAGE INDEX"" data item implicitly created by an ""INDEXED BY"" (see 
 [OCCURS], page 158
 ) clause in the table’s definition. 
 3. At the time the ""SEARCH"" statement is executed, the current value of the search index 
 data item will define the starting position in the table where the searching process will 
 begin. Typically, one initializes that index to a value of 1 before starting the ""SEARCH"" 
 via ""SET <
 search-index
 > TO 1"". 
 4. Each of the <
 conditional-expression-n
 >s on the ""WHEN"" clause(s) should involve a data 
 element within the table, subscripted using the search index. 
 5. The searching process is as follows: 
 A. Each <
 conditional-expression-n
 > will be evaluated, in turn, until either one evalu-ates 
 to a value of TRUE or all have evaluated to FALSE. 
 B. The <
 imperative-statement-n
 > (see
  [Imperative Statement], page 593
 ) specified on 
 the ""WHEN"" clause whose <
 conditional-expression-n
 > evaluated to TRUE will be 
 executed; after that, the search will be considered complete and control will fall 
 into the first executable statement following the ""SEARCH"". 
 C. If all <
 conditional-expression-n
 >s evaluated to FALSE: 
 •
  The search index will be incremented by 1 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.38. SEARCH ALL,"SEARCH ALL Syntax
  
  
 SEARCH ALL table-name-1  
  
 ~~~~~~ ~~~  
  
  
 [ AT END imperative-statement-1 ]  
  
  
  
  
 ~~~  
  
  
  
 WHEN conditional-expression-1 imperative-statement-2  
  
  
 ~~~~  
 [ END-SEARCH ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SEARCH ALL"" statement performs a binary, or half-interval, search against a sorted 
 table.  This is generally
  significantly
  faster than performing a sequential ""SEARCH"" of a 
 table, especially if the table contains a large number of entries. 
 1. The reserved word ""AT"" is optional and may be included, or not, at the discretion of the 
 programmer. The presence or absence of this word has no effect upon the program. 
 2. To be eligible for searching via ""SEARCH ALL"": 
 A. The ""OCCURS"" clause of <
 table-name-1
 > must contain the following elements: 
 •
  An ""INDEXED BY"" entry to define an implicit search index data item with a 
 ""USAGE"" (see
  [USAGE], page 186
 ) of ""INDEX"". 
 •
  An ""ASCENDING KEY"" or ""DESCENDING KEY"" clause to specify the field within the 
 table by which all entries in the table are sorted. 
 B. Just because the table has one or more ""KEY"" clauses doesn’t mean the data is 
 actually
  in
  that sequence in the table — the actual sequence of the data
  must
  agree 
 with the KEY clause(s)! A table-based ""SORT"" (see
  [Table SORT], page 457
 ) can 
 prove very useful in this regard. 
 C. No two records in the table may have the same ""KEY"" field values. If the table has 
 multiple ""KEY"" definitions, then no two records in the table may have the same 
 combination
  of ""KEY"" field values. 
 3. If rule (A) is violated, the compiler will reject the ""SEARCH ALL"". If rules (B) and/or (C) 
 are violated, there will be no message issued by the compiler, but the run-time results 
 of a ""SEARCH ALL"" against the table will probably be incorrect. 
 4. The <
 conditional-expression-1
 > should involve the ""KEY"" field(s), using the search index 
 (the table’s ""INDEXED BY"" index name) as a subscript. 
 5. The function of the single, mandatory, ""WHEN"" clause is to compare the key field(s) of 
 the table, as indexed by the search index data item, against whatever literal and/or 
 identifier values you are comparing the key field(s) to in the <
 conditional-expression-1
 >",NA
6.17.39. SET,NA,NA
6.17.39.1. SET ENVIRONMENT,"SET ENVIRONMENT Syntax
  
 SET ENVIRONMENT { literal-1 
 } TO { literal-2 
 } 
 ~~~ ~~~~~~~~~~~ { identifier-1 } ~~ { identifier-2 } 
 ———————————————————————————————————————— 
 The ""SET ENVIRONMENT"" statement provides a straight-forward means of setting environ-
 ment values from within a program. 
 1. The value of <
 literal-1
 > or <
 identifier-1
 > specifies the name of the environment variable 
 to set. 
 2. The value of <
 literal-2
 > or <
 identifier-2
 > specifies the value to be assigned to the 
 environment variable. 
 3. Environment variables created or changed from within GNU COBOL programs will be 
 available to any sub-shell processes spawned by that program (i.e. CALL ""SYSTEM"") but 
 will not be known to the shell or console window that started the GNU COBOL program. 
 This is a much simpler and more readable means of setting environment variables than by 
 using the ""DISPLAY UPON ENVIRONMENT-NAME"" statement (see
  [DISPLAY UPON
  
 ENVIRONMENT-NAME], page 373
 ). 
 identical results: 
 For example, these two code sequences produce 
 DISPLAY ""VARNAME"" UPON ENVIRONMENT-
 NAME  
 DISPLAY ""VALUE"" UPON ENVIRONMENT-
 VALUE 
 SET ENVIRONMENT ""VARNAME"" TO ""VALUE"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.39.2. SET Program-Pointer,"SET Program-Pointer Syntax
  
 SET program-pointer-1 TO ENTRY { literal-1 
 } 
 ~~~ 
 ~~ ~~~~~ { identifier-1 } 
 ———————————————————————————————————————— 
 The ""SET <
 Program-Pointer
 >"" statement allows you to retrieve the address of a procedure 
 division code module — specifically the ""PROGRAM-ID"", ""FUNCTION-ID"" or an entry-point 
 established via the ""ENTRY"" statement (see
  [ENTRY], page 382
 ). 
 1. If you have used other versions of COBOL before (particularly mainframe implemen-
 tations), you’ve possibly seen subroutine calls made passing a procedure name as an 
 argument — that is not possible in GNU COBOL; instead, you need to know how to use 
 this form of the ""SET"" statement. 
 2. The 
 ""USAGE"" (see 
 [USAGE],
  
 page
  
 186
 ) of <
 program-pointer-1
 > must 
 be 
 ""PROGRAM-POINTER"". 
 3. The <
 literal-1
 > or <
 identifier-1
 > value specified must name a primary entry-point name 
 (""PROGRAM-ID"" of a subroutine or ""FUNCTION-ID"" of a user-defined function) or an 
 alternate entry-point defined via an ""ENTRY"" statement within a subprogram. 
 4. Once the address of a procedure division code area has been acquired in this way, the 
 address could be passed to a subroutine (usually written in C) for whatever use it 
 needs it for. For examples of ""PROGRAM-POINTER""s at work, see the discussions of the 
 ""CBL_ERROR_PROC"" built-in system subroutine (see
  [CBL ERROR PROC], page 536
 ) 
 and ""CBL_EXIT_PROC"" built-in system subroutine (see
  [CBL EXIT PROC], page 538
 ). 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.39.3. SET ADDRESS,"SET ADDRESS Syntax
  
 SET [ ADDRESS OF ] { pointer-name-1 }... 
 ~~~ ~~~~~~~ ~~  { identifier-1  
 } 
 TO [ ADDRESS OF ]  
 { pointer-name-2 } 
 ~~  ~~~~~~~ ~~  { identifier-2  
 } 
 ———————————————————————————————————————— 
 The ""SET ADDRESS"" statement can be used to work with the addresses of data items rather 
 than their contents. 
 1. When the ""ADDRESS OF"" clause is used
  before
  the ""TO"" you will be using this statement 
 to alter the address of a linkage section or ""BASED"" (see
  [BASED], page 130
 ) data item. 
 Without that clause you will be assigning an address to one or more data items whose 
 ""USAGE"" (see
  [USAGE], page 186
 ) is ""POINTER"". 
 2. When the ""ADDRESS OF"" clause is used
  after
  the ""TO"", this statement will be identifying 
 the address of <
 identifier-2
 > as the address to be assigned to <
 identifier-1
 > or stored 
 in <
 pointer-name-1
 >. 
 3. If the ""ADDRESS OF"" clause is absent after the ""TO"", the contents of <
 pointer-name-2
 > 
 will serve as the address to be assigned. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.39.4. SET Index,"SET Index Syntax
  
 SET index-name-1 TO { literal-1 
 } 
 ~~~ 
 ~~ { identifier-2 } 
 ————————————————————————————————————————
 This statement assigns a value to a ""USAGE INDEX"" data item. 
 1. Either the ""USAGE"" (see
  [USAGE], page 186
 ) of <
 index-name-1
 > should be ""INDEX"", or 
 <
 index-name-1
 > must be identified in a table ""INDEXED BY"" clause. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.39.5. SET UP/DOWN,"SET UP/DOWN Syntax
  
 SET identifier-1 { UP 
 } BY [ LENGTH OF ] { literal-1 
 } 
 ~~~ 
 { ~~ 
 } ~~ ~~~~~~ ~~ { identifier-2 } 
 { DOWN }  
 ~~~~ 
 ———————————————————————————————————————— 
 Use this statement to increment or decrement the value of an index or pointer by a specified 
 amount. 
 1. The ""USAGE"" (see
  [USAGE], page 186
 ) of <
 identifier-1
 > must be ""INDEX"", ""POINTER"" or 
 ""PROGRAM-POINTER"". 
 2. The typical usage when <
 identifier-1
 > is a ""USAGE INDEX"" data item is to increment it’s 
 value ""UP"" or ""DOWN"" by 1, since an index is usually being used to sequentially walk 
 through the elements of a table. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.39.6. SET Condition Name,"SET Condition Name Syntax
  
 SET condition-name-1... 
 TO { TRUE 
 } 
 ~~~ 
 ~~ { ~~~~ } 
 { FALSE }  
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""SET <
 Condition Name
 >"" statement provides one method of specifying the TRUE / 
 FALSE value of a level-88 condition name. 
 1. By setting the specified <
 condition-name-1
 >(s) to a TRUE or FALSE value, you will 
 actually be assigning a value to the parent data item(s) to which the condition name 
 data item(s) is(are) subordinate to. 
 2. When specifying ""TRUE"", the value assigned to each parent data item will be the first 
 value specified on the condition name’s ""VALUE"" clause. 
 3. When specifying ""FALSE"", the value assigned to each parent data item will be the value 
 specified for the ""FALSE"" clause of the condition name’s definition; if any <
 condition-
 name-1
 > occurrence lacks a ""FALSE"" clause, the ""SET"" statement will be rejected by the 
 compiler. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.39.7. SET Switch,"SET Switch Syntax
  
 SET mnemonic-name-1... 
 TO { ON 
 } 
 ~~~ 
 ~~ { ~~ 
 } 
 { OFF }  
 ~~~ 
 ———————————————————————————————————————— 
 This form of the ""SET"" statement is used to turn switches on or off. 
 1. Switches are defined using the ""SPECIAL-NAMES"" (see
  [SPECIAL-NAMES], page 62
 ) 
 paragraph. 
 2. Switches may be tested via the ""IF"" statement (see
  [IF], page 397
 ) and a Switch-Status 
 Condition. See
  [Switch-Status Conditions], page 222
 , for more information. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.39.8. SET ATTRIBUTE,"SET ATTRIBUTE Syntax
  
 SET identifier-1 ATTRIBUTE { { BELL 
 } { ON 
 }... 
 ~~~ 
 ~~~~~~~~~ 
 { ~~~~ 
 } { ~~ 
 } 
 { BLINK  
 { ~~~~~  
 { HIGHLIGHT  
 { 
 ~~~~~~~~
 ~  
 { LEFTLINE  
 { ~~~~~~~~  
 { LOWLIGHT  
 { ~~~~~~~~  
 { OVERLINE  
 { ~~~~~~~~ 
 } { OFF } 
 } 
 ~~~ 
 }  
 }  
 }  
 }  
 }  
 }  
 }  
 } 
 { REVERSE-VIDEO }  
 { 
 ~~~~~~~~~~~~
 ~ }  
 { UNDERLINE }  
  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SET ATTRIBUTE"" statement may be used to modify one or more attributes of a screen 
 section data item at run-time. 
 1. When making an attribute change to <
 identifier-1
 >, the change will not become vis-ible 
 on the screen until the screen section data item containing <
 identifier-1
 > is next 
 accepted (if <
 identifier-1
 > is an input field) or is next displayed (if <
 identifier-1
 > is not 
 an input field). 
 2. The attributes shown in the syntax diagram are the only ones that may be altered by this 
 statement. See
  [Data Description Clauses], page 125
 , for information on their usage. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.40. SORT,NA,NA
6.17.40.1. File-Based SORT,"File-Based SORT Syntax
  
 SORT sort-file-1 
 ~~~~ 
 { ON { ASCENDING 
 } KEY identifier-1... 
 }... 
 { ~~~~~~~~~ 
 } 
 { DESCENDING } 
 ~~~~~~~~~~ 
 [ WITH DUPLICATES IN ORDER ] 
 ~~~~~~~~~~ 
 [ COLLATING SEQUENCE IS alphabet-name-1 ] 
 ~~~~~~~~~ 
 { INPUT PROCEDURE IS procedure-name-1  
 } 
 { ~~~~~~ ~~~~~~~~~  
 } 
 { [ THRU|THROUGH procedure-name-2 ]  
 } 
 { ~~~~ ~~~~~~~  
 } 
 { USING file-name-1 ...  
 } 
 ~~~~~ 
 { OUTPUT PROCEDURE IS procedure-name-3  
 } 
 { ~~~~~~ ~~~~~~~~~  
 } 
 { [ THRU|THROUGH procedure-name-4 ]  
 } 
 { ~~~~ ~~~~~~~  
 } 
 { GIVING file-name-3 ...  
 } 
 ~~~~~~ 
 The ""DUPLICATES"" clause is syntactically recognized but is otherwise non-functional. 
 ———————————————————————————————————————— 
 This format of the ""SORT"" statement is designed to sort large volumes of data according to 
 one or more key fields. 
 1. The reserved words ""IN"", ""IS"", ""KEY"", ""ON"", ""ORDER"", ""SEQUENCE"" and ""WITH"" are 
 optional and may be included, or not, at the discretion of the programmer.  
 The 
 presence or absence of these words has no effect upon the program. 
 2. The reserved words ""THRU"" and ""THROUGH"" are interchangeable. 
 3. GNU COBOL always behaves as if the ""WITH DUPLICATES IN ORDER"" clause is speci- 
 fied, even if it isn’t. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.40.2. Table SORT,"Table SORT Syntax
  
 SORT table-name-1  
 ~~~~ 
 { ON { ASCENDING 
 } KEY identifier-1... 
 }... 
 { ~~~~~~~~~ 
 } 
  
 { DESCENDING }  
  
  
 ~~~~~~~~~~  
 [ WITH DUPLICATES IN ORDER ]  
  
  
 ~~~~~~~~~~  
 [ COLLATING SEQUENCE IS alphabet-name-1 ] 
  
 ~~~~~~~~~ 
 The ""DUPLICATES"" clause is syntactically recognized but is otherwise non-functional. 
 ———————————————————————————————————————— 
 This format of the ""SORT"" statement sorts relatively small quantities of data — namely data 
 contained in a data division table — according to one or more key fields. 
 1. The reserved words ""IN"", ""IS"", ""KEY"", ""ON"", ""ORDER"", ""SEQUENCE"" and ""WITH"" are 
 optional and may be included, or not, at the discretion of the programmer.  
 The 
 presence or absence of these words has no effect upon the program. 
 2. GNU COBOL always behaves as if the ""WITH DUPLICATES IN ORDER"" clause is speci-fied, 
 even if it isn’t. 
 While any COBOL implementation’s sort or merge facilities guarantee that records with 
 duplicate key values will be in proper sequence with regard to other records with 
 different key values, they generally make no promises as to the resulting relative 
 sequence of records having duplicate key values with one another. 
 Some COBOL implementations provide this optional clause to force their sort and 
 merge facilities to retain duplicate key-value records in their original input sequence, 
 relative to one another. 
 3. The <
 table-name-1
 > data item must be a table defined in any data division section 
 except
  
 the report or screen sections. 
 4. The data within <
 table-name-1
 > will be sorted in-place (i.e. no sort file is required). 
 5. The sort will take place by rearranging the data in <
 table-name-1
 > into the sequence 
 defined by the ""KEY"" specification(s) on the ""SORT"" statement, according to the 
 ""COLLATING SEQUENCE"" specified on the ""SORT"" (if any) or — if none was defined —
 the ""PROGRAM COLLATING SEQUENCE"" (see
  [OBJECT-COMPUTER], page 58
 ). Keys 
 may be any supported data type and ""USAGE"" (see
  [USAGE], page 186
 ) except for level-
 78 or level-88 data items. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.41. START,"START Syntax
  
  
 START file-name-1  
  
 ~~~~~  
  
  [ { FIRST   
  
  
  
  
 } ]  
  
   { ~~~~~  
  
  
  
  
  
 } 
  
    { LAST   
  
  
  
  
 }  
  
   { ~~~~   
  
  
  
  
 }  
  
   { KEY { IS EQUAL TO | IS = | EQUALS  } identifier-1 }  
  
  
    { ~~~~~  
  
  
 ~~~~~~  
 }  
  
      
 { IS GREATER THAN | IS >  }  
  
      
 { ~~~~~~~  
  
  
  
 }  
  
      
 { IS GREATER THAN OR EQUAL TO | IS >= }  
  
      
 { ~~~~~~~  
  
  ~~ ~~~~~  
 }  
  
  
  
  
  
 { IS NOT LESS THAN  
  
 }  
  
      
 { ~~~ ~~~~  
  
  
  
 }  
  
      
 { IS LESS THAN | IS <  
  
  }    
  
  
  
 { ~~~~  
  
  
  }  
  
      
 { IS LESS THAN OR EQUAL TO | IS <=  
 }  
  
      
 { ~~~~  
  
 ~~ ~~~~~  
 }  
  
  
  
  
  
 { IS NOT GREATER THAN  
  
 }  
  
      
 ~~~ ~~~~~~~  
  
  [ INVALID KEY imperative-statement-1 ]  
  
    ~~~~~~~  
  
  [ NOT INVALID KEY imperative-statement-2 ]  
  
    ~~~ ~~~~~~~  
 [ END-START ]  
  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""START"" statement defines the logical starting point within a relative or indexed file for 
 subsequent sequential read operations. It positions an internal logical record pointer to a 
 particular record in the file, but does not actually transfer any of that record’s data into the 
 record buffer. 
 1. The reserved words ""IS"", ""KEY"", ""THAN"" and ""TO"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. To use this statement, <
 file-name-1
 > must be an ""ORGANIZATION RELATIVE"" 
 (see
  [ORGANIZATION RELATIVE], page 82
 ) or ""ORGANIZATION INDEXED"" (see 
 [ORGANIZATION INDEXED], page 84
 ) file that must have been defined with an ""ACCESS 
 MODE DYNAMIC"" or ""ACCESS MODE SEQUENTIAL"" in its ""SELECT"" statement (see
  
 [SELECT], page 73
 ).",NA
6.17.42. STOP,"STOP Syntax
  
 STOP { RUN [ { RETURNING|GIVING { literal-1 
 } 
 } ] } 
 ~~~~ { ~~~ { ~~~~~~~~~ ~~~~~~ { identifier-1 } 
 } 
 } 
 { 
 { 
 } 
 } 
 { 
 { WITH { ERROR 
 } STATUS [ { literal-2 
 } ] } 
 } 
 { 
 { 
 { ~~~~~ 
 } 
 { identifier-2 } 
 } 
 } 
 { 
 { 
 { NORMAL } 
 } 
 } 
 { 
 ~~~~~~ 
 } 
 { literal-3 
 } 
 ———————————————————————————————————————— 
 The ""STOP"" statement suspends program execution. Some options will allow program exe-
 cution to resume while others return control to the operating system. 
 1. The reserved words ""STATUS"" and ""WITH"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. The reserved words ""RETURNING"" and ""GIVING"" are interchangeable. 
 3. The ""RUN"" clause halts the program without displaying any special message to that 
 effect. 
 4. The <
 literal-3
 > clause displays the specified text on the ""SYSOUT""/""STDOUT"" device, 
 waits for the user to press the Enter key and then — once the key has been pressed —
 allows the program to continue execution. 
 5. The optional ""RETURNING"" clause provides the opportunity to return a numeric value 
 to the operating system (a ""return code""). The manner in which the return code may be 
 interrogated by the operating system varies, but Windows can use ""%ERRORLEVEL%"" 
 to query the return code while Unix shells such as sh, bash and ksh can query the 
 return code as ""$?"". Other Unix shells may have different ways to access return code 
 values. 
 6. The ""STATUS"" clause provides another means of returning a return code. Using the 
 ""STATUS"" clause is functionally equivalent to using the ""RETURNING"" clause. 
 7. Using the ""STATUS"" clause without a <
 literal-2
 > or <
 identifier-2
 > will return a return 
 code of 0 if the ""NORMAL"" keyword is used or a 1 if ""ERROR"" was specified. 
 8. Your program will
  always
  return a return code, even if no ""RETURNING"" or ""STATUS"" 
 clause is specified. In the absence of the use of these clauses, the value in the ""RETURN-
 CODE"" special register (see
  [Special Registers], page 243
 ) at the time the ""STOP"" statement 
 is executed will be used as the return code. 
 9. Any programmer-defined exit procedure (established via the ""CBL_EXIT_PROC"" built- 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.43. STRING,"STRING Syntax
  
 STRING 
 ~~~~~~ 
 { { literal-1 } [ DELIMITED BY { SIZE  
 } ] }... 
 { identifier-1 } ~~~~~~~~~  
 { ~~~~  
 } 
 { literal-2 } 
 INTO identifier-3  
 ~~~~ 
 { identifier-2 } 
  
  
 [ WITH POINTER identifier-4 ]  
  
  
  
  
  
 ~~~~~~~  
  
  
 [ ON OVERFLOW imperative-statement-1 ]  
  
  
  
 ~~~~~~~~  
  
  
 [ NOT ON OVERFLOW imperative-statement-2 ]  
  
  
 ~~~   
 ~~~~~~~~  
 [ END-STRING ]  
  
 ~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""STRING"" statement is used to concatenate all or a part of one or more strings together, 
 forming a new string. 
 1. The reserved words ""BY"", ""ON"" and ""WITH"" are optional and may be included, or not, at 
 the discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. All literals and identifiers (except for <
 identifier-4
 >) must be explicitly or implicitly 
 defined with a ""USAGE"" (see
  [USAGE], page 186
 ) of ""DISPLAY"". Any of the identifiers 
 may be group items. 
 3. The ""POINTER"" data item — <
 identifier-4
 > — must be a non-edited elementary integer 
 numeric data item with a value greater than zero. 
 4. Each <
 literal-1
 > / <
 identifier-1
 > will be referred to as a source item. The receiving data 
 item is <
 identifier-3
 >. 
 5. The ""STRING"" statement’s processing is based upon a ’
 current character pointer
 ’. The 
 initial value of the current character pointer will be the value of <
 identifier-4
 > at the 
 time the ""STRING"" statement began execution. If no ""POINTER"" clause is coded, a value 
 of 1 (meaning ""the 1st character position"") will be assumed for the current character 
 pointer’s initial value. 
 6. For each source item, the contents of the sending item will be copied — character-by-
 character — into <
 identifier-3
 > at the character position specified by the current 
 character pointer. After each character is copied, the current character pointer will be 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.44. SUBTRACT,NA,NA
6.17.44.1. SUBTRACT FROM,"SUBTRACT FROM Syntax
  
 SUBTRACT { literal-1 
 }... 
 FROM { identifier-2 
 } ] ] }...  
 } 
 ~~~~~~~~ { identifier-1 } 
 ~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO 
 ~~~~~~~ ~~~~ 
 { ~~~~~~~~~~~~~~ 
  
  
  
  
  
  
 { NEAREST-AWAY-FROM-ZERO } 
  
  
  
  
  
  
 { 
 ~~~~~~~~~~~~~~~~~~~~~~ }  
  
  
  
  
  
 { NEAREST-EVEN  }   
  
  
  
  
 { ~~~~~~~~~~~~  
 }   
  
  
  
  
 { NEAREST-TOWARD-ZERO  
 } 
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~~~~~~ 
  
 }   
  
  
  
  
 { PROHIBITED  
 } 
  
  
  
  
  
  
 { ~~~~~~~~~~  
 } 
  
  
  
  
  
  
 { TOWARD-GREATER  
 } 
  
  
  
  
  
  
 { ~~~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
 { TOWARD-LESSER  
 } 
  
  
  
  
  
  
 { ~~~~~~~~~~~~~  
 } 
  
  
  
  
  
  
 { TRUNCATION  
 } 
  
  
  
  
  
  
  
 ~~~~~~~~~~  
  
 [ ON SIZE ERROR imperative-statement-1 ]  
  
  
  
  
 ~~~~ ~~~~~  
  
 [ NOT ON SIZE ERROR imperative-statement-2 ]  
  
  
 ~~~ ~~~~ ~~~~~  
 [ END-SUBTRACT ]  
  
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 This format of the ""SUBTRACT"" statement generates the arithmetic sum of all arguments 
 that appear before the ""FROM"" (<
 identifier-1
 > or <
 literal-1
 >) and subtracts that sum from 
 each <
 identifier-2
 >. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items. 
 3. <
 literal-1
 > must be a numeric literal. 
 4. The optional ""ROUNDED"" (see
  [ROUNDED], page 240
 ) clause available to each 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.44.2. SUBTRACT GIVING,"SUBTRACT GIVING Syntax
  
 SUBTRACT { literal-1 
 }... 
 FROM identifier-2  
 ~~~~ 
 ~~~~~~~~ { identifier-1 } 
 GIVING { identifier-3 
 ~~~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO  
 } ] ] }... 
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~  
 } 
 { NEAREST-AWAY-FROM-ZERO } 
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 { NEAREST-EVEN  
 } 
 { ~~~~~~~~~~~~  
 } 
 { NEAREST-TOWARD-ZERO  } 
 { ~~~~~~~~~~~~~~~~~~~  
 } 
 { PROHIBITED  
 } 
 { ~~~~~~~~~~  
 } 
 { TOWARD-GREATER  
 } 
 { ~~~~~~~~~~~~~~  
 } 
 { TOWARD-LESSER  
 } 
 { ~~~~~~~~~~~~~  
 } 
 { TRUNCATION  
 } 
 ~~~~~~~~~~ 
 [ ON SIZE ERROR imperative-statement-1 ] 
 ~~~~ ~~~~~ 
 [ NOT ON SIZE ERROR imperative-statement-2 ] 
 ~~~ ~~~~ ~~~~~ 
 [ END-SUBTRACT ] 
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SUBTRACT GIVING"" statement generates the arithmetic sum of all arguments that ap- 
 pear before the ""FROM"" (<
 identifier-1
 > or <
 literal-1
 >), subtracts that sum from the contents 
 of <
 identifier-2
 > and then replaces the contents of the identifiers listed after the ""GIVING"" 
 (<
 identifier-3
 >) with that result. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be numeric unedited data items. 
 3. <
 literal-1
 > must be a numeric literal. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.44.3. SUBTRACT CORRESPONDING,"SUBTRACT CORRESPONDING Syntax
  
 SUBTRACT CORRESPONDING identifier-1 FROM identifier-2 
 ~~~~~~~~  
 ~~~~ 
 [ ROUNDED [ MODE IS { AWAY-FROM-ZERO } ] ] 
 ~~~~~~~  ~~~~  
 { ~~~~~~~~~~~~~~ } 
 { NEAREST-AWAY-FROM-ZERO } 
 { ~~~~~~~~~~~~~~~~~~~~~~ } 
 { NEAREST-EVEN  
 } 
 { ~~~~~~~~~~~~  
 } 
 { NEAREST-TOWARD-ZERO  } 
 { ~~~~~~~~~~~~~~~~~~~  } 
 { PROHIBITED  
 } 
 { ~~~~~~~~~~  
 } 
 { TOWARD-GREATER  
 } 
 { ~~~~~~~~~~~~~~  
 } 
 { TOWARD-LESSER  
 } 
 { ~~~~~~~~~~~~~  
 } 
 { TRUNCATION  
 } 
 ~~~~~~~~~~ 
 [ ON SIZE ERROR imperative-statement-1 ] 
 ~~~~ ~~~~~ 
 [ NOT ON SIZE ERROR imperative-statement-2 ] 
 ~~~ ~~~~ ~~~~~ 
 [ END-SUBTRACT ] 
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SUBTRACT CORRESPONDING"" statement generates code equivalent to individual 
 ""SUBTRACT FROM"" statements for corresponding matches of data items found subordinate 
 to the two identifiers. 
 1. The reserved words ""IS"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. Both <
 identifier-1
 > and <
 identifier-2
 > must be group items. 
 3. See
  [CORRESPONDING], page 236
 , for information on how corresponding matches 
 will be found between <
 identifier-1
 > and <
 identifier-2
 >. 
 4. The optional ""ROUNDED"" (see
  [ROUNDED], page 240
 ) clause available to each 
 <
 identifier-2
 > will control how non-integer results will be saved. 
 5. The optional ""ON SIZE ERROR"" and ""NOT ON SIZE ERROR"" clauses may be used to 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.45. SUPPRESS,"SUPPRESS Syntax
  
 SUPPRESS 
 PRINTING  
 ~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""SUPPRESS"" statement causes the presentation of a report group to be suppressed. 
 1. The reserved word ""PRINTING"" is optional and may be included, or not, at the discretion 
 of the programmer.  
 The presence or absence of this word has no effect upon the 
 program. 
 2. This statement may only appear within a ""USE BEFORE REPORTING"" procedure (in 
 ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 )). 
 3. ""SUPPRESS"" only prevents the presentation of the report group within whose ""USE 
 BEFORE REPORTING"" procedure the statement occurs. 
 4. This statement must be executed each time presentation of the report group is to be 
 suppressed. 
 5. When a report group’s presentation is suppressed, none of the following operations for 
 the report will take place: 
 A. Actual presentation of the report group in question. 
 B. Processing of any ""LINE"" (see
  [LINE], page 153
 ) clauses within the report group in 
 question. 
 C. Processing of the ""NEXT GROUP"" (see
  [NEXT GROUP], page 156
 ) clause (if any) 
 within the report group in question. 
 D. Any modification to the ""LINE-COUNTER"" special register (see
  [Special Registers], 
 page 243
 ). 
 E. Any modification to the ""PAGE-COUNTER"" special register. 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.46. TERMINATE,"TERMINATE Syntax
  
 TERMINATE report-name-1...  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""TERMINATE"" statement causes the processing of the specified report(s) to be completed. 
 1. Each <
 report-name-1
 > must be the name of a report having an ""RD"" (see
  [REPORT 
 SECTION], page 107
 ) defined for it. 
 2. The specified report name(s) must be currently initiated (via ""INITIATE"" (see 
 [INITIATE], page 404
 )) and cannot yet have been terminated. 
 3. The ""TERMINATE"" statement will present each ""CONTROL FOOTING"" (if any), in reverse 
 sequence of the control hierarchy, starting with the most minor up to ""FINAL"" (if any). 
 During the presentation of these groups and the processing of any ""USE BEFORE 
 REPORTING"" procedures for those groups, the prior set of control data item values will 
 be available, as though a control break had been detected at the most major control 
 data name. 
 4. During the presentation of the ""CONTROL FOOTING"" groups, any necessary ""PAGE 
 FOOTING"" and ""PAGE HEADING"" groups will be presented as well. 
 5. Finally,the ""REPORT FOOTING"" group, if any, will be presented. 
 6. If an ""INITIATE"" is followed by a ""TERMINATE"" with no intervening ""GENERATE"" (see 
 [GENERATE], page 391
 ) statements (all pertaining to the same report, of course), no 
 report groups will be presented to the output file. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.47. TRANSFORM,"TRANSFORM Syntax
  
 TRANSFORM identifier-1 FROM { literal-1 
 } TO { literal-2 
 } 
 ~~~~~~~~~ 
 ~~~~ { identifier-2 } ~~ { identifier-3 } 
 ———————————————————————————————————————— 
 The ""TRANSFORM"" statement scans a data item performing a series of monoalphabetic sub-
 stitutions, defined by the arguments before and after the ""TO"" clause. 
 1. Both <
 literal-1
 > and/or <
 literal-2
 > must be alphanumeric literals. 
 2. All of <
 identifier-1
 >, <
 identifier-2
 > and <
 identifier-3
 > must either be group items or 
 alphanumeric data items. Numeric data items with a ""USAGE"" (see
  [USAGE], page 186
 ) 
 of ""DISPLAY"" are accepted, but will generate warning messages from the compiler. 
 3. The ""TRANSFORM"" statement will replace characters within <
 identifier-1
 > that are 
 found in the string specified
  before
  the ""TO"" keyword with the corresponding 
 characters from the string specified
  after
  the ""TO"" keyword. 
 4. This statement exists within GNU COBOL to provide compatibility with COBOL pro-
 grams written to pre-1985 standards. The ""TRANSFORM"" statement was made 
 obsolete in the 1985 standard of COBOL, having been replaced by the ""CONVERTING"" 
 clause of the ""INSPECT"" statement (see
  [INSPECT], page 405
 ). New programs should be 
 coded to use ""INSPECT CONVERTING"" rather than ""TRANSFORM"". 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.48. UNLOCK,"UNLOCK Syntax
  
 UNLOCK filename-1 
 RECORD|RECORDS  
 ~~~~~~ 
 ———————————————————————————————————————— 
 This statement synchronizes any as-yet unwritten file I/O buffers to the specified file (if any) 
 and releases any record locks held for records belonging to <
 file-name-1
 >. 
 1. The reserved words ""RECORD"" and ""RECORDS"" are optional and may be included, or 
 not, at the discretion of the programmer. The presence or absence of these words has 
 no effect upon the program. 
 2. If <
 file-name-1
 > is a Sort/Merge work file, no action will be taken. 
 3. Not all GNU COBOL implementations support locking. Whether they do or not de-pends 
 upon the operating system they were built for and the build options that were used 
 when GNU COBOL was generated. When a program using one of those GNU COBOL 
 implementations issues an UNLOCK, it will ignored. There will be no compiler message 
 issued. Buffer syncing, if needed, will still occur. 
 4. See
  [Record Locking], page 233
 , for additional information on record locking. 
 Chapter 6 - PROCEDURE DIVISION 
 3 June 2014",NA
6.17.49. UNSTRING,"UNSTRING Syntax
  
 UNSTRING identifier-1  
 ~~~~~~~~  
  
 DELIMITED BY { [ ALL ] literal-1 } [ OR { [ ALL ] literal-2 } ]... 
 ~~~~~~~~~ 
 { 
 ~~~ 
 } 
 ~~ { 
 ~~~ 
 } 
 { identifier-2 
 } 
 { identifier-3 
 } 
 INTO { identifier-4  
 ~~~~ [ DELIMITER IN identifier-5 ] [ COUNT IN identifier-6 ] }... 
  
  
  
  
  
  
 ~~~~~~~~~ 
  
 ~~~~~   
 [ WITH POINTER identifier-7 ]  
  
  
  
  
  
 ~~~~~~~  
  
  
 [ TALLYING IN identifier-8 ]  
  
  
  
 ~~~~~~~~  
  
  
 [ ON OVERFLOW imperative-statement-1 ]  
  
  
  
  
 ~~~~~~~~  
  
  
 [ NOT ON OVERFLOW imperative-statement-2 ]  
  
  
 ~~~   
 ~~~~~~~~  
 [ END-UNSTRING ]  
  
 ~~~~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""UNSTRING"" statement parses a string, extracting any number of substrings from it. 
 1. The reserved words ""BY"", ""IN"" and ""ON"" are optional and may be included, or not, at the 
 discretion of the programmer. The presence or absence of these words has no effect 
 upon the program. 
 2. <
 identifier-1
 > through <
 identifier-5
 > must be explicitly or implicitly defined with a 
 ""USAGE"" (see
  [USAGE], page 186
 ) of ""DISPLAY"". 
 group items. 
 Any of those identifiers may be 
 3. Both <
 literal-1
 > and <
 literal-2
 > must be alphanumeric literals. 
 4. Each of <
 identifier-6
 >, <
 identifier-7
 > and <
 identifier-8
 > must be elementary non-edited 
 integer numeric items. 
 5. At the time the ""UNSTRING"" statement begins execution, <
 identifier-7
 > must have a value 
 greater than 0. 
 6. <
 identifier-1
 > will be referred to as the ’
 source string
 ’ and each <
 identifier-4
 > will be 
 referred to as a ’
 destination field
 ’ in the following discussions. 
 7. The ""UNSTRING"" statement’s processing is based upon a ’
 current character pointer
 ’, the 
 initial value of which will be the value of <
 identifier-7
 > at the time the ""UNSTRING"" 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
6.17.50. WRITE,"WRITE Syntax
  
 WRITE record-name-1  
 ~~~~~  
  
 [ FROM { literal-1  
 } ]  
  
  
 ~~~~ { identifier-1 } 
 [ WITH [ NO ] LOCK ]  
  
  
  
 ~~  ~~~~  
 [ { BEFORE } ADVANCING { { literal-2  
 } LINE|LINES } ]  { 
 ~~~~~~ }   
 { { identifier-2  
  
 } 
  
 { AFTER  }   
 { PAGE  
  
 } 
  
  
 ~~~~~  
  
  
 { ~~~~  
  } 
  
  
  
  
  
  
 { mnemonic-name-1  
 } 
  
  
 [ AT END-OF-PAGE|EOP imperative-statement-1 ]  
  
  
  
 ~~~~~~~~~~~ ~~~  
  
  
 [ NOT AT END-OF-PAGE|EOP imperative-statement-2 ]  
  
  
 ~~~  ~~~~~~~~~~~ ~~~  
  
  
 [ INVALID KEY imperative-statement-3 ]  
  
  
  
 ~~~~~~~  
  
  
 [ NOT INVALID KEY imperative-statement-4 ]  
  
  
  
 ~~~ ~~~~~~~  
 [ END-WRITE ]  
  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 The ""WRITE"" statement writes a new record to an open file. 
 1. The reserved words ""ADVANCING"", ""AT"", ""KEY"", ""LINE"", ""LINES"" and ""WITH"" are op-
 tional and may be included, or not, at the discretion of the programmer. The presence 
 or absence of these words has no effect upon the program. 
 2. The reserved words ""END-OF-PAGE"" and ""EOP"" are interchangeable. 
 3. The <
 record-name-1
 > specified on the statement must be defined as an 01-level record 
 subordinate to the File Description (""FD"" (see
  [File/Sort-Description], page 94
 )) of a 
 file that is currently open for ""OUTPUT"" (see
  [File OPEN Modes], page 421
 ), ""EXTEND"" 
 or ""I-O"". 
 4. The optional ""FROM"" clause will cause <
 literal-1
 > or <
 identifier-1
 > to be automatically 
 moved into <
 record-name-1
 > prior to writing <
 record-name-1
 >’s contents to the ap-
 propriate file. If this clause is not specified, it is the programmer’s responsibility to 
 populate <
 record-name-1
 > with the desired data prior to executing the ""WRITE"". 
 3 June 2014 
 Chapter 6 - PROCEDURE DIVISION",NA
7. Report Writer Usage Notes,NA,NA
7.1. RWCS Lexicon,"There are a number of terms that describe various aspects of the operation of the Report 
 Writer Control System (RWCS). Understanding the meanings of these terms is vital to 
 developing an understanding of the subject. 
 Control Break
  
 An event that is triggered when a control field on an RWCS-generated report 
 changes value. It is these events that trigger the generation of control heading 
 and control footing groups. 
 Control Field
  
 A field of data being presented within a detail group; as the various detail 
 groups that comprise the report are presented, they are presumed to appear in 
 sorted sequence of the control fields contained within them. As an example, a 
 department-by-department sales report for a chain of stores would probably be 
 sorted by store number and – within like store numbers – be further sorted by 
 department number. The store number will undoubtedly serve as a control 
 field for the report, allowing control heading groups to be presented before 
 each sequence of detail groups for the same store and control footing groups to 
 be presented after each such sequence. 
 Control Footing
  
 A report group that appears immediately after one or more detail groups of an 
 RWCS-generated report. Such are produced automatically as a result of a 
 control break. This type of group typically serves as a summary of the detail 
 group(s) that preceed it, as might be the case on a sales report for a chain of 
 stores, where the detail groups documenting sales for each department (one 
 department per detail group) from the same store might be followed by a 
 control footing that provides a summation of the department-by-department 
 sales for that store. 
 Control Heading
  
 A report group that appears immediately before one or more detail groups of 
 an RWCS-generated report. Such are produced automatically as a result of a 
 control break. This type of group typically serves as an introduction to the 
 detail group(s) that follow, as might be the case on a sales report for a chain of 
 stores, where the detail groups documenting sales for each department (one 
 department per detail group) from the same store might be preceeded by a 
 control heading that states the full name and location of the store. 
 3 June 2014 
 Chapter 7 - Report Writer Usage Notes",NA
7.2. The Anatomy of a Report,"Every report has the same basic structure, as shown here, even though not all reports will 
 have all of the groups shown. In fact, it is a very unusual report indeed that actually has 
 every one of these groups: 
 •
  
 REPORT 
 HEADING 
 •
  
 PAGE 
 HEADING 
 [1] 
 •
  CONTROL HEADING(S) [2] 
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
7.3. The Anatomy of a Report Page,"Each page of a report is divided into as many as five (5) areas, as shown in the following 
 diagram. 
 _______________________________ 
 |  
 | 
 | Top-of-page Unuseable Area  
 |—# Lines: LINES AT TOP (LINAGE) 
 |_______________________________| 
 |  
 |—Line #: HEADING (RD) 
 | Heading Area  
 | 
 |_______________________________|—Line #: FIRST DETAIL (RD) - 1 
 |  
 |—Line #: FIRST DETAIL (RD) 
 |  
 | 
 | Body Area  
 |—Line #: LAST CONTROL HEADING (RD) 
 |  
 |—Line #: LAST DETAIL (RD) 
 |_______________________________|—Line #: FOOTING (RD) 
 |  
 |—Line #: FOOTING (RD) + 1 
 | Footing Area  
 | 
 |_______________________________| 
 |  
 | 
 | Bottom-of-page Unuseable Area |—# Lines: LINES AT BOTTOM (LINAGE) 
 |_______________________________| 
 When describing a report via the ""RD"" (see
  [REPORT SECTION], page 107
 ) clause, the 
 total number of usable lines are specified as the ""PAGE LIMIT"" value; this value is the sum 
 of the number of lines contained in the Heading, Body and Footing Areas. 
 3 June 2014 
 Chapter 7 - Report Writer Usage Notes",NA
7.4. How RWCS Builds Report Pages,"A report created via a ""WRITE"" statement (see
  [WRITE], page 479
 ) will contain carriage-
 control information. Most notably, ASCII form-feed characters (X’0C’) will be written to the 
 report file to support the statement’s ""ADVANCING PAGE"" option. Whether the data for a 
 report line created via ""ADVANCING PAGE"" occurs
  before
  or
  after
  the form-feed character 
 depends upon whether the programmer coded ""WRITE <
 record-name
 > BEFORE 
 ADVANCING PAGE"" or ""WRITE <
 record-name
 > AFTER ADVANCING PAGE"", respectively. 
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
7.5. Control Hierarchy,"Every report that employs control breaks has a natural hierarchy of those control breaks 
 based upon the manner in which the data the report is being generated from is sorted. This 
 concept is best understood using an example which assumes a COBOL program to process 
 sales data collected from every computerized cash register across a chain of stores having 
 multiple departments is being developed. 
 The application that collects data from the various cash registers at each store will generate 
 data records that look like this to a COBOL program: 
 01 
 Sales-For-Register. 
 PIC 9(8). 
 05 Sales-Date 
 05 Time-Collected 
 PIC 9(6). 
 05 Register-Number 
 PIC 9(7). 
 05 Store-Number 
 PIC 9(3). 
 05 Department-Number 
 PIC 9(3). 
 05 Total-Sales 
 PIC 9(6)V99. 
 Your task is to develop a report that shows the sales total from each cash register and 
 summarizes those sales by department within each store, by store and also generates a total 
 sales figure for the day across all stores. 
 To accomplish this, you will use a ""SORT"" statement (see
  [SORT], page 453
 ) to sort the file of 
 cash register sales data into: 
 1. Ascending sequence of store number 
 2. Within each store, data will be sorted into ascending sequence of department number 
 3. If there are multiple cash registers in a particular department of a specific store, the data 
 needs to be further sorted so that the cash registers are ordered in sequence of their 
 register number. 
 So, assuming a sort file has been defined and it’s record layout (essentially a mirror of the 
 raw data file) is defined as follows: 
 01 
 Sorted-Sales-For-Register. 
 PIC 9(8). 
 05 Sorted-Sales-Date 
 05 Sorted-Time-Collected 
 PIC 9(6). 
 05 Sorted-Register-Number 
 PIC 9(7). 
 05 Sorted-Store-Number 
 PIC 9(3). 
 05 Sorted-Department-Number 
 PIC 9(3). 
  
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
7.6. An Example,"This section contains an example of the RWCS at work. The complete program, presented 
 here, is a stripped-down version of a program I have used to generate a report for a class I 
 teach on PC hardware.  
 This report will provide benchmark statistics on a variety of 
 popular AMD and Intel CPUs. The data for the report was obtained from the website
  www. 
 cpubenchmark.net
  in December of 2013. By the time you are reading this, that data will most 
 likely have become rather out-of-date, but it illustrates RWCS well enough.",NA
7.6.1. Data,"Here is the data that the program will be reading. Each record reflects the aggregated 
 benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have 
 been reported to the
  cpubenchmark.net
  wwebsite by their PassMark benchmark software. 
 The data consists of four fields. Fields are separated from one another by a single comma. 
 The descriptions of the fields are as follows: 
 Benchmark Score
  
 A five-digit number showing the aggregated benchmark scores for the CPU; the 
 higher this number, the better the CPU performed in benchmark testing. 
 Vendor
  
 The name of the vendor who makes the CPU. In this data, that will either be 
 ""AMD"" (American Micro Devices) or ""INTEL"". 
 Family
  
 The 7-character family of CPU products the CPU falls into. This will have values 
 such as ""A4"", ""A10"", ""Core i5"", ""Core i7"", etc. 
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
7.6.2. Program,"Here is the program that will be producing the report. Pay attention to how the data is 
 sorted and how the control hierarchy (""CONTROLS ARE"") relates to the ""SORT"". 
 IDENTIFICATION DIVISION. 
 PROGRAM-ID. DEMORWCS. 
 ENVIRONMENT DIVISION. 
 CONFIGURATION SECTION. 
 REPOSITORY. FUNCTION ALL INTRINSIC. 
 INPUT-OUTPUT SECTION. 
 FILE-CONTROL. 
 SELECT CPU-FILE  
 SELECT REPORT-FILE 
 ASSIGN TO ""CPUDATA.txt""  
 LINE SEQUENTIAL. 
 ASSIGN TO ""CPUREPORT.txt"" 
 LINE SEQUENTIAL. 
 SELECT SORT-FILE  
 ASSIGN TO DISK. 
 DATA DIVISION. 
 FILE SECTION. 
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
7.6.3. Generated Report Pages,"Finally, here’s the report the program generates! 
 2013/12/24 
 CPU Benchmark Scores 
 Page: 
 1 
 ******************************************** 
 ** 
 All CPU Data From cpubenchmark.net 
 ** 
 ******************************************** AMD 
  
 A10  
 Family   Model Benchmark Score (High to Low) 
 ======   ====== 
 ============================= A10  
  
 6800K  
  5062  
  
  5800B   4798  
  
  6700  
  4767  
  
   
  4677  
 5800K   5700  
  4251  
  
  4657M   3449  
  
  5750M   3332  
  
   
  3253  
 5757M   4600M   3145  
  
  5745M   2758  
  
  4655M   2505  
  
   
  3817.90 ( 11 Family CPUs) Ave... 
 AMD  
 A4  
 Family   Model Benchmark Score (High to Low) 
 ======   ====== 
 ============================= A4  
  
  6300  
  2305  
  
 5300  
  
 2078  
  
  5150M   1973  
  
   
  1919 5000  
  
  3420  
  1768  
  
  4300M   1685  
  
  5300B   1632  
  
   
  1625 3400  
  
  3300  
  1583  
  
  3330MX   1343 
 3 June 2014 
 Chapter 7 - Report Writer Usage Notes",NA
7.7. Control Hierarchy (Revisited),"The sample program just discussed presents a great opportunity to show what can happen 
 if you don’t define the control hierarchy of a report properly. 
 3 June 2014 
 Chapter 7 - Report Writer Usage Notes",NA
7.8. Turning PHYSICAL Page Formatting Into LOGICAL ,NA,NA
Formatting,"You can trick RWCS into using the PAGE LIMIT values as logical specifications rather than 
 physical ones quite easily — simply include an ASCII form-feed (X’0C’) character into your 
 page heading design! Here’s how the sample program shown earlier could be easily 
 modified: 
 Simply Change This. . . 
 01 TYPE IS PAGE HEADING. 
 05 LINE NUMBER 1. 
 10 COL 1 SOURCE WS-Date PIC 9999/99/99.  
 10 COL 14 VALUE ’CPU Benchmark Scores’.  
 10 COL 37 VALUE ’Page:’. 
  
 10 COL 43 SOURCE PAGE-COUNTER PIC Z9.  
 05 LINE NUMBER PLUS 1. 
  
 10 COL 1  
 SOURCE WS-Starz PIC X(44).  
 05 LINE NUMBER PLUS 1. 
 10 COL 1 VALUE ’**’. 
 10 COL 6 VALUE ’All CPU Data From ’ & 
  
  
 ’cpubenchmark.net’. 
 10 COL 43 VALUE ’**’. 
 05 LINE NUMBER PLUS 1. 
 10 COL 1 SOURCE WS-Starz PIC X(44). 
 To This. . . 
 01 TYPE IS PAGE HEADING. 
 05 LINE NUMBER 1. 
  
  
 *
 >
  NEW 
  
  
 10 COL 1 VALUE X’0C’. *
 >
  NEW 
  
 05 LINE NUMBER PLUS 1. 
  
  
 *
 >
  CHANGED 
  10 COL 1 SOURCE WS-Date PIC 9999/99/99. 
 10 COL 14 VALUE ’CPU Benchmark Scores’. 
 10 COL 37 VALUE ’Page:’. 
 10 COL 43 SOURCE PAGE-COUNTER PIC Z9. 
 05 LINE NUMBER PLUS 1. 
 10 COL 1 SOURCE WS-Starz PIC X(44). 
 05 LINE NUMBER PLUS 1. 
 10 COL 1 VALUE ’**’. 
 10 COL 6 VALUE ’All CPU Data From ’ & 
  
  
 ’cpubenchmark.net’. 
 10 COL 43 VALUE ’**’. 
 05 LINE NUMBER PLUS 1. 
 10 COL 1 SOURCE WS-Starz PIC X(44). 
 RWCS will still be counting lines to decide when to close off one page and start a new one, but 
 when a new page is started it’s page heading will
  physically
  form-feed the printer 
 Chapter 7 - Report Writer Usage Notes 
 3 June 2014",NA
8. Interfacing With The OS,NA,NA
8.1. Compiling Programs,"Program source files should have extensions of "".cob"" or "".cbl"". 
 Program filenames should match exactly the specification of PROGRAM-ID (including case). 
 Spaces cannot be included in primary entry-point names and therefore should not be in-
 cluded in program filenames. 
 The GNU COBOL compiler will translate your COBOL program into C source code, com-pile 
 that C source code into executable binary form using the ""C"" compiler specified when GNU 
 COBOL was built and link that executable binary into: 
 Directly executable form 
 This is an executable file directly-executable from the command-line. On Win-
 dows computers, this would be an "".exe"" file. On Unix systems, this will be a file 
 with no specific extension, but with execute permissions. This file will include 
 the main program as well as any static-linked subprograms. 
 Static-linkable form 
 This is a single subprogram compiled into object-code form, ready to be linked 
 in with a main program to form a directly-executable program. On windows 
 computers, these generally are "".o"" (object-code) files. 
 Dynamically-loadable executable form 
 These are dynamically-loadable object code files ready to be invoked from 
 other programs at execution time. On Windows systems, these would be "".dll"" 
 files, while on Unix systems they are typically "".so"" files (OSX uses "".dylib"").",NA
8.1.1. cobc - The GNU COBOL Compiler,"The GNU COBOL compiler is named ""cobc"" (""cobc.exe"" on a Windows system). 
 The following describes the syntax and option switches of the cobc command. This infor-
 mation may be displayed by entering the command ""cobc –help"". 
 Usage: cobc [options] file ... 
 Options: 
  
 -help  
 Display this message 
  
 -version, -V  
 Display compiler version 
  
 -info, -i  
 Display compiler build information 
  
 -v  
 Display the commands invoked by the compiler 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.1.2. Compilation Time Environment Variables,"The following are the various environment variables that can play a role in the compilation 
 of GNU COBOL programs. 
 ""COB_CC"" * 
 Set to the name of the C compiler you wish GNU COBOL to use. 
 USE THIS FEATURE AT YOUR OWN RISK – YOU SHOULD ALWAYS USE THE C 
 COMPILER YOUR GNU COBOL BUILD WAS GENERATED FOR 
 ""COB_CFLAGS"" * 
 Set to any switches that you’d like to pass on to the C compiler from the ""cobc"" 
 compiler (in addition to any that ""cobc"" will specify). 
 ""COB_CONFIG_DIR"" * 
 Set to the path to the folder where GNU COBOL ""config"" files are kept. 
 ""COB_COPY_DIR"" * 
 If copybooks your program needs are NOT stored in the same directory as your 
 program, set this environment variable to the folder in which the copybooks 
 may be found (IBM mainframe programmers will recognize this as ""SYSLIB""). 
 ""COB_LDADD"" 
 Set to any additional linker switches (ld) that can specify where standard li-
 braries that must be linked with the program can be found. The default is """" 
 (null). 
 ""COB_LDFLAGS"" 
 Set to any linker/loader (ld) switches that you’d like to pass on to the C compiler 
 from the ""cobc"" compiler (in addition to any that cobc will specify). 
 ""COB_LIBS"" * 
 Set to any linker switches (ld) that specify where standard libraries that must be 
 linked with the program can be found. 
 ""COBCPY"" 
 This environment variable provides an additional means of specifying where 
 copybooks may be found by the compiler (see also COB COPY DIR, above). 
 ""LD_LIBRARY_PATH"" 
 If you are planning on using static-linked subroutine libraries, set this variable 
 to the path of the directory containing your libraries. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.1.3. Locating Copybooks,"The GNU COBOL compiler will attempt to locate copybooks by searching for them in the 
 following folders. The search will occur in the sequence shown below, and will terminate 
 once a copybook is found. 
 1. The folder named as the <
 library-name-1
 > on the ""COPY"" statement (see
  [COPY], page 
 40
 ). 
 2. The folder in which the program being compiled resides. 
 3. The folder named on the ""-I"" switch. 
 4. Each of the folders named on the ""COBCPY"" compilation-time environment variable (see 
 [Compilation Time Environment Variables], page 514
 ). 
 A single folder may be named or multiple folders may be specified, separated by a 
 system-appropriate delimiter character. When multiple folders are specified, they will 
 be searched in the order they are named on the environment variable. 
 If the GNU COBOL compiler you are using was built to utilize a native Windows 
 environment, use a semicolon (;) as the delimiter character. 
 If, however, the GNU COBOL compiler was built for a Unix, OSX or Linux environ-ment, 
 or was built for a Windows environment utilizing either the Cygwin or MinGW Unix 
 emulators, use a colon character (:) as the delimiter. 
 5. The
  single
  folder specified on the COB COPY DIR environment variable. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.1.4. Compiler Configuration Files,"GNU COBOL uses compiler configuration files to define various options that will control the 
 compilation process. These configuration files are specified using the ""-conf"" switch compi-
 lation switch and are found in the folder defined by the ""COB_CONFIG_DIR"" compilation-
 time environment variable (see
  [Compilation Time Environment Variables], page 514
 ). 
 The following is a verbatim listing of the ""default"" configuration file (the one used if you don’t 
 specify the ""-conf"" switch), just to show you the types of settings that may appear: 
 # COBOL compiler configuration 
 -*- sh -*-# 
 Value: any string  
 name: ""GNU COBOL"" 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.2. Running Programs,"Once GNU COBOL programs have been compiled into either directly-executable programs 
 (created via the ""-x"" switch) or dynamically-loadable libraries (created via the ""-m"" switch), 
 those programs may be executed from any shell environment. The exact manner in which 
 the two are executed will differ, as described in the upcoming sections.",NA
8.2.1. Direct Execution,"GNU COBOL programs compiled with the ""-x"" switch will be generated as directly- 
 executable programs. For example, a native Windows or Windows/MinGW build of GNU 
 COBOL will generate an "".exe"" file when the ""-x"" switch switch is specified to the compiler. 
 On Unix, OSX, or Windows/Cygwin builds, the ""-x"" switch switch will generate an exe- 
 cutable binary file, usually with no particular extension unless one is explicitly requested 
 of the compiler via the ""-o"" switch. 
 On a UNIX system this means the programs may be executed from a command shell such 
 as bash, csh, ksh and so forth. When a GNU COBOL program runs on a Windows system, 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.2.2. Executing Dynamically-Loadable Libraries,"As discussed previously, dynamically-loadable libraries are created via the compiler’s ""-m"" 
 switch. Once so created, the program(s) in these libraries are executed from the command 
 line (via the GNU COBOL ""cobcrun"" utility), or as dynamically-loadable subprograms.",NA
8.2.2.1. cobcrun - Command-line Execution,"It is possible to generate executable modules for all GNU COBOL programs, not just 
 subprograms, by choosing to use the ""-m"" switch option to specify the loader output format, 
 even for main programs. 
 Some may prefer to compile their GNU COBOL main programs into these dynamically-
 loadable modules in the interests of using the same general compilation command for all 
 programs without having to think ""Is it a main program or a subprogram?"". 
 Main programs compiled in this manner should be executed as follows: 
 ""[
 path
 ]cobcrun
  program
  [
 arguments
 ]"" 
 Do not specify the "".so"" or "".dll"" extension on the program name. The
  program
  value must 
 exactly match the primary entry-point name of the main program (including upper-and 
 lower-case letters), unless you are planning on using ""Call Folding"" (see
  [Dynamically 
 Loaded Subprograms], page 521
 ). 
 The general usage and syntax of cobcrun is as follows: 
 Usage: cobcrun PROGRAM [param ...]  
 or : cobcrun --help (-h)  
  
 Print this help  
 or : cobcrun --version (-V)  
  
 Print version information 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.2.2.2. Dynamically Loaded Subprograms,"Dynamically-loaded subprograms are executed (from a COBOL syntax point of view) just 
 like any other subprograms. What makes them unique, however, is that they are loaded into 
 memory only when they are actually used the first time during the execution of a program. 
 When a dynamically-loadable module needs to be loaded (because it is not already in 
 memory from a previous subprogram execution), the dynamically-loadable library will be 
 sought in the same directory from which the main program was loaded. If it cannot be found 
 there, each directory named in the ""PATH"" run-time environment variable (see
  [Run Time 
 Environment Variables], page 522
 ) will be searched. If it was not located in any of those 
 directories, the library specified by the ""COB_LIBRARY_PATH"" run-time environment 
 variable will be searched. Finally, if it
  still
  cannot be located, execution will be terminated 
 with an error message (""libcob: Cannot find module ’xxxxxxxx’""). 
 The process of locating dynamically-loadable modules is case-sensitive on UNIX systems; 
 ""CALL ""dynsub"""" and ""CALL ""DYNSUB"""" will both fail to locate the ""DynSub.so"" library on a 
 UNIX system. 
 Windows implementations of GNU COBOL may, or may not, be similarly case sensitive with 
 regard to library names, depending upon the Windows version and GNU COBOL build 
 options — it is safest to simply treat library names as case-sensitive in all environments. 
 It is possible, however, to automatically cause all library names to ’fold’ to uppercase by 
 specifying the ""-ffold-call"" switch with the ""upper"" option (i.e. ""--fold-call=upper"") to the 
 GNU COBOL compiler. Similarly, library names could be folded to lowercase by using the 
 ""lower"" option (i.e. ""--fold-call=lower"". If libraries are maintained entirely using upper- or 
 lower-case filenames, either of these options will allow libraries to be found regardless of 
 how the programmer entered their names on ""CALL"" statements. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.2.3. Run Time Environment Variables,"The following is a list of the various environment variables that can play a role in the 
 execution of GNU COBOL programs. 
 ""COB_DISPLAY_WARNINGS"" 
 If set to a value of ""Y"", any run-time warnings (such as noting the implicit 
 closing of open files when a ""GOBACK"" statement (see
  [GOBACK], page 393
 ) or 
 ""STOP"" statement (see
  [STOP], page 461
 ) with the ""RUN"" option is executed) 
 will be displayed. Any other value for this environment variable (including not 
 setting the variable at all) will suppress such messages. 
 ""COB_LIBRARY_PATH"" 
 At runtime, GNU COBOL will attempt to locate and load any application 
 dynamically-loadable libraries using from the directory in which the program 
 executable was found or, if it wasn’t found there, using the ""PATH"" 
 environment variable. If these library files could be somewhere else, specify the 
 directory path using this variable. 
 ""COB_LOAD_CASE"" 
 If set to either ""UPPER"" or ""LOWER"", this environment variable will internally 
 convert referenced entry-point names to either upper- or lower-case before ini-
 tiating searches for dynamically-loadable modules. The ""UPPER"" and ""LOWER"" 
 values of the environment variable are actually case-insensitive. 
 ""COB_PHYSICAL_CANCEL"" 
 If set to ""Y"", ""y"" or ""1"", a ""CANCEL"" statement (see
  [CANCEL], page 363
 ) will 
 physically unload a subprogram dynamically-loadable module. 
 If set to anything else, a ""CANCEL"" statement (see
  [CANCEL], page 363
 ) log-
 ically unloads a module so that subsequent use will re-initialize the module as if 
 it had actually been reloaded, but the overhead of actually reloading the module 
 will be avoided. 
 ""COB_PRE_LOAD"" 
 If set to any non-null value, this variable will cause all dynamically-loadable 
 libraries to be loaded when the program begins execution (rather than 
 searching for and loading the module upon first use). 
 ""COB_SET_DEBUG"" 
 If a ""USE FOR DEBUGGING"" (see
  [DECLARATIVES], page 208
 ) section exists, the 
 code within it will be disabled unless this environment variable is set to a value 
 of ""Y"", ""y"" or ""1"". 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.2.4. Program Arguments,"Regardless of the manner in which a main program is executed (i.e.  
 directly or via 
 ""cobcrun""), any arguments specified to the program may be retrieved via any of the fol-
 lowing: 
 •
  ""ACCEPT FROM COMMAND-LINE"" (see
  [ACCEPT FROM COMMAND-LINE], page 339
 ) 
 •
  ""PROCEDURE DIVISION CHAINING"" 
 page 204
 ) 
 (see 
 [PROCEDURE
  
 DIVISION
  
 CHAINING],
  
 Chapter 8 - Interfacing With The OS 
 3 June 2014",NA
8.3. Built-In System Subroutines,"There are a number of built-in system subroutines included with GNU COBOL. Generally, 
 these routines are intended to match those available in Micro Focus COBOL (CBL . . .) or 
 ACUCOBOL (C$. . .). 
 These routines, all executed via their UPPERCASE NAMES via the ""CALL"" statement (see 
 [CALL], page 359
 ), are capable of performing the following Functions: 
 •
  Changing the current directory 
 •
  Copying files 
 •
  Creating a directory 
 •
  Creating, Opening, Closing, Reading and Writing byte-stream files 
 •
  Deleting directories (folders) 
 •
  Deleting files 
 •
  Determining how many arguments were passed to a subroutine 
 •
  Getting file information (size and last-modification date/time) 
 •
  Getting the length (in bytes) of an argument passed to a subroutine 
 •
  Justifying a field left-, right- or center-aligned 
 •
  Moving files (a destructive ""copy"") 
 •
  Putting the program ’to sleep’, specifying the sleep time in seconds 
 •
  Putting the program ’to sleep’, specifying the sleep time in nanoseconds; CAVEAT: 
 although you’ll express the time in nanoseconds, Windows systems will only be able to 
 sleep at a millisecond granularity 
 •
  Retrieving information about the currently-executing program 
 •
  Submitting a command to the shell environment appropriate for the version of GNU 
 COBOL you are using for execution 
 Early versions of Micro Focus COBOL allowed programmers to access various runtime 
 library routines by using a single two-digit hexadecimal number as the entry-point name. 
 These were known as call-by-number routines. Over time, Micro Focus COBOL evolved, 
 replacing most of the call-by-number routines with ones accessible using a more conventional 
 call-by-name technique. 
 Most of the call-by-number routines have evolved into even more powerful call-by-name 
 routines, many of which are supported by GNU COBOL. 
 Some of the original call-by-number routines never evolved call-by-name equivalents; GNU 
 COBOL supports some of these routines.",NA
8.3.1. C$CALLEDBY,"C$CALLEDBY Built-In Subroutine Syntax
  
 CALL ""C$CALLEDBY"" USING prog-name-area  
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine returns the name of the program that called the currently-executing program. 
 The program name will be returned, left-justified and space filled, in the specified <
 prog-
 name-area
 > argument, which should be a ""PIC X"" elementary item or a group item. If <
 prog-
 name-area
 > is too small to receive the entire program name, the program name value will 
 be truncated (on the right) to fit. 
 The ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) will be set to one of 
 the following values: 
 -1 An error occurred. The <
 prog-name-area
 > contents will be unchanged. 
 0 The program calling ""C$CALLEDBY"" was not called by any other program (in other words, 
 it is a main program). The <
 prog-name-area
 > contents will be set entirely to spaces. 
 1 The program calling ""C$CALLEDBY"" was indeed called by another program, and that 
 program’s name has been saved in <
 prog-name-area
 >.",NA
8.3.2. C$CHDIR,"C$CHDIR Built-In Subroutine Syntax
  
 CALL ""C$CHDIR"" USING directory-path, result ~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine makes <
 directory-path
 > (an alphanumeric literal or identifier) the current di-
 rectory. 
 The return code of the operation is returned both in the <
 result
 > argument (any non-edited 
 numeric identifier) as well as in the ""RETURN-CODE"" special register (see
  [Special 
 Registers], page 243
 ). The return code of the operation will be either 0=Success or 
 128=failure. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.3. C$COPY,"C$COPY Built-In Subroutine Syntax
  
 CALL ""C$COPY"" USING src-file-path, dest-file-path, 0 ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 Use this subroutine to copy file <
 src-file-path
 > to <
 dest-file-path
 > as if it were done via the 
 ""CP"" (Unix/OSX) or ""COPY"" (Windows) command. 
 Both file path arguments may be alphanumeric literals or identifiers. 
 The third argument is required, but is unused. 
 If the attempt to copy the file fails (for example, it or the destination directory doesn’t exist), 
 the ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) will be set to 128; 
 on successful completion it will be set to 0.",NA
8.3.4. C$DELETE,"C$DELETE Built-In Subroutine Syntax
  
 CALL ""C$DELETE"" USING file-path, 0  
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine deletes the file specified by the <
 file-path
 > argument (an alphanumeric literal 
 or identifier) just as if that were done using the ""RM"" (Unix/OSX) or ""ERASE"" (Windows) 
 command. 
 The second argument is required, but is unused. 
 If the attempt to delete the file fails (for example, it doesn’t exist), the ""RETURN-CODE"" 
 special register (see
  [Special Registers], page 243
 ) will be set to 128; on successful 
 completion it will be set to 0.",NA
8.3.5. C$FILEINFO,"3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.6. C$GETPID,"C$GETPID Built-In Subroutine Syntax
  
 CALL ""C$GETPID""  
 ~~~~ 
 ———————————————————————————————————————— 
 Use this subroutine to return the PID (process ID) of the executing GNU COBOL program. 
 The PID value is returned into the ""RETURN-CODE"" special register (see
  [Special Registers], 
 page 243
 ). 
 As you can see, there are no arguments to this routine.",NA
8.3.7. C$JUSTIFY,"C$JUSTIFY Built-In Subroutine Syntax
  
 CALL ""C$JUSTIFY"" USING data-item, ""justification-type"" ~~~~ 
 ~~~~~ 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.8. C$MAKEDIR,"C$MAKEDIR Built-In Subroutine Syntax
  
 CALL ""C$MAKEDIR"" USING dir-path  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 With this routine you may create a new directory — the name of which is supplied as the 
 <
 dir-path
 > argument (an alphanumeric literal or identifier). 
 Only the lowest-level directory (last) in the specified path can be created — all others must 
 already exist. This subroutine will NOT behave as a ""mkdir -p"" (Unix) or ""mkdir /p"" 
 (Windows). 
 The ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) will be set to the 
 return code of the operation; the value will be either 0=Success or 128=failure.",NA
8.3.9. C$NARG,"C$NARG Built-In Subroutine Syntax
  
 CALL ""C$NARG"" USING arg-count-result  
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine returns the number of arguments passed to the program that calls it back to 
 in the numeric field <
 arg-count-result
 >. When called from within a user-defined function, a 
 value of one (1) is returned if any arguments were passed to the function or a zero (0) 
 otherwise. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.10. C$PARAMSIZE,"C$PARAMSIZE Built-In Subroutine Syntax
  
 CALL ""C$PARAMSIZE"" USING argument-number  
 ~~~~  
 ~~~~~ 
 ————————————————————————————————————————
 This subroutine returns the size (in bytes) of the subroutine argument supplied using the 
 <
 argument-number
 > parameter (a numeric literal or data item). 
 The size is returned in the ""RETURN-CODE"" special register (see
  [Special Registers], page 
 243
 ). If the specified argument does not exist, or an invalid argument number is specified, a 
 value of 0 is returned.",NA
8.3.11. C$PRINTABLE,"C$PRINTABLE Built-In Subroutine Syntax
  
 CALL ""C$PRINTABLE"" USING data-item [ , char ] ~~~~ 
  
 ~~~~~ 
 ————————————————————————————————————————
 The ""C$PRINTABLE"" subroutine converts the contents of the data-item specified as the first 
 argument to printable characters. Those characters that are deemed printable (as defined by 
 the characterset used by <
 data-item
 >) will remain unchanged, while those that are NOT 
 printable will be converted to the character specified as the second argument. 
 If no <
 char
 > argument is provided, a period (""."") will be used.",NA
8.3.12. C$SLEEP,"C$SLEEP Built-In Subroutine Syntax
  
 CALL ""C$SLEEP"" USING seconds-to-sleep  
 ~~~~ ~~~~~ 
 ————————————————————————————————————————
 ""C$SLEEP"" puts the program to sleep for the specified number of seconds. The <
 seconds-to-
 sleep
 > argument may be a numeric literal or data item. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.13. C$TOLOWER,"C$TOLOWER Built-In Subroutine Syntax
  
 CALL ""C$TOLOWER"" USING data-item, BY VALUE convert-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine will converts the <
 convert-length
 > (a numeric literal or data item) leading 
 characters of <
 data-item
 > (an alphanumeric identifier) to lower-case. 
 The <
 convert-length
 > argument must be specified ""BY VALUE"" (see
  [CALL], page 359
 ). Any 
 characters in <
 data-item
 > after the <
 convert-length
 > point will remain unchanged. 
 If <
 convert-length
 > is negative or zero, no conversion will be performed.",NA
8.3.14. C$TOUPPER,"C$TOUPPER Built-In Subroutine Syntax
  
 CALL ""C$TOUPPER"" USING data-item, BY VALUE convert-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine will converts the <
 convert-length
 > (a numeric literal or data item) leading 
 characters of <
 data-item
 > (an alphanumeric identifier) to upper-case. 
 The <
 convert-length
 > argument must be specified ""BY VALUE"" (see
  [CALL], page 359
 ). Any 
 characters in <
 data-item
 > after the <
 convert-length
 > point will remain unchanged. 
 If <
 convert-length
 > is negative or zero, no conversion will be performed.",NA
8.3.15. CBL AND,"CBL AND Built-In Subroutine Syntax
  
 CALL ""CBL_AND"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.16. CBL CHANGE DIR,"CBL CHANGE DIR Built-In Subroutine Syntax
  
 CALL ""CBL_CHANGE_DIR"" USING directory-path 
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 This routine makes <
 directory-path
 > (an alphanumeric literal or identifier) the current di-
 rectory. 
 The return code of the operation, which will be either 0=Success or 128=failure, is returned 
 in the ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ). 
 The directory change remains in effect until the program terminates (in which the original 
 current directory at the time the program was started will be automatically restored) or 
 until another ""CBL_CHANGE_DIR"" or a ""C$CHDIR"" built-in system subroutine (see
  
 [C$CHDIR], page 526
 ) is executed.",NA
8.3.17. CBL CHECK FILE EXIST,"CBL CHECK FILE EXIST Built-In Subroutine Syntax
  
 CALL ""CBL_CHECK_FILE_EXIST"" USING file-path, file-info ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.18. CBL CLOSE FILE,"CBL CLOSE FILE Built-In Subroutine Syntax
  
 CALL ""CBL_CLOSE_FILE"" USING file-handle  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 The ""CBL_CLOSE_FILE"" subroutine closes a bytestream file previously opened by either the 
 ""CBL_OPEN_FILE"" built-in system subroutine (see
  [CBL OPEN FILE], page 545
 ) or 
 ""CBL_CREATE_FILE"" built-in system subroutine (see
  [CBL CREATE FILE], page 534
 ) sub-
 routines. 
 If the file defined by the <
 file-handle
 > argument (a ""PIC X(4) USAGE COMP-X"" data item) 
 was opened for output, an implicit ""CBL_FLUSH_FILE"" built-in system subroutine (see 
 [CBL 
 FLUSH FILE], page 540
 ) will be performed before the file is closed. 
 If the subroutine is successful, a value of 0 will be returned in the ""RETURN-CODE"" special 
 register (see
  [Special Registers], page 243
 ). 
 register value of -1 to be passed back.",NA
8.3.19. CBL COPY FILE,"Failure will cause a ""RETURN-CODE"" special 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.20. CBL CREATE DIR,"CBL CREATE DIR Built-In Subroutine Syntax
  
 CALL ""CBL_CREATE_DIR"" USING dir-path  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 With this routine you may create a new directory — the name of which is supplied as the 
 <
 dir-path
 > argument (an alphanumeric literal or identifier). 
 Only the lowest-level directory (last) in the specified path can be created — all others must 
 already exist. This subroutine will NOT behave as a ""mkdir -p"" (Unix) or ""mkdir /p"" 
 (Windows). 
 The ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) will be set to the 
 return code of the operation; the value will be either 0=Success or 128=failure.",NA
8.3.21. CBL CREATE FILE,"CBL CREATE FILE Built-In Subroutine Syntax
  
 CALL ""CBL_CREATE_FILE"" USING file-path, 2, 0, 0, file-handle ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 The ""CBL_CREATE_FILE"" subroutine creates the new file specified using the file-path argu-
 ment and opens it for output as a byte-stream file usable by ""CBL_WRITE_FILE"" built-in 
 system subroutine (see
  [CBL WRITE FILE], page 548
 ). 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.22. CBL DELETE DIR,"CBL DELETE DIR Built-In Subroutine Syntax
  
 CALL ""CBL_DELETE_DIR"" USING dir-path  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine deletes an empty directory. 
 The only argument — <
 dir-path
 > (an alphanumeric literal or identifier) — is the name of the 
 directory to be deleted. 
 Only the lowest-level directory (last) in the specified path will be deleted, and that directory 
 must be empty to be deleted. 
 The ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) will be set to the 
 return code of the operation; the value will be either 0=Success or 128=failure.",NA
8.3.23. CBL DELETE FILE,"CBL DELETE FILE Built-In Subroutine Syntax
  
 CALL ""CBL_DELETE_FILE"" USING file-path  
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine deletes the file specified by the <
 file-path
 > argument (an alphanumeric literal 
 or identifier) just as if that were done using the ""RM"" (Unix/OSX) or ""ERASE"" (Windows) 
 command. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.24. CBL EQ,"CBL EQ Built-In Subroutine Syntax
  
 CALL ""CBL_EQ"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 Old 
 Old 
 New 
 This subroutine performs a bit-by-bit comparison between the 
 Arg 1 
 Arg 2 
 Arg 2 
 left-most 8*<
 byte-length
 > corresponding bits of <
 item-1
 > and 
 Bit 
 Bit 
 Bit 
 <
 item-2
 >, storing the resulting bit string into <
 item-2
 >. The 
 ===== ===== ===== 
 truth table shown to the left documents the EQ process. 
 0 
 0 
 1 
 The <
 item-1
 > argument may be an alphanumeric literal or a 
 0 
 1 
 0 
 1 
 0 
 0 
 data item and <
 item-2
 > must be a data item. The length of 
 1 
 1 
 1 
 both <
 item-1
 > and <
 item-2
 > must be at least 8*<
 byte-length
 >. 
 The <
 byte-length
 > argument may be a numeric literal or data item, and must be specified 
 using ""BY VALUE"" (see
  [CALL], page 359
 ). 
 Any bits in <
 item-2
 > after the 8*<
 byte-length
 > point will be unaffected. 
 A result of zero will be passed back in the ""RETURN-CODE"" special register (see
  [Special 
 Registers], page 243
 ).",NA
8.3.25. CBL ERROR PROC,"CBL ERROR PROC Built-In Subroutine Syntax
  
 CALL ""CBL_ERROR_PROC"" USING function, program-pointer 
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 This routine registers a general error-handling routine. 
 The <
 function
 > argument must be a numeric literal or a 32-bit binary data item (""USAGE 
 BINARY-LONG"", for example) with a value of 0 or 1. A value of 0 means that you will be 
 registering (""installing"") an error procedure while a value of 1 indicates you’re 
 deregistering (""uninstalling"") a previously-installed error procedure. 
 The <
 program-pointer
 > must be a data item with a ""USAGE"" (see
  [USAGE], page 186
 ) of 
 ""PROGRAM-POINTER"" containing the address of your error procedure. This item should be 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.26. CBL EXIT PROC,"CBL EXIT PROC Built-In Subroutine Syntax
  
 CALL ""CBL_EXIT_PROC"" USING function, program-pointer 
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine registers a general exit-handling routine. 
 The <
 function
 > argument must be a numeric literal or a 32-bit binary data item (""USAGE 
 BINARY-LONG"", for example) with a value of 0 or 1. A value of 0 means that you will be 
 registering (""installing"") an exit procedure while a value of 1 indicates you’re deregistering 
 (""uninstalling"") a previously-installed exit procedure. 
 The <
 program-pointer
 > must be a data item with a ""USAGE"" (see
  [USAGE], page 186
 ) of 
 ""PROGRAM-POINTER"" containing the address of your exit procedure. 
 A success (0) or failure (non-0) result will be passed back in the ""RETURN-CODE"" special 
 register (see
  [Special Registers], page 243
 ). 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.27. CBL FLUSH FILE,"CBL FLUSH FILE Built-In Subroutine Syntax
  
 CALL ""CBL_FLUSH_FILE"" USING file-handle  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 In Micro Focus COBOL, calling this subroutine flushes any as-yet unwritten memory buffers 
 for the (output) file whose file-handle is specified as the argument to disk. 
 This routine is non-functional in GNU COBOL. It exists only to provide compatibility for 
 applications that may have been developed for Micro Focus COBOL.",NA
8.3.28. CBL GET CSR POS,"CBL GET CSR POS Built-In Subroutine Syntax
  
 CALL ""CBL_GET_CSR_POS"" USING cursor-locn-buffer 
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine will retrieve the current cursor location on the screen, returning a 2-byte 
 value into the supplied <
 cursor-locn-buffer
 >.  
 The first byte of <
 cursor-locn-buffer
 > will 
 receive the current line (row) location while the second receives the current column 
 location. 
 The returned location data will be in binary form, and will be based upon starting values of 
 0, meaning that if the cursor is located at line 15, column 12 at the time this routine is called, 
 a value of (14,11) will be returned. 
 The following is a typical <
 cursor-locn-buffer
 > definition: 
 01 CURSOR-LOCN-BUFFER. 
 05 CURSOR-LINE  
 05 CURSOR-
 COLUMN 
 USAGE BINARY-CHAR.  
 USAGE BINARY-CHAR. 
 Values of 1 (Line) and 1 (column) will be returned if GNU COBOL was not generated to 
 include screen I/O. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.29. CBL GET CURRENT DIR,"CBL GET CURRENT DIR Built-In Subroutine Syntax
  
 CALL ""CBL_GET_CURRENT_DIR"" USING BY VALUE 0, 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 BY VALUE length,  
 ~~~~~  
 BY REFERENCE buffer  
 ~~~~~~~~~ 
 ———————————————————————————————————————— 
 This retrieves the fully-qualified pathname of the current directory, saving up to <
 length
 > 
 characters of that name into the specified <
 buffer
 >. 
 The first argument is unused, but must be specified. It must be specified ""BY VALUE"" (see 
 [CALL], page 359
 ). 
 The <
 length
 > argument must be specified ""BY VALUE"". The <
 buffer
 > argument must be 
 specified ""BY REFERENCE"". 
 The value specified for the <
 length
 > argument (a numeric literal or data item) should not 
 exceed the actual length of the <
 buffer
 > argument. 
 If the value specified for the <
 length
 > argument is LESS THAN the actual length of the 
 <
 buffer
 > argument, the current directory path will be left-justified and space filled within 
 the first <
 length
 > bytes of <
 buffer
 > — any bytes in <
 buffer
 > after that point will be 
 unchanged. 
 If the routine is successful, a value of 0 will be returned to the ""RETURN-CODE"" special 
 register (see
  [Special Registers], page 243
 ). If the routine failed because of a problem with 
 an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st 
 argument value is anything but zero, the routine will fail with a 129 value.",NA
8.3.30. CBL GET SCR SIZE,"CBL GET SCR SIZE Built-In Subroutine Syntax
  
 CALL ""CBL_GET_SCR_SIZE"" USING no-of-lines, no-of-cols ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 Use this subroutine to retrieve the current console screen size. 
 When the system is running in a windowed environment, this will be the sizing of the console 
 window in which the program is executing. When the system is not running a windowing 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.31. CBL IMP,"CBL IMP Built-In Subroutine Syntax
  
 CALL ""CBL_IMP"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 Old 
 Old 
 New 
 This subroutine performs a bit-by-bit logical ""implies"" pro- 
 Arg 1 
 Arg 2 
 Arg 2 
 cess between the left-most 8*<
 byte-length
 > corresponding bits 
 Bit 
 Bit 
 Bit 
 of <
 item-1
 > and <
 item-2
 >, storing the resulting bit string into 
 ===== ===== ===== 
 <
 item-2
 >. The truth table shown to the left documents the 
 0 
 0 
 1 
 IMP process. 
 0 
 1 
 1 
 The <
 item-1
 > argument may be an alphanumeric literal or a 
 1 
 0 
 0 
 1 
 1 
 1 
 data item and <
 item-2
 > must be a data item. The length of 
 both <
 item-1
 > and <
 item-2
 > must be at least 8*<
 byte-length
 >. 
 The <
 byte-length
 > argument may be a numeric literal or data item, and must be specified 
 using ""BY VALUE"" (see
  [CALL], page 359
 ). 
 Any bits in <
 item-2
 > after the 8*<
 byte-length
 > point will be unaffected. 
 A result of zero will be passed back in the ""RETURN-CODE"" special register (see
  [Special 
 Registers], page 243
 ). 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.32. CBL NIMP,"CBL NIMP Built-In Subroutine Syntax
  
 CALL ""CBL_NIMP"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 Old 
 Old 
 New 
 This subroutine performs the negation of a bit-by-bit logi- 
 Arg 1 
 Arg 2 
 Arg 2 
 cal ""implies"" process between the left-most 8*<
 byte-length
 > 
 Bit 
 Bit 
 Bit 
 corresponding bits of <
 item-1
 > and <
 item-2
 >, storing the re- 
 ===== ===== ===== 
 sulting bit string into <
 item-2
 >. The truth table shown to the 
 0 
 0 
 0 
 left documents the NIMP process. 
 0 
 1 
 0 
 The <
 item-1
 > argument may be an alphanumeric literal or a 
 1 
 0 
 1 
 1 
 1 
 0 
 data item and <
 item-2
 > must be a data item. The length of 
 both <
 item-1
 > and <
 item-2
 > must be at least 8*<
 byte-length
 >. 
 The <
 byte-length
 > argument may be a numeric literal or data item, and must be specified 
 using ""BY VALUE"" (see
  [CALL], page 359
 ). 
 Any bits in <
 item-2
 > after the 8*<
 byte-length
 > point will be unaffected. 
 A result of zero will be passed back in the ""RETURN-CODE"" special register (see
  [Special
  
 Registers], page 243
 ).",NA
8.3.33. CBL NOR,"CBL NOR Built-In Subroutine Syntax
  
 CALL ""CBL_NOR"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 Old 
 Old 
 New 
 This subroutine performs the negation of a bit-by-bit logi- 
 Arg 1 
 Arg 2 
 Arg 2 
 cal ""or"" process between the left-most 8*<
 byte-length
 > corre- 
 Bit 
 Bit 
 Bit 
 sponding bits of <
 item-1
 > and <
 item-2
 >, storing the resulting 
 ===== ===== ===== 
 bit string into <
 item-2
 >. The truth table shown to the left 
 0 
 0 
 1 
 documents the NOR process. 
 0 
 1 
 0 
 The <
 item-1
 > argument may be an alphanumeric literal or a 
 1 
 0 
 0 
 1 
 1 
 0 
 data item and <
 item-2
 > must be a data item. The length of 
 both <
 item-1
 > and <
 item-2
 > must be at least 8*<
 byte-length
 >. 
 The <
 byte-length
 > argument may be a numeric literal or data item, and must be specified 
 using ""BY VALUE"" (see
  [CALL], page 359
 ). 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.34. CBL NOT,"CBL NOT Built-In Subroutine Syntax
  
 CALL ""CBL_NOT"" USING item-1, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine ""flips"" the left-most 8*<
 byte-length
 > bits of <
 item-1
 >, changing 0 bits to 1s 
 and 1s to 0s. The changes are made directly im <
 item-1
 >. 
 The <
 item-1
 > argument must be a data item. The length of <
 item-1
 > must be at least 8*<
 byte-
 length
 >. 
 The <
 byte-length
 > argument may be a numeric literal or data item, and must be passed using 
 ""BY VALUE"" (see
  [CALL], page 359
 ). 
 Any bits in <
 item-1
 > after the 8*<
 byte-length
 > point will be unaffected. 
 A result of zero will be passed back in the ""RETURN-CODE"" special register (see
  [Special 
 Registers], page 243
 ).",NA
8.3.35. CBL OC NANOSLEEP,"CBL OC NANOSLEEP Built-In Subroutine Syntax
  
 CALL ""CBL_OC_NANOSLEEP"" USING nanoseconds-to-sleep 
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine puts the program to sleep for the specified number of nanoseconds. The 
 effective granularity of <
 nanoseconds-to-sleep
 > values will depend upon the granularity of 
 the system clock your computer is using and the timing granularity of the operating system 
 that computer is running. For example, I donæt expect youæll see any difference 
 whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between 
 values such as 250000000 and 500000000. 
 The <
 nanoseconds-to-sleep
 > argument is a numeric literal or data item. 
 There are one BILLION nanoseconds in a second, so if you wanted to put the program to 
 sleep for 1/4 second you’d use a <
 nanoseconds-to-sleep
 > value of 250000000. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.36. CBL OPEN FILE,"CBL OPEN FILE Built-In Subroutine Syntax
  
 CALL ""CBL_OPEN_FILE"" USING file-path, access-mode, 0, 0, handle ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine opens an existing file for use as a byte-stream file usable by CBL WRITE FILE or 
 CBL READ FILE. 
 The <
 file-path
 > argument is an alphanumeric literal or data-item. 
 The <
 access-mode
 > argument is a numeric literal or data item with a PIC X USAGE COMP-X 
 (or USAGE BINARY-CHAR) definition; it specifies how you wish to use the file, as follows: 
 1 = input (read-only)  
 2 = output (write-only)  
 3 = input and/or output 
 The third and fourth arguments would specify a locking mode and device specification, 
 respectively, but they’re not implemented in GNU COBOL (currently, at least) — just specify 
 each as 0. 
 The final argument (<
 handle
 >) is a ""PIC X(4) USAGE COMP-X"" item that will receive the 
 handle to the file. That handle is used on all other byte-stream functions to reference this 
 specific file. 
 A ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) value of -1 indicates 
 an invalid argument, while a value of 0 indicates success. A value of 35 means the file does 
 not exist.",NA
8.3.37. CBL OR,"CBL OR Built-In Subroutine Syntax
  
 CALL ""CBL_OR"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.38. CBL READ FILE,"CBL READ FILE Built-In Subroutine Syntax
  
 CALL ""CBL_READ_FILE"" USING handle, offset, nbytes, flag, buffer ~~~~ 
  
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine reads <
 nbytes
 > of data starting at byte number <
 offset
 > from the byte-stream 
 file defined by <
 handle
 > into the specified <
 buffer
 >. 
 The <
 handle
 > argument (""PIC X(4) USAGE COMP-X"") must have been populated by a prior 
 call to ""CBL_OPEN_FILE"" built-in system subroutine (see
  [CBL OPEN FILE], page 545
 ). 
 The <
 offset
 > argument (""PIC X(8) USAGE COMP-X"") defines the location in the file of the first 
 byte to be read. The first byte of a file is byte offset 0. 
 The <
 nbytes
 > argument (""PIC X(4) USAGE COMP-X"") specifies how many bytes (maximum) 
 will be read. If the <
 flag
 > argument is specified as 128, the size of the file (in bytes) will be 
 returned into the file offset argument (argument 2) upon completion. Not all operating 
 system/GNU COBOL environments may be able to retrieve file sizes æ in such cases, a value 
 of zero will be returned. The only other valid value for flags is 0. This argument may be 
 specified either as a numeric literal or as a ""PIC X USAGE COMP-X"" data item. 
 Upon completion, the ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) 
 will be set to 0 if the read was successful or to 10 if an ""end-of-file"" condition occurred. If a 
 value of -1 is returned, a problem was identified with the subroutine arguments.",NA
8.3.39. CBL RENAME FILE,"Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.40. CBL TOLOWER,"CBL TOLOWER Built-In Subroutine Syntax
  
 CALL ""CBL_TOLOWER"" USING data-item, BY VALUE convert-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine will convert the first <
 convert-length
 > (a numeric literal or data item) 
 characters of <
 data-item
 > (an alpha-numeric identifier) to lower-case. 
 The <
 convert-length
 > argument must be specified ""BY VALUE"" (see
  [CALL], page 359
 ). It 
 specifies how many (leading) characters in data-item will be converted — any characters 
 after that will remain unchanged. 
 If <
 convert-length
 > is negative or zero, no conversion will be performed.",NA
8.3.41. CBL TOUPPER,"CBL TOUPPER Built-In Subroutine Syntax
  
 CALL ""CBL_TOUPPER"" USING data-item, BY VALUE convert-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.42. CBL WRITE FILE,"CBL WRITE FILE Built-In Subroutine Syntax
  
 CALL ""CBL_WRITE_FILE"" USING handle, offset, nbytes, 0, buffer ~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 This routine writes <
 nbytes
 > of data from the specified <
 buffer
 > to the byte-stream file 
 defined by <
 handle
 > starting at byte number <
 offset
 > within the file. 
 The <
 handle
 > argument (""PIC X(4) USAGE COMP-X"") must have been populated by a prior 
 call to CBL OPEN FILE. The offset argument (""PIC X(4) USAGE COMP-X"") defines the location 
 in the file of the first byte to be written to. The first byte of a file is byte offset 0. 
 The <
 nbytes
 > argument (""PIC X(4) USAGE COMP-X"") specifies how many bytes (maximum) 
 will be written. 
 Currently, the only allowable value for the flags argument is 0. This argument may be 
 specified either as a numeric literal or as a ""PIC X(1) USAGE COMP-X"" data item. 
 Upon completion, the ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) 
 will be set to 0 if the write was successful or to 30 if an I/O error condition occurred. If a 
 value of -1 is returned, a problem was identified with the subroutine arguments.",NA
8.3.43. CBL XOR,"CBL XOR Built-In Subroutine Syntax
  
 CALL ""CBL_XOR"" USING item-1, item-2, BY VALUE byte-length 
 ~~~~ 
 ~~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.44. SYSTEM,"SYSTEM Built-In Subroutine Syntax
  
 CALL ""SYSTEM"" USING 
 command  
 ~~~~  
 ~~~~~ 
 ———————————————————————————————————————— 
 This subroutine submits the specified <
 command
 > (an alphanumeric literal or data item) to 
 a command shell for execution as if it were typed into a console/terminal window. 
 A shell will be opened subordinate to the GNU COBOL program issuing the call to ""SYSTEM"". 
 Output from the command (if any) will appear in the command window in which the GNU 
 COBOL program was executed. 
 On a Unix system, the shell environment will be established using the default shell program. 
 This is also true when using a GNU COBOL build created with and for OSX or the Cygwin 
 Unix emulator. 
 With native Windows Windows/MinGW builds, the shell environment will be the Windows 
 console window command processor (usually ""cmd.exe"") appropriate for the version of 
 Windows you’re using. 
 To trap output from the executed command and process it within the GNU COBOL pro-
 gram, use a pipe (>) to send the command output to a temporary file which you read from 
 within the program once control returns. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.45. X,NA,NA
"""",NA,NA
91,NA,NA
"""","X
 ""
 91
 ""
  Built-In Subroutine Syntax
  
 CALL X""91"" USING return-code, function-code, binary-variable-arg ~~~~ 
 ~~~~~ 
 ———————————————————————————————————————— 
 The original Micro Focus version of this routine is capable of providing a wide variety of 
 functions. GNU COBOL supports just three of them: 
 •
  Turning runtime switches (SWITCH-1, . . . , SWITCH-8) on.
 •
  
 Turning runtime switches (SWITCH-1, . . . , SWITCH-8) off.
 •
  
 Retrieving the number of arguments passed to a subroutine. 
 The <
 return-code
 > argument must be a one-byte binary numeric data item (""USAGE 
 BINARY-CHAR"" is recommended). It will receive a value of 0 if the operation was successful, 
 1 otherwise. 
 The <
 function-code
 > argument must be either a numeric literal or a one-byte binary numeric 
 data item (""USAGE BINARY-CHAR"" is recommended). 
 The third argument — <
 variable-arg
 > — is defined differently depending upon the 
 <
 function-code
 > value, as follows: 
 11 
 Sets and/or clears all eight of the COBOL switches (SWITCH-1 through 
 SWITCH-8). See
  [SPECIAL-NAMES], page 62
 , for an explanation of those 
 switches. 
 The <
 variable-arg
 > argument should be an ""OCCURS 8 TIMES"" table of ""USAGE 
 BINARY-CHAR"". 
 Each occurrence that is set to a value of zero prior to the ""CALL X""91"""" will 
 cause the corresponding switch to be cleared. Each occurrence set to 1 prior to 
 the ""CALL X""91"""" will cause the corresponding switch to be set. 
 Values other than 0 or 1 will be ignored. 
 12 
 Reads all eight of the COBOL switches (SWITCH-1 through SWITCH-8) 
 The <
 variable-arg
 > argument should be an ""OCCURS 8 TIMES"" table of ""USAGE 
 BINARY-CHAR"". 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
8.3.46. X,NA,NA
"""",NA,NA
E4,NA,NA
"""","X
 ""
 E4
 ""
  Built-In Subroutine Syntax
  
 CALL X""E4""  
 ~~~~ 
 ———————————————————————————————————————— 
 Use X""E4"" to clear the screen. There are no arguments and no returned value.",NA
8.3.47. X,NA,NA
"""",NA,NA
E5,NA,NA
"""","X
 ""
 E5
 ""
  Built-In Subroutine Syntax
  
 CALL X""E5""  
 ~~~~ 
 ———————————————————————————————————————— 
 The X""E5"" routine will sound the PC ""bell"". There are no arguments and no returned value.",NA
8.3.48. X,NA,NA
"""",NA,NA
F4,NA,NA
"""","X
 ""
 F4
 ""
  Built-In Subroutine Syntax
  
 CALL X""F4"" USING byte, table  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 This routine packs the low-order (rightmost) bit from each of the eight 1-byte items in 
 <
 table
 > into the corresponding bit positions of the single-byte data item <
 byte
 >. 
 The <
 byte
 > data item need be only a single byte in size. If it is longer, the excess will be 
 unaffected by this subroutine. 
 3 June 2014  
 Chapter 8 - Interfacing With The OS",NA
8.3.49. X,NA,NA
"""",NA,NA
F5,NA,NA
"""","X
 ""
 F5
 ""
  Built-In Subroutine Syntax
  
 CALL X""F5"" USING byte, table  
 ~~~~ ~~~~~ 
 ———————————————————————————————————————— 
 This routine unpacks each bit of the single-byte data item <
 byte
 > into the low-order (right-
 most) bit of each of the corresponding eight 1-byte items in <
 table
 >. The other seven bit 
 positions of each of the first eight entries in <
 table
 > will be set to zero. 
 The <
 byte
 > data item need be only a single byte in size. If it is longer, the excess will be 
 unaffected by this subroutine. 
 The <
 table
 > data item must be at least 8 bytes long. If it is longer, the excess will be ignored 
 by this subroutine. 
 Typically, table is defined similarly to the following: 
 01 Table-Arg. 
 05 Each-Byte OCCURS 8 TIMES USAGE BINARY-CHAR.",NA
8.4. Binary Truncation,"By default, the GNU COBOL compiler will truncate binary data items to the precision 
 indicated by their ""PICTURE"" (see
  [PICTURE], page 162
 ) clause, if they have one. For 
 example, the following data item will have 2 bytes of storage allocated for it: 
 01 Comp-5-Item PIC 9(3) COMP-5. 
 Because of truncation, even though this field has enough bits allocated (16) to store values 
 from 0 to 65535, it will be limited to values of 0 to 999 because of its ""PICTURE"". 
 Or is it? 
 Take a look at the small demo program shown here.  
 This program will perform three 
 different types of operations against a binary field, displaying the results of each: 
 IDENTIFICATION DIVISION. 
 Chapter 8 - Interfacing With The OS  
 3 June 2014",NA
9. Sub-Programming,NA,NA
9.1. Subprogram Types,"Simply stated, a ’
 Subprogram
 ’ is a program that is invoked by another program; the sub-
 program performs whatever its designed operations are and — when complete — typically 
 returns control back to the program that invoked it. There are two different types of 
 subpro-grams supported by GNU COBOL, subroutines and user-defined functions. The 
 distinction between these two subprogram types lies in the manner in which they are 
 executed. 
 When program ""A"" invokes subprogram ""B"" as a ’
 Subroutine
 ’, it does so using a special 
 statement dedicated to that function (the ""CALL"" statement (see
  [CALL], page 359
 ), just as if 
 ""B"" were one of the built-in system subroutines. 
 When program ""A"" invokes program ""B"" as a ’
 User-Defined Function
 ’, it does so in a manner 
 identical to how ""B"" would have been invoked had it been one of the many built-in intrinsic 
 functions. 
 In either instance, program ""A"" is referred to as the ’
 Calling Program
 ’ while program ""B"" is 
 known as the ’
 Called Program
 ’. GNU COBOL programs may be a calling program, a called 
 program or both. 
 A program written in the C programming language may serve as either the calling or called 
 program too. A called program may act as a calling program to another called program. 
 When a calling program does not serve as a called program to any program, that calling 
 program is known as a ’
 Main Program
 ’. 
 Both subroutines and user-defined functions may return a value. The value they return 
 must be an integer in the range -2147483648 to +2147483647. This value will be available 
 in the ""RETURN-CODE"" special register (see
  [Special Registers], page 243
 ) and also as the 
 value of the data item specified on the ""RETURNING"" (see
  [CALL], page 359
 ) clause of a 
 subroutine’s CALL.",NA
9.2. Independent vs Contained vs Nested Subprograms,"Subprograms (either subroutines or user-defined functions) can be implemented in three 
 different ways. 
 ’
 Independent Subprograms
 ’ 
 These are subprograms that are coded as the only COBOL program in their 
 Compilation Unit (see
  [Compilation Unit], page 512
 ). 
 ’
 Contained Subprograms
 ’ 
 These are subprograms which occur in the same Compilation Unit as a main 
 program and/or other subprograms. Each contained subprogram is separated 
 from the next via an ""END PROGRAM"" marker line. As an example. . . 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.3. Alternate Entry Points,"Any subroutine may have multiple entry-points defined within it. This means the subrou-
 tine could be called either via a ""CALL ’<
 program-id
 >’"" or a ""CALL ’<
 entry-point
 >’"" 
 statement. There may be any number of alternate entry-points defined within a subroutine. 
 Alternate entry-points provide multiple ways in which the same subroutine may be called; 
 presumably, each entry-point will provide some different functionality to the calling pro-
 gram. For example, if you wished to write a subroutine that manipulates ""student"" records 
 in a database, you might have the primary entry-point name retrieve a student record from 
 the database, while the alternate entry points ""Add-Student"", ""Update-Student"" and ""Delete-
 Student"" could provide the alternate functions implied by their entry-point names. 
 The alternative to using multiple entry points in your subroutine, by the way, would be to 
 include an additional argument to the primary (and only) entry point of the subroutine; this 
 new argument might be named ""STUDENT-FUNCTION"" and might have values of ""FETCH"", 
 ""ADD"", ""UPDATE"" or ""DELETE"". 
 The primary entry-point for any subroutine is always the first executable statement 
 following any ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 ) in the procedure division. 
 The name of that entry-point (the name that will be called) is the subroutine’s ""PROGRAM-
 ID"" (see
  [IDENTIFICATION DIVISION], page 53
 ). 
 An alternate entry point is added to a subroutine using the ""ENTRY"" statement (see 
 [ENTRY], page 382
 ). 
 When an alternate entry-point is called, execution within the subroutine will begin at the 
 first executable statement following the ""ENTRY"" statement.",NA
9.4. Dynamic vs Static Subprograms,"Any subprogram may be either statically or dynamically loaded into memory. 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.5. Subprogram Execution Flow,"When a subprogram is invoked, the flow of execution will differ slightly depending on 
 whether the subprogram is a subroutine or a user-defined function.",NA
9.5.1. Subroutine Execution Flow,"When a subroutine is ""CALL""ed: 
 1. The calling program issues a statement of the form ""CALL ’<
 entry-point
 >’ USING ..."" to 
 transfer control to the subroutine. 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.5.2. User-Defined Function Execution Flow,"When a user-defined function is executed: 
 1. The object code for the called program (the user-defined function) will be located, as 
 follows: 
 A. If it is a static user-defined function, it will already be part of the executable file 
 containing the calling program. 
 B. If it is a dynamic user-defined function, the GNU COBOL run-time system will check 
 to see if a dynamically-loadable module containing the function’s entry point was 
 already located. If it was, no further ""location"" activity is needed. If not, the 
 dynamically-loadable module will be located (see
  [Locating Dynamically-Loadable 
 Modules], page 561
 ). 
 C. Once the module has been located (if location was needed), it will be loaded into 
 memory (if not already loaded). 
 2. Execution of the calling program is suspended and control will transfer to the called 
 program, as follows: 
 A. Local-storage, if any, will be allocated and initialized. 
 B. Execution will begin with the first executable statement in the procedure division 
 following any ""DECLARATIVES"" (see
  [DECLARATIVES], page 208
 ) that might be 
 present. 
 3. The flow of execution will then progress through the coding of the function as it would 
 with any other program. 
 4. If the function issues a ""STOP"" statement (see
  [STOP], page 461
 ) with the ""RUN"" option, 
 program execution ceases and control returns to the operating system or whatever 
 execution shell invoked the main program. 
 5. If the function wishes to return control back to the calling program, it will do so using 
 either the ""GOBACK"" statement (see
  [GOBACK], page 393
 ) or the ""EXIT FUNCTION"" 
 statement (see
  [EXIT], page 387
 ). At this time: 
 A. The value of the data item found on the user-defined functions ""PROCEDURE 
 DIVISION RETURNING"" (see
  [PROCEDURE DIVISION RETURNING], page 206
 ) 
 clause is moved to the ""RETURN-CODE"" special register (see
  [Special Registers], 
 page 243
 ). 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.6. Sharing Data Between Calling and Called Programs,NA,NA
9.5.1. Subprogram Arguments,NA,NA
9.6.1.1. Calling Program Considerations,"Data items defined in a calling program may be passed to either type of called program 
 (subroutine or user-defined function) as arguments. 
 Arguments must be described in both the calling and called programs, and while they don’t 
 need to have the same names in both programs, they should be described in an identical 
 manner with regard to the following characteristics: 
 •
  ""PICTURE"" (see
  [PICTURE], page 162
 ) (including both type and length)
 •
  
 ""SIGN"" (see
  [SIGN], page 319
 ) 
 •
  ""SYNCRONIZED"" (see
  [SYNCRONIZED], page 181
 ) 
 •
  ""USAGE"" (see
  [USAGE], page 186
 ) 
 A subroutine may be passed a maximum of 36 arguments; if you build the GNU COBOL 
 software yourself from the distributed source, you CAN change this value by altering the 
 defined value of ""COB_MAX_FIELD_PARAMS"" in the ""common.h"" header file.  
 There is no 
 built-in GNU COBOL limit to how many arguments a user-defined function may be passed. 
 Whether or not changes made to an argument within a subroutine will be ""visible"" to the 
 calling program depends on how the argument was passed. There are three ways in which 
 arguments may be passed from a calling program to a subroutine, as defined by the use of 
 optional ""BY"" clauses in the ""CALL"" (see
  [CALL], page 359
 ) statement’s list of arguments. 
 As an example, the following statement passes three arguments to a subroutine — each 
 argument is passed differently. 
 CALL ""subroutine"" USING BY REFERENCE arg-1 
  
 BY CONTENT arg-2 
  
 BY VALUE arg-3 END-
 CALL 
 The three ways arguments are passed are as follows. 
 ""BY REFERENCE"" 
 When a subroutine argument is passed ""BY REFERENCE"", the subroutine is 
 passed the
  address
  of the
  actual data item
  being passed as an argument. The 
 item may anything defined within the data division of the program. If the sub-
 routine modifies the contents of this argument, the calling program will ""see"" 
 the results of that change when the subroutine returns control. This is the de- 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.6.1.2. Called Program Considerations,"When coding a GNU COBOL subprogram (a subroutine or user-defined function), all ar-
 guments to the subprogram must be defined in the subprogram’s linkage section. 
 These arguments must be explicitly included on the ""PROCEDURE DIVISION USING"" (see 
 [PROCEDURE DIVISION USING], page 202
 ) clause that lists the arguments in the se-quence 
 in which they will be passed to the subprogram. 
 These arguments described in the ""PROCEDURE DIVISION USING"" clause may each be 
 defined as either ""BY REFERENCE"", if the calling program is passing them either ""BY 
 REFERENCE"" or ""BY CONTENT"", or as ""BY VALUE"" if they are being passed ""BY VALUE"". 
 By default, all arguments are assumed to be ""BY REFERENCE"" unless explicitly stated oth-
 erwise on the procedure division header. 
 Arguments to a user-defined function are always to be specified as ""BY REFERENCE"" (either 
 explicitly or by not using any ""BY""). 
 Chapter 9 - Sub-Programming  
 3 June 2014",NA
9.6.2. GLOBAL Data Items,"Another way in which a data item may be shared between a calling program (""A"") and a 
 called program (""B"") is by defining the data item in the calling program and attaching the 
 ""GLOBAL"" (see
  [GLOBAL], page 146
 ) clause to it so that it may be used within the called 
 program. In order for this to work, program ""B"" (the one called by program ""A"") must be a 
 nested subprogram within program ""A"". 
 Here’s a small example: 
 IDENTIFICATION DIVISION.  
 PROGRAM-ID. DemoGLOBAL.  
 ENVIRONMENT DIVISION. 
 DATA DIVISION. 
 WORKING-STORAGE SECTION. 
 01 
 Arg GLOBAL 
 PIC X(10). 
 PROCEDURE DIVISION. 
 000-Main. 
 MOVE ALL ""X"" TO Arg  
 CALL ""DemoSub"" END-CALL  
 DISPLAY ""DemoGLOBAL: "" Arg END-DISPLAY  
 GOBACK  
 . 
 IDENTIFICATION DIVISION. 
 PROGRAM-ID. DemoSub. 
 PROCEDURE DIVISION. 
 000-Main. 
 MOVE ALL ""*"" TO Arg. 
 GOBAC
 K  
 . 
 END PROGRAM DemoSub. 
 END PROGRAM DemoGLOBAL. 
 When the program runs, it produces the output: 
 DemoGLOBAL: **********",NA
9.6.3. EXTERNAL Data Items,"The final way in which a data item may be shared between a calling program (""A"") and a 
 called program (""B"") is by defining the data item (with the same name) in both programs 
 and attaching the ""EXTERNAL"" (see
  [EXTERNAL], page 141
 ) clause to it (again, in both 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.7. Recursive Subprograms,"A subroutine may ""CALL"" itself, either directly or indirectly from another subroutine or 
 user-defined function that it ""CALL""s. Any subroutine that indulges in this sort of behavior 
 (called recursion) is called a ’
 Recursive Subprogram
 ’. 
 Any GNU COBOL subroutine can be recursively invoked only if it is defined to the GNU 
 COBOL compiler as
  being
  a recursive subroutine. This is accomplished by adding the 
 ""RECURSIVE"" attribute to it’s ""PROGRAM-ID"" (see
  [IDENTIFICATION DIVISION], page 53
 ). 
 All User-defined functions are automatically capable of being executed recursively. 
 Chapter 9 - Sub-Programming  
 3 June 2014",NA
9.8. Combining GNU COBOL and C Programs,"The upcoming sections deal the issues pertaining to calling C language programs from GNU 
 COBOL programs, and vice versa. Two additional sections provide samples illustrating 
 specifics as to how those issues are overcome in actual program code.",NA
9.9.1. GNU COBOL Run-Time Library Requirements,"Like most other implementations of the COBOL language, GNU COBOL utilizes a run-time 
 library. When the first program executed in a given execution sequence is a GNU COBOL 
 program, any run-time library initialization will be performed by the compiled COBOL code 
 in a manner that is transparent to the C-language programmer. If, however, a C program is 
 the first to execute, the burden of performing GNU COBOL run-time library initialization 
 falls upon the C program. See
  [C Main Programs Calling GNU COBOL Subprograms], page 
 575
 , for an example of how to do this. 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.9.2. String Allocation Differences Between GNU COBOL and C,"Both languages store strings as a fixed-length continuous sequence of characters. 
 COBOL stores these character sequences up to a specific quantity limit imposed by the 
 ""PICTURE"" (see
  [PICTURE], page 162
 ) clause of the data item. For example: ""01 LastName 
 PIC X(15)."". 
 There is never an issue of exactly what the length of a string contained in a ""USAGE 
 DISPLAY"" (see
  [USAGE], page 186
 ) data item is — there are always exactly how ever many 
 characters as were allowed for by the ""PICTURE"" clause. In the example above, ""LastName"" 
 will always contain exactly fifteen characters; of course, there may be anywhere from 0 to 
 15 trailing SPACES as part of the current LastName value. 
 C actually has no ""string"" datatype; it stores strings as an array of ""char"" datatype items 
 where each element of the array is a single character. Being an array, there is an upper limit 
 to how many characters may be stored in a given ""string"". For example: 
 char lastName[15]; /* 15 chars: lastName[0] thru lastName[14] */ 
 C provides a robust set of string-manipulation functions to copy strings from one char array 
 to another, search strings for certain characters, compare one char array to another, 
 concatenate char arrays and so forth. To make these functions possible, it was necessary to 
 be able to define the logical end of a string. C accomplishes this via the expectation that all 
 strings (char arrays) will be terminated by a NULL character (x’00’). Of course, no one 
 forces a programmer to do this, but if [s]he ever expects to use any of the C standard 
 functions to manipulate that string they had
  better
  be null-terminating their strings! 
 So, GNU COBOL programmers expecting to pass strings to or receive strings from C 
 programs had best be prepared to deal with the null-termination issue, as follows: 
 1. Pass a quoted literal string from GNU COBOL to C as a zero-delimited string literal 
 (Z’<
 string
 >’). 
 2. Pass alphanumeric (PIC X) or alphabetic (PIC A) data items to C subroutines by 
 appending an ASCII NULL character (X’00’) to them. For example, to pass the 15-
 character LastName data item described above to a C subroutine: 
 on 
 01 
 LastName-Arg-to-C 
 PIC X(16). 
 ... 
 MOVE FUNCTION CONCATENATE(LastName,X’00’) TO LastName-Arg-to-C 
 And then pass LastName-Arg-to-C to the C subprogram! 
 3. When a COBOL program needs to process string data prepared by a C program, the 
 imbedded null character must be accounted for. This can easily be accomplished with 
 an ""INSPECT"" statement (see
  [INSPECT], page 405
 ) such as the following: 
 INSPECT Data-From-a-C-Program 
 Chapter 9 - Sub-Programming  
 3 June 2014",NA
9.9.3. Matching C Data Types with GNU COBOL USAGEs,"Matching up GNU COBOL numeric USAGEs with their C language data type equivalents is 
 possible via the following chart: 
 COBOL 
  
 C 
  
 BINARY-CHAR [ UNSIGNED ]  
 unsigned char 
 BINARY-CHAR SIGNED  
 signed char  
 BINARY-SHORT [ UNSIGNED ]  
 unsigned  
  
 unsigned int 
  
 unsigned short 
  
 unsigned short int 
 BINARY-CHAR [ UNSIGNED ]  
 unsigned char 
 BINARY-CHAR SIGNED  
 signed char  
 BINARY-SHORT [ UNSIGNED ]  
 unsigned  
  
 unsigned int 
  
 unsigned short 
  
 unsigned short int 
 BINARY-SHORT SIGNED  
 int  
  
 short  
  
 short int  
  
 signed int 
  
 signed short 
  
 signed short int 
 BINARY-LONG [ UNSIGNED ]  
 unsigned long 
  
 unsigned long int 
 BINARY-LONG SIGNED  
 long  
 BINARY-INT  
 long int  
  
 signed long 
  
 signed long int 
 BINARY-C-LONG SIGNED  
 long 
 BINARY-DOUBLE [ UNSIGNED ] 
 unsigned long long  
 unsigned long long int 
 BINARY-DOUBLE SIGNED  
 long long int 
 BINARY-LONG-LONG  
 signed long long int 
 COMPUTATIONAL-1  
 float 
 COMPUTATIONAL-2  
 double 
 N/A (no GNU COBOL equivalent)  
 long double 
 These are the ANSI2002 standard specifications for C-program data compatibility and GNU 
 COBOL programmers should get used to using them when data is being shared with C 
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
9.9.4. GNU COBOL Main Programs CALLing C Subprograms,"Here’s a sample of a GNU COBOL program that CALLs a C subprogram. 
 COBOL Calling Program 
  
  
 C Called Program 
  
 ================================== 
  
 =============================== IDENTIFICATION DIVISION. 
  
  
 #include <stdio.h> 
  
 PROGRAM-ID. maincob. 
  
  
 int subc(char *arg1, 
  
 DATA DIVISION. 
   
  
  
  
 char *arg2, 
  
 WORKING-STORAGE SECTION. 
   
   
 unsigned long *arg3) { 01 
 Arg1 
  
 PIC X(7). 
  
  
 char nu1[7]=""New1""; 
  
 01 Arg2 
  
 PIC X(7). 
  
  
 char nu2[7]=""New2""; 
  
 01 Arg3 
  
 USAGE BINARY-LONG. 
  
 printf(""Starting subc\n""); PROCEDURE DIVISION. 
  
  
 printf(""Arg1=%s\n"",arg1); 000-Main. 
  
  
  
  
  
  
 printf(""Arg2=%s\n"",arg2); DISPLAY ’Starting maincob’
  
 printf(""Arg3=%d\n"",*arg3); MOVE Z’Arg1’
  
 TO Arg1 
  
  
  
 arg1[0]=’X’; MOVE Z’Arg2’
  
 TO Arg2 
   
 arg2[0]=’Y’; 
  
 MOVE 123456789 TO Arg3 
  
  
 *arg3=987654321; 
  
 CALL ’subc’
  
   
 return 2; 
  
  
  
 USING BY CONTENT 
  
 Arg1, 
  
 } 
  
  
  
  
   
 BY REFERENCE Arg2, 
  
  
  
  
   
 BY REFERENCE Arg3 
  
 DISPLAY ’Back’
  
 DISPLAY ’Arg1=’ Arg1 
  
 DISPLAY ’Arg2=’ Arg2 
  
 DISPLAY ’Arg3=’ Arg3 
  
 DISPLAY ’Returned value=’
  
  
  
  
 RETURN-CODE 
  
 STOP RUN 
  
 .
  
 The idea is to pass two string and one full-word unsigned arguments to the subprogram, 
 have the subprogram print them out, change all three and pass a return code of 2 back to 
 the caller. The caller will then re-display the three arguments (showing changes only to the 
 two ""BY REFERENCE"" arguments), display the return code and halt. 
 While simple, these two programs illustrate the techniques required quite nicely. 
 Note how the COBOL program ensures that a null end-of-string terminator is present on 
 both string arguments. 
 Since the C program is planning on making changes to all three arguments, it declares all 
 three as pointers in the function header and references the third argument as a pointer in 
 the function body. It actually had no choice for the two string (char array) arguments –they 
 must be defined as pointers in the function even though the function code references them 
 without the leading * that normally signifies pointers. 
 These programs are compiled and executed as follows. 
 $ cobc -x maincob.cbl subc.c 
 Chapter 9 - Sub-Programming  
 3 June 2014",NA
9.9.5. C Main Programs Calling GNU COBOL Subprograms,"Now, the roles of the two languages in the previous section will be reversed, having a C main 
 program execute a GNU COBOL subprogram. 
 C Calling Program 
  
 ===========================================
 == #include <libcob.h> /* COB RUN-TIME */
  
 GNU-COBOL Called Program 
  
 ===============================
 == IDENTIFICATION DIVISION.
  
 #include <stdio.h> 
  
 PROGRAM-ID. subcob.
  
 int main (int argc, char **argv) { 
  
 DATA DIVISION.
  
 int returnCode; 
  
 LINKAGE SECTION.
  
 char arg1[7] = ""Arg1""; 
  
 01 
  
 Arg1 
  
 PIC X(7).
  
 char arg2[7] = ""Arg2""; 
  
 01 
  
 Arg2 
  
 PIC X(7).
  
 unsigned long arg3 = 123456789; 
  
 01 
  
 Arg3 
  
 USAGE BINARY-LONG.
  
 printf(""Starting mainc...\n""); 
  
 PROCEDURE DIVISION USING
  
 cob_init (argc, argv); /* COB RUN-TIME */ 
  
 BY VALUE 
  
 Arg1,
  
 returnCode = subcob(arg1,arg2,&arg3); 
  
 BY REFERENCE Arg2,
  
 printf(""Back\n""); 
  
 BY REFERENCE Arg3.
  
 printf(""Arg1=%s\n"",arg1); 
  
 000-Main.
  
 printf(""Arg2=%s\n"",arg2); 
  
 printf(""Arg3=%d\n"",arg3); 
  
 printf(""Returned value=%d\n"",returnCode); 
 return returnCode;
  
 DISPLAY ’Starting 
 cobsub.cbl’DISPLAY ’Arg1=’ Arg1 
  
 DISPLAY ’Arg2=’ Arg2 
  
 DISPLAY ’Arg3=’ Arg3
  
 } 
  
 MOVE ’X’ TO Arg1 (1:1) 
  
 MOVE ’Y’ TO Arg2 (1:1) 
  
 MOVE 987654321 TO Arg3 
  
 MOVE 2 TO RETURN-CODE 
  
 GOBACK 
  
  
 .
  
 3 June 2014  
 Chapter 9 - Sub-Programming",NA
10. Programming Style Suggestions,"This chapter deals with a variety of stylistic issues that may be of interest to someone who 
 is just starting out learning and using COBOL. Much of this chapter makes recommenda-
 tions and suggestions for how to write your own programs. The sample programs in the 
 ""Sample Programs"" document (see
  Sample Programs
 ) were coded using almost all of these 
 recommendations. 
 There’s no particular order of importance to the topics presented here.",NA
10.1. Marking Changes in Programs,"For quite a while now (back to the 1970s), the ""sequence number area"" of a COBOL 
 statement (columns 1-6) has come to be used as a change indicator area. Programmers 
 would place a code in columns 1-6 of every line they changed in a program. The author 
 works in a COBOL shop where change indicators of the form ""xxmmyy"" are required on 
 every altered line of a program — ""xx"" is the initials of the programmer while ""mmyy"" are 
 the month and two-digit year of the date the change was made. This is frequently 
 accompanied by a comment block at or near the top of a COBOL program providing general 
 documentation of what changes were made and what change indicator was used to mark 
 that change. 
 The GCic sample program source listing (see
  Section “GCic” in
  GNU COBOL Sample Programs
 ) 
 provides an excellent example of such documentation. 
 This technique of using columns 1-6 as a change indicator will ONLY work if fixed source-
 record format is in effect. 
 Some COBOL shops prefer to use the eight-character Program Name Area (columns 73-80) 
 as a change code area. 
 Marking changes becomes more of a challenge when free-format source code is in effect. 
 Creating a top-of-program comment block to generically describe changes that have been 
 made isn’t difficult, even in free-form. What IS difficult, however, is coming up with a 
 scheme for per-statement markup of changes that doesn’t introduce a ridiculously excessive 
 number of source lines to the program. I’m not sure there is a good answer to this problem 
 (if a reader has one, please let me know). Generally, I’ve noticed that shops using free-
 format conventions for their COBOL source tend to stick with just the top-of-program 
 comment block combined with minimal comment blocks sprinkled throughout the program 
 noting areas that underwent major changes.",NA
10.2. Data Item Coding and Naming Conventions,"When programs get very large, it becomes more and more challenging to keep track of the 
 data items that will be used in the program. Here, in no particular order of importance, are a 
 variety of conventions that can simplfy that problem. 
 3 June 2014  
 Chapter 10 - Programming Style Suggestions",NA
10.3. Table Subscripting versus Table Indexing,"The elements of a table may be referenced either using a subscript or an index. 
 Syntactically, this is coded using parenthesis, as per the following three examples, all of 
 which store the letter ""A"" into the 17th occurrence of a data item named WSS-Output-
 Image-TXT: 
 1. MOVE ’A’ TO WSS-Output-Image-TXT (17) 
 2. MOVE 17 TO WSS-OI-SUB  
 MOVE ’A’ TO WSS-Output-Image-TXT (WSS-OI-SUB) 
 3. SET WSS-OI-IDX TO 17  
 MOVE ’A’ TO WSS-Output-Image-TXT (WSS-OI-IDX) 
 Chapter 10 - Programming Style Suggestions  
 3 June 2014",NA
10.4. Copybook Naming Conventions and Usage,"Since the intent of a copybook is to introduce COBOL code into a particular spot in a 
 program via the ""COPY"" statement (see
  [COPY], page 40
 ), it is always a good idea to prefix 
 copybook names with a character sequence that identifies where in a program it’s contents 
 are intended to be copyed. 
 For example: 
 Chapter 10 - Programming Style Suggestions  
 3 June 2014",NA
10.5. PROCEDURE DIVISION Sections Versus Paragraphs,"The issue of whether to use section and/or paragraph names (collectively referred to as 
 procedure names) within the procedure division is one of near religious significance with 
 many COBOL programmers. 
 COBOL programming standards used by many organizations that use the language gener-ally 
 call for procedure names to: 
 1. Contain a leading numeric component (for example: AND. . 
 . 
 ""2000-Update-Customer""), 
 2. Be defined in the procedure division in non-decreasing sequence of that numeric com-
 ponent. 
 When you are looking at or editing any large COBOL program that has been created with 
 programming standards that include these two rules, it is always a simple thing to know 
 whether a reference to a procedure is being made to code that exists before or after your 
 current location in the program, simply by comparing the numeric component of the 
 current procedure’s name with the one in question. 
 Technically, GNU COBOL does not require ANY procedure names be defined unless: 
 1. You are using the ""ALTER"" statement (see
  [ALTER], page 358
 ) (the use of which should 
 be avoided at all costs) 
 2. You are using a procedural ""PERFORM"" statement (see
  [Procedural PERFORM], page 
 422
 ) 
 3. You are using a ""GO TO"" statement (see
  [GO TO], page 394
 ) 
 4. You are using a ""MERGE"" statement (see
  [MERGE], page 411
 ) with an ""OUTPUT 
 PROCEDURE"" 
 3 June 2014  
 Chapter 10 - Programming Style Suggestions",NA
10.6. COMPUTE Versus ADD-SUBTRACT-MULTIPLY-DIVIDE,"Over the years, there has been much debate over the efficiency and arithmetic accuracy of 
 using the ""COMPUTE"" statement (see
  [COMPUTE], page 366
 ) rather than the four basic 
 arithmetic operation statements. 
 Here are the facts — draw your own conclusions as to which approach is more appropriate 
 under which circumstances. 
 1. The ""COMPUTE"" statement supports exponentiation (via the ""**"" operator) — there is no 
 equivalent basic arithmetic statement. Although you could simulate integral exponentiation 
 (raising a value to the third power, for example) using ""MULTIPLY"" statements, and you 
 may use the ""SQRT"" intrinsic function (see
  [SQRT], page 321
 ) to 
 Chapter 10 - Programming Style Suggestions  
 3 June 2014",NA
Appendix A - Glossary of Terms,"’
 Alphabetic Data Item
 ’ 
 A data item whose ""PICTURE"" clause allows it to contain only upper- and/or 
 lower-case letters. See
  [PICTURE], page 162
 . 
 ’
 Alphanumeric Data Item
 ’ 
 A data item whose ""PICTURE"" clause allows it to contain absolutely any char-
 acter whatsoever. See
  [PICTURE], page 162
 . Group items (see
  [Structured Data], 
 page 10
 ) are also implicitly considered to be alphanumeric data items. 
 ’
 Alphanumeric Literal
 ’ 
 A string of characters enclosed within a pair of quotation marks ("") or apos-
 trophes (’). See
  [Alphanumeric Literals], page 33
 . 
 ’
 Called Program
 ’ 
 Another way to refer to a subprogram. Note that a called program may also be a 
 calling program. 
 ’
 Calling Program
 ’ 
 A program that executes a subprogram. Note that a calling program may also be 
 a called program. 
 ’
 Collating Sequence
 ’ 
 The sequence in which the characters that are acceptable to a computer are 
 ordered for purposes of all types of sorting, merging, comparing, and processing. 
 GNU COBOL programs may utilize standard character-set collating sequences 
 (such as that defined by the ASCII or EBCDIC charactersets) or programmer-
 defined custom sequences as specified in the OBJECT-COMPUTER paragraph 
 (section 4.1.2) and defined in the SPECIAL-NAMES paragraph (section 4.1.4). 
 ’
 Compilation Group
 ’ 
 The collection of all compilation units being compiled by a single execution of 
 the GNU COBOL compiler. 
 ’
 Compilation Unit
 ’ 
 A single source file being compiled by the GNU COBOL compiler. A compila-tion 
 unit may contain one or more programs. 
 ’
 Control Break
 ’ 
 An event that is triggered when a control field on an RWCS-generated report 
 changes value. It is these events that trigger the generation of control heading 
 and control footing groups. 
 3 June 2014  
 Appendix A - Glossary of Terms",NA
Appendix B - Reserved Word List,"The following is the complete list of reserved words in the 23NOV2013 build of GNU COBOL 
 2.1. Even though the functionality behind some of these words may not be implimented in 
 this version of GNU COBOL, none may be used as any user-defined name. 
 A 
 ABS, ACCEPT, ACCESS, ACOS, ACTIVE-CLASS, ADD, ADDRESS, 
 ADVANCING,  
 AFTER, ALIGNED,  
 ALL,  
 ALLOCATE,  
 ALPHABET, 
 ALPHABETIC,  
 ALPHABETIC-LOWER,  
 ALPHABETIC-UPPER, 
 ALPHANUMERIC,  
 ALPHANUMERIC-EDITED,  
 ALSO,  
 ALTER, 
 ALTERNATE,  
 AND,  
 ANNUITY,  
 ANY, ANYCASE,  
 ARE,  
 AREA, 
 AREAS, ARGUMENT-NUMBER, ARGUMENT-VALUE, ARITHMETIC, 
 AS, ASCENDING, ASCII, ASIN, ASSIGN, AT, ATAN, ATTRIBUTE, 
 AUTHOR, 
 AUTO, 
 AUTO-SKIP, 
 AUTOMATIC, 
 AUTOTERMINATE, 
 AWAY-FROM-ZERO 
 B 
 B-AND, B-NOT, B-OR, B-XOR, BACKGROUND-COLOR, BACKGROUND- 
 COLOUR, BASED, BEEP, BEFORE, BELL, BINARY, BINARY-C-LONG, 
 BINARY-CHAR, 
 BINARY-DOUBLE, 
 BINARY-INT, 
 BINARY-LONG, 
 BINARY-LONG-LONG, BINARY-SHORT, BIT, BLANK, BLINK, BLOCK, 
 BOOLEAN, BOOLEAN-OF-INTEGER, BOTTOM, BY, BYTE-LENGTH, 
 BYTE-LENGTH 
 C 
 C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, CALL, 
 CALL-CONVENTION, CANCEL,  
 CAPACITY,  
 CD,  
 CENTER,  
 CF, 
 CH,  CHAIN,  
 CHAINING,  
 CHAR,  
 CHAR-NATIONAL,  
 CHARACTER, 
 CHARACTERS, CLASS, CLASS-ID, CLASSIFICATION, CLOSE, COB- 
 CRT-STATUS, CODE, CODE-SET, COL, COLLATING, COLS, COLUMN, 
 COLUMNS, 
 COMBINED-DATETIME, 
 COMMA, 
 COMMAND-LINE, 
 COMMIT, COMMON, COMMUNICATION, COMP, COMP-1, COMP-2, 
 COMP-3, COMP-4, COMP-5, COMP-6, COMP-X, COMPUTATIONAL, 
 COMPUTATIONAL-1, COMPUTATIONAL-2,  
 COMPUTATIONAL-3, 
 COMPUTATIONAL-4,  
 COMPUTATIONAL-5,  
 COMPUTATIONAL-X, 
 COMPUTE,  
 CONCATENATE,  
 CONDITION,  
 CONFIGURATION, 
 CONSOLE, CONSTANT, CONTAINS, CONTENT, CONTINUE, CON- 
 TROL, 
 CONTROLS, 
 CONVERSION, 
 CONVERTING, 
 COPY, 
 CORR, 
 CORRESPONDING, COS, COUNT, CRT, CRT-UNDER, CSP, CURRENCY, 
 CURRENCY-SYMBOL, CURRENT-DATE, CURSOR, CYCLE 
 D 
 DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, 
 DATE-OF-INTEGER,  
 DATE-TO-YYYYMMDD,  
 DATE-WRITTEN, 
 DAY, DAY-OF-INTEGER,  
 DAY-OF-WEEK,  
 DAY-TO-YYYYDDD,  
 DE, 
 DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, 
 DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, 
 DETAIL, 
 DISABLE, 
 DISC, 
 DISK, 
 DISPLAY, 
 DISPLAY-OF, 
 DIVIDE, 
 DIVISION, DOWN, DUPLICATES, DYNAMIC 
 3 June 2014  
 Appendix B - Reserved Word List",NA
Appendix C - GNU Free Documentation License,"Version 1.3, 3 November 2008 
 Copyright c
 ⃝
  2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. 
 http://fsf.org/
  
 Everyone is permitted to copy and distribute verbatim copies 
 of this license document, but changing it is not allowed. 
 0. PREAMBLE 
 The purpose of this License is to make a manual, textbook, or other functional and 
 useful document
  free
  in the sense of freedom: to assure everyone the effective freedom 
 to copy and redistribute it, with or without modifying it, either commercially or non-
 commercially. Secondarily, this License preserves for the author and publisher a way to 
 get credit for their work, while not being considered responsible for modifications 
 made by others. 
 This License is a kind of “copyleft”, which means that derivative works of the document 
 must themselves be free in the same sense. It complements the GNU General Public 
 License, which is a copyleft license designed for free software. 
 We have designed this License in order to use it for manuals for free software, because 
 free software needs free documentation: a free program should come with manuals 
 providing the same freedoms that the software does. But this License is not limited to 
 software manuals; it can be used for any textual work, regardless of subject matter or 
 whether it is published as a printed book. We recommend this License principally for 
 works whose purpose is instruction or reference. 
 1. APPLICABILITY AND DEFINITIONS 
 This License applies to any manual or other work, in any medium, that contains a notice 
 placed by the copyright holder saying it can be distributed under the terms of this 
 License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to 
 use that work under the conditions stated herein.  
 The “Document”, 
 below, refers to any such manual or work. Any member of the public is a licensee, and is 
 addressed as “you”. You accept the license if you copy, modify or distribute the work in a 
 way requiring permission under copyright law. 
 A “Modified Version” of the Document means any work containing the Document or a 
 portion of it, either copied verbatim, or with modifications and/or translated into 
 another language. 
 A “Secondary Section” is a named appendix or a front-matter section of the Document 
 that deals exclusively with the relationship of the publishers or authors of the 
 Document to the Document’s overall subject (or to related matters) and contains 
 nothing that could fall directly within that overall subject. (Thus, if the Document is in 
 part a textbook of mathematics, a Secondary Section may not explain any 
 mathematics.) The relationship could be a matter of historical connection with the 
 subject or with related matters, or of legal, commercial, philosophical, ethical or 
 political position regarding them. 
 3 June 2014  
 Appendix C - GNU Free Documentation License",NA
ADDENDUM: How to use this License for your documents,"To use this License in a document you have written, include a copy of the License in the 
 document and put the following copyright and license notices just after the title page: 
 Copyright (C)
  
 year
  
 your name
 .
  
 Permission is granted to copy, distribute and/or modify this document under the terms 
 of the GNU Free Documentation License, Version 1.3 or any later version published by 
 the Free Software Foundation; 
  
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. 
  
 A copy of 
 the license is included in the section entitled ‘‘GNU Free Documentation License’’.
  
 If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the“with. . 
 .Texts.” line with this: 
 with the Invariant Sections being
  list their titles
 , with the Front-Cover Texts 
 being
  list
 , and with the Back-Cover Texts being
  list
 .
  
 If you have Invariant Sections without Cover Texts, or some other combination of the three, 
 merge those two alternatives to suit the situation. 
 If your document contains nontrivial examples of program code, we recommend releasing 
 these examples in parallel under your choice of free software license, such as the GNU 
 General Public License, to permit their use in free software. 
 ———————————————————— 
 End of Appendix C — GNU Free Documentation License 
 Appendix C - GNU Free Documentation License  
 3 June 2014",NA
Appendix D - Summary of Document Changes,"GNU COBOL is an ever-evolving tool.  
 While all reasonable attempts will be made to 
 maintain the currency of the information in this document, neither the author of this 
 document nor the authors of the GNU COBOL software extend any warranties of any kind for 
 this document or for the information contained therein. 
 3rd Edition - 09 APR 2014 
 1. The document has been converted to GNU Texinfo format, from which both GNU ""info"" 
 and PDF files may be created for distribution. 
 2. A new document — ""Sample Programs"" — has been created from the former ""Sample 
 Programs"" chapter of this document. 
 3. A new document — ""Quick Reference"" — has been introduced to provide a complete 
 summary of all syntax diagrams. 
 3rd Edition - 01 MAY 2014 
 1. Updated to include RWCS documentation, added with GNU COBOL 2.1. 
 2. Removed the ""See Also"" links from all sections; with the Index now being fully hyper-
 linked, the maintenance of these links as well as the document size increase imposed by 
 them is no longer justified. 
 2nd Edition - 17 JUL 2012 
 1. Updated for version 23NOV2013 of GNU COBOL 2.0. 
 2. Corrected a problem with several bogus footnote references. 
 3. Added an International A4 page layout format version of the document, in addition to the 
 US Letter page format version. 
 4. The use of a slash character (/) in column 7 was documented this feature has existed 
 since at least the 06FEB2009 version of OpenCOBOL 1.1, but was undocumented. 5. Added 
 documentation on the DEBUG-ITEM special register. 
 6. Updated DECLARATIVES documentation to better explain how to use it. 
 7. A new section was added to the documentation to discuss the ramifications, rules and 
 capabilities of sub-programming. 
 8. Documentation was added on the COB SET DEBUG environment variable. 
 9. The listings of all sample programs are now presented as listings generated by the GNU 
 COBOL Interactive Compiler utility (itself included as a sample program). This not only 
 shows full source listings of the sample programs but complete cross-reference listings 
 as well. 
 10. A new sample program – DAY-FROM-DATE – was introduced to illustrate how to write a 
 user-defined function. 
 3 June 2014  
 Appendix D - Summary of Document Changes",NA
Index,NA,NA
"""","-o Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . .
  513
 ,
  519
  
 "" (Quote)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33",NA
& ,"& (Literal Concatenation)
  . . . . . . . . . . . . . . . . . . . . .
  34
  
 -O Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  556
 -O2 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . .
  556
 -Os 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . .
  556
 -
 Wobsolete Compiler Switch
  . . . . . . . . . . . . . . . . . . .
  54
 -x 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . .
  513
 ,
  519
 -x 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . .
  560
 ,
  592",NA
’,NA,NA
.,"’ (Apostrophe)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
  
 . (Punctuation)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36",NA
* ,NA,NA
/,"* (Multiplication)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  216 
 * In 
 Column 7 (Comment)
 . . . . . . . . . . . . . . . . . . . . .
  32 
 ** 
 (Exponentiation)
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  215
  
 / (Division)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  216 
 / In 
 Column 7 (Comment)
 . . . . . . . . . . . . . . . . . . . . .
  32
  
 *> (Comment)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  32",NA
+ ,"+ (Addition)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  216
  
 + (Unary Sign Retention)
  . . . . . . . . . . . . . . . . . . . . .
  215",NA
; ,"; (Punctuation)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36",NA
>,">>D (Debugging Line)
  . . . . . . . . . . . . . . . . . . . . . . . . .
  32",NA
", ",", (Punctuation)
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36",NA
-,">>DEFINE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  45 
 >>ELIF
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  47 
 >>ELSE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  47 
 >>END-IF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  47 
 >>IF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  46 
 >>SET
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  49
  
  
 - (Character in Words/Names)
  . . . . . . . . . . . . . . . . . .
  6
 - 
 (Subtraction)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  216
 - 
 (Unary Sign Reversal)
  . . . . . . . . . . . . . . . . . . . . . .
  215
 - In 
 Column 7 (Continuation)
 . . . . . . . . . . . . . . . . . .
  34
 -b 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  560
 -conf 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . .
  516
 -debug 
 Compiler Switch
 . . . . . . . . . . . . .
  209
 ,
  264
 ,
  265
 -
 fdebugging-line Compiler Switch
  . . . . . .
  32
 ,
  57
 ,
  209
  
 >>SOURCE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  50 
 >>TURN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  51",NA
^,"^ (Exponentiation)
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  215
  
 -ffold-call Compiler Switch
 . . . . . . . . . . . . . . . . . . . .
  521
 -
 ffold-copy Compiler Switch
  . . . . . . . . . . . . . . .
  49
 ,
  516
  
 (Character in user-defined words)
  . . . . . . . . . . . . .
  6
  
 -fintrinsics Compiler Switch
 . . . . . . . . . . . . . . . . . . .
  245
  
 -fintrinsics=ALL Compiler Switch
 . . . . . . . . . . . . . .
  60
 -fixed 
 Compiler Switch
  . . . . . . . . . . . . . . . . .
  26
 ,
  49
 ,
  50",NA
0,"-fnotrunc Compiler Switch
 . . . . . . . . . . . . . . . . . . . .
  553
 -
 foptional-file Compiler Switch
  . . . . . . . . . . . . . . . . .
  74
  
 01-Level Constants
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  118
  
 -free Compiler Switch
  . . . . . . . . . . . . . . . . . .
  26
 ,
  49
 ,
  50
 -fsyntax-extension Compiler Switch
  . . . . . . . . . . . .
  70",NA
6,"-ftrace Compiler Switch
  . . . . . . . . . . . . .
  433
 ,
  435
 ,
  523
 -
 ftraceall Compiler Switch
  . . . . . .
  264
 ,
  265
 ,
  435
 ,
  523
 -g 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . .
  264
 ,
  265
 -I 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  515
 -m 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . .
  513
 ,
  520
 -m 
 Compiler Switch
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  560
  
 66-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  121",NA
7 ,"77-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  122
  
 78-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  123
  
 3 June 2014  
 Index",NA
8 ,"ANNUITY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  248
  
 88-Level Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  124 
  
 ANY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  385
  
 ANY LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  125
  
 Area ""A"" (Columns 8-11)
 . . . . . . . . . . . . . . . . . . . . . .
  28",NA
A ,"Area ""B"" (Columns 12-72)
 . . . . . . . . . . . . . . . . . . . . .
  28
  
 A Sample Screen
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  19 
 ABS
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  246 
 ACCEPT
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  338 
 ACCEPT FROM 
 COMMAND-LINE
  . . . . . . . . .
  339 
 ACCEPT FROM 
 CONSOLE
  . . . . . . . . . . . . . . . . .
  338 
 ACCEPT FROM 
 DATE/TIME
 . . . . . . . . . . . . . . .
  347 
 ACCEPT FROM 
 ENVIRONMENT
  . . . . . . . . . .
  341 
 ACCEPT FROM 
 Runtime-Info
  . . . . . . . . . . . . . . .
  349 
 ACCEPT FROM 
 Screen-Info
  . . . . . . . . . . . . . . . . .
  348 
 ACCEPT screen-
 data-item
  . . . . . . . . . . . . . . . . . . .
  342 
 ACCESS MODE 
 DYNAMIC
 . . . . . . . . . . . . . . .
  83
 ,
  85 
 ACCESS MODE 
 RANDOM
  . . . . . . . . . . . . . . . . . . .
  82 
 ACCESS MODE 
 RANDOM
  . . . . . . . . . . . . . . . . . . .
  85 
 ACCESS MODE 
 SEQUENTIAL
 . . . . . . . . . . . . . . .
  78 
 ACCESS MODE 
 SEQUENTIAL
  . . . . . . . . . . .
  81
 ,
  85 
 ACOS
 . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . .
  247 
 ADD
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  350 
 ADD CORRESPONDING
 . . . . . . . . 
 . . . . . . . . . . . .
  354 
 ADD GIVING
 . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . .
  352 
 ADD TO
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 .
  350 
 Additional Reference Sources
  . . . . . . . . . . . . . . . . . . .
  
 1 
 ADDRESS OF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  447 
 ADVANCING PAGE
  . . . . . . . . . . . . . . . . . . . . . . . . .
  480 
 AFTER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  423 
 AFTER ADVANCING
  . . . . . . . . . . . . . . . . . . . . . . .
  480 
 AFTER EXCEPTION CONDITION
  . . . . . . . . .
  208 
 ALL
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  60
 ,
  198
 ,
  476 
 ALL 
 INTRINSIC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  60 
 ALL 
 OTHER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  73 
 ALL 
 OTHER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  231 
 ALLOCATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  356 
 ALPHABET
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  67 
 Alphabet-Name-Clause
  . . . . . . . . . . . . . . . . . . . . . . . .
  67 
 ALPHABETIC
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  219
 ,
  399 
 Alphabetic Data Item
  . . . . . . . . . . . . . . . . . . . . . . . .
  589 
 Alphabetic Data Items
  . . . . . . . . . . . . . . . . . . . . . . .
  163 
 ALPHABETIC-LOWER
  . . . . . . . . . . . . . . . . . . . . .
  219
  
 ARGUMENT-NUMBER
  . . . . . . . . . . . . . . . . . . . . .
  339 
 ARGUMENT-NUMBER
  . . . . . . . . . . . . . . . . . . . . .
  372 
 ARGUMENT-VALUE
 . . . . . . . . . . . . . . . . . . . . . . . .
  339 
 Arithmetic Expressions
  . . . . . . . . . . . . . . . . . . . . . . .
  215 
 ASCENDING KEY
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  442 
 ASCII
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  67 
 ASIN
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  249 
 AT END
  . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  441 
 AT END + NOT AT 
 END
  . . . . . . . . . . . . . . . . . . . .
  235 
 ATAN
 . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  250 
 AUTHOR
  . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  53 
 AUTO
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . .
  126 
 AUTO-SKIP
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . .
  127 
 AUTOTERMINATE
  . . . . . . . . . . . . . . . . . . . . . . . . .
  
 128",NA
B,"BACKGROUND-COLOR
  . . . . . . . . . . . . . . . . . . . .
  129 
 BASED
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  130 
 BEEP
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  131 
 BEFORE ADVANCING
 . . . . . . . . . . . . . . . . . . . . . .
  480 
 BELL
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  132 
 Binary 
 Truncation
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  552 
 BLANK
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  133 
 BLANK WHEN 
 ZERO
  . . . . . . . . . . . . . . . . . . . . . . .
  134 
 BLINK
 . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . .
  135 
 BLOCK CONTAINS
  . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  95 
 Built-In System Subroutines
  . . . . 
 . . . . . . . . . . . . . .
  525 
 BY CONTENT
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  362 
 BY CONTENT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  566 
 BY REFERENCE
  . . . . . . . . . . . . . . . . . .
  202
 ,
  362
 ,
  
 565 
 BY REFERENCE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  566 
 BY VALUE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  203
 ,
  362 
 BY 
 VALUE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  566 
 BYTE-
 LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  118 
 BYTE-
 LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  251
  
 ALPHABETIC-UPPER
  . . . . . . . . . . . . . . . . . . . . . .
  219 
 ALPHANUMERIC
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  399",NA
C,"Alphanumeric Data Item
  . . . . . . . . . . . . . . . . . . . . .
  589 
 Alphanumeric Data Items
  . . . . . . . . . . . . . . . . . . . .
  163 
 Alphanumeric Literal
  . . . . . . . . . . . . . . . . . . . . . . . . .
  589 
 Alphanumeric Literal (Hexadecimal)
  . . . . . . . . . . .
  34 
 Alphanumeric Literal (Zero-Delimited)
 . . . . . . . . .
  34 
 Alphanumeric Literals
  . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 ALPHANUMERIC-EDITED
  . . . . . . . . . . . . . . . . .
  399 
 ALSO
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  43
 ,
  384 
 ALTER
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  358 
 Alternate Entry 
 Points
  . . . . . . . . . . . . . . . . . . . . . . .
  559 
 ALTERNATE 
 RECORD KEY
 . . . . . . . . . . . . . . . . .
  85 
 An Example
 . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . .
  490 
 AND
  . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  225
  
 C Main Programs Calling GNU COBOL 
  
 Subprograms
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  575 
 C$CALLEDBY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  526 
 C$CHDIR
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  526 
 C$COPY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  527 
 C$DELETE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  527 
 C$FILEINFO
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  527 
 C$GETPID
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  528 
 C$JUSTIFY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  528 
 C$MAKEDIR
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  529 
 C$NARG
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  529 
 C$PARAMSIZE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  530 
 C$PRINTABLE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  530
  
 Index  
 3 June 2014",NA
D,"Compiler Switches, -m
  . . . . . . . . . . . . . . . . . . .
  513
 ,
  520 
 Compiler Switches, -m
 . . . . . . . . . . . . . . . . . . . . . . . .
  560 
 Compiler Switches, -o
 . . . . . . . . . . . . . . . . . . . .
  513
 ,
  519 
 Compiler Switches, -O
  . . . . . . . . . . . . . . . . . . . . . . . .
  556 
 Compiler Switches, -O2
 . . . . . . . . . . . . . . . . . . . . . . .
  556 
 Compiler Switches, -Os
  . . . . . . . . . . . . . . . . . . . . . . .
  556 
 Compiler Switches, -Wobsolete
 . . . . . . . . . . . . . . . . .
  54 
 Compiler Switches, -x
 . . . . . . . . . . . . . . . . . . . .
  513
 ,
  519 
 Compiler Switches, -x
 . . . . . . . . . . . . . . . . . . . .
  560
 ,
  592 
 Compiling Programs
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  509 
 COMPUTE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  366 
 COMPUTE Versus 
  
  
 ADD-SUBTRACT-MULTIPLY-DIVIDE 
  
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  586 
 CONCATENATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  254 
 Concurrent Access to Files
 . . . . . . . . . . . . . . . . . . . .
  231 
 Condition Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  124 
 Condition Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  218 
 Conditional Expressions
  . . . . . . . . . . . . . . . . . . . . . .
  218 
 CONFIGURATION SECTION
  . . . . . . . . . . . . . . . .
  56 
 CONSOLE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  65 
 CONSOLE IS CRT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  63 
 CONSTANT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  45
 ,
  49 
 CONSTANT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  98 
 CONSTANT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  138 
 Contained Subprograms
  . . . . . . . . . . . . . . . . . . . . . .
  557 
 CONTENT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  382 
 Continuation (- in Column 7)
  . . . . . . . . . . . . . . . . . .
  34 
 CONTINUE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  368 
 CONTROL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  109 
 Control Break
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  489 
 Control Break
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  589 
 Control Field
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  590 
 Control Footing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  590 
 Control Heading
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  590
  
 D In Column 7 (Debugging Line)
  . . . . . . . . . . . . . .
  32 
 Data
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  490 
 Data Definition Principles
  . . . . . . . . . . . . . . . . . . . . .
  90 
 Data Description Clauses
  . . . . . . . . . . . . . . . . . . . . .
  125 
 DATA DIVISION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  89 
 Data 
 Initialization
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  23 
 Data 
 Item
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  10
 ,
  591 
 Data 
 Item Coding and Naming Conventions
  . .
  579 
 DATA 
 RECORD
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 DATE-
 COMPILED
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  53 
 DATE-OF-
 INTEGER
  . . . . . . . . . . . . . . . . . . . . . . . .
  258 
 DATE-TO-
 YYYYMMDD
  . . . . . . . . . . . . . . . . . . . .
  259 
 DATE-
 WRITTEN
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  53 
 DAY-OF-
 INTEGER
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  260 
 DAY-TO-
 YYYYDDD
  . . . . . . . . . . . . . . . . . . . . . . . .
  261 
 DB HOME
 . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  524 
 DB HOME 
 Environment Variable
  . . . . . . . . . . . .
  233 
 DEBUG-ITEM 
 Special Register
  . . . . . . . . . . . . . .
  209 
 DEBUGGING 
 MODE
  . . . . . . . . . . . . . . . . . . . . . . . . .
  57 
 DECIMAL POINT IS 
 COMMA
  . . . . . . . . . . . . . . .
  63 
 DECLARATIVES
  . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  208 
 DEFAULT
  . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . .
  400 
 DEFINED
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  47 
 DELETE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  369 
 DELIMITED BY
  . . . . . . . . . . . . . . . . . . . . . . . .
  464
 ,
  
 476 
 DELIMITER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  476 
 DEPENDING ON
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  159 
 DESCENDING KEY
  . . . . . . . . . . . . . . . . . . . . . . . . .
  442 
 Detail 
 Group
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  591 
 detail 
 report
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  391
 ,
  392 
 Detail 
 Report
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  591 
 Direct 
 Execution
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  519 
 DISPLAY
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  370 
 DISPLAY 
 screen-data-item
  . . . . . . . . . . . . . . . . . . .
  374 
 DISPLAY 
 UPON COMMAND-LINE
  . . . . . . . . .
  372
  
 Index  
 3 June 2014",NA
E,"ESCAPE KEY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  348 
 EVALUATE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  383
  
  
 E
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  262 
 Elementary Item
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  11
 ,
  591 
 ELSE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  397 
 EMPTY-CHECK
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  139 
 END-
 OF-PAGE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  481 
 ENTRY
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  382 
 Entry-point
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  591 
 Entry-point Name
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  591 
 ENVIRONMENT
  . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  341 
 ENVIRONMENT DIVISION
  . . . 
 . . . . . . . . . . . . . . .
  55 
 Environment Variables, COB 
 CONFIG DIR
  . .
  516 
 Environment Variables, COB 
 LIBRARY PATH 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  521 
 Environment Variables, COB LIBRARY PATH 
 . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  561 
 Environment Variables, COB LOAD CASE
 . . .
  561
  
 EVENT STATUS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  62 
 EXCEPTION STATUS
 . . . . . . . . . . . . . . . . . . . . . . .
  349 
 EXCEPTION-FILE
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  263 
 EXCEPTION-LOCATION
  . . . . . . . . . . . . . . . . . . .
  264 
 EXCEPTION-STATEMENT
  . . . . . . . . . . . . . . . . .
  265 
 EXCEPTION-STATUS
 . . . . . . . . . . . . . . . . . . . . . . .
  266 
 Executable File
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  592 
 Executing Dynamically-Loadable Libraries
  . . . .
  520 
 Execution Thread
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  592 
 EXIT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  387 
 EXP
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  268 
 EXP10
  . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  269 
 EXTEND
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  421 
 EXTERNAL
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  141 
 EXTERNAL Data Items
  
 . . . . . . . . . . . . . . . . . . . . .
  567
  
 Environment Variables, 
  
 COB PHYSICAL CANCEL
  . . . . . . . . . . . . .
  363",NA
F,"Environment Variables, 
  
  
 COB PHYSICAL CANCEL
  . . . . . . . . . . . . .
  561 
 Environment Variables, COB PRE LOAD
  . . . .
  361 
 Environment Variables, COB PRE LOAD
  . . . .
  561 
 Environment Variables, COB SCREEN ESC 
  
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  344 
 Environment Variables, 
  
  
 COB SCREEN EXCEPTIONS
  . . . . . . . . . .
  344 
 Environment Variables, COB SET DEBUG
  . .
  209 
 Environment Variables, COB SET TRACE
  . .
  433
 ,
  
 FACTORIAL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  270 
 FALSE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  142 
 Figurative Constants
 . . . . . . . . . . . . . . . . . . . . . .
  35
 ,
  592 
 File OPEN Modes
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  421 
 FILE SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  93 
 File 
 Sharing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  231 
 FILE 
 STATUS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  76 
 File Status 
 Codes
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  76 
 File-Based 
 SORT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  453 
 FILE-SECTION-
 Data-Item
  . . . . . . . . . . . . . . . . . . . .
  98
  
 435 
  
 File/Sort-Description
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  94
  
 Environment Variables, COB SORT MEMORY 
 . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  455 
 Environment 
 Variables, COB SWITCH n
 . . . . . .
  70 
 Environment 
 Variables, COBCPY
  . . . . . . . . . . . .
  515 
 Environment 
 Variables, DB HOME
 . . . . . . . . . . .
  233 
 Environment 
 Variables, LANG
  . . . . .
  256
 ,
  300
 ,
  301
 ,
  
 Files
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  11 
 FILLER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  92 
 FINAL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  109 
 FIRST DETAIL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 Fixed 
 Format Mode
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  26 
 Fixed 
 Format Mode
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  50
  
 302
 ,
  303 
  
 Fixed Format Mode
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  592
  
 Environment Variables, LD LIBRARY PATH 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  512 
 Environment Variables, PATH
  . . . . . . . . . . . . . . . .
  521 
 Environment Variables, PATH
  . . . . . . . . . . . . . . . .
  561
  
 FOLDCOPYNAME
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  49 
 FOOTING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 FOOTING AT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 FOREGROUND-COLOR
  . . . . . . . . . . . . . . . . . . . .
  143
  
 3 June 2014  
 Index",NA
G,"INSTALLATION
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  53 
 INTEGER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  273
  
  
 GENERATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  391 
 Generated Report Pages
  . . . . . . . . . . . . . . . . . . . . . .
  497 
 GIVING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  413
 ,
  456
 ,
  461 
 GIVING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  467 
 GLOBAL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  146 
 GLOBAL Data Items
 . . . . . . . . . . . . . . . . . . . . . . . . .
  567 
 Glossary of Terms
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  589 
 GNU COBOL Main Programs CALLing C 
  
  
 Subprograms
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  574 
 GNU COBOL Run-Time Library Requirements 
  
 . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  571 
 GNU COBOL 
 Statements
  . . . . . . . . . . . . . . . . . . . .
  338 
 GNU Free 
 Documentation License
  . . . . . . . . . . . .
  603 
 GO TO
  . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  394 
 GO TO DEPENDING 
 ON
  . . . . . . . . . . . . . . . . . . .
  395 
 GOBACK
  . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  393 
 GROUP INDICATE
 . . . . . . . . . . . . . . . . 
 . . . . . . . . . .
  147
  
 INTEGER-OF-DATE
  . . . . . . . . . . . . . . . . . . . . . . . .
  274 
 INTEGER-OF-DAY
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  275 
 INTEGER-PART
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  276 
 Interfacing to Other Environments
  . . . . . . . . . . . . .
  37 
 Interfacing With The OS
  . . . . . . . . . . . . . . . . . . . . .
  509 
 INTO
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  429
 ,
  431
 ,
  436 
 INTRINSIC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  60 
 Intrinsic Function
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  593 
 Intrinsic Functions
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  245 
 Introducing COBOL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  1 
 Introduction
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  1 
 INVALID KEY + NOT INVALID KEY
  . . . . . . .
  238",NA
J,"JUSTIFIED
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  149
  
 Group Item
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  10
 ,
  592",NA
K,"KEY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  159
 ,
  412
 ,
  431",NA
H,"HEADING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 Hexadecimal Alphanumeric Literal
 . . . . . . . . . . . . .
  34 
 Hexadecimal Alphanumeric Literal
 . . . . . . . . . . . .
  592 
 Hexadecimal Numeric Literal
  . . . . . . . . . . . . . . . . . .
  33 
 Hexadecimal Numeric Literal
  . . . . . . . . . . . . . . . . .
  593 
 HIGH-VALUE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36 
 HIGHEST-ALGEBRAIC
  . . . . . . . . . . . . . . . . . . . . .
  272 
 HIGHLIGHT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  148 
 How 
 RWCS Builds Report Pages
  . . . . . . . . . . . . .
  486",NA
L,"LABEL RECORD
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 LANG 
 Environment Variable
  . .
  256
 ,
  300
 ,
  301
 ,
  302
 , 
 303 
  
 Language Reserved Words
  . . . . . . . . . . . . . . . . . . . . . .
  6 
 LAST CONTROL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 LAST 
 DETAIL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 LD 
 LIBRARY PATH
  . . . . . . . . . . . . . . . . . . . . . . . .
  514 
 LD 
 LIBRARY PATH Environment Variable
  . .
  512 
 LEADING
  
 . . . . . . . . . . . . . . . . . . . . . . .
  41
 ,
  43
 ,
  177
 ,
  333",NA
I,"LEFTLINE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  151 
 LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  118
  
  
 I-O
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  421 
 IDENTIFICATION DIVISION
  . . . . . . . . . . . . . . . .
  53 
 Identifiers
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  593 
 IF
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  397 
 IGNORING LOCK
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  234 
 Imperative Statement
  . . . . . . . . . . . . . . . . . . . . . . . .
  593 
 Independent Subprograms
  . . . . . . . . . . . . . . . . . . . .
  557
  
 LENGTH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  277 
 LENGTH OF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36 
 LENGTH-AN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  278 
 LENGTH-CHECK
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  152 
 Level 
 Number
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  593 
 LINAGE 
 IS n LINES
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 LINAGE-
 COUNTER Special Register
  . . . . . . . . .
  96
  
 Index  
 3 June 2014",NA
N,"Literals (Alphaumeric)
 . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 Literals (Numeric)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 LOCAL-STORAGE SECTION
  . . . . . . . . . . . . . . .
  102 
 LOCALE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  63 
 LOCALE Names
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  64 
 LOCALE-COMPARE
  . . . . . . . . . . . . . . . . . . . . . . . .
  279 
 LOCALE-DATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  280 
 LOCALE-TIME
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  281 
 LOCALE-TIME-FROM-SECONDS
 . . . . . . . . . . .
  282 
 Locating Copybooks
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  515 
 LOCK
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  77
 ,
  364 
 LOCK MODE IS AUTOMATIC
 . . . . . . . . . . . . . .
  233 
 LOCK 
 MODE IS MANUAL
  . . . . . . . . . . . . . . . . . .
  233 
 LOCK ON
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  233 
 LOG
  . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  283 
 LOG10
 . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . .
  284 
 LOW-VALUE
  . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  35 
 LOWER
  . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . .
  49 
 LOWER-CASE
  . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . .
  285 
 LOWEST-ALGEBRAIC
 . . . . . . . . . . . . . . . . . . . . . 
 .
  286 
 LOWLIGHT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  155
  
 NATIONAL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 National Characterset
  . . . . . . . . . . . . . . . . . . .
  162
 ,
  594 
 NATIONAL-EDITED
  . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 NATIVE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  67 
 Negated Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  226 
 NEGATIVE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  221 
 Nested Subprograms
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  558 
 NEXT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  156
 ,
  429 
 NEXT GROUP
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  156 
 NEXT 
 PAGE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  153
 ,
  156 
 NEXT 
 SENTENCE
  . . . . . . . . . . . . . . . . . . . . .
  229
 ,
  397 
 NO 
 ADVANCING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  371 
 NO 
 OTHER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  232 
 NO 
 REWIND
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  364 
 NO 
 REWIND
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  420 
 NO-
 ECHO
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  157 
 NOFOLDCOPYNAME
 . . . . . . . . . . . . . . . . . . . . . . . .
  49 
 NORMAL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  461 
 NOT
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  226 
 NOT 
 INVALID KEY
  . . . . . . . . . . . . . . . . . . . . . . . . .
  238 
 NOT ON 
 EXCEPTION
  . . . . . . . . . . . . . . . . . . . . . .
  239 
 NOT ON 
 OVERFLOW
  . . . . . . . . . . . . . . . . . . . . . .
  239",NA
M,"NOT ON SIZE ERROR
  . . . . . . . . . . . . . . . . . . . . . .
  240 
 NULL
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  36
  
  
 Main program
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  594 
 Main Program
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  557 
 Marking Changes in Programs
  . . . . . . . . . . . . . . . .
  579 
 Matching C Data Types with GNU COBOL 
  
  
 USAGEs
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  573 
 MAX
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  287 
 MEAN
  . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  288 
 MEDIAN
  . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  289 
 MEMORY SIZE
 . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . .
  58 
 MERGE
  . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  411 
 MIDRANGE
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . .
  290 
 MIN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . .
  291 
 MOD
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 .
  292 
 MODE IS BLOCK
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  342 
 MODULE-CALLER-ID
  . . . . . . . . . . . . . . . . . . . . . .
  293 
 MODULE-DATE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  294 
 MODULE-FORMATTED-DATE
  . . . . . . . . . . . . .
  295
  
 NUMERIC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  219 
 NUMERIC
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 Numeric Data Item
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  594 
 Numeric Data Items
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  163 
 Numeric Edited
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  165 
 Numeric Edited Data Item
  . . . . . . . . . . . . . . . . . . .
  594 
 Numeric Literal
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  594 
 Numeric Literal (Hexadecimal)
  . . . . . . . . . . . . . . . .
  33 
 Numeric Literals
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  33 
 NUMERIC SIGN TRAILING SEPARATE
 . . . . .
  65 
 NUMERIC-DECIMAL-POINT
  . . . . . . . . . . . . . . .
  302 
 NUMERIC-EDITED
  . . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 NUMERIC-THOUSANDS-SEPARATOR
  . . . . .
  303 
 NUMVAL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  304 
 NUMVAL-C
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  305 
 NUMVAL-F
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  306
  
 MODULE-ID
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  296 
 MODULE-PATH
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  297 
 MODULE-SOURCE
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  298
  
 3 June 2014",NA
O ,"OBJECT-COMPUTER
 . . . . . . . . . . . . . . . . . . . . . . . .
  58
  
 Index",NA
Q,"ORGANIZATION SEQUENTIAL
  . . . . . . . . . . . . .
  78 
 OUTPUT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  421 
 OUTPUT PROCEDURE
  . . . . . . . . . . . . . . . .
  413
 ,
  456 
 overflow condition
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  464
  
 Qualification
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  595 
 Qualification of Data Names
  . . . . . . . . . . . . . . . . . .
  212 
 QUOTE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  35
  
 OVERLINE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  161 
 OVERRIDE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  45",NA
R,"RANDOM
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  312",NA
P,"Random READ
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  430 
 RANGE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  314
  
  
 PAGE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  156 
 Page Footing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  594 
 Page Heading
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  595 
 PAGE LIMITS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  108 
 PAGE-COUNTER
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  178 
 PAGE-COUNTER Special Register
 . .
  110
 ,
  404
 ,
  471 
 PARAMETER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  45 
 PATH
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  524 
 PATH Environment Variable
  . . . . . . . . . . . . . . . . .
  521 
 PATH Environment Variable
  . . . . . . . . . . . . . . . . .
  561 
 PERFORM
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  422 
 perform scope
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  422 
 PI
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  310 
 PICTURE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  114
 ,
  162 
 POINTER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  463 
 POSITIVE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  221 
 PRESENT WHEN
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  170 
 PRESENT-VALUE
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  311 
 PREVIOUS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  429 
 Primary Entry-Point
  . . . . . . . . . . . . . . . . . . . . . . . . .
  595 
 PRIMARY KEY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  85 
 PRINTER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  65 
 PRINTING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  40 
 Procedural PERFORM
  . . . . . . . . . . . . . . . . . . . . . . .
  422
  
 READ
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  428 
 READ ONLY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  232 
 Readability of Programs
  . . . . . . . . . . . . . . . . . . . . . . . .
  7 
 READY TRACE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  433 
 Record
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  98 
 Record
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  595 
 RECORD CONTAINS
  . . . . . . . . . . . . . . . . . . . . . . . .
  96 
 RECORD DELIMITER
  . . . . . . . . . . . . . . . . . . . . . . .
  73 
 RECORD IS VARYING
  . . . . . . . . . . . . . . . . . . . . . . .
  96 
 RECORD KEY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  369 
 Record Locking
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  233 
 RECORDING MODE
  . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 RECURSIVE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  54 
 Recursive Subprogram
 . . . . . . . . . . . . . . . . . . . . . . . .
  568 
 Recursive Subprograms
  . . . . . . . . . . . . . . . . . . . . . . .
  568 
 REDEFINES
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  172 
 REEL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  364 
 REFERENCE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  382 
 Reference Modifiers
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  213 
 Relation Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  223 
 RELATIVE KEY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  82 
 RELATIVE KEY
  . . . . . . . . . . . . . . . . . . . . . . . . .
  83
 ,
  369 
 RELEASE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  434 
 REM
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  315
  
 Index  
 3 June 2014",NA
S,"REMARKS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  53 
 RENAMES
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  173 
 REPLACE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  42 
 REPLACING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  41
 ,
  42 
 REPLACING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  400
 ,
  405 
 Report Footing
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  595 
 Report Group
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  596 
 Report Group Definitions
 . . . . . . . . . . . . . . . . . . . . .
  111 
 Report Heading
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  596 
 REPORT IS
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  96 
 REPORT SECTION
  . . . . . . . . . . . . . . . . . . . . . . . . .
  107 
 REPORT SECTION Data Items
 . . . . . . . . . . . . . .
  113 
 Report Writer Features
  . . . . . . . . . . . . . . . . . . . . . . . .
  22 
 Report Writer Usage Notes
  . . . . . . . . . . . . . . . . . . .
  483 
 REPOSITORY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  60 
 REQUIRED
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  174 
 RESERVE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  73 
 Reserved Word
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  596 
 Reserved Word List
  . . . . . . . . . . . . . . . . . . . . . . . . . .
  599 
 Reserved Words
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  6
 ,
  599 
 RESET
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  180 
 RESET TRACE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  435 
 RETURN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  436 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  361 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  461 
 RETURN-CODE Special Register
  . . . . . . .
  526
 ,
  527 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  528 
 RETURN-CODE Special Register
  . .
  529
 ,
  530
 ,
  532
 , 
  
 533
 ,
  534
 ,
  535
 ,
  536 
  
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  537 
 RETURN-CODE Special Register
 . . .
  538
 ,
  541
 ,
  542 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  543 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  544 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  545 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  546 
 RETURN-CODE Special Register
  . . . . . . .
  547
 ,
  548 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  549 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  557 
 RETURN-CODE Special Register
  . . . . . . .
  562
 ,
  563 
 RETURN-CODE Special Register
  . . . . . . . . . . . .
  564 
 RETURNING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  356 
 RETURNING
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  362
 ,
  461 
 RETURNING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  562 
 REVERSE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  316 
 REVERSE-VIDEO
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  175 
 REVERSED
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  420 
 REWRITE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  437 
 ROLLBACK
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  439 
 ROUNDED
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  240 
 RUN
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  461 
 Run 
 Time Environment Variables
 . . . . . . . . . . . . .
  522 
 Running Programs
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  519 
 RWCS Lexicon
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  483
  
 SAME RECORD AREA
 . . . . . . . . . . . . . . . . . . . . . . .
  87 
 SAME 
 SORT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  87 
 SAME SORT-
 MERGE
  . . . . . . . . . . . . . . . . . . . . . . . .
  87 
 SCREEN CONTROL
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . .
  62 
 Screen Formatting 
 Features
  . . . . . . . . . . . . . . . . . . . .
  18 
 SCREEN SECTION
 . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  115 
 SCROLL
  . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . .
  344 
 SEARCH
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . .
  440 
 SEARCH ALL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  442 
 Search Index
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 440 
 SECONDS-FROM-FORMATTED-TIME
  . . . . .
  317 
 SECONDS-PAST-MIDNIGHT
 . . . . . . . . . . . . . . . .
  318 
 SECURE
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  176 
 SECURITY
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  53 
 SEGMENT-LIMIT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  58 
 SELECT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  73 
 Sentence
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  227
 ,
  596 
 SEPARATE CHARACTER
  . . . . . . . . . . . . . . . . . .
  177 
 Sequence Number Area (Columns 1-6)
  . . . . . . . . .
  27 
 Sequential READ
  . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  428 
 SET
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  47 
 SET
 . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  445 
 SET ADDRESS
  . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  447 
 SET ATTRIBUTE
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  452 
 SET Condition Name
 . . . . . . . . . 
 . . . . . . . . . . . . . . . .
  450 
 SET ENVIRONMENT
  . . . . . . . . . . . . . . 
 . . . . . . . . .
  445 
 SET Index
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  448 
 SET Program-Pointer
  . . . . . . . . . . . . . . . . . . . . . . . .
  
 446 
 SET Switch
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  451 
 SET UP/DOWN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  449 
 SHARING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  77 
 SHARING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  231 
 SHARING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  421 
 Sharing Data Between Calling and Called 
  
 Programs
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  565 
 SIGN
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  319 
 Sign 
 Conditions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  221 
 SIGN IS
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  177 
 Simple GO TO
  . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  394 
 Simple MOVE
 . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . .
  414 
 SIN
  . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  320 
 single record locking
  . . . . . . . . . . . 
 . . . . . . . . . . . . . . .
  233 
 So What is GNU COBOL?
  . . . . . . . . . . . 
 . . . . . . . . . .
  5 
 SORT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . .
  453 
 SORT STATUS
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  76 
 Sorting and Merging Data
  . . . . . . . . . . . . . . . . . . . . .
  15 
 SOURCE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  178 
 Source Line Format, Fixed
  . . . . . . . . . . . . . . . . .
  26
 ,
  50 
 Source Line Format, Free
  . . . . . . . . . . . . . . . . . .
  26
 ,
  50 
 SOURCE-COMPUTER
  . . . . . . . . . . . . . . . . . . . . . . .
  57 
 SPACE
 . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  35 
 Special Data 
 Items
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  118 
 Special Registers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  243 
 Special Registers
  . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . .
  596 
 Special Registers, DEBUG-
 ITEM
  . . . . . . . . . . . . .
  209 
 Special Registers, LINAGE-
 COUNTER
  . . . . . . . .
  96
  
 3 June 2014  
 Index",NA
T,"Table Handling
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  15 
 Table References
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  211 
 Table SORT
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  457 
 Table Subscripting versus Table Indexing
  . . . . .
  582 
 TALLYING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  405 
 TAN
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  327 
 TEMP
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  524 
 TEMP 
 Environment Variable
  . . . . . . . . . . . . . . . . . .
  96 
 TEMP 
 Environment Variable
  . . . . . . . . . . . . . . . . .
  456 
 TERMINATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  472 
 TEST-DATE-YYYYMMDD
 . . . . . . . . . . . . . . . . . .
  328 
 TEST-
 DAY-YYYYDDD
 . . . . . . . . . . . . . . . . . . . . . .
  329 
 TEST-
 NUMVAL
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  330 
 TEST-
 NUMVAL-C
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  331 
 TEST-
 NUMVAL-F
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  332 
 The 
 Anatomy of a Report
  . . . . . . . . . . . . . . . . . . . .
  484 
 The 
 Anatomy of a Report Page
 . . . . . . . . . . . . . . .
  485 
 THRU
  . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  384 
 TIMEOUT
  . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  344 
 TIMES
 . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . .
  422 
 TMP
  . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . .
  515
 ,
  524 
 TMP Environment 
 Variable
 . . . . . . . . . . . . . . .
  96
 ,
  456 
 TMPDIR
 . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . .
  515
 ,
  524 
 TMPDIR Environment 
 Variable
  . . . . . . . . . . . . . . .
  96 
 TMPDIR Environment 
 Variable
  . . . . . . . . . . . . . .
  456 
 TO
 . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . .
  183 
 TRAILING
  . . . . . . . . . . . . . . . . . . . . . 
 .
  41
 ,
  43
 ,
  177
 ,
  333 
 TRANSFORM
  . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  473 
 TRIM
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . .
  333
  
 Index  
 3 June 2014",NA
U,"UNDERLINE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  185 
 UNLOCK
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  474 
 UNSIGNED
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  194 
 UNSTRING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  475 
 UNTIL
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  422 
 UNTIL EXIT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  422 
 UPDATE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  342 
 UPON
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  179
 ,
  370 
 UPON CRT
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  374 
 UPON CRT-UNDER
 . . . . . . . . . . . . . . . . . . . . . . . . .
  374 
 UPPER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  49 
 UPPER-CASE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  334 
 USAGE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  186 
 USE 
 AFTER STANDARD ERROR 
  
  
 PROCEDURE
  . . . . . . . . . . . . . . . . . . . . . . . . . . .
  210 
 USE 
 BEFORE REPORTING
 . . . . . . . . . . . . . . . . .
  208 
 USE FOR 
 DEBUGGING
  . . . . . . . . . . . . . . . . . . . . .
  209 
 Use of Periods
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  227 
 Use of VERB/END-
 VERB Constructs
  . . . . . . . .
  229 
 USER NAME
  . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . .
  349 
 User-Defined Function
  . . . . . . . 
 . . . . . . . . . . . . . . . . .
  557 
 User-Defined Function
  . . . . . . . . . . 
 . . . . . . . . . . . . . .
  597 
 User-Defined Function Execution 
 Flow
 . . . . . . . .
  563 
 User-Defined Names
  . . . . . . . . . . . . . . . . 
 . . . . . . . . . .
  597 
 User-Defined Words
  . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . .
  6 
 USING
  . . . . . . . . . . . . . . .
  196
 ,
  202
 ,
  362
 ,
  382
 ,
  
 412
 ,
  454
  
 VARYING
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  160 
 VARYING
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  425
 ,
  440 
 Verb
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  229 
 Verb
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  597",NA
W,"WHEN
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  384
 ,
  442 
 WHEN OTHER
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  384 
 WHEN-COMPILED
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  336 
 Why 
 YOU Should Learn COBOL
  . . . . . . . . . . . . . . .
  2 
 WITH 
 DEBUGGING MODE
 . . . . . . . . . . . . . . . . . .
  32 
 WITH 
 FILLER
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 WITH 
 IGNORE LOCK
  . . . . . . . . . . . . . . . . . . . . . .
  234 
 WITH KEPT 
 LOCK
  . . . . . . . . . . . . . . . . . . . . . . . . .
  234 
 WITH LOCK
  . . . . . . 
 . . . . . . . . . . . . . . . . . . . . .
  234
 ,
  421 
 WITH NO LOCK
  . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . .
  234 
 WITH TEST
 . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . .
  423 
 WITH WAIT
 . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . .
  234 
 WORKING-STORAGE SECTION
  . . . . . . . . . 
 . .
  100 
 WRITE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 479",NA
X,"X""91""
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  550 
 X""E4""
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  551 
 X""E5""
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  551 
 X""F4""
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  551 
 X""F5""
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  552",NA
Y,"YEAR-TO-YYYY
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  337",NA
V ,NA,NA
Z,"VALUE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  197
 ,
  382 
 VALUE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  400 
 VALUE OF
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  95 
 VARIANCE
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  335
  
 ZERO
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  35 
 ZERO
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  221 
 Zero-Delimited Alphanumeric Literals
 . . . . . . . . . .
  34 
 Zero-Delimited Alphanumeric Literals
 . . . . . . . . .
  597
  
 3 June 2014  
 Index",NA
