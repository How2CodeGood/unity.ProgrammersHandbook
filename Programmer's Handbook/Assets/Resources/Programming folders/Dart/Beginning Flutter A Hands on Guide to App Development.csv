Larger Text,Smaller Text,Symbol
BEGINNING FLUTTER,"®
  
 INTRODUCTION  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
  
 xxi
  
 ▸ PART I 
  
 THE FOUNDATIONS OF FLUTTER PROGRAMMING
  
 CHAPTER 1 
  
 Introducing Flutter and Getting Started  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 3
  
 CHAPTER 2 
  
 Creating a Hello World App   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 25
  
 CHAPTER 3 
  
 Learning Dart Basics   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  
 .  . 43
  
 CHAPTER 4 
  
 Creating a Starter Project Template  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 65
  
 CHAPTER 5 
  
 Understanding the Widget Tree  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 77
  
 ▸ PART II 
  
 INTERMEDIATE FLUTTER: FLESHING OUT AN APP
  
 CHAPTER 6 
  
 Using Common Widgets  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 103
  
 CHAPTER 7 
  
 Adding Animation to an App  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 151
  
 CHAPTER 8 
  
 Creating an App’s Navigation  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 177
  
 CHAPTER 9 
  
 Creating Scrolling Lists and Effects   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 221
  
 CHAPTER 10 
 Building Layouts  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 253
  
 CHAPTER 11 
 Applying Interactivity   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 267
  
 CHAPTER 12 
 Writing Platform-Native Code  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 307
  
 ▸ PART III CREATING PRODUCTION-READY APPS
  
 CHAPTER 13 
 Saving Data with Local Persistence  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 327",NA
BEGINNING ,NA,NA
Flutter,NA,NA
®,NA,NA
BEGINNING ,NA,NA
Flutter,NA,NA
®,NA,NA
A HANDS ON GUIDE TO APP DEVELOPMENT,Marco L. Napoli,NA
ABOUT THE AUTHOR,"Marco L. Napoli
  is the CEO of Pixolini, Inc., and an experienced mobile, web, and desktop app 
 developer. He has a strong proven record in developing visually elegant and simple-to-use 
 systems. He wrote his first native iOS app in 2008. His work and published apps can be seen at 
 www.pixolini.com
 .
  
 He has loved computers from an early age. His dad noticed and bought him a PC, and he has been 
 developing software since. He attended the University of Miami for an architecture degree, but he had 
 already started his own business, and after four years he decided architecture was not for him. He 
 developed systems for a diverse mix of industries including banking, healthcare, real estate, education, 
 trucking, entertainment, and horizontal markets. Later, a leading banking software company acquired 
 his MLN Enterprises, Inc., company. The main products were mortgage banking, processing, and 
 marketing software.
  
 Next, he started consulting and later created IdeaBlocks, Inc., with the purpose of software devel-
 opment consulting. He developed for a client that sold hospitality software for mobile, desktop, and web 
 platforms. The main product focus was on hotel sales, catering, webspace, guest service, and 
 maintenance software. The products synced via cloud servers using Microsoft SQL Server with 
 encryption applied to sensitive data. His client’s customers included Hyatt Place and Summerfield, 
 Hilton Hotel, Holiday Inn, Hampton Inn, Marriott, Best Western, Radisson Hotel, Sheraton Hotels, 
 Howard Johnson, Embassy Suites, and many more. Once his contract was done, he closed IdeaBlocks.
  
 Today, his focus is running Pixolini. He develops mobile, desktop, and web apps for iOS, Mac, Android, 
 Windows, and the Web. He also teaches a course at Udemy using a web app that he devel-oped for 
 analyzing real estate investment calculations. He has developed and published more than 10 apps in 
 each respective store.
  
 He was interviewed by Hillel Coren for the “It’s All Widgets Flutter Podcast” on November 27, 
 2018, and the episode can be found at 
 https://itsallwidgets.com/podcast/episodes/1/ 
 marco-napoli
 .
  
 “I cannot code without espresso, cappuccino, or coffee, and I love martial arts.”
  
 Marco is married to Carla, and they have three amazing children.",NA
ABOUT THE TECHNICAL EDITOR,"Zeeshan Chawdhary
  is an avid technologist, with 14 years of experience in the industry. Having 
 started his career with mobile development with J2ME, he soon ventured into web development, 
 creating robust and scalable web applications. As a chief technology officer, he has led teams to build 
 web and mobile apps for companies such as Nokia, Motorola, Mercedes, GM, American Airlines, and 
 Marriott. He is currently director of development on an international team, serving clients with tech-
 nologies like Magento, WordPress, WooCommerce, Laravel, NodeJS, Google Puppeteer, ExpressJS, 
 ReactJS, and .NET. He has also authored books on iOS, Windows Phone, and iBooks.
  
 Zeeshan is based in Mumbai, India. He can be reached at 
 imzeeshanc@gmail.com
  or on Twitter 
 @imzeeshan, and he maintains a Medium publication at 
 https://medium.com/@imzeeshan
 .",NA
ACKNOWLEDGMENTS,"I want to thank the talented team at Wiley, including all of the editors, managers, and many people 
 behind the scenes who helped to get this book published. My thanks to Devon Lewis for recogniz-ing 
 early on that Flutter is having a major impact on the industry, to Candace Cunningham for her project 
 editing skills and her insights, to Zeeshan Chawdhary for his technical input and suggestions, to Barath 
 Kumar Rajasekaran and his team for getting the production of the book ready, and to Pete Gaughan for 
 always being available.
  
 A special thanks to the Flutter team at Google, especially Tim Sneath, Ray Rischpater, and Filip 
 Hráček, for their kindness and invaluable feedback.
  
 A thank-you to my wife and children who have patiently listened and given feedback for the projects 
 created in this book.",NA
CONTENTS,"INTRODUCTION 
  
 xxi
  
 PART I: THE FOUNDATIONS OF FLUTTER PROGRAMMING
  
 CHAPTER 1: INTRODUCING FLUTTER AND GETTING STARTED 
  
 3
  
 Introducing Flutter  
  
 Defining Widgets and Elements 
  
 Understanding Widget Lifecycle Events  
  
 The StatelessWidget Lifecycle 
  
  
 The StatefulWidget Lifecycle 
  
 Understanding the Widget Tree and the Element Tree 
  
 Stateless Widget and Element Trees 
  
  
 Stateful Widget and Element Trees 
  
 Installing the Flutter SDK  
  
 Installing on macOS 
  
  
  
 System Requirements 
  
  
  
 Get the Flutter SDK 
  
  
  
 Check for Dependencies 
  
  
  
 iOS Setup: Install Xcode 
  
  
  
 Android Setup: Install Android Studio 
  
  
  
 Set Up the Android Emulator 
  
  
 Installing on Windows 
  
  
  
 System Requirements 
  
  
  
 Get the Flutter SDK 
  
  
  
 Check for Dependencies 
  
  
  
 Install Android Studio 
  
  
  
 Set Up the Android Emulator 
  
  
 Installing on Linux 
  
  
  
 System Requirements 
  
  
  
 Get the Flutter SDK 
  
  
  
 Check for Dependencies 
  
  
  
 Install Android Studio 
  
  
  
 Set Up the Android Emulator 
  
 Configuring the Android Studio Editor  
 Summary  
 4  
 5 
  
 5  
 6 
  
 6 
  
 8  
 9 
  
 10 
  
 13  
 13 
  
 13 
  
 13 
  
 14 
  
 14 
  
 14 
  
 15 
  
 15 
  
 15 
  
 16 
  
 16 
  
 16 
  
 17 
  
 17 
  
 17 
  
 18 
  
 19 
  
 19 
  
 19 
  
 20  
 20",NA
INTRODUCTION,"Flutter was unveiled at the 2015 Dart Developer Summit under the name Sky. Eric Seidel (engineer 
 director for Flutter at Google) opened his talk by saying that he was there to speak about Sky, which 
 was an experimental project presented as “Dart on mobile.” He had built and published a demo on the 
 Android Play Store, and he started the demo by stating that there was no Java drawing this appli-cation, 
 meaning it was native. The first feature Eric showed was a square spinning. Driving the device at 60 
 Hertz was Dart, which was the first goal for the system: to be fast and responsive. (He wanted to go 
 much faster [i.e., 120 Hertz], but he was restricted by the capability of the device he was using.) Eric 
 went on to show multitouch, fast scrolling, and other features. Sky provided the best mobile experience 
 (for users and developers); the developers took lessons from working on the Web, and they thought 
 they could do better. The user interface (UI) and the business logic were both written in Dart. The goal 
 was to be platform-agnostic.
  
 Fast-forward to 2019, and Flutter now is powering Google’s smart display platform including the 
 Google Home Hub and is the first step toward supporting desktop apps with Chrome OS. The result is 
 that Flutter supports desktop apps running on Mac, Windows, and Linux. Flutter is described as a 
 portable UI framework for all screens like mobile, web, desktop, and embedded devices from a single 
 codebase.
  
 This book teaches you how to develop mobile applications for iOS and Android from a single code-base 
 by using the Flutter framework and Dart as the programming language. As Flutter is expanding beyond 
 mobile, you can take the knowledge that you learn in this book and apply it to other plat-forms. You 
 don’t need to have previous programming experience; the book starts with the basics and progresses to 
 developing production-ready applications.
  
 I wrote this book in a simple, down-to-earth style to teach you each concept. You can follow the “Try It 
 Out” practice-style exercises to implement what you learn and create feature-focused applications.
  
 Each chapter builds upon the previous ones and adds new concepts to advance your knowledge for 
 building fast, beautiful, animated, and functional apps. By the end of this book, you’ll be able to take the 
 knowledge and techniques you have learned and apply them to develop your own applications. In the 
 last four chapters of the book, you’ll create a journal app with the ability to save data locally and a 
 second journal app that adds mood tracking with state management, authentication, and multidevice 
 data cloud syncing capabilities including offline sync, which is a must for today’s mobile applications. I 
 have made every effort to teach you the techniques using a friendly and commonsense approach so you 
 can learn the basics all the way to advanced concepts needed for the workplace.
  
 From the first time I saw Google presenting Flutter, it has captured my attention. What especially 
 attracted me to Flutter was the widgets concept. You take widgets and nest (
 composition
 ) them together 
 to create the UI needed, and best of all, you can easily create your own custom widgets. The other major 
 item that attracted me to Flutter was the ability to develop for iOS and Android from a single codebase; 
 this is something I had been needing for a long time and never found a great solution until Flutter. 
 Flutter is declarative; it’s a modern reactive framework where widgets handle what the UI should look 
 like according to their current state.",NA
WHO THIS BOOK IS FOR,"This book is for everyone who wants to learn how to program mobile, multiplatform applications by 
 using Flutter and Dart. It is for absolute beginners who want to learn to develop modern, fast native 
 performance, and reactive mobile applications for iOS and Android. However, it also takes you from 
 absolute beginner to learning the advanced concepts required to develop production-ready applica-
 tions. It’s also for people who are familiar with programming who want to learn the Flutter frame-work 
 and the Dart language.
  
 This book is written with the assumption of having no prior programming, Flutter, or Dart experi-ence. 
 If you have programmed in other languages or are familiar with Flutter and Dart, you’ll simply get a 
 deeper understanding of each concept and technique.",NA
WHAT THIS BOOK COVERS,"The early chapters introduce and cover the architecture of the Flutter framework, the Dart language, 
 and steps for creating a new project. You’ll use that knowledge to create new projects for each exer-cise 
 in the book. Each chapter is written to advance your knowledge by focusing on new concepts. 
  
 The chapters are also written to be reference material to refresh your knowledge of each concept.
  
 Starting in Chapter 2, as you learn each concept and technique, you’ll follow the “Try It Out” practice-
 style exercises and create new application projects to put into practice what you’ve learned. 
  
 As you move forward, each chapter is designed to teach you more advanced topics. The last four 
 chapters focus on creating two production-ready applications by applying previously learned materi-
 als and implementing new advanced concepts. You can also find these exercises as part of the code 
 downloads on this book’s page at 
 www.wiley.com/go/beginningflutter
 .",NA
HOW THIS BOOK IS STRUCTURED,"This book is divided into 16 chapters. Although each chapter builds upon the previous concepts, they 
 are also self-contained and written for you to be able to jump to a particular interest to learn or refresh 
 that topic.
  
 xxii",NA
Part I: The Foundations of Flutter Programming,"In the first part of the book, you’ll get to know the core aspects of Flutter so you have a solid founda-
 tion to build on.
  
 Chapter1: Introducing Flutter and Getting Started
 —You’ll learn how the Flutter framework 
 works behind the scenes and about the benefits of the Dart language. You’ll see how 
 Widget
 , 
 Element
 , and 
 RenderObject
  are related, and you’ll get an understanding of how they form the 
 widget tree, element tree, and render tree. You’ll get an introduction to 
 StatelessWidget 
 and 
 StatefulWidget
  and their lifecycle events. You’ll learn that Flutter is declarative, mean-ing 
 Flutter builds the UI to reflect the state of the app. You’ll learn how to install the Flutter 
 framework, Dart, editor, and plugins on macOS, Windows, or Linux.
  
 Chapter2: Creating a Hello World App
 —You’ll learn how to create your first Flutter project 
 to get familiarized with the process. By writing this minimal example, you’ll learn the basic 
 structure of an application, how to run the app on the iOS simulator and the Android emula-tor, 
 and how to make changes to the code. At this point, do not worry about understanding the code 
 yet; I’ll walk you through it step-by-step in later chapters.
  
 Chapter3: Learning Dart Basics
 —Dart is the foundation of learning to develop Flutter 
 applications, and in this chapter you’ll understand Dart’s basic structure. You’ll learn how to 
 comment your code, how the 
 main()
  function starts the app, how to declare variables, and 
 how to use the 
 List
  to store an array of values. You’ll learn about the operator symbols and 
 how to use them to perform arithmetic, equality, logical, conditional, and cascade notation. 
 You’ll learn how to use external packages and classes and how to use the 
 import
  statement. 
 You’ll learn how to implement asynchronous programming by using a 
 Future
  object. You’ll 
 learn how to create classes to group code logic and use variables to hold data and how to define 
 functions to execute logic.
  
 Chapter4: Creating a Starter Project Template
 —You’ll learn the steps to create a new 
 project that you’ll use and replicate to create all of the exercises in this book. You’ll learn how 
 to organize files and folders in your project. You’ll create the most commonly used names to 
 group your widgets, classes, and files by the type of action needed. You’ll learn how to struc-
 ture widgets and import external packages and libraries.
  
 Chapter5: Understanding the Widget Tree
 —The widget tree is the result of 
 composing
  
 (nest-ing) widgets to create simple and complex layouts. As you start nesting widgets, the code 
 can become harder to follow, so good practice is to try to keep the widget tree as shallow as 
 possible. You’ll get an introduction to the widgets that you’ll use in this chapter. You’ll get an 
 understanding of the effects of a deep widget tree, and you’ll learn how to refactor it into a 
 shallow widget tree, resulting in more manageable code. You’ll learn three ways to create a 
 shallow widget tree by refactoring with a constant, with a method, and with a widget class. 
 You’ll learn the benefits and cons of each technique.",NA
Part II: Intermediate Flutter: Fleshing Out an App,"In Part II of the book, you’ll get your hands dirty, stepping through how to add functionality that cre-
 ates great user experiences.
  
 xxiii",NA
Part III: Creating Production-Ready Apps,"For the final four chapters of the book, you’ll move into more advanced territory and prepare to 
 release your sample apps to production.
  
 Chapter13: Saving Data with Local Persistence
 —You’ll learn how to build a journal app. 
  
 You’ll learn how to persist data over app launches by using the JSON file format and sav-ing the 
 file to the local iOS and Android filesystem. JavaScript Object Notation (JSON) is a common 
 open-standard and language-independent file data format with the benefits of being human-
 readable text. You’ll learn how to create database classes to write, read, and serialize JSON files. 
 You’ll learn how to format a list and sort it by date.
  
 In a mobile application, it’s important not to block the UI while processing, and you’ll learn 
 how to use the 
 Future
  class and the 
 FutureBuilder
  widget. You’ll learn how to present a 
 date-selection calendar, validate user entry data, and move focus between entry fields.
  
 You’ll also learn how to delete records using the 
 Dismissible
  widget by dragging or flinging 
 on an entry. To sort entries by date, you’ll learn how to use the 
 List().sort
  method and the 
 Comparator
  function. To navigate between pages, you’ll use the 
 Navigator
  widget, and you’ll 
 learn how to use the 
 CircularProgressIndicator
  widget to show that an action is running.
  
 Chapter14: Adding the Firebase and Firestore Backend 
 —Spanning this chapter, Chapter 
 15, and Chapter 16, you’ll use techniques that you have learned in previous chapters along with 
 new concepts and tie them together to create a production-level mood journaling app. In a 
 production-level app, how would you combine what you learned, improve performance by 
 redrawing only the widgets with data changes, pass state between pages and up the widget 
 tree, handle the user authentication credentials, sync data between devices and the cloud, and 
 create classes that handle platform-independent logic between mobile and web apps? These 
 are the reasons why these last three chapters will teach you how to apply the previous tech-
 niques you learned along with new important ones to develop a production-level mobile app.
  
 In these last three chapters, you’ll learn how to implement app-wide and local-state manage-
 ment and maximize platform code sharing by implementing the Business Logic Component 
 (BLoC) pattern.
  
 xxv",NA
WHAT YOU NEED TO USE THIS BOOK,"You’ll need to install the Flutter framework and Dart to create the example projects. This book uses 
 Android Studio as its primary development tool, and all projects compile for iOS and Android. For 
 compiling iOS applications, you’ll need a Mac computer with Xcode installed. You can also use other 
  
 xxvi",NA
CONVENTIONS,"To help you get the most from the text and keep track of what’s happening, we’ve used a number of 
 conventions throughout the book.
  
 TRY IT OUT 
  
 You should work through all the 
 Try It Out
  exercises in the book.
  
 1. 2. 
  
 These exercises consist of a set of numbered steps. 
 Follow the steps with your copy of the database.
  
 HOW IT WORKS
  
 At the end of each 
 Try It Out,
  the code you’ve typed will be explained in detail.
  
 As for styles in the text:
  
 ➤➤
  
 We 
 italicize
  new terms and important words when we introduce them.
  
 ➤➤
  
 We show keyboard strokes like this: Ctrl+A.
  
 ➤➤
  
 We show filenames, URLs, and code within the text like so:
  
 persistence.properties
  
 We present code in two different ways:
  
 We use a monofont type with no highlighting for most code examples.
  
 We use bold to emphasize code that is particularly important in the 
 present context or to show changes from a previous code snippet.",NA
ERRATA,"We make every effort to ensure that there are no errors in the text or in the code. However, no one is 
 perfect, and mistakes do occur. If you find an error in one of our books, like a spelling mistake or faulty 
 piece of code, we would be very grateful for your feedback. By sending in errata, you may save another 
 reader hours of frustration, and at the same time, you will be helping us provide even higher-quality 
 information.
  
 xxvii",NA
PART I ,NA,NA
The Foundations of Flutter ,NA,NA
Programming,"▸
  CHAPTER 1:
  Introducing Flutter and Getting Started▸
  
 CHAPTER 2:
  Creating a Hello World App
  
 ▸
  CHAPTER 3:
  Learning Dart Basics
  
 ▸
  CHAPTER 4:
  Creating a Starter Project Template▸
  
 CHAPTER 5:
  Understanding the Widget Tree",NA
1 ,NA,NA
Introducing Flutter and ,NA,NA
Getting Started,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 What the Flutter framework is 
  
 What Flutter’s benefits are 
  
 How Flutter and Dart work together 
  
 What a Flutter 
 Widget
  is 
  
 What an 
 Element
  is 
  
 What a 
 RenderObject
  is 
  
 What type of Flutter widgets are available 
  
 What the stateless and stateful 
 Widget
  lifecycle is 
  
 How the widget tree and element tree work together 
  
 How to install the Flutter SDK 
  
 How to install Xcode on macOS and Android Studio on macOS, 
  
 Windows, and Linux
  
 ➤➤
  
 How to configure an editor
  
 ➤➤
  
 How to install the Flutter and Dart plugins
  
 In this chapter, you’ll learn how the Flutter framework works behind the scenes. Flutter uses 
 widgets to create the user interface (UI), and Dart is the language used to develop the applica-
 tions. Once you understand how Flutter handles and implements widgets, it will help you in 
 architecting your apps.",NA
INTRODUCING FLUTTER,"Flutter is Google’s portable UI framework for building modern, native, and reactive applications for iOS 
 and Android. Google is also working on Flutter desktop embedding and Flutter for the Web 
 (Hummingbird) and embedded devices (Raspberry Pi, home, automotive, and more). Flutter is an open-
 source project hosted on GitHub with contributions from Google and the community. Flutter uses Dart, 
 a modern object-oriented language that compiles to native ARM code and production-ready JavaScript 
 code. Flutter uses the Skia 2D rendering engine that works with different types of hardware and 
 software platforms and is also used by Google Chrome, Chrome OS, Android, Mozilla Firefox, Firefox OS, 
 and others. Skia is sponsored and managed by Google and is available for any-one to use under the BSD 
 Free Software License. Skia uses a CPU-based path render and also sup-ports the OpenGL ES2-
 accelerated backend.
  
 Dart is the language that you’ll use to develop your Flutter applications, and you’ll learn more about it 
 in Chapter 3, “Learning Dart Basics.” Dart is ahead-of-time (AOT) compiled to native code, making your 
 Flutter application fast. Dart is also just-in-time (JIT) compiled, making it fast to display your code 
 changes such as via Flutter’s stateful hot reload feature.
  
 Flutter uses Dart to create your user interface, removing the need to use separate languages like 
 Markup or visual designers. Flutter is declarative; in other words, Flutter builds the UI to reflect the 
 state of the app. When the state (data) changes, the UI is redrawn, and Flutter constructs a new instance 
 of the widget. In the “Understanding the Widget Tree and the Element Tree” section of this chapter, 
 you’ll learn how widgets are configured and mounted (rendered) creating the widget tree and element 
 tree, but under the hood, the render tree (a third tree) uses the 
 RenderObject
 , which com-putes and 
 implements the basic layout and paint protocols. (You won’t need to interact directly with the render 
 tree or the 
 RenderObject
 , and I won’t discuss them further in this book.)
  
 Flutter is fast, and the rendering runs at 60 frames per second (fps) and 120fps for capable devices. 
 The higher the fps, the smoother the animations and transitions.
  
 Applications made in Flutter are built from a single codebase, are compiled to native ARM code, use the 
 graphics processing unit (GPU), and can access specific iOS and Android APIs (like GPS location, image 
 library) by communicating via platform channels. You’ll learn more about platform channels in Chapter 
 12, “Writing Platform-Native Code.”
  
 Flutter provides the developer with tools to create beautiful and professional-looking applications and 
 with the ability to customize any aspect of the application. You’ll be able to add smooth anima-tions, 
 gesture detection, and splash feedback behavior to the UI. Flutter applications result in native 
 performance for both iOS and Android platforms. During development, Flutter uses hot reload to 
 refresh the running application in milliseconds when you change the source code to add new features 
 or modify existing ones. Using hot reload is a great way to see the changes you make to your code on the 
 simulator or device while keeping the application’s state, the data values, on the screen.",NA
Defining Widgets and Elements,"The Flutter UI is implemented by using widgets from a modern reactive framework. Flutter uses its 
 own rendering engine to draw widgets. In Chapter 5, “Understanding the Widget Tree,” you’ll get an 
 introduction to widgets, and in Chapter 6, “Using Common Widgets,” you’ll learn how to imple-ment 
 widgets.
  
 You might be asking, what is a widget? Widgets can be compared to LEGO blocks; by adding blocks 
 together, you create an object, and by adding different kinds of blocks, you can alter the look and 
 behavior of the object. Widgets are the building blocks of a Flutter app, and each widget is an immu-
 table declaration of the user interface. In other words, widgets are configurations (instructions) for 
 different parts of the UI. Placing the widgets together creates the widget tree. For example, say an 
 architect draws a blueprint of a house; all of the objects like walls, windows, and doors in the house are 
 the widgets, and all of them work together to create the house or, in this case, the application.
  
 Since widgets are the configuration pieces of the UI and together they create the widget tree, how 
 does Flutter use these configurations? Flutter uses the widget as the configuration to build each ele-
 ment, which means the element is the widget that is mounted (rendered) on the screen. The elements 
 that are mounted on the screen create the element tree. You’ll learn more about the widget tree and 
 element tree in the next section, “Understanding the Widget Tree and the Element Tree.” You’ll also 
 learn to manipulate the widget tree in detail in Chapter 5.
  
 Here’s a brief look at the wide array of widgets at your disposal:
  
 ➤➤
  
 Widgets with structuring elements such as a list, grid, text, and button
  
 ➤➤
  
 Widgets with input elements such as a form, form fields, and keyboard listeners
  
 ➤➤
  
 Widgets with styling elements such as font type, size, weight, color, border, and shadow
  
 ➤➤
  
 Widgets to lay out the UI such as row, column, stack, centering, and padding
  
 ➤➤
  
 Widgets with interactive elements that respond to touch, gestures, dragging, and dismissible
  
 ➤➤
  
 Widgets with animation and motion elements such as hero animation, animated container, 
  
 animated crossfade, fade transition, rotation, scale, size, slide, and opacity
  
 ➤➤
  
 Widgets with elements like assets, images, and icons
  
 ➤➤
  
 Widgets that can be nested together to create the UI needed
  
 ➤➤
  
 Custom widgets you can create yourself",NA
UNDERSTANDING WIDGET LIFECYCLE EVENTS,"In programming, you have different lifecycle events that usually happen in a linear mode, one after 
 another as each stage is completed. In this section, you’ll learn the widget lifecycle events and their 
 purpose.
  
 To build the UI, you use two main types of widgets, 
 StatelessWidget
  and 
 StatefulWidget
 . A 
 stateless widget is used when the values (state) do not change, and the stateful widget is used when",NA
The StatelessWidget Lifecycle,"A 
 StatelessWidget
  is built based on its own configuration and does not 
 change dynamically. For example, the screen displays an image with a 
 description and will not change. The stateless widget is declared with one 
 class, and you’ll learn about classes in Chapter 3. The 
 build
  (the UI 
 portions) method of the stateless widget can be called from three different 
 scenarios. It can be called the first time the widget is created, when the 
 widget’s parent changes, and when an 
 InheritedWidget
  has changed. In 
 Chapter 15, “Adding State Management to the Firestore Client App,” you’ll 
 learn how to implement the 
 InheritedWidget
 .
  
  
 StatelessWidget 
 Constructor
  
 build
  
 FIGURE 1.1:
  Stateless-
 Widget lifecycle
  
 The following sample code shows a 
 StatelessWidget
  base structure, 
 and Figure 1.1 displays the widget’s lifecycle.
  
 class JournalList extends StatelessWidget {
  
  @override
  
  Widget build(BuildContext context) {
  
   
  return Container();
  
  } 
  
 }",NA
The StatefulWidget Lifecycle,"A 
 StatefulWidget
  is built based on its own configuration but can change dynamically. For example, 
 the screen displays an icon with a description, but values can change based on the user’s interaction, 
 like choosing a different icon or description. This type of widget has a mutable state that can change 
 over time. The stateful widget is declared with two classes, the 
 StatefulWidget
  class and the 
 State 
 class. The 
 StatefulWidget
  class is rebuilt when the widget’s configuration changes, but the 
 State 
 class can persist (remain), enhancing performance. For example, when the state changes, the widget is 
 rebuilt. If the 
 StatefulWidget
  is removed from the tree and then inserted back into the tree some-
 time in the future, a new 
 State
  object is created. Note that under certain circumstances and restric-
 tions, you can use a 
 GlobalKey
  (unique key across entire app) to reuse (not re-create) the 
 State 
 object; however, global keys are expensive, and unless they’re needed, you might want to consider not 
 using them. You call the 
 setState()
  method to notify the framework that this object has changes, and 
 the widget’s 
 build
  method is called (scheduled). You would set the new state values inside the 
 setState()
  method. In Chapter 2, you’ll learn how to call the 
 setState()
  method.
  
 The following example shows a 
 StatefulWidget
  base structure, and Figure 1.2 displays the widget’s 
 lifecycle. You have two classes, the 
 JournalEdit StatefulWidget
  class and the 
 _Journal-EditState
  class.
  
 class JournalEdit extends StatefulWidget {
  
  @override
  
  _ JournalEditState createState() => _ 
 JournalEditState();",NA
UNDERSTANDING THE WIDGET TREE AND THE ELEMENT TREE,"In the previous section, you learned that widgets contain the instructions to create the UI, and when 
  
 you compose (nest) widgets together, they create the widget tree. The Flutter framework uses the 
  
 widgets as the configurations for each element that is mounted (rendered) on the screen. The mounted",NA
Stateless Widget and Element Trees,"A stateless widget has the configuration to create a stateless element. Each stateless widget has a 
 corresponding stateless element. The Flutter framework calls the 
 createElement
  method (cre-
 ate an instance), and the stateless element is created and mounted to the element tree. In other",NA
Stateful Widget and Element Trees,"A stateful widget has the configuration to create a stateful element. Each stateful widget has a cor-
 responding stateful element. The Flutter framework calls the 
 createElement
  method to create the 
 stateful element, and the stateful element is mounted to the element tree. Since this is a stateful 
 widget, the stateful element requests that the widget create a state object by calling the 
 Stateful-Widget
  class’s 
 createState
  method.
  
 The stateful element now has a reference to the state object and the widget at the given location in the 
 element tree. The stateful element calls the state object widget’s 
 build
  method to check for child 
 widgets, and each child widget creates its own element and is mounted to the element tree. This 
 process results in two trees: the widget tree and the element tree. Note that if a child widget display-ing 
 the state (journal note) is a stateless widget like the 
 Text
  widget, then the element created for this 
 widget is a stateless element. The state object maintains a reference to the widget (
 StatefulWidget",NA
INSTALLING THE FLUTTER SDK,"Installing the Flutter SDK requires downloading the current version, which is 1.5.4 at the time of 
 writing (your version might be higher), of the SDK from the Flutter website. This chapter includes 
 sections for installing on macOS, Windows, and Linux. (Note that targeting and compiling for the iOS 
 platform requires a Mac computer and Xcode, Apple’s development environment). Do not get 
 discouraged by the number of steps; you’ll do this the first time you install only.
  
 You’ll be using the Terminal window to run installation and configuration commands.",NA
Installing on macOS,"Before starting the installation, you need to make sure your Mac supports the minimum hardware 
 and software requirements.
  
 System Requirements
  
 ➤➤
  
 macOS (64-bit)
  
 ➤➤
  
 700 MB of disk space (does not include disk space for the integrated development environ-
  
 ment and other tools)
  
 ➤➤
  
 The following command-line tools:
  
 ➤➤
  
 Bash
  
 ➤➤
  
 mkdir
  
 ➤➤
  
 rm
  
 ➤➤
  
 git
  
 ➤➤
  
 curl
  
 ➤➤
  
 unzip
  
 ➤➤
  
 which
  
 Get the Flutter SDK
  
 The latest installation details are available online on the Flutter website at 
 https://flutter 
 .dev/docs/get-started/install/macos/
 . Execute steps 2 and following from your Mac’s 
 Terminal window.
  
 1. 
  
 Download the following installation file to get the latest release, v1.7.8 (your version might 
 be higher), of the Flutter SDK:
  
 https://storage.googleapis.com/flutter_infra/releases/stable/macos/ 
 flutter_macos_v1.7.8+hotfix.4-stable.zip
 .
  
 2. 
  
 Extract the file in the desired location by using the Terminal window.
  
 cd ~/development 
  
 unzip 
 ~/Downloads/flutter_macos_v1.7.8+hotfix.4-stable.zip",NA
Installing on Windows ,"Before starting the installation, you need to make sure your Windows supports the minimum hard-
 ware and software requirements.
  
 System Requirements
  
  
 ➤➤
  
 Windows 7 SP1 or later (64-bit)
  
  
 ➤➤
  
 400 MB of disk space (does not include disk space for an integrated development environ-
  
  
 ment and other tools)
  
  
 ➤➤
  
 The following command-line tools:
  
 ➤➤
  
 PowerShell 5.0 or newer
  
 ➤➤
  
 Git for Windows (
 Git
  from the Windows Command Prompt)",NA
Installing on Linux ,"Before starting the installation, you need to make sure your Linux supports the minimum hardware 
 and software requirements.
  
 System Requirements
  
  
 ➤➤
  
 Linux (64-bit)
  
  
 ➤➤
  
 600 MB of disk space (does not include disk space for an integrated development environ-
  
  
 ment and other tools)
  
  
 ➤➤
  
 The following command-line tools:
  
  
  
  
 ➤➤
  
 Bash
  
  
  
  
 ➤➤
  
 curl
  
  
  
  
 ➤➤
  
 git 2.x",NA
CONFIGURING THE ANDROID STUDIO EDITOR,"The editor you’ll be using is Android Studio. Android Studio is the official integrated development 
 environment for Google’s Android operating system and is specifically designed for Android develop-
 ment. It’s also a great development environment for developing apps with Flutter. Before starting to 
 build an app, the editor needs the Flutter and Dart plugins installed to make it easier to write code. 
 (Other editors that support these plugins are IntelliJ or Visual Studio Code.) The editor plugins give 
 code completion, syntax highlighting, run and debug support, and more. Using a plain-text editor to 
 write your code without any plugins would also work, but without the use of plugin features is not 
 recommended.
  
 Instructions for setting up different code editors are available at 
 https://flutter.dev/docs/ 
 get-started/editor/
 . To support Flutter development, install the following plugins:
  
 ➤➤
  
 Flutter plugin for developer workflows such as running, debugging, and hot reload
  
 ➤➤
  
 Dart plugin for code analysis such as instant code validation and code completion
  
 Follow these steps to install the Flutter and Dart plugins:
  
 1. 
  
 2. 
  
 3. 
  
 4. 
  
 5. 
  
 Start Android Studio.
  
 Click Preferences 
 ➪
  Plugins (on macOS) or File 
 ➪
  Settings 
 ➪
  Plugins (on Windows 
 and Linux).
  
 Click Browse Repositories, select the Flutter plug-in, and click the Install button. 
 Click Yes when prompted to install the Dart plugin.
  
 Click Restart when prompted.",NA
SUMMARY,"In this chapter, you learned how the Flutter framework architecture works behind the scenes. You 
 learned that Flutter is a great portable UI framework to build mobile applications for iOS and Android. 
 Flutter also plans on supporting development for desktop, web, and embedded devices. You learned 
 that Flutter applications are built from a single codebase that uses widgets to create the UI and that you 
 develop with the Dart language. You learned that Flutter uses the Skia 2D rendering engine that works 
 with different types of hardware and software.
  
 You learned that the Dart language is AOT compiled to native code, resulting in fast performance for 
 your applications. You learned that Dart is JIT compiled, making it fast to display code changes with 
 Flutter’s stateful hot reload.
  
 You learned that widgets are the building blocks for composing the UI, and each widget is an immu-
 table declaration of the UI. Widgets are the configuration to create elements. Elements are the widgets 
 made concrete, meaning mounted and painted on the screen. You learned that the 
 RenderObject 
 implements the basic layout and paint protocols.",NA
2 ,NA,NA
Creating a Hello World App,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to create a new Flutter mobile app 
  
 How to refresh the running app with hot reload 
 How to style the app with themes 
  
 When to use a stateless or stateful widget 
  
 How to add external packages
  
 A great way to learn a new development language is to write a basic app. In programming, Hello 
 World is the most basic program to write. It simply displays the words 
 Hello World
  on the screen. 
 In this chapter, you’ll learn the main steps of how to develop this basic program as a Flutter app. 
 Do not worry about understanding the code yet; I’ll walk you through it step-by-step later in this 
 book.
  
 Writing this minimal example helps you learn the basic structure of a Flutter app, how to run the 
 app on the iOS simulator and the Android emulator, and how to make changes to the code.",NA
SETTING UP THE PROJECT,"The initial project setup for each app is the same. I’m using Android Studio to create the sample 
 apps in this book, but you can choose a different editor such as IntelliJ or Visual Studio Code. 
  
 An overview of the process in Android Studio is as follows: you create a new Flutter project, 
 select the Flutter application as the project type (template), and enter the project name. The 
 Flutter software development kit (SDK) then creates the project for you, including creating a 
 project directory with the same name as the project name. Within the project directory, the 
 lib 
 folder contains the 
 main.dart
  file with the source code (in other words, 
 project_name/lib/ 
 main.dart
 ). You’ll also have an 
 android
  folder for the Android app, the 
 ios
  folder for the iOS 
 app, and a 
 test
  folder for unit testing.",NA
USING HOT RELOAD,"Flutter’s hot reload helps you see code and user interface changes immediately while retaining state to 
 an app running the Dart virtual machine. In other words, every time you make code changes, you don’t 
 need to reload the app, because the current page shows the changes immediately. This is an incredible 
 time-saving feature for any developer.
  
 In Flutter, the 
 State
  class stores mutable (changeable) data. For example, the app starts with the 
 counter value set to zero, but each time you tap the + button, the counter value increases by one. When 
 the + button is tapped three times, the counter value shows a value of three. The counter value is 
 mutable, so it can change over time. By using hot reload, you can make code logic changes, and the 
 app’s counter state (value) does not reset to zero but instead retains the current value of three.
  
 TRY IT OUT 
  
 Running the App
  
 To see how hot reload works, you’ll start the emulator/simulator, make changes to the page title, save 
 them, and see the changes happen immediately.
  
 From Chapter 1, the iOS simulator was automatically created when you installed Xcode, and you manu-ally 
 created the Android emulator. The iOS simulator is available only if running Android Studio on a Mac 
 computer because it requires Apple’s Xcode to be installed. It’s assumed that you have both the iOS 
 simulator and Android emulator installed. If not, use the Android emulator.
  
 1. 
  
 From Android Studio, click the Flutter device selection button on the right of the toolbar. A 
 drop-down list shows the available iOS simulator and Android emulator.
  
  
 2. 
  
 Select either the iOS simulator or the Android emulator.
  
 3. 
  
 Click the Run icon in the toolbar.",NA
USING THEMES TO STYLE YOUR APP,"The theme widgets are a great way to style and define global colors and font styles for your app. 
  
 There are two ways to use theme widgets—to style the look and feel globally or to style just a por-tion 
 of the app. For instance, you can use themes to style the color brightness (light text on a dark 
 background or vice versa); the primary and accent colors; the canvas color; and the color of app bars, 
 cards, dividers, selected and unselected options, buttons, hints, errors, text, icons, and so on. The beauty 
 of Flutter is that most items are widgets, and just about everything is customizable. In fact, customizing 
 the 
 ThemeData
  class allows you to change the color and typography of widgets. (You’ll learn more 
 about widgets in detail in Chapter 5, “Understanding the Widget Tree,” and Chapter 6, “Using Common 
 Widgets.”)",NA
Using a Global App Theme,"Let’s take the new 
 ch2_my_counter
  app and modify the primary color. The current color is blue, so 
 let’s change it to light green. Add a new line below the 
 primarySwatch
  and add code to change the 
 background color (
 canvasColor
 ) to 
 lightGreen
 .
  
 primarySwatch: Colors.blue, 
  
 // Change it to 
  
 primarySwatch: Colors.lightGreen, 
  
 canvasColor: 
 Colors.lightGreen.shade100,
  
 Save by pressing 
  (in Windows 
 ). Hot reload is invoked, so the app bar and the canvas are now 
 both a light shade of green.
  
 To show a little Flutter awesomeness, add a 
 platform
  property of 
 TargetPlatform.iOS
  after the 
 canvasColor
  property, and run the app from the Android emulator. Suddenly, the iOS traits are run-
 ning on Android. The app bar’s title is not left aligned but changed to the center, which is the custom-
 ary iOS style (Figure 2.1).
  
 primarySwatch: Colors.blue, 
  
 // Change it to 
  
 primarySwatch: Colors.lightGreen, 
  
 canvasColor: 
 Colors.lightGreen.shade100, 
  
 platform: TargetPlatform.iOS
  
 This can be done in reverse by using 
 TargetPlatform
 . Specifically, to show Android traits on iOS, 
 change the 
 platform
  property to 
 TargetPlatform.android
  and run the app from the iOS simula-tor. 
 The app bar’s title is not center aligned but has changed to be left aligned, which is the customary 
 Android style (Figure 2.2). Once navigation with multiple pages is implemented, this will be even more 
 apparent. In iOS when navigating to a new page, you usually slide the next page from the right side of 
 the screen towards the left. In Android when navigating to a new page, you usually slide the next page 
 from bottom to top. 
 TargetPlatform
  has three choices: Android, Fuchsia (the operating system under 
 development from Google), and iOS. 
  
 primarySwatch: Colors.blue, 
  
 // Change it to 
  
 primarySwatch: Colors.lightGreen, 
  
 canvasColor:",NA
Using a Theme for Part of an App,"To override the app-wide theme, you can wrap widgets in a 
 Theme
  widget. This method will com-
 pletely override the app 
 ThemeData
  instance without inheriting any styles.
  
 In the previous section, you changed 
 primarySwatch
  and 
 canvasColor
  to 
 lightGreen
 , which affected 
 all widgets in the app. What if you want only one widget on a page to have a different color scheme and 
 the rest of the widgets to use the default global app theme? You override the default theme with a 
 Theme
  widget that uses the 
 data
  property to customize 
 ThemeData
  (such as 
 card-Color
 , 
 primaryColor
 , and 
 canvasColor
 ), and the child widget uses the 
 data
  property to customize the 
 colors.
  
 body: Center(
  
  child: Theme(
  
   
  // Unique theme with ThemeData - 
 Overwrite",NA
UNDERSTANDING STATELESS AND STATEFUL WIDGETS,"Flutter widgets are the building blocks for designing the user interface (UI). Widgets are built using a 
 modern react-style framework. The UI is created by nesting widgets together into a 
 widget tree
 .
  
 Flutter’s react-style framework means it observes when the state of a widget changes and then com-
 pares it to the previous state to determine the least number of changes to make. Flutter manages the 
 relationship between the state and the UI and rebuilds only those widgets when the state changes.
  
 In this section, you’ll compare stateless and stateful widgets and learn how to implement each class and 
 most importantly which one to use depending on the requirement. In later chapters, you’ll create apps 
 for each scenario. The appropriate class is extended (making it a subclass) by using the keyword 
 extends
  followed by either 
 StatelessWidget
  or 
 StatefulWidget
 .
  
 StatelessWidget
  is used when data does not change, and it relies on the initial information. It’s a 
 widget without state, and the values are final. Some examples are 
 Text
 , 
 Button
 , 
 Icon
 , and 
 Image
 .
  
 class Instructions extends StatelessWidget {
  
  @override
  
  Widget build(BuildContext context) {
  
   
  return Text('When using a 
 StatelessWidget...'); } 
  
 }
  
 StatefulWidget
  is used when data changes. It’s a widget with state that might change over time, 
 requiring two classes. For changes to propagate to the UI, making a call to the 
 setState()
  method is 
 necessary.
  
 ➤➤
  
 StatefulWidget
  class—This creates an instance of the 
 State
  class.
  
 ➤➤
  
 State
  class—This is for data that can be read synchronously when the widget is built and 
  
 might change over time.
  
 ➤➤
  
 setState()
 —From within the 
 State
  class, you make a call to the 
 setState()
  method to 
  
 refresh changed data, telling the framework that the widget should redraw because the state 
  
 has changed. For all the variables that need changes, modify the values in 
 setState(() { 
  
 _ myValue += 50.0;})
 . Any variable values modified outside the 
 setState()
  method will 
  
 not refresh the UI. Therefore, it is best to place calculations that do not need state changes 
  
 outside the 
 setState()
  method.
  
 Consider the example of a page that shows your maximum bid on a product. Every time the Increase Bid 
 button is tapped, your bid increases by $50.  You begin by creating a 
 MaximumBid
  class that extends the 
 StatefulWidget
  class. Create a 
 _MaximumBidState
  class that extends the state of the 
 MaximumBid
  
 class.
  
 In the 
 _MaximumBidState
  class, you declare a variable named 
 _maxBid
 . The 
 _increaseMyMaxBid() 
 method calls the 
 setState()
  method, which increments the 
 _maxBid
  value by $50. The UI consists",NA
USING EXTERNAL PACKAGES,"Sometimes it’s not worth building a widget from scratch. Flutter supports third-party packages for the 
 Flutter and Dart ecosystems. Packages contain the source code logic and are easily shared. There are 
 two types of packages, Dart and plugin. 
  
 ➤➤
  
 Dart packages are written in Dart and may contain Flutter-specific dependencies.
  
 ➤➤
  
 Plugin packages are written in Dart (with the Dart code exposing the API) but are combined 
  
 with platform-specific code implementations for Android (Java or Kotlin) and/or iOS 
  
 (Objective-C or Swift). Most plugin packages aim to support both Android and iOS.",NA
Searching for Packages,"In the app, say you need to store the user preferences on both iOS and Android and want to find a 
 package to do that for you. 
  
 1. 
  
 2. 
  
 3. 
  
 4. 
  
 Start your web browser and navigate to 
 https://pub.dartlang.org/flutter
 . Packages 
 are published at this location often by other developers and Google.
  
 Click the Search Flutter Packages search bar. Enter 
 shared preferences
 , and the results will be 
 sorted by relevance.
  
 Click the link for the 
 shared_preferences
  package. (The direct link is 
 https://pub.dart-
 lang.org/packages/shared_preferences
 .)
  
 Details on how to install and use the 
 shared_preferences
  package are available at this 
 location. The Flutter team authors this particular package. Click the Installing tab for 
  
 detailed instructions. Each package has instructions on how to install and use it. Most of the 
 packages’ installation is similar, but they differ on how to use and implement the code. The 
 instructions are located on the home page of each package.
  
 TRY IT OUT 
  
 Installing Packages
  
 You’ve learned how to find third-party packages. Next you’ll learn how to implement the 
 shared_pref-
 erences
  external package in your app.
  
 1. 
 2. 
 3. 
  
 4. 
  
 Open the 
 ch2_my_counter
  app with Android Studio.
  
 Open the 
 pubspec.yaml
  file by double-clicking.
  
 In the 
 dependencies:
  section, add 
 shared_preferences: ^0.5.1+1
 . (Your version might be 
 higher.) 
  
 Save the file, and the package will install. If you do not see the process automatically run, you can 
 manually invoke it by entering 
 flutter packages get
  in your Terminal window in Android 
  
 Studio. Once finished, the message will say 
 Process finished with exit code 0
 .",NA
Using Packages,"Each package has its unique way of being implemented. It’s always good to read the documentation. 
 For the 
 shared_preferences
  package, you need to add a few lines to implement it. Please remember 
 the main point here is not how to use this package but how to add external packages to your app in 
 general.
  
 TRY IT OUT 
  
 Implementing and Initializing a Package
  
 In the 
 _MyHomePageState
  class, add a function called 
 _updateSharedPreferences()
 . 
  
 class _MyHomePageState extends State<MyHomePage> 
 { // ...
  
  void _updateSharedPreferences() async {
  
  SharedPreferences prefs = await",NA
SUMMARY,"In this chapter, you learned how to create your first app and use hot reload to view changes instanta-
 neously. You also saw how to use themes to style apps, when to use stateless and stateful widgets, and 
 how to add external packages to save yourself from reinventing the wheel. You now have a general 
 understanding of the main ideas behind Flutter app development. Do not worry about understanding 
 the actual code yet. You’ll learn all about it throughout the book.
  
 In the next chapter, you’ll learn the basics of the Dart language that is used to create Flutter apps.",NA
3 ,NA,NA
Learning Dart Basics,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 Why you use Dart 
  
 How to comment code 
  
 How to use the top-level 
 main()
  function 
  
 How to reference variables such as numbers, strings, Booleans, lists, 
  
 maps, and runes
  
 ➤➤
  
 How common flow statements (such as 
 if
 , 
 for
 , 
 while
 , and the ternary operator), 
  
 loops, and 
 switch
  and 
 case
  work
  
 ➤➤
  
 How functions are used to group reusable logic
  
 ➤➤
  
 How to use the 
 import
  statement for external packages, libraries or classes
  
 ➤➤
  
 How to create classes
  
 ➤➤
  
 How to use asynchronous programming to avoid blocking the user interface
  
 Dart is the foundation of learning to develop Flutter projects. In this chapter, you’ll start 
 understanding Dart’s basic structure. In future chapters, you’ll create apps that implement these 
 concepts. All the sample code is in the 
 ch3_dart_basics
  folder. (In the sample code, don’t worry 
 about how it’s laid out; just take a look so you can see how Dart code is written. Tap the floating 
 action button located on the bottom right to see log results.)",NA
WHY USE DART?,"Before you can start developing Flutter apps, you need to understand the programming lan-
 guage used, namely, Dart. Google created Dart and uses it internally with some of its big 
 products such as Google AdWords. Made available publicly in 2011, Dart is used to build",NA
COMMENTING CODE,"In any app, comments help the readability of the code, as long as they’re not overdone. Comments 
 can be used to describe the logic and dependencies of the app.
  
 There are three types of comments: single-line, multiline, and documentation comments. Single-line 
 comments are commonly used to add a short description. Multiline comments are best suited for long 
 descriptions that span multiple lines. Documentation comments are used to fully document a piece of 
 code logic, usually giving detailed explanations and sample code in the comments.
  
 Single-line comments begin with 
 //
 , and the Dart compiler ignores everything to the end of the line.
  
 // Retrieve from the database the list filtered by 
 company _listOrders.get(...
  
 Multiline comments begin with 
 /*
  and end with 
 */
 . The Dart compiler ignores everything between 
 the slashes.
  
 /*
  
  * Allow users to filter by multiple 
 options
  
  _listOrders.get(filterBy: _userFilter...
  
 */
  
 Documentation comments begin with 
 ///
 , and the Dart compiler ignores everything to the end of the 
 line unless enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level",NA
RUNNING THE MAIN() ENTRY POINT,"Every app must have a top-level 
 main()
  function, which is the entry point to the app. The 
 main() 
 function is where the app execution starts and returns a 
 void
  with an optional 
 List<String>
  param-
 eter for arguments. Each function can return a value, and for the 
 main()
  function the data return type is 
 a 
 void
  (empty, contains nothing), meaning that it does not return a value.
  
 In the following code, you see three different ways to use the 
 main()
  function, but in all the exam-ple 
 projects in this book, you will be using the first example—the arrow syntax 
 void main() => 
 runApp(MyApp());
 . All three ways to call the 
 main()
  function are acceptable
 ,
  but I prefer using the 
 arrow syntax since it keeps the code on one line for better readability. However, the main reason to use 
 the arrow syntax is that in all the example projects there is no need to call multiple statements. The 
 arrow syntax 
 => runApp(MyApp())
  is the same as 
 { runApp(MyApp()); }
 . 
  
 // arrow syntax 
  
 void main()
  => 
 runApp(MyApp());
  
 // or 
  
 void main()
  {
  
  
  runApp(MyApp()); 
  
 }
  
 // or with a List of Strings 
 parameters 
  
 void main(List<Strings> filters) {
  
  
  print('filters: $filters'); 
  
 }",NA
REFERENCING VARIABLES,"In the previous section
 ,
  you learned that 
 main()
  is the top-level entry to an app
 ,
  and before you start 
 writing code
 ,
  it’s important to learn about Dart variables. Variables store 
 references
  to a value. Some of 
 the built-in variable types are numbers, strings, Booleans, lists, maps, and runes. You can use 
 var
  to 
 declare (you will learn declaring variables in the next section) a variable without specifying the type. 
 Dart infers the type of variable automatically. Although there is nothing wrong with using 
 var
 , as a 
 personal preference, I usually stay away from using it unless I need to do so. Declaring the",NA
DECLARING VARIABLES,"Now you know that variables store references to a value. Next, you’ll learn different options for 
 declaring variables.
  
 In Dart, all variables are declared public (available to all) by default, but by starting the variable name 
 with an underscore (
 _
 ), you can declare it as private. By declaring a variable private
 ,
  you are saying it 
 cannot be accessed from outside classes/functions; in other words, it can be used only from within the 
 declaration class/function. (You will learn about classes and functions in the “Functions” and “Classes” 
 sections later in this chapter.) Note some built-in Dart variable types are lowercase like 
 double
  and 
 some uppercase like 
 String
 .
  
 What if the value of a variable doesn’t need to change? Begin the declaration of the variable with 
 final
  or 
 const
 . Use 
 final
  when the value is assigned at runtime (can be changed by the user). Use 
 const
  when the value is known at compile time (in code) and will not change at runtime.
  
 // Declared without specifying the type - Infers 
 type var filter = 'company';
  
 // Declared by type 
  
 String filter = 
 'company';
  
 // Uninitialized variable has an initial value of 
 null String filter;
  
 // Value will not change 
  
 final filter = 'company';
  
 // or 
  
 final String filter = 
 'company';
  
 // or 
  
 const String filter = 'company'; 
  
 // or 
  
 const String filter = 'company' + 
 filterOption;",NA
Numbers,"Declaring variables as numbers restricts the values to numbers only. Dart allows numbers to be 
 int 
 (integer) or 
 double
 . Use the 
 int
  declaration if your numbers do not require decimal point preci-sion, 
 like 10 or 40. Use the 
 double
  declaration if your numbers require decimal point precision, like 50.25 or 
 135.7521. Both 
 int
  and 
 double
  allow for positive and negative numbers, and you can enter extremely 
 large numbers and decimal precision since they both use 64-bit (computer memory) values.
  
 // Integer 
  
 int counter = 0; 
  
 double price = 0.0; 
  
 price = 125.00;",NA
Strings,"Declaring variables as 
 String
  allows values to be entered as a sequence of text characters. To add a 
 single line of characters, you can use single or double quotes like 
 'car'
  or 
 ""car""
 . To add multiline 
 characters, use triple quotes, like 
 ""'car""'
 . Strings can be concatenated (combined) by using the plus 
 (
 +
 ) operator or by using adjacent single or double quotes. 
  
 // Strings 
  
 String defaultMenu = 'main';
  
 // String concatenation 
  
 String combinedName = 'main' + ' ' + 'function'; 
  
 String combinedNameNoPlusSign = 'main' ' ' 
 'function';
  
 // String multi-line 
  
 String multilineAddress = 
 '''
  
  123 Any Street
  
  City, State, Zip 
  
 ''';",NA
Booleans,"Declaring variables as 
 bool
  (Boolean) allows a value of 
 true
  or 
 false
  to be entered. 
  
 // Booleans 
  
 bool isDone = 
 false; 
  
 isDone = true;",NA
Lists,NA,NA
Maps,"Map
 s are invaluable in associating a 
 List
  of values by a 
 Key
  and a 
 Value
 . Mapping allows recalling 
 values by their 
 Key
  ID. The 
 Key
  and 
 Value
  can be any type of object, such as 
 String
 , 
 Number
 , and so on. 
 Keep in mind that the 
 Key
  needs to be unique since the 
 Value
  is retrieved by the 
 Key
 .
  
 // Maps - An object that associates keys and values.
  
 // Key: Value - 'KeyValue': 'Value' 
  
 Map mapOfFilters = {'id1': 'company', 'id2': 'city', 'id3': 
 'state'};
  
 // Change the value of third item with Key of 
 id3 mapOfFilters['id3'] = 'my filter';
  
 print('Get filter with id3: 
 ${mapOfFilters['id3']}'); // Result from print 
 statement 
  
 // Get filter with id3: my filter",NA
Runes,"In Dart, declaring variables as 
 Rune
 s are the UTF-32 code points of a 
 String
 . Emojis, anyone?",NA
USING OPERATORS,"An operator is a symbol used to perform arithmetic, equality, relational, type test, assignment, logical, 
 conditional, and cascade notation. Tables 3.1 through 3.7 go over some of the common operators. 
  
 For the sample code, I use the values directly to simplify the examples instead of using variables.
  
 TABLE 3.1: 
 Arithmetic operators
  
 OPERATOR
  
 DESCRIPTION
  
 SAMPLE CODE
  
 +
  
 Add
  
 7 + 3 = 10
  
 -
  
 Subtract
  
 7 - 3 = 4
  
 *
  
 Multiply
  
 7 * 3 = 21
  
 /
  
 Divide
  
 7 / 3 = 2.33
  
 TABLE 3.2: 
 Equality and relational operators
  
 OPERATOR
  
 DESCRIPTION
  
 SAMPLE CODE
  
 ==
  
 Equal
  
 7 == 3 = false
  
 !=
  
 Not equal
  
 7 != 3 = true
  
 >
  
 Greater than
  
 7 > 3 = true
  
 <
  
 Less than
  
 7 < 3 = false
  
 >=
  
 Greater than or equal to
  
 7 >= 3 = true 
  
 4 >= 4 true
  
 <=
  
 Less than or equal to
  
 7<= 3 = false 
  
 4 <= 4 = true",NA
USING FLOW STATEMENTS,"To control the logic flow of the Dart code, take a look at the following flow statements:
  
 ➤➤
  
 if
  and 
 else
  are the most common flow statements; they decide which code to run by com-
  
 paring multiple scenarios.
  
 ➤➤
  
 The ternary operator is similar to the 
 if
  and 
 else
  statements but used when only two 
  
 choices are needed.
  
 ➤➤
  
 for
  loops allow iterating a 
 List
  of values.
  
 ➤➤
  
 while
  and 
 do-while
  are a common pair. Use the 
 while
  loop to evaluate the condition 
  
 before running the loop, and use 
 do-while
  to evaluate the condition after the loop.
  
 ➤➤
  
 while
  and 
 break
  are useful if you need to stop evaluating the condition in the loop.
  
 ➤➤
  
 continue
  is for when you need to stop the current loop and start the next loop iteration.
  
 ➤➤
  
 switch
  and 
 case
  are alternatives to the 
 if
  and 
 else
  statements, but they require a 
  
 default clause.",NA
if and else,"The 
 if
  statement compares an expression, and if 
 true
 , it executes the code logic. The expression is 
  
 wrapped by open and close parentheses followed by the code logic wrapped in braces. The 
 if
  state-
  
 ment also supports multiple optional 
 else
  statements, which are used to evaluate multiple scenarios. 
  
 There are two types of 
 else
  statements: 
 else if
  and 
 else
 . You can use multiple 
 else if
  state-
  
 ments, but you can have only one 
 else
  statement, usually used as a catchall scenario.",NA
ternary operator,"The ternary operator takes three arguments, and it’s usually used when only two actions are needed. 
 The ternary operator checks the first argument for comparison, the second is the action if the argu-
 ment is 
 true
 , and the third is the action if the argument is 
 false
  (see Table 3.8).
  
 TABLE 3.8: 
 ternary operator
  
 COMPARISON
  
  
 TRUE
  
  
 FALSE
  
 isClosed
  
 ?
  
 askToOpen()
  
 :
  
 askToClose()
  
 This will look familiar to you from the “Operators” section’s conditional expressions because it’s used 
 often to make code flow decisions.
  
 // Shorter way of if and else 
 statement 
  
 isClosed ? askToOpen() : askToClose();",NA
for Loops,"The standard 
 for
  loop allows you to iterate a 
 List
  of values. Values are obtained by restricting the 
 number of loops by a defined length. An example is to loop through the top three values, which means 
 you specify the number of times to execute the loop. Using a 
 List
  of values also allows you to use the 
 for-in
  type of 
 Iteration
 . The 
 Iteration
  class needs to be of type 
 Iterable
  (a collection",NA
while and do-while,"Both the 
 while
  and 
 do-while
  loops evaluate a condition and continue to loop as long as the condi-
 tion returns a value of 
 true
 . The 
 while
  loop evaluates the condition before the loop is executed. The 
 do-while
  loop evaluates the condition after the loop is executed at least once. Let’s look at two 
 examples that show how to use the 
 while
  and 
 do-while
  loops.",NA
while and break,"Using the 
 break
  statement allows you to stop looping by evaluating a condition inside the 
 while
  loop.
  
 In this example, the 
 askToOpen()
  method is called inside the loop by the 
 if
  statement, executing logic 
 that returns a 
 bool
  value of 
 true
  or 
 false
 . As long as the value returned is 
 false
 , the loop continues 
 as normal by calling the 
 checkForNewOrder()
  method. But once 
 askToOpen()
  returns a value of 
 true
 , 
 the 
 break
  statement is executed, stopping the loop. The 
 checkForNewOrder()
  method is not called, 
 and the entire 
 while
  statement stops from running again.
  
 // Break - to stop loop 
  
 while (isClosed) {
  
  
  if (askToOpen()) 
 break;
  
  
  checkForNewOrder(); 
  
 }",NA
continue,"By using the 
 continue
  statement, you can stop at the current loop location and skip to the start of 
 the next loop iteration.
  
 In this example, the 
 for
  statement loops through a 
 List
  of numbers from 10 to 80. Inside the loop, the 
 if
  statement checks whether the number is less than 30 and greater than 50, and if the condition is 
 met, the continue statement stops the current loop and starts the next iteration. Using the 
 print 
 statement, you see that only the numbers 30, 40, and 50 are printed to the log.",NA
switch and case,"The 
 switch
  statement compares integer, string, or compile-time constants using 
 ==
  (equality). The 
 switch
  statement is an alternative to the 
 if
  and 
 else
  statements. The 
 switch
  statement evaluates an 
 expression and uses the 
 case
  clause to match a condition and executes code inside the matching 
 case
 . 
 Each 
 case
  clause ends by placing a 
 break
  statement as the last line. It’s not commonly used, but if you 
 have an empty (no code) 
 case
  clause, the 
 break
  statement is not needed since Dart allows it to fall 
 through. If you need a catchall scenario, you can use the 
 default
  clause to execute code that is not 
 matched by any of the 
 case
  clauses, placed after all the 
 case
  clauses. The 
 default
  clause does not 
 require a 
 break
  statement. Make sure that the last 
 case
  is a 
 default
  clause that executes logic if no 
 previous 
 case
  clause has a match.
  
 In our example, we have the 
 Stringcoffee
  variable initialized to the 
 'espresso'
  value. The 
 switch
  
 statement uses the 
 coffee
  variable expression where each 
 case
  clause needs to match the 
 coffee
  
 variable value. When the 
 case
  clause matches the correct value, the code associated with the clause is 
 executed. If none of the 
 case
  clauses matches the 
 coffee
  variable value, the 
 default
  clause is selected 
 and executes the associated code. 
  
 // switch and case 
  
 String coffee = 'espresso'; 
  
 switch (coffee) {
  
  
  case 'flavored':
  
   
  orderFlavored();
  
   
  break;
  
  
  case 'dark-roast':
  
   
  orderDarkRoast();
  
   
  break;
  
  
  case 'espresso':
  
   
  orderEspresso();
  
   
  break;
  
  
  default:
  
   
  orderNotAvailable(); 
  
 }",NA
USING FUNCTIONS,"Functions are used to group reusable logic. A function can optionally take parameters and return 
 values. I love this feature. Because Dart is an object-oriented language, functions can be assigned to 
 variables or passed as arguments to other functions. If the function executes a single expression, you 
 can use the 
 arrow
  (
 =>
 ) syntax. All functions return a value by default, and if no return statement",NA
IMPORT PACKAGES,"To use an external package, library or an external class, use the 
 import
  statement. Separating code 
 logic into different class files allows you to separate and group code into manageable objects. The 
 import
  statement allows access to external packages and classes. It requires only one argument, 
 which specifies the uniform resource identifier (URI) of the class/library. If the library is created by a 
 package manager, then you specify the 
 package:
  scheme before the URI. If importing a class, you 
 specify the location and class name or the 
 package:
  directive.
  
 // Import the material package 
  
 import 
 'package:flutter/material.dart';
  
 // Import external class 
  
 import 'charts.dart';
  
 // Import external class in a different 
 folder 
  
 import 'services/charts_api.dart';
  
 // Import external class with package: directive 
  
 import 
 'package:project_name/services/charts_api.dart';",NA
USING CLASSES,"All classes descend from 
 Object
 , the base class for all Dart objects. A class has members (variables and 
 methods) and uses a constructor to create an object. If a constructor is not declared, a default construc-
 tor will be provided automatically. The default constructor provided for you has no arguments.
  
 What is a constructor, and why is it needed? A constructor has the same name as the class, with 
 optional parameters. The parameters serve as getters of values when initializing a class for the first 
 time. Dart uses syntactic sugar to make it easy to access values by using the 
 this
  keyword, referring 
 to the current state in the class. 
  
 // Getter 
  
 this.type = 
 type;
  
 // Syntactic Sugar 
  
 this.type;
  
 A basic class with a constructor would have this simple layout:",NA
Class Inheritance,"In programming, inheritance allows objects to share traits. To inherit from other classes, use the 
 extends
  keyword. Use the 
 super
  keyword to refer to the superclass (the parent class). Constructors 
 are not inherited in the subclass.
  
 In this example, you’ll take the previous 
 BaristaNamedConstructor
  class and use inheritance to 
 create a new class that inherits the parent class traits. Declare a new class with the name 
 BaristaIn-
 heritance
  using the 
 extends
  keyword and the name of the class you are extending, which here is 
 BaristaNamedConstructor
 . The inherited class constructor looks just a little bit different than the 
 previous declarations; at the end of the constructor, you add a colon (
 :
 ) and 
 super()
 , referring to the 
 superclass. When the 
 BaristaInheritance
  class is initialized, it inherits the parent class traits, mean-
 ing it can access variables and methods (class functions) from 
 BaristaNamedConstructor
 .
  
 // Class inheritance 
  
 class BaristaInheritance extends BaristaNamedConstructor 
 { int yearsOnTheJob;
  
  BaristaInheritance({this.yearsOnTheJob}) : 
 super(); }
  
 // Init Inherited Class 
  
 BaristaInheritance baristaInheritance = BaristaInheritance(yearsOnTheJob: 
 7); // Assign Parent Class variable 
  
 baristaInheritance.name = 'Sandy'; 
  
 print('baristaInheritance.yearsOnTheJob: 
 ${baristaInheritance.yearsOnTheJob}'); print('baristaInheritance.name: 
 ${baristaInheritance.name}');",NA
Class Mixins,"Mixins are used to add features to a class and allow you to reuse the class code in different classes. In 
 other words the mixins allow you to access class code between unrelated classes. To use a mixin, you 
 add the 
 with
  keyword followed by one or more mixin names. Place the 
 with
  keyword right after the 
 class name declaration. The class that implements a mixin does not declare a constructor. Usually the 
 mixin class is a collection of methods. In Chapter 7, “Adding Animation to an App,” you’ll create two 
 animation apps that use mixins. For example, using 
 AnimationController
  relies on 
 TickerProvider-StateMixin
 .",NA
IMPLEMENTING ASYNCHRONOUS PROGRAMMING,"In a mobile application, you will use a lot of asynchronous, or 
 async
 , programming. Async functions 
 perform time-consuming operations without waiting for the operation to complete. In Dart, to not 
 block the UI, you use functions that return 
 Future
  or 
 Stream
  objects.
  
 A 
 Future
  object represents a value that will be available at some point in the future. For example, 
 calling a web service to retrieve values might be fast or take a long time, and you do not want to stop",NA
SUMMARY,"This chapter covered the basics of the Dart language. You learned how to comment your code for better 
 readability and how to use the 
 main()
  function that starts the app. You learned how to declare 
 variables to reference different kinds of values such as numbers, strings, Booleans, lists, and more. 
  
 You used the 
 List
  to store an array of filters and learned how to iterate through each value. You looked 
 at operator symbols commonly used to perform arithmetic, equality, logical, conditional, and cascade 
 notation. The cascade notation is a powerful operator to make multiple sequence calls on the same 
 object such as scaling and translating (positioning) an object.",NA
4 ,NA,NA
Creating a Starter ,NA,NA
Project Template,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to create folders in the project, grouping them by file types How 
 to separate and structure widgets into different files
  
 In this chapter, you will learn how to create a Flutter starter project and how to structure the 
 widgets. (I’ll cover widgets in depth in the next three chapters.) In future chapters, every time 
 you start a new example, I’ll refer to this chapter, which contains the steps to create a new 
 starter project. Like when building a home, the foundation is the most critical factor, and the 
 same is true when creating new apps.",NA
CREATING AND ORGANIZING FOLDERS AND FILES,"All the example apps created in this book start with the same steps in this chapter for creating a 
 starter project, so I’ll refer to this process often. To keep the project code organized, you’ll cre-ate 
 different folders and files to group similar logic together and to structure the widgets.
  
 TRY IT OUT 
  
 Creating the Folder Structure
  
 Create a new Flutter project by following the steps in Chapter 2, “Creating a Hello World App.” 
  
 1. 
  
 In step 4 of the “Creating a New App” section, enter 
 ch4_starter_exercise
  for the project 
 name and click Next. This app is the sample exercise to structure future projects. Note that 
  
 the Flutter SDK path is the installation folder you have chosen in Chapter 1. You can option-ally 
 change the project location and description.",NA
STRUCTURING WIDGETS,"Before you start developing an app, it’s important to create your structure; like when building a house, 
 the foundation is created first. (In Chapter 5, “Understanding the Widget Tree,” you’ll explore widgets in 
 more detail.) Structuring widgets in an organized manner improves the code’s readability and 
 maintainability. When creating a new Flutter project, the software development kit (SDK) does not 
 automatically create the separate 
 home.dart
  file, which contains the main presentation page when the 
 app starts. Therefore, to have code separation, you must manually create the 
 pages
  folder and the 
 home.dart
  file inside it. The 
 main.dart
  file contains the 
 main()
  function that starts the app and calls 
 the 
 Home
  widget in the 
 home.dart
  file.
  
 TRY IT OUT 
  
 Creating the Dart Files and Widgets
  
 A great way to learn how Flutter works is to start from a blank slate. Delete all the contents of the 
 main. 
 dart
  file. The 
 main.dart
  file has three main sections.
  
 ➤➤
  
 The 
 import
  package/file
  
 ➤➤
  
 The 
 main()
  function
  
 ➤➤
  
 A 
 class
  that extends a 
 StatelessWidget
  widget and returns the app as a widget (like I said before, 
  
 just about everything is a widget)
  
 Note for the import package that you’ll be using Google’s Material Design. All the examples in the book 
 import and use Material Design. In Chapter 2, you learned that Material Design is a system of best-prac-tice 
 guidelines for user interface design. The Material Design components in a Flutter project are 
 visual
 , 
 behavioral
 , and 
 motion
  widgets. Cupertino can also be used to adhere to Apple’s iOS design language that 
 supports iOS-style widgets. You can use both standards in different parts of your app. Right off the bat, 
 Flutter is smart enough to show the native actions in both operating systems without you having to worry 
 about it.
  
 For example, by importing the 
 cupertino.dart
  library, you can mix some of the Cupertino widgets with 
 Material Design. The date and time picker work differently in Android and iOS, and you can specify in the 
 code which widget to show depending on the operating system. However, you’ll need to choose up front 
 either Material Design or Cupertino for the entire look and feel of the app. Why? Well, the base of your app 
 needs to be either a 
 MaterialApp
  widget or a 
 CupertinoApp
  widget because this determines the 
 availability of widgets. In step 3 of this exercise, you’ll learn how to use the 
 MaterialApp
  widget.
  
 Let’s start by adding the code to the 
 main.dart
  file and saving it. 
  
 1. 
  
 Import the package/file. The default import is the 
 material.dart
  library to allow the use of Material 
 Design. (To use the Cupertino iOS-style widgets, you import the 
 cupertino.dart
  library 
  
 instead of 
 material.dart
 . For the apps in this book, I’ll use Material Design.) Then import the 
 home.dart
  page located in the 
 pages
  folder.
  
 import 'package:flutter/material.dart'; 
  
 import 
 'package:ch4_starter_exercise/pages/home.dart';",NA
SUMMARY,"In this chapter, you learned how to create the starter project you’ll use for all future apps in this book. 
 You created folders with the 
 mkdir
  command and named them accordingly to group the logic. You also 
 created two Dart files: 
 main.dart
  for the 
 main()
  function that starts the app and 
 home.dart
  to contain 
 the code for the 
 Home
  widget.
  
 In the next chapter, we analyze the widget tree. Flutter works by nesting widgets together, and we find 
 out quickly that readability and maintainability takes a hit quickly.  We take a look at an example of how 
 to flatten the widget tree.",NA
5 ,NA,NA
Understanding the Widget Tree,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 The 
 fundamentals 
 of 
 widgets 
  
 How to use a full widget tree 
  
 How to use a shallow widget tree
  
 The 
 widgettree
  is how you  create your UI; you position widgets within each other to build 
 simple and complex layouts. Since just about everything in the Flutter framework is a widget, 
 and as you start nesting them, the code can become harder to follow. A good practice is to try to 
 keep the widget tree as shallow as possible. To understand the full effects of a deep tree, you’ll 
 look at a 
 fullwidgettree
  and then refactor it into a 
 shallowwidgettree,
  making the code 
 more manageable. You’ll learn three ways to create a shallow widget tree by refactor-ing: with a 
 constant, with a method, and with a widget class.",NA
INTRODUCTION TO WIDGETS,"Before analyzing the widget tree, let’s look at the short list of widgets that you will use for this 
 chapter’s example apps. At this point, do not worry about understanding the functionality for 
 each widget; just focus on what happens when you nest widgets and how you can separate them 
 into smaller sections. In Chapter 6, “Using Common Widgets,” you’ll take a deeper look at using 
 the most common widgets by functionality.
  
 As I mentioned in Chapter 4, “Creating a Starter Project Template,” this book uses Material 
 Design for all the examples. The following are the widgets (usable only with Material Design) 
 that you’ll use to create the full and shallow widget tree projects for this chapter:
  
 ➤➤
  
 Scaffold
 —Implements the Material Design visual layout, allowing the use of Flutter’s 
  
 Material Components widgets
  
 ➤➤
  
 AppBar
 —Implements the toolbar at the top of the screen",NA
BUILDING THE FULL WIDGET TREE,"To show how a widget tree can start to expand quickly, you’ll use a combination of 
 Column
 , 
 Row
 , 
 Container
 , 
 CircleAvatar
 , 
 Divider
 , 
 Padding
 , and 
 Text
  widgets. You’ll take a closer look at these 
 widgets in Chapter 6. The code that you’ll write is a simple example, and you can immediately see how 
 the widget tree can grow quickly (Figure 5.1).
  
 FIGURE 5.1:
  Full widget tree view",NA
BUILDING A SHALLOW WIDGET TREE,"To make the example code more readable and maintainable, you’ll refactor major sections of the code 
 into separate entities. You have multiple refactor options, and the most common techniques are 
 constants, methods, and widget classes.",NA
Refactoring with a Constant,"Refactoring with a constant initializes the widget to a 
 final
  variable. This approach allows you to 
 separate widgets into sections, making for better code readability. When widgets are initialized with a 
 constant, they rely on the 
 BuildContext
  object of the parent widget.
  
 What does this mean? Every time the parent widget is redrawn, all the constants will also redraw their 
 widgets, so you can’t do any performance optimization. In the next section, you’ll take a detailed look at 
 refactoring with a method instead of a constant. The benefits of making the widget tree shal-lower are 
 similar with both techniques.
  
 The following sample code shows how to use a constant to initialize the 
 container
  variable as 
 final 
 with the 
 Container
  widget. You insert the 
 container
  variable in the widget tree where needed.
  
 final container = 
 Container(
  
  color: Colors.yellow,
  
  height: 40.0,
  
  width: 40.0, 
  
 );",NA
Refactoring with a Method,"Refactoring with a method returns the widget by calling the method name. The method can return a 
 value by a general widget (
 Widget
 ) or a specific widget (
 Container
 , 
 Row
 , and others).
  
 The widgets initialized by a method rely on the 
 BuildContext
  object of the parent widget. There 
 could be unwanted side effects if these kinds of methods are nested and call other nested methods/ 
 functions. Since each situation is different, do not assume that using methods is not a good choice. 
 This approach allows you to separate widgets into sections, making for better code readability. How-
 ever, like when refactoring with a constant, every time the parent widget is redrawn, all the methods 
 will also redraw their widgets. That means the widget tree is not optimizable for performance.
  
 The following sample code shows how to use a method to return a 
 Container
  widget. This first 
 method returns the 
 Container
  widget as a general 
 Widget
 , and the second method returns the 
 Container
  widget as a 
 Container
  widget. Both approaches are acceptable. You insert the 
 _buildContainer()
  method name in the widget tree where needed.
  
 // Return by general Widget 
 Name 
  
 Widget _buildContainer() {
  
  return Container(
  
   
  color: Colors.yellow,
  
   
  height: 40.0,
  
   
  width: 40.0,
  
  ); 
  
 }
  
 // Or Return by specific Widget like Container in this 
 case Container _buildContainer() {
  
  return Container(
  
   
  color: Colors.yellow,
  
   
  height: 40.0,",NA
Refactoring with a Widget Class,"Refactoring with a widget class allows you to create the widget by subclassing the 
 StatelessWidget 
 class. You can create reusable widgets within the current or separate Dart file and initiate them 
 anywhere in the application. Notice that the constructor starts with a 
 const
  keyword, which allows you 
 to cache and reuse the widget. When calling the constructor to initiate the widget, use the 
 const",NA
SUMMARY,"In this chapter, you learned that the widget tree is the result of nested widgets. As the number of 
 widgets increases, the widget tree expands quickly and lessens code readability and manageability. I 
 call this the 
 full
  widget tree. To improve code readability and manageability, you can separate wid-
 gets into their own widget class, creating a shallower widget tree. In each app, you should strive to 
 keep the widget tree shallow.
  
 By refactoring with a widget class, you can take advantage of Flutter’s subtree rebuilding, which 
 improves performance.
  
 In the next chapter, you’ll look at using basic widgets. You’ll learn how to implement different types of 
 buttons, images, icons, decorators, forms with text field validation and orientation.",NA
PART II ,NA,NA
Intermediate Flutter: Fleshing ,NA,NA
Out an App,"▸
  CHAPTER 6:
  Using Common Widgets
  
 ▸
  CHAPTER 7:
  Adding Animation to an App
  
 ▸
  CHAPTER 8:
  Creating an App’s Navigation
  
 ▸
  CHAPTER 9:
  Creating Scrolling Lists and Effects▸
  
 CHAPTER 10:
  Building Layouts
  
 ▸
  CHAPTER 11:
  Applying Interactivity
  
 ▸
  CHAPTER 12:
  Writing Platform-Native Code",NA
6 ,NA,NA
Using Common Widgets,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤➤
  
 How to use basic widgets such as 
 Scaffold
 , 
 AppBar
 , 
 SafeArea
 , 
 Container
 , 
 Text
 , 
  
 RichText
 , 
 Column
 , and 
 Row
 , as well as different types of buttons
  
 ➤➤
  
 How to nest the Column and Row widgets together to create different UI layouts
  
 ➤➤
  
 Ways to include images, icons, and decorators
  
 ➤➤
  
 How to use text field widgets to retrieve, validate, and manipulate data
  
 ➤➤
  
 How to check your app’s orientation
  
 In this chapter, you’ll learn how to use the most common widgets. I call them our base building 
 blocks for creating beautiful UIs and UXs. You’ll learn how to load images locally or over the Web 
 via a uniform resource locator (URL), use the included rich Material Components icons, and 
 apply decorators to enhance the look and feel of widgets or use them as input guides to entry 
 fields. You’ll also explore how to take advantage of the 
 Form
  widget to validate text field entry 
 widgets as a group, not just individually. Additionally, to account for the variety of device sizes, 
 you’ll see how using the 
 MediaQuery
  or 
 OrientationBuilder
  widget is a great way to detect 
 orientation—because using the device orientation and layout widgets accordingly based on 
 portrait or landscape is extremely important. For example, if the device is in portrait mode, you 
 can show a row of three images, but when the device is turned to landscape mode, you can show 
 a row of five images since the width is a larger area than in portrait mode.",NA
USING BASIC WIDGETS,"When building a mobile app, you’ll usually implement certain widgets for the base structure. 
 Being familiar with them is necessary.",NA
SafeArea,"The 
 SafeArea
  widget is a must for today’s devices such as the iPhone X or Android devices with a notch 
 (a partial cut-out obscuring the screen usually located on the top portion of the device). The 
 SafeArea
  
 widget automatically adds sufficient padding to the child widget to avoid intrusions by the operating 
 system. You can optionally pass minimum padding or a Boolean value to not enforce pad-ding on the 
 top, bottom, left, or right.
  
 TRY IT OUT 
  
 Adding a SafeArea to the Body
  
 Continue modifying the 
 home.dart
  file.
  
 Add a 
 Padding
  widget to the 
 body
  property with a 
 SafeArea
  as a 
 child
 . Because this example packs in 
 different uses of widgets, add a 
 SingleChildScrollView
  as a 
 child
  of the 
 SafeArea
 . The 
 Single-ChildScrollView
  allows the user to scroll and view hidden widgets; otherwise, the user sees a 
 yellow and black bar conveying that the widgets are overflowing.
  
 body: Padding(
  
  padding: EdgeInsets.all(16.0),",NA
Container,"The 
 Container
  widget has an optional 
 child
  widget property and can be used as a decorated widget 
 with a custom border, color, constraint, alignment, transform (such as rotating the widget), and more. 
 This widget can be utilized as an empty placeholder (invisible), and if a child is omitted, it sizes to the 
 full available screen size.",NA
Text,"You’ve already used the 
 Text
  widget in the preceding examples; it’s an easy widget to use but also 
 customizable. The 
 Text
  constructor takes the arguments 
 string
 , 
 style
 , 
 maxLines
 , 
 overflow
 , 
 text-Align
 , and others.
  
 Text(
  
  'Flutter World for Mobile',
  
  style: TextStyle(
  
   
  fontSize: 24.0,
  
   
  color: Colors.deepPurple,
  
   
  decoration: TextDecoration.underline,
  
   
  decorationColor: Colors.deepPurpleAccent,
   
  decorationStyle: 
 TextDecorationStyle.dotted,
   
  fontStyle: 
 FontStyle.italic,
  
   
  fontWeight: FontWeight.bold,
  
  ),
  
  maxLines: 4,
  
  overflow: TextOverflow.ellipsis,
  
  textAlign: TextAlign.justify, 
  
 ),",NA
RichText,"The 
 RichText
  widget is a great way to display text using multiple styles. The 
 RichText
  widget takes 
 TextSpan
  as children to style different parts of the strings (Figure 6.1).",NA
Column,"Column
  
 A 
 Column
  widget (Figures 6.2 and 6.3) displays its children 
 vertically. It takes a 
 children
  property containing an array of 
 List<Widget>
 . The children align vertically without tak-ing 
 up the full height of the screen. Each child widget can be 
 embedded in an 
 Expanded
  widget to fill available space. You 
 can use 
 CrossAxisAlignment
 , 
 MainAxisAlignment
 , and 
 MainAxisSize
  to align and size how much space is occupied 
  
 on the main axis.
  
 Vertically Aligned
  
 widgets
  
 Column(
  
 FIGURE 6.2:
  Column widget
  
  crossAxisAlignment: CrossAxisAlignment.center, 
 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
 mainAxisSize: MainAxisSize.max,
  
  children: <Widget>[
  
   
  Text('Column 1'),
  
   
  Divider(),
  
   
  Text('Column 2'),
  
   
  Divider(),
  
   
  Text('Column 3'),
  
  ], 
  
 ),",NA
Row ,"Row
  
 A 
 Row
  widget (Figures 6.4 and 6.5) displays its children hori-
 zontally. It takes a 
 children
  property containing an array of 
 List<Widget>
 . The same properties that the 
 Column
  contains 
 are applied to the 
 Row
  widget with the exception that the 
 alignment is horizontal, not vertical.
  
 Row(
  
 Horizontally Aligned
  
 widgets
  
  crossAxisAlignment: CrossAxisAlignment.start,
  
  
  mainAxisAlignment: MainAxisAlignment.
  
 spaceEvenly,
  
  mainAxisSize: MainAxisSize.max, 
 children: <Widget>[
  
   
  Row(
  
    
  children: <Widget>[
  
    
  Text('Row 1'),
  
 FIGURE 6.4:
  Row widget
  
    
  Padding(padding: EdgeInsets.all(16.0),),
    
  Text('Row 2'),
  
    
  Padding(padding: EdgeInsets.all(16.0),),
    
  Text('Row 3'),
  
    
  ],
  
   
  ),
  
  ], 
  
 ),
  
 Column and Row Nesting
  
 A great way to create unique layouts is to combine 
 Column
  and 
 Row
  widgets for individual needs. 
 Imagine having a journal page with 
 Text
  in a 
 Column
  with a nested 
 Row
  containing a list of images 
 (Figures 6.6 and 6.7).",NA
Buttons,"There are a variety of buttons to choose from, depending on the situation, such as 
 FloatingAction-Button
 , 
 FlatButton
 , 
 IconButton
 , 
 RaisedButton
 , 
 PopupMenuButton
 , and 
 ButtonBar
 .
  
 FloatingActionButton
  
 The 
 FloatingActionButton
  widget is usually placed on the bottom right or center of the main screen 
 in the 
 ScaffoldfloatingActionButton
  property. Use the 
 FloatingActionButtonLocation 
 widget 
 to either dock (notch) or float above the navigation bar. To dock a button to the navigation",NA
USING IMAGES AND ICONS,"Images can make an app look tremendous or ugly depending on the quality of the artwork. Images, 
 icons, and other resources are commonly embedded in an app.",NA
AssetBundle,"The 
 AssetBundle
  class provides access to custom resources such as images, fonts, audio, data files, 
 and more. Before a Flutter app can use a resource, you must declare it in the 
 pubspec.yaml
  file.
  
 // pubspec.yaml file to edit 
  
 # To add assets to your application, add an assets section, like 
 this:",NA
Image ,"The 
 Image
  widget displays an image from a local or URL (web) source. To load an 
 Image
  widget, 
 there are a few different constructors to use.
  
 ➤➤
  
 Image()
 —Retrieves image from an 
 ImageProvider
  class
  
 ➤➤
  
 Image.asset()
 —Retrieves image from an 
 AssetBundle
  class using a key 
  
 Image.file()
 —Retrieves image from a 
 File
  class
 ➤➤
  
 ➤➤
  
 Image.memory()
 —Retrieves image from a 
 Uint8List
  class
  
 ➤➤
  
 Image.network()
 —Retrieves image from a 
 URL
  path
  
 Press Ctrl+Spacebar to invoke the code completion for the available options (Figure 6.13).
  
  
 FIGURE 6.13:
  Image code completion
  
 As a side note, the 
 Image
  widget also supports animated GIFs.
  
 The following sample uses the default 
 Image
  constructor to initialize the 
 image
  and 
 fit
  arguments. 
 The 
 image
  argument is set by using the 
 AssetImage()
  constructor with the default bundle loca-tion 
 of the 
 logo.png
  file. You can use the 
 fit
  argument to size the 
 Image
  widget with the 
 BoxFit 
 options, such as 
 contain
 , 
 cover
 , 
 fill
 , 
 fitHeight
 , 
 fitWidth
 , or 
 none
  (Figure 6.14).",NA
Icon,"fit: BoxFit.cover, 
 ),
  
 FIGURE 6.15:
  Silhouette-style image
  
  
 The 
 Icon
  widget is drawn with a glyph from a font described in 
 IconData
 . Flutter’s 
 icons.dart
  file 
 has the full list of icons available from the font 
 MaterialIcons
 . A great way to add custom icons is to 
 add to the 
 AssetBundle
  fonts containing glyphs. Once example is Font Awesome, which has a high-
 quality list of icons and a Flutter package. Of course, there are many other high-quality icons available 
 from other sources.
  
 The 
 Icon
  widget allows you to change the 
 Icon
  widget’s 
 color
 , 
 size
 , and other properties 
 (Figure 6.16).",NA
USING DECORATORS,"Decorators
  help to convey a message depending on the user’s action or customize the look and feel of a 
 widget. There are different types of decorators for each task. 
  
 ➤➤
  
 Decoration
 —The base class to define other decorations.
  
 ➤➤
  
 BoxDecoration
 —Provides many ways to draw a box with 
 border
 , 
 body
 , and 
 boxShadow
 .
  
 ➤➤
  
 InputDecoration
 —Used in 
 TextField
  and 
 TextFormField
  to customize the border, label, 
  
 icon, and styles. This is a great way to give the user feedback on data entry, specifying a 
  
 hint, an error, an alert icon, and more.
  
 A 
 BoxDecoration
  class (Figure 6.17) is a great way to customize a 
 Container
  widget to create 
 shapes by setting the 
 borderRadius
 , 
 color
 , 
 gradient
 , and 
 boxShadow
  properties.
  
 // BoxDecoration 
  
 Container(
  
  height: 100.0,
  
  width: 100.0,
  
  decoration: BoxDecoration(
  
   
  borderRadius: 
 BorderRadius.all(Radius.
  
 circular(20.0)),
  
   
  color: Colors.orange,
  
   
  boxShadow: [
  
    
  BoxShadow(
  
    
  color: Colors.grey,
  
    
  blurRadius: 10.0,
  
    
  offset: Offset(0.0, 10.0),
    
  )
  
   
  ],
  
  ),
  
  
 FIGURE 6.17:
  BoxDecoration applied to a 
 Container
  
 ),
  
 The 
 InputDecoration
  class (Figure 6.18) is used with a 
 Text-Field
  
 or 
 TextFormField
  to specify labels, borders, icons, hints, errors, and 
 styles. This is helpful in communicating with the user as they enter 
 data. For the 
 border
  property shown here, I am imple-menting two 
 ways to customize it, with 
 UnderlineInputBorder 
 and with 
 OutlineInputBorder
 :
  
 // TextField 
  
 TextField(
  
  
 FIGURE 6.18:
  InputDecoration 
 with OutlineInputBorder and 
 default border",NA
USING THE FORM WIDGET TO VALIDATE TEXT FIELDS,"There are different ways to use text field widgets to retrieve, validate, and manipulate data. The 
 Form 
 widget is optional, but the benefits of using a 
 Form
  widget are to validate each text field as a group. You 
 can group 
 TextFormField
  widgets to manually or automatically validate them. The 
 TextForm-Field
  
 widget wraps a 
 TextField
  widget to provide validation when enclosed in a 
 Form
  widget.
  
 If all text fields pass the 
 FormStatevalidate
  method, then it returns 
 true
 . If any text fields contain 
 errors, it displays the appropriate error message for each text field, and the 
 FormStatevalidate 
 method returns 
 false
 . This process gives you the ability to use 
 FormState
  to check for any valida-tion 
 errors instead of checking each text field for errors and not allowing the posting of invalid data.
  
 The 
 Form
  widget needs a unique key to identify it and is created by using 
 GlobalKey
 . This 
 GlobalKey
  value is unique across the entire app.
  
 In the next example, you’ll create a form with two 
 TextFormField
 s (Figure 6.19) to enter an item 
 and quantity to order. You’ll create an 
 Order
  class to hold the item and quantity and fill the order 
 once the validation passes.
  
  
 FIGURE 6.19:
  The Form and TextFormField layout",NA
CHECKING ORIENTATION,"Under certain scenarios, knowing the device orientation helps in laying out the appropriate UI. 
 There are two ways to figure out orientation, 
 MediaQuery.of(context).orientation
  and 
 Orientation Builder
 .
  
 A huge note on 
 OrientationBuilder
 : it returns the amount of space available to the parent to figure 
 out orientation. This means it does not guarantee the actual device orientation. I prefer using 
 MediaQuery
  to obtain the actual device orientation because of its accuracy.
  
 TRY IT OUT 
  
 Creating the Orientation App
  
 Create a new Flutter project and name it 
 ch6_orientation
 . You can follow the instructions in Chap-ter 
 4. For this project, you only need to create the 
 pages
  folder.
  
 In this example, the UI layout will change depending on orientation. When the device is in portrait mode, it 
 will show one 
 Icon
 , and when in landscape mode, it will show two 
 Icons
 . You’ll take a look at a 
 Container
  
 widget that will grow in size and change color, and you’ll use a 
 GridView
  widget to show two or four 
 columns. Lastly, I added the 
 OrientationBuilder
  widget to show that when the 
 Orienta-tionBuilder
  
 is not a parent widget, the correct orientation is not calculated correctly. But if you place the 
 OrientationBuilder
  as a parent, it works correctly; note that using 
 SafeArea
  does not affect the 
 outcome. The following image shows the final project.",NA
SUMMARY,"In this chapter, you learned about the most commonly used (basic) widgets. These basic widgets are the 
 building blocks to designing mobile apps. You also explored different types of buttons to choose 
 depending on the situation. You learned how to add assets to your app via 
 AssetBundle
  by listing 
 items in the 
 pubspec.yaml
  file. You used the 
 Image
  widget to load images from the local device or a 
 web server through a URL string. You saw how the 
 Icon
  widget gives you the ability to load icons by 
 using the MaterialIcons font library.
  
 To modify the appearance of widgets, you learned how to use 
 BoxDecoration
 . To improve giving users 
 feedback on data entry, you implemented 
 InputDecoration
 . Validating multiple text field data entries 
 can be cumbersome, but you can use the 
 Form
  widget to manually or automatically validate them. 
 Lastly, using 
 MediaQuery
  to find out the current device orientation is extremely powerful in any mobile 
 app to lay out widgets depending on the orientation.
  
 In the next chapter, you’ll learn how to use animations. You’ll start by using widgets such as 
 Animat-edContainer
 , 
 AnimatedCrossFade
 , and 
 AnimatedOpacity
  and finish with the powerful 
 Anima-tionController
  for custom animation.",NA
7 ,NA,NA
Adding Animation to an App,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to use 
 AnimatedContainer
  to gradually change values over time How to 
 use 
 AnimatedCrossFade
  to cross-fade between two children widgets How to use 
 AnimatedOpacity
  to show or hide widget visibility by animated 
  
 fading over time
  
 ➤➤
  
 How to use the 
 AnimationController
  to create custom animations
  
 ➤➤
  
 How to use the 
 AnimationController
  to control staggered animations
  
 In this chapter, you’ll learn how to add animation to an app to convey action, which can improve 
 the user experience (UX) if appropriately used. Too many animations without convey-ing the 
 appropriate action can make the UX worse. Flutter has two types of animation: physics-based and 
 Tween. This chapter will focus on Tween animations.
  
 Physics-based animation is used to mimic real-world behavior. For example, when an object is 
 dropped and hits the ground, it will bounce and continue to move forward, but with each 
 bounce, it continues to slow down with smaller rebounds and eventually stop. As the object gets 
 closer to the ground with each bounce, the velocity increases, but the height of the bounce 
 decreases.
  
 Tween
  is short for “in-between,” meaning that the animation has beginning and ending points, a 
 timeline, and a curve that specifies the timing and speed of the transition. The beauty is that the 
 framework automatically calculates the transition from the beginning to end point.",NA
USING ANIMATEDCONTAINER,"Let’s start with a simple animation by using the 
 AnimatedContainer
  widget. This is a 
 Container 
 widget that gradually changes values over a period of time. The 
 AnimatedContainer
  constructor has 
 arguments called 
 duration
 , 
 curve
 , 
 color
 , 
 height
 , 
 width
 , 
 child
 , 
 decoration
 , 
 transform
 , and many 
 others.
  
 TRY IT OUT 
  
 Creating the AnimatedContainer App
  
 In this project, you’ll animate the width of a 
 Container
  widget by tapping it. For example, you could use this 
 type of animation to animate a horizontal bar chart.
  
 1. 
  
 Create a new Flutter project and name it 
 ch7_animations
 . You can follow the instructions in 
 Chapter 4, “Creating a Starter Project Template.” For this project, you need to create only the 
  
 pages
  and 
 widgets
  folders.
  
 2. 
 3. 
 4. 
  
 Create a new Dart file in the 
 widgets
  folder. Right-click the 
 widgets
  folder, select New 
 ➪
  Dart 
 File, enter 
 animated_container.dart
 , and click the OK button to save.
  
 Import the 
 material.dart
  library, add a new line, and then start typing 
 st
 . The autocompletion 
 help opens. Select the 
 stful
  abbreviation and give it a name of 
 AnimatedContainerWidget
 .
  
 After the class 
 _AnimatedContainerWidgetStateextendsState<AnimatedContainerWidget> 
 and before 
 @override
 , add the variables 
 _height
  and 
 _width
  and the 
 _increaseWidth()
  
 method.
  
 The 
 _height
  and 
 _width
  variables are of type 
 double
 .
  
 double _height = 100.0;
  
 The 
 _increaseWidth()
  method calls the 
 setState()
  method to notify the framework that the 
 _width
  value has changed and schedules a build for the state of this object to redraw the subtree. If 
 you do not call 
 setState()
 , the 
 _width
  value still changes, but the 
 AnimatedContainer
  widget will 
 not redraw with the new value.
  
 class _AnimatedContainerWidgetState extends 
 State<AnimatedContainerWidget> { double _height = 100.0;
  
  double _width = 100.0;
  
  _increaseWidth() {
  
  
  setState(() {
  
   
  _width = _width >= 320.0 ? 100.0 : _width += 
 50.0;
  
  });
  
  }    
  
  @override
  
  Widget build(BuildContext context) 
 {
  
 When the page loads, the 
 _height
  and 
 _width
  variables are initiated with values of 100.0 pixels. 
 When the 
 FlatButton
  is tapped, the 
 onPressed
  property calls the 
 _increaseWidth()
  method.",NA
USING ANIMATEDCROSSFADE,"The 
 AnimatedCrossFade
  widget provides a great cross-fade between two children widgets. The 
 AnimatedCrossFade
  constructor takes 
 duration
 , 
 firstChild
 , 
 secondChild
 , 
 crossFadeState
 , 
 sizeCurve
 , and many other arguments.
  
 TRY IT OUT 
  
 Adding the AnimatedCrossFade Widget
  
 This example creates a cross-fade between colors and size by tapping the widget. The widget will cross-
 fade the changing size and color from yellow to green.
  
 1. 
 2. 
 3. 
  
 Create a new Dart file in the 
 widgets
  folder. Right-click the 
 widgets
  folder, select New 
 ➪
  Dart 
 File, enter 
 animated_cross_fade.dart
 , and click the OK button to save.
  
 Import the 
 material.dart
  library, add a new line, and start typing 
 st
 . The autocompletion help 
 opens. Select the 
 stful
  abbreviation and give it a name of 
 AnimatedCrossFadeWidget
 .
  
 After the class 
 _AnimatedCrossFadeWidgetStateextendsState<AnimatedCrossFadeWidget> 
 and before 
 @override
 , add a variable for 
 _crossFadeStateShowFirst
  and the 
 _crossFade()
  
 method.
  
 The 
 _crossFadeStateShowFirst
  variable is of type Boolean (
 bool
 ).
  
 bool _crossFadeStateShowFirst = true;
  
 The 
 _crossFade()
  method calls 
 setState()
  to notify the framework that the 
 _crossFadeState-
 ShowFirst
  value has changed and schedules a build for the state of this object to redraw the sub-
 tree. If you do not call 
 setState()
 , the 
 _width
  value still changes, but the 
 AnimatedCrossFade 
 widget will not redraw with the new value.
  
 class _AnimatedCrossFadeWidgetState extends State<AnimatedCrossFadeWidget> 
 { bool _crossFadeStateShowFirst = true;",NA
USING ANIMATEDOPACITY,"If you need to hide or partially hide a widget, 
 AnimatedOpacity
  is a great way to animate fading over 
 time. The 
 AnimatedOpacity
  constructor the takes 
 duration
 , 
 opacity
 , 
 curve
 , and 
 child 
 arguments. 
 For this example, you do not use a curve; since you want a smooth fade-out and fade-in, it’s not 
 necessary.
  
 TRY IT OUT 
  
 Adding the AnimatedOpacity Widget
  
 The example uses 
 opacity
  to partially fade out a 
 Container
  widget. The widget will animate the 
 opac-
 ity
  value from fully visible to almost faded out.
  
 1. 
 2. 
 3. 
  
 Create a new Dart file in the 
 widgets
  folder. Right-click the 
 widgets
  folder, select New 
 ➪
  Dart 
 File, enter 
 animated_opacity.dart
 , and click the OK button to save.
  
 Import the 
 material.dart
  library, add a new line, and then start typing 
 st
 . The autocompletion 
 help opens. Select the 
 stful
  abbreviation and give it a name of 
 AnimatedOpacityWidget
 .
  
 After the class 
 _AnimatedOpacityWidgetStateextendsState<AnimatedOpacityWidget>
  and 
 before 
 @override
 , add the variable for 
 _opacity
  and the 
 _animatedOpacity()
  method.
  
 The 
 _opacity
  variable is of type 
 double
 .
  
 double _opacity = 1.0;
  
 The 
 _animatedOpacity()
  method calls 
 setState()
  to notify the framework that the 
 _opacity 
 value has changed and schedules a build for the state of this object to redraw the subtree. If you do 
 not call 
 setState()
 , the 
 _opacity
  value still changes, but the 
 AnimatedOpacity
  widget does not 
 redraw with the new value.
  
 class _AnimatedOpacityWidgetState extends State<AnimatedOpacityWidget> 
 { double _opacity = 1.0;
  
  void _animatedOpacity() {
  
  
  setState(() {
  
   
  _opacity = _opacity == 1.0 ? 0.3 : 
 1.0;
  
  
  });
  
  }
  
  @override
  
  Widget build(BuildContext context) 
 {
  
 When the page is loaded, the 
 _opacity
  variable is initiated with a value of 1.0, which is fully vis-
 ible. When the 
 FlatButton
  widget is tapped, the 
 onPressed
  property calls the 
 _animatedOpac-
 ity()
  method.
  
 To calculate the widget opacity, use the ternary operator. If the 
 _opacity
  value is 
 1.0
 , then set 
 _opacity
  to 
 0.3
 . Otherwise, set it to 
 1.0
  since the current value is 
 0.3
 .",NA
USING ANIMATIONCONTROLLER,"The 
 AnimationController
  class gives you increased flexibility in animation. The animation can be 
 played forward or reverse, and you can stop it. The 
 fling
  animation uses a physics simulation like a 
 spring.
  
 The 
 AnimationController
  class produces linear values for a giving duration, and it tries to display a 
 new frame at around 60 frames per second. The 
 AnimationController
  class needs a 
 Ticker-
 Provider
  class by passing the 
 vsync
  argument in the constructor. The 
 vsync
  prevents off-screen 
 animations from consuming unnecessary resources. If the animation needs only one 
 AnimationCon-
 troller
 , use 
 SingleTickerProviderStateMixin
 . If the animation needs multiple 
 AnimationCon-
 troller
 s, use 
 TickerProviderStateMixin
 .  The 
 Ticker
  class is driven by the 
 ScheduleBinding. 
 scheduleFrameCallback
  reporting once per animation frame. It is trying to sync the animation to be 
 as smooth as possible.
  
 The 
 AnimationController
  default object ranges from 0.0 to 1.0, but if you need a different range, you 
 can use the 
 Animation
  class (using 
 Tween
 ) to accept a different type of data. The 
 Animation 
 class is 
 initiated by setting the 
 Tween
  class (in-betweening) 
 begin
  and 
 end
  property values. For exam-ple, you 
 have a balloon that floats from the bottom to the top of the screen, and you would set the 
 Tween
  class 
 begin
  value of 400.0, the bottom of the screen and the 
 end
  value of 0.0, the top of the screen. Then you 
 can chain the Tween 
 animate
  method, which returns an 
 Animation
  class. Simply put, it animates the 
 Tween based on the animation, such as a 
 CurvedAnimation
  class.
  
 The 
 AnimationController
  class at first can seem complex to use because of the different classes 
 needed. The following are the basic steps that you take to create a custom animation (shown in 
 Figure 7.1) or, eventually in the example, multiple animations running at the same time.
  
 1. 
  
 2. 
  
 3. 
  
 4. 
  
 5. 
  
 Add 
 AnimationController
 .
  
 Add 
 Animation
 .
  
 Initiate 
 AnimationController
  with 
 Duration
  (milliseconds, seconds, and so on). Initiate 
 Animation
  with 
 Tween
  with 
 begin
  and 
 end
  values and chain the 
 animate
  method with a 
 CurvedAnimation
  (for this example).
  
 Use the 
 AnimatedBuilder
  with 
 Animation
  using a 
 Container
  with a balloon to start 
 Animation
  by calling the 
 AnimationController.forward()
  and 
 .reverse()
  to run the 
  
 animation backward. The 
 AnimatedBuilder
  widget is used to create a widget that performs a 
 reusable animation.
  
 As you can see, once you break down the steps, it becomes more manageable and less complicated.",NA
Using Staggered Animations,"A 
 staggered animation
  triggers visual changes in sequential order. The animation changes can occur 
 one after the other; they can have gaps without animations and overlap each other. One 
 Anima-
 tionController
  class controls multiple 
 Animation
  objects that specify the animation in a timeline 
 (
 Interval
 ). Now you’ll walk through an example of using one 
 AnimationController
  class and the 
 Interval()curve
  property to start different animations at different times. As noted in the preced-ing 
 section, a staggered animation uses 
 Interval()
  to begin and end animations sequentially or to overlap 
 one another.",NA
SUMMARY,"In this chapter, you learned how to add animations to your app to improve the UX. You implemented 
 AnimatedContainer
  to animate the width of a 
 Container
  widget with a beautiful spring effect by 
 using 
 Curves.elasticOut
 . You added the 
 AnimatedCrossFade
  widget to cross-fade between two 
 children widgets. The color is animated from amber to green while at the same time the widget 
 increased or decreased in width and height. To fade a widget in, out, or partially, you added the 
 AnimatedOpacity
  widget. The 
 AnimatedOpacity
  widget uses the 
 opacity
  property passed over a 
 period of time (
 Duration
 ) to fade the widget. The 
 AnimationController
  class allows the creation of 
 custom animations.
  
 You learned to use multiple 
 AnimationController
 s with different durations. You used two 
 Anima-
 tion
  classes to control the floating upward or downward and the inflation and deflation of the bal-loon 
 at the same time. The animation is created by using 
 Tween
  with 
 begin
  and 
 end
  values. You also used 
 different 
 CurvedAnimation
  class for a nonlinear effect like 
 Curves.fastOutSlowIn
  to float upward or 
 downward and 
 Curves.elasticInOut
  to inflate or deflate the balloon. Lastly, you used one 
 AnimationController
  class with multiple 
 Animation
  classes to create staggered animations, which 
 give a similar effect as the previous example.
  
 In the next chapter, you’ll learn the many ways of using navigation such as 
 Navigator
 , 
 HeroAnima-
 tion
 , 
 BottomNavigationBar
 , 
 BottomAppBar
 , 
 TabBar
 , 
 TabBarView
 , and 
 Drawer
 .",NA
8 ,NA,NA
Creating an App’s Navigation,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to use the 
 Navigator
  widget to navigate between pages 
  
 How hero animation allows a widget transition to fly into place from one page 
  
 to another
  
 ➤➤
  
 How to display a horizontal list of 
 BottomNavigationBarItem
 s containing an 
 icon 
  
 and a 
 title
  at the bottom of the page
  
 ➤➤
  
 How to enhance the look of a bottom navigation bar with the 
 BottomAppBar 
  
 widget, which allows enabling a notch
  
 ➤➤
  
 How to display a horizontal row of tabs with 
 TabBar
  
 ➤➤
  
 How to use 
 TabBarView
  in conjunction with 
 TabBar
  to display the page of the 
  
 selected tab
  
 ➤➤
  
 How 
 Drawer
  allows the user to slide a panel from left or right
  
 ➤➤
  
 How to use the 
 ListView
  constructor to build a short list of items quickly
  
 ➤➤
  
 How to use the 
 ListView
  constructor with the 
 Drawer
  widget to show a menu list
  
 In this chapter, you’ll learn that navigation is a major component in a mobile application. Good 
 navigation creates a great user experience (UX) by making it easy to access information. For 
 example, imagine making a journal entry, and when trying to select a tag, it’s not available, so you 
 need to create a new one. Do you close the entry and go to Settings 
 ➪
  Tags to add a new one? 
 That would be clunky. Instead, the user needs the ability to add a new tag on the fly and 
 appropriately navigate to select or add a tag from their current position. When designing an app, 
 always keep in mind how the user would navigate to different parts of the app with the least 
 number of taps.",NA
USING THE NAVIGATOR,"The 
 Navigator
  widget manages a stack of 
 routes
  to move between pages. You can optionally pass data to 
 the destination page and back to the original page. To start navigating between pages, you use the 
 Navigator.push
 , 
 pushNamed
 , and 
 pop
  methods. (You’ll learn how to use the 
 pushNamed
  method in the 
 “Using the Named Navigator Route” section of this chapter.) 
 Navigator
  is incredibly smart; it shows 
 native navigation on iOS or Android. For example, in iOS when navigating to a new page, you usually 
 slide the next page from the right side of the screen toward the left. In Android when navigat-ing to a 
 new page, you typically slide the next page from the bottom of the screen toward the top. To summarize, 
 in iOS, the new page slides in from the right, and in Android, it slides in from the bottom.
  
 The following example shows you how to use the 
 Navigator.push
  method to navigate to the About 
 page. The 
 push
  method passes the 
 BuildContext
  and 
 Route
  arguments. To push a new 
 Route
  
 argument, you create an instance of the 
 MaterialPageRoute
  class that replaces the screen with the 
 appropriate platform (iOS or Android) animation transition. In the example, the 
 fullscreenDialog
  
 property is set to 
 true
  to present the About page as a full-screen modal dialog. By setting the 
 fullscreenDialog
  property to 
 true
 , the About page app bar automatically includes a close button. In 
 iOS, the modal dialog transition presents the page by sliding from the bottom of the screen toward the 
 top, and this is also the default for Android.
  
 Navigator.push(
  
  context,
  
  MaterialPageRoute(
  
   
  fullscreenDialog: true,
  
   
  builder: (context) => About(),
  
  ), 
  
 );
  
 The following example shows how to use the 
 Navigator.pop
  method to close the page and navigate 
 back to the previous page. You call the 
 Navigator.pop(context)
  method by passing the 
 BuildContext
  argument, and the page closes by sliding from the top of the screen toward the bot-
 tom. The second example shows how to pass a value back to the previous page.
  
 // Close page 
  
 Navigator.pop(context);
  
 // Close page and pass a value back to previous 
 page Navigator.pop(context, 'Done');
  
 TRY IT OUT 
  
 Creating the Navigator App, Part 1—The About Page
  
 The project has a main home page with a 
 FloatingActionButton
  to navigate to a gratitude page by 
 passing a default selected 
 Radio
  button value. The gratitude page shows three 
 Radio
  buttons to select a 
 value and then pass it back to the home page and update the 
 Text
  widget with the appropriate value.",NA
Using the Named Navigator Route,"An alternate way to use 
 Navigator
  is to refer to the page that you are navigating to by the route 
 name. The route name starts with a slash, and then comes the route name. For example, the About 
 page route name is 
 '/about'
 . The list of 
 routes
  is built into the 
 MaterialApp()
  widget. The 
 routes
  
 have a 
 Map
  of 
 String
  and 
 WidgetBuilder
  where the 
 String
  is the route name, and the 
 WidgetBuilder
  has a 
 builder
  to build the contents of the route by the 
 Class
  name (About) of the 
 page to open.
  
 routes: <String, WidgetBuilder>{
  
  '/about': (BuildContext context) => About(),
  
  '/gratitude': (BuildContext context) => Gratitude(), 
 },
  
 To call the route, the 
 Navigator.pushNamed()
  method is called by passing two arguments. The first 
 argument is 
 context
 , and the second is the 
 route
  name.
  
 Navigator.pushNamed(context, '/about');",NA
USING HERO ANIMATION,"The 
 Hero
  widget is a great out-of-the-box animation to convey the navigation action of a widget flying 
 into place from one page to another. The hero animation is a shared element transition (anima-tion) 
 between two different pages.
  
 To visualize the animation, imagine seeing a superhero flying into action. For example, you have a list of 
 journal entries with a photo thumbnail, the user selects an entry, and you see the photo thumbnail 
 transition to the detail page by moving and growing to full size. The photo thumbnail is the super-hero, 
 and when tapped, it flies into action by moving from the list page to the detail page and lands perfectly 
 on the correct location at the top of the detail page showing the full photo. When the detail page is 
 dismissed, the 
 Hero
  widget flies back to the original page, position, and size. In other words, the 
 animation shows the photo thumbnail moving and growing into place from the list page to the detail 
 page, and once the detail page is dismissed, the animation and size are reversed. The 
 Hero 
 widget has 
 all of these features built in; there’s no need to write custom code to handle the size and animation 
 between pages.
  
 To continue with the previous scenario, you wrap the list page 
 Image
  widget as a 
 child
  of the 
 Hero 
 widget and assign a 
 tag
  property name. Repeat the same steps for the detail page and make sure the 
 tag
  property value is the same in both pages.
  
 // List page 
  
 Hero(
  
  tag: 'photo1',
  
  child: Image(
  
   
  image: 
 AssetImage(""assets/images/coffee.png""), ), 
  
 ),
  
 // Detail 
 page 
  
 Hero(",NA
USING THE BOTTOMNAVIGATIONBAR,"BottomNavigationBar
  
 is 
 a 
 Material 
 Design 
 widget 
 that 
 displays 
 a 
 list 
 of 
 BottomNavigation-BarItem
 s that contains an 
 icon
  and a 
 title
  at the bottom of the page 
 (Figure 8.1). When the 
 BottomNavigationBarItem
  is selected, the appropriate page is built.
  
  
 FIGURE 8.1:
  Final BottomNavigationBar with icons and titles
  
 TRY IT OUT 
  
 Creating the BottomNavigationBar App
  
 In this example, 
 BottomNavigationBar
  has three 
 BottomNavigationBarItem
 s that replace the current 
 page with the selected one. There are different ways to display the selected page; you use a 
 Widget
  class as 
 a variable.",NA
USING THE BOTTOMAPPBAR,"The 
 BottomAppBar
  widget behaves similarly to the 
 BottomNavigationBar
 , but it has an optional 
 notch along the top. By adding a 
 FloatingActionButton
  and enabling the notch, the notch provides a 
 nice 3D effect so it looks like the button is recessed into the 
  
 navigation bar (Figure 8.2). For example, to enable the notch, 
  
 you set the 
 BottomAppBarshape
  property to a 
 Notched-
  
 Shape
  class like the 
 CircularNotchedRectangle()
  class and 
  
 set the 
 ScaffoldfloatingActionButtonLocation
  property 
  
 to 
 FloatingActionButtonLocation.endDocked
  or 
 center-
  
 Docked
 . Add to the 
 ScaffoldfloatingActionButton
  prop-
 erty a 
 FloatingActionButton
  widget, and the result shows 
 the 
 FloatingActionButton
  embedded into the 
 BottomApp-Bar
  widget, which is the notch.
  
 BottomAppBar(
  
  shape: CircularNotchedRectangle(), 
 )
  
 FIGURE 8.2:
  BottomAppBar with 
 embedded 
 FloatingActionButton 
 creating a notch
  
 floatingActionButtonLocation: 
 FloatingActionButtonLocation.endDocked, floatingActionButton: 
 FloatingActionButton(
  
  child: Icon(Icons.add), 
  
 ),
  
 TRY IT OUT 
  
 Creating the BottomAppBar App
  
 In this example, the 
 BottomAppBar
  has a 
 Row
  as a child with three 
 IconButton
 s to show selection items. 
 The main objective is to use a 
 FloatingActionButton
  to dock it to the 
 BottomAppBar
  with a notch. 
  
 The notch is enabled by the 
 BottomAppBarshape
  property set to 
 CircularNotchedRectangle()
 .
  
 1. 2. 
  
 Create a new Flutter project and name it 
 ch8_bottom_app_bar
 . Again, you can follow the instruc-
 tions in Chapter 4. For this project, you only need to create the 
 pages
  folder.
  
 Open the 
 home.dart
  file, and add to the 
 body
  a 
 SafeArea
  with a 
 Container
  as a 
 child
 .
  
 body: SafeArea(
  
  child: Container(), 
  
 ),
  
 3. 
  
 Add a 
 BottomAppBar()
  widget to the 
 ScaffoldbottomNavigationBar
  property.
  
 bottomNavigationBar: BottomAppBar(),",NA
USING THE TABBAR AND TABBARVIEW,"The 
 TabBar
  widget is a Material Design widget that displays a horizontal row of tabs. The 
 tabs 
 property takes a 
 List
  of 
 Widgets
 , and you add tabs by using the 
 Tab
  widget. Instead of using the 
 Tab
  
 widget, you could create a custom widget, which shows the power of Flutter. The selected 
 Tab
  is 
 marked with a bottom selection line.
  
 The 
 TabBarView
  widget is used in conjunction with the 
 TabBar
  widget to display the page of the 
 selected tab. Users can swipe left or right to change content or tap each 
 Tab
 .
  
 Both the 
 TabBar
  (Figure 8.3) and 
 TabBarView
  widgets 
  
 take a 
 controller
  property of 
 TabController
 . The 
 Tab-Controller
  is responsible for syncing tab selections 
 between a 
 TabBar
  and a 
 TabBarView
 . Since the 
 TabController 
  
 syncs the tab selections, you need to declare the 
 Single-TickerProviderStateMixin
  to the class. In Chapter 
 7, “Adding Animation to an App,” you learned how to imple-
 ment the 
 Ticker
  class that is driven by the 
 Schedule-
  
 Binding.scheduleFrameCallback
  reporting once per 
 animation frame. It is trying to sync the animation to be as 
 smooth as possible.
  
  
 FIGURE 8.3:
  TabBar in the Scaffold 
 bottomNavigationBar property
  
 TRY IT OUT 
  
 Creating the TabBar and TabBarView App
  
 In this example, the 
 TabBar
  widget is the child of a 
 bottomNavigationBar
  property. This places the 
 TabBar
  at the bottom of the screen, but you could also place it in the 
 AppBar
  or a custom location. When 
 you use a 
 TabBar
  in combination with the 
 TabBarView
 , once a 
 Tab
  is selected, it automatically displays the 
 appropriate content. In this project, the content is represented by three separate pages. You’ll create the 
 same three pages as you did in the 
 BottomNavigationBar
  project.
  
 1. 2. 
  
 Create a new Flutter project and name it 
 ch8_tabbar
 . Once more, you can follow the instructions in 
 Chapter 4. For this project, you need to create only the 
 pages
  folder.
  
 Open the 
 home.dart
  file, and add to the 
 body
  a 
 SafeArea
  with 
 TabBarView
  as a 
 child
 . The 
 TabBarViewcontroller
  property is a 
 TabController
  variable called 
 _tabController
 . Add to 
  
 the 
 TabBarViewchildren
  property the 
 Birthdays()
 , 
 Gratitude()
 , and 
 Reminders()
  pages that 
 you’ll create in step 3.
  
 body: SafeArea(
  
  child: TabBarView(",NA
USING THE DRAWER AND LISTVIEW,"You might be wondering why I’m covering the 
 ListView
  in this navigation chapter. Well, it works great 
 with the 
 Drawer
  widget. 
 ListView
  widgets are used quite often for selecting an item from a list to 
 navigate to a detailed page.",NA
SUMMARY,"In this chapter, you learned to use the 
 Navigator
  widget to manage a stack of routes so as to allow 
 navigation between pages. You optionally passed data to the navigation page and back to the original 
 page. The hero animation allows a widget transition to fly into place from one page to another. The 
 widget to animate from and to is wrapped in a 
 Hero
  widget by a unique key.
  
 You used the 
 BottomNavigationBar
  widget to display a horizontal list of 
 BottomNavigation-BarItem
 s containing an 
 icon
  and a 
 title
  at the bottom of the page. When the 
 user taps each 
 BottomNavigationBarItem
 , the appropriate page is displayed. To enhance the look of a 
 bottom navigation bar, you used the 
 BottomAppBar
  widget and enabled the optional notch. The notch is 
 the result of embedding a 
 FloatingActionButton
  to a 
 BottomAppBar
  by setting the 
 BottomAppBar 
 shape
  to a 
 CircularNotchedRectangle()
  class and setting the 
 ScaffoldfloatingActionButton-Location
  property to 
 FloatingActionButtonLocation.endDocked
 .
  
 The 
 TabBar
  widget displays a horizontal row of tabs. The 
 tabs
  property takes a 
 List
  of widgets, and 
 tabs are added by using the 
 Tab
  widget. The 
 TabBarView
  widget is used in conjunction with the 
 TabBar
  
 widget to display the page of the selected tab. Users can swipe left or right to change content or tap each 
 Tab
 . The 
 TabController
  class handled the syncing of the 
 TabBar
  and selected 
 TabBar-View
 . The 
 TabController
  requires the use of 
 withSingleTickerProviderStateMixin
  in the class.
  
 The 
 Drawer
  widget allows the user to slide a panel from left or right. The 
 Drawer
  widget is added by 
 setting the 
 Scaffolddrawer
  or 
 endDrawer
  property. To easily align menu items in a list, you pass a",NA
9 ,NA,NA
Creating Scrolling Lists ,NA,NA
and Effects,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤➤
  
 How 
 Card
  is a great way to group information with the container having rounded 
  
 corners and a drop shadow
  
 ➤➤
  
 How to build a linear list of scrollable widgets with 
 ListView
  
 ➤➤
  
 How to display tiles of scrollable widgets in a grid format with 
 GridView
  
 ➤➤
  
 How 
 Stack
  lets you overlap, position, and align its children widgets
  
 ➤➤
  
 How to create custom scrolling effects using 
 CustomScrollView
  and slivers
  
 In this chapter, you’ll learn to create scrolling lists that help users view and select information. 
  
 You’ll start with the 
 Card
  widget in this chapter because it is commonly used in conjunction 
 with list-capable widgets to enhance the user interface (UI) and group data. In the previous 
 chapter, you took a look at using the basic constructor for the 
 ListView
 , and in this chapter, 
 you’ll use the 
 ListView.builder
  to customize the data. The 
 GridView
  widget is a fantastic 
 widget that displays a list of data by a fixed number of tiles (groups of data) in the cross axis. 
 The 
 Stack
  widget is commonly used to overlap, position, and align widgets to create a custom 
 look. A good example is a shopping cart with the number of items to purchase on the upper-
 right side.
  
 The 
 CustomScrollView
  widget allows you to create custom scrolling effects by using a list of 
 slivers widgets. Slivers are handy, for instance, if you have a journal entry with an image on the 
 top of the page and the diary description below. When the user swipes to read more, the 
 description scrolling is faster than the image scrolling, creating a parallax effect.",NA
USING THE CARD,"The 
 Card
  widget is part of the Material Design and has minimal rounded corners and shadows. To 
 group and lay out data, the 
 Card
  is a perfect widget to enhance the look of the UI. The 
 Card 
 widget is 
 customizable with properties such as 
 elevation
 , 
 shape
 , 
 color
 , 
 margin
 , and others. The 
 elevation
  
 property is a value of 
 double
 , and the higher the number, the larger the shadow that is cast. You 
 learned in Chapter 3, “Learning Dart Basics,” that a double is a number that requires decimal point 
 precision, such as 8.50. To customize the shape and borders of the 
 Card
  widget, you modify the 
 shape
  
 property. Some of the 
 shape
  properties are 
 StadiumBorder
 , 
 Underline-InputBorder
 , 
 OutlineInputBorder
 , and others.
  
 Card(
  
  elevation: 8.0,
  
  color: Colors.white,
  
  margin: EdgeInsets.all(16.0),
  
  child: Column(
  
   
  mainAxisAlignment: 
 MainAxisAlignment.center,
  
  
  children: 
 <Widget>[
  
    
  Text('
  
     
  'Barista',
  
     
  textAlign: TextAlign.center,
  
     
  style: TextStyle(
  
      
  fontWeight: FontWeight.bold,
  
      
  fontSize: 48.0,
  
      
  color: Colors.orange,
  
     
  ),
  
    
  '),
  
    
  Text(
  
     
  'Travel Plans',
  
     
  textAlign: TextAlign.center,
  
     
  style: TextStyle(color: Colors.grey),
    
  ),
  
   
  ],
  
  ), 
  
 ),
  
 The following are a few ways to customize the 
 Card
 ’s 
 shape
  property (Figure 9.1):
  
 // Create a Stadium 
 Border 
  
 shape: StadiumBorder(),
  
 // Create Square Corners Card with a Single Orange Bottom Border 
  
 shape: UnderlineInputBorder(borderSide: BorderSide(color: 
 Colors.deepOrange)),
  
 // Create Rounded Corners Card with Orange Border 
  
 shape: OutlineInputBorder(borderSide: BorderSide(color: 
 Colors.deepOrange.
  
 withOpacity(0.5)),),",NA
USING THE LISTVIEW AND LISTTILE,"The constructor 
 ListView.builder
  is used to create an on-demand linear scrollable list of widgets 
 (Figure 9.2). When you have a large set of data, the 
 builder
  is called only for visible widgets, which is 
 great for performance. Within the 
 builder
 , you use the 
 itemBuilder
  callback to create the list of 
 children widgets. Keep in mind the 
 itemBuilder
  is called only if the 
 itemCount
  argument is greater 
 than zero, and it is called as many times as the 
 itemCount
  value. Remember, the 
 List
  starts at row 0, 
 not 1. If you have 20 items in the 
 List
 , it loops from row 0 to 19. The 
 scrollDirection
  argument 
 defaults to 
 Axis.vertical
  but can be changed to 
 Axis.horizontal
 .",NA
USING THE GRIDVIEW,"The 
 GridView
  (Figure 9.3) displays tiles of scrollable 
  
 widgets in a grid format. The three constructors that I focus 
 on are 
 GridView.count
 , 
 GridView.extent
 , and 
  
 GridView.builder
 .
  
 The 
 GridView.count
  and 
 GridView.extent
  are usually used 
 with a fixed or smaller data set. Using these constructors means 
 that all of the data, not just visible widgets, is loaded at 
 init
 . If 
 you have a large set of data, the user does not see the 
 GridView
  
 until all data is loaded, which is not a great user experience (UX). 
 Usually you use the 
 GridView.count
  when you need a layout 
 with a fixed number of tiles in the cross-axis. For example, it 
 shows three tiles in portrait and land-scape modes. You use the 
 GridView.extent
  when you need a layout with the tiles that 
 need a maximum cross-axis extent. For example, two to three 
 tiles fit in portrait mode, and five to six tiles fit in landscape 
 mode; in other words, it fits as many tiles that it can depending 
 on screen size.
  
 The 
 GridView.builder
  constructor is used with a larger, 
 infinite, or unknown size set of data. Like our 
 ListView.
  
 builder
 , when you have a large set of data, the 
 builder
  is 
 called only for visible widgets, which is great for performance. 
  
 Within the 
 builder
 , you use the 
 itemBuilder
  callback 
 to create the list of children widgets. Keep in mind the 
  
  
 FIGURE 9.3:
  GridView layout
  
 itemBuilder
  is called only if the 
 itemCount
  argument is greater than zero, and it is called as many 
 times as the 
 itemCount
  value. Remember, the 
 List
  starts at row 0, not 1. If you have 20 items in the 
 List
 , it loops from row 0 to 19. The 
 scrollDirection
  argument defaults to 
 Axis.vertical
  but can 
 be changed to 
 Axis.horizontal
  (Figure 9.3).",NA
Using the GridView.count,"The 
 GridView.count
  requires setting the 
 crossAxisCount
  and the 
 children
  argument. The 
 crossAxisCount
  sets the number of tiles to display (Figure 9.4), and 
 children
  is a list of widgets. 
  
 The 
 scrollDirection
  argument sets the main axis direction for the 
 Grid
  to scroll, either 
 Axis 
 .vertical
  or 
 Axis.horizontal
 , and the default is 
 vertical
 .
  
 For the 
 children
 , you use the 
 List.generate
  to create your sample data, a list of values. Within the 
 children
  argument, I added a 
 print
  statement to show that the entire list of values is built at the same 
 time, not just the visible rows like the 
 GridView.builder
 . Note for the following sample code, 7,000 
 records are generated to show that the 
 GridView.count
  does not show any data until all of the records 
 are processed first. 
  
 GridView.count(
  
  crossAxisCount: 3,
  
  padding: EdgeInsets.all(8.0),",NA
Using the GridView.extent,"The 
 GridView.extent
  requires you to set the 
 maxCrossAxisExtent
  and 
 children
  argument. The 
 maxCrossAxisExtent
  argument sets the maximum size of each tile for the axis. For example, in 
 portrait, it can fit two to three tiles, but when rotating to landscape, it can fit five to six depending on 
 the screen size (Figure 9.5). The 
 scrollDirection
  argument sets the main axis direction for the grid 
 to scroll, either 
 Axis.vertical
  or 
 Axis.horizontal
 , and the default is 
 vertical
 .
  
  
 FIGURE 9.5:
  GridView extent showing the maximum number of tiles that can fit according to screen size
  
 For the 
 children
 , you use 
 List.generate
  to create your sample data, which is a list of values. 
 Within the 
 children
  argument, I added a 
 print
  statement to show that the entire list of values is 
 built at the same time, not just the visible rows like the 
 GridView.builder
 .
  
 GridView.extent(
  
  maxCrossAxisExtent: 175.0,
  
  scrollDirection: Axis.horizontal,
  
  padding: EdgeInsets.all(8.0),
  
  children: List.generate(20, (index) {
  
   
  print('_buildGridViewExtent 
 $index');
  
  return Card(
  
  
  margin: EdgeInsets.all(8.0),
  
  
  child: InkWell(
  
   
  child: Column(
  
    
  mainAxisAlignment: 
 MainAxisAlignment.center,
  
  
  
  
 children: <Widget>[
  
     
  Icon(
  
     
  _iconList[index],
  
     
  size: 48.0,",NA
Using the GridView.builder,"The 
 GridView.builder
  requires you to set the 
 itemCount
 , 
 gridDelegate
 , and 
 itemBuilder 
 arguments. The 
 itemCount
  sets the number of tiles to build. The 
 gridDelegate
  is a 
 SilverGrid-Delegate
  responsible for laying out the children list of widgets for the 
 GridView
 . The 
 gridDelegate 
 argument cannot be null; you need to pass the 
 maxCrossAxisExtent
  size, for example, 
 150.0 pixels.
  
 For example, to display three tiles across the screen you specify the 
 gridDelegate
  argument with the 
 SliverGridDelegateWithFixedCrossAxisCount
  class to create a grid layout with a fixed number of 
 tiles for the cross axis. If you need to display tiles that have a maximum width of 150.0 pixels, you 
 specify the 
 gridDelegate
  argument with the 
 SliverGridDelegateWithMaxCrossAxisExtent
  class 
 to create a grid layout with tiles that have a maximum cross-axis extent, the maximum width of each 
 tile.
  
 The 
 GridView.builder
  is used when you have a large set of data because the 
 builder
  is called only 
 for visible tiles, which is great for performance. Using the 
 GridView.builder
  constructor results in 
 lazily building a list for visible tiles, and when the user scrolls to the next visible tiles they are lazily 
 built as needed.
  
 TRY IT OUT 
  
 Creating the GridView.builder App
  
 In this example, the 
 GridView
  widget uses the 
 builder
  to display a 
 Card
  that shows each 
 Grid
  item 
 with an 
 Icon
  and a 
 Text
  showing the index location. The 
 onTap
  will print the index of the tapped 
 Grid
  
 item.
  
 1. 
  
 Create a new Flutter project and name it 
 ch9_gridview
 , following the instructions in Chapter 4. 
  
 For this project, you need to create only the 
 pages
 , 
 classes
 , and 
 widgets
  folders. Create the 
 Home 
  
 Class
  as a 
 StatelessWidget
  since the data does not require changes.
  
 2. 
  
 Open the 
 home.dart
  file and add to the 
 body
  a 
 SafeArea
  with the 
 GridViewBuilderWidget() 
  
 widget class as a 
 child
 .
  
 body: SafeArea(
  
  child: const",NA
USING THE STACK,"The 
 Stack
  widget is commonly used to overlap, position, and align widgets to create a custom look. A 
 good example is a shopping cart with the number of items to purchase on the upper-right side. The 
 Stackchildren
  list of the widget is either positioned or nonpositioned. When you use a 
 Positioned 
 widget, each 
 child
  widget is placed at the appropriate location.
  
 The 
 Stack
  widget resizes itself to accommodate all of the nonpositioned children. The nonpositioned 
 children are positioned to the 
 alignment
  property (
 Top-Left
  or 
 Top-Right
  depending on the left-to-
 right or right-to-left environment). Each 
 Stack
  child widget is drawn in order from bottom to top, like 
 stacking pieces of paper on top of each other. This means the first widget drawn is at the bottom of the 
 Stack
 , and then the next widget is drawn above the previous widget and so on. Each child widget is 
 positioned on top of each other in the order of the 
 Stackchildren
  list. The 
 RenderStack 
 class 
 handles the stack layout.
  
 To align each child in the 
 Stack
 , you use the 
 Positioned
  widget. By using the 
 top
 , 
 bottom
 , 
 left
 , and 
 right
  properties, you align each child widget within the 
 Stack
 . The 
 height
  and 
 width
  proper-ties of 
 the 
 Positioned
  widget can also be set (Figure 9.6).
  
  
 FIGURE 9.6:
  Stack layout showing Image and Text widgets stacked over the background image
  
 You’ll also learn how to implement the 
 FractionalTranslation
  class to position a widget fraction-
 ally outside the parent widget. You set the 
 translation
  property with the 
 Offset(dx,dy)
  (double 
 type value for x-and y-axis) class that’s scaled to the child’s size, resulting in moving and positioning the 
 widget. For example, to show a favorite icon moved a third of the way to the upper right of the parent 
 widget, you set the 
 translation
  property with the 
 Offset(0.3,-0.3)
  value.
  
 The following example (Figure 9.7) shows a 
 Stack
  widget with a background image, and by using 
 the 
 FractionalTranslation
  class, you set the 
 translation
  property to the 
 Offset(0.3,-0.3) 
 value, placing the star icon one-third to the right of the x-axis and a negative one-third (move icon 
 upward) on the y-axis.
  
 Stack(
  
  children: <Widget>[
  
   
  Image(image: 
 AssetImage('assets/images/dawn.jpg')),
  
  
  
 Positioned(",NA
CUSTOMIZING THE CUSTOMSCROLLVIEW WITH SLIVERS,"The 
 CustomScrollView
  widget creates custom scrolling effects by using a list of slivers. Slivers are a 
 small portion of something larger. For example, slivers are placed inside a view port like the 
 CustomScrollView
  widget. In the previous sections, you learned how to implement the 
 ListView 
 and 
 GridView
  widgets separately. But what if you needed to present them together in the same list? 
 The answer is that you can use a 
 CustomScrollView
  with the 
 slivers
  property list of widgets set to 
 the 
 SliverSafeArea
 , 
 SliverAppBar
 , 
 SliverList
 , and 
 SliverGrid
  widgets (slivers). The order in 
 which you place them in the 
 CustomScrollViewslivers
  property is the order in which they are 
 rendered. Table 9.1 shows commonly used slivers and sample code.
  
 TABLE 9.1: 
 Slivers
  
 SLIVER
  
 DESCRIPTION
  
 CODE
  
 SliverSafeArea
  
 Adds padding to avoid the 
 device notch usually 
 located on the top of 
  
 the screen
  
 SliverSafeArea(
  
  
  sliver: SliverGrid(), 
 )
  
 SliverAppBar
  
 Adds an app bar
  
 SliverAppBar(
  
  
  expandedHeight: 250.0,
  
  
  flexibleSpace: 
 FlexibleSpaceBar(
  
  
  title: 
 Text('Parallax'),
  
  
  ),
  
  )
  
 SliverList
  
 Creates a linear 
  
 scrollable list of widgets
  
 SliverList(
  
  
  delegate: 
 SliverChildListDelegate(
  
  
  
 List.generate(3, (int index) {
  
   
  return ListTile();
  
   
  }),
  
  
  ),
  
  )
  
 SliverGrid
  
 Displays tiles of 
  
 scrollable widgets in a 
 grid format
  
 SliverGrid(
  
  
  delegate: 
 SliverChildBuilderDelegate(
   
   
  (BuildContext context, int  
 index) {
  
     
  return Card();
  
    
  },
  
    
  childCount: _rowsCount,
  
   
  ),
  
  
  gridDelegate: 
 SliverGridDelegateWithF 
 ixedCrossAxisCount(crossAxisCount: 3), 
 )",NA
SUMMARY,"In this chapter, you learned to use the 
 Card
  to group information with the container having rounded 
 corners and a shadow. You used the 
 ListView
  to build a list of scrollable widgets and to align grouped 
 data with the 
 ListTile
 , and you used the 
 GridView
  to display data in tiles, using the 
 Card 
 to group 
 the data. You embedded a 
 Stack
  in a 
 ListView
  to show an 
 Image
  as a background and stacked 
 different widgets with the 
 Positioned
  widget to overlap and position them at the appropri-ate 
 locations by using the 
 top
 , 
 bottom
 , 
 left
 , and 
 right
  properties.
  
 In the next chapter, you’ll learn to build custom layouts by using 
 SingleChildScrollView
 , 
 SafeArea
 , 
 Padding
 , 
 Column
 , 
 Row
 , 
 Image
 , 
 Divider
 , 
 Text
 , 
 Icon
 , 
 SizedBox
 , 
 Wrap
 , 
 Chip
 , and 
 CircleAvatar
 . You’ll 
 learn to take a high-level view as well as a detailed view to separate and nest widgets to create a 
 custom UI.",NA
10 ,NA,NA
Building Layouts,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to create simple and complex layouts 
  
 How to combine and nest widgets 
  
 How to combine vertical and horizontal widgets to create a custom layout How to 
 build the UI layout by using widgets such as 
 SingleChildScrollView
 , 
  
 SafeArea
 , 
 Padding
 , 
 Column
 , 
 Row
 , 
 Image
 , 
 Divider
 , 
 Text
 , 
 Icon
 , 
 SizedBox
 , 
 Wrap
 , 
 Chip
 , and 
 CircleAvatar
  
 In this chapter, you’ll learn how to take individual widgets and nest them to build a professional 
 layout. This concept is known as 
 composition
  and is a huge part of creating Flutter mobile apps. 
 Most of the time you can build simple or complex layouts either using vertical or horizon-tal 
 widgets or using a combination of both.",NA
A HIGH-LEVEL VIEW OF THE LAYOUT,"This chapter’s goal is to create a journal entry page displaying details from top to bottom. The 
 journal page shows the header image, title, diary detail, weather, (journal location) address, tags, 
 and footer images. The weather, tags, and footer images sections are built by nesting widgets to 
 build a custom layout (Figure 10.1).",NA
Weather Section Layout,"Each journal entry records the weather, temperature, and location at the time of entry to recall the 
 details at a later time. To provide that information, you’re including a journal entry weather section. 
  
 Using a 
 Row
 , you add two 
 Column
  widgets and one 
 SizedBox
  widget. The first 
 Column
  contains an 
 Icon
  
 to show the weather symbol. The second 
 Column
  contains two 
 Row
  widgets. The first 
 Row
  has a 
 Text
  
 showing the weather temperature and description. The second 
 Row
  has a 
 Text
  showing the loca-tion 
 address of the journal entry (Figure 10.3).
  
  
 FIGURE 10.3:
  Weather section",NA
Tags Layout,"To organize each journal entry and facilitate searching, you use tags to add categories to the entry. 
  
 Tags are items such as movie, family, birthday, vacation, and so on. The tags section uses a 
 Wrap 
 widget with a children list of 
 Chip
  widgets. When you have a list of items that can be of different 
 lengths and an unknown number of items, nesting them in a 
 Wrap
  widget lays out each child auto-
 matically according to available space (Figure 10.4).
  
  
 FIGURE 10.4:
  Tags section
  
 The 
 Chip
  widget is a great way to group information and customize the presentation look and feel. 
 Setting the 
 label
  property is the only requirement but most of the time it’s used by setting the 
 avatar 
 property with an 
 Icon
  or an 
 Image
  widget. By default the Chip widget is a gray stadium (rectangle with 
 large semicircles on the ends at opposite sides) shape but you can customize it by using the 
 shape 
 property and the 
 backgroundColor
  property. The following sample code shows a customized 
 Chip 
 widget that displays the 
 label
  and 
 avatar
  in a rectangular shape with small rounded corners. The 
 RoundedRectangleBorder
  class returns the rectangular border with rounded corners.",NA
Footer Images Layout,"It is said that a picture is worth a thousand words, and the footer section allows you to add photos to 
 each journal entry to bring back memories. The footer sections use a 
 Row
  with a 
 CircleAvatar 
 widget 
 showing different images. At the end of the 
 Row
 , a 
 SizedBox
  is used to space the child 
 Column 
 to the 
 end. The 
 Column
  shows vertically aligned 
 Icon
 s (Figure 10.5).
  
  
 FIGURE 10.5:
  Footer section",NA
Final Layout,"You looked at how to lay out each section of the journal detail page. By nesting widgets, you build 
 custom or complex layouts known as 
 composition
 . The power of nesting widgets to create beautiful UIs 
 is limited only by your imagination. Figure 10.6 shows the journal detail page and the three main 
 customized sections for the weather, tags, and footer images.",NA
CREATING THE LAYOUT,"When creating the layout, it's good to start from a high-level view and then work your way down to 
 each detailed section. By taking each section of the page, you start to analyze the requirements and 
 format as needed. For example, if a particular section lays out the items horizontally, you start with a 
 Row
 ; if the section’s layout is vertical, you start with a 
 Column
 . Then you look at the display require-
 ments and start breaking down data into its own sections by nesting widgets.",NA
SUMMARY,"In this chapter, you learned how to envision a high-level custom layout and break it down into its 
 main sections. Then you took each main section and built the layout needed by nesting widgets.
  
 In the next chapter, you’ll learn to add interactivity by using the 
 GestureDetector
 , 
 Draggable
 , 
 DragTarget
 , 
 InkWell
 , and 
 Dismissable
  widgets.",NA
11 ,NA,NA
Applying Interactivity,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤➤
  
 How to use 
 GestureDetector
 , which recognizes gestures such as tap, double tap, 
  
 long press, pan, vertical drag, horizontal drag, and scale.
  
 ➤➤
  
 How to use the 
 Draggable
  widget that is dragged to a 
 DragTarget
 .
  
 ➤➤
  
 How to use the 
 DragTarget
  widget that receives data from a 
 Draggable
 .
  
 ➤➤
  
 How to use the 
 InkWell
  and 
 InkResponse
  widgets. You will learn that 
 InkWell 
  
 is a rectangular area that responds to touch and clips splashes within its area. 
  
 You’ll learn that 
 InkResponse
  responds to touch and that splashes expand out-
  
 side its area.
  
 ➤➤
  
 How to use the 
 Dismissible
  widget that is dismissed by dragging.
  
 In this chapter, you’ll learn how to add interactivity to an app by using gestures. In a mobile 
 application, gestures are the heart of listening to user interaction. Making use of gestures can 
 define an app with a great UX. Overusing gestures when they don’t add value or convey an action 
 creates a poor UX. You’ll take a closer look at how to find a balance by using the correct gesture 
 for the task at hand.",NA
SETTING UP GESTUREDETECTOR: THE BASICS,"The 
 GestureDetector
  widget detects gestures such as tap, double tap, long press, pan, verti-cal 
 drag, horizontal drag, and scale. It has an optional 
 child
  property, and if a 
 child
  widget is 
 specified, the gestures apply only to the 
 child
  widget. If the 
 child
  widget is omitted, then the 
 GestureDetector
  fills the entire parent instead. If you need to catch vertical drag and horizon-
 tal drag at the same time, use the pan gesture. If you need to catch a single-axis drag, then use 
 either the vertical drag or horizontal drag gesture.",NA
IMPLEMENTING THE DRAGGABLE AND DRAGTARGET WIDGETS,"To implement a drag-and-drop feature, you drag the 
 Draggable
  widget to a 
 DragTarget
  widget. You 
 use the 
 data
  property to pass any custom data and use the 
 child
  property to display a widget like an 
 Icon
  and remains visible while not being dragged as long as the 
 childWhenDragging
  property is 
 null
 . 
 Set the 
 childWhenDragging
  property to display a widget while dragging. Use the 
 feedback 
 property 
 to display a widget showing the user visual 
 feedback
  where the widget is being dragged. 
  
 Once the user lifts their finger on top of the 
 DragTarget
 , the target can accept the 
 data
 . To reject 
 accepting the 
 data
 , the user moves away from the 
 DragTarget
  without releasing touch. If you need to 
 restrict the dragging vertically or horizontally, you optionally set the 
 Draggable axis
  property. To 
 catch a single axis drag, you set the 
 axis
  property to either 
 Axis.vertical
  or 
 Axis.horizontal
 .
  
 The 
 DragTarget
  widget listens for a 
 Draggable
  widget and receives 
 data
  if dropped. The 
 DragTarget 
 builder
  property accepts three parameters: the 
 BuildContext
 , 
 List<dynamic> acceptedData 
 (
 candidateData
 ), and 
 List<dynamic>
  of 
 rejectedData
 . The 
 acceptedData
  is the 
 data
  passed from 
 the 
 Draggable
  widget, and it expects it to be a 
 List
  of values. The 
 rejectedData
  contains the 
 List
  of 
 data
  that will not be accepted.
  
 TRY IT OUT 
  
 Gestures: Adding Drag and Drop
  
 In this section you’re going to add to the previous app an additional drag area that catches drag events. 
 You’ll create two widgets: a palette 
 Icon
  widget that is draggable around the screen and a 
 Text
  widget that 
 receives data by accepting a drag gesture. When the 
 Text
  widget receives data, it will change its text color 
 from a light gray to a deep orange color but only if the drag is released on top of it.
  
 To keep the example clean, the 
 Draggable data
  property passes the deep color orange as an 
 integer 
 value
 . The 
 DragTarget
  accepting an 
 integer value
  checks whether a 
 Draggable
  is over it. If not, a 
 default label shows the message “Drag To and see the color change.” If 
 Draggable
  is over it and 
 data 
 has a 
 value, you see a label with the 
 data
  passed. The ternary operator (conditional statement) is used to check 
 whether the 
 data
  is passed.
  
  
 Continuing with the previous gestures project, let’s add the 
 Draggable
  and 
 DragTarget
  methods.
  
 1. 
 Create the 
 _buildDraggable()
  method, which returns a 
 Draggable integer
 . The 
 Draggable 
 child
  is a 
 Column
  with the 
 children
  list of 
 Widget
  consisting of an 
 Icon
  and a 
 Text
  widget. The 
 feedback
  property is an 
 Icon
 , and the 
 data
  property passes the 
 Color
  as an 
 integer value
 . The",NA
USING THE GESTUREDETECTOR FOR MOVING AND SCALING,"Now you’ll build upon what you learned in the “Setting Up GestureDetector: The Basics” section, and by 
 taking a more in-depth look, you’ll learn how to scale widgets by using single or multitouch gestures. 
 The goal is to learn how to implement multitouch scaling of an image by zooming in/out, double tap to 
 increase zoom, and long press to reset the image to original size. The 
 GestureDetector 
 gives you the 
 ability to accomplish scaling by using 
  
 onScaleStart
  and 
 onScaleUpdate
 . Use 
 onDoubleTap
  to 
 increase the zoom, and use 
 onLongPress
  to reset the zoom to 
 the original default size.
  
 When the user taps the image, the image can be dragged 
 around to change position or scaled by zooming in/out. To 
 accomplish both requirements, you’ll use the 
 Transform 
 widget. Use the 
 Transform.scale
  constructor to resize the 
 image, and use the 
 Transform.translate
  constructor to 
 move the image (Figure 11.2).
  
 The 
 Transform
  widget applies a transformation before the 
 child
  is painted. Using the 
 Transform default
  construc-tor, 
 the 
 transform
  argument is set by using the 
 Matrix4
  (4D 
 Matrix) class, and this transformation matrix is applied to the 
 child
  during painting. The benefits of using the default 
 constructor are to use the 
 Matrix4
  to execute multiple cascad-
 ing (
 ..scale()..translate()
 ) transformations. The double 
 dots (
 ..
 ) are used to cascade multiple transformations. In 
 Chapter 3, “Learning Dart Basics,” you learned that the cas-cade 
 notation allows you to make a sequence of operations on the 
 same object. The following sample code shows how to use the 
 Matrix4
  class with the cascade notation to apply a 
 scale 
 and a 
 translate
  transform to the same object:
  
 Matrix4.identity()
  
  ..scale(1.0, 1.0)
  
  ..translate(30, 
 30);
  
 The 
 Transform
  widget has four different constructors.
  
  
 FIGURE 11.2:
  Moving and scaling an 
 image
  
 ➤➤
  
 Transform
 : Default constructor taking a 
 Matrix4
  for the transform argument.
  
 ➤➤
  
 Transform.rotate
 : Constructor to rotate a 
 child
  widget around the center by using an 
  
 angle
 . The 
 angle
  argument rotates clockwise by radians. To rotate counterclockwise, pass 
  
 a negative radian.
  
 ➤➤
  
 Transform.scale
 : Constructor to evenly scale a 
 child
  widget on the x-axis and y-axis. 
  
 The widget is scaled by its center alignment. The 
 scale
  argument value of 1.0 is the original 
  
 widget size. Any values above 1.0 scale the widget larger, and values below 1.0 scale 
  
 the widget smaller. A value of 0.0 makes the widget invisible.",NA
USING THE INKWELL AND INKRESPONSE GESTURES,"Both the 
 InkWell
  and 
 InkResponse
  widgets are Material Components that respond to touch ges-tures. 
 The 
 InkWell
  class 
 extends
  (subclass) the 
 InkResponse
  class. The 
 InkResponse
  class extends a 
 StatefulWidget
  class.
  
 For the 
 InkWell
 , the area that responds to touch is rectangular in shape and shows a “splash” effect—
 though it really looks like a ripple. The splash effect is clipped to the rectangular area of the widget (so 
 as not go outside it). If you need to expand the splash effect outside the rectangular area, the 
 InkResponse
  has a configurable shape. By default, the 
 InkResponse
  shows a circular splash effect 
 that can expand outside its shape (Figure 11.3).
  
 FIGURE 11.3:
  InkWell and InkResponse splash",NA
USING THE DISMISSIBLE WIDGET,"The 
 Dismissible
  widget is dismissed by a dragging gesture. The direction of the drag can be changed 
 by using 
 DismissDirection
  for the 
 direction
  property. (See Table 11.2 for 
 DismissDi-rection
  
 options.) The 
 Dismissible child
  widget slides out of view and automatically animates the height or 
 width (depending on dismiss direction) down to zero. This animation happens in two steps; first the 
 Dismissible child
  slides out of view, and second, the size animates down to zero. Once the 
 Dismissible
  is dismissed, you can use the 
 onDismissed
  callback to perform any necessary actions 
 such as removing a data record from the database or marking a to-do item complete (Figure 11.6). 
  
 If you do not handle the 
 onDismissed
  callback, you’ll receive the error “A dismissed 
 Dismissi-ble
  
 widget is still part of the tree.” For example, if you use a 
 List
  of items, once the 
 Dismissible 
 is 
 removed you need to remove the item from the 
 List
  by implementing the 
 onDismissed
  callback. 
 You’ll take a detailed look at how to handle this in step 9 of the next exercise.
  
  
 FIGURE 11.6:
  Dismissible widget showing the swiped row dismissed animation to complete the item",NA
SUMMARY,"In this chapter, you learned how to use a 
 GestureDetector
  to handle 
 onTap
 , 
 onDoubleTap
 , 
 onLongPress
 , and 
 onPanUpdate
  gestures. The 
 onPanUpdate
  is suitable to use when you need to track 
 dragging in any direction. You took an in-depth look at using the 
 GestureDetector
  to move, scale by 
 zooming in/out, double tap to increase zoom, and long press to reset the elephant image to original size. 
 For example, these techniques would be applied to a journaling app when a user selected an image and 
 wanted to look closer at details. To accomplish this goal, you used the 
 onScaleStart 
 and 
 onScaleUpdate
  to scale the image. Use the 
 onDoubleTap
  to increase the zoom and 
 onLongPress 
 to 
 reset the zoom to the original default size.
  
 You learned two different techniques to scale and move the image when a gesture is detected. With 
 the first technique, you used the 
 Transform
  widget by nesting the 
 Transform.scale
  constructor to 
 resize the image and the 
 Transform.translate
  constructor to move the image. For the second 
 technique, you used the 
 Transform default
  constructor by using the 
 Matrix4
  to apply the trans-
 formations. By using the 
 Matrix4
 , you executed multiple cascading transformations (
 ..scale().. 
 translate()
 ) without the need to nest multiple 
 Transform
  widgets.
  
 You used the 
 InkWell
  and 
 InkResponse
  to respond to touch gestures like tap, double tap, and long 
 press. Both widgets are Material Components (Flutter material design widgets) that display a splash-
 ing effect when tapped.
  
 You implemented the drag-and-drop feature by using the 
 Draggable
  and 
 DragTarget
  widgets. These 
 widgets are used in conjunction. The 
 Draggable
  widget has a 
 data
  property that passes information to 
 the 
 DragTarget
  widget. The 
 DragTarget
  widget can accept or refuse the data, which gives you the 
 ability to check for the correct data format. In this example, you dragged the paint palette 
 Icon 
 (
 Draggable
 ) over the 
 Text
  (
 DragTarget
 ) widget, and once you let go, the 
 Text
  color changes to red.
  
 The 
 Dismissible
  widget listens to vertical and horizontal dragging gestures. By using the 
  
 DismissDirection
  for the direction property, you can limit which dragging gestures you listen to, such 
 as restricting to horizontal-only gestures. In this example, you created a 
 List
  of 
 Trip
  items that are 
 displayed with the 
 ListView.builder
 . When the user drags an item on the list from left to right, a 
 green background with a checkbox 
 Icon
  is revealed to convey the action that is about to be per-formed, 
 completing the trip. But if the user drags on the list item from right to left, a red background with a 
 trash can 
 Icon
  is revealed to convey the action that the trip is going to be deleted. How does",NA
12 ,NA,NA
Writing Platform-Native Code,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤➤
  
 How to use platform channels to send and receive messages from the Flutter app to 
  
 iOS and Android to access specific API functionality
  
 ➤➤
  
 How to write native platform code in iOS Swift and Android Kotlin to access device 
  
 information
  
 ➤➤
  
 How to use 
 MethodChannel
  to send messages from the Flutter app (on the 
  
 client side)
  
 ➤➤
  
 How to use 
 FlutterMethodChannel
  on iOS and 
 MethodChannel
  on Android to 
  
 receive calls and send back results (on the host side)
  
 Platform channels give you the ability to use native features such as accessing the device 
 information, GPS location, local notifications, local file system, sharing, and many more. In the 
 “External Packages” section of Chapter 2, “Creating a Hello World App,” you learned how to use 
 third-party packages to add functionality to your apps. In this chapter, instead of relying on third-
 party packages, you’ll learn how to add custom functionality to your apps by using platform 
 channels and writing the API code yourself. You’ll build an app that asks the iOS and Android 
 platforms to return the device information.",NA
UNDERSTANDING PLATFORM CHANNELS,"When you need to access platform-specific APIs for iOS and Android, you use platform chan-nels 
 to send and receive messages. The Flutter app is the client, and the platform-native code for iOS 
 and Android is the host. If needed, it is also possible to have the platform-native code to act as a 
 client to call methods written in the Flutter app dart code.
  
 The messages between the client and host are asynchronous, making sure that the UI remains 
 responsive and not blocked. In Chapter 3, “Learning Dart Basics,” you learned that 
 async
  func-
 tions perform time-consuming operations without waiting for those operations to complete.",NA
IMPLEMENTING THE CLIENT PLATFORM CHANNEL APP,"To start communication from the Flutter client app to the iOS and Android platforms, you use the 
 MethodChannel
 . A 
 MethodChannel
  uses asynchronous method calls, and the channel requires a 
 unique name. The channel name needs to be the same for the client as for the iOS and Android host. 
 I suggest when you’re creating a unique name for the channel that you use the app name, a domain 
 prefix, and a descriptive name for the task such as 
 platformchannel.companyname.com/ 
 deviceinfo
 .
  
 // Name template 
  
 appname.domain.com/taskname 
  
 // Channel name 
  
 platformchannel.companyname.com/deviceinf
 o
  
 At first, it seems that you are going overboard naming the channel, so why is it important for the 
 name to be unique? If you have multiple named channels and they share the same name, they will 
 cause conflicts with each other’s messages.
  
 To implement a channel, you create the 
 MethodChannel
  through the default constructor by pass-ing 
 the unique channel name. The default constructor takes two arguments: the first is the channel name, 
 and the second (which is optional) declares the default 
 MethodCodec
 . The 
 MethodCodec
  is the 
 StandardMethodCodec
 , which uses Flutter’s standard binary encoding; this means the serialization of 
 data sent between the client and the host is automatically handled. Since you know the name of the 
 channel at compile time and it will not change, you create the 
 MethodChannel
  to a 
 static const 
 variable. Make sure you use the 
 static
  keyword, or you will receive the error “Only static fields can be 
 declared as const.”
  
 static const platform = const 
  
 MethodChannel('platformchannel.companyname.com/deviceinfo')
 ;
  
 Table 12.1 displays the supported value types for Dart, iOS, and Android.
  
 TABLE 12.1: 
 StandardMessageCodec-Supported Value Types
  
 DART
  
 iOS
  
 ANDROID
  
 null
  
 nil
  
 null
  
 bool
  
 NSNumber numberWithBool:
  
 java.lang.Boolean
  
 int
  
 NSNumber numberWithInt:
  
 java.lang.Integer
  
 int
  (bigger 
  
 than 32 bits)
  
 NSNumber numberWithLong:
  
 java.lang.Long
  
 double
  
 NSNumber numberWithDouble:
  
 java.lang.Double
  
 String
  
 NSString
  
 java.lang.String
  
 Uint8List
  
 FlutterStandardTypedData 
 typedDataWithBytes:
  
 byte[]
  
 continues",NA
IMPLEMENTING THE iOS HOST PLATFORM CHANNEL,"The host is responsible for listening to incoming messages from the client. Once a message is received, 
 the channel checks for a matching method name, executes the call method, and returns the appropri-ate 
 result. In iOS, you use the 
 FlutterMethodChannel
  for listening to incoming messages that take two 
 parameters. The first parameter is the same platform channel name—'
 platformchannel. 
 companyname.com/deviceinfo
 '—as the client. The second is the 
 FlutterViewController
 , which is 
 the main 
 rootViewController
  of an iOS app. The 
 rootViewController
  is the root view controller for 
 the iOS app window that provides the content view of the window.",NA
IMPLEMENTING THE ANDROID HOST PLATFORM CHANNEL,"The host is responsible for listening for incoming messages from the client. Once a message is received, 
 the channel checks for a matching method name, executes the call method, and returns the appropriate 
 result. In Android, you use the 
 MethodChannel
  to listen to incoming messages that take two 
 parameters. The first parameter is the 
 FlutterView
 , which extends the 
 Activity
  of an Android app 
 screen and, by using the 
 flutterView
  variable as the parameter, is the same as calling the 
 getFlutterView()
  (
 FlutterView
 ) method from the 
 FlutterActivity
  class. The second parameter 
 is the same platform channel name 
 platformchannel.companyname.com/deviceinfo
  as the client.
  
 private val DEVICE_INFO_CHANNEL = 
 ""platformchannel.companyname.com/deviceinfo"" val methodChannel = 
 MethodChannel(flutterView, DEVICE_INFO_CHANNEL)
  
 You then use the 
 setMethodCallHandler
  (
 Future
  handler) to set up a callback for a matching method 
 name that executes the Android native platform code. Once completed, it sends the result to the client.
  
 methodChannel.setMethodCallHandler { call, result ->
  
  // Check for incoming method call name and return a result 
 }
  
 Both the 
 MethodChannel
  and the 
 setMethodCallHandler
  are placed in the 
 onCreate
  method of the 
 Android app’s 
 MainActivity.kt
  file. The 
 onCreate
  is called when the activity is first created.
  
  override fun onCreate(savedInstanceState: Bundle?) 
 {
  
  // Code
  
  }
  
 TRY IT OUT 
  
 Creating the Android Host Platform Channel
  
 In this example, you want to retrieve the running device information such as the manufacturer, device 
 model, name, operating system, and a few other details. The Android host is written in Kotlin to access 
 the platform API call to the 
 Build
  class to query the device information and uses the 
 MethodChannel 
 to 
 receive communication from the client. Once the message is received, the 
 setMethodCallHandler 
 handles the request and returns the result.
  
 In this section, you’ll open another instance of Android Studio and edit the native Android Kotlin code.
  
 1. 
  
 If you closed the Flutter project 
 ch12_platform_channel
 , reopen it. Click on the Android Studio 
 Tools menu bar and select Flutter 
 ➪
  Open for Editing in Android Studio.",NA
SUMMARY,"In this chapter, you learned how to access and communicate with iOS and Android platform-specific API 
 code by implementing platform channels. Platform channels are a way for the Flutter app (client) to 
 communicate (messages) with iOS and Android (host) to request and receive results specific to the 
 operating system (OS). For the UI to remain responsive and not blocked, the messages between the 
 client and host are asynchronous.
  
 To start communicating from the Flutter app (client), you learned to use the 
 MethodChannel
  that sends 
 messages that contain method calls to be executed by the iOS and Android (host) side. Once the host 
 processes the method requested, it then sends back a response to the client, and you update the UI to 
 display the information. The 
 MethodChannel
  uses a unique name, and you used a combination of the 
 app name, the domain prefix, and the task name like 
 platformchannel.companyname.com/ 
 deviceinfo
 . To start the call from the client and specify which method to execute on the host, you 
 learned to use the 
 invokeMethod
  constructor, and it is called from inside a 
 Future
  method since calls 
 are 
 asynchronous
 .
  
 For the iOS and Android host, you learned to use the Flutter 
 FlutterMethodChannel
  on iOS and the 
 MethodChannel
  on Android to start receiving communications from the client. The host is responsi-ble 
 for listening to incoming messages from the client. You used the 
 setMethodCallHandler
  to set up a 
 callback for an incoming matching method name that executes on the native platform-specific API code. 
 Once the method completes, it sends the result to the client.
  
 In the next chapter, you’ll learn to use local persistence to save data locally to the device storage area.",NA
PART III ,NA,NA
Creating Production-Ready Apps,"▸
  CHAPTER 13:
  Saving Data with Local Persistence
  
 ▸
  CHAPTER 14:
   Adding the Firebase and Firestore Backend▸
  
 CHAPTER 15:
   Adding State Management to the Firestore 
  
 Client 
 App
  
 ▸
  CHAPTER 16:
  Adding BLoCs to Firestore Client App Pages",NA
13 ,NA,NA
Saving Data with Local ,NA,NA
Persistence,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to persist saving and reading data locally 
  
 How to structure data by using the JSON file format 
  
 How to create model classes to handle JSON serialization 
  
 How to access local iOS and Android filesystem locations using the 
  
  
 path provider package
  
 ➤➤
  
 How to format dates by using the internationalization package
 ➤➤
  
 How to use the 
 Future
  class with the 
 showDatePicker
  to present a 
  
 calendar to choose dates
  
 ➤➤
  
 How to use the 
 Future
  class to save, read, and parse JSON files
 ➤➤
  
 How to use the 
 ListView.separated
  constructor to section 
  
 records with a 
 Divider
  
 ➤➤
  
 How to use 
 List
 ()
 .sort
  to sort journal entries by date
  
 ➤➤
  
 How to use 
 textInputAction
  to customize keyboard actions
 ➤➤
  
  
 How to use 
 FocusNode
  and 
 FocusScope
  with the keyboard 
  
 on 
 Submitted
  to move the cursor to the next entry’s 
 TextField
 ➤➤
  
 How to pass and receive data in a class by using the 
 Navigator
  
 In this chapter, you’ll learn how to 
 persist
  data—that is, save data on the device’s local storage 
 directory—across app launches by using the JSON file format and saving the file to the local iOS 
 and Android filesystem. JavaScript Object Notation (JSON) is a common open-standard",NA
UNDERSTANDING THE JSON FORMAT,"The JSON format is text-based and is independent of programming languages, meaning any of them can 
 use it. It’s a great way to exchange data between different programs because it is human-readable text. 
 JSON uses the key/value pair, and the key is enclosed in quotation marks followed by a colon and then 
 the value like 
 ""id"":""100""
 . You use a comma (
 ,
 ) to separate multiple key/value pairs. Table 13.1 
 shows some examples.
  
 TABLE 13.1: 
 Key/Value Pairs
  
 KEY
  
 COLON
  
 VALUE
  
 ""id""
  
 :
  
 ""100""
  
 ""quantity""
  
 :
  
 3
  
 ""in_stock""
  
 :
  
 true
  
 The types of values you can use are Object, Array, String, Boolean, and Number. Objects are declared by 
 curly (
 {}
 ) brackets, and inside you use the key/value pair and arrays. You declare arrays by using the 
 square (
 []
 ) brackets, and inside you use the key/value or just the value. Table 13.2 shows some 
 examples.
  
 TABLE 13.2: 
 Objects and Arrays
  
 TYPE
  
 SAMPLE
  
 Object
  
 {
  
  ""id"": ""100"",
  
  ""name"": ""Vacation"" 
  
 }
  
 Array with values only
  
 [""Family"", ""Friends"", ""Fun""]",NA
"USING DATABASE CLASSES TO WRITE, READ, AND ",NA,NA
SERIALIZE JSON,"To create reusable code to handle the database routines such as writing, reading, and serializing 
 (encoding and decoding) data, you’ll place the logic in classes. You’ll create four classes to handle 
 local persistence, with each class responsible for specific tasks.
  
 ➤➤
  
 The 
 DatabaseFileRoutines
  class uses the 
 File
  class to retrieve the device local document 
  
 directory and save and read the data file.
  
 ➤➤
  
 The 
 Database
  class is responsible for encoding and decoding the JSON file and mapping it 
  
 to 
 a 
 List
 .
  
 ➤➤
  
 The 
 Journal
  class maps each journal entry from and to JSON.
  
 ➤➤
  
 The 
 JournalEdit
  class is used to pass an action (save or cancel) and a journal entry bet-
  
 ween pages.
  
 The 
 DatabaseFileRoutines
  class requires you to import the 
 dart:io
  library to use the 
 File
  class 
 responsible for saving and reading files. It also requires you to import the 
 path_provider
  package to 
 retrieve the local path to the document directory. The 
 Database
  class requires you to import the 
 dart:convert
  library to decode and encode JSON objects.
  
 The first task in local persistence is to retrieve the directory path where the data file is located on the 
 device. Local data is usually stored in the application documents directory; for iOS, the folder is called 
 NSDocumentDirectory
 , and for Android it’s 
 AppData
 . To get access to these folders, you use the 
 path_provider
  package (Flutter plugin). You’ll be calling the 
 getApplicationDocuments-
 Directory()
  method, which returns the directory giving you access to the 
 path
  variable.
  
 Future<String> get _localPath async {
  
  final directory = await getApplicationDocumentsDirectory();
  
  return directory.path; 
  
 }",NA
FORMATTING DATES,"To format dates, you use the 
 intl
  package (Flutter plugin) providing internationalization and locali-
 zation. The full list of available date formats is available on the 
 intl
  package page site at 
 https:// 
 pub.dev/packages/intl
 . For our purposes, you’ll use the 
 DateFormat
  class to help you N format 
 and parse dates. You’ll use the 
 DateFormat
  named constructors to format the date according to the 
 specification. To format a date like Jan 13, 2019, you use the 
 DateFormat.yMMD()
  constructor, and",NA
SORTING A LIST OF DATES,"You learned how to format dates easily, but how would you sort dates? The journal app that you’ll 
 create requires you to show a list of entries, and it would be great to be able to display the list sorted by 
 date. In particular, you want to sort dates to show the newest first and oldest last, which is known as 
 DESC (descending) order. Our journal entries are displayed from a 
 List
 , and to sort them, you call the 
 List().sort()
  method.
  
 The 
 List
  is sorted by the order specified by the function, and the function acts as a 
 Comparator
 , com-
 paring two values and assessing whether they are the same or whether one is larger than the other—
 such as the dates 2019-01-20 and 2019-01-22 in Table 13.3. The 
 Comparator
  function returns an 
 integer as negative, zero, or positive. If the comparison—for example, 2019-01-20 > 2019-01-22—is 
 true
 , it returns 1, and if it’s 
 false
 , it returns -1. Otherwise (when the values are equal), it returns 0.",NA
RETRIEVING DATA WITH THE FUTUREBUILDER,"In mobile applications, it is important not to block the UI while retrieving or processing data. In Chapter 
 3, “Learning Dart Basics,” you learned how to use a 
 Future
  to retrieve a possible value that is available 
 sometime in the future. A 
 FutureBuilder
  widget works with a 
 Future
  to retrieve the latest data 
 without blocking the UI. The three main properties that you set are 
 initialData
 , 
 future
 , and 
 builder
 .
  
 ➤➤
  
 initialData
 : Initial data to show before the snapshot is retrieved.",NA
BUILDING THE JOURNAL APP,"You’ll be building a journal app with the requirement of persisting data across app starts. The data is 
 stored as JSON objects with the requirements of tracking each journal entry’s 
 id
 , 
 date
 , 
 mood
 , and 
 note
  
 (Figure 13.1). As you learned in the “Understanding the JSON Format” section, the 
 id
  key value is 
 unique, and it’s used to identify each journal entry. The 
 id
  key is used behind the scenes to select the 
 journal entry and is not displayed in the UI. The root object is a key/value pair with the key name of 
 'journal'
  and the value as an array of objects containing each journal entry.
  
  
 FIGURE 13.1:
  Journal app
  
 The app has two separate pages; the main presentation page uses a 
 ListView
  sorted by DESC date, 
 meaning last entered record first. You utilize the 
 ListTile
  widget to format how the 
 List
  of records is 
 displayed. The second page is the journal entry details where you use a date picker to select a date from 
 a calendar and 
 TextField
  widgets for entering the mood and note data. You’ll create a data-base Dart 
 file with classes to handle the file routines, database JSON parsing, a 
 Journal
  class to handle individual 
 records, and a 
 JournalEdit
  class to pass data and actions between pages.
  
 Figure 13.2 shows a high-level view of the journal app detailing how the database classes are used in 
 the Home and Edit pages.",NA
Adding the Journal Database Classes,"You’ll create four separate classes to handle the database routines and serialization to manage the 
 journal data. Each class is responsible for handling specific code logic, resulting in code reusability. 
 Collectively the database classes are responsible for writing (saving), reading, encoding, and decoding 
 JSON objects to and from the JSON file.
  
 ➤➤
  
 The 
 DatabaseFileRoutines
  class
  handles getting the path to the device’s local documents 
  
 directory and saving and reading the database file by using the 
 File
  class. The 
 File
  class 
  
 is used by importing the 
 dart:io
  library, and to obtain the documents directory path, you 
  
 import the 
 path
 _
 provider
  package.
  
 ➤➤
  
 The 
 Database
  class
  handles decoding and encoding the JSON objects and converting them 
  
 to a 
 List
  of journal entries. You call 
 databaseFromJson
  to read and parse from JSON 
  
 objects. You call 
 databaseToJson
  to save and parse to JSON objects. The 
 Database
  class 
  
 returns the 
 journal
  variable consisting of a 
 List
  of 
 Journal
  classes, 
 List<Journal>
 . The 
  
 dart:convert
  library is used to decode and encode JSON objects.
  
 ➤➤
  
 The 
 Journal
  class
  handles decoding and encoding the JSON objects for each journal 
  
 entry. 
 The 
 Journal
  class contains the 
 id
 , 
 date
 , 
 mood
 , and 
 note
  journal entry fields stored 
  
 as 
 String
 s.
  
 ➤➤
  
 The 
 JournalEdit
  class
  handles the passing of individual journal entries between pages. 
  
 The 
 JournalEdit
  class contains the 
 action
  and 
 journal
  variables. The 
 action
  variable is 
  
 used to track whether the Save or Cancel button is pressed. The 
 journal
  variable contains 
  
 the individual journal entry as a 
 Journal
  class containing the 
 id
 , 
 date
 , 
 mood
 , and 
 note 
  
 variables.",NA
Adding the Journal Entry Page,"The entry page is responsible for adding and editing a journal entry. You might ask, how does it know 
 when to add or edit a current entry? You created the 
 JournalEdit
  class in the 
 database.dart
  file for 
 this reason—to allow you to reuse the same page for multiple purposes. The entry page extends a 
 StatefulWidget
  with the constructor (Table 13.4) having the three arguments 
 add
 , 
 index
 , and 
 journalEdit
 . Note that the index argument is used to track the selected journal entry location in the 
 journal database list from the Home page. However, if a new journal entry is created, it does not exist in 
 the list yet, so a value of -1 is passed instead. Any index numbers zero and up would mean the journal 
 entry already exists in the list.
  
 TABLE 13.4: 
 EditEntry Class Constructor Arguments
  
 VARIABLE
  
 DESCRIPTION AND VALUE
  
 final bool add
  
 If the 
 add
  variable value is 
 true
 , it means you are adding a new 
 journal. If the value is 
 false
 , you are editing a journal entry.
  
 final int index
  
 If the index variable value is 
 -1
 , it means you are adding a new journal 
 entry. If the value is 
 0
  or greater, you are editing a journal entry, and you 
 need to track the index position in the 
 List<Journal>
 .",NA
Finishing the Journal Home Page,"The Home page is responsible for showing a list of journal entries. In Chapter 9, “Creating Scroll-ing 
 Lists and Effects,” you learned how to use the 
 ListView.builder
 , but for this app, you’ll learn how to 
 use the 
 ListView.separated
  constructor. By using the 
 separated
  constructor, you have the same 
 benefits of the 
 builder
  constructor because the builders are called only for the children who",NA
SUMMARY,"In this chapter, you learned how to persist data by saving and reading locally to the iOS and Android 
 device filesystem. For the iOS device, you used the 
 NSDocumentDirectory
 , and for the Android device, 
 you used the 
 AppData
  directory. The popular JSON file format was used to store the journal entries to a 
 file. You created a journaling mood app that sorts the list of entries by DESC date and allows adding and 
 modifying records.
  
 You learned how to create the database classes for handling local persistence to encode and decode 
 JSON objects and write and read entries to a file. You learned how to create the 
 DatabaseFile-
 Routines
  class to obtain the path of the local device documents directory and save and read the 
 database file using the 
 File
  class. You learned how to create the 
 Database
  class handling decoding 
 and encoding JSON objects and converting them to a 
 List
  of journal entries. You learned how to use 
 json.encode
  to parse values to a JSON string and 
 json.decode
  to parse the string to a JSON object. 
 The 
 Database
  class returns a 
 List
  of 
 Journal
  classes, 
 List<Journal>
 . You learned how to create 
 the 
 Journal
  class to handle decoding and encoding the JSON objects for each journal entry. 
  
 The 
 Journal
  class contains the 
 id
 , 
 date
 , 
 mood
 , and 
 note
  fields stored as 
 String
  type. You learned how 
 to create the 
 JournalEdit
  class responsible for passing an 
 action
  and individual 
 Journal
  class 
 entries between pages.",NA
14 ,NA,NA
Adding the Firebase and ,NA,NA
Firestore Backend,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to create a Firebase project 
  
 How to register the iOS and Android projects to use Firebase How 
 to add a Cloud Firestore database 
  
 How to structure and create a data model for the Cloud Fire-
  
  
 store database
  
 ➤➤
  
 How to enable and add Firebase authentication
  
 ➤➤
  
 How to create Firestore security rules
  
 ➤➤
  
 How to create the Flutter client app base structure
  
 ➤➤
  
  
 How to add Firebase to iOS and how to add the Android projects 
  
 with the Google service files
  
 ➤➤
  
 How to add the Firebase and Cloud Firestore packages
  
 ➤➤
  
 How to add the 
 intl
  package to format dates
  
 ➤➤
  
 How to customize the 
 AppBar
  and 
 BottomAppBar
  look and feel by 
  
 using the 
 BoxDecoration
  and 
 LinearGradient
  widgets
  
 In this chapter, in Chapter 15, and in Chapter 16, you’ll use techniques that you have learned in 
 previous chapters along with new concepts and tie them together to create a production-level 
 mood-journaling app. In the previous chapters, you created many projects that taught you dif-
 ferent ways to implement specific tasks and objectives. In a production-level app, you need to 
 combine what you have learned to improve performance by redrawing only the widgets with",NA
WHAT ARE FIREBASE AND CLOUD FIRESTORE?,"Before you start configuring, let’s take a look at what Firebase encompasses. Firebase consists of one 
 platform with a multitude of products that share and work together. Firebase handles the entire back-
 end server infrastructure connecting iOS, Android, and web apps.
  
 Build Apps
  
 ➤➤
  
 Cloud Firestore
 —Store and sync NoSQL data in documents and collections between devices
  
 ➤➤
  
 Real-time database
 —Store and sync NoSQL data as one large JSON tree between devices
  
 ➤➤
  
 Cloud storage
 —Store and serve files
  
 ➤➤
  
 Cloud functions
 —Run backend code
  
 ➤➤
  
 Authentication
 —Secure user’s authentication
  
 ➤➤
  
 Hosting
 —Deliver web app assets",NA
Structuring and Data Modeling Cloud Firestore,"To understand the Cloud Firestore data structure, let’s compare it to a standard SQL Server database 
 (see Table 14.1). The SQL Server database is a relational database management system (RDBMS) that 
 supports table and row data modeling (Figure 14.1). The comparison is not a one-to-one but a guideline 
 since the data structures differ.",NA
Viewing Firebase Authentication Capabilities ,"Adding security to an app is extremely important in keeping the information private and safe. Fire-base 
 Authentication provides built-in backend services accessible from the client’s SDK to support full 
 authentication. The following is a list of the currently available authentication sign-in providers:
  
  
 ➤➤
  
 Email/Password
  
  
  
 ➤➤
  
 Phone
  
  
  
 ➤➤
  
 Google
  
  
  
 ➤➤
  
 Play Games (Google)
  
  
  
 ➤➤
  
 Game Center (Apple)
  
  
  
 ➤➤
  
 Facebook
  
  
  
 ➤➤
  
 Twitter
  
  
  
 ➤➤
  
 GitHub
  
  
  
 ➤➤
  
 Anonymous
  
 Each authentication sign-in provider is disabled by default, and you enable the providers needed 
 for your app specs (Figure 14.4). I’ll walk you through how to enable a sign-in provider later in 
 this chapter.
  
  
 FIGURE 14.4:
  Firebase Authentication’s Sign-In Providers",NA
Viewing Cloud Firestore Security Rules,"To secure access to collections and documents, you implement Cloud Firestore security rules. In the 
 previous section, you learned that you create a Firebase User object through the Firebase Authentica-
 tion SDK. Once you have the Firebase User object’s unique ID, you use it with Cloud Firestore secu-rity 
 rules to secure and lock data to each user. The following code shows the security rules that you’ll create 
 for securing the Cloud Firestore database:
  
 service cloud.firestore {
  
  match /databases/{database}/documents {
  
   
  match /journals/{document=**} {
  
    
  allow read, write: if resource.data.uid == 
 request.auth.uid;
  
  
  
  allow create: if 
 request.auth.uid != null;
  
   
  }
  
  } 
  
 }
  
 The rules are editable from the database rules page on the Firebase console website. The rules consist 
 of using the 
 match
  statements to identify documents, with the 
 allow
  expressions to control access to 
 the documents. Every time you change the rules and save them, a history of changes is automatically 
 created, allowing you to revert changes if needed (Figure 14.5).
  
 Let’s take a look at an example that requires rules to allow a user to read and write documents assigned 
 to them. The first 
 match /databases/{database}/documents
  declaration tells the rules to match any 
 Cloud Firestore Database in the project.
  
 match /databases/{database}/documents
  
 The second and the main part of understanding is to use the 
 match
  statement to point to the collec-
 tion and expression to evaluate, as in 
 match /journals/{document=**}
 . The 
 journals
  declara-tion 
 is the container name, and the expression to evaluate is 
 document=**
  (all documents for the",NA
CONFIGURING THE FIREBASE PROJECT,"You now understand how Cloud Firestore stores data and the benefits of syncing multiple devices 
 with offline data persistence. The offline feature works by caching a copy of the app’s active data, 
 making it accessible when the device is offline. Before you can use Cloud Firestore in your app, you 
 need to create a Firebase project.
  
 A Firebase project is backed by the Google Cloud Platform, which allows apps to scale. The Firebase 
 project is a container that supports sharing features such as the database, notifications, users, remote 
 config, crash reports, and analytics (many more) between the iOS, Android, and web apps. Each account 
 can have multiple projects, for example to separate different and unrelated applications.
  
 TRY IT OUT 
  
 Creating the Firebase Project
  
 You need to create a Firebase project that sets up a container to start adding your Cloud Firestore database 
 and enabling authentication. You will start by adding the iOS app, and then you’ll continue by adding the 
 Android app.
  
 1. 
 Navigate to 
 https://console.firebase.google.com
  and log in to Google Firebase with your 
 Google account. If you do not have a Google account, you can create one at 
 https://accounts 
 .google.com/SignUp
 .",NA
ADDING A CLOUD FIRESTORE DATABASE AND ,NA,NA
IMPLEMENTING SECURITY,"You’ve learned how to create a Firebase project, making it possible to add the Cloud Firestore data-base 
 and Firebase Authentication. You learned about the different available sign-in methods, and in this 
 section, you’ll walk through how to implement security rules and enable an authentication sign-in 
 method—specifically, an email/password authentication provider.
  
 TRY IT OUT 
  
 Creating the Cloud Firestore Database and Enabling Authentication
  
 In this exercise, you’ll learn how to enable Firebase Authentication, create a Cloud Firestore database, 
 and implement security rules to keep the data private for each user.
  
 1. 
 Navigate to 
 https://console.firebase.google.com
  and select the journal project.
  
 2. 
 From the menu on the left, click the Authentication link in the Develop section. If the Develop 
 section is closed, click the Develop link to open the submenu. Click the Sign-in Method tab 
 showing a list of available sign-in providers.",NA
BUILDING THE CLIENT JOURNAL APP,"The process of creating the mood-journaling app spans from this chapter to Chapter 16. In this sec-tion, 
 you’ll create the base structure of the app and configure the iOS and Android projects to use Firebase 
 Authentication and the Cloud Firestore database. You’ll modify the basic look and feel of the app by 
 using color gradients.
  
 The goal of the mood-journaling app is to have the ability to list, add, and modify journal entries by 
 collecting a date, a mood, a note, and the user’s ID. You’ll learn to create a login page to authenticate 
 users through the email/password Firebase Authentication sign-in provider. The main presentation 
 page implements a 
 ListView
  widget by using the 
 separated
  constructor sorted by DESC (descend-ing) 
 date, meaning last entered record first. The 
 ListTile
  widget easily formats how you’ll display the 
 List
  
 of records. The journal entry page uses the 
 showDatePicker
  widget to select a date from a calendar, a 
 DropdownButton
  widget to select from a list of moods, and a 
 TextField
  widget to enter the note.",NA
Adding Authentication and Cloud Firestore Packages to the Client ,NA,NA
App,"It’s time to create the Flutter app and add the Firebase Authentication and Cloud Firestore SDKs by 
 installing the Firebase Flutter packages. The Flutter team authors the different Firebase pack-ages, 
 and like other packages, the full package source code is available on the appropriate package’s GitHub 
 page.
  
 You’ll install the 
 firebase_auth
 , 
 cloud_firestore
 , and 
 intl
  packages. You’ll download the Google 
 service files (config) for iOS and Android that contain properties needed to access the Firebase products 
 from the client app.
  
 TRY IT OUT 
  
 Creating the Journal App
  
 In this example, you’ll build a production-level journal app similar to the one in Chapter 13, but instead, it 
 uses Firebase Authentication for security and the Cloud Firestore database for storing and syncing data. 
 The structure of how you read and save data is completely different. You’ll also add mood tracking to each 
 journal entry. You’ll use some new and familiar packages in this exercise.
  
 ➤➤
  
 To add security to your journal app, you’ll use the 
 firebase
 _
 auth
  package, which provides 
  
 authentication.",NA
Adding Basic Layout to the Client App,"In the previous section, you learned how to add and configure Firebase Authentication and the Cloud 
 Firestore database. The next step is to work on the Flutter project to customize the look and feel of the 
 journal app.
  
 You’ll customize the app’s background color by setting the 
 MaterialApp canvasColor
  property to a 
 light shade of green. The 
 AppBar
  and 
 BottomAppBar
  customizations show a color gradient from light 
 green to a 
 very
  light shade of green, merging with the app’s background color. To achieve the color 
 effect, set the 
 BoxDecoration gradient
  property by using a 
 LinearGradient
  widget that you 
 learned in Chapter 6, “Using Common Widgets.”
  
 TRY IT OUT 
  
 Adding a Basic Layout to the Journal App
  
 In this section, continue to edit the 
 journal
  project by customizing the app’s colors and look and feel, 
 giving it that professional look.
  
 1. 
  
 Open the 
 main.dart
  file. Modify the 
 MaterialApp title
  property to 
 Journal
  and modify the 
 ThemeData primarySwatch
  property to 
 Colors.lightGreen
 . Add the 
 canvasColor
  property and 
  
 set the color to 
 Colors.lightGreen.shade50
 . Add the 
 bottomAppBarColor
  property and set the 
 color to 
 Colors.lightGreen
 .
  
 return MaterialApp(
  
  debugShowCheckedModeBanner: false,
  
  title: 'Journal',
  
  theme: ThemeData(
  
   
  primarySwatch: Colors.lightGreen,
  
   
  canvasColor: 
 Colors.lightGreen.shade50,
  
   
  bottomAppBarColor: Colors.lightGreen,
  
  ),
  
  home: Home(), 
  
 );
  
 2. 3. 
  
 Open the 
 home.dart
  file, set the 
 AppBar title
  property’s 
 Text
  widget to 
 Journal
 , and set the 
 TextStyle color
  property to 
 Colors.lightGreen.shade800
 .
  
 To customize the 
 AppBar
  background color with a gradient, remove the 
 AppBar
  widget shadow by 
 setting the 
 elevation
  property to 
 0.0
 . To increase the 
 AppBar
 ’s height, set the 
 bottom
  property to 
  
 a 
 PreferredSize
  widget with the 
 child
  property as a 
 Container
  widget and the 
 preferredSize 
 property to 
 Size.fromHeight(32.0)
 .
  
 4. 5. 
  
 Set the 
 flexibleSpace
  property to a 
 Container
  widget, with the 
 decoration
  property set to a 
 BoxDecoration
  widget.
  
 Set the 
 BoxDecoration gradient
  property to a 
 LinearGradient
  with the 
 colors
  property set to a 
 list of 
 [Colors.lightGreen,Colors.lightGreen.shade50]
 .",NA
Adding Classes to the Client App,"You’ll need to create two classes to handle formatting dates and tracking the mood icons. The 
 FormatDates
  class uses the 
 intl
  package to format dates. The 
 MoodIcons
  class stores reference to 
 the mood icons 
 title
 , 
 color
 , 
 rotation
 , and 
 icon
 .",NA
SUMMARY,"In this chapter, you learned how to persist and secure data over app launches by using Google’s 
 Firebase, Firebase Authentication, and Cloud Firestore. Firebase is the infrastructure that doesn’t 
 require the developer to set up or maintain backend servers. The Firebase platform allows you to con-
 nect and share data between iOS, Android, and web apps. You configure the Firebase project with the 
 online web console. In this chapter, you registered both the iOS and Android projects with the 
 com 
 .domainname.journal
  package name to connect the client app to the Firebase products.
  
 You created a Cloud Firestore database that safely stores the client app’s data in a cloud database. 
 Cloud Firestore is a NoSQL document database to store, query, and sync data with offline support for 
 mobile and web apps. You structure and data model Cloud Firestore databases by using a collec-tion 
 to store documents that contain data as a key-value pair similar to JSON.
  
 Securing the Cloud Firestore database is done by creating Cloud Firestore security rules. The secu-rity 
 rules consist of using the 
 match
  statements to identify documents, with the 
 allow
  expression to 
 control access.
  
 Firebase Authentication provides built-in backend services that are accessible from the client’s SDK, 
 which supports full user authentication. Enabling the email/password authentication sign-in provider 
 allows users to register and log in to the app. By passing the user credentials (email/password) to the 
 client’s Firebase Authentication SDK, the Firebase backend services verify whether the credentials are 
 valid and return a response to the client app.
  
 You created the base structure of the client mood-journaling app and connected it to the Firebase 
 services by installing the 
 firebase_auth
  and 
 cloud_firestore
  packages. You configured the client 
 iOS and Android projects to use Firebase. You added the 
 GoogleService-Info.plist
  file to the iOS 
 project and the 
 google-services.json
  file to the Android project. The Google service files contain 
 properties needed to access the Firebase products from the client app. You modified the base look and 
 feel of the app by using the 
 BoxDecoration
  widget, with the 
 gradient
  property set to a 
 Linear-
 Gradient
  to create a smooth light green color gradient.
  
 In the next chapter, you’ll learn how to implement app-wide and local state management by using the 
 InheritedWidget
  class and how to maximize platform code sharing and separation by implementing 
 the Business Logic Component pattern. You’ll use state management to implement Firebase Authenti-
 cation, access the Cloud Firestore database, and implement service classes.",NA
15 ,NA,NA
Adding State Management to ,NA,NA
the Firestore Client App,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤➤
  
 How to use state management to control Firebase Authentication 
  
  
 and the Cloud Firestore database
  
 ➤➤
  
 How to use the BLoC pattern to separate business logic
  
 ➤➤
  
 How to use the 
 InheritedWidget
  class as a provider to manage 
  
 and 
 pass state
  
 ➤➤
  
 How to implement 
 abstract
  classes
  
 ➤➤
  
 How to use 
 StreamBuilder
  to receive the latest data from Firebase 
  
 Authentication and the Cloud Firestore database
  
 ➤➤
  
 How to use 
 StreamController
 , 
 Stream
 , and 
 Sink
  to handle Fire-
  
 base 
 Authentication and Cloud Firestore data events
  
 ➤➤
  
 How to create service classes to handle Firebase Authentication 
  
 and 
 Cloud Firestore API calls with 
 Stream
  and 
 Future
  classes
 ➤➤
  
 How to 
 create a model class for individual journal entries and 
  
 convert Cloud 
 Firestore 
 QuerySnapshot
  and map it to the 
  
  
 Journal
  class
  
 ➤➤
  
 How to use the optional Firestore Transaction to save data to the 
  
 Firestore database
  
 ➤➤
  
 How to create a class to handle mood icons, descriptions, 
  
  
 and rotation
  
 ➤➤
  
 How to create a class to handle date formatting
  
 ➤➤
  
 How to use the 
 ListView.separated
  named constructor",NA
IMPLEMENTING STATE MANAGEMENT,"Before you dive into state management, let’s take a look at what state means. At its most basic, 
 state 
 is 
 data that is read synchronously and can change over time. For example, a 
 Text
  widget value is 
 updated to show the latest game score, and the state for the 
 Text
  widget is the value. 
 State manage-
 ment
  is the way to share data (state) between pages and widgets.
  
 You can have app-wide state management to share the state between different pages. For example, the 
 authentication state manager monitors the logged-in user and when the user logs out, it takes the 
 appropriate action to redirect to the login page. Figure 15.1 shows the home page getting the state from 
 the main page; this is app-wide state management.
  
 You can have local-state management confined to a single page or a single widget. For example, the page 
 displays a selected item, and the purchase button needs to be enabled only if the item is in-stock. 
  
 The button widget needs to access the state of the in-stock value. Figure 15.2 shows an Add button 
 getting state up the widget tree; this is local-state management.
  
 There are many different techniques for handling state management, and there isn’t a right or wrong 
 answer on which approach to take because it depends on your needs and personal preference. The 
 beauty is that you can create a custom approach to state management. You have already mastered one 
 of the state-management techniques, the 
 setState()
  method. In Chapter 2 you learned how to use the 
 StatefulWidget
  and call the 
 setState()
  method to propagate changes to the UI. Using the 
 setState()
  method is the default way that a Flutter app manages state changes, and you have used it 
 for all of the example apps that you’ve created from this book.",NA
Implementing an Abstract Class,"One of the main benefits of using an abstract class is to separate the interface methods (called from 
 the UI) from the actual code logic. In other words, you declare the methods without any implemen-
 tation (code). Another benefit is that the abstract class cannot be directly instantiated, meaning an 
 object cannot be created from it unless you define a factory constructor. Abstract classes help you to 
 program to interfaces, not the implementation. Concrete classes implement the methods of the 
 abstract class.
  
 By default (concrete) classes define an interface containing all of the members and methods that it 
 implements. The following example shows the 
 AuthenticationService
  class declaring a variable 
 and methods containing the code logic:
  
 class AuthenticationService {
  
  final FirebaseAuth _firebaseAuth = 
 FirebaseAuth.instance;
  
  Future<void> sendEmailVerification() async {
  
  
  FirebaseUser user = await 
 _firebaseAuth.currentUser();
  
  
 user.sendEmailVerification();
  
  }
  
  Future<bool> isEmailVerified() async {
  
   
  FirebaseUser user = await 
 _firebaseAuth.currentUser();
  
  
  return 
 user.isEmailVerified;
  
  } 
  
 }
  
 You are going to use an 
 abstract
  class to define your authentication interface in this section. The 
 abstract
  class has callable methods without containing the actual code (implementation), and they 
 are called 
 abstract methods
 . To declare an 
 abstract
  class, you use the 
 abstract
  modifier before the 
 class declaration like 
 abstract class Authentication {}
 . The abstract methods work with a 
 class that implements one or more interfaces and is declared by using the 
 implements
  clause like 
 this example: 
 class AuthenticationService implements Authentication {}
 . Note that the 
 abstract method is declared by using a semicolon (
 ;
 ) instead of the body declared by curly brackets 
 (
 {}
 ). The code logic for the abstract methods is implemented (concrete implementation) in the class 
 that implements the 
 abstract
  class.
  
 The following example declares the 
 Authentication
  class as an 
 abstract
  class by using the 
 abstract
  modifier and contains two abstract methods. The 
 AuthenticationService
  class uses the 
 implements
  clause to implement the methods declared by the 
 Authentication
  class.
  
 abstract class Authentication {
  
  Future<void> sendEmailVerification();
  
  Future<bool> isEmailVerified(); 
  
 }",NA
Implementing the InheritedWidget,"One of the ways to pass 
 State
  between pages and the widget tree is to use the 
 InheritedWidget 
 class as a provider. A provider holds an object and provides it to its child widgets. For example, you 
 use the 
 InheritedWidget
  class as the provider of a BLoC class responsible for making API calls to the 
 Firebase Authentication API. As a reminder, the BLoC pattern is covered in the “Implementing the 
 BLoC Pattern” section. In the example we’ll go through now, I cover how to use the 
 Inherited-
 Widget
  class with a BLoC class, but you could also use it with a regular service class instead. You’ll 
 learn how to create service classes in the “Implementing the Service Class” section.
  
 For the journal app, the relationship between the 
 InheritedWidget
  class and the BLoC class is one to 
 one, meaning one 
 InheritedWidget
  class for one BLoC class. You’ll use the 
 of(context)
  to get a 
 reference to the BLoC class; for example, 
 AuthenticationBlocProvider.of(context). 
 authenticationBloc
 .
  
 The following example shows the 
 AuthenticationBlocProvider
  class that 
 extends
  (subclasses) the 
 InheritedWidget
  class. The BLoC 
 authenticationBloc
  variable is marked as 
 final
 , which refer-
 ences the 
 AuthenticationBloc
  BLoC class. The 
 AuthenticationBlocProvider
  constructor takes a 
 Key
 , 
 Widget
 , and 
 this
 .
 authenticationBloc
  variable.
  
 // authentication_provider.dart 
  
 class AuthenticationBlocProvider extends InheritedWidget 
 { final AuthenticationBloc authenticationBloc;",NA
Implementing the Model Class,"The model class is responsible for modeling the data structure. The data model represents the data 
 structure for how the data is stored in the database or data storage. The data structure declares the 
 data type for each variable as a 
 String
  or 
 Boolean
 . You can also implement methods that perform a 
 specific function like mapping data from one format to another.
  
 The following example shows a model class declaring the data structure and a method to map and 
 convert data:
  
 class Journal {
  
  String 
 documentID;
  
  String date;
  
  Journal({
  
  
  
 this.documentID,
  
  
  this.date
  
  });
  
  factory Journal.fromDoc(dynamic doc) => 
 Journal(
  
  
  documentID: doc.documentID,
  
   
  date: doc[""date""]",NA
Implementing the Service Class,"The journal app uses Firebase Authentication to verify user credentials and the Cloud Firestore data-
 base for storing data to the cloud. The services are invoked by making the appropriate API call.
  
 Creating a class to group all of the same type services together is a great option. Another benefit of 
 separating services in service classes is that this makes it easier to create separate classes to imple-
 ment additional or alternative services. For the journal app, you’ll learn how to implement the service 
 classes as abstract classes, but for this example, I wanted to show you how to implement the basic 
 service class.
  
 The following example shows a 
 DbFirestoreService
  class that implements methods to call the 
 Cloud Firestore database API:
  
 class DbFirestoreService {
  
  Firestore _firestore = 
 Firestore.instance;
  
  String _collectionJournals = 'journals';
  
  DbFirestoreService() {
  
  
  _firestore.settings(timestampsInSnapshotsEnabled: 
 true); }
  
  Stream<List<Journal>> getJournalList(String uid) {
  
   
  return _firestore
  
    
  .collection(_collectionJournals)
  
    
  .where('uid', isEqualTo: uid)
  
    
  .snapshots()
  
    
  .map((QuerySnapshot snapshot) {
  
    
  List<Journal> _journalDocs = snapshot.documents.map((doc) => Journal 
 .fromDoc(doc)).toList();
  
    
  _journalDocs.sort((comp1, comp2) => 
 comp2.date.compareTo(comp1.date));
  
  
  
  return _journalDocs;
  
   
  });
  
  }
  
  Future<bool> addJournal(Journal journal) async {}
  
  void updateJournal(Journal journal) async {}
  
  void updateJournalWithTransaction(Journal journal) async 
 {} void deleteJournal(Journal journal) async {} 
  
 }",NA
Implementing the BLoC Pattern,"BLoC stands for Business Logic Component, and it was conceived to define a platform-agnostic inter-
 face for the business logic. The BLoC pattern was developed internally by Google to maximize code 
 sharing between Flutter mobile and AngularDart web apps. It was first publicly presented by Paolo 
 Soares at the DartConf 2018 conference. The BLoC pattern exposes streams and sinks to handle data 
 flow, making the pattern reactive. In its simplest form, reactive programming handles the data flow 
 with asynchronous streams and the propagation of data changes. The BLoC pattern omits how the data 
 store is implemented; that is up to the developer to choose according to project requirements. By 
 separating the business logic, it does not matter which infrastructure you use to build your app; other 
 parts of the app can change, and the business logic remains intact.",NA
"Implementing StreamController, Streams, Sinks, and ",NA,NA
StreamBuilder,"The 
 StreamController
  is responsible for sending data, done events, and errors on the 
 stream 
 property. The 
 StreamController
  has a 
 sink
  (input) property and a 
 stream
  (output) property. To add 
 data to the 
 stream
 , you use the 
 sink
  property, and to receive data from the 
 stream
 , you listen to the 
 stream
  events by setting up listeners. The 
 Stream
  class is asynchronous data events, and the 
 Sink 
 class allows the adding of data values to the 
 StreamController stream
  property.
  
 The following example shows how to use the 
 StreamController
  class. You use the 
 Sink
  class to add 
 data with the 
 sink
  property and the 
 Stream
  class to send data with the 
 stream
  property of the 
 StreamController
 . Note the use of the 
 get
  keyword for the 
 _addUser
  (
 Sink
 ) and the 
 user 
 (
 Stream
 ) 
 declarations. The 
 get
  keyword is called a getter, and it’s a special method that provides read and write 
 access to the object’s properties.
  
 final StreamController<String> _authController = 
 StreamController<String>(); Sink<String> get _addUser => 
 _authController.sink; 
  
 Stream<String> get user => _authController.stream;
  
 To add data to the 
 stream
  property, you use the 
 sink
  property’s 
 add(event)
  method.
  
 _addUser.add(mood);
  
 To listen to 
 stream
  events, you use the 
 listen()
  method to subscribe to the 
 stream
 . You also use 
 the 
 StreamBuilder
  widget to listen for 
 stream
  events.
  
 _authController.listen((mood) 
 {",NA
BUILDING STATE MANAGEMENT,"Before implementing state management for the client journal app that you created in Chapter 14, let’s 
 go over the overall plan and priority steps. In order of creation, you’ll create the model class, service 
 classes, utility classes, validator classes, BLoC classes, and 
 InheritedWidget
  class as a provider, and 
 finally you’ll add state management and BLoCs for all pages. You begin by modifying the main page, 
 creating the login page, modifying the home page, and creating the entry page.
  
 Note that from the UI widget pages you’ll inject the platform-specific 
 authentication.dart
  and 
 db_firestore.dart
  service classes to the BLoC class constructor. The BLoC class uses the API abstract 
 class to receive the injected platform-specific service class, making the BLoC class platform-agnostic. If 
 you were also creating a web version of the journal app, you would inject the web appro-priate 
 authentication and database service classes to the BLoC classes, and they would just work; these are 
 some the benefits of using the BLoC pattern.
  
 Table 15.1 lists the folders and pages structure for the journal app.
  
 TABLE 15.1: 
 Folders and files structure
  
 FOLDERS
  
 FILES
  
 blocs
  
 authentication_bloc.dart 
  
 authentication_bloc_provider.dart 
 home_bloc.dart 
  
 home_bloc_provider.dart 
  
 journal_edit_bloc.dart 
  
 journal_edit_bloc_provider.dart 
 login_bloc.dart
  
 classes
  
 format_dates.dart 
  
 mood_icons.dart 
  
 validators.dart
  
 models
  
 journal.dart
  
 pages
  
 edit_entry.dart 
  
 home.dart 
  
 login.dart
  
 services
  
 authentication.dart 
  
 authentication_api.dart 
  
 db_firestore.dart 
  
 db_firestore_api.dart
  
 Root folder
  
 main.dart",NA
Adding the Journal Model Class,"For the journal app, you’ll create a 
 Journal
  model class that is responsible for holding individual journal 
 entries and mapping a Cloud Firestore document to a 
 Journal
  entry. The 
 Journal
  class holds the 
 documentID
 , 
 date
 , 
 mood
 , 
 note
 , and 
 uid String
  fields. The 
 documentID
  variable stores a reference to 
 the Cloud Firestore database document unique ID. The 
 uid
  variable stores the logged-in user unique ID. 
 The 
 date
  variable is formatted as an ISO 8601 standard, for example, 2019-03-18T13:56:54.985747. The 
 mood variable stores the mood name like 
 Satisfied
 , 
 Neutral
 , and so on. The note variable stores the 
 detailed journal description for the entry.
  
 TRY IT OUT 
  
 Creating the Journal Model Class
  
 In this section, continue to edit the 
 journal
  project that you created in Chapter 14. You’ll be adding the 
 Journal
  model class.
  
 1. 
 Create a new Dart file under the 
 models
  folder. Right-click the 
 models
  folder, select New 
 ➪
  Dart 
  
 File, enter 
 journal.dart
 , and click the OK button to save.
  
 2. 
 Create the 
 Journal
  class structure.
  
 class Journal {
  
 }",NA
Adding the Service Classes,"They are called service classes because they send and receive calls to a service. The journal app has 
 two service classes to handle the Firebase Authentication and Cloud Firestore database API calls.
  
 The 
 AuthenticationService
  class implements the 
 AuthenticationApi abstract
  class. The 
 DbFirestoreService
  class implements the 
 DbApi abstract
  class. The following is a sample call to 
 the Cloud Firestore database to query records; Table 15.2 describes the details:
  
 Firestore.instance
  
  .collection(""journals"")
  
  .where('uid', isEqualTo: 
 uid)
  
  .snapshots()
  
 TABLE 15.2: 
 How to query the database
  
 CALL
  
 DESCRIPTION
  
 Firestore.instance
  
 Obtain the 
 Firestore.instance
  reference.
  
 .collection('journals')
  
 Specify the collection name.
  
 .where('uid', 
 isEqualTo: uid)
  
 The 
 where()
  method filters by the specified field.
  
 .snapshots()
  
 The 
 snapshots()
  method returns a 
 Stream
  of a 
 QuerySnapshot
  containing the record(s).
  
 Cloud Firestore supports using transactions. One of the benefits of using transactions is to group 
 multiple operations (add, update, delete) in one transaction. Another case is concurrent editing: when 
 multiple users are editing the same record, the transaction is run again, making sure the latest data is 
 used before updating. If one of the operations fails, the transaction will not do a partial update. 
 However, if the transaction is successful, all of the updates are executed.",NA
Adding the Validators Class,"The 
 Validators
  class uses the 
 StreamTransformer
  to validate whether the email is in the correct 
 format by using at least one @ sign and a period. The password validator checks for a minimum of six 
 characters entered. The 
 Validators
  class is used with the BLoC classes.
  
 The 
 StreamTransformer
  transforms a 
 Stream
  that is used to validate and process values inside a 
 Stream
 . The incoming data is a 
 Stream
 , and the outgoing data after processing is a 
 Stream
 . For 
 example, once the incoming data is processed, you can use the 
 sink.add()
  method to add data to the 
 Stream
  or use the 
 sink.addError()
  method to return a validation error. The 
 StreamTransformer. 
 fromHandlers
  constructor is used to delegate events to a given function.
  
 The following is an example that shows how to use the 
 StreamTransformer
  by using the 
 fromHan-
 dlers
  constructor to validate whether the email is in the correct format:
  
 StreamTransformer<String, String>.fromHandlers(handleData: (email, sink) 
 { if (email.contains('@') && email.contains('.')) {
  
   
  sink.add(email);
  
  } else if (email.length > 0) {
  
   
  sink.addError('Enter a valid email');
  
  } 
  
 });",NA
Adding the BLoC Pattern,"In this section, you’ll create the authentication BLoC, authentication BLoC provider, login BLoC, 
 home BLoC, home BLoC provider, journal edit BLoC, and journal edit BLoC provider. The login BLoC 
 doesn’t need a provider class because it does not rely on receiving data from other pages.
  
 I want to remind you of this important concept: BLoC classes are platform-agnostic and do not rely on 
 platform-specific packages or classes. For example, the Login page injects the platform-specific (Flutter) 
 AuthenticationService
  class to the 
 LoginBloc
  class constructor. The receiving BLoC class has the 
 abstract AuthenticationApi
  class that receives the injected 
 AuthenticationService 
 class, 
 making the BLoC class platform-agnostic.
  
 Adding the AuthenticationBloc
  
 The 
 AuthenticationBloc
  is responsible for identifying logged-in user credentials and monitoring 
 user authentication login status. When the 
 AuthenticationBloc
  is instantiated, it starts a 
 Stream-
 Controller
  listener that monitors the user’s authentication credentials, and when changes occur, the 
 listener updates the credential status by calling a 
 sink.add()
  method event. If the user is logged in, 
 the 
 sink
  events send the user 
 uid
  value, and if the user logs out, the 
 sink
  events sends a 
 null
  value, 
 meaning no user is logged in.
  
 TRY IT OUT 
  
 Creating the AuthenticationBloc
  
 In this section, continue to edit the 
 journal
  project. You’ll be adding the 
 AuthenticationBloc
  class to 
 handle calling the Firebase Authentication service to log in or log out a user.
  
 1. 
 Create a new Dart file in the 
 blocs
  folder. Right-click the 
 blocs
  folder, select New 
 ➪
  Dart File, 
  
 enter 
 authentication_bloc.dart
 , and click the OK button to save.
  
 2. 
 Import the 
 async.dart
  library and 
 authentication_api.dart
  class and create the 
  
 AuthenticationBloc
  class.
  
 import 'dart:async'; 
  
 import 
 'package:journal/services/authentication_api.dart';",NA
SUMMARY,"In this chapter, you implemented the client app’s app-wide and local-state management. You learned 
 how to implement the BLoC pattern to separate business logic from the UI pages. You created an 
 abstract
  class to define the authentication interface and the authentication service class to imple-
 ment the 
 abstract
  class. By using the 
 abstract
  class, you can impose implementation and design 
 constraints. You used the 
 abstract
  class with the BLoC class to inject at runtime the appropriate 
 platform-dependent class, resulting in the BLoC class being platform-agnostic.
  
 You implemented an 
 InheritedWidget
  class as a provider to pass 
 State
  between widgets and pages. 
 You used the 
 of()
  method to access reference to the provider. You created the 
 Journal
  model class to 
 structure the individual journal records and used the 
 fromDoc()
  method to convert and map a Cloud 
 Firestore database document to an individual 
 Journal
  entry. You created service classes to manage 
 sending and receiving the service API calls. You created the 
 AuthenticationService
  class 
 implementing the 
 AuthenticationApi abstract
  class to access the Firebase Authentication API. You 
 created the 
 DbFirestoreService
  class implementing the 
 DbApi abstract
  class to access the Cloud 
 Firestore database API.
  
 You implemented the BLoC pattern to maximize separation of the UI widgets and the business logic 
 components. You learned that the pattern exposes sinks to input data and exposes streams to output 
 data. You learned how to inject the platform-aware service classes to the BLoC’s constructor, making 
 the BLoC classes platform independent. By separating the business logic from the UI, it does not mat-ter 
 if you are using Flutter for the mobile apps, AngularDart for web apps, or any other platform. You 
 implemented the 
 StreamController
  to send data, done events, and errors on the 
 stream
  property. 
  
 You implemented the 
 Sink
  class to add data with the 
 sink
  property and the 
 Stream
  class to send 
 data with the 
 stream
  property of the 
 StreamController
 .
  
 In the next chapter, you’ll learn how to implement reactive pages to communicate with the BLoCs. You’ll 
 modify the main page to implement the app-wide state management by using the authentica-tion BLoC 
 provider. You’ll create the login page and implement the BLoC to validate the email and password, log 
 in, and create a new user account. You’ll modify the home page to implement the data-base BLoC and 
 use the 
 ListView.separated
  constructor. You’ll create the journal edit entry page and implement the 
 BLoC to create and update existing entries.",NA
16 ,NA,NA
Adding BLoCs to Firestore ,NA,NA
Client App Pages,"WHAT YOU WILL LEARN IN THIS CHAPTER
  
 ➤
 ➤
  
 ➤
 ➤
  
 ➤
 ➤
  
 How to pass app-wide state management between pages How to 
 apply local-state management in the widget tree 
  
 How to apply the 
 InheritedWidget
  as a provider to pass state 
  
  
 between widgets and pages
  
 ➤➤
  
 How to use dependency injection to inject service classes to the 
  
 BLoC classes to achieve platform independence
  
 ➤➤
  
 How to apply the 
 LoginBloc
  class to the Login page
  
 ➤➤
  
 How to apply the 
 AuthenticationBloc
  class to manage user cre-
  
 dentials for app-wide state management
  
 ➤➤
  
 How to apply the 
 HomeBloc
  class to the home page to list, add, 
  
 and 
 delete journal entries
  
 ➤➤
  
 How to apply the 
 JournalEditBloc
  to the journal edit page to add 
  
 or 
 modify an existing entry
  
 ➤➤
  
  
 How to build reactive widgets by implementing the 
 StreamBuilder 
  
 widget
  
 ➤➤
  
 How to use the 
 ListView.separated
  constructor to build a list of 
  
 journal entries with a divider line by using the 
 Divider()
  widget
 ➤➤
  
 How to use the 
 Dismissible
  widget to swipe and delete an entry
 ➤➤
  
  
 How to use the 
 Dismissible
  widget 
 confirmDismiss
  property to 
  
 prompt a delete confirmation dialog",NA
ADDING THE LOGIN PAGE,"The Login page contains a 
 TextField
  for entering the email address and a 
 TextField
  for enter-ing 
 the password by obscuring the characters for privacy. You’ll also add a button to log in the user and a 
 button to create a new user account. You’ll learn how to implement the 
 LoginBloc
  class by using the 
 StreamBuilder
  widget. You’ll learn how to use dependency injection to inject the 
 AuthenticationService()
 class to the 
 LoginBloc
  class constructor, resulting in the 
 LoginBloc 
 being platform-agnostic. See Figure 16.1 for an idea of how the final Login page will look.",NA
MODIFYING THE MAIN PAGE,"The main page is the control center responsible for monitoring app-wide state management. You’ll 
 learn how to implement the 
 AuthenticationBlocProvider
  class as the main provider to the 
 AuthenticationBloc
  class. You’ll learn how to implement the 
 HomeBlocProvider
  class as the 
 provider to the 
 HomeBloc
  class with the 
 child
  property as the 
 Home
  class and also to hold the state",NA
MODIFYING THE HOME PAGE,"The home page is responsible for showing a list of journal entries filtered by the logged-in user 
 uid
  and 
 the ability to add, modify, and delete individual entries. In this section, you’ll learn how to implement 
 the 
 AuthenticationBlocProvider
  as the provider for the 
 AuthenticationBloc
  class. You’ll learn 
 how to implement the 
 HomeBlocProvider
  class as the provider for the 
 HomeBloc
  class. You’ll learn 
 how to apply the 
 StreamBuilder
  widget to build the journal entries list by calling the 
 ListView 
 .separated
  constructor. The 
 Dismissible
  widget is used to swipe on an item to delete the entry. 
 You’ll learn how to use the 
 Dismissible
  widget 
 confirmDismiss
  property to prompt the user with a 
 delete confirmation dialog. You’ll learn how to call the 
 MoodIcons
  class to color and rotate icons 
 according to the selected mood. You’ll learn how to call the 
 FormatDates
  class to format dates.
  
 Note that I purposely didn’t inject the 
 MoodIcons
  and 
 FormatDates
  classes into the 
 HomeBloc
  and 
 EditJournalBLoc
  classes to show that you can decide not to include certain utility classes in the BLoC. 
 If you were to include them in these BLoCs, you would duplicate the 
 MoodIcons
  and 
 Format-Dates
  
 methods into two different BLoCs. In Chapter 15’s “Implementing the BLoC Pattern” sec-tion, you 
 learned in the UI design guidelines to create a BLoC for each complex enough component. Another 
 option is to create a 
 MoodAndDatesBloc
  class to handle the 
 MoodIcons
  and 
 FormatDates 
 classes (as 
 abstract classes) and use the 
 MoodAndDatesBloc
  class in both the home and edit entry pages. See 
 Figure 16.3 for an idea of how the final home page will look.
  
  
 FIGURE 16.3:
  Final home page",NA
ADDING THE EDIT JOURNAL PAGE,"The edit journal page is responsible for adding and editing a journal entry. In this section, you’ll learn 
 how to create the journal edit page that implements the 
 JournalEditBlocProvider
  as the provider 
 for the 
 JournalEditBloc
  class. You’ll learn to use the 
 StreamBuilder
  widget with the date, mood, 
 note, and Cancel and Save buttons. You’ll implement the 
 showTimePicker()
  function to present the 
 user with a calendar to choose a date. You’ll learn how to use the 
 DropdownButton()
  widget to present 
 the user with a list of selectable moods with the icon, color, description, and mood icon rota-tion. You’ll 
 use the 
 Matrix4 rotateZ()
  method to implement the mood icon rotation. You’ll use the 
 TextEditingController()
  constructor with the note 
 TextField()
  widget. You’ll learn how to call 
 the 
 MoodIcons
  class to color and rotate icons in the 
 DropdownButton DropdownMenuItem
  selection 
 list. You’ll learn how to call the 
 FormatDates
  class to format the selected date. See Figure 16.4 for the 
 look of the final edit journal page.",NA
SUMMARY,"In this chapter, you completed the journal app that you started in Chapter 14. You applied the BLoC 
 pattern to separate the UI widgets from the business logic. You implemented BLoC classes, BLoC 
 providers, service classes, utility classes, model classes, and app-wide and local-state management. You 
 passed app-wide state management between pages and local-state management in the widget tree by 
 using providers (
 InheritedWidget
 ) and BLoCs. You used dependency injection to inject service classes 
 into the BLoC classes. You learned that the benefit of using dependency injection keeps the BLoC classes 
 platform-agnostic, giving the ability to share BLoC classes between different platforms like Flutter, 
 AngularDart, or others.
  
 You applied app-wide state management by implementing the 
 AuthenticationBlocProvider
  and 
 AuthenticationBloc
  classes to the app’s main page. You used the 
 StreamBuilder
  widget to moni-
 tor the 
 _authenticationBloc.user stream
  for user credential changes. When the user credential 
 changes, the 
 StreamBuilder builder
  rebuilds and appropriately navigates the user to the login or 
 home page.
  
 You applied the 
 LoginBloc
  class to validate the user’s credentials and email and password 
 requirements. You overrided the 
 initState()
  method to initialize the 
 _loginBloc
  variable with 
 the 
 LoginBloc
  class by injecting the 
 AuthenticationService()
  class without using a provider. 
  
 Note that the reason you initialized the 
 _loginBloc
  variable from the 
 initState()
  and not the 
 didChange Dependencies()
  is because the 
 LoginBloc
  does not need a provider (
 InheritedWidget
 ).",NA
INDEX,"A
  
 abstract
  class, 414–415, 424, 427, 450 
  
 accessing 
 main()
  function, 64 
  
 actions
  property, 104 
  
 adding 
  
  
 animation to apps, 151–175 
  
  
 AppBar
  widgets, 105–107 
  
  
 authentication to client journal app, 395–403 
  
 AuthenticationBloc
  class, 432–434 
  
  
 AuthenticationBlocProvider
  class, 
  
   
 435–436 
  
  
 basic layout to client journal app, 403–406 
  
 BLoC pattern, 432–449 
  
  
 BLoCs to Firestore client app pages, 453–487 
  
 classes to client journal app, 406–408 
  
  
 Cloud Firestore database to journal app, 
  
   
 391–395 
  
  
 Cloud Firestore packages to client journal app, 
   
 395–403 
  
  
 drag and drop, 275–277 
  
  
 edit journal page, 472–484 
  
  
 Firebase to journal app, 375–410 
  
  
 Firestore to journal app, 375–410 
  
  
 HomeBloc
  class, 441–443 
  
  
 HomeBlocProvider
  class, 443–444 
  
  
 Journal
  model class, 422–424 
  
  
 JournalEditBloc
  class, 444–447 
  
  
 JournalEditBlocProvider
  class, 
  
   
 447–449 
  
  
 login page, 454–460
  
 addOrEditJournal()
  method, 338–339, 
  
   
 362–364, 368, 371, 467, 471, 472 
  
 addOrUpdateJournal()
  method, 476 
  
 ahead-of-time (AOT), 44 
  
 Android Emulator 
  
  
 setting up on Linux, 19 
  
  
 setting up on macOS, 15 
  
  
 setting up on Windows, 17 
  
 Android host platform channel, implementing, 
   
 318–321 
  
 Android Studio 
  
  
 about, 23 
  
  
 configuring editor for, 20 
  
  
 installing on Linux, 19 
  
  
 installing on macOS, 14–15 
  
  
 installing on Windows, 16–17 
  
 animatedBalloon()
  method, staggered 
  
   
 animations and, 172, 174 
  
 AnimatedBuilder
  widget, 176 
  
 AnimatedContainer
  widget 
  
  
 about, 176 
  
  
 using, 152–155 
  
 AnimatedCrossFade
  widget 
  
  
 about, 176 
  
  
 using, 155–159 
  
 animatedOpacity()
  method, 160–163 
  
 AnimatedOpacity
  widget 
  
  
 about, 176 
  
  
 using, 160–163 
  
 animation 
  
  
 adding to apps, 151–175
  
  
 LoginBloc
  class, 436–440 
  
 service classes, 424–430 
  
 state management to Firestore client app, 
  
 411–451 
  
 Validators
  class, 430–432
  
 using 
 AnimatedContainer
  widget, 152–155 
 using 
 AnimatedCrossFade
  widget, 155–159 
 using 
 AnimatedOpacity
  widget, 160–163 
 using 
 AnimationController
  class, 164–170 
 using staggered animation, 170–175
  
 489",NA
WILEY END USER LICENSE ,NA,NA
AGREEMENT ,"Go to www.wiley.com/go/eula to access 
 Wiley’s ebook EULA.",NA
