Larger Text,Smaller Text,Symbol
"Maps, Monads, Monoids, and More!","It’s all in the name: 
 Learn You a Haskell for 
 Great Good!
  is a hilarious, illustrated guide 
 to this complex functional language. Packed 
 with the author’s original artwork, pop 
 culture references, and, most impor-tantly, 
 useful example code, this book 
  
 teaches functional fundamentals in a way 
 you never thought possible. 
  
 You’ll start with the kid stuff: basic syntax, 
 recursion, types, and type classes. Then 
  
 once you’ve got the basics down, the real 
 black-belt master class begins: you’ll learn 
 to use applicative functors, monads, zippers, 
 and all the other mythical Haskell constructs 
 you’ve only read about in storybooks.
  
 As you work your way through the author’s 
 imaginative (and occasionally insane) 
  
 examples, you’ll learn to:
  
 •
  Laugh in the face of side effects as you 
 wield purely functional programming 
 techniques
  
 •
  Use the magic of Haskell’s “laziness” to 
  
 •
  Organize your programs by creating 
 your own types, type classes, and 
 modules
  
 •
  Use Haskell’s elegant input/output 
 system to share the genius of your 
 programs with the outside world
  
 Short of eating the author’s brain, you will 
 not find a better way to learn this powerful 
 language than reading 
 Learn You a Haskell 
 for Great Good!",NA
About the Author,"Miran Lipovacˇa is a computer science 
  
 student in Ljubljana, Slovenia. In addition to 
 his passion for Haskell, he enjoys boxing, 
 playing bass guitar, and, of course, drawing. 
 He has a fascination with dancing skeletons 
 and the number 71, and when he walks 
  
 through automatic doors, he 
  
 pretends that he’s actually 
  
 opening them with 
  
 his mind.
  
 play with infinite sets of data 
  
 THE FINEST IN GEEK ENTERTAINMENT
 ™
  
 www.nostarch.com
  
 $44.95 
 ($51.95 CDN)
  
 SHELVE IN:
  
 PROGRAMMING LANGUAGES/
  
 HASKELL",NA
Learn You a ,NA,NA
Haskell,NA,NA
for ,NA,NA
Great Good!,NA,NA
A Beginner’s Guide,"“I LIE FLAT.”
  
 Lipovacˇa",NA
Miran Lipovacˇa,"This book uses a lay-flat binding that won't snap shut.
  
 FSC LOGO",NA
Learn You a ,NA,NA
Haskell,NA,NA
 for ,NA,NA
Great Good!,NA,NA
A Beginner’s Guide,NA,NA
Miran Lipovacˇa,San Francisco,NA
B R I EF CONTENTS,"Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . 
  
 xv 
 Chapter 1: Starting Out . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . 
  
  
 1 
 Chapter 2: Believe the Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . 23 Chapter 3: Syntax in Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . 35 Chapter 4: Hello Recursion! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . 51 Chapter 5: Higher-Order Functions . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 Chapter 6: Modules . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 Chapter 7: Making Our Own Types 
 and Type Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .109 Chapter 8: Input and 
 Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .153 Chapter 
 9: More Input and More Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 .169 Chapter 10: Functionally Solving Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . .203 Chapter 11: Applicative Functors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . .217 Chapter 12: Monoids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .243 Chapter 13: A Fistful of Monads . . . . . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .267 Chapter 14: For a Few Monads More . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .297 Chapter 15: Zippers . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .343 Index. . . . . . . . . . . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .363",NA
C O N T E NTS IN DETAIL,"INTRODUCTION 
  
 xv
  
 So, What’s Haskell?
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 xv
  
 What You Need to Dive In
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  xvii
  
 Acknowledgments
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  xviii
  
 1
  
 STARTING OUT 
  
 1
  
 Calling Functions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 3
  
 Baby’s First Functions
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 5
  
 An Intro to Lists
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 7
  
 Concatenation
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 8
  
 Accessing List Elements
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 9
  
 Lists Inside Lists
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 9
  
 Comparing Lists
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 9
  
 More List Operations
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 10
  
 Texas Ranges
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 13
  
 I’m a List Comprehension
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 15
  
 Tuples
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 18
  
 Using Tuples
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 19
  
 Using Pairs
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 20
  
 Finding the Right Triangle
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 21
  
 2
  
 BELIEVE THE TYPE 
  
 23
  
 Explicit Type Declaration
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 24
  
 Common Haskell Types
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 25
  
 Type Variables
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 26
  
 Type Classes 101
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 27
  
 The Eq Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 28
  
 The Ord Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 28
  
 The Show Type Class
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 29
  
 The Read Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 29
  
 The Enum Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 The Bounded Type Class
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 31
  
 The Num Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 The Floating Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 32
  
 The Integral Type Class
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 33
  
 Some Final Notes on Type Classes
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 33",NA
INTRODUCTION,NA,NA
"Haskell is fun, and that’s what it’s all about!","This book is aimed at people who have experience programming in im-
 perative languages—such as C++, Java, and Python—and now want to try out 
 Haskell. But even if you don’t have any significant programming experience, 
 I’ll bet a smart person like you will be able to follow along and learn Haskell.
  
 My first reaction to Haskell was that the language was just too weird. But 
 after getting over that initial hurdle, it was smooth sailing. Even if Haskell 
 seems strange to you at first, don’t give up. Learning Haskell is almost like 
 learning to program for the first time all over again. It’s fun, and it forces you 
 to think differently.
  
 NOTE 
 If you ever get really stuck, the IRC channel
  #haskell
  on the freenode network is a 
 great place to ask questions. The people there tend to be nice, patient, and understand-ing. 
 They’re a great resource for Haskell newbies.
  
 So, What’s Haskell?
  
 Haskell is a
  purely functional
  programming language.
  
 In
  imperative
  programming languages, you give the computer a sequence 
 of tasks, which it then executes. While executing them, the computer can 
 change state. For instance, you can set the variable
  a
  to 5 and then do some 
 stuff that might change the value of
  a
 . There are also flow-control structures 
 for executing instructions several times, such as
  for
  and
  while
  loops.",NA
1 ,NA,NA
STARTING OUT,NA,NA
If you’re the horrible sort of person who doesn’t read ,NA,NA
"introductions, you might want to go back and read the ",NA,NA
"last section anyway—it explains how to use this book, ",NA,NA
as well as how to load functions with GHC.,"First, let’s start GHC’s interactive mode and call some functions, so we 
 can get a very basic feel for Haskell. Open a terminal and type
  ghci
 . You will 
 be greeted with something like this:
  
 GHCi, version 6.12.3: http://www.haskell.org/ghc/
  
 :? for help
  
 Loading package ghc-prim ... linking ... done.
  
 Loading package integer-gmp ... linking ... done.
  
 Loading package base ... linking ... done.
  
 Loading package ffi-1.0 ... linking ... done.
  
 NOTE
  
 GHCi’s default prompt is
  Prelude>
 , but we’ll be using
  ghci>
  as our prompt for the 
 ex-
  
 amples in this book. To make your prompt match the book’s, enter
  :set prompt 
 ""ghci> "" 
 into GHCi. If you don’t want to do this every time you run GHCi, create a file 
 called 
 .ghci
  in your home folder and set its contents to
  :set prompt ""ghci> ""
 .",NA
2 ,NA,NA
BELIEVE THE TYPE,NA,NA
One of Haskell’s greatest ,NA,NA
strengths is its powerful type,"is known at compile time, which leads 
  
 to safer code. If you write a program 
  
 that tries to divide a Boolean type with 
  
 a number, it won’t compile. This is 
  
 good because it’s better to catch those",NA
system.,"In Haskell, every expression’s type",NA
3 ,NA,NA
SYNTAX IN FUNCTIONS,NA,NA
"In this chapter, we’ll take a look at the syntax that en-",NA,NA
ables you to write Haskell functions in a readable and ,NA,NA
sensible manner. We’ll look at how to quickly decon-,NA,NA
"struct values, avoid big",if else,NA
" chains, and store the ",NA,NA
results of intermediate computations so that you can ,NA,NA
reuse them multiple times.,"Pattern Matching
  
 Pattern matching
  is used to specify patterns to which 
 some data should conform and to deconstruct the 
 data according to those patterns.
  
 When defining functions in Haskell, you can 
 create separate function bodies for different pat-
 terns. This leads to simple, readable code. You can 
 pattern match on pretty much any data type—",NA
4 ,NA,NA
HELLO RECURSION!,NA,NA
"In this chapter, we’ll take a look at recursion. We’ll ",NA,NA
learn why it’s important in Haskell programming and ,NA,NA
how we can find very concise and elegant solutions to ,NA,NA
problems by thinking recursively.,"Recursion is a way of defining func-
 tions in which a function is applied in-
 side its own definition. In other words, 
 the function calls itself. If you still don’t 
 know what recursion is, read this sen-
 tence. (Haha! Just kidding!) 
  
  
 Kidding aside, the strategy of a re-
 cursively defined function is to break 
 down the problem at hand into smaller 
 problems of the same kind and then
  
  
 try to solve those subproblems, breaking them down further if necessary. 
 Eventually we reach the
  base case
  (or base cases) of the problem, which can’t 
 be broken down any more and whose solutions need to be explicitly (non-
 recursively) defined by the programmer.
  
 Definitions in mathematics are often recursive. For instance, we can 
 specify the
  Fibonacci sequence
  recursively as follows: We define the first two 
 Fibonacci numbers directly by saying that
  F
 (0) = 0 and
  F
 (1) = 1, meaning",NA
5 ,NA,NA
HIGHER-ORDER FUNCTIONS,NA,NA
Haskell functions can take functions as parameters and ,NA,NA
return functions as return values. A function that does ,NA,NA
either of these things is called a,NA,NA
 higher-order function,NA,NA
.,NA,NA
Higher-order functions are a really powerful way of ,NA,NA
"solving problems and thinking about programs, and ",NA,NA
they’re indispensable when using a functional program-,NA,NA
ming language like Haskell.,"Curried Functions
  
 Every function in Haskell officially takes 
 only one parameter. But we have de-
 fined and used several functions that 
 take more than one parameter so far—
 how is that possible?
  
 Well, it’s a clever trick! All the func-
 tions we’ve used so far that accepted 
  
 multiple parameters have been
  curried 
 functions
 . A curried function is a function 
 that, instead of taking several parame-ters, 
 always takes exactly one parameter.",NA
6 ,NA,NA
MODULES,NA,NA
A Haskell,NA,NA
 module,NA,NA
 is essen-,NA,NA
tially a file that defines ,NA,NA
"some functions, types, ",NA,NA
and type classes. A Has-,NA,NA
kell,NA,NA
 program,NA,NA
 is a ,NA,NA
collection of modules.,"A module can have many func-
 tions and types defined inside it, and it
  
 exports
  some of them. This means
  
  
 that it makes them available for the outside world to see and use.
  
 Having code split up into several modules has many advantages. If a 
 module is generic enough, the functions it exports can be used in a multi-tude 
 of different programs. If your own code is separated into self-contained 
 modules that don’t rely on each other too much (we also say they are
  loosely 
 coupled
 ), you can reuse them later. Your code is more manageable when you 
 split it into several parts.
  
 The Haskell standard library is split into modules, and each of them 
 contains functions and types that are somehow related and serve some com-
 mon purpose. There are modules for manipulating lists, concurrent pro-
 gramming, dealing with complex numbers, and so on. All the functions,",NA
7 ,NA,NA
MAKING OUR OWN TYPES AND TYPE ,NA,NA
CLASSES,NA,NA
"So far, we’ve run into a lot of ",NA,NA
data types:,Bool,NA
",",Int,NA
",",Char,NA
",",Maybe,NA
", ",NA,NA
and so on. But how do we make ,NA,NA
"our own? In this chapter, you’ll ",NA,NA
learn how to create custom ,NA,NA
types and put them to work!,"Defining a New Data Type
  
  
 One way to make our own type is to use the
  data
  keyword. Let’s see how the 
 Bool
  type is defined in the standard library.
  
 data Bool = False | True
  
 Using the
  data
  keyword like this means that a new data type is being de-
 fined. The part before the equal sign denotes the type, which in this case is 
 Bool
 . The parts after the equal sign are value constructors. They specify the 
 different values that this type can have. The
  |
  is read as
  or
 . So we can read 
 this as saying that the
  Bool
  type can have a value of
  True
  or
  False
 . Note that",NA
8 ,NA,NA
INPUT AND OUTPUT,NA,NA
"In this chapter, you’re going to learn how to receive ",NA,NA
input from the keyboard and print stuff to the screen.,"But first, we’ll cover the basics of input and output (I/O):
  
 •
  
 What are I/O actions?
  
 •
  
 How do I/O actions enable us to do I/O?
  
 •
  
 When are I/O actions actually performed?
  
  
 Dealing with I/O brings up the issue of constraints on how Haskell func-
 tions can work, so we’ll look at how we get around that first.
  
 Separating the Pure from the Impure
  
 By now, you’re used to the fact that Haskell is a purely functional language. 
 Instead of giving the computer a series of steps to execute, you give it def-
 initions of what certain things are. In addition, a function isn’t allowed to 
 have
  side effects
 . A function can give us back only some result based on the 
 parameters we supplied to it. If a function is called two times with the same 
 parameters, it must return the same result.",NA
9 ,NA,NA
MORE INPUT AND MORE OUTPUT,NA,NA
Now that you understand the concepts behind Has-,NA,NA
"kell’s I/O, we can start doing fun stuff with it. In this ",NA,NA
"chapter, we’ll interact with files, make random num-",NA,NA
"bers, deal with command-line arguments, and more. ",NA,NA
Stay tuned!,"Files and Streams
  
 Armed with the knowledge about
  
 how I/O actions work, we can move 
 on to reading and writing files with 
 Haskell. But first, let’s take a look at 
 how we can use Haskell to easily 
 process streams of data. A
  stream
  is a 
 succession of pieces of data enter-ing 
 or exiting a program over time. For 
 instance, when you’re inputting 
 characters into a program via the 
 keyboard, those characters can be 
 thought of as a stream.",NA
10 ,NA,NA
FUNCTIONALLY SOLVING PROBLEMS,NA,NA
"In this chapter, we’ll look at a couple of interesting ",NA,NA
"problems, and we’ll think about how to solve them as ",NA,NA
elegantly as possible using functional programming ,NA,NA
techniques. This will give you the opportunity to flex ,NA,NA
your newly acquired Haskell muscles and practice your ,NA,NA
coding skills.,"Reverse Polish Notation Calculator
  
 Usually, when we work with algebraic expressions in school, we write them 
 in an infix manner. For instance, we write
  10 - (4 + 3) * 2
 . Addition (
 +
 ), 
 multiplication (
 *
 ), and subtraction (
 -
 ) are infix operators, just like the in-fix 
 functions in Haskell (
 + `elem`
 , and so on). As humans, we can parse this form 
 easily in our minds. The downside is that we need to use parentheses to 
 denote precedence.
  
 Another way to write algebraic expressions is to use
  reverse polish nota-
 tion
 , or
  RPN
 . In RPN, the operator comes after the numbers, rather than being 
 sandwiched between them. So, instead of writing
  4 + 3
 , we write
  4 3 +
 . But how 
 do we write expressions that contain several operators? For exam-ple, how 
 would we write an expression that adds
  4
  and
  3
  and then multiplies",NA
11 ,NA,NA
APPLICATIVE FUNCTORS,NA,NA
"Haskell’s combination of purity, higher-order func-",NA,NA
"tions, parameterized algebraic data types, and type ",NA,NA
classes makes implementing polymorphism much eas-,NA,NA
ier than in other languages. We don’t need to think ,NA,NA
"about types belonging to a big hierarchy. Instead, we ",NA,NA
consider what the types can act like and then connect ,NA,NA
them with the appropriate type classes. An,Int,NA
 can act ,NA,NA
"like a lot of things—an equatable thing, an ordered ",NA,NA
"thing, an enumerable thing, and so on.","Type classes are open, which means that we can define our own data 
 type, think about what it can act like, and connect it with the type classes 
 that define its behaviors. We can also introduce a new type class and then 
 make already existing types instances of it. Because of that, and because 
 Haskell’s type system allows us to know a lot about a function just by its type 
 declaration, we can define type classes that define very general and abstract 
 behavior.
  
 We’ve talked about type classes that define operations for seeing if two 
 things are equal and comparing two things by some ordering. Those are very 
 abstract and elegant behaviors, although we don’t think of them as very spe-
 cial, since we’ve been dealing with them for most of our lives. Chapter 7",NA
12 ,NA,NA
MONOIDS,NA,NA
This chapter features another useful and fun type ,NA,NA
class:,Monoid,NA
. This type class is for types whose values ,NA,NA
can be combined together with a binary operation. ,NA,NA
We’ll cover exactly what monoids are and what their ,NA,NA
laws state. Then we’ll take a look at some monoids in ,NA,NA
Haskell and how they can be of use.,"First, let’s take a look at the
  newtype
  keyword, because we’ll be using it a 
 lot when we delve into the wonderful world of monoids.
  
 Wrapping an Existing Type into a New Type
  
 So far, you’ve learned how to make your own alge-braic 
 data types by using the
  data
  keyword. You’ve also seen 
 how to give existing types synonyms with the
  type
  
 keyword. In this section, we’ll look at how to make new 
 types out of existing data types by using the 
 newtype
  
 keyword. We’ll also talk about why we would want to 
 do that in the first place.
  
 In Chapter 11, you saw a couple of ways for the 
 list type to be an applicative functor. One way is to 
 have
  <*>
  take every function out of the list that is its",NA
13 ,NA,NA
A FISTFUL OF MONADS,NA,NA
"When we first talked about functors in Chapter 7, you ",NA,NA
saw that they are a useful concept for values that can be ,NA,NA
"mapped over. Then, in Chapter 11, we took that con-cept ",NA,NA
"one step further with applicative functors, which allow ",NA,NA
us to view values of certain data types as values with ,NA,NA
contexts and use normal functions on those val-ues while ,NA,NA
preserving the meaning of those contexts.,"In this chapter, you’ll learn about
  monads
 , which are just beefed-up ap-
 plicative functors, much like applicative functors are beefed-up functors.
  
 Upgrading Our Applicative Functors
  
 When we started off with functors, you 
 saw that it’s possible to map functions 
 over various data types using the
  Functor 
 type class. The introduction to functors 
 had us asking the question, “When we 
 have a function of type
  a -> b
  and some 
 data type
  f a
 , how do we map that func-
  
  
 tion over the data type to end up with
  f b
 ?” You saw how to map something 
 over a
  Maybe a
 , a list
  [a]
 , an
  IO a
 , and so on. You even saw how to map a func-",NA
14 ,NA,NA
FOR A FEW MONADS MORE,NA,NA
You’ve seen how monads can be used to take values ,NA,NA
"with contexts and apply them to functions, and how ",NA,NA
using,>>=,NA
 or,do,NA
 notation allows you to focus on the ,NA,NA
"values themselves, while Haskell handles the context ",NA,NA
for you.,"clearer by letting you treat all sorts of values as 
  
 monadic ones. Further exploration of monads 
  
 will also solidify your intuition for recognizing and 
  
 working with monads.
  
 of the
  mtl
  package. (A Haskell
  package
  is a collec-tion of modules.) The
  mtl
  package 
 comes with the Haskell Platform, so you probably already have it. To check if you do,",NA
15 ,NA,NA
ZIPPERS,NA,NA
While Haskell’s purity comes with a whole bunch of ,NA,NA
"benefits, it makes us tackle some problems differently ",NA,NA
than we would in impure languages.,"Because of referential transparency, one value is as good 
 as another in Haskell if it represents the same thing. So, if we 
 have a tree full of fives (high fives, maybe?), and we want to 
 change one of them into a six, we must have some way of 
 knowing exactly which five in our tree we want to change. 
 We need to know where it is in our tree. In im-pure 
 languages, we could just note where the five is located in 
 memory and change that. But in Haskell, one five is as good 
 as another, so we can’t discriminate based on their location 
 in memory.
  
 We also can’t really
  change
  anything. When we say that 
 we “change a tree,” we actually mean that we take a tree 
 and return a new one that’s similar to the original, but 
 slightly different.
  
 One thing we can do is remember a path from the root 
 of the tree to the element that we want to change. We could 
 say, “Take this tree, go left, go right and then left",NA
I N D E X,"Symbols & Numbers
  
 &&
  (double ampersand) 
  
 as Boolean operator conjunction, 2 
  
 using with folds and lists, 78–79 
  
 '
 (apostrophe) 
  
 using with functions, 7 
  
 using with types, 149–150 
  
 *
  (asterisk) 
  
 as multiplication function, 3 
  
 using with kinds, 150 
  
 **
  (exponentiation), using with RPN func-
   
 tions, 207–208 
  
 \
  (backslash), declaring lambdas with, 71 
 `
  
 (backticks) using with functions, 4–5 
 :
  
 (colon) 
  
 as cons operator 
  
   
 bytestring version of, 200 
  
   
 using with applicatives, 238–239 
  
   
 using with lists, 8–9 
  
 using with infix constructors, 134 
  
 ::
  (double colon) 
  
 using in record syntax, 116 
  
 using with type annotations, 30, 118 
  
 using with types, 24 
  
 :k
  command, identifying kinds with, 
  
   
 150–151 
  
 $
  (function application operator), 
  
   
 80–81, 83 
  
 /
  (division), using with RPN functions, 
  
  
 207–208 
  
 /= 
 (not-equal-to) operator, 3, 28 
  
 =
  (equal) sign 
  
 using with 
 data
  keyword, 109 
  
 using with data types, 122 
  
 using with functions, 5 
  
 ==
  (double equal sign), 3 
  
 using with 
 Eq
  type class, 28 
  
 using with type instances, 139–140
  
 !!
  (double exlamation point) 
  
 in 
 Data.List
  module, 182 
  
 using with lists, 9 
  
 >
  (greater-than) operator, using with 
  
   
 lists, 9–10 
  
 >>
  function, replacing, 279 
  
 >>=
  (bind) function 
  
 in A Knight’s Quest, 292 
  
 nested use of, 280 
  
 using with functions as monads, 311 
  
 using with monads, 269–270, 272, 
  
   
 274–280, 283–284, 286 
  
 using with 
 Reader
  monad, 312 
  
 using with 
 State
  monad, 316–317 
  
 using with 
 Writer
  type, 302
  
 ->
  (arrow) 
  
 in type signature, 60–61 
  
 using with functions, 25 
  
 using with lambdas, 71
  
 -> r
  as functor and monad, 311 
  
 <
  (less-than) operator, using with lists, 9–10 
 <*>
  function 
  
 calling with applicative values, 236 
  
 left-associative, 233 
  
 specializing for 
 IO
 , 234 
  
 using with applicative style, 232 
  
 using with liftM function, 325 
  
 using with zip lists, 237 
  
 <=
  operator, using with lists, 9–10 
  
 <$>
 , using with applicative style, 231–232 
 <-
 , 
 using with I/O actions and 
  
   
 functors, 219
  
 -
  (minus) operator, using with sections, 62
  
 ()
  (parentheses) 
  
 minimizing use of, 81, 83 
  
 placement with functions, 7 
  
 using with operations, 2, 5 
  
 using with sections, 62 
  
 (,,)
  function, using with zip lists, 238",NA
The Electronic Frontier Foundation ,NA,NA
(EFF),NA,NA
 is the leading organization defending civil ,NA,NA
liberties in the digital world. We defend ,NA,NA
"free speech on the Internet, fight illegal surveillance, ",NA,NA
promote the ,NA,NA
rights of innovators to develop new digital ,NA,NA
"technologies, and work to ",NA,NA
ensure that the rights and freedoms we enjoy are ,NA,NA
enhanced — ,NA,NA
rather than eroded — as our use of technology grows.,NA,NA
PRIVACY ,NA,NA
EFF has sued telecom giant AT&T for giving the ,NA,NA
NSA unfettered access to the ,NA,NA
private communications of ,NA,NA
millions of their customers.,NA,NA
 eff.org/nsa,NA,NA
FREE SPEECH ,NA,NA
EFF’s Coders’ Rights Project is defending the ,NA,NA
rights of programmers and security ,NA,NA
researchers to publish their ,NA,NA
findings without fear of legal challenges. ,NA,NA
eff.org/freespeech,NA,NA
INNOVATION ,NA,NA
EFF's Patent Busting Project challenges ,NA,NA
overbroad patents that threaten ,NA,NA
technological innovation. ,NA,NA
eff.org/patent,NA,NA
FAIR USE ,NA,NA
EFF is fighting prohibitive standards that would take ,NA,NA
away your right to receive and use over-the-air television broadcasts ,NA,NA
any way you choose.  ,NA,NA
eff.org/IP/fairuse,NA,NA
TRANSPARENCY ,NA,NA
EFF has developed the Switzerland Network ,NA,NA
Testing Tool to give individuals the tools ,NA,NA
to test for covert traffic ,NA,NA
filtering.,NA,NA
 eff.org/transparency,NA,NA
INTERNATIONAL ,NA,NA
EFF is working to ensure that international ,NA,NA
"treaties do not restrict our free speech, ",NA,NA
privacy or digital consumer rights.,NA,NA
 ,NA,NA
eff.org/global,NA,NA
EFF is a member-supported organization. Join Now!  ,NA,NA
www.eff.org/support,NA,NA
ELOQUENT ,NA,NA
JAVASCRIPT ,"A Modern Introduction to 
 Programming
  
 by
 MARIJNHAVERBEKE
  
 Eloquent JavaScript
  is a guide to JavaScript that focuses on good programming 
 techniques rather than offering a mish-mash of cut-and-paste effects. The author 
 teaches readers how to leverage JavaScript’s grace and precision to write real, 
 browser-based applications. The book begins with the fundamentals of 
 programming—variables, control structures, functions, and data structures—then 
 moves on to more complex topics, like object-oriented programming, regular 
 expressions, and browser events. With clear examples and a focus on 
  
 elegance, 
 Eloquent JavaScript
  will have the reader fluent in the language of 
 the Web in no time.
  
 JANUARY
  2011, 224 
 PP
 ., $29.95 
  
 ISBN
  978-1-59327-282-1",NA
THE LINUX PROGRAMMING ,NA,NA
INTERFACE,"A Linux and UNIX
  
 ®
  System Programming Handbook
  
 by
 MICHAELKERRISK
  
 The Linux Programming Interface
  is the definitive guide to the Linux and UNIX 
 programming interface—the interface employed by nearly every application that 
 runs on a Linux or UNIX system. In this authoritative work, Linux programming 
 expert Michael Kerrisk provides detailed descriptions of the system calls and 
 library functions that readers need to master the craft of system programming 
 and accompanies his explanations with clear, complete example programs. 
 Extensively indexed and heavily cross-referenced, 
 The Linux Programming Inter-
 face
  is both an introductory guide for readers new to the topic of system 
 program-ming and a comprehensive reference for experienced system 
 programmers.
  
 SEPTEMBER
  2010, 1552 
 PP
 ., $99.95, 
 hardcover 
  
 ISBN
  978-1-59327-220-3",NA
LAND OF LISP ,"Learn to Program in Lisp, One 
 Game at a Time!
  
 by
 CONRADBARSKI
 , 
 M
 .
 D
 .
  
 Lisp is a uniquely powerful programming language that, despite its academic 
 reputation, is actually very practical. 
 Land of Lisp
  brings the language into the real 
 world, teaching readers Lisp by showing them how to write several com-plete 
 Lisp-based games, including a text adventure, an evolution simulation, and a robot 
 battle. While building these games, readers learn the core concepts of Lisp 
 programming, such as recursion, input/output, object-oriented program-ming, 
 and macros. And thanks to Lisp’s powerful syntax, the example code is 
  
 short and easy to understand. The book is filled with the author’s brilliant Lisp 
 cartoons, which are sure to appeal to many Lisp fans and, in the tradition of all 
 No Starch Press titles, make learning more fun.
  
 OCTOBER
  2010, 504 
 PP
 ., $49.95 
  
 ISBN
  978-1-59327-281-4",NA
THE BOOK OF ,NA,NA
CSS3 ,"A Developer’s Guide to the Future 
 of Web Design
  
 by
 PETERGASSTON
  
 CSS3 is the latest revision of cascading style sheets, the language used to define 
 the look and formatting of web documents. A still-evolving standard, CSS3 
 presents a moving target for developers who need to stay abreast of which fea-
 tures are supported by particular web browsers. 
 The Book of CSS3 
 uses real-
 world examples to teach developers the fundamentals of the CSS3 specification, 
 high-lighting the latest developments and future features while paying close 
 attention to current browser implementations. Each chapter examines a different 
 CSS3 module and teaches the reader to use exciting new features like web fonts, 
 background images, gradients, 2D and 3D transformations, animation, box effects, 
 and more. 
  
 MAY
  2011, 304 
 PP
 ., $34.95 
  
 ISBN
  978-1-59327-286-9",NA
MAP SCRIPTING 101 ,"An Example-Driven Guide to Building Interactive Maps 
 with Bing, Yahoo!, and 
  
 Google Maps
  
 by
 ADAMDUVANDER
  
 Map Scripting 101
  uses a project-based approach to teach readers how to create 
 useful and fun online map mashups like weather maps and local concert track-
 ers. Author Adam DuVander shows readers how to use Mapstraction, an open 
 source JavaScript library, to create and manipulate basic maps by setting zoom 
 levels, showing and hiding markers, geocoding addresses, customizing maps for 
 visitors based on their locales, and so on. Readers will also learn to handle 
 complex GIS (geographic information system) data and formats like KML and 
 GeoRSS, and to create graphical overlays to make sense of data and trends. This 
 book is perfect for any web developer, whether their goal is to build a map to 
 track earthquakes around the world or to simply mark the best coffee shops in 
 town.
  
 AUGUST
  2010, 376 
 PP
 ., $34.95 
  
 ISBN
  978-1-59327-271-5
  
 PHONE
 : 
  
 EMAIL
 : 
  
 800.420.7240 
 OR 
  
 SALES
 @
 NOSTARCH
 .
 COM 
 415.863.9900
  
 MONDAYTHROUGHFRIDAY
 , 9 
 A
 .
 M
 . 
 TO
  5 
 P
 .
 M
 . (
 PST
 )
  
 FAX
 : 
  
 415.863.9950 
  
 24 
 HOURSADAY
 , 
  
 7 
 DAYSAWEEK
  
 WEB
 : 
  
 WWW
 .
 NOSTARCH
 .
 COM
  
 MAIL
 :
  
 NOSTARCHPRESS 
  
 38 
 RINGOLDSTREET 
  
 SANFRANCISCO
 , 
 CA
  94103
  
 USA",NA
U P D A T E S,"Visit 
 http://www.nostarch.com/lyah.htm
  for updates, errata, and 
  
 other information.",NA
"Maps, Monads, Monoids, and More!",NA,NA
Learn You a ,NA,NA
Haskell,NA,NA
for ,NA,NA
Great Good!,"It’s all in the name: 
 Learn You a Haskell 
  
 •
  Organize your programs by creating 
  
 for Great Good!
  is a hilarious, illustrated 
  
 your own types, type classes, and 
  
 guide to this complex functional language. 
  
 modules
  
 Packed with the author’s original artwork, 
 pop culture references, and, most impor-
 tantly, useful example code, this book 
 teaches functional fundamentals in a way 
  
 •
  Use Haskell’s elegant input/output 
 system to share the genius of your 
 programs with the outside world
  
 you never thought possible. 
  
 Short of eating the author’s brain, you will 
  
 You’ll start with the kid stuff: basic 
 syntax, recursion, types, and type 
 classes. Then once you’ve got the basics 
 down, the real 
  
 not find a better way to learn this powerful 
 language than reading 
 Learn You a Haskell 
 for Great Good!
  
 black-belt master class begins: you’ll learn to 
 use applicative functors, monads, zippers,",NA
About the Author,"and all the other mythical Haskell constructs 
  
 Miran Lipovacˇa is a computer science",NA
A Beginner’s Guide,"you’ve only read about in storybooks.
  
 student in Ljubljana, Slovenia. In addition to 
  
 As you work your way through the author’s 
 imaginative (and occasionally insane) 
  
 examples, you’ll learn to:
  
 his passion for Haskell, he enjoys boxing, 
 playing bass guitar, and, of course, drawing. 
 He has a fascination with dancing skeletons 
 and the number 71, and when he walks 
  
 •
  Laugh in the face of side effects as you 
  
 through automatic doors, he
  
 wield purely functional programming 
  
 pretends that he’s actually
  
 techniques
  
 opening them with
  
 •
  Use the magic of Haskell’s “laziness” to 
  
 his mind.
  
 play with infinite sets of data 
  
 THE FINEST IN GEEK ENTERTAINMENT
 ™
  
 www.nostarch.com
  
 $44.95 
 ($51.95 CDN)
  
 SHELVE IN:
  
 PROGRAMMING LANGUAGES/
  
 HASKELL
  
  
 “I LIE FLAT.”
  
 This book uses a lay-flat binding that won't 
 snap shut.
  
 Lipovacˇa",NA
Miran Lipovacˇa,NA,NA
